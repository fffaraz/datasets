let and const also hoist, similar to var, but not like function declarations where the initialization (function value) is also hoisted. What's different about let and const is that you aren't allowed to access them until after their declarations. If you do, an error is thrown. It's their hoisting that allows this to happen. For example given: let x = 1 { console.log(x) let x = 2 } What would you expect to happen? The answer is an error is thrown. The inner version of x (value of 2) gets hoisted in it's block mean the log would access it instead of the first x declared outside of the block. And because you can't access before declaring, you get the error. This hoisted error space is known as the demilitarized zone (DMZ).
I looked and didn't find a public API. The code is here https://github.com/joeflateau/gymstreak/blob/master/index.js I'm basically performing the web login process with code to get session cookies. Then they have a JSON endpoint that returns your check-in history. None of this is documented. 
If they explained what's going on under the hood, it wouldn't be a black box. Sometimes it's better to not know how sausage is made. It's another one of the many reasons I prefer libraries over frameworks. 
That’s why explicit types make so much sense, they removes the need to write a bunch of tests around type adherence. Instead you can focus on writing tests that actually test behaviour. My experience using lodash does not match your example, granted I don’t use lodash for much. If that’s a problem that bothers you then open an issue, or opt-out of bad typings and just declare the module as any.
“Temporal Dead Zone” (TDZ)*
Lol yes thank you. Its still early ;)
I'm not against strict typing and I've seen the benefits of TS when I've used it, but I'm not convinced it is time well spent. The Lodash problem I mention is not something you can opt out of. You get a symbol that you've never imported.
Laravel has a newbies guide and automatically generated API documentation, so to go beyond the really simple stuff you need to look on stackoverflow or try to dig into the source code. Aside from the annoying stuff, some things seem really dangerous. There are methods that will change their entire behaviour (eg. pluck) in a way that might not even break your application. There's also issues like some queries returning soft-deleted records, which are flaws in the abstraction but are not planned to get fixed. These all seem like security holes to me, so maybe applications using these frameworks need to be unit tested to hell and back?
Never tell PHP developers how wrong they are. All you get are downvotes and no gratitude. It's not a community that values learning, sadly.
Or a tazer embedded in your thigh that will punish you when you miss a leg day.
That's the whole point of a framework though. The documentation they give you is going to show you how to operate the framework, not all the constituent components that make it work. The framework makes it so that you don't have to know that stuff and be more productive. If they wrote documentation on all of it, their documentation would be four times as long. 
That might be annoying, but the professor is actually teaching you a valuable skill about what it's like to work as a professional software engineer. 
Subscriptions are explained with the graphql-subscriptions library. The docs clearly show how to swap out the pub sub instance and use redis which can scale vs the in memory pub sub. As I said, they are moving fast and the docs aren’t complete. Glad I get down votes for simply saying that it’s a real project and you can find in depth help on slack. 
Aren't const and let block scope? Pretty sure only var is hoisted.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals
Both will work to create a string. The `` is used in javascript as part of the "template literal" syntax. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals 
Try running this in your console: const whatsItCalled = ‘template literals’; `The back ticks are used to denote ${whatsItCalled}, whereas the single or double quotation marks are used for strings as you have probably always traditionally used them.`
Unfortunately, most documentation concerns itself with "how to use this" and usually not with "why this is the way it is" or "how does this work under the hood". There is a reason, though: It is what most people _firstly_ reach the documentation for. What you're asking for is more generally known as _process documentation_ or _development documentation_ and it is not something that most projects actually publish, or even produce internally. Nowadays, most of such documentation follows the form of chat conversations, mailing list discussions, issue tracking, but most of the time there is no formal solidification of such things into "proper" documentation, or if there is, it is not usually made public or it is kept in a secondary place, not on the main public documentation.
Vanilla JS meaning without frameworks is my understanding. So do you consider yourself a full-stack developer then since you know node?
Great reply, and the only real way to learn. It can be hard finding an explanation by someone that just tells you how it works and answers things from an individual's perspective, as everyone is at a different point in their understanding. Maybe if you take the time to read the code you could be that expensive consultant who comes in to save the day!
 // assuming your unit of test imports { doSomething } from 'do-something'; jest.mock('do-something', () =&gt; ({ doSomething: (x, y) =&gt; { const args = [ { x: 1, y: 2, response: 20 }, { x: 5, y: 2, response: 10 }, ]; return args.find((arg) =&gt; arg.x === x &amp;&amp; arg.y === y).response; }, })); You could setup a default value and better handle args that aren't found but you get the idea.
IoC is not a dependency-only thing and certainly was not invented in Java/C#. There's nothing particularly "older way" about the pattern.
I'm sure you could get a junior position somewhere with that set of technology, but it would be a junior position and you'd be expected to progress and learn. I can't imagine *specialising* in only knowing pure JS being a useful or sensible direction to take at all. There isn't *that* much to learn about the language itself, you're going to get diminishing returns fairly quick. Pretty much every project has some place for other technology be it a library or framework. Vanilla js is a tounge and cheek comment on the tendency of JS developers to reach for libraries and frameworks *too* readily. It doesn't mean you should never use them. 
No you got that backwards. Var is hoisted but not the value being stored into it. If you want to function itself hoisted, don't use var.
I believe eslint can probably be configured to do this if you so desire. It can fix some lint issues automatically, and can likely be configured how you want it.
Everyone here is wrong and totally missing the point. If you want to function itself to be hoisted, you need to use a function declaration. Everyone here is talking about how variable declarations are hoisted and totally forgetting that we're talking about the function *values* being hoisted, not the variables! For example, try this and see what the errors are: fn1(); fn2(); fn3(); fn4(); fn5(); function fn1() {} var fn2 = function() {} const fn3 = function() {} let fn4 = function() {} let fn5 = () =&gt; {}
?
I mean, while just using pure js imports, factories and sort you can usually achieve similar results, but without the black magic, all shallow and clean.
&gt; Then I build a POC that covers those cases, usually as integration tests rather than a full application. It allows you to focus on specific problems and figure out if the framework can cope with them. We have a framework at work that wraps express/feathers for stuff like documentation generation, API versioning, etc. that I'm responsible for. For much the same reasoning as you, this is how almost the entire test surface is implemented. There are a few modules that are tested in isolation, but most of the tests are a tiny application built with the framework that does one thing and then the test actually spins up an application server, makes the request, and ensures the whole thing works. This way, when someone asks me how to achieve something, I can almost always link them directly to a test case, which is code they can drop in their project. If I can't link them to a test case, I make one, then link them to it.
Pretty sure it’s your iterator that’s the issue. Basically you’re calling your async method a bunch of times using a sync loop, which doesn’t care if your async method is finished by the time it falls it again on the next iteration.
I didn't know if I had mis-remembered the advice or if the VMs had gotten smarter. Good to know it's the latter!
Are there any methodologies to capture process/development documentation and preserve it in some useful form?
It’s not a discrimination against age. Age has nothing to do with it. My belief is that someone who has only 2.5 years of experience and only one job might not have enough datapoints to be able to mentor someone from zero to employed. That advice would be pretty biased towards that one experience.
Yeah, it just isn't necessary. GraphQL without Apollo is just fine, Apollo is this huge thing that tries to do everything and is extremely opinionated and it drives me nuts having to deal with at work. 
I think you meant the former was hoisted?
It's a design pattern that has its place, and is the best solution for some problems. 
``` ' ``` is a string ``` ` ``` is a template literal - it lets you print variables out without having to concatenate ``` let name = "gerry"; `hello ${name}`; ``` note: using ``` ` ``` usually communicates intent to do string interpolation (i.e. print variables out in the string) so if you're not printing out variables, use `'` and `"`
Yes, block scoped, but still hoisted - hoisted in any block rather than function blocks like var.
Not sure why this isn't more common in the JS world. I guess it's marginally harder to type? 
Do you know a good source where I can learn more about this?
I had a job a couple years ago where we only used jQuery. We didn't have any dedicated frontend developers though. 
You’re correct in that a cleaner impl would probably be a queue of promises. But I think all you need to do here is add an ‘await’ to the ‘doAction’ call. 
Ironically, with redux, you'll end up relying on context anyways (unless you like doing compile-time hacks for testing) The thing about context is that now that it's part of the API, they are pretty much is stuck with it. `react-router` relies on it. `react-redux` relies on it. These are not obscure libraries and lots of production code rely on them. And the whole reason facebook puts any time whatsoever on migrations for react is because they have a ton of old react code (some 30k components, last I heard) and it's not really feasible for them to just willy nilly make breaking changes in react. There are proposals for improved versions of context, but I think it's going to be take some time to get rid of the existing amount of context-related code debt.
Where I work, the main front end project is a became a framework, but it's built by the people who worked there using just 'vanilla' js, no framework used (only some library like moment, jquery i18n...) So it's possible for sure but I think learning a new framework (one of the most used like react, angular or vue) can be really really helpful, I would suggest do to that
Apollo and Meteor are the same corporate entity. They have raised lots of venture capital and don't have a clear monetization strategy. Your assessment of their consulting promotion business tactics could be accurate
I worked for five years on a proprietary web framework with heavy focus on highly interactive sub-ms precision audio/video and made a good living doing it. A lot of great challenges and I learned a ton about the language through studying the specification, open source libraries, and specifications for various web APIs (websockets, media element, web audio, etc). However, these types of positions are very rare, you need to be **extremely** proficient in EcmaScript. There's a pretty big downside in that if you need to move to a new position, most places generally want you to write "React/Angular/JSBuzzWord" on your resume in the skills section. You're at a huge disadvantage if you don't keep current on the flavor of the month. That being said, if you do land one of these positions you'll have the opportunity to familiarize yourself with the language on a level that simply isn't present in the staggering majority of devs. At my current position I'm more management than dev but we use React/Redux for a lot of projects. However, I personally still write a lot in vanilla especially if we're doing something unique in node. I wrote a server authoritative game engine recently using horizontally scalable websockets in vanilla (only packages used I believe were uWS and ioredis). 
Not specifically. Mdn might have something about it, though behaviorally, anything explaining the TDZ gets you information about this. You might not hear it referring to hoisting much since in the case of let and const you get an error. The error prevents what would otherwise be unusual behavior explained with the concept of hoisting.
It's an API, so he doesn't have full control over the calling code. 
&gt; There isn't that much to learn about the language itself, you're going to get diminishing returns fairly quick. Just want to bring up a few points on this * most devs don't hover anywhere near the full depth of the language. * a lot of the things which can be done in JS aren't JS specific (design patterns etc). * the ratio between the number of devs who use react/lodash/three/etc. to the number of devs who could write react/lodash/three/etc is pretty steep. Just from personal experience. Most devs can pick up a new framework and do useful work, but have pretty huge knowledge gaps. Some common ones limited to just JS (not specific APIs) are: regular expressions, first class functions, call/apply, promises, async patterns, general design patterns/anti-patterns, deep knowledge of how prototypal inheritance works, function composition, partial application, currying, the event loop, and type coersion.
I know many many js developers that haven't even looked at es6+ features like fat arrows, template literals, etc. and even promises! They look at me like I have two heads when I suggest they use a promise for some async task. 
Seems like you need something like https://medium.com/@the1mills/a-better-mutex-for-node-js-4b4897fd9f11
The problem is, if you do enough vanilla, you start to recognize patterns in your work, ultimately deriving some framework of your own to facilitate those patterns making it easier to do the next project. 
The idea of TDD is not limited to a single programming language. IMO the biggest win of TDD is that you're forced to think ahead of what you're going to implement. Instead of testing if already written code passes some specifications. 
Sounds useful.
If your aim is to get employed in a javascript role, learn React. You could always try something else, I'm just telling you the most effective way currently to get hired in something related to javascript.
To add on to this, it's perfectly valid to use context for specific use cases that require it. We're working on our own UI component library and using context to pass prop-like values between compositional components. This is a great way to make your components reusable while giving developers a lot of flexibility in implementation. You just shouldn't use it as a substitute for a state store.
Pretty much any provider uses context...including react-redux. You may have a use case for it if you're writing code that's going to be packaged and used elsewhere.
The library helped me in a lot of ways and that's why I published it to the world as an npm package. If you get a chance to use it and find something that could be improved, do let me know. 
What is the reason for t({}).isObject // =&gt; false I would that expect to be true.
GraphQL tutorials are all terrible for this very reason. There's the perfectly serviceable reference implementation, why not just use that?
How about... return (&lt;Child something={something}&gt;&lt;Grandchild something={something} /&gt;&lt;/Child&gt;); ?
In my books, if you reference the same string more than once it should be made into a variable. Most patterns you see make the value the same as the constant, but with more complicated sites to avoid naming conflicts, you might have more information about the action in the type name, i.e `reducer-name/action-name`.... writing that out in more than one spot seems like a recipe for disaster.
Most good dependency websites have a page dedicated to "rationale", "design principles", "concepts", or the like. Others bury it in the FAQ somewhere. Some don't have one at all. 
Can't agree more. Over the years i've known a lot of developers tha can write decent code using frameworks but when it comes to thinking into solving complex problems that involves deep knowledge of the language and knowledge of patterns and algorithms they froze. I think that every respetable developer has to learn the basics first
Its truly baffling that Angular 8 (or whatever version theyre on now) still bakes DI framework on top of TypeScript.
Thanks for the catch. That is a fault in the documentation. I'm gonna go change it now.
What is Vanilla JS anyway? Not using a precompiler, not using TypeScript or CoffeeScript? Not using React? Not using jQuery? As an employer I am of course interested in developers that now their way around the language itself, quirks and all. If the definition of Vanilla JS is to write everything yourself and not use frameworks and libraries etc, you're missing out big time. You're not standing on the shoulders of the entire community of developers creating helpful tools for you to use within frontend, backend, testing, networking, protocols, deployments etc. Frankly, it's kids of arrogant not to. I would be careful to hire a developer like that.
interesting, thanks for the in depth reply!
i like this idea, thanks!
You shouldn't use elements which force interpolation on strings that don't need it. You're wasting time calculating whether every sting has a variable in it.
I use to be like that , until last year. The whole compiler understanding thing was a pain but you are missing out. You can’t compile native apps in vanilla js also. You are holding yourself back.
Thanks for the response. I guess I'm just trying to get away from having to learn something new every year. But I take it if I'm a competent vanilla js developer learning a JS framework should be piece of cake right?
What happens when something breaks? A developer that only knows frameworks won't know how to fix this necessarily.
I keep hearing about developers that know how to use frameworks but when something breaks they don't know how to fix it cause their vanilla JS skills are horrible. To me learning the full language completely so I can fix issues like this is aiming to know more, not less.
I don’t necessarily agree that there are a lot of challenges with calling your graphql api directly. What would you consider some related challenges that Apollo helps with?
There are so many obvious use cases, like theming, providing anything really. Redux, redux-router and so on use self-made broadcasts and emitters, and lots of packages in the eco system break composition because of it (most styling libs, tree-views, etc. don't allow you to use hoc's because they try to inject props). The new api they've just released is very welcome, it will make it so much easier. 
This is exactly why I feel like specializing in vanilla js would be a good thing. Who do people call when their app is broken and they don't know why because everybody on the team just knows how to develop with frameworks?
&gt; I think that every respetable developer has to learn the basics first Serious question: why? If your work (not just job) requires you to build stuff, and that “stuff” doesn’t require a lower level understanding and you’re happy operating at that higher level of abstraction, then what benefit do you actually gain? It’s not like we will revert back to lower level abstractions, in the sense that frameworks will disappear or people writing C now are going to start writing assembly. 
The implication of this is that other frameworks have already done the hard work (and ironed out the many many bugs), so rolling your own is essentially unnecessary. What's more, you will be more employable if you know a framework or two.
There are developers who _like_ magic? In production? Wow!
I've worked on two projects that were using GraphQL without any framework or library client-side to handle it. These are the things we struggled with when compared to a REST API wrapper + a global store: - Building the query by hands is dangerous. The straightforward way to do that "properly" is to code a 20ish-line function to do serialization + interpolation, but then you're open to a whole class of injection attacks. Apollo &amp; Relay can generate functions from parametrized queries &amp; mutations that are safe and easy to use. - Handling storing/caching manually is a pain. For a query with a single root node it's easy; but once you want to cache the results of mutations or queries with multiple edges you need to write a lot of boilerplate that is hard to get right. Also, you'll need a store anyway for this (Redux/MobX/Vuex or whatever). Nowadays GraphQL clients abstract all that for you, and that significantly simplifies the code. And that's without talking about the problems that GraphQL clients solve that were already hard without GraphQL (pagination, subscriptions).
That is true, by relying on others you might not be in a position to fix the bug. Then again, you probably won't be the only one using the framework in question - if it is popular, most likely others will be involved to tackle it if you won't. It ties in to what you wish to spend time on. You don't want to spend time on creating features that others have solved long ago, that might be available in a mature and proven library. This goes especially for what I like to call *infrastructure*. The stuff you just need to work that doesn't directly give you any business value. Forms are a perfect example, without a library it takes time to hook up that stuff with proper validation, both client and server side with proper security measures in place. It just doesn't make sense to write all that code from a business perspective or a developer perspective. Example: At my company I have a few developers that LOVE to develop everything themselves. Of course they do, and I totally understand why. It's fun and it's a personal challenge. They are excellent developers, but they sometimes forget the fact that others might have solved it already, open-sourced it and been proven in the market for a while. I can almost guarantee that it will take longer to do it ourselves than to use an existing tool. Now and then we do develop our own library for a specific purpose, but you have to make a case of why the existing tools in the market doesn't fit the bill. It is very important to balance the decisions of doing it yourself and using existing tools for the job. This is what truly separates a good developer from a poor one.
Yes. I've sort of come to despise Knockout.js for that reason. I picked it over Angular specifically because of its tight scope as a provider of an MVVM layer, and when it works it's cool, but JC, if something breaks, figuring out what you did wrong is damn hard. You wonder if the value of the abstraction isn't out weighed by the cost of the obfuscation.
&gt; what benefit do you actually gain? If you understand lower level abstractions, or higher level design patterns, you have more tools at your disposal to write cleaner, clearer, and more concise code. If developer A only knows how to use jQuery, and developer B knows a slew of useful design patterns and useful language features in addition to knowing how to use jQuery, who do you think will write better code?
It'd be fun to have a Sunday Slack code review where we go line by line in Apollo.
&gt; This is exactly why I feel like specializing in vanilla js would be a good thing. The thing is: there's nothing precluding you from knowing both. I highly advocate learning vanilla JS in and out prior to learning any framework. In fact, I only hire devs who demonstrate a deep understanding of the language they'll be coding in. However, knowing vanilla doesn't mean you shouldn't *also* learn a framework. Frameworks are useful tools to have at your disposal, just like knowing the language, and knowing design patterns are useful tools. Just like writing good tests, and having a clean and clear build process are useful tools. Why not have as many tools as possible at your disposal? It just makes finding solutions easier when you're aware of all the possible solutions, and can choose the best fit for your use case. If you've built an app "within" a framework (meaning the majority of the code base is using a framework's API), then your developers who are experts with that framework are the people best suited to fix a problem with the app or implement new features. If there is a problem with the framework however, you need someone with a deeper knowledge of JS to submit a pull request to the framework to fix the issue or allow for your particular use case. TL;DR Learn both.
That isn't an argument against learning vanilla JS. It's an argument against coding your own framework. Learn JS, but also learn which frameworks can save the time and hassle of rewriting 60% of the lodash source for every project you work on.
Yeah, it's being released this week in 16.3, but you can play with it now in alpha. https://medium.com/@baphemot/whats-new-in-react-16-3-d2c9b7b6193b
I don't like this style. I prefer the way lodash does it, where it's _.isString('test') // =&gt; true Using getter styles for things that should be functions is just confusing.
Agreed. It's good to do vanilla JS to keep your basics up, but there's no need to reinvent the wheel
Worth noting that there functions beyond string interpolation, such as tagged template literals: function tag(strings, age) { return strings [0] + age + strings[1]; } const age = 10; tag`Jack is ${age} years old`; // Jack is 10 years old
I've been doing a lot of work creating browser extensions lately, and there's strong incentives not to use frameworks in that context: funny APIs, funny process model and communication model, incentives to keep things small, no backward compatibility requirements, but all that in a pretty powerful environment where you can do a lot without a lot of code.
Yep, until then the lib uses a polyfill. I'm already running the 16.3-alpha, seems great so far. Awesome article btw, i haven't had much time to get into the other stuff, very curious about the async mode.
because redefined variable text in that function scope takes precedence over outer one. its declaration gets hoisted to the top of f1() function but definition remains between console.log calls.
In that case, anyone would be able to make the same call for the endpoint, considering the fact that js source code contains the API link. Should I limit the call to a specific URL?
Looks like you've stumbled accross a great example of **[Variable Shadowing](https://stackoverflow.com/questions/11901427/an-example-of-variable-shadowing-in-javascript)**! This is feature of how lexical scope works in JS. When you re-create a variable with the same name (text) inside a function, it *shadows* the variable, meaning it creates a new variable scoped to the function and prevents access to the other var named text. Many languages wouldn't allow this... but its javascript after all (throwing no shade lol) Try changing: var text = "f1 text" to: text = "f1 text" 
All good points, but I really meant this in terms of specialising in pure JavaScript. Those are all concepts that I'd kind of expect a FE developer to have at least some grasp of. I wouldn't need a JavaScript specialist for them.
That's not a common situation at all. Sorry, but if they can't hire someone good at javascript internally, what makes you think they can hire an external expert? 
Just to be realistic here: it would help every developer to know the basics, that doesn't necessarily mean it'll help at their job though. I've seen plenty of people in the same position for years that never changed their style and the company never cared. They got the job done, that's all that mattered. I don't follow that philosophy myself, but that doesn't mean it doesn't exist. Tons of companies only care about getting the job done, not how good it actually is in the end. 
Well, you're going to be unemployed then in the long run. Frameworks exist for a reason. The help create applications faster and with less bugs than doing it from scratch. You can be versed in vanilla js all you want, but if you refuse to learn frameworks just because, then I wouldn't hire you. Most companies use frameworks, and yes they change often, but that's simply the nature of front end development right now. 
No. Learn vanilla JS, know it, and then learn frameworks so you can become more advanced and employable.
A mentor said something similar, once you think you know a language build your own framework for that language to truly understand it.
Totally agree with this. Why re-invent the wheel? If I assigned you a task and you spun your wheels for a week and came up with some vanilla-JS solution that was already a built-in component in the API of a popular framework I would seriously question your skills as a developer. 70% of being a career developer is delivering quality code in a timely matter. It's always a balancing act of rolling your own and reaching for an off the shelf solution. Do people overuse dependencies? Yes, all the time. However you are never going to impress anyone in an interview with your crazy vanilla JS wizardry. Save these skills for a hobby. 
 &gt; '#' + (Math.random() * 0xffffff | 0).toString(16).padStart(6, '0') "#05b8d0"
What does vanilla mean?
Hey everyone, I should clarify exactly what my question is. Why is it that I can set main scope **text** variable from within the function but I cannot read it unless I also set it after reading it?
On call of t() all the boolean values are evaluated. On the contrary I think its pretty read-able that the end part contains the test without the input.
I disagree. A framework is something far more concrete (and defined) than patterns of preferred coding behavior. The inability to tell the difference indicates someone who has trouble seeing the forest for the trees.
The composition point makes a lot of sense. I've used it for a &lt;Form&gt; implementation for validation for that very reason... I still try and avoid it since it makes things harder to reason about, so I only want to use it in very black-boxy situations like that. Really curious to lean how the new context api helps with that
Assuming you control the code, not really, but you would need to export anyway... otherwise you couldn’t call that method from your promise.
All your front end code is available to read, and any extra code can be run simply by opening a console. It makes absolutely no difference if you use a named or anonymous function. A better question is, why are you concerned about this in the first place? Do you have some critical piece of security that can easily be broken by simulating the success function? 
Yes, it picks a random value inside the RGB cube. There are 0xffffff colors and I just randomly pick one of them. Using HSL is often a better idea, though. It gives you control over the saturation and lightness ranges.
Because when that stuff you write (or other code you have to pull in) breaks, you’ll have a much better chance of being able to solve the problem efficiently and effectively if you know what’s going on. 
There's a link to the code from the help and game over screens, but here it is for anyone who missed it: https://github.com/nullobject/tetris
I doubt the OP meant "safe" as "secure against attacks"
This is generally why I still think jQuery belongs in many places, not because of `$()` but because of browser compatibility.
I found a bug. When you press up it never lands. Rotation is incorrect. Otherwise a good tetris. My tetris in Vanilla Js is here: https://mystikkogames.itch.io/jstetrix
What you're suggesting (allowing the developer to request decoding before the response is available) can certainly work, but it's quite clear why it was implemented this way from the perspective of the API implementor. The implementors wanted to provide the simplest API that would cover all use cases a developer might have. Imagine that you're implementing fetch(). You know that, based on how HTTP and the underlying TCP operate, the conceptual "response" (the status and headers) and the "response body" are two separate things, and in fact, will arrive at different times. The response also contains information about what the body looks like, so what you can do with the response body depends on what is in the response. Knowing this, you want developers to be able to receive the response first, analyze it, and proceed accordingly. Thinking about it this way, having fetch() return a promise that will resolve with just the response makes sense. From there, developers can check the status and headers to determine what to do with the body, and then use one of the other promise-based APIs on the response object to get the body. This is a very logical API that covers all possible use cases. Implementing a "shortcut" that combines the response promise with body promise is not very valuable given that going straight from the response to the body is already very easy. Implementing a shortcut would make it so that there are two ways to get the response body, and the API is no longer as simple despite not actually adding functionality that wasn't there before.
Cool, thanks. I'll be sure to fix it.
While it's not necessarily going to help you understand in depth, I've always found it helpful to think of asynchronous functions as functions that will take an unknowable amount of time to execute. So in order to not block other functions from running while you wait, the runtime promises to execute the function you supply as a callback "sometime later" when it has finished and usually supplies the result as an argument to your callback. So for example with fetch, you're telling the browser you want to get some data from some API. The browser has no idea how long that's going to take. So you supply a callback through the then method that the browser promises to call when your API call finished. Because this could potentially take seconds, the browser can put that callback aside so other work can continue. Under the hood it's more complicated than that. A good starting place would be to look at how the event loop works in the browser and node.
And by refusing to use frameworks, you won't have a job~!
It has nothing to do with reading and writing, but about your `var` declarations. Look at the articles provided by @spicy_ice_cream.
That wasn't pushed as a best practice, but it was unfortunately how it was described in the documentation for brevity. This led to a bad culture of using static facades (which are indeed just service locators), but that's really a function of the newer developers using Laravel who really didn't understand why DI is better. Regarding AR, I've never had a problem fully normalizing a database. In fact I've been able to bolt Eloquent onto an existing DB of ~315 or so tables that were all fully normalized. Eloquent worked with very, very little effort, and the queries it uses are very efficient. In cases where an ORM doesn't make sense, Eloquent transitions to lower level query builder seamlessly. From there it's easy to encapsulate all of the AR and QB queries behind domain-facing repositories and domain queries. Meanwhile return values can adhere to simple contracts so that the rest of the domain doesn't touch or depend on any of the AR behavior from the entities. 
Back in my day we used: Object.prototype.toString.call(thing); But seriously consider defining getters for each value, instead of calculating all of them: function t(thing) { return { get isString() { return Object.prototype.toString.call(thing).slice(8, -1) == 'String'; } }; } Which i would again have written as: Object.defineProperties(obj, { isString: { get: function() { /* ... */ }, set: function() { throw new Error("readonly"); } } });
I've been meaning to finish the demo for a while, and your comment prompted me to do it: https://jasonday.github.io/printThis/ Thanks
1. Pick random number from 0 to 1, say 0.618 2. Multiply this number with the “maximum” color (#ffffff = 0xffffff = 256*256*256 = 16 777 216 = “white”), so you’ll get 10368319,488 3. Floor it - get rid of the number after floating point. 4. Convert it to hexadecimal base 5. If it has less than 6 characters, put zeroes in front 6. Put “#” in front of it
Well, [here's a PR for #1](https://github.com/joeflateau/gymstreak/pull/1). 
Agreed. There really is no security difference in having success code sitting in the "success area" (promise?) vs in a module. The code is accessible for anybody who wants to read it or hijack-able for anybody who wants to hijack it. Your best efforts in security here is to read up on XSS attacks and keep any malicious foreign code outside of your user's browser space and make sure that you don't have any code in your front end code base that you don't want exposed to the user.
Look up variable hoisting.
Everybody else in this thread would disagree apparently O.o
Learning vanilla is fine. But I hope you are not using this as an excuse to learn no frameworks. If you do a job with vanilla, this will hurt the customer if the next guy who needs to maintain it doesn’t understand what you did. The nice thing about frameworks like React it takes a lot more effort to really screw up a project. But with vanilla anything is possible. No offense, but is is extremely unlikely you have the skill to produce maintainable vanilla js. Very few people do and those who do tend to write open source frameworks. 
Nice! Very encouraging, thanks!
Use this if you hate magic DI https://medium.com/@pyrolistical/factory-functions-pattern-in-depth-356d14801c91
I hate that there is a framework called [Vanilla JS](http://vanilla-js.com/) because I never know if someone is talking about that, or as in "plain old regular javascript".
Falls inline with my theory that 99% of the people you come across in this field have opinions based on nothing but other people's opinions.
Learn more vanilla JavaScript first but then once you're good with that and you know ES6 and stuff, move onto a framework or library. I suggest starting with Vue, it's the easiest to learn out of the 3 main ones and it's quite nice to use. I suggest learning Vue from a free tutorial series by Jeffrey Way at: http://vuecasts.com/
Yes, this seems to be an obvious problem that you can notice from the source code. No offense to the author, but this is fairly shitty library right now: Input: ``` var t = require('typy') var stringType = t('hello') console.log('stringType.isString', stringType.isString) var numberType = t(123) console.log('numberType.isNumber', numberType.isNumber) // Original types are broken. console.log('stringType.isString', stringType.isString) console.log('stringType.isNumber', stringType.isNumber) ``` Output: ``` stringType.isString true numberType.isNumber true stringType.isString false stringType.isNumber true ```
Awesome, thanks for the suggestion!
How was it meant? &gt; ...does that leave me vulnerable to someone learning how to call the function itself and bypass my fetch request[?] It sure sounds like OP is concerned about misuse of this code.
I haven't, but I want to. (This is unrelated to my point though as postgraphql is for the server. I was talking about GraphQL clients like Apollo and Relay.)
You’re also the author of Mithril.js and that framework is poetry. 
&gt; our best efforts in security here is to read up on XSS I did mean secure against attacks, and these responses cleared it up for me. I was unsure if creating a separate method made it easier for potential attacks, as opposed to leaving it in my promise (I thought maybe an attacker might have a harder time figuring out how to run that snippet of code than he/she would if he just called the function). Although, they would probably have an easier time running the code if it's in a named function, it seems that it doesn't really matter which I choose because ultimately all code that requires any security is handled on my server so them getting the success message doesn't really change anything. Thanks for taking the time to answer 
Don't know about you but it's something it doesn't usually happen to me. Even if it did, is not still better having great readability in any filesize even if at the cost of one small probable "silly" 3 lines?
Thanks, didn't know about the auto-fix. It AFAIK it'll only align assignments and properties, that's more than I expected though. Still, the opinionated like Prettier and community, in general, seem to like reading hieroglyphics.
**Both** the key and its value are perfectly align in the second example. It's like reading a spreadsheet.
You can vote down my comment all you like; it doesn't make you right. Instead, you could merely argument your point.
Knowing JS well is important - although at times the messiness of the browser can sort of 'get in the way' of learning JavaScript. Yes - not everything you can do with JavaScript is browser centric - but usually at some point, most people when learning something want to see something other than console output. Nothing wrong with that. If it wasn't for jQuery back in the day, I don't think I woulda had the patience to take JavaScript seriously. It dealt with cross-browser annoyances / etc (and also querySelectorAll wasn't a thing back then) so I could focus on the 'getting my job' done aspect. So - pick the tools that let you learn JavaScript well - if you are more comfortable going the purist route - no problem. If you are more comfortable using something like React, Vue, Angular, etc so you can start building stuff as a learning tool - no problem. Knowing "Just JavaScript" well will let you jump into existing projects easier regardless of what frameworks the are using or not. Something about the term "Vanilla JS" recently is really starting to bug me, and think it's starting to lose a bit of meaning. 
"get employed", yes, maybe - but as a junior. And you will have to learn whatever your employer uses, which is going to be either an inhouse framework, one of the Big Two (react / ng), something a bit more left field like Polymer or a gaming framework, or worst case scenario, a weird, obsolete framework associated with a CMS like ExtJS or whatever they use on AEM. "progress in your career" - no change. It's simply not enough. You need knowledge of at least a framework. As simple as that. Of course, you could find one of the 0.1% employers who really builds stuff with vanilla js and only vanilla js, but don't build your career on that assumptions.
See a comment above, apparently your package is broken.
The coolest thing about tagged literals is that they don't have to do anything like normal interpolation and don't even have to return strings. My HTML templating library, lit-html ( https://polymer.github.io/lit-html/ ), uses tagged template literals to return template strings and values separately so they can update existing DOM: let hello = (name) =&gt; html`&lt;h1&gt;Hello ${name}`; render(hello('World'), document.body); render(hello('Reddit'), document.body); The graphql-tag ( https://github.com/apollographql/graphql-tag )library uses them to produce GQL queries: const query = gql`{ user(id: 5) { firstName lastName } }`; Tagged template literals are amazing for being able to embed DSLs and process them at the same time. And because the tag has to be attached to the literal, editors and syntax highlighters can key off them to offer intellisense on the inline language.
Thanks for this! 
&gt; What happens when something breaks? If it's something like React, JQuery, Angular, tens if not hundreds of devs will volunteer and release a fix. What happens when something breaks in your own, homebaked framework? How many people are willing and able to fix it?
If you are using jQuery is not vanilla. 
Wow, thank you so much! Very helpful.
&gt; to get good at JS you have to write your own libraries and frameworrks anyway says who?
if you follow DRY principles, there's no way to get around writing re-usable functions. Whether its a official library or a group of functions, youre going to write them.
Thanks :)
There is a huge difference between "re-usable functions" and something like Angular. Are you going to reinvent every single wheel needed to put together a modern SPA?
https://www.youtube.com/watch?v=8aGhZQkoFbQ Great video that visualizes the inner workings of Javscript.
OK, so the variable declarations are effectively pulled to the beginning of the function no matter where they are written?
Thanks for the catch. I somehow missed secluding the state from each call. An issue has been opened and now closed in the GitHub. This is fixed now. =)
fine go ahead and keep depending on frameworks and spend half the time resolving conflicting dependencies. ill be flying by you with my vanilla JS custom libraries that are just a git clone away
Even if you completely ignore frameworks/libraries, that doesn't stop you from having to learn new things every year. Browser APIs are always changing/evolving. The language itself is evolving faster than ever.
Thanks for the catch. It's fixed now =)
I wanted to adopt 'chai' library's BDD style of syntax to get the result. But I'm intrigued now. Having both the styles wouldn't be a bad thing.
I prefer ['is-explicit'](https://www.npmjs.com/package/is-explicit) For four reasons: 1) The syntax allows you to check any type and is less verbose 2) It returns a boolean, not an object 3) You can check multiple types at once 2) I wrote it, and I'm a megalomaniac
Wow, thanks for the words of wisdom. I understand I'll always have new things to learn as JS evolves and what not I just want to keep it to a minimum as much as possible.
The job post isn't the interview.
Note that Math.round(Math.random()*17) means that a number from 0 to 17 will be rounded: 1 to 16 will be overrepresented, while 0 and 17 will be only half as represented as you want.
What environment?
Definitely. I wouldn't really hire a "javascript specialist". A good dev should know all of the above, but should also put in the time to learn the relevant frameworks. It's just pretty tough to find/hire those people.
Is this what you're looking for? https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback
It's going to be any computer really, but I wanna do it on my Mac ( but my group members also have Microsoft laptops ). I just wanna see my options on the environment part so it could be really anything. I hope I answered your question. 
Hmm sounds promising. Do you have any experience with this ? 
So what would you add?
Think of async programming as an office full of people planning for a party. There are several tasks to complete: 1. Send invites 2. Arrange catering 3. Buy party supplies You could assign one person to do these items in sequence. Or, you could assign 1 person to each task and have them execute in parallel. Now here's the kicker. Either way, all 3 tasks must be complete before the party can actually start. In scenario one (1 person handling all 3 tasks) you have to wait for however long it takes for that person to accomplish the series of tasks in order. In scenario 2, each person can accomplish a task on his own time and the overall wait is far less time. Still, each person has to report back to a single person of responsibility and that single person controls when the party is ready to start. This is async programming. Whether you use callbacks, promises, or async/await (syntactic sugar on top of the promise paradigm), all of these are examples of individuals handling one task independently of the overall purpose. Now let's look at an example of setting up the party using some callback code, shall we? var tasksCompleted = 0; function sendInvites(callback) { // ... callback(); } function arrangeCatering(callback) { // ... callback(); } function buySupplies(callback) { // ... callback(); } function throwParty() { sendInvites(function() { tasksCompleted++; }) arrangeCatering(function() { tasksCompleted++; }) buySupplies(function() { tasksCompleted++; }) (function waitForTasks() { setTimeout(function() { if (tasksCompleted &lt; 3) { return waitForTasks(); } else { // let's get the party started! } }, 1000); })(); } The `throwParty` function is the top level party planner. He delegates the individual tasks and waits for all 3 tasks to be complete before actually starting the party. The throwParty function uses `setTimeout` to wait for these tasks to complete asynchronously. It may well be some seconds, hours, or days before `tasksCompleted === 3`. Meanwhile, other code can continue to execute while the `setTimeout` loop executes.
And holy shit, the fact I can do backend all in JS with node makes it even more awesome. KISS agreed! Did you ever code any vanilla JS for Node? 
Working on my first professional project, by myself, have had minor anxiety attacks about this a few times a day every day for the past week ... hahaha ...
Node, yeah, I like it. If for vanilla you mean not using transpilers and extensions, yeah, only a couple of times I have "required" to use babel, I still have to try TS or flow. For the use cases I have seen, I have never felt like standard ES5/6 with a couple of battle tested libs was falling short. Disclaimer: again, this is only for the things I have seen, I don't doubt there are teams out there that require a big complicated setup / dependency tree.
Async javascript is more like synchronous scheduled javascript, with the exception of web workers. The browser javascript core can do things in separate threads, like web requests, and can run a callback when that is done. Node.JS has similar mechanisms for the `fs` module. To understand this, javascript is really an event loop that runs segments of code in a synchronous and ordered fashion. For example, let's look at this: ``` setTimeout(function () { console.log('In timeout'); }, 0); console.log('Not in timeout #1'); console.log('Not in timeout #2'); console.log('Not in timeout #3'); ``` The output in the console will be: &gt; Not in timeout #1 &gt; Not in timeout #2 &gt; Not in timeout #3 &gt; In timeout You'd expect that `'In timeout'` would output immediately, but it won't, because it's been scheduled to run in 0 milliseconds, but it has to wait for the next available time to be scheduled. You could add even more _immediate/synchonous_ code after those console.log calls and it would all execute before `'In timeout'` is output. Execution blocks are determined mostly by scoping (ie function calls), but various browsers may have other intelligent ways to determine breaks. `fs.readFile` does the same logic. Behind the scenes, when you call `fs.readFile(handleOrPath, options, callback);`, NodeJS asynchonously access that file, and reads in all the contents. When it's done doing that (which could be almost immediately, depending on file size), it schedules `callback` to be called with either an error object (which could be null) and the contents (which might be null if there was an error). One important thing to note is that code executed by scheduling (ie timeout, interval, etc.) cannot return to synchronous code. For instance, you could not do this: ``` setTimeout(function () { console.log('Timeout called'); }, 1000); runAfterTimeout(); // Runs immediately ``` To make this work as expected, you'd have to: ``` setTimeout(function () { console.log('Timeout called'); runAfterTimeout(); }, 1000); ``` Using callbacks is great, but depending on if you need to chain multiple asynchronous calls together, you may end up with deeply nested code inside a bunch of inline functions ("Callback hell"). On top of this, if you want to handle errors, you may have a lot of try/catch blocks and if statements, and it can get messy. To lessen this, some smart people dug up an old pattern called `Promise`s. A `Promise` is a way to chain a series of values asynchonously. A promise either resolves or rejects. A `resolve`means it was successful, and can carry a value, and a `reject` means something went wrong (sometimes via a thrown exception, other times forcibly by the developer). Promises are powerful because they simplify the control flow of asynchronous code. For instance, before promises, your `fs.readFile` would go like this: ``` fs.readFile(path.resolve('./someFile.txt', { encoding: 'utf-8' }, function (err, text) { if (err) { console.error('Could not read file', err); } doSomethingWithText(text); }); ``` With promises: ``` var readFile = new Promise(function (resolve, reject) { fs.readFile(path.resolve('./someFile.txt', { encoding: 'utc-8' }, function (err, text) { if (err) return reject(err); resolve(text); }); }); readFile .then(function (text) { console.log(text); }) .catch(function (err) { console.error(err); }); ``` Promises will always return more promises, too, and you can form a big chain. For instance: ``` var initialPromise = new Promise(function (resolve, reject) { resolve('Hello'); }); initialPromise .then(function (str) { // str = 'Hello' from initialPromise return [str, 'world'] }) .then(function (parts) { // parts = ['Hello', 'world'] return parts.join(', ') }) .then(function (combined) { // combined = 'Hello, world' console.log(combined); }); ``` Promises are also scheduled, so think of them like our first `setTimeout` example. That means every time you call `.then(callback)` on a promise, it is stuck waiting until the previous promise is resolved. If the previous promise rejects, you'll need a `.catch(callback)` to handle that. `fetch` uses `Promise`s to manage the asynchronous nature of requests, and as a means to handle program control. The general way that fetch works looks like: ``` fetch(url, { options }); // returns a Promise that either resolves a response, or rejects a network error ``` Typically, you'd have something like: ``` fetch('/restful/call.json') .then(function (response) { if (response.status &gt;= 200 &amp;&amp; response.status &lt; 400) { return response.json(); // Parse the body of the response as json, and pass that along the promise. } throw new Error('Network status ' + response.status.toString()); // Each .then is automatically wrapped in try/catch, so this forces a reject }) .then(function (json) { console.log('Data:', json); }) .catch(function (err) { console.log('Network error:', err); }); ``` If there is an exception/error to catch, the promise chain skips all the next `.then(callback)` calls and finds the next closest `.catch(callback)`. Async/await also uses promises and generators. I'm not going to get into generators, because I think they'll confuse you, but the short summary is they are special functions that returns a series of items. When you create an async function, behind the scenes, javascript knows that the return value is actually going to be a promise. The `await` keyword is a way to specify that there are multiple promises being chained together. For instance, these functions are essentially the same: ``` function doThingWithPromises () { return fetch('/resource.json'); .then(function (res) { return res.json() }) .then(function (json) { console.log('data: ', json) }) .catch(function (err) { console.error(err); }); } async function doThingWithAwait () { try { var response = await fetch('/resource.json'); console.log('data: ', response.json()); } catch (err) { console.error(err); } } ``` In bigger promise chains with more logic, async/await can be a real winner over straight-up promises, **but** keep in mind that async/await is just a little sugar on top of promises. I hope that clarifies a bit of the mysteries of what's happening. Feel free to ask any questions if I wasn't clear on something.
There's only 24 hours in a day though and I'm trying not to be a jack of all trades; king of none
This is one of the fastest most refreshing websites I've seen in awhile. 
Shows up on a lot of clickbait sites too. Here's the full source to the window, at least as far as Dev Tools shows me: https://gist.github.com/anonymous/bc172f2641132c571909717ff9180e11 (I was going to paste the code here, but it's 21k, which is longer than the 10k limit Reddit lets me post). Anyone figure out what it's actually doing?
why there is NO front hair ?
If you have the time, read the async chapter of you don't know js. It's free.
Here's a basic non-programming explanation of synchronous vs asynchronous operations. Suppose Alice wants to make a cake, but she's out of eggs. She's not allowed to get eggs, but she can get Bob to bring some to her. Alice is also very forgetful; if she starts doing something new, she forgets what she was doing before. **Synchronous egg fetch:** Alice tells Bob to get her some eggs. While Bob is gone, Alice stands around doing absolutely nothing so she doesn't forget that she's going to bake a cake. Once Bob returns he gives the eggs to Alice and she resumes baking the cake. **Asynchronous egg fetch:** Alice tells Bob to get her some eggs and gives him the cake recipe. While Bob is gone, Alice goes to do other tasks. Once Bob returns he gives the eggs and recipe to Alice, who reads the instructions and resumes baking the cake. When you call an async Node function like `fs.writeFile` you need to pass a piece of the code (the callback function) so that when the operation is done it can run the code to continue the task. You might be wondering why Bob needs to give Alice the recipe. Can't she just remember where she was in the cake-baking process herself? This is essentially what `async`/`await` does; it lets a function pause in the middle of execution while a long operation is happening, and then pick up where it left off once the operation is done.
Can you please tell what horrible in that.
ha haa haa
Ya, These are some basic questions, If you can suggest some good questions, I will grateful to you. 
A getter means you don't have to precalculate the value. It's about optimization. The syntax ends up being the same.
This should be published somewhere less ephemeral than reddit. Please link back when you do.
Yea, their algorithms was one of the best part of it. Really challenging and good head scratcher.
I'll guess I'll just have to accept I'm in the minority on this :\
I used to at my last job. I had a job running tests on the current sight. At runtime it would inject my code and it would take over styles and functionality based on a cookie that was dropped by the analytics platform. Then I could report data back to the analytics software and record our findings. Then the feature would be rebuilt "properly" after it came back with a positive influence on the public. Point is, I wrote a LOT of vanilla javascript. I got into the nitty gritty of the language and learned so much about it.
I am a C programmer and in C there's no gazillion frameworks and standards forcing you to write a particular style. And somehow C-programmers get the job done without frameworks??? In JavaScript there's gazillion bloated frameworks doing very simple stuff you can do with just small libraries.
Wow, looks great! But I'm not sure I love the "standard library" name.
Here's a great talk that I highly recommend: https://www.youtube.com/watch?v=L-fx2xXSVso
&gt;minify your js files online Oh wait till you learn about Webpack. Nice learning project though.
I also found a major bug, it's not playable on mobile :-)
Thanks, I will check it out.
Okay you need to bring proofs and numbers on your arguments. For the slowness I have read some article so I can believe it. For browser compatibility, my personal experience says otherway. I'm a hard user of Firefox for personal browsing and every website I browsed with Firefox that use web components worked cleanly. I won't argue about Internet Explorer, anyways no one is using it. Looking in Polymer's doc they have polyfills and use feature detection to make it work on every browser. The fact that youtube has a shit UI is your opinion and I disagree, that's just another discussion than my problem. If you have tested and can recommend an alternative to Polymer, I'll take your feedback :)
really love your website style, It's so clean and delightful
Not my thing but I can see this being useful. Nice work.
Thx!
I'm talking about constants for action types; i.e you have a file where you declare constants (e.g. LOGOUT) and you import those in your reducers. It's not uncommon for action types to affect multiple reducers (as in the LOGOUT case, where most reducers have to reset to default state), and in this case you'll want to be using constants to refer to the action type, for several reasons: 1) One source of truth for action type names, helps to avoid misspellings or otherwise introducing variation into your types 2) No naming conflicts + easy to rename action types 3) Easy to search for uses of the action type throughout your reducers 
Like i wrote above, [check out contextual](https://github.com/drcmda/react-contextual) and click through some of these examples, especially the ones for multiple providers (theming and time). It is quite useful. I think context will have a major impact on the react eco system. 
Does that also work for a text file online?
Thank you, so I'll need to write something that downloads and stores it first? 
Yeah, that's true. I'm using 'axios' for requests.
I'm going to look that up, thanks! 
It's always better to specify things to be 100% clear than spendind a time to discuss not related stuff. Just the question was a bit weird. I mean, there is no point to learn only vanilla js and don't try any libraries/frameworks. I can think only about a very-junior or even internship level of work. Or some specific project where they can't (or don't want to) use any frameworks because of some reason. But in the second case it means they will have to implement the same features and it's better to know how they are working in existing frameworks. 
or maybe your opinion is just dogshit
What you use to declare variable in JavaScript ?
Nah! It's not unethical in my eyes. Just make sure that when the students leave their feedback they should have the option to opt out from you using their comments.
This didn't exist yet?
Mmm. I don't see why you don't have a single function that handles either a single ingredient or a list. Also, it doesn't handle plurals or alternate spelling (colour/color). Vaguely useful as a proof of concept, but that's it.
Comic sans in the logo, you are a true visionary
Your example DB migration to Eloquent probably started in a denormalized form. Fully normalized is 6NF - each table essentially a key/value store, like Hadoop.
/r/titlegore
Not comic sans, mixture of two fonts.
JSBin or JS Fiddle. 
I prefer `()=&gt;` over `_=&gt;`, if only because of `(()=&gt;{}).length` vs. `(_=&gt;{}).length`.
Thanks for the comment, @Boris-B
what specifically were you unhappy about?
memory leaks what?
Why do you have pure JSON data in JS files? ([e. g.](https://github.com/hmontazeri/is-vegan/blob/ee42f94c748e6a889c77f8919f2c0018171d61ab/src/util/canbevegan.js)) Why have the unpretty list in your repository as well as the processed ones? ([e. g.](https://github.com/hmontazeri/is-vegan/blob/ee42f94c748e6a889c77f8919f2c0018171d61ab/src/util/unprettylist.json)) Why don't you just return [here](https://github.com/hmontazeri/is-vegan/blob/ee42f94c748e6a889c77f8919f2c0018171d61ab/src/modules/IsVegan.js#L13) instead of making an explicit `return true/false`? Why not use `for...of` to iterate over the supplied parameters [here](https://github.com/hmontazeri/is-vegan/blob/ee42f94c748e6a889c77f8919f2c0018171d61ab/src/modules/IsVegan.js#L29) so that iterables are also supported? Why do you have two functions if you could just have one default export which checks the parameter for iterable/non-iterable and performs the correct operation based on that?
Well, if you know jupyter notebook, it's quite efficient : you can have your course content in the same page as the demo code and it also leaves room for your student to run their own code. This is pretty neat when working with the newcomers. Debuggers are... for people who have a little more experience. I am definitely introducing them to this but not teaching them with it. 
# TSTL (TypeScript Standard Template Library) - https://github.com/samchon/tstl I'm a programmer taking algorithms and optimizations. I prefer to implement prototype and demonstrate with TS (React) first, and optimize it to C++ second. TSTL is a migration project from C++ STL to TypeScript-STL, for myself, for convenience on such migrations. Anyway, TSTL supports most of C++ STL features. With TSTL, you can enjoy the STL's own specific containers, algorithms and functors in the JavaScript. If TypeScript, you also can take advantage of type restrictions and generic programming with the TypeScript. ### Containers - **Linear Containers** - [Vector `vector`](http://samchon.github.io/tstl/api/classes/std.vector.html) - [Deque `deque`](http://samchon.github.io/tstl/api/classes/std.deque.html) - [List `list`](http://samchon.github.io/tstl/api/classes/std.list.html) - [ForwardList `forward_list`](http://samchon.github.io/tstl/api/classes/std.forwardlist.html) - **Associative Containers** - *Tree-structured Containers* - [TreeSet `set`](http://samchon.github.io/tstl/api/classes/std.treeset.html) - [TreeMultiSet `multiset`](http://samchon.github.io/tstl/api/classes/std.treemultiset.html) - [TreeMap `map`](http://samchon.github.io/tstl/api/classes/std.treemap.html) - [TreeMultiMap `multimap`](http://samchon.github.io/tstl/api/classes/std.treemultimap.html) - *Hash-buckets based Container* - [HashSet `unordered_set`](http://samchon.github.io/tstl/api/classes/std.hashset.html) - [HashMultiSet `unordered_multiset`](http://samchon.github.io/tstl/api/classes/std.hashmultiset.html) - [HashMap `unordered_map`](http://samchon.github.io/tstl/api/classes/std.hashmap.html) - [HashMultiMap `unordered_multimap`](http://samchon.github.io/tstl/api/classes/std.hashmultimap.html) - **Adaptor Containers** - [Queue `queue`](http://samchon.github.io/tstl/api/classes/std.queue.html) - [Stack `stack`](http://samchon.github.io/tstl/api/classes/std.stack.html) - [PriorityQueue `priority_queue`](http://samchon.github.io/tstl/api/classes/std.priorityqueue.html) ### Algorithms - [`&lt;algorithm&gt;`](http://www.cplusplus.com/reference/algorithm/) - [iterations](https://github.com/samchon/tstl/tree/master/src/std/algorithms/iterations.ts) - [modifiers](https://github.com/samchon/tstl/tree/master/src/std/algorithms/modifiers.ts) - [partition](https://github.com/samchon/tstl/tree/master/src/std/algorithms/partition.ts) - [sorting](https://github.com/samchon/tstl/tree/master/src/std/algorithms/sorting.ts) - [binary search](https://github.com/samchon/tstl/tree/master/src/std/algorithms/binary_search.ts) - [union set](https://github.com/samchon/tstl/tree/master/src/std/algorithms/union_set.ts) - [heap](https://github.com/samchon/tstl/tree/master/src/std/algorithms/heap.ts) - [mathmatics](https://github.com/samchon/tstl/tree/master/src/std/algorithms/mathmatics.ts) ### Functors - [`&lt;exception&gt;`](http://www.cplusplus.com/reference/exception/) - [Exception `exception`](http://samchon.github.io/tstl/api/classes/std.exception.html) - [LogicError `logic_error`](http://samchon.github.io/tstl/api/classes/std.logicerror.html) - [RuntimeError `runtime_error`](http://samchon.github.io/tstl/api/classes/std.runtimeerror.html) - [`&lt;functional&gt;`](http://www.cplusplus.com/reference/functional/) - [IComparable](http://samchon.github.io/tstl/api/interfaces/std.icomparable.html) - [`&lt;utility&gt;`](http://www.cplusplus.com/reference/utility/) - [Pair `pair`](http://samchon.github.io/tstl/api/classes/std.pair.html) - [Entry `entry`](http://samchon.github.io/tstl/api/classes/std.entry.html) - [`&lt;thread&gt;`](https://github.com/samchon/tstl/tree/master/src/std/thread.ts) - [ConditionVariable `condition_variable`](http://samchon.github.io/tstl/api/classes/std.conditionvariable.html) - [Mutex `mutex`](http://samchon.github.io/tstl/api/classes/std.mutex.html) &amp; [TimedMutex `timed_mutex`](http://samchon.github.io/tstl/api/classes/std.timedmutex.html) - [SharedMutex `shared_mutex`](http://samchon.github.io/tstl/api/classes/std.sharedmutex.html) &amp; [SharedTimeMutex `shared_timed_mutex`](http://samchon.github.io/tstl/api/classes/std.sharedtimedmutex.html) - (experiments) [Semaphore `semaphore`](http://samchon.github.io/tstl/api/classes/std.experiments.semaphore.html) &amp; [TimedSemaphore `timed_semaphore`](http://samchon.github.io/tstl/api/classes/std.experiments.timedsemaphore.html) 
Correct. One small note, better not import the entire lodash and use the underscore variable. Import just the functions required and use them directly. With the help of something like https://github.com/lodash/babel-plugin-lodash you will be saving precious bundle size.
&gt; Like I showed in this response, either you don't use the diff tools correctly or I don't understand your point. The latter, I think. You seem to have missed the bit I marked as "the most important [part of my post] by far", the part that said "In other people's projects follow their coding standards". In a someone else's project it doesn't matter what tool I prefer to use and how well I know how to use it, there is far more than me in the picture. While I can encourage other people to change their processes I can't resonably enforce what I think is the better way to work (including what I think is the better way to format code) unless it is a project that I have at least so authority in. I refrain from taking the "you don't know how to X properly" tack as that would break the second part of my point: not being a dick about it. Not all diff tools normaise whitespace in their comparisons (particularly if you are working on a legacy project that uses a legacy tool chain you have neither the time, nor the inclination the spend time if you had it, to refactor), most do not by default because in some cirumstances the whitespace can be significant, and many people leave this default alone because accidentally leaving the setting inthe non-default state could result in missing differences where that are significant later. &gt; Like I showed in this response You say that as if I'd read your post and ignored it when making my point. If you check the timestamps I did just blindly post without reading the rest of the thread: your post came in about seven hours *after* mine that you are replying to here.
Hey man, often when I build a personal project my philosophy is 'better done than perfect'. You can always go back and rewrite your code as you continue learning. I'm sure OP would appreciate feedback and some of the valid points you give, but doing it this way make you look like a complete douchbag 
What were your reasons for not using them?
Hack together a react app that does most of the green-light of the real app in a few weekends, and talk about that. It's hard to dismiss time saving / organizational / modern bag of goodies once it's in your face in the exact context your company has been dealing with daily.
You sound like an asshole. Next time you offer critique, start with a broader assessment of the project. Does this code do what it’s supposed to do? Does it accomplish this in an interesting or unique way? Is it effective? Then get drill into the details. Otherwise, it sounds like you’re dismissing the entire project because of some minor flaws. 
You‘re being an asshole. Next time you offer critique, start with a broader assessment of the project. Does this code do what it’s supposed to do? Does it accomplish this in an interesting or unique way? Is it effective? Then get drill into the details. Otherwise, it sounds like you’re dismissing the entire project because of some minor flaws.
TL;DR - Don't forget Chrome (and probably Firefox) has a memory profiler, and you can use it to do "heap comparisons." Want to figure out what's *causing* the differences, or if they're improtant? Well... You'll have to figure that out on your own.
Of course `() =&gt; {}`. They are semantically different, not only syntactically. One has 1 argument and the other one has 0.
Thank you for your input. The topic of memory leaks is so vast that any article can not please everyone’s request. That is why I named it toddlers guide and not a beginners guide. A toddler doesn’t need to know real world applications of standing, she just needs to learn how to stand. 
This is great, but still not that easy. All apps eat memory with use, so how do you actually know when it's a leak? Most of us don't know the difference in consumption between normal and leaking. There just isn't enough info / guides to know. And this article doesn't help much with it.
I just use the brackets all the time for consistency and clarity... () =&gt; {} (arg1) =&gt; {}
const or let
_ is an argument, it is the same as i =&gt;
What about TypeScript?
Whilst this is really good feedback, it would be better received if it was less direct, for example: ``` You could store [this data](https://github.com/hmontazeri/is-vegan/blob/ee42f94c748e6a889c77f8919f2c0018171d61ab/src/util/canbevegan.js) in a json file and import it directly. You can return [this statement](https://github.com/hmontazeri/is-vegan/blob/ee42f94c748e6a889c77f8919f2c0018171d61ab/src/modules/IsVegan.js#L13) rather than using it in a if statment. eg: ` return !blackList.includes(ingredientToCheck.trim().toLowerCase()); ` ```
I like the ending prop syntax as well - its easier to read. 
Nice one, although I kinda feel like a new library like this would have been a good chance to use a Promise-based API for stuff like `fs.readFile` instead of using the same callback-based API that node uses.
lol, you must really depend on frameworks
Thanks man, I posted this on stackoverflow and find an easy solution using only promises :) https://stackoverflow.com/questions/48608505/how-to-avoid-this-race-condition
Yeah, the await doesn't work but queueing promises is the solution: https://stackoverflow.com/questions/48608505/how-to-avoid-this-race-condition
`() =&gt;` would be preferred, I think. If you're super into using `_`, I have seen it used to deemphasize arguments in a method which would look like ` ``` function someMethod(_, value) { //do something with value but not _ } ```
Im not familiar with Jupyter, but taking a quick glance at their site, it would seem to be a trivial task to do something in straight HTML for JavaScript. A simple textarea with a button linked to an `eval` gets you 90% of the way there. Are you basically looking for something like MDN is doing? Ex: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
Thanks everyone for their inputs! It sounds like building a prototype / demo of some sorts is the way to go. In addition to Eric Elliott's articles, many JS articles I shared in my company gets feedbacks with hints of protest too. Eric's articles gets the extreme end of reactions. But thanks for everyone's feedback! Really appreciate that.
I know, without a shred of doubt, that you have never coded professionally or in a team; for this reason I can't take you seriously, and I wish you'd take yourself a lot less seriously too. It's absolutely common sense that there is an extreme amount of value to be had by utilizing the entire ecosystem (hint: you are not smarter than the collective open source community) instead of recreating your own (shitty copy). 
Some of the entries in the blacklist are questionably non-vegan. Acetate, for instance? I've never heard of animal-sourced acetate.
So many snowflakes...
That isn’t beating around the bush. It’s about offering constructive, instead of dismissive criticism. That’s not exclusive to English or western norms. 
You can use filter to select the long names. It basically becomes $('.name').filter(...).hide() http://api.jquery.com/filter/
It was not feeling better than debugger in term of interrupting the flow of the course. But console being console, I might switch back to it.
Sorry, requirements were implied behind the text... Non interruption of the flow of the course, not friendly to new comers, ability to write your code on top of the demo code with a simple dialog that can be prepopulated
&gt; doctoring my words only to convince some people I'm calm or happy feels fake and I rather not do it. I see your point, but the risk you take is that you associate yourself in peoples minds with others who are similarly direct in their thought-&gt;words-&gt;keyboard processing, and they *are* emotionally and often irrationally driven in their responses. Communication is the art of spreading information, preferably correct information. If the choice of words, however honest, gives the wrong impression then I would argue that the communication has, in part, failed because other parties come away with a false interpretation of your state and/or intent. With the preponderance of emotionally driven unfiltered responders on the Internet that may risk unintentionally stoking a mini flame war.
Thanks ! I found out about Jupyter this morning. I am gonna have a look at Kajero though. It seems to be what I'd want...
Hi, Thanks for the feedback. I'm still working on the list.
Thought about it, might actually go with it at some point if am not satisfied with the rest of the course. The lacking function would be autosave to file but we can't have it all right ? :)
yes, I work there, but no worries, I appreciate your feedback. We work hard on improving/updating the design at the moment, so all your suggestions have turned up just at the right moment.
What so $('.name').filter(length &gt;5).hide() ?
I think let is used by Es6 or Ecmascript 2015 is not yet supported by all browsers
Not just semantically wrong, it's functionally wrong too. const a = () =&gt; {} console.log(a.length) // 0 const b = _ =&gt; {} console.log(b.length) // 1 This matters for things like curry or decorator implementations.
This is essentially `_.get`, but it would be great to have it baked into the language.
The important aspect - from my point of view - is shareability and thus being able to reproduce results. In addition, accounts allow to keep implementations and review them later on again. 
&gt; if everyone has agreed on that let a = 1 is "better" than let a=1 &gt; I just wonder why it's not as obvious with vertical alignment. I don't know. It could be that spacing around assignment and (in)equality operators is local to the operator, so changes to alter the spacing are similarly localised, where changes to maintain alignment can have much wider effects. Also code alignment can sometimes be used to make other problems like long, perhaps multi-statement, lines or otherwise overly dense code, less detrimental to readability. In these cases the alignment is a code smell that highlights the source problem and fixing that it the better solution. Once people associate alignment with being a smell in some (many?) places they may react to it even where it actually helps rather than being a band-aid over another formatting issue. &gt; This reminds me one little bit from a Douglas Crockford talk, he said, among other examples, something like: "it took us one generation to realize goto wasn't a good idea". Remembering of course that goto can sometimes be the right tool (for readability), though these circumstances are very rare and the construction lends itself to being used to produce difficult-to-follow code. It is like the base two rules of optimisation: * Basic rule of optimisation: *don't* * Advanced rule of optimisation: don't, *yet* For goto it is: * When to use goto (basic): Never * When to use goto (advanced): Never, unless it really will produce something that is easier to follow/maintain I'd also argue that it didn't take a generation to realise it was a force for bad far more often than it was useful. If you look at early papers on programming and early CPU instruction sets, higher-level constructs were desired pretty much from the start and basic support (via JSR/RTS or equivalent instructions) was present early too, but it took a while for the tools (hardware in terms memory for stack frames and such, techniques for avoiding needing a stack and optimising compilers after that) to catch up, then it took a while to convert those who started out using goto as it was pretty much all they had. Some have the impression that higher-level constructs are younger than they really are because they initially learned on 8-bit home micros using BASIC, and many implementations in that family neglected to include even GOSUB let alone anything more powerful even though other constructs had been available elsewhere for some time. BBC BASIC was a notable exception, at least in its later iterations, as it supported named procedures &amp; functions as well as GOSUB {&lt;number&gt;|&lt;label&gt;}. But I'm rambling here and have strayed *far* off-topic...
I like to use _ when the function has more than one argument and one is unused on body of function: arr.map((x, _, xs) =&gt; ...) or [5,4,3,2,1,0].map((_, i) =&gt; i)
Yea were talking about the same thing. The point of constants are as you've mentioned. If one needs to be shared one could always export it. I just find things easier to follow if everything is in one file for a given slice of the state
This is not a "to each his own" sort of situation. You wrote a sprawling article that was short on actual information (apart from some interesting sections of code). You also end it suddenly and abruptly. Most of the article is basically an introduction, and then you end the article just after the part that actually starts addressing the information.
$('.name').each(function() { if ($(this).text().length &gt; 5) $(this).hide(); }); Done it thank you
Hi /u/eashish93, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_).
Next up: use Travis CI to automatically republish a static version of the site to Github-pages every time you push new life commits to your Github repository. 
Hi /u/mckenziedave, For javascript help, please visit /r/LearnJavascript. Thank you!
'_' as parameter is usually used for callbacks which have that parameter, but you aren't using it. E.g.: &gt; Array.from({length: 5}, (_, i) =&gt; 2 ** i) (5) [1, 2, 4, 8, 16]
Thanks for your recommendation!
ehhh I know what you mean, but don't lose sleep over it. Newbies can paste terrible "working" code and that might be worse than pasting something that doesn't even run without syntax errors. The dev community is great and there's no shortage of resources / people to get help from. I don't think we need to be too hand-holdy. You can spend the rest of your life getting angry at artlcles 😜
That’s great!
y tho
I’m building an a nice app for that.. so thought would be nice to open source the checker... 
https://stackoverflow.com/questions/14446447/how-to-read-a-local-text-file
spam
He did. He posted 4 links to tutorials/lessons. 
I don't think that way of others. I read their words and that's it. This is text, we have to be honest, it's very easy to misinterpret anyone's tone here, in the chats etc. I understood this since IRC. I never let a conversation get serious with close friends or family. If it's the case, I pick up the phone and we talk and in 5 seconds we've just settled the misunderstanding. So if someone here, no matter how honest or correct or civil I am, no matter what my point is... if they are more interested in what they think my tone is or they lose focus of the discussion because I'm not dropping enough smilies or I'm not faking enough happy feels and flowers... They are most likely not worth my time.
You should know about 1. Variable hoisting 2. Closures - How do JavaScript closures work? (https://stackoverflow.com/questions/111102/how-do-javascript-closures-work) 3. Prototypes and Inheritance - Inheritance and the prototype chain (https://developer.mozilla.org/bm/docs/Web/JavaScript/Inheritance_and_the_prototype_chain) 4. Promises - Promise (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) 5. Function currying 6. How this keyword works - How does the "this" keyword work? (https://stackoverflow.com/questions/3127429/how-does-the-this-keyword-work) 7. Event delegations - Bubbling and capturing (https://javascript.info/bubbling-and-capturing) 8. CORS - Cross-Origin Resource Sharing (CORS) (https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) 9. Scopes 10. ES6 Features 11. Event propagation 12. Strict keyword in JS 13. Functional programming This list is not in any order. 
Thanks for this! I'll view some of them and offer some feedback.
[removed]
And the performance sucks!
That’s part of it, yes. The declaration of a `var` is hoisted to the top of function scope. The assignment stays where it is, which is why you get `undefined` in that one case. The other part is that functions create a new scope which inherits from the parent scope, and any variables declared with the same name as a variable in an outer scope will be shadowed, and therefore inaccessible to the inner scope.
&gt; Remembering of course that goto can sometimes be the right tool I'd love an example
this is awesome
Thanks for the PR, merged.
the length comparison has to be in a function (I didn't type it out before because I was on my phone). It would be: $('.name') .filter(function(){ return $(this).text().length &gt; 5 }) .hide() 
https://github.com/hmontazeri/is-vegan/blob/master/src/util/nonvegan.json#L592 ಠ_ಠ
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [hmontazeri/is-vegan/.../**nonvegan.json#L592** (master → 7a2aaa3)](https://github.com/hmontazeri/is-vegan/blob/7a2aaa318b92c2550f7ef195d8e3202afdf5a8aa/src/util/nonvegan.json#L592) ---- 
I dont have a blog or anything. Feel free to share elsewhere. 
Will be happy to hear any feedback you might have - always looking to improve!
You could save to local storage in the background as they work in the document, and then, when the user needs to do anything with the file (like email it or whatever), you can have a button to save via save dialog. You could also have it save changes to a server somewhere automatically, but that gets a little more complicated. 
yeap and because i was come from Java development world, so typescript was useful
Run it for a while. If it keeps going, you ain't got enough of a leak to worry about.
See the `(i)` at the end of the function? Those parentheses are invoking the function, and passing `i` as an argument, which the function receives as the parameter `j`. The inner function is.... eh... *technically* a closure, I suppose, in the sense that it's a function object and uses a non-local variable. But it's a useless closure. In fact, it's a useless function in general. That line of code could have just been this: thePost[i]['id'] = uniqueID + i; Ultimately this is a poor example of closures.
Thank you so much for your help! Definitely something they'd ask me during my interview this week.
I'm not sure why they used that as an example of a closure. Do you have a better example that they might ask during an interview? Also, thanks for the help. I appreciate it.
Good luck with your interview!
Is it asking you to write code on your phone? Because that's definitely one of my least favorite things to do.
It is made by an animal...
I think the issue is not so much what's old, but that there isn't really much of a process to prevent the language from getting too complicated over time. We're already starting to see different dialects of JS (OOP-ish style in typed crowds, FP in stream crowds, ES5 in the minimalist crowds, etc) and we're still seeing more and more things getting pushed through the TC39 proposals pipeline. But unlike C++, where all the language complexity goes through several optimization passes during compilation, with JS the browser vendors have to ship all the JIT complexity and load all of it into memory. If there's no end to the increase in language complexity, eventually - even with web assembly - we'll be at a point where just starting the runtime will be so noticeably battery-intensive that it'll no longer be a viable alternative to native mobile code.
It's just a convention that I picked up somewhere. If I'm not using one of the required params in a method then it's easy for me to see at a glance that it is not be used. An example would be if I were to use JQuery's $.each method and I didn't care about the index arg in the callback method but I did care about the value arg.
Sorry but watching youtube/whatever videos about programming is distracting and anti-learning. The only way to learn is to code by yourself.
Knowing vanilla JS requires knowing those things and despite what a lot in the industry will admit, those ARE the basics (well, with the exception of knowing when to trade one request for multiple requests and vice-versa). but then again i'm salty explaining to my boss how to use the Chrome profiler and DOM inspector for the 50th time so I'm harsh on the field at large. 
I personally will sometimes use the `_=&gt;` form just to avoid parenthese overload. For example, if I'm writing an IIFE: (() =&gt; { // ... })() vs (_ =&gt; { // ... })() The latter seems less noisy to me. But I recognize this probably isn't standard practice, and I'd give in easily if someone on my team fought me on it.
lol, show me some of your code? ill show you what im getting paid to work on right now https://imgur.com/a/6DVlg usually people who talk like you have no portfolio or any real experience. so go on then, prove me wrong. 
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/Ob1wLjo.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dts3ogf) 
In what language or framework did you make the app in? Native, React native, other?
what am I supposed to take away from that picture? https://puu.sh/zhhAY/b91ce2a408.png
673 contributions in a year!? AND for opensource? XD
Could you name a few features that gained popularity through babel, but were thrown out? I'm genuinely curious. IMHO if many people use &amp; like a stage 1 feature, it will go forward. 
seems better left to libraries to be honest. this seems like a poor fit for a language feature.
Ah yes, you are absolutely correct. Thanks for the correction.
There's no isolation benefit, but it's a great away to keep track of what globals you are dealing for future maintenance/modularization, as I said, a nice api. ;)
The big closure trap is functions in loops, and this happens a lot with event listeners getting added in loops. Are you comfortable with the behavior of this code (know what, if anything is wrong, and what would fix what is... if anything)? var buttons = document.getElementsByTagName('button'); for (var i = 0; i &lt; buttons.length; i++) { buttons[i].addEventListener('click', function (event) { alert('You clicked ' + buttons[i].textContent); }); }
Let's assume that our whole JavaScript worker's world is : const stack = [] const queue = [] Now, each time you *do* something, the worker usually adds it to the `stack`, saying "I need to resolve this!". The `stack` is `synchronous`: The worker runs down all of the items in the `stack` one after enough, just like `fs.writeFileSync` returns a value immediately. Each time you add something to the `queue` however, you are saying "I need to resolve this, but once the stack is empty!". The `queue` is `asynchronous`: The worker runs down the list at some point in the future, not right now, just like `fetch` resolves into a value at some point in the future. Now let's start adding things to the `stack` and `queue`: let a = 'a' That looks synchronous! It goes in the `stack` const fetch = cb =&gt; setTimeout(cb(null, 'a'), 100) fetch((err, data) =&gt; a = data) Well now, what's this `setTimout` thing doing here? It sounds like we are wanting to tell our worker "At a future date, this happens", which means it goes into the queue! const fn = () =&gt; 'a' a = fn() Looks synchronous! Into the `stack` const writeFile = (...args) =&gt; fs.writeFile(...args) writeFile('my file data', 'file.txt', (err, data) =&gt; a = data) This one is confusing but since we can look at the node docs and see that `fs.writeFile` is `asynchronous`, this gets added to the `queue` as well. Now, after our worker has looked through the file and added things to the stack or queue, its world looks something like: stack === [ 'assign "a" to a', 'assign fn() to a'] queue === ['fetch with cb', 'writefile with cb'] Which means that the worker would first assign `a` the value of `'a'`, and then the value of calling `fn()`, even though that the assigning of `a = fn()` happens *lower down the file* than `fetch(cb)`. Now, how does our worker know when things are ready to be taken off the `queue`? Well, `setTimeout` takes care of that abstraction and you should look into `processImmediate`/`nextTick` and the other ways that `node` offers us to add things to the `queue` and how it decides when to take them off. With `Promises` or `async/await`, it is similar to how a `callback` function or `fs.readFile` works: fs.readFile(path, 'utf8', (err, data) =&gt; { // This function here is called at some point in the future // when `fs.readFile` tells `node` to take it off the queue }) And a Promise would look like: const prom = new Promise(res =&gt; { // This function inside of `Promise()` // will not be resolved until the NEXT tick regardless // if you immediately did `res('a')` // Just by creating a Promise, you've pushed the // resolution to at least the next tick setTimeout(() =&gt; { // This function inside of `setTimeout` that does the // actual resolving of the promise happens at least // 100ms after the worker sees it. res('a') }, 100) }) prom.then(data =&gt; console.log(data) /* logged in ~ 100ms */)
This will change my life. I legitimately only install lodash for `_.get`.
Tell that to C#
Hey, that's a good idea.
`_.get`'s default is close, but it does not handle `null`, only `undefined` values. var obj = { a: null }; _.get(obj, 'a', true) null
What? So you don't read books or watch videos, you literally just type code and then say "oh wow, look at me, I just used an ES6 proxy even though I've never used one before, I've never seen how to use one, and I don't know what one is"? 
What are `&lt; &gt;`?
TIL and I stand corrected. Thanks. However, I actually think it’s useful to only fall back to default on undefined - I'm not too well-versed in those quirks so there’s probably a catch, but null should definitely be considered a valid value. I use nulls very often, and I wish we had `_.get` behaviour natively.
They are called angle brackets, also I've heard HTML brackets before. I'm sure we've all also heard `{}` referred to as "curly braces" or "curly brackets", that might be a bit regional too. After looking into this more, it looks like `()` technically do fit into the "brackets" category in a written-language context, but is not a suitable term for computer science because we have more specific rules. https://en.wikipedia.org/wiki/Bracket#Computing
Thanks for sharing.
Yeah that's a tough one. I think it's definitely circumstantial. Sometimes you might want the `null` and sometimes you might not. It's making assumptions as to what values mean. But you see similar behavior in other places in the language too, like loops. There's a number of ways to loop over collections and it seems like each one does something differently. Not to try to pass that off as an excuse ;)
Are you missing something? If `data` was undefined, the error would have happened on `data.length`.
Been subbed to you for a while now, keep it up. Plan on following your build native node apps with golang, been wanting to try golang for a while so your videos are a perfect opportunity to code along to
Hi all! I've been using [Hyper](https://hyper.is) for a couple of weeks now because how it's easy to customize through plugins and themes and decided to write my first NPM package and JavaScript project, I'm an engineer student who is only comfortable enough writing in Python and perhaps C++. I then wrote a cryptocurrency information status line for the hyper terminal. Since I'm not familiar with the language and css I looked for some hyper status line plugins from which I could learn. You'll find that most of the styling and react's element structure is done based on [this status line plugin](https://github.com/henrikdahl/hyper-statusline). I mainly wrote this to get familiar with the notion of **states** and to learn how to interact with REST APIs, before writing this I had no idea how those worked at all, I'm thankful to the well written docs. Turned out I learned a lot of npm packages handling workflow and git to make it easily available for installation in Hyper. Since it's just a small index.js file, if some of you would provide me valuable feedback on the code I'd be grateful, I'm probably missing a lot of good practice styling patterns and I'm looking forward to use my free time to improve the css styling and code itself.
&gt; features that gained popularity through babel, but were thrown out I don't think there's any example of that, specifically yet, but sprinkling non-standard stuff in your code can definitely cause problems, for example when migrating to typescript. There have been proposals with a reasonable amount of hype that got dropped, most notoriously Object.observe, cancellable promises and SIMD. There are also examples of active proposals that haven't really made much headway. For example, the pipeline operator proposal has been around since 2015, it's not even that complex, but it's still at stage 1. If you want a bigger example of technology death, there's ES4, which had many of the same features as ES6 and even a working implementation, but ultimately got killed due to politics.
thanks for your support :)
Just like anything else videos can be a great source of information, but hands on experience by using the info in your own context is what really seems to make you master the explained concepts, in my opinion
thank you! &lt;3
Pretty fun. I noticed all generated messages are going to your analytics... just a little creepy.
You're getting data back, but it looks like its not the data you're expecting. This is beyond promises. log or inspect `data[0]` in a debug session and see what you're getting there.
Monkey see, monkey do is the literal foundation of learning.
Yes, in js land _ brings to mind lodash/underscore before anything else, and also who needs lodash anymore?
Originally I was using the body-parser and express-busboy libs to make the request object easier to work with. They helped quite a bit in the beginning, but earlier today I discovered busboy significantly truncates the body if it gets too large. I removed busboy, and now I'm only using body-parser. This is my first time dealing with busboy alone, so I'm not sure how to convert this structure.
Use https://github.com/facebookincubator/idx instead.
How do you deal with negativity in the JS world? 
crocodile mouths
&gt; possibly to make up for the lack of "Vous/Sie/..." English has an equivalent of Vous/Sie - it's called "You". What English no longer has is an equivalent of tu/du. If you're going to try and do a /r/iamverysmart you should at least be accurate.
por que no los dos?
/r/iamverysmart what?? I think it's just you trying to be a pedant.
I made the argument that "dismissive" was just one person's interpretation of _someone else's_ choice of language. When giving feedback about code. Which doesn't prevent me from being dismissive here. When having an argument about what comments are acceptable on /r/javascript. Two different people, and two different situations. You got both wrong. You are dismissed
Is this or the above stage 1 features available to use in non-ejected create react apps?
Nice
You can put the CSS portion in the CSS section and the JS portion in the JS section of codepen, that'll make more sense to people. This is somewhat subjective, but I'd recommend getting used to putting semicolons at the end of statements when appropriate: automatic semicolon insertion is automatic *error correction* - better to write proper JS yourself. You'll surprise yourself less. https://github.com/airbnb/javascript#semicolons I'd also suggest using *const* rather than *let* - use *const* by default, and only use *let* when you realize later that you need to reassign the variable. Again, you'll surprise yourself less. In your compare function, it would be more concise to simply return the difference between a.count and b.count.
That was a great intro to what GraphQL is, thanks :-)
Hi Senocular, The app has advanced JavaScript contents which are asked mostly in interviews.
After reading this case study (link below) I think I'll only use frameworks if I really need too. For example, I know with payments at least, I'd definitely use Stripe library vs just doing it myself. https://www.smashingmagazine.com/2017/05/why-no-framework/ With that said, anything worth doing is going to take time. The barrier to entry is bigger so there are fewer people attempting it. If you can learn React in two days, I can only imagine the overwhelming supply of React devs in the marketplace.
Just tried moving the folder, and that fixed it. Moving it back to the same name, made it break again????
Are you saying the code is already there, written for you?
hey Tim...I wanted to say thanks for doing all this. I haven't been following along 100% on your tutorials (mostly because they are too advanced for me) but now looking back at some of the earlier stuff you posted, they are making more sense! This is really good stuff man.
I prefer Mocha. Ava is pretty sweet, if your tests can be run in parallel. I mostly write node / backend code, though. I suspect jest might be more useful for something like react. Chai is an assertion library, not a testing framework. Useful, though.
Yes... It has code with explanation for key concepts. You can give it a try :)
On mobile, the 4th column heading says "anal" which gave me a chuckle. This is why automated testing can't replace humans until they develop a sense of humor, then god help us all
Heya! stdlib here. Yeah, we are aware that the website currently has broken links. :( We are, however, working on this. If you have any other feedback, let us know!
Should have looked at the CSS, too. 
Not much to go on here, but sounds like it could be a good PubSub situation, no? 
I think you should giver [this](https://youtu.be/PhUb7y9WZGs) video a watch. It doesn’t compare Ruby and Node.js directly but I think it properly addresses your question. 
I'm not sure how I feel about [this](https://github.com/facebookincubator/idx/blob/master/packages/idx/src/idx.js#L58-L69).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [facebookincubator/idx/.../**idx.js#L58-L69** (master → bcff743)](https://github.com/facebookincubator/idx/blob/bcff7433f55b481b3930b7985ec4e20ca808dfee/packages/idx/src/idx.js#L58-L69) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dtt5jd3.)
Thank you, I’ll look into that! He
that's a good question :)
Nice to see C# innovations making their way to other languages for a change.
I’ll have to follow you. Done with my basic JavaScript courses soon so I’ll need something for the next step. Thanks! 
This deserves more votes
Yes, its working, I will mark as solved. I agree with what you write. Still, if I do `callApi1().then` I get an object back. But when its part of the `Promise.all` the same call returns a string. No problem working around that, just find it a bit odd
I generally use either Mocha or Jasmine. I tend to prefer Mocha, but I think Jasmine's _fixtures_ (DOM fragments) are very convenient sometimes. You _can_ use Mocha + JSDOM, but Jasmine's approach is more straightforward. Other stuff: Chai (assertions) an Sinon (mocks). I've sometimes tried using Cucumber but in the end, its benefits were not really applicable to the situation.
Personally i find this a great way to learn :D ... tossed in the deep end is a challenge to me and sure maybe i'll have a couple nights working until 3am but it means you then have the opportunity *later* to analyze how you handled X or Y situations and then grow from them :D 
The article is correct. It's not about the environment where a function gets executed, but rather the circumstance where that environment is _different_ from the environment where it was _defined_. That is, basically a closure is a function that is created in a certain context, but then it _gets out_ of that contexts and is run in a different one. The original context is no longer available in general, but as the function was created there, it -the function- _can_ still access it.
For me was the feeling of the Unix world without the little but never ending issues I had to solve in a Linux installation, the good quality, and starting to loose some prejudice I might have had against apple. But still f*ck apple. The option to code for Google world and Apple world.
Thanks for the response, that makes a lot of sense!
I am a pretty thick-skinned person in general, most of the time I just ignore all that bollocks :)
Thank you! Glad you found it useful :)
thanks! I am now (slowly) planning to do a set of videos on foundations of js as quite a lot of people seem to be in the need of that kind of info. so, stay tuned :)
I liked JavaScript: the Good Parts. It served me well circa 2011 when I picked up JS, also coming from a C background. It focuses on fundamentals without being overly handholdy. I suspect it has aged well.
It is a nice article, but it is more specifically about currying than closure. Currying is the act of returning a prepared function that isn't quite ready yet, but is primed for subsequent calls. Also there is a code example with `const z = ‘random’;` which is never used. The way to properly understand closure is a concept of accessing references across *scope depth* or *scope chain*. In the end you need two vital ingredients to exemplify closure: nesting of scopes and references declared in one scope, but used (or called) in a different nested scope. A common misconception many people have is that closure is a phenomenon specifically confined to functions. This observation exists because in the EMCAScript specification functions are defined literally as closures. The terminology and description in the spec is correct as a function is a closure. The confusion is an equivalence fallacy in the reverse of a term definitions. To say a function is a closure does not immediately suggest a closure is a function. If you want to get super scientific about the concept it is generically termed *lexical scope* in programming and derives from *lambda calculus* in math pioneered by Alonzo Church and was later proved in the *Church-Turing Thesis*. Closure, or rather lexical scope, is present in various languages or at least appears to be present in many languages. The one true discriminator that determines whether a language has closure is the ability to assign a new value (write) to a closure from a child scope. This ability ensures references aren't being silently cloned into child scopes for convenience of access to like values.
Tampermonkey is "just" a browser addon. It does not add anything that you couldn't achieve by writing a browser addon yourself. But a Tampermonkey userscript can be used on any browser that is supported by Tamperkonkey. If you write addons, you have to write them for each individual browser. 
I don't want to sound like an ungrateful pieceo f shit, but: Sorry, that voice/sound effect killed me. Maybe you should consider writing tutorials instead of making videos? 
Linux distros have gotten a lot better (maybe try one before getting Windows), but i hadn't heard about WSL before. Thanks for the answer!
Windows has to much magic that makes it easy to start coding but difficult to configure your development environment the way you like it, or at least that is they way I felt about it when I made the move to Linux about 10 years ago.. and I don't kwow, I felt for that terminal and the Unix file system, it was easy, it made sense, ssh, scp, service, yum, apt, brew , permissions and users.. etc.. Because of xcode.
Thank you! Really happy to hear that :)
It looks like the implementations are not _exactly_ equal. NodeJS is sending more headers bringing it to about 130bytes per request vs 80 bytes per request on the Ruby implementations.
&gt; Do you think this is a best way to test someones js level? Doesn't really matter. You either impressed them or your didn't.
To do so, maybe you can reference my newly created demo repo, it can save you some time :) https://github.com/jeromewu/travis-ci-gh-pages-demo
What makes JavaScript unique (and strong) are these concepts: * functions as first-class citizens * native lexical scope (not hidden behind a convention like lambda expressions) To be competent in JS you really need a level of emotional comfort with those two concepts. You can avoid wrapping your head around these concepts, and many people do, but your code will be brittle. OOP is completely optional in JS. You can write large elegant applications without it by never using *this*. There is even an ESLint rule to error on uses of *this* outside classes. I don't know what Electron's API looks like, but I recommend not abstracting it. For the best performance learn this API and access it directly. If you find you are doing identical (or nearly identical) IO operations frequently then you can write a shallow alias to the API at the discretion of your application code.
If you would like to write browser addon for all major browsers, maybe you can check kango framework(http://kangoextensions.com/index.html), it will make your life easier. From your description, looks like you are going to copy data from multiple webpages, maybe you can consider writing a program in Python or Javascript to achieve the goal without dealing with the addon issues.
It goes both way. Either they impressed me or they didn't. As a developer it's likely you're in a comfortable position of being able to tell the interviewers to go and eat their pens, and quit. I mean, I wouldn't do it over having to use a pen, last time I did so was due some more significant lack of professionalism coming from people doing the interview. But I could. If I really hated pens. Which I don't. I like them more than pencils. Pencils make unpleasant scratchy noises. Pencils are the worst. I might leave on the spot if they handed me a pencil.
I will say there is an expressive formalism to writing things down. You are forced to communicate formally and with some degree precision. This is a good way to see if the candidate can communicate. My first corporate job had a paper test that they used as a quick filter. There were some questions I disagreed with or thought were ambiguous so I circled the best answer and then wrote notes in the margin about how I felt the question was unclear. This won me additional points. After this I moved into the real interview.
I personally love to make people write code on paper when I am interviewing them. You can see exactly their thought process when using pen and paper. On a keyboard they can just backspace if they made a mistake, but on pen and paper they have to scribble stuff out. I normally give them a very simple problem, and I am always quite lenient with mistakes etc, because i know it's not an easy thing to do. To me it tells me more about how they go about solving problems, and less about how good they are with an IDE or at typing etc.
I will never ask people write code on paper if i interview with them. It's not my type, definitely. 
Lucky. In my last interview they gave me a stone tablet and a chisel.
If you dislike it, the answer is "too much" if you take a job that uses it. All the front-end work that you do for that company will be in React, and being "fullstack" means you work both the front- and back-ends at the same time.
They didn't _want you answer with a pen_. They wanted you to answer with your brain.
I totally agree that it is better if you check what's wrong with body-parser or other related packages, if you still cannot find the root cause and you really want to parse it, you can try [qs](https://www.npmjs.com/package/qs) which is used by body-parser and should be able to help you to parse the string to object.
OMG
*sneezes* _SPLAT_ Do I pass?
Mocha and Jest are testing frameworks whereas Chai is an assertion library. On Chai’s home page you can see the difference between BDD and TDD styles based on their Should vs Expect vs Assert examples. It’s totally a matter of preference. 
Is there any outline of what's changed between editions. I only recently managed to get my hands on a hard copy of the second edition.
That's true i need to copy data from multiple similar webpages of same website, e.g. reddit profile page of different users(just an example, need data from other website). What would be best way to do that, so that it should be easier coding and easy to use as well. Not gonna worry about different browsers, we will be using chrome.
Sounds like you could probably automate this using Chrome puppeteer, just scrape the pages 
Even when you got started? I find people tend to be really negative towards people who "create" things and self-promote.
I’d like to know too. I was going to set a RemindMe but I don’t remember how that works and I’m to lazy to look. 
Worst book ever.
Great video Elijah. I was surprised how useful debugging straight from VSCode could be once I set it up. I’ll have to take a closer look at the config block you used in the film. 
I think all this should necessarily depend on the type of role they are hiring for, in addition to personal preferences. I would not, for instance, want to fill a senior role for software development with someone who cannot think through a basic problem without a computer. They can write pseudo code or draw diagrams or whatever to articulate an idea, but whiteboarding is a really important skill. On the polar opposite side, however, I wouldn’t expect a junior dev applying to a more casual, website development position to be super comfortable with this, at least at that point in their career.
This information is awfully outdated. The API is old and some of the statements are false: &gt; Hyperapp requires node.js, npm, and gulp node modules... None of these is required to use Hyperapp. You will probably use npm to install `hyperapp` and a JavaScript bundler when bundling your application, but some prefer to download Hyperapp from a CDN like [unpkg/hyperapp](https://unpkg.com/hyperapp) and that's fine too. Hyperapp **does not** require gulp lol.
Have you tried toggling? https://jsfiddle.net/40ajcv6a/3/
&gt; Is there any outline of what's changed between editions. I can't see one. You could download the HTML version of each, extract all the content in H1 and H2 tags, then do a diff against the result. That'll give an idea of what significant additions have been made, though won't tell you much about smaller changes and improvements. &gt; I only recently managed to get my hands on a hard copy of the second edition. This is appears to be in late-draft for at the moment, so your dead-tree copy won't be replaced by a 3rd edition for a bit of time yet.
Use this. function darkmodeon() { var lightbody = document.getElementById("lightbody"), lighttext = document.getElementById("lighttext"); lightbody.className = lightbody.className ? "" : "darkbody"; lighttext.className = lighttext.className ? "" : "darktext"; } 
Oh, yeah, I've heard some ridiculous shit coming towards me in the beginning. Mostly just laughed it off ;)
the 3rd edition is updated to modern JS practices in ES2015, ES6, etc. Changes include like using let/const instead of var and shows how to use arrow functions, template strings.
&gt;*Pros and Cons* &gt;&gt;Lists no cons 🤔
can you explain what a "classList" is? Thanks
It's seriously handy -- it's all classes currently attached to the object, and you can use functions like add() and remove() (and most relevantly toggle()) with it. 
angular.js no angular :(
His comment history provides ample context for his comment, though. If a person like him likes a book, I would consider that far more troubling.
I would say the opposite. Eloquent Javascript was the book that gave me my "ah ha!" moment and finally understand the language. I wouldn't say the best for newcomers, but I still was able to understand it thanks to the amazing writing.
Didn't knew about Puppeteer, I will look into it. Looks like it needs node.js about which I have no knowledge.
This book is definitely worth going through if you're new to JS or programming in general. It's a good balance of explaining things and making you work through shit to improve. Pretty decent as a reference too.
This is great news. I've recommended this book to a few people starting out, and they all loved it. I was hoping for an updated edition covering ES6, and here we are :)
Thank you very much
OP also repeated 'a' in the array, possibly to make the array longer, but it's still not long enough to have a value at index 17.
All of the images and links are for the 2nd edition, and the top of the website says there is just a draft of the 3rd. Is it really out, I can't find it anywhere
“Dead tree Copy” lol
I'd like and AI that can recognise fruit and veg as you prepare them and weight them and calculates total calories. A raw fruit and veg white list would be better.
Subbed! :)
Hi. Mithril author here. Since you mentioned it, I figured I'd chime in some corrections too. Neither mithril nor inferno are one man shows (and for that matter vue and preact also have a bunch of contributors). Regarding the 1Kb thing: I think it's important to mention that is gzip+min because someone who is unfamiliar might think it's 1kb of unminified code, which might make them question the integrity of claims about how much can be accomplished with it. BTW, the 1kb number is also outdated (it's about 30% larger than claimed) Also, if you're going to talk about pros and cons, it would be useful to mention what are the trade-offs being made to achieve small bundle sizes. For example, preact is smaller than react partly because it doesn't have synthetic events, fragments, error boundaries, portals, prop/context types. Also worth mentioning what's included in the advertised library size. For hyperapp, it's only core. For mithril, it includes router and HTTP request related modules (although they are technically optional modules) because I care more about framework size impact in production apps than how small a hello world can be. Anyways, I don't want to criticize hyperapp because I'm a fan of it. Keep up the good work u/JorgeBucaran
first a has a special blank character after, the last one has one before. You can see because if you select it and right click you have the option to "search google for ` ` ", whereas a normal space does not. Because of it you have 3 different variables just as if you had &gt; ab =1 &gt; &gt; a=2 &gt; &gt; ba==3 
I never mock or stub databases - not sure why you'd ever want to do that. I use a test database, often with transactions that are rolled back/tables that are dropped between each test suite (or even case). &gt; It's one thing to test functions, it's another to test I/O. I don't think it's much different, especially if you're using an ORM (which you probably should) and not a driver + raw queries. You have the previous state of the database. You execute a query. You have the expected next state of the database. That the state exists on disk somewhere (and not in-memory like a variable) is honestly a bit irrelevant.
check my answer below to dangoodspeed
Just use `Promise.all`, that's what it's for: async function main(){ await Promise.all([ first('async boi'), second('async boi'), ]) }
Thanks, I thought Promise.all() also executes them one at a time. 
Or leave out the await before the initial call, and use await when you're actually going to use the data. async function main(){ try { const t1 =first('async boi') // waits this to finish const t2 = second('async boi') // then runs this return console.log('done async boi', await first, await second) // Or whatever you're actually *doing* with the values. } catch (e) { throw e } }
Thank you! &lt;3
Yes. Why not just try it and see for yourself?
Others may disagree, but here's my 2 cents: - It's much easier to think about how to split up code when you are using functional programming patterns. If you code yourself into a situation where circular dependencies feel unavoidable, you're probably trying to apply a pattern that doesn't fit the situation. - Functions that are used in 2 or more modules, especially pure functions, should probably live in `/utils`. If your function in `message.js` needs access to the `app.js` context, there are a few ways to go about this. I love functional programming, but sometimes it's easier to do things with a class. I've set up very simple websockets projects that could be mostly covered by a single class with some utility functions. const socket = require('socketio-client') class Server { constructor() { this.init() } init() { this.client = socket() this.initEventListeners() } initEventListeners() { this.client.on('open', () =&gt; { this.client.on('message', message =&gt; { this.handleMessage(message, socket) }) }) } handleMessage(message, socket) { // now i have access to message, socket, and this.client } } 
I have already read YDKJS and a few other things. Is it still worth reading eloquent JS?
The Amazon link in the announcement leads to the *second* edition.
I just start messing around with code immediately. This is how I learn. I can't speak for others of course. If other people learn by watching youtube then all the best for them!
Open source books, cool! Is there any site or list where I can find more like this?
[Here's a link to see what's been changed](https://github.com/marijnh/Eloquent-JavaScript/compare/3rd).
[Here](https://github.com/marijnh/Eloquent-JavaScript/tree/3rd) it is on github if anyone wants to tear through to commits to see what has been changed.
Sure - there will be some overlap, but it's good to see how different people teach the same subject. I've never regretted reading more than one book on the same language - I always learn something new.
That's really cool, great job! I ran ![lighthouse](https://i.imgur.com/hMscvC0.png) on your PWA and it seems the PWA score isn't 100% mainly because you forgot to add "/" to the list the staticFileGlobs (I assume you used sw-precache). You'd think that "/" and "index.html" are the same, but they're treated as different URLs, so you've got to cache both of them
I wasn't sure how to mock async code like this to try it out.
Aaaand theresalwaysonejack*ssperthread. Eloquent JS is well known and appreciated by most JS developers.
&gt; A closure is the combination of a function and the lexical environment within which that function was declared. This environment consists of any local variables that were in-scope at the time the closure was created. From: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#Closure The best way I've found to phrase this is to say that a closure is created around variables referenced within the inner function. In this, case a closure is created around **uniqueID** so that it's accessible within the inner anonymous function. If you were add another variable function generateBlogPostID(thePost) { var uniqueID = 100; // Captured by the closure var notCapturedByClosureAsItIsNotReferenced = "FOO BAR BAZ"; // Not captured by the closure for(var i=0; i&lt;thePost.length; i++) { thePost[i]['id'] = function(j) { // j parametric variable is the i passed in on invocation of this IIFE return uniqueID + j; // each iteration of the for loop passes the current value of i into this IIFE and it saves the correct value to the array }(i); // immediately invoke this function passing the i variable as a parameter } return thePost; } and put a breakpoint on the **return uniqueID + j;** line, notCapturedByClosureAsItIsNotReferenced would not be available as a local variable, while **uniqueID** would be available.
Thanks, ill check it out.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [mystikkogames/voodoo/.../**vclock.js#L135** (master → 3d17db9)](https://github.com/mystikkogames/voodoo/blob/3d17db9192264a2b302239053d3376e8593d14ae/components/vclock.js#L135) ---- 
You need to explain yourself a bit better. So, you have something of the form... { text: { 'Some title 1': [ Object1 ], 'Some title 2': [ ObjectA, ObjectB, ObjectC ], 'Some title 3': [ ObjectX ], // ... } } ...and you want to do what with this? You want to transform it into what exactly?
So I'm trying to use functional programming, but I still don't quite get the immutable data part. If I want to save a state (ie a table of data) how the hell do you do that immutable? Take the original table, create a new table with the old data+new data then overwrite original table? Also I thought even in ES6 you should stay away from classes, also that class of yours you are saving a variable outside of the class definition directly inside is that a good way to do it? You're even saving it in the class definition and not via a new instance of the class or doesnt js classes need to be instantiated?
Hey thanks, yes just like that. I want to number each item in each array. Example: 'Some title 2': [ ObjectA(1), ObjectB(2), ObjectC(3)] I want to add a number to the end of each object. 
But what does that mean? Add a number how? where? Or maybe, you could explain what is the purpose of it, how are you going to use that number. It's an array, why would you need to _number_ the items in an array?
I agree with a lot of this, especially the point about "Its Javascript". As a newb who just started looking into Angular, I'm not a fan of the complex binding syntax Angular templates use, and I'm not really sold on TypeScript either. I see the benefits, but writing plain javascript, especially es6 has lots of benefits too, ilke the ability to more easily migrate your code to some other library. Angular presents a really nice experience initially with all of the dev tools, typescript, and cli but in my mind these tools will also lock you into syntax that offers little possibility of ever migrating your code to a different framework. 
The draft is out. From the Introduction: &gt;There have been several versions of JavaScript. ECMAScript version 3 was the widely supported version in the time of JavaScript’s ascent to dominance, roughly between 2000 and 2010. During this time, work was underway on an ambitious version 4, which planned a number of radical improvements and extensions to the language. Changing a living, widely used language in such a radical way turned out to be politically difficult, and work on the version 4 was abandoned in 2008, leading to the much less ambitious version 5 coming out in 2009. **Then, in 2015, a major update, including some of the ideas planned for version 4, was made. Since then we’ve had new, small updates every year.** &gt; **The fact that the language is evolving means that browsers have to constantly keep up, and if you’re using an older one, it may not support every feature. The language designers are careful to not make any changes that could break existing programs, so new browsers can still run old programs. In this book, I will use the 2017 version of JavaScript.** The highlighted text is new.
Yes I want to display the number. Each array contains classes. Example 'VR Salad Bar': [ [Object], [Object], [Object], [Object] ] Is a class that has been conducted 4 times. I want to display the number next to the class name.
Or display the index of each object in the array.
Use a `for` loop? I mean, I don't see what the difficulty is. Something like this? let subject = list.text["Some Title 1"]; for (let i = 0; i &lt; subject.length; i++) { console.log("index: ", i, "item: ", subject[i]); }
RemindMe! 1 week. 
That's my point. You proved my point. You didn't just "learn to code by yourself", you looked up a resource such as a book, video, website, etc beforehand. Therefore, videos are not a waste of time and are far from "anti-learning", like I said.
Is there a way I can run it on every array at once?
As far as immutable data goes, it only means that you don't change things in place, which naturally means you will make copies of things you want to change. If I have a state object, and I want to make a change to it I can do something like this: const state = { foo: 1, bar: 2, baz: 3 } const new_state = { baz: 4 } state = Object.assign({}, state, new_state) console.log(state) // { foo: 1, bar: 2, baz: 4} Notice that I reassigned state, but I did not mutate the original object, I merged its contents into a new object literal, and merged the new changes into that. This is a very basic example of how pattern helps prevent unexpected side effects. It's just as you described. The opposite of this would be direction mutating the existing object. state = Object.assign(state, new_state) Or state.baz = 4 As far as "staying away from classes" goes, here's my opinion. Functional programming is great for some very tangible reasons. It got a lot of attention in the recent past via Haskell, Elm, Redux, and other technologies. This does not, however, mean "classes are bad", that would be a huge oversimplification of how these tools work. When people do recommend to avoid classes, they generally either argue that JavaScript doesn't actually have classes, which is not a real argument, inheritance is dangerous, which is true if you don't know what you're doing or are doing really complex inheritance, or they are just jumping on the FP hype train and don't have a real opinion. And your question about "saving a variable", are you talking about when i bind `this.client = socket()`? This would only be a problem in the following scenario: const socket = require('socketio-client')() class Server { constructor() { this.init() } init() { this.client = socket } } In the above code, I called the function returned from `require('socketio-client')` outside the class, so every new instance of Server will be bound the the same socket client, which is not what you want. If you don't call the function, it will be a new socket client for each instance of Server. And no, I didn't instantiate the class, but you do have to do that. Honestly there are a lot of ways to do this, I personally don't shy away from classes when they are used correctly but you have lots of options.
I am pulling events from an api, I want to label events with the same name by order. I am pulling events from Eventbrites api. Say I had an event called “fun time”, and it was the third time we have had the event. When I display the event name I want to display the number 3 next to the name. Sorry if this is confusing. I can upload more code in a bit to better explain.
No. The post links to the correct 3rd edition page, however all of the content on the page is the 2nd edition. When clicking on the the paperback link on the official 3rd edition page, you are sent to an amazon listing for the 2nd edition. The 3rd edition is not out, as the title states. There have just been a few changes to the content. Highly misleading, and most likely not worth purchasing when there is no description whatsoever of the updated sections from the author nor the Reddit poster. Also, advertising the 2nd edition on the official site when the 3rd is supposed to be released soon seems like a pretty slimy move. [Screenshot](https://imgur.com/a/jIlgh)
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/a3aiz0i.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
Honestly all this immutability stuff seems like a shitload of overhead for making sure you don't do stupid shit in code.
Nice! Keep the good work!
Yes the title is misleading, that's why I said the **draft** ist out, in my very first sentence. Of course you can't purchase it. &gt; There have just been a few changes to the content. It's an update, not a complete new book. That's why it's called *Eloquent JavaScript's 3rd edition* and not something completly different. There won't be made big changes to this draft: https://twitter.com/MarijnJH/status/958665332448784384 &gt; when the 3rd is supposed to be released soon seems like a pretty slimy move. How dare him to tell people on his website that the updated book is in a draft version, while still giving them the option to purchase the 2nd edition - for a book **that you can read for free on this very site**.
Ok I think I was going about this problem wrong. Ill re-post something later tonight. Thanks for the help!
Try it and see. If it fails, report back with an explanation and we can take it from there.
Great! Thanks for this. I'll check out those 2 books. I'm leafing through the book and am already up to the chapter on OOP. The main reason I'm reading it is to learn about the DOM and the BOM and how to interact with them using JS. Those are concepts I have no knowledge about, and are kind of the crux for my app. Thanks again!
&gt; I can't see one directly, though it may be in the text of the introductary section if you read that. Nah. nothing there unfortunately. &gt; This is appears to be in late-draft for at the moment, so your dead-tree copy won't be replaced by a 3rd edition for a bit of time yet. Yeah, I'm aware that it'll be some time before a 3rd edition hard copy can be purchased. I'm simply trying to figure out if it's best to simply read through the hard copy I have and then pick out certain updated sections to the cover online VS. abandoning the hard copy version altogether. It looks like there's no clear breakdown of what's changed to figure out what's best.
I agree with your points. I just leafed through some pages that described functions as objects and lexical scope. It was surprising to me first that functions are just regular objects and therefore, I can create a reference to a function and use it as a regular variable. This exists in modern C++ too, but there is a strict distinction between a pure function and a functor(function object). I'll definitely keep these points in mind. Thanks for the input!
Yea I can see your point. I'm still muttering a bit about how to structure my shit but I think I have a clearer picture. Feel free to comment but: Functions that are "model specific" (ie say parsing messages and only used in message.js) is fine to leave in the same js. Something like a "DiscordInfo.js" which just returns an object to save info then something like discord1 = require('discordinfo.js')() discord2 = require('discordinfo.js')(). I'm still not sure what is better regarding business logic that is cross modules though. Should I in app get the return value from one module, handle it then pass it to a second module? Or should module1 directly call module2 which creates a dependency of module1 for module2. I ran into that problem in a different app I'd written where I TRIED to make things well but I created deep dependencies like that and it made expanding/changing shit a fucking nightmare. On the other hand I really do not like cluttering up app.js with business logic because app.js feels more like a bootstrapper/initiation/setup file.
Hi /u/ryanflorence, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Yeah, that's true. I probably wouldn't do it for a junior. Or at least I would be very forgiving.
It did not ask me to install. OnePlus 5t with Chrome and OxygenOS 5.0.3.
&gt; [...] this community has little to no quality control on posts. Please read: https://en.wikipedia.org/wiki/Survivorship_bias And funny, I don't remember seeing your application for moderator when we were accepting them. It's also charming that your sole submission to this sub is this current post, and 1/2 of your comments (2 out of 4) were basically just useless noise... &gt; [...] however nothing has been released and likely won't be released for a while. Without providing sources or credentials, your words on the current subject are no better than a magic 8 ball. If you know more about the topic _from an authoritative source_, then by all means, please share! Otherwise, it's just more unsubstantiated claims.
oh i'm so scared!
explain 
Very cool! Great job, cant wait for your next projects! 
Honestly, you'll probably do just fine with plain old JS. I work out of SharePoint for most of my development, and I haven't had any issues with just... JS. A little jQuery to make DOM stuff less verbose, a little underscore to handle collections. On bigger projects, I might write up my own Handlebars templates, but I don't do any of the compiling, nodejs stuff.
You know that Vue is declartive like React, and has a virtual DOM? The only simularity between Angular and Vue is the template syntax with directives. 
Fair points. But you should look at Size Limit closer. --why flag shows you why you have this size, so it is very helpful in decreasing size. Docs also contains some great examples how --why really help me and other develop to decrease size of libraries (PostCSS and Browserslist, for examle). https://github.com/ai/size-limit
Yeah colour me interested too. I can't see anything in a cursory glance which should be capable of this. Maybe a never-ending HTTP stream making an ever-larger page with CSS hiding all but the latest copy, but I'm seeing nothing in the network panel either.
You need to configure the scss parser
Imo, Codecademy. If that's too beginner friendly (that is, not in-depth enough), wait for other answers. It's what I started with and then learnt details on the go :) 
&gt; I'm not a huge fan of framework specific attributes that do DOM manipulation as opposed to data passing between elements The way Vue and React handle most stuff is pretty similar, they are both focused on the same component paradigm after all. The Vue template and dsl compiles to render functions, similar to what you have in React. I personally prefer the declarative approach of Vue’s dsl for things like conditional rendering, but I can see why someone might prefer the JSX approach. JSX is available to use in Vue, but it doesn’t seem to be commonly done. 
I just discovered this and I'm ecstatic. It's only got ~7,000 downloads so I thought for sure it'd be a broken piece of junk. It worked, right off the bat, and has a lot more settings than similar packages to permit the use of aliases and specify styles. Also, unlike a lot of packages, it doesn't only work for npm modules. This is legitimately going to save me hours.
`--why` tells you what the sizes of things are, not how to make things smaller. I know it sounds pedantic, but it's not. Part of my day job is providing tools to teams at my company so they can optimize their apps. Simply showing them what things have what sizes is not sufficient to make people do bundle size optimizations. They might see regeneratorRuntime taking 20kb+, but they won't have a clue how to get rid of it. Also, I think size-limit only really helps when your code grows to a point where bloat can occur. If you're writing small things like [this](https://github.com/MithrilJS/mithril.js/blob/next/ospec/ospec.js) or [this](https://github.com/hyperapp/hyperapp/blob/master/src/index.js), reducing size becomes more a matter of design trade-offs.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [MithrilJS/mithril.js/.../**ospec.js** (next → 81903ca)](https://github.com/MithrilJS/mithril.js/blob/81903cacdbcee1fb8a0d3ac8a0c639159a99015b/ospec/ospec.js) * [hyperapp/hyperapp/.../**index.js** (master → 0028809)](https://github.com/hyperapp/hyperapp/blob/002880933b2e249bf9d5c07ccc6ce60cbbc81dcb/src/index.js) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dtufquv.)
If you're not new to programming, [Eloquent JavaScript](https://eloquentjavascript.net/). It's too terse for absolute beginners, but ideal for those coming to JS from another language.
i dunno, man, i get downvoted through the floor any time i say something unpopular, even if i couch it as a personal opinion, or defend it with textbooks
It looks like you wrote a lowercase I instead of an uppercase I. This has happened 6679 times on Reddit since the launch of this bot.
Need to set myself a reminder to read this after my intro to react. Thank you.
It's actually pretty common at a lot of places that I've interviewed and worked at. As many others have mentioned, it gives some insight into how you solve problems but it also gives a lot more insight into your grasp on syntax and whether you understand the language, or just google how to do something and click on the first Stack Overflow link you see. I mentioned syntax specifically because I had a whiteboard interview like that in the past and I pseudo coded my answer first, then wrote it out and there was a part that I was blanking on how to write it because I was using vanilla, and at the time I was used to jQuery. I told that to the interviewers and they said that they were happy with how I solved it because you can always google things like syntax (or just use the syntax highlighting in an IDE) but the problem solving aspect of it was what they were looking for because that's what the job entailed. My point is that these kinds of interviews can be uncomfortable at first, but odds are that you may find yourself in another one someday and it might be good to get used to that.
Here is Mozilla Developer Network's JavaScript learning pathway, it's been getting great reviews these days, https://developer.mozilla.org/en-US/docs/Learn/JavaScript It's very clear and concise, and walks you through simple projects. I also have been using SoloLearn's JavaScript learning app for android, https://www.sololearn.com/Course/JavaScript/
bad bot
Yeah, I must have missed the further details, or you edited your post. 
Hmmm, yeah I know what you mean. I think it's generally okay to have deep dependency trees, as long as your file and variable naming conventions are standard and consistent. Stack traces should still tell you exactly where something is happening, tools like breakpoints can help you step through complex flows incrementally (even with node). Another thought is that by taking advantage of promises and/or async functions, you can easily chain actions, or if you are doing FP, using things like R.compose from ramda to chain functions. This is kind of a psuedocode example but: const messageHandler = require('./models/message') const dispatcher = require('./utils').dispatcher class App { constructor() { this.init() } init() { this.client.on('message', message =&gt; { this.handleMessage(message) }) } async handleMessage(message) { const response = await messageHandler(message) dispatcher(response) return this } } This kind of approach can help you avoid deep dependencies, even for modules that do asynchronous things like make API calls, make sense?
You said it yourself: Most ;) not that I wanna defend that idiot but for me personally i had more success with other resources as well. JavaScript the weird part then ydks did it for me.
Yeap. It is always better to have magic “Solve everything” button 😄. I see it as a linter or benchmark. It works best when it added to project and check every PR. So when you receive some PR to open source library you will be warned on some strange bloating.
you dont know JS ... seriously (its a book series) google the book series by Kyle Simpson, eventually check out his workshops on frontendmasters.com
Possibly HTTP streaming? (standard header that indicates that the server will be responding in multiple chunks). Not sure how the browser deals with that header for an html file though
How different from the last version? Does it worth checking?
I am on the other side of the coin and I love React. I also read Eloquent JavaScript 2nd edition and I recommend reading this before studying React. There are a lot of things you'll learn here like map, filter, and reduce which are used often in React
Any way to get a PDF version?
VS Code already automatically adds imports?https://code.visualstudio.com/updates/v1_18#_auto-import-for-javascript-and-typescript
https://github.com/bpesquet/thejsway Go here and you are good!
!remind me in 3 days
Want it too !
That code is never executed, as stated [here](https://github.com/facebookincubator/idx/blob/master/packages/idx/src/idx.js#L43). It is a babel transform that only runs at compile time and translates to sane code at runtime.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [facebookincubator/idx/.../**idx.js#L43** (master → bcff743)](https://github.com/facebookincubator/idx/blob/bcff7433f55b481b3930b7985ec4e20ca808dfee/packages/idx/src/idx.js#L43) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dtup85t.)
Ahh I see. Well I just started using Mocha for my project. It started out well at the start, but it does not really encourage synchronicity in the testing. So i decided to use another library called Ava instead. Thank you so much for clarifying the differences :) 
Codecademy offers a nice FREE overview of JavaScript 
No.
I looked at the source code. That updates in real time too.
Explain how to add a http long poll?
Do you really want to have to rewrite all your react code? 
Thank you I will check into Codeacademy! Free is always super nice.
Oh, so this is done with back end code I presume. Some of the magic is gone there, but it's still a rather interesting effect.
https://javascript.info/
Which intro to react are you reading? Would you recommend it?
Can't agree more. I look back on my old code when I just started learning it and damn, it's bad.
READ IT!!! it is one of the best books on js
I can think of a few reasons: * You want to use backticks in your string without escaping them * You want to use `${` in your string without escaping it. * backwards compatibility: your target does not support ES6 (becoming less and less common these days) But for most use cases I think you're right, and if you just wanted to use backticks you could most of the time. 
There are some who say that code should signify intent and you should only use back ticks if you intend to do substitution. I don't hold to that. That said, there are some places where the traditional quotes come in handy -- when working with preformatted strings that use backquotes. Also useful if you have to write ES3-compliant code at any time. 
&gt; backwards compatibility: your target does not support ES6 (becoming less and less common these days) Isn't this sort of thing usually managed automatically by the coder running everything through Babel before posting it for public consumption?
Sure, or closure compiler or whatever. But if you're writing something really trivial for for older targets and don't want to set up a whole build environment to do it, or don't want to wait for compilation, or just feel more comfortable, then you could just use ES5. That being said, it's becoming less and less common.
Well if you have to run it through babel anyways (which not everyone is doing), why not just use the proposed syntax through the [plugin](https://github.com/babel/babel/tree/dd0337cc85c341b36b0657e05964532a650fd088/packages/babel-plugin-proposal-optional-chaining)?
Could you add a fiddle or something. 
Would this be a good book for beginners?
Could you please elaborate?
`try {doSomething()} catch (e) {throw e}` does the same thing as `doSomething()`. If there's an error, the end result is that the error is thrown, so you might as well remove try/catch block.
I use ‘ instead of backtick for plain strings. It helps communicate to other devs that it has no variables in the string.
Add examples
You can go to the 3rd edition branch on the GitHub repository and build it from there probably but not sure if the makefile was updated for the 3rd edition or not. I tried building the pdf and it would crash but didn't seem to have problems with the HTML or EPUB versions.
I think FreeCodeCamp has a good support system. I've never used it myself, but I've had people link me threads.
I meant more of a one on one help
Check out Vanilla.js
Backticks are annoying to type with some keyboard layouts. I only use them if I do interpolation.
JavaScript and jquery by Jon Dickey is really good for beginners. https://www.amazon.com/gp/aw/d/1118871650/ref=zg_bs_3617_3/137-3406105-0641913?ie=UTF8&amp;psc=1&amp;refRID=JR7KTG48P1RWX1325G06
Hi /u/bornleader77, For javascript help, please visit /r/LearnJavascript. Thank you!
I recommend FreeCodeCamp. Not only does it cover the basics, teaches you how to use the code, but also points you in the direction of many small projects that actually have helped me learn about JavaScript. It doesnt hold your hand the whole way and lets you learn by doing, which I love. In my experience, there havent been any huge difficulty spikes, but every next project has been just a little bit out of comfort. 
What is your budget? 
70 per hour if it's a guaranteed help
I also vouch for codeacademy.
This is an old school chat room tech. It's a never ending HTTP connection that spits out new data as the server receives it. In the old days, this meant a never ending scroll of table cells with the content posted by users. Nowadays with flexbox, you could present the content a number of ways.
Ill send you a PM. 
Yep, been around since the 90s, nothing new.
"JavaScript: The Good Parts" was helpful for me.
I’ve heard about FreeCodeCamp as well, I appreciate your suggestion! Thank you! 
Thank you! 
Codeacademy
not really, but I did read all the nonsense the 207 online users posted. The dev said he's gonna shut it down n did shut it down :/
https://caniuse.com/#feat=template-literals Mostly just IE not supported, seems like.
Sure. Thanks.
I really hate people on the internet sometimes
Also great for multi line strings. I like to make a distinction between concatenating a couple of strings vs. substitution. They are equivalent, obviously, but so are for/while and if/switch. 
Just the MDN docs, and the console in the browser isn’t a bad start. Set up a basic HTML page with some stuff and poke around with the DOM, learn traversal and manipulation of elements, then learn to build a UI components from JS, then start transferring that knowledge to things like Node/React/Vue/whatever.
Chunking 
Odd. Doesn't work for me. I can't remember it ever working for me. I'm happy it's working now. I didn't realize it was supposed to be doing that all along. I spend so much time updating those imports.
https://en.m.wikipedia.org/wiki/Chunked_transfer_encoding I was closeish :)
Non-Mobile link: https://en.wikipedia.org/wiki/Chunked_transfer_encoding *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^146081
It’s still pretty magic imo
Is it because you're logging it directly after? Maybe give it time to respond first.
https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/onreadystatechange It’s an asynchronous request, so you need to attach a handler to catch the response. Right now, your log will return before the request does, so null.
I use an all Javascript stack if you want help.
- Import statements don't allow them. This is invalid: import { foo } from `foo`; - They're more annoying to type - They're going to be ever so slightly slower to parse (almost certainly inconsequential, but I haven't tested it)
Makes me pleased I don’t do much JS anymore. How does anyone keep up with this stuff and have a life at the same time?
Also great. 
Sounds like the reference to js file in index.html is wrong. Just check index.html in build folder. Non run build essentially generate index.html and a js and a css. Just need to make sure their relative path are correct after you publish. Not sure what kind of website you are building. Maybe could try https://dochameleon.io It generates static website from markdown and React 
My co-workers joke about how full-stack JS is just the new Ruby on Rails.
The others are right - it's async, so you can't just log the response immediately after the request gets sent, because it takes at least a few ms to get the response back. Fetch is probably better to use than XMLHttpRequest at this point.
That and everything thing ELSE it doesn't support. 
Well, that's not terribly correct. The set of instructions is _not_ for the computer, but _for the programmer_. An algorithm is a set of instructions, a well-defined and efficient specification of how to solve a type of problem. That code there is just code. The algorithm is not expressed in code, but in a formal but natural language. Code can be, at most, a particular implementation of an algorithm. Let's see an algorithm for finding an item in a list. A simple algorithm could take this form. 1. If there are no items in the list, you've finished: The item is not in the list. 2. Get the first item in the list 3. Evaluate if it is the item you wanted. 1. If yes, you've finished: The item is the current item you're holding. 2. If not, discard it from the list and go to step 1. Now, an implementation of this algorithm _could_ be something like... while (item = list.pop()) { if (criteria(item)) return item; } But this code is not the algorithm, just an _implementation of the algorithm_.
A pet peeve of mine is that the timer's "Pause" button actually stops and restarts the timer. So it doesn't actually pause.
I have never thought about it this way. Good article.
In addition to what everyone else has said I just find backticks to be less readable than single-quotes.
There you go! [Codility](https://app.codility.com/programmers/lessons/1-iterations/) Besides lessons they release challenges! 
Good point! 
Yay for Vue! But React does seem to be eating the world. They’re right about Vue having a lovely developer experience. Switching back to React can feel a bit tedious at times. 
Positive username.
You don't have to keep up with all of them.
Back in the day we cared about a lot of different things. Maybe you are throwing up chaff and confusion. 
Yeah, it's mostly settled: http://www.npmtrends.com/angular-vs-react-vs-vue-vs-@angular/core I guess if you're a blog-writer you need some drama, talking about javascript fatigue or some imaginary fight between frameworks, it's all nonsense. If you're following your instincts and look at the established technologies in a field as chaotic as the web, then it's quite easy to determine your foundation. Javascript overall couldn't be in a better place.
I already said it didn't matter according to my test, why are you whining?
There are always people like you showing up with nonsense noise contributions about trivial imagined performance issues; then some other newbies read it, feel clever and parrot it in the next thread and so the cycle continues.
wow you have issues. Keep them to yourself :) I mentioned a possible issue and then corrected it.
http://shop.oreilly.com/product/9780596101992.do is a good book to start learning JavaScript
Please post more random ideas and simplistic tests and whine a bit more if people don't take it.
I called you out on your simplistic performance issue but you keep trying to be a smartass about it.
Could you at least tell which browser did you use for testing? I tested it on V8 and SpiderMonkey - no difference. All examples you provided in SO are working.
They're incredibly annoying on german keyboards, which is why I remapped it in vscode to the same key as the double quote, but with the alt instead of the shift modifier. 
I used chrome (will update with version when I get to the pc). Also on Node (no type error) and REPL (no type error on repl if you do for example window.x = 5) Here is a fiddle that produces the TypeError for me: https://jsfiddle.net/kg2odL13/
##javascript on irc.freenode.net
..so are { and } and even [ and ]. german keyboards are just absolutely shit for devs, which is why I've switched to QWERTY one's long ago.
..but... that's a backtick.
Did somebody hurt you? Do you feel sad? Or angry? &gt; They're going to be **ever so slightly slower** to parse (**almost certainly inconsequential** &gt; **Back with PHP3** &gt; **doesn't show any performance difference** The way I read this /u/VoiceNGO's thought process was probably "This used to be a performance issue, I doubt it still is, but let's see.. nope". I find that mildly interesting. And you seem to have taken it as a personal insult that (s)he even thought it. I'm amused, thank you! I'm sure you'd be a pleasure to work with.
[Now for something to think about...](https://jsfiddle.net/kg2odL13/5/) [Or to put it in a different way...](https://jsfiddle.net/kg2odL13/6/) :)
Thanks for your contribution, glad to be of help.
Which should be all developer jobs tbh
Should be - I agree - but that's often not the case. Either way, if you want to grow as a developer you need to find time to experiment with technology - new or old. If you have opportunity to do that at your job that's fantastic, if you don't just get up an hour early every day and do it. Or get up early on Saturday and do it for few hours. Just like any other skill you need to keep pushing. 
Absolutely love the Vue developer experience. I know Reacts eating the world and all BUT as a lone front-ender, working among other developers of varying skill. Vue and Vues documentation makes life so much easier, especially when your already dealing with a mountain load of tech debt. About 2 years ago, we started our first Larvel/Vue project that will end up in close to 200 stores nation-wide. Before we settled on using Vue. I created the same sandbox project in Angular, React and Vue, and showed the team how each was built. Out of everyone on our team. They all chose Vue, which is funny because to begin with, everyone wanted to try React because "Facebook". haha Once the project kicked off. The PHP backend developer that I was working with took something like one hour with the Vues documentation to get up to speed. The only thing that Vue's has been missing is a solid hybrid framework which Ionic (https://blog.paulhalliday.io/2017/10/04/how-to-use-vue-js-with-ionic-4/) is hopefully going to address.
I was hired right of college at a company and ended up being put in front-end. I knew basically nothing about js and one of our main platforms was being written from the ground up in Vue. It was definitely a pleasant experience (although there were some bumps in the road) and now, 8 months in, I’m very comfortable with it. I’m a huge fan of Vue. 
thiS iZZ aWesOm3
I’ve been out of college and employed as a software engineer for less than a year. My manager generally assigns me work that he knows that I can accomplish and he also assigns tasks that I have no idea about. Our weekly one-on-ones are generally me talking through what I’ve learned and any problems I’m running into, in which he doesn’t just nod his head, but he challenges my knowledge and offers further insight/suggestions. This past sprint it was OAuth2.0/OIDC integration with one of our platforms. He wanted me to find out what I could, make meetings with people at work who are involved in our Auth infrastructure, write a POC, and then write an issue ticket for actual integration of what I had learned. I left the military, went to college, and then got hired here. I’ve never had a manager be so actively involved in my education. It’s been an amazing experience.
1 knOw righT ;)
Luckily, our solution is comprised of libraries I'm already familiar with. Redux, reselect, seamless-immutable, thunk, axios. Hopefully we don't encounter _too_ many quirks!
I wish I had more well formulated opinions of Angular. I have done a few side-project-y things in it, but haven't gotten to delve into it enough to post intelligently about it. I will say that my cursory experimentation with it has a lot of the same faults of Angular (you have to know the framework really, really well to be proficient, your code is heavily saturated with framework specific code, etc). I would still like to revisit it, as there are a few projects at my workplace using it with success 
&gt;The likely end scenario? Facebook does what it does best: copy the innovators and the world continues to use React. I'm really not sure if react is a good example of Facebook copying innovators. Async rendering built into web framework seems pretty innovative. 
Yes. Main reason is that not all JavaScript engines support ES6. The other reasons are that, if the string doesn't contain many multiple lines, or if the string is too long and you want to break it into multiple lines using line continuation escape character. Using normal quotes also require less processing time because the JavaScript engine doesn't need to look for expression to parse - especially if the string is not combined with any variable (not e.g. `"i have " + v + " fingers"`). Although it's small in performance difference, the difference may be noticable if the string is long enough.
That `null` result is the return value of `console.log()`. If you want to log the response once it's fully retrieved, listen to the `XMLHttpRequest` object's `load` event and log the response from within the event handler.
This article throws so much unnecessary shade at React. I didnt click that link in the article but im guessing they were parroting the Elm creator's claim that he came up with the idea of virtual DOM first. Which is pretty lol because the amount of ideas that Elm borrows is massive. That's one of the major selling points of open source, building on each other's work freely. 
makes me please that JS is the ecosystem it is today. It weeds out all the weak ass kids who can't keep up. 
It's Eric Elliott. Let the insult-fest begin (I personally don't mind him, but he seems to really be hated around here. I think it's the Jesus hair)
Hows Java 5 working out for you?
It's easy. The frameworks are very similar to each other. They all do props-down-events-up data flow. "Render props", "named slots", and "templateOutlets" are variations of the same thing. React looks more like Klingon than the other two: &lt;&gt;{({...x, Object.assign(...) {&lt;&gt;...x&lt;/&gt;} ? : [a, b, ...props]})}&lt;/&gt; whereas Angular looks like the guy in a suit in the old "I'm a PC, I'm a Mac" ads: private static virtual @Attribute('ChildType'): Response&lt;@Injectable() BaseType, Array&lt;Element&gt;&gt; {} And Vue looks more or less like a play doh commercial (sorry can't be arsed to make up an example after those two). Bottom line: it's all cosmetics. The concepts are all the same.
Vue is still insanely overhyped. API-wise, it's a more tightly coupled Angular 1.x. Not interested in going back to template hell. 
https://gist.github.com/drcmda/c5082ce0a929f4e208bc07933b3acd04
Well shit. Can you do the other basics like this though? Data binding?
Furthermore, you should also consider the readability of the string. If it starts with backticks, you should be able to definitely say "this has interpolation", whereas the others shouldn't. I think it's a problem if you use backticks for everything, as a cursory glance then won't reveal if it has interpolation or not.
Most of these items aren't new, just describing the state of established technologies that any front-end dev should already be familiar with. The other half are emerging techs that are gaining steam but it's not like you have to keep up with all of them.
ITT: 2 people with shitty attitudes.
https://i.imgur.com/5nokyAJ.png Not JS-related, but this is a trend I've noticed with tech blog posts lately. It's definitely not just this blog post either, I've seen this everywhere. I'm not perfect at writing blog posts, but I was taught to write three-sentence minimum paragraphs when I was 10. Hopefully someone else has noticed this, too?
I must be the only dev in the world who started with Vue and now prefers React :P
Sure, there are no regressions. Obviously it isn't recommended, neither for React nor for Vue, but being able to quickly whip up snippets for teaching and otherwise is useful.
Sorry, I'm a little confused. Do you or do you not understand this is an issue around ASI? Because you link to SO which explains this, but the post here makes it sound like a Function prototype/toString/orSomething issue.
I teach a big chunk of Vue without the webpack tools, to ease students from vanilla to “magic”. I don’t think you can do it as readily with React, but maybe I’m wrong. That was my original point. 
I have been deving hybrid with vue for over a year now. If you can run a browser in an app you can js /html. 
Yeah true. Keeping up is tough. But one thing about js is that it’s getting better through these changes. It no longer feels like slow browser dumpy tech days of yore. It’s pretty badass now and since there is a push to fatter clients and apps through JS it seems that through JS you can do more. 
There is so much you can with JS. I hated this trend cause JS was such crap, but through these changes JS has gotten better and way more powerful so it’s hard to ignore. Nothing really can compare to it. 
That's great, but since I assume you have little to compare it to I encourage you to try other things on small scale personal projects. You'll probably end up liking Vue even more after but you'll learn a lot along the way about the entire ecosystem. All of the popular frameworks/libraries are amazing and they all bring something to the table.
Ah, that would explain it ;) Those damn race conditions!
What are the odds... came into post this as the 3rd edition was just released!
Thank you! I share your views and feel a little less alone !
Which [Chrome hopes to do automatically](https://groups.google.com/a/chromium.org/forum/m/#!msg/blink-dev/czmmZUd4Vww/1-H6j-zdAwAJ) very soon
If there is one thing on that list to learn, it's Vue.
Ah, that's an easy fix. Thank you!
Could you expand on this? How is it more tightly coupled than, say, React?
I hate templating language. They are a waste of brains. I actually wish Go had a better templating system, like JS's backtick strings.
So imagine you had a React app, what sort of effort is involved in migrating from one to the other? I've some React experience but haven't played with Vue really. I appreciate it's a "how long is a bit of string" question, but I imagine some people have been through the process.
Vue is going to be the next jQuery. You heard it here first.
Highly likely 
I just saw someone in /r/php asking how to turn a php web app into a desktop app, and I was like, "Just use Javascript." People were blown away that you could do that. I was like, "Where the fuck have you guys been the last 3 years?" lol
Even easier, if you take some work time to work on your own stuff.
No, I'm the same after using Vue. I feel I have more control with react, even though they're roughly equivalent if you rip out the HTML templating from vue. I think it's because it *feels* more like JavaScript than vue, so I feel I have more control and it slots into my functional-lite style of JS easier.
To begin with, you can check the [official example](https://developer.chrome.com/extensions/getstarted) in google extension for changing the background color of the web page, check popup.js, and do some research, `chrome.tabs.executeScript` is useful in your scenario and you some basic knowledge for DOM manipulation in JavaScript.
I've been using Angular my entire career (started at 1.3 and am now using 5), and no matter how many times people want to say "Get an Angular app up in 5 minutes with Angular CLI" I will tell them they're wrong. It takes 10 minutes just to npm install everything. Vue is super quick and easy, and I really like it. I like Angular way more (in general), but I think Vue is a fantastic teaching tool and introduction into frameworks. Side note: I hate React.
The examples are contrived at best and useless at worst. While I like the idea, it's just not feasible in a lot of code bases where the things you are checking for are inherently more complicated that conditionA and conditionB and returning some stuff. And if that's your case, maybe you have a bit of a code smell that you could refactor some other logic. Take his example, you could avoid his terniary nesting and just stick with the early return: if (!conditionA) return valueC; return conditionB ? valueA : valueB; Instead we get the weird chaining. Oh well. 
From [wiktionary](https://en.wiktionary.org/wiki/game#Verb) &gt; 3. (transitive) To exploit loopholes in a system or bureaucracy in a way which defeats or nullifies the spirit of the rules in effect, usually to obtain a result which otherwise would be unobtainable. &gt; We'll bury them in paperwork, and game the system
I've been doing Angular my entire career (started in 1.3 and now am using 5), and I absolutely hate React. I cannot stand it. Having the html in the js files is excruciating to me. It's hard to follow the flow of the code. I know Angular has its flaws (making capitalization matter in the template, for one), but at least the majority of the logic stays in the js, and the html stays in the html (although, yes, there is a chance to put it in the component, but it's not common that people do it).
One man's best practices are another's stolen ideas.
I can't agree at all. Go look at the code for Vuetify. Find the templates. Vue allows you to use multiple methods, and that includes everything from Vue templates to JSX to render. It allows for you to have the flexibility you need for your project.
For anyone looking, [Maximilian Schwarzmüller](https://www.udemy.com/user/maximilian-schwarzmuller/) has courses on all 3 on Udemy, though I've only taken his [Vue](https://www.udemy.com/vuejs-2-the-complete-guide/learn/v4/overview) and [React](https://www.udemy.com/react-the-complete-guide-incl-redux/learn/v4/overview) courses. They are excellent and Vue has a low learning curve. It's also similar to React in many ways so a lateral move is not that hard. I spent a lot of time in Angular 1 and felt a bit hoodwinked back when the Angular 2 announcement came out. I felt as though I wasted an incredible amount of time with Angular 1 (now referred to as AngularJS). It may sound petty, but I've moved on from Angular. However, *if* I were looking for Angular, I'd surely buy Max's course on Udemy.
* Please whiteboard out Netflix * No React!
The news papers that appeal to the less educated demographics do this as well. 
Vue gets a lot of hype and for good reason. But that doesn't mean people have just stopped using React, to the contrary in most metrics it still far outmatches Vue. But people have less reason to hype React because everyone already knows about it and when your goal is clicks over content you go for the newest things.
Seriously, I keep my finger on the pulse, but I'm still developing in Node 4 (though hopefully we're bumping that to 8 this spring) and Angularjs 1.x
It's a classic
I'd say moving between React, Preact, Inferno and Vue (which is the furthest from the other 3) is quite a simple practice. "How long" will depend on how well (and how close to Vue's approach) is the React / Preact / Inferno app structured and the sheer size of the codebase obviously.
Thanks, yeah it's a pretty powerful tool. I still typically like to debug my React code in the browser, but it can be really handy for me when trying to debug unit tests (instead of using console.logs everywhere!)
With IntersectionObserver API, which is unsupported in Safari and IE11. https://caniuse.com/#feat=intersectionobserver
Yeah, I figured it would be a generally hard question to answer. I'm not planning any moves in that direction, but it's useful to have an idea of whether they're so ideologically different it's just painful. Thank you :)
Nice, I really liked the first edition of this book. Cool that it keeps getting updated!
It's the same with Dutch default keyboard settings, which is the US International layout. However, if you add the US English layout, you can quickly switch between them with `Windows` + `Space` (on Windows 10). The latter layout is my "code writing setting", giving me the exact behaviour I expect while coding. No accents, no double key presses. Hope this helps!
Just refer to them by name (single quotes, double quotes, backticks). The SwiftKey layout I'm using on Android has all 3. The backtick is buried 3 levels deep, though.
&gt; jsperf doesn't show any performance difference There probably isn't a good way to measure parsing speed via JSPerf. In your benchmark, the parsing probably happens only once.
I think not including an HTTP module and opting for `fetch` is fine. But I think providing it is just a fine. It's one the easiest modules to make optional, so treeshaking isn't really much of an issue. The trade-offs in my mind are: fetch doesn't give you progress/abort hooks, and it doesn't handle querystring serialization. Also a compliant fetch polyfill isn't necessarily smaller than a XHR-based util. The upside is what you said: it's a transferrable skill. Also, it's a very good option, size-wise, for Chrome-only intranet apps. Sometimes it's ok to make some trade-offs, sometimes you can't.
Teachers taught 3 sentence paragraphs so they knew you would need to put effort into writing 5 paragrpahs. There is no real minimum or real maximum. It's all just style, under the broad idea of one idea per paragraph. But marketing blogs have been doing that for 10 years now and I hate it.
Thank you!
He can't, because it's not.
I've got a simple one if someone would like to take a look. https://github.com/bgk-/pokemon_showdown
Checked out the google examples already. Not much idea about DOM manipulation, I will look into it. Thanks
I started with React in my spare time, then when I took a role at a company they were early adopters of Vue. I was blown away. I occasionally do some React but more for fun. In London at least, there’s a lot of Vue work coming through. This makes me happy! To have 2 healthy frameworks is great. I’m sure Angular has its place but the wait for Angular 2 killed me. 
Are you at least active in using the knowledge you already have? If not, that should be your first step. If you are, and nothing interests you enough to stop and learn it, perhaps that's good enough? Learning skills that the community tells you to learn isn't going to be any more engaging than learning the skills you've already decided you should learn. That is to say, it'll be boring. You have to have motivation to learn new things, and nobody else can provide that motivation for you.
"Signalling intent" is an incredibly important aspect of programming, BUT not all intentions matter. The whole point of signalling intent is so that when you or a co-worker come back to that code a year from now you can understand what the author was trying to do. But backticks vs. quotes tells you NOTHING useful about what the author was trying to do. A string is a string is a string, and whether the original author thought about throwing a variable in that string (but didn't) isn't a useful intention to share.
What about directives?
Try reading r/javascript
If you only have a small bit of JS experience, you should aim to get a big bit of experience before sinking your teeth in frameworks. Just my 2c.
Well explained.
It's not a motivation issue at all, I was helping out in the community a lot more and started mentoring the youth at my local temple. But I don't code outside of work which is the problem. I wanna get caught up with the community because I know that it'll have a promising future. I could have stuck with PHP but I listened to the community about going towards JavaScript and I have never been better. 
Can you expand on the last 2?
IANAL But, if you publish it to GitHub with an open source software license, then that should be enough to prove copyright. The likelihood of someone stealing your app is slim to none. Usually web apps rely on some backend API which the user has no access to and you're not required to publish code for.
I'm looking to get into a full stack position but also don't have framework experience. What was your javascript experience/aptitude before taking that position?
https://stateofjs.com/2017/introduction/
Pretty familiar with most vanilla javascript, nothing fancy. Tbh my qualification was mostly "has degree, did some kind of coding internship, seems smart, eager to learn". I would suggest applying at big companies geared to teach new hires. That's where I'm at. Small webdev orgs or "startups" are going to be looking for someone who can contribute week 2-4, which you most likely won't be able to in a meaningful way.
https://btholt.github.io/complete-intro-to-react/
The React kool-aid in the JS subreddit is strong
What makes your app special that is difficult to reproduce? That’s the part you need to protect. Often, for web apps, that part lives on the backend and not in the browser.
Im lucky enough to have an hour or so most days. I have found myself learning about vanilla js, ruby, vim, databases and regular expressions instead - stuff that’s really useful for my job. I guess it just depends on how much of a specialist you want to be. I did do some React work a few months ago and feel out of date already! My plan is just to know js really well (got a long way to go) and hope the ecosystem settles down over time.
The author just takes it down temporarily until the morons leave. It's back online now.
Of course, those are only predictions: Async rendering in React looks like very difficult to pull. The architectures in game engines with smoother user experience and higher performance are different to the async rendering the team is trying to get with React. Wait and see. Sync models of execution have been ditched these last years in profit of async. But many use cases only expect to do one thing at a time but want the result as fast as possible. Think threads, machine learning, game loop, ... Sync flavored with multithread may make a comeback. I don't think sync will become a defacto new way of doing things, but we may see libs for specific use cases choosing not to rely on the event loop for managing concurrency. 
Yeah, that's fair. I'd say the HTTP module in Mithril is more geared towards someone who might reach out for axios. But as I said, with things being modular, it's really easy to use whatever you like.
Dig into regular JavaScript for a bit, play around with it for a bit before tackling something big. Possibly use JQuery, since you can manipulate the DOM and see your changes happen live. But I wouldn't tackle anything bigger than JQuery for a while
I thought it was 3 sentences maximum and each sentence had to have a series of #hashtags #attheend
So a secure excel sheet?
What trends do you expect to emerge?
For me, working on a personal project that incorporates one or more topics I'm not great at is my favorite way to get better at them. The stuff you'd like to learn really hits on a lot of points you'll run into when building a full stack app, so maybe think of a fun side project for yourself and take a crack at building it out. Something like a react/redux driven app that talks to a backend database using something like bookshelf or typeORM or even Firebase. Deploying to heroku is only one option but if you want to get your hands dirty you can set up your own server on something like Digital Ocean. Then dropping in an SSL cert with letsencrypt and tweaking some server settings will get your security in check.
Thank you. With Digital Ocean, I can get $50 credit as a student plan! Awesome!
It's weird how this article makes a strong case for Vue and then goes on to talk about Next.js without ever even mentioning Nuxt.js, which is the same thing for Vue (instead of React.)
I think the most interesting JS trend in 2018 might be building low level components for frameworks. These will slowly progress into building up UI much quicker than having to write the same boilerplate code over and over again. Contrast to how we had it before, we had fully featured libraries with a ton of configuration, and in the end had to modify the library anyway. I guess these were more akin to plugins than libraries. I think this peaked for many with Bootstrap, but for me it was when I spent a week modifying a jquery plugin, just end up writing it as a library architecture instead. Now this trend is originating from making building components easier and faster, but I think it will turn into something bigger, which is making site builders actually good for once in history. One of the most important trends we'll see I think is the importance of open source. It's now a staple of our community, but it is not always managed well. I think now we'll see much more contribution and organizations, rather than having 11 people working on the same thing, but not together. This also comes through when many people are doing open source at work, not just on their spare time. Another trend this year might be developers dropping support for things like IE11. There's no way anyone is going to fully support that browser until 2025. And then there's everything from the last few years that will just continue to improve because they are important goals, like tooling, improving programming API's, etc. The overall trend you could say the trend is just to make everyone's lives easier, and make developing with JavaScript an enjoyable experience.
thx a lot!
I tried vue after using react for a year or so, but couldn't find anything equivalent to higher order components which I love in react. I also really like the way react sticks to regular js structures which makes them much easier to manipulate.
Prove it. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [bgk-/pokemon_showdown/.../**pokemon.js#L24** (master → c9654e9)](https://github.com/bgk-/pokemon_showdown/blob/c9654e9b184d383d1ec0803425cd0305ce548765/pokemon.js#L24) ---- 
Thanks. Well async in react already works, and there is already data showing it's much better. You can read more here: https://github.com/koba04/react-fiber-resources
Also be prepared for setTimeOut and Interval questions!
`autocannon` is one I've used that's pretty easy and powerful. The `fastify` Node framework uses it for their benchmarking. It has an official CI version: https://github.com/mcollina/autocannon-ci
Take a look at the fallback methods of SignalR. It uses a few interesting ones and you might find something that works. https://docs.microsoft.com/en-us/aspnet/signalr/overview/getting-started/introduction-to-signalr#transports-and-fallbacks 
It's far easier to scan, almost like a bulleted list.
Hmm, I think it's harder to read because I'm trying to read it like they're speaking it. If it's a list it should be a list :p
Most people are horrible at time management. Youre not busy, you're just not trying hard enough. So yeah, you probably do have an extra hour of time. I mean, look at how much time the average person wastes watching TV: https://www.statista.com/statistics/276748/average-daily-tv-viewing-time-per-person-in-selected-countries/ Complaining about not having enough time while browsing Reddit is ironic. Many people on this Earth don't have the luxury to do what you're doing.
I feel like all the authors of these articles have never used Angular. Maybe it’s just me?
Good advice thanks
yes.
It looks doable but I don't think you can reach the same level of composability such as in recompose. I like that react hocs are just higher order functions which means I can use utility libraries like ramda on my components without any extra effort
Thanks for taking a look! That was definitely my thinking, there must be a better way. As far as repeated code I was thinking I could use a hash with "type" : "amount" and then loop through the keys and eval() the value (will eval accept variables?) const types = { "half_damage_from": "advantage2 /= 2", "double_damange_from" : "advantage2 *= 2", // etc } This wouldn't work, but something like this was a thought. But the nested searches through the arrays I'm stumped. Because each pokemon can have one or two of a possible 17 types, then they have six varying damage advantages/disadvantages for each of those which can include any number of those 17 as well. The api will return a damage_relations object in a call like this https://pokeapi.co/api/v2/type/6/ Any thoughts are appreciated!
&gt; Jest is also heavily associated with react This just isn't true at all.
I would set up a hash table of the types vs each other with a multiplier as the value. Remember x * 0.5 === x / 2 typeAdvantages.set('grassfire', 0.5); typeAdvantages.set('dragondragon', 2); typeAdvantages.set('firegrass', 2); Then it is as simple as looping each type, looking it up and using the multiplier (or pushing it to an array if you want other calcs like flagging if something will be super effective first). typeAdvantages.get(type+enemyTypePrimary); 
&gt; Is something wrong with me or is this company asking for too much? How could we tell that? 
No code, no help. It's as simple as that. We can't point you in the right direction from just "it doesn't work". Post your configs as a Gist so we can see what you're doing.
Startups / small webdev biz's typically are looking for a senior developer at junior - mid ranged prices. I absolutely hate looking for a Jr dev job and seeing 3-5 years experience as a requirement. No that's not a Jr dev position. I applied to one a bit back and the manager emailed me back and flat out toldme they were looking for a jr dev with 5 years experiencing in c# :/
The author never used Angular. It is popular and growing fast. It's just that React is growing faster than everyone else. However total popularity isn't the only factor.
you wouldn't. Just take a look at popular projects these days. Jest is winning JS devs left and right. It mostly works and It's fastest there is.
Would be cool but Active Directory tokens are a pain and we also needed a few native plugins including barcode scanning.
I mean just based on everything I've gone through with the company, do you personally feel that the company is going overboard or is it just me? I'm just looking for some word of advice, encouragement, or validation that this hiring process is excessive. Or if you, yourself are currently in a company maybe share some issues that you have come across in the hiring process that someone like me wouldn't know about or consider.
can fork this to make JSCoin
lol. My internship was kind of similar. I had a college-junior-level knowledge of programming concepts, but no real practical web solution experience. I came in knowing basic javascript, Java, etc, and the boss had asked me about those in interview. Then I get into the job and what he wants is for me to make this web app which is a java backend which takes soap requests from his wordpress site. He had bought this java program that did whatever and wanted to turn it into a web app. Needless to say I was lost and it was basically a waste of both our time. But it helped me say I had an "internship" and now I have a full job so.. whatever.
absolutely yes :)
Yep. Learn the tech with much fewer job opportunities, it’s the single best use of your time.
Right. It’s so much better that it has essentially 0 mindshaee.
The Complete JavaScript Course: Build a Real-World Project is an amazing course. It is very clear and it goes very in-depth about the language. Good examples and a chance to practice as you go along. The final project is done very well to help understand everything that goes into coding. [https://www.udemy.com/the-python-mega-course/](http://the-complete-javascript-course.udemy.ltd)
No offense but you either must be new to this subreddit or not on here often. Everything in the js world is react this or that. Vue is just barely starting to get the recognition of deserves 
Eloquent Javascript! https://eloquentjavascript.net/3rd_edition/
No offense but I could say the same about you. Everywhere I look is “Vue this”, “Vue that”, just a bunch of counter culture tbh.
Too long didn't read
we first need to create a 1 year Roadmap for this effort, then market an ICO, then execute on what could be done over a weekend.
Hey, thanks! It's intimidating to see all these technologies that you feel you should know about! :) 
It will never go 100%
Wasm aims to provide means for developers to write code that needs to be very performant in a language that supports that idea like rust or cpp and execute it on a secure vm in the browser. This code can then interoperable with Javascript that is used to code high level stuff like ui. 
If you're a beginner, go with this one and don't look back. https://watchandcode.com/
The ecosystem is huge, and it's hard to choose what to invest your time in. Lots of these technologies are very niche, and are competing for a very small market share. Others are competing to be chosen in the industry. You're better off learning how to improve your actual programming knowledge, and once you know what your biggest challenges and needs are, then you can research which technologies can help you out.
I started with 30 days of react. I DO NOT recommend that, terribly organized. I've moved on to a somewhat outdated guide but I'm able to use other documentation to fill in the gaps. I really don't know what's the best thing to recommend. 
'Also nice 1yr account' - Lol I must have struck a nerve &gt;_&lt;
Nice emoticon, you a member of /r/creepyasterisks ?
They've done a lot to show interest in you. It's not you, it's them. If you weren't worthy of all that attention, you wouldn't have gotten it. It doesn't seem like they're in a rush to hire anyone, so don't be worried if it takes more time (it sucks for you, for sure, but if you're interested enough, hang in there). If they're looking at other people, it only means more time you'll have to wait until those people also get put through the ringer until the company ultimately decides who they want. Personally, I think 2 months is excessive. At that point you (as a company) will start losing candidates to other jobs. But this can also be an advantage for you if you can hold out where other candidates wouldn't.
I appreciate that you can use it with other web frameworks, but because it's facebook and how it started, there is imo a strong association is with React. From their docs: `Although Jest may be considered a React-specific test runner, in fact it is a universal testing platform, with the ability to adapt to any JavaScript library or framework.` My point is people won't consider using it with different framework particularly when the framework itself recommends something like jasmine - for example Angular recommends jasmine - https://angular.io/guide/testing. Of course you can use jest with other frameworks - https://facebook.github.io/jest/docs/en/testing-frameworks.html, but I think a lot of people associate it with react.
Don't do it. Don't try too hard now. You're getting all riled up over the fact that people like Vue.js lol
let's start working on a new organization on GitHub, this is my profile: https://github.com/thecreazy
Keep going, it’s cute!
https://media.giphy.com/media/rrLt0FcGrDeBq/giphy.gif
I use jest to test Vue and it’s incredible 
Just please, understand that people over the net CAN'T thell you if the problem is you or them, no matter how much we would like to be helpful. 2 months is a bit too much. But it might just be that they would want to hire you, but every time they have a slot someone just a tad better pops up. "They say they were impressed" doesn't mean much. In my company recruiters always say so, because even if someone is not ready to hire YET, they might as well be in say 5-6 months, so why not encourage them to try again. I wish you well and I hope you will keep trying, but we just can't help you much, sadly.
Thank you, it helps to be reminded that if they weren't interested in me they would've stopped contacting me by now. This long wait has put a huge strain on the finances but I can keep holding out, and will keep trying to for as long as possible. I also agree with your sentiment, at this point aren't they just loosing out on the opportunity to bring on the best people? Either way, thanks again!
They have to be part of the echo chamber or else face the hiveminds scorn. 
You made the initial statement, burden of proof falls on you.
Personally I wouldn't. We've used Jest to test Angular, React, and Vue as well as doing API testing with node and Express or Hapi.js. It works like a charm, runs fast, and is very easy to get going with.
No. I hate having so much html in the javascript. It makes a hard-to-follow flow.
Isomorphic Fetch Polyfill: https://github.com/matthew-andrews/isomorphic-fetch
If I use require in my ES6 library, can Babel still convert that down for ES5 for IE support? 
I said "the majority of the logic stays in the js." A directive is just an attribute added to an element. That's not a lot of logic in the html. In fact, I would consider that almost no logic at all. ngFor and ngIf would be higher in logic than a directive, I would think. Or are you talking about element directives in AngularJS? In which case, that's just a custom DOM element, and all of the logic is still in the js, and all of the HTML should still be in the template (HTML) file.
Yep, works fine. This library just extends [whatwg-fetch](https://github.com/github/fetch/blob/master/fetch.js) and combines it with [node-fetch](https://github.com/bitinn/node-fetch).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [github/fetch/.../**fetch.js** (master → 3abc04b)](https://github.com/github/fetch/blob/3abc04b28106d393ec24be0a95d39b342d4bd088/fetch.js) ---- 
That's kind of what it is in react though, you have components with a render method, which is your template. There's no html anywhere else, and you can even keep those in separate files. Really just depends how you want to write your app.
Sure thing :). But if you're financially hurting, you shouldn't stop aggressively looking for other jobs as well. If this one doesn't pan out, as clear as it seems they may want you, it could end up being a bit of a setback. And if you get another offer while waiting, you can use that (maybe) as leverage to force this particular company's hand. You don't want to be too aggressive about it, but if you simply ask for an update, letting them know that you have other offers and you can't wait much longer, that could (maybe) help them decide quicker. You just don't want to come off like you're trying to make them decide; it's more about letting them know that you will no longer be an option for them if they keep delaying.
I’ve got an angular project. Feedback is welcome. https://github.com/hackafro/angular-epic-spinners
About C++ target, take a look at LLVM
&gt; This is fundamentally wrong. The compiler knows the target, that's kind of its job. Your statement is fundamentally wrong. In general, any compiler must know its target platform. However, for C++, that target platform is not inherently virtual, like the JVM. The result of this fundamental difference is that a C++ developer cannot make assumptions with the same level of granularity as a Java developer. For example, if I'm writing C++ code and don't know the target platform, I have to go to great lengths to verify values like the sizes of integers, floating point numbers, and characters, as well as the *endianess* of integers. Java developers do not have to make any such assumptions. The sizes of various data types are well-specified and the JVM guarantees them. Of course the flip-side is that a C or C++ program can take direct advantage of the underlying hardware, which can increase performance greatly because 1) there is no JVM abstraction overhead, and 2) when the physical hardware is actually known, C/C++ can *bit-twiddle*. To this day, [C++ even still supports](http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2012/n3485.pdf) the `register` keyword. Optimizing compilers have essentially made this keyword obsolete, but I have written C code for platforms where it did make a noticeable difference in performance. In some instances, I have written C code that was every bit as efficient as optimized ASM code. &gt; You're counting on the underlying VM for performance. It is the one that compiles the bytecode to system code. Yeah, so what are you going to do about performance when the underlying hardware has 20 bit registers but your VM *guarantees* a 32 bit integer word size? The code will run, but it will run with horrible performance compared to native C or C++ code that has been written for the target platform with specific optimizations in mind. &gt; C++ is only for the MVP. The goal is to support a variety of languages. Qt is a C++ framework that adheres to the MVP pattern, but C++ is flexible enough to support **ANY** pattern, not just MVP.
&gt; my instincts say that the trade-off in application complexity for the relative performance gain will often be a net loss for code maintainability This is why WASM does not aim to replace JavaScript. Only performance critical code like the core of a game engine will benefit from the added complexity of having to compile the code for the web platform. That said in the future WASM will through the addition of a garbage collector be able to support a wider range of languages which in turn should make it possible to write web apps without JS.
I use it because I have to - Angular CLI user
I don't recommend mixing an `if` statement and the ternary operator for similar operations one after the other. I don't care which you use, but it helps to be consistent within a single chunk of code. This would be fine: if( ! conditionA ) return valueC; if( conditionB ) return valueA; return valueB; Or this would be fine too: return( ! conditionA ? valueC : conditionB ? valueA : valueB ); The latter is identical to the example in the article, but formatted in a way that I think is much easier to follow. The formatting of the ternary operator chain in the article is really bizarre - it's hard to visually see what goes with what.
react simple img is using IntersectionObserver :)
do you find the component simple and easy to use?
If all you care about is the fame and not the profit you should definitely consider open sourcing the projects. This will make your authorship claim very strong while allowing others to benefit and learn from your code. If are worried about someone stealing your work it is important to know that you can never truly protect any digital ip. Good examples of this are movies and tv shows that are available to download online the next hour after being released.
I took a look at LLVM a few years back. Although I liked the concept, I had a hard time getting it to work with my toolchain and gave up on it. Admittedly, I didn't try really hard because 1) I usually know my target platform and 2) in those cases where I don't I write my code with enough checks to catch problems (at those that I can foresee) at compile or runtime.
&gt; For example, if I'm writing C++ code and don't know the target platform Cool. The target is WASM. http://webassembly.org/docs/c-and-c++/ &gt;Qt is a C++ framework that adheres to the MVP pattern, but C++ is flexible enough to support ANY pattern, not just MVP. MVP means Minimum Viable Product. In the context of what I said, I have no idea how you got this confused with MVC. 
What the other guys in here said, don't let time bring you down, it's not on you. Keep on interviewing OP, sometimes not getting what you want opens up the door for better stuff! Take this as interviewing practice, which is a great skill to have for it lets you be comfortable and impress people without knowing much about them.
I appreciate your sincere reply, but your response causes me to ask my original question: *How is wasm better than Java in this regard?* The GC has been a fundamental concept from the very beginning when the language was being designed.
&gt; But GraphQL really shook things up for Redux, primarily when it comes to data fetching. How can people write sentences like this? It's kind of like saying that potatoes really shook things up for oranges.
I honestly thought his was a little too hold your hand javascript teaching. I ended up ditching halfway through, because I learned so much faster with other tutorials/reading the docs.
Because the GC is not yet implemented I think you should look for specific information in the github of the project starting at this issue: https://github.com/WebAssembly/design/issues/1079 If we assume however that the GC implemented in WASM and in JVM will be very similar a fundamental difference would still exist. WASM is sandboxed while JVM isn't. This is very important because websites can execute arbitrary code on your computer and that code cannot be free to do anything to your machine.
As I understand, wasm is intended to be used in CPU-intensive code such as games and visualizations. I don't think it aims to target the class of problems that can be solved by "looking at overall architecture and building an appropriate combination of back-end, middleware and interface to a framework running on the client" as you put it. JS has reasonable performance for web tasks, but if you want to do things like particle physics, and you're trying to really extract maximum performance out of JS, it's really difficult to reason about what's fast because the performance characteristics of the runtime can change from under your feet and there's no guarantee that these characteristics are even remotely similar from one browser environment to another. For example, what happens with objects w/ 10 properties? Do hidden classes kick in? Under what circumstances do deopts occur? What about in Firefox or Edge? Who knows. I think the goal of web assembly is to provide primitives that are more similar to the primitives you'd see in C++, and with which you could reason about performance costs in a less abstracted manner.
Nvm I got it working, thank you so much.
&gt; Cool. The target is WASM. About that, I'll repeat the question in my previous post that you conveniently ignored. &gt; Yeah, so what are you going to do about performance when the underlying hardware has 20 bit registers but your VM guarantees a 32 bit integer word size? &gt; MVP means Minimum Viable Product. In the context of what I said, I have no idea how you got this confused with Model-View-Presenter, but you clearly have. Even though it's an extremely common term, I figured since you linked webassembly.org and wanted to talk about this, I assumed you had read some of the docs where "The MVP" is mentioned on nearly every single page. I'm guessing that you don't actually write code, do you? The only groups of people I know who use MVP non-ironically to mean *Minimum Viable Product* (and say it without rolling their eyes) are project managers and marketing teams. When I read through the docs and saw a few mentions of MVP with C/C++ as the target, my impression is that WASM wants to really appeal to C/C++ developers, but whomever wrote that documentation doesn't understand the very group they are targeting initially for their MVP. Just based on the replies in this thread, the more I learn about WASM, the more I think that it is just an exercise in computer science theory rather than a practical solution that any developers, nevermind C/C++ developers, would find useful.
I'm the author. This was inspired by a recent conversation here on reddit, and my long winded response seemed better suited for a blog post.
https://github.com/michalczmiel/vinci Node.js todo Cli Commander, Flow, Babel, Jest
Your answer here is very helpful to me. Thank you.
Pick one and stick to it. I would recommend react because it’s the most popular by far, and it will make you a better programmer, by thinking more in functional programming and about your data flow. 
Hey Javascript folks. The server source code is available here: https://github.com/wybiral/noscript-chat -the developer
It's not a framework.
&gt;I'm guessing that you don't actually write code, do you? You have nothing else, so you're attacking my credibility when you don't know an industry term that is used extensively in the documentation for the standard you're arguing against? Nor do you seem to click on references since I linked the page where they described their MVP. &gt;he only groups of people I know who use MVP non-ironically to mean Minimum Viable Product (and say it without rolling their eyes) are project managers and marketing teams. And the WASM documentation. All you have to do is click on the documentation, which you have clearly not done given the pathetic arguments you have tried here. There is not "some mention" it is mentioned several times on every single overview for every single section of the documentation, I have also provided links directly to where they explain their goals for the MVP and Post-MVP phases. http://webassembly.org/docs/high-level-goals/ http://webassembly.org/docs/mvp/ http://webassembly.org/docs/future-features/ It's even given it's own section on the guidelines for C/C++ Developers page, which I figured you would have **at least** read since you claim this as your area of expertise. (which I've already linked) http://webassembly.org/docs/c-and-c++/ Had you read any of this at all, there would be no confusion for what MVP was meant for. You are the poster-boy for Dunning-Kruger and in the face for being called out all you have is to attack the credibility of the person calling you out. Childish and pathetic. 
I used to subscribe to the notion that all functions in JavaScript were closures. Afterall, they all had the _potential_ to be. But now I only consider functions that refer to non-global free variables to be closures. I'm pretty sure functions used to capture all parent scopes in full, but I think that's been optimized out in newer engines. So, for example now, during a debugging session, if you try to access free variables within a function from a parent scope that are not already closure variables in that function, you'll get an error since those variables aren't available. Globals are immune to this since all functions have access to the global scope. But if you have a function that doesn't capture any free variables, is it then completely isolated and not a closure? I would say so - global still being the exception. And maybe global still makes a case for all functions since functions carry that over crossing realms, right? But what good is the term "closure" if it's just synonymous with every other "function"? 
Yeah a closure is about persisting the variable in its local block scope. Neither of the last two examples contain variables that are scoped to a block, they're global scoped.
I want to play too!
What I don't understand is the "why" for mining a new block, what is the significance of asking people to solve some arbitrary problem? Why are new blocks not just created after a certain time interval or when the transaction array has reached a certain length, for example?
Rule of thumb: if you don't hear back from a company, call them after a week (not email, call them). It's fairly common that a company doesn't have dedicated HR and whoever was doing the interviews got busy and forgot to follow up. When you call, ask when they'll have a decision. If they don't respond by that time frame, call them again. If you called and they are giving you a wishy-washy response, move on. Some comments specific to your situation: "2 code challenges, several video interviews, 3 rounds of follow up questions, then more video interviews and an in-person interview over 2 months" is far too many rounds for a junior position. Ask them for a decision pronto and be prepared to move on.
Thanks for the input
I've been in the game long enough to tell you that this isn't as confusing or "bleeding edge" as it looks. Most of this tech has been around for a while. JS developers like to try out new ways of solving an old problem on top of it, which is why it looks like the ecosystem is unmanageable. I was gonna write out point-by-point what's going on, but that became too much so here's a quick summary: 1. lots of this tech has been around for years. Vue 4+ years, React 5+ years 2. lots of this tech is fairly easy to learn and displaces existing solutions, if you need it. eg. Prettier, Jest, Parcel 3. a bunch of the points are for developers that require specific solutions for specific problems. eg. Apollo, GraphQL, 4. half of this stuff talks about updates to existing technology. Eg. webpack, babel, typescript, flow This shit feels overwhelming but it's really not if you partition it. JS culture is very much centered on building new creative solutions for old problems. We're addicted to seeing what other people come up with. I used to be a WP developer, and you could write just as long of an article about "exciting new things in PHP". So for instance, here's my stack at work for the front-end: - AngularJS/Angular hybrid (converting legacy app to a new app) - TypeScript (JS with loose-ish types, part of the build toolchain) - Webpack + Babel (build toolchain) And for back-end: - Express (back-end framework) - ObjectionJS (ORM) 
&gt;The new stuff that's coming out, like javascript on native platforms, reason, graphql, ... you're not required to know any of it, but in some cases it genuinely can make your work easier. Yeah, you really need a *reason* to learn those. I don't think the trends you posted really paint the full picture but it's obvious that the three giants: React, Vue, Angular...are exactly that, giants. They're the frameworks to reach for if you're doing standard front-end dev. React is obviously the most popular, Angular has a specific-ish audience, and Vue is the underdog that people love using when they can. Most concepts are translatable almost 1-to-1 between them on top of it.
1. Comes into a thread for developers and tells an actual developer that his comment is "*fundamentally wrong*" 1. Actual developer explains why arrogant assertion is actually wrong. 1. Proceeds to ignore explanation then attempts to deflect by using an obscure (and fundamentally irrelevant) acronym out of context 1. Displays air of self-superiority and levels Dunning-Kruger 1. Gets pissy when asked if he's actually a developer 1. Hilarity ensues 
&gt; It's hard to follow the flow of the code [in React]. Lol. You can literally mutate internal component state in your Vue templates, not to mention change the entire state of the world through `$root` scope. Here's the top answer on StackOverflow for responding to onmouseover events: &lt;div v-if="active"&gt; &lt;h2&gt;Hello World!&lt;/h2&gt; &lt;/div&gt; &lt;!-- lol what in the actual fuck --&gt; &lt;div v-on:mouseover="active = !active"&gt; &lt;h1&gt;Hover me!&lt;/h1&gt; &lt;/div&gt; I'd *love* to see your debugger step into that. 
The above implementation is not following the bitcoin protocol With bitcoin (or any pow currency), when you submit a transaction, it's broadcasted from one node to another (nodes stores uncommitted transactions and blocks). Nodes reject invalid transactions (ie: someone trying to spend more than they have). But sometimes you get double spend attack: someone trying to send the same amount twice but when their account only have enough for one. So it could happens that nodes disagree on which transaction is the valid one (generally they consider the first one they see as valid). When a block is mined and include one of the two transactions, the other transaction is then invalidated on all the nodes I hope I was clear enough, I'm really bad at explaining stuff ;)
Other things aside, I wonder about one thing on the `compareAdvantage` function. The argument `pokemon1Types` is actually never used.
Other things aside, I wonder about one thing on the `compareAdvantage` function. The argument `pokemon1Types` is actually never used.
Thanks, that explains some other things that were left out of the implementation. But that doesn't really explain WHY you need to have someone do an arbitrary problem to create the new node. Why can't someone just say "create a new node please"? Is mining just a way of rate-limiting node creation?
What's your basic background? Years of experience, portfolio, etc? Hard to tell w/o knowing what level you're at
I totally understand if you learn only what the top job asks for. That is a huge priority you need to weigh - sometimes out of your control. But also weigh time spent learning which also translates to a working result. For me I’ve been programming so long I see the trends come and go. In the long run, I need to find joy in what I do otherwise , everything gets boring way too quick. So long as I have the control, I will try to choose on the terms That I think matter to the project rather than follow the herd. 
Okay, well, 99% of Vue’s “innovations” are carbon copies of React. React also has more tutorials, more modules, and a stronger core team, which is the reason I prefer it. To each their own!
This bitcoin the proof of work is changing and is determined by the timestamp of the previous blocks. The goal is to get a block every 10 minutes so if the average gap (I don't know the exact implémentation) is not equal to ten the complexity is augmented or reduced The thing is no one should be trusted so we shouldn't let anyone create new blocks. The proof of work is to make sure that the blockchain is immutable (once a block is created it cannot be edited) by making creating a block difficult but verifying it easy (nodes will verify the validity of a block before broadcasting it to others) But there is a catch, if a group manage to get more power than all the others (51% attack), they could rewrite previously commited blocks... I think you would be interested in Nano(xrb), anyone can create blocks but it's not based on the blockchain technology
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/tck1AKI.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
React doesn't put any HTML in JS files. It is all JavaScript. *If* you want to, then you can use JSX to turn somewhat cumbersome function calls such as React.createElement("div", { aProp: "aValue" }, children); Into a nicer syntax: &lt;div aProp="aValue"&gt; {children} &lt;/div&gt; React, Vue and Angular essentially all result in logic and presentation becoming somewhat intertwined. Many people prefer the React approach of using functions to render elements over the Angular/Vue approach of having a funky custom DSL imposed into their HTML.
Thank you! Interviews don't scare me, I used to be a Teacher. Everyday was an interview for me lol. I'm really good at talking to people and I typically give a pretty good impression and get good reception from employers. I'm waiting to hear back from other companies but, this one is my favorite and I've invested so much time into them!
Yeah, I've been actively applying this whole time. I recently got some traction in the job hunt and my bootcamp invited me back for another career fair where I got some leads. Right now I have this current company and another company that seem the most promising. I have 2 other ones I've interviewed with but haven't heard back so I sent a follow up to see what's up. I'm really hoping for the other company to say yes so I can kind of push this company into making a decision like you said. The co-founder did ask me about other companies when I went in last week so I was very honest and told them about everyone I was interviewing with. 
&gt;Implementation-Defined Behavior &gt;Most implementation-defined behavior in C and C++ is dependent on the compiler rather than on the underlying platform. For those details that are dependent on the platform, on WebAssembly they follow naturally from having 8-bit bytes, 32-bit and 64-bit two’s complement integers, and 32-bit and 64-bit IEEE-754-2008-style floating point support. Which will lead you here: http://webassembly.org/docs/semantics/ I don't remember claiming to be a C++ developer. I have worked on converting projects from C++, but I have not written it since college. So I'm not sure why you think throwing some edge case at me is some kind of bizarre proof of me not knowing the intricacies of low level design in a language I have not written in almost 15 years, then so be it. If this doesn't answer your edge case question, then you should raise an issue on GitHub or try to find it in the documentation, like a developer who is actually interested in the answer would do. Instead of asking an enterprise application developer about fucking processor registers.
Do you really think no one audits the dependencies? On another note, the size of jest and it’s dependencies means almost nothing. The code doesn’t get packaged into your app bundle. I’d download a bit more megabytes for ease of use.
The reason is security. This is an oversimplification, but let's say you are trying to compromise the blockchain. Then you need to find a better "nonce" than the people who created that block in the first place. This would mean that on average, you would need more computing power than everyone else trying to find a nonce, or you could just luck out, but this is extremely improbable. So they distribute money to people who do this arbitrary problem to make sure there is more computing power on the mining side than the hacking side, which will create incentives to do the right thing. Then you make the problem hard enough to solve so that you don't have to give away too much money too quickly and the currency doesn't lose value.
Flow isn't sound either. For one, it doesn't check that fields are initialized before being used: https://github.com/facebook/flow/issues/650 When designing a type system, there's a tradeoff between bugs prevented and restrictiveness. In this case, Flow's designers probably decided they didn't (yet) have a good way to catch this bug without making the type system too restrictive. And "too restrictive" is a subjective measure. Haskell users are probably more willing to work with a restrictive type system in order to prevent a larger class of bugs. When Typescript started out, the average JS developer was not used to working with a type system and so being too restrictive might have hindered adoption. I was disappointed at the time, since I was used strict type systems, but I could sympathize with their decision. Fortunately, Typescript has been steadily moving towards being more sound over the years (--strictNullChecks, --strictFunctionTypes, etc) and I think it's in a much better place right now. Another problem with talking about "soundness" is that it's not an absolute property -- it's relative to some defined type system. For example, Flow's type system doesn't distinguish between integers and floating-point numbers, but that doesn't make it "unsound". However, in Java this would be unsound because the type system is precise enough to distinguish between the two. (And Python could be considered sound under a trivial "unityped" type system.) But, for the programmer, whether the failure is in soundness or precision, they both suck. Basically, it's not useful to talk about soundness without talking about precision. And it's not useful to talk about either of those without considering the restrictiveness tradeoffs. When comparing Typescript and Flow, the difference is subtle enough that it's more useful to show some code and see how the two of them handle it.
Ok, ok. Everybody thinks they better than the other. We get it. Can we be nice now? &gt; what are you going to do about performance when the underlying hardware has 20 bit registers but your VM guarantees a 32 bit integer word size I'm a bit confused. Is this a realistic scenario? Wouldn't the overall browser performance for this platform be utter crap to begin with? Can you even build a major browser on a 20-bit architecture? Would anyone actually want to?
Haha you're right! Since I take the types and get the matrices from it I don't need it in that function
I can't see anything immediately wrong, but it's been a long time since I've used Grunt. Maybe someone else with more up-to-date knowledge can chime in.
&gt; Is this a realistic scenario? Wouldn't the overall browser performance for this platform be crap to begin with? Can you even build a major browser on a 20-bit architecture? Would anyone actually want to? Good question. I've worked on many *weird* architectures over the years, so I don't immediately assume that I'm going to be working with native 32/64 bit systems. I have seen and developed browsers implemented for specialized architectures such as medical devices, scientific apparatus, low-power devices, *etc.* that were not 16, 32, or 64 bit. When I hear `asm`, I immediately think of these kinds of applications. Perhaps WASM is not the best choice of name for a project whose goal is to make a virtualized target platform that is theoretically more efficient than optimized JS but not as efficient as ASM/C/C++ and targeted at only x86/x64 architectures?
They haven't ghosted you if they're still asking you to come in and interview. Just make sure to keep all of your options open. You shouldn't let this one company derail you from interviewing at other places. You can also use another offer to force them to fish or cut bait. So, keep being nice to them because they'll probably make you an offer once you have another offer and then you'll have 2 offers which you can use against each other to negotiate in your own best interest.
Then the ball is in their field and they better not drop it! Best of luck!
These guys should really take a look at GraphQL. They'd see that their library may simplify REST slightly, but it doesn't bring any of the awesome features you get from GQL.
From what you've said, your dev is telling the truth. It's part of an e-commerce site, it probably runs entirely in a repo which has dependencies and a deploy process, and may be complex, entirely depending on whomever set it all up. But this is exactly the sort of thing that a web dev should know or be able to figure out. So, yes, it's possibly not a walk in the park depending on a lot of factors, but also, it sounds like a pretty standard task.
It sounds like you're talking about react? `super()` runs the constructor of the class you're extending. If it's the React.Component class, React claims that it needs props, even if you're not passing down props in your hierarchy. I'd listen to React: https://reactjs.org/docs/state-and-lifecycle.html#adding-local-state-to-a-class
I'd bet the code is spaghetti of weird jquery plugins, so probably changing anything on that site is a complex task. A good developer who knows the codebase should be able to pull it off in half a day if he/she doesn't get distracted with needless refactorings IMHO.
Udacity has amazing mentors if you enroll in some of their programs. You can chat with them real time when you need help.
&gt; React kind of attracts a lot of functional oriented programmers. Vue attracts a lot of people who’d prefer the more classic HTML, CSS &amp; JavaScript model of development. And Angular attracts a lot of people coming from a Java or C# enterprise background. That's a good way of summarizing the differences between the big 3 frontend frameworks (React, Vue, Angular)
If you cannot make simple changes like that you have a serious problem. Either your dev is being honest with you and your architecture/process is severely broken or your dev isn't being honest with you and are likely incompetent. Either way you will need to dig into the problem cause and fix it (not the code). This is more a managerial and architecture problem than a coding problem. Once you have addressed the problem you can work out the coded solution.
Try again, i adjust the percentage, now is more precise.
&gt; Perhaps WASM is not the best choice of name I guess `web-bytecode` didn't sound cool enough ¯\\\_(ツ)_/¯
Rather simple. Blockchain technology was created because of Bitcoin to create a digital currency. As a store of value, among the features of a currency is scarcity. Block mining and the concept of proof of work are a means to create digital scarcity, because mining (solving problems) takes time and resources. If you could just say "create a new block please" how else would you induce scarcity in the digital domain? Without scarcity there would be no value.
Doesn’t work on my iPhone. 
That's not the fault of Jest though. That's the fault of the community.
Your article doesn't dive into scope nesting, which is commonly referred to as *scope depth* or the *scope chain*. In order to understand closure you need two things: 1. nesting of scopes 2. access to a reference from a high scope in the nested scope The quickest way to illustrate this is to call a global reference inside a function, but this is too primitive for many people to really appreciate the concept. Here is a quick example of something with an elaborate scope depth: http://prettydiff.com/?m=beautify&amp;jsscope=true&amp;s=http://prettydiff.com/lib/jspretty.js In that code output scroll down and you will see a bunch of colors. The colors indicate a scope at a given level of nesting and the references declared at that scope level. You can also see references that are of one color used in a nested scope of another color. That is a reference *used in closure*. Many developers claim their favorite language has something like closure. The one true test is whether you can assign a value to a reference used in closure and ensure that reference actually did change to the newly assigned value later in its local scope. This guarantees the references is not a cloned copy provided into the nested scope for convenience. JavaScript has this, but most languages do not.
We’re most likely switching to jest at work. We use angular cli, so you can use jest with angular 2/4/5 :)
The Firefox debugger is garbage. I regularly have to wait minutes for it to load the source from a source map when it hits a breakpoint. 
I use it for node testing and React. It’s easier for or less experienced devs to learn a single api and it meets ourbackend unit testing needs.
Quiz answers ( / answer weights) should *not* be viewable client-size for any reason - anyone with a bit of smarts can glance at the source code and figure out which answers to select. Once all questions are answered, they should probably be bundled into a request for something on a server to analyze and grade, which can respond with the results. Array methods are generally better to use than for loops; they're more elegant, more chainable and composable, and provide better abstraction. Assigning to .textContent is generally safer to use than .innerHTML. If you want to create elements, it's probably better to do so explicitly via document.createElement. In checkAnswer(), you should make sure that at least one answer is checked; you could use .some() to accomplish that. I do hope that this is for a homework assignment of some sort rather than an actual client.
Your mental bridge from C++ to JavaScript: https://github.com/Jeff-Mott-OR/javascript-cpp-rosetta-stone
I'm not sure you read the article closely enough. Every code example in there has nested scope. And a nested scope accessing a variable from an outer scope doesn't necessarily imply a closure. I mentioned and linked to C code specifically to make that point. You also briefly touched on but then breezed right past the main question of the article. &gt; The quickest way to illustrate this is to call a global reference inside a function, but this is too primitive for many people to really appreciate the concept. This was literally one of my examples in the article. Does an ordinary global function accessing an ordinary global variable count as a closure.
&gt; A common misconception many people have is that closure is a phenomenon specifically confined to functions. What led you to believe this is a misconception? Do you have an example to demonstrate?
Is this really all required for a junior position?
Too be clear, a decision doesn't need to be "hired" or "not hired". It can be "we would love to have you on board in 3 months, when project Y is starting", or "we are talking to other candidates, we'll reach a decision by X date and let you know." But you need to ask them to spell out their hiring process: the number of steps, where you are in the process and when you can expect a decision. Also, at this point, it's really not unreasonable to ask the co-founder what's the deal with the 2 month long hiring process, because it definitely isn't a standard time frame. It's somewhat unprofessional, even. If the problem is that leadership keeps second guessing, I'd consider that a red flag. Don't think you have some obligation to keep with this company just because you already put that much time with them. Chances are that they are just disorganized when it comes to hiring, and if that's the case, perhaps the best thing to do is to write to the co-founder and give him the whole I'm-enthusiastic-and-would-be-a-great-fit-do-I-get-the-job speech to try to force him to show his hand.
Is there space for one more? 
I am building 0xbitcoin and I realized that the hash doesnt have to start with a certain number of zeroes 'per se' to be a solution. The difficulty target is simply a 256 bit number (uint256) that gets bigger or smaller and the hash, when interpreted as a uint256, has to be SMALLER than the difficulty target. What ends up happening is you see lots of zeroes. 
Examples, but I just checked the source and now see what you mean.
It isn't even just to create digital currency. Its to create a decentralized cloud server and so much more. I.e. Ethereum
When I inspect the contents of packages, I routinely find things that shouldn't be there, like build artifacts that were unwittingly included due to misconfigured npmignore files. People aren't looking at the contents of the packages. There's a high probability that something malicious deliberately added to a package would evade detection long enough to do serious damage. Many developers who publish packages on npm are using incredibly poor security practices. I encourage you to read this [report](https://github.com/ChALkeR/notes/blob/master/Gathering-weak-npm-credentials.md) by a researcher who found that he could compromise as much as 54% of the npm registry by exploiting leaked or trivially brute-forced passwords.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ChALkeR/notes/.../**Gathering-weak-npm-credentials.md** (master → ffd4826)](https://github.com/ChALkeR/notes/blob/ffd4826ac9c40cce4f5ab893d39d4cfeba926fd0/Gathering-weak-npm-credentials.md) ---- 
&gt; I have seen and developed browsers I meant `build a major browser` in the sense of compiling a mainstream browser that has manpower behind their web assembly implementation efforts. For example, from a glance, Chromium only seems to build in the handful of mainstream OSes: https://www.chromium.org/developers/how-tos/get-the-code If you're building something custom that _requires_ C++ level of performance, then... why go through the trouble of implementing a browser _and_ the web assembly spec on top of it?
This video gets into detail about the why and the how: https://www.youtube.com/watch?v=bBC-nXj3Ng4
Yeah I'm reading the book on Bitcoin by Andreas Antonopolis it's great. Also that methodology of course allows for more possible difficulties .. like higher resolution ! Pretty genius stuff 
Closure is achieved when a reference is accessed in a scope where that reference is not declared. The concept is called *lexical scope* and closure is a demonstrated instance of lexical scope. Here is where the term *closure* comes from: https://en.wikipedia.org/wiki/Closure_(computer_programming)#History_and_etymology Specifically, a child scope is closed over from the current local scope so that it has privacy apart from references and declarations in the local scope. Qualities allowed by closure: * Privacy - https://en.wikipedia.org/wiki/Closure_(computer_programming)#State_representation * Currying (delayed execution) and environmental structures - https://en.wikipedia.org/wiki/Closure_(computer_programming)#Other_uses Because JavaScript has closures as a native concept it doesn't need a `private` keyword to achieve privacy as do languages like Java and C#. These are the common misconceptions around closure: * Closure must be functions, because the latest spec calls functions closures. Functions are closures, and prior to ES6 closure could only be demonstrated with functions. ES6 brings block scope, that allows scope in blocks that cannot be referenced. Closure can be demonstrated in a block when a blocked scoped reference is assigned to a reference declared in a higher scope. * Closures must be functions because you can reference a function but you cannot reference a block. It is true that all functions **must** have a reference (except of IIFEs) and that blocks cannot be referenced, but this is not determinate as to whether closure occurs. * Closures are only present when you return a function. This is a pattern called currying. Yes, it is an example of closure, but that does not mean closure is limited to this example. You don't have to return anything or delay execution to have closure.
It's complete physical value is turning energy into currency. In the next 5 years, you'll see both dirty and clean block chains. Bitcoin is the dirty side.
My original post was designed to elucidate this very issue. Based on what I've learned from this thread, I'm even less enthusiastic about WASM than when I first posted my original question. I guess that having more tools in your toolbox is better than fewer, but the use cases where WASM are advantageous seem to be very narrow. If ultimate performance is the goal, use `asm`, `C`, or `C++` compiled for the target platform. If those aren't required to reach performance criteria specified by an SLA, use JS. WASM appears to fit somewhere between, but only on x86 or x64 hardware. I do like that it can run sandboxed in the browser, but I'm just not sold on it being useful to most web developers. I'm guessing that it'll find the most use on mobile devices, but again, if I can't solve a performance issue with JS and a middle tier is not an option, then, if I'm writing for iOS, I'm likely going with a native Objective-C app, but if it's for Android, then I'm going with a native Java app. I know that C and C++ can also be used to develop Android apps using the NDK, but that approach seems to be non-standard.
https://stackoverflow.com/questions/42002777/cors-facebook-passport First search result for "CORS Passport".
Not at all =&gt; he's asking for boilerplate code that you would add to... We use this all the time in my work (saves a ton of time and keeps practices consistent).
Writing graphile will make graphql acceptable
I misunderstood him then. Do you have a link to what you use? It sounds like a major time saver.
Yayyyyy!
This is es6 syntax. It's part of object oriented workflow. The constructor method is basically for code that needs to run before the rest of your code. The super is....I forget. I'm watching Netflix
So here is the nice thing I've found, since I've used many of the different methods. Creating a component that's going to need more logic? Use the rendering method. You'll have more control and avoid that template hell. Want to get something everyone will understand quickly or only need a couple of lines of HTML/template code, use the templating. Everything in between depends on use case and audience. Hell I've had projects where I haven't been able to use anything but script tags, no compilers like Webpack, and had to use templates in script tags. Thankfully Vue allowed me too. The nice thing about Vue is it's flexibility. You sound like you know what you like or need. Shouldn't the framework allow you to do that? 
In JavaScript land, every framework shakes things up you don't even know what the framework does anymore.
Phaser, I was playing with him a lot 
It's not hard at all. I'm a full time Dev on bigcommerce sites. I was going to help you until I saw that you literally stole the footer design from one of the sites I made. Shame on you
This result is of no help, my fault really, I should have mentioned that I do in fact have cors running and am still receiving this error
What per-say would my header have to be though? Is there a list of 'non' custom headers? I see in that documentation 'headers: {'X-Custom-Header': 'foobar'}' Does that mean I'm supposed to do 'headers:{'Access-Control-Allow-Origin':'true??'}
This sounds like a CORS (cross-origin resource sharing) issue, and it sounds like your server needs to set `Access-Control-Allow-Origin: ` to something. See this question for way more detail: https://stackoverflow.com/questions/20035101/why-does-my-javascript-get-a-no-access-control-allow-origin-header-is-present
What was the bootcamp? Was it online or in person?
You're not wrong, Walter, you're just an asshole.
I'm sorry, can you explain that? I'm not quite understanding what that does.
 while (!op.hired) { for (job of jobs) { job.apply(op); } }
exactly, thank you. 
This is one of JS. iggest warts. Dart fixed it, and libs like datefn and moment help too.
wasm is meang for games anf apps like photoshop. Apps where speed is essential and fps must be high. wasm will never replace webdevelopment in a traditional sense. think of wasm as a subset of js with additional integertypes etc. Its a target platform not a platform you code on directly.
This is slightly off topic, but I discovered today that the redux devtools has a testing tab that will generate some boilerplate for testing reducers. It might do more than that, haven't had the chance to dig in yet. As far as react components go, if something like this doesn't exist it seems like a nice side project to work on 😁😁
Check out https://www.nimiq.com, very polished js code base.
If you want to access this.props in the constructor, you have to pass it to constructor and super. Otherwise you don't have to.
What's your goal? The value of knowing raw sql if your goal involves the backend can't be overstated. As far as the front end goes, if you want to dig deeper into react and redux I suggest looking at some advanced patterns like higher order components and render props. And he reselect library for redux. Reselect has been one of my most useful tools in a large scale production react app. Devops wise check out docker and set up a nice dev container for yourself maybe look into continuous integration with Jenkins or something. These recommendations come from what I've found to be the most helpful things in the growth of my company and myself.
Just use .filter to capture only the first occurrence of the stringified object https://jsfiddle.net/j2664ug2/
Awesome thanks!
True I guess, it doesn’t exactly walk you through it, but they’ve got pretty good docs around OOJS that I think a beginner could follow. But you’re right it does assume at least a basic understanding
Are these elements already in a JSON array? If so you could use reduce. Something like: oldArr.reduce(function(arr,a,i,old) { if (old[i - 1] !== a) { arr.push(a) } return arr }, []) If not you would have to convert it to an array first.
 function removeAdjacentDups(arrayOfJson) { const deduped = [...arrayOfJson], toPropValStr = obj =&gt; Object.keys(obj).concat(Object.values(obj)).join(""); let i = 0; for (let elem of deduped) { if (toPropValStr(elem) === toPropValStr(deduped[i + 1])) { deduped.splice(i, 1); } i++; } return deduped; }
What about if I wanted to compare menuitem and menuitem?
The problem with that is that objects (including arrays) are only === when they're pointed at the same reference. [0] !== [0].
`deduped.splice(i, 1);` mutates the array while you're iterating over it; to make this work, don't increment `i` if a splice occurs.
Would this still work if I had a bigger array such as this? If I wanted to compare the name field? { "pagination": { "object_count": 33, "page_number": 1, "page_size": 50, "page_count": 1, "has_more_items": false }, "events": [ { "name": { "text": "Programming Design Systems", "html": "Programming Design Systems" "id": "33829488912", "url": "https://www.eventbrite.com/e/programming- design-systems-tickets-33829488912", "start": { "timezone": "America/New_York", "local": "2017-06-03T09:30:00", "utc": "2017-06-03T13:30:00Z" }, "end": { "timezone": "America/New_York", "local": "2017-06-04T17:00:00", "utc": "2017-06-04T21:00:00Z" }, "created": "2017-04-18T19:44:59Z", "changed": "2017-06-09T10:31:45Z", "capacity": 17, "capacity_is_custom": false, "status": "completed", "name": { "text": "Intro to Unreal Engine 4", "html": "Intro to Unreal Engine 4" }, "start": { "timezone": "America/New_York", "local": "2017-06-10T09:30:00", "utc": "2017-06-10T13:30:00Z" }, "end": { "timezone": "America/New_York", "local": "2017-06-11T17:00:00", "utc": "2017-06-11T21:00:00Z" }, "created": "2017-04-21T20:00:11Z", "changed": "2017-06-16T10:34:03Z", "capacity": 16, "capacity_is_custom": false, "status": "completed", 
In `.filter`, reference the current element's menuitem, then reference the previous element's menuitem, then compare them both stringified.
Thanks, but that didn't work with my example above.
I don't love using Vue when i can, i use it at work when i must. As someone has written above, Vue is an Angular 1.x clone, we've all been through that. The lip service and hype it gets is insane, unfortunately it doesn't translate into usage stats.
I don't know about Cypress.io but TestCafe works great for my purpose at work. Biggest Pro: It is free, not only while in beta...
Tell us something we don't know.
If you're the author section 5.1 looks like you might've stroked out writing it: &gt; 5.1 The Chain **Endopoint** &gt; This **andpoint** will **bel** very very simple. Just will return the chainarray stored inside the blockchain Otherwise well written, easily understood, and very concise article. 
&gt; No 'Access-Control-Allow-Origin' header is present on the requested resource. That means you didn't set CORS up correctly, then. To confirm this, it is as easy as opening the network tab in the developer tools and looking at the **response** received and see if the header is there or not.
You don't have to use them, but it's good to be familiar with their names and what purpose they fulfill in general sort of way.
Is it a workflow that's encouraged or does it have an alternative to JSX? 
are you sure? because their site says it's 499€ per developer on commercial projects [source](https://testcafe.devexpress.com/Buy/)
What is your favorite feature of GraphQL?
thx a lot, updated :)
Is it supposed to be Chain End**o**point and not Chain Endpoint?
Hey, You are either 1) not following everything to a T (double check that serverSide:true) 2) You are using a different version of dataTables, previous versions follow a different structure. Hope you figure it out. Post the code somewhere and I will take a look at it.
&gt; content editable If you haven’t already, read [why ContentEditable is terrible](https://medium.engineering/why-contenteditable-is-terrible-122d8a40e480) by the people at Medium. It’s the part of browsers that is IMHO the most not standard. Your problem sounds par for the course. One of the applications at a previous employer forced users to use compatibility mode because of some old content editable workaround code. We would find subtle differences between different windows updates of the same IE version. Even small tweaks to the doc type string messed with it.
they opened sourced it: https://devexpress.github.io/testcafe/ 
Thanks /u/JermoneWu, DOM manipulation is the answer to my problem, thanks.
Access-Control-Allow-Origin is a server response header so adding it on the request won't do anything. Just add that header to your server file.
I guess we'll all soon be editing our javascript code in the webbrowser. This is awesome.
I think this is basically what it boils down to. But I think specifically, it becomes important if you want props in the constructor and another component extends your component. If the component that extended yours didn't pass props through to super, your component wouldn't get any. As far as React goes, I don't think there's anything specific about `Component` that requires props be passed up to it. All it does is copies the argument into the member variable `props`. During mounting the original props are assigned back to the instance over top whatever was done in there during construction, and this before any of the lifecycle events ensuring props is correct in each of those. I believe starting with fiber (?) you'll get a warning if you implement a constructor and don't pass the provided props into `super`. So its expected. The docs do it, and so should you ;)
I guess since both Atom and VSC are Electron based, we already do. ;) But CSB is awesome for sure! Use it pretty much daily for swapping code around at work or in order to teach/show the implementation of something over remote. 
That's really great to hear! If you have any questions or feedback, don't hesitate to message me!
with node I've not seen testing with jest. Do you have any resources that show it? so far I saw people using mocha to test
These are always fun experiments but the use of Proxy should be limited in practice. One of its bigger shortcomings is compatibility with internal slots. And when private class members land - which use internal slots - that greatly limits the usefulness of the Proxy approach used in this article. Of course you could alternatively argue that private members will limit classes and their instances (:
I hope not. I was thrilled when .NET actively decided against it. It’s made me a multiple inheritance bigot. Of course, I’m also a major string bigot (hate them). Also, the Swiss. Also, termites. And J-pop. I’m a horrible person. :(
IE has *always* been different than every other browser on the planet. It's why IE is at the bottom of the browser pile after once having 95% market share. (Now it's 15% worldwide? I forget.) Edge is far better but is still slow to comply overall.
Yes, but why?
The Medium article presents some horrific security issues like **Cross-Site Scripting (XSS** and **Cross-Site Request Forgery (CSRF** and **Server-side JavaScript Injection (SSJI)**, but still the **[AI Mind](http://ai.neocities.org/MsIeAi.html)** in JavaScript is a lot more to be trusted than its Perl version **[ghost](http://wiki.opencog.org/w/Ghost)**.pl or its Forth version **[MindForth(http://dl.acm.org/citation.cfm?doid=307824.307853)**. 
ф
Evan never claimed to be the first one to invert vdom. He even had a talk at a react conf about how react and elm reached the same solution independently.
Thanks!
To eliminate build step?
Good advice. Many will say "have less dependencies", but this responds well to that: &gt; But the fact is, you need dependencies in order not to reinvent the wheel and to be able to use dedicated, proven, well-tested libraries and tools that somebody has already authored. Still, do what you can to _minimize_ dependencies when/where it makes sense and commit your lock files. 
too much "i made a thing!"
Interesting idea. The trouble is you make every client transpile at least once, and download the transpiler. I have used PHP SASS transpilers and found them to be useful. That is about the closest thing you won't get slapped for.
So you would rather have your user download a raw SASS file, parse it and then get the browser to re-render the compiled CSS, rather than simply compiling SASS beforehand and sending it down the line? Seems like an anti-pattern to me.
Probably. Though it would be introducing layers of complexity for little discernible benefit. CSS files can be big but are rarely the largest files you serve. 
At the end of the day it matters most that you learn how to learn, not that you learn the perfect stack one time and do that forever. That being said: 1. Node is definitely being used in production by lots of companies of all shapes and sizes. I was just at a Node meetup recently where a large, week known finance related company was a sponsor, and they are hiring Node developers. That’s an anecdote and lots of companies use other language, in many cases they use many different technologies over different products. So yeah, learn Node, but know that choosing it now doesn’t mean you are stuck with it forever. 2. Again, don’t get so hung up on the choice. Postgres is basically SQL, MySQL is old but great, and people may say that about Mongo and nosql but lots of projects use mongo in production (including my company), and it has its benefits and weaknesses. Probably you will end up using at least two of those in your career. There are Node libraries for all of those databases, in fact you’d be hard pressed to find a database that you can’t use with Node. 3. You should learn how to do this type of research now, because its going to be the most valuable skill you’ll have. Google is definitely your friend, if you google node MySQL you will find what you are looking for. A final thought: there’s nothing wrong with full stack as a concept, I’m a front end guy but I stand up smaller node projects frequently. However, the common pattern is that when you are trying to learn both sides at the same time, you’re more likely to have more weak points than if you focused on one side. Learn how to choose the right tools for you project, and don’t try to learn without having a project to build. No one is going to care that you made a Hello World app, but if you come up with a problem and show a potential employer how you solved it, that will be compelling. Good luck!
Postgres and Node will do fine for your first back-end languages. No doubt they will only be your first, so it's no matter whether you choose Node, .NET, Java or PHP. It's just a starting point. With the database though, I would probably recommend sticking to a traditional relational database until you're more fluent. The important thing is you learn the fundamentals of database management and how to write queries, etc. and both Postgres and MySQL are interchangeable in this regard. However I would still recommend Postgres as it provides some more interesting features later on. 
What? Yes... I tested it... it works fine.
What? It works just fine.. how did you implement it? Can you provide a stripped down version?
Technically yes. In reality, it’s a crazy dumb idea. Especially just to avoid a build step. JS would have to AJAX a raw SCSS file, parse it with some library, then re-render the whole page. That’s a lot of overhead for the users machine computationally and in terms of bandwidth. 👎🏼
The render method is in the javascript file with the html in it... or at least it has been in basically every React app I've seen.
Vue is for bad developers. 
Express and Postgres are solid choices, that's what I'd recommend. Where it gets a bit murky is when it comes to DB abstraction layers and ORMs. Personally I'm a fan of Knex which allows you to write DB-agnostic queries rather than going with a full-blown ORM.
&gt; and closure is an instance of a reference used across scope boundaries in lexical scope. No, it's not. { let a = 1; { let b = 2; { console.log(a + b); } } } Accessing a variable across scope boundaries isn't closure. It's just scope. The variables a and b and said to be "in scope", even in nested scope blocks. &gt; The stackoverflow answer links to a post by Douglas Crockford with a definition of closure. This answer agrees with the Crockford definition Crockford: What this means is that ***an inner function*** always has access to the vars and parameters of its outer function, ***even after the outer function has returned***. I don't think Crockford's definition backs you up here either. &gt; Perhaps you didn't read the part about History and Etymology. The term closure was coined due to usage in languages who made early use of lexical scope. It says closures were developed to support lexically scoped **first-class functions**. So no, wikipedia still doesn't back you up either.
Ah.. thanks. `toPropValStr(elem) === toPropValStr(deduped[i + 1] || deduped[i])` fixes the break. And yeah, I see what you mean on the second one and how not mutating can address it. Thanks!
this is awesome, we are planning on using CSB for an intro to React class in April. Splitting the group of students up and giving them their own ready to go sandbox so they can just focus on the code and not have to deal with setting up a dev environment.
I heard it firsthand when he was on the JavaScript Jabber podcast. 
Cordova and Vue play together fine.
*fewer ^^^&lt;/stannis&gt;
Postgres all the way. Instead of comparing stars look google for "why not mysql" or "mysql vs postgres" or cry at shit like this: https://blog.ionelmc.ro/2014/12/28/terrible-choices-mysql/
I think people get mad if you blame it on bad programming skills. I blame the widely accepted rule that rolling your own thingy is considered bad practice.
Were all to deeply frustrated to read more than one sentence before we judge.
this actually links to "http://the-complete-javascript-course.udemy.ltd/" which I assume is some sort of affiliate link
Also, last time around, it took me many months, and I got jerked around like crazy. I think it's normal now. Be a slut, two time your ass off. Never let them lead you on.
Why would you want to do that
What does your showMore() function look like? Any chance you could put the problem into a codepen?
The solution to all these choices is more choices? XKCD comic, please.
It could be useful if you want the variable values defined at runtime
Something is wrong with the hiring process for newcomers. Don't worry I'm in the same boat. Been to 5 final interviews recently and been rejected ultimately for all of them. Done code challenges, that's fine. Always get past the HR screen. Usually tumble in the 'spew definitions of concepts' technical screen. No result. I don't have the CS degree. I can code. I can be personable. I can't spitfire back textbook definitions to concepts though. There's also been cases where I've applied to a role that doesn't have x years requirement then find out that they were really looking for a mid-level dev. I don't have a solid answer for you but what I'm seeing where I live is a total lack of junior roles. I'll have to move and try somewhere else. It's particularly difficult for those of us who are trying to break-in to the field and we have non-tech related jobs on our resume. People in the field assume it's a piece of cake and if you're capable in any way even as a shitty coder EVERYONE can get a job, if not you're just a dysfunctional person, they forget how it was like when they didn't have the title yet; or, maybe the environment has shifted significantly even from 5 years ago.
See my comment above. Bootcamp grads like us are running into a brick-wall right now. Some of my colleagues have been hired, 50% of us haven't and it's been 90 days since our cohort ended. Some of them have had FAR less interviews than I have and have sent out 400ish resumes. I haven't done that because mostly doing that ends up being a black hole.
Also, the reason you didn’t get many relevant links for “node with postgress” is that you misspelled postgres. Google “node postgres” and you’ll get pages and pages of relevant resources 
I think its great people are making things, no one is forcing you to use their modules. Why hamper creativity or learning and publishing a module? Just don't use it if you find it problematic. I'll never understand this mentality. Aren't we developers because we like building things with code?
https://xkcd.com/927/
For everyone suffering from the NIH syndrome. 
Haha, I didn't think anyone would do it. Thanks! :D
&gt; What this means is that an inner function always has access to the vars and parameters of its outer function, **even** after the outer function has returned. That says **even** and not **because**. That definition is accurate if you read it for what it is. A first-class function merely means a function may reside at any point in the code grammar a primitive may reside. When functions are allowed in locations where they were never allowed before and they provide scope in locations that were never allowed before new means of reference resolution exist. &gt; It's just scope. That doesn't make any sense. Scope is a concept that applies to every programming language, but not all programming languages have lexical scope. Just because JS has lexical scope doesn't redefine the terms *closure* or *scope* in context to this language alone as closure is also a universal programming term that predates JS.
Here: https://codepen.io/anon/pen/ZrLJJe?editors=1010
For me it has nothing to do with skills. I think the fact is that we so many different platforms and with the pace of development being so fast, you simply want to outsource small functions to the "experts". Look at left-pad for example - at one point it was needed. Now you can use padLeft, if you use babel. Who has the time to keep up with all the changes? Instead you put the padding code in a micro-library, and then every so often you revisit it and if you can update it you do - and all your projects will be updated too next time they are build. Of course, there is a problem of trust, but it's not as crazy as it sounds
I just checked the part of that podcast where they talk about react and he didn't make any claims about it.
This is just someone shouting from a soapbox. Want me to listen? Throw me some examples or situations where the things listed became relevant so I can follow along and form my own opinions. This will then foster discussion, and everyone comes out learning something. As it is, it feels like someone who feels entitled to tell me what to think is.. well.. telling me what to think. Also a number of these issues are taken to their very extreme. Why does this page exist? 
Am I correct that you consider this... let a = 1; { let b = 2; { console.log(a + b); } } ...to be an example of closure? If so, take this snippet to whomever in the JavaScript community you'll actually listen to and ask them if this is an example of closure.
You can take it whomever and listen to (or not) whatever answer you want.
He holds your hand indeed. But what I like is that on the other hand (sorry), it teaches you a test driven approach that REALLY helps you in the real world.To me, programming It's never about the language, it's more about learning the mindset that brings you to analyze, dissect, and solve problems.
What is code splitting?
If you are including emoji in your articles, please, never publish again. 
It's defined in the article...
&gt; Instead of comparing stars on github (what does that even really mean?) Everyone and their mother makes a point of boasting about Github stars these days; is it any surprise that newbies think it's a serious measure of merit?
Thanks 
I disagree, as I wrote below - I think the fact is that we support so many different platforms and with the pace of development being so fast, you simply want to outsource small functions to the "experts". Look at left-pad for example - at one point it was needed. Now you can use padLeft, if you use babel or a polyfill. Who has the time to keep up with the ever changing spec and browser support? Instead you put the padding code in a micro-library, and then every so often you revisit it and if you can update it you do - and all your projects will be updated too next time they are built. Of course, there is a problem of trust, but it's not as crazy as it sounds
First of all, I am just sharing article about great technology. I am not the author. Secondly, if you seem something so cool and your best shot is about emoji... Well, our world perception is simply way different.
I know you're not the author. He'll read this though. Second, no, there's no emoji that need be conveyed in the written world, especially in a journalistic context. Its atrocious. 
Just letting you know that VoiceNGO isn't alone, you're a proper asshole.
postgres is a better database than mysql in very many ways. for most mundane uses though they're equally capable. you'll find more random blogposts and such with mysql because it has historically been more popular (for stupid reasons). beware that simply having more blogposts is NOT a positive. it means there's a lot more noise relative to signal in your google searches. 
My friend found himself writing variants of this component in multiple projects, so I told him we'd solve it today.
[removed]
With postgresql you can use the jsonb format, and therefore using it just like mongodb. It even has better performance than mongo.
It doesn't have to be, just like it doesn't have to be in Angular.
Not sure how much browser buttons scroll by by default, but you probably just want something like window.scrollBy(-20, 0); or window.scrollBy(20, 0);
Hi /u/lhorie, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
So your answer is to have library authors reinvent the wheel many times so your final application includes several duplicated ways to pad a string instead of one well tested central micro-lib?
This isn't about browser specs though. My problem with LeftPad is that it is a trivial piece of code to write on your own. Before the browser ecosystem adopted it, there was no reason to even bring it in as a library because writing the same functionality for your own library requires something like 10 lines of code. This isn't some "expert" level piece of software that is impossible for mere mortals to create. I've dealt with enough dependency hell to realize that duplicating code and effort is far from the worst thing in the world if you want your libraries to be easily consumable. No, what is far worse is when using fancy library X requires you to install C++ bindings, Ecmascript, ruby, closure, python, java, and a whole host of other things all to be broken because sub-sub-sub-sub library decided they wanted to use python 3.5 instead of 3.4. That costs me and every upstream project from me time to go through and update the universe all because some petulant library decided "lolz, backwards compat is for suckers!" I don't think you should reinvent a gzip library for your wizbang framework. But on the flipside, it is more than reasonable that my dependency on Angular doesn't also require a dependency on react, vue, and ember because all of those libraries had 10 lines of code in them that could be reused.
His insistence that all the apps work well with bundled bootstrap is fucking retarded.
My insistence. And why?
How big is the lib after minification?
oh sweet, thanks. If I want to use this on a div that has some hidden overflow, how would i target it?