My goal is to have full working environment for reactjs and that includes hot reloading. That's my idea of react starter kit.
&gt; they already have some built in type and defined checks Built in type checks?
JavaScript: The Good Parts and https://github.com/getify/You-Dont-Know-JS Good luck with project!
I'm guessing that's because the spawn center is full of energy. Try creating another creep.
Nevermind the type checks I was thinking about other thing.
According to the link I provided it said that "code complexity." So I assume it's because it was difficult to implement 
"Next week task runner"? There are literally only two with any traction whatsoever.
It's probably more correct to say that the pointer/reference to the object is constant, instead of the object is read only. But yes.
I phrased my sentence wrong but that's actually what I meant.
&gt;Edit: TL;DR: Solved. So it turns out that Javascript "bubbles up" the declaration to the top of the function Don't say bubbles up. Say hoists - it's what this phenomenon is called. Bubbling up has a loaded meaning in relation to JavaScript events.
Yeah, I've been interested to see how Starfighter will turn out ever since I first saw the announcement on Hacker News. It's a very interesting idea with high hopes.
You can access the DOM this way: http://facebook.github.io/react/docs/working-with-the-browser.html
Isn't knowing Javascript kind of a basic requirement for being a web developer? So is learning to google the answers to your questions btw.
Variables declarations and scope setup is all handled at author time during lexing. This means that during run time it won't really have any effect on performance and you should opt for easy to understand code!
&gt; My understanding is a variable is gc'd once there is no longer a reference to it. Not immediately, but yes that's the gist of it. &gt; I'm no expect on JavaScript engines and the intricacies of how they manage the memory, but my naive take on that would be that after the function loop ends, the inner var would be collected and the next iteration would reallocate a new var. The variable is a name for the integer. So it is the integer being allocated, not the variable. There is only one variable and it points to a bunch of different integer objects. When it is rebound, the old integer has no reference to it anymore and it goes away.
[react-dnd Touch support proof of concept](https://github.com/gaearon/react-dnd/pull/143) edit: You can turn off ghosting and draw a component in a drag layer. I have used it to build a drag and drop interface and it worked extremely well. I did not however use touch, but according to a comment on that ticket there is a pull request out for pretty good support of touch.
Of course it was exageration. But still gulp don't have all plugins that grunt have. And now we have new kid on the block - webpack. And why should I learn any of them, or be dependent on them, that I can't upgrade some of my tools because there are no plugins updated? And regarding all the css and assets processing. If you use postcss, there is no need even for webpack. I may be wrong in that. I will find out. I'm still researching the topic, but up until know I see that all those tusk runners do, can easily be done with scripts and piping.
X-Post referenced from /r/webgl by /u/Zipz0p [Do you want to learn a WebGL framework? "Learning Babylon.js - The ebook" is out!](https://www.reddit.com/r/webgl/comments/3kjhzk/do_you_want_to_learn_a_webgl_framework_learning/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher)
https://xkcd.com/927/
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 1969 times, representing 2.4160% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cuyv17y)
I've written one with Redux, React, Node, Immutable.js, and Webpack: http://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html
I really wish it would come with an automatically generated default config file that includes all options and their descriptions as comments. Then it would be easier for people to use it as a best practice learning tool along the way. Having to keep such a list updated manually is a but of a hassle.
Except that I'm using what's already available without any additonal plugins: npm scripts. Read this http://blog.keithcirkel.co.uk/why-we-should-stop-using-grunt/
It feels like most react components can be created with cleaner/less code in deku. 
A lot of people say this, but the API is no more complex than jQuery. It's just a selection library that is more data centric. What's complex is the generated DOM structure and the translation of data to a coordinate system. You really have to hand it to Bostock for making an extremely easy and efficient API for one of the harder things to do in computer science, graph drawing. Interpolation and transitions are just icing on the cake.
What advantages does it have over React? 
I would suppose it is. But, here I am. Necessary conditions aside.. If that's a dig about my supposed inability to Google things for myself, I just wanted MORE input from people familiar with it. (If it wasn't clear, I did Google for resources and found some stuff. Some of it is useful. Some of it is not.) 
Yeah! I've been reading through and putting some of it into use. Thank you very much! 
Bookmarked and saved for when I have had coffee. Thank you! 
&gt; the scope of the z variable is the parent for loop. This is incorrect, `var` is scoped per function, not per block. &gt; so it should be deleted after it exits scope (the parent for loop) (at least in c/c++/sometimes JS). Incorrect, variables declared with `var` are never deleted until execution of the current function scope ends. edit: that's ignoring closures, where the lifetime of the variable is as long as the closure lives. If you want _block scope_, as in c/c++, then you should use the new `let` keyword [introduced in ES6](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let).
Why would that animation scenario actually be helpful? Isn't it just a bunch of organized information you want to get to and use anyway? Maybe I'm missing something.
Thank you. Browser sync looks well made. :)
Ehh recursion can be bad. There is **a lot** more bloat added to the call stack with a recursive function compared to iteration; although that can be solved by tail calls. Then there's also issues with making recursion *understandable* and readable. More often than not, you'll run across a recursive function that is essentially spaghetti code and hard to debug. There are appropriate cases for recursion, such as divide and conquer algorithms (binary searches/sorts) or trees (like the video you posted). From OP's example, recursion doesn't particularly fit the picture if he's only iterating over a two ranges of numbers.
If you wouldn't mind could you link me to the pull people are referring to?
Javascript: The Good Parts by Douglas Crockford
You Don't Know JavaScript, JavaScript Allonge, and Exploring ES6
Can you explain what part isn't working? Doing the request itself? Or the recurring aspect? Or?
Effective JavaScript by David Herman. 
It is rather obvious that anything done in a JS framework is possible in another or in vanilla JS. 
* Eloquent JavaScript * You Don't Know JS (series)
Links to the free online versions: * [You Don't Know JS: ES6 &amp; Beyond](https://github.com/getify/You-Dont-Know-JS/blob/master/es6%20&amp;%20beyond/README.md#you-dont-know-js-es6--beyond) * [JavaScript Allongé, the "Six" Edition](https://leanpub.com/javascriptallongesix/read) * [Exploring ES6](http://exploringjs.com/es6/)
Try same with aces.. ;)
These are declarative physically based animations with tweening. That isn't common. 
What means new developer? It is very good: https://leanpub.com/javascriptallongesix/read#leanpub-auto-values-and-identity 
It was great at the time, and parts are still relevant, but I'm not sure if a seven year-old book based on ES3 meets the definition of "modern".
Are you looking to do lightweight javascript for a website or heavyweight javascript for a web application?
I saw [this](https://github.com/GetExpert/redux-blog-example) example app posted somewhere in the last couple days. I haven't gone through the source, but maybe it'll help you.
This is the real question
It's a great tutorial but it isn't isomorphic
https://www.sitepoint.com/premium/books/javascript-novice-to-ninja http://www.amazon.com/Professional-JavaScript-Developers-Nicholas-Zakas/product-reviews/1118026691/ref=cm_cr_pr_btm_link_3?ie=UTF8&amp;showViewpoints=0&amp;sortBy=recent&amp;reviewerType=all_reviews&amp;formatType=all_formats&amp;filterByStar=all_stars&amp;pageNumber=3#R33UK6Q44Y4XUU
[Async JavaScript](https://pragprog.com/book/tbajs/async-javascript)
wow yeah you're right, I could have sworn it was
Secrets of the JavaScript Ninja. Despite the campy title this is a fantastic book from the creator of the jquery library. Though you will want to wait for the second edition to come out soon since it will have information about es2015. Another recommendation is Professor Frisby’s Mostly Adequate Guide to Functional Programming https://github.com/DrBoolean/mostly-adequate-guide
&gt; it's hoisted I dislike this term because it feels like it has been invented just for the sake of explaining how scopes work to non-JS programmers. There is very simple rule for variables- any var statements inside a function body register a variable reachable from anywhere inside that body. From the implementation stand point it is easier to implement than the usual-works from here downwards.
Here's a blog post where someone recommended some free ones [10 Free JavaScript Books](http://sixrevisions.com/javascript/free-javascript-books/) My co-workers like JavaScript: The good parts
Expert JavaScript by Apress is very concise. I've read all the others on this list (with the exception of Effective JavaScript) and agree with most of them are great. But this book is the one I keep referencing. 
I am, by no means, an expert but I did this: if (coin &lt;0.510000001) { coin = "Heads"; var heads = parseInt(document.getElementById('cone').innerHTML, 10); document.getElementById('cone').innerHTML = heads + 1; } else { coin = "Tails"; var tails = parseInt(document.getElementById('ctwo').innerHTML, 10); document.getElementById('ctwo').innerHTML = tails + 1; it seems to work, though I am certain, someone can explain a better way to do it and why this way may not be the best.
Also; Math.floor(Math.random() * 2); Seems to be the preferred way of calculating random numbers; in this case you get either 0 or 1; I am not certain that there is actually anything wrong with your method. Again someone with more knowledge may be able to speak to that.
I didn't know that but it's not a big surprise. He comes off pretty arrogant in his writing sometimes. But I still find the book useful as an advanced, modern JS reference.
Knowing another framework couldn't hurt, but learning Angular now will give you a jump on 2.0, since a lot of the fundamentals won't change. If you decide to go that route though, try to avoid using ng-controller, which I think is deprecated in 2.0. Directives can have their own controllers, and putting logic there instead of using ng-controller makes for more modular code and is probably better practice overall, even in 1.x.
Not to mention it's free!
What are you trying to accomplish with your learning? Are you trying to get a job? Are you trying to build something specific? If you are trying to get a job, then there's nothing wrong with learning an existing framework. If you get a job you're most likely going to maintain and update something that has already been built using an existing technology, you're probably not going to be building something from the ground up with a brand new technology. Say you get a job at Tumblr for example, they use Backbone for most of their stuff as far as I know, they're not likely to hire someone who only knows Angular 2. Plus even if you are going to build something new, its entirely likely that the company is going to choose to build it using an established tool that most of their developers are already comfortable with, and with which they can develop quickly. Tools and frameworks come and go. If you focus on learning whatever the latest popular framework is, or trying to get ahead of the curve and trying to anticipate and learn the *next* popular framework, thats probably not the best use of your time. Its certainly not a good use of your time to simply *not learn anything* because you're waiting to see how things will pan out. If you learn *anything* now then you're going to be better prepared for learning whatever the next big thing is. Another option is to focus on learning the fundamentals of programming that haven't changed for 50 years. Or dedicate serious time to understanding how vanilla Javascript actually works. Invest your time into things that aren't likely to change much or go away any time soon. Even with Javascript's impending update with ES6, you can get ahead of that by using babel.js to emulate ES6 behaviour and syntax in your applications. If you invest in the fundamentals then learning new tools and frameworks is going to be a lot easier and faster for you, because you will be familiar with the patterns that they're using. If you're going to use a tool it shouldn't be a magical black box to you.
That's a good point... and possible easy to implement with the linked list just by moving the `_last` pointer. It shouldn't impact the `emit` method but `add` should be faster and avoids garbage collection. One reason I prefer the signals API vs. using RxJS observable or [event-signal](https://www.npmjs.com/package/event-signal) is that they only emit one argument. In many cases this means creating a new JS object for each emit that gets discarded almost immediately.
i've been reading javascript &amp; jquery by duckett which has been pretty goddamn good for a beginner like me.
absolutely - and with the new edition the in-page-editor is even more helpful.
Get the pitchforks!
I actually quite disliked YDKJS, am I the only one?
Do you mean something like this? https://cdn.rawgit.com/chenglou/react-motion/e8f42dcd9678a8cea8648a3cf4f994583a99e7f7/demos/demo2/index.html Code samples are from: https://github.com/chenglou/react-motion 
Fielding is REST zealot. He advocates REST at its purist form, not pragmatic REST.
That's what I like most about React - it's getting people to think about things the right way. I think its lasting contribution is going to be similar to Backbone's - more a lesson in good design than code that people want to integrate.
&gt; the strong point of [css] animation [...] is altering the destination in the middle A "strong point" does not consist of solving the simplest case and making the rest literally impossible (within the bounds of CSS). CSS makes it easy to change which destination you end up at - it does *not* make it easy, or even possible, to transition between animations, or to make changing the destination in any way pleasing for the user, rather than the developer.
I'd recommend angular 1 because it taught me a lot about the fundamentals of data binding and the structure of angular. I don't expect much of that to change, but I'm also not sure that I'll switch right away. Typescript seems to be the best path for Angular 2 right now because the ES6 syntax is meh and everyone is pushing Typescript. I'm not a big fan of typescript, but I might eventually consider it because it may eventually have tooling I need. Hope this helps you decide.
How would I make it automatically add &lt;li&gt;
https://github.com/zeroclipboard/zeroclipboard all browsers via flash swf ie 10, chrome 43+, ff any https://developers.google.com/web/updates/2015/04/cut-and-copy-commands 
Got the paperback of this just the other day - really great book to start getting deeper into the JS language once you have all concepts (I bought to further my understanding of OO JS for use with Angular)
Second. This was the first book on JavaScript I read and it is designed for just that - absolute beginners 
&gt; document.getElementById("output").innerHTML = "&lt;li&gt;"+coin+"&lt;/li&gt;"; Thanks, last thing: Is there a way to make the new entries at the top, and how to only make it have a certain amount before clearing (E.G: 10)
Fielding's REST dissertation may date from 2000, but it didn't get instant traction, and REST API's didn't really come to the forefront until after 2005 when Ajax came to the forefront. Furthermore, the "core principles" are pretty much just the full set of HTTP verbs, which I was well aware of before Fielding's disseration: all you had to do was read "Webmaster in a Nutshell" 
It's very opinionated. 
Took me some googling to realize what you mean. (Sorry I sux at quotes and/or references). For anyone else wondering: &gt; I'm doing a (free) operating system (just a hobby, won't be big and professional like gnu) for 386(486) AT clones. &gt; \- Linus Torvalds I often find myself saying something stupid/funny just to realize everyone think it's a reference :|
Hello again! Are you getting it all figured out?
Just messing around with making chrome extensions and thought it might come in handy.
Not really, to be honest:(
Seems like it would, yeah! I Googled around though and it sounds like, for security reasons, browsers make it pretty difficult to do... Here's some discussion: https://css-tricks.com/forums/topic/copy-to-clipboard-pure-javascript-solution/
I guess you mean examples? At the moment code itself is kinda ugly (That will be fixed in future - still deciding). Anyway, thanks!
Saved.
X-Post referenced from /r/webdev by /u/DBBX [Wrote my first story on medium today: How to enhance your front-end development workflow using Gulp [looking for feedback]](https://www.reddit.com/r/webdev/comments/3koqyf/wrote_my_first_story_on_medium_today_how_to/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher)
Better to use `ul` and `li` tags than `br`s in a `div`: http://codepen.io/stevegoldberg/pen/EVPYrm
Not much to feedback on--pretty standard stuff. Hopefully it helps some people switch to using task runners. Gulp was my main tool for Angular related stuff but have been very happy with Webpack after doing mostly React.
That works a lot better than I thought it would!
Nobody expects originality when it's so easy to imitate. \- Someone, I'm sure
&gt; Do not trust quotes on the internet &gt; \- Lincoln 
~~How's it unfair?~~ Oh... I didn't know Math.random() did 0 to 1 **inclusive**. I thought it just went 0 to .99 so I just punched in .49. I've changed it to .5 now.
Which box? The previous outcomes? It's just a div with an id and then I set inner html **+=** and threw in some control logic...
No man anybody is welcome do you have a github account or an email I can get in touch?
I doubt that this actually works with a real capcha that isn't just crystal-clear block letters on light grey background
Seems too arbitrary/pedantic to me... just conformig to some standard that doesn't affect aesthetics or functionality, yet requires more work. I don't know, I tend to operate parsimoniously when possible. I do appreciate the info though!
Hi /u/richardruiter, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `richardruiter.nl`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [richardruiter.nl](/search?q=%28and+site%3A%27richardruiter.nl%27+author%3A%27richardruiter%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|10|71%
Hi /u/abdulapopoola, this post was removed because it's currently yielding a `504 Gateway Timeout`. Also, if it's just a CSS compatibility table, then it probably doesn't belong here.
Pretty nice!
Think of it as embedding a version number in your filenames, automatically, so just from the HTML the browser can immediately know whether your currently cached version is valid, with no further requests. If instead you depend on 'x.js' in your HTML, the browser can't know which version you mean. The browser has to request the current one, and then should cache that for as long as it can, but you can't let it cache it forever, because 'the current one' will change (you'll change x.js), and the browser needs to get the new version when it's available. You have to disable or limit caching, so the browser checks whether there's been a change on the server every time you load the page, or you have to just give up on ever getting new versions of the file. More caching is better, in general - it lets you do more with fewer requests - so we'd like to be able to depend on a file, confidently use it from the cache when it hasn't changed, or immediately go to the server and get the new version any time it has. Hashes in filenames let you do that. if you depend on 'x-12398hasd98h.js', where 12398hasd98h is a hash based on the contents of the file, then you're depending on an exact set of contents. There is never going to be a different version of 'x-12398hasd98h.js', because any different contents would have a different hash (ignoring hash collisions). You can let the browser cache it forever, confident in the knowledge the cached version will always be up to date. Thus, if the browser is given an HTML page referencing 'x-12398hasd98h.js' it can just use the version it's already got, without even talking to the server. In addition, the browser now knows immediately the first time it ever needs to update and download a different version, because your HTML will specify a different name, for a file it's never cached (say 'x-abasdbasdb123.js'). This is 'cache-busting'. By specifying exactly which version of the file you want in the HTML (as part of the filename), you can change only the HTML and 'bust' the cache: guarantee that the browser will always load the new version and will immediately stop using any old cached versions. In practice it could actually just be a version number (x-0.1.0.js), because published versions should never change. That's less good though because there's nothing ensuring that's definitely the case, version numbers tend to imply more human involvement (e.g. making semver decisions, or deciding if this is a 'big enough' change to jump to 2.0, etc), and working out the new version number means you need to know at least the last number you used. Hashing meanwhile only needs the current contents of the file, and easily guarantees the filename will do what it needs to do (always and only change when the file contents does), and nothing more.
Oh... you think I'm using &lt;div&gt;s. I'm not, I'm adding html text to one containing div. I'm just putting the text in directly and adding a &lt;br/&gt; to break the line of text as new text is added each time.
Thanks for taking a look! You can see a live demo here: http://mattmcfarland.github.io/react-markdown-area/
I'm having trouble imagining an actual use-case that would result in code like this. Do you know of one?
By far the best one I have come across hands down which employs AltJs, Isomorphic, Express, Webpack, ES6 etc. https://github.com/choonkending/react-webpack-node
 (a=&gt;{b=&gt;{a+b;}})() That line doesn't do anything useful. If you use curlies, you need a `return` if you want to return something. If you write it like this: let x = (a =&gt; b =&gt; a + b)() It still doesn't do anything useful: &gt; x('foo') "undefinedfoo" You didn't put an argument in the invocation parenthesis at the very right. "a" is `undefined`. Anyhow, since this is ES6, you probably don't really need that IIFE anyways. You are usually inside some block were you could just declare another local variable. And if you write a module, simply don't export everything.
I find this var a = [....]; var b = a.map( x =&gt; return x * 2; ) easier to read than var a = [....]; var b = a.map( function(x) { return x * 2; } ) 
Currying. But you'd better be off using a factory function for that. 
It’ll just take getting used to. Side note, if you use the braces, you *have* to use a return statement. The two are equivalent a =&gt; { return a; } a =&gt; a
Oh my, I just saw this message. Here is the pull request. https://github.com/gaearon/react-dnd/pull/240 I would just copy the code out and use it as a backend. No need to clone the pull request repo. ReactDnD is the best Drag and Drop React library I have found. Hell, it's one of the best React component plugins there is. /u/gaearon knows what he is doing. I'd also recommend looking at Redux. 
I still think there should be a "generate" method. &gt; Array.from({length: 5}, (v, k) =&gt; k * k) [0, 1, 4, 9, 16] Wishful thinking: Array.generate(5, x =&gt; x * x) Thankfully, "fill" doesn't care about holes. While it's not as nice as a "filled" method which creates and initializes an array, the DIY combo isn't too shabby: &gt; new Array(5).fill(0) [0, 0, 0, 0, 0]
This might seem irrelevant but: Dr. Rauschmayer's site has very interesting articles in it but from my location (Turkey / Istanbul) I have never been able to access to his site without using a proxy. His server consistently returns 503:Connection refused for me. Is anyone else experiencing something similar with his site?
Using a proxy substantially lowers the bandwidth. Videos load and play slower depending on the load on a particular server 
Just seems like too much work for a simple text output. But thanks again for the info.
This will do it for you: javascript:(function(){window.location.assign(window.location.toString().replace("youtube", "ytpak"))})()
Thanks but it gives this error data:text/html,chromewebdata
[More on promises](https://remysharp.com/2014/11/19/my-five-promise-patterns)
it does work but only if youtube is actually running. In pakistan running youtube link gives an error and then bookmarklet doesnt work gives error Thanks for your help anyway. Is there a way it can be fixed? 
Modifying the built-ins is always a bad idea. Only do that for standard-compliant polyfills. Also, this is something you'd put on Array itself, not its prototype. This isn't something Array instances would need nor does it access `this`. Anyhow, I'd write it like this: function arrayGenerate(length, generator) { return Array.from({length}, (v, k) =&gt; generator(k)); }
What exactly do you want it to do? Replace all the youtube links on a page with ytpak links?
Man I reddit alot and go to r/videos. If I can just click a youtube link and it opens in ytpak that'd be great. 
it's not that modern, but Javascript Patterns by Stoyan Stefanov is a great book for the pragmatic, intermediate JS dev, and JS Allonge by Reg Braithwaite/raganwald/homoiconic is pretty definitive (I'd recommend watching his talk about metaobjects too...)
If you were, the language would be colorful.
Is there actually a valid use for holes in Arrays? I have always considered them to be extremely poor programming style that should be avoided in favor of better, more obvious approaches. 
I don't have a perf test since I'm on mobile. However, when you know what the length of the array will be (even if populated out of order) setting the length ahead of time is faster. We use this optimization for rest params in Babel.
How is this any different from using Q or Bluebird? var promises = array.map(function (item) { return async(item): }); Q.all(promises).then(...) I guess it just makes it easier by removing the need to use `.all`
Sorry if I sound pedantic, but in what way is this a "live" preview? It has a preview certainly, but having to tab between "edit" and "preview" is literally the opposite of live. 
Try this: javascript:(function(){var elems = document.getElementsByTagName('a');for(var i = 0;i &lt; elems.length;i++) {var matched = elems[i].href.match(/https?\:\/\/(www.)?youtube\.com(.+)/);if(matched) elems[i].href = 'http://ytpak.com'+matched[2];}})()
`new Array(x)` creates an array with holes, it's just different syntax: &gt; 0 in new Array(2) false &gt; 0 in [ undefined, undefined ] true
man youre my hero. thanks so much it totally works In a few years when I graduate I will get you gold
youre a wizard
if you can rephrase your last paragraph, someone might have an answer. I think it's still unclear what you are asking. 
You can usually find it listed in the package.json under 'engines'. [For Express 4.x it lists node 0.10.0 or higher.](https://github.com/strongloop/express/blob/4.x/package.json#L76) As for Node v4, they're actively discussing it; Doug Wilson, the current primary maintainer, said [they don't anticipate any major bugs, but are going to test](https://github.com/strongloop/express/issues/2754) before officially supporting it. 
Your example doesn't return an IIFE due to using curly braces. With curly braces, you need a `return` in there.
Thanks everyone - I was on my cell and didn't get a chance to test it out, kind of figured it always returned. Nice to know it does so without curly braces. I still say they're not very pleasing to look at. I'll probably start using them more since I'm sure I'll be seeing them more and more.
okay, but that doesn't demonstrate my point. &gt; 0 in new Array(2) false &gt; 0 in [,] false The article is about how `[,,]` is now actually working like `[undefined, undefined, undefined]`. If you used the `new Array(x)` syntax, you wouldn't be impacted at all for creating arrays with \*proper\* syntax vs relying on `[,,,,]`. IMO, `new Array(x)` is the preferred syntax over `[,,,,]` because it has an explicit behavior associated with it, rather than an implicit one that `[,,,,,]` does. 
i actually hadn't read this until just last week and wish it would have been the first javascript book i read a couple years ago.
Thanks! I wouldn't have thought to look in package.json since node isn't installed with it. makes sense though; that's basically what I was missing. Good to hear as far as node v4 goes, support is mainly expected. 
All good points. Still, using {length: 5} feels fragile, somehow... It seems like there should also be a clean yet succinct way to do this with Array.from on an appropriate iterator object. But then you wouldn't know the length in advance, so this is probably most efficient.
The article is about arrays with holes, not about any specific syntax to create them. Where's the difference between `[,,]` and `new Array(3)`? Both still evaluate to the same thing and will be treated the same by all new constructs/functions..? Is your whole argument that the article should have used a different coding style as in "This article about recursion is bad because it doesn't use semicolons!"? Or do you assume that there's a functional difference between the two ways of generating sparse arrays? Again: From all I can tell, if you're using `new Array(x)` you get the exact same impact. There's 0 difference between the two: &gt; [,,,].map(() =&gt; 2) [ , , ] &gt; new Array(3).map(() =&gt; 2) [ , , ] &gt; Array.from(new Array(3), () =&gt; 2) [ 2, 2, 2 ] &gt; Array.from([,,,], () =&gt; 2) [ 2, 2, 2 ] `new Array(x)` and `[,,,]` can't even express the same things*, so I'm not sure where your "preferred syntax" comes from. In the few cases where you'd ever "need" sparse arrays, you likely won't have a choice between the two..? (*) `[,,]` can't express dynamic length, `new Array(x)` can't be properly used as an expression when you want to provide some of the values.
/u/moreteam is right: Array literals don’t change in ES6. The only change is that methods that were added in ES6 and whose inputs (via `this` or a parameter) are Arrays now interpret holes differently (convention in ES5: ignore holes; convention in ES6: treat them as `undefined` elements). `Array.from()` is one such method: &gt; [,].length 1 &gt; 0 in [,] // hole at index 0 false &gt; 0 in new Array(1) // hole at index 0 false &gt; 0 in [undefined] // element at index 0 true &gt; Array.from([,]) // convert hole to element [ undefined ] 
&gt; Is there actually a valid use for holes in Arrays? I think it's for serializing/deserializing. If you think about how Array::toString works then you can see that you might deserialize the result back to an Array. Remember that JavaScript is essentially an early scripting language for the web, it was simplified to handle string input from forms etc.
[ undefined, undefined ] is not the same as [,] or new Array(2). see: [ undefined, undefined ].map( (el, i) =&gt; { console.log(i) }); vs. [,].map( (el, i) =&gt; { console.log(i) }); or ( new Array(2) ).map( (el, i) =&gt; { console.log(i) });
A great eslint I use (as well as many others): https://www.npmjs.com/package/eslint-config-airbnb They have a great eslint configuration for both Emcascript and Emcascript + JSX.
Ok. Thanks. So this says there are 3 ways to get a file object. 1) You can convert an htmlcanvas object to a file - not relevant here 2) via drag and drop. G+ Also supports this but not the one I'm interested in. 3) via an input field. This is what I'm getting at. It appears they are doing this approach but when inspecting the Dom there is no file input field to be found. So either there is a 4th way or They are doing a great job of hiding the input field
I think `return Promise.all(coordRequests)` needs it's own catch. Though... the .catch at the bottom should conceivably throw the error. The first call looks like it generates and throws an error which should call that last .catch while skipping the rest. It won't skip cityCenter though because .all() needs to check that both promises resolve. If you don't want the promise chain to end if airport() fails then don't put it in a .all(), that's all I can think of without being able to play with the code myself.
Well I mentioned the SSL changes, and I didn't know about url.resolve() but still, these are fairly small. I suppose you're correct. It's _not_ 100% compatible. But its like 99.9% compatible hah. Express works just fine :)
Doesn't what I suggested apply to any promise library though? Just not really seeing why I'd need an additional dependency over `.all`
It might be interesting to run a [buildbot](http://buildbot.net/) server that iterates and runs tests of various popular JavaScript packages on different versions of [Node.JS](https://nodejs.org/en/), [io.js](https://iojs.org/en/), and [PhantomJS](http://phantomjs.org/). Could be an interesting project to work on at home some day.
Any one know whether this can be used in the browser? I'm still looking for a way to hash strings in the browser (preferably using md5, but not a hard requirement). Haven't looked that hard yet, though.
Hi there, Shame on Google Jukebox. Felling bored i pushed Web Audio API to the limit. Now i am not sure wether i should make a real software out of the prototype. Hoping you could give me some feedback. Peace Kind Regards Kilian
They could very well inject an input field when you click on the upload button and "forward" the click event to it.
Oh hey, thanks for sharing! :)
&gt; The IV is derived from they key, because that's totally how an IV ought to be generated. No, that is not how it ought to be generated. It's terrible advice. Following this advice breaks semantic security. The IV is meant to be properly random, not pseudorandom or derived from anything else, randomly generated from a quality source of randomness designed for use in cryptographic application. 
If you are going for super modern browsers then you can use [crypto.subtle](https://developer.mozilla.org/en/docs/Web/API/SubtleCrypto). There is a really handy [github page](https://github.com/diafygi/webcrypto-examples#web-cryptography-api-examples) if you do not want to read stuff on the MDN, though it only cover encoding/decoding functionalities. If you are targeting older browsers too there is [CryptoJS](https://code.google.com/p/crypto-js/#Hashers), which is discontinued but it still work. Also please do **not** use MD5, SHA2 is the (new) standard for hashing functions for [a good reason](http://www.mathstat.dal.ca/~selinger/md5collision/).
Thanks! I was actually looking for sha1 instead of md5. Reasons for not using either do not really apply to my use case, as I mostly want to simulate Git commit hashes for demo purposes. Thus, they will only be used for presentation - any random set of characters would probably be sufficient, but using the actual hashing algorithm just feelds better ^.^
This would be great if you had the live preview under the textarea box and it updated on every few keypresses, possible? :)
Switch unit testing with framework and go in that order. ES6 is mostly just sugar and a few more array, math, object methods, easy to grasp. You can join automation with modules loading as well, gulp supports plugins which make it easy to do your bundles, there are various ways to do it, stick with what you prefer the most, some will suggest webpack because it supports hot loading, others will say browserify is easier to get going, in the end it's a matter.of preference.
Especially as the upgrade for NAN to get it working on 3.0.0 is big 
Long article on optimisation, not one mention of profiling, lots of micro-benchmarks. Profiling *can* be tricky, as some things tend to hide from profiling (like string concatenation) but you'd still be able to pin it down to the right function/set of functions. The circular reference section seems rather spurious at a glance, if it's talking about JS/DOM cycles then that only affects IE6/7 (and to a lesser extent 8) and jQuery will do the event deregistration properly. If it's just talking about closures capturing variables then you'd have to have some rather odd code structure for that to ever be a serious issue. (Passing lots of giant, different, objects to functions that then create event bindings which are never removed?). [Some browsers have more accurate closure reference tracking than others](http://stackoverflow.com/questions/19798803/how-javascript-closures-are-garbage-collected). I mean, it *can* be a problem, but it's not really something you'd run into on your usual JavaScript codebase. The semantics of `eval` and `new Function` are different and to suggest the use of both without mentioning this is strange. (`eval` runs code in the current scope whereas `new Function` generates a new function which will have only the global scope). Also, Chrome 21/Firefox 12/Safari 5? That places this article at 3 years old, JS engines change and get better quickly, take any benchmarks within with a grain and salt and PROFILE PROFILE PROFILE.
&gt; Wannabe class. What year is this? &gt; I'm not too sure what you're getting at here? That's because I don't know what I'm on about though, so I'm just curious what you mean... Something like JS devs attempting to force it to read like other (more OOP) languages or something? Not sure, cheers 
ES6 has classes. Use those. Your tools understand them and everyone knows how they work.
I am not aware of such article, but my approach in REST so far was to build form my entity UP and do not think of the transport method of my data ... REST to me is just the final interface for your code and should not dictate how to organize its business layer. So I would normally have this structure for REST: /Models (holds my JS entities) /Mappers (Handles my data retrival and respons always with Entities) /Services (handles my mappers) /REsources (handles express.js or other, routes, uses req and res to handle input to my services and sets the response So for a rest endpoint of GET /user/1 I would have the following functions: resources.getUser(req,res,next) services.getUser(id, cb) mappers.getUser(id, cb) Entity The mapper layer and the service layer could be merged depending on your data and how you want to handle this. I've used the above several times and found it flexible and clear enough for others to understand when they open the code from first glance. I like to think that how clients consume the data, how the data is stored and its business rules should all be as separate as possible to allow flexibility and easier refactoring! Angular or React, front end frameworks come and go. Also an API should be prepared to be used by all kinds of resources such as third parties, old applications, mobile applications etc ... Hope that is of any use even tho its not the response you were looking for
&gt;In past couple of years JavaScript has emerged as the de facto expression of next generation web technologies, and a critical component of HTML technologies along with CSS and JQuery. What? Javascript *along* with JQuery? **JQuery** *is* **Javascript!**
Found the original article from 2012. Thought I'd seen those images before. http://moduscreate.com/javascript-performance-tips-tricks/ The advice in this article is out of date and looks like it's just a rewrite of other peoples work.
&gt; JQuery is Javascript! Sooooo tired of this dated phrase. A couple of years ago when JQuery was at its height people would say this implying something more like: *JavaScript is JQuery*, thereby suggesting they could not write in the language without JQuery. It was stupid then and its just as stupid now.
&gt; classes are stylistic convention that aren't otherwise beneficial in this language. Standardization is important. It means you won't have to evaluate a dozen flavors of DIY classes/inheritance anymore. It also means interoperability. And it also means that you don't have to learn the ins and outs of several of those. If you read someone else's code, you'll know how it works. Since it's declarative, it's also more accessible to static code analysis. You don't have to execute some random code to figure out what kind of structure it would create. You get more intelligent auto-complete and even stuff like documentation benefits from this. You can hate classes all you want, but you shouldn't pretend that there aren't any benefits.
No, that is not what the author is implying. Just because they identified JQuery separately from JavaScript does not mean they implied JQuery is written in a different language. How did you even come to this conclusion? To be clear JQuery is an optional and not required supplement.
This is not exactly the same but here's a similar implementation with mdast and deku: https://github.com/rsystem-se/showcase-mdast-deku.
The context was tooling. I meant intelligent context-aware code completion aka IntelliSense™. http://i.imgur.com/RlrN6xt.gif E.g. you have some kind of Vector2D object and you want a normalized copy. How does your editor know that such a method exists? How does it even know that a Vector2D thingy exists? Modules and classes really help with that. The imports are declarative and so are the class declarations. &gt; And the extremely imperative code without classes It was written in 2013. Of course there won't be any classes.
You'd have to log in to plus.google.com. I'm just talking about their post images modal that comes up when you want to post a photo from your hard drive to your feed.
I've updated the story and the Github gist based on the feedback I've got from the other post and on Github.
Yep. That's why I'm so curious as to how they did it since I can't find anything after searching the dom 
&gt; Serious developers are building serious apps Meh. I've spent a lot of time writing "serious apps" in many different languages and oop threading always becomes a major headache as the app grows. No threading forces you to deal with the pain upfront in a correct manner (like sending long running processes to a distributed job queue) instead of just throwing it in a thread and adding tech debt that will become a pita to clean up later.
Thank you this is helpful. My question is how they get the file into JavaScript. This example first has the input[type=file] to load into the browser then it can be manipulated via that js api. What I'm saying is it appears they are doing it without the input field so am curious if there is another way to do it that I've never heard of or if they are just very good at hiding it.
I promise you they are using an input field. The input field can be anywhere on the page though, as you can use JavaScript to click it. They probably created a small uploading library that they use for many things. That's pretty common practice. For clarification, the input field is most likely hidden.
[removed]
You can keep a reference to the input field after removing it from the DOM and still access the selected files. So you can inject an input field when the user clicks on your custom button, forward the click event to the input field, remove the input field from the DOM and voilà. When your user selects a file, you will still have access to the input and to its files property.
I'm not sure what you're trying to do here really. Use ES6 and transpile it with Babel or something similar...can't get much easier than that.
hey that is a good idea!
Hi /u/Kat1ln, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Spot the bug! //Break the cycle! function foo(e, d) { $(e).on("click", cbk(d)); } function cbk (d) { }
Sounds like you have discovered something like Elm's foldp. 
setInterval happens every 1500ms and setTimeout occurs after 3000ms. So... the second time setInterval happens it will be 3000ms which is when setTimeout also occurs, right?
zachrip is just saying jQuery is a JavaScript library, and not an entirely separate thing like CSS is. He's not saying jQuery is an inseparable component that JavaScript cannot be used without.
6 way data binding? 
I back this, with browserify and webpack doing the bundle you're really better just using the requirejs way from node (now import on ES6), it's the standard, it's the one used on the node environment and what I've seen on most codebases. I think you can still used the rest normally, it's down to preference. Wrapping your imported modules in a function doesn't feel tidy for me.
Redux is directly inspired by Elm.
Right. [It's even pointed out in the docs.](http://rackt.github.io/redux/docs/introduction/PriorArt.html) 
can you explain?
Glad you got that part figured out! Oh... wow, the whole thing is being done in javascript/jquery. That's pretty cool! Yeah, .shift() just removes the first item from an array each time it's called on it.
Even stupider question, but how do I install this forked version of react-dnd? I can't figure it out. I only have installed modules using package managers previously 
I think you've made a completely irrelevant point. While giving very little input on what was being asked. &gt;How to elegantly structure your code is something you just know Making statements like this strikes me of naivety. Software development is an art not a science. Structuring code is down to personal/team preference and opinion. Of course theres ways of solving problems in particular ways but these are only guidelines. Writing software is like writing a book, it can take many drafts and rewrites to produce something remotely well structured. You'll never create a masterpiece on your first try! Learning the basics is key, but if someone is interested in learning framework then let them jump and find stuff out for themselves! 
I wouldn't. I briefly talked about not cloning the repo. Read through the docs on ReacDnD website. Specifically anything about "backends". 
My library uses `.all`, and that’s exactly why I made this library. Using `.all` directly gets really messy really fast, and this "small" library only helps with improving the messy code and readabilty. Nothing special.
I see, so it's mainly to provide a cleaner and more direct approach than using `.all`? Look, I'm not necessarily against this, or trying to be disrespectful (not sure if you're down voting my responses). I'm just trying to understand *why* I'd need this so that I can decide if I would use it or not. Regardless, it looks well done, so kudos!
[removed]
that's what I kept telling myself as well, but I cannot find it anywhere by searching the dom using firebug. I even went through all the iframes to see if its embedded somewhere. Hence my curiosity as to how they are pulling it off...
But... But I can do 50 million string concatenations per second instead of only 10 million if I follow this article! /s Maybe if an application has that as the bottleneck, the developer should be thinking about how to avoid making 50 million string concatenations. Microoptimization teaches the bad practice of fixing the symptom instead of the cause.
this pattern is used in creating middleware for Redux, although the syntax is store =&gt; next =&gt; action and not bothering with the extra curly brackets like the initial post has. when I first saw it, my head was a bit 'wha?', but now that I've gotten used to it - finding it pretty natural.
That is correct, you can use the Touch backend with out having to use the version of ReactDnD in that pull request. Just do a check if the environment supports touch and supply that backend instead of the HTML5 backend 
Hmm. Is it possible for a mod to edit the title? I feel "React Native for Android Released" is better.
If you're referring to the `$.get` in `componentDidMount`, then... Sending an HTTP request in `componentDidMount` and passing props down to child components is a perfectly acceptable thing to do. Flux is good once your application gets more complicated and you need to share state, improve debuggability, and keep state under tight control. [Take a look at Redux sometime.](http://rackt.github.io/redux/index.html) It's a lot less complicated than Flux, and has skyrocketed in popularity. It still won't be that easy to learn, but if you *do* use a Flux-ish library, Redux is probably the best choice. You may not actually realize why Flux and companions are a good thing until you go without it for a while. 
I like React and all but things like that first paragraph bug me. &gt; React Native brings what developers are used to from React on the web — React has been in the wild less that a year? Are we really "used to" *anything* from it yet?
Well finally, this is huge news.
"Don't take it the wrong way" means don't take my comments as simply a means of offending you. It may be offensive to you because you worked hard on this project, but I'm offering my honest opinion to what I think you can do to improve the visibility of your project and how you're communicating to potential collaborators. In short, I'm trying to help. I thought you were trolling because the whole document sounded like you just threw a bunch of buzzwords in to make it sound trendy. You might be offended by what I'm saying, but I'm just speaking honestly. Dude, you even say that you don't "need" to explain 6-way binding to someone before they express interest in the project. How the hell are people supposed to be interested in the project if they have no idea what it is? That's called blind faith, my friend. Most programmers don't live by that. And regarding DI - why don't you add something in that explains how leveraging DI is better then require/imports? In what cases are they better? Always? Sometimes? I understand you want to create your own package manager, but why? You're asking for collaborators, so EXPLAIN things. I get it's your project, but once you open your project up to the public, you need to explain yourself.
Nah I'm good. Those numbers on the list could be bigger though. A lot bigger. Get on it.
Except you're not a static billboard, you're a real person who can make real changes. And who said I wasn't interested? I'm replying, aren't I? I found the billboard interesting, but the message it was giving wasn't coming off clearly. I would contact the owner of the advertisement. Do I really need to spell this out for you? First bit of advice, if you post your work to a public forum, expect it to be criticized. If you can't take the heat then don't post it publicly. 
It's a personal project, I just hadn't pushed the code yet. I appreciate the offer, I'll take another look at it and push it up soon if I can't sort it out.
It's not -- the [center tag](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/center) is deprecated and should not be used. Presentation should be controlled with CSS, not HTML.
Why would you need that after setting up your project? Its purpose is to scaffold out the basic things you need, not to be continually run.
Well sure, but the constant over the top back-patting that the press releases do is just annoying. All sizzle and no steak. I can't possible be the only person that feels that way.
It is called "Native" but the way they talk about lots of js code seems like it just runs on top of an interpreter. Does it really all compile to native code?
The JavaScript is interpreted by JavaScriptCore, the JS VM for WebKit. The reason it's called React Native is that it doesn't run in a WebView or Cordova. It uses native UI components and doesn't provide access to web APIs. Therefore, you will get much better performance and a native feel for your apps.
Well I’m certainly not down voting, someone is down voting my link though (which is a bit weird). And your feedback is very much appreciated, that’s why I posted it here: to look for feedback. The reason I made this is I needed some clean way to work with promisified arrays in my projects and I was repeating this `.all` task all over the code, this helps to keep it neat.
There's lots of java/ios code under the hood. I didn't dive into how they do it but it runs smoothly, I've seen a bit more of RAM usage when I tried the iOS version but it was not significantly.
Padding makes it easy: html &lt;div class='imgDiv'&gt; &lt;img src='http://a.dryicons.com/images/icon_sets/travel_and_tourism_part_1/png/128x128/car.png'&gt; &lt;/div&gt; css .imgDiv { display:inline-block; padding:50px; border:1px solid; } *...Why downvoted? 
I'm no expert, but I'm curious to see the challenge and your code and can give you my non professional/non expert feedback on it... Up to you.
Too bad that according to the website it only works on OS X for now, was looking forward to trying it out :(
You're right, I think "live preview" is the easiest way to explain it for the sake of brevity. How would you call it in less or same amount of words? Maybe just react-markdown-area brings "textarea" up a notch with preview? "live preview" seems to make more sense here, although in purity its not as accurate.
You should consider if you want the following * async interaction types - - events, messages/channels, promises, event streams * chain-able ( jQuery like ) * key libraries to work with * library weight/size complexity * reuse * MVx pattern to use - - MVVM, MVC, etc... Should it be like angular, react, knockout, backbone, etc.. * level of experience to use - - what libs does the target developer use regularly
What is wrong with just calling it a "preview"? That's exactly what it is. React Markdown textarea with preview. 
Not sure I understand what the problem is, http://www.hamsters.io/ solves everything you need. You can run things concurrently on the main thread and separate threads on an individual function level, and even run a single function across multiple threads for parallel execution. Javascript is decidedly "threaded" at this point. 
I don't understand what you are saying... are you talking about the article linked in this thread? What is "back-patting" about it? It seems like an interesting account of how they ported stuff to Android? 
You should probably use a proper router, and combine that with some ajax POST functions. What you're doing sounds terrible.
interesting...nice little hack. thanks for your help
that's what /u/urcadox was suggesting as well. I haven't had a chance to confirm yet, but that may be the case. What i find interesting is that you may be able to add it when a user clicks a button then remove it immediately after the dialog opens but before a user selects a file to upload. 
Is it an algorithm question? You can see if something similar shows up on [https://leetcode.com/](https://leetcode.com/) and see what the optimal solutions are. 
+1 then.. I shall either call it that, or add a live preview to the bottom.
How should I go about dealing with ES6 features like promises? I assume it is bad to assume ES6 features since I can't know the user's environment, does that sound right?
Maybe you shouldn't have made this post until you were ready to post the code?
- Imperative programming instincts If you want to wire together DOM elements with jQuery within React, that's a 'bad' developer not a fault of react. - A fair amount of wheel-reinventing Plenty of projects exist wrapping more advanced components as react components. And the fact that this has to be done is just a fact of using something such as react. The fact that people made jQuery specific programs isn't a bad part of react, it's the nature of libraries and frameworks. - It’s bright and shiny and everyone wants to keep painting it chrome A) Flux frameworks: React is not flux, and this is actually a great part of react, sense react did not build this into their core, we have a much more stable react and you can easily stay current with. B) Generators: What the hell does this have to do with react? C) Babel: Once again, this has nothing to do with react. And if you want to right React in vanilla js, be my guest. The 'bad' is mostly commentary on the front end ecosystem as a whole but attempts to relate the discussion with react to make the article seem relevant rather than a poorly written rehash of points made in a more general format over and over. 
Still nothing
Compare your code with the example in the bottom left. Also, indent your code. Formatting your code properly is not optional. It's required to make it readable.
No
As said by senocular, your braces are messed up. What you're meaning to do is start a new "block" after the if statement, to contain everything you want to do when the if statement evaluates to true. What you're instead doing is starting a new block (the first {) and then executing an if statement. The result of the body of this if statement evaluating to true is a no-op being executed: the semi-colon (similar to how it is sometimes used at the end of C for loops with no body). The block previously opened is now closed. All of this so far is valid JavaScript, but probably not what you intended. Finally, the JavaScript interpreter finds the keyword "else" at the beginning of your next statement, which is reserved, and so fails with an error. The rest of the code is not executed.
Whoops. Sorry for my noobishness, I was absolutely knackered when I wrote this a few days ago, fixed that part, but even when I fixed the formatting it still gets the error.
X-Post referenced from /r/reactjs by /u/itsananderson [Relay: Declarative data for React applications | Engineering Blog | Facebook Code](https://www.reddit.com/r/reactjs/comments/3kyfqq/relay_declarative_data_for_react_applications/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher)
It seems to currently break on other platforms due to references to platform specific shell scripts. See https://github.com/facebook/react-native/issues/2681 and https://github.com/facebook/react-native/issues/2684
Thanks jodraws, really appreciate seeing another point of view. I'll take a look a look at what you sent me and study some more to see if I can arrive at a similar solution. 
No problem :) Go [here](http://codepen.io/) and make a new pen with your code in it so others can see what is does and edit it.
Derp, forgot to save, [here](http://codepen.io/anon/pen/yYeXog)
Isn't forEach significantly slower than a for loop?
Open the inspector, go to the console, check the errors. Also, "command.log"?
Oh! Shoot, sorry, I constantly think that it's a command log, because it logs some commands, I hate my brain sometimes
While you're fixing that, make sure you take a look at assignment vs comparison (= vs ===).
I absolutely respect the work that is being done on redux. My comment was not really directed towards this particular framework. However when you take a look at the current way you design user interfaces with react and other component frameworks, as a old native developer it really seems like there is a whole lot of reinventing the wheel going on and the supposedly shiny and new and clever tools that are being developed for web UIs still feel awfully clunky compared to classic RAD tools like VS and Delphi.
Yeah, thanks man, finally finished it.
Nice! Two weeks early, too*! *http://reactnativeandroid.com/
I'm glad to see support from such a well respected company, known for their light, fast, and stable applications. Oh, they also made the Facebook app? Oops. Edit: Ah, right. I didn't realize this was /r/javascript and my app developer views aren't really welcome here.
Yes, fair enough, the JavaScript community is pretty history-less and likes reinventing things (See: Atwoods Law) That said, it's a trait that is common among programmers in general and might seem stronger in JS just because the community is so big and moves so fast.
[Noooo](http://cdn2.crushable.com/wp-content/uploads/2014/07/Caesar-saying-no-in-Dawn-of-the-Planet-of-the-Apes-GIF.gif)
Yeah. I' mature that I'll get used to it after a few more lessons, but currently I'm taking in 3 types of languages (English, Spanish and Coding) and all these words and the separate structures that are needed for something to make sense just get muddled up, hell, I accidentally used an if function in English to decide a character's reaction to something.
While I'm pretty comfortable with Blaze, I can't wait for Meteor + React. It's gonna be great to experiment with.
How is this different from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map? Other than being available on non-modern browsers?
Besides the cool getOrCompute function, this is a HashMap. Each object has a hash of it calculated, which returns an integer. This integer specifies where the object is stored in the array. This means that looking up the value is however long it takes to calculate the hash (hint: not very long!) http://jsperf.com/hashmap-vs-map Also yes, non-modern browsers.
Looking at results between Waterfox, Chrome, and Safari, it seems that maybe Safari already uses a hash based map? Not sure why Map came out so much better just on Safari.
I ran the test on chrome/edge/waterfox on windows, strange enough edge's map implementation is also faster.
Sounds exactly like Titanium Appcelerator, what's the difference?
He's known for cursing, and being a bit of a dick.
One thing the article didn't talk about was that defining a straight onClick on each DOM element could potentially introduce performance issues since you're adding multiple event handlers. The non-react way to get around this was to define a container element that registered a catch-all handler, where the actual event to be executed was determined by the target's id or classList. I'm unsure of react's internal implementation but I would guess that the catch-all approach is used in some fashion since the events that come through are synthetic.
 var hm = new HashMap(); hm.put(15, 'better'); hm.put(25, 'correct'); hm.put(false, 'than'); hm.put(true, 'fast'); hm.get(15); // 'fast' hm.get(25); // 'than'
Does anyone know the minimum size footprint on either iOS or Android?
I'd recommend changing it to a region-specific configuration instead, since numbers generally only follow 3 different rules (use commas, periods or spaces). [See here!](http://docs.oracle.com/cd/E19455-01/806-0169/overview-9/index.html). If it were me, I'd list a bunch of different regex definitions in a dictionary, and use an 'onkeyup' event handler to change the format as you type.
Why not make a web app instead?
Where is the need to use non strings as key?
Interesting. Just curiosity really from somebody who's been using Appcelerator since almost day one. Will give it a 2nd look. FYI, Appcelerator just recently turned to a pay product, all of us older users got grandfathered into a free paid account (not that it helps new users).
How is that better than using the message event?
This page describes best what the issues are: https://www.safaribooksonline.com/library/view/high-performance-javascript/9781449382308/ch03s04.html &gt;When there are a large number of elements on a page and each of them has one or more event handlers attached (such as onclick), this may affect performance. Attaching every handler comes at a price—either in the form of heavier pages (more markup or JavaScript code) or in the form of runtime execution time. The more DOM nodes you need to touch and modify, the slower your application, especially because the event attaching phase usually happens at the onload (or DOMContentReady) event, which is a busy time for every interaction-rich web page. Attaching events takes processing time, and, in addition, the browser needs to keep track of each handler, which takes up memory. And at the end of it, a great number of these event handlers might never be needed (because the user clicked one button or link, not all 100 of them, for example), so a lot of the work might not be necessary. 
Not Idiomatic because of heavy use of synchronous methods.
Because that is the whole point of CSS? Markup shouldn't be concerned with style, only content. 
That page only says it is slow not how slow. All code that you run take some time to run. If there is nothing showing that the speed is slow enough to cause issues, then there is no issue at all.
soisoisoi
Old services in express, new ones in Koa. Microservice architecture :D
Nice. I've been dabbing into koa too. Looks pretty neat how you can create a route that's independent of the main app itself (as in the route can technically work without main app unlike express). `koa-router` was a bit confusing though. Used `koa-route` instead. Any resources that you recommend? So far I've been literally looking at the source code (which is surprisingly clean and simple) to get my hands dirty. 
I suspect you didn't read that at all.
That's a fair point; I didn't intent for the headlines "The Bad" and "The Good" as unilateral criticisms/praise, but I can see how that can be inferred. 
Alright; I made some changes based on your feedback. Thanks for reading!
Nope, sorry.
This works if you don't need to support older browsers. Also look into `transform: translateX/Y(-50%)`
Thanks. That is good to know.
Needs a better hash function.
It does! I'd love if you made an issue or PR to help me out.
So....web components? Which use HTML/CSS? Also, if you're using SASS to manage your styles, it becomes much easier to keep things separate and clean. 
Why didn't you just use an object literal? 
If you are that worry about memory, you shouldn’t be using objects in the first place.
If a method is going to return undefined (meaning not return at all) make it return `this`
&gt; If you are that worry about memory, you shouldn’t be using objects in the first place. Almost everything is an object in JavaScript (even arrays): ``` [] instanceof Object // =&gt; true ``` I'd be very interested to hear alternatives to objects.
A web app sandboxed on mobile doesn't have access to all of the features desired to make a high quality product for what they were making. You should try reading the article before commenting next time as they very clearly explain this.
[Here](https://speakerdeck.com/vjeux/react-css-in-js)
So.... it _shouldn't_ be installed globally? 
I'm not seeing how that would be a problem. I'm talking declaring his whole hash object are a literal over doing `Object.prototype.function` over and over
Yeah there's been quite a few stabs at it... * [static AST](http://jointjs.com/demos/javascript-ast) * [AST step-through](http://int3.github.io/metajs/) * [higher-level step-through](http://latentflip.com/loupe/) Found those in just a few minutes.
It does work on Linux with small changes and also Windows, except watchman doesn't work on windows.
Because *this* changes depending on context/scope but because of closures we can still use the intended *this* by binding it into a variable.
Take this code as an example: function Car(name,route){ this.name = name; this.routeDistance = route.distance; this.speed = route.speed; } Car.prototype.drive = function(){ var self = this; setTimeout(function(){ // `this` now refers to `window` (or undefined, if in strict mode) // `self` still refers to the `Car` instance console.log("Car ",this.name,"(",self.name,") arrived at its destination"); }, this.routeDistance / this.speed * 1000); } var c = new Car("one", { distance: 1, speed: 0.5 } ); c.drive(); // "Car ( one ) arrived at its destination" By storing the current `this` value in a variable, you make sure you can refer to it later (even if you create a new scope, changing the `this` value). It's basically an alternative to `.bind()`'ing everything.
In javascript a function can be called with any context. Usually, you will call a function on an object like this, `object.myFunction();` and inside the function `this` will be what you expect. However, object.myFunction is also a property in and of itself, in javascript, and can be used is different way. eg. function MyObject() { var self = this; this.eventHandler = function(evt) { // what is 'this' in here? Which one should I use? this.counter++; self.counter++; }; this.counter = 0; }; var myObject = new MyObject(); myObject.eventHandler(); // can of course just call like usual. // But how about if my object/component also handles events from the DOM ?? document.getElementById('aButton').addEventListener('click', myObject.eventHandler); To answer the question, when the DOM triggers an event and calls the event handler, it will call it with the 'this' context set to the DOM node which triggered the event. In this case, the button (or whatever it is) #aButton. Usually of course, you would also setup your event handlers inside the construction of the object. Also, [ES6 arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions) (note the "lexical this" section) are designed to help with this, along with [function.prototype.bind()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) - a method on all function object which allow you to create a new function which is the present function, but with a set context. eg. function MyObject(someDomNode) { var self = this; this.eventHandler = function(evt) { this.counter++; }; this.counter = 0; someDomeNode.addEventListener('click', this.eventHandler.bind(this)); }; // Note, I'm passing in the DOM node I want to apply MyObject to! ;-) var myObject = new MyObject(document.getElementById('aButton')); OR, even nicer to look at with ES6 arrow functions ... could make even better with ES6 classes, but let's leave that for later ;-P function MyObject(someDomNode) { var self = this; // eventHandler will be an ES6 arrow function where this is lexically bound to our outer this. this.eventHandler = (evt) =&gt; { // and if we need the dom node, we could get it from evt.target, // or from someDomeNode, since we kinda already know it this.counter++; }; this.counter = 0; someDomeNode.addEventListener('click', this.eventHandler); }; var myObject = new MyObject(document.getElementById('aButton'));
You can get a lot of the native api with stuff like Cordova. You do it for the native ui elements.
What you are describing is a [Call Graph](https://en.wikipedia.org/wiki/Call_graph) . I'm not aware of any tools that will do this for JavaScript. Like flow charts, they are seldom used in practice. 
Well, you could start anywhere but it makes sense to start with ES6 first and use its advantages over ES5 such as modules, classes et. The new specification has some great features and if you'r comfortable writing ES6 than the rest evolve.
Open source version is still free and will forever remain free
It is the same idea. And it is not paid if you stick with the open source variant. 
As an Amsterdam native I'm seriously bummed that I completely missed this.
I get: TypeError: commentData.data(...) is undefined: index.js:14:38 Edit: It's because you're loading data from google docs and that's blocked at my workplace. It's better to check the data is actually there before you try to use it :) Also, `&lt;h5 id="credits"&gt;&lt;/h4&gt;` isn't quite right...
Thanks I'll take a look.
You might just use ES6 and it's arrow functions or .bind. Arrow functions can be placed almost everywhere: classes, Object.prototype.fn, IIFE... if you use babel it gets them right and you avoid adding binds, arrow functions make your core much more readable as well.
Yes it is a LOT slower. I still always go for for. Less issues with this as well. Not that there is a this in this problem though. I think it's better to always use for or forEach. Don't mix and match because it makes your code less straightforward. It's personal preference in the end though. 
Good to know. I still use Appcelerator for everything.
It’s OK as a language (getting better with the latest version, ECMAScript 6), while being very practically useful: * The only native language for web browsers. * Build apps for iOS and Android via [React Native](https://facebook.github.io/react-native/). * Build cross-platform desktop apps via [Electron](http://electron.atom.io/). * Runs on the server, via Node.js. * Can be used for cross-platform shell scripting, via Node.js. Many build tools are written in JavaScript, these days. * Has numerous libraries, which are easy to install via the npm package manager. * Well supported by many NoSQL databases. This is a longer JavaScript sales pitch that I have written: “[Why JavaScript?](http://speakingjs.com/es5/ch02.html)”
You can install new version of the SDK with the Appc CLI, but build using Ti CLI and everything will remain free ;)
All those build tools and I'm still looking for one which isn't garbage and doesn't depend on plugins . 
So you're looking specifically for a build tool which has been written by something with exactly the same build as you? Or you're looking for a monstrosity that includes every tool known to man? What's wrong with plugins?
Hey. Just wanted to let you know that I agree to a degree with some of what you're getting at here. I've noticed a pattern where programmers and developers tend to think "It must be done this way because this book says so." Thinking like that kills creativity imo. And I think creativity should not be hindered, but promoted within the world of development.
Just because someone has connections that doesn't mean they don't have merit in what they do.
The build tool doesn't need to aware of anything. It just needs to let me build up a command line for the tool I want, and then execute it. Executing a tool via its command line interface *is* the standard interface. It is a strange feature of the JS community that build tools have gone down the plugin route. 
You're mixing up syntax highlighting with text editors. A text editor lets you edit text, like Word or Notepad. The syntax highlighting is what makes things like `var` or `if`stand out. Syntax highlighters have different color schemes that turn the different parts of the syntax different colors. I prefer [Sublime Text](http://www.sublimetext.com/3) cause it's fast, it doesn't crash, a lot of designers prefer it and I work with designers a lot, and it works on Windows, OS X and desktop Linux. [Here are some color schemes](http://colorsublime.com/) for it.
Do what currently a lot of people are doing in Europe - Just go in. 
Do NOT look at Typescript, except with a jaundiced eye. Everyone remember JScript?
sublimetext if you want to make your own tmTheme: http://tmtheme-editor.herokuapp.com/
Another vote for https://atom.io/ I'm doing node Addons and this works perfectly for C/C++ and JavaScript.
Benefits of C++ over JS: * Faster * Control over memory allocation Benefits of JS * It can run absolutely anywhere, while you cannot always install or run a C++ application everywhere. * JS code is much faster to write * You don't **need** classes in JS. They are there now if you really really want to punish yourself. * Closure/lexical scope/lambdas are native concepts in JavaScript from inception. * JS is powerful enough now that you can accomplish most application tasks directly in this language without noticeable delay. * No static compile time. The code is compiled on the fly at execution time, so just write your code an run it anywhere. * Because of the previous point you can edit and test this code substantially faster than a C++ app. Things non-JS developers frequently whine about: * Sloppiness - There is a great deal of sloppiness allowed in this language. Just code defensively and build strong coding practices so that this is never a problem. * Doesn't look like Java/C++ class system - This is actually a fantastic quality, but you have to learn to remove yourself from this madness. Read about functional programming. If you attempt to write C++/Java in this language you honestly should fail. * Poor understanding of abstraction - The benefit of abstraction is to allow developers to focus directly on the problem at hand without concentration on low level concerns. I have found many developers tend to either want to abstract how the language actually works thereby allowing them to work on a completely unrelated problem and/or falsely identify the parts of development they don't want to do as low level unrelated concerns. * JavaScript's relationship with the browser - JavaScript runs almost anywhere. Soon Cisco switches and routers will be running JavaScript natively. JavaScript runs on the Windows command line, and anywhere Node.js is installed. JavaScript has nothing to do with the browser directly. A list of external APIs and features allow JS to talk to features of the browser including: DOM, setTimeout, setInterval, File API, navigator object, window object, and others.
Facebook isn't running on React Native yet. The article clearly states that their Ad Manager app is their first cross platform app.
&gt; professional experience in ... Lua Then you know JS. Lua is ~~based on~~ EDIT: *similar to* ECMAScript, just like JS. As an ex C/C++ dev myself, two other things spring to mind: 1. You never have to worry about threads / shared memory again. 2. Prototypal inheritance blows Class-ical inheritance out of the water. *Favor 'object composition' over 'class inheritance'.* is right there at the start of GoF's book ;)
I could see there being situations where you don't want to use `bind` because you want access to whatever `this` is going to end up being.
I do this sometimes (although I know about bind and friends) if I need to reference an object scope in another scope that's nested more than one level, because I think it's usually clearer to explicitly define the scope I want with a meaningful identifier than to use multiple binds. Of course, one could argue that deeply nested callback or closure scopes could be a code smell, but it seems somewhat necessary at least occasionally, especially when writing in a functional manner. 
Webstorm - "The Smartest JavaScript IDE" https://www.jetbrains.com/webstorm/
Have been googling around, no luck in using regular jQuery things such as "range: true" etc. I thought jQuery would be quite flexible in this regard.
People unable to use language properly, rare 'once in a blue-moon' caseslike /u/utuxia said, and just language being dumb(It was written in 10 days so yeah). But isn't the fact JS is damn dumb, highest reason we love it so much? 
this looks great !
Well JS obviously isn't suitable for PS4 or XBox, nor will it compete with cutting-edge, native game engines. As an indie developer though, I don't think I'd have the resources for a game of that scope, so writing a game for the browser platform works fine for me. Plus you get to do some good old fashioned optimization and amaze people that your app isn't native. Also consider that: &lt;canvas id="gamecanvas"&gt;&lt;/canvas&gt; &lt;script&gt;var gl = document.getElementById('gamecanvas').getContext('webgl');&lt;/script&gt; is all you need to start writing an OpenGL app.
hahaha! My laugh of the day. Obviously you're a Microsoftie. No one in their right mind would say what you just did. (And your user name may have given you away, Sime)
What planet are you on? 
Hah! /Patrik, Sweden - the land of the ~~vikings~~ muslims
Just how dead is Polymer anyway?
this thread is a joke 1. var that = this; $('#id').click(function(){ that.mystuff() }); -2. 'oh why don't you just use bind for everything' you take a simple solution and instead add a load of crap on top to look smart, because obv other developers 'dont know about bind'. since code readability and maintainability is not an issue for some of the smarty pants here : http://jsperf.com/bind-vs-clojure 
I'm using Brackets - http://brackets.io/ This one is my personal favorite for doing web stuff ( like HTML, JS, CSS)
"fierceful"?
I'm with you. I know about bind but do it this way because: 1. It works in every enviroment/browser 2. Its intent is clearer than bind 3. It's easier to maintain for people who might not know what bind does. I don't see what the upside of using bind is.
Ahahaha. Not only are you a 'softie but you're a redditor! hahaha
can you run c++ in a browser? 
I got a Fuse beta invite at work the other day. I haven't had time to play around with it except to make a simple hello world app and compile it for both iOS and Android. Can anyone link me to, or explain to me, the major differences between React and Fuse? I know react has been around longer and, therefore, has a community built up around it with libraries and such already. I'm wondering what the fundamental differences in the technologies are. 
I'm OK with things not resembling the C++ class system (I haven't done enough Java to know what that is like). I recognize Javascript as a prototypal language much like Lua is. How do you manage things with Javascript like it's global namespace, lack of modules, and performance? Having everything be an object with variable length keys strikes me crippling, but this might just be acceptable for all the javascript programs people are writing.
I was just bitten by this. Isn't it more efficient to use bind rather than a closed over `self` too ?
&gt; In this jungle, trying to find your way without a **map** will **reduce** your chances of success and will increase the likelihood of a burn-out. The author must have thought long and hard about this :P
If your team doesn't understand bind, apply, etc... you should put together a short presentation and teach them one day over lunch. These really aren't so esoteric that you can ignore them. That being said, if your style is already `var that = this;` I wouldn't change it. Consistency is one of maslow's highest needs in a codebase. 
There is also a mdast-react that I based my implementation on. :) 
I guarantee most people know about `bind`, they just don't make up reasons to use bind when `self` works perfectly fine and is incredibly clear already.
don't forget es6 added `find`
Thank you. Yes that is a great idea, I actually already had something similar in mind but no implemented. But I'm guessing thats the way to go! Also, onkeyup is great, why didnt I think of that?! Thank you for the feedback.
It's because I know all those languages that I am honestly requesting alternative opinions. Everything I know is telling me that it's a poorly designed language, and it seems (looking at ES6/7, typescript etc), that practitioners are aware of this too. And I would classify a language invented by one guy in ten days as coming out of thin air. Unless you know many languages that were invented in a shorter time. Compare to languages like Haskell which took a long time to construct in an academic environment by committee. 
it may be ridiculous to you. to people who write node apps that serve thousands of concurrent users, it is quite useful.
Currently Java and Scala dominate in Finance because they are storied languages that have a higher security spec (not completely secure mind you) than JavaScript. Though I would not throw in the towel on JS learning yet, but instead see if the Java is moving to more of a Services Based Architecture that would require more elaborate Single Page Applications using Javascript on the front-end. I am bias as a Javascript developer who works with Java services though.
Those are some great resources, thanks for your help!
So because one framework does something, it is a good idea? I'm not saying React is wrong, I understand what and why they did that, but React is also serves a specific function and not *every* site needs to use React. 
So.... architecture I try to limit my global footprint as much as possible. The global space should be limited to an exposed API(s). For example: var myAPI = {}; (function init() {}()); I would build all my API keys inside that function. All other variables and other qualities would also go inside that function. The only reference in the global space is `myAPI`, so there is less opportunity for collision, but there is no limit upon what you can do and build with your application code. Most JavaScript applications make heavy use of modules now. There is not a native module system (yet). A native module system is proposed and standardized, but nobody is supporting it yet. This means people are heavily leaning upon build tools to fill that gap. Such tools are: gulp, grunt, browserify, broccoli, and a couple of others. In JavaScript object literals are the slowest and most painful data stores. I only use objects to create methods when I create an API or when I need to store data where the keys are commonly known. If I need to store data and the keys are not commonly known I would just use an array. You can do substantially more, from a data perspective and algorithms, using arrays and they are much faster to access. I tend to avoid inheritance and poly-instantiation in this language. The use cases for inheritance are when you need access to a persistent store in memory that is without constantly being garbage collection since frequent garbage collection will impact performance of a persistently execution application. Examples that would benefit from inheritance are games and applications that perform recursion in extremely long intervals faster than GC can be performed. Aside from those rare (extremely rare) cases where you need consistent memory performance the typical goal of performance in JS is to execute as absolutely fast as possible everything else be damned. Inheritance won't give you this. An understanding of the scope model will certainly help. Another thing that helps with performance is to limit access to external APIs (from within an application) to as few as possible. There is a dramatic performance hit every time you have to leave the language for something. Also, be aware that a poor choice of abstraction may make reading and editing code easier, but at a dramatic performance penalty. As far as code organization I tend to organize all my code as a hierarchy of functions, perhaps how people might use a class hierarchy in C++. This means I am nesting functions, and sometimes deeply so. JavaScript did not get block scope until very recently and it is only supported on very recent software (within the last 1.5 years).
Syncfusion grid is nice: http://www.syncfusion.com/products/javascript/ejgrid They offer a community license now too: https://www.syncfusion.com/products/communitylicense
He has a point. I had first used fierceful in the article, and replaced it later by fierce.
This is a browser issue
To add to the excellent and detailed examples given, it essentially nails down the scope to a variable you can use in other scopes within the main scope. 
Thanks for your comprehensive response! I'm starting to form a clearer picture of how JS is coded in the wild. How do arrays work in javascript when objects have variable size? Are they internally pointers to heap memory or are the objects self describing? I had a little bit of trouble understanding the connection you made between inheritance and garbage collection. Could you elaborate a little? When you say external APIs, do you mean things like system/OS calls? Or do you mean accessing the foreign function interface? How does JS interoperate with other languages? Is it a typeless stack like Lua?
Beware! `.bind()` creates a *copy* of the function (a new *bound function*). So if you do this `x.addEventListener('event', fn.bind(this)); x.removeEventListener('event', fn.bind(this))`, the event will not be removed. You have to store the bound function in a variable and apply it to both methods.
Type checking is indeed part of it, but it's more than just the type (int, float, string, etc). Most of the benefit is derived from taking advantage of type classes (like is this a pointer, or value, is this const or not const). By annotating my variables and arguments, I can signal usage intention to other programmers or my future self and have confidence that the compiler will yell at me if I try to break the contract. Also, it makes it very clear when data copying occurs.
Sometimes `this` isn't what you want it to be..... though that problem is much reduced thanks to the lexical binding of fat-arrow functions.
yeah, just some unfunny humor on my part.
only in fb?
I don't think their are that many methods in Javascript, what your probably confusing with "tons" is the browser's Web APIs. With that, I'm sure you can memorize, and fully understand all the Javascript methods. Now with the Web APIs no, because you will never use all of them, and don't need to mainly due to libraries wrapping around them, or even then if you don't use the libraries, and use them directly, you won't use most of them. Plus their are new Web APIs being talked about/implemented like everyday. 
This is a formatting/CSS issue. It might also be caused by bad fonts, or the browser, or strange unicode characters. Lots of things really. But probably not vdom.
&gt; How do arrays work in javascript when objects have variable size? Are they internally pointers to heap memory or are the objects self describing? Arrays conceptually contain values and/or references to objects (you can think heap here). How they work internally is magic fairy dust as far as I need to be concerned. The JS engine can employ a number of different strategies and/or optimisations. This is one of the benefits of having a language having a programming model which is abstracted somewhat from the implementation. I programmer just use the clean programming model, and the JS engine gets the space to run my code how it sees fit. 
It's well known that web app does not provide all the functionality, and often it is not as high as quality. This is non-controversial. They state clearly they want the speed, fidelity and feel of native applications - that's a perfect explanation why not to use a webapp/sand boxed webapp.
Think about Kotlin too. It falls somewhere right in between Java and Scala. People who work in finances typically use C# or some form of Java because they see static typing as more reliable/safer for the back-ends of big projects... more of an enterprisey sort of perspective. They value safety over raw performance. With that said, you will always need to know JS for the front-end, and more and more enterprises are starting to use Node.
Agreed. The JS core is actually pretty minimalistic. It's worth reviewing and memorizing. However, I wouldn't call it elegant and predictable. I get mad every time I have to reference how Arrray.concat works, for example. 
No
Coming from C++ you need to break the C++ obsession with needing to know and worry about every tiny little detail like stack vs heap allocation for example. 
I thought that humor was pretty funful.
While you're here, I'd recommend either not making the header fixed on mobile, or make it a lot shorter. http://i.imgur.com/3fi6oEa.png
&gt;I get mad every time I have to reference how Arrray.concat works, for example. I know what you mean -- I've gotten pretty accustomed to `Array#push` vs. `Array#concat` for instance, but I still find myself having to look up `Array#slice` vs. `Array#splice` vs. `String#slice`.
Thank you for your feedback, it has been improved.
&gt; JavaScript has a ton of methods. It actually doesn't. JavaScript's standard library is comparatively small. (The DOM stuff is separate. It's just some API which is available in some environments. It's not part of JS itself.) Anyhow, memorizing this stuff is something your brain automatically does. If you do stuff with strings, check the string docs. If you do stuff with arrays, check the array docs. You just do this for a while and you'll eventually remember.
Your first argument was that web apps were not able to perform well, now you are saying that web apps cannot perform better than native apps. Your original statement is wrong, your new statement is right. Native apps should perform better than web apps, but that does not mean that web apps can't perform well.
I think that accessing properties shouldn't be like gambling. In my opinion a developer should know which objects they access with `this`. 
You can also pass `Object.create(yourObject)` instead of just your object. I think "There is no way, by default, to ensure that your Javascript Object you passed into a function will stay as is nevertheless." could be rephrased.
&gt; how many do you have no idea about (obviously hard to put an exact figure on) How is it even possible to put any sort of a figure on that? The possibility ranges from 0 to infinity, and any evidence to support that number means that you have an idea about a certain function, thus removing it from your list.
Awesome articles !
Javascript's standard library is pretty small and abysmal, especially if you reduce it to just the functions that work in all browsers. For example, `Number.isInteger(42)` doesn't work in IE or Safari. Not even in the latest versions. I forgot about this recently and flat out broke my website for half my users until the following morning. The hard part about Javascript's standard library is not memorizing but, but staying up to date with what's available in what browser. This is one of the reasons why libraries like http://lodash.com/docs exist. You can drop Lodash into every Javascript project, use Lodash methods over the native ones, and avoid the situation where you accidentally write code with compatibility issues. Check it out. I recommend speeding up your documentation lookup workflow. I recommend [Dash](https://kapeli.com/dash) if you're on OSX. For example, if I want to remember how the `Array::every` method works in Javascript and Lodash, I hit `Shift-Ctrl-D` to open Dash, and type "every" and it shows me the docs: https://dl.dropboxusercontent.com/spa/quq37nq1583x0lf/rfh0-f8j.png Being able to quickly navigate documentation on demand is more valuable than memorizing things because with quick access to docs, you incidentally memorize things just from the exposure. :)
People who are developing code for the web platform
Is Lodash similar to Underscore.js?
If that is true, then we are on the same page. I still think webapps should at least be considered, I think you agree with me on that too.
Instead of binding, you can use `call()`. 
Yes, but `call()` calls the function immediately, so it cannot be used with `add|removeEventListener()` (which is what I was commenting on)
Again, pointless argument. You don't use the tag because it's been deprecated.
checkout http://lichess.org, and flarum platform(http://flarum.org) is also going rewrite the UI part on mithrill.js
Guys please, pay some respect and don't make mr Norris angry! 😀
That's not what i was arguing about
I'm very happy with Notepad++. It has syntax highlighting for a lot of languages, including javascript, and a vast collection of text editing tools. Useful plugins are textfx, compare and explorer.
Here is my status with the methods by type: * Date, Math - memorized none. I have to look these up every time. * Array - I use push, pop, slice, and splice exclusively. I don't have to look up other methods because I don't use them. * Object - I don't ever use object methods * String - I really just use toLowerCase, toUpperCase, and slice. I always use slice instead of substr and substring * Number - I never use any number methods. I use alot of Node.js methods, but I have to look most of these up.
What on earth makes you think JavaScript can beat *any* JVM language in performance?
My point is that the same company developed them both.
Neat! Looks a lot like [python's doctests](https://docs.python.org/2/library/doctest.html) but with the aditional build step. 
Calling it an obsession might be a little heavy-handed. I like to know how things work. If something breaks, or if something gets hacked, or I lose frames or something, I like being able to look at the disassembly and see what's going on. I want to conceptually know if I'm liking to be doing an L1/L2 fetch, or a call to main memory. This might matter if I'm doing something millions of times or even thousands of times depending on what it is. This doesn't mean I'm *always* thinking about it. Ideally, I only think about it when it matters, but when I need to think about it, I have a way to reason about things. (incidentally, this is one of the reasons I eventually abandoned Haskell, as much as I love the type system)
I just posted my variant of a well-known polyfill [here](https://www.reddit.com/r/javascript/comments/3l0a5w/why_do_developers_use_self/cv2tuiq). 🙌
Thanks for this. I hadnt considered performance concerns involved with `bind`. Leave it to Javascript to give you enough rope to hang yourself with. 
Set some console.log or debugger statements in your code!
Awesome tool! Would love to see some mocha love though... Also, does it integrate with CI services?
You're in luck! We haven't yet shipped it yet but we literally just added mocha/chai support today. Currently you have to use chai with mocha but we tried to make the package as modular as we could so that you can extend it further to fit your needs :) Edit: No it currently does not integrate with CI services.
Seriously? You need to stop thinking of Java as one thing - look at the Spring framework, specifically with Jackson serving up JSON. Also transactions - no mention here of declarative transaction control - start learning the principles of transaction isolation. A large barrier stopping JavaScript devs (or UI focused devs in general) working on boring/serious apps is their lack of awareness of transaction boundaries.
For starters, Node.js beat Java during benchmark tests at PayPal, plus they are using it in production now. Node.js served double the requests and had a 35% decrease in the average response when compared to Java. https://www.paypal-engineering.com/2013/11/22/node-js-at-paypal/
Thanks :) I have Dash on my computer/phone. For the JavaScript docset, it lists 2766 methods, 652 classes, 268 events, and 45 functions. Are the methods listed mostly unused, or not technically methods? Do you know of a good list that summarizes or simply lists all of the mainly used methods (things like CacheStorage.match and CameraCapabilities.flashModes)?
But not the same team. I personally dislike Facebook, the product. But I love Facebook, the company that makes open source stuff like React. Most likely, it's different teams working on them (though they might merge at some points).
So you think it's impossible to recognize and learn from mistakes?
New buzzword in finance (IB in UK) lately - the 'full stack developer', seems all the rage and mentioned in an increasing number of job descriptions. Jack of all trades, master of none. Then again, it's not about how good you are, it's about how you sell yourself. Currently I am having to cross-train some of our Java devs into JavaScript to that effect. It's not fun. I imagine the opposite (to Java) will be easier
Great idea!
Would you mind clarifying a little bit? Are you referring to before-hooks?
Hi, I run a dev team in financial services. We do use Java to provide our web service APIs and calculations engines, but truth be told we don't do anything terribly exciting in Java (unless you're a programmer with a background in actuarial maths, then you might enjoy the engines more). The fun stuff is all in the front end, as that's where we do all the interaction and hold all the application state. JS is where our apps live and die, it's where the complexity and challenges are. 
Do you actually work with Javascript? as in a web developer or something
Bring them TypeScript, its compile-time typesafety is Good Enough(TM). The dev environment is almost there and I foresee TS2 taking the world by storm.
 console.log("Suddenly, Bieber stops and says, 'Who wants to race me?'") var userAnswer = prompt("Do you want to race Bieber on stage?"); if (userAnswer === 'yes') { console.log("You and Bieber start racing. It's neck and neck! You win by a shoelace!"); } else if (userAnswer === 'no') { console.log("Oh no! Bieber shakes his head and sings 'I set a pace, so I can race without pacing.'"); } only change = to ===, "else" to "else if" and no/yes to 'no'/'yes' ;)
To learn more about the subject, and have maps in older browsers 
didn't read the text under your code :p .. So you do this with a loop ;) console.log("Suddenly, Bieber stops and says, 'Who wants to race me?'") var userAnswer; while(userAnswer !== 'yes' &amp;&amp; userAnswer !== 'no') { userAnswer = prompt("Do you want to race Bieber on stage?"); if (userAnswer === 'yes') { console.log("You and Bieber start racing. It's neck and neck! You win by a shoelace!"); } else if (userAnswer === 'no') { console.log("Oh no! Bieber shakes his head and sings 'I set a pace, so I can race without pacing.'"); } } 
Thanks a lot
Their Java implementation was much worse than Javascript in terms of coding quality as I remember so it's bad example. 
A new Node application beat out an existing Java monolithic application, added to over a decade. That's not hard to do. I have seen code for old monolithic Java applications, and it's terrifying. JavaScript/Node/V8 isn't a magic bullet, but enterprise usually finds it easier to justify rebuilding an application on a new platform because, "We think the code we have now is crappy," usually doesn't fly with management, where, "There are some great opportunities for improving *xyz* on Node!" is an easier sell.
Bro, the one you pointed at the bottom of the comment (BotDetect) is not the joke you were breaking in your article. We are ready to bet you that you will not come nowhere even close to 0.1% on a million randomly generated ones in the default configuration. And the most likely you will end up being some orders of magnitude under the above mentioned threshold. Wanna try :)? 
Read through the source. Saw the primitive hash function that you rolled, thought it was pretty cool. Then saw the potential for multiple keys to collide on the same hash. Then checked if you had buckets, and you did not. Kind of makes it unusable doesn't it? # calculateHash("shores") == calculateHash("shot's") true # calculateHash("probes") == calculateHash("prod's") true # calculateHash("hood's") == calculateHash("iPod's") true Anyways, cool stuff
memorizing api's is a waste of time. Especially with modern tools. Learn the syntax of the language your working with, and hopefully you use a well supported library kit / framework which has reasonably good documentation. Memorization only occurs when you use a single product all the time, in which case if you are, you should probably find some place not trying to sabotage your career.
Hashes are not guaranteed to be unique (just like Java's), although there definitely is a higher rate of collision than there should be. I'd love any help I could get with it though.
I don't know if he is, but I would love to see before and after hooks in use with this. Normal tests can get pretty complex. I find myself using sinon and other mocking on functions under test as well as loading JSON fixtures from files to provide data to crunch and to check test results. I am wondering how this would all work given the comment syntax without getting out of hand.
https://github.com/ericelliott/essential-javascript-links
Thank you. I'm going to play on code wars later tonight and practice a little bit. 
Doing something about it when you can is ideal, but if it is not in your power, complaining is better than nothing.
Not long ago, in Waterloo, Ontario, I was asked by a group of CS students what to do if they were told to use `new`, `this` or `self`, and I answered, "Just say no."
In a good part you have right. the variants are all intentionally made to be as easy as possible for humans. And spammers are kept at bay by randomly choosing among 60 (and counting) of them. So forcing spammers to make 'filters' for many variants, and the code that recognize what variant it is dealing with. What as you noticed by yourself is just not worth the effort; considering that it takes us less time to develop a new variant than to spammers to write a code for breaking them; not to mention that affected user can simply turn off the affected variant in no time.
I think this is important. I would look into adding this functionality, if you were interested in continuing the library.
Oh come on, it's simple: as we know, there are known knowns; there are things we know we know. We also know there are known unknowns; that is to say we know there are some things we do not know. But there are also unknown unknowns – the ones we don't know we don't know. Now hard is that?? (Interestingly, while everyone gave Rumsfeld a lot of shit for that, nothing he says is technically wrong... it's just so convoluted-sounding that most people couldn't follow the logic and reverted to making fun of him... but, correct or not it *does* sound nuts!) 
HTML5 range doesn't support more than one handle (not overly happy about that fact). Had to use jQuery slider for that problem.
Transpile was a new word for me, thanks. Also, I plan on experimenting with React Native soon. Incidentally, I'm bullish on both C++ and JS actually (albeit for different reasons). If you haven't seen C++14/17, you should give it another look.
Can you give me a brief summary of why there are so many? I was trying to look at a bunch of them but I haven't had my boots on the ground yet to understand the feature differentiation.
Ok I'm a little confused. In your documentation what is the variable `scriptContent` ?
I am so sorry. You are right. I am too angry. I will try to be less angry in the future.
I honestly don't understand the point of this. What advantage does this give over using native maps? Not attacking, but genuinely curious.
Except the entire view layer uses native element... Hence the name.
[removed]
The downside is that you need to know the detailed behavior of the loose equality operator in order to understand in full that the code is correct.
Seriously, there is no specific number figure. I remember things sometimes and other times I forget things that I shouldn't. For example, the other day I embarassingly forgot about string.split. I ended up writing a regular expression that did the same thing and then realised afterwards the split method did the same thing. So I don't know. I have the general mechanics of Javascript down (if statements, switch/case, prototypal inheritance), but when it comes to other parts it all depends on how much sleep and/or caffeine I have had.
Obv. because Gulp sucks.
&gt; The fun stuff is all in the front end, as that's where we do all the interaction and hold all the application state. JS is where our apps live and die, it's where the complexity and challenges are. I see the exact same trend in the financial firms I am working with. 
Seriously, how can you say that JavaScript is viable for a real enterprise application ? Concerning the monitoring of the thread, the stability, the huge API available in java to connect every system. To me JS will die, it is just a temporary trend, they try to put it on server side as it is not really working well on client due to compatibility reasons.
But the former impossible ?
/u/ruinercollector's answer nails it
&gt; I have been coding using JavaScript for more than a decade now. How did you avoid picking up a book on Java or even just running through the [Sun tutorials](https://docs.oracle.com/javase/tutorial/) (yes I know Oracle has removed all the Sun branding) our of morbid curiosity? Are you a programmer or not? I would expect any programmer to dabble in a variety of languages - because they love programming.
You're looking for 'Linting' tools, specifically SublimeLinter in your case. Be sure to follow the instructions to set it up properly, iirc it's more than one package.
More examples would be nice.
I don't have very fond memories of Spring. 
You should probably get into both linting and testing if you plan on doing JS for some time. You can use Node.js to constantly watch your code and run linting and tests every time you save the code. I recommend [tape](https://github.com/substack/tape) for testing. It's quite simple to start out with and you get assertions for free. Good luck. :)
You could also try using a 'confirm' dialog for yes and no questions var answer = confirm("Do you want to race?"); if( answer ) { alert( "You race and the cheerleader becomes your girlfriend." ); } else { alert( "You decline, but that turns on the cheerleader next to you and she becomes your girlfriend." ); }
The reason I've created it is because I'm working with an international team and sometimes my colleagues forget to chat in English, which makes other team members uncomfortable. Traductor can detect if the message is not in English, translate it and give the translation back in a form of a reply to original poster in the same channel/group. Also the bot will kindly ask to use English. It's also possible to suspend the bot for 10 minutes in current channel/group with a special command "stop", like this: "@traductor: stop". More info and source code in the repo.
So what do you actually want? You're saying no to calling the tools directly because you want more, and you're saying no to gulp plugins that are very thin wrappers around the tools or sometimes just [the tools themselves](https://github.com/gulpjs/gulp/blob/master/docs/recipes/browserify-transforms.md), because you want less. Clue: There is no middle ground. You're looking for an integer between 2 and 3.
&gt; If it's perfect, it'd be slow as f. Not true. Dynamic perfect hashing algorithms can be quite fast if well-implemented, and can ultimately result in O(1) amortized time complexity for insertion and searching operations. The [broad strokes are laid out in these class notes](http://courses.csail.mit.edu/6.897/spring03/scribe_notes/L2/lecture2.pdf) in section 4.2.
Don't know if there is a performance difference, but the second option is in almost all cases the better option. 
 const isTrue = true; function moreStuff (input) { let something = false; if ((input &gt; 1) === isTrue) { something = !(!isTrue); } } Is it better now mate? 
* Invariant/covariant/contravariant types (T, +T and -T) * Refined types (new Foo {...}) * Structural types (x: {def y: Int}) * Path dependant types (a.B) * Specialized types (@specialized) * Self types (this =&gt;) * Projection types (A#B) * Existential types (M[_]) * Type bounds (&lt;:, &gt;:) * Type constraints (=:=, &lt;:&lt; and &lt;%&lt;) * Type members (type T) * Type aliases (type T = Int) * Type classes ( (implicit ...) ) * View bounds (&lt;%) * Higher kinded types (* =&gt; *) * F-Bounded type polymorphism (M[T &lt;: M[T]])
What the fuck.
hey reddit, can you solve undecidability for me?
I've been doing this for ten years and I regularly have to look up the difference between `call` and `apply.` Because knowing that is pointless when I can look it up on google nearly as fast as I can recall it. I remember basic things like control structures and functions and the shit that I use constantly. But I'm always looking up "javascript check if number" or "javascript find key in array." Knowing the syntax of doing something is way less important than knowing when and why to do it.
I didn't do prototype.get because closurecompiler will obfuscate it. As for deleting vs setting to null, deleting is much slower.
Browser compatibility.
Thanks!
I think JS is ubiquitous with anything web (especially front end). It's not going anywhere. With ES6, JS will continue to thrive on the backend as well, but I agree it may lose some steam over time.
Not really a reply to your question but, Google Chrome's developer tools are at least as good as firebug if not better. You should check them out at some point. 
how about just try it? 
They were able to build the same functionality *new* in Node faster and with fewer people than in Java. They did not start from scratch on the Java side. Because the company I work for is currently invested in a monolithic Java architecture, this issue and example are very dear to me. I've read the blogs posts and watched talks given about the change over and the development of Kraken.js. They did not start over on the Java side; they developed new functionality on their existing monolith and discovered it was much more efficient to start fresh on Node. The event-driven design almost certainly has an impact on the performance. Java design, particularly older monolithic applications, are built on massive layers of inherited classes and a huge amount of data structure. Javascript development has mostly moved away from instantiated data "classes" which are the stock and trade of Java. Closures and callbacks and promises let JavaScript maintain and pass lean data objects with minimal overhead while Java dev are generating copies of keys that are built based on other values that are hidden because it's easier to make another key than rename the existing one that's used dozens of places (I have seen this happen). At the core of it all, the JVM is a better optimizer than V8. V8 takes a series of shortcuts, like performing optimization for the data type currently set, and destroying and re-compiling the function if the data types change. If you write *equivalent code*, not just the same functionality in two radically different ways, Java should win in final executed performance. I still would much rather develop in JavaScript and Node than Java. Skim through [this article](http://blog.paralleluniverse.co/2014/05/15/modern-java-pt3/) which talks about how a number of the established practices and tools are part of the problem in modern Java development.
Have you tried just using canvas (or better, for devices that support it, webgl) directly? If you want great performance, webgl is the way to go, but you need to study how it works. There's no 'blitting' in webgl. You're in web programming land now. Direct access to hardware is not something you get to have anymore. Try not to do too much pixel pushing in JavaScript. It's not as good at it as C. 
You did, but I cannot use this because the images I am using are much larger, and yours slide in, which causes the images not to work correctly. I tried to work around it, but couldn't find a good way.
Glad it works for you! :) Please let me know if you have any questions!
No better answer than this. It's like asking the question "Why another jQuery plugin?"
Well, one thing, when paused I cannot "unpause" how could I change that?
my question ^^^ haha &gt;.&lt;
Of course It gets absolutely the same result in the end. But: If you've ever had the misfortune to code in Perl, you would understand why abstracting and reducing a line of code to its absolute essence is a nightmare for anybody else to read your code. Thats why including an actual 'if' when you indent to do an if operation makes it much easier for the next poor sod who have to read your code. Not as sexy, not as smart, but uniform and easy to read.
Thanks alot for your feedback! This is very valuable information.
Exactly, I don't know how hard is it to get going with his example... it's a inline assignment, you see those everywhere. Some tips that can make you write less with the same end result.
Why didn't just do object literals? Saves you from writing `Object.prototype` over and over again. var HashMap = { /** * Creates a new HashMap. * All keys are calculated down to a numerical hash. * @constructor */ init: function () { this.entries = {}; this.length = 0; return this; }, /** * Gets the value associated with a certain key * @param key the key to get the value for * @returns {*} the value stored, or null */ get: function (key) { // Code, etc. }, // More properties } var hm = Object.create(HashMap).init(); hm.functionName();
&gt; C++ engines like SDL work in different way where you actually blit every single texture on screen and sprite during your render loop. If you want that kind of thing, just use the Canvas API directly. &gt; With SDL I could just prerender every y-line to texture You can do the same with Canvas. Create an off-screen canvas, draw to it, then draw it onto the on-screen canvas as if it were a regular image. I'm using an off-screen canvas in this demo: https://dartpad.dartlang.org/89e91a34b3262049bc98 This is Dart, but it works exactly the same with JS.
Hey! Thank you for answer! I would just want to ask if there is any library that is a wrapper for this? because I would want to draw things using webgl as well, and would need something like SDL that allows me to draw using webgl with html5 canvas fallback :)
Transpilers are a thing..?
You've confused a "perfect hash table" with a "perfect hashing function". A perfect hashing function simply doesn't exist in the general case (just think about it, it would have to return a huge number of bits to uniquely hash every possible thing in the world). The method described in section 4.2 is basically a more advanced version of the buckets I was talking about, where each bucket is another hash map that uses a different hashing function, so the chance of both hash functions colliding is pretty low. And then they describe a method for changing the hash function on the inner hash table dynamically in case there's a collision to keep the table "perfect". Anyways yeah, not a perfect hashing function.
Or just use "scrollBy" for relative scrolling (evergreen browsers only). window.scrollBy(0, -64)
Thank you for the kind words and your additions, very much appreciated.
I had no idea scrollBy was a thing... And I'd never heard that term evergreen. Thanks for giving me a heads up on both!
Why are you not sure exactly? You were missing the h in quoth, what's the problem?
SlickGrid Handsontable w2ui Backgrid.js
Hi /u/Codesurvival, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
If you're working with AngularJS, then UI-Grid is the way to go: http://ui-grid.info/
could you tell me more about no blitting in webgl?
Yeah... you could use the Chrome [Custom Javascript](https://chrome.google.com/webstore/detail/custom-javascript-for-web/poakhlngfciodnhlhhgnaaelnpjljija) extension to do it. Codecadmey is good... except for explaining DOM manipulation. You're going to want to look in to `.getElementsByClassName()` and `.getElementsByTagName()`. The `.open()` method will probably come in handy too; `.click()` as well. 
You should probably be looking elsewhere. Those are hot technologies and that's an extremely low number to be working in them.
Programming professionally for 18 years. I work with .Net backends and Angular/JS frontends for a big fortune 100 co. $111k + benefits in AZ. I'm an oddball though, I've got tons of experience but no degree. I got the job I was going to school for while still going to school.
Sorry, yes, I should say you are using them indirectly. A program that doesn't use file descriptors, ports, etc, is unlikely to be useful :)
will do, thanks for the suggestion. I still have much to learn, but I figure the knowledge will be useful in a general kind of way regardless or not of whether I can directly apply it to this project
No prob! Sounds good, please feel free to message me if you want any help!
mate, mate, this is EXACTLY what I was thinking about. hell I don't even know how I could improve it beyond simply inputting my list of terms into the array... You have no idea how much this helps me. Just a couple of questions: how does the program know to work itself down the list? I understand how a "for" function works, and how the ".length" works, but I cannot see how it interprets "terms.length" as an indication to keep working its way down the list. second, how did you know what the exact google URL for "news in the past 24 hours" was going to be? I tried to find it out by inputting a something simple into google, setting it to "news in the past 24 hours" and seeing if there was a piece of the URL that I could cut, but I got https://www.google.co.uk/#q=hello&amp;tbm=nws&amp;tbs=qdr:d which I can't really understand. Is there a resource where you can find this kind of stuff out? And third, how would I go about saving this into an file that I can run from anywhere? I just want to say, thank you so much for this. You've saved me dozens of hours of boring work, the code is simple enough for me to understand, and it just works so perfectly. I have skills that are probably useless for someone who works in IT, but if you need a translation to or from English, Arabic, French, Spanish or Romanian, or proofreading, or something along those lines, let me know. Considering how much time you've just saved me it'd be the least I could do. 
It looks like you're trying to implement something like: s/black (and|&amp;) white/black white/ But your code ends up with odd things if an earlier part of the string contains " and " or " &amp; ". "red and black and white" turns into "red black and white", which may not be what you want. Consider this single line alternative: keyword.val( newValue.replace(/black (and|&amp;) white/, "black white") ) 
This is perfect, thank you! Anyway to simplify the conditional? 
Don't use the conditional at all. Replace your entire code there with only this line. This code handles both cases.
Perfect! Works exactly how it should. 
Here are some: [Bootstrap Tour](http://bootstraptour.com/) [Shepherd](http://github.hubspot.com/shepherd/docs/welcome/) [Intro.js](http://usablica.github.io/intro.js/) [Tourist.js](http://easelinc.github.io/tourist/) EDIT for specifically Angular libraries: [Angular Tour](https://github.com/DaftMonk/angular-tour) [ngJoyride](https://github.com/abhikmitra/ng-joyride/)
Thanks for the reply, I am going to link Michael to this. That is a fair bone to pick. I don't have a good answer. I don't want to be soliciting misinformation through the podcast, and I know this doesn't absolve me, but we do want to err on publishing strong opinions even if there is a bit of bias--and it's hard to know how much bias/misinformation there is because SE Daily covers a lot of topics, and beyond a thin surface level, these topics get super opaque to from a journalistic level. If you listen to the Bitcoin episodes and the Ethereum episodes, you will hear my opinion waffling back and forth on who I trust. I do try to adhere to the a16z mantra of "strong opinions weakly held".
It's like you pass some information to a person to do a task, leave an incomplete message that he has to work on, when he finishes it he calls you back and you go and take the final processed message and do whatever you want with it. Person = findYear(car, callback); Note = callback **Me**: Hey **Person** can you say me when this 'Ford' was built? findYear('Ford'); **Person**: Fine, I will need to search through the files and I will call you back when I'm done! function findYear(car) { var buildYear = searchOnFiles(car); } **Me**: Oh I almost forgot! I'm leaving here the **Note**, can you pass to him the information? findYear('Ford', function Note() { }); **Person**: Cool, I will. (searching for 'Ford' information about when it was built) function findYear(car, callback) { var buildYear = searchOnFiles(car); } **Person**: Hey **Note** here it's the information (2013), I found it! function findYear(car, callback) { var buildYear = searchOnFiles(car); callback(buildYear); } **Note**: Great, i'm going now! findYear('Ford', function Note(year) { window.alert('My Ford was built in ' + year); });
When a friend is coming to visit you give them your phone number and tell them to call you when they get to station so you can pick them up - the phone number is call back "interface" you pass to your friend, you picking them up is the function and them calling you is the call back being used. 
You take a certain medicine every day at 1:00 P.M. It's 11:00 A.M. and you notice you are out of medicine so you go to the pharmacy to get the prescription refilled. The pharmacist says that it will take 2-3 hours to fill the prescription. You ask that they call you when it's ready and the pharmacist agrees. You go back home, 1:00 P.M. rolls around, time to take your medicine. Medicine is still gone. (this is a problem you might encounter) 1:20 P.M., you receive a call from your pharmacist that your refill is ready and you go get it, i.e., you run your getting medicine routine.
This is really good. So let's say Anna goes out and I go out with her. As she's juggling balls she tosses one to me and I write a word on the ball and then toss it back to her. Is that like using a callback function on Array.filter?
Are you saying a callback function is like an assembly line?
How does that work with a modularized app? Looks cool.
Sounds like you need Google alerts: https://www.google.co.uk/alerts Let me know if that helped :)
You receive a package in the mail. While this package may possibly include some data, the most important piece of this package is that it includes an envelope addressed back to the package's sender (postage paid for of course!) You may use some data in the package, or generate some of your own, but you for sure have a way of recontacting (calling back!..) your original sender. function waiter(callback){ console.log('[waiter] Wait for 5 seconds!'); setTimeout(callback,5000); console.log("[waiter] Wait for it!.."); } waiter(function(){ waiter(function(){ console.log("[process] I've waited long enough!"); }); console.log("[process] I'll wait!"); }); Edit: [Async.js](https://github.com/caolan/async#control-flow) deals a lot with callbacks for control flow (it'll be great when you understand callbacks!) 
https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Visualizations_with_Web_Audio_API
Very nice work! 
Your point was that the language is 2 decades old, and didn't meet your criteria for "appearing out of thin air", my counter point is that we were interpreting that phrase differently, and the quoted point I made about legacy quirks is reasoning that justifies the alternative interpretation of "appear out of thin air" as being a legitimate complaint. Separately, you are the only party in this conversation choosing to be rude/dismissive of others, so how about giving that a rest.
[**@polymer**](https://twitter.com/polymer): &gt;[2015-09-16 16:59:37 UTC](https://twitter.com/polymer/status/644193936140042240) &gt;Shadow DOM v1 status &gt;Chrome: [*groups.google.com*](http://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/Ez2cuT0KmQo) &gt;Saf: [*bugs.webkit.org*](https://bugs.webkit.org/show_bug.cgi?id=148695) &gt;FF: [*bugzilla.mozilla.org*](https://bugzilla.mozilla.org/show_bug.cgi?id=1205323) &gt;Edge: [*dev.modern.ie*](http://dev.modern.ie/platform/status/shadowdom) ---- [^[Mistake?]](/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/3l8poe%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
My guess is: https://nodejs.org/api/cluster.html#cluster
Get used to looking at the console as your first debugging step. Your code is broken right off the bat because you're trying to reference a bunch of local files that don't exist -- `vis.css`, `vis.js`, and `wc.ogg`. These all show up as 404s in the console.
Object.assign deserves mention.
This is what I want to know, and like the other comment said it's probably just cluster, which I believe is basically fork if I'm not mistaken. It's a separate process, not threads.
But at least it can use multiple processors then, so it is something.
Can you do something for me? Find out how much in taxes do I have to pay. Here's the data you need. I'm gonna do something else. When you're done, please text me and tell me how much do I have to pay. Thanks.
Can anyone: ##ELI5 - Shadow DOM?
A friend suggested to me that you should always try to interview with companies that you don't care too much about first. That way you can get used to interviewing and so be prepared for the interviews you do care about.
Ok, I guess my point was that there's no way the fiddle is going to run correctly with those 404s. If it's also not working locally then there's something else wrong, but it'd be easier for people to debug from the fiddle if it didn't have broken links.
Could you please provide a use case to use this in the client?
I've never written a chrome extension, but I see the reason it is probably not working. You are calling `notif()` immediately, and it is not waiting for the response from the Reddit API. You need to move it inside the $getJSON callback: $.getJSON('https://www.reddit.com/r/hockey/new.json?sort=new', function(data){ console.log(data); postName = data.data.children[0].data.title; notif(postName); }); Also, you'll see that I am passing the postName variable to the notif() function. You can set up your function to use this variable by defining it as one of the attributes: function notif (postName) { var opt = { type: "basic", title: "Push notification", message: postName, iconUrl: "reddit.png" }; chrome.notifications.create(opt); } 
Love it!
Perfect! Thank you.
Am I the only one around here that finds webpack difficult to configure in comparison to gulp? Don't get me wrong, the bundling features are second to none, but I want that as a piece of my build, not taking over the whole thing. And why do I want to load static assets via js??
Reddit to the rescue! Thanks to everyone!! This definitely cleared it up for me!!
Lol. I guess my tongue-in-cheek-ness wasn't obvious enough. But not using classList for addClass, removeClass, and toggleClass was on my list and I just made those changes. Cool note on the length property. I'll have to look into that.
I really don't see what's supposed to be funny about this. Modifying objects you don't own is a stupid thing to do.
Chrome and Opera are the only ones that have [released their own versions](https://dev.modern.ie/platform/status/shadowdom/). And form elements are styled differently because historically, those were created using methods from the host OS, thus forms on Windows and Mac were different, and forms on XP and Win7 were different, etc. They've experimented with allowing CSS to styling, but support has ebbed and flowed since some ideas worked great, and yet other ideas didn't. [MDN explains it better than me.](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms/Styling_HTML_forms)
That would be inaccurate
Use case is pretty much anything you've ever wanted to do client side but was limited by single threaded performance, you can write any arbitrary function to run on its own thread. Additionally you can split single functions across multiple threads for true parallelism, also one project I released so far using this is lzwFloss which is a multithreaded lzw string compression library useful for providing data compression for json xhr request without impacting user performance
https://www.youtube.com/watch?v=i6LGJ7evrAg Each beacon (function) being lit (run) in turn has another beacon (function) that is lit (run) when it completes/returns.
Yeah bro, it's pretty impressive to see when you change the strength of the green dot, and then particle start to rotate it like ISS rotate around earth. It is damn cool. Glad you liked it. 
I've always liked metaphor iof it being like a return address for a letter. When you call a function, you are sending a letter. The contents of the letter are the parameters passed to the function. Providing a callback parameter is like including a return address for your letter, so that the recipient can write a letter back to you if they want. 
Another, more direct answer, is that it's a like return value that can be received asynchronously.
React isn't the same though, it manipulates the regular DOM, just like every other view library currently (except Polymer?). The *virtual* DOM it uses doesn't serve the same purpose as the shadow DOM, it's basically there for fast diffing. The shadow DOM and web components are something of a not-yet-ready competitor to React components.
Personally I've noticed JSDoc is more relevant to server-side code then client-side code. I think it's mostly because server side JS code makes heavier use of very small modules which leave room for the somewhat verbose documentation of JSDoc. In Angular, at least for me, as my controllers grow steadily longer the last thing I want to do is commit a further ten lines to document a function that executes a very obvious control flow (say ng-resource with a callback that modifies a property on the scope..).
I don't see this working for any non-trivial tests.
Yes, I've seen so many people confusing this two concepts PSA: SHADOW DOM !== VIRTUAL DOM
Anyone know if web components will ever let certain global css rules get inherited by the children components? 
&gt; The shadow DOM and web components are something of a not-yet-ready competitor to React components. Not really competitors, React components could be reified to shadow DOM. In fact that might be pretty cool.
The ability to create sub-trees opaque from the parent and self-contained, so they have their own styling and selectors which don't bleed into the external document, and styles and queries in the external document don't match stuff in the sub-trees. It provides for greater separation and isolation between "components" and the page's primary DOM. Technically this already exists (to an extent) with `&lt;video&gt;` for instance, there just isn't a clean API to interact with it, and developers can't create new ones in JS.
Shadow DOM is still DOM. That means they would still affect your performance as regular DOMs do. Also here is video from the Polymer Summit that points out why it's a bad idea to create more than a thousand elements. (I linked it to the time it was mentioned.) https://youtu.be/Yr84DpNaMfk?list=PLNYkxOF6rcICdISJclfQhj2S8QZGjXV8J&amp;t=1161 PSA: Don't do thousands of DOM nodes. Keep it lean people.
There is \&gt;\&gt;\&gt; and ::shadow. But these selectors are really unwieldy and essentially breaks the encapsulation that Shadow DOM promises. They are now being deprecated. CSS variables are now seen as a solution for styling web components.
 Unfortunately it does not work with React Native. I haven't worked with React Native yet and don't know much about UI libs for it :(
There are a lot of libraries out there that virtualizes lists to display large amounts of data.
See http://playgroundjs.com/ and http://canvasquery.com/ for something simpler.
Ad blockers do not rely on DOM but rather on domains, therefore no impact on ad blocking.
You have forgotten Knockout or Aurelia, both great and Aurelia seems to be a real contender with Angular 2.
Angular 1 is still used extensively in a lot of companies who have been building their product(s) in the last 3-5 years. You will probably find more jobs in this area than React at the moment. However, I still believe React will become much bigger over the next year or two. So it kind of depends. If I wanted a job right away at a stable company, I'd go for Angular 1. If I wanted to go for a startup or just lay a nice foundation to get ready to work with web dev, I'd pick React. I'd consider React more future-proof and I say this as an Angular dev.
Please re-format it if you don't mind.
This - this video, mindset, common misconception - is one thing that really frustrates me about the website development community. 1,000 is a *very small* number for a computer. If you need to limit the number of X on your page to 10 or 20 or 100, then X is *very very expensive*. And the bottleneck is not the DOM. The browser can render 10,000 DOM nodes in a few milliseconds, as it does on any decently-sized reddit comments thread. The bottleneck is the way that you implemented X. And, without fail, these videos saying absurd things like "limit your tables to 100 rows" come from people pushing frameworks that cut deeply into performance. (Like Polymer. But I don't fault Polymer for that, because it was always a "write the future today, get the performance tomorrow" framework.) So my question remains, will shadow DOM be as fast as directly appending children - which is fast enough that we can do it 10,000 times on a page - or something with a significant overhead, that we need to limit? The polyfills certainly need to be used sparingly, but I would expect a native implementation to have an advantage.
It's not "can", there are very few websites that load under 1,000 nodes. Even a Google search loads around 800, and that's as lightweight as it gets. I certainly see the value in eliminating thousands of *unnecessary* nodes, I'm just saying that if your page has 5,000 nodes and takes too long to load, the node count is not your problem.
&gt; Angular is a framework, but has a unique API which means you will be learning Angular specific idioms, which would have little use outside of that framework. Having started with Angular at my last job, and making the switch to React at the new one, I can appreciate this comment. Angular is extremely useful if you follow their patterns, and it will get you to market very quickly with relatively little headache, but you're committing that product to Angular from that point on. As long as you're aware of this fact, and trust that Angular will be well maintained for the product's lifetime, then go right ahead. Once you start considering how to separate your concerns out, though, React starts to make a lot of sense at the view layer.
&gt; Lots of legacy maintenance apps for JQuery Ah, the new COBOL
Can you elaborate more on the patent angle? This is news to me
I agree if you look at the job market, but just because there are less jobs (aurelia is still in alpha I think) it doesn't mean the frameworks are any less or anything. For the life of me I cannot understand why people would choose React given it wants you to have your view markup in code, it seems a horrible monster unless you use one of the template plugins to separate the view from the code (which is what most other sensible JS ui frameworks try to do).
Extremely exciting news! I've long expected the Web Components set of standards to eventually become relevant, as the current "state of the art" of a single, globally shared DOM is an increasingly ridiculous foundation on which to build complex and interoperable frontend applications. Sadly, their pace of development everywhere but in Google-Land has been quite disappointing.
For the people who downvoted me, read your damn license files :-) Do not blame the messenger. It is especially stupid idea to bury my comment, because then people like ridicalis may have hard time to see critical information like this.
Thanks for all of those! Looks like I should have been googling "tour" instead of "walkthrough" and "tutorial". 
Help me out with this please? https://www.reddit.com/r/javascript/comments/3lambr/how_to_change_this_code_to_support_an_image/
I did a bit of research on this as part of my Master's Thesis. Here's the [relevant jsperf](https://jsperf.com/shadow-dom-cost); sadly, since the results were originally gathered late last year, jsperf seem to have lost them. You can generate new test runs, though. Anyway, the original aim was to measure the comparative costs of various mechanisms for isolation within the DOM, hence the inclusion of the &lt;iframe&gt; (currently the strongest form of DOM isolation money can buy) and a plain-old &lt;div&gt; (as a baseline). Keeping in mind these types of benchmarks are [fundamentally inaccurate on small scales](http://calendar.perfplanet.com/2010/bulletproof-javascript-benchmarks/), [my results](http://imgur.com/YWRNMJX) indicated a **very moderate performance penalty** for using shadow roots instead of simple elements, the latter being only about doubly as fast. Compare this to the several orders of magnitude slower iframe, and its significance shows: you get a good chunk of the same isolation guarantees, for a fraction of the cost!
 buttonDom.innerHTML = "&lt;img src='" + (isPlaying ? "play.png" : "pause.png") + "'/&gt;"; Might not be best way though. There would be that loading time for the image since you're reloading the &lt;img&gt; with every change. You could load both images and have them hidden with css "display:none", then hide/show them as necessary.
Dude, learn to google it. Dynamically adding or removing an image to the DOM is basic stuff, no need to ask on a forum. Just ask the googles and you will find thousands of resources. 
I google things like crazy, just seems like I can't get it to work, I only ask here because I love asking you guys, I always get good responses with good explanations.
i had read /deep/ was deprecated and replaced with &gt;&gt;&gt;. they are scrapping this idea entirely? any info on how we're expected to target elements within components now?
Aye. Well put. Full Stack Js dev weighing in. React is the way of the future. Angular is merely a stepping stone along the way. That being said I still use angular in very few use cases. Proof of concepts or coming into an existing backend, angular is easier to hook up and gets good results quick too. 
 setTimeout(function() { document.getElementById("yourImgId").style.visibility = "hidden"; }, 1000); //time is in milliseconds
The `&lt;video&gt;` element has a look and feel which is defined by your browser internally. "Elements" like its play button are not styleable by CSS and not exposed to the DOM. The Shadow DOM gives ordinary web developers the ability to create these sorts of isolated components that behave just like the special browser-defined elements. *^edit: ^grammar*
it sucks when you can't correct spelling in the headline
If reddit appears to have fucked up the formatting, you can click Source underneath the comment to see what was originally written. Reformatted for you: &gt; You can't really enjoy the react way of doing things (and understand why it is better for you as a developer) unless you had a prior experience with an mv* framework first. &gt; &gt; Start with angular and then move to react. &gt; &gt; Plus, as a beginner you will most likely have a bad time with all the tooling you need to setup before starting hacking jsx. &gt; &gt; Here is a roadmap for u: &gt; &gt; * understand what mvc/mvvm is first &gt; * why do u need angularjs or react in the first place &gt; * make a hello world in angularjs by injecting stuff in theccontroller $scope and displaying it in your view &gt; * know you basic directives (ng-click, ng-show, ng-hide, ng-if, ng-..) &gt; * have some good time with two-way data binding (enjoy your first deadly cigarette) &gt; * get some infos about dependency injection in general and why it is (was?) one of the best things in angularjs &gt; * start with injecting some services, factories etc. &gt; * read the todomvc app code and understand it well. &gt; * create your own basic directives &gt; * do some async stuff with $http service. &gt; * move to more advanced stuff like creating more complicated directives, routing, the digest cycle, how the hell angular knows your object changed, difference between services and factories, etc etc &gt; * make your code more maintainable with john papa's style guide. &gt; * understand why angularjs sucks. &gt; After that start with React and get ready to be blown away. &gt; Ps: you don't really need a lot of time to get started with react, but i don't really think you'll enjoy it unless you got to know the limits of an mv* framework. &gt; And yes, React is not just the v in mvc, it is the R in Re-think how you code stuff.
Thanks for reformatting it. I don't see a "Source" option. Do you have a browser extension that adds that?
So like a fancy same domain iframe?
GZIPPED as it should be standard. As for minifying, I'm looking at a PR that shaves off quite a few bytes.
Wait for v2
Why would they all need a shadow DOM? Use it where you need it and nowhere else.
I assume no difference. React gets it performance from managing lightweight versions of DOM elements. (IE: it doesn't have to keep/create the complex DOM elements in it's hierarchy and only generates the change commands to edit the DOM in a more efficient way.) If anything, it will allow the React team to use Web Components to further encompass the elements improving the render footprint of the output. (Potentially not needing react-id properties and simplifying DOM manipulations.) I don't see it replacing React by any means, but I could see some beneficial outcomes.
So, for any bigger corporation this is still a problem. in practical terms it means that if your do a startup core stuff is written in react - you may never get acquired because of that. Because the clause is problematic not for you but for acquiring company if I undestand the implications correctly. I think that for example google devs cannot use react in their work. I know that this clause doesn't affect everyone but it may have real life impact on your business at one point. But then again I'm a developer not a lawyer.
XOXO That is looking fantastic. Edit: [I blasted the sun](http://imgur.com/QBmJruH)
A super lean iframe. Hopefully in v2 they can also do full js isolation.
 &lt;input type='range' value=0 max=30 id='range'&gt;&lt;/input&gt;&lt;br/&gt; &lt;input type='date' id='date'&gt;&lt;/input&gt; --- range.onchange = function() { if (this.value &lt; 10) { date.value = "2015-09-0" + this.value; } else { date.value = "2015-09-" + this.value; } } date.onchange = function() { var value = this.value.slice(-2); console.log(value); range.value = value; }
JScript? As in Microsoft's abomination? Ignore that... You need to have something run on the server to host JSON or to interact with a client side tool? If you want to keep most of your existing JavaScript, Node.js would probably help you out. I've built quite a few Node [Express](http://expressjs.com/starter/hello-world.html) servers to simply generate JSON data for testing and mocking. --Edit: This is a simple way to send JavaScript Objects as JSON objects: app.get('/api/path', function(req, res) { res.json(myObject); }); --End Edit Also, you will not be using Document.Write() FYI. You'll be sending your JavaScript Object as the response. As far as concurrency, don't worry about that right now. Get it running, then look into the options when you have it running and find out if it is performant enough (Node is pretty damn good for lightweight tasks and scaling up has several methods)
In-browser websockets are build on top of TCP - so comparing them to enet, that is based on UDP, is impractical. Generally speaking, you will want an implementation as close to the RFC as possible, and with a reliable throughput. I have used Autobahn.ws in the past, and it yielded very good results for a latency-sensitive set of applications. 
Using them in a simulation application, where a user model is compiled down to JS inside a worker and run, then results passed back for visualisation using TypedArrays and transferlists. This stuff isn't really a good fit for WebHamsters, given the code for the Worker is much larger than a single function. I honestly struggle to think of uses for worker APIs like WebHamsters beyond stuff like running a filter over some image data or similar. Obviously very useful when needed, but tends to be a very obvious performance point, rather than something you'd have scattered throughout an application. If you're making games or similar, you can do things like moving all of the logic code into a worker, and then passing render commands out to the main window. But again there you'd separate out your UI and Worker code.
Exactly what I was looking for!
Oh man, this is you. I am fan of yours now.
One key benefit is it lets you have elements that are totally immune to css styling outside of them.
Very cool, but it breaks the back button. I had to click a thousand times to get back here...
If you do `window.jQuery`, you will share the same jQuery instance. If you did `&lt;script src="//cdn.blah/jquery.min.js"&gt;&lt;/script&gt;` which imported jQuery, and there was full isolation, then you would have a new copy of jQuery in memory. The main point about isolation is that if you declare jQuery in your "isolated" shadow root, it wouldn't get attached to your global scope (i.e. window). http://robdodson.me/shadow-dom-javascript/#javascriptscopeahrefidjavascriptscopea 
It should be here, it has gained its place and will be here for a decent time I guess. (upvotes saying)
If you have your source accessible I could identify some places in your project where you will find a benefit. The best use cases are really for offloading background tasks onto their own threads as well as splitting individual (parallelizable) tasks across multiple threads and moving more logic from the server to the client. Identifying where to implement parallelism is difficult but where you should focus your efforts is understanding https://en.wikipedia.org/wiki/Amdahl%27s_law and identifying the slowest part of your application as your maximum performance scaling will always be limited by the slowest sequential parts of your application...no matter how many threads and cores you throw at it. Here is an example project I made, essentially just implements lzw string compression inside workers so you could for example, compress all json data going into and out of xhr request without impacting the user experience (less bandwidth == less $$) https://github.com/austinksmith/lzwFloss Really, the sky is the limit..put as many or as few functions onto their own threads as you want but keep in mind there is some overhead in doing so (mainly when not using dataType argument) and you'll have to weigh that benefit and cost to see if it's viable for your use case. 
It's really fast for me, could be I'm using an SSD.
Your browser would cache the image after first load.
I'm eagerly awaiting the "Avoid using generators for async!" articles. Generators and iterators are *not* asynchronous, and a bunch of people are determined to learn this the hard way. Also, a side note: it cracks me up to see developers creating huge nests of callbacks when using promises. Stop being lazy.
I wrote a QR code reader that used getUserMedia and did the image analysis in a web worker. TypedArrays go in, text data comes out. It was Neat and Cool.
Thank you man, but unfortunately I'm still not getting the notification to show up. The corrections you suggested make sense but I may have another issue.
[KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
I always think of callbacks like handling instructions on a package. There's the initial "sendPackage" that takes a name and address and sends the package to that location, but then there's also an extra instruction about what happens once it has gotten there. That's the call back. Is it "leaveOnStoop", "getSignature", "returnToSender", or just "confirmDelivered". These are instructions that are invoked as part of the delivery process. 
SPOILER ALERT! I coded it for you: http://codepen.io/ForScale/pen/QjNqMJ I did it as straightforward as I could think of... the `parseFloat` thing turns the default text input into a numerical value with a decimal. The `.toFixed(2)` rounds and cuts the number at 2 decimal places. Please feel free to ask as many questions as you would like!
[Here](http://codepen.io/anon/pen/dYMVdv) is a little change I would make. I just added a detection for if the first character is a dollar sign and cut it out if it was. Also, if you are inserting just text, I would use 'textContent' instead of 'innerHTML'.
Nice! I like how you detect and deal with the potential `$`. And... funny enough... I had no clue about the `.textContent` property. Thanks for the heads up on that!
We have written sequence analysis tools in javascript. We offload the expensive tasks to web workers. This is mostly sequence alignments. This not only allows for fast computation, the UI also remains responsive.
AutoHotKey might be a lot easier than using JS
You guys are awesome! I really appreciate the help as this is very time sensitive and I really didn't just want someone to do it, but I am very appreciative you guys did. In the text field how would I be able to show the amount for example if I type 5 into the field, on submit for it to say or show $5.00/item? I understand the .toFixed(2) is a very helpful function to cut the decimal places so it displays a better value and I see the part with ((value - (value * .03)) * .10).toFixed(2); so what is the .03 you guys are referencing each time in the code?
Thought that was where PHP was headed...
What make and model of machine are you running it on? Just curious.
Pretty cool, I love Ramda!
I'm on a recent macbook pro with SSD and it's also very slow for me. I don't really understand why speed hasn't been an important feature to focus on, but I trust and hope they'll be able to resolve these obvious performance problems in the near future.
thank you for all the help but I finally managed to get it working right after my last reply haha. It had to do with my manifest file (needed for chrome extensions). I forgot to include the jquery script inside it so getJSON wasn't working when I called it and thus the call to notif wasn't happening either. Hence why whenever I tried to run the chrome notification without getJSON it would work but whenever I put it in the callback function the code would stop at getJSON due to the error. Thank you again!
I didn't check the math, but if you want to print out a string in JavaScript, you just need to concatenate using the '+'. I added a field where i did that [here](http://codepen.io/anon/pen/wKGrOQ).
You can trigger event listeners alright (simply use the elements [`.dispatchEvent()`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent) method) - it just won't trigger default browser behavior.
It is a MBP.
No problem! The `.03` is literally the numerical value .03. I used it to find 3% of the input value. Like .03 X 100 = 3, 3% of 100 = 3. #justmaththings There are a few ways you could go about handling an integer (no decimals) being entered. You'd have to check for it, so you could do something like sub.onclick = function() { if (inp.value % 1 === 0) { inp.value += ".00"; } var value = parseFloat(inp.value); one.innerHTML = value * .03; two.innerHTML = value - (value * .03); three.innerHTML = ((value - (value * .03)) * .14).toFixed(2); four.innerHTML = ((value - (value * .03)) * .10).toFixed(2); } I *think* that little if logic will handle it. Test it out and see! 
Tip: You can do `time some command` to see how long something takes. Very usefull!
You sound like you're explaining pointers, not callback functions O_o
Generators are blocking. Async/await will not be. Async/await is not sugar.
Oops, been working with too much virtual dom. Head is filled with it! You're 100% correct.
Browser + AUtomation The answer is always Selenium rather than self-build.
I pitched the idea to the creator of lodash around the time we had this convo: https://www.reddit.com/r/programming/comments/3kys28/lodash_10_javascript_utility_functions_that_you/cv36ghh?context=3
Thank you, this has been a great help and learning experience. One last thing, if you don't mind. So I was able to by your help set it so that when a user enters a solid number 5 and hits submit it formats the input field to show 5.00/per item, what can I do so that if a user enters 5.64 and hits enter it does the same to show 5.64/per item, currently if I do 5.64 it leaves out the added words. Also if I want to add a dollar sign before the 5.64 how would I show that?
AHK is the right answer, and is exactly what you're describing. 
Is this an approved dev pattern in javascript programming? I thought closures were a performance penalty and sources of memory leaks? https://developers.google.com/speed/articles/optimizing-javascript#avoiding-pitfalls-with-closures 
I use uploadifive: http://www.uploadify.com/download/download-uploadifive-standard/ Its $5 but worth it. 
Github?
Options: * node (including modules such as pm2) * Amazon's [Lambda](http://docs.aws.amazon.com/lambda/latest/dg/welcome.html) * vert.x (JVM) * Nashorn (JVM) * golang (via go-duktape) * c (again, via duktape) * PHP, calling out to node via exec (using node purely for scripting, not for the server capability) Node is probably your best option for something easy; several hosts provide CLI tools to help automate deploying it. Although it can run multiple requests concurrently, it can't run them in parallel (look into what is and is not asynchronous in node). Modules such as [pm2](https://github.com/Unitech/pm2) help get multiple processes up and running if you need it. Odds are pretty good you're going to have to put at least some effort into updating your client-side scripts, since the global objects- window and document, for example- don't exist in node. However, if all you're doing is preparing JSON, it should be relatively straight forward. -- edit -- In case it wasn't obvious, I included PHP, go and c mostly as a joke, though it's still feasible. For what you're doing, I imagine node will be the most straight-forward option.
That is very useful. I always mistyped "time" when I wanted "date". It turns out a lot of time I really wanted "time". : )
As the champion of Async Functions I think I can say that Generator yield and Async function await are not significantly different. An informative desugaring that gets the core semantics correct is even provided [in the spec](http://tc39.github.io/ecmascript-asyncawait/#desugaring). The FF implementation uses generators under the hood as far as I'm aware. As for Chakra's, I won't comment yet, you'll have to wait for the blog coming out hopefully this week :) Maybe you can explain more about what you mean by "blocking". Then I can maybe help you understand how they're more alike than you might think!
Try this: document.addEventListener('keyup', function() { console.log(arguments); }); var event = new KeyboardEvent('keyup', { code: 9 }); document.dispatchEvent(event);
Will do! Thanks, I don't know how I missed that last time. 
Yes, sorry folks. It's [Ramda](http://ramdajs.com/0.17/index.html).
Can we use ES2015 classes?
That's a different thing in javascript http://stackoverflow.com/questions/17382427/are-there-pointers-in-javascript The "point" is that you can "reference" a function by name and have it called by another function, presumably at the end. In javascripty pseudocode: function playSummerPlaylist(callback) { //play Track 1 //play Track 2 // etc. if (!callback) { return; } callback(); } function playAutumnPlaylist(callback) { //play Track 1 //play Track 2 // etc. if (!callback) { return; } callback(); } playSummerPlaylist(playAutumnPlaylist); ...which is obviously way oversimplified. But that's a reference to the autumn playlist function passed as a argument.
Odd, speed was the primary reason I switched to using the 3.0 releases. 
There are quite a few options for configuring your project. Depending upon the needs you might want to follow the popular [MVC](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) pattern. Check out [this](https://github.com/strongloop/express/tree/master/examples/mvc) example to help you get started.
Hasn't this same question been here a dozen times before? 
Pretty much any current JS book will get you ready. There are tons of recommendation threads in this sub, but if you like your current one I'd say stick with it and you should be fine.
Thanks for your input!
This test doesn't look like the best setup. They're all running from the same file and none are done done in idiomatic ways.
You can use classes in JavaScript. It is actually quite common, people just don't call them classes and in ES5 it was a bit awkward and non-standardized. There are lots of other things you can do with nested functions etc., but nothing wrong with classes. In fact in ES6 classes are now standard. I use ES6 with babel. Before creating classes though you should see if exporting functions and/or data from a module will handle it. Actually ES6 modules (optionally exporting classes when necessary) with semantic versioning, the massive npm library, and browserify make JavaScript pretty cutting edge as far as code organization. From the standpoint of front-end, React components (possibly with a Flux-type framework) are the in thing (also fairly cutting-edge and sophisticated), which by the way you can make using babel, JSX and ES6 classes.
I recommend you convince your team to move to React/Flux or find a better job and until then don't let Angular corrupt your brain too much.
Hell no, I'd rather sodomize myself with a glowing pitchfork. (We use SNOW at work. It's already terrible as a user. Can't imagine having to develop it, especially considering that apparently all you can do is adding some custom js to it)
Mr Doob's G+ page. https://plus.google.com/+ricardocabello/posts/2AUu8Q2yct6
This article is a summary of the following blog post, created with permission of its author: http://ashleynolan.co.uk/blog/frontend-tooling-survey-2015-results
&gt; It feels "loose". Well, that's because it is. You can't tell which properties exist, which globals exist, what a function returns, which parameters a function expects and so on. You can pass an arbitrary amount of arguments to functions and things which would be usually result in a TypeError are silently ignored. The good news is that ES6 added a bit more structure. There are modules and classes. So, if you import a "Foo" class, an editor with a good analyzer (e.g. VS Code) will know that instances of this class have a "bar" method and it will tell you, in a tool-tip, that it expects a specific set of arguments. Simple module example: http://i.imgur.com/47Bydlf.png You can beef this up a bit more with d.ts files for the libraries you're using. E.g. this is VS Code with a d.ts for jQuery: http://i.imgur.com/ETG4yuK.gif Note how it mentions the types of those parameters. Your editor will actually complain if you try to pass the wrong type. Those definition files are managed and installed with TSD: http://definitelytyped.org/ If you want the same kind of thing for the code you write yourself, use TypeScript. You only need to add those optional type annotations to the surface area of your code (e.g. function signatures) to get the tooling benefits. TypeScript does add a compile step but so does ES6 (Babel). Fortunately, you can automate this. I use Dart myself. It provides similar benefits and the language is quite a bit cleaner. However, JS interop isn't nearly as nice and you currently can't use it to write libraries/frameworks which can be consumed by JS. It supports things like async/await and operator overloading, which is really handy. Here is an example which uses those two features: https://dartpad.dartlang.org/e91384a4e1eee6749287
change the constructor too to add a year parameter. To use the earlier example, function Quote (quote, author, year){ this.quote = quote; this.author = author; this.year = year; } var quotes = []; quotes.push (new Quote ("We're made of star stuff", "Carl Sagan", 1999)); alert (quotes [0].quote + " -" + quotes [0].author + " -" + quotes [0].year ); //etc EDIT: Spelling
Thank you! I was wondering if there was a way to edit the constructor down in the code (like you would edit an object literal), but I guess not. I'm new to all of this so I don't even know if there'd be a situation where one would *need* to change the constructor without editing the parameters where it was declared.
1) What i did was to edit the constructor to accept the new year parameter. 2) Code gets changed for any number of reasons. For instance, you could edit the constructor to set default values or log the code to console to debug code at runtime etc. May i suggest going through a few javascript tutorials ( say on youtube etc ), and then trying it out hands on. Initially just try to follow instructions, and soon you will start to see patterns in code, and the logic would follow. And don't hesitate to ask for help when struck.
Thank you so much! I bought Jon Duckett's book, so I'm going to go back to that and see what I missed on Objects.
"I'm having trouble with x library/framework". "Use y library/framework instead". 
thanks ill take a look
I was not aware. I'll take a look at this.
Yes, you can! Sorry for late answer.
Scoping is kinda wonky in JS. `var` is function-scoped (don't use it) and `let`/`const` are block-scoped. In arrow functions, `this` is lexically scoped and it regular functions it's bound at runtime. If you do everything with `let`/`const` and classes where they make sense, things will be somewhat less weird.
The 'model triggers re-render' mindset is more akin to react than angular, so it's normal that you're having some trouble wraping your head around it. The angular way is slightly different. It's more centered on the controllers, and services *mostly* would be stateless (for the most part abstractions of business logic and API interfaces). To store information between controllers, you would use a service though. The model as you knew it does not exist in angular. You have scope (or `this` if you're using `controllerAs` syntax) and that is tied to the controller lifecycle. Basically you hit a page/directive, load a controller, use some services to get data, use scope/this to interface with the template to show that data, and use bindings on the template to change the controller state. You move to another page, and start this again. I do not know of any specific resource for making the backbone-to-angular change easier, but since that mindset is similar to that of react you might have an easier time finding react-to-angular resources (although it would be more common the other way around). The resource that I can recommend though is a good angular style guide, because it will be like an 'accepted standards' blueprint. I use [john papa's angular style guide](https://github.com/johnpapa/angular-styleguide). It's long but will answer most any questions about how and why on angular.
That's a seriously twisted way of saying "have problems with authority" .
Spot on
What would you say is the idiomatic way of handling an undefined value in JS? Would you write var a = new Quote("Lacrimae rerum sunt.", "Virgil", undefined); explicitly or just fail to provide the argument?
&gt; I find the web development community can be extremely fractured, cliquey and hostile at times. Immaturity. This has nothing to do with intelligence or competence and is purely a personality failure. Mature developers, particularly those innovating new technology, enjoy *positive confrontations*. That is a fancy way of describing people telling you how wrong you are and providing you an opportunity to prove otherwise. It also means people are notifying you of faults so that you can fix problems. For people who don't understand this.... honestly, they can go fuck themselves. I am into technology, not marketing. I don't need anybody's approval to build new things from original ideas even if the original idea could make somebody sad or challenge their preexisting conclusions.
Well all ads have to be lazy loaded, which is the reason why it all jumps around. Really no way around it other than not having ads.
Typical reddit post (and upvoted, too). Ignore the data. It's not pretty enough.
Ideally you don't want to deliberately use undefined if it can be helped. You can check for undefined like so if( typeof variable === 'undefined' || variable === null ){ // Do stuff } 
It was a complete nightmare on mobile.
Yeah, the inclusion of it in the MV framework list was weird. Sadly, the one we use here didn't even make it into the list. (CanJS)
to be fair react is not a framework either.
It has the new trend of watching for the user to leave the top of the screen to pop up a message that nobody is going to read.
Thank you for that. Any suggestions on what I should learn to get into being able to do calculations like these? Or should I be starting at the bottom and learning javascript from the basics?
Sorry, that's an exercise for you... I really have no idea.
Allow me to answer in two parts - 1) about the license. The football.db datasets are by definition public domain (e.g. the football.db org only includes public domain data). About public domain (in the US sometimes known as CC0 / Creative Commons Zero). There's no copyright, no rights reserved, no license e.g. the "license" reads - the football.json data is dedicated to the public domain - use it like you desire without any restrictions whatsoever. Cheers.
2) about the how often is the data updated? Allow me quote the updated readme: Note: The JSON files get (auto-)generated using the football.db datasets, thus, please do NOT edit the JSON files but the source files in the country repos e.g.: - English Premier League in [`/en-england`](https://github.com/openfootball/eng-england) - Deutsche Bundesliga in [`/de-deutschland`](https://github.com/openfootball/de-deutschland) - Spanish Primera División ("La Liga") in [`/es-espana`](https://github.com/openfootball/es-espana) - Italian Serie A in [`/it-italy`](https://github.com/openfootball/it-italy) - and so on If all works weekly updates get pushed by the skriptbot. See the [`skriptbot/football.json`](https://github.com/skriptbot/football.json) scripts for the (auto-)update machinery.
Any time! Calculations are pretty easy. You just type numbers like `1`, `2.33`, `100`, etc. The basic binary operators are pretty straightforward: `+`, `-`, `*`, `/`. I believe order or operations is preserved in javascript, so... "PEMDAS." To get familiar with the basics of javascript, I'd look at [this](http://eloquentjavascript.net/01_values.html) and then work through [this](https://www.codecademy.com/courses/getting-started-v2/0/1?curriculum_id=506324b3a7dffd00020bf661). Have fun!
In the JavaScript world, there's the [Cycle.js](http://cycle.js.org/) framework which provides all of the same benefits of Redux and some of its own. The architectures are pretty different, but they both model state as a function of all past actions. Also check out [Elm](http://elm-lang.org/). Elm is the direct inspiration for Redux. It isn't JavaScript, but it does compile to JS.
FYI: Added a license section to the readme e.g. see [README.md#license](https://github.com/openfootball/football.json/blob/master/README.md#license) Just (another) copy of the football.db project license.
Yep. Tried it in landscape mode. Huge unmovable share links at the bottom, a survey container that displayed while not scrolling, it was unusable.
Is SASS really that much more popular than LESS?
Yeah... believe me, it's not fun. Particularly so because the owners of jQuery products want things to be done ASAP which encourages even messier code which just snowballs and oh god pls no
I never seen them and I have done searches for that exact thing. If you have, do you mind sharing a link to them.
Anytime!
No prob! I would also do a bunch of reading on php's file_get_contents and php file manipulation in general. It might help you to do a little whiteboarding of your flow and what you want your different ajax calls to trigger in that php file. By the way, I don't know where this seeming requirement comes from to use a json file in this way. Usually json is either a static resource (configurations file) or else a way to get data into a javascript-readable format, like so: Database -&gt; Web Service -&gt; JSON In Http Response or Web Form -&gt; Javascript Parses Form Data Into JSON -&gt; Ajax Sends JSON To Web Service Anyway, if it's not a requirement that you have to read and update this json file (for example, if you're just prototyping and don't want to mess with mysql), you might want to check out a javascript database emulator such as: http://www.taffydb.com/beginner Good luck!
&gt; There is a better way to do it by caching images in HTML5 Local Storage. I don't think this qualifies as "better". This is not what localStorage was made for. "Application Cache" (manifest) is a much better option!
No one is complaining about it not being pretty. We're annoyed because of the website is difficult to use because of its obnoxious and annoying issues.
That's way better. Let's agree to never link to webdesignledger.com again. That site is annoying as hell.
&gt; a premium version of the site that is ad free. Which we'll have to pay for I assume?
Likely $10/year or less and we'd work with companies that you use already to get you discounts to save you much more than that every year. So you would spend less money every year and be able to read a site that didn't have banner ads. Horrible idea? 
&gt; Yes Shame, especially when I can get the same result from Adblock. What would I get as a benefit from your site other than removing adverts? I don't mean to be negative, but I hate that the Internet has become one massive advertising platform. It should be for information, not advertisements. 
Here's some feedback. Static ads are fine and totally reasonable. Autoplaying ads with sound anywhere on your site are NOT. You're making a ton of requests to http resources; these are being blocked by my browser because your site is https. Load everything external with https. The sidebar on the right functions only to provide social links and ad space, and the content column doesn't even have enough space to avoid wrapping your parade of social share links. Get rid of it and put the 'follow us' links elsewhere. It looks like you at least store a cookie and only show the full screen modal once, and pressing esc correctly exits the modal, but consider only showing that after the user has reached the bottom of the content block instead of seconds after the page loads (or never). Overall just consider your target audience of web professionals. They're simply not going to tolerate an experience like this.
https://github.com/paldepind/functional-frontend-architecture has several examples of the Elm architecture in JS, using a set of focused libraries rather than a framework, highly recommended. Baobab as far as I can tell is more inspired by Om cursors than Elm.
How about monitoring? It's something very importsnt in deployment.
You can pass *null*, like so: var a = new Quote("Lacrimae rerum sunt.", "Virgil", null); But in that case, you should just leave that parameter off. If, for example, you wanted to specify the quote and the year, but not the author, you would do this: var a = new Quote("Apples taste good.", null, 2015); 
I'd recommend looking into Typescript. It has many of the features found in a common compiler. http://www.typescriptlang.org/
this is pretty funny and seems on point lol 
IMO the full screen modal overlay ad is wayyy worse than any of the jumping around stuff. 
Forgot about that one! Really recommended. Yeah, Baobab is a really different beast. FWIW I didn't have much luck with it. The error messages were pretty bad and there was no thought as to the structure of it in a real application.
I'm glad you're offering things other than an ad-free site for a price. The thing is, I've done web development for 14 years commercially and I've *never* bought a stock image, I have always used royalty free imagery. So I guess in that respect I'm not your target audience? Either way, I think offering discounts for stock imagery is a moot point, especially when there are plenty of royalty free image sites out there. I feel for you though, I hope your site works. Perhaps lessen the load times - currently it's unbearable to wait the 5-10 seconds load time *every* time you load a new page. It's only going to lessen your audience. Check out: http://tools.pingdom.com/fpt/#!/DO7NG/www.webdesignledger.com 1. 230 network requests is insane for one page. 2. The order in which you are loading scripts is bad as well, lots of blocking scripts that need to be last. Not first. 3. You have 30 requests to a data url that is not complete 4. https://load.sumome.com/ is terribly slow, consider loading it else where. 5. Reduce the lazy loading, images that are under 50kb do **not** need to be lazy loaded. 6. You have **far** too many analytics scripts running. Do you **really** require that much analysis? It's hindering your site experience. 7. CPU load is horrible as well (I'm assuming due to the above issues), I have a semi-decent computer and the FPS in Chrome was terrible. I did a second test and the page took **35 seconds** to load, that is terrible. 
Man... so many people who have heard of Underscore but aren't using it. You people are really missing out. Though I don't agree with it being categorized with jQuery, Angular, and friends. It's just a library of common helper functions that apply to Javascript as a whole (helps with grabbing values for calculations, managing arrays, extending objects, etc.), not just front-end or the UI. I use it on the server all the time in Meteor apps. Anyway, it's just too simple and the functions are too handy. I can't remember the last time I didn't use it.
The last time I checked, Angular included quite a bit of attention to testing. I believe this is due to the fact that it's creator, Miško Hevery, has long been involved with software testing. So if you want practical, real-world help with testing your Angular apps, then you shouldn't have to look any further than the Angular docs, mailing list, etc. And if you're looking for more of the rationale and philosophy behind testing, then check out [Hevery's site](http://misko.hevery.com/category/testability/); even though everything's 5+ years old, the basic principals of testing remain pretty much the same.
Yeah, and why is Underscore in there? It's just a library full of helpers and has very little in common with React or Angular aside from the language it's written in.
We definitely appreciate the constructive feedback. We've changed the ads to be static, in reality many of the top 100 sites have that type of sticky ads now. Autoplaying ads should never be on our website, if they are, they shouldn't be. It's somewhat tough to track those down. Agreed on the mixed https: calls, we're tracking those down and fixing them as quick as we can. We've reduced the number of share options to keep from wrapping in certain browsers. 
I suppose I have been fortunate. I have always had two separate careers that I have worked in parallel. One as a full time software developer for major US corporations and the other as management in the military. In my part time job I manage 28+ people and have director level responsibilities, so I have to be absolutely critical with an iron dictator's grip otherwise people completely walk over me like I am nothing. I don't have time to parent people. The interesting thing is that comparatively speaking the civilian world is soooooo soft and yet good employers just seem to know why I choose to speak my mind and engage discussion. I am allowed to fail and to be wrong, but they really expect me to never sit back in silence when boat is sailing in the wrong direction. They absolutely rather I say something, but...... with an appropriate volume (so to speak).
We're actually hit max load on our server the last day or two a couple times so we're looking at increasing it's size (and cost). Agreed on the requests, we're looking into what we can pull. 
Any recommendations on products/services you'd like us to get discounts for?
Kickass. Got a working demo somewhere?
Setting the variables on the global scope like that is really ugly to me. It would be better if they were defined as var Days = Enum.define(["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]); That way it's obvious how `Days` is defined.
As a mostly LESS user, I'm sadden that I will have to give up its convenient client-side library in order to use SASS more often to keep up with everything else using it.
Thank you, going to look into that. I think local `runtime-tools`install should fix the issue.
Just checked what helper functions it has and oh my god, how have I never used this before?
The simplest way to do it is probably to make an HTTP server route that responds with the instance status data. Monitoring services could then be configured to curl this route periodically for automatic notifications.
ELI10: unikernels vs. containers (docker)? Also, can this unikernel use a local OS directory outside of the image?
Is it really? Are you one of the guys working on the nodejs source that you're able to say they're slower?
...is this an attempt at some sort of insult? Click the link, read. Youd see it actually was from one of the guys thats qualified to say so. Mind if I ask what your mental block was?
Haven't looked into the details, but from working with scripting languages C-APIs (Matlab,Python,Lua): Every time you cross the language border, it costs. I guess having the buffer object implemented on the JavaScript side avoids having to cross that border on a lot of method calls.
See? SEE!? It's so helpful! How do people function without this?
A use case I have, though maybe not common, would be to have inheritance on Enums var Service = Enum.define(['Uninitialized', 'Ready', 'Running']); var RemoteService = Enum.extendFrom(Service, ['Connecting', 'Disconnected']); RemoteService.Ready instanceof Service === true RemoteService.Ready instanceof RemoteService === true Haven't really thought it through but just happened to be related to something I'm working on :) Edit: There is also probably an example with Ringed planets or Planets with satellites mixed in there somewhere :P Edit 2: This [appears to be a sketchy issue in the CS world] (http://stackoverflow.com/questions/55375/extending-an-enum-via-inheritance) but I'm not really swayed either way. Maybe it's better considered a union instead of a subclass. Edit 3: Wonder if it is fixed by requiring a mapping in each level of inheritance. Kinda makes sense in my case: Service.Uninitialized -&gt; RemoteService.Uninitialized Service.Ready -&gt; RemoteService.Ready Service.Running -&gt; RemoteService.Running / RemoteService.Disconnected / RemoteService.Connecting Then by treating an enum value as a RemoteService you have a more specific typing than as a Service and things observing Services still understand the state
Okay. Knowing almost nothing about the project, but having worked in an industry where I've seen a lot of stuff like that ("can you host this access database to power our website?" "we just need a basic webform but we definitely aren't going to want to deal with Infrastructure or a DBA, can you just build us a page?"), here is my advice: Maybe look at a lot of other free technologies that have come out that already do what you're trying to do. The first thing that jumps out at me is create a google doc spreadsheet for your team. Boom. People can come and comment on it. If google docs is not an option, what about some of the free collaboration software solutions out there, like Basecamp or such? You could post the table and everyone can just chime in and comment on it. Google "free online collaboration software", there's a lot of options. Another thing would maybe be to use a survey site, like surveymonkey and just embed it on your webpage. All of the above companies have already figured out the kind of thing you're trying to do. Sometimes it's really cool to be like "hey I built what you wanted, check out this little one page app I made to collect comments on this table". But the downside of that is: now you have to fix every problem with it. And knowing it was all built in-house will cause people to think you can do anything they can think of, and then they bombard you with stupid "enhancements" or "feature requests". If you present them with a solution that works, you get credit for knowing about it, and you can still be the guy who maintains / runs it, but you don't have to be responsible for uptime / security / stuff like that. Sometimes the tool you can build is better than the tool you can find, sometimes not.
This it the reason - keep it as a JS type and avoid the conversion cost. C/C++ can easily index into JS types but not the other way around
I completely agree, the project serves another purpose. Teaching myself JavaScript, and high order functions. That's why I tried to keep it vanilla and was apprehensive about using server side programming like php and asp. 
what's w the quotes? i read a paragraph then reread it again as a quote. this isn't a magazine.
Inheritance with enums is interesting. I haven't really run into a scenario where I've required it, but I know in Java you can use marker-interfaces and then have different enums implement that interface. But you can't extend an enum. 
soccer.json :)
That's right, slide that post up. Show them who's boss.
It's weird to read today! Or maybe I'm old.
Very cool. Using a hand-rolled history in an app I'm working on .. might try using this as a drop-in and see how it goes, one less thing to maintain on my own :)
r/itsaunixsystem
Haha this is interesting.
You can only do that when you're 100% sure that "", 0, null, etc. can never be a valid `something`. That's probably fine in this particular case, but imo, you should probably just throw in a `=== undefined` just to not make that mistake.
To not shoot yourself in the foot, gotcha.
Looks like they just copied some jQuery from Wordpress and threw it on the screen hoping everyone would think it was some *leet hacker codez*.
VanillaJS: "where you can reinvent the wheel, but a shittier version of the wheel that's yours."
My wheel is pretty good actually.
I started using nodejs in production end of 2009. not so weird buddy. before someone asks why: because I was able to fix issues myself and it was fast and easy. it worked flawless. production = up to 5-6k req/sec at peak, I scaled it over 12 core cpu's on two 4 machines. ... a few month later I added mongodb to the stack and a year later we replaced MySQL with mongodb. no regret yet. edit: 2009 - not 2008 obviously. and yes I did. we paid interest in it because I was helping with lighttpd and we were annoyed that node doesn't support http 1.1 and a couple other things so we started chatting up ryan in his irc channel... 27 downvotes for miscalculating when I was working with it - good job Reddit.
It's faster due to the overhead of JavaScript -&gt; C++ and back, not because JavaScript memory allocation is any faster. 
OK buddy
So you managed to get your hands on it a year before it was created?
I'd love feedback on this. Does anyone find themselves looking for a bindAll type helper? It would be interesting to think about a core `Object.bindAll` companion to `Function.bind`. Thoughts?
Thanks! Yeah with eval there are definitely performance problems but for dynamic functions the slow part is only when they are first compiled from the string. Once that is done, I believe the performance is no different from a regular function. 
I'll bet you thought all those job listings asking for 7 years of experience in node were just blowing smoke up your ass.
If you're worried about the size of a dependency like underscore and just want certain methods (though I'd be surprised, generally, if on a certain codebase you'd only find one method from underscore or lodash to be beneficial), you can always include lodash methods as dependencies one by one. i.e.: https://www.npmjs.com/package/lodash.bindall
Doesn't matter if you have the best, roundest wheel ever. Is every method in your wheel documented? Can you confidently say any developer who isn't your clone could put your wheel on their car, cart, bike, or wheel barrow? Frameworks are good. They allow many developers to work confidently on projects together. 
I'm a little surprised the test suite numbers are so low. I thought I was committing some horrible crime rolling jQuery with no tests...
Haven't taken a peak at your solution but fwiw Symbols were added in ES6 to ensure uniqueness. Here are some tests showing them being used: https://github.com/kentcdodds/es6-workshop/blob/master/test-final/16_symbols.test.js
Interesting! I will have to check this out.
my wheel is a square wheel that rolls better than round wheels, https://www.youtube.com/watch?v=E7UfiLRMQxA
I don't think so, the overhead there is not that big. v8 is full on VM, and if the JVM is anything to go by, allocating arrays and creating objects are faster on the JVM, than in C++. It's not magic, and the reason is simple. C++ is going to request a free memory block from the OS to use for the object, this does not happen with the JVM (and probably the same goes for v8), because we already have a large enough memory region for the VM, so we essentially bypassed the cost of a malloc call. So all the allocation will do on a VM is to say, that from this to this address, you have an array. (I know it's a bit of oversimplification, but this is kind of how it works) Also, probably array creation is a pretty optimized in v8 anyway, It's not like an interpreter runs through the lines of how to create an array step by step.
&gt; that I maintain You need to get over this or your life is going to be spent needlessly duplicating tons of code that is (generally) going to be less reliable and well tested than what's already out there. If you're more worried about the literal code and dependencies changing just add a specific version of whatever package.
[OMG u guis this is real](https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript)
Where are the loud noises?
I don't doubt the results of the tests, but i do doubt their usefulness,it's like benchmark hello world performance. It just doesn't matter. The req/s does not have to do with the VM and language itself anyway.
Most frameworks are not that great in performance and add even hundreds of kilobytes in size. Many times using pure JavaScript is also even simplier. It's easier to start with frameworks though, but it could be good to invest some time to learn the language itself, so that you don't have to learn new framework/version everytime everything changes. And finding errors from long stack traces is not that great, either.
All three benchmarks there are using LibUV for the web serving part. so the base remains the same and the performance difference is in the languages themselves. JS is JIT, HHVM is JIT but go is compiled. HHVM's performance is near to the compiled Go performance. I did some personal benchmarks a few days ago with an nginx with 4 worker processes and hhvm running on a single one, their performance was about the same. so what I am saying is that HHVM can easily out perform that. I was considering writing a component of my app in js and when I was about to deploy it, I decided to benchmark it. JS is slow for servers and requires more resources, HHVM when run on the same machine with the same libuv base is much more performant. I had to rewrite that component in PHP again to make it able to handle the workload. I care efficiency and I am sure I am not alone, IMO JS and Node should only be used for non-high workload stuff where you need concurrency for example I am using it as a background daemon where I do a lot of concurrent http requests and login to servers and execute some predefined commands. Node is awesome for that, but it's also a hell lot inefficient.
&gt; https://gist.github.com/RickySu/8edb9bcc58829e5478ac Unfortunately, this isn't a useful benchmark. There are a large number of factors to consider, and it requires a lot of research to do cross-language benchmark comparisons that we can draw useful conclusions from. Even then it has limited real-world value because specific applications will always have their own specific hot spots. Generally we can tell from benchmarks that JS is extremely fast, though. V8 and Spidermonkey have lots of clever optimizations from years of browser wars. In some cases Go can be faster, and Luajit is generally the fastest non-compiled language.
Super basic animation? CSS is fine, super cool animations? Give Greensock a go :) https://greensock.com/
I'm not trying to defend node.js. All I'm saying is that after all, for example regex performance is much more important, or whatever your application does the most. If the only thing your service does is return a static string, than you might need to think things through. Personally i wouldn't use any of those, if i have a choice.
I'm pretty sure computer hacking is a running joke among crime/drama writers at this point.
CSI is such a awful show.
CSS isn't even needed (indeed often gets far more complicated than plain old javascript), and greensock is only good until they pull the plug on webgl instead of canvas. I think it is important for developers to know how to do these things without relying on third parties. That way you have a choice.
Watch [MrRobot](https://www.reddit.com/r/MrRobot). The writer actually consulted information security professionals to give it a more realistic touch. (and the plot is also good btw)
This blog title answers itself, so does this blog title answer itself?
Oh man, I am such an idiot. Thank you so much! I'm sorry if this is a bother, but I just started learning JS a week ago, so a lot of your code is way over my head (I've been learning with Treehouse and thought I was learning a lot, but apparently not). Would you mind commenting the code or explaining what each part is doing? I want to understand the code better and not just copy it. I have never seen anything.prototype, have not dealt with event handlers yet. I feel like such an idiot. Every time I feel like I'm learning something, I find out I'm doing it the wrong way.
Yep, Node.js installs easily on Windows, follow express (or your alternative flavour) tutorial, profit. 
Like these guys are saying, Javascript is normally executed on client side. PHP, Ruby and Python are all server side languages. In this case you should grab http://www.usbwebserver.net/en/ USBwebserver. Throw it on a usb stick and boom, mobile personal testing server.
This is how beginners develop the "frameworks are bad mantra", they see this FUD about "frameworks are slow, and have big ass dependencies", and start repeating it, continuing the cycle.
&gt; You Don't Know JS Awesome. Ill check it out. 
That is somewhat irrelevant to the point I was making. The JS engine can't assume that the global scope hasn't been invalidated by the dynamic function, so it turns off most optimizations for the entire program. Either way, cool idea!
Ok, forget the dependency discussion because it is fairly contentious. I am more curious what people think about there being an `Object.bindAll`in the ES core.
it's recursive.
It's all C++ really.
Treehouse is great. Definitely recommend. I've done the full gambit of online: codecademy, treehouse, you don't know js, javascript.org, etc. Treehouse is great because its very structured and they spend a lot of time giving you the right kind of exposure, but you will definitely need at least another source of info if not a couple of sources to give yourself a full breadth required. I recommend doing a freebie (codecademy) then if your interest hasn't wained: treehouse + a book series (You Don't Know JS as an example)+ but also spend time to find a JS mentor, and go find a real project to work on. 
Nobody wants to try to argue that point. Mozilla holds the critical API copyrights (the base JS implementation) because of their netscape roots. Anyone why tries to make a claim about the ES6 extensions would face issues because their works would be derivatives of the original license. Enforcing their copyright claims would require them to deal with Mozilla. Although I don't like some of the politics Mozilla has become involved in recently, I trust them in this area much more than any other major player in the web standards area. In light of the Oracle victory, it would be nice if Mozilla and the other companies involved explicitly licensed the API preventing arguments in the future, but I think a lot of companies don't want to set a precedent quite yet (as the court case will probably drag on for some time and could wind up in front of the supreme court again in the future). If you're worried about copyright on languages/features, you are much better served by being worried about IBM and SQL or whoever may own the copyrights on C.
Yeah that's just me being paranoid :) 
Pardon?
I dunno what you have against application frameworks. Jquery is understandable. There isnt much use for it anymore. However stuff like lodash i feel is indispensable
If you want somewhere to talk about just the language itself, why not r/ecmascript?
Mr Robot is definitely the most accurate, but there are still facepalm moments where the tech is off. I also remember hearing Slater say "mall-ware". 
It's a good thing it didn't end in another question referring back back to the original one. They may have crashed the Internet. 
This is the right approach. You will learn the basics of the language from the mentioned resources but its quite a different thing to put it in action when its not being spoon fed to you. Find a project to work on sooner than later. Once you have a general understanding of js check out codewars.com and you will quickly realize you don't know it that well ;) 
I'll create a GUI Interface using ~~Visual Basic~~ jQuery so we can track the killer's IP address.
Two way data binding? No thank you. I'm working on project with a fair amount of knockout code right now and the spaghetti like logic structure in addition to the constant dom refreshes I have to think about is making it a nightmare.
Well it is mentioned under MV*
I use third party libs when it makes sense, if I'm doing some rather basic stuff VanillaJS is probably completely fine over say jQuery. When it comes to decent animations, I rather reap all the benefits from years of hard work spent developing Greensock(which btw has no reliance on webgl or canvas). Perhaps you're fairly new, at least when it comes to programming animations, try do an animation like you seen on Greensocks demos and then do it with Greensock. CSS isn't needed, you're right. That doesn't mean it isn't more appropriate for some basic animations, take hover effects for example. Also confused about the choice thing, don't I have more choice by having a range of third parties to choose from?
Why not contribute this back to the main project?
So use Brackets. 
You should have a demo page that only includes the code from this plugin, and does not include intence or viewport.js code. Because it's hard to tell where naturalscroll ends and those libraries begin. You should also put it on npm
Yes, but it sounds like the JS (handlebars/mustache) is rendering the content that he is interested in scraping. 
Short story long: main project was intence. While I had been making the webpage for it, I decided to release some of the solutions on the webpage as the separate libraries (viewport.js and naturalScroll). Later on some of those became even more popular than intence. That's not the bad thing, but maybe it means I was focused on the wrong things :-) According to my impression, npm is supposed to be used for backend / system libraries, natural scroll is published on bower. Am I wrong about npm?
I guess this might happen because of intence which replaces the scrollbar with featured indicator. I guess I should create a separate demo page for only naturalScroll.
Yeah, npm is just for javascript. With browserify/webpack you can use npm modules on the client.
if there are certain elements that you need to scrape, then do a setinterval that checks for existence of these elements, then scrape the data once they are found.
This seems to me a good solution for this scenario I can remove the interval if the data is collected otherwise it will run till the DOM is rendered.
Ah sorry if my comment came across as snide. T'was unintentional.
Cool demo, looks like an interesting concept. I had the same problem as doctorionghost. My hardware is also a 1st gen iPad mini, but I'm using chrome. I own a desktop, 2 laptops, a iPhone and this iPad mini. I find I do most of my browsing on this iPad for whatever reason - weight and form factor as great for reading and even short posts like this. So, I think it's important to keep devices like this in mind when developing, at least for the next few years.
 let response = a + b; \, cache[response] = response; | this is the scope of response; | response can only be used here return cb(response); /'
No requestAnimationFrame?
This. So many times, this.
Really, it's just saying they're re-using a buffer (or a portion of) that was previously malloc()'d, or pre-allocated. So no round trip from the top to the bottom to get another buffer (plus the associated free() calls). Just keep a pool of memory to re-use over and over.
Same, on whatever version the current stable Chrome version is on Windows 10.
okay thank you very much for this answer
Scrolling programmatically is not natural. And it may be 748 bytes, but it makes my browser laggy as if it was megabytes.
true, but what would you do upon user clicks a menu item?
I'm on an iPad Air 2 (fastest model) and the demo is basically unusable. The mini map looks like an interesting idea, but there has to be a way to do it without destroying the feel of the native scroll gestures.
http://eloquentjavascript.net
There's a discussion [here](https://www.reddit.com/r/javascript/comments/3l71ky/could_i_do_this_with_javascript/) from ~3 days ago, the code I'm sure you're looking for should be upvoted there. Edit: [gojoe262's post](https://www.reddit.com/r/javascript/comments/3l71ky/could_i_do_this_with_javascript/cv3uvor) is what I believe will work for you, [moon_room's post](https://www.reddit.com/r/javascript/comments/3l71ky/could_i_do_this_with_javascript/cv3v669) below gojoe262's should be a working example if you save the code as an *.html* file. Edit 2: The examples I posted regard automating queries with Google, here is some code tailored for your situation (you'll have to past your links into the *urls* array. Open up an empty notepad, copy and paste the below code into it, save it to your desktop as links.html (not links.html.txt) and open it with your browser:) &lt;!doctype html&gt; &lt;html lang="en"&gt; &lt;body&gt; &lt;script&gt; var urls=[ 'https://www.google.com/', 'http://www.reddit.com', 'etc.com' ]; for(var url in urls){ window.open(((urls[url].substr(0,4)==='http')?'':'http://')+urls[url],'_blank'); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
Got'cha already, paste away in the textbox! &lt;!doctype html&gt; &lt;html lang="en"&gt; &lt;body&gt; &lt;textarea id="links"&gt;&lt;/textarea&gt;&lt;br/&gt; &lt;button onclick="submit()"&gt;open all&lt;/button&gt; &lt;script&gt; function submit(){ var links=document.getElementById('links').value.split('\n'); for(var link in links){ window.open(((links[link].substr(0,4)==='http')?'':'http://')+links[link],'_blank'); } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Edit: here's a [jsbin link](https://jsbin.com/yicoduzuca/edit?html,output) that should work without any issues too. Your browser may prevent the windows from opening because it might see jsbin.com as trying to open pop-ups.
Wait, in the javascrpi file you mean main.js that I will link in my html once compiled? So I will set the dependencies by requiring each vendor before the other, or browserify will manage it and remove duplicate sub node_modules? Like underscore.js is a submodule of backbone.
Yeah, browserify works (for the most part) just like node, so it bundles everything up in a way that there are no dependency conflicts, you also get shims for all the built-in modules. The important thing you must remember is that your main.js (which has all your requires and code in it), doesn't go in your HTML. Run it through browserify, put the output in bundle.js, and link to bundle.js in your HTML. Also, google "browserify handbook"
This project seems quite similar to my library [Reactbone](https://github.com/andrejewski/reactbone). Reactbone goes a little bit further than passing events to React, it also passes the entire application data hierarchy (plain JSON) to React along with method helpers to interact with the models in the context of change events. This allows cool possibilities where you can work in Backbone mutably, but all React sees is immutable structures. Either way, using either of these projects will save you from having to use Backbone.View and that is the most important benefit.
published https://www.npmjs.com/package/natural-scroll
The `npm search` command is still worthless garbage though.
They finally made flat dependencies? Holy hell, we had to make our CI builds run almost in the root of our C:\ drive or else we'd get errors with NPMs busting the file path limit. I thought the NPM team was overrun by idiots when last year, they responded to this issue on github about file length in windows saying pretty much "We're not changing this, screw you" source : [github issue](https://github.com/nodejs/node-v0.x-archive/issues/6960#issuecomment-46704998)
It's just a daemon for eslint. Doesn't really belong in the main eslint code.
Right, but aren't I assigning response to cache, which is in the parent scope?
Although somewhat similar, there are two important distinctions that require close attention here: 1. Backscatter is deliberately oblivious in regards to which parts of the monitored model hierarchy are relevant to the view's (React component) render. This ensures that the Model is tucked safely away from View concerns, so you can freely develop both separately. With Backscatter you can even use the same model(s) in different contexts, using different React components without any change to your models. I leave it to the user to decide whether her model hierarchy relates to "view" and/or "business". 2. Backscatter doesn't try to keep direct track of changing model/collection associations, instead it tracks all its entities' events and reports back only to relevant registered consumers. This reduces the risk of "dropping" events or reporting irrelevant ones. m2c: React is great at DOM manipulations, however, since not all web-apps are strictly about DOM manipulations (sometimes they control audio, canvas, URL history etc.) Backbone.Views are still an important tool I love to have around. I use it to serialize/keep-track of models that are fed to React, so they both "co-exist" wonderfully :)
Why is it that newer projects are using jQuery less and less?
I'd recommend learning "Vanilla" JS by writing functions that implement a small portion of jQuery's functionality with similar interface. For instance, how about trying to write a "toggleClass" function that receives an element, a class-name and a boolean as arguments, and behaves similar to [jQuery's toggleClass](http://api.jquery.com/toggleclass/) ? This way you'd make yourself familiar with both jQuery's great interface and JS's internals. Good luck!
By far one of the best Redux and React tutorials out there.
Shouldn't they be complaining to Microsoft about this problem? Having a path that contains more than 260 characters is surely a problem for more than just npm, even Microsoft has had problems with it: [Internet Explorer versions up to version 11 do not allow you to bookmark URLs longer than 260 characters.](https://connect.microsoft.com/IE/feedbackdetail/view/837865/issue-with-add-to-favorites-in-ie10-and-ie11).
Maybe OP can correct me if I'm wrong. It seems like docker makes it easier on the developer to adopt more features provided by linux (or whatever) and anything that might be considered "standard" installed apps. For those trying to optimize docker, they would be building a system that needs to handle quite a variety of features, and I would imagine any app that's heavily OS dependent has a lot of other optimization issues it'll face, which can impact other containers. A unikernel is significantly easier to optimize, yet it still provides the deployment niceties that docker provides. I would compare it to AWS' Lamba.
The whole "infinitely recursing dependencies" was a really bad design from the NPM guys. Even their "solution" of "mostly flat" is pretty bad imo. No other package manager does infinite dependencies because they use versioning instead, so different versions of the same package can live side by side. 
&gt;literally what is youtube guys
I see a lot of value in learning Vanilla JS so you can understand the language at its core, but please do not discard frameworks like JQuery. These frameworks will save you so much time. Don't listen to anyone who encourages you to make a full web application in vanilla JS, you will hate yourself, and probably start to write your own version of JQuery. The issue I see with these big frameworks is not understanding the language they are built on. When something goes wrong and the culprit is some JQuery function you are calling, it really helps to know how that function works. If you know vanilla JS you can figure that out. TLDR: Learn some basics but definitely take advantage of some of these frameworks.
What is the best practice for testing routes that cannot be reached until you log in?
There's an [alternate repo available](https://github.com/6pac/SlickGrid/wiki).
It’s not as needed today. Browser incompatibilities are significantly less now than they were when jQuery was most popular.
a-hole responses like this is what ruins Reddit. What is the point of fostering a community if everyone treats each other badly? Pretend that he/she asked for "recommended" or "best" video tutorials. There is lots of crap on YouTube so you don't add anything to this subreddit by telling them to "search" for it.
There are a few good Lynda.com and PluralSight intro tutorials I've taken. The ones I watched didn't deep dive but they will show what's coming or is new. Unfortunately those are paid courses. I think treehouse has a free interactive introduction course. To deep dive I would recommend looking at books. There is a sticky thread in this sub that has links to free reads focused on ES2015 (ES6). May be worth starting there.
The readme says it re-evals functions. Does it mean it wouldn't work with closures?
It uses eval from inside the function, not the global eval, so it works properly with closures (at least as well as V8). 
Is there a tldr version?
Please, just try the demo from github on an iPhone, and weep. 
TDD: Because who doesn't want to spend lots of time writing tests that will change a dozen times during development?
Sorry for the delay and thanks alot. Merged :)
Vimium is a kickass Sublime plugin. Much more than mere Vim-mode. Let's you work in Sublime as though it was Vim, but doesn't lose its mind when you try to use the mouse.
See this https://www.reddit.com/r/javascript/comments/3lgc7g/realizing_typesafe_enums_in_javascript/cv86hb6
Right. Your use of it here is absolutely appropriate, although you should `"use strict"`. The reason `eval` is poison is because it can arbitrarily change anything in the current scope, (as can `with`), but `new Function()` can't. 
Yeah spot-on. I was thinking about this a bit more yesterday and realized the main difference is that eval executes arbitrary code, and so the engine cannot optimize that. But when you use `Function` and pass in code, it is only arbitrary that one time. Once the function is compiled, it has a reified representation that is not going to change on every execution, and so the engine can optimize based on that.
If you want to keep your application completely pure, you can use [redux-effects](https://github.com/redux-effects/redux-effects) in your action creators. Using this, the only imperative function in your entire application is dispatch. And if you want to go one layer even deeper than that, I am also working on an ultra micro framework that just pipes redux into a virtual-dom and vice versa: [vdux](https://github.com/ashaffer/vdux). Using this, even the imperative dispatch calls are eliminated - all your event handlers just return raw actions.
Good, really good. I believe there is a need for some sort of explanation, help. Also, you could highlight the line on the left that is currently running on the right. Bravo.
Why anyone would down-vote this tut is really beyond me. Tero made a really good piece here and yeah I'm sure people have philosophical issues with parts of it, but for the intent of demonstrating *one way* to use redux it's really quite good.
Main purpose of the plugin is easier way for people to use ServiceWorkers and support for fallback technologies such as AppCache. It supports different update strategies, like "update all" (by version), "update by hash" and "update changed". Later is most advanced mode and is only supported by the ServiceWorkers. This mode allows to re-download and re-cache only updated/changed files.
I recommend https://watchmecode.net/
Here's an idea. How about spend some time making a small jQuery "clone" - just implement the functions that you use most often. Then when continuing your JavaScript learning, whenever you would use jQuery, try using the clone you made. This will serve two purposes: for one, you will gain a basic understanding of how jQuery works, and two, you will still be able to use all of the niceties of jQuery when you're learning about newer things.
Either of these any good? * [canvas-text-wrapper](https://libraries.io/npm/canvas-text-wrapper) * [split-text-canvas](https://libraries.io/npm/split-text-canvas)
This doesn't work in Chrome 44 on OSX
If you want to display a lot of text, the DOM might be the better option. A canvas is similar to an image element. You can stack it on other elements or stack others on top. It also gives you better looking text with subpixel antialiasing instead of grayscale antialiasing.
[I've clean it a bit](https://gist.github.com/peduxe/2935de3280202567c008), it's still not fully working. Your challenge is to fix the rest :) By the way, you're using the `const` keyword, are you aware that these are ES6 only and you need to transpile? Not all browsers run it (version or vendor specific).
What are you people doing
Redux doesn't seem to have a practical API. Seems like even more boilerplate than traditional flux.
Also checkout Joe, a very neat CLI tool to do just that https://github.com/karan/joe
assuming you've added another word list, var wordList1 = [...]; add this, var randomNumber1 = parseInt(Math.random() * wordlist1.length); replace the `var name` line with this: var name = Math.random() &lt; 0.5 ? (wordlist2[randomNumber2] + "" + wordlist3[randomNumber3] + " " + wordlist4[randomNumber4] + " " + wordlist5[randomNumber5] + " " + wordlist6[randomNumber6]) : (wordlist1[randomNumber1] + " " + wordlist5[randomNumber5] + " " + worldList6[randomNumber6]); `name` now has a 50% change to generate as it does now, 50% to generate from wordList1, 5 and 6.
exactly, the reality is that UX designers today are designing the change between every state in an application / website as a transition. So unless you can convince your designer that it's bad design to ever hijack the scroll position (and maybe you can), you're going to need to do this occasionally.
Is this goofy or a copy? http://www.goofyapp.com/
Generally I'd suggest avoiding "libraries" unless you are seeking an all-in solution like Pixi or PhaserJS. Instead, you might prefer a couple of npm modules. Here's a few text/canvas related modules you might like: - [word-wrapper](https://www.npmjs.com/package/word-wrapper) - for multi-line text - [vectorize-text](https://www.npmjs.com/package/vectorize-text) - if you want to do fancier 3D/SVG stuff - [canvas-loop](https://www.npmjs.com/package/canvas-loop) - generic boilerplate for raf loop + full screen canvas fitting - [get-canvas-context](https://www.npmjs.com/package/get-canvas-context) - tiny convenience util - [load-bmfont](https://www.npmjs.com/package/load-bmfont) and [layout-bmfont-text](https://www.npmjs.com/package/layout-bmfont-text) - for bitmap text Below is a more general list of text modules. A lot of them are tailored for WebGL. https://github.com/mattdesl/text-modules
There's also http://fbmacmessenger.rsms.me/ which I've been using for a while, but is fairly buggy. Realistically, they're all just thin wrappers around the same underlying web app, so they'll all look very similar.
It says it has desktop notifications. Is that possible in Electron or is that just a Facebook messenger thing?
Pretty cool! Thanks for sharing!
This is a wrapper for [Messenger.com](http://messenger.com), which is really nice.
I think that there is a genius idea in here but I find it quite hard to use and understand. The buttons don't have mouseovers to say what they are doing, debugging is very hard, etc. Does the pulsing indicate how often the code is being run or is it just a visual effect? What does the recorder button do? 
Pretty cool! What do you see as the possible applications of this?
Also potentially problematic is that using dynamic functions will prevent usage of the library in places with a content security policy (csp). For example, [chrome extension csp](https://developer.chrome.com/extensions/contentSecurityPolicy#JSEval) will probably prevent the library from working in chrome extensions.
Thanks! Here is all that I thought: 1. Easy access to your phone all time, personally. 2. Instead of having emulators, anyone can now test an app on a live phone - much faster. 3. If you use localtunnel, and you have connected the phone to a laptop, anyone who has internet can access and control this phone. Give them the URL which localtunnel gives and this works like remote desktop. 4. Stupid thing, but this makes it easier to demo your apps while using a projector. (We used to use facetime and show our phones while demo-ing)
Ya, i'm working on that. For the time being, the best way to understand my packages at least is just to read the source code. They are all extremely short (1 file, &lt;100 lines of code, for the most part). And if you have any particular questions i'd be happy to answer them, and they'd be very helpful in creating better documentation and examples for others.
Give the following a shot. python -m SimpleHTTPServer
Thanks for sharing info (:
The first one looks like what I need, I'll try that and see how it goes. Update: [canvas-text-wrapper](https://libraries.io/npm/canvas-text-wrapper) is cool. I combined it with a simple class to generate and cache text offscreen with it, I'll probably put that on github at some point.
Classes, instances, classical inheritance, static methods, singletons, etc, etc.
&gt; Foo.staticObj.prop = 2; // Error! const can't be changed! This isn't right, `const` doesn't affect a value, it affects a reference. This is just about the most common misconception in ES6 I think. const foo = {}; foo.bar = "foobar"; // works fine, no problem foo = false; // syntax error, cannot re-assign `foo` const bar = Object.freeze({}); bar.foo = true; // Error, cannot assign a new property to a frozen object. bar = {}; // SyntaxError, cannot re-assign a const
ES6 classes can do all of those things...
Certs are great. They make cert companies a lot of money from people who think they need one!
Not tested but can you do: ``` oninvalid="this.setCustomValidity($filter('myfilter')('String'))" ``` Edit: alternatively you could use the filter within your setCustomValidity method?
Giving a second life to a tablet with broken touch ?
I'm not an expert on performance, but one thing you DO want to use is prototype. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype This means you use a shared method for all derivatives of your class.
This looks a lot like https://github.com/paulirish/adb-screenrecord-script 
Not really, it's syntactic sugar.
How is that meaningfully different?
Like this? &lt;input placeholder='0'&gt;&lt;/input&gt; &lt;input placeholder='1'&gt;&lt;/input&gt; --- var input = document.getElementsByTagName("input"); input[0].onclick = function () { alert("You clicked input 0"); input[1].click(); } input[1].onclick = function () { alert("You clicked input 1"); } 
I need to reserve some time to learn in depth this library, it looks like a powerful utility. I've just used Subjects and flatMapLatest but there are just so much it may be worth.
I don't think so. I started using Redux at work pretty much when it came out and just built a little side project with it that I'll probably share later today. I didn't spend a lot of time writing straight Flux, but Redux definitely seems like it has fewer concepts and cleaner architecture.
Well I knew about browserify, but didn't know it was common practice to put frontend modules in npm. Although I don't really see what it would change from using something like bower, in the case of frontend stuff. budo (from your link) is awesome though, I'm currently require.js and I would prefer that.
My main gripe is not being able to do for in an array and for of an object in ES6, until then coffee.
Wow! Now that's an use case I haven't thought about at all!
That's part of the issue. They're short, but I'm not entirely following the context of when, where, and why you would want to use them. I sorta grasp the idea that you're creating a pseudo promise chain, but not clear on what's going on past that. I don't have any absolutely specific questions atm. I'll try to let you know if I think of any.
Coffeescript completely squandered their lead on ecmascript The kickstarter for coffeescript redux was a failure. Now they can't even get features babel has like async functions as options. These are things that are extremely important to people looking forward. I'll always be thankful for the influence of Coffeescript but Coffeescript is so mismanaged you'd be insane to start new projects with it. If you look at the issues on GitHub the owner of the repo ignores everything important. 
Just reverse them http://jsfiddle.net/yydbwj21/ http://jsfiddle.net/346tmmtf/
Most of these types of complaints look like they stem from mental laziness to me. The "future proof" point seems odd as my biggest gripe about Javascript is the "don't break the web" mandate ECMA has taken. Basically, they've committed to never removing the bad parts of Javascript. To me, the real motivation of most of the hate of every non-javascript language is just that people are too lazy to learn a new syntax or a new programming style. Personally, I like the fact that I get to work in several different languages on a daily basis. I'm also hopeful that we can kill off javascript as the assembly language for the web with wasm. My bet is that having lots of languages compile to byte code and never touch javascript will kill off javascript very quickly.
Coffeescript was always a non-starter for most devs. 
Hey @DWboutin -- we (Frontend Masters) offer refunds for basically any reason, so feel free to ping us and we'll offer a full refund.
For sure, I'm in the same situation! I've lately been looking into React though, and it seems like a better bet for us noobs. Although I from what I've read, just locking down fundamental Javascript concepts should be the first priority. I don't think employers should really expect junior developers to be experts in any one framework since they're changing so fast anyway.
Then it looks 'half a lot' like Paul Irish's implementation.
Those seem like good enough reasons.
I've been looking for something exactly like this for months. Awesome!
He has done so much but left a lot undone. Funny that he created underscore and coffee but never added a |&gt; operator to coffee that they added in the livescript fork livescript.net that would've allowed both to work together much nicer in my opinion. The explanations for not including this stuff alway ends up with a pull of the trump card with "it compiles to ugly code" and "Coffeescript is just javascript"... Okay but I don't see why there isn't a plugin or a flag for future es options (like every browser, transpiler, and node) or even a standard way to write plugins
I never understood the appeal CS. Why would you introduce a whole new layer of tooling, debugging issues, and a whole new syntax (that will have to be maintained by future team members) just for some syntactic sugar?
balance cost with what potential value you might get. I have a college degree that hasn't really done anything for me, but people still like seeing it on a resume.
I was hoping to find a miracle solution to reverse tethering through USB for my tablet with broken touch and broken wifi, half of my problem is solved now, thanks! Some feedback on your package.json : I had to `npm install body-parser`manually. It works fine on Chrome but I can't get it to work on Firefox, I guess it doesn't like the headerless JPEGs sent by Express. Some random thoughts : - Streaming through a web socket would be less intense and a bit faster. - You left some wine and cheese in the /screenshot folder :-) 
I would drop coffee for ES6 but unfortunately I am allergic to squiggly brackets.
Ho sorry, i didn't know! Thank you
i really really really hope - like i'd totally contribute money if it assured me - that ES6 is the death of coffeescript. i realize its not exactly "professional" but if i'm looking for a lib to do something and its written in coffeescript... i keep looking. 
&gt; # Outputs your greeting into console &gt; say = (who, what = 'Hello world!') =&gt; &gt; [firstName, _, lastName] = who &gt; output = "#{what} - #{lastName}, #{firstName}" &gt; console.log output &gt; &gt; say ['John', 'Michael', 'Doe'] I don't get why anybody would want to write gibberish like this.
When do you actually need to log the type of a class, though? It's like every other tedious criticism of JavaScript that requires you to be be doing really odd things - no-one is ever going to run into it when doing real work.
ugh - I *despise* list comprehensions in coffee, I personally prefer to abstract that stuff away into a functional lib like ramda
I'm glad you mentioned this. From all CoffeeScript variants, LiveScript is definitely my favourite. Its pretty much what CoffeeScript should have been from the start. However, LiveScript is still not in line with ES6. It doesn't support ES6 modules, which is a major bummer. For me, its pretty much a dealbreaker already. Also how would you add optional static typing to LiveScript? If you choose to use ES6, you can still use TypeScript or Flow. With TypeScript... Not so much luck. The biggest problem I find with LiveScript is developer fragmentation: if you 10% of devs want to write CoffeeScript, its probably 10% of that 10% that prefer LiveScript over vanilla Coffee. So why the heck I would want to choose to use LiveScript if other devs don't use it? 
Nailed it.
This is exactly the way I view the world as well. Ashkenas has done an enourmous job. He has contributed by far more than anyone could ask from a person, heck, even from a company. The thing is just that these things have outgrown what one man or woman can do alone. We should have let Coffee grown into an open source community ages ago if we really wanted to have continuity. Its kind of sad this didn't happen. But its also very awesome that people at Ecma community took note and took out the good parts and lessons learned from Coffee.
Ruby developers? I also don't know why indentation needs to be forced, I mean, come on guys...
What?
They're now developing some stuff on ES6, check the line ending selector, incompatible-packages package, it's using ES6 and the later has a React variation.
Did you really not understand that it's an example to cram as many features as possible into a small snippet? Obviously you wouldn't use this for anything, but you might use: * Default Parameters * Array Destructuring * Ignoring a value you aren't interested in * String Interpolation None of those are in ES5, but are in CoffeeScript and ES6
Wasn't even sugar, just shorthands. Ths is wt Coffee lukd lik 2 me cmpred 2 real jvscript. Good fucking riddance to it!
yer
Any reference to where the rewrite is mentioned ?
Hi /u/DWboutin, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
This is a great book, though aimed at people who already know JS.
Not sure why you're being downvoted but =&gt; is in es6. Also, you realize that coffeescript is a context sensitive grammar right? Which is considered to be background overhead and an OCD killer by many due to the rules this introduces ;) IMO, it looks squeaky clean but the hidden context sensitivity makes it a bit of a bruised apple. You never truly win this game bwahahaha. 
I did my PhD research on creating embedded languages for non software engineers so I do know quite a bit about what makes makes it possible for novices to write software (it's never easy, however). And, we creates Domain Specific Languages (DSLs) that had many fewer features -- to the point that some weren't turing complete -- and implemented specific design patters very well. When you give people the right tools for the job, the job does get easier. 
Haven't used it myself, but they claim this works: http://www.technicaladvices.com/2012/07/16/preventing-backspace-from-navigating-back-in-all-the-browsers/
This is possible through the process described in my other comment (which was downvoted for some reason). Depending on which event the library is listening to (likely `change` or `input`), you can "proxy" events by programmatically creating new events, then dispatching them from the other element. [Here](http://jsfiddle.net/bmaa911n/1/)'s an example with `input`: var ownElement = document.getElementById("inp1"), theirElement = document.getElementById("inp2"); ownElement.addEventListener("input", function(e){ var ev = new Event("input", {bubbles: true}); // overwrite srcElement and target var that = this; Object.defineProperty(ev, "srcElement", { get: function(){ return that } }); Object.defineProperty(ev, "target", { get: function(){ return that } }); theirElement.dispatchEvent(ev); }); // THEIR CODE theirElement.addEventListener("input", function(e){ document.getElementById("outp").textContent = e.target.value; });
Try something like `if(event.which == 8 &amp;&amp; this.value == '') event.preventDefault()`?
Now we just need GitHub to get rid of their shitty standard and convert Atom.io to ES6
Sure. Admittedly my little bitch session is not too common, however I have run into some little helper tying backbone to socket.io in CS. Little things like that. Perfect little solution solving some minor inconvenience... Then u realize it's in CS and therefore not perfect :) 
Pretty neat. It'd looks much better if you remove the stroke:black from your .axis text, imo. fill works best for svg text if you want to change color.
I first got the following errors: * Error: Cannot find module 'express' * Error: Cannot find module 'body-parser' Had to manually install via 'npm install express' and 'npm install body-parser' before I could run the 'node node_screenshots.js' command. Then I got this error when running the './screenshots.sh' command from the scripts directory: ./screenshots.sh: line 4: adb: command not found. So, I had to go to https://code.google.com/p/adb-fastboot-install to get and install the ADB software. Now I'm getting the following error: error: device not found. The pre-reqs on the github page says, "Connect phone to computer via USB before and make sure you have adb v24.3.4 in path." v24.3.4 is the Android SDK version. I am running adb version 1.0.29 now. Running Galaxy Note 4 with USB debugging turned on. The phone connects to the computer via Android File Transfer, but doesn't show up as an adb device for some reason.
Seems like you hit your API request limit. 429: rate limited
We use CS at work, happy that we're moving forward to ES6
React is much easier than angular for its intended purpose. Plus React Native is going to eventually dominate a large slice of the commercial mobile app development job market. So it's good to learn. To anybody generally confused about the concepts, I'd recommend going through the fantastic, interactive Knockout.JS tutorial. Within 1 hour you will understand data-binding and basic single-page app design. Knockout inspired the next generation like React, Vue etc. You can learn react pretty comprehensively in under a week.
Can't the same be said for learning ANY language? C'mon.
Why doesn't ES6' arrow functions count? Since when doesn't JS have an object literal syntax? ES6 might not have array comprehensions, but [ES2016 certainly does](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Array_comprehensions).
Because that "syntactic sugar" can remove a completely insane amount of cruft from code which is simply unnecessary. CoffeeScript has: - Default values for arguments - Destructuring assignment - Destructuring in function parameters - Lexically scoped variables by default (remember that CoffeeScript existed before strict mode, this was *huge* then) - Shorthand function syntax - Everything is an expression (ES6 still doesn't have this, `if` being a statement instead of an expression is a giant pain in the ass in ES6) - Classes, including inheritance and `super`. - String interpolation - Existential operator (ES6 doesn't have this, and it's super, super useful, this is probably CoffeeScript's best feature, and it's inspired similar features in other languages like C# and Swift) - Lexically bound functions (ES6 finally has this, but this was a huge pain point in ES5) - A non broken `switch` statement (again not in ES6) - Conditional assignment (Babel has a non-standard extension for this, but I feel bad enabling it since it's not in either ES6 or ES7) - Implicit return (I admit this is a double-edged sword, sometimes it can be a bit problematic) That is not trivial lipstick. CoffeeScript is a fundamentally more powerful language than ES5, and in some respects still more powerful than ES6. These are all features (aside from inheritance) which people usually cheer for a great deal in languages, so why is CoffeeScript so reviled when it adds a lot of stuff which people love in other languages to JavaScript? It baffles me completely. Also there is no denying that most new features in ES6 are taken straight from CoffeeScript. The argument that you need tooling and get debugging issues is just as true for Babel as for CoffeeScript. Babel is a transpiler too, the way it works is fundamentally the same as CoffeeScript. And seriously the new syntax takes like ten minutes to learn for new team members. It's not that hard.
Thanks for this! I've been wanting to learn React because like you said it's going to be a huge part of the mobile scene (and the job market). I always put off learning Knockout because I felt it was outdated, but I'll definitely do the tutorial. Any resources for getting React down? 
I had an interview a few weeks ago and did not get the position because they deemed me to be too newbish. But they were super awesome and sent me a list of things to learn and freshen up on - Mobile Java Javascript Node.js so that leaves me to think Any javascript-based MVC framework would work. 
I write plenty of assembly code, I love assembly. Assembly is in a different domain than web devlopment.
You mean like Python?
Thanks for pointing out the issues. I have added express and body-parser as dependencies in my package.json. just 'npm install' should have worked from within the porject folder. I have also updated the version numbers for SDK and adb in the README. My adb version: Android Debug Bridge version 1.0.32 Revision 57224c5cff69-android However, if 'adb devices' does not list your phone, that seems to be a different issue altogether. You might have to fix that first.
Who inline their functions like that? Curly braces and function bodies in the same line, are you taking the piss? You will most likely see this, process.on('SIGTERM', () =&gt; { server.close(() =&gt; process.exit(0)); }); and: process.on('SIGTERM', function () { server.close(function () { process.exit(0); }); });
Interesting - that's helpful information. Mind if I ask what kind of position you applied to? It seems like they want a bunch of different skills for both frontend and backend.
Wait, somehow whitespace is better than a bracket you can actually see and count? That makes little to no sense. Shit man, most every editor will show you the bracket depth anyways. edit: Regardless of if you think whitespace is better, don't force people to use it, that's just forcing your way of coding on other people for no other reason beyond personal preference.
I'll bear that in mind next time I personally design a programming language
If I am hiring a mid to senior developer and one has experience writing javascript and one has a credential... I will want to interview the person with experience. However, if I am hiring a junior developer and one has no javascript experience and the other has a credential, I will interview the guy with a credential. Yes, I will ask a lot of questions about the credential and javascript in general.
Ah I see. They want interns to know all that too? Talk about high expectations... better step up my game. ;)