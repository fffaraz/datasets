You shouldn't ever be writing .d.ts files manually. They are output by the typescript compiler. You should just be writing .ts files.
You might be better off looking into Outlook macros bases on the subject line or something. 
This looks gnarly. Thanks for the link!
Are you saying you release all the pooled objects at once, or that you link them back to the pool when finished with them? Are the objects always the same, structurally?
People use frameworks because they make things easier. Fundamentally, some common things have to be done. They can be done by the language (standard library functions), tools and frameworks, or by the programmer reinventing the wheel. Even if the language becomes saturated with helper functions, all you have done is changed the definition of "vanilla js". So, no, as long as people continue to do mildly complicated things with js, they will keep using tools and frameworks to help abstract and avoid repetition. Less is more only works when your web app actually does less. It's not like js is the only language with frameworks.
I don't think NodeList.prototype has .map. It does have forEach on modern browsers, though. But yeah, I did exaggerate the length a bit. That "createTextNode" was a joke ;)
[I'm a guy](https://github.com/pakastin)
must be using npm v2 or something, that is one slow install
if you want to get close to vanilla, use vanilla. 
I dunno, I'm not holding my breath. You still have to do too much direct DOM manipulation with Web Components, and data binding isn't a thing. I hope Web Components can mature to the point where they can seriously compete with existing JavaScript frameworks. It would be amazing to use only native technology. But right now, I think there are still too many use cases they don't handle well. 
I don't really see how using a library means you're no longer writing vanilla JS. If you use lodash, for instance, it's still written in JS. You're just not rewriting all those functions yourself. It's no different than using functions from the standard library in Python, or importing a 3rd party package.
Also a good choice.
In all seriousness though, I get a hard-on when I read things like "2KB."
Here's one benchmark: https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html
listen to keypress, while key pressed move in direction
&gt; I have a program which allocates many small short-lived objects of a few different types in bursts (every n millisecond), Generational garbage collectors are already optimized for this use case. They just bump a pointer when allocating a memory from nursery.
I return them all to the pool. Structurally they are the same (I do not add new properties).
Have a listener for keydown. When the key is pressed, set some variable to true. Have a listener for keyup. When the key is pressed, set some variable to false. In a requestAnimationFrame-based loop, update the position of the object according to those variables. Then draw it (if you're using a canvas).
I am - but jQuery does a really good job of making things very simple to develop AND has great cross browser capabilities. If I write code in jQuery I can be pretty sure it'll work across 99% of browsers. 
`forEach` is more indicative of what you're doing, so it's a win win.
üòéüëç
I'm confused by the point of doing this; doesn't webpack's latest iterations integrate tree-shaking via a few tweaks to the config? https://webpack.js.org/guides/tree-shaking/
I can confirm that with `16.0.0-beta.3` I was able to render the application using both Chrome v25 and Fetch as Google.
See [this talk](https://www.youtube.com/watch?v=0nh2EK1xveg) where I live code a slightly simplified version from scratch in ~30 minutes üòâ
I think Vanilla JS refers to the newest ECMAScript standard. To me vanilla JS is currently the ECMAScript 2017 standard
1. To be able to move html elements you should pull out them from rendering thread, where the browser render is responsible for positioning. Do element.style.position = 'absolute'; 2. The properties responsible for positioning are 'left' and 'top' (it's like x and y). Do element.style.left = '20px' to put it left into point 20 px. 3. Add event listener to body and check keyCode of pressed button. body.addEventListener('keydown', function(e) { If (e.keyCode == %key code for button%) { //do move here } }) %key code for button% is integer number defining keyboard button. They are well known, like constants. For example for arrow keys: left = 37 up = 38 right = 39 down = 40 Just simplest implementation, hope that help.
You can also try to play with options like `max-semi-space-size` if you trigger minor GC too often during this bursts.
This is in stage one right now iirc!
not who you replied to, but i'll give you my two cents anyway: - mongo (or any document db for that matter) don't subscribe to the concept of schemas. this is nice for prototyping, but once you know your data, it becomes a hindrance. Not having a schema on the db level blocks a lot of optimisations that a relational db can pull off. - there are no joins. because every document in mongo is supposed to be complete, you basically have to actiely duplicate your data ("denormalization"). this is mostly resolved by the 3.2 update and its map-reduce type of aggregation, but frameworks like meteor still don't allow for any joins - the dataformat is quite large ( coming from rethinkdb and not mongo here). we recently migrated a project from rethinkdb (a document db) to postgres, and the db size is now a tenth of the old one. i assume this is because document dbs have to store the keys too, since there's not hard schema. relational dbs can optimize here, since the schema is known. - and lastly (this one is not a technical argument): mongo as a product has been losing data for a long time until it was fixed, as well as [repackaging postgres for the BI connector](https://www.linkedin.com/pulse/mongodb-32-now-powered-postgresql-john-de-goes)
Why would you reinvent the wheel?
Absolutely agree! We have nice Vanilla API's now, but if I knew I had to support old IE, you can bet I'll use jQuery. It's just not worth the headache for the sake of being modern. 
Once you call setTimeout, it will start the timer and continue running code. So the entire for loop executes instantly and queues up all 5 timeouts. And then they all will fire at the same time. There are a few solutions. You can either offset the time for each timeout. So instead of 2000, you could do 2000*(i+1). Another option is to have one timeout's callback start the timeout of the next one and daisy chain them all together. Both solutions are good but one will usually make more sense depending on the specific situation.
setTimeout is asynchronous. JavaScript is one threaded language, it can't just wait. You can emulate needed behavior with promises or generators.
ahhhhhh that makes sense. Thanks!
Oops. I totally forgot setTimeout was asynchronous. Thanks!
This is the code you need https://jsfiddle.net/newuy4gg/ But it will only work in modern browsers or with Babel transpiling to ES5.
[removed]
[removed]
It's pretty easy to do this in a way that works in all browsers. For example: function slowLoop( count, interval, callback ) { var i = 0; next(); function next() { if( callback( i ) !== false ) { if( ++i &lt; count ) { setTimeout( next, interval ); } } } } slowLoop( 10, 1000, function( i ) { console.log( i ); }); In many cases what you probably really want to do is iterate over an array. So you could do that like this: function slowEach( array, interval, callback ) { if( ! array.length ) return; var i = 0; next(); function next() { if( callback( array[i], i ) !== false ) { if( ++i &lt; array.length ) { setTimeout( next, interval ); } } } } var array = [ 10, 20, 30, 40, 50 ]; slowEach( array, 1000, function( element, index ) { console.log( element, index ); }); 
Joe Eames on one of his Angular courses estimated that using a framework such as Angular or React can save 80-90% of code over plain JS. If that is true, it's Game Over. 
you can force javascript to wait you by adding a while loop : let amount = 5 let amountLeft = amount for (i = 0; i &lt; amount; i++) { let done = false; setTimeout(() =&gt; { console.log('test') amountLeft-- console.log(amountLeft) done = true; }, 2000) while(!done){} } 
Maybe checkout SendGrid and build some small node server that pushes all the mails.
Yeah you're right about .map, haven't done web in a while and I'm already forgetting things!
I'm in the habit of defaulting to .map to avoid unwanted side effects, not that it would help in this without unpacking it first 
Windows...
You can use it if you need to support old browsers, for compatibility. But in real world, there is WebSockets available and you can push update messages from the server.
Without a framework: * State management: dumping data into dom nodes and constructs sprinkled all over the place * Orchestration: setTimeout to wait for a fadeout until the button collapses * Optimization: thrashing the dom with unorganized read/writes for extra bad performance * Reactive: updating with wires thrown throughout the app to inform views * Components: just a big div soup with id and class hooks * Sharing: very little can be shared or re-used, if anything at all * Eco system: everything is made from scratch You wouldn't come far, so even if you don't use a ready-made framework, you would most certainly make your own to deal with these issues. The chance that your method is slower, has more bugs and becomes unmaintainable after a while compared to battle-tested and established frameworks is probably a healthy 100%. And this is just you alone, in teams it will cause further problems. Frameworks are lightweight anyway. The react-like functional ones [start at 2-3kb](https://twitter.com/LJKenward/status/892969545723371522). That is a small price to pay. On top of it they have large eco systems and cut all ties to the browser. They're actually empowering vanilla js instead of crippling it like the browser does by separating it from ui-constructs.
My advice would be to to not make any choices. Redux, Flux or Rx? How about none? Relay or Apollo? How about window.fetch? Understand what the library does for you and what you need and then make a choice and introduce the third party tool. This might take a while but you will get a deeper understanding of what you are doing. 
Hehe! Nice one! You could use the steps() parameter on the animation for the progress bar to make it more terminal-choppy, and add another layer of realism to it.
You can automate this using https://github.com/lodash/babel-plugin-lodash
I am thinking the trend towards decomposition of large complex things into small simple things ala Functional Reactive View, Containerized deployment, Service oriented architecture. Anyone have some opinions?
Object orientation (i.e. there are way fewer structure / procedural langs used in general) because polymorphism is conducive to coding at scale. 
Would be interesting to hear Facebook dev's comment as to what made them work on `flowlint` versus supporting existing solutions in the ecosystem, such as https://github.com/gajus/eslint-plugin-flowtype.
That won't happen for the good of web development. wc don't solve real world problems and are years behind the modern stack that solves current issues elegantly. Their imperative nature isn't a benefit. Worst of all, javascript is already out there driving mobile and desktop apps natively because the functional nature of modern frameworks allows javascript to be free from the browsers shackles. wc are, again, template based and bound to the dom, so all that goes out of the window and we're back to the 2010 era where the browser is the only content host. wc will also always be dependent on frameworks like polymer, because the spec alone does virtually nothing but encapsulation. There is not a chance that developers that have worked with a modern stack will see much benefit in wc [and you see this reflected in usage stats.](http://www.npmtrends.com/vue-vs-react-vs-@angular/core-vs-ember-cli-vs-@polymer/polymer)
OOP is a little bit old school. I am finding folks are starting to try to centralise data more and more on the client and distribute data by feature more and more on the server whilst rely on simpler functional composition everywhere in between. I think strict typing on the front end now with Flow and Typescript allows for some great deliberate polymorphism across projects or services. In what way do you find polymorphism helps with scalable code? What sort of languages and platforms are you thinking about there?
Those numbers are pulled out of thin air. If you don't use a framework you would first start with making your own framework. The advantage of these existing frameworks is that their developers have been working on them for several years so they are more efficient and have less bugs. The disadvantage is that they come with functionality you might not need. You will save 80-90% code if you write code which is not reusable depending on the size of your projects yes, but you should try to write reusable code.
This is ridiculous. Unless you code on Raspberry Pi level of hardware there is no possible way either of those editors will take minutes to open one file. Of course Vim is faster but try to compare JS features of Vim with VSCode and Atom.
Thanks for the reply. After searching the web for websockets I noticed almost all examples are chat apps using web sockets. Is it common to use it only for chat apps or is it just an easy example? 
WebSockets just allow to send messages in both ways between server and client in real time (with no additional requests), and chats are the common example of the app which require as minimal delays as possible. Look for Socket.io library, it's easy to use and it has fallbacks for old browsers.
Lol not sure if cheeky comment or not. There is no scenario where you'd ever notice a performance difference unless you were doing a loop of 10,000 or something.
Thanks, and best of luck again. I'd like to see Open Collective succeed, I think it's a good idea and has a lot of potential. Seems like a fun project :)
Haha a bit, I don't really believe this is the area true performance gains are made.. But according to JSperf it's 100% slower, or twice as slow on my machine: https://jsperf.com/getelementsbyclassname-vs-queryselectorall/15
~~I've tried again updating to v16, but I am getting some really weird behaviour https://youtu.be/jsG9_gC5cy4. CC /u/brianvaughn Sorry for a video instead of a replicable test case. I can try to isolate this, but it is no small task.~~ Whatever is going on here, I am able to replicate it using v15.
It's a bit early in the morning for me to bother deciphering it all, but there are references to an MSIE 6.0 user agent, http headers, and what looks like an attempt to invoke ActiveX or WSH objects. It's almost definitely an older malware script. Looks like it may be making the rounds again. I found a similar script on pastebin.com from 2016 https://pastebin.com/kEzLeKAc And various references to exploit toolkit analysis results: https://www.hybrid-analysis.com/sample/c8bdc983c0ee5216e5adf520e6945fb928e8caff606e8ca16deb6bd0279e31ef?environmentId=100 
For frontend development, https://cycle.js.org/ (and honorary mention https://gist.github.com/staltz/868e7e9bc2a7b8c1f754) was an eye opener for me. Not using it at production, but it opened whole new world of sense for me. Like modelling and thinking about interactions not on the basis of events but by streams. From there, it took short path to React land for me, the and which at last made sense for me (as oposed to OOP patterns and languages like java/backbone/angular)
functional programming in a nutshell ;)
websockets will break in the real world, household wifi won't be a problem but company networks often have them blocked so people behind it won't be able to use your app. Socket.io has nearly the same api, with a couple of lines you have a server/client connection working, but it overcomes everything, not just servers or old browsers lacking ws but also blocking networks/routers.
&gt; we have tools like Babel to avoid compatibility issues Babel won't account for run-time weirdness like when two browsers implement the same spec differently/incorrectly etc. That's what jQuery is there to solve (and also to solve compatibility on very old browsers). I don't really use jQuery any more (haven't touched it in nearly 2 years), but Babel is not a silver bullet for behavioural compatibility issues, only syntactical ones and can't be used as a justification to do away with jQuery.
I can only see this happening in Vue and Angular, maybe. React has already stated that it will not go the way of web components. `react-render-dom` *might*, but `react` itself will not use web components.
yes, plain javascript without frameworks will *usually* outperform framework javascript when written perfectly. however, developer 'cycles' are more expensive than CPU cycles and usually the performance difference is negligible. Plus one of the main benefits of a framework is that it helps you organise your code. You could write a few widgets using plain javascript and probably do just fine. But many frameworks have optimisations over plain javascript. Take React for example, which uses a virtual DOM so it only ever updates the DOM when it notices a change in props. Unless you wrote something like that, React probably outperforms your Vanilla code.
Thanks for this tip but could not make it works. Can you show me how?
Does anyone know of any *good* flow plugins that won't make VSCode shit the bed? I love VSCode and hate Nuclide/Atom, but it's really awful to use Flow in which means I basically only ever use TypeScript. Even in nuclide/atom the flow update cycle seems really slow, which is the main reason I do not use it.
Agree and disagree. I was recently tasked with making a very simple two page app. It was easier to just make it in vanillajs. I wrote a simple $ selector and just got it done. It was incredibly liberating. It's for an MVP, and it is a very small app, but there is no question in my mind that the sub-half-second load times that I get are 100% a result of my choice to keep frameworks out of it until they are necessary. At some point, some element will be better served by react than vanilla js, and on that day I will add react. But I'll do it after the project is successful enough to warrant the extra overhead. In the meantime, this was cheap, fast, and quick. A lot of times our projects don't need to be as complex as we make them. A lot of times we would be better off settling for less and finding out which more makes the most sense. 
Same reason as why they made jest instead of contributing to mocha and why they made yarn instead of contributing to npm.
I don't use VSCode so this may not be of use to you, but with Atom I highly recommend using [flow-ide](https://github.com/steelbrain/flow-ide) rather than Nuclide because it's a lot more lightweight but still has everything you would want (linting, autocompletion, goto definition/declaration, etc). I haven't really noticed any sluggishness or slowness with it.
Are you referring to TypeScript et al, that compile into JavaScript or are you referring to frameworks like JQuery that encourage a very different style of coding or just frameworks in general? People use frameworks and modules to avoid writing boilerplate code. Don't see why people would stop doing that. Browser comparability isn't really a huge problem now that people are moving off IE and Microsoft is getting their shit together. So the need to use JQuery et al for that reason is going away. The DOM API is famously pretty shit. That's not JavaScript however, it's just a browser API you can use to modify the DOM. You can use a framework to deal with the DOM if you feel like. People use TypeScript et al for convenience. The reason Microsoft developed TypeScript was to manage 100k+ codebases and make things like refactoring variables manageable. Not really sure what you mean by Vanilla JS. Tbh it sounds like a "too many frameworks reeeeee" rant. Writing plain JavaScript has become a lot more common what with the browsers playing nice but there are still going to be frameworks and transpilers to keep devs productive. 
Because that offsite link is pointing to gaearon taking the criticism on board and bringing it up with other CRA contributors.
 async function start(){ let amount = 5; let amountLeft = amount; for (i = 0; i &lt; amount; i++) { await new Promise((resolve,reject)=&gt;{ setTimeout(() =&gt; { console.log('test'); amountLeft--; console.log(amountLeft); resolve(amountLeft); }, 2000); }); } } start();
&gt; $("#someId") is rather more pleasant to type than document.getElementById("someId") (especially if you're typing it more than once) Well then: let gbid = document.getElementById; let element = gbid("someId); ... ... Was that difficult? The way some people complain about having to poke some extra keys on a keyboard you'd think they were digging ditches for a living. 
The default response is always "web sockets", but the reality is that web sockets are a rather heavy handed solution for simple use cases like these. You would not rent an 18-wheeler if you only need to transport a single dresser from Ikea... I answered a StackOverflow question related to this a long time ago, my answer still applies today: https://stackoverflow.com/questions/14051795/push-changes-to-a-webpage-without-refreshing/14070911#14070911
I'm new to React, but not new to JS. I've been using Ember for a while, and was an early adopter on that, which was painful, so I made a point of not jumping on the React bandwagon for a while, so it could mature, and I could enjoy a more robust, battle-tested ecosystem. One of the things I like about Ember, though, is that it's got sensible defaults that are designed to work well together, so you just have that standard, and when you develop a specialty need, you can pull in something else as a stack component, and the Ember plumbing can accommodate that. It's not that I don't appreciate the need for a data fetching layer, and state management or whatever, but I'm not super eager to jump in with one tool, find out it has fundamental flaws for common use cases midway through, have to swap it out and rewrite a bunch of crap over and over.
Aside from the examples given here, can you give an example of the type of code you are talking about?
You are looking for setInterval not setTimeout. var id = setInterval(function, ms) calls a function every ms milliseconds. You can then use clearTimeout(id) to stop the loop
Nop, `flowlint` is about style errors, not type errors.
Discovery of the day. Looks sweet.
I don't see a single function call here :/
https://en.wikipedia.org/wiki/Functional_programming
But it does not work with .chain()
the mostest random number
The gradual upwelling of Vue over React is evident with the license talk and the github popularity. I'd say the largest factor for me personally is knowing when to ignore the infrastructure/packages/libraries/paradigm shifts/etc and actually sit and program with a goal towards the end product. I have found myself in the past getting lost in the miasma of patterns/functional programming/webpack/babel/linters/jsdoc/flow/typescript/etc and wasting all of the time I use to use on actual programming on learning the new hot tool, no more.
13k! _but /r/js1k/ ought to be enough for anybody_
BACK IN MY DAY: https://en.wikipedia.org/wiki/64K_intro ;)
&gt; It‚Äôs just flat out ridiculous to have an editor consume all the processing power and memory available on a ‚Äúmodern‚Äù expensive laptop, when it doesn‚Äôt need to do so at all. I don't know who sold him that expensive "modern" laptop but he got ripped off big time. I bought my laptop almost two years ago. I tested opening a 50mb xml file with VSCode and it took around 4-5 seconds.
Maybe not in a big way. But recently I was fighting memory-leak and performance problems for a large grid written in EmberJS and this thought has crossed my mind couple of times already. 
Thank you so much for your precious contribution. :)
`writeTo` won't be available in global scope. Try adding `window.writeTo = writeTo;` in the entry file, or just skip setting the event handler in the HTML and set it directly in the JS instead. Also, it should be `&lt;button onclick="writeTo()"&gt;` (note the parenthesis).
Thank you very much it works.
You're welcome.
Most of the time you'll be using a library or commercial service to provide realtime updates that will automatically use the best message delivery mechanism available so that you don't have to worry about the implementation. These libraries still use long polling when appropriate, but the API is typically a black box that works the same regardless of message transport.
I use vim and I've never gotten flow to be performant for very long. I realized for me, it was actually the flow server in the background hogging resources. It's bad enough that I don't use it for new projects anymore. 
This fails for me. I tried in the first snippet `document.getElementById("root").getElementsByTagName("label")` but it returns an error. Lately I have been using http://jsbench.github.io/
 I found this video helpful. Kind of a visualization of this explanation. https://www.youtube.com/watch?v=8aGhZQkoFbQ
 good stuff. If he wanted it to run with 2 seconds between each iteration he could just change setTimeout to setInterval, right? Nevermind you did a setInterval. got confused with another code snippet on here. 
You're welcome!
A plain vanilla app will almost **never** be faster than the abstraction. The simplest actions will bog your app down like unscheduled read/writes to the dom that thrash the browsers layout engine. That's why frameworks have async schedulers. State distribution will waste countless of cycles and re-render things that could have been re-used. That's why frameworks have change detection. Events will waste lots of performance, that's why frameworks re-pool events and use global handlers. And it only get worse as framework are already preparing for visual occlusion and per component render priority. There are countless of other things you'd have to take care of to come even close to any random framework and the moment you start to get even, you've written written one yourself. You probably saw benchmarks that gave you that impression, they test frameworks against *atomics*. Of course plain JS will be faster deleting a node or adding one. And while frameworks should be fast doing that, which is why these tests exist, they will always win out in a real world scenario for all the reasons above.
Absolutely! Check out my forked pen. I have added a little walkthrough at the bottom of the SCSS-area. https://codepen.io/mr-tamagotchi/pen/rzWpZO
Ah, nice. I thought you gonna use jquery's `step` method. Thanks for this.
Did you define `root`? Tests run in a separate context. You need to define `&lt;div id='root' /&gt;` in HTML setup.
Yet node happened, or Electron, or react-native. The flexibility and community support that js has cannot be matched by any other language. Whatever little advantage language xyz has over plain es7, at least for frontend development, it doesn't amount to anything because it's still rigid and lacks a large community. Having made frontend in countless of languages and systems, i think js, at least, is very suitable for frontend
This isn't a new revelation. Atom and Code have existed for years already. I think by now, people've figured that performance isn't the highest priority compared to the overall development experience. Using just one or two metrics in choosing an editor is shortsighted, and while that's your prerogative, I'd advise not telling others to do the same.
If we're talking about software products, React is a clear winner. But I wanna mention unit tests and code reviews as the MVP for me. Surely this counts as a trend, no? 
Is that a common occurrence, IT/NetSec guys blocking websockets that is, in corporate environments? What would the reason be?
I have quite a bit of code to handle pooling. I would not expect processing to be faster with this approach, and why would you? It's designed to avoid unintentional GC at the cost of processing overhead to manage the free/allocated/protected pools. My recommendation would be to use JS Sets and add/delete based off reference.
We're in Europe and IT companies, the bigger ones at least, are *very* conservative. I have no idea why they're doing it. When we had ws in place and opened up for test access many clients couldn't use it. It may be different in the US but why risk it. Socket.io btw will always use web-sockets when both ends support it.
All variables parsed in the global scope get attached to the global scope. Using window. is definitely not necessary. The issue as you pointed out was the missing parens.
Flowtype could expose the same information using an interface that an ESLint plugin can read. This would create a broader integration surface. The good news is that I still can read the output of `flowlint` and integrate it into `eslint-plugin-flowtype`. Here is an issue for that https://github.com/gajus/eslint-plugin-flowtype/issues/264
I thought we already are doing that. I have been on this train for the past year already. Nobody should use jQuery anymore. Atom just dropped it altogether in favor of vanilla JS. With new ES advancements there is pretty much no reason to use it. Frameworks like Angular are, IMO, more for bootstrapping a project as well as security. Why recreate all that from scratch for no reason? But for customizations and little things, sure, I'd say vanilla JS all the way.
Loop forever? So like... npm 2 speed with npm 5 feedback.
The demoscene was amazing! Saw a demo of a massive texture compression algorithm that blew me away! 3gb uncompressed, 64k compressed.
OG Pied Piper
If OP were using plain JS that would be correct, but running JS through Webpack results in all manner of closures wrapping your code, making any top-level functions and variables in your files _not_ global. See [this](https://www.webpackbin.com/bins/-Kqhrnr09qgd2RidOg2g) for an example.
Ah! Sorry, my bad. Hope you found it useful somehow anyways!
indeed, I miss the demoscene. I guess it still kinda quasi exists but it's not the same nowadays. Been years and years since I've been on IRC let alone #trax on EFnet or Scenenet, and evne longer since I've watched incredibly detailed ansi art flow down my telix console when trying to log into a distro BBS
Got it, thanks!
Clear, thanks!
Any idea how to find that algorithm? Might not be useful now, but I'm curious how it worked.
https://www.khanacademy.org/computing/computer-programming/programming
&gt;mess of dependencies oh you mean literally everything I've ever downloaded from npm?
Thank you
I have like 5-6 options to choose from "FROM" section.
Right- but you can't make any assumptions about what other users have. 
http://esq.h-cdn.co/assets/15/15/1428516335-1428506326-siliconvalleydickjokescreenshot.jpg
i'm struggling to see the benefit of having this on the client other than perhaps better DX. `import` would require the entire file to be loaded and parsed (no tree shaking), and would require an extra http request (not in http2, but still). and all the files are unminified/unmangled, so usually sub-optimal for production use. a compiled bundle still has every advantage for production use.
I type in `lodash` or `lodash@4.17.4`, press return and I get "Failed to fetch". Edit: Request goes to "https://wzrd.in/bundle/lodash@4.17.4" and Chrome says it's not secure because of invalid ssl certificate. Edit2: instead of only on return press you could fetch packages also on blur, first time I didn't pressed return (I don't read instructions, but who the hell does, right?) and wasn't sure why `lodash` or `_` wasn't defined. Edit3: Let me know when it's done, would like to play around a little more. Lack of npm modules is probably only thing I hate about JSPerf, so nice fucking job dude.
For small projects it's really nice not to use a bundler. I really miss the time when you can just write js and not have to think about npm or any compile step. I think this is a step in the right direction.
the problem is that ES6 encourages splitting up code, whereas before you consciously knew that if you had 100 `&lt;script&gt;` tags, or `require` calls, that your code would load much more slowly. with native module support, that concern is more obscured and you have language-level constructs that can result in unnecessary i/o. with http2, it's *less* of a concern, but you still have a not-100%-parallelizable chain of load calls as each module's deps are eagerly parsed and resolved.
It seems that the CDN was down for a moment, I switched to my own server, could you try now. Edit: thank you so much for the nice words! Edit 2: I'll handle blur too.
This isn't operator overloading. https://en.wikipedia.org/wiki/Operator_overloading *operator overloading [...] is a specific case of polymorphism, where different operators have different implementations depending on their arguments* You need type information at compile time for this kind of thing. Then you could make those operators do something different if functions are involved. The plugin replaces the &gt;&gt; and &lt;&lt; operators and you can disable it for a "scope" (block?) via some pragma.
Cool, now npm loading worked. Created a simple benchmark for lodash, I saved it successfully, but I got "Error, couldn't load one of your scripts.", I can't go back or do anything, error covers whole viewport. Opened Dev Tools and there is once again `https://wzrd.in/bundle/lodash`, ouch. At first I thought, maybe there was an error in my script and I tried to just open `https://perf.zone/create`, so I got a login view, I choose GitHub. So then I git new benchmark form as expected, so to get to what I already created I have to click to my name in upper right corner, right!? Aaaaaaand it shows login form again. If I login I get back to /create once more :( Edit: to keep it for next time I will write out it here, setup: const _ = require('lodash'); const input = ['a', 'b', 'c', 'd', 'a', 'd', 'e', 'c', 'e']; Lodash map: let count = 0; _.map(input, item =&gt; count += (item == 'a' || item == 'c') ? 1 : 0); Lodash each: let count = 0; _.each(input, item =&gt; count += (item == 'a' || item == 'c') ? 1 : 0); Edit 2: Also I can't choose "map" or "each" for snippet names, because they are too short for some reason. I would assume they are constrained to single benchmark, so there shouldn't be any collisions and thus no limits.
[Here's another set of React components.](http://blueprintjs.com/)
Count the number of dependencies in Vue and React. Tip: it's 0
And I used to love your tutorials, too...
Do you have github repository or any other way to report issues / leave feedback, you don't necessarily need to post source code for that!? Some kind of mechanism to report issues / tracking progress would be nice, I'm not saying reddit sucks, but for this purpose it does.
&gt; with http2, it's *less* of a concern, but you still have a not-100%-parallelizable chain of load calls as each module's deps are eagerly parsed and resolved. Not necessarily with any more network io than bundled code though. With ES6 modules being much more statically-analyzable and http2 supporting server hints/push, the code can be sent down all at once, so as the module is parsed on the client and the dependency discovered, there is no more network io to do.
If a is your input array, then a.map((full_name) =&gt; full_name['last_name']); 
What you could do is `map` over the list that you get after parsing the JSON string and then get the `prop` that you need. So, something like the following const prop = key =&gt; obj =&gt; obj[key]; // our helper function const list = [...] // your list const onlyLastNames = list.map(prop('last_name'));
I mean I can't thank you enough. https://github.com/alshakero/perf.zone
i don't understand this argument. the server has nothing to do with this. the *client* has to recursively analyze each module and load any dependencies serially. you can't statically analyze things that haven't been i/o'd
Yep, agree - I've already got a dozen small projects that use it since it has been available in Firefox Nightly. I love just being able to write JS, no build tools, no extra crap, just straight web standards. I love that I have projects lying around from 2004 that I can double-click index.html and they run exactly as they did. I can edit the code in notepad and make changes without worrying about what toolchain existed 13 years ago! 
lodash is a dependency friendo. 
&gt;And the var surnames would be {Sparham, O'Cannovane, Dobbie, Simoes, Pellant} You actually want an array of strings, right? Not an object. In which case, yeah, you want to use `map` as the other comments indicate.
but not now after I posted that graphic picture? /me ashamed
It's never gone out of style. You don't even need knowledge of "vanilla" javascript. If you understand fundamental principles of software engineering and computer science/information theory, you can not only glide from library to framework to tool with little effort and no stress, you can do the same with new languages, programming paradigms, network architecures, etc. You'll also see that "javascript fatigue" is really a result of the insecurity of not knowing everything in JS world and the stress of having to make a decision yourself about what next to learn and how to properly evaluate things. Sorry, I just get kind of worked up on this topic. Choice and options are a good thing. There's a lot more people writing code, more ubiquitos devices running code. A lot more and different perspectives are coming in and for a lot of the problems being faced there isn't a clear solution. I liken this period to the Cambrian explosion
¬Ø\\_(„ÉÑ)_/¬Ø
While it's fairly new you should add this link "Report an issue" to the page, most people won't do it, but some might.
Does this mean iOS will finally get progressive web apps?
This seems a bit like madness... why would you overwrite existing valid code when you could just use some other symbol? Shift-left and shift-right aren't some exotic abandoned part of JavaScript - if you're doing any math or game related code, they're standard. Why not use some other symbol so then you could use pipes AND regular bitwise operators together? It seems unnecessarily confusing to break regular JavaScript like this.
Feature suggestion for version vGoogol: For most of the projects I'm working on clients require IE11 support, so I use babel to transpile code, but of course writing perf tests and transpiling and then pasting that ugly code is tiresome. Testing performance in modern browser, which supports all the features I'm using doesn't necessarily mean same results in same browser with transpired code. It would be nice if there would be an option to run code through babel before running test. It would require to be able to [set different configuration \(preset, targets, etc.\)](https://babeljs.io/repl/) not just "use babel". So this is no easy feat by any means.
All the Ring UI pages seem to be temporary down. (Also, [Ringu](https://en.wikipedia.org/wiki/Ring_(film). LOL.)
Ah yes, and it even includes jerky-scrollTM! ;) (I'm on a Android tablet)
Doing all the DOM manipulations and state management in a large SPA in vanilla JS while keeping everything high performance would be very time consuming, and so very expensive in terms of developer pay. Any dev team tasked with this would no doubt end up building a lib / framework (either by natural evolution or deliberate design). These libs / frameworks would no doubt come to resemble some of the major open source libs / frameworks, only they wouldn't be as good. The problems that these frameworks solve generally still exist, so they aren't going anywhere.
The server can analyze your JS and/or client request patterns and preemptively send down the dependencies. With http1.1, only the client can request resources. With http2, the server can send them down without a request. This means the client's parse-discover-dependencies-request spiral you're describing doesn't have to apply.
Definitely the core enabler for PWA support, so‚Ä¶ fingers crossed!
You're looking at it through the lens of a large company doing large projects. I agree with you almost 100% in that regard. I'm just glad there is an alternative for smaller projects and experiments to live without a build step, one that doesn't involve script tags that are order dependent.
Really curious what you think was so good about that time? I still associate it with lots of manual labour, tight-jacket feeling, not being able to do the things i had in mind without jumping through hoops, gigantic payloads. I still know that i was stunned when i first tried webpack because it did away with all of it in one strike. No matter how small, the minute it takes to set up a self contained project was never a problem.
Angular is written entirely in TypeScript. And I don't mean business apps, I mean Angular itself and all the core libraries. It also shipped with RxJS as a first class citizen in some core libraries. There's nothing wrong with building upon useful abstractions. That's pretty much the most important concept in programming. I don't know why the JavaScript community is so wary of this. 
[They know](http://js1k.com/2016-elemental/). Look at the last prize.
it sounds like you are looking for an asynchronous state management solution, meaning you want your application to react whenever an action resolves into render-able data. there are different approaches, but flux (and its most popular implementation, [redux](https://github.com/reactjs/redux)) or [rxjs](https://github.com/ReactiveX/rxjs) might be good starting points. i'd recommend the latter if you are not developing within React's ecosystem.
and here I am struggling to code the ui for a simple accordion
"Introduced"? The only completed Web Components standard is HTML Templates. Custom Elements, Shadow DOM, and HTML Imports are still working drafts with spotty implementation across major browsers.
Was just looking around and found [this](http://demoseen.com/windowpane/magister.html). It's a 1kB png whose IHDR block contains enough valid HTML to create a canvas, and load itself in an image tag with an onload callback that draws the image to the canvas, reads it byte by byte (with `fromCharCode`), then evals the result.
"Last prize. Pssh! I'll show them! All I need is 12 more k..."
Should play great with http/2 multiplexing and pushing features.
I think I would do something like: var submitted = { home: false, comments: false, questionnaire: false, thanks: false }; function sendReportOnNextButtonClick(currentView) { if (submitted.hasOwnProperty(currentView) &amp;&amp; !submitted[currentView]) { console.log("submitted" + currentView); var submit = currentView === 'comments' ? issueReportForAppropriateView : sendReportForAppropriateView; submit(currentView); submitted[currentView] = true; } } ... Edit: /u/boompleetz noticed a bug; added a condition for using issueReportForAppropriateView over sendReportForAppropriateView.
Yup! It works exactly how you'd expect.
how is what you're describing any different than a server that does on-the-fly bundling? the client would simply do `&lt;script src="bundle.js"&gt;&lt;/script&gt;` and the server would run Rollup &amp; Uglify for each request. while Rollup &amp; Uglify are fast, they're not webserver-fast. you could write the ES6 module resolution as an binary module, but then you don't need any of this in the client anyhow.
Yea, basically a CDN parses the dep tree and pushes the deps with the initial request. Works great, its actually a single network call that spreads out to many virtual requests.
Do you think the author indents with tabs, or spaces?
Do you think the author indents with tabs, or spaces?
Bundles can only be cached in their entirety so there's a balance to strike between redelivering already-fetched assets and having more http requests across multiple bundles. http2 can theoretically do better since clients can decline server-hinted assets if they're already cached. Depending on your app and how assets are delivered, http2 be much more request and cache efficient than bundles.
interesting, so what's the benefit of having any of this in the client if all that's needed is server push? and a way of signalling the top-level imports, which can simply be passed through a query string, eg. `assets.js?imports=a,b,c,d`
What is also great if you don't use &lt; stage4 es features, with es modules you can completely exclude bundler from app building process with no issues to app network performance.
i'm looking at it through the lens of a small lib i have which has dozens of imports per file and many files. eg. [1]. would it really be optimal for me to distribute the lib with 50+ files, each with a ton of imports rather than a single package?...and this is just a small amount of code for a view layer base. if i were not to bundle the entirety of a moderate-size application, it would be quite sprawling. how deep should the import turtles go? does http2 allow us to treat TCP as 0-overhead i/o? [1] https://github.com/leeoniya/domvm/blob/3.x-dev/src/view/patchAttrs.js
You could indicate imports like that, but it's probably smarter to just use the `import` semantics as defined in ES6. I can envision canonical CDN paths for popular modules along with sha256 verification on the script tag. Then once you're ready for production, use webpack or something to fetch resources at build time and verify the checksum again. I don't think we'll ever fully get rid of a build step, it's a nice way to optimize. I think we'll use CDNs and runtime imports when developing locally. Want to try out a new library? Just import it and start messing around, no need for CLI tooling to fetch the source.
What's the benefit of ES modules? Good question. Most importantly, ES modules are not just an asset delivery mechanism: they are a way of encapsulating re-usable components. Also: 1. Server-push is immensely more complicated and it would suck to be the only way of loading ES modules. 2. Server pushed modules probably don't have their module factory executed until they're imported (not sure because I haven't read the spec). 3. You still have to import a module in order to use it. If you didn't have a module system, how would one module make use of another module? Would every module export everything globally? That would obviously suck and defeat the purpose of modules. 4. Standardizing modules that declare dependencies on each other enables better tooling, e.g. bundling, linting, tree shaking, etc. Having a million non-standard module systems makes life harder for tool makers, e.g. supporting CJS, AMD, whatever, supporting dynamic require expressions in the middle of a file, etc. 5. Lastly, ES modules are trying to be the best of the varying non-standard module systems, e.g. supporting both synchronous and asynchronous loading. CJS was only solving server-side module loading and AMD was only solving it for the browser while ES modules are trying to be usable everywhere.
&gt; What's the benefit of ES modules i wasn't asking what the benefit of ES6 Modules is. ES6 modules are awesome and i use them w/Rollup. i'm questioning their benefit *on the client*.
I bet they don't have a node_modules directory! 
Are you asking what benefits there are to having a module system in the browser? Why would there be less value in having modules in a browser app than a server app? Most programming languages have a module system and a way of having modules take dependencies/import other modules. There's no programming environment, browser or otherwise, that is better off having everything be declared global. Right? Or are you asking why there is benefit to allowing ES modules in a browser to request more modules from the server or something more specific? EDIT: Just reread your post. I think you're forgetting the stuff I said above: http2 + ES modules are trying to make the trade off between number of http requests and cache efficiency a false dichotomy by having a highly efficient single, multiplexed http stream with high cache efficiency and low redundancy in assets delivered. So you shouldn't be asking "why do I need ES modules in the browser" but rather "why do I still need rollup?" (And there are good answers to that, for now: tree shaking, simplicity of deployment, more mature tooling, etc).
This is more of a personal design choice, but try to solve problems functionally and play to the strengths of the language. Use .forEach, .filter, .map, and functions returning functions when appropriate 
X-Post referenced from [/r/node](http://np.reddit.com/r/node) by /u/keithwhor [StdLib Updates: Node 8.2.1 support, Logging, and Investment from Slack](http://np.reddit.com/r/node/comments/6rk80r/stdlib_updates_node_821_support_logging_and/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
This had already been posted once or twice, probably more than that. 
Hey that's great again a little older an idea but new to front end. I didn't think much about practices like that. Yep pair programming is something I am seeing more and more of too.
Don't compare yourself to others. There is someone out there trying to figure out what an accordion is. ;)
But see, there is no good or bad. One framework is good in one thing and the other framework gets something else right. Relay focuses a lot on performance but has a high learning curve. Often people who ask these general questions don't seem to know what they want, otherwise they would describe what they want in the question. So maybe I misread your question and your actual question is more like: What is a solid GraphQL client solution to begin with? I would argue for Apollo then. It is easier to use. At some point you might find that you need some of Relays benefits and are willing to take the tradeoffs. 
Chicks love a good accordion. Gets some smooth animations up in there and you'll have so much nice-nice coming your way you'll have to beat them off with a stick. 
It's been about 8 years since then, but I think it was a German company, and the demo was of a city that crumbled and bricks snaked through the cityscape.
Why did they go with something different than what Node.js already uses?
I do not understand this joke. You can explain for me? Thanks you
Spawn("doom.exe");
Lil
I've now realized I have to remove my fadeAudio() line. But still, the fade out doesn't work.
Actually, quite a few of the js13k starter kits use npm modules for building, serving, live reload, linting, etc and yes, the size of those modules will easily add up to 100+Mb üòÇ i think the one I'm using this year is 170Mb or so and all that to produce a 13kb zip. Mad.
Cherry picking in git is a much different concept, it was just cause confusion.
Looks amazing! What tools did you use? What tutorials did you follow at the beginning?
It would be nice for development to not run a bundler. Plus seperate caching which is potentially useful. Mainly browser support will ensure this becomes a standard. There are active projects that still use globals and IIFEs, maybe this could convince them to swith, and those compile time benifits will trickle down.
How long was(is?) development?
They aren't so visually pleasing in my opinion.
here's some coding exercises I do in js interviews: Given an array of users: const users = [ {username:'bob', age: 25}, {username:'sue', age: 18}, ...] 1. Create a function that will take an age return an array of the users that are older than a given age. 2. Modify the function to return an array of only the usernames that are older than the given age. 3. Modify the function to also take a predicate and returns only the usernames of users that match that predicate. 4. Modify the function to return the sum of all users ages that match the predicate. 5. Curry method: &gt;Implement pluralize such that when called with 1 it will return the singular form and when called with 2 it will call the plural form: pluralize('loaf', 'loaves')(3) // returns 'loaves' pluralize('loaf', 'loaves')(1) // returns 'loaf' pluralize('loaf', 'loaves')(0) // returns 'loaves' of course these lean towards functional programming, which are kind of at odds with standard classes, loops, and flow control.
I am striving to write everything I can in es6 without jquery or frameworks. Mainly because I went down a dangerous path of trying to learn JavaScript while using frameworks at work. Frameworks are great, but you need to know the basics. I haven't picked up React yet, because I can't skip to driving without learning how to walk.
[removed]
Good game. Got a couple of hours of forgiving gameplay in with the cpu on my first try. Very impressive and would love to see some writing about your development process and thoughts on your tools.
Games that came on 2-4 disks each retail.... 5 of them on a single disk. So awesome.
/r/titlecancer
Yes. And it will be soon. All browsers are stable and using complete 100% of all of the latest javascript from last 2 years. And once all old codebases start moving to modern code. Vanilla may still be not enough, but sitting on top of es2015+ as base would be easier to implement very thin wrappers that could work pretty well.
What have you tried so far?
What do you mean something different? The modules are part of ES2015.
React also accumulates, but does reclaim periodically: http://imgur.com/a/C9ivD there's a bit of Detached DOM, and the DOM doesnt have anything extra in it either. https://codepen.io/anon/pen/Ljbvay/ :/
Hopefully before they remove app cache lol
How come noone ever mentions &lt;template&gt;
This is really exciting to see finally coming! For now I'll keep using jspm/babel, but this means we may finally be just a year or two from not transpiling javascript!
I'd write @bmeurer on twitter. He'll usually look into these things or forward it to his colleagues at google chrome
~~Nodejs is the one that went with something different.~~ Edit: Apparently I'm wrong 
It's about time.
Could you elaborate on socket.io being a disaster? What hurdles did you come to related to it with this project?
I think Yarn was completely justified. Before Yarn, npm responded to everybody telling them how to improve the core algorithm with "it's complicated, you don't know what you're talking about". Then Facebook published Yarn, then npm shut up and did (some) things the Yarn way. Sometimes you need more than a PR - you need to introduce competition. Look at Chrome for IMO the greatest example of this. Chrome's market share never mattered to Google, what they wanted was for *every* browser to become better at browsing their websites - and they succeeded spectacularly.
I'm not exactly sure about the history, but Node.js was using CommonJS (sorta) in at least 2013, but maybe much earlier than that... 2009 I think? AMD was born directly from CommonJS, and ES6 modules came from AMD.
Node.js was using modules before ES6/2015
My guess is that it is because implementing that was simpler. Babel can parse &gt;&gt; but it cannot parse |&gt;. You cannot extend the parser in a plugin and Babel won't extend the parser with support for things that are too far from ending up in the official language.
Yes it's not 0, but it's never at the core parts of either framework. they're both fairly clean usages of lodash in my opinion. None at [react](https://github.com/facebook/react/search?utf8=%E2%9C%93&amp;q=lodash&amp;type=) Only used with local-cli at [react-native](https://github.com/facebook/react-native/search?p=3&amp;q=lodash&amp;type=&amp;utf8=%E2%9C%93) so it's not a runtime dep in the client bundle Used very little at server-side rendering at [vue](https://github.com/vuejs/vue/search?p=1&amp;q=lodash&amp;type=&amp;utf8=%E2%9C%93)
That will do huge things to app and progressive web app market. I am so excited.
Your link just opens npmtrends.com , not sure if I was supposed to see a comparison.
&gt; issueReportForAppropriateView The only problem with this is that one case calls this function instead of `sendReportForAppropriateView` 
Absolutely. It'll be interesting to see how Apple is planning on profiting from PWAs, as any app developed as a PWA rather than an App Store app (native or cross-platform) is currently a definite loss in terms of revenue for Apple.
Music instrument, duh.
Seriously amazing! If you want to replace socket.io with something much more performant and better at handling tons of connections, checkout [mosca](https://github.com/mcollina/mosca) and [mqtt](https://github.com/mqttjs/MQTT.js).
Yeah, I think that's why they have been dragging their feet so much. It was a major issue with I was developing pwa's.
Looks like the site died. It was supposed to track a couple of frameworks. Polymer, since it got on npm finally, still went flatlining, maybe 10-20 production environments fetching it daily, probably half of it is Googles own Polymer team. That is quite the difference from the 250.000 fetch-requests that the competition gets per day. Now that doesn't account for Polymer on bower, but still paints a pretty sad picture, if developers were so excited surely more than a small handful would experiment with it daily.
[removed]
Farbrausch on pouet, check the 64k toplist. Can't find a direct link at the moment. Busy 
That's why you choose an appropriate type of wheels for your application.
I wrote &gt; The Flow linter uses the Flow type information. You can readily *see* that when you look at the "sketchy-null" lint check. Same with the "import from untyped files" check, which warns because the resulting type would be `any`. All (i.e. both) rules available at this time use information about _the actual (Flow) types_! The Flow linter knows the types - eslint does not!
The new demo scene ... Demo JScene
Someone had to reinvent it before you could choose it. Haha accidentally deleted above comment. It said~ &gt; Because cart wheels wouldn't support a car, and wooden circles wouldn't work on a bike
Had a quick read of your code and I have to say good work. (I am a Software Developer professionally) Your code is very clean, nicely laid out and very logical. It is a pleasure to read with each of the functions being understandable and self descriptive. This is the biggest point from me. On the side of the canvas wrapping that it primarily focuses on, I thought it was very lean and quite useful. Reminds me a lot of working on pet projects with Pygame, and I found myself writing similar style wrappers to make future projects much easier to maintain much less create. Keep it up! You write code better than half of the company I work for.
The main reason, to my knowledge, is that commonjs modules are not statically analyzable.
The demoscene is still alive. Go to pouet.net and have a look yourself. Great releases every year, on multiple platforms.
Debris by Farbrausch. http://www.pouet.net/prod.php?which=30244
Good work! Very pragmatic approach, easy to read. A suggestion: You should really get used to newer features (primarily the large swat of features that came in ES2015) of the Javascript language. Since you are very young, there is no point in learning old syntax. Pretty much all of ES2015 is supported in the major browsers today. For example, in ES2015 there is a *class* construct that makes it much easier and readable to create the kind of class that your MoopleGame is. Feel free to ask me anything! I've been doing this for a while.
oh, good catch. Didn't notice! That is a bit of a wrinkle, isn't it. 
I have a fairly minor criticism, but personally, I find functions that take more than 3-4 parameters to be difficult to read. Most libraries generally stick to the limit of four parameters. If necessary, your last parameter can always be an object which includes a number of options. Take a look at the function signatures here for example. https://nodejs.org/api/fs.html Also, large blocks of if else are fairly inefficient. If you find yourself writing one, there is usually a better way. In this case, we can derive the property name from the key that was touched. Additionally, we can take advantage of the fact that letters have numeric codes associated with them to see if the letter matches a range from a-z or A-Z. if(e.key == "a" || e.key == "A"){moopleGame.prototype.aIsDown = true;} else if(e.key == "b" || e.key == "C"){moopleGame.prototype.bIsDown = true;} else if(e.key == "c" || e.key == "C"){moopleGame.prototype.cIsDown = true;} else if(e.key == "d" || e.key == "D"){moopleGame.prototype.dIsDown = true;} else if(e.key == "e" || e.key == "E"){moopleGame.prototype.eIsDown = true;} Can be replace with below. You don't usually want to be setting properties on the prototype dynamically. The prototype gets used for every single object created. It's also fairly inefficient to edit prototypes dynamically. If there were two games going on a single page, they would both be setting the value on the prototype. function isLetter(key) { return (key &gt;= 'a' &amp;&amp; key &lt;= 'z') || (key &gt;= 'A' &amp;&amp; key &lt;= 'Z'); } moopleGame.prototype.handleKeyboard = function() { var _this = this; $(document).on('keydown', function(e){ if (isLetter(e.key)) { var property = e.key.toLowerCase() + 'IsDown'; _this[property] = true; } }) .on('keyup', function(e){ if (isLetter(e.key)) { var property = e.key.toLowerCase() + 'IsDown'; _this[property] = false; } }); } By all means though, good work. This is far more than I could have done at 15. Just trying to provide some advice to help simplify your code. Edit: fix some issues and typos
that was so much better than I was expecting. I'm also curious about some BTS details. 
 // "canv" - canvas id it should be more flexible if you would take Canvas object itself and not canvas id (not every Canvas object must have its `id` nor even added to the document). document.body.style.overflow = "hidden"; document.body.style.padding = 0; document.body.style.margin = 0; this is seriously wrong. You shouldn't mess with the global state / global styles. It would be better to left styling to the user. You could also make separate function like `setDocumentStyles()` that would be helper for automatically set styles recommended by your library. if(width != "fullScreen" &amp;&amp; height != "fullScreen") if(width == "fullScreen" &amp;&amp; height != "fullScreen") if(width != "fullScreen" &amp;&amp; height == "fullScreen") if(width == "fullScreen" &amp;&amp; height == "fullScreen") You're technicaly right that if your check two true-false conditions, then you have 2 * 2 = 4 cases. But it doesn't mean that you have to create 4 ifs blocks, if these conditions are unrelated. Now you have just 4 ifs and in each block after `if`half of the code is copy-pasted. It would be better to check these conditions separately (and you would have only 2 `if`s). Notice that copy-paste technique you used is not scalable. If you had third condition, you would create 8 `if` blocks (2 * 2 * 2), and if you had four condition, you would create 16 (2 * 2 * 2 * 2) `if` blocks. That's not how it should be done ;) if(typeof sprite === "boolean") { warn(" Your sprite can't be a boolean"); WHY do you check this condition? :/ &gt; // I'm so lazy so I want to write "warn" instead of "console.warn" :( This is actually good practice. Laziness and conciseness is good. for(var i = 0; i &lt; this.addedSprites.length; i++) { if(sprite.id == this.addedSprites[i].id) this could be simplified either by using `this.addedSprites.find` or `this.addedSprites.indexOf` method ;) 
Define "better"... some of it comes down to preference. A lot of people, especially in professional environments use task runners like grunt or gulp to watch and compile their pre-processed code. It might feel a little uncomfortable to use the command line at first, but after a while it becomes second nature like tying your shoes in the morning.
1) It's missing the documentation or even the basic API specs 2) The fact that your game engine is not using WebGL tells me right away you are doing it wrong. 3) It's not clear what you're trying to achieve. If it's an exercise simply for yourself, then good job, but then why post it here? If you're actually trying to create a game engine/framework, it's horrible - there are many tiny game engines that are decent, have good documentation, and have communities behind them.
Nobody had to reinvent anything as it was already invented.
Much thanks @based2!! Have you used any of these btw? Made any app.. would be great if I can check it out.
[removed]
About 16 months. 
just gonna point out with the second issue you have - there are a myriad of js game engines that don't use webGL at all. Not every browser supports webGL properly and it still causes video card issues if your pc isn't good enough. I wouldn't recommend webGL as a default. Even ThreeJS or PhysicsJS which of course have webGL as a default have an automatic fallback to canvas. 
&gt;Since you are very young, there is no point in learning old syntax. I disagree, I think there are a number of good reasons. One of them is, the more background you have, the more informed decisions you can make about how to do something. Another is, when helping others learn new things, it is often very useful to relate it back to previous versions or even other languages. 
That's the demo I was thinking of! Thanks!
I don't understand your point. Or if I do it makes no sense in relation to the above. The *car* wheel is not a reinvention of the wheel? The *car* wheel was "already invented"? Yeah *after* it was invented!
https://github.com/alanhett/encodex I made an encoder / decoder that allows you to specify a custom set of characters. For example, if you wanted a base-26 encoder that only used upper-case letters, or only symbols, or whatever.
What is the advantage of using your pipe operator when you can do times20(dec5(inc(10))) // 120 I really appreciate functional programming but IMHO sometimes it introduces too much abstraction when all you want to do is code.
I was hoping someone would ask. Reasons to not use socket.io: * It's extremely poorly documented. The documentation for the client and server API consist of [one long minimalistic page](https://socket.io/docs/server-api/). There are basic things not documented, like the heartbeat pings socket.io automatically send out to your clients. For those heartbeats, there are no server-side handlers, so if you wanted to perform a specific action when a client reaches a high latency, you basically have to write your own ping functionality on top of the one that exists. * Websockets API is just as simple, if not more simple than socket.io. * Socket.io is a huge performance killer. By default, it does a lot of behind the scenes stuff like compression and bit encoding, which you might need (trade of CPU power for bandwidth) but can't really make educated decisions because of the poor documentation. * Constant random disconnects on certain clients for unexplained reasons (which never happens on vanilla ws) all of which are undocumented. I've had to take the time to document them myself as I find them. They are like catching pokemon: "transport close," "transport error," "client namespace disconnect," etc. Socket will throw these vague error messages (if you know where to find them) but offers no documentation/explanation as to what they mean. * If you follow the project on git hub, there are issues going back &gt; 7 years that are major bugs which can be fixed with 1 line of code, yet the still haven't been implemented. * If you look at the source code changes, most of the changes have been unsubstantive since 1.5: https://github.com/socketio/socket.io/releases * The original purpose of socket.io was to provide a fallback mechanism for browsers that hadn't yet adopted websockets. Now that websockets is standardized, there really is no purpose for it. Good read on the topic, "Why you don't need socket.io": https://medium.com/@ivanderbyl/why-you-don-t-need-socket-io-6848f1c871cd You can also find a bunch of dev horror stories with socket.io if you do some google searches. tl;dr it's just bad, unnecessary middleware which cost me hundreds of hours of extra coding and put a big damper on the network performance of my game. All of the cool functionality it has over vanilla JS (like rooms and namespaces), could have written myself in a few hours (anyone with a basic understanding of JS scoping can). I chose socket.io because I was extremely uninformed when I started making my game. Unfortunately now, socket.io is tangled very deep with my netcode, so If I want to switch to vanilla websockets, It will be a huge operation. I'm still considering it though. 
Your `isLetter` function is incorrect. You'd want a `&amp;&amp;` between each of a-z ranges. Even better, if you used `String#toLowerCase`, then you'd only need a single `&amp;&amp;`.
Forget whatever I've said and read up: https://en.wikipedia.org/wiki/Reinventing_the_wheel
thanks, I'll look into those!
But he doesn't have an automatic fallback. Can you name a single widely used web game engine that doesn't use WebGL and only renders to the 2D canvas? I don't think I can.
Also, the second 'on' should be on keyup, i think.
I'm aware of the concept, I just think it gets over-applied.
In some cases, I think it can make the processes the function executes more clear/readable. For example a function that takes a `cameCaseString` or `dash-case-string` and returns a `snake_case_string` implemented using only Ramda functions and the pipe operator: const toSnakeCase = pipe( split(/(?=[A-Z])/), chain(split('-')), map(toLower), join('_'), ); The same function implemented without pipe: const toSnakeCase = str =&gt; join('_', map(toLower, chain(split('-'), split(/(?=[A-Z])/, str)))); I think the pipe version is more readable, personally. However, like most things in programming, it can be awesome when used correctly, and horrible when abused. And the pipe operator can definitely be abused. I also would like to point_(free)_ out, one of my favorite things about the pipe operator, is if you have really good function names, you can have almost human readable code: const splitCaps = split(/(?=[A-Z])/); const splitHyphens = split('-'); const joinWithUnderscore = join('_'); const toSnakeCase = pipe(splitCaps, chain(splitHyphens), map(toLower), joinWithUnderscore); Obviously a little much for this trivial of an example, but I think it a nice example of what I like about `pipe`.
Always love spotting autism in the wild like this. 
He's 15. It's pretty clear from the code that he hasn't worked on anything open source with documentation and unit tests. Instead of giving criticism and saying that he's not doing anything new, why not suggest some libraries for him to look at or even contribute to?
I am going to agree with your first point, some sort of api documentation should be provided. As for the other two points: you're an ass. WebGL is not the only way, a canvas is acceptable for something like this. OP is 15 and just getting experience, not writing a library for the world to use. Get over yourself.
*‚ÄúWhen the debate is lost, slander becomes the tool of the loser.‚Äù* 
It's easier to see in what order they will evaluate with a pipeline. It's also easier to re-order them, add a step or remove a step. And pipelines scale better. If you had an operation with 10 steps, the first strategy becomes unusable. Unless you're a Lisp programmer and that level of nested parentheses doesn't bother you.
Well that was interesting. The first two are easy to make pass, but it's the typeof undefined check which is the real trick here. But the solution is way simpler than expected once you figure it out :P
"He wrapped himself in quotations- as an autist would enfold himself in a misunderstanding of the tone of the thread." - some guy 
Thanks for the advice. That's definetely is going to improve it!
You must be familiar with this ;) I wouldn't expect many people to just be able to "figure out" the solution.
[removed]
Impressive work, friend! I am no professional, but I do commend your skill! Cleanly written code is always a treat to read! Have you any plans for future features?
How about we don't throw around homophobic slurs at people for downvoting a condescending comment. 
Fun with stateful getters...
If you have a solution using getters I'd love to see it!
Your future is bright, kid. Good job.
He's not using jQuery anywhere except for here, and I would recommend he leave jQuery out early and keep it out if he wants his game library to maintain good performance as it grows. It's especially important for libraries to use no or as few other libraries as possible. His library's users can use jQuery if they like, but by leaving it out himself, he doesn't force all his users to load the jQuery plugin, *and* his code will be faster. function isLetter(key) { return key &gt;= 'a' &amp;&amp; key &lt;= 'z' || key &gt;= 'A' &amp;&amp; key &lt;= 'Z'; } moopleGame.prototype.handleKeyboard = function (e) { var _this = this; document.addEventListener('keydown', function (e) { if (isLetter(e.key)) _this.prototype[e.key.toLowerCase() + 'IsDown'] = true; }); document.addEventListener('keyup', function (e) { if (isLetter(e.key)) _this.prototype[e.key.toLowerCase() + 'IsDown'] = false; }); }
On mobile, so I can't try it, but does the 'void' function return true? Edit: Nvm void 0 is undefined, not truthy 
Nope, but I like where your head's at!
[Spoiler](/s "document.all")
This interests me a lot. I think there must be some time of standard json format that can be applied to an array/object and make a transformation, but I dont have any idea. I hope someone has a solution Edit: I came up to a possible idea: I thought that if we could execute a mongodb aggregate on an array (and not against mongo), you will only need to store the aggregate config array and run the aggregate to get the transformated result. I found a library called [mingo](https://www.npmjs.com/package/mingo) that seems to do that exact thing (run mongodb-like queries against arrays/objects), maybe this is a possible solution
&gt; Yet node happened, or Electron, or react-native. Yeah, and I still don't get why. &gt; The flexibility and community support that js has cannot be matched by any other language. AHHAHAHAHAHA. Oh God, this is the best laughter I've had in years. Have you heard about Perl? Or Python? Heck, I imagine even C++ has bigger ecosystem than JS. At least we here have proper databases, you dolts still cannot [implement a conforming PostgreSQL driver!](https://github.com/brianc/node-postgres/issues/613) P. S. Also, you forgot to include JSS. I guess JavaScript developers are so mortified of learning other languages, they try their darndest to bring everything to them.
You got it! I'd appreciate you hiding your answer so others can struggle for a little longer :)
I'll detail my thinking here in case it's helpful for someone then :) - Ok, I can make the two first checks pass easily with just a plain function and some properties - But how can I possibly make `typeof` return `'undefined'` for a function? - Maybe this is one of those weird corner cases with typeof... - Let's look up `typeof` on mdn... The solution was perhaps on that page :)
Couldn't do it. You got me.
I wrote in all these languages, i was fluid in perl and C++ is with me for most of my career. If C++ wanted to create a *frontend application* and its competition is js/npm, it would loose in every category imaginable: time, team-size, vividness, features, etc. The same of course applies to the backend. I write things in js in days that i know i would take weeks or even months in C++. I still use it of course, when it fits the job. Currently we're moving a large application from an old base to node/js: https://twitter.com/0xca0a/status/884851183051001856 The cad system existed in two prior variants, the last one in C#, before that C++. Critical stuff is still written in C++ (and managed/delivered via node). The node portion of it and the frontend are saving us heaps of code, a rough estimation is 70% less in the end. The manner and speed in which js can add features was shocking to us.
&gt; If C++ wanted to create a frontend application and its competition is js/npm, it would loose in every category imaginable Mm... Sorry, there are whole desktop environments written in C++ with JS sprinkled where needed. When you have a desktop environment written in JS, write me back. &gt; The same of course applies to the backend. &lt;...&gt; &gt; Critical stuff is still written in C++ Pick one. Node backend is the most under-developed and awful I've experienced. Especially if you're not writing a "web scale" app in MongoDB.
There are, and they will die out. C++ for the frontend is pointless. We did pick. C++ for critical low-level, will flow quite possible into web-asm one day. Node for scaling, managing and remote. I am doing this for at least 15-20 years now, i have seen javascript make an impact that neither C++, perl nor python would be able to do or else we'd have used them instead. 
&gt; There are, and they will die out. Suuuuuuuuuuuuuure. Just like Ruby and Python were to "die out" when Node.JS came out.
I see nothing here that could stand in the way between you and being a programmer. There are a few developers working with me that write hieroglific code compared to yours and they make thousands of dollars per month :)
Jesus, go back to the cave, you are not good at mentoring right?
Yep to both of these. Downsides of not actually running your code and writing in the reddit editor.
I always like to include a chain function which can be used like this: const result = chain(initialValue)( square, add(5), it =&gt; it * 5, ) Often times the result of a compose or flow is only used once. In these cases i find it very unreadable, when the value that is piped through all of this comes at the end. With this chain implementation you get the benefits of a chainable interface without needing to import a complete module (like lodash's _.chain)
Oh wow, this is unexpected. Can someone explain this? 
The `document.all` non-standard host object. * It is defined as typeof undefined: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#Exceptions * It is an array-like object of elements on the page. * It can be accessed as a function as well. I attempted to find a way to solve this with a proxy object that carefully modified itself, but since `i` is passed in as a reference, one couldn't change the referred-to reference in the function to account for the `typeof` operator. There doesn't appear to be a `typeof` operator trap with JS Proxies, unfortunately (or fortunately?).
It's an array of stuff. If you invoke function, it returns n-th array element. and also it has type of undefined, for some reason.
A functional GOTO could also do this by breaking out of the inner function, but JS only has loop labels, no GOTOs.
&gt; Can you please give me any recommendations or your opinion about this: what do you think? This isn't asking for advice?
I can see that if you want to keep a one-liner it is definitely more readable. Thanks for the detailed reply.
To make it harder I should've done this for the last check: const isUndefined = i === void 0
https://github.com/slanatech/swagger-stats I made swagger-stats module that provides embedded API telemetry for node express apps. It traces API calls, collects and monitors API and System stats. It detects API operations on the fly based on express routes, and it accepts swagger/OpenAPI spec as API definition. Comes with built-in UI, so you can enable swagger-stats middleware in your app and start monitoring right away. 
This "some reason" is the most interesting part! 
[http://amoeba.blue/docs/acp080417.html](http://amoeba.blue/docs/acp080417.html) Finished all working components of USCG Contingency Plan. All dynamic features are js. Mapping features use js google maps API. 
[https://www.w3schools.com/js/js_timing.asp](https://www.w3schools.com/js/js_timing.asp) I think w3schools is one of the best sources for entry level tutorials. 
I recommend a linter (especially rules like `eqeqeq` to enforce triple equals when you really meant typed comparisons) and familiarizing yourself with ES6. This is very clean though for what it is.
How-To: https://henschel-robotics.ch/applications/remote-control-hdrive-mobile-phone/
Wait, why is this getting downvoted? Am I wrong or am I missing something?
but would that have worked? (or is there something else that it works for?)
https://github.com/funkia/list I'm working on a pure immutable list that aims to have really good performance and a functional Ramda-like API.
But what about .sample() and .shuffle() ( Õ°¬∞ Õú ñ Õ°¬∞)
Oh, you're right. That wouldn't have worked.
Did not know that. Actually I did not event know that current browsers STILL implemented document.all ... So, document.all is not relevant anymore since what? at least 10 years? Why are browser vendors still keeping this? Especially since it is not even standard and there IS a standard alternative that is used by everyone today.
Still simpler without pipe etc: function toSnakeCase(s) { return s .split(/(?=[A-Z])|-/) .map(s =&gt; s.toLowerCase()) .join('_'); }
Probably using the [DefinePlugin](https://github.com/webpack/docs/wiki/list-of-plugins#defineplugin). new webpack.DefinePlugin({ PRODUCTION: JSON.stringify(true), }) ... if (PRODUCTION) { require('analytics.js') }
Instead of using setInterval for updating, you should definitely use [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame) 
Well, sure on this trivial example vanilla js is better suited. My point was to show that piping can be much easier to read/reason about than nested function calls. 
~ is a binary operator so the number will be parsed to an integer, so but how is it performance wise?
Like `| 0`, `~~` truncates. It's not the same as floor. It's only like floor for positive numbers: &gt; Math.floor(1.2) 1 &gt; Math.floor(-1.2) -2 ~~1.2 1 ~~-1.2 -1 // not -2 Also, it only works for numbers which are small enough: &gt; Math.trunc(2**30) 1073741824 &gt; Math.trunc(2**31) 2147483648 &gt; ~~(2**30) 1073741824 &gt; ~~(2**31) -2147483648 // negative! When you use bitwise operators, the number gets converted to a signed 32-bit integer.
Chaining looks a lot better and requires less typing.
I would agree, but since the OP asked about the advantage of piping over their example of nested function calls, I figured I‚Äôd give a pure ramda/pipe sample. Not how I‚Äôd actually recommend implementing the function. Also, in the above chaining sample, they were smart enough to split on both dashes and caps in a single regex, so it‚Äôs clearly the better solution. It also wins because it requires no dependencies. I‚Äôm just a fan of the Ramda library trying to pass out the koolaid. 
Because.. appendToList(addHeader(createListItems(debugLog(formatText('product', generateText(add2(floor(divideBy3(square(getInputValue())))))))))) is slightly ridiculous. And difficult to modify. Especially when you start adding additional arguments. That said... Ramda and its `pipe` function are not functional programming, they're tools that are available to you if you feel they're appropriate to what you're doing. 
This is true for a limited number of cases [0,2^^32), and perf isn‚Äôt great either: All but wise operators are defined in terms of 32 bit values, so the first thing that happens is your value is converted to an int via fmod() which is expensive (its possible that there are bounds check to see if we can avoid this but I can‚Äôt recall for sure it‚Äôs been a while since I wrote code there) The semantics of integer ~~ based floor is a round to 0 rather than round to negative infinity which is what you actually want. That said you can use all bitwise operators in this way: |0 &gt;&gt;0 &lt;&lt;0 &gt;&gt;&gt;0 // only apply to positive integers &amp;-1 Because all you‚Äôre doing is using ToInt32 part of the spec 
Your api is very clear and that is definitively the most important thing. I also liked that you are using prototypes instead of the new ES6 classes, I guess it's better to know the fundamentals. There are just minor things to work...for readability you don't want many if blocks together, also you did repeat yourself a lot on these (the ones at the very beggining), you should only set the instace width and height there, the other statements didn't need to be inside the if. You also probably do not need to use 4 ifs at all. Also: function log(msg) { console.log(msg); } function warn(msg) { console.warn(msg); } You could simply do this with one liners: var log = console.log; var warn = console.warn; I think at some point you had to bind console to it but not anymore.
You can think of it as `floor` rounds towards `-Infinity`, while `trunc` rounds towards 0. (For their defined ranges.)
That's not giant. When I worked a corporation we printed out one problematic switch statement. It ran 3 floors from top to bottom.
you could do that, but libraries make it arguably easier. Right now you're pushing a new dom node independently of adding a new element to the `todo` array. Really you should split these two out.... probably update the todo array (the model) and the update routine (view) should work independently of the `addTodo` method; it's job should be to ensure the `todolist` dom node reflects what is in the `todo` array. This way you could add methods for removing todos, modifying todos, etc. - and they could all call the same routine for updating the dom with what is in the `todo` array. With your example, it may not seem necessary... but let's say you add more to the todo model, like completed or something. That would necessitate a change to the markup to include the a strikethrough or something -- doing this in one spot makes a lot more sense than having an `add` and `update` method that both update the dom in the same way. Of course, this could get kind of complicated to do efficiently... you could just blow away everything and replace it with the todo array every time... but if you have 500,000 items and one is modified, you don't want to recreate everything.... so you'd need some way to find the related dom node and update it's value. Like I say, it gets kind of complicated... and frameworks can help with this. As an exercise it's good to try to build these things without frameworks but when it comes down to it if your job is to build a web app and a framework lets you do that considerably faster... framework wins.
The interface is very clean!
I have news for you kid, You are already a programmer and have done more open source work than most devs I've worked with. I'd say go out and get a job today, but I believe in the idea of a well-rounded education amongst a group of peers
Looking at your post history I can say that you've come far from 6 months ago. Keep up the good work and don't forget to keep honing your JS skills - you should definitely give You Don't know JS a shot and also get up to speed on ES6 once you're comfortable with ES5 concepts. Also for single player games have a look at Phaser.js - cool library - you can even get some inspiration from it maybe for your own. 
you're not writing C.
Are these exercises you've personally done, or are they ones you give to applicants? If the second, I may need to apply for some jobs.
Every user gonna have the same 'items' in FROM SECTION
Wait.. you said three *floors*? O.o
Yes. 3 stories. printed out it was over 30 feet long.
I'm not seeing very many architectural suggestions, so here's one: make it event-based. For example: https://github.com/danmoop/moople.js---html5-library/blob/master/Examples/Game%20example%20%231/app.js For your button presses, you could listen for button events: game.keyboards.forEach(kbd =&gt; kbd.on('w', functionWhenWKeyIsPressed)) // Next would be, how can you use events to do stuff like 'w+ctrl' ? Personally I don't know! :) And an event for your updates: game.main.on('logic-update', functionThatComputesStuff) game.main.on('draw-update', functionThatDrawsStuff) And so on. Game engines typically just hardcode these (from Game Boy to regular Windows games): main loop: input_update(state) logic_update(state) draw_update(state) etc... Other than that you did very well :) +1 Event based and composition are basically the be-all end-all for anything. Events decouple nearly everything. Composition makes nearly all code reusable. Very powerful combination of concepts. Also try to always process things as lists, rather than a single item (for example, the game.keyboards I used earlier. You assume only 1 keyboard will every be used, when computers can use more than 1, or even zero!).
It‚Äôs not part of JavaScript - document.all is specified in the html dom spec
Please don't ever actually use this in code. Write *clear* code, not *clever* code.
&gt; So, document.all is not relevant anymore since what? at least 10 years? Why are browser vendors still keeping this? Backwards compatibility is a big deal, documents published on the web that used to work shouldn't stop working just because they're old.
It isn't.
&gt;Does anyone else Probably
it's a valuable tool when you notice the right kind of problem. for example, being able to build a function than produces other functions, like a function factory, seems like a weird idea until you run into a problem that would be complicated to solve without it. in addition, javascript really revolves around functions -- they are first class citizens in javascript world -- so to get the most out of the language you need to think in functions.
I don't usually think "oh I'm going to write this as a HOF" Rather, it comes more as a result of what goal I want to achieve. For example, I recently wanted to create a function which would allow me to look up stuff in a tree like structure. Right, so how would I go about this? A really basic implementation could just have a hardcoded search: Allow only to look up based on item ID. But then, what if I also need to search by some other parameter? Perhaps the amount of child nodes? I certainly could add another function that allows me to search the tree based on child node count... But why not allow the caller of the search function define the criteria they want to use? And what's the easiest way to allow them to do that? Let them pass in a function that can be used to filter out the items they care about. Hope that made sense :)
You're quick, I'll give you that.
Good comment, and I just wanted to add that it's very common for programmers to not see the point of whatever library when they're using it for small/trivial tasks (like a little TODO app).
Yes it did, since the book's example was actually using data of a list of people from the author's family. HOFs were then used to deal with this data in all sorts of ways. I kept reading until you answered, and the book stresses composability of functions as important, which is exactly what you seem to be talking about.
This is not uncommon, but generally the guards are simpler as to avoid confusion. obj &amp;&amp; obj.prop; Object value or simple condition guarding I see all the time, but I don't think I've seen anything as complicated as your example, at least nothing that got through a code review. In the future if/when we get [pattern matching](https://github.com/tc39/proposal-pattern-matching) we could have a dedicated syntax to handle this which should prove easier to digest.
[Short-circuit evaluation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Short-circuit_evaluation), yes, it gets used a lot. Even more so in [React templates](https://facebook.github.io/react/docs/conditional-rendering.html#inline-if-with-logical--operator).
Isn't jQuery such a function factory? A library of HOFs handling the cases of different browsers?
&gt; Short-circuit evaluation I know about short-circuit evaluation and use it often, but I have never seen anyone use it to replace a switch or a series of if-else statements. Is there a good reason why this isn't common?
So you'd reject it in code review on grounds of readability? Correct me if I'm wrong, but pattern matching is something different. It returns different things depending on the shape of the arguments, but in this case I want to test the arguments against different conditions.
&gt; So you'd reject it in code review on grounds of readability? Me personally, I don't know. Might depend on how I'm feeling that day. But I know a number of people I work with that would definitely not let it through. &gt; Correct me if I'm wrong, but pattern matching is something different. it is, but something like [if predicates](https://github.com/tc39/proposal-pattern-matching#if-predicates) could allow it to be used for a very similar behavior. At this point, you'd still be including the argument match for each leg, so its not as clean, but I think there's some potential there.
If the switch statements are constants they should be converted by the js runtime into hash tables with a constant lookup time so doing it a different way will mean more processing as each condition you guard is evaluated. If you are doing computed switch values as a replacement for large if else structures then it might not matter as much computationally. Either way though ifs and switches are idiomatic. Very simple short circuit guards for variable assignment are also idiomatic in js. But complicated guards like your example are not. I don't see anything to gain by using an unfamiliar pattern when it does the same thing as the already existing ones with no performance benefits.
Why not just bootstrap regular React on different elements?
There is the define plugin for production scripts. Don't put secrets into client side code though. Anyone can read your client side javascript that visits the site.
A ternary chain does the same thing, which is what more people go with. const bmiTell = bmi =&gt; bmi &lt;= 18.5 ? "You're underweight" : bmi &lt;= 25 ? "You're normal" : bmi &lt;= 30 ? "You're overweight" : "You're Obese" There are lots of nice, readable ways of writing it though. I'd probably do something like this, with `.0` added to even it out. function bmiTell(bmi) { if (bmi &lt;= 18.5) return "You're underweight" if (bmi &lt;= 25.0) return "You're normal" if (bmi &lt;= 30.0) return "You're overweight" return "You're obese" } But it ends up being personal preference in the end.
They are some whiteboard coding exercises I ran some candidates through for a junior developer position
At most, 15 year olds are usually trying to write games and not game libraries -- keep at it! I didn't read all of it, but one piece of advice is to notice if every if branch contains the same piece of logic, that piece is not conditional anymore and you should probably move it out. 
I pass in a function with a debug statement and step through till after the isArrayLike variable is declared. Then I set the local i to void 0 in the console and let it complete the call. It's a manual process but I don't see you saying that is not allowed.
Thank you. :)
Easter was months ago.
Do you have any evidence of that? Because I would not at all be surprised to find this is heavily biased by people learning for loops before they learn functional programming.
1. Pollute the global namespace less 2. Constructors should be capitalized Nice job :)
&gt; and I want to be a programmer in future. Congrats, it's the future and you're a programmer. This is more impressive than anything I've written and I'm full time.
Great job! Have you looked into things like Phaser to get ideas on how to further expand your codebase?
/r/javascript/comments/6rsvt5/dijkstra_was_right_recursion_should_not_be/dl7x20t/
Does that not need `.bind(console)` anymore? 
At least in chrome you don't need
https://github.com/cidouchi/redditExpress/blob/master/README.md simple 'RES' like chrome extension : D
So? It's not the only language out there, and javascript really needs a good game engine right now. While C and its brothers are always gonna be around, for they are powerful languages, they are not the most adequate for all use cases nowadays. Some big apps have been opting to use javascript even for desktop applications through tools like electron. Discord and NVidia Experience are good examples. Go be elitist somewhere else.
haha. no. I meant "You're not writing C. Don't use C-style 'if' blocks". do this: if (foo) { } not this: if (foo) { }
Your code is awesome. Don't worry about your code style, every JS programmer has its way, as long as you follow good practices. I actually write in similar manner as you, and I have seen horrible and awesome JS code (lots, actually). You are already a programmer, be proud of it! Nice initiative, JS is a wonderful language and needs more game development tools.
Lol, sorry for the rant, that being the case. I removed the downvote. Now, to actually respond your comment, I never lperceived indentation style as bound to specific languages. I know several different programmers with different indentation styles, and they usually carry them over from one language to another. Indeed, my girlfriend also indents the way OP does, regardless of the language. I indent your way, so whenever we work together we mess with each other by messing their indentation.
that's what code linting is for. You define the agreed upon rules and the linter enforces them. Now a days, you can just pick one of the default rules like "AirBNB Style" or "Node.js Style" etc. etc. Checkout eslint.
I meant we do it as a joke of course, lol üòÇ We do respect a single code style when working. We do use a linting tool that supports a variety of languages, though I hear ESLint is one of the best :P
It's a bot, so...
What if one of the values you wanted to choose is "falsey". For example, calculate the discount. Buy 10-99 items and get a 5% discount; buy 100 or more items and get a 10% discount: const getDiscountPercent = items =&gt; items &lt; 10 &amp;&amp; 0 || items &lt; 100 &amp;&amp; 5 || 10; Yes, you can reorder this so that the 0 is the final value but something easy to miss if you're not paying attention. 
What?? That would just make too much sense.
Ah yes, the Air Bud meta-strategy. I approve.
&gt; Backwards compatibility is a big deal, documents published on the web that used to work shouldn't stop working just because they're old. When they're 10+ years old, yes they should.
You're right, it is easier to work with recursion for those who started with a functional programming where recursion is a standard mechanism instead of a loop. I mention that in the article. However, the recursive solutions for harder problems like Tower of Hanoii, merge sort and the likes are not easy even for those who got used to using recursive solutions. And the concepts like backtracking and memoization are hard to grasp for most of us.
Well, you don't need to explain call stacks and tail-call optimizations to teach someone iterative programming concepts. 
This + environment checks on whatever server is running the code. 
This is cool - you can always tell when someone is creating something simply because they enjoy doing it. Small critiques; 1) try to always evaluate without coercing a statement (e.g. === or !== instead of == or !=) unless you actually have some use case where your data can possibly exist as multiple types (e.g. as a number of string for example). Other devs that read your code may think you are intentionally accounting for this concept. 2) Look into code-splitting; it will help you structure your files a lot better rather than one monolithic file. NodeJS + a library like webpack can help you out a lot with these concepts. 3) moopleGame is technically a class (although JS does not implement a class in a traditional sense) and these typically should be declared with a capital letter to denote it accordingly; e.g. MoopleGame. You can see this practice in action with things like Date, Object, Error, etc =&gt; anything used to construct an instance of itself is typically denoted this way. 4) While I understand your goal is to create a library and you want to warn users when they call your functions with incorrect parameters, you should be aware of how this can impact performance to check this every time a function is called and whether or not that warning is worth it. Overall really good job and it looks like others have raised some solid feedback for you.
You can do this without an `isWeird` function... let weirdObj = () =&gt; { weirdObj = { length: 1, get 0 () { weirdObj = void 0 return true } } return true } let isWeird = false try { const isFunction = weirdObj(0) const isArrayLike = weirdObj[weirdObj.length - 1] const isUndefined = typeof weirdObj === 'undefined' isWeird = isFunction || isArrayLike || isUndefined } catch (e) { isWeird = false } finally { console.log(isWeird); // true } The fundamental problem with an `isWeird` function is you can't modify the `i` argument to turn it to undefined unless `i` is in scope, and if you pass i as a function, it'll never be in scope. If it was a `function` instead, i.e.: function isWeird (i) { .... } One could cheat by doing.... isWeird = new Proxy(isWeird, { apply: () =&gt; true }) isWeird() // true !! But because it is a const, that won't work. That's as close as you could get.... aside from `document.all` that is.
You don't need to start there to teach recursion, either. 
You don't need to start with it but you certainly shouldn't skip over it unless you just want to teach bad programming practices.
I'd be more surprised if you found an important feature that was only available in code and atom vs emacs and vim.
If you want to look more into tswaters answer. Wiki MVC architecture, it is a very common approach for user interface development. There are also many variations of MVC, but the key point is that they all separate the view from the model. Another way to think about it is, why separate code in general? Why put code in different files or modules instead of one big one? Often programmers have to keep multiple systems in their head: the view library calls the network library which updates the database, etc. If we find a bug in the view code, we can open the view file and focus on debugging the view code. We don't have to context switch and start thinking about the database or model or whatever else. If you wiki MVC, the advantages section also lists benefits of modularity, which you can explore more deeply as you level up.
Hello. I've worked with Phaser.js in winter.Actually yes, I was inspired by phaser. In future I want to add mouse functions(like x and y, click detections) and physics. Phaser projects: https://github.com/danmoop/space-invaders https://github.com/danmoop/mario-phaser.js
Hello. I've worked with Phaser.js in winter.Actually yes, I was inspired by phaser. In future I want to add mouse functions(like x and y, click detections) and physics. Phaser projects: https://github.com/danmoop/space-invaders https://github.com/danmoop/mario-phaser.js
Hello. I want to add mouse functions(like x and y, click detections). Also physics would be good. And I want some kinda editor for this. Because creating big maps is really tough.
Thanks a lot!
Thank you. To be honest, I can't get any job. I can't work officially because of my age. But on freelance competition is very high so it's hard for me to get a job. To be honest, I can work also with socket.io - I created web chat using it. - https://github.com/danmoop/Node.jsChat I can create mobile apps using js - https://github.com/danmoop/Trianglify and anything stuff with js ;)
Thank you. I didn't expect to hear good words about it :)
Thank you! I added your solution to the project! It works brilliant! ;)
Thank you! I have more projects, like mobile app using javascript - https://github.com/danmoop/Trianglify. You can create lowpoly effect for your photo!
That is a single view in a trivial todo app. Imagine several of them in a more demanding application and they all [interact with and modify one another, share state](https://pbs.twimg.com/media/C7eEVWJVUAA8era.jpg:large), etc. Designing, refactoring and debugging will become a nightmare because the application is not based on components but imperative code pieces wildly sprinkled throughout the codebase that, if a thousand arbitrary conditions hold water, piece together the app. The application will grow exponentially and implement so many wires and flags and exceptions that it will become unmaintainable. The whole point of frameworks is that there's a clean separation at least between state and views. Views reflect state (and may cause actions) and that frees them from internal logic which is in its own domain. It makes for lean applications using little code, that are easily understood and the designer can shuffle and replace components at will. 
So where would you put, say a API needed for some js library you're using if it's not in the client side code?
All I want from these tutorias is real world examples where this is actually useful. I've never in 10 years of programming needed the sum of numbers from an array or to find binary combinations. The one place I use recursion for running through a JSON object.
NONE of this stuff should be difficult 
Your isLetter function should just use regex instead of testing for a range. `/[a-z]/i.test(key)`. Much cleaner and can be expanded on easily I. The future instead of adding more logical operators.
&gt; Is it ability to code any kind of app without googling and known whole documentation? You're kind of new at programming as a whole, aren't you...
I had a colleague (which has since parted way with us) who'd never figure out situations that call for recursion. He'd just start nesting loops and solve the problem 2-3 levels deep and assume the structure he receives never goes deeper. I find it very bizarre, as if the mind of some people isn't built for systems thinking. Grocking recursion is an essential skill in understanding and building systems of any kind, because you'll find the same patterns at low levels as you'd find at high levels. You need to be able to find the similarities, and come up with a recursive understanding and solutions to the problems at hand, rather than keep doing the same thing over and over and not even noticing. Another bizarre example in recursive thinking is how web frameworks use MVC in an application-wide flat manner, without understanding MVC triad often hook in hierarchies. The result is spaghetti code. If you have problems with recursion you need to play with it in your spare time until it feels right. Otherwise you'd be wasting time and coming up with poor solutions and not even realize it. 
The only time that comes to mind for me was to traverse the DOM for web scraping. If the current element does not have children, do something with its text content, otherwise recurse with each of its child nodes.
I'm not sure that compatibility is really that big a deal people try to make it be. There is not a single website I used this year that was not updated in the last 4 years. And the desktop software I bought 10 years ago, surprise, doesn't work on my up-to-date system, so? Also, the majority of people today find content via google. I'm not sure if unoptimized sites from 10+ years ago would even be found in the first 3 pages of search results, which most people don't cross anyway. Anyway, if I had a job to create a site that will not be touched for 10+ years, I would not even try to write a single line of JavaScript and render everything on the server. Good old HTML content that will be displayed by the browser even in 10+ years, maybe with flawed design or formatting, but still readable. For the case of document.all. Why not just create something like a compatibility mode? Definitely disabled as a default, but can manually be enabled if someone wishes to.
... but imagine having a photographic memory... 
Built in clipboard :-) I load up StackOverflow in my brain for a job interview and can write FizzBuzz in a hundred different wrong ways. 
One would rather write `setTimeout(() =&gt; this.update())`, though. &gt; It's just shorter Arrow functions compared to function expressions, yes. Assigning some arrow function to a const compared to a function declaration? Not really. function foo() { ... } function foo() { return ...; } const foo = () =&gt; ...; const foo = () =&gt; { return ...; }; You basically just exchange some normal letters for punctuation, which makes it a bit slower to type. One might argue that using a const protects against redeclarations, but you get that anyways with ESLint, TypeScript, etc anyways.
You should know the basics of JavaScript without having to Google it: syntax for basic loops, if/else statements, switches, declarations. You should have a good grasp of integral concepts like how scope works, logic checks, objects, promises. In practical terms, I would never hire a junior developer who can't program a poker game, a hangman game, and a very basic calculator in vanilla. Edit. Doing small projects to teach yourself is perfectly fine. Googling is expected. No one knows everything. Don't worry if it feels slow to you. Programming isn't easy and you won't pick it up overnight. If you're still really new, codecademy has a JavaScript tutorial that can help you get used to programming in vanilla.
Used it for crawling nested sitemaps once
There is a big difference between the 2 examples, the first is a function expression, but also using an arrow function. (If you want a named arrow function, this is the only way to do it) The second is a function declaration using regular function syntax. As well as the two examples you have given, you could write const f = function(x) { return x; } The difference between arrow functions and regular functions is that 'this' is bound to different things. (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions) The difference between function declarations and expressions is that function declarations are hoisted, whereas function expressions are not. (https://elegantcode.com/2011/03/24/basic-javascript-part-12-function-hoisting/) 
I'm not aware of any difference between declaring a variable vs a function expression. That said, all arrow functions are anonymous and therefore can only be referenced by a variable that points to them. 
Make some ~~CSRF~~ HTTP request with a CSRF token to your own server which just fires off another request to the third party API.
but do people really _need_ whitespace? ;) function foo(){ ... } function foo(){ return ...; } const foo=_=&gt; ...; const foo=_=&gt;{ return ...; };
Return is implicit in arrow functions const double = x =&gt; x*2 Arrow functions are also great for functional programming [1, 2, 3, 4] .map(value =&gt; value * 2) .filter(value =&gt; value &gt; 2) .forEach(value =&gt; console.log(value))
Here are some differences. For clarity, I'm renaming the second example to `f2`: const f = (x) =&gt; x; function f2(x) { return x; } * f is an arrow function, f2 is a function declaration * f is a syntax which is new as of ES6, f2 has been around since the dinosaurs * f doesn't have its own `this` or `arguments` and instead inherits them from the next non-arrow parent function scope. f2 gottem. * Related to this, `bind` (or `call` or `apply`) cannot be used to change context (`this`) for a call to f, but can for f2 * f, defined with `const`, cannot be redeclared; f2 can * f2 is hoisted and can be referenced and called higher in the code, f cannot * f is confidently block scoped, f2 is ... well, there's history, and you generally try to avoid defining function declarations in a block (though they should be correctly block scoped in strict ES6+) * f2 can be used as a constructor, f cannot * Related to this, f2 has a `prototype` property, f does not
Function expressions can be assigned to variables anywhere and you can reuse these variables as much times as you wish. Function declarations shouldn't be used in any `{}` blocks other than the outermost `function` block (e.g. `for`, `if`, `while`) for obvious reasons. 
Http interceptor? Attach it to the app with your router and then filter all requests. 
The topic is assigning arrow functions to consts, though. I already mentioned that arrow functions are terser than function expressions.
Great league table. Thanks for sharing.
The behavior of JS OOP hasn't changed with ES6. You just have some nicer, cleaner syntax to work with. Under the hood its all the same, i.e. its still prototypal. I personally would suggest still learning the ES5 approach just because it brings you closer to the metal of how things work - things that can get hidden from you with the ES6 syntax. You may also come across OOP code written before ES6 and it would help to be able to understand what its doing.
&gt; f, defined with const, cannot be redeclared; f2 can Not much of an issue in practice since ESLint and TSC would catch this. &gt; well, there's history, and you generally try to avoid defining function declarations in a block ES6 added block-level function declarations. You can now declare them in any block. &gt; though they should be correctly block scoped in strict ES6+ Sloppy mode, too: https://jsfiddle.net/5uvd1tmd/ In the past, the problem was that browsers behaved differently and Firefox even threw an error when you tried to declare a function not at the top level or the top level of a function. Babel makes this work by converting it to function expressions which are assigned to variables. (That's basically the reason why Crockford recommended to always assign function expressions to variables in lieu of using function declarations. Always using the workaround which was necessary for ES3/5 was more consistent.)
The difference is primarily syntactic (both are ways to declare functions that are callable from other code), but there is an actual functional difference between the two. If you don't understand how `this` works in JS, this might go over your head. Effectively, `this` is a lot more loose than it is in a language like Java because it can be bound to different things depending on how you use functions. Take this function: function f() { return this.x; } By default, `this` points to the global object: `window` in browsers, `global` in node, etc. If you call `f` by itself in any context, `this` will always refer to that global object. There are two ways to make `this` refer to something else: binding and making the function a property. With binding, you can directly bind `this` to some value, which will be permanently tied to `this` for the lifetime of the function: const bound = f.bind({ x: 1 }); console.log(f()); // undefined (or whatever global.x is) console.log(bound()); // 1 As you can see, `f` is still the original function, unchanged. But `bind` creates a new copy of the function where `this` is bound to whatever value you pass to it. So `bound` will always have `this` set to that object, and that can never be changed. You can also set the function as a property of some object and call it via that object: const obj = { f, x: 1 }; console.log(obj.f()); // 1 const _f = obj.f; console.log(_f()); // undefined (global.x) We set `f` as a property on the object, and when we call it with `obj.f()` it uses `obj` as `this`. But unlike `bind`, this isn't permanent. This will only be the case when the function is called *as a property of the object*. When you take the function and then store it in another variable and call it separately (as we do with `_f`), it will behave exactly as the original `f`. You can also use this with object oriented programming in JS. function MyClass() { this.x = 1; } MyClass.prototype.f = f; console.log((new MyClass()).f()); // 1 There is a lot more to explain here, but by setting the function as a property on the prototype, you are exposing it to be usable by all instances of the class. Here you are accessing `f` in the same way as above, so `this` will behave as expected. Here is the more modern syntax for the above: class MyClass { constructor() { this.x = 1; } f() { return this.x; } } It does exactly the same thing. Now, the above rules are complicated to remember, sometimes even for more advanced developers. It's easy to get wrong because there is too much implicit work going on. Arrow functions make working with `this` a lot smoother. const f = () =&gt; this.x; The above function cannot be bound, and even when you set it as a property on an object, it will never use `this` as any other value *than the value it had when it was declared.* Arrow functions use "lexical this", meaning that whatever `this` was in the context that the function was created, that is permanently the value of `this` in that function. This is very useful when you have a context where you are controlling `this` and you want it to keep a specific value even in sub-functions: class MyClass { constructor() { this.values = []; } addValues(array) { array.forEach(v =&gt; this.addValue(v)); } addValue(v) { this.values.push(v); } } In the `addValues` function, we declare an arrow function that uses `this`, and that will always refer to whatever `this` is in `addValues`, which will ideally be an instance of `MyClass`. But the point is that you only have to care when calling `addValues`, at one place, not once for each function you create. Hope that made sense.
 foo()=&gt;...; Dart wins. Too bad you can't use arrows for function declarations and methods in JS as well.
yeah, it always bothers me to use the method shorthand but still be burdened with `return` (or brackets for that matter) when arrow functions are able to do away with them ¬Ø\\\_(„ÉÑ)\_/¬Ø 
didn't fully understand your question. could you please explain more?
A lot of languages people are learning today don't even require the compiler or runtime to support TCO. It's extremely useful for a subset of programs, but rather academic in most others. Frankly, beginners have more important issues to deal with. 
Consider: `setTimeout(this.update, 100)`
Another difference is that arrow functions are always anonymous whereas regular functions can *always* be named (even if you can't reference it by its name). const x = function y() {}; // valid console.log(x.name); // "y" y(); // ReferenceError 
Cool. Preferred reference? Google yields the following which I have used. [scotch](https://www.google.com/url?q=https://scotch.io/bar-talk/4-javascript-design-patterns-you-should-know&amp;sa=U&amp;ved=0ahUKEwjxhPqY7MLVAhWCqFQKHawqCxoQFggSMAI&amp;usg=AFQjCNEOh5awp_82Jia-i-H-2rsQVOefhg) and ["do factory "](http://www.dofactory.com/javascript/design-patterns). I also have js the good parts and some other books. 
That would tear off the method. let o = { x: 5, y() { return this.x * 4; } }; console.log(o.y()); // 20 let a = o.y; console.log(a()); // NaN let b = o.y.bind(o); console.log(b()); // 20 let c = () =&gt; o.y(); console.log(c()); // 20
ES6 added block-level function declarations.
It standartized the block-level functions as a part of legacy compatibility, not added them. And this specification is optional for non-browser enviroments (while in browsers, babel will not transpile block-level function semantics). So you can't actually rely on it anywhere.
I think the secret here is to use both. With the rule you use to determine when being what keeps your code the most human readable. Arrow functions are great when you just need a short oneliner callback for a filter function or something. And old school functions are great when you are building your projects function library.
I wholeheartedly believe you can do it!
As people have mentioned the detail with the this context being different, another difference is the syntactic structure of using arrow functions. [What is nice is that you get closures essentially for free](https://jsfiddle.net/jrab227/wno5eak0/) without needing to specify a "return function(x, ...) { " expression. Personally, I wouldn't call this a cosmetic difference, since when a repeated pattern can be expressed with syntactic simplicity, it's a feature of the language.
Not if update is itself an arrow function, or otherwise bound to the object. 
There are a bunch of types of higher order functions. So much to the point that I don't really think lumping them together is practical for JS development. Array methods are (usually) higher order functions. Seasoned JS developers use these constantly. Then there's higher order functions for dependency injection. For example, a method will use Math.random by default, but can accept another random function. Then there are transformational higher order functions. These can be things like reversing argument order, memoizing (caching the results of) the passed in function, or turning the function into a curried version. There's also functions like lodash's flow that take an arbitrary number of functions and chain them together. What I'm saying is that all of these functions exist and have their own merits and drawbacks. When you see a questionable reduce, ask "when or why would a seasoned JS developer use reduce?" 
&gt; Seems like with es6 I can take my OOP knowledge from Java and apply it to Javascript (I.e. Interfaces, adapters, factory, singleton, observer) There are no interfaces in JS. Only implicit ones. (TS fixes that.) The singleton pattern isn't necessary since JS has object literals. If you want a single instance, you just use a literal. Another important thing to note is that everything must be inside some class in Java. That's not the case with JS. It's perfectly fine if a module is just some top-level functions and/or constants. E.g. if you were to recreate JS' standard library today, you wouldn't stick all of the math stuff into a "Math" object. You'd simply put these things into a module.
&gt; or otherwise bound to the object You are tearing it off.
 this.update = _update.bind(this);
[removed]
Nice! Very cool projects. Phaser is a lot of fun to play around with. Keep up the good work! All of this is amazing. At 15, you are doing work that some of my colleagues would only be dreaming about.
Thank you!
Adding a property which looks like a method, but doesn't behave that way would be a rather weird thing to do. Creating the closurized tear-off in an unusual place isn't an improvement.
It's really useful for searching in graphs. Context searching in a web crawler, looking in directories, generating from a parse-tree, etc.
What version of Firefox ever did that? Sounds like BS as that was never part of the ES3 standard.
This is a major important point if you were writing a third-party script, or are writing a component in the context of a larger project. If an error occurs in something you wrote, without context (e.g., setTimeout), and without a function name, then your analytics may have a very difficult time tracking you down to fix your shit. In code reviews and general maintenance, I always try to add names to functions when I can.
You can also use the name within the function itself, allowing you to call it recursively const x = function y() { y(); // valid (well, will obviously overflow the call stack, but the call is valid) } Using an arrow function recursively without using a reference from a different scope (ie, not using x() in the above example) is trickier, but can be done using a Y combinator: http://kestas.kuliukas.com/YCombinatorExplained/ 
Hi /u/UglyLiar, please keep it civil.
Yep, anonymous functions are the devil when debugging. 
Hi /u/LostMyCharm, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Yes it's exactly what I'm looking for. 
It's incredibly useful in AI, or really anything where you need to break a problem space down in size to reduce algorithmic complexity. All these people claiming they've never needed to use recursion... they're either solving problems wrong, or working on code-monkey bitchwork. 
Your links are more geared towards patterns rather than core oop concepts. That's all fine and dandy, but if you're really looking for what a class means in JS, you'll want to forgo patterns. MDN is a go to reference for core and DOM APIs, and they have decent tutorials for stuff like this too, https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_JS Note that while JS uses prototypes for inheritance, this isn't the same as the gof prototype pattern, it's more of a flyweight pattern. Understanding this behavior is crucial to knowing how oop works with JS.
Common in the React world
You should be able to. clearInterval doesn't prevent you from calling setInterval again for a new interval, it simply gets rid of the background task handling a previous interval. Do you have a simple example showing your problem?
how about this? https://jsfiddle.net/dota8z4g/
Base class's contructor does stuff.
This takes the first argument passed into the constructor of this class and passes it along to the constructor of the class it extends. If this is the only thing the constructor does, its unnecessary, since the automatic constructor will do this for you. But when writing your own constructor, you'll want to be able to make sure that if you're extending another class, that its constructor gets called with the arguments passed into new instances created (if needed). For example: class Animal { constructor (name) { this.name = name } } class Cat extends Animal { constructor (name) { super(name) } } var kitten = new Cat('spot') kitten.name //-&gt; spot If super was not called (or, rather, called but without passing the name), the name would not make it into the super constructor preventing the name from getting set.
https://github.com/service-bot/servicebot Written with NodeJS/React/Redux It's a platform to manage gigs, for freelancers and small businesses who need to manage projects better I've been working on this a while with a group of friends - just launched our open-beta (you can request a free instance at https://servicebot.io)
Function declarations did indeed used to be illegal anywhere except at the top-level of a scope. In [ES5](https://www.ecma-international.org/ecma-262/5.1/index.html#sec-A.4), a statement included things like var statements, if statements, return statements... but not function declarations. Instead, there is a "source element" that is either a statement or a function declaration, and the program itself and function bodies were defined to be 0 or more source elements. So a function declaration could appear at the top-level of a program, or at the top-level inside another function, but not inside blocks (if blocks, for blocks, etc). Contrasted with [ES6](https://www.ecma-international.org/ecma-262/6.0/index.html#sec-statements) and beyond, where function declarations still aren't technically a statement, but they can appear in statement _lists_, since a statement list item is either a statement or a declaration. Pre-ES6, it's a good thing function declarations inside blocks used to be illegal, because otherwise you'd run into weird situations like this: if (condition) { function f() { return "foo"; } console.log(f()); } else { function f() { return "bar"; } console.log(f()); } In pre-ES6, these function declarations weren't scoped to their block, so both declarations would have been hoisted, and the latter declaration would always win, regardless of how the if was evaluated, so the language simply made function declarations inside blocks illegal.
Okay I got. But can't imagine how this would be used in react.
Cant you just return an array of components instead? return [&lt;div /&gt;, &lt;div /&gt;] 
&gt; What version of Firefox ever did that? https://kangax.github.io/compat-table/es6/#block-level-function-note *Note that prior to ES6, it was recommended that ES5 implementations forbid block-level declarations in strict mode.* Firefox was the only browser which actually threw a SyntaxError. You can find references to this in older SO comments etc. https://stackoverflow.com/a/8871984 *Function declarations inside blocks are a syntax error in strict mode* Actual error message: SyntaxError: In strict mode code, functions can only be declared at top level or immediately within another function.
&gt; ...not added them. ... babel will not transpile block-level function semantics [They did](https://www.reddit.com/r/javascript/comments/6ry2t0/why_declare_functions_with_expressions/dl8x94l/), and [it does](https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-2&amp;targets=&amp;browsers=&amp;builtIns=false&amp;debug=false&amp;code_lz=JYMwBAFAxg9gdgE2AF2PAlGA3gKDPsEAVzilXkIk1wNrACcBTZI-uMAIhBhg4G48BAL45B-WHADOMADaMAdDJgBzCCCroBQsIxmTG2MYRJk07ddSO0mLNpwBGAQ3r8jIoxOlzFKtRq1AA).
&gt; Is there a benefit of the first form compared to the second beyond cosmetic? No. But syntax can aid readability and demonstrate intent. A function is essentially a mapping of one space of values to another space. For example it can map the space of integers, to a space of their correspondent squared versions. You can express this mapping in pseudo code like this: $integer =&gt; $integer * $integer And wouldn't you know, that's what arrow function expressions are written like. Hence it's very clear what you're doing when you write it like this.
&gt; it does. Wow. Never knew that. &gt;They did It's called &gt;B.3.3 Block-Level Function Declarations Web Legacy Compatibility Semantics in &gt;(normative) Additional ECMAScript Features for Web Browsers &gt;This annex describes various legacy features and other characteristics of web browser based ECMAScript implementations. All of the language features and behaviours specified in this annex have one or more undesirable characteristics and in the absence of legacy usage would be removed from this specification. However, the usage of these features by large numbers of existing web pages means that web browsers must continue to support them. The specifications in this annex defined the requirements for interoperable implementations of these legacy features. &gt;These features are not considered part of the core ECMAScript language. Programmers should not use or assume the existence of these features and behaviours when writing new ECMAScript code. ECMAScript implementations are discouraged from implementing these features unless the implementation is part of a web browser or is required to run the same legacy ECMAScript code that web browsers encounter. 
I think you were looking for a React specific answer, no? If you don't pass `props` into super, then `this.props` will be undefined inside of the constructor. Note: `this.props` *will* be defined inside of other methods, like `render`, regardless of whether you pass it into super. So, if you are expecting access to `this.props`inside of the constructor, pass `props` into super. See the [relevant docs](https://facebook.github.io/react/docs/react-component.html#constructor) or a [stack overflow answer](https://stackoverflow.com/questions/30571875/whats-the-difference-between-super-and-superprops-in-react-when-using-e?rq=1) to this question.
What were your reasons to choose inheritance over composition to give your classes the iterator ability? 
With respect to react, props are given to react components as an argument in the constructor call. React components extend `React.Component` who's constructor take a props object. So when you write your constructor call, you need to pass props along through `super` to make sure `React.Component` gets it (where it in turn saves it to the `props` property for you).
More readable, shorter and they auto-bind `this` which is a major benefit.
`function` and `=&gt;` are both functions, but are both have different behaviour. Arrow functions don't open up a new context when they're declared, so `this` inside one will reference the same scope the function was declared in.
Us code monkeys love to learn :) can you provide a real example from your work?
It is indeed common in react if you're not using arrow functions in your class components for some reason, but I primarily brought it up for technical accuracy - having update be an arrow function to begin with was my main point. 
You should check out the OOLO (objects-linked-to-other-objects) pattern and forget about most of what you learned from Java in the context of JS. After all, JS is not Java, and both have different approaches towards OOP. Kyle Simpson makes a pretty solid case against it here: https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&amp;%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes (chapters 4-6 + Appendix).
&gt; Make some **CSRF** request to your own server [Not sure you're using that term right...](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF\))
being that this is a javascript sub, they're doing it the right way since recursive solutions quickly run out of stack space for any large number of inputs and memoization solutions aren't exactly the easiest code for people to read when an iterative solution will do just fine. 
If you assign keys, yes you can.
&gt; I.e. Interfaces, JS has duck typing instead of explicit interfaces. But there are interfaces in TypeScript and in Flow (they compile to plain JS). &gt; adapters, factory, singleton, observer) these are just design patterns, not dependent on language. You could implement them in ES5 or even ES3. ES6 didn't change anything here. &gt; Seems like with es6 I can take my OOP knowledge from Java Everytime I see somebody "take OOP knowledge from Java" and tries to apply it in JavaScript, I see bunch of overengineered spaghetti code. Where in Java you would use class to every little thing, in JS you often should use e.g. function, object literal or some other thing instead. Java OOP does not translate to JS OOP 1:1. Of course many things in OOP are independent of language you use, for example design patterns, but even they could have completely different implementation in Java and completely different in JS. So. The best strategy is to keep "beginner's mind" and treat JS as a completely new language with its own rules.
I mean, I was already very familiar with recursion by that point but I'm not sure what that has to do with my point. You understand that recursion is often an expensive solution, right?
fixed.
If you're working on a small problem to begin with, performance is less important than "elegance", or working in a language with TCO (which, despite being in the standard, JavaScript doesn't really have) then recursion is a great choice. If any of those don't apply, iterative is almost always better. It's really not about "code-monkey bitchwork" and more about "know what I'm doing".
Most recently; We have a need to validate user's names that the enter into the system with their names in the database. We need to do this for 2 reasons; 1. We need to be able to match names like "Mike Peterson Jr" with a record in the database "Michael Peterson Junior", and we don't have a database that maps people's short names ("Mike") to their long names ("Michael"). 2. We need to be able to handle the situation where people misspell their own names, such as "Micheal Peterson" (You wouldn't believe how often this happens). So we decided to use a recursive algorithm to find the longest matching substrings between the input and the target. So, we remove all the spaces and punctuation, convert it to lowercase: michaelpetersonjunior &lt;--- input mikepetersonjr &lt;--- database mikepetersonsr &lt;--- database Find the longest matching substring between the first two: michael | petersonj | unior mike | petersonj | r Now record the fact that we found a 9-character match by taking the 1.2nd power (this is an arbitrary heuristic thing that we determined was optimal for our database, not really important for the recursion aspect), which is 13.9, and add that to an accumulator. Now, recursively perform the same operation to both sides. mi | chael &lt;-- two operations --&gt; unio | r mi | ke | r This time we get a match of 2 for the left recursive branch, so add 2.3 to the accumulator. And then we get a match of 1 for the right recursive branch, so add 1 to the accumulator. We can discard the right branch since there's now no other matches to make, we've consumed everything there. The left branch only needs to make one recursion: cha | e | l k | e | So that's another 1 added to the accumulator, for the 'e'. We can discard the right branch of this since there's nothing left to compare, giving us one final recursion; comparing 'cha' to 'k'. But since there's no common letters, there's no match, and no points. Computation terminates there, giving us a score of: total: 18.26 Alright, next comparison: michael | peterson | junior mike | peterson | sr 8-character match, 12.1 into accumulator. mi | chael &lt;---&gt; junio | r mi | ke &lt;---&gt; s | r match: 2, 2.3 into accumulator. match: 1, 1 into accumulator. cha | e | l k | e | match: 1, 1 into accumulator. total: 16.42 So from this example, we've determined that "Mike Peterson Jr" has a score of 18.26, and "Mike Peterson Sr" has a score of 16.42, making "Mike Peterson Jr" the most likely database record match for "Michael Peterson Junior". The role of recursion here was two-fold: 1. It simplified the problem by splitting up the input into smaller pieces and solving only the sub-problems. 2. By using the stack to maintain our tree, we didn't need to create a complex data structure to remember all of the places where we split the strings to compare sub-strings. I can't even imagine trying to handle this problem without recursion. But with recursion, the algorithm was able to be simplified into about 4 lines of JavaScript code.
I mean if I've already coded setInterval(Function), then clearInterval(Function), and then setInterval(Function). Pausing/starting the same interval function basicly.
It's a stupid API react introduced when forcing themselves to use es6 classes. You can still use create-react-class to use the previous object class api
clearInterval works on an "id", not a function. This id is the return value from a setInterval call. You don't use a function because you can pass the same function into setInterval multiple times for multiple intervals and a clearInterval wouldn't know which interval to target. Instead, setInterval returns a value that you'd keep track of and then use it with clearInterval if you want to clear that specific interval var intervalId = setInterval(func, 1000) clearInterval(intervalId) There's nothing to stop you from using setInterval with the same function as many times as you want. You'll just want to make sure that you keep tabs on those interval id's each call returns so that you can stop (clear) them if/when you need to.
I see. So to start the interval again you simply need to make a line of setInterval(intervalId), after the lines you wrote?
For an in-depth look at this, see [Named Functional Expressions Demystified](http://kangax.github.io/nfe/). When that was written in 2009 it was a pretty important article. These days, with a different set of ecmascript implementations than we had in 2009 and most of my code being run through Babel before it hits the browser, I'm not sure which parts of that article are still relevant.
[**Tagmeme**](https://github.com/andrejewski/tagmeme) After working in Elm, I really wanted to bring tagged unions into JavaScript. There are other libraries that do this. This library captures for me what are the important bits of the concepts and strictly enforces its pattern matching and API usage.
More or less. It's a completely _new_ interval, rather than, say, pausing an existing one and starting it back up again. But yeah, when you want to have a repeating, running interval, simply call setInterval.
I see. Cheers :-)
You use this typically when your React component needs to set state based on the properties. There's no lifecycle method that's called in the initial mounting of the component where it's appropriate to call setState (componentWillReceiveProps isn't called for the initial mounting). So often it ends up mirroring what you do in componentWillReceiveProps, but that's not necessarily the case (you may set a default state based on the props and choose not to update it based on prop changes). One example of when this would be useful is when you need to an expensive transformation on the incoming state: constructor(props) { super(props) this.state = { foo: expensiveFunction(props.bar } } componentWillReceiveProps(nextProps) { if(nextProps.bar !== this.props.bar) { this.setState({foo: expensiveFunction(nextProps.bar)}) } } This way you control when expensiveFunction is called and reduce the # of invocations to the minimum. If you just called expensiveFunction in the render method then you may call it many more times than you need if other properties on the component change.
We can. That's what prerender.io does as a service. 
The this-talk-is-not-about-x part is also really useful. 
Well, sort of. Arrow functions get their names from where they end up, and the name of all functions can be changed. const x = () =&gt; {}; console.log(x.name); // x Object.defineProperty(x, 'name', {value: 'foo', configurable: true}); console.log(x.name); // foo The defined name is what appears in stack traces and elsewhere. 
Thank you for the answer. I've still some questions: what are the cons? I expected this solution to be the primary when we talk about server rendering, instead Angular team is working hard to solve all @angular/platform-server issues. Then, does it work with Angular2+? The website just talks about AngularJS, and why does it refer only to web crawlers? What if I want to serve the pre-rendered version also to users? 
Yeah great question. I never managed to get it to work. I don't know how it works with Angular, but the biggest issue if your framework does not do DOM diffing is I believe the framework will need to rerender everything again. Another (major) con is it's super slow. On cold cache, prerender.io took 13 seconds to respond. My home-baked solutions were even slower. May I ask what your application is? I'd like to talk through with you whether you actually need server rendering for your human clients. 
Never tried this, so another answer might be better, but I know you can use [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) to request web-pages. If you can properly request the next page of results, you can explore that page's DOM just like you can with the current page. If that works like I imagine, you could use `querySelectorAll` to get every result "item" (div, presumable) and append those to the list on the current page. You could even find the next-page link on the next page and follow that, and do the same process. This is, of course, probably something you should be quite careful about, as you could easily trigger DDoS protection from Ebay's server if you request too many documents too quickly. Good luck!
This kind of thing is highly dependent on how their page works. I'd honestly say the work to do it is not worth the reward. I imagine you could leverage some API that they expose to download the items, then manually generate the DOM for the each item and append those to the page. You'd also have to recode the "next page" button. I think the Reddit Enhancement Sweet does something similar for Reddit. But depending on how the eBay page is coded, there may be an easier way. Perhaps you can fiddle with some of the parameters in the URL.
Do note there are some things that are *not* equivalent with ES6 classes compared with ES5 constructor functions. The most notable thing is that there's no equivalent of `super()` in ES5 constructor functions which makes it impossible to subclass builtins that way e.g.: class MyCollection extends Array { constructor(...args) { super(...args) // No ES5 equivalent, there's no general // way to subclass an array in ES5 } } The consequence of this is it even leads to un-subclassable things in HTML, e.g. if you want to use custom html elements ES6 classes are effectively required: class Timer extends HTMLElement { constructor(time) { super() // No ES5 equivalent } connectedCallback() { this.innerHTML = ` ... ` } } 
I have learned like the basic skeleton and Boolean...
Dart win what. Google made dart. But choose typescript from Microsoft for angular 2. Dart and coffeescript are decent attempts. But time to put them to rest. 
Well, 170Mb is just 20.27MiB. Seems okay to me.
just came across this same problem and found it was because I was calling `connection.on("error", ...)` when setting up my Mongoose connection, but never removing it. I just added a call to removeAllListeners when it is closed. connection.on('close', () =&gt; { connection.removeAllListeners(); });
So it has nothing to do with async await , its an event emitter problem ! ? 
Neat! May have found a bug - answer choices didn't appear for me on the 9th question "Who is John Snow have sex with at the end of this season". EDIT: And the console log /favicon.ico Failed to load resource: the server responded with a status of 404 () angular.min.js:93 Error: [ngRepeat:dupes] http://errors.angularjs.org/1.2.32/ngRepeat/dupes?p0=(key%2C%20value)%20in%20data.list&amp;p1=string%3ADayeneris&amp;p2=%22Dayeneris%22 at angular.min.js:6 at angular.min.js:202 at Object.fn (angular.min.js:110) at h.$digest (angular.min.js:111) at a.$$childScopeClass.$$childScopeClass.$apply (angular.min.js:114) at HTMLButtonElement.&lt;anonymous&gt; (angular.min.js:196) at angular.min.js:31 at r (angular.min.js:7) at HTMLButtonElement.c (angular.min.js:31) (anonymous) @ angular.min.js:93 . Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: (key, value) in data.list, Duplicate key: string:Dayeneris, Duplicate value: "Dayeneris" EDIT: And one more - navigating directly to `https://got-app-d0350.firebaseapp.com/app/#/questions/` (in my case by refreshing the page) just displays a black screen with the text "3 of 3 Lives Remaining".
yeah, it's totally unrelated. I found an article talking about event handlers which led me to my Mongoose connection. once I added that code I don't get that warning on my Mocha integration tests.
Thanks.
Thanks Grinde! This error was because someone writes a question with the same answers on each option.
Yes, it will never hurt to expand your knowledge but with Node around your entire infrastructure can be built with JS and that‚Äôs the beauty of it. You can explore further into the field by looking into Elm, TypeScript or ReasonML (etc...) but at the end of the day, you can only go as deep as you dive and if you aren‚Äôt needing to find that solution that is missing from your workflow then there‚Äôs no point to. By finding a solution it could be solving a particular problem or javascript fatigue. 
Hi /u/iangilman, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I feel you, I feel you. As it seems to be in general with programming, one needs to be pragmatic about each case in question. Anyway, I'll keep learning, getting these answers from you guys was actually helpful since my question was more of a 'how to look at things' type of question, thanks BenjiSponge :).
I would learn one multi thread language because some jobs requires a lot of processing that needs to take advantage of multi-thread language. JavaScript can be used for back-end but for financial tech companies, I don't think they use NodeJS because they need a language that can effectively do multi-thread process with all the transactions coming in.
I think you are asking the wrong question. A better question is what do I want to accomplish? Then you can discover if you can do that with just JavaScript. In my experience less experienced developers believe 100% of the challenge is in the programming and so they ignore everything else. For example many developers who are new to developing for the web believe HTML is simple and so it isn't a real individual skill, but then their HTML is often garbage and completely fails accessibility.
lol-- nice
Why limit yourself? Keep growing as a developer and you will learn to use the right tool for the job. In this case, your tools being programming languages. You *can* do everything you mentioned in Javascript, but it does not mean you *should*. All I'm saying is to be open about it.
As I stated in the post, I have tried lots of other programming languages. If I just kept switching my *main* programming language, however, I wouldn't really be good at any programming language. 
Node provides APIs which are written in C++ that are threaded, but the JS that runs on node is itself not.
Not only can JS be enough, it probably wouldn't hard to find a job where you'll spend the remainder of your days supporting and fixing bugs in an unnecessarily large, horribly written web application developed by many previous authors, each with their own idea on how to write code and approach similar problems in different ways using an archaic JS framework that no one ever uses anymore. So cush!
Does react not warn about the rendering of `Aux` since it renders an array without keys?
JavaScript is a single-threaded language. Node asynchrony is handled by an event loop.
JS is enough to have a successful programming career right now. 10 years from now? Probably still will be. 20 years from now? Maybe. 30 years from now? Who knows.
TIL! Thanks
you could also use React which is better in essentially every way possible. 
From working in financials for over a decade, at a fortune 500 company, I would disagree. They choose their languages more out of tradition than for multi threading. Also, I met very few people who actually would claim to understand parallel computing. Scaling comes in many forms. I do agree though that you should learn parallel computing properly. Understand data races, and how to manage threads, mutexes, and semaphores manually. But also clustering, and messaging, etc. All of which just makes you more knowledgeable and more hirable. Regarding the OP's question though, I would say no. JavaScript is by far my favorite language, but I will never hang my hat (career) on any one thing. Right now, it's definitely a great choice for many things in the industry though.
You can fork a process but any single process is single threaded. The async io is often sufficient though for many types of work.
hey TheNixxeD. You are right I don't really know too much about multi-thread process. But this is just something a lead engineer in my company told me. He told me that, our company wouldn't be able to use NodeJS as a backend language because since it is not really a multi-thread language, it wouldn't be able to handle all the transaction that customers make in our backend services.
Well he's completely incorrect. I think that kind of blanket decision making is exactly why I left that industry. There are so many ways to handle scaling. 
When you pre-register, the misspelling with the word "just" makes the entire thing look really fake.
I see lol, I am actually a big fan of JavaScript too. If possible I would like to do NodeJS backend. But if I want to get into backend for my current company, I have to pick up C#.
This sounds like a bad "as seen on tv" infomercial lol. Seriously answering the question, is JS enough? Maybe? Is it a good starting point? Absolutely. Front-end development is a hot career at the moment, there are tons of positions that involve JS but you shouldn't limit yourself on learning just one language. JS is just a tool for solving problems. It does things very well and is crap in other instances. A better question to ask is what career do you want to explore? Do you want to work on front-end problems involving web? Do you want to learn about PWA? Server-side problems with node? Desktop development? embedded systems? 
It's not prototypal under the hood (at least not all the way). Object.create and class are slower and use more memory than raw prototypes. I'll find some better examples later but here you have few benchmarks https://github.com/kwasniew/jsupskill/tree/master/test/performance 
I would be pretty horrified if it wasn't. There is so much one should know to become a good javascript developer and trends in JS change very fast. To me it makes much more sense to focus on one language and get more knowledge about it rather than try to keep up with multiple ones and get overwhelmed. 
The Dart and TS/JS versions of Angular 2.x used a single TS codebase for a while, but they are now two separate projects again. Google uses Dart for a bunch of things including its biggest money-maker: AdSense. By the way, they used AngularDart for this. Also, Dart isn't just some to-JS language. It got its own VM and can even be AOT-compiled. That's why the Flutter framework also works on iOS.
I'm not sure what you mean by "not all the way". The inheritance mechanism is the same. Object.create does less (no constructors) and class does more (simplifies syntax while handling additional boilerplate), but in the end, its all prototypes. function ConstructorFunc(){} ConstructorFunc.prototype.member = function(){} const constructorInstance = new ConstructorFunc typeof ConstructorFunc === 'function' // true Object.getPrototypeOf(constructorInstance) === ConstructorFunc.prototype // true 'member' in constructorInstance // true constructorInstance.hasOwnProperty('member') // false Object.getPrototypeOf(constructorInstance).hasOwnProperty('member') // true Object.getPrototypeOf(constructorInstance).member === constructorInstance.member // true class ClassDef { member(){} } const classInstance = new ClassDef typeof ClassDef === 'function' // true Object.getPrototypeOf(classInstance) === ClassDef.prototype // true 'member' in classInstance // true classInstance.hasOwnProperty('member') // false Object.getPrototypeOf(classInstance).hasOwnProperty('member') // true Object.getPrototypeOf(classInstance).member === classInstance.member // true const createPrototype = { member(){} } const createInstance = Object.create(createPrototype) Object.getPrototypeOf(createInstance) === createPrototype // true 'member' in createInstance // true createInstance.hasOwnProperty('member') // false createPrototype.hasOwnProperty('member') // true createPrototype.member === createInstance.member // true const rawPrototype = { member(){} } const rawInstance = {} Object.setPrototypeOf(rawInstance, rawPrototype) Object.getPrototypeOf(rawInstance) === rawPrototype // true 'member' in rawInstance // true rawInstance.hasOwnProperty('member') // false rawPrototype.hasOwnProperty('member') // true rawPrototype.member === rawInstance.member // true 
and which library would that be? socket?
&gt; I would say no. JavaScript is by far my favorite language, but I will never hang my hat (career) on any one thing. Yeah, just look at all those people that did that with ActionScript... _\* cough cough \*_
What else is bad is that there's no information about who's behind the course. You'll receive a certificate for completing a course taught be someone who's probably not even qualified, and/or has little to no real world experience, otherwise they would have made both of these available and clear to further reinforce the validity of it. That being said, the whole thing is worthless and won't be recognised by potential employers.
Yes, you can. It's fairly easy to setup but very hard to get right. I had it running for a previous employer for an angular 1 SPA. We have a same type of phantomjs solution for a react codebase at my current employer, but I'm one day away of finishing the serverside rendering stuff. If you're running on angular &gt; 2, or react, vue, whatever; go for the server side rendering stuff the framework/library offers. It will be much, much faster and reliable. Like /u/BenjiSponge said, it's pretty hard to know when a library is done with its diffing/rendering and there is tons of stuff which can have some impact on it (e.g. render/digest cycle -&gt; xmlHTTPrequest -&gt; render/digest cycle -&gt; setTimeout -&gt; render/digest cycle, etc etc). 
What kind of poker game? Sounds reasonably difficult for a quick test. 
you can use Angular2 AOT to achieve the desired result.
this is a false claim
...unless you're just looking to learn, rather than have a certification to put on your resume.
I think JS can do a LOT but the only area where I'd say it will (hopefully) never be great in is game development. If you ever think about developing games then you willl have to pick up either C# or C++.
I hadn't touched JavaScript once during my degree. Since graduation I've gone into full stack, and I do 85% JS now, with the other 10% being Java and Objective C, and the final 5% being SQL. With things like Electron, React Native, and NodeJS getting so big I don't see it going anywhere any time soon. If things like Electron and RN-windows continue to improve I think we'll be sitting comfy for a while. Node seems to be one of the more highly paid languages in London. Lots of banks are using it, so it drives the salary for competent Node devs up quite high. I think JS is enough, if JS is what you want to be in. Still helps to understand DS and algos, although to be honest you can get away without that deep of an understanding in the JS world, since it's so high level.
There's a third difference - `const`. You can't get a runtime-enforced constant with a function declaration.
It doesn't... come to think about it, I don't understand whats the reason it does not. I have read through the related issue thread, but don't see the explanation https://github.com/facebook/react/issues/2127. My instinct was that `props.children` assigns key to every node, but it does not.
I'm guessing it's done with the array check by the time it's populated into props.children (as that's handled differently from any other prop). Either that or it's a non-normal array (with an added bit of metadata or something).
No any info - looks like fake... 
I don't "need" it actually, I just learned enough about Angular and I had some free time, so I thought "what's next? what can I learn?" and server-side rendering looked interesting. I googled and collected some information about platform-sever, so I noticed all the difficulties developers are facing. I thought "why can't we make it simpler?" and that's it
:O
I understand, thank you for sharing your experience
Not exactly the same, but still a step closer
Is there any significant performance difference between the two?
When we're talking about AAA titles then you're right. If we're talking about small indie titles, Javascript may become an eligible choice in couple of years. But you're right-choosing C# or C++ is the way to go when you want to do some serious games.
Keeps me well off financially. Although knowing SQL is very desirable as well, since 95% of web runs on SQL dbs.
You don't always have a reference to the element the event handler is being invoked on. For example, the handler might not be a nested function.
Imagine you've defined a toggleOpen function somewhere else then did box.addEventListener('click', toggleOpen). In this case, the function wouldn't know about the box variable. But yes, in your example the result is the same.
I don't know, but you shouldn't really care all that much. That is premature optimisation at its finest ;)
No problem. If you still want to try to understand prerendering with a headless browser (what phantom is), you should also check its alternatives and especially chrome headless; I think it's going to replace phantom as the default headless browser in the near future.
Yes actually when writing out my comment I was picturing an engine that follows the JS philosophy of making everything as easy as calling one method with a bunch of options. It would in fact be great and easy to use but in some places you just have to have the possibility to scratch the "recommended" way and do it yourself in a way that is much much faster. That just probably wouldnt be the case with JS as everything it would be calling would be predefined so even in indie games you would have to be able to extend gameobjects with C# scripts just to not make devs hit dead ends inside your engine. Anyway, coming back to OP's question, even if there was an engine that allows for extensive game development with JS, as an employer I think you'd still expect devs to at least have touched staticly typed languages before so they could jump in and fix stuff that are just too slow with JS. 
Using "this" is better, because you could "querySelectorAll" and it would still work compared to using "box" which would have a reference to the list of nodes.
Its just the behavior of the event API. As a convenience, listener functions, where possible, are called with the context of the current event target - or whatever `addEventListener` was called from. If you have a variable referring to the target available in the same scope your listener is defined, you can use that variable to reference the target directly. If not, and the listener function is able to get called with a different context (i.e. not an arrow function or an explicitly bound function), `this` also would work. And if not any of those cases, you could also provide an `event` parameter in your listener function and access it through `event.currentTarget`. box.addEventListener('click', function(event) { // box === this === event.currentTarget }); All different ways to get to the same thing.
This is a very annoying type of answer in every community possible. It's pretty much the same as we had years ago with jQuery. "How do I do this?" - "oh just use this jQuery plugin". Your answer is also pretty wrong, most new(ish) libraries have SSR support. React docs about SSR just sucks and it doesn't just magically work unless you have some very basic crud/Todo app. /rant
Thank you so much!
I see! Thanks a lot! For some reason, I didn't saw the broad context.
Thanks!
Thanks!
i think this can be confusing for a beginner. one would expect that logical operators are returning boolean values (but conveniently in js they are just returning the first or second argument). also, this approach is very brittle, since it relies on that the part after the `&amp;&amp;` is always truthy. i'd go with the ternary op.
When you get into bitwise operations, this all goes up in flames, too. A bitwise operation forces a number to be a 32bit signed integer... Because why the hell not I guess. 
It's not 'fake' so much as just a marketing ploy. They want to collect info from a niche group of people probably to spam them pay-for courses. 
Edit: I'm a jerk
I first learned JavaScript. I've since dabbled in, or learned, at least five other languages. I went from "I can do everything in JS, so why not?" to, "I wish these things could be done in another language all together, they picked one of the worst ones." Learning other languages opens you up to more opportunities and gives you a more rounded mindset as a developer. I may not like JS near as much as I did when it was the only language I knew, but I'm glad I know it for when I, as a single person and not a whole team, need to do something on the web, or react native, or run a quick node script.
how would you expect binary operations to work on a floating point?
Looks great!
I practice C for CS50, Scala for work, Go for work and personal, and JS for personal web apps, along with Python and Ruby for work (and Haskell because it's really fun). You learn them by being forced to use them. It's fine to learn more than one. 
It's just confusing and unintuitive when you start using integers and double representations. Often they are cast between the two representations and can feel strange. 
Thanks for this pretty brutal feedback. &gt; Your 'functional' examples show terrible anti-patterns like initializing an array, using a for look, and pushing to the array under a condition. Functionally this is an Array#find transform. And this poor advice is given continually throughout (specifically, loops everywhere). Did you read this chapter entirely? It shows how to refactor these initial examples in a functional way, using `map()`, `filter()`, `reduce()` and function composition. &gt; That coupled with the early and heavy push to the very limited class kw is enough that I won't be reading the rest. JavaScript is a prototypal language and you are doing your readers a huge disservice by glossing over what the sugar of class is actually doing (which is saw where there, but very much so glossed over.. not to mention the lack of using the factory pattern which is a hugely helpful real-world tool in JS). And inheritance for a game? ECS. In the OO chapter, I explain that JavaScript OO is prototypical and that `class` is just syntactic sugar over it. "Class is useless" is your opinion, not a fact. I made some choices for this beginner-oriented book, if you don't like them, don't read the book. Or better yet, try writing yours and see how easy it is.
Nope, no spam, no paid courses. The stretch goal of 1500 people was to make the entire course free -- it's now going to be free! :) 
Some employers don't recognize Coursera certificates either. Nothing you can do to control that. But *some* employers DO recognize certificates. I'm the teacher the by the way. More info on me in the video, if you watched it. Kinda lacking room for the "about me" spot on that page. Definitely solid feedback though, thank you! 
Definitely not a fake. Message me if you want more deets. :) 
The score board isn't updating. 
[removed]
Yeah, but I was wondering how to apply a binary operation on a floating point number? See [this](https://stackoverflow.com/a/1723938/2545680)
You can't really judge whether something is "all the way" prototypal based on how fast it runs, because JS engines are optimized for specific usage patterns. I also wanted to share my results of your benchmark. performance $ node performanceBenchmark.js prototype x 6,493,731 ops/sec ¬±2.73% (82 runs sampled) class x 6,827,160 ops/sec ¬±1.81% (81 runs sampled) closure x 3,425,522 ops/sec ¬±1.71% (83 runs sampled) OLOO x 4,720,582 ops/sec ¬±1.02% (87 runs sampled) Fastest is class This was run on node v7.10.0.
Hi /u/Huskar, if you have a specific question and have already attempted to answer it, then we're more than glad to help, but we're not going to do your work/homework for you.
Or just post them?
Also consider that PhantomJS is a huge pain to debug *when* (not if) you encounter a quirk. If you have a reason not to use your framework's provided AOT rendering tools, I would suggest headless Chrome over Phantom. Edit: Also PhantomJS's lead dev stepped down in the wake of the headless Chrome announcement: https://groups.google.com/forum/m/#!topic/phantomjs/9aI5d-LDuNE
 const fizzBuzz = (max) =&gt; { const getChar = (num) =&gt; { const BASE_NUM = 88; const FIZZ_BUZZ = [10, 4, 3, 12, 5]; let char = BASE_NUM; for (var i = 0; i &lt; num; i++) { char += FIZZ_BUZZ[i]; } return String.fromCharCode(char); }; const fizz = [2, 3, 5, 5].map(getChar).join(''); const buzz = [1, 4, 5, 5].map(getChar).join(''); let output = ''; for (let i = 1; i &lt;= max; i++) { output = ''; if (i % 3 === 0) output += fizz; if (i % 5 === 0) output += buzz; if (output.length === 0) output = i; console.log(output); } }
hello! this isn't work or homework, im just trying to get rid of youtube's new layout because it interferes with my extensions. as im a complete newbie, i just wanted to know where i should put "youtube.com" and where i should put &amp;disable_polymer=true i tried changing it for "value" but that didn't work, i'm sorry if what im asking is a lot of work without me realizing, it seemed to me to be a 10 minute thing for someone that knows the language.
Good point, I could just post them. Do ya one better though: [the intro video (YouTube)](https://www.youtube.com/watch?v=zcESJDwXPZU) basically has all the details and won't bore you to death. 
Video linked by /u/KalobTaulien: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Welcome to JavaScript Essentials](https://youtube.com/watch?v=zcESJDwXPZU)|Arkmont School|2017-08-05|0:03:19|3+ (100%)|752 &gt; New JavaScript course by Kalob Taulien. Preregister to get... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/KalobTaulien ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dlaavs0\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.3b
Sooo what is it ?
Universal code splitting made easy for webpack + React
Yeah sorry, we don't take requests here. 
JavaScript casts the number to a 32 bit integer, then performs the actions. They don't make sense otherwise. 
Does a PWA make sense for a blog, though? One of my issues is that it serves data from the last time it cached, which means that your visitors won't see the latest data when they arrive. They'll see the data that was available last time they were there. If there's a way around this (and still make it fully work offline) I'd love to know about it.
How is rxDb for latency ? if its base on couchDb sync model, its eventual consitency type of realtime ? Like 300ms+ for a user to receive updates from another user changes. I moved from pouchDb/CouchDb combination because it was too slow for our use, turned to horizon.js but... the whole rethink fiasco made it forgotten. I think gun.db could be awesome but i can't bring myself to trust it, still on horizon, despite current status, looking for an alternative. Doing live classroom with webrtc and whiteboards, need low latency realtime for whiteboard specifically, think rxDb could achieve this ?
alright, i wasn't aware of that when i posted, i didnt see it in the rules. would you know of any place that would help me?
That's the expected way of working. How you can do it is by sending a notification from the service worker when there is an update
Thanks Jodraws! You're on right! It's because Firebase paginates the scoreboard when more of 100 items are stored in the DB. I will take a look how to fix this.
But why not UUIDs?
&gt; Disclaimer: RxDB-maintainer here RxDB is based on pouchdb and when you sync, it is using exactly the same couchdb-sync-algorithm. So in the end, the sync of RxDB will not be faster than using pouchdb/couchdb. But there is more: * If you have very big and complex documents, you can speed up the synchronisation with RxDB's KeyCompression. * If you want to quick-sync a given set of data very fast, you can grep the json-state from the server with a single request and import it with RxDatabase.importDump(). * Also its possible to optimise synchronisation by using the sync()-function with a given query so only the last revisions of the matching documents will be synchronised (this is also possible with pouchdb). What will be faster is the event-propagation over multiple browser tabs and reactive queries because of the QueryChangeDetection. &gt; EDIT: Formating
I prefer arrow functions instead of using .bind(this) everywhere. Also I prefer anonymous inner functions over short named functions that only updates state. But I guess it comes down to taste. If I needs to revert to initial state like a form reset or something I usually declare a initialState const outside of the class instead of a function for it like on your entry page. I get you do this because of your Java background ;) Otherwise it looks like a good start. Good luck :)
And that's why I'd say it's not the same under the hood. Fact it's optimised differently could cause in very extreme situations different behaviour. Also, benchmark for me on node v8.2.1 prototype x 819,947 ops/sec ¬±0.90% (87 runs sampled) class x 789,045 ops/sec ¬±1.16% (86 runs sampled) closure x 578,204 ops/sec ¬±3.67% (74 runs sampled) OLOO x 791,297 ops/sec ¬±1.70% (86 runs sampled) Fastest is prototype
Hasn't this not been a problem for a while? &gt; const a = () =&gt; { throw new Error() } undefined &gt; const b = () =&gt; a() undefined &gt; const c = () =&gt; b() undefined &gt; b() Error at a (repl:1:25) at b (repl:1:17) at repl:1:1 at sigintHandlersWrap (vm.js:22:35) at sigintHandlersWrap (vm.js:73:12) at ContextifyScript.Script.runInThisContext (vm.js:21:12) at REPLServer.defaultEval (repl.js:340:29) at bound (domain.js:280:14) at REPLServer.runBound [as eval] (domain.js:293:12) at REPLServer.&lt;anonymous&gt; (repl.js:538:10)
Super simple poker game. Make a deck of cards, shuffle it, deal it, and run a hand. I don't play poker myself so I can't remember what the variant is called. It might actually be black Jack? but I'd would be looking for dynamic arrays built with loops, memory usage, and logic comparisons.
The only situation I've ever seen it in practice was like this: function recursiveFunction(num = 0) { if(num &lt; limit) { num++; recursiveFunction(num); } else { doFinalThing(); } } recursiveFunction(); but that seems unnecessarily difficult when you could just do this: for (var i = 0; i &lt; limit; i++) { doStuff(); } doFinalThing();
Is there a way to re-pull the data and get the updated data, other than making the user reload the page completely? Or does the new service worker only take effect after an actual refresh?
On EntryPage, you have a method down below the render method, I've never seen anything below render before this so I'd say it hurts readability a bit (and the lint config that I use would complain). I see you're using var quite a bit - prefer const and let in es6. The NotActivated page should be turned into a 'stateless functional component'. On the SubmitCampaignData page, near the bottom you're using window.location - I didn't read everything closely so maybe this is what uou want, but usually I'd use react router's push method there. Usually people recommend having just a few 'containers' that have state and methods, then have more stateless components to hold each part of the views. But honestly the way you set this up looks pretty good to me. 
what steps have you taken to try and get it working? Please list in detail.
Dang, nicely done youtube bot. That's awesome haha. 
 document.getElementById("nav-main").querySelector("i").style.display = "block" document.getElementById("menu-show").querySelector("i").style.display = "none"
That one's not anonymous, tho ;)
how do you get the course? didn't get a link after I pre-registered
interesting but if someone would write this in a real app and I would have to work with it..I would break my Laptop on his/her head :)
I see what you did, there.
You'll get a link to the course soon. Think of it like a Kickstarter -- at the end of the campaign you get the link. But I'm working on getting that to you sooner.. because waiting sucks. :) 
From the site you could have read: &gt; It uses more symbols than UUID (A-Za-z0-9_~) and has the same number of unique options in just 22 symbols instead of 36 Though I doubt the difference is going to be significant. It won't save a lot of bandwidth per URL, pages containing many URLs with IDs in are likely to be compressed which will likely get the same saving, and if the character count is a concern for storage then your database is wrong (UUIDs are best stored in a binary type rather than a hex string or this format), and it still isn't going to be something you want to type as a user (even less pass on verbally or in writing).
well, it is a bit of a chicken and an egg. using jquery can help familiarize you with traversing the dom. fwiw the need for jquery has diminished a lot since the browsers have largely standardized on dom access, so you don't see a lot of enthusiasm for it these days. either way you need to know how the dom works.
Yes, that's correct. I thought you didn't understand why as you wrote `Because why the hell not I guess.`
I just realized that one way to possibly handle this is to have an additional Ajax call that looks for newer data and then merges it in with the old and displays it. It would show the old stuff instantly and then pull in the new stuff after, which is the best of both worlds. The new data would have to be a different URL than the original, of course.
It's merely confusing haha. I've been doing a lot with bitwise representations and weird things happen at the integer boundary. 
You have a few components that neither have state nor use lifecycle methods. You could use normal functions instead. I wouldn't say it's a clear improvement, but it's kinda best practice. Check out the container and presentational components pattern to learn more.
 document.addEventListener('DOMContentLoaded', function () { var menuEl = document.getElementById('menu-show'); var menuCloseEl = document.getElementById('menu-close'); menuEl.addEventListener('click', function () { menuEl.style.display = 'none'; }); menuCloseEl.addEventListener('click', function () { menuEl.style.display = 'block'; }); });
Cool! But pretty damn useless in real life
Next level; anonymous recursion without function reference. 
No, jQuery is meant to make this easy for you.
Seems okey, but please don't promote `picodom` and jbucaran, before you are absolutely sure what you are doing :D `pico-dom` is the original https://www.npmjs.com/package/pico-dom and look the npm profile of Jorge - 400 empty packages, just for saving the names - okey, probably not all of them are absolutely empty, but just scroll over them and you'll see what i'm talking about. Everything around is against npm rules and it's reported. (edit: damn, npm don't order them by name already? Before some few time, when you open his profile you can get shocked) edit2: just few lines of code to get the packages. https://gist.github.com/charlike/e155f6b7d0c3943ce41405dcd7cfc845 http://i.imgur.com/K4uaMtP.png
Just because you can, doesn't mean you should.
How plugins are called is not really my question. as the speaker says, ask the sandbox for what you need. So to word this differently, my plugin needs [whatever_module] and [whatever_module] is bundled with the webapp. I'm trying to figure out if it's possible to have an approach where I can dynamically load this plugin, and provide it with [whatever_module] in a way where the plugin can ask for it using standard require / import syntax. And thus, in a plugin project, you would configure your bundler to treat those dependencies as externals that are provided, somehow, and when loaded dynamically in the webapp, the bundler's bootstrap code in the webapp can load this plugin and provide it with whatever module it's trying to load. While there are other ways to pass in these sorts of dependencies, such as the AMD-esque approach above (which is not the plugin asking the app for something, but instead it's the app giving the plugin everything), I'm hoping there is some sort of solution possible to avoid that.
Not sure if this really adds a value not present in other solutions... Looks like many other issue trackers / team tools...
Thanks, this will be a great addition to our company style guide. We are already writing all functions recursively, this will finally remove the bit of text! No need to localize our source code if it's all symbols, genius. 
Awesome! thank you! I can read/google javascript enough to know that this does the trick. If you dont mind i got a followup noobish question: I made a .js file and added you script. And then i imported it like this: @import url('../under-lindesnes/js/menufix.js'); And i can now find it if i inspect the page, but the function does not seem to work
Importing is for CSS. Instead, add a script tag to your page. &lt;script src="toggleMenuFix.js"&gt;&lt;/script&gt;
yep, you're right. I apologize for my pre-coffee, mobile-only, hungover, poorly crafted analysis. I have actual criticisms but this is overall a pretty good reference and I won't nit pick it.
In Chrome or V8, sure, but not everyone is there.
Well, you sir are a genius. Thanks - nailed it :)
I highly recommend it-just the fact that it forces you to write a type defs/documentation is a huge step up from regular REST api. 
Totally! Fair enough. I'm pretty lucky we don't have to support old browser vendors.
I don't see how this is any more an example of "anonymous recursion" than the below: var f = function(l) { console.log(l); f( l.slice(1) ); } In both cases, the anonymous function is bound to f. I get that your example is more of a functional style though.
jQuery is just a helper library. A tool to make things simpler. But keep this in mind. What can you do when jQuery is not available?
Precisely right. Var f = function(){} is technically anonymous, which is all this mess boils down to.
The best analogy of GraphQL is that it's similar to what a WSDL is to a SOAP service. It defines the schema of your web service (i.e. the shape of your data). REST is amazingly powerful and it's completely free form, however one of the pain points with REST is that there's no real standard for defining a schema or documenting how it works (although there are some nice tools like Swagger for this).
Honest question: why? Why use this over CSS?
Nevermind, my reply was a bit brutal too. And I'm interested in your post-coffee criticisms :)
The comma separated query parameters ```fields``` (e.g. fields=id,name) and ```expand```(sub resource expansion) are not that hard to implement, which will reduce under- and overfetching. Have a look into oData if you don't know what I mean. The biggest advantage is standardization imo. (If you didn't know, REST is an architectural design principle, not a standard.)
You use `axios` in many React component which has consequences: * you couple your code to `axios` library (what if you wanted to use some other ajax library?) * because you pass urls to `axios`, you entangle your components with the specific urls. You won't be able to use them in other contexts * and vice versa: you scatter your url config all over the place. If you will want to change server name from `localhost`, you will have to change it in many places. It's anti-DRY). * because your components connect to the network (via axios), it will be harder to test them. * you assume that data will be gotten via AJAX, so your components are coupled with the data retrieval mechanism (what if you would like to get data via web sockets or from localStorage?) It would be better if all AJAX calls would be hidden under the abstraction in some separate module. View should not directly make AJAX calls (if you want to make a scalable and maintainable solution). 
It says the user was suspended.
This is good, I can run linear regression to see if my users will forget to press the submit button on my form! 
Anonymous recursion hasn't truly worked in javascript since they took out the callee property. I miss those days.
Read the first 4 sections of this tutorial https://www.howtographql.com/basics/0-introduction
Team mates must be hate this guy.
Wouldn't it just be easier to auto save fields as they change or make the submit button more visible lol
CSS in javascript is necessary for many animations. I see questions like this (or someone saying it's a trend that needs to go away) whenever something to do with CSS in javascript is posted. I guess many front end developers never need to work with animation. 
in the world of pure functional programming you can't have variables! except function arguments, which are variables but don't count.
well you can do `(function foo() { foo(); })();` but yes it's not really anonymous as `arguments.callee` would be since you must know the function name. But arguments.callee is not gone and you can still use it, and probably can for the very long term future since backwards-compatibility is very important for JS. Just not in strict mode. 
The benefit is you get exactly the data that you request, as opposed to a traditional API that gives you a ton of JSON data you have to parse and figure out what information you actually need, and a GraphQL query is a lot easier to put together and read than a long, cryptic query string.
This always reminds me off the conceptual difference between raster vs vector in graphics for some reason. 
Do you know about [TypeScript](https://www.typescriptlang.org/)? &gt; ‚ÄúTypeScript helped us to reuse the team‚Äôs knowledge and to keep the same team velocity by providing the same excellent developer experience as C# ... A huge improvement over plain JavaScript.‚Äù &gt; &gt; ‚Äî Valio Stoychev, PM Lead - NativeScript
Pretty cool project, connecting multiple databases ( at one ) to GraphQL is of particular interest to me ( Redis and Neo4j ). Hopefully it helps with getting that working!
Where would this capable community be without a weekly article on variable declaration?
I agree. I like to think of it as recursive currying which is important for functional programming since a traditional for loop is imperative. The OP code is not very enticing.
I fail to see the point. As you noted at the end of the readme, "Creating a new object every time you access into the ValMap will likely create a lot of garbage". So you're better off keeping a reference to the actual key, which means you can use Map as designed. Yet, it seems your design is explicitly for the case where you want to recreate the key every time. But looking at the code, your _getKeyHash function basically returns JSON.stringify(key) and uses the resulting string to get the actual key from the keyStore. That's fragile because even the order of properties in a stringified object is based on the order in which they were defined. &gt; JSON.stringify({a: 1, b: 2}) "{"a":1,"b":2}" &gt; JSON.stringify({b: 2, a: 1}) "{"b":2,"a":1}" 
I've watched some presentations given by Anders about the language but have never tried it out. Do you find that you keep the flexible, non-hierarchical designs that JavaScript naturally lends itself when using TypeScript? I'm trying to avoid classes and inheritance. Ideally, I'd love to just have a tool that parses any module exports and can tell when I may be consuming it incorrectly
What's "not working" mean? What do you get when you console.log(surround)? 
It just writes s[a]
My solution to anything jQuery is to use Vanilla JS since jQuery has no purpose other than to add 50 KB
You shouldn't create any classes to use TypeScript. You can create function by yourself or export it from npm, and TypeScript will tell you when you call function with wrong arguments. Just look at the [beginners guide](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html) The downside of TypeScript (like any other js-improvers, IMHO): if you got a job at the company when people have a lot of legacy source code written on js you may not be able to migrate to TypeScript. So, it's ok to start writing new project on it, or rewrite a small one. Also, some programmers use Facebook Flow
I wouldn't say you *shouldn't* create classes in typescript. I would say you shouldn't create classes in typescript if you weren't going to in Javascript anyway. Also ts has a new ability to include js files in ts code bases.
You have ' or " around the line
Are you sure index "b" exists in f?
Thanks for the reply and better explanation. I didn't know about this feature.
OP's trick is to get a variable by putting the whole mess into a function which is passed itself for no other reason than to obtain a name... its like a really awkward way to give a function a name.
Yea this seems like a bad idea at best.
Typescript can just be JS with type annotations. But even without that information, tooling can provide code hints giving you insight into the signatures of functions and methods as you use them. Lately I've been using [VS Code](https://code.visualstudio.com/) and been enjoying it. It does a lot for you out of the box and has plenty of extensions to do more where it might not. https://code.visualstudio.com/images/intellisense_intellisense_icons.png
As said, you most definitely can, but it's a lot slower to fire up a PhantomJS instance for every request, than to just render a string in node (not too experienced with Angular but in react it's a simple renderToString function). JSDOM can be faster than Phantom (in some/most cases, although it has its own limitations). I did a small [benchmark](https://github.com/laggingreflex/scrapers-benchmarks#scrapers-benchmarks) (zombie uses jsdom). It's for scraping but I think the performance is still relevant, especially when compared to 'request' which is the fastest it can be. Also checkout this wonderfully written article on the subject: https://medium.com/@gajus/pre-rendering-spa-for-seo-and-improved-perceived-page-loading-speed-47075aa16d24. 
You're looking for Flow, Facebook's alternative to TypeScript. Flow doesn't require you to write JavaScript any certain way. It'll just parse your existing code, including trying to parse your dependencies/imports, and will give you compile time errors when you call methods in a way that the compiler will likely fail on at runtime. If you dive into flow, one thing to remember that the docs don't always make clear: you do not need to start annotating your JS with type hints -- you can if you want, and it'll give you better checking. But all you have to do to get started is download the flow-bin package, put /* Flow */ at the top of your JS file(s) and run the checker. 
This is definitely cool in one of those, "Huh, that's neat" ways. Personally, I strive for readability over terseness, and recommend others do the same. Still cool, and knowing what's possible‚Äîregardless of whether or not you should use it in practice‚Äîis always a plus.
&gt;Flow doesn't require you to write JavaScript any certain way. Neither does typescript. It is 100% opt in. The only exception is if you turn implicit any off inside the tsconfig and then you need to add typing information where it can't be inferred.
That's fair. The more choices we have for picking the right tool, the better. I've only read about TS and taken a look at TS projects (vs. implementing using Flow). I'll have to take a look at TS more closely. 
Isn't a traditional for loop 'declaritive'?
Please, for the love of DOS don't say OS.
No. Imperative has a procedural flow and in the example of a for loop the code dictates how to loop through the collection or array. The key word is how. This also creates a lot of mutating state, like the current index, the current iteration value, the upper bound, etc.
Another, directly from Google‚Ä¶ "deeplearn.js is an open source hardware-accelerated JavaScript library for machine intelligence." via https://pair-code.github.io/deeplearnjs/ also see https://ai.google/pair
Pfft, so old fashioned!
&gt; I fail to see the point. As you noted at the end of the readme, "Creating a new object every time you access into the ValMap will likely create a lot of garbage". So you're better off keeping a reference to the actual key, which means you can use Map as designed. Yet, it seems your design is explicitly for the case where you want to recreate the key every time. I mean, it's a very common pattern in Python. I'm not sure how they manage, or if they just live with the fact that a lot of garbage is created. Having to track keys separately is tedious, and creates boilerplate code that has nothing to do with your actual algorithm. It's unnecessary complexity when the data structure could be managing the keys internally. &gt; That's fragile because even the order of properties in a stringified object is based on the order in which they were defined. I hadn't considered that. I went with JSON.stringify out of laziness, mostly. I think it serves for the purposes of a proof of concept.
Care to elaborate? Implementation details aside, this is how dictionaries work in Python. Trying to work with Maps in Javascript is incredibly tedious.
This article crashes my browser (chrome on android).
[Beware](https://www.reddit.com/r/javascript/comments/3x91ac/why_not_to_hire_people_who_like_es6_classes/cy2o6zj/)^1 [referencing](https://www.reddit.com/r/javascript/comments/6q2lk0/why_composition_is_harder_with_classes/dku34cl/)^2 or [learning](https://www.reddit.com/r/javascript/comments/5c5lkq/what_eric_elliot_wants_to_say_can_somebody/d9u6tv3/)^3 from Eric Elliott.
Dope! I've been interested in machine learning for while now. Guess I'll start learning it.
If you're not familiar with JS or DOM APIs don't use jQuery while you're learning. There's a lot of important things that jQuery glosses over.
Sorry for everyone, I try to dynamically generate blur effects, and use a lot of inline style, in the latest version, I support the css-in-js and inline-style two solutions. Anyway, the rendering speed should be much faster than before.
I see that others have already replied to your question. Here is an additional thing to watch out for: if one is using the `id` attribute to identify elements (e.g., `getElementById('#elementId')` or `$('#elementID')`), then one should also use that attribute with the `a` element. Starting with HTML5, `a#elementId` matches `&lt;a id="elementId"&gt;...&lt;/a&gt;`, but *not* `&lt;a name="elementId"&gt;...&lt;/a&gt;`. The latter can only be matched with `a[name=elementId]`, and should be avoided nowadays. This is something to keep in mind if one is using `a` elements to create buttons (which is occasionally useful when building Bootstrap sites).
If you are using namespaces, then the expression syntax is the only option.^1 This will work: var namespace = {} namespace.f = function (x) { return x } This will *not* work: function namespace.f (x) { return x } ^1 Ignoring the ugly option of declaring the function *within* the curly braces of the *namespace* object, i.e., `var namespace = { f: f (x) { return x } }`.
Get a machine to learn it for you. 
Oh, this will serve as a perfect job interview question. A great reason to stand up, slowly walk back to the door, turn around and RUN LIKE YOU ARE CHASED BY NETSCAPE.
&gt; Say the plugin uses lodash. Well, if the app includes lodash as part of the platform then it should expose it through an API. Sure, so how can that API be import/require()? I don't want to re-invent the wheel. &gt; If not, you'll end up having the plugins tightly coupled to particular versions of lodash and get in a mess quickly. That can be up to the author to decide. If the author wants to include libraries that are already part of the core, they can. I'd prefer they didn't. We are not disagreeing here you realise...
https://github.com/fatman-/easy-undo - A simple JavaScript undo/redo interface; for easy management of 'state' histories in an application; based on a similar older project
ok, I'm starting to think I'm not explaining myself clearly because it does not seem service workers are even relevant here. Let's pretend webpack is a requirement. I create a "vendor bundle" with webpack. Now I want an external script that is loaded dynamically at runtime, that the main app bundle is unaware of at compile time, to reuse that vendor bundle. I hope that clears things up a bit.
Test defensively, when things already work, before they break. Sometimes, if you have a very clear idea of what you want to make, you may even want to write your tests before doing anything else. The idea is that once you have good unit test coverage, you can make changes with confidence, allowing you to refactor big chunks of code and easily check that the functionality has not changed.
Thanks for the reply! So I should test any function I create essentially? Even if there's visual evidence that it works in my console or webpage?
Exactly. Some things Elliot writes aren't bad (and he obviously knows a lot), but I would always check what he's saying. Also, his way of thinking is very black and white and he doesn't take constructive criticism seriously. More often than not, he only answers to comments he has a clever answer to and ignores the rest. However, /u/cujarrett, I think it's great that you made your first open source repository. Cheers mate :)
In a professional context, yeah. Any time you expect others to have to understand and modify your code, you should definitely be creating unit tests. This includes yourself, it's perfectly possible to be confused by something you've written yourself, particularly if you haven't seen it in a while. Tests also act as documentation of a sort, as you're stated the expected inputs and outputs when you create them.
It's always good to have a solid understanding of the "vanilla" language before using a library. That being said, I don't think you *have* to start with Vanilla JS. Just make sure to understand what's jQuery code and what is not. One of the latest shop talk episodes discusses this in some length, if you're interested: http://shoptalkshow.com/episodes/274-vanilla-js-chris-ferdinandi/
Well, for one thing, you're not making a map, you're making an object with a collection of string keys (which you could always do with javascript). With maps, the key is the container, not the contents. So with a map, this works: const mappy = new Map() const taco = {yum: 'yum'} const burrito = {yum: 'yum'} console.log(taco === burrito) //false console.log(taco) // { yum: 'yum' } console.log(burrito) // { yum: 'yum' } mappy.set(taco, 'taco') // Map { { yum: 'yum' } =&gt; 'taco' } mappy.get(taco) // 'taco' mappy.get(burrito) // undefined taco.type = 'crispy' console.log(taco); // { yum: 'yum', type: 'crispy' } mappy.get(taco) // 'taco' Even though I added properties onto the taco key, it still fetched my information. Your implementation breaks this: const vally = new ValMap(); const taco = {yum: 'yum'} const burrito = {yum: 'yum'} console.log(taco) // { yum: 'yum' } console.log(burrito) // { yum: 'yum' } vally.set(taco, 'taco') /* ValMap { { yum: 'yum' } =&gt; 'taco', keyStore: { '{"yum":"yum"}': { yum: 'yum' } }, disableToStringHash: false, preventUndefinedKey: true } */ vally.get(taco) // 'taco' vally.get(burrito) //'taco' taco.type = 'crispy' console.log(taco) // { yum: 'yum', type: 'crispy' } vally.get(taco) // undefined vally.get(burrito) //'taco' Just keep in mind that what you're doing is no longer a map. You're creating something map-like, but it breaks the fundamental features of a map. I'm not as familiar with Python, but I believe an object is a much closer match to a dictionary than a map. Your "class ValMap extends Map" could just as well be "class ValMap extends Object".
Since `@cycle/http` uses `superagent` under the hood, have you tried searching for that instead? Not sure if it'll be helpful, but this article was near the top of my Google results for 'superagent file upload'. https://blog.gaya.ninja/articles/uploading-files-superagent-in-browser/
Part of the reason you unit test things that you know work is to prevent regressions. How many times have you added a feature to working code only to later find that you broke something else? It gives you some security when you add new features or refactor code, to know that you didn't break anything. Plus, tests aren't just for you! They are also for the people who inherit your code later. Try contributing to an open-source project that you didn't write. How do you add a feature or fix a bug and know that you didn't break anything? You couldn't reasonably manually test something like Angular if you tried to make a contribution to their open-source GitHub repo. I don't test everything in my javascript because some of it is hard to test or just too fragile if it deals with what actually appears on screen (like I might test of a class exists on an element, but not the exact HTML structure because it is too subject to change). I do test anything that has non-trivial logic in it. In Backbone applications I unit test my Models' AJAX calls (with mockjax stubs), validations (like required fields and min/max lengths), and default values. When I receive a bug report, my first step is to attempt to write a (failing) test to prove that it is broken. Then I investigate and fix the code. When the test now passes and doesn't cause any other tests to fail, I know I've fixed the bug and the test will prevent any regressions in the future. Don't be surprised if you have more test code than actual code for some functions!
yes, I read that article, I had most of the code correct. multipart boundary error was due to me setting type parameter (content-type) of http request manually. not specifying it resulted in correct content-type header param with multipart boundary part.
Hi /u/Entrepreneur2015, if you have a specific question and have already attempted to answer it, then we're more than glad to help, but we're not going to do your work/homework for you.
Hi /u/cezarlz, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
It's a great module, but it is fairly big to embed in a web build if you just need a single feature from it. In that case, see if you can extract it or find a simpler library.
I just wanted a few pointers and I find your attitude a bit aggresive for a moderator maybe someone might feel inclined to help me or direct me towards a professional service who might help me. just my two cents
Why for each request? We just need to do it once at server startup, then we can send the to client the same rendered client. Thank you for the article 
Well thank you fucking prick I hope the power abuse makes up for the sad sight you have to see everyday in the mirror
To be perfectly honest, moment caused a lot of trouble to me when used with webpack... not sure which of them caused them, but eventually I had to out opt of moment. Shame, because the lib itself is great. 
Interesting, I haven't encountered that problem when using the lib and webpack to build.
&gt;The API is not imported/required. The core passes the API to the plug-in when it loads it. It's not reinventing the wheel, really; it's pretty normal. yes, but this allows the plugin to "speak" to the app or vice versa. I am not talking about this in any way whatosever ;) My question has little to do with how a plugin is called or instantiated (though this may be impacted) and has everything to do with how to share resources that the app ships with, with the plugin itself. Again, in your example, I can expose libs like Vue, axios, D3, etc etc etc in "coreAPI", but this is not natural, this won't work well with your IDEs, it's just generally an "unnatural" way of doing things. All I want in life, is for PLUGIN.JS to do import * as d3 from 'd3', and d3 is provided by the bootstrap code of webpack or browserify or whatever. This also has an impact on the idea of shared libs that are themselves, plugins. eg: two plugins generate very different graphs with teh same data, so the fetching of that data is handled by a third plugin that the two plugins depend on. That's another justification for what I'm trying to do.
Agreed. If you just want to use a single function one time on the frontend, you can just write a custom function. For bigger apps or for node it's worthwhile. The FE is always a balancing act between size and usefulness.
You sure need a lot of hand-holding for an _entrepreneur_. edit: The previous response was a canned response that we've been using for over a year, and you're the first to complain about the tone. Make of that what you will.
Excuse me for trying to get the information at the right place. go back on your high horse retard.
Use search()
How?
[date-fns](https://github.com/date-fns/date-fns) is a great alternative in many cases.
It depends on what you actually want to do. If you're trying to make dynamic web-pages/applications, then i'd start by at least mentioning that jquery is a little antiquated and dom traversal is not the optimal way of handling application state. You need to know neither of the two. Even when jquery was still widely used it was basically a helper meant to abstract the dom. But nowadays, if you pick a framework, jquery is 100% obsolete and the dom isn't much more than an implementation detail that happens to be there in the browser but other than that you don't use and/or traverse it ever. The only command you will encounter in a contemporary application, once, is document.querySelector to pick the applications mounting point.
You can use [`String.prototype.match()`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/match) and check/assign the return value appropriately (`match` returns an array with entire matched result or `null` if no match).
The point of ValMap is to treat an object in the same way as a primitive: as a piece data. Map doesn't allow you to have two different `1` keys, so why should there be two different `{x: 1, y: 1}` keys representing a point? The point is to be able to create a mapping between KeyObject -&gt; ValueObject where KeyObject is identified by its contents, rather than its reference, which I believe is much more useful in general. So yes, your example doesn't work because the mechanics of ValMap are different from Map. 
Disclosure: Self-post
something like this: `var match = input.match(regExp)` ? this will test if my entire string matches the regexp and not just a substring of it?
The employed you of 2040 won‚Äôt regret it. 
&gt; A tool similar to Angular, Vue, and React You may as well say "an animal like a dog, cat and dolphin." I would look at the source to see what it does, but you've only provided a minified version with no documentation other than the vision statements in your readme. 
Instead of having Col-xs-7 and col-xs-5 as siblings within a row, the col-xs-5 was inside of it's own row. To take advantage of Bootstrap's grid you need to nest your cols inside of a row. You can think of a bootstrap row as a row in a table if that helps your visualize it. I edited your code a bit, I think it suits your needs. You can see that I moved &lt;div className="row"&gt; into your return statement, and let Charts be in charge of the col-xs-7 https://codesandbox.io/s/KZrvOxlPr 
Yes, that would be how to do it. What exactly gets matched depends on the `regExp` you pass. To test for a substring match, you might do something like: var input = 'abcdef'; var regExp = /b[a-z]{2}e/; // match the letter "b" followed by 2 letters followed by the letter "e" var match = input.match(regExp); The above would find the substring and output `['bcde', index: 1, input: 'abcdef']`. From there you can extract the matched substring :) 
Thank you!
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/search There is an example towards the middle of the document.
`search` would not be appropriate for this use case as OP also wants the matched substring. `search` only returns the index of the match. Unless your comment was subtly meta...
&gt; Unless your comment was subtly meta... Take your upvote you smarty pants
Moment added some 300KB to my minified build. What type of project would make this justifiable?
By the way how to say followed by white space in regexp?
`\s` matches a whitespace character. [Reference](http://www.regular-expressions.info/shorthand.html).
ELI5 answer: You could walk a couple of miles from your home to work every day, but would you do it? Probably not unless you work very close to your home. In the same way your approach works because your example is trivial. Once you start having hundreds of functions to update the DOM you have already wasted a lot of time writing boilerplate code and your project becomes exponentially unmaintainable.
Don't let hype for the fancy things cloud your judgement. Sometimes HOFs are indeed the right choice, but you should pick your tools to suit your problems, not pick your tools first and then figure out how you can solve the current problem with those. The simpler a solution is, the better. Your future self will thank you.
Please forgive my English ability, I don't think you've seen the API link in my gihub home page This is only the beta version, with only 5 basic instructions and 5 basic options I must admit that it is not perfect now But i think you deserve to have a try
You could use an E4X parser such as [this one](https://github.com/eligrey/e4x.js/). That would get you an object and then simply `JSON.stringify()`.
TL;DR: We chose React because we just discovered data binding in 2017 
1) Validate regex array parameter before opening the file. BTW the file remains opened in this case now. 2) Let users pass encoding instead of hard-coding utf-8 3) What about cases where matching string is read in separate chunks? There might be cases when you'll have to read the whole file and check its content against regex to determine whether they match.
I'm guessing that's when including locales?
Oh I'm sorry I didn't see the links. You may want to consider adding those to your Github repo as pages and definitely providing a full source.
At this point you are a well known author of quality javascript articles. You probably don't have to disclose your self-posts anymore ;)
The codeblocks in the api are very strangely formatted which makes it awkward to read. Maybe run them through a standard formatter (prettier, or whatever)
Correction: this is not the right place. This subreddit is for discussing JavaScript, and getting help with specific questions. It is not a place for you to outsource your work to.
Regarding the reply in another answer of you, I wouldn't test *every* function you write. What a Unit is is something you can debate about with your team or yourself. The problem with writing a test for every function is that it makes your tests brittle, if you decide to move things around while refactoring, those tests will fail, while functionally your component might still do the same thing. Instead I'd opt to write unit tests for the functions that have complexity to them (as in, hard to reason about etc) that you can't, or don't have time for, reorganize or clean up. This way if you modify something, that specific unit test will warn you if the changes you made afterwards didn't break it. (or in general, do write unit tests for functions that are inherent complex) Most of my components are tested as a black box, you'd use em in your tests like you do in your application &amp; you test how they behave. If I have a table component, I'd simulate clicking the order icon &amp; verify that the items appear in the correct order. (By checking DOM node orders &amp; content etc). If I have a form component or something that goes server side, I'd verify that the correct POST or GET call goes out when I press enter or click "submit". It still tests the specific component so it'll run fast but perhaps doesn't make sense in the bigger picture (that's where E2E tests come in), but you'll know something is wrong much faster. As with all it's a balance excercise between unit/functional/acceptance tests so don't expect to get it right, but testing each function shouldn't be the goal, you want to know if something functionally works as intended &amp; you want em to fail fast if something is wrong.
Thank you for your advice! I will improve 
IIRC locales were installed as a separate repo
Wow, thank you for taking the time to write an amazing in depth explanation. This community is great!
Thanks, i am definitely taking this points 1 and 2 into my consideration. However, covering point 3 when matching must be spreaded in the whole file i am not sure about it. PR is welcome of course.
Hey again, I am not good at regexp so I found this one that detects youtube URLs: `/^(ftp.*|http.*|https.*|www.*|web.*)(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&amp;v=|\?v=)([^#\&amp;\?]*)/` However, it works only if the entire input is a youtube URL. I removed the `^` symbol in the beginning and now it tolerates words before the URL, something like `bla bla bla [youtube link]` but it still doesn't accept words after the URL like `[youtube link] bla bla bla` Can you help me with that? the final goal is to have a regexp that detects youtube links within `bla bla [youtube link] bla bla` Thanks!
On the internet, there's _always_ someone who will whine about stuff like self-disclosure. But yes, I have no problems with authors of high-quality material publishing links to their own posts. Nothing wrong with a bit of self-advertising, especially if it's going to be useful to the rest of us. (Disclosure: I too am an author of hopefully high-quality articles, and also self-advertise :) )
As you mentioned I noticed the problem too After that, I'll apply for a domain name of my own, You can test this item freely
That he continues to do so is a sign of integrity.
The last portion of the regex `([^#\&amp;\?]*)` which matches the Youtube video ID at the end of the URL says "match any amount of characters not present within the set (square parentheses), so you should add any characters you expect to follow the URL in the original string to that set. If your input source is HTML then you might expect double quotes to follow, so you would change the last portion to `([^#\&amp;\?"]*)`.
moment-timezone, yes, which has three versions, depending on how much data you need.
I had no idea what a DOM is when I first started to use jquery so I guess you also should be fine. 
Thanks, but it still doesn't work. I am using this Jsfiddle to test it: https://jsfiddle.net/cpjushnn/172/ when I put a youtube link followed by some characters it says not valid
Finance. Enterprise. Reporting. Something real-time or close enough to it that you need to ensure you can correctly and accurately display times in locations that are not guaranteed to be the local machine's time zone. Something that depends heavily on date manipulations.
[This regex](https://regex101.com/r/oFWo8x/1) should match as you want (example in link).
Thanks a lot!!!
In case you guys are looking for the same implementation but non-blocking (async iterator), I experimented a bit a few days ago with async generators. https://github.com/rafaelkallis/lines-async-iterator
Apis seem natural to write unit tests for. What I have a problem writing unit tests for is javascript UI, particularly for react components. Not sure what to write and what to test. If someone with experience writing unit tests for react code would like to comment or provide some examples, I'd love you forever.
**Everything** Last night I discovered a package I maintain^1 had a bug. The package is basically one file with two small dependencies. It has just seven functions in it, and is 3.2 KB when compiled with dependencies and compressed by Browserify. It has 100% test coverage. But it still had a bug. I didn't think to test UUIDs with capital letters, which aren't handled by the `HEX` dictionary in `any-base`. The `uuid` library I use provides only lowercase UUIDs. So I followed a Test Driven Design principle, and wrote the test that *should* work which [proved that my current code was broken](https://travis-ci.org/oculus42/short-uuid/builds/262087383?utm_source=github_status&amp;utm_medium=notification). Then, I fixed the problem. Unit tests should prove proper *and* improper behavior. Even if a function seems small and obviously works, it can misbehave in ways you might not expect. Some of the common issues to watch are falsy tests instead of explicit false or undefined tests, `null` vs `undefined`, and type coercion problems. ^1 [short-uuid](https://www.npmjs.com/package/short-uuid)
Confession: It's less about self-promotion than sheer laziness: I outsource comment moderation to `/r/javascript` so that I don't need to wield my own banhammer and spam filters :-D
Yes. I'm currently working on a large single based web app. It's already market leader in the country I'm based, an now is expanding to other countries / timezones. Dates and times are very heavily involved and everything needs to adapt to the user's timezone / be internationalised so we use moment. It may be that we could look into replacing it with something smaller / something homebrew, but I think I'd class that as an optimisation, and as such leave it till later. 
You *can* do inheritance and classes in Typescript, but you probably shouldn't. Too many C# developers try to turn JS projects into an ASP.NET-looking monstrosities with 'base classes' and unnecessary inheritance. If you use TypeScript to define interfaces and simple object structures, you'll find your IDE catching a ton of bugs *while* writing code, instead of at run-time.
Don't forget about `moment-timezone`. As someone working in finance, we let the customer create, view, and edit financial transactions in a profile-specified timezone, regardless of their computer's timezone. The beautiful thing about moment-timezone is you can drop-in replace the plain moment.js and with a single line that sets the default timezone, everything is suddenly correct. We were able to fix international date line issues on the Bootstrap date picker we use that depends on Moment without modifying it at all. It's brilliant.
Tests aren't written WHEN things go wrong. Test are written BEFORE things go wrong. After you change your code because you need to add a feature or something, you run all the tests that you've already made, to verify that you didn't break anything. It might not just be visual bugs, but validation bugs, things that happen in memory and that you don't see. What to add to test? Well, what are the most difficult things to debug? What are the critical points of your application? Particularly, in javascript, it's hard to decide because many things you want to test are visual components, and they're hard to test. The thing is, you want to test small portions of your code, those that you can isolate (hence, the name "unit"). You don't test whether the input value you entered is stored correctly in the database after calling this service; no, that's testing the ENTIRE application, and that's what integration tests are about. Unit tests test the units, the small fractions of your code to make sure that INDIVIDUALLY, each part does the small individual task it's supposed to do. For example, your data validator, or your calendar, those things. "But all my code is tightly coupled! I can't isolate this input from that function or that popup!" A hah! Then you find that your code isn't testable because it's all interconnected in a spaghetti fashion. To unit test effectively, you need to rethink how you write your app, and that's up to you. 
Hard to justify such a bloated lib for anything that needs to execute on mobile, which is a lot of apps out there. Someone at work attempted to use `momentjs`, we figured out we only needed 1% of its 300KBs and updated an internal date utility instead. [YAGNI](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it) is your friend. The "You Should Be Using" sort of morphs into "You should look into it, weigh costs vs. benefits and maybe use it if it makes sense."
The call to fstat seems unnecessary. You can just break the loop when the call to read returns null.
Reg, you are such an awesome source of learning material. Thanks for putting your thoughts and other info out into the world!
onmouseover only registers an event handler for the onmouseover event. I need for a way to toggle that event programmatically while my mouse is not actually on the element.
No. That is another event. It's not a way to trigger that event and keep it active programmatically.
Hi /u/tpucci, please resubmit using the direct link (you can still mention it's a cross-post in the title if you wish).
If you use jQuery or it's queryselector motor, I suggest $(selector).trigger('eventname') it's also helpful to launch custom events on elements
Huh, I think that's the first time I've seen a G.K. Chesterton quote applied to programming.
Ok It looks like you can not do this due to security concerns. https://stackoverflow.com/questions/4347116/trigger-css-hover-with-js/17244507#17244507
In addition to what others are saying (which I agree with), flair also makes it kinda obvious: https://i.imgur.com/pOSwbSK.png
It's not the first time I've seen Chesterton's Fence applied - though I am not sure where I heard it first.
Ebay and facebook, the masters of beautiful and usable UI's are showing us how to do it! I'm jumping on this gravy train before you plebs migrate your enterprise projects off React.
Thank you for taking a look at the code. The official docs (https://nodejs.org/dist/latest-v8.x/docs/api/fs.html#fs_fs_read_fd_buffer_offset_length_position_callback) don't mention read() returning null. Therefore there might be a breaking change in the future. (Without trying it) I assume bytesRead === 0 in case all bytes have been read, so using fstat() should be unnecessary with the bytesRead check.
Yeah, when I think "User interfaces", I think: "Ebay."
Ebay is the worst, right up there with PayPal for horrible uis.
So, curiously, anyone have any code that actually uses the new generator / iterator things? Looking for some examples. I "get" it, but I don't see the utility of it. 
Remember that a unit test is looking for the operability of one thing. A lot of people think that total functionality should be tested at every step. That means that they fear too much work and are not prepared to write the tests. Remember, if your unit is a screwdriver, test the screwdriver, not the entire battleship. Integration specs take care of the larger scope. 
Bandwagoning. This new hot shit library has this and that benefit so let's go deep into debt/refactor or hire someone who knows it and they'll train all of us on it. 
if I had a better way with words I'd say the same :-)
At least they had "fun" making them
Google maps.
Couldn't agree more.
WHAT HAPPENS WHEN HE STOPS?
Great work. :) I'm unsure if intentional, but the live preview hugs the side of the page, even in desktop mode, on my android.
Yeah it's annoying how popularity gets confused for quality. In like 2009 I remember being pushed to learn from Facebook and Twitter when at the time the quality of their UIs was garbage. **sigh**
Design !== Javascript library. Not sure what you all are getting at. Looks pretty cool IMO! 
Managing scope creep
When desperate to make things work then just hacking things until they look like they do what you want - leaving in place fragments of stuff that didn't work with no comment or explanation. And along the same lines: never stopping to consider if what's being attempted is a sensible approach to a problem.
God help us all.
That may have been true in the past, but the website has evolved a lot in recent years. We are transitioning much of eBay.com to a new Node.js stack and Marko is being used there (this includes heavily trafficked pages such as the new eBay homepage built on Marko). That said, Marko is library for building scalable and maintainable user interfaces. It does not dictate a certain UI design. Disclaimer: I work at eBay and am a maintainer for Marko
http://imgur.com/buFdIy9
I use Marko every day. It's a phenomenal library, and I encourage folks to take a look at it before passing judgement.
1. Architecture mess (e.g. putting business logic in the view layer or other symptoms of "big ball of mud"). 2. Having too much faith in libraries/frameworks/tools. People often write code in a way that is coupled 100% to the libraries they use. They don't create any abstractions over libraries (which makes impossible to make choice of switching from library X to Y later). 3. Overengineering, complicating things instead of following KISS &amp; YAGNI rules 4. Lack of use proper OOP techniques (and for example abusing `switch/case` instruction for emulate late-binding or polymorphism). 
What do you like about it vs. something like react?
Yes, test the things that "already work". You're not testing for today. You're testing for 6 months from now. 
We'll have none of that nonsense here at /r/javascript.
Not OP but using Marko at a startup where I've been building and maintaining a video player with some annotation/sharing/editing capabilities. - I can use real DOM events directly. - Generally find myself writing terser code. - Server-side rendering is a breeze. - Cleaner templating syntax than JSX (with features like loops and conditionals that you'd expect from more traditional templating languages) - Smaller file-size than React. Some drawbacks: - I need to split up components into individual JS/template files because although there's support for single-file Marko components, there's no linting support. So each component needs its own directory.
Music to my ears. 
wow, this looks _really_ weird, but c'mon, when i saw JSX for the first time, it was _really_ weird too!
Cool stuff - like alternative approach to web components. How interoperable are Marko components with other frameworks?
Lookin' like a great update. Atom used to always hog my memory on big projects, and some of my recent work has up to thousand line files. Nice one.
ITT: people confusing how things look vs. how things are built.
we just have to remember to call .return()
I mean.. yeah. http://imgur.com/OQnv2FX
Anyone tried Vue and this? It has some stuff that looks nice having used react for the last year, but the only thing I see that Vue doesn't already do (potentially better) is win at the benchmarking
Why not just use Redux? 
- Greatly reduced boilerplate code, simpler interface - Observable, store subscriptions are automatic using an observer pattern. No need to mapStateToProps or wrap your components, just use values from the store if and when you need them and they will stay in sync - Immutability is baked-in - Actions contain update lifecycle - Simplifies use cases like async updates, removes middleware - Allows components to be more purely presentational - Updates made to the state happen in the context of the action and are tracked throughout its lifecycle - Gives context to async updates, surfaced in DevTools 
While this doesn't answer your directly, I did give a talk at a local Node.js Meetup where I walked through Marko, React and Vue that you might find interesting: [Meetup: Building the UI - a comparison of React, Vue, and Marko (from the Marko creator)](https://www.meetup.com/Node-js-Denver-Boulder/events/240076091/) - [Video recording](https://youtu.be/i6eZA8Y_GgA) - [Slides](https://docs.google.com/presentation/d/1BegZ-EhEZG9qsQFXyLLuS7AdwXkJhNK1yyq4gz1T9zI/edit?usp=sharing) 
How does this compare to mithril?
This. ‚òùüèª
Along with the fact that it's blazing fast. That's another huge plus. http://markojs.com/#benchmarks
A Marko UI component compiles to a JavaScript module that exposes an API that allows it to be rendered into any location in the DOM using an API similar to the following: let MyComponent = require('./path/to/my-component.marko'); // ... let myComponent = MyComponent.renderSync({ name: 'Frank '}) .appendTo(document.body) .getComponent(); // You can interact with the UI component programmatically if desired: myComponent.doSomething(); We experimented with creating a seamless UI bridge layer between various UI frameworks and it worked really well because the design paradigms for Marko, React and Vue are all very similar. We haven't yet open sourced the UI bridge library (lower priority), but that is our intention.
I assure you, it's a lot easier to work with than JSX.
This library is NOT about the *design* of the UI, but how the UI library works within the DOM structure.
... and browser events.
Do you mind expanding point 4?
Care elaborating on this? I don't think I've ever been like "damn if only jsx did this..". What could possibly be easier? genuinely curious
Quickest way to get this to a working stage will be to assign unique ID's for all your elements and assign the event handlers for them individually. Happy learning.
"An iterable is an object with a [Symbol.iterator] object. when invoked, [Symbol.iterator]() returns an iterator. " -- something seems a bit off here
Here are a few specific examples: - Marko is a superset of HTML (assuming that you are using quoted strings for attribute values) and that means that almost any HTML fragment can be pasted into a Marko file (JSX is strict XML, not HTML so HTML must go through a conversion) - Marko uses `class` while React JSX utilizes `className` - In general, Marko requires much less boilerplate since it starts with HTML - Attribute values are always parsed JavaScript expressions in Marko (React requires `{ ... }`) Here's a more in-depth comparison between Marko and React that also examines JSX: [markojs.com: Marko vs React: An In-depth Look](http://markojs.com/docs/marko-vs-react/)
How does atom compare to vs code these days? I made the switch for better performance and better vim support about a year ago, and never looked back...
&gt;They don't create any abstractions over libraries ... &gt;Overengineering, complicating things 
I use both. Atom is nice for Ruby still, but the built-in TypeScript support for VS Code is insanely good. 
I had to switch to visual studio code on my work Mac because it crashed all the time.
None of this makes marko "a lot" easier to work with. They're minor syntax differences. I'll bite on copying + pasting existing html, though this has rarely come up for me and been at most a minor inconvenience. 
that's awesome!
Abstractions are not over-engineering, and your comment points to another problem with experienced (or even most) JavaScript developers related to /u/0x13mode's point #1: avoiding abstractions entirely, and generating FUD about abstractions.
&gt; Atom 1.19 introduces a native C++ text buffer implementation that improves responsiveness and memory usage. The transition to the Dark Side begins
I switched to vscode as well for both performance and typescript integration. It's pretty tough to use an editor originating from Microsoft after being an emacs user for for a long time, but I've been surprised and pleased by vscode. I don't think I'll go back to atom.
That violates the very yagni principle that the post above espoused. 
"A lot" can mean very small "lots" over a long period of time making it "a lot". :D As in, every time I don't have to write boilerplate in Marko it's a lot easier to build web apps. In fact, over a large application or multiple applications it makes a significant, meaningful difference.
Abstractions do not violate yagni.
lol, how long until its a pure C++ IDE?
Good work, but holy shit, what a boring music video.
Not sure if I'm on 1.19 yet, but I'll say; for my React/Django projects, it's been nothing but stable and responsive. I'll always take more, but what Atom has been for the last ~year has been terrific for my needs. As a web guy, the mention of incorporating a c++ text buffer feels like a cheap shot. JS all the things, right? I can easily assume the benefits here, but also makes me wonder: when can a JavaScript app take this on natively? What are the current restrictions? Looking forward to checking my version and seeing how it feels. Out of all the editors I've used, Atom is my biggest crush.
A general lack of documenting in the code, sure I can read it, follow the script through a debugger and figure out what it's doing, but if the original coder spent an extra 30 seconds writing some comments about why it's doing something I could save 40 minutes when I have to extend it later. 
Well this is just for me, but the main reason that I prefer Atom is because it's a lot more customizable than VSC. It's really nice to be able to change styles for any part of your editor or any plugin you have installed with just a little CSS. Also, I tried out VSC, but I remember having issues getting Flow to work properly there. I don't know if it's gotten easier since then.
Mmm... having seen it now, Marko - to me, doesn't seem like a UI library at all. It looks more like a framework. When I think of UI libraries, I think more like Material-UI or React-Bootstrap or NG-Animate. What Marko looks like, to me, is an application state manager, forusing on managing user experience and behavior than User Interface... so I got a little confused. What I'm curious about is the claims of being "blazing fast" - especially compared to Preact. Is it that you just don't use a virtual DOM? Do you have fewer features? Where is the tradeoff? 
That's actually a negative, in my opinion. I've worked with HTML for 20 years and Javascript for 3. I would much rather have JS code generate HTML for me than write HTML by hand. 
Good music I suppose
Regarding 2. After having gotten a taste of Haskell and Elm's package ecosystems, I wish more people could experience the power of being able to completely trust 3rd party code, and not have to worry about refactoring. I get that JS dependencies are fragile, I just think that writing your own library/framework/tools is not the way forward long term. We innovate by leveraging others work.
You had me at Elixir
I'm pretty stoked about it. As long as Atom remains the hackable HTML/CSS/JS editor that it is, I don't really care what's used internally to make it performant.
I kind of like Atom. But I realised the other day that every time I try to switch away from Vim, I hit a stumbling block in tab management. It seems every other editor allows you to have tabs _inside_ window splits - whereas Vim has splits _inside tabs_. The split-inside-tab layout works so much better for me and I haven't seen other editors that do it*. *I'm sure emacs can but that feels like just as much of a rabbit hole as Vim itself.
Guess it should be `with a [Symbol.iterator] property?
Honestly, I agree 100%. I want an extensible, modular, powerful and fast editor that is both cross-platform and open-source. Sublime is all of those except for open-source, Atom is all of those except for fast. I value open-source more than fast, so I prefer Atom. I don't care what language Atom is written in as long as it is open-source, and preferably fast. 
Hey, when I think node.js frameworks, I think Walmart ;) "Hapi framework was first created by Eran Hammer and team working at Walmart" _source:_[noeticforce.com](http://noeticforce.com/best-nodejs-frameworks-for-web-and-app-development)
I was hoping they somehow improved Electron's memory usage which in turn made Atom less memory consuming rather than transforming it to whole another language altogether.
Good morning, I'll resubmit with the direct link. Thank you for your reply.
What a sentence! How times have changed
I have only stayed on atom because vim mode is vastly superior to vscode, has something changed in the past 6 months?
VSCode?
VSCode doesn't have multiple projects per window yet, it's in the beta but it hasn't been released yet. I will definitely compare Atom and VSCode after, but I bet this version of Atom will be faster than VSCode is.
Your website is Level 10 awful. If your reddit client looks as bad as your website, it will fail. JUST SAYIN.
The amount of times I had to copy and paste html and refactor it in JSX literally adds up to days of effort for me by this point. Whether it's migrating old projects, or copy/pasting bootstrap snippets from documentation, it is something a lot of us do very frequently. Just adding some alternative anecdotes to your anecdotes.
&gt; I want an extensible, modular, powerful and fast editor that is both cross-platform and open-source. So vim?
I also use both. Atom for Ruby, Elm and JS. VS Code for TS and F#. For anyone wondering, I'm just more comfortable with Atom. Can't deny that VS Code is faster than Atom. 
Maybe. I haven't looked into using vim on Windows.
Unsure if VS Code is open source but wow its good. It has a healthy extension ecosystem. It's similar enough to atom that if you make the switch it won't be uncomfortable. It is hackable in a sense - maybe not pure HTML/CSS/JS but you can definitely make it your own. Edit: oops, just saw you're in another comment thread about vs code already.
This "corruption" cannot come too soon. Do not fear the embrace of darkness Atom, the promised awaits you. SublimeText is already there.
Yeah, out of the box the support is just stunning. It's making me want to switch to it from WebStorm, but I have a mixed code project.
Because atom crashed? I assume that's what you're referring to. VS Code is pretty good though. I always thought that atom was supposed to be lightweight and efficient; I gave it a test run and was disappointed with atoms performance.
Running `npm i --save lodash` before checking to see if JS supports it natively. Then replace lodash with x module and you find people just install modules left and right. [Frustration creates modules](http://loda.sh).
Yeah VS Code is open-source. Not the binaries as Microsoft adds in extra "features" for those, but the source is available.
The gzip compression can give you better compression if you have only one big file than having my many little files. But using code splitting to dynamically load stone cider is useful too.
Is there any "problems" this fixes that other UI frameworks don't handle?
I always wanted to dive into vim but the learning curve seems pretty steep. Do you happen to have any good ressources/tips?
And then run it on WebAssembly. /s
At the bare minimum, you should write tests for parts of your code that prove to be more complex than you had originally anticipated. Bugs are a good indicator of this. Whenever you find a bug, not only should you write a regression test for the bug, you should also look into the module where the bug occurred. If the module is a "repeat offender" when it comes to bugs, it might be a hint that there is an underlying complexity there that is not adequately understood. In such a case, it is worthwhile to think more deeply about what the module ought to do, and then to write a battery of tests that specify that behavior in detail. In an ideal world, we would write perfect test cases the first time around. In practice, however, we tend to discover new things as the project progresses. The key is to capitalize on these discoveries. If you are unsure of what to test, you can experiment with different methodologies (of which TDD is just one). If you are just starting out, then a pragmatic, sparse approach is to feel into the intuition that tests are just another tool to help you get things done. If you find yourself testing the app "manually", for example, you should be able to save yourself quite some time by automating that task.
There. Got you two answer sets, for two companies I have been working recently ;)
I hope this can be of some use to you. I am fairly amateur at jQuery, so, I'm sure this can be done better. https://codepen.io/Neilz0r/pen/dzWXwa Enjoy!
So essentially it's open-source software which 99% of people are happy to use a closed-source version of? That's marketing genius if true.
Wow, amazing stuff again. Thank you both so much! 
https://github.com/t9md/atom-vim-mode-plus is just awesome, switched from native Vim and never looked back.
If i could afford i would give you gold, you are awesome mate. Thanks!
Yes, it's true and it really is marketing genius, which is why I would prefer to stick with Atom if possible.
Look at /r/vim sidebar.
Are they allowed to use the actors from Silicon Valley in this way?
In React 16+, you'll be able to use `class` or `className` too. :)
it's something about the lastIndex property of the regex object, chech this out https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex in your test the index is set to 15 after the 1st test,so the second fails and sets it back to 0 and then the 3rd test matches and sets it back to 15
Emacs for Windows is pretty good. I've been using it since 1998.
Thank you for your clarification and the link! Too bad understanding the actual "usefulness" of this "feature" goes beyond my own capabilities.
Misconception: shorter code is better/more maintainable. Lack of skill: the ability to explain how they arrived at a particular solution.
Hot chocolate, Aspirin, then bed. No arguments!
The extensions isn't as good. I currently use VSCode, but only because Atom started to feel slugish with my 5k monitor. Maybe I'll give it another try now. 
Yeah I love VSCode! I don't even use all the features I'm sure but it's great. Built in terminal and Git diffing is great! I still use SourceTree for my Git stuff but VSCode offers a nice diffing tool to see differences quickly. I'm also using the 'Atom One Dark' theme and it's awesome. +1
I don't understand :&lt;
Hold music.
Will do, thanks!
Look into projects that use Redux. They often practically emulate full blown OOP with reducers, pure functions and switch/case instructions. `case: ` blocks are like methods. And using OOP for Redux could simplify much of a boilerplate: https://jsfiddle.net/v1kvcjbu/126/ Redux documentation has even article about this, but nobody reads it anyway: http://redux.js.org/docs/recipes/ReducingBoilerplate.html#generating-reducers
The code itself works just fine for me. Do you have Elements with the id "loopcounter1" too "loopcounter9" in your HTML document?
It's like salt. It improves taste, but too much salt can spoil soup. It would violate YAGNI only if you're really "ain't gonna need it". But there are scenarios that some abstraction would be very useful and needed. Good abstraction can be simple, bad abstractions are complex. Good abstractions actually can simplify design, bad abstractions are the ones that make things complicated. Simple abstractions: - to avoid using inline styles, I would use CSS classes - to avoid coupling `axios` library with my project, I could make a simple "AJAX service" and force all modules to use AJAX via this service. I could also make some more high level abstractions like "resource" or other things, that will still be simple, yet useful. Complex abstractions: - I would make a WebGL based layout system and to style Hello World text as red with blue shadow, I would create canvas, compute positions within layout, and render Hello World with my shaders running to achieve a red color and blue shadow. Then, I would emulate browser selecting text behavior in WebGL to make my website accessible. And this way I will get rid of inline styles ;) - I would create a provider for creating a factory which will create a builder for me. Then I will inject my singletons in this builder and this will create a service for me. Service will get 4 parameters, and two of them I could get from universal parameter providers, and remaining two parameters I will have to create before each service calling... etc. (it's made up example, but based on real life situations, where similar patterns were in use). And in the end of a day, I could make a single AJAX call XD So... I think same thing can be abstracted in different way ;) 
What plugins do you use for ruby. I find it hard coming from and IDE. 
What plugins do you use for ruby. I find it hard coming from and IDE. 
What about you just shut up and wait for the beta? Just saying 
Not on my computer now but from memory the three main ones are the Ruby linter, a plugin that let's you switch between a file and the corresponding rspec file and another plugin that converts between `do` `end ` and curly braces. I also have a non-ruby specific plugin that switches between single and double quotes via a shortcut. Handy if you're stickler for using single quotes when you're not using string interpolation. Wish that one would also cycle through backticks for JavaScript but I guess I should make a PR for that. But atom, in my opinion, can't compete with an IDE like Ruby Mine. The click through in Ruby Mine is a killer feature. The only reason I don't use Ruby Mine is the same reason I don't use VS Code: I'm too used to the atom/sublime editors. 
Thanks Scharnvirk! And thanks to everyone else who responded, this has been a huge help for me.
I totally understand. I use the plugin atom-beautify with rubocop for autoformat, linter-rubocop for listing errors, and I've set up ctags in the terminal to help get back to the feel of an IDE. 
What type of features are included that are not inside the repository of the open source code? I wasn't aware of the fact that VSCode wasn't 100% opensource. Have been using it for quite some time now, must say that I am really impressed by VSCode.
I switched from atom to NeoVim on Windows recently. I'm finding out to be very easy to use (albeit with a learning curve) and very performant.
Post the whole code! :)