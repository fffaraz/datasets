just to avoid 6 digits for the last one. And it also feels more like the index of a javascript array.
I feel like this same principle should be extended to other languages: C++: You might not need (boost/the standard library) C: You might not need libc Perl: You might not need CPAN C#: You might not need System After all, any library you drag in is obviously going to be slower and less efficient than any code you write yourself, and that is the only relevant consideration. /s
you are right (with the current setup it is an eternal rank), see https://www.reddit.com/r/javascript/comments/3begcu/10k_most_popular_javascript_projects_on_github/cslqym6 maybe I should change the standard sorting to "week" or "month", if that is what people expect from the list. Then you have the "trending" repos of the timeframe in top positions, moving down over time. Or I have to implement a ranking that takes time into account to make projects bubble up and down (maybe after i have recorded a year or 6 months). But that would also mean that mature projects like "jQuery" would vanish pretty soon.
Very nice idea. One thing I'm missing is internationalization. Maybe an enhancement could be to base this on momentjs? Then you don't have to parse the dates yourself, and you get internationalization.
Yeah! It's good practice and is more functional.
For starters, it's messy! yulk!! :(
Arrows and splats are not supported by many browsers yet. If you are happy to use Babel, yes you can use them but otherwise for the time being underscore and lodash are still important tools in the arsenal of web devs.
Even with ES2015, a trimmed down underscore or lodash library will still be useful.
1739 Get rekt :D
You clearly failed to read the article or to follow up with the latest news. Things like `forEach`, `map`, `filter`, ... are now part of ES5, ES6 and ES7. You don't actually need to write an entire loop, no, you just have to replace a single line of code by another single line of code. Obviously, if you need to support old browsers you might just stick with Underscore or Lodash (or an ES* shim). That's why the article says "you might not need it".
&gt; I can't take seriously an instructor that builds his course around w3schools pages and YouTube videos. Absolutely. I base all of *my* courses around MDN and Vimeo.
C# doesn't capitalise locals. Edit to correct myself: doesn't capitalise locals *by convention*. Typically, only fields and properties are capitalised in `PascalCase`, whereas locals are in `camelCase`. 
Here is a simpler for-loop iteration scope demo: let callbacks = []; for (let i = 0; i &lt; 3; i++) { callbacks.push(() =&gt; i); } console.log(callbacks[0]()); // 0 Doing the same with `var`: let callbacks = []; for (var i = 0; i &lt; 3; i++) { (function (i2) { callbacks.push(() =&gt; i2); }(i)); } console.log(callbacks[0]()); // 0 Keep in mind that Firefox doesn't support this detail of `let` yet. Babel and Chrome (strict mode) do, however. http://kangax.github.io/compat-table/es6/ Also, do not capitalize your variables in JavaScript. PascalCase is used for classes.
now showing an additional "timeframe RANK" by default when "DAY", "WEEK" or "MONTH" is selected. Thats the dynamic RANK where projects bubble up and down depending on their "popularity" on GitHub for a certain timeframe and what most people seem to be most interested in. The "absolute" or "eternal" RANK doesn´t change that much (for example mature projects that have gained a lot of stars/forks in the past will mostly keep their rank)
You can also do this in es5: var Tags = {'Prepend': null ,'Append': null, 'Transpile': null} for(var Name in Tags){ if(Tags.hasOwnProperty(Name)){ setTimeout(function(Name){ console.log(Name) }, 0, Name) } } If you pass extra arguments to `setTimeout` they will be passed on to the callback.
&gt; I don't care about a grade so This thread is a stupid flame. You will likely take all kinds of course both inside your formal education and after that you may disagree with. It doesn't matter. Everybody is entitle to their own opinion. Consider this a valuable life lesson. As a professional web developer most of your education will be continuous self-education. If you are waiting for somebody to teach you the latest and greatest and bitch about everything you disagree with nobody will want to work with you.
Where can I get this "normalized NPM downloads"?
You can't. I asked the NPM guys about this on IRC and they said its not available. I should have been more clear that this is something ideal but currently fictional.
you guys better be
So you compare the well-established standard libraries with Javascript's huge set of obscure 3rd party libraries? Either you are not very smart or out for a fight for no reason.
bad english, looks interesting 
Given the asynchronous nature of these operations, I don't see how tracking their performance would be possible unless you create a small event hook in the template renderer yourself - but I'm not 100% fit in AngularJS, so I might have overlooked something.
&gt; Array.from(new Array(n), (_, i) =&gt; i + x) Also Array.apply(null, Array(n)).map((_, i) =&gt; i);
&gt; return is not a function, it's a keyword. so replace return(whatever) with return whatever. Altho this is technically true, `return(whatever)` will still work, just like you can use `typeof val` or `typeof(val)` for the same result. 
I just wanted to let you know that this is an excellent comment, worthy of more than just an upvote. 
As i unterstand it, it's experience, no matter how much you've learned from that experience. 
I was just about to start a project which would use this sort of thing. I debated using a canvas or something like that, but this just works so well. Thanks :)
That's what I meant. Lodash is much much faster in most cases than native. It's the selling/key feature. Although, the perf benefits are not that apparent for simplistic use cases.
The three levels as I understand them: Junior Developer: new devs with little or no experience. They need to have someone looking over their shoulder and reviewing all of their code in case they do something crazy and break something. Developers: people with a degree of experience and can operate independently. It's expected that they are self sufficient enough to solve their own problems. Senior Developer: someone with a great deal of experience. They spend more time managing other developers and training junior developers than they do actual developing. 
Still waiting for the intro animation to finish
Agreed. I'm not sure I'd want it as a dependency, but compatibility could be quite useful.
I love the animation, also TIL there is an &lt;hr&gt; tag. Would the sqrt calculations really be an issue? 
Wow. Let's relax a bit. I think complaining about substandard teaching methods is a valuable use of time because it get the idea out there to noobs that not ALL professors are always correct or using the best methods. All of the students that started this class have now dropped except me. For some of them this could have been their first exposure to programming. Now they won't try it and it has forever impacted their lives. You think that I should sit down and have a heart to heart with the instructor on his teaching methods? Why? I say just go to other resources and not waste time on someone who doesn't care enough to create good content. Why would I want to learn from them? And I am very big on self education. The entire idea of my post was that many times there are better resources online to get better instruction than some college classes. 
It's great for them when they get someone enrolling.
Could you not just clean up the function like this? function mySetter(opts, prop) { if (typeof opts === 'string') this.element[opts] = prop; else if (typeof opts === 'object') for (var key in opts) if (opts.hasOwnProperty(key)) this.element[key] = opts[key]; return this; } (note: instead of your `for...in` loop you could just use `Object.assign(this.element, opts)` but you'd need a polyfill or an ES6 transpiler for that) Of course if this is a common pattern in many of your setter functions, why not abstract this functionality out into another function that takes an object to change (in this case, `this.element`): function applySetter(target, opts, prop){ if (typeof opts === 'string') target[opts] = prop; else if (typeof opts === 'object') for (var key in opts) if (opts.hasOwnProperty(key)) target[key] = opts[key]; return target; } function mySetter(opts, prop) { return applySetter(this.element, opts, prop); } function myOtherSetter(opts, prop) { return applySetter(this.otherThing, opts, prop); }
You should probably check in the network tab in the developer console in your browser. Most likely you will find a 500 server error from your ajax-call to your web service. From looking at your code I think your syntax is wrong in the after 'data':. Try something like this: data: JSON.stringify({ "transactId": tId }), One other thing is that calls against .NET WebMethods wrap the response in an object 'd'. So to get to your return value (when you change your method from void to e.g. string or bool) you can use console.log(e.d) to check the value you return. edit: Also check that your URL is correct. You write that the .asmx-file is in a different folder called "Utilities". When you call it from your javascript you would have to write: url: 'Utilities/ITPSWebService.asmx/ApproveTransaction',
I applaud that you do this, but unfortunately we live in a world with imperfect people. if everyone were nice enough to comment their code to this extent people may not be inspired to make a regex-creation wrapper like jonny_eh's done, but unfortunately not everyone does :/
you are one evil person :D
Well shit dude, yeah I could. That looks way nicer. I think I got carried away with trying to do things only once way back when, and ended up doing it the way in the OP. But this is much better. If I was a bard, I'd write a song about you and pass it down through the ages. I'm just English, though, so "nice one, yeah? thanks"
JavaScript is the only programming language that will run in the browser. You can make sites without JavaScript and depending on your situation, that's perfectly fine. 
I really have to disagree. I think everyone should embrace these utility methods more. I'd venture to say if you're using a small subset of of your utility library then you are not using it enough. The pros farrrr outweighs cons. 1. Tested 2. Optimized 3. Documented 4. Consistency 5. Provides vocabulary for common low-level operations I really wouldn't underestimate the power of #5. Yes it means you have to know the library, but when you start seeing everything as compositions of low-level utility methods it feels like cooking with gas. "It’s much easier to recover from no abstraction than the wrong abstraction. " The abstractions that utility libraries provide are so low-level I find it hard to believe that there's any real risk in heavily relying on them. If you use the wrong utility method, replace it with another. It's likely the function signature didn't even change. (lodash-fp and ramda also have auto-currying which is fantastic once you get used to it)
I can easily see a future where libraries like lodash/underscore do what jQuery does, by dynamically selecting a given compatibility mode that depends on what version of ECMAScript you're actually running. After all, the native `foreach()` implementation is bound to be faster than whatever you have to do in ES4. This way, the library continues to behave like a normalization/compatibility layer, and you don't have to re-train nor rewrite your code.
An instantly-invoked anonymous function is at least inline to the callsite which minimizes the indirection. Factoring its body out into another function just adds indirection. Seems to only be a benefit if you're unfamiliar with anonymous functions. Similarly, in this contrived trivial example, you've also polluted the file namespace with a function you use once.
Postman is a great chrome extension for these sorts of things you can put the request in yourself and see the exact headers coming back from your server. That way you can tell if the problem is on your server or client side code. https://www.getpostman.com/ 
When we were writing JS targeting engines that only supported ES3, the low level library functions like `_.map` and `_.filter` were a blessing, because the alternative would have been writing a for loop. But now that these things are provided by the language, we don't need the library functions to handle them, the same way we don't use a library to concatenate two strings together. But we can raise the bar for libraries to provide what the JavaScript of today doesn't. Libraries aren't going away, but I expect them to evolve with the language.
Use [Fiddler](http://www.telerik.com/fiddler) or [Chrome dev tools](https://developer.chrome.com/devtools) to inspect the ajax calls.
This is true (although, as mentioned above, the utility libraries provide optimizations that are not possible with the native implementations). 
He does give some examples, but I still stand by my point. For example this line of code: array.filter(x =&gt; !!x) Pretty simple. It's the compact function, but how would you know that from just looking at that line of code? A comment works. But. Where's the documentation? Where are the examples for the other (junior) devs? I wasn't saying these things aren't easily doable with ES5+, but it does take some more work (especially if you rely on the ES6+ examples). The specific examples provided are for some relatively easy lines of code too. Things like groupBy, indexBy, and difference are all more difficult problems. Yes, I and most developers can write them, but why waste my time when I can rely on a battle tested and well-documented version. 
I agree, when I first started the project I didn't think it would get any popular at all... It's so hard to choose names for projects... I'll try to find out a good name :)
That's alright! It looks like what happened is you overthought the function, and you got the two code paths (if opts is a string and if opts is an object) to both run no matter what. That's often useful if the paths overlap, but in this case there's nothing in common between how you handle an object argument and a string argument, so a simple if statement or switch case is fine. 
Try exclamations next time.
Thank you
I've used sequelize quite a bit, and I really like how you do relationships here. Nice work. How do you handle migrations?
Don't worry — you'll catch up eventually. I'm a senior, and I've been doing ES6 since childhood.
On a side note JSLint is being almost rewritten from scratch and the new version includes ES6 support directly.
Hi, I'm the author of this little library which lets you create desktop like interface on the web. It was initially developed for use in the online portfolio hosting website - pridesk.com. One year after publishing, I decided to close site due to lack of motivation, funds and marketing experience. 
Without javascript you would have to use a form so an html text input field would hold the name, they hit the submit button which sends that request to the server, the server gets whatever data it needs and sends back a whole new page that has the results of whatever code you did on the server. It's certainly possible to build sites that way, most sites worked like that a decade ago. The javascript method would be similar but the page wouldn't refresh, it would just request the data with an ajax request, the server returns only the data needed(instead of a whole new page) and then javascript updates whatever portion of the page needs changing based on that data. It sounds like you have more back end knowledge so I might just go the Bottle route for now if you know that. You can always learn javascript and add functionality as you go along unless this is a huge project where changing things as you go would be a huge burden. 
Oh, nice. I'm at #357 w/ Mithril.js. On a side note, big shout out to the js.org author for providing free subdomain names for github js projects.
Wow thank you for this. I have truly learned something. My only question is, why when you pass console.log as an argument to setTimeout, does it only pass the function "log" and not the console object? 
I've been there recently, so remembered the exercise) Studying JS as well ;)
Ah, thanks hadn't realised they changed the name. Fair enough! Somewhat of a weird decision as that somewhat limits them to changing it once a year (thinking of the future when all browsers are evergreen and hopefully be better at implementing standards).
 var me = {}, you = {}, we = [you, me]; we.happiness = me.happiness &amp;&amp; you.happiness; 
var weAreHappy = isHappy(me) &amp;&amp; isHappy(you); 
You can use any language you want on the server side. Javascript doesn't care what the backend is running, as long as you format the data correctly that you are sending back when javascript sends a data request. I would start by doing some Javascript tutorials on something like codeacademy, then read up on Ajax calls. If you've programmed before, javascript should be fairly straightforward to learn and there are a ton of resources.
Uncaught ReferenceError: we is not defined
I think Underscore does this (uses native `forEach` when it's available), but Lodash doesn't because its optimized loop is actually faster than native `forEach`.
Corrected the code. Writing JS on mobile can be difficult ;-)
There are a couple ways to do this. I like this best though since it can be read like English and ran like Javascript. There are definitely somethings I'd change in actual code, but this maximizes for cuteness :P if ( i.amHappy &amp;&amp; you.areHappy ) { var weAreHappy = true }
You are all getting virtual Christmas cards :)
&gt; Are indians programmers really worst in general compared to programmer here or great one like Carmack ? No, but the ones who are as good as Carmack don't work for outsourcing firms. They either are building their own companies in India, or moving to the US/EU.
Congrats on the job, this will be a great step up for you. There is basically zero javascript needed to drive basic GWT. There is however a bunch of sort-of blackbox stuff that happens to convert java to javascript and to move data around. Hopefully in the short run you won't need to dig into any of that stuff. I would go read up on java. I would concentrate on things you might need to write validation code. So checking inputs to have appropriate values. YOu might also want to learn a bit about databases, concentrate on the SQL "select" and "insert" and "update" statements. Knowing a tiny bit about the concept of a "transaction" might be helpful. Since there are senior devs on the project, I would concentrate on the basics of java programming. The senior folks will have already setup a framework to do the fancy stuff. So you'll probably be coming into to help "fill in the busy work details" This is still real programming and you will need to learn quite a bit. Good luck!!
I'm thinking of getting it tattooed. It took us a while to figure out we needed to be happy as individuals to be happy together. It's something personal that will make sense to him :)
FYI: typeof 'foo'; // 'string' typeof new String('foo'); // 'object' Underscore does it like this: function isString(str) { return Object.prototype.toString.call(str) === '[object String]'; }
How did you even qualify for that job in the first place? You are screwed. 
OK, well in that case I'd guess he's a programmer? We can be particular about syntax (the structure of code) so I'd be very sure about what you choose... also, look at pseudo code (non programming specific structure) as that's more timeless. That said, that is pretty sweet! My SO wouldn't do this, he is lucky :) good luck.
Started googling.... found this! ======================= You had me at "Hello World" =======================
I'm really sorry it has taken me so long to tell you thanks. I've been sharing your response with some people that are experts and they have been looking into the issue. I can't tell you how much I appreciate this response. Thanks for all your help!!!!!
The same reason you'd use any ORM: to be able to easily manipulate the query in code prior to its execution. But if you think a JS implementation of dapper.net would be valuable you certainly could make it.
Thanks! I think more to show that javascript was cool before html5. The library was written almost four years ago and is based mainly on SVG. Well, I quite pleased with the result even though today is not so great.
Regardless, might prove a good opportunity to advance your career to something more than a mere "Web Designer". But you have a long road ahead of you given that your programming skills are virtually non-existent. Pick up a Java book and practice creating your own projects. Once you are comfortable with simple Java console projects then do the same for Javascript. By the way, Javascript and Java have no relation to each other so you'll probably have to put way more effort into this than you realize. 
But why is it called moron.js?
Underscore isn't obscure
Why moron.js and not something more original? cretin.js or imbecil.js . I'm just afraid It will not be so easy to google it and find valuable information, without stumbling upon morons.
&gt; That said, your solution is a lot easier to read than stuffing a self-executing function in there. Bingo. Once you start analyzing it, you'll see it's exactly equivalent. But the fact that it's a lot easier to read, makes all the difference.
setTimeout was just an example, my real life use case was promises.
That looks good, but what is the 10 for?
I'm going to be that jerk who rains your parade (because I'd rather be a dick once, than let someone regret something forever): don't get this as a tattoo. It's a sweet sentiment and all, but I mean, seriously? You know those people who don't speak a bit of Chinese, but get 愛 or 意粉 tattooed on them anyway? That's what you're about to do. You know how those people regularly get derided for doing that? That's what you can expect. Prepare for a bunch of people to ask you things like "oh, you're a programmer? what's your favorite language" or "how long have you been programming" or "lol I hate computers, can you fix my printer?". Prepare for a bunch of people to tell you things like "you should've written it this other way" or "your code is garbage" or "JavaScript is such a shitty language...". Also, that logic is a tautology. If I was elected president, stood up there for my inaugural address, and told the whole world, "If the oceans are blue, and the sky is blue..." (big pause for suspense), "... then the oceans and sky are blue." Would anyone be impressed? that's a meaningless statement. Despite how sentimental yours is, it's exactly the same. The only time you'd write code like that is as a shortcut, not as meaningful statement on its own. If your husband is a programmer, seriously discuss this with him. I get that the statement has some personal meaning to you, so maybe I'm just being the total asshole, but since you're not a programmer, you should get his programmer's opinion before permanently marking it on your skin.
No.
It think it is weird if someone gets insulted by a library name, or chooses a library based on its name. Of course there are limits but I didn't think this crossed them.
well maybe not insulted but moron is not a word I would like to use in my morning meetings. I guess insult is not the correct word here but surely it sounds strange enough for me.
watch out for : typeof null // "object"
Very clever! I like this idea a lot but I think it's best if xeger just returns a plain regex file for now.
If you had an object like this var obj = {prop : 'value'} and you passed `obj.prop` to a function console.log(obj.prop) you would've only passed `prop`, not the whole `obj`. Similarly, and since functions are treated as first class citizens in JavaScript, they too, are passed independently of their parent object. 
[Chrome has a heap profiler](https://developer.chrome.com/devtools/docs/heap-profiling) that allows you to record heap allocations, which is a nice way of finding memory leaks, then there are also heap snapshots that allow you view current memory allocation. Firefox's Firebug addon has a similar feature, I don't know if they ever incorporated it or not.
destructuring, homie
I am thinking of doing one on that as well.
Yes, it's javascript. People do crazy stuff with CSS these days but I don't know of anything that's easy to understand which does this. I've used [jQuery Zoom](http://www.jacklmoore.com/zoom/) before and it was ok and really easy, but doesn't do sidebyside out of the box. [Magnifierjs](http://mark-rolich.github.io/Magnifier.js/) does exactly this but I have no idea how easy it would be to implement for someone with little JS knowledge. Looks really straightforward.
Don't you use [sequelize-cli](https://github.com/sequelize/cli) for your migrations ?
The Magnifierjs link looks great, thanks! My only question is how could I make it so that it zooms when I click on the photo not when I hover over it? 
[relevant](https://youtu.be/ruNgTP3r5xw?t=107)
whoa, I really didn't expect Reddit Enhancement Suite to be in there... I mean, it's a one-site-specific browser extension. Cool!
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Immediately-invoked function expression**](https://en.wikipedia.org/wiki/Immediately-invoked%20function%20expression): [](#sfw) --- &gt;An __immediately-invoked function expression__ (or __IIFE__, pronounced "iffy" ) is a [JavaScript](https://en.wikipedia.org/wiki/JavaScript) design pattern which produces a [lexical scope](https://en.wikipedia.org/wiki/Scope_(computer_science\)) using JavaScript's [function scoping](https://en.wikipedia.org/wiki/Function_scoping). Immediately-invoked function expressions can be used to avoid [variable hoisting](https://en.wikipedia.org/wiki/JavaScript_syntax#Scoping_and_hoisting) from within blocks, protect against polluting the [global environment](https://en.wikipedia.org/wiki/Global_variable) and simultaneously allow public access to methods while retaining privacy for variables defined within the function. This pattern has been referred to as a __self-executing anonymous function__, but Ben Alman introduced the term IIFE as a more semantically accurate term for the pattern, shortly after its discussion arose on comp.lang.javascript. &gt; --- ^Relevant: [^JavaScript ^syntax](https://en.wikipedia.org/wiki/JavaScript_syntax) ^| [^Anonymous ^function](https://en.wikipedia.org/wiki/Anonymous_function) ^| [^Scope ^\(computer ^science)](https://en.wikipedia.org/wiki/Scope_\(computer_science\)) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+csn3q9h) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+csn3q9h)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](/r/autowikibot/wiki/index) ^| [^Mods](/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Call ^Me](/r/autowikibot/comments/1ux484/ask_wikibot/)
I'm mobile for a while right now, but the library doesn't appear to support it. You can do it with the jquery zoom guy [like this](http://plnkr.co/edit/MtGJtufgYNGu3ar7FuVc?p=preview). Set the target to the element you want the zoomed part to pop up in. Good luck!
Hasn't happened where I am at all. Typically people have a problem outsourcing due to communication issues. I don't know anyone packing it in. Everyone I know is making more and more every year. But everyone I know moves around and never sits in a single language for to long. They use what is best for the job. 
I just put together a video on how I do this https://www.youtube.com/watch?v=OLWEyH7_4e0
Oh, thanks, this is so helpful, i will check now
Honestly, you probably won't have memory leaks. The garbage collectors are pretty damn good now, you really have to do some weird stuff to have a bad memory leak. But in chrome, use the heap allocation, run some functions, look at memory allocated. Do it again, if the memory goes back to the level it was before the first time, you're good. If it keeps going up every time you do it, you have a problem. 
Great duplicate post of an article published over six months ago. Try this next time, copy the URL of whatever article you deem needs a mention here, paste it in the search box, limit the results to /r/javascript and click the search icon. You may have found this... http://www.reddit.com/r/webdev/comments/2o5hua/javascript_modules_the_es6_way/ I guess duplicate posting is one way of getting your post count mini-game score up.
&gt; o. For the red detached nodes, how do you know it's due to the lazy load? Are you looking at something there or if you look at the retain tree you can see that they are held on by jquery.. and based on the elements being retained I made made a hypothesis :) and it turned out to be correct.
Can someone eli5 garbage and collection? 
This was previously discussed here : http://www.reddit.com/r/javascript/comments/1l2ndc/how_to_detect_memory_leak_in_javascript/ The comments and the article should be a good start.
That looks like a pretty cool utility. The reason why the Array prototype was not extended to node lists is because it is too buggy. Actually arrays come from JavaScript which means their state is always known to the JavaScript application containing them. Node lists come from the DOM which is subject to change unknown to the JavaScript application. That said the Array methods are designed for chaining and usually for use on indexes. If you attempt to use many of the Array methods on an index that no exists you get an error. This kind of error could occur either way if not checking that the current index is undefined. The problem with node lists is that a given index, in theory, could become undefined between the check and the desired action. Granted this is unlikely..... but since there is no available solution to protect against such errors native node lists do not get array methods.
With this approach you will quickly find that practically all of your "services" are using the same code. I think a batter approach would be to have a generic RESTApiService or something in that manner that you can later extend for your model services. Another thing to think about is where would you put methods that relevant to a collection of models? 
To ensure octal parsing doesn't create errors. Try this in a JS console: 011 // that's 9? How? A leading zero will switch into octal.
All it takes is to create a memory leak is to lose a reference to a persistent object. Technically you can do that with this alone: `document.body.appendChild(document.createElement('div'));` Granted, you can get that reference back in different ways, but this is, by definition, a memory leak. Here's perhaps a more realistic example: `document.body.addEventListener('click', function() { console.log(1); });` Still not convinced? Here's an example that doesn't involve the DOM, and is a pattern that is widely used to hide implementation details. var bar; (function() { var foo = new Array(100000); bar = function() { return foo; }; })(); Actually, losing the reference to `foo` by changing `bar` to something else will remove that object from the GC roots, and the GC will clean it up. Still, this should help clarify how easy it is to end up with memory leaks in your application.
"Garbage collection" is automatic memory management. When you create an object in code, you allocate memory for that object. Often you'll have a reference to an object. var x = 5; x is our reference, 5 is the object. With JavaScript and other languages, you can ~~delete a reference~~ assign the reference a new value or no value, or as /u/lokhura points out, stop using the reference in scope. x = null; The object `5` is still off in memory. You can't just delete the object, because other things may have references to that object as well. But in our case we have no more references. The JavaScript runtime will garbage collect this object and remove it from memory because it can no longer be accessed. *Editted* Thanks /u/lokhura; sleepy-ness is a bitch.
Could you eli5 why that '10' does that?
If anyone wrote code like that, they just might deserve whatever hell comes upon them. But I'd also suspect that the gc would also figure it out eventually, at least everyone but IE's.. :-) 
Right, in your second example, the GC will pick up that var foo very quickly. and your first example is somewhat unrealistic. Unless somebody is going to append like 50,000 divs to the document.body....they still won't have a problem. Like I said, it's not easy to do if you at least half know what you're doing. The GC is very good and it will pick up many terribly written things. 
Agreed, see http://stackoverflow.com/questions/1696877/how-to-set-a-value-to-a-file-input-in-html for additional explanations
This has already been posted last week. Is there any reason why you resubmit it? Update: quite a lot of people seem to think that this is an example of criticizing a repost. It isn't. It's just a friendly question that already found an answer.
Thanks for this, it was actually pretty simple... created a .npmrc file and placed registry = https://customregistry.url/ in the file and then just for that project it has the correct registry. Cheers 
Hyvää framework, Sami! (Good framework in finnish)
nice animation in the second fiddle. one question: what is it good for? where do you need colored lines? that are made of hr-tags?
this is how i did it, maybe you can use this https://jsfiddle.net/qah1t5td/ theres a few things going on there: - set a wrapper div with `overflow:hidden` and set its size to the original image - inside of it put a zoomed image (this is gonna be bigger than the wrapper div) - change zoomed-image's `margin-left` and `margin-top` to negative values with javascript so it slides around under the parent box also used a positioning trick to get it over the description values - where the top div is `position relative`, the zoom div is `position absolute`, and the other divs are `position relative` again - put the `z-index` of zoom div to +1 - then put the content img and description to `float left` so they appear on the same line and under the zoomed pic due to `z-index +1` the algorithm isnt 100%... for `zoom:2` it should be `x=x*1,y=y*1` for `zoom:4` you should use `x=x*3; y=y*3`, `zoom:6` is `x*5`, etc 
The best way to find memory leaks in javascript is using the '3 snapshot technique' with Chrome's heap profiler. It is as follows: 1. Load your page 2. Take snapshot A 3. Perform the action you want to test for memory leaks 4. Take snapshot B 5. Perform the action you want to test for memory leaks 6. Take snapshot C Now, open snapshot C and in the menu at the top of the profiler that says "All Objects", choose "Objects allocated between snapshots 1 and 2". What you have done is filter the list to contain only things that were allocated by the first instance of the action, but for some reason are still hanging around. Assuming that the action in question isn't supposed to carry over state across multiple invocations, every single item in this list is a leak, and you can use the Retainers view to figure out why they're still hanging around. Another thing that can occasionally be useful is if you go into your DevTools settings and enable "Show advanced heap snapshot properties" under the "Profile" subsection. This will help you detect certain types of hidden references, and occasionally see when it's actually Chrome's GC's fault that something is still hanging around (in these cases, you can often mitigate it by explicitly setting properties to null, even though you shouldn't have to).
I don't know... maybe I want to do something like [this](https://jsfiddle.net/wq017cht/3/)? (scroll the list)
There's a nice talk from last year by Addy Osmani about memory management. Well worth a watch. https://www.youtube.com/watch?v=LaxbdIyBkL0
I'm sorry to say it is a bit like magic, unless you know the science. Even without knowing the precise cause of memory leaks, it still possible to avoid them. It may seem magic if someone has an intuitive understanding of the patterns which are known not to cause memory leaks, and then they refactor code into those patterns.
30 years later and I still suck at this game. 
And some of us do, but we don't all want to waste time to look at the same things again and again, thus my question, that unlike what you might have taken it for, was not criticism.
Good posts make it to the top, repost or not. I missed this last week but it's awesome and I'm glad I found it. Thanks op! 
Hey! hitlerdidnothingwrong.js is still good!
ES6 is swiftly becoming best-practices to use in your javascript applications. If you're using a library that doesn't play nice with ES6, you will be writing more boilerplate code anyway to do some magic tricks to make said library communicate with your other classes. React plays nice with ES6 for the most part, with one major exception: mixins are not supported when using ES6 class syntax. https://facebook.github.io/react/docs/reusable-components.html I've been building out a pretty hefty application, and I chose to use Reflux from the beginning and am now revisiting that decision. Part of what reduces so much boilerplate code in Reflux is the [Reflux.connect(myStore)] mixin. I don't want to sacrifice using ES6 class structure, which imo makes for very pretty code architecture, just to avoid boilerplate code. I've also read that facebook is planning on dropping mixin support altogether in future releases (sorry I can't find the source for this, I've read a TON about React), in which event, Reflux is going to have to change it's whole architecture to get along with React again, and all of the developers using Reflux are going to probably have to rewrite a significant portion of thier apps, or be stuck with an outdated, pre-major release in production. One thing I've found nice about Reflux is being able to call actions inside any deeply-nested component, reducing the need to chain event handlers upstream. I do like some things about the pub/sub event system, and it's also helpful at times to have multiple subscribers that handle the same action-event in isolation, but overusing this pattern is easy and can make it difficult to make changes later, not to mention forget who is subscribing to what. The bigger my application gets, the more I like the idea of a central dispatcher. I got into the habit of giving my Reflux actions unique names anyway, since it's just best practices to be as declarative as possible, just like when you are naming your functions and variables. It doesn't help you later on when you have 20 different actions all called 'update.' And it definitely doesn't help other developers figure out what's going on in your code. I'm planning on refactoring my store handling into vanilla Flux. Really, in the end, less deps gives you more control over what's going on in your application and protects you from having to fix a ton of broken code when everyone pushes out a new release. I highly recommend this presentation by Sebastian Markbage where he covers these issues more in-depth https://www.youtube.com/watch?v=4anAwXYqLG8
I still don't know if that's re-submitted , i searched with title and domain but still couldn't find anything on same. I am not often coming on this subreddit, so wont be able to know even if it is known to others earlier.
I still don't know if that's re-submitted , i searched with title and domain but still couldn't find anything on same. I am not often coming on this subreddit, so wont be able to know even if it is known to others earlier.
You seem to make the same mistake as Laerpni, which is falsely assuming that my post was criticism of a repost, when in fact it was solely a question if something worthwhile had changed in the last few days. Since by now I had time to take a look, I can also comment that there are indeed some changes.
I just saw that the previous post was deleted.
I haven't found any good tools that are easy to use, so I brute force it. I begin by visually inspecting the code... am I creating resources without releasing them, adding event listeners and never removing them, etc. Then I try to reduce the code base. I just start commenting out code until it doesn't leak. Then I go and look at the last thing I commented out.
Be aware.. all the parent post suggestions are Angular apps. There are other alternatives which may be friendlier if you are just starting out. If you are truly interested in learning, I'd start out with a simple static page, JavaScript and some CSS styling to learn the basics. It doesn't have to be a complex application and diving straight into Angular will have you quickly developing an application that doesn't make any sense at all. (personal bias here) If you want to dive into the deep end of single page apps there are multiple options and JavaScript has a TON of options that are constantly changing. I suggest you try out one of those options, search for 'React starter', 'Ember starter', 'Meteor starter', or potentially 'Backbone starter'. Take a look at each one and see if any of them make more sense to you. There is a lot of personal preference here, so don't be afraid to try each one out! As an aside, you found the right location to subscribe. We have a ton of interesting conversations around here. Just keep one eye on the various articles around here and have fun!
you should invest your skills in processing.js
&gt; waste time &gt;&gt; waste time &gt;&gt;&gt; waste time ... uhh this is reddit bruh.
Oh good. I'm glad this will finally be supported.
Does anyone have an updated es6 version as it's now finalized?
I think that is unspecified. I wrote [Zousan](https://github.com/bluejava/zousan) and called the onFulfilled (or onRejected) callbacks *asynchronously* with regard to the then/resolve/reject - but synchronously (in a batch) amongst themselves - and passed the full Promise/A+ test suite.
Could be https://www.xmind.net/. Use it at work and it's great once you understand the UI and shortcuts. 
Sweet. There are a bunch of things that can get some good optimization with TCO. They used forEach as an example in the article, but it applies nicely to most looping flow control. I would hope the js engines that support it also see the obvious place to alleviate GC pressure, for instance the implementation of reduce would be (did i get splats right): ~~const f = (op, a, x, y...) =&gt; f(op, op(a, x), ...y);~~ That should compile down to a while loop and not create any garbage. Edit: check muh infinite loops. The correct version should be const f = (op, a, x, ...y) =&gt; y.length ? f(op, op(a, x), ...y) : op(a, x); 
I expected an emscripten/asm port. Oh boy was I wrong! brb, looking for my jaw some 8 floors below. 
this is so freaking stupid. what did you crack exactly? 
Hi /u/john_philip, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
The company behind this library, Vincit, is mainly located in Tampere, Finland. In tampere they say hi and bye to eachother with the word 'moro' or a derivative of it. 'Moronees', 'morjes' etc. so it could be a funny tanget on that too.
You might wanna change the factory function name from `$`to something else, as `$` is practically owned by jQuery ;)
The user a-t-k didn't check to see if it was the same link that was posted before. They just assumed it was, and then assumed it was a repost. It's trivial, but this is what ruins communities. If you see a repost just hide it and move on. If a community is growing, *good* reposts are not only expected, but should be encouraged. There are literally users that saw this post today that were not on reddit a week ago. 
[**@mkldny**](https://twitter.com/mkldny): &gt;[2015-06-30 13:39:48 UTC](https://twitter.com/mkldny/status/615877398362484737) &gt;data:text/html,&amp;lt;body onload="l=location;t.value=atob\(l.hash.slice\(1\)\)"&amp;gt;&amp;lt;a onclick="l.hash=btoa\(t.value\)"&amp;gt;Save&amp;lt;/a&amp;gt;&amp;lt;br&amp;gt;&amp;lt;textarea id=t cols=99&amp;gt; ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/3bmpmn%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Buy a java tutorial course ASAP.
This is just a syntax brain map. Don't think it goes into scoping issues. 
Preaching to the choir.
Also, I'd like to have the native mind map file to add to it.
Here is a very basic example I use to get started. Not very sophisticated. https://github.com/ThePerryR/zion It's node/express, mongodb, passportjs on the backend and on the frontend is React.
&gt; Is this possible in JS, to change the URL text and attribute? Yes, most definitely. html &lt;div id="menuItem"&gt;&lt;/div&gt; js function setMenuItem(introducer) { var menuItem = document.getElementById("menuItem"); if (introducer == 12345) { menuItem.innerHTML = "&lt;a href='tel:+44123456789'&gt;introducer1#&lt;/a&gt;"; } else if (introducer == 54321) { menuItem.innerHTML = "&lt;a href='tel:+'&gt;introducer2#&lt;/a&gt;"; } } setMenuItem(12345); //setMenuItem(54321); You guys wanna hire me?
I believe you meant http://www.google.com/#q=How+Do+Browsers+Work
Since browsers are singlethreaded, I feel that someone doing something like this: for (var i = 0; i &lt; callbacks.length; i++) { setTimeout(callbacks[i], 1); } is adding complexity where none needs to exist :/
`foo` won't be touched unless `bar` is changed to point to something else. We weren't discussing what is problematic. We were discussing how "difficult" it is to create a memory leak. It's not difficult at all. The GC isn't intelligent. It can't really make assumptions about variables your application has hanging around.
Wut? function main() { function foo() { console.log('test'); }; foo(); } No global namespace pollution. (Except for, in this case, "main", which can be whatever function you already have as a wrapper. 
I've been working on [a little book](http://survivejs.com/) about Webpack and React. Maybe that will help you to get started.
My point was just that it's kinda weird and broken that the entire ecmascript API is based on "classes" without a real Super other than Object.prototype. I love OOP (prototypal OOP even more so) and there are lots of applications for it that work beautifully. It's just that operations like replace, map, slice, etc. aren't examples of those applications. It's just a weird decision we're stuck with because I presume Eich didn't want those functions just floating around in the global namespace.
Ah, interesting. That sounds like a valid strategy. I guess you still use the Chrome Timeline to check for memory leaks?
Any good source that shows patterns to avoid?
This is really helpful. Thank you.
That's how you get mad karma.
It should probably also be noted that only heap allocated objects are going to need garbage collection, since with stack allocation the memory is freed automatically. This kind of wanders into "it depends" territory, but depending on the JS engine, some things will be stored on the stack instead of the heap for efficiency. 
 function getLocationQueryString(variable) { var query = window.location.search.substring(1); var vars = query.split('&amp;'); for (var i = 0; i &lt; vars.length; i++) { var pair = vars[i].split('='); if (decodeURIComponent(pair[0]) == variable) { return decodeURIComponent(pair[1]); } } return "" } var introducer = getLocationQueryString('introducer') if (introducer == '1234') //'1234' is a string $('.menu19 a').attr('href','tel:+phonenumber') // have to change this to real menu classname else if (introducer == '4321') $('.menu19 a').attr('href','tel:+phonenumber') else if (introducer == '') // default, blank query string 1 // do nothing edit 2: '1234' definitely a string also not sure how to set your menu, best way is to add class="promophone" and if your using jquery do `$('a.promophone').attr('href', 'tel:+phonenumber')`
I'm slightly confused by this comment since, looking at your code, the callbacks are called asynchronously. `soon` is used to defer all the important operations. When a promise is resolved or rejected, the calling of the resolve / reject handlers is delayed. When `then` is called on an already-resolved promise, the resolution of the newly returned promise is delayed. Once the callbacks start executing they are looped through synchronously, but this does not make the operation synchronous. Outside of the promise implementation, it will just look like the asynchronous callbacks are called really quickly. This will never lead to a scenario where ex. `then` immediately calls either callback. This optimization is also covered by 3.1.
cool, gl.
Great work! An html version would be amazing as you could also search inside it... 
I think Hot Towel is based on express, you can use the server side of it. https://github.com/johnpapa/generator-hottowel
What warning are you going to display? "Warning: everything will still work just fine!"
yeah, that's what I assumed. It really would make searching the internet sketchy if that was the case. 
What I was implying I suppose is it is difficult to create a memory leak that the GC won't pick up. Once you're out of scope, you're good. Sure, someone who is new to JS and implements a bunch of anti patterns and no scoping could do it, but they won't be writing anything that will be used anyway with that so...
IOC is a necessity because of Java's compiled nature. JS being dynamically typed and interpreted, dependency injection is effortless and doesn't REQUIRE IOC. &gt; I understand that JavaScript doesn't support Interfaces but uses duck typing. In Java we tend to always code using interfaces and not implementations. How common is duck typing used to accomplish the "code by interface" mantra. JS, being a prototype language, favors composition. &gt; In Java, java doc is very important. However, win the few libraries I have looked at, functions are barely documented in code. Any reason for that? Laziness. There are a handful of good tools out there to generate API documentation. as well, some people just write structureless comments and generate documentation as annotated source code. Sometimes thats nice, mostly it's not. &gt; For anyone that has went from Java to JS, what are some other differences in programming culture you have experienced? thanks in advance. Javascript is an immature language with an immature community. I don't mean that everyone behaves like children though, but I do mean that JS has only just started to grow up. As such, it is suffering greatly from Not Invented Here syndrome. This will eventually sort itself out and people will congregate around certain core ideas that are represented by certain popular frameworks and libraries. Java is a class-based OO language, and JS is a prototype-based OO language. These concepts have many differences. Java and JS have many similar tools however: NPM is the main package manager. It works similarly to Maven. Centralized repositories that contain the actual packages you want. You can setup private cacheable repos with NPM (think Sonatype's Nexus). Grunt is similar to Maven. It's all configuration based. Gulp is similar to Gradle or Ant, where build tasks are mostly just pieces of code. Unit testing is a bit different from JUnit. The best options in my opinion are Mocha (test runner), Chai (assertion library), and Sinon (mocking), or JasmineJS (all of the above in one package), but there are others such as QUnit and Nodetest. There are plenty of tools to generate JUnit reports however for integration into your favorite CI server or Sonarqube. JS has sloppy syntax for modules. For the current browser standard, you have CommonJS and AMD syntaxes, and for the newest standard of Javascript (called Ecmascript 2015), you have this: http://eviltrout.com/2014/05/03/getting-started-with-es6.html. Definitely not wonderful when compared most other languages. The JS community is impatient, and riddled with transpilers that will convert one standard of JS to another, or convert another language to JS. For example, the ES2015 standard is not supported in any major browser 100%, so people will use tools like BabelJS that will spot ES2015 syntax, and transpile it into ES5 (the previous standard) syntax. Others will use "polyfills" which will manipulate the core JS library to support ES2015 standards. I am not a big fan of any of this, but I prefer polyfills over transpilers as you have better control over polyfills. I can't think of a Java analog, but there are examples of this in other languages like the Python 2to3 tool. JS is split between server side (NodeJS based on Google's JS engine) and browser side (IE, Chrome, Firefox, etc engines). This is sometimes confusing. In general, JS is single threaded, and on the server side, it has non-blocking IO. This is quite different from the JVM and it's native threads. They solve different problems. I can't see why someone would use NodeJS over the JVM for CPU intensive problems, but I can see why one would use NodeJS over the JVM for IO intensive problems. 
Hey again! First and foremost, make sure you actually have a div with id='menu-item-3407' in your html. Should look like this: &lt;div id='menu-item-3407'&gt;&lt;/div&gt; Your js looks good! But for the function to run, you need to trigger it by having an event like a button click or mouse over or just calling it in the js occur. To call it in the js, just add setWhisper(); with your introducer number as input (the part between the parentheses). If you want it to run automatically, then we're going to have to do a little extra work... 
Alas, also the mindset of the people who complain about other people who they mistakenly think complain about repost...
Yeah no I get it. I kinda figured that's what It was but I just wanted to reinforce my theory. So JS has automatic garbage collection, are their languages that make you manually manage garbage?
Bookshelf follows Backbones model / collection patterns. That is big annoyance for me.
Actually, both of your strategies are incorrect. The actual choices are: * Use `setTimeout` or similar deferring mechanism to execute each callback, or * Batch the calls by putting them in a queue and then flushing the queue via a single `setTimeout` or other deferral. High-performance libraries generally use the second approach. But the whole point of the "A" in Promises/A+ is that it should *never* be possible for callbacks to be executed as an immediate side-effect of interacting with a promise, whether that interaction is calling `.then()` or resolving/rejecting the promise.
You're calling them asynchronously, just in a batch. Batching is allowed, and all the highest-performance promise libraries use batching.
Why not learn both? You'll be a stronger programmer for it.
No one implements it yet. Or has public plans to implement it. You'll be waiting a while, sadly :(
&gt; The original mindmap diagram is drawn with Mindnode and exported to PDF/PNG/OPML files along with a *.mm file which can be edited with FreeMind, another SVG file will be released after the whole project is finished(issues #9). I found this info on the [project's GitHub page](https://github.com/coodict/javascript-in-one-pic/).
A quick eyeball scan of these comments tell me you have a cumulatively negative score of about -25. And you're arguing with multiple people. Let's be more constructive. Use the "hide" button next time...
Perfect choice of libraries. Tx.
I've worked with Ext and Sencha Touch quite extensively for a couple of years. While I would prefer to work with Ember or React, I've built plenty of custom components with the Ext products (that is, components that are outside of Exts widgets). It's as simple as setting up a controller, view, model and store, then styling the component with sass variables and classes. Not really any different than another framework. 
Is it just me or is this webpage loading in basic HTML?
You still think I would be more concerned about fake Internet points than about this community? And you tell me to be constructive? I am strangely curious how you arrive at such conclusions.
Wow I have never heard of or stumbled upon that. 
 Yeah, that will definitely work; it just seems a bit tedious to import each one. That may simply be the only thing I can do here though. 
what's wrong with: import {2WD,AWD,4WD,Car} from 'car';
my actual const list is longer and have much larger names... it works, just a bit messy. 
the only people that use safari are designers and some clients. not the clients' users... just the client themselves. which makes it super important to work perfectly in it.
well I'd just use `class.CONST_NAME` then or: Object.keys(class).forEach(key=&gt;(key===key.toUpperCase()) &amp;&amp; eval(`${key}=class[${key}]`)); ;)
Firefox Nightly correctly prints **0**, **1** and **2**.
Just because it's very common, doesn't mean that it makes any sense at all, or should be used. If you did something like that in C/C++/probably most compiled languages, you'd have bar() either crashing instantly or returning a pointer to a location that as soon as you accessed it would crash. Doing something like this is going really out of the way to intentionally create something that you can't easily remove. But, as you pointed out, if you change bar, such as by running that anonymous function again, it will clean the old reference. You can also delete bar(). 
What are IOC containers and what's their purpose? Could you explain what exactly it is you're trying to achieve with them? There's probably a different way to achieve that goal in JavaScript. The major difference, other than dynamic and duck typing, in my opinion, is functional programming. To get really good with JavaScript you should learn functional programming. It's a completely different style of programming, and almost shares nothing with how things are done in Java. The lack of type checking is very frustrating as projects get larger and larger. I'm still not sure what's the best remedy here.
As a developer that tended to have to do quite a bit of design, I'd never consider both of them the same thing at all.
Stick them all in one object, freeze it, and export it.
Ugh. The worst is that there are differences between iPad, iPhone, OSX and Windows versions.
Wrap your application setup in a promise, and it should be fine as they tend to be rather robust in catching errors. var app = function() { return new Promise(function(resolve, fail) { return (function setup() { return q + t; })(); }); app().then(console.log.bind(console)).catch(console.log.bind(console)); Which should give you an error like this (in Chrome at least): ReferenceError: q is not defined at setup (&lt;anonymous&gt;:7:14) at app (&lt;anonymous&gt;:8:7) at app (&lt;anonymous&gt;:5:10) at &lt;anonymous&gt;:12:1 at Object.InjectedScript._evaluateOn (&lt;anonymous&gt;:895:140) at Object.InjectedScript._evaluateAndWrap (&lt;anonymous&gt;:828:34) at Object.InjectedScript.evaluate (&lt;anonymous&gt;:694:21) 
Ridiculous. The thesis of this post is essentially: here's a handful of absolute bleeding-edge technologies that Safari doesn't support, so it's the new IE. Browser compatibility is actually pretty good right now. The biggest problems I have day to day are with out-of-date versions of browsers.
&gt; There is a difference between not having the latest unapproved (or recently approved in the last week) candy and actually breaking basic conformance. From the article: &gt; To take an example close to my heart, IndexedDB was proposed more than 5 years ago and has been available in IE, Firefox, and Chrome since 2012. Apple, on the other hand, didn’t release IndexedDB until mid-2014, and when they did, they unveiled a bafflingly incompetent implementation that was so bad, it’s been universally derided as unusable. (LocalForage, PouchDB, and YDN-DB, the major IndexedDB wrappers, all ignore Safari’s version and fall back to WebSQL.) But I guess you didn't make it that far if you stopped 3 sentences in where it mentions Twitter :)
I didn't mention a horribly designed API. I just said that iOS Safari and OS X Safari feel like the same thing when you're writing JavaScript. For instance, try to use IndexedDB in either one. Same shitty thing. The thing about Safari being the new IE is about having a popular browser that is missing some key features and has very buggy/non-compliant implementations of some others. And having the company that makes that browser seemingly not care about those problems. Basically I'm paraphrasing the original article at this point :)
&gt; The thing about Safari being the new IE is about having a popular browser that is missing some key features and has very buggy/non-compliant implementations of some others. I hear your point, but IE was a special case that Safari isn't anywhere near. Maybe it has some overlapping similarities but Safari never really was the trailblazer IE6 was and I don't find it at all that behind on compliance/features compared to Firefox and Chrome. I guess Safari is the most IE-like, but that's purely speaking relatively.
`$('#menu-item-3407').html("&lt;a href='www.google.co.uk'&gt;google&lt;/a&gt;");` should be ok 
They'd also complain once they couldn't find a job.
I agree. Depending on what you're doing, you might not notice Safari's deficiencies. I am acutely aware because I wrote [an IndexedDB-based game](http://play.basketball-gm.com/) and people often ask me how they can play on iOS :)
I remember working on animations similar to those shown in the Netflix example when I worked at Famous (http://famous.org/). It's actually pretty cool as they take advantage of css transforms and animations.
It's pretty common to have a separate constants module for constants that are used in more than one place. If you don't want to import them individually: import {ALABAMA, ARKANSAS, AND, SO, ON} from 'constants'; ...just import the whole object: import C from 'constants'; doSomething(C.ALABAMA); 
I stand corrected. In that case, I agree. The use of $ should be reserved for the major selector libraries (jquery, zepto, ender). 
Ok. That's a failure of Safari. I can point out major failures and sources of frustration for other browsers. Chrome has had **terrible** support for web typography *for years*. And cross-platform, cross-browser HTML5 video is still mostly impossible thanks to Firefox. The point being, IE was *IE* because it was a consistent, endemic source of incompatibility and frustration for developers. It did not have flaws, it *was* flawed. To say that, today, Safari rises anywhere close to that level is ridiculously hyperbolic.
Safari is worse than IE as they provide nothing like http://dev.modern.ie/tools/vms/ officially 
Doesn't help Apple's case that Safari's the only application that can JIT on IOS. I've mentioned before that IMO if this were done by Microsoft there would have been antitrust action.
Ever tried to use the tools in old IE? If you had, you would not be inclined to agree with this statement.
I'll concede IndexedDB. So what else? What are all of these magical things Safari is holding back? Look, 5 years ago I would seriously have said that I felt constrained by IE and that it was the biggest singular obstacle to moving web development forward. Are you seriously saying that this is literally true today of Safari?
Didn't Microsoft do exactly that with Windows RT and that's why Mozilla stirred up a shitstorm?
Reminder that IE still lacks basic support for things like preserve-3d and decent antialiasing.
i can't think of a single reason why any front-end code wouldn't be using a build process with an automated task runner like grunt or gulp. if you're not concatenating and minifying all your JS and CSS, you're not deploying to production. nevermind the fact that if you're not using gulp or grunt, that means you're probably not using any sort of unit test suite, which is also a must-have for production. even in the back end with node you should still be using grunt/gulp for unit tests/linting. I can't say I fully agree with hopping onto the ES6/7 train yet, but anyone who's even a semi-decent developer is using a build process. 
&gt; Doesn't help Apple's case that Safari's the only application that can JIT on IOS. This isn't true with the new API introduced in iOS 8 (IIRC). Still only the platform JSC library can JIT, nothing else can, though. &gt; I've mentioned before that IMO if this were done by Microsoft there would have been antitrust action. Apple don't have anywhere near a monopoly (even on mobile, their marketshare is less than 50%), so there's no anti-trust action to answer.
Can you link me to the API docs? Or some kind of source? &gt;Apple don't have anywhere near a monopoly (even on mobile, their marketshare is less than 50%), so there's no anti-trust action to answer. IDC about anti-trust, I care about releasing software painlessly everywhere. Edit: [Still can only JIT JS, brutal API](http://www.iphonehacks.com/2014/06/ios-8-javascript-performance-safari-apps.html). So lame.
Of course. I agree. I was just pointing out it sounds like we are just moving complexity around, not reducing it. 
there is something to be said about using *standardized* complexity though. although I'm a bit skeptical of using things like Babel to transpile to working JS at the moment, it would be nice to see everything standardized instead of a long list of libraries. at my work we use just about every single library/framework out there in a single app, it's ridiculous. at this point quite a few of them could be replaced with ES6/ES7 features that won't eventually disappear and lose support, can't say the same about a public module
and that the browser upgrades are tied to OS upgrades, and some hardware can't or won't upgrade. and not being available on other platforms. THAT is it being the new IE.
I agree with this. Though it would be cute as hell on a mug or something.
That's a good point. I haven't suffered that yet as im the only JS developer at my company. The Python and C++ devs aren't used to this huge list of popular libraries. They would lose their mind at the long list of imports for a large MVC app. 
Safari is the old safari. It's always been super duper safari and it's safarality is still intolerable.
Implementing tail *recursion* optimization is straightforward, and can be handled by transpilation. I believe that Babel does it already. True tail-call optimization in a transpiler is a global transformation, and I have trouble believing it can be done in an environment mixing transpiled and non-transpiled code.
BS: https://html5test.com/results/desktop.html http://css3test.com 
Thank you
Maybe you can diff the source of your page with the source when adblock is enabled. CTRL+U might not work as that is the source as it comes from the server. But maybe you can right-click the html node in dev tools and copy then paste into a file. Then do the same with adblock enabled. Investigate and see what you find.
Wow! You really are clueless. I already called BS on you in your other post so I won't do it again here!
great, thanks!
It's really great as long as you don't have animations that overlap into other laid out sections of the page with new render contexts. Usually best to avoid that from a UX perspective anyway; and a good designer will architect a page nicely to start with. Using transform animations where everything is done on the GPU helps a LOT though; really nice work there from Netflix, and this demo from Eli.
Safari cheats somewhat, for example they "support" form validation but the form will not error, display a message, and will submit anyway. edit: And regardless, does not change the fact that it is an extremely hard platform to test for without physical apple hardware which is unlike any other browser on the market besides the blackberry browser or something obscure like that.
it might be because (desktop) safari has less than 5% browser share. not spending time implementing all of this stuff might legitimately make sense.
&gt;Then you're doing it wrong. The web developer's mantra is, still, if it works in IE, but not the other browsers, your code is wrong. &gt;While Microsoft likes to tell you how Edge is going to be, just like they told you how IE 7/8/9/10/11 were all going to be Firefox/Chrome killers, it is only IE without all the legacy baggage. It is still the same IE chugging along, adding new features and properties years behind every other browser, and that includes Safari. Edge is adding features that Firefox and Chrome are considering/implementing on a similar timeframe. MS hired a former Mozilla standards guy that is working with the Edge team and a consortium of other browser teams to align standards compliance. What the fuck are you talking about here? 
All I care about is a functional default browser in Windows 10, not someone's browser vitriol on Reddit. Come back in a year and tell me how Edge is doing, and then be quiet.
As I said, heard the exact same crap with IE7/8/9/10/11 and it's never been true. In any case, facts bare it out in my links: Edge can't hold a candle to **today's** Chrome and Firefox. And, in your one year waiting time, you think Chrome and Firefox will be sitting still?! Ha! You won't even be in this business one year from now.
&gt; Then you're doing it wrong. The web developer's mantra is, still, if it works in IE, but not the other browsers, your code is wrong. I follow the mantra "if my code follows the spec, then it's right regardless of how the browser handles it". But it's a useless mantra since the entire point of writing code is for it to work. So right or wrong, code that doesn't work in certain browsers is still broken code. Microsoft has certainly upped their game in recent years when it comes to developer engagement, so it's not really fair to compare them to their older browsers which were much more closed to the public. Also, for the time IE8 and 9 were good browsers. Chrome actually sucked shit when IE8 was released, but it improved quickly. Also I'm not really sure what you're arguing here. Can't really dispute the fact that Safari leads IE in features, but compliance means more than just adding formalised features. These features must work as expected in every situation you throw at it, and with any other features you combine them with. Safari, I found, behaves differently a little more often with edge cases than other browsers.
Methinks you don't know what you're doing. IE **needs** VMs for test. No other browser does except for Safari but I'd rather test in a better browser like Safari than have to deal with any version of IE or Edge.....and I do! But you need other hardware to test on mobile so your complaint is invalid. btw, do those VMs run on Linux?
Yus, their linux target of choice is Virtualbox but I think you can port them to vmware as well. I can also test for mobile pretty well with a lot of tools including android emulators which run everywhere.
&gt; I follow the mantra "if my code follows the spec, then it's right regardless of how the browser handles it". And what if you only think you are. That's typically the case of people who don't know what they're doing when they blame the browser when their code doesn't work. I've been listening to that BS for 11 years now and here we are with another BS Microsoft browser that all of reddit is raving about as the new [insert browser] killer. Same story as before. Nothing has changed and redditors never learn. My links don't show features. They show compliance and IE trails the pack as always.
My opinion on this is that even though the author's comparison might be a bit off (see the bikeshedding everywhere this has been posted, including right here), the truth of the matter is that Safari is behind, and it's costing webdevs time, money, and happiness. See /u/cwbrandsma's comment [here](https://www.reddit.com/r/javascript/comments/3bns68/safari_is_the_new_ie/cso6oea) also.
I'll be back in a year, still in the business, to reply to your original comment and call you an idiot. I really hope you aren't a developer because your co-workers probably don't enjoy working with you. Edit: It's important to understand that THERE IS NO BROSWER WAR, these companies aren't trying to own the internet like its 1998 still. There is no money in becoming the next AOL, because look at what happened to AOL: they became a media company and that's where the battlefield shifted to. Don't be that guy.
Wait, what?! VirtualBox?!! You are totally lost man.
Hey man, I visited your site and read the first article in this series. I found it very helpful, but I do have one question, where art articles 2, 4 &amp; 5?
I know Devs can be stubborn. I know I am. But damn you top the cake. Stop being narrow minded. 
And 7?
&gt; IE tends to chug along just fine. uhhh which IE?
If you are a typical redditor and going to try and make this thread about me, then I'm done. It's not narrow minded to prove Edge sucks.
IE10/11? They're pretty good, and I would make 11 my default browser if it supported extensions.
oh ok, makes sense. thought you meant supporting IE8 doesn't seem to be an issue.
&gt; You are really stretching your credibility man. And your attitude is destroying yours. Can you try and be a little more civil? It's just a discussion about web browsers, it's not a big deal.
This tutorial is pretty good, has linking of social accounts to one main user account https://scotch.io/tutorials/easy-node-authentication-linking-all-accounts-together
&gt;Can Javascript be used in conjunction with Python/HTML/CSS? And if so, is Bottle still required as well? JavaScript = any logic on the client side (in the browser) if you want server side logic like database interactions or building an API, you'll need something else. pretty much everyone building web back ends uses a web framework in their language of choice, there's a ton of them. if you're used to python go with Bottle or Django. or if you're learning JS already, you could try your hand at server-side JS with node.js
Haha yeah nah no IE8 support from me... Although, even that is actually *not* that bad. I mean, more often than not my websites work and look perfectly fine in IE8 without ever testing it.
It might of been mentioned here before or there is an article out there that made Safari/IE antitrust comparison. Legally Apple can get around it because they also control the hardware unlike Microsoft. I'll try to dig the reference up later too lazy right now.
You should start seeing a therapist. If you're already seeing one you might want to consider going a lot more often.
Safari private mode is also rage inducing. Every other browser will just clear indexeddb/localStorage/sessionStorage on close, but it completely breaks them...
Generators rely on their internal state to do what they do. "Yielding" returns a value as a result of that particular state. Without digging into it, my opinion is that tail-call optimization has limitations similar to `catch` and `finally`. A generator requires a context that can't be optimized away. That said, I can think of ways to regenerate state before each yield, and make your generator stack very small, but then you're wasting CPU cycles to avoid stack and memory limitations. Speaking of, generators typically don't have an ever-growing stack. Their next yielded value is calculated off of their previous state, so I'm not sure exploring tail-call optimization for a generator even makes sense.
And, you know, iPhone users. One or two of those around.
&gt; well I'd just use class.CONST_NAME then Thanks to googling "const in es6 class" I learned [this](http://stackoverflow.com/questions/22528967/es6-class-variable-alternatives) and now I'm upset.
I think this guy is just mentally retarded. Why is everyone still responding to him?
I cannot agree with this statement enough. Safari is an absolute pain to work with, and that is just the desktop version. Don't get me started on the bug-riddled half implementations in the iOS versions of Safari which cause me so much pain I have been in situations where the product team have made a conscious decision to take it on the chin and move on. The modern day Apple looks an awful lot like 90's Microsoft and look how well that turned out for MS, the countless antitrust cases. I am loving this new brave and highly innovative Microsoft, Edge is a great browser and a wonderful step forward. Thankfully Safari's market share on desktop is so low that we don't have to worry about it, mobile however is another story.
I wish this bug was fixed... https://github.com/Microsoft/TypeScript/issues/17 I ended up avoiding the typescript-loader because it was buggy the first time I looked into it. Currently I use `grunt-ts`, which basically transpiles each module/file into a CommonJS javascript file, and then use Webpack to just bundle the js modules. If you're not using grunt or gulp, I imagine you could just pre-build with the Typescript compiler and do the same. If you need to produce a single Typescript definition file for your project and all of it's modules, use [dts-generator](https://github.com/SitePen/dts-generator).
Great technical breakdown of the effect, especially going about it the right way using native Javascript API's and methods like classList instead of something like jQuery. The lesson here is to rely as much on CSS animations and transitions as you can and avoid using Javascript where possible to prevent redraws and reflows which can be expensive in large layouts.
Nah mate, I'm getting some seriously advanced HTML coming my way :P Try refreshing a few times.
I'm thinking of, eg. function* ascending(n) { yield n; yield* ascending(n+1); } where the obvious implementation has an "inverted stack" of generators: if you make a `const x = ascending(0)`, at the second `next` call, you allocate another `ascending(1)` and point to it, and then that points to an `ascending(2)` and so on. But since the `yield*` is in "tail-position", it seems like it'd be permissible to eliminate it―at the second `next` call, construct the `ascending(1)` object on top of `x`, etc. Is there an obstruction to this? I'm sorry, I didn't understand what you meant by "regenerate state before each yield" though.
You declared num inside of the do {} block and then try to use it outside of the block in the while() and then again underneath the whole thing. You'll need to find a way to move the declaration of num to above the while and outside of the do statement, but keep the bit where you prompt for a number and set num inside of the block. Have a quick read up on blocks and scope, it's a thing that's present in a lot of different programming languages.
 var numberCheck = function (x) { var num; if (isNaN(x) === false &amp;&amp; x &lt; 9E15) { return x; } else if (isNaN(x) === true || x &gt; 9E15) { do { num = prompt("The number was either too large or not a number at all. Please re-enter your number:"); num = parseFloat(num); } while (isNaN(num) === true || num &gt; 9E15); } return num; }; Would this work? It's no longer saying that num is out of scope. I delcared the variable num right above the if statement. Also thank you for your help
Ah, i guess i was thrown off by the example returning a function rather than an object as is the normal pattern.. Which made me think it was doing something weirder.. I guess. Still, you can delete the resultant object / function, so i don't think this really counts as a leak. If the internal functions lost their references to the variables they'd still get cleaned up too. 
I am not familiar with how JavaScript implements generators, iterators, and enumerables, so much of this is intuition based on what I know about other languages and runtimes. What happens internally is JavaScript constructs a state machine (State machine sounds wrong; I think I'm using the wrong term). In your example, you could envision it refactored as such (ignore anything about tail-recursion here, that's not what I'm demonstrating). (function() { var self = this, _nOriginal, _nIncrement; self.reset = function() { _nIncrement = _nOriginal; }; self.next = function() { return _nIncrement++; }; return function(n) { _nOriginal = n; return self; } }).call({}); Essentially, `next()` is called, and the value is returned. You can see here how the generator's `_nOriginal` and `_nIncrement` can't be optimized out of the tail-call. `_nIncrement`, at least, is needed for subsequent yields. So extending this to your example where your generator yields a generator *ad infinitum*, you don't add to your *call* stack so much as you are allocating whole new state machines that yield new state machines. This ultimately adds to your application's heap. I have a sneaking suspicion that JavaScript generators aren't really functions, and so there isn't really a tail-call here, but I'm not sure. I hope that helps explain what I'm thinking, at least, even if it's not entirely true of JavaScript. As for "regenerating state" I just mean create a special functiont that, for each iterative call, the previous state is recreated so the next return value can be returned. It would be computationally expensive to do this.
Never use sleep or similar in a browser. setTimeout,setInterval are Js functions to do this for you
One problem: won't work for empty “arrays”. How about: const f = (op, a, x, ...y) =&gt; x !== undefined ? f(op, op(a, x), ...y) : a; Or, if you want to work with arrays instead of parameters: const f = (op, a, [x, ...y]) =&gt; x !== undefined ? f(op, op(a, x), y) : a; 
That is correct. `yield* iterable` is basically: for (let x of iterable) { yield x; } Therefore, if you use `yield*` for recursion, there will be a chain of generator objects, each one storing the current execution state of a generator function. Unfortunately, none of these can be optimized away.
I think he is an obvious troll, but every one seems intent on feeding him. 
I'm using `awesome-typescript-loader` directly with webpack, it seems to do the job with 1.5.0. 
Us developers have nothing better to do. Also, it's compiling!
It still has the same issues as it did last week. Comments aren't identifiers, 0123 doesn't work anymore, 0o and 0b are missing, etc.
Thanks to lots of great community feedback and input, xtypejs now has a home at [http://xtype.js.org](http://xtype.js.org), with great documentation, user guide, and lots of examples.
Using the CSS ~ operator, you don't actually need JavaScript to move the other tiles: http://codepen.io/anon/pen/Nqyxeo
&gt;The JS community is impatient, and riddled with transpilers that will convert one standard of JS to another, or convert another language to JS. You seem annoyed at the industry trend of transpilation. Why?
Your second code block is broken. The `setTimeout` line is equivalent to: console.log(name); setTimeout(undefined, 0);
As of iOS9 you'll be able to embed Safari itself using `SFSafariViewController`. Better, but still not ideal. &gt; IDC about anti-trust Why did you bring it up in the first place, then? :)
&gt; http://codepen.io/anon/pen/Nqyxeo That is shit hot, thanks
Look, we can argue until we're blue, but different sites prioritize different specs by breaking them down into more and more points. For example, should ES6 Proxies be 21 points, or 1? I'm not sure there is any objective way to rank browsers, but at least I can say that looking at Edge versus Safari, one is clearly ahead. Are either as good as Chrome? No*. But, anyway, since you think I'm lying: https://i.imgur.com/REcOMlA.png I just ran the test on Edge on my laptop. There's no reason to be snarky. \* Edge has better support than Chrome canary (Chrome 45/46) in ES6, but worse in CSS3. Both will be part of a future HTML standard, so how do you say which is further ahead?
My personal pain point, because it limits our App in Safari: Try offering a Blob as a download. Firefox and Chrome are easy with `URL.createObkectUrl` and the download attribute, IE 10+ has an even easier to use (but propritary) API. Safari? Requires huge workaround contained in libraries like this one: https://github.com/eligrey/FileSaver.js/ Oh and the Webkit devs essentially don't care: https://bugs.webkit.org/show_bug.cgi?id=102914
Because of two things: - avoid collisions between property names - implement private properties, goes with the previous point; and "for all practical purposes" -- which isn't "secrecy" but avoiding more undisciplined programmers using methods and properties meant to be private and [see previous point] Of course there are other ways to achieve this. There *always* are, you only need one or two assembler instructions to do *anything* (there was an article somewhere a few days ago that it had been proven you can program anything with just MOV instructions, that they are Turing complete), so *please* let's not have that kind of discussion. There is complexity of the language itself vs. complexity of what you write with it and practical matters like how do most people (programmers) actually work when you can't pick from an idealized sample but have to live with those you find. So a contrived example that has been used: [Storing data with DOM objects](http://stackoverflow.com/questions/5905994/i-know-its-bad-to-store-data-in-the-dom-but-why). If you use symbols you avoid a lot of the potential issues.
The site you provided shows that there's only a 15 % between safari and IE11(?), furthermore, EDGE leads by 1,5 %. You're wrong, and based on MS's progress in the last three years, I think that edge will be great.
You could so some coding using the React framework. There will already be highly tested patterns used that avoid memory leaks. I say this based on my understanding of how much work has gone into an overall high quality project, rather than specifically that's it's very good regarding memory leaks.
&gt; Unfortunately, none of these can be optimized away Why not though? In the case of a basic recursive yield like above, you can't observe the generator's identity, which is the main obstruction I can see. So there's no reason a rule analogous to tail-recursion optimization couldn't be given, right?
Thank you - this is a great foundation and I will try to figure the rest out to save asking you more questions! You've been a great help, thank you.
You're welcome :-)
I'm the author of ts-loader (https://github.com/jbrantly/ts-loader). One solution that might work for you is gulp which calls webpack which calls something like ts-loader. That is what I do at my day job since we use gulp for our entire build process. You can take a look at how to call webpack from gulp here: http://webpack.github.io/docs/node.js-api.html `typescript-loader` is still running on TS 1.4 and therefore doesn't support ES6. The other 3 loaders listed at http://webpack.github.io/docs/list-of-loaders.html#dialects I believe all support TS 1.5. One thing to know is that webpack doesn't understand ES6 modules, and since TypeScript in ES6 mode outputs ES6 modules you can't feed that directly to webpack. You would need to put another loader after the typescript loader such as Babel to do the translation from ES6 to ES5. You might also consider `gulp-typescript` which I know is a popular project but I don't use it. If I'm not mistaken it doesn't do the fancy stuff you can do with webpack/browserify like pull in NPM modules (but I could be wrong). If you have more questions I'd be happy to answer them. I've found working with webpack and TypeScript to be quite nice so I definitely recommend pursuing this route.
# Example of using xtypejs. ### Go from this: function searchEmployees(value) { if (typeof value === 'string') { if (value.trim().length &gt; 1) { return EmployeeDB.searchByName(value); } else if (value.trim().length === 1) { return EmployeeDB.searchByMiddleInitial(value); } else { return { error: 'Invalid search value supplied' }; } } else if (typeof value === 'object' &amp;&amp; value !== null) { if (Object.keys(value).length === 1) { return EmployeeDB.searchByFieldValuePair(value); } else if (Object.keys(value).length &gt; 1) { return { error: 'Search by multiple fields not supported' }; } else { return { error: 'Invalid search value supplied' }; } } else if (typeof value === 'number') { if (!isNaN(value) &amp;&amp; isFinite(value) &amp;&amp; value &gt; 0 &amp;&amp; value % 1 === 0) { return EmployeeDB.searchByEmployeeNumber(value); } else { return { error: 'Invalid employee number supplied' }; } } else if (typeof value === 'undefined' || value === null) { return { error: 'No search value supplied' }; } else { return { error: 'Invalid search value supplied' }; } } ### To concise, performant, readable, data validation: function searchEmployees(value) { switch (xtype.which(value, 'str2+ str1 int+ obj1 obj2+ num nil')) { case 'str2+': return EmployeeDB.searchByName(value); case 'str1': return EmployeeDB.searchByMiddleInitial(value); case 'int+': return EmployeeDB.searchByEmployeeNumber(value); case 'obj1': return EmployeeDB.searchByFieldValuePair(value); case 'obj2+': return { error: 'Search by multiple fields not supported' }; case 'num': return { error: 'Invalid employee number supplied' }; case 'nil': return { error: 'No search value supplied' }; default: return { error: 'Invalid search value supplied' }; } }
These decorators are describing the behavior of the function. In the implementation lodash methods are getting applied to project that behavior. So I'm failing to see how that differs from your example. Can you give an example maybe?
How does this compare to Elm?
No. "function" is easier to read than (...) =&gt; something, especially when nested. I didn't do a representative study (using objective metrics, not asking the people what they think! and best if the participants are unaware of what is being tested, or that anything is tested at all) but I'm willing to bet money in the outcome. Yes that's rhetoric, but so is the claim that somehow just because you use a few less letters to write the *exact same thing* somehow magically is "better". Some people get worked up how "elegant" they can "express" this or that in mathematical notation - yet mathematicians are only better mathematicians. They are not better engineers, lovers, politicians, doctors, anything. This " more elegant syntax" thing is a dick measuring context of people "look how smart I am". Where is the proof that actual real-world outcomes are better (using "big data", not just anecdotes? *With everything else constant* the use of () =&gt; {} for function(){} lead to 20% less errors, 15% faster application, etc. using the following tests... I really doubt that would be the outcome. Many if the people writing those languages SPEND WAY TOO MUCH TIME WITH THE LANGUAGES. I started programming in the 1980s and immediately took to programming. They threw me out of the computer science class "you get an A but pelase don't show up again". I see very, VERY little real-world progress, instead a lot of back-tracking. Still, the language enthusiasts are ECSTATIC! How *elegant* they can write code now! And yet I have to write still just as low-level as 20 years ago. I can more easily manage larger amounts of code, modularization and encapsulation and testing etc. but overall it's still the *same kind of code*. With Javascript (that I sort-of like) we even went back: Now I have to worry about underlying hardware again, in a high-level language! Does this function call get its values from a fast or from a slow medium? Async or sync? Interestingly, as long as I had to wait for a human (GUI input) I never was troubled by this - but with node.js I was suddenly troubled by having to wait for *hardware* (non-humans) delayed responses. Anyway, among computing aficionados there is *way* too much self-congratulation and occupation with computing instead of doing anything with it. It's like the many MANY songs about singing, or musicals like "Cats" that mostly is about... actors and stage work! And movies about movies. It seems humans mostly care about what they do - haha. Unfortunately that's really hindering progress when it happens in such a basic *helper(!)* field as IT and programming.
Edge is a leader in ES6 support. https://kangax.github.io/compat-table/es6/ I think that's a decent indicator that Microsoft is starting to do more stuff right
Useful as fuck. 
Knock Knock. - Who's there? - It's me, another JavaScript Framework.
Lol, I love the minimized version removing two spaces and a semicolon.
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 1707 times, representing 2.4135% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_csopn00)
I really like this boilerplate - https://github.com/sahat/hackathon-starter
I'd rename it to "Kill Your Browser" game.
You haven't proved a thing 
found this the other day during searches as a recent convert to observables. looking forward to checking it out!
Are going to explain what you don't like about it or is this just a moody line...?
Another framework, that will probably has tons of bugs, a wonky way to write code, that makes sure you can't reuse anything that you wrote / will write. I really don't like these frameworks. I know it's sure easy to do a Todo app in it, but if you want to write anything more complicated, it will only hold you back.
&gt; I know it's sure easy to do a Todo app in it no, it doesn't seem easy to write anything, not even Todo app in this. I'll stick to React.
Really nice. I knew that I could use the ~ operator to move the ones after but I didn't think about listening to hover on the row to move everything left. Very smart.
FRP !== Evented programming
Look into some of the [yeoman generators](http://yeoman.io/generators/). I'm quite fond of [angular-fullstack](https://github.com/DaftMonk/generator-angular-fullstack), which has a full REST API with JSON web tokens for security, and all the fancy yeoman stuff for generating some of the boilerplate for endpoints and Angular routes. If you're not interested in Angular I'm sure there are others you might be interested in
The only thing confusing here is that you specify "start counting from the first column", but there's no mention of doing anything with other columns. Otherwise, sounds like a straightforward loop. 
Why are people so offended by new javascript frameworks? Every time there's a new JS framework, the JS world is introduced to new concepts and patterns. The good ones eventually get rolled into more popular frameworks. I know it's hard to keep up with new tools, but I'd rather be in a job where I'm constantly learning, than one where I'm doing the same thing over and over. 
Article talks about what they are, then gives a noncommittal recommendation to use each in superficially defined contexts. Not worth the read. IMO, promises everywhere. All counter arguments I've seen hinge on performance, which is funny to me because most things aren't performance critical. Composability is far more conducive to maintainability, and I would rather have an easy to maintain project than a callback hell nightmare. Anecdotally, most of the people I've had this discussion with don't understand promises, which makes it hard to convince them that they are better.
Ships can't shoot asteroids so it's pretty trivial to optimize where you easily have more ships than enemy ships spawn. Also what is the purpose of having the `Particle.step` and `BackgroundStars.wrap` methods. Are they they encouraging me to cheat by just basically removing particles like this? ENGINE.Particle.prototype.step = function(dt) { this.x = 0; this.y = 0; this.progress = 0; } At that point I could easily just add something like: ENGINE.Asteroid.prototype.applyDamage = function(damage, attacker) { this.die(); } And modify getTarget to start shooting Asteroids ha.
For the "another framework?" commenters below here's a little exposition: Cycle is a hotly anticipated framework that has been working toward a 1.0 release for the last few months. It is being watched closely by people who enjoy using observable libraries like RxJS, Bacon, Kefir, etc (this one uses RxJS). These are reactive libraries. RFP (reactive functional programming) is something similar but different and the the two are often conflated. You can kind of think of observables as promises on steroids and it's looking like [they will be part of the ES7 spec](https://youtu.be/-vPFP-2Mkl8?t=22m58s). It is common to use a reactive library within another framework (React, Angular, Backbone, etc) and that works fine. One of the exciting things about Cycle is that your entire app is contained within an observable stream. It is very lightweight glue around using RxJS along with the lightweight and performant, React-inspired, [virtual-dom](https://github.com/Matt-Esch/virtual-dom) project. The author of Cycle JS, Andre Staltz, is well-known in the space: * His [The introduction to Reactive Programming you've been missing](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754) gist is widely circulated. * [A great introduction to reactive vs. passive programming](http://futurice.com/blog/reactive-mvc-and-the-virtual-dom) also of interest is how that fits with Facebook's React and Flux. * He wrote the [RxMarbles](http://rxmarbles.com/) site. * He talks about the reactive design goals around Cycle in his presentation [What if the user was a function](https://www.youtube.com/watch?v=1zj7M1LnJV4). Reactive programming may not be your thing and that's fine! But now at least you have a little background on why people are excited about it. :-)
BOOOOOM. BOOOOOM. Who's there? [It's me, the Inception trailer noise.](http://inception.davepedu.com/)
That stack seems pretty awesome, thanks for the writeup. What made you guys choose AJAX/CORS instead of websockets?
i.e. a TodoMVC for game engines....great idea, great execution IMO! 
any ideas on how I would adjust the counter?
WKWebView can JIT; the legacy API cannot.
What is it exactly that you're looking to get out of this sub? While I don't fully agree with your assessment, I respect the sentiment. There are indeed a lot of new faces, seeing that we've [doubled in size in under 2 years](http://redditmetrics.com/r/javascript), but I think that's a good problem to have. I would be much more concerned if we went back to the pace from just a few years ago, where the only real news in the JS ecosystem was the release of new jQuery plugins. To counter your argument, because I was curious, I looked at our [stats for the month of May](https://www.reddit.com/r/javascript/comments/38h5d7/subreddit_stats_may_2015/), and this is my summation of the top 5: 1. Comic critiquing new JS frameworks 2. Deep dive into promises, async/await 3. NodeJS and io.js merge announcement 4. [video] Angular 2 + Visual Studio + Mac from a Google Dev 5. Critique of popular project (Bower) with suggested work-around/solution On a day-to-day basis, maybe it just seems like there's nothing of substance, but I think with all things considered, we have some really great content. 
Honestly, my personal favorite implementation is angular-material https://material.angularjs.org/latest/#/. Some of the other frameworks have a tendency to fall behind and don't necessarily follow the spec all the way. I haven't had any experience with material-ui (such as the react components to it). But so far I've had a really good experience using angular-material.
&gt;Why did you bring it up in the first place, then? Sorry, I was being a little terse. I don't care about whether Apple is actually a 'trust' in the economic or market definition of the word. Similarly, I didn't care that Microsoft had 90% market share back in the day. I cared that their APIs/browser weren't standards compliant. That was the behavior that needed to be corrected, as once that was corrected the market would sort out the rest.
If I understand you correctly you have some 3 3 3 4 4 4 4 4 4 4 2 2 2 values and want to end up having 30 values with 3, 30 values with 4, 30 values with 2. Is that it? Or do you want to end up with 3 3 3 27 4 4 4 4 4 4 24 2 2 2 27?
There are two ways to solve this. Either go from back to front, then you'll insert the extra elements behind the counter and don't need extra adjusting. If you go from start to end, you need to add the number of added elements to the counter. For the sake of simplicity, I would advise the former approach.
Could you tell me a something about the performance of that solution? I haven't yet used Object.observe, but it might solve a few problems in a future project rather elegantly.
Yes it is. You add some framework layer that handles a few things for you and lets you define them in a declarative way, it's still all event driven.
It does introduce new concepts. I challenge you to find a well-known JS framework (or for any other programming language) based on the idea of reactive dialogues (in other words, "mutual observation", or "fixed point x = g(f(x))". The only one that comes close is Haskell 1.0 Stream I/O, but still there are substantial differences between that and Cycle. The most complicated project using Cycle is not TodoMVC. There are multiple (at least 3 AFAIK) Cycle.js apps in production, closed-source though. The largest open-source is RxMarbles, which has been very important in the reactive community, and is integrated into ReactiveX.io. With regard to React, first of all it's not FRP. It's not even reactive (only a small part of it is reactive). Second, "the equivalent of setState is called implicitly by the "DOM driver" any time any change happens anywhere in the DOM" is just wrong. But most importantly, if it's a contender to React then it's a good thing. This is how things improve: by experimentation, by different ideas, etc. The problem of the JavaScript community isn't the abundance of tools and ways of working. It's the status quo of sticking with The Framework Of The Year just because it *sounds* reliable, and not having the curiosity or guts to improve wherever possible. If it weren't for this curiosity, then React wouldn't be were it is today. Cycle.js is just my 2 cents to the world. Have some respect please.
Well done, lucono. xtypejs looks very interesting. The source code also is very clean. I wrote a snippet of a test on yolpo here: http://www.yolpo.com/embed.html?gist=89733e1dc8e1a02c34f2 
and i think it's so awful because apple opposes google's HTML5-all-the-things, because it wants to app-store-all-the-things.
This was the high-point in the article for me: &gt; But once all the browsers support both wasm and ASM.js, and after a decent interval of browser updates, then wasm can start to grow extra semantics that need not be put into JavaScript. So the AST representation need not be 1:1 with ES6 or whatever. So up front, wasm pushes aside any time wasted on parsing .js code which is a nice win. From there, extensions get bolted on so we may whisper new things into the JS compiler's ear. It will be interesting to see where that takes us.
Thank you.
Right. So, after the process you end up with 30 rows with value 1, 30 rows with value 2, 30 rows with value 3, etc. I ask this way because, if the rest of the content of the row isn't relevant (or is fixed or something), then having to calculate 30 - 3, 30 - 5, 30 - 4, 30 - 12, etc, seems a bit pointless. I mean in the sense that, in the end, it doesn't matter how many rows with 1 there were initially. I don't know whether this would be a valid approach for your problem, because I don't really know Google Spreadsheet's API so I don't know what you can or can't do. But forgetting that for a moment, a different way of doing "mostly the same" as what you explained would be... First get all the values into an array and destroy the current rows. Starting from the beginning of the array, get each value. If it's a new value, create 30 rows with that value. If it's the same value as the previous one, don't do anything. Again, I don't know if you can do that with the API or not. I'm just trying to provide a different view of the process. 
For Mithril JS I am creating a MD library, Polythene: https://github.com/ArthurClemens/Polythene Please check out the examples and docs.
Thanks for the breakdown and the links. I'd been super confused about reactive programming and this prompted me to take a dive down the rabbit hole. Also realized the stuff I'd been doing with gulp with streams is related...
 @compose(_.trim) set name(name) { [this.firstName, this.lastName] = name.split(' '); } is terrible compared to set name(name) { [this.firstName, this.lastName] = _.trim(name).split(' '); } because the second is actually easier to read and understand than the first. If you just want to apply a function, apply a function. A much better use of a decorator is the debounce or bind examples below. These actually clean things up by reducing the code you need to write.
Not to mention that you only have to write purely functional code. No side effects (since all updates to state are handled by the framework.) That's a pretty big deal when it comes to testability and classes of bugs you don't have to worry about.
Unfortunately the row is connected to other values. Also the rows added would be empty. So the inserted row amount would always be different. Thanks for your help!
Well there is one excuse. IIRC, it was based on java's date class, which does the same thing. It's a poor excuse, but at least there is some method to the madness. 
didn't realize this was a thing, thanks for the info!!
commenting to review this later. I'm actually struggling a bit with the closures portion of the codeschool course, so this came just in time. 
I'm also very interested in this question. I just discovered the whole idea of reactive programming and recently got very interested in elm. It seems like taking the ideas from this library and applying it with a pure language with syntax designed for functional programming would be ideal. 
Nice, thanks for that benchmarks link! I always get frustrated when people talk about performance in callback code like the rest of their garbage code is optimized, and the callbacks are the bottleneck. It always comes with a poor understanding of the semantic difference between callbacks and promises.
What you want are named exports, not a default export (whose syntax you are getting wrong). For those, you have two options. Option one: inline, via the keyword `export`: export function fn1() {} export function fn2() {} Option two: all in one place, via an `export` clause: function fn1() {} function fn2() {} export { fn1, fn2 };
To be fair though, talking about frameworks is kind of like talking about body work at a mechanics shop. You can have a nice looking car, but it's not going to get you far if it doesn't run. I get frustrated with a lot of the framework talk here because they aren't really useful as general programming or javascript concepts - much like knowing Angular or jQuery doesn't make you better at Javascript. You may know how to write Javascript with the help of Angular or jQuery, but lost without the framework. So many of these frameworks are just re-grouping the same ideas - data-binding from this, event handling from this, message passing from this. This is one of the few frameworks I've seen on this sub that have actually spurred a very interesting conversation. Personally, it seems like this framework focuses on some very root issues, like JS coding patterns, that many others avoid entirely. 
A whole 10% shaved off the original, well worth. I'm just a little sad he didnt have a whole build process set up for it.
Hah! I used Breakout as a means to learn my way around some concepts in JS. Highly recommend this approach!
Do you feel like you are lost when writing Python without understanding Assembly? Javascript is a very basic language that we're only now getting serious about replacing with higher level structures, it's natural that there are going to be a ton of new frameworks built as we figure out what will work best for the future of the web.
Flux doesn't really scale all that well either - it works well for fairly flat applications, but turns into a monolithic mess very quickly at scale. The benefit of using Rx is that you can define component state as a stream, and then compose them together without needing a somewhat monolithic global dispatch.
Dumb question: is reactive JS mainly good for games? It seems most highly interactive websites are not dealing with input sequences of more than a click? no? 
Don't get me wrong, I'm not trying to say that you don't need to know Javascript *at the moment*. I'm saying that you shouldn't need to know Javascript in ten years or so once people have figured out how to build a strong and complete framework to replace it with, and that this dream of a strong and complete framework supplanting Javascript knowledge entirely is clearly the end goal of many if not most of the people involved in building these frameworks.
Nice! One of my favorite intros to Rx so far has been the first ten minutes of [this video](https://www.youtube.com/watch?v=2btEt0W7UxU) (though the whole things is a fun watch). It's simple, it's short, and the whole thing is hands-on demos. There's a lot of deep dives and a lot of high-level conceptual overviews out there, and those are needed for certain stages of learning, but this one is very pragmatic.
you can, the difference is on import: export function fn1() {} export function fn2() {} you gonna need import like this: import * as myThing from 'mything.js'; the option2 (my favorite): export default { fn1, fn2 }; the import will be: import myThing from 'mything.js';
Cool!
That explains it. I searched the github project for the code, but I couldn't find it. It was on Google Code.
Yes you can do that if you can edit the js application or the developer has built that functionality into the application. https://css-tricks.com/snippets/javascript/get-url-variables/ Looking at the specific example you provided, it does not appear trivial to link to the 1yr chart.
Only if the page already supports some way of passing that state. What you are trying to do is called Cross Site Scripting (XSS) and is a Bad Thing^TM because it would allow anyone to execute arbitrary code on someone else's site.
It's not a dumb question. For very simple pages with a click handler or two it may indeed be overkill. If you're adding many click handlers around a page, one benefit is you don't have to worry about removing your event listeners. (Of course any good DOM library will offer that but if you're going to include a DOM library Rx.DOM is a good choice.) For anything beyond that it immediately becomes more useful (plus you'll quickly get addicted to the API and miss it when it's not there; if you're already a lodash fan you know what I'm talking about). For example as soon as you make an Ajax call you'll start to appreciate it more than just promises. Here's a tiny example. // Create an observable for the request (nothing is executed until subscribe() is called). var github_users = Rx.DOM.ajax({method: 'GET', url: 'https://api.github.com/users''}); // Only process 200 responses. .filter(x =&gt; x.status === 200) // Convert to JSON (there's also Rx.DOM.getJSON() but this is just an API exploration). .map(JSON.parse) // Cache the last ajax response so multiple subscribers will reuse. . shareReplay(1) // Explode each array item in the JSON response to an individual item in the stream. .flatMap(x =&gt; Rx.Observable.from(x)); // Create a new observable from the result above. var usernames_list = github_users // Pull only the usernames from the stream. .pluck('login') // Akin to the .then() method on a promise. .subscribe(x =&gt; console.log('GitHub user:', x)); Nothing you can't do in roughly the same LOC using ES5 promises/map/filter and maybe a memoize function. But it's still a tight API. Enter scope creep: Now the product manager asks you to output a username each time the user clicks a link. No problem, we can reason about both activities as a single entity. // Create an observable of click events. var clicks = Rx.DOM.click(document.querySelector('#thelink')); // Combine each click with a user. clicks.zip(usernames_list, (click, user) =&gt; user) // When the list is exhausted the event handler is removed. .subscribe(x =&gt; console.log('GitHub user:', x)); Dumb example, sure. But once you start seeing everything as an event stream you start appreciating the unified API. It makes simple things very terse and complicated things easier to reason about.
How does this library differ from React?
If you can't convince him, you might want to consider working elsewhere. Your supervisor sounds like someone who knows far less about software development than he would like to believe.
You're basically saying that OO doesn't really mattern and MVC doesn't really matter and Design Patterns don't really matter. And then you suggest ES6? You think this Andy is doing vanilla JS because he's a purist? It's because he doesn't know any better.
&gt; You're basically saying that OO doesn't really mattern I am indeed! There are lots of ways to develop software, OO is just one of many, and it isn't worth being religious about -- it is just a tool. Functional is gaining tons of popularity these days, and of course Procedural (Imperative) is the old standby and dozens of other styles exist and are in common use. &gt; and MVC doesn't really matter Again, exactly right! I am glad you understood my comment. MVC again is just one of many ways to structure an app and isn't better than many of the other ones. HMVC, MVVM, MVP, MVA... and there are hundreds more... &gt; and Design Patterns don't really matter. Here sadly you missed my point. They do matter, as they are horrible and harmful and those who are slavishly devoted to them are stuck being mediocre developers their entire careers. 
I would start off with something he can see the value of. Ask him how they validate the business rules you're talking about? Is there some way where the input for the business rule is passed in, and you can easily get output and validate the result. Move from here into some unit testing for your business logic. You'll need to add at least modularization to accommodate this, but it's value should be self evident by allowing you to use a unit test runner like [Jasmine](http://jasmine.github.io/2.3/introduction.html). Doesn't need to be Jasmine of course, it's just one JS test framework. After you have this logic into modules, you'll at least have some organisation into the project. From there, I would suggest looking at where things are at with Andy, and see what he would suggest from there. Now you have your business logic in nice units, how can we organise the rest of our application so that things are clear and concise? It may look like more code to Andy, but if it makes things clearer and more obvious, then that's still a massive advantage IMO.
You know, I agree with everything you said, with the exception of design patterns. I'm a fan, but that's just because I view them as just another toolset. They're appropriate sometimes and other times not. But their most important value is as learning tools, to understand the concept that drives the patterns in the first place and why the pattern handles it. It's like reading _Programming Pearls_ but on another level. 
&gt; Not having any one of these is ok, but when all are just incomprehensible by your boss, then you're in trouble. No, it just means you have a lot of places to improve. No need to get all negative and defeatist about it -- this is a functioning business, not a business that is failing, they are HIRING PEOPLE! Their boss is worried about having to maintain something they don't understand, that is PERFECTLY reasonable. Start slow, improve over time, be a good employee -- it is a unique and bold tactic that just might work. &gt; don't you see that "something else" will by definition be a homegrown pile of crap This is some weird type of hero-worship of the existing MVC frameworks, a lot of them ARE CRAP. Many of them ARE WORSE THAN NOTHING. ----- It seems that "Andy" is scared of "magic" and I understand and respect that, magical overbearing hard to understand frameworks OFTEN cause more harm than good. So, you gotta ease him into it -- no magic, no bullshit. Start with low hanging fruit (seems like there is a lot of it) and move up as you go. 
&gt; there are huge switch statements, giant nested loops several layers deep, and the program just executes a bunch of functions and uses onclick events. omg, get out of there. Here's what I would do: directly and plainly ask for leeway to design and structure the program as you see fit. If you are rejected, start looking for another job right away.
&gt; You're basically saying that OO doesn't really mattern and MVC doesn't really matter and Design Patterns don't really matter. They don't matter. They don't matter one bit. If the implementation calls for an OO approach or a Design Pattern, then those concepts will be natural fits on their own. Javascript is an incredibly rich and expressive language, shoehorning yourself into a structure prematurely is just bad development. The question should never be "what pattern can I use to do this", it should be "what concepts can help me implement a solution." On the surface those may sound like the same thing, but they're not. The former is trying to force your problem into a rigid structure, the later is building a structure around the problem. As for MVC: - [Why MVC doesn't fit the web](http://aredridel.dinhe.net/2015/01/30/why-mvc-does-not-fit-the-web/) (2015) - [MVC: A Problem or a Solution?](http://www.sitepoint.com/mvc-problem-solution/) (2014) - [MVC is dead, it's time to MOVE on](https://cirw.in/blog/time-to-move-on) (2012) - [MVC Obscures The Mechanics of the Web](http://aredridel.dinhe.net/2015/01/30/why-mvc-does-not-fit-the-web/) (2007) - [MVC and web apps: oil and water](http://www.sitepoint.com/mvc-and-web-apps-oil-and-water/) (2005) (Granted, some of these posts are talking about backend)
Don't say "what" you're doing, say "why" you're doing it.
cyber bullying?
htmlpreview + dropbox = free hosting for many small projects
Yeah just liked the design of Bloomberg better. I'll use Yahoo, but had trouble finding the symbol for the Shanghai Index there.
By the way I wrote it, in one long sentence with no punctuation, I was trying to convey that discarding every possible pattern is bad, it's not that you need them all, but using/knowing absolutely nothing could lead to very amateurish projects (remember, it's not a conscious choice to be a purist, he just doesn't fucking know anything). It's not theoretical talk about code patterns here, the OP described zero patterns and spaghetti code with no structure. I was replying to the guy that systematically discarded all the things the OP considers good practice. I know that before I discovered MVC (on the backend), I was a terrible developer, I scoffed at code patterns, my code worked so who cares. But sometimes when you're forced into a pattern you didn't know, you realize how to structure your code in smarter ways, or why even to structure your code to begin with.
Minor nitpick here, but Relay is built on top of Flux and Relay is a framework with a server-side requirement as opposed to Flux being a pattern. Jing Chen came up with Flux and she is also one of the key people behind Relay as well. So they're both heavily related, but different. So Relay didn't really displace Flux, they can actually be used together. Relay is simply the concept of a central store as opposed to multiple stores like you might have in an application that uses the Flux pattern for your data.
There are many conceptual similarities between React + Flux and Cycle. There is a world of semantic and implementation difference though. Parts of React are declarative however other parts are imperative (setState, for example). Parts of React are "reactive" ("I'll update myself when I hear you update") but other parts are "passive" ("Please change me when you change yourself.", e.g., passing callbacks to children.) The Cycle author gave a _tongue-in-cheek_ presentation on React a while back that covers these ideas ([link](http://staltz.com/dont-react/); please note the slides provocative on purpose but the actual presentation was light-hearted and he fully acknowledged React's role as a thought leader and moving the industry forward). If you want to see what the Cycle philosophy plus Rx looks like using React as the rendering backend look no farther than the [cycle-react](https://github.com/pH200/cycle-react) repo.
&gt; design patterns are really nothing more than a vocabulary I believe (sadly) that is the theory of design patterns more than their common use. As a nifty shorthand for quick communication, they are fine, even excellent. As a "name your favorite design patterns" quiz in an interview, they are idiotic and of negative value. I think the industry has drifted to the latter not the former. I am arguing about the practical consequences of "Design Patterns" in modern development. 
&gt; Flux works quite well up to a point, but the concept of having a central dispatcher somewhat ruins composability and tends to turn into a god object. Why is the dispatcher is a problem? The dispatcher is the one thing that would make me want to use Flux over observables: centralized debugging, tooling, time travel, logging/debugging, transformation, etc. The dispatcher is probably the least problematic part of Flux conceptually: you barely have to think about it. Is there a commonly-accepted way to do something similar with observables?
Trying to do websockets directly with angular is not a great idea, you have to know the limitations of your framework. My socket code runs a digest cycle maybe once per 15-50 socket messages and most of that code lives outside of angular. Performance - while I've inadvertently hit the max listener count a few times while making data heavy stuff, I easily overstepped that problem by just hiding data points until the user needs them or by using one-time bindings. There's a limit to what needs to be visible or actionable at once on a single page/view. I'm sticking with angular until I see a replacement that's similarly flexible and still saves you from writing all the "connecting logic" that angular does with `ng-repeat` and `ng-click` (i.e. not having to write any DOM manipulation code for 90% of cases).
Who the fuck writes in pure JS without OOP in 2015 and calls themselves a front end dev? PS: I'm a front end developer
Being evil never felt so good
&gt; I know that before I discovered MVC (on the backend), I was a terrible developer Be wary of that, every time the new buzzword ("discovery") comes along you will think whatever you did before was "terrible", and you were a "terrible developer", because that is how new buzzwords are sold to the masses. Build up fundamentals so you aren't worried about the buzzword of the week -- don't worry about the label you put on a pattern, focus on the value you provider your users. Your job is to transform data usefully for your users, everything else is overhead. All code is replaced over time -- every great idea today is tomorrows shitty garbage code. That code you wrote yesterday you are so proud of in a decade will be an embarrassment... and that is good, that means the industry is growing and you are learning. Don't overvalue code, or patterns, it is the useless muck that doesn't matter. What matters is algorithms and features, the things that will remain through the endless rewrites the future will bring. 
We are currently switching to angular and I have to do my best to stop my junior colleage to put event handlers for global functions on every single node.
http://www.web-crunch.com/really-learn-javascript-series-part-1-getting-started/ http://www.web-crunch.com/really-learn-javascript-series-part-2-variables-datatypes-operators/ http://www.web-crunch.com/really-learn-javascript-series-part-3-conditionals-loops/ http://www.web-crunch.com/how-to-really-learn-javascript-series-part-4-functions/ http://www.web-crunch.com/how-to-really-learn-javascript-series-part-5-the-dom/ http://www.web-crunch.com/how-to-really-learn-javascript-series-part-6-object-oriented-programming/ http://www.web-crunch.com/how-to-really-learn-javascript-series-part-7-from-javascript-to-jquery/ http://www.web-crunch.com/how-to-really-learn-javascript-series-part-8-understanding-closures/
&gt; Why is the dispatcher is a problem? A global dispatcher is a problem because it needs to be aware of all events globally. Adding a new component that interacts with it means you need to maintain a "God Class" list of all events, and being global you can't treat your app as just a standalone composable component. These are all things easily fixable with relatively simple tweaks to the standard flux examples, so you don't have to completely throw it out. But if you start going down that road, you end up reinventing half of RxJS anyway. &gt; entralized debugging, tooling, time travel, logging/debugging, transformation, etc. You can do all of this without a global dispatcher. You just need to compose all your localized streams into a single application state atom up the same dependency tree that builds your component hierarchy. You can do this without a global singleton dispatcher. To think of it another way - Flux is a cut-down version of Rx. By switching, you're not losing the advantages of Flux, you're simply implementing a similar idea in a different way.
The interesting part is that wasm is just an attempt to define a standard for JS bytecode, plus a few extensions that are already included in future standards, for example SIMD. It's not what comes after JS, it is JS; not a replacement, but a part of it.
Thanks for the help! I'm actually quite new to using Webpack - from what you described it appears that would solve my immediate issue and more! Definitely will give it a shot. I had a nice facepalm moment today and realized that with Typescript 1.5 I can start using es6 import statements. With import statements, I could then use an es6 module loader (https://github.com/ModuleLoader/es6-module-loader) and just load up all the modules I need. For my project, I don't need to pull in any npm modules, so I really didn't need browserify after all O.o Simply put, I just needed this little statement: import "./test"; I know that specific import statement implies side effects, but it's a basic import that includes all the source right there. In the future I also have the flexibility of giving it a named import as well, but for now this works with my current project. I'm gonna get back to coding and play around with webpack some more. Cheers and thanks again for the help!
Are we really living in a world where a developer looks at a project written in vanilla JS and thinks that's weird? Really? This is Armageddon by framework.
I would be advocating for consistency and process over a particular design pattern to be quite honest. Use a Javascript linter like ESLint, implement unit testing, code coverage and possibly even some end-to-end testing for good measure. Use the appropriate front-end tooling to get the job done, a big plus one for using Gulp or Grunt to organise your tedious front-end tasks like; bundling, minification, compiling SCSS/LESS and other tasks. Also consider looking into ECMAScript 2015 (aka ES6) classes coupled with a transpiler like Babel. This will allow for neater and more uniform Javascript code, more inline with a class-based object oriented language (of which Javascript technically is not). I think design patterns in Javascript are a little redundant as it doesn't really offer the same kind of flexibility a language like PHP does when it comes to being able to namespace and class your code into module like fragments. This is just my opinion though.
I'd start with the concepts of technical debt and the cost of refactoring. Make a case for modular code, with OOP as a way of making code more modular and keeping related changes together. (Ever have to change a hundred functions because you had to change how a piece of data was stored? Ever want to?) Here difficulty translated directly to cost - the harder it is to make a change, the more time and effort must be invested. Whether you go with MVC or another architectural pattern, having one at all gives you another layer of modularity and abstraction, so you can adapt to new requirements and new features without changing as much of the existing code. Again, that translates to a little more time spent at the beginning, and a lot of time saved later on. It's about buying structure early when it's cheap, not late when it's expensive. Have you talked with Andy about how he got into programming? Sometimes people get swept into programming just because they were the only one in the office not afraid to try it. If he started that way, he may appreciate some training, if offered tactfully.
&gt; Then, convince the company to switch to angular. That's taking things a bit far.
Hmm, how would you implement unit testing without having the MVC pattern? Really, when I attempt to write proper code that is testable for web applications, I usually end up with something MVC-ish. In order to be able to unit test your code, your code should be modular. If you don't have modular code, you'll have a problem with mocking all dependencies (DOM, AJAX, frameworks, event handling, ...). Modularity and separation of concerns goes hand in hand (how are you going to chop your code into modules?) And really, is there another way to split your code in having your HTML on one side (~view), your business data/logic (~model) on the other side and then have some glue between it (event handling/actions/...) (~controller)? Well, if you end up with that structure and repeat it for each screen/part of your application you actually have a basic example of the MVC pattern. Though I'm not a design pattern-guru, I would like to have an idea how you write unit tests for code that does not follow an MVC-ish pattern.
Urgent!!! Immediate requirement for full stack php development engineer with at least 3 yrs experience in hot San Jose startup with10 years of customer satisfaction. Masters or equivalent degree must.
THIS. Your coworker sounds insecure and thus not open to learning new ideas because it's threatening. If you continue trying to craft your software instead of just throw it together, he's not going to understand how to work with it which will make you even more of a threat. Then, he will resort to the only thing he has: speed. He will write out applications with even shittier architecture in order to get them completed as quickly as possible, while raising criticism of how long it takes you to do your work. You should be looking to work with someone who either: a) has little experience and is eager to learn. b) has loads of quality experience and can be your mentor. Someone with loads of experience hammering out shitty applications isn't going to teach you anything other than how to win at office politics. Find somewhere else to work or you'll end up just like him.
Don't talk about OO and good practices. Do. One little tiny step at a time. Eventually he will see the light.
I was hoping that something like this existed.
Design patterns are a cult that consumes Junior to intermediate developers. They're suggestions, not rules, and are meant for OO languages. Javascript is not strictly OO, and treating it like Java is at your own peril. Don't shoehorn things. 
It should be noted that design patterns apply to OO languages. Javascript isn't necessarily OO, and has tools to make such patterns unnecessary. Naturally FP has its own patterns though, namely based in category theory. 
&gt; Polythene Polythene is quite nice but still beta.
sounds nice. I try Angular Material. 
(Tip: prefix your code lines with 4 spaces.) No, export statements must be in the top-level scope, you can’t put them inside functions, `if` statements, etc.
There is documentation for ES6 modules out there [1], so I tried to answer your question as concisely as possible (that is, I’m not accusing you of anything). [1] https://leanpub.com/exploring-es6/read#ch_modules
Not only is MVC not the only way to organise a webapp, I'm increasingly questioning whether it's even a very good way. I generally find functional patterns more useful. &gt; And really, is there another way to split your code in having your HTML on one side (~view), your business data/logic (~model) on the other side and then have some glue between it (event handling/actions/...) (~controller)? Well, there's the flux pattern, which doesn't really break down along those lines. Not to mention Om/Omnium style apps. :) &gt; I would like to have an idea how you write unit tests for code that does not follow an MVC-ish pattern. Really easily? If your code is modular, avoids touching the DOM, and consists, where possible, of pure functions, then it'll be easy to test. Eg, if your view function accepts a model (or your entire application state) and returns a tree of DOM nodes, you can pass it some testing data and check to see if the resulting DOM is correct, etc. Conversely, I've seen a lot of (and, shamefully, written a bit of) MVC code which is tightly coupled and effectively untestable. The average Backbone project, in my experience, is a soup of events, CSS selectors, and direct manipulation of the DOM via jQuery, doesn't have tests, and won't be getting any anytime soon. :)
It’s the logical next step after emscripten. emscripten already allows you to write HTML5 pages in C++ and other languages (for example C# via Unity3D), and wasm makes it more efficient than JavaScript itself when it comes to loading/parsing the page. It might look small, but it’s very significant for certain areas that were traditionally not web-related, like gaming.
I don't think I get the idea behind this? Why wouldn't you just use CSS-classes and data-attributes like, for instance, slides.com? I build pretty much everything in React these days and love it, but this seems pointless to me. Did I miss something obvious here? Why would I want to learn a bunch of new component and property names like &lt;ListComponent&gt; &lt;ListItem /&gt; &lt;ListItem /&gt; &lt;/ListComponent&gt; instead of &lt;ol&gt; &lt;li /&gt; &lt;li /&gt; &lt;/ol&gt; 
Hard to say whether he is right or not - not enough details about the scale and complexity of the project. Let me start by giving an example [CodeMirror](https://github.com/codemirror/CodeMirror/blob/master/lib/codemirror.js). This is the code that supports many online code editors. It has quite huge impact. Can it be simplified - probably. Would it require a lot of effort - probably. [Some discussion](https://github.com/codemirror/CodeMirror/issues/747), where MVC is also discussed. But do note, that it's maintainable, even without the "explicit" design patterns. Exhibit 2, [TodoMVC app without the MVC](https://github.com/ondras/todomvc/tree/gh-pages/vanilla-examples/vanillajs-ondras/js). Just by using "Design Patterns" your code won't necessarily become better, it might become worse as well. "Design Pattern" solves a particular problem (often in a particular language when taking GoF as basis), when you don't have that problem you shouldn't be using it. Also every design pattern has it's own trade-offs in complexity. When using libraries then every dependency is also liability. Does that mean you should never use libraries - obviously not. But just depending on some small feature X in library Y you might be pulling in 100MB of dependencies, that could be solved by a 3 line function with no dependencies. Of course, if you tried to write CodeMirror from scratch it would take years of development to ensure cross-browser compatibility. Before making anything reusable, first make it usable. A lot of code doesn't get reused, and making it reusable, means you are spending time on something that has absolutely no value. Sometimes it's also easier to rewrite something than to reuse some old code. So as a suggestion for both of you, read [Eloquent JavaScript](http://eloquentjavascript.net/). I think it strikes the best balance between OO and functions in JavaScript. Essentially worry less about design patterns and more about what brings value to the user and how will the software evolve - you'll make better decisions that way.
I don't know. JavaScript isn't *that* bad...
[How Browsers Work: Behind the scenes of modern web browsers](http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/)
Totally agree. Wasm definitely has some real potential use cases, but the there is something wholly good about the openness of the current web languages (html, css, js). It wont be positive if companies try to replace all JS with something like wasm; perpetuating old ideas of keeping code proprietary and closed. 
But I think angular Material has the worst performance . :/
It’s spelled [WAT](https://www.destroyallsoftware.com/talks/wat), not “WTF."
Similar to Gulp, Fly favors code over configuration, but aims to provide a definitive simpler way to describe and compose tasks. + Fly shuns the stream-based implementation common in other build systems and favors promises and generator based flow-control via co-routines. + Fly is written in ES6, but it does not require you to write your modules in ES6. + Fly still lets you compose pipeline-like sequences, but it's not constrained to the stream metaphor. + Fly requires at least Node 0.11 for generator and promise support. + Creating filter / transform plugins is as simple as adding your own filter function into the pipeline via Fly.prototype.filter. + Async sub processes can be wrapped into a promise using the Fly.prototype.defer built-in method. + Tasks are described using generator functions and operations that return a promise are yielded with yield: exports.task = function* () { yield this.task.deploy() } + Plugins are automatically required and available via this.pluginName inside tasks granted they exist inside your node_modules directory and listed in your package.json dependencies, devDependencies, etc. + You can add tasks descriptions using JSDoc syntax /** @desc description */.
Haha, yep - that's what I used within the article (As can be seen by the prominent meme photo with the title "WAT.").
I oversimplified. It's not VM bytecode, but a very tense, effective format.
Right but he's the one here asking for advice, trying to improve. He has little room for growth if he doesn't have a strong mentor.
The tag names allow context based inline styles to be applied, along with any other behavior. Check the source out, you'll see what I mean.
The WebAssembly AST is NOT javascript AST. It is just a pre-parsed form of an assembly language.
One option is to use something like GreaseMonkey (for Firefox) or TamperMonkey (Chrome) which allow you to execute any code you like after the page loads. So, you could automate the clicking of the "1 Year" button with code like the following: document.querySelector("[data-value='1_YEAR']").click() 
It seems you've missed the eval function
Yes - thats right met48. Sorry for the confusion. The OP was asking whether EACH callback that is waiting on a promise needs to use an async mechanism such as setTimeout. This would have the effect of clearing the stack of even promise code - but as anonnomis2 quoted above, the spec allows "platform code" to exist in the stack, and hence, its ok to "batch" them as pje states above your comment. [I'll edit my comment above to be more clear - thanks!]
Sorry for the confusion - See my comment below. I've edited my comment to be more clear.
Doesn't the fact that webgl is a subset of open gl 2.0 also contribute to the speed difference? And you can get non-webgl code to run that fast by hand writing js. Fairly easily actually... Using typed arrays and keeping variables local lets ylthe VM get insane speeds after a short warmup. Still, when you consider that js is a dynamically typed "interpreted" language its fucking amazing it can achieve the speeds it does. I just have a sore spot being told by "experts" that they can't use NodeJS because JavaScript is slow, so they go with python instead...
&gt; Doesn't the fact that webgl is a subset of open gl 2.0 also contribute to the speed difference? How? The Web browser just translates it to the same OpenGL/DirectX calls. &gt;And you can get non-webgl code to run that fast by hand writing js. Fairly easily actually... Using typed arrays and keeping variables local lets ylthe VM get insane speeds after a short warmup. Most optimizations a C++ compiler does are not useful on a source level. If you would do those, you couldn't read it any more (like aggressive inlining, reordering commands, etc). That's why there are things like the closure compiler, which translates JavaScript to JavaScript with an optimizer step in between. However, the optimizer integrated in llvm is much better than most of them (I think gcc is even better right now, but that one doesn't have an asm.js backend). &gt;I just have a sore spot being told by "experts" that they can't use NodeJS because JavaScript is slow, so they go with python instead... That one's funny :)
maybe I could have worded that better? Spring and other similar tools that work with compiled languages like Java or C++ solve the problem of runtime dependency injection. JS, PHP, and other intepreted languages, do not make it difficult to do dependency injection at runtime, so a large IOC framework like Spring is unnecessary.
This isn't funny anymore.
I never heard someone claim that JavaScript is like Scheme
Makes sense. I can't speak for C++ since I've never used it for anything serious, but the big complex Spring style frameworks in Java are more of an artefact of the "Enterprise" bullshit creating over-engineered solutions than actually being required. It's been a long time since I've written straight up Java, but there's plenty of clean lightweight IOC tools and patterns in Scala, most of which I believe work with native Java as well. Compiled or Interpreted doesn't really affect this significantly. Even in languages with no runtime reflection support at all, IoC is usually possible without bloat.
Actually you are incorrect. I know why i'm doing this script already. What the script contains as in the information is what alludes me. Also you have given no other comment in this thread than to critique my grammar? Thanks for the "help." Here is a tip spend less time worrying about grammar in a thread about javascript. I'm sure there is a /r/grammar. Bye bye now.
Scheme is no longer minimalist? Or JavaScript is no longer minimalist?
I think it depends upon the circles you move in. For people who don't know Scheme well, or know it very well, you would never hear a claim like this. But there is this subset of programmers who only know Scheme through books like SICP and "The Little Schemer," and they discover books like "The Good Parts" that focus on the functions-as-first-class-entities part of JavaScript, and they draw the comparison.
&gt;It's not longer minimalist though. And that's a shame. One of the great things about ES5 (and earlier) was that it was very easy to learn, and it ran in every web browser so most people new to programming had a very easy time learning it. Not so in the future. While people can still learn and use ES5 going forward, the source code available to read will get more complex and that will mean a higher learning curve. ES5 still gets the job done, and the new sugar will only prove cumbersome to many trying to learn the language. 
&gt;&gt; I never heard someone claim that JavaScript is like Scheme &gt; I think it depends upon the circles you move in. Literally first line in the article: &gt; It seems like I can’t spend five minutes on reddit these days without someone playing the JS-is-Scheme is card. I spend more than 5 minutes a day on reddit, am subscribed to a number of webdev and general-programming subreddits, and have never heard it either.
&gt; Don’t tell me it’s got lexical scope, because JavaScript’s scoping is an abomination in the face of God. I see people say this from time to time, and I can't actually figure out why. People just say JS's scoping is bad like it's a self-evident truth, without ever saying why. I've never had a problem with function-level scoping. Why do people hate it so much? Or is it like prototypical objects in people only hate it because it's not what they're used to and/or just like to bash JS?
Not that I agree with "abomination" but it is rather convoluted. Consider: var things = { "_ignore": { "doAsync": function () { }, "args": [] }, format: function () { var self = this; } }; Here's a question: what does `self` refer to? `things.format` or `things`? Something else? Ideally the answer should be self-apparent but it isn't even frown-for-a-minute realization either. To this day, having read and laid down millions of lines myself, I still have to google the answer. It just simply floors me every time. Every. Time. Call that what you will but it is not good scoping. 
The article was written in 2013. It's entirely possible that your experience and the author's experience are both valid.
Crockford mentioned that in several talks. http://www.crockford.com/javascript/little.html &gt; JavaScript has much in common with Scheme. Also, bananas have much in common with kiwis since both are berries. Well, botanically, anyhow.
a list of of charting libraries that does not include d3.js is pretty much useless. &lt;/opinion&gt;
It looks like the archive doesn't work -- the first vid in the series is pre-talk and the second vid in the series is mid-talk?
yeah me neither, guess you have to actively search for it to find it "every five minutes"... 
I guessed this correct at once. My line of thought: The function is declared as a field on an object, and hence is a method of the object. "this" thus refer to that object. Even if js was block-scoped, what else should "this" referred to in this case? Overall, I don't find this difficult at all. A "this" inside a method refer to the object, inside a function refer to the closure, and inside a constructor refer to the newly created object. Or am I thinking about this wrong?
`this` is dynamically bound so the correct answer is unknown until you actually execute the function. The rules governing that binding are actually relatively simple.
&gt; JavaScript has more in common with functional languages like Lisp or Scheme than with C or Java So he's saying that a dynamically typed mixed-paradigm language has more in common with other dynamically typed mixed-paradigm languages than with statically typed imperative languages.
Good points. Worth mentioning that strict mode/linters can address 3 out of the 4 issues.
iirc he said in his "Crockford on Javascript" talks that JS was inspired by Scheme, Self and java (for the syntax). I never heard it as "JS = Scheme". It's just his opinion on how the inspiration came for the language. I spend some time reading reddit, stackoverflow and ES-discuss, and I have never seen anyone claiming this ridiculous "js=scheme", that looks like clickbait to me.
Someone should post this to /r/DiWHY 
No idea, but this might help: https://github.com/kriasoft/react-starter-kit
Yep. Presumably in the example you're expected to call `things.format()`, so `this` would be `things`. Although that's entirely tangential to the concept of scope.
wrong sub.
As counter intuitive as it may seem, I recommend not using Flux when beginning with React. Build out a simple application using your own Components. Implement navigation with something like [React Router](https://github.com/rackt/react-router). By creating a few simple applications without Flux and attempting to implement more complicated features you will get more comfortable with React programming patterns as well as the challenges they present. Then when you are able to get further into Flux (I recommend [Fluxxor](http://fluxxor.com/)) it will be much more obvious how to use the pattern and how it helps solve those issues. The problem with using a starter repo is you are given several parts with no clear guide as to how they interact or where to go from the base. Creating your own projects, with your own requirements will allow for you to learn the patterns which work best for you and your workflow, rather than what somebody else has found to be the most comfortable. tl;dr: There are a lot of parts that go into a full React application. It is much easier to learn the parts one at a time, rather than trying to throw them all together at once.
I can't wait to see the first application using Node.js for the server and php uniter-jquery for client. Next is a db in pure css, and sql for stylesheets (I wont be surprised if that one already exists).
Perhaps the person who submitted this (cough) could have aded `[2013]` to the title to help provide some context for readers. Sometimes, even if things have changed, it's interesting to read a perspective from a while back just to highlight what has changed... And what hasn't.
Kill it with fire!
&gt; waaaaay to many new vocabulary terms Yep, just too frustrating for beginners (not their fault, i don't think the starter-kit is for beginners). I'll check out the links, thanks!
Except with this you aren't saving yourself from PHP, you are now using PHP instead of JS
Maybe I misunderstood. Why do you need to say what the code is doing? Is it for commenting?
Maybe React isn't for you then? No one needs React anymore than they need any other framework. If you're not feeling it, try something else
I always love reading JS source from Facebook because I learn something amazingly cool every time. This technical preview will be a lot of fun to play around with and hopefully I can get it integrated into projects at work as soon as Relay gets released.
option 2 sounds nice until you realize that bosses (especially shitty ones) can, have and will fire you for proving them wrong
eh..................... no. WebAssembly is a VM for browsers, and you will compile JS into machine language for that VM. So yes, it is a replacement to JS from the browsers point of view. From the developers point of view, it means increased freedom to use whatever language you want on the web without forcing the end user to install plugins and without being locked into anything at all. JS certainly is not the worlds best language. Transpilers are just bandaid solutions. WASM, or something similar, will be the future, and the concepts behind it have a very proven track record outside of the web (JVM, LLVM, CLR, etc). Language lockin is lame, plugins are lame, WASM is the solution to both ;) edit: someone pointed out that WASM is not a VM for browsers. now I'm sad and cynical again
good way to get fired then. not all jobs are worth having. software development skills are extremely in-demand. finding a new job shouldn't be hard. 
This is good!
http://www.crockford.com/javascript/javascript.html &gt; ## Lisp in C's Clothing &gt; JavaScript's C-like syntax, including curly braces and the clunky `for` statement, makes it appear to be an ordinary procedural language. This is misleading because **JavaScript has more in common with functional languages like Lisp or Scheme** [emphasis added] than with C or Java. It has arrays instead of lists and objects instead of property lists. Functions are first class. It has closures. You get lambdas without having to balance all those parens. http://java.ociweb.com/mark/programming/JavaScript.html &gt; "It's basically Scheme with C syntax." - Douglas Crockford The article refers to the same quote, by the way. It's from one of his earlier talks and it has been repeated ever since. Also note that the article is from 2013. Saying that JS is "basically like Scheme" isn't popular anymore and this article is one of the reasons.
I don't think that's a good example. I mean, what would "self" refer to in equivalent Python code? The answer there, as here, would be "it depends".
Any more critics besides "there are too much frameworks" ? When these other established frameworks arrived, someone also shout "another framework?" :) My point was to create something focused, and not dependent on extensive documentation and tutorials. Something that reading the README.md would suffice! 
This is addressed in the first paragraph of the article &gt; It seems like I can’t spend five minutes on reddit these days without someone playing the JS-is-Scheme is card. I see everything from the innocuous, “JavaScript has a lot in common with Scheme”, all the way up to, “JavaScript is basically Scheme.” This is basically crazy. Or, at least it has a lot in common with crazy.
&gt; JS is so fast that the current bottleneck is the speed that it can be read and parsed... To be fair, it's often impossible to declare a LANGUAGE as being fast or slow. The IMPLEMENTATION is what counts. So, how does V8 compare to Oracle's JVM? even then, this can be a poor comparison considering that the JVM is multithreaded and V8 is single threaded. So it's probably only fair to compare V8 to other JS implementations (including ones that are meant to run with the JVM like Nashorn). Even then, those comparisons might be a bit murky. And then you have to ask yourself what are your needs. To say that the only bottleneck of JS is the speed in which it can be read and parsed, is ignoring entirely the fact that it is single threaded. There are plenty of scenarios where multithreaded environments are preferable and will leave any single threaded implementation of a language in the dust. 
You're presenting a false dichotomy. Neither is a good choice,and lesser of two evils is positively asinine to suggest. 
Do you need routes right away? Ultimately they are just state changes which is what react is really good at. Also, I found adding react router in the future was easy and having the app fleshed out a bit gives you a better understanding of how you want things structured. The same goes for flux. Do you need it? It's a pattern for fairly complicated apps that may not fit what you need. As I once read a quote somewhere, it's like first person shooters... You run into the room and get gunned down, but you got a good look around the room and now you know exactly what to do. You should experience the pain that things like flux are solving before adding them and you should only add them when you are sure they are needed. Unnecessary layers of abstraction are one of the roots of all evil. 
Generally when people refer to a language as being fast, they refer to the most common implementation or implementations of them unless specified. &gt;the JVM is multithreaded and V8 is single threaded V8 is multithreaded... Just create a new isolate in the V8 engine for each thread and you can run as many as you want, and can pass messages between them, use semaphores, and "share memory" between the threads. You can also do this in node.js using a fork() system. It's even on [the actual "about" page](https://nodejs.org/about/). And if you want actual threads (as opposed to processes) there are tons of extensions which allow full use of the V8 isolate system. Even in the browser you can use [Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) which are true multi-threading in javascript in the browser. This also supports pass-by-reference style message passing including raw buffers (which are practically C arrays). I'm currently using these in an image-processing system in the browser which can pin my 16 core CPU at 100% usage across all cores. And it's not just V8 that has this, all major JS engines can do this. &gt;To say that the only bottleneck of JS is the speed in which it can be read and parsed I never said that it was the only bottleneck, just that it was a major one. Major enough for most major JS engine maintainers to come together and come up with a solution. It's far from the only slow part. So while I agree that it's kind of "iffy" to compare language (implementations) with any kind of 100% certainty, it is possible to get a general feeling for what a language does well, and which "can be" faster (in the most general sense). (EX: If performance is a major issue, maybe don't use Ruby...)
Well that error pops up, because the event doesn't fire for the click (which would bring up the page with that element) the 2nd pass (When the call back is called)
We can use media queries for sizes and portrait/landscape in every halfway recent client. For everything else, the distinction between touch/pointer interface is more important than form factor.
We don't see enough of your code to be able to reasonably debug your problem. You can try encapsulating the selected node with $(), as I suggested or ignore my suggestion. Using frames could be a problem, too.
I think it's easier for someone who isn't very familiar with design patters to learn/use OO heavily first and then branch out from there. I find that using OO is the easiest way to find out where OO does/doesn't work.
Hey! I'm a creator of [turris.js](https://github.com/turrisjs/generator-turris) generator for React apps written in ES6. The basic app generated by it includes all that you'd mentioned, is quite minimalistic on it's own and should be relatively easy to understand. You can find an example scaffolded application with additional component and store with interactions here: https://github.com/turrisjs/turris-example-app If something's too hard or you just have any questions - will be happy to answer any you might have. And if you are interested more in details and logic behind my code, I wrote one [article with overview of the generator](https://medium.com/@yamalight/building-modular-javascript-applications-in-es6-with-react-webpack-and-babel-538189cd485f), and another one [addressing building stores](https://medium.com/@yamalight/using-postal-js-as-flux-dispatcher-in-your-modular-react-application-with-turris-js-1355e9feacc9) with [postal.js](https://github.com/postaljs/postal.js) as dispatcher
Isn't it great that "speeeeed" is what most managers crave yet it is the single most destructive and dangerous thing you can do while programming. I know a few programmers at my current workplace that pride themselves on how many tickets they can burn through (and management loves them for it). Half of what I ended up doing was fixing the "hard" bugs that were only hard because these rockstars took the easiest route to solve a case.
&gt; Generally when people refer to a language as being fast, they refer to the most common implementation or implementations of them unless specified. er, fair enough I suppose. But I always see a counter argument to that in communities that have several stable implementations of the same language (eg: python, java) that saying CPython is slow vs something else is unfair because that something else might be slower than stackless python. &gt; Just create a new isolate in the V8 engine for each thread and you can run as many as you want, and can pass messages between them, use semaphores, and "share memory" between the threads. Now how would you code that in a way that is as elegant as C# or Java? &gt; You can also do this in node.js using a fork() system. It's even on the actual "about" page. And if you want actual threads (as opposed to processes) there are tons of extensions which allow full use of the V8 isolate system. Forking and threading can achieve the same goals, but with very different problems that need solving. I've personally found that in any situation where data needs to be shared between two parallel parts, threads are far more elegant than multiple processes. &gt; Even in the browser you can use Web Workers which are true multi-threading in javascript in the browser. Very true. I do keep forgetting about web workers as I have not used them very much at all. &gt; So while I agree that it's kind of "iffy" to compare language (implementations) with any kind of 100% certainty, it is possible to get a general feeling for what a language does well, and which "can be" faster (in the most general sense). (EX: If performance is a major issue, maybe don't use Ruby...) I'm not entirely sure I agree with this. In some cases it can be clear (Matz Ruby vs V8), in others it's quite murky (JVM vs V8). There is also the issue of what one means when they say "fast". Different problems have different bottlenecks. NodeJS will blow most things out of the water if your bottleneck is centered around I/O. But if your bottleneck is the CPU, NodeJS will not shine as bright as the JVM. 
I didn't even realize the whole history with Mark Zuckerberg. Maybe I need to watch the Social Network again. Thanks for the information. Searching Github for 'Facemash' I found [Mugshot Wars](https://github.com/ecto/mugshot-wars) which is perfect because it contains all the logic, the developer has included [blog posts](http://blog.campedersen.com/post/2769403852/the-math-behind-mugshot-wars) about the math behind the algorithm, and I'll be able to build a REST server with Node.js instead with an AngularJS front-end which is probably a lot more interesting than the standard TODO. For added bonus, I will use ScraperJS to 'data mine' my local county sheriff's website for jail records. I don't know why this is getting downvoted hard because this to me is a fun interesting first MEAN stack project and I'm excited about getting started. 
Feel free to contact me about any issues or problems you might have with it :) 
Isn't it a bit unfair to say that ? I mean, the guy doesn't even have a twitter account afaik, nor does he post anywhere outside his website and the desert that is google+.
Allow me: https://www.youtube.com/watch?v=hQVTIJBZook&amp;feature=youtu.be&amp;t=35m41s From the comments of the article.
Yes
If you are just starting out with JavaScript maybe it would be worth it to take a roundabout and try out Meteor first? https://www.meteor.com/ This will get you started building apps faster. It handles a LOT of boilerplate for you concerning all aspects of your application, like a login system, data storage and fetching for your client. You can build something very fast, and when you got something up and running, you can try out react for the user interface with Meteor as a general app/data/backend framework. This quick half hour introduction really convinced me that meteor is worth looking into. https://www.youtube.com/watch?v=SYqyWff6iMQ
Adding `&amp;&amp; temp &gt;= 0` _after_ `value &lt; array[temp]` wouldn't improve anything because you're checking whether the index is in range _after_ you've already subscripted the array with it.
God not again!
Clever! 
Huh? He does a lot of public speaking and he also got a book.
You might find this article helpful: http://www.toptal.com/react/navigating-the-react-ecosystem As a bonus it links at the end to an example app that brings all the pieces together. (I can also strongly endorse the libraries and tools chosen by the author.)
Mastering something and being able to do something useful are two very different things, and with ES6 both will be more difficult for a beginner. I guess people can still learn BASIC. :(
True, I was not sure if I should post it here, but I saw that my [first](https://www.reddit.com/r/javascript/comments/3bfljo/debugging_in_webstorm_intro_to_breakpoints/) tutorial had some upvotes in this reddit, so I thought it wouldn't hurt to post the second one here as well. All the techinques that I discuss in the tutorial work exactly the same no matter what language you use in webstorm. If you use typescript, es5, es6, coffeescript, nodejs, all use the same kind of debugger, with the same shortcuts, so in that sense I think the tutorial is relevant here.
&gt; *Time flies like an arrow. Fruit flies like a banana.* — Groucho Marx 
No, not starting out with Javascript :-) I think my post sounds a bit like i have never seen any programming concepts, maybe i should have said that i have a CS background. I just got frustrated because it's so hard to get some good and easy to understand information about the library.
Yea, react is pretty straightforward. My problem was not React anyways, more the whole ecosystem throwing a billion keywords at you with no starting point. :/
So.... what are some names?
Apples and oranges, my friend.
Dude give some context what's an onboarding widget? 
I deal with this sort of difficulty at work frequently, except in MATLAB. One coworker in particular is very smart. He'd have to be to get the spaghetti code he writes to work 90% of the time, as he does! They all deserve a lot of respect for their capabilities. Especially when these guys are engineers (like the bridges and pumps and electrical systems ones) who just have to code to get by. I've had the same frustrating conversations with some of them before. They just don't see the benefit. Honestly, if you're smart, there isn't much benefit the first time you write it. It's when you want to refactor and reuse it that it becomes obvious what the benefits of OOP are. I've had success making little utilities for them and then sharing those just as "some functions you can reuse". I think everyone's starting to catch on that an OO coding style can save them some time if they do it right. But they aren't going to stop and learn the lingo. They have other things to do. I just have to give them working bits that don't break, but which they can fit into their paradigm. But over time, I will grow my empire! Muah ha ha
&gt; "Learn Lisp, and you will be a better ~~JavaScript~~ programmer". Functional paradigms help everywhere.
I don't understand what this is. 
Yeah, the ecosystem can be very buzzword heavy. I recommended just starting with vanilla React (+1 for JSX, React with JS is a lot less eloquent). The advantage of not using anything on top of React to start is the React API is *very* light. You can read the docs top to bottom in ~30 minutes. This helps build a good understanding of what React does and does not do. The docs are filled with (mostly trivial) examples, and better, warnings about things not to do and why. The dev build also does a very good job of telling you what and where you have done something wrong as well. I guess the point I'm trying to get at is the key to success with React is knowing what to do in React and know what to break out to another service, then learning how to connect the two (which is where Flux comes in). 
Thanks, glad you enjoyed it :)
Nope - I love it too! Posted a link to it at bottom, here it is again, by Gargaj: https://www.youtube.com/watch?v=6glpmkKXfLk
Thanks :)
can't believe I forgot about that, thanks!
Did this to slow things down, but same problem: javascript: (function() { "use strict"; var x = 0; var links = $("[id^=exchange_mailboxes_view]", top.frames["mainFrame"].document); var loopLinks = function() { console.log('loopLinks'); console.log($(links).length); console.log(x); $(top.frames["mainFrame"].document).ready(function() { doLinks(function() { console.log('Do Links Callback'); x++; console.log(x); if(x &lt; $(links).length) { //setTimeout(loopLinks, 3000); loopLinks(); } else { console.log('NO MORE'); } }); }); }; var doLinks = function(cb) { console.log('Do Links 1'); console.log($(links[x])); $(top.frames["mainFrame"].document).ready(function() { $(links[x]).trigger('click'); $(top.frames["mainFrame"].document).ready(function() { console.log('Do Links 2'); //$("#path_select1", top.frames["mainFrame"].document)[0].click(); setTimeout(function() { $("#path_select1", top.frames["mainFrame"].document).click(); $(top.frames["mainFrame"].document).ready(function() { setTimeout(function(){ console.log('Do Links 3'); cb(); }, 3000); }); }, 3000); }); }); }; loopLinks(); })();
"Sacrifice a long weekend" You may have to 'sacrifice' a little more than that to become proficient with react and its ecosystem of libraries and build tools.
I'm assuming you want to do one of those things where you point out features to new users? I've used Chardin.js before. It's alright. It's not super dynamic but it gets the job done. I really like the way Slack does their feature discovery with little pulsing blue dots on the page. You could probably implement that yourself without too much trouble.
Author of the post here. God damn, I do love me some Jon Hopkins.
Regarding writing lots of tests. It's another bandwagon - blindly writing "just because" - makes as sense as writing 10 unit tests for every command that you run on command line. Every time you write a check you will be spending time on code that no one ever sees and no one ever uses. It's essentially waste - that of course doesn't mean it's useless. If you don't have ideas or haven't been designing code a lot - it will help you make better design decisions. Here the asserts/constraints don't help that much. The more experienced, the more you don't need that help. The best solutions to complicated problems I've seen are developed on paper and not with TDD. Making code testable you are also breaking things apart, which may destroy the architecture and understandability of the code. Basically, it is one way of ensuring quality, but there are other tools/things/processes for that as well e.g. code-checkers/validators/verifiers/fuzzers, exploratory testing.... They provide different things in quality, but remember not everything needs the same level of quality. Trying to make everything to extreme quality is a noble goal, but you might be better off spending time on other things that provide more value to the user. NB! Don't read these arguments as "I don't need testing" or "I don't have to write checks because X"... they are just bound to trade-offs like everything else in engineering. Blindly making decision to either extreme can make your code either fragile or mkae you produce waste or guide you to poorer design. In some places they are useful, in some places they are not. 
Please join the gitter room and let me know your thoughts, I am just trying to move things forward =&gt; https://gitter.im/flyjs/fly
exactly. if your experience is limited to discussing the newest js frameworks' potentials and playing with jquery, I'm not surprised if someone hasn't recognized Scheme as a language...much less the common references to it in js discussions. Lua and Scheme are the go-to comparisons.
I really like how thorough this is. Kudos to the developers who put it together. It takes a lot of work to compile these rules.
then upvote or gild it.
I agree, but I think build systems in particular don't really come out _as_ often as frameworks. Give it a shot if you are curious and please let me know what you think.
Like 10 years new, yep
Anyway, I still think Meteor is worth checking out.
Read it quite a long time ago, also has one of my favorite design tools - Naked CRC (usually combine with ideas from physics of software). *Note, I'm daily working on a code base that is 35+ years old, so I know quite well the harms/cons of not having automated checks.*
Looks like some useful progress. Fortunately the API changes aren't too big :)
For the sake of javascript, **don't roll your own thing**. I'm serious. I have been using electrolyte, but as you can see by yourself there are so _many_ "roll my own thing" implementations, and none of them is substantially comprehensive. Electrolyte is not so well documented, but is the easier to use and so straightforward once you understand what Jared Hanson was thinking (he's quite a smart guy). I am trying to convert myself to simple-ioc, since is the only seriously maintained project, and they welcome contributions. (although if you look at the code, you can guess it started exactly as "roll my own thing") Jared is far too busy to maintain this library, and I think IoC is really powerful and important piece of code for node.js, so please, contribute, don't reinvent the wheel.
First I have to say that I'm not sure about this but I assume that the Khan Academy tutorial is wrapping the code in all sorts of things so it's easier for beginners. If you look at http://processingjs.org/learning/ you can see that you need a canvas and some setup code to initialize it. All of that is missing from your JSFiddle.
For me the way npm and modules work in Node is one of the main reasons I've migrated so much of what I do over to Javascript. 
I'm curious, why no generators? 
&gt;Do you really want to have to know how and why this works? I would rather require negative-zero. This is the mindset terrible programmers have. You should absolutely be curious how and why that works. Especially if it's not complex at all like this one line of code. If you'd seriously rather include a module for this one simple task I feel bad for your co-workers and users of your software. Edit: I would write that one line myself and put it in a common functions place. All too often I see people pulling in huge libraries for just one feature it exposes. Im not opposed to using other people's code, I'm opposed to bringing a bungh of shit in that you arent going to use a quarter of.
I'm pretty sure Sindre Sorhus knows how the negative-zero module works. I think the point he's trying to get across is that things like working out -0 maybe one line but it makes your code harder to read having it in-line. Also, if the definition is off, you only need to fix it once rather than every occurrence. If you're copy and pasting (or even worse re-typing) snippets, you're doing it wrong - DRY (Don't Repeat Yourself).
&gt; This is the mindset ~~terrible~~productive programmers have. FTFY. There's a time for curiosity and a time for getting things done. I can agree the example might not be the strongest and I was curious for the math as well, but even so I would say that at least for readability the module approach was way better and it didn't weaken his overall point.
Yuck, that must have been a fun bug to hunt down :) Doesn't seem like you can redefine undefined in Node.js thought so that's nice...
First thing I did was scroll all the way to the bottom to make sure they closed out that function declaration in the header. Good job.
Really interesting read for me as I'm getting to the level of know-how where memory leaks matter. Kind of surprised that was published in that state though. Typos everywhere, even in code, which confused me for a moment.
This is how programming works. We build abstractions and label them with English words, so that we can stop repeating ourselves in code (potentially making errors in the process), and carry the code through multiple projects (i.e. versioning, package management). Like I said in the thread; a lot of these tiny modules were modularized so the author could stop repeating their code across projects. It just so happens that they documented, tested and published it publicly, so now anybody else looking to stop repeating themselves could also benefit from it. Other tiny modules that I have used instead of repeating them myself: [smoothstep](https://github.com/gre/smoothstep/blob/master/index.js), [clamp](https://github.com/hughsk/clamp/blob/master/index.js), [cbrt](https://github.com/sindresorhus/cbrt/blob/master/index.js). Just like `Math.sin()` or `parseInt`, I don't care much for the implementation details as long as it fits my needs. I'd rather focus on building the application than waste time writing and unit testing a small function.
This begs the question of what you were using before? .NET folks have Nuget on Windows, and your OS package management system for Mono for *nix. Java/Scala/Groovy has Maven PHP has Composer and PEAR Python has pip Ruby has Gem Javascript has NPM Perl has PPM Lua has LuaRocks D has Dub 
My work utilizes this one as well as John Papa's AngularJS style guide. Both are fantastic and thorough guides with great detail as to "why?"
Very happy reading this. It really seems like they are moving in the right direction!
Not sure why you got downvoted, you aren't wrong. But I will argue that NPM is probably the easiest package manager to use. I've worked with Maven, Nuget and Composer and they all have layers of complexity that make it more difficult to learn and understand fully. 
The author works at Google and is a very vocal advocate of Polymer, so I am confused as to the lack of comparison between Polymer and React. This oversight may have been sensible had the author not dismissed React based solely on performance. On last count, Polymer is quite slow, even after you perform tedious optimizations and hacks. I'm skeptical of the numbers for various reasons, and have little doubt that they will be disproven if they haven't been already. In any case: * Even if React isn't as fast-by-default as some thought, it's important to remember just how easy it is to optimize a React application compared to Angular, Polymer, vanilla, et al. Usually, all you really have to do is implement `shouldComponentUpdate` on a troubled component. And there are the [React Performance Tools](https://facebook.github.io/react/docs/perf.html), which tell you exactly where the problem is. You can achieve theoretically superior performance in any of the mentioned frameworks/techniques, *if you spend enough time and effort*. * Complicated applications written using vanilla JS *will* interleave reads and writes and inflict numerous other performance blunders unless delicate care is taken. It's a lot harder to destroy performance in React. Fixing a performance problem in React is almost *too* easy compared to Angular and vanilla JS. I've yet to have a single difficult performance problem. In every case, all I had to do was use the React Performance Tools and implement `shouldComponentUpdate` on a couple components.
When you yield, you need to call the generators next() method to resume execution. There are some other implementation details as well. Async functions will automatically resume when the called promises resolve.
&gt; The belief, inexplicable as it was, was that OOP was inherently modular. (As you probably already know, OOP is anti-modular.) OOP is not INHERENTLY modular, but I fail to see how it's ANTI-modular. Care to elaborate?
http://programmers.stackexchange.com/questions/70831/is-objected-oriented-programming-paradigm-outdated-since-it-is-anti-modular-and
that's a good start. thank you very much. it's definitely one way of doing it although you have to fill in the missing pixels somehow (here, with a simple interpolation). Is it easy to put the depth map info into the z-buffer and let WebGL's renderer take care of displaying the scene for various camera viewpoints?
You win the JavaScripts for today!
WASM isn't any more of a solution than transpiling. What we need are better debugging tools for compiled languages, and that's not dependent on WASM becoming a thing. The vast majority of apps wouldn't benefit much from WASM anyway.
I didn't mean that I'm actually going to just spend one weekend on it.
Yes, it probably is! Anyways, I like using actionhero.js currently, so if I get bored of it at some point, i'll probably check out Meteor. :-)
Bookmarked, thanks!
&gt; I can't speak to this too much, but the fact that NPM can have infinitely cascading child dependencies means it can do the same thing Maven can, you just end up with a different project structure. I'm talking more about child modules of a single project. I look at our Java code here as an example: We have a root pom, then we have a collection of modules for business logic, then we have a collection of modules to expose that business logic through REST APIs, then a collection of modules to wrap all of this up into neat and tidy servlets. All these modules make up the final product. The root POM is the only place (by office convention, not maven convention) where we specificy our dependencies and their versions, ensuring consistency across the whole board. Then just run mvn clean install on the root pom and voila. As far as I'm aware, NPM can not support a project structure like this. &gt; We use Nexus at work (with Maven) and it's a great tool. In fact, it's so great that it supports a huge list of dependency managers including NPM! *mind blown*. I never knew about this. I must investigate further, thank you for bringing this to my attention. &gt; Are snapshots actually a concept specific to Maven or just a best practice? Could you not do something similar with your NPM packages and just append something after the version number to indicate it's a W.I.P? (I've never tried it, just wondering) First, Maven does differentiate between snapshots and releases. You can see this in repository configurations (for one set of packages, I can have one repo for releases, and one for snapshots). But more importantly, I can push a package to a maven repo, even if a package with the same GAV (Group, artifact, version) already exists. This is not possible in NPM. Now, the reasoning for this, is that when I say "I depend on moduleA v0.1.2" I should always expect to get the same thing. If moduleA changes, then the version number must change along with it. It's sound reasonable, especially for managing a central public repository of packages. But it's also ironic that this is their reasoning while at the same time allowing wildcard versions for dependencies. But I digress... But it doesn't make much sense to force this onto people outside of the central repository. I can't push moduleA v1.2-SNAPSHOT more than once. I've worked around this by having the minor version increase after every build, and everything that depends on this module uses wildcards for the version. But this is a hack that I don't feel is at all necessary in the office environment. As well, in order for this hack to work (our CI builds when SVN changes), there is a difference between what's in the NPM registry, and what's in SVN. I realize that with NPM, you can use RCS URLs as I pointed out in my previous rambling, but the problem with RCS URLs is that code in an RCS hasn't necessary gone through the build process. In other words, packages in our private NPM registry, are there because they passed all our linting tests, unit tests, style checks, etc. So the concept of saying ModuleA version 1.2-SNAPSHOT will always point to the latest built package of 1.2-SNAPSHOT, does not exist in NPM, and to me is the most important thing that needs solving, either via NPM or via third party registries like Sinopia (or apparently Nexus!).
Horrible table formatting, but the data itself is fabulous.
For one inheritance breaks modularity. That's why in recent years practically everyone recommends to use composition over inheritance. Also large class hierarchies become very rigid and brittle. Hence the rise of IOC frameworks, basically turning class hierarchies on its head. In other words all the best practices in OO design that we learned and accumulated over the decades can be summed up as "Do not use OO while writing OO code". Do not use inheritance. Do not create large hierarchies. Try to make your classes immutable (do not use setters). All this is pretty damning if you ask me. 
[Are they saying what I think they're saying?](https://github.com/airbnb/javascript#28.1)
I don't think any of this really says that OOP is anti modular, just that certain practices are anti modular. Put it this way, composition is not anti OOP, and inheritance is not anti-modular. It just depends on how its all used.
Good points. I think the versioning is a solvable problem using NPM &amp; Nexus, but I can see how Maven handles it more elegantly. I think my biggest gripe with Maven is how much shit it tries to do. I like in the JS world how NPM handles my node dependencies, Bower handles my UI dependencies and Grunt runs my build tasks. Maven tries to do all of it, and the configurations can get *way out of hand*. Too often I get lost in pom files over 1000 lines long that try to solve world hunger instead of just doing one thing.. Ah well, development tooling is fun stuff \^_^
There's a distinct lack of consensus among the browser vendors over how to implement a number of the web components features, and the specification isn't really finalized. If you rely on the polyfills built into polymer / webcomponnets.js / x-tags, you run the risk of your code breaking when the native implementation comes online in a very different way than what your code was written against- meaning you have to keep re-deploying updates as the spec changes, and the polyfills themselves change. This is where the benefit of something like react or angular come along- they don't rely on polyfills in the browsers they claim to support, so as browsers implement new features, they'll keep working as-is without any manual updates from you, the developer. I'm hoping the web components spec gets finalized somewhat soon- there's supposed to be a big meeting in July that should help get them on track. On why vendors haven't agreed on the spec: https://hacks.mozilla.org/2015/06/the-state-of-web-components/ http://christianheilmann.com/2015/07/01/over-the-edge-web-components-are-an-endangered-species/ On why the web components specifications are hard to properly polyfill into the current browser environments http://developer.telerik.com/featured/web-components-arent-ready-production-yet/ 
Agreed, this is great work. I'm really glad they went out and posted pull requests with pieces like regenerator with *huge* (claiming 40x higher op/s with the tests) potential improvements.
str.replace(/\W/g, '')
I'm also glad to see the transpilers included here. 
Can you explain this more? What do you mean tag attributes?
It's right there in the document: &gt; Why? They don't transpile well to ES5. 
question: array.slice() gives a shallow copy, what should I do if I want a deep copy?
So... is there still going to be a way to get the actual component from a ref instead of just the DOM node?
Just think of them as tools, they are all tools. To me it's really a non-decision. Learn the high level design patterns, the various architectures, the data flows, the vanilla javascript, and you won't ever need to lock yourself into any one framework or ideology which inevitably come and go. Just look at what happened with Angular 1. It shot up like a star only to be superseded by Angular 2 a few years later, which bears little to no resemblance to the original. All of these frameworks, react, angular, whatever it may be are all transient *tools* to help you build good web apps. Once you've established the fundamental competencies mentioned above, you will not have a problem finding a job/adapting to any new tool that might come your way.
It's dangerous to live on the presumption that everyone is on a modern browser that behaves the same, unless we magically pop back to the IE monopoly days. Not saying to ditch all modern stuff, I'm just saying don't forget about the caveats of old JS engines.
What is that saying?
Surely, if it simply *replaces* the JVM, we should just go back to Java applets?
You should put the URL in the text of your post. :) My suggestions: - use camelCase for variable names - generally, avoid obscure single-letter variable names for any public fields - `instanceof` creates a vendor lock-in and also leads to issues with multiple versions of a module; generally it isn't needed and can be avoided altogether - The class produces unusual/surprising effects depending on the orders of A and B - I would strongly recommend against using `eval` in such a way that it is exposed to the end-user Overall quite good for your first public release. IMHO bare arrays are better suited for vectors in JavaScript, but that's just me. Some more references: - [gl-vec3](https://github.com/stackgl/gl-vec3) optimized for 3 components - [vectors](https://github.com/hughsk/vectors) supports n-dimensional vectors - [ThreeJS Vector3](https://github.com/mrdoob/three.js/blob/master/src/math/Vector3.js)
I'm surprised that it needs to be said that frameworks incur some kind of performance overhead compared to the vanilla implementation. There's always a line between optimizing for performance vs optimizing for developer time/ease of use and maintainability. React is not perfect, but it's a very good compromise between the two.
A shallow copy references the same objects. For a deep copy you have to duplicated all of the (mutable) objects and all (mutable) objects they are referencing and so on. There is no generic mechanism for duplicating objects. If you ever need the ability to clone some of your objects, you can just add a clone method which creates a duplicate. DOM nodes have such a method, for example: https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode
Agreed. I've been using babel a lot for side projects lately, and it's nice to see some likely starting areas for profiling when performance becomes a consideration.
I wouldn't include a module. I'd write it myself and put it in a common functions area.
Not what I was saying. I would abstract it myself instead of pulling in an NPM module.
Solved: The first time it would go through just fine, returning the a href element, the second time, it was just coming back with the context only.. so if just do the selector each time with .get(x), it works: $("[id^=exchange_mailboxes_view]", top.frames["mainFrame"].document).get(x).click(); Full code much smaller: javascript: (function() { var x = 0; var links = $("[id^=exchange_mailboxes_view]", top.frames["mainFrame"].document); var start = (function() { var doLinks = function() { if(x &lt; $(links).length) { $("[id^=exchange_mailboxes_view]", top.frames["mainFrame"].document).get(x).click(); setTimeout(function() { $("#path_select1", top.frames["mainFrame"].document).click(); setTimeout(function() { console.log('Do Links 3'); x++; doLinks(); }, 1000); }, 1000); } }; return doLinks; })(); start(); })();
The major change has been more progress towards further separation of modules in react, which now has a core part that most react components use and another part which is concerned with manipulation of the DOM.
Something like this: https://github.com/mrluc/owl-deepcopy Blog post about how it works here: http://www.oranlooney.com/deep-copy-javascript/
Not. Subtle. :)
I think you can actually go mental picking JS tools, we need to develop a couple of frameworks for choosing frameworks. I wouldn't choose ember, I started a simple project and it created two 10mb minified files... what's up with that.
Can we keep the subreddit drama out of here please?
Ohhhh, I get it now. Thanks for clearing up for me!
Thank you for such a quick response. I will look into making the check more general so as to avoid the `instanceof` check. And I appreciate the note about the `eval` call; I was just reading about returning a built up string as a function invocation and now after looking at that vectors for n-dimensional library you mentioned, I believe I can avoid the `eval` with that method. Could you give me an example of an unusal/surprising effect that you mentioned? I would like to clean that up asap. And again, Thank you.
Yeah so much drama in this thread
Agreed. Also: &gt; employability in the future Learning Angular 1.0 may be fine for the next year or two, but after that you can expect React (and similar solutions) to supercede Angular 1.0. Besides, most Angular jobs require 50 years of Angular experience.
Basically, in javascript, using native functions is, counterintuitively, slower than just writing some javascript to do it, in so many cases, that i've given up trying to figure out what the hell is going on. 
What's up with the vars?
It's probably a hell of a lot faster to just for loop it, and abort at the first difference. 
I suspect that the KA Javascript lessons aren't *meant* to be valuable in terms of building real-world ProcessingJS apps. Instead, the goal is to learn how to think algorithmically and cover some of the basics of imperative languages (functions, conditionals, loops, etc.), so that, when you go to learn some real-world (more complicated) GUI system, it'll be easy. KA's GUI is engineered for beginners, so that you can focus on the underlying concepts, rather than worry about the more superficial concerns of learning an intricate GUI API. If you're looking to make real-world apps, I hear good things about Codecademy's web development courses. The [Make a Website](http://www.codecademy.com/skills/make-a-website) course will cover the web basics, then [Make an Interactive Website][cc-int] will show you the Javascript you need to know to treat the web as a GUI. Put that together with the general programming and Javascript knowledge from the KA course, and you should be ready to start making real stuff :) (For what it's worth, /u/jeresig is a mod here *and* he's the guy who originally designed the system. I interned with KA a couple summers ago, so I can *kinda* start to guess at his pedagogy, but he can probably give an even better answer :D He's also the creator of jQuery, which Codecademy uses in [Make an Interactive Website][cc-int], so I'm actually really interested in what he has to say about moving from one of his GUI APIs to another :o) [cc-int]: http://www.codecademy.com/skills/make-an-interactive-website
Don't see it as reinventing the wheel... people try and that is how innovation happens, you're free to pick one and go with it. There are very good explanations for the majority of the features and why they came to be, in every major framework (major, lol) . And they exist mainly because of the lack of tooling/tech that was available some years ago (and might be today) in the JavaScript space. If you look at the history of Computer Science researches and tech you'll see that today we are actually arriving at a state of web graphical interface programming that the ""desktop"" has been at for years! Things like modules (which would be like namespaces in compiled binaries), more practical ways of programming object-oriented code and observer/event systems... . When you look at Angular 1.x and try to understand the reasons features were created at that time and at that space (Google and java guys) you'll see dependency injection because tech like browserify|webpack|require... weren't stable|big at that time, directives because there was a need to separate a part of your app so it could become independent and reusable (components...), controllers because the business logic should be separate from the view... e.t.c. . IMO today React.js has reached the best state until now in the way that you can abstract your rendering target (DOM, Native...) and develop your application in a fully modular, composable and even actually reactive (with Rx.js and friends). Still every framework has it's part in the innovation of web technologies... . People get angry at the speed of change because some wish to work in the space but there is a big lack of stability in which framework/tech to learn. In this case don't look for technology, look for people, look for culture. Companies with great minds don't depend on an implementation of a certain technology pattern, if you wish to work with front-end learn the technologies of the front-end, be great at JavaScript, DOM API, CSS layout/styling.... if the company is really that good and worthy of your value they will hire you and listen to what you have to say... if you need time to learn, they should give it to you or at least ask realistically of what you can give. . Test out the frameworks. Get a little simple idea (todo list, message app, calculator, pacman...) and build it with every framework/library that interests you, do it on the weekend/freetime. Go with the one you're most comfortable with. There will never be "the framework|library" anymore (like what jQuery sort of was for years)... there are too many cultures/personalities for that.
Thanks! I'll give it a shot, although ideally I'd like to provide a link for someone else to click. It sounds like that's not possible.
It really depends on the case. In Benchmark, your claim is almost always true. The reason is that benchmarks have typically little to no polymorphism. When the types are very predictable, the JavaScript optimizer can do a great job at simplifying the control flow. When the code is very polymorphic, a native function can sometime be faster. Native functions can have type-specific fast-path. On entry, the function selects which fast-path depending on the types and can execute some stuff very efficiently. In general, JavaScript code perform quite poorly on polymorphic code. The function is just de-optimized until it is generic enough to handle all the types seen. The real world is somewhere in between. There is a lot of very polymorphic and monomorphic code. It is easy to find real web pages where native function do better, and the other way around.
The premise is this: If you read from the DOM after writing to the DOM, you may force the browser to recalculate before it was planning to in order to give you the answer you're looking for. As you might imagine, this slows things down. This may be triggered in various places across your application such that you can't manually ensure this doesn't happen. fastdom gives you a global queue you can use to batch all of these reads and write such that you never force the browser to recalculate at the wrong time. This does have interesting side effects if you're not careful to order your reads and writes. For instance, if you're reading to measure the result of the write, the call to read should be nested inside of the callback yo write or you'll read before the write even happens. The project page and [the blog post](http://wilsonpage.co.uk/preventing-layout-thrashing) do a much better job at explaining it all than I can here, and there are a few in-browser benchmarks you can run to see it in action.
&gt; I was under the impression that most browsers try to delay reflows until the next frame naturally. They do but if you write then read then write then read (as the examples show -- a worst case scenario) then it would need to do expensive operations like reflow for every read. So think of every change between writing or reading as cache invalidation.
I'd rename it to "Instructions not included" game.
Reddit's frontend code has always been a liability.
And that's how you actually do it: window.setTimeout(countdown, 1000 - (new Date().getTime() % 1000));
What was the point of that? You are passing a large negative number as the last argument...
What I don't get is how you're supposed to go about finding that module in the first place. Do you go to npm and search for every problem you want to solve, no matter how small? Or how are you supposed to remember the existence of all these tiny modules that do incredibly niche functions? And how long does it take to find out if it does *exactly* what you want it to? I would argue it's easier to just create it as a function yourself if it's as basic as this example.
It's as ridiculously thorough as you'd expect from Paul Irish, good stuff. Don't understand a lot of it though! Also you gotta any of that css9 to share? 
As a Google employee with customer relations, no, I don't think you can.
I am not surprised at all that it is this bad. Also, look at what they use and then compare it to what everyone on reddit is talking about using and claims you must use or die. Now think about that.
Not to mention that they made React Components for things like icons and buttons? I mean I'm no React expert but that seems a bit wtf to me tbh... 17 secs just setting up the damn app? dafuq
m.reddit is built on React, if the profile didn't make that clear. Not having used React, I have no idea how big an impact that has on performance (I have heard that it is relatively performant by client side framework standards), but the fact that the site is rendered client side at all boggles the mind, given how static reddit is. 
You generally make everything a react component, that's the benefit of react. 17 seconds is super excessive, but I don't think it's because too mamy things are react components. 
I dunno man, I just read the whole Act 3 thing, and phrases like: &gt; Act 3: Component Party (22 seconds): React is mounting components like the dickens. So much mount. and later on the React Perf Analysis you see MobileButton and SnooIcon (mostly) at the top of the charts for some really small functionality... and it seems to me that it is React misuse somehow? Either there's too many or they just plain mount so slow...
 var tenMinutes = 1000*60*10; var fourSeconds = 1000*4; function timer(time, msg) { var timeNow = new Date().getTime(); var targetTime = timeNow+time; function countdown() { if(targetTime &lt;= new Date().getTime()) { console.timeEnd("a"); console.log(msg); } else { var left = targetTime - new Date().getTime(); setTimeout(countdown, Math.floor(left/2)); } } countdown(); } console.time("a"); timer(tenMinutes, "finished"); Just playing about, This is about 25ms out, haven't put much thought into it.
To be fair, the site could be this sluggish in vanilla JS too. Seems there are a few relatively simple things they could do to correct most of the major problems - most of which don't really have anything to do with react.
I'm one of the weird ones that likes the new m.reddit, but this is interesting finds. A pretty good argument for server side rendering as well. Problem is you're basically stuck with a node stack at that point.
It's initial load performance could use some improvement, but once it is loaded, it seems fast enough for being on my phone.
Hahaha many blink, such animate, wow! 
Not necessarily - there are bindings to V8 from other languages, but it definitely adds unnecessary complexity. Just look at the dumb stuff Discourse has to do because it's Ruby + Ember: http://www.discourse.org/
True - this is an easy win
I've tried looking into with rails &amp; react, but especially when you want to use flux as well, it becomes a huge headache.
No, the garbage collection will sweep up remaining timer pointers long before they can become a problem.
I make anything that is going to *use* React a React component. If it's a static icon there's no need to do so, as it's never going to be updated. In this case very little of the page needs React's virtual DOM stuff.
I have to be honest: I like that they actually mentioned critical areas that are absolutely no-brainers when you develop to anywhere but the browser (using storage on computer, audio, initial loading, etc), so improvements on these fronts will be much appreciated. Most importantly, WebAssembly is still just something I cant believe to be coming :D
Yea, no one will do anything risky with an AAA budget. AAA titles generally play it safe. They go with popular genres and they don't diverge too much from the successful formulas. I'd say this is more interesting for indies and smaller studios. It's not suitable for gigabytes of content, but a few megs up to a hundred or so should work pretty well.
You can make any technology slow if you misuse it. And it's vastly easier to misuse vanilla JS when you're working with more than a few people on a complicated app with a lot of state. What we do know is that performance is rarely a concern in React apps, insofar as it's caused by using React. Based on real experience building very complicated apps.
&gt; Apparently as seen on m.reddit.com, it's equally easy to misuse React when working with more than a few people on a complicated app with a lot of state. Not really. On inspection, there appears to be merely a couple, perhaps a few, misuses of React. Using vanilla JS tends to be far more problematic.
Java apparently works pretty well using Nashorn to run the JavaScript.
I started issue describing differences for FAQ https://github.com/Vincit/moron.js/issues/11
Be sure to note that for any http request to not incur extra roundtrips (latency) a file needs to be less than 10 packets, about 13kb. Good luck ;). Extra latency is especially bad over mobile links.
No; the JavaScript engine calls `countdown` every `1000 - (new Date().getTime() % 1000)` ms. No stack memory is allocated beyond subsequent calls to `countdown` which, because it is [presumably] not recursive, is freed upon completion.
I hate these utility methods. In my opinion they make code unreadable and quite unclear. While it seems odd to call `isEmpty` on a number, the way it behaves is certainly unintuitive.
Hmm, most examples/explanations I've seen have related to async code. I kind of like the use case for Unity for coroutines. Though its specific in the fact that the following iterations of the coroutine seemed to be called automatically each frame. Is there a parallel use case with your build system, Fly? 
Fly isn't mine. I just saw your comment and wanted to clear up a nitpick. Here's an example in JavaScript that is similar. While Unity will handle making subsequent calls, the JavaScript event loop will handle subsequent calls here: var div = document.getElementById('myVisibleDiv'); function fade() { if (div.style.opacity == 0) return; div.style.opacity -= 0.1; requestAnimationFrame(fade); } fade();
It's not an exact one-for-one. `requestAnimationFrame` would be the co-routine in this case. Since there isn't really a way to tell the browser to redraw an element, we're stuck with setting the opacity and then waiting for the browser to redraw and call us again. But to answer your part about yield: yes.
So other than animation, what would be an elegant use of a real coroutine? And thanks for discussing this with me, its been helpful. Im trying to think of a genuine use case where another pattern wouldnt be simpler and more readable. For a build system such as the one featured in the OP, Im still not sure I get the benefit of the pattern; I suppose even more so for generators.
MUAHAHAHAHAHAHHA 
An easy way to test something in a string is to use regular expressions. [Here's nice introduction](http://regexone.com/) to them and [here's how to use them in JavaScript](https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions). They can be bit cryptic at times but they are really a powerful feature built right into many languages.
Are you on WiFi? The test was run on a barely 4G connection. Latency plays a big role in mobile testing.
I honestly can't think of a reason to use co-routines in JavaScript. I've never tried, so I'd have to point you to other people who know more about the subject than I. http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/
Nice, I have always scraped using http requests, never even thought of just running javascript in the browser.
I was on wifi. I switched to 4g, but it still wasn't as bad as Irish experienced, with the website being functional about 1-2 seconds after appeared "loaded".
SnooIcon is a rather complicated animated SVG: https://github.com/reddit/reddit-mobile/blob/master/src/views/components/icons/SnooIcon.jsx It probably should be updated to add the `shouldComponentUpdate` method to return false.
You're trying to do too much at once. First start with a function that tests a single password for compliance. function validPass(Pass) { // an array of the three regexes which we require var Requirements = [ "[a-z]", "[A-Z]", "[0-9]" ]; // go over each requirement Requirements.map(function(ThisReq) { // if any one requirement is failed on this password, immediately fail if (!(new RegExp(ThisReq).test(Pass))) { return false; } }); // without a failure, we have a success return true; } Then separating them is as simple as keeping two arrays, mapping over the list, checking if one is valid to determine which array to use, and pushing that password into whichever array, then returning those. function bin(Passes) { var Accepted = [], Rejected = []; Passes.map(function(Pass) { (validPass(Pass)? Accepted : Rejected).push(Pass); }); return {accepted: Accepted, rejected: Rejected}; } 
greetings, today i introduce to you riskyclicks.click, a "reddit" for javascript code. scripts can be posted, rated, executed, and commented on via the interface. scripts execute in the context of the site's DOM via the use of $.getScript from jquery. since scripts are totally arbitrary, there are no accounts or stored session information. votes are casted by ip, thus each ip gets a single vote. moreover, the site is entirely anonymous. personally, i found this structure amusing. for those curious, the site is a single-page app running on backbone.js. it is styled with pure.css and supplemented by some small libraries for toasts and ajax load bars. the api that the backbone.js interface makes calls to is written in haskell using the snap framework and uses mongodb for persistence. scripts are stored on amazon s3 since it's dirt cheap.
Your "validPass" function always returns true. Rewrite it to use some() instead of map(): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
It's an off-by-one error in the for loop. Because you test for "i &lt;= passwordGet.length", the loop goes through one iteration more than the length of the array. This causes a syntax error when "passwordGet[i].length" is called in the last iteration, because there's no such value in the array. Changing the "&lt;=" comparison to just "&lt;" will fix the problem. When iterating over arrays, we generally prefer the form "for (var i in passwordGet)" because it's more concise and avoids bugs like this.
I agree with the idea of splitting things, but not with your usage of the 'map' function. 'map' should really be used to do projection, taking a collection in, outputting a collection with same number of elements, the new elements being generated by function execution on previous ones. If you want to test that all the elements of an array match a predicate (like for the regex.test), then 'every' is the way to go (without forgetting to returning the result). Iterating for side effects is the meaning of 'forEach'. And aggregation (e.g. if you wanted to directly create and return your final object instead of declaring the arrays externally and mutate them) is the role of 'reduce'.
"if any one requirement is failed on this password, immediately fail" That's what they want to do. They only care if it's 1+, not all of them.
Fun fact! if a library/framework (say, underscore/lodash or jQuery) you'd want to use for convenience isn't included on the site you'd like to scrape, you can do the following to include it: var script = document.createElement('script'); script.type = 'text/javascript'; script.src = 'http://underscorejs.org/underscore.js'; document.head.appendChild(script); 
Thanks, I always forget about the space argument. I added that to the article.
If you want it hanging from a functional predicate, it's `every`, not `some` - some is for at least one, and he wants all. The reason I chose the structure I chose was to minimize the number of new things he needed to learn at once. I wanted to show him control flow and decomposition. Not every lesson needs to teach every thing. In the meantime, no, actually, it doesn't always return true. As soon as any one fails, the return short circuits in place.
The reason I chose the structure I chose was to minimize the number of new things he needed to learn at once. I wanted to show him control flow and decomposition. Not every lesson needs to teach every thing. Returning over map is entirely adequate.
&gt; A pretty good argument for server side rendering as well. Disagree, a lot. This is definitely 100% an argument for understanding your problem rather than trying to fix issues by taping another "performance-enhancing feature" on top. Besides, Paul Irish says they're already using server-side rendering.
So, are we going to learn from this that libraries have a price even when installing them doesn't? No, didn't think so. Probably just means the reddit devs suck.
The real problem here, I think, is that both you and underscore's authors seem to think it's OK for communication about a function's purpose to be as vague as human intuition as to what constitutes a "somehow empty" value. `isEmpty` may be pretty but it invites errors; `isEmptyArray` and `isEmptyObject` and `isUndefined` don't.
The JVM is highly opinionated on how code is organized, the way memory is managed, and the security model it uses. All of its opinions in these areas (heavily OOP, garbage collection, and everything-accessible-by-default) are awful for what asm.js and wasm are trying to accomplish (host C++-like languages in the browser). The key is "next gen"- wasm is much more language agnostic than the JVM, reuses the browser's security model, and integrates much better with the browser environment than anything the JVM ever did.
Oh, my mistake. Thanks.
I read that as Lebron.
There was a really high quality of talks at React Europe. Most of them were worth watching, but if you only see two, wait for Dan Abramov's and Cheng Lou's. 
.... we should be friends.
I wasn't willing to start an argument. &gt;if any one requirement is failed on this password, immediately fail I was only pointing out that failing on first failure (aka returning false on first false) was exactly the semantic of 'every', while 'some' semantic is 'returning success on first success', and that's all there was in my remark. Except for that, yes, I agree that the code as to be refactored, and yes, in a real-world case you'd probably want to associate each predicate with an error message and return them.
Here is a great place to test your regex as well. I use it all the time. http://regexr.com/
For what it's worth, you could return for reals from inside that callback in a language which supports non-local returns. JavaScript isn't one of those languages, however. As far as I know, there are no plans to add this.
There's a pretty neat looking library you can use.. [Isomer](https://jdan.github.io/isomer/)
I've toyed with this, it's pretty excellent
[Moment](https://github.com/moment/moment) is the JS gold standard for things like this.
how to get month and day in Moment.JS? help please :'(
snake_case --&gt; camelCase conversion is supported, as is any other conversion between database and "external" formats. Check out the [recipes file](https://github.com/Vincit/moron.js/blob/master/RECIPES.md#map-column-names-to-different-property-names) in github.
that's nice
Thank you for writing this. This is the right approach Not just for this case but in many other aspects at work as well. This is how you plant ideas into people's minds.
Since we're working in the Javascript console, the part before the reduce() could be simplified with XPath: $x('//tr[count(td)=4]') 
I do believe 1.0 is coming out soon. It's currently in alpha, and it works almost flawlessly for me. If you still have doubts, then my favorite is [Alt](http://alt.js.org/). Flummox is being deprecated in favor of Redux. I would avoid Reflux unless your app is pretty small; it breaks a lot of the great things about flux to reduce verbosity, it forces you to use ES5, and it isn't isomorphic. etc. Works fine for simple things though. I really enjoy [NuclearJS](http://optimizely.github.io/nuclear-js/) too, which uses ImmutableJS. However, some parts are a little confusing, and I'm not a huge fan of ImmutableJS in flux. Plain objects work fine and are elegant and flexible, as Redux proves.
Makes sense to me!
Thanks for the quick overview, I have been putting my eyes on Alt as well.
That's good to hear! But I still have to fully define the models correct?
There are actually two questions here: 'how should I develop graphics in the browser?', and 'how should I develop *games*?'. The latter is probably more important to answer first, because it comprises the former. If you are using a game framework (such as Phaser), it's very likely it'll provide you some abstraction over the graphics layer and place certain constraints around the way you draw things. The only framework I've used is Phaser, and Phaser assumes two-dimensional sprite-based graphics with raster images. You give it assets and can draw them at arbitrary locations, or draw primitive shapes. You don't actually touch the graphics layer itself. If building a game is your ambition, your best bet is probably to find a games framework that has rich support for creating the kind of graphics you want to create, and letting it worry about the implementation details. Now, what if we're intent on doing our own graphics programming? Well, there are three options here: - **DOM graphics** involves creating elements in a &lt;div&gt; and using style properties and background images to create visual effects. This is the oldest method and most browser-compatible, but it's fiddly and rather unperformant. It's quite rare to see DOM graphics used much these days except for very simple things. - **SVG** is a vector graphics format for the web. Vectors are interesting because they are infinitely scalable, and SVG is interesting because it effectively has its own DOM implementation: you create elements that persist, can be moved, can have events attached, can be deleted. It is what we would call a _retained graphics API_. - **Canvas** is an arbitrary bitmap graphics element. Unlike SVG, canvas is an _immediate graphics API_. You push pixels to it, and they just persist there until they are overwritten. There is no 'shape', just the resulting pixels, so you cannot zoom a canvas shape. And unlike SVG, you can't 'move' the pixels you've just created, you have to redraw both them and whatever they originally covered. And you can't just attach event handlers like you can with SVG either. However, because there are no entities on the heap (memory space), and because you don't have a DOM to deal with, canvas is very fast and scales well when you're drawing lots of complicated entities. Now, canvas and SVG have similar browser support, so there's not much to choose between there (although Raphael.js can effectively be used to shim SVG in legacy IE if needs be). Canvas is usually faster for large numbers of entities, but can be less performant than SVG for very large bitmaps (like the ones you'll want to create to exploit high resolution displays like Retina). SVG gives you events for free, but God help you if you want to emulate 3D graphics in it. I use SVG a lot in my daily work, but that's because I create 2D visualizations, often ones which need to be printed - so canvas really wouldn't work for me. It all really depends on the vision for your game. Generally, canvas will scale better for games, and there are a lot of libraries that will provide you a retained API with evented 'entities' whilst still using canvas under the hood. These projects will help you if you think your game is going to get particularly complicated visually. A lot of it depends on whether your objective is to _write a game_ or to specifically _write graphics code_.
That's pretty awesome. Love the flexibility of Redux.
Node? Sure, it will install. So I guess I wasn't clear. Install node on windows. Then try npm install say . . . damn near anything. Some deep dependency will want to compile and fail because there's no windows toolset similar to linux "build essential" Node runs, sure... but what's the point if random dependencies can't install?
&gt; Points 1 and 2 are not really clear. There's one sentence on JS&lt;-&gt;ES and there is, in passing, the mention that the focus will be the "JS interpreter". B Hi I just read your response, thank you very much for your feedback it's my first go at this. I will certainly take your suggestions to heart 
Regex with an array loop/method
I wonder if this is also influenced by developers in some languages being more passive on Github, so a popular project in one language might get more stars than in an equally popular project in a language where fewer users have Github accounts. For example, there are lots of Java projects on Github, but they seem to get relatively few stars.
It's not showing any content for me. When I click on the video it says "An error occurred". Found this error in the console: &gt; services.js:350 Uncaught TypeError: Cannot read property 'id' of undefined 
It's not unintuitive as there is no meaning of "empty" for primitive types like number and boolean. Empty doesn't even make sense in those contexts and even if you bend your mind in such a way as to make it a coherent thought, we already have undefined and null for primitives. We don't have a native value for empty objects, arrays or strings, however. It does exactly what you'd expect when called an object, which is its intended purpose. The issue is that developers don't read documentation. It's specifically for cases where you'd want the logical and of the three functions you've mentioned above as well and is much prefer not to have if statements with those three littered all over my code base, thanks. 
No, it comprises 1/3 of the popular applications, however that is determined.
It's probably worth pointing out why when so many people seem to believe JavaScript's popularity is due solely to its "merits."
JavaScript decimates one third!
There's a difference between "available" and "required."
In the console of Kongregate I get: Cannot read property 'videoId' of undefined here's one you might like: https://github.com/jgthms/juketube
Would be nice to see fibonacci example in ES6
Of course there's influences like this, hence why the title claims "popular applications *on Github*" and doesn't try to make a claim outside of that scope. 
I do the same thing as 99% of other Redditors: I read the headline and comment.
Congratulations youre a shitposter
I just rewrote a project yesterday, now using redux. I must say it i s a joy to use. Simplicity at its finest. Thanks gearon! You are doing &lt;insert entity of choice&gt; work son.
I had assumed you were considering memory management to be part of the interpreter platform, V8 gains some of its performance advantage by using very efficient garbage collection algorithms and representing JS objects in memory in ways that make lookup faster. You get into some weird areas just below the surface of the interpreter, vendors can implement the underlying functionality however they please. Browser API calls, while being JS methods, do a lot of different things under the surface to implement those behaviors without relying on more JS code to execute those functions. Because things are so implementation specific, I would recommend you choose one particular engine to study in detail so that you have an opportunity to provide very specific examples of performance engineering and can do some benchmarks. I personally feel like the interpreter is just one piece of the puzzle in the browser; I think you could sum this series up by showing how the interpreter works with the rendering and browser engines and underlying providers to make rich client side experiences possible.
A point to consider though is that if you try to use bind() to change the context of an arrow function, it will not have any affect, so you need to make sure the current context of this is really what you want(will be right most of the time). Arrow functions also get duplicated on each instance of the class because they are not associated with the prototype. I wish the article gave more examples about the nature of closures and why arrow functions are so convenient, but also showing the alternatives. ES6 adds a lot of cool stuff but everyone still needs to be familiar with older language gotchas.
That's not always true / or true without a transpiler. Most frameworks add that much code anyway. The js generated by typescript is simple, compact and readable.
It's just a javascript library. If you use it to build an app with something like cordova/phonegap, there's no reason why it wouldn't work on Android
Google for 'canvas draw example javascript'
I've never met anyone with that attitude and can't imagine someone claiming that the browser had nothing to do with its popularity. Are you getting mad at imaginary people?
Unlike bookshelf.js, it doesn't depend on any particular query builder (like knex.js for bookshelf). it is adapter-based, and you are free to roll your own.
Angular-Meteor? I've used it for a few months without issue. Adjusting to Meteor is quite a change though, lots of caveats, but I've quickly grown to like it.
One of the most exciting parts for me is array and object destruction. The fact that it works both for parameter as well as for return values allows you to write beautiful interfaces. 
I liked it, but it was massively buggy when I tried it. I made a simple list, with an add item button, and a delete items button (which deleted them 1-by-1, not the prescribed method, I know). I opened up two instances side-by-side and added a few hundred items. I then hit the delete button and they were totally out of sync. I didn't even look any further into it.
Meteor makes real-time data dead simple. It's probably worth cutting off your left arm just for that. Maybe try out one of the official tutorials and see if you like it: https://www.meteor.com/tutorials/blaze/creating-an-app https://www.meteor.com/tutorials/angular/creating-an-app
Looks cool! The only problem I see is that it can only work inside of single application. Is there a way to pub-sub messages between different applications/processes?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/learnjavascript] [Problem with countdown can anyone help! : javascript](https://np.reddit.com/r/learnjavascript/comments/3ca88j/problem_with_countdown_can_anyone_help_javascript/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger/wiki/) ^/ ^[Contact](/message/compose/?to=\/r\/TotesMessenger))* [](#bot)
Thanks. Indeed it is designed as a tool to facilitate decoupling of components within a **specific** app. Messaging between apps is a problem from a different domain. However, it would not be difficult to create a transport layer between apps (on top of HTTP, WS, memory sockets, etc.) which connects two instances of Portage; much like is done with https://github.com/postaljs/postal.socketio for example.
I imagine it wouldn't be difficult to wire this up to pub/sub messages over AMQP.
"Polyfills just detect the presence of an API, they do not iron out the bugs or inconsistencies found across the breadth of browsers." ; That is not always true, many polyfills are loaded after feature testing. Look at es5-shim source for examples
I want you do my JS homework please yes thankyou bye
Thanks and noted; in that case though, in order to use the spec'd API, you would have to override the original and potentially reference the original within the override. Pretty yucky (and dangerous), another good reason to lean on facades and avoid the issues all together. 
&gt; A facade, a form of wrapper, is a design pattern Welcome J**S**EE : JavaScript Entreprise Edition Proudly introduce by its father J**2**EE : Java Entreprise Edition
Oh, I didn't mean to criticise the article. Just wanted to add a thought I had regarding the scope of the findings.
This makes a lot of sense. Why would you ever want to access a variable before it's declared?
One thing that really bothered me during Browserify development: I can't use the developer console to test my application anymore. When an app loads, there's no way (afaict) to require a module so i had to put `window.foo = module.exports = { ... }`. Maybe I missed it. IMO Browserify should have an option to export modules to global scope during development.
I'm doing the same thing :)
That's also true @maruwan.
I guess this is for stubbing tests? You might be interested in: http://stephenjamescode.blogspot.ca/2015/05/mockingstubbing-dependencies-for-unit.html?m=1
so your code is just one large JS file all on the global scope without a hint of architecture? :P
I agree with this. One should be skeptical of stuff that modifies the standard library :P
Sounds like you're trying to reimplement expressjs and with the same goals? Only right now this boilerplate is more verbose and very limiting in its feature set.
just call it a backports
[You keep using that word...](http://imgur.com/au1NkeW)
This sounds fun! What are the exact instructions?
Just because you and I have run across people with differing opinions doesn't mean this is in my head.
What is Postal doing that it takes *seven seconds* to execute? Something isn't adding up here.
To be lazy, or weird code organization rules.
Could you post your benchmark code, please?
Declare or define your variables at the beginning of your methods. Problem solved.
The search results were either using the canvas tag or it was done in jquery. The assignment is to be done in pure js. 
As far as I understand from [postal's source](https://github.com/postaljs/postal.js/blob/master/src/AmqpBindingsResolver.js#L30), it's doing RegExp matching. In that test there are thousands of subscriptions and thousands of publications. Seems like postal will do millions of RegExp tests. Run this in Node and see how long it takes: for (var i = 0 ; i &lt; 1e6 ; i++) (new RegExp(".+" + i)).test("a" + i); In contract, Portage can eliminate comparisons much faster by organizing subscriptions in a tree structure, and traversing only the branches which can contain a matching subscription.
The instructor wants us to do it in a div and not a canvas tag.
Analogous to your "wrong tool" analogy is using web technologies for native apps. I'm still scratching my head over that one.
so, your non-framework boilerplate project becomes a framework boilerplate for the person that uses it. that's the definition of boilerplate :)
Makes sense. Why would they create new regex objects in the loop too? Gross. I figured it was a "bug" (in my opinion) in Postal after looking through the Fuzzy Tree source.
Did you know you can do the same thing in jQuery? You can build very fast code with or without jQuery or React or any other framework. Your speed difference here is likely only because the plugin was not approached very well when written for jQuery. The only argument here might be that it's easier to "get it right" with React.
Hmm that doesn't appear to be the case here. Chrome 43.0.2357.130 m http://imgur.com/mFmZHWJ
You may want to clarify what your instructor expects of you. A drawing application can be an advanced topic depending on what level you're at, and usually presumes that you have a canvas (general canvas, not HTML canvas) on which things can be painted. For your instructor to state not to use an HTML canvas, I have to wonder whether he just wants you to implement a UI around a drawing application, rather than the drawing application itself.
Yep, good to know. I wasn't aware of that particular "feature" either.
Temporal dead zone. \*reads link\* Yep. `var` is the one doing a weird thing by prematurely hoisting inside a function scope.
i admit the XML piece of the android layout mechanism is the least offensive and yeah, html+css+javascript has its own set of problems to manage. 
The result of `Object.create(null)` does not have a prototype.
Thanks! I am still learning javascript so I'm really proud haha and yes I choose some of the colors from google's material and used them in this. (I like flat design)
That's because you're setting result of that expression to have its `.__proto__` point to null (essentially overwriting the prototype chain). 
The why or how isn't what's important. We're just saying that when you say &gt; This means it's the only object not to do so that's not necessarily the case. And you're not necessarily overwriting the chain, rather creating an object that never had one to begin with. Overwriting would be if you had a pre-existing object and redefined `__proto__` to null or used Object.setPrototypeOf() with null.
Well when you take the stupid terminology away it still means that let/const are hoisted, because they shadow the same name variable from the outer scope.
you use RequireJS instead?
That TDZ stuff really isn't an issue. You can't use a local variable prior to its declaration. That's it. It's like that in most languages. It's so much of a non-issue that other languages don't even have a term for that. If you actually do make that mistake, you get a squiggly line, because that mistake is so simple that even a linter can spot it. If you run it anyways, the used JS engine will tell you the same thing. It's impossible to miss and fixed within seconds.
Thank you for saying this. I read the SO answers and then felt like I was taking crazy pills or something. I kept thinking: "Isn't the behavor of `let` best described as 'sane' or 'normal' for a programming language?" Edit: Okay, now I see the problem. The 'let' keyword has one wart: [the variable is considered kinda/sorta 'defined' for the entire scope *before* the let statement itself is evaluated.](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-let-and-const-declarations) So it's possible to shadow a variable in an outer scope, just because the statement is *present.* And since the behavior here is to throw an exception before the let statement is evaluated, we have yet another odd JS behvior to account for. Best put those variable declarations ('let x;') at the top of the function scope, just like your CS prof. told us.
 function initialize({controls = {}, models = {}, reducers = {}, actors = []}) { That is not actually an example of destructuring. It is an example of default parameters. 
&gt; This is purely Node. Expressjs is purely node. No idea how you can suggest it isn't otherwise. One of the main objectives of Express is to provide a minimal layer to build applications without bloat and does it very well. The point I'm getting at is why create a project that does the same thing and with the same goals when you could contribute to the existing if it's not working how you like? Running `express myapp` and I have a complete minimal project structure without any bloat just as you are trying to develop towards.
Yes. I need this in the console: `$ = require('jquery')` 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Is a coherent full stack testing strategy even possible? What am I missing? (full stack JavaScript)](https://np.reddit.com/r/programming/comments/3cbs1i/is_a_coherent_full_stack_testing_strategy_even/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger/wiki/) ^/ ^[Contact](/message/compose/?to=\/r\/TotesMessenger))* [](#bot)
Yeah, sure. Agreed once you bring in the `main` wrapper. But as we get less and less contrived, it becomes less and less fun to argue. 
Things to consider: **Order of execution** For consumer code: fire('event'); do('stuff'); In the first implementation, listeners would always be triggered before `do('stuff')`, the 2nd, the reverse. I don't think there is universal definition for this, but I believe Promise (if considered a pub/sub) defines that `do('stuff')` should always happen first. **Minimum delay** setTimeout has a minimum time of 4ms (defined in HTML5 spec). So if you go thru a stack of 10 event listeners, your code would be delayed 40ms. This can be resolved with setImmediate or similar shim. **Exception handling** Depending on the choice, exception handling would need to be done differently. Since one is sync, the other is async
Why do you want to enter js code instead of typical mathematical expressions? Also, why not just write a script that takes js as input and outputs typical mathematical expressions?
Don't downvote people for asking questions about a project. That doesn't help anything and destroys discussion. Didn't realise I was getting into an argument about frameworks though. I guess you don't like people comparing your work to other projects with the same goals so I'll leave it at that, good luck.
use the `browser` field in your `package.json`. It allows you specify a version of a file to use when building the client bundle so you give different versions to clients versus requiring the same file locally. it's even [documented right in the readme](https://github.com/substack/node-browserify#browser-field) 
That is destructuring with default values but without a default value for the whole thing (needs another "= {}" at the end). So, it will break if you call it with zero arguments. Anyhow, here is a somewhat simpler example: function foo({x, y}) { console.log(x * y); } class Point { constructor(x, y) { this.x = x; this.y = y; } } foo(new Point(3, 5)); // 15
I agree on the exception handling and order of execution. I am not so sure about the minimum delay though. There is definitely a delay, but I don't think that it is additive. I tried this in safari and chrome and they both executed pretty quickly once the page loaded. http://jsfiddle.net/notoriousb1t/L0Lw7La0/1/ var start = new Date().getTime(); var total = 100; for (var x = 0; x &lt; 100; x++) { setTimeout(function() { total--; if (total === 0) { var end = new Date().getTime(); document.getElementById("something").innerHTML = "" + (end - start) + " ms"; } }); }
You want to crack a password. It's done by checking every possible condition until the right one is found. You need to write code that will check all possible combinations of allowable characters. The whole practice falls under the scope of cryptography. You can Google "crack password" to learn some techniques, but obviously be kind of careful as password cracking comes with some unscrupulous connotations. 
I believe I know native DOM APIs, but I don't know what I'm looking at here...
Ya I am using it to get back into my accounts and I cant reset the password and I am locked out of my gmail so I cant do it that way either plus I thought this would be a good way to practice my Javascript class lessons.
I don't know... I'd just write the js in a js environment and then copy and paste the results in to the graphing calculator. Maybe I'm misunderstanding what you're trying to do though...
I've never don one... but I'll see if I can throw something together. Give me a minute here...
I would look into something like [Karma](http://karma-runner.github.io/0.12/config/browsers.html), if you would like to automate front end / client / browser tests. It's a bit complicated, but a huge time-saver once it's set up, and I believe it will cover a good chunk of your requirements. Not all of them, though, if you need to automate across operating systems and don't already have a set of virtual machines setup for this. Other options would be something like [browserstack](https://www.browserstack.com/) or [saucelabs](https://saucelabs.com/) where they emulate a list of browsers / mobile environments and automate the unit tests with reporting. I don't have experience with those and I don't believe they are free, but I have heard good things. Use something like gulp (my favorite), browserify, or webpack to automate the javascript build (minification, dependencies, etc).
What specifically don't you understand? I'm here to explain anything.
I considered that... I don't know how to get around it though.
Not exactly. They indeed allow stubbing but at compile time and only one level deep. I needed something that works at runtime.
Because you have to update the models when the DDL changes, and store what is pretty much a DDL definition in two places. Likewise having it just in moron makes it not as portable as raw SQL. This is generally okay with people who are creating brand new products from the ground up, but not for people who are managing multiple code bases and working on migrations for services from one code base to the other.
That is a good idea
forEach is nice if you just want to call some function. E.g.: a.forEach(foo); Or if it's a short lambda: a.forEach(v =&gt; ...); But if you want to put some multi-line body there, for-of looks quite a bit nicer: a.forEach(v =&gt; { ... }); for(let v of a) { ... } Another key difference is that forEach only works with arrays. for-of, on the other hand, works with anything that's iterable. So, it will, for example, work with a NodeList returned by QSA: for(v of document.querySelectorAll('.md')) { console.log(v); } Or a DOMTokenList: for(v of document.body.classList) { console.log(v); } It also works with generators or Map &amp; Set. So, for-of is kinda handy, actually. For what it's worth, my list pretty much looks like yours. :)
Are you dead set on javascript? You can probably do it with just html and css. But javascript isn't hard to implement either. Like this? html &lt;div class='timeBlocks'&gt;&lt;div class='timeBlocks tabCell'&gt;1:00&lt;/div&gt;&lt;/div&gt; &lt;div class='timeBlocks'&gt;&lt;div class='timeBlocks tabCell'&gt;2:00&lt;/div&gt;&lt;/div&gt; &lt;div class='timeBlocks'&gt;&lt;div class='timeBlocks tabCell'&gt;3:00&lt;/div&gt;&lt;/div&gt; &lt;div class='timeBlocks'&gt;&lt;div class='timeBlocks tabCell'&gt;4:00&lt;/div&gt;&lt;/div&gt; css body { background:darkgray; text-align:center; } .timeBlocks { display:inline-block; height:60px; width:100px; border:1px solid; text-align:center; } .tabCell { display:table-cell; vertical-align:middle; background:lightgray; font-weight:bold; position:relative; cursor:pointer; } .tabCell:hover::after { display:block; height:100px; width:300px; background:white; content:'Hi'; border:1px solid black; border-radius:10px; font-weight:normal; position:absolute; top:66px; }
How minimal the business requirements are for the front-end depends upon the nature of the SPA and how the modules are laid out. For instance, when BAs make a decision to show a certain widget on certain URL states, maybe it makes sense to put that into a backend API and call it as a resource, but you probably want to still validate that it is rendering that way with end-to-end tests regardless.
I have figured out how to extend the password guess, but I would like to see a console log maybe of it trying to guess it i'm not sure if you can though it would be nice. And what is the .split(" ")?
Ofcourse, but by pushing the business logic to a resource you have ensured that you can test the business logic and UI in isolation, which is crucial. 
You know how you could do this: div[0].className = 'divClass'; You could just do: div.className = 'divClass'; But for something that's an attribute yes use that: div.setAttribute('ok', 'yes'); BTW I'd change my variable name from `div` to `divs`
That's fine, but it hardly makes front-end testing minimal, which was my original point. It's still a mountain of work to do testing properly given enough views.
Very nice response. Yes, setTimeout will add a slight performance overhead to your call. Not much, but enough that if you can not use if for large data sets, it's best not to, you also add another function to the call stack. setTimeout will run the code inside of it at the next possible open tick, which is what setTimeout will do. I have noticed for large data sets, this will cause the process to bind, as the browser needs to handle a mess of these, which causes it to thrash, instead of letting the browser cut in when it wants. In theory it's nice, and less of a blocking factor, but in reality you get into problems. One this that is kinda nice about this, and you nailed it on the head, because you're running those functions in setTimeout, if one fails, the other iterations will still run. However, you can do that with try/catch statements.
Thanks for your reply I'm on my phone now as well so can't try but would that cause the countdown to be correct all day then change at 4:15 to add another hour?
I think it is possible, but very hard to achieve. You would need to write frontend and backend in the same language(JS or any language which transpiles to it) and on top of that you would have to properly share portions of your code between frontend/backend.
I really wonder about the growing popularity of XML in client side web development, because client side developers have bitched about XML so much for so long. It really strikes me as odd.
ever heard of smaccs? https://smacss.com/
Do you want to actually generate the modal in JavaScript? 
Putting everything in a single file is going to be hell. What's wrong with modules?
Yes it does thanks for explaining! But how would I make it so it will do a console log of all the "passwords" it has tried?
Isn't validation on both the front-end and back-end a good thing? 
I think people bitched about XML as a data interchange format. This is a bit different, it's about building a tree of components. There are many viable ways to do that, but it so happens that XML/HTML/JSX works pretty well. It's easy to grok and familiar to anyone who has worked with HTML, like designers. Since we need to work with HTML anyways (we are building webpages here, right?) it makes sense to have an API that looks a lot like HTML. Arguments for and against XML as a data interchange format is a whole separate discussion, of course :)
Gibbon is closed source so a lot of this talk isn't too useful unless you want to write your own react-canvas interface.
Well... with my little example here, the password has to be known. What you're going to do, if you're actually going to apply this somewhere, is have the program enter each password until it's in. So if would have to fill in a password field and then click a button to submit each password and then move on to the next. Ya dig?
Not sure why you're being downvoted. The script could be heavily simplified if OP pulled in a dedicated library for dealing with dates/times (e.g. don't need to worry about months being 0 based).
Alright I'll think of something I'm interested in. Thanks!
&gt;It shows that reddit's developers really don't understand front end dev - they just jump onto the latest framework without any regards for suitability Reddit is a site with massive content and user interaction. It's a perfect use case for React.
On the subject of "Material Design" in general, there's been an ongoing discussion in /r/webdev and elsewhere to try to understand why Material Design is appealing to so many developers when many people find it to be visually not especially appealing, and it has annoying quirks like buttons that appear to move upwards when pressed downwards. It occurred to me exactly what's wrong with Material Design. The problem is it was designed by Google engineers. It was designed the way an engineer would do design, by studying the problem as if it is something that can be solved if you analyze it scientifically. And so from that they created a well worded document describing the problem and their solution. What's missing is the artistic side. The human side. The stuff that you can't analyze and compute a correct answer. The touchy feely artsy stuff that makes Apple design and others so inexplicably appealing. I think that's what's missing from Google's culture where advanced degrees are valued above natural ability and artsy type creativity, and that's why Material Design isn't as appealing as it could be. Except the issue with the buttons that move up and you press them down, that's just a failure on all levels.
Lots of whitespace and easy to read comments for separation. The quicker you can scroll a lot of content and be able to easily identify different areas of code in your file (that would otherwise be modularized) the better
Thanks for the link! As a C# developer learning JavaScript (and looking forward to a Node/NodeToolsForVisualStudio/(yet bundled for execution in the browser somehow) ecosystem, I've been watching typescript for a couple months. Last week, I watched Rob Ashton's "React + NPM for Great Good" on youtube and thought: write views in JS... makes sense! But then I thought: how am I possibly going to get TS to see that stuff... no way! and now, there's a way :)
Ok, you got me... maybe two :) No, what I was saying is that all that stuff I'd categorize as "bells and whistles". A basic bus is what I was talking about because for most use cases that's sufficient.
There's already promised core Nodejs module. https://github.com/normalize/mz
Woo pretty cool, didn't think it would land anytime soon. I was using React.DOM until now, I'll need to look at it. 
I just want a modal to appear without having to have dozens of them in the markup. I dont know if that means having one and using variables or what the workable method would be.
Hire a QA staff or outsource it to a QA firm and let them deal with it ;) But in all seriousness: 1) Separate unit testing from integration testing. Unit testing should not require a much bootstrapping like precompiling/minifying your js. Integration testing is essentially simulating the end user using your application. There are a variety of unit testing frameworks. I personally prefer Jasmine as it's very easy to get up and running. There is also Karma, which is more flexible and modular, but needs more configuration to get going. 2) You can automate integration testing using a wide variety of tools, and it all depends on your real business needs. Check out Selenium for creating automated cross browser tests. You can integrate this into your build server, and include other tasks that can spool up real servers for your web app to talk to. 3) Unit testing should be part of day-to-day development, but integration testing does not. Ignore that Agile mantra nonsense about how there always needs to be a fully functioning piece of software at the end of the day (or iteration, or whatever). Your frontend and backend teams can deal with being temporarily out of sync sometimes, and so you don't need to make sure your server side unit tests work before making sure your client side unit tests work. In fact, just treat them as separate projects, either bureaucratically, or just on your build server.
If you absolutely won't use a module pattern like AMD or whatnot, at least "modularize" your code using global namespaces for your constructors and functional code and import the various files in your index.html (or whatnot). If you really really want them all as one file and you stubbornly refuse to use some compile step to merge many to one, first think long and hard about why. Then if you're still set on it, just split things off with nice big spacers between your major themes. Whatever your folders or files would be called, do that with some fancy ASCII section comments.
What? I'm sorry, you need to show me where the 'massive user interaction' is, because I only see a mostly static page with a few user interactive elements, like the up vote button and the menus. These don't change the actual DOM structure significantly. And if you have massive content (which in reddit's case is disputable), why would you want to render it on underpowered mobile clients instead of your server? 
I saw this about a month ago, thought it might be relevant. [ Making Material Design](https://www.youtube.com/watch?v=rrT6v5sOwJg)
What is your dev/build env? I guess something is wrong here. There are tools that will, with no effort, put you directly in the module world and build for you the lonely main.js file you like. 
The event dispatch example wants them "in parallel" so the benchmark was correct. (They're not really executed in parallel though, they're all queued one right after the other as the for loop iterates, then after the interval each is pulled off the main event loop and executes sequentially.)
The code seems to work fine for me. Could you specifiy what exactly goes wrong? Do you get an error message? Does the page have enough content to actually make it scrollable? And if so, is there enough content below the '#joinus' element so the page can actually scroll further down?
Just to be back on topic, I think it's really perfect to use it with ReactJS. It misses some parts like animations or form validation, but I believe (OK, want to believe) that it will be maintained by Google 
I'll just put his out there. I strongly dislike animations in UIs, they make me feel dizzy and I find them incredibly distracting and disorienting. One of the first things I do when I get a new Mac is modify all the system defaults and remove any animations that I can. I also have stopped using apps before simply because they started adding animations I couldn't turn off. Also, every time I come across parallax I immediately close the tab because it annoys me to no end. I think it has something to do with the uncanny valley where thing looks like they're moving in some sort of natural way, but I can clearly tell it's not natural. For this reason I really can't stand material design.
Updated feature list description (added some examples for clarity): https://github.com/xpl/useless/blob/master/README.md#functional-primitives
It's really buggy in the demo section. I can't preview on components, like cards, by clicking on the left sidebar. 
Let's start with the fact the Java and JavaScript are NOT the same thing so installing/updating Java SDK on your machine is irrelevant and will have no impact either way.
hi. I developed Echoes Player - which is based on angular. http://echotu.be (also available as a Chrome App)
Be careful not to get the likes of "angular-material" confused with "Material Design". Material Design is mostly documentation (it's a design language and a set of guidelines), while angular-material is mostly software that implements some of those guidelines. I'm pretty sure you could implement those guidelines using Bootstrap if you wanted.
What browser (and version) are you using?
True true, all of these frameworks such as angular-material, MaterializeCSS etc. are implementations of Material Design as you said. But my point still stands that implementing Material Design is no different to implementing the default Bootstrap theme. It's down to the designers and developers to actually customize that theme. To me it doesn't make sense to say implementing Material Design is boring as it's the same if you implement any framework's default styles.
Regarding the HTML/JS/CSS triumvirate, I always like to use this video as a response: https://www.youtube.com/watch?v=DgVS-zXgMTk&amp;t=3m20s tldw; "HTML" in JS isn't so bad if you're thinking in terms of components I can understand not wanting to sully TypeScript with something you don't think is pure. The somewhat good news is that they didn't make it React-specific. They tried to keep an open mind about other possible uses of JSX and make sure the implementation works with those too. So there's that, at least.
Chrome (latest)
&gt; You can build very fast code with or without jQuery or React or any other framework. (...) The only argument here might be that it's easier to "get it right" with React. Agreed.. and being easier to "get it right" still sounds like a great benefit to me. &gt; Your speed difference here is likely only because the plugin was not approached very well when written for jQuery. I'm open for suggestions on how to improve the plugin since I'm still going to be using it with jQuery, so please let me know if you have any tips. On the other hand, by simply following along with React's convention, I was able to get a much better performance. Again, sounds like another +1 for React.
I like the idea of adding default function parameters first - that one totally slipped my mind. I'm not so sure about adding let/const earlier though - it feels like this one might confuse a few people, and I like the idea of putting a simple win at the top.
Wow, can you check your console and see if there are any JS errors? It is working perfectly here in Chrome (although on the Dev channel.)
You didn't write about the best part (IMO) of the arrow functions, which is scope.
this was the case for me too yesterday evening, but today everything seems to be ok.
You only have to define the relations in moron.js. Not other columns. The `jsonSchema` object is only needed if you want to use the built-in json schema validation. If you add a relation or change a foreign key column, you have to modify the code also with Bookshelf, right? Or am I missing your point completely?
email, from-to, conditional mandatory, etc. But I guess validation is out of the scope of MDL. I didn't check how easy it's to integrate a validation library with mdl, if it's the path chosen.
Sure, nothing wrong with efficiency being an out-of-the-box feature. The general-case tip I have is to write your code in a framework-less way, and then plug your code into any frameworks you want to use or support. In this way, you end up avoiding excessive calls to `$()` and tying things up "the jQuery way." Another recommendation is to be smart about how you're approaching rapid draws. Do you need to animate, and does it make sense to use CSS instead? Do you need to add a bunch of elements to the page? Perhaps maintaining an element tree "in-memory" and then appending the entire tree to the page make sense, rather than appending one element at a time. Is jQuery too slow at creating complex trees from a string? Use `document.createElement` instead. These aren't really specific to jQuery though. I recommend the same for React and any other framework.
In the first example you can also do this :) var totalPostsByActiveUsers = users .map((user) =&gt; user.posts) .filter((posts) =&gt; posts &gt; 50) .reduce((a, b) =&gt; a + b);
I don't know if JavaScript behaves the same way, but in TypeScript the way around this issue &gt; But if you try to use this as the body to an arrow function, it’ll expect that the opening { is the start of a regular FunctionBody, and error when it sees that the contents doesn’t make any sense. // When you write this... var newUser = name =&gt; { screenName: name, posts: 0 }; is simply to surround the body with parentheses var newUser = name =&gt; ({ screenName: name, posts: 0 }); [TS Playground example](http://www.typescriptlang.org/Playground#src=var%20x%20%3D%20o%20%3D%3E%20\(%7B%20key%3A%20o%20%7D\)%3B) Oh wait, he mentions it. Nevermind.
Maybe read the whole article?
The getting started document is empty...
No worries, I'm a n00b as well! Okay, so here's how I'm thinking about it: With a site like Gmail, the program would have to locate the password input field, set its value to each guess, and then activate the submit button each time. I'll see if I can think of a way to have it do just enough digits to crack the code.
Spacegray + Oceanic Next + Babel
I hope it doesn't mean "It's so easy to get started that there's no need for a 'getting started' section"
Seems like a bad version of Bootstrap
Drawing and playing cards is like a running a state machine the cards can also have context so that depending on the current state, the next card may or may not have a new effect. You can build a "deck" that is a javascript object like this: deck = [ { "name": "red", "effect": "turns background red" }, { "name": "die" "effect": "kills player" } ] You will still have to have a function that determines the state as each card is drawn. This function can have hooks that affect the GUI so when you are ready to deal with the GUI, just build on these functions. But as you can see, if it's helpful for your game you can add a lot of attributes to each card as you need them. These properties can help the state function determine what to do next and how it gets to determine the GUI state as well.
Not entirely sure what you're looking for here, but... css .card { height:116px; padding-top:68px; width:120px; border:2px solid; border-radius:10%; text-align:center; font-weight:bold; background-image:url(http://cdn.europosters.eu/image/750/stickers/ace-of-spades-i7539.jpg); background-position:center; background-repeat:no-repeat; background-size:124px 150px; } modified your js function Card(name) { this.name = name; document.getElementsByTagName("body")[0].innerHTML = "&lt;div class='card'&gt;"+this.name+"&lt;/div&gt;" }
Okay, but here's the strange part. What you described isn't exactly "very basic." It's certainly not ideal, and it involves understanding how to create elements on the fly, and how CSS positioning works. You can accomplish this with *just* divs by injecting an absolutely-positioned div into the point where the cursor was dragged. I can't for the life of me think why your instructor would assign such an asinine task, however. What level is this? I would challenge your instructor (respectfully) and ask why he wants you to approach it this way, or whether you're misunderstanding his intent.
Well you can handle it in different ways. One way is to just add an extra test in your function for the state you are looking for. Adding a listener that responds when a certain observed event occurs is workable but it's a little bit more difficult to understand. The code starts to hide your programming intent.
&gt; Yep, but as I said, trying to get as many lines out there as possible. So do you have any advice? 
Given the name, I was expecting this to be some joke framework like [vanilla.js](http://vanilla-js.com/) or at the very least contain some fun tongue-in-cheek acknowledgement of useless vs Use Less... nope. Totally serious. Good luck with that :)
Semicolons are good. God damn coffeescripters, get off my lawn.
This is a forum to talk about Javascript development, not to get troubleshooting advice for why your machine isn't running a site's javascript like you think it should. 
And how else can I describe it?
So you don't even know what's **not** working?! Hoo boy... Let's start here: what are you trying to do and do you have any **working** examples?
I'm starting to see why they call you The Pariah... 
I'm not the most articulate at times. it's not intentional, I hope you can see.
Contact the site admin?
Unfortunately, this sub is not the place to pursue a solution.
Do you know where I can go that I haven't already?
Yep. Nexus support is ass. 
Cool. Also consider maintaining the source as Markdown. That way it would be easer for others to read and edit.
http://codepen.io/aholmes/pen/BNrVdv Oh I just read the part where OP said "drag around a div." Oh well.
~~http://codepen.io/ForScale/pen/ZGxRKG~~ ~~http://codepen.io/ForScale/pen/XbEYYN~~ Okay, here are the basics, OP (**the absolute positioning on the drawn divs needs to be adjusted for various screen sizes**... and there's a glitch which allows the drawing to keep happening when the mouse button is not being held down... Can you find it?). I'm going to start adding on to mine: var div = document.createElement("div"); document.body.appendChild(div); div = document.getElementsByTagName("div")[0]; div.style.margin = "auto"; div.style.height = "400px"; div.style.width = "600px"; div.style.border = "1px solid"; div.style.position = "relative"; div.style.overflow = "hidden"; div.style.cursor = "crosshair"; var bool; div.addEventListener("mousedown", function() { var x = window.event.clientX; var y = window.event.clientY; div.innerHTML += "&lt;div style='height:10px; width:10px; background-color:black; position:absolute; left:" + (x - 665) + "px; top:" + (y - 14) + "px;'&gt;&lt;/div&gt;"; bool = true; }); div.addEventListener("mouseup", function() { bool = false; }); div.addEventListener("mousemove", function() { if (bool == true) { var x = window.event.clientX; var y = window.event.clientY; div.innerHTML += "&lt;div style='height:10px; width:10px; background-color:black; position:absolute; left:" + (x - 670) + "px; top:" + (y - 10) + "px;'&gt;&lt;/div&gt;"; } });
This is exactly how Material Design should have been implemented all along. The React and jQuery implementations were cool, but being dependency-free is pretty vindicating.
Very true: one is mentioned in the article, the other is not.
Huh, apparently it's working for me right now. Are there any logs or some such i could give you? 
Had to make a better one! Different approach; used only js this time. http://codepen.io/ForScale/pen/XbEYYN 
Really, look into moment.js This problem has been solved. Over and over and over and then someone made a solid library so we could stop solving time management in javascript.
 .map(({posts}) =&gt; posts)
Dammit! It's perfect on my screen... I got obsessive with it! Perhaps I'll try messing with %s to see if that'll work...
What the fuck.
For completeness here's pause: function pause(millis) { return new Promise(function (resolve) { setTimeout(function () { resolve(true); // truthy to avoid headaches }, millis); }); }
well.. shit. just tried that and the variables are indeed tied to the instance of the subclass, since that's the scope the baseclass constructor runs in. thanks for explaining this, really helpful!
This is my least favorite thing about es6. Now we have two ways to write functions, each with their own scope and one which is completely unreadable.
Cards have different effects!
thanx, I will try it for a bit, but I'm *quite* conservative with my homepage XD
My brain.
That didn't do it. I can't figure it out. I'm going to give up for now. Maybe look at it with fresh eyes later this week. Thanks though
Made my own to get up to speed: http://codepen.io/ForScale/pen/bdvjjw Pretty straightforward. I'll take a look at yours...
Alright, added your video and buttons in after my experiment. Yours is working for me on Chrome. It's a little slow for some reason, but it is working. Let me know if you have any questions! http://codepen.io/ForScale/pen/bdvjjw
Why would one use X-View instead of React?
I second JavaScript Weekly. Very informative and concise.
Neither, actually. It will be a Node object, which in JavaScript is a little different than a regular object. It will have all the element.prototype methods on it. Try opening up the console on this page and entering the following. document.getElementsByClassName('content')[0]
Lol okay and sounds good.
For it to be a length 1 array, `getElementsByClassName()` would have had to have returned an array containing a series of arrays that each contain one element. That would be pretty useless and hostile, don't you think? The [documentation says](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName): &gt; Returns an array-like object of all child elements which have all of the given class names. 
GREAT! I'm a guy in the midwest, but I'll keep your offer in mind! Thanks! Say... does your business need an IT guy?
getElementsByClassName returns an array-like object. Via square brackets and an index you can access one of its items. [0] is the first item. By the way, there is no point in using getElementsByClassName ever. Since it's not supported by IE8 and below, you can as well just use querySelectorAll and querySelector. So, to get the first element with the class "babes", you can just write `document.querySelector('.babes')`. If you use querySelector and querySelectorAll often, create aliases for them: var qs = document.querySelector.bind(document); function qsa(selector) { return [].slice.call(document.querySelectorAll(selector)); } Now you could write `qs('.babes')`. That qsa function returns a real array which means that you can now use stuff like forEach.
&gt; Haha! Everyone's so mad at me! We're the people who clean up after you. :)
&gt; cross-platform Since when is javascript not cross platform? If you're talking about the build process, ok, but the library itself shouldn't even have to specify this. Also, you may think the name is funny, but it will turn more people away than it will attract. I didn't even know it was serious until these comments, and I even went to look at the repository first.
I think these dates are all generated in PHP, not Javascript. You would have to post the relevant PHP code for any feedback.
Ya I know about inspect element, and that makes sense. How would we incorporate it into the script though?
That part... hmm... I don't know. We might have to do some Googling for that one. "How to inject javascript in to established webpages" or something like that. You could do another post here asking about it too... people can be kind of finicky though...
Sure, that's three different event dispatches. If each one adds 4ms (irregardless of the number of observers) then you're right that it'll take an extra 12ms for the entire chain to execute. If this delay is problematic there are faster ways to do async: Node has process.nextTick, browsers have postMessage, and there's also Promise.resolve in modern JS. Each of these can be used to call arbitrary code on the main event loop without adding timer delays.
Yeah I feel like the ES6 stuff is fairly coffeescript influenced, which sucks because I really don't like coffeescript... Between the destructuring and new function arrows, I find it considerably less readable.
You're not insulting, you're rather funny (in good sense) and wise. Thank you for that.
How would you get the elements vertically centered the same as netflix? I'm having difficulty doing that, vertical-align: middle isn't working. edit: nevermind, I just noticed the `transform-origin` and setting it to center worked great. Anyway thanks for the example!
why?
give this person his gold! edited for great social justice
It's still just an object. Nodes aren't special in any way from normal objects except for the prototype.
Because I need to 
First, you need to establish a) editing privileges for said pages (we don't approve XSS), b) knowledge which potentially conflicting JS is already on the page, c) a workflow how to add and/or replace JS.
When you search injecting javascript in to established webpages alot comes up so we may not even need other peoples help for this. But the information may not pertain to what were doing.
And someone said this for my post First, you need to establish a) editing privileges for said pages (we don't approve XSS), b) knowledge which potentially conflicting JS is already on the page, c) a workflow how to add and/or replace JS.
Not sure if it is a good idea to create aliases for that kind of things for the same reasons "typedef float flt;" is a bad idea.
Not maintained anymore, but it works just fine: https://github.com/defunkt/dotjs
Use something like Selenium Web Driver: https://code.google.com/p/selenium/wiki/WebDriverJs
&gt; Nodes aren't special in any way from normal objects Except that they aren't normal objects. They are magical host objects which correspond to nodes in the DOM tree (which lives over in native land). That's why some seemingly simple operations on them are surprisingly slow. E.g. `someNode.children` is a live HTMLCollection which means that accessing its `length` property is actually somewhat costly. Another good example is `document.location = ...`. This allowed you to navigate to a different URL way before setters existed in JavaScript. Since `document` is a magical host object, it could just do something like that.
This seems like a neat way to add some more complex features to bitbucket. I find that more frequently I'm looking for smaller utility or cosmetic changes to improve workflow, and have a lot of luck using regular old user-scripts to enhance my repo-provider of the moment. https://github.com/jamesgarfield/bblocdiff https://github.com/jamesgarfield/GitHubSourceTree 
You think this: [].forEach.call(document.querySelectorAll('.md'), function(e){ ... }); is better than: qsa('.md').forEach(function(e) { ... }); ? Well, I don't. I also think that jQuery is quite nice. By the way, this stuff isn't necessarily shrouded in mystery. If you use modules, it's crystal-clear where this function is coming from. Plus, you can just use "go to definition" to look at the source or tool-tip it to read the one-line summary.
https://github.com/antimatter15/jsgif haven't used it, but looks like its what you want.
I prefer this: var mds = document.querySelectorAll(".md") for(var i = 0; i &lt; mds.length; ++i){ ... } The "go to definition" mitigate, but does not solve the problem.
Why don't you type it into the console and find out? There is absolutely on excuse for this post... Down with hand holding
I think you’ve misread him. What he is trying to add is a javascript widget, I don’t believe that it’s already an app on Facebook. We need more info from op to better assist him. 
8132bit?! Excuse my ignorance and stupidity, but I honestly thought 128 was highest since all of the websites I've seen (such as all of the CS:GO betting websites, Paypal and my online bank account) use 128-bit encryption: http://gyazo.com/1ce4c05e1571c9abb2aa4cf994e76219 unless that's something else? However I have never looked in to this before as, well, I've never needed to so, again, sorry for my stupidity on the matter :s However I will look in to them, again, thank you so much!
What's your specialty? We have a few people we subcontract in the past, but we're trying to keep as much in house as we can.
Ah yes, my mistake. He has a ready made JavaScript widget that he want's to embed on his mother's Facebook.
Yes??? What is your point? Just a random comment because it's late?
Every programmer at some point in his/her life had no idea how to access the browser console. This stuff has a learning curve.
&gt; What's your specialty? Providing solutions to problems related to html/css/javascript. Also general PC including Microsoft Office applications. Mobile device set up and maintenance. Business analysis including report generation. And mental health counseling (clinical interviewing and treatment provision... goes a long way towards superior customer service!). :)
:) You gotta reply to me each time, not to yourself. Otherwise I don't see a notification letting me know you messaged me!
Usually when you need this inside the function. Also, I would omit the parens around the parameter list since there is only one parameter. Also, if you have a one liner function the arrow function syntax is more readable (no function keyword, no braces, no return keyword) once you get used to seeing it.
So, you don't create any functions because functions are confusing? Also, tooling isn't necessary to understand it. It's just there to assist you. You could ask me in 10 years what "qsa" means and I would be able to tell you that it's a commonly used abbreviation of "querySelectorAll". However, no one remembers all code they ever wrote and usually, when you're working in a team, you haven't written all the code anyways. That's what tooling is for. If you don't remember or know what something is, the tooling will provide this information as quickly as possible. In general, you'll have a lot more information right at your fingertips. Anyhow, let's go back to your imperative code snippet. How would you do a filter followed by map? Would you write 2 for-loops? Do you think that would be an improvement?
Nice job! I wish my sense of design was as sharp. Off Topic: I shared my own codebit over at /r/codecademy. Your post showed up there too. Did you post to both subreddits or is there some other way postings are shared? (I'm new, sorry)
I really like the idea of the project directing the architecture. Each project has different needs and starting with a very simple implementation will help you figure out what's right for you, rather than blindly follow an already established approach.
&gt; Yea, just about everything in JavaScript is an object (even an array). JavaScript has objects and primitives. https://people.mozilla.org/~jorendorff/es6-draft.html#sec-primitive-value "member of one of the types Undefined, Null, Boolean, Number, Symbol, or String" So, numbers and strings don't actually have methods. Those primitives are just auto-boxed to make it look like they do. `'foo'.toUpperCase()` is actually `(new String('foo')).toUpperCase()`.
Haha oops.
Okay so we need to get that then use it to inject our script once of course we get it so it can enter the password and submit it.
GTFO. This isn't a place to ask for free work. Pay someone to do it if you lack the skills. 
The nice part is greasemonkey can really do all of that. There might be more tailored extensions but greasemonkey will let you do anything.
Facebook doesn't make this as easy as they used to. You will probably need to go down the path of creating an app and adding it to your pages apps. They used to be more fun and customizable than they are now.
The problem is not creating new functions. The problem is replacing standard features with your own code.
Madness. Regular old JavaScript is rad. All that other goofy crap is the burning hellfire. Calling it "bare metal".... shit son. Be glad you don't have to think about what a pointer is.
Was referring to "The generators/yield were new, async/await isn't" part of your comment. My apology, should've been more specific, since your comment is quite detailed. 
Again, never said that creating functions is a problem. You can stop with the straw man now.
They *are* new. Have a look at the name of this subreddit... it too is quite specific.
Well, let's go back to square one then. There is a function called "qsa". "QSA" is a common abbreviation for "querySelectorAll". This function is called with a string which is obviously selector. Then there is some forEach or whatever which contains some DOM code. And you're saying that this would be most certainly super confusing. I don't think it would be. If you can't guess what it does because you're completely stoned or whatever, you can just tooltip it. The answer to your question will magically appear. I think that convenience functions are a good thing. If you do the exact same shit more than once, put it in a function. https://en.wikipedia.org/wiki/Don%27t_repeat_yourself
Might want to add riotjs to the list.
I too found this. And it is not at all what I was looking for. This is how to add an app that is already available on facebook, something you'd have to be brain dead to not figure out how to do. But thanks anyways. I'm glad you took the time to read both my question and your link.
I'm not seeking work, just a point in the right direction or something. Or knowledge that this is something you actually need to pay someone to do. I'm not familiar with facebook or java script. I just need a little guidance.
Hmmmmmmmkay. 
Yes, that typedef is pointless, but that "qsa" function isn't. Writing "[].slice.call(document.querySelectorAll('.foo'))" or "[].forEach.call(document.querySelectorAll('.foo'), function(e){...});" is annoying as fuck. It's also error-prone and fairly cryptic. &gt; The problem is that your code is a single line, it doesn't make sense to make that into a function So is that interpolateCatmull function. It's a single statement. About half of the common easing functions are also one-liners: t * t t * t * t t * t * t * t t * t * t * t * t t * (2 - t) t &lt; 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t t &lt; 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; -1 * (Math.sqrt(1 - t * t) - 1) All of those are super easy, right? Do you know which one is which? Which of these snippets is easier to understand and easier to modify? // A var v = easing.inOutQuad(elapsed / duration); // B var t = elapsed / duration; var v = t &lt; 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; &gt; do you think "(i+1)%2" should become a function? Dart has things like int.isEven, int.isOdd, Iterable.first, Iterable.last, Iterable.isEmpty, and Iterable.isNotEmpty. print(5.isOdd); // true print(['a', 'b'].last); // b It's very convenient. It makes for very readable code. &gt; So neither does your conversion to Array. My function runs QSA and returns the result as array. It does not convert an array-like to array as [Array.from](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from) does. &gt; About being stoned, I will just pretend you didn't type that. I said it like that because I do assume that you are able to infer what that function does. You are usually able to put 1 and 1 together, right?
Vuejs is pretty cool as well. I've used it now and again.
I must admit that I have zero knowledge of riotJS. A quick look over the docs makes it look very interesting and it's size means that I might be looking at a good ultra-light framework (I know it's somewhat niche, but some existing projects really benefit from a very lightweight framework that can be slipped into the existing code and deal with the hard problems).
Calling slice with "call" like you did will convert your array like object, node list, to an array. If you insist on using an Array, but think that converting to an array is too ugly, let me show a different way. Array.apply(Array, document.querySelectorAll(".smile")) Also, there is nothing wrong with the object returned by querySelectorAll. Yes, it does not have forEach, but that is not the end of the world. I will do you a favor and just ignore your last question.
So how will we do this?
&gt; Calling slice with "call" like you did will convert your array like object, node list, to an array. The point was that this utility function does two things. You described it as "conversion to Array" which is factually wrong. Again, it "runs QSA and returns the result as array". That's what that function does. &gt; a different way That one is even longer (even if you replace the second "Array" with "[]"). What's the point? ES6: [...document.querySelectorAll('.md')] Array.from(document.querySelectorAll('.md')) DOM4 (proposed): document.queryAll('.md') Dart: querySelectorAll('.md') &gt; there is nothing wrong with the object returned by querySelectorAll. Yes, it does not have forEach Yes, there is nothing wrong with array-like objects except that they aren't arrays. That's what makes them inconvenient to use. That's why DOM4 will fix this. Everyone hates that shit.
Is there a good way to enable it en masse across an organization's repositories? Frequently when I sit down to write little things like this, it's to effect a change across our entire workflow, and I can see needing to enable it repository by repository getting a little onerous. That being said, if you think this is a good target for an Add-On, I'll definitely take a look at porting it over!
With what semantics, precisely? The return value of a function is a single value, while the parameter list for a function is a list of values―they don't exactly line up.
 &gt; Math . atan2 . length 2 Super easy. Right.
maybe we could nominate someone to take it over?
Explain?
See above.
Right now, with ES6, the idea is to use Promises for managing async operations. If you want to get tricky with Promises with Generator functions, you can use yield to merge your would-be async handlers into synchronous looking code. [Task.js](http://taskjs.org/), for example, is a library that helps facilitate this. But if you're already using babel/traceur for ES6 support, you might as well utilize the ES7 async/await features that do this a little more naturally - effectively doing what the promise+generator trickery does, but without needing a spawner like task.js. If you're interested more about the meat and bones of the promise+generator approach, this article goes into some depth about it: http://davidwalsh.name/async-generators
Interesting go at it.
Use the Fetch API and/or a polyfill.
To account for wonky valueOf assignments? Seems like a stretch.
the Addition operator is overloaded, this really isn't any different.
Note that now with spdy and http2 browsers making a single js file is actually an anti pattern. An update to one file means it can't be cached. Mobile parsers have to parse and load a bigger file. You end up serving uneeded js. Same with sprite maps.
I REALLY wish more devs understood this simple truth.
Indeed so - right at the beginning of the function.
 function compose(f, g) { return (...x) =&gt; f(...[].concat(g(...x))); }
you might want to listen to the `input` event to handle your validation. This will let you validate whenever your inputs change so you can accurately know when to enable or disable your submit button. Here's a simple example: http://jsfiddle.net/32pvuae9/
What browser are you using to test this in? Sounds like you might be missing some debugging knowledge - hopefully I can set you down a path to help you in that respect...
Everything is equally terrible, embrace the badness.
I think you're referring to the ES6 pattern used to simulate the 'async' functions in ES7 proposal. You might want to take a look at http://jakearchibald.com/2014/es7-async-functions/
So does this explanation.
but is it better than php?
Wow you helped more than you think. I never thought of linking my jsfiddle hahaha. Thanks!
I have, appreciate the link! I am more curious if node.js and keeping an open connection is the way I have to go. If node.js is the only way I can start looking more into that. Thanks!
You clearly haven't been writing SPAs that much. The number one thing you need even for the simplest things is proper modules. That means browserify/webpack/JSPM, that is what you should mention before jquery. Then you can start thinking about an abstraction for DOM traversal/manipulation.
Disagree, answer will always be a subjective, so there is no need to know what kind of app is he building. It wouldn't hurt, but most people would use their favourite framework for any kind of SPA.
FWIW, returning false is non-standard and may or may not work for addEventListener. The intended approach would be `e.preventDefault()`. jQuery, however, does support its own implementation of capturing event handler returns and translates returning false to `e.preventDefault()` and `e.stopPropagation()`
Why? Zepto is like 9kb in production.
It's not really clear what you are trying to achieve... It sounds like you are trying to have some kind of interactive facebook widget, in which case you almost certainly need a developer/consultant. 
That's cool, good work. Ignore the comments were people ask why and link to some existing option. People seem to forget that folk program for fun/learning/experience/challenge. 6kb is impressive.
I think I've written that exact code many times over. :)
Thanks for the info I will start looking into node.js!