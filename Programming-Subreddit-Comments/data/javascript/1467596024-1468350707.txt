Look at all the es6 syntax in the examples on that link! /sarcasm
I have been using it for a few months now on an ecommerce site I work on. It's amazing for JS/ES2016. I mean it won't really help you on the CSS/HTML/Image front like Webpack might but it's way better than Webpack IMO for JS. The Sysgem.js bundler is very handy and easy to use.
HA! This is so fucking cool
&gt; When using const, use CAPITAL_CASING. I'm not sure where the author has come up with such a *novel* idea. From a brief google their article is the only thing on the web suggesting this. Also their example of arrow functions is bizarre, why on earth are they using a let declaration or console.log inside a map without a return? let arr = ['apple', 'banana', 'orange']; let breakfast = arr.map( fruit =&gt; { console.log(fruit + 's'); } ); // apples bananas oranges 
Wouldn't you still want to use it in development to get hot code swapping? And you'd probably want _some_ build step to at least minify those individual files you're transmitting. Webpack has a bunch of other useful things like loaders which pull in styles, JSON files, etc. I'm sure these arguments could be made for any other compiler/packager as well.
I'm going to deploy my JavaScript project files into desktop app(uses CommonJS-style modules and bundles them with WebPack). Which do I want to use NW.js or Electron?
Well, we are talking about JavaScript. Most of the patterns are still valid with the same characteristics.
From someone that used Compass for years: stop using Compass. Just use prefix-free and roll your own functions/mixins as needed. Might not apply to you but my CSS feels way cleaner and less abstracted without it
Why is it a novel idea? Just about every single other language uses the same naming style for constants.
There are still a lot of compass functionalities that I like though. \*looks at the compass imports in his last project\* "Let's see, *reset, sticky-footer, link-color, clearfix and appearance*" Ok you're right, it's kind of pointless at this point, I already stopped using Compass for prefixes though.
This kind of stuff is cool and great and useful, but honestly as far as the description of "easy" goes, I just don't think this qualifies. Once you get deep enough into your webpack configs abstraction becomes very useful, but honestly if you're just trying to learn how it works or even put together a simple/easy build, I just don't think it's necessary to have something like a 51-line typescript file just to compile sass files. I think this is part of the problem as far as the barrier to entry is concerned. 
[Here you go](https://github.com/Erkaman/gl-water2d)
My preference for CSS development is using the Stylus preprocessor (which works great with Webpack), so I haven't had a lot of experience using Webpack with SASS and Compass. However, I did some reading, and maybe this will help? http://browniefed.com/blog/webpack-and-compass/
All the major tech companies all have a piece of pie: * Google - V8 * Microsoft - Node * Samsung - Node * IBM - Express, etc * Apple - Webkit etc It is highly unlikely one would turn on all the others, as they will get gang upon. Even if they do, the pieces are highly replaceable. For example, if Node wants to move away from V8, it could probably migrate in a few month to either Spidermonkey or Chakra (Node.js forks of both backend exist as proof of concept) 
I've a problem with the capitals too. const in js just mean you can't charge the reference. If I remember C correctly you could captialise const variables only when they were primitives that would never change 
Interesting point of view!! Even now, webpack 2 will also come with chunk splitting features that allow for level 4 caching support for http2. I think that even with HTTP there are a lot of modules that have many deps and those deps have lots of deps too. It's not truly proven to be the end all to bundling. It sounds like you have a lot of experience in the area. Maybe instead you could help provide some expertise on features that might elevate the product.
Typically when you are using webpack you are only requiring the code needed for one page. Also it supports asnyc loading via `require.ensure` or `System.import`. Soyou can make it as lazy as you need.
If you're supporting IE8, it might be worth it. Otherwise, if you're just learning, stay with straight JS. Don't even look back! And then, later on, just bother with jQuery if you have some complicated stuff, and just need something easier to use for AJAX and select other utils.
Just know that gulp/grunt have no understanding of loading or bundling modules. All they can do is concatenate and glob. So you get duplication, bloated code, etc. Webpack, and Module Loaders handle these things out of the box.
It's best to know both, then use whichever feels natural in each situation. JQuery has a lot of utility even today with many plugins and features. But! you don't always have it or want it around. 
This is not a novel idea. Constants have been defined with CAPTIAL_CASE for ages in most languages. Though constants in javascript aren't full constants (since object properties can still be mutated) so this a bit debatable 
Cause ES7 literally just added 2 things to the Javascript language and while cool, there isn't really much to write about: http://www.2ality.com/2016/01/ecmascript-2016.html
Browserify is a bundler. Webpack is a build system. Browserify and HTTP2 do not even begin to address the issues that Webpack solves. The confusion is probably Webpacks own fault for allowing the current webpage and documentation to pass.
In your mind, what would a Webpack GUI Tool look like?
With ES6 it's okay to love it for what it is. No need to hide anymore
I certainly agree with you. Im using webpack in a react-redux project for 8 months and I gained a lot of xp, but I still use http://webpackbin.com very often. 
For me, it's that it's still not really clear for me what the advantages of JSPM are...
Your post will be a huge hit on /r/java 
You point it to your entry file, define a couple of loaders (minify, auto-prefix, JSX, Sass, whatever you need). And then you just code without having to worry about buildsystems or running behind your code to correct includes and version stamps. Webpack is aware of your projects structure through AST and everything that's in node_modules by default. Your dependencies are declared in package.json, and not in your HTML markup. Need a polyfill, UI component, etc.? Npm-install it and use it just like that. It shakes off unused dependencies. Take a (es6) module that has a hundred functions of which you need one, then that one is what you get. Uglyfy has dead code elimination but very limited as it can't remove from IIFE's or modules. Webpack will split bundles and distribute common chunks when several pages share the same code. It has a dev server with module hot reload inbuilt. You can edit your app live, which retains its state while changing only the components or modules that you edited.
Browserify is a tool in a chain of tools. If you use it as such, it works great. The configs become increasingly verbose if you go beyond its scope as it is over its good wits fast. In theory [it can do some parts that Webpack does](https://gist.github.com/substack/68f8d502be42d5cd4942), but to get there isn't easy as you're basically coding and cli'ing around things that Webpack does right out of the box. Browserify emerged out of the require era. Webpack was the logical next step as they focussed on all the issues that came with requiring.
Don't waste your energy. He has invested a complete weekend to tell everyone in this thread that webpack is unnessessary because "HTTP2 and cache busting".
Thanks for pointing out the mistake in the arrow function example. Fixed it. :) Also, capital casing is more of a preference. People from coming from C/C++/C# tend to use capital casing for constants. At the end of the day, your codebase, your rules.
I saw an article written by one of the node.js community leaders (mikeal maybe?) that was suggesting http2 isn't going to be useful because we're still going to be dependent on tools like babel for a long time to come. And it wasn't wrong, babel probably isn't going anywhere. 
I was being a little over the top and unnecessarily confrontational in that sentence. Whilst constants in other languages use that naming style, js consts are not that similar in behaviour. And pretty much no major projects or style guides recommend an UPPER_CASE naming scheme. It just doesn't seem sensible to suggest a convention which nobody is using in a guide for newcomers to es6.
As I [replied below](https://www.reddit.com/r/javascript/comments/4r2nno/es6_for_humans_a_kickstarter_guide_to_writing_es6/d4yloz6) I was being unnecessarily dramatic in that comment. Hadn't had my morning coffee yet, but that's no real excuse. My point was that presenting CAPITAL_CASING for consts as an established practice in javascript is really misleading when no major frameworks or styleguides suggest/use it. also you're still using an array.map in that example with a console.log arr.map( fruit =&gt; { console.log(fruit + 's'); } ); // apples bananas oranges if you insist on using a map operation it would be good if it made sense arr.map( fruit =&gt; { return fruit + 's'; } ); console.log(arr) // ["apples", "bananas", "oranges"] 
ES6 and compile to ES5. Essentially it's like having 2 different branches in git.
&gt; Not that impressed by the 4 years worth of changes... That is not 4 years worth of changes because the project was inactive for years and just now started to move slowly, entirely through community effort. &gt; There is always Reveal Which does not support 3D and doesn't have the liberty impress.js gives you: http://impress.github.io/impress.js/. Besides, it is owned by a corporation.
But that would mean the library grows in twice the size..
trolls everywhere... your time has passed pal ;) 
Hey thanks. In other way, I think devs might find this helpful if their customers are asked for console error info as its detailed. Think of a scenario where customers website is broken and you need to know whether something is wrong on their end as far as js is concerned, you might get some pretty specific info from him. As far as roadmap goes, am thinking to add another link where devs can link their support forms so that users can file bugs and the data will be passed as get params, other is the on screen modal as I already mentioned. Rest I'll think what I can make the most out of it.
Hi! This answer explains a way to do it for Android, as I think there's no way to make it work on all platforms (PC, Android, iOS, ...) with just one app. 1) Check both [Cordova](https://cordova.apache.org/) and [Ionic](http://ionicframework.com/), that are two frameworks that allow you to build mobile apps with HTML/Javascript/CSS languages only. All the building process and the app generation is made by the framework itself. 2) Each framework has its own documentation to guide you along the process. 3) It depends. If you just already have a website and want to "transform" it to a mobile app, then Android webviews might help you (they are just like HTML iframes but placed inside an Android app). If you want to provide more functions instead (such as menus, or use phone sensors or location) then you might want to use the above frameworks to simplify the coding. I hope this can help you!
For building desktop applications using web tech you can check out https://github.com/electron/electron and https://github.com/nwjs/nw.js/ Those are the main 2 I know of.
I was already looking for a book to order, but this ES6 summary is really great. Read through the first 5 chapters and I'm already lightened by a lot. I never did really understand the ... Operator until now. Two easy examples explaining the spread and rest, like a no brainer. Thank you very much! 
Sure, or something similar. How would you go about it? Not writing the same thing twice and produce the same result? 
As i mention above, no toggle.
If you just want easier dom manipulation on top of your vanillajs app, then you could always just include sizzle (the selector engine, not the dating app).
Since you're just switching between two states, just use JQuery's built-in abstraction for this sort of thing called toggle: http://api.jquery.com/toggle/ $("#clickme").click(function() { $(".menu").toggle(); });
&gt; $("#clickme").click(function() { &gt; $(".menu").css("display", "none"); &gt; }); Exactly like that, thank you so much!!
You can check out react native and react native desktop. They take a different approach than Cordova and the like. Instead of using WebViews, they use native UI elements. 
I can recommend [WebdriverIO](http://webdriver.io/), [here's a good intro](https://medium.com/@boriscoder/setting-up-selenium-tests-with-webdriver-io-cc7fc3c86629#.5srixro77). 
Uh, ok. If you know anything about how babel plugins come around, then you'll know that babel is still useful. Do browsers support async/await yet? No? That's a good reason to use babel still. Babel will always be ahead of browsers. Maybe you're one of those kiddies who makes assumptions about other people and their work, though.
so the upshot of this is don't use console.log because it's disrespectful, use some other console methods instead which are somehow less disrespectful? why is using console.log so much worse than using console.dir? i can see why `debug` and `monitor` are actual alternatives because you use them at run time and they don't change your code, but what if you're trying to debug something that executes as soon as the page loads? what if you want to see the value of a variable computed within a function body rather than passed directly into a function? also, this isn't 'beyond' javacsript console debugging tricks, this is just a brief introduction of the writer claiming that they're superior to their colleagues who use console.log, and then goes on to outline a few standard console debugging tricks using other console methods.
Isn't it better for beginners to use something that abstracts/wraps webpack and gives you an opinionated set of choices - I suspect there are yeoman project templates that come setup with a build process. 
This is weird. People can forget to remove those as well, which was his major rant with console.log and debugger... funny guy
Actually, when you drink it more, you'll get more confused.
I know I get downvoted for this because of /r/javascript, but toggling something can be done with a simple HTML checkbox and a few lines of CSS.
The author isn't saying it's disrespectful to *use* `console.log`, just that leaving it in the code is disrespectful. The other functions are not provided as better things to leave in the code, they are provided as alternatives to avoid needing to edit the code whilst debugging. As for your other points about when it might be useful to edit the code, I'd have thought that setting breakpoints would solve those problems. That being said, I don't see a huge problem with editing the code. If I came across a `console.*` I'd check git, chat with the person who added it, and then likely remove it. Regardless, the article is useful for enumerating these alternatives to plain old `console.log`.
i see your and his point, but he also says he hasn't used a console.log in years, and has "seen the light" about not using it, but somehow not the other commands? and also why is console.dir or console.time or whatever easier to remove from your code after testing? also, he says setting a breakpoint (for eaxmple, using `debugger`) causes all hell to break loose, so i don't think he'd recommend doing that. he also doesn't provide alternatives to using `debugger`, and if he had he would have had to acknowledge that these too have their advantages and disadvantages. also also, setting break points is no better or worse than using console.log really. sure, break points let you poke around more freely after the fact, but if anything, using a break point is more risky, because it literally breaks the code if you do forget to remove it, whereas you can use a shim to avoid breaking the code if console.log is unsupported by a certain browser.
As I commented below, I believe these are to be used in the console, not to be left in the code, hence the title that was used (that specifically notes they're *console* debugging tricks). edit: the screenshots clearly show him using the console, too ;)
how will you debug anything that is not in global scope in this case?
I've been writing my libraries in ES2015 and building a UMD version with Rollup. The package's `main` points to the UMD form and `jsnext:main` points to the ES2015 entry point. Basically, [I've been following this](https://github.com/rollup/rollup/wiki/jsnext:main).
&gt;JavaScript specializations Once you're good at JS you can do any of these things. It's just a matter of reading some docs and learning the library/framework you're using. My advice is just to learn all of it by building an app you would find interesting.
Not enough jQuery.
[There is never "not enough jQuery"](http://youmightnotneedjquery.com/)
Holy fuck, do programmers have no sense of humor? I was obviously joking around hence the :P Go fuck yourselves.
Exactly
It's just not just about the user though, the developer DOES have to download twice the size of the library. And again, wouldn't the ES5 library also get included AUTOMATICALLY during compilation even if you use the ES6 part of the library?
Lot of money in what I call "UI Engineering" right now, especially with cross platform technologies. There are a lot more people self describing as full stack right now, but not many who claim to have that same breadth on the client side 
&gt; I use webpack on Linux it's stupid easy. Said for the first time ever.
You could, if you wanted. Personally, I would just make the http call from the browser context (as in, use main to launch a window with index.html, then index.html would contain js - preferably still a module, not just inline on the page - which would make the http call). You could technically have main do it, but then you'd probably have to start digging into [IPC](https://github.com/electron/electron/blob/master/docs/api/ipc-main.md). Which is great for some things (like cross-window communication), but not really necessary in this context.
yes
so you're only supposed to debug your code when its in a static state? im sorry but that's just dumb. also they could be called *console* debugging tricks because they use the browser console and the console object. calling them a console debugging trick definitely doesn't imply that you access them directly from the console and nowhere else.
well, you will want to attach an event listener to the submit button for the form, preventdefault on the submit event, and then update the html based on the data in the form. something like this would be in the onsubmit or onclick handler: function formSubmitted(e){ e.preventDefault(); var newText = document.getElementById("Id of input element to get new value from").value document.getElementById("Id Of Element To Update").innerText = newText } 
`return false;` is for old-school event-handler properties, though it might still work for event listeners; `evt.preventDefault();` (assuming the event object is stored in a variable called `evt`) is recommended for event listeners, because in particular it does not also stop propagation, while `return false;` does.
Pfff this 'for humans' title nonsense is ridiculous. Like the other guides aren't written for humans? Also when the robot uprising finally comes you people are going to get zapped first.
[overcommit](https://github.com/brigade/overcommit) makes this super simple.
If you are talking strictly freelance, it's all in your portfolio and more importantly your hustle. You could be the best js developer ever but if you have no ability to sell yourself it all amounts to nothing.. Conversely I've seen people who barely know HTML consistently finding freelance work, because they can sell themselves.
You can use Libreoffice on the command line to convert it to a PDF file and then there are a lot of tools.
I could spend way too much time talking about this... Things are too interdependent and too inconsistent. For instance, Hot Module Replacement requires configuring and starting a dev server, adding two libraries to each bundle pointing at that dev server, and adding a plugin. I want to turn on 1 feature, and I have to know to do 4 different things. As another example, if you want to export your bundles into two separate folders (perhaps a `dist` and an `examples`), you need to make two different Webpack `config`s and pass them in a list. `webpack` CLI can parse a list, but `WebpackDevServer` can't; so, now you have to do even more fiddling to reduce them back into a single config for the Dev Server, but pass them as a list to the CLI. That doesn't even get into `context`, `resolveLoader.root`, `output.path`, and `output.publicPath`. Webpack has too many secret knobs. Of course, documenting the knobs helps, but I shouldn't have to tweak 4 separate things just-so to use your flagship feature, or completely reformat my config depending on whether or not I'm running the server. I think if you look at the things Webpack enables and completely forget the current API, you can come up with a lot more ergonomic paths to do the same thing. Webpack is a fantastic tool, but of all the ones I've used, it's also the most difficult to configure.
Let's write our own `forEach` function: function forEach (someFunction, someArray) { for (var i = 0; i &lt; someArray.length; i++) { someFunction(someArray[i], i) } } To use this function I could write: forEach(function (item, index) { console.log(item, index) }, ['foo', 'bar', 'baz']) That would output on the console: // foo, 0 // bar, 1 // baz, 2 Let's "outline" our function and our array: function logStuff (item, index) { console.log(item, index) } var arrayOfStuff = [ 'foo', 'bar', 'baz' ] forEach(logStuff, arrayOfStuff) And we get the same result. JavaScript's Array `forEach` method is basically the same but it applies that function you pass in to the array you called `forEach` on instead of having to pass in the array as an argument like we have done above.
There are so many of these articles now.. Also 0.o: &gt; A function with no parameters requires parentheses or an underscore: No more local lodash! =p 
1) What I wrote was the complete code of my example. 2) They come from here: function forEach (someFunction, someArray) { for (var i = 0; i &lt; someArray.length; i++) { someFunction(someArray[i], i) &lt;--- someArray[i] is item and i is index } } 3) that's the body of a function.. that's the stuff that actually executes when you call a function function foo () { // when you call this function with foo() // the stuff in between these curly braces will run } I'm guessing the part you are having a hard time with is understanding that functions can be passed around as arguments to other functions. Here's a simpler example: function foo (anotherFunction) { anotherFunction('world') // call the function } foo(function (aString) { console.log('Hello ' + aString) }) // outputs 'Hello world' Or 'outlined' again: function foo (anotherFunction) { anotherFunction('world') } function logHelloAndSomethingElse (aString) { console.log('Hello ' + aString) } foo(logHelloAndSomethingElse) // outputs 'Hello world' 
I seem to remember doing something like that with google docs at one point. Been a while tho.
That will be nice, I def don't think we should jump there with 2. I don't think we're fully ready to play this http2 game fully. Its still got some growing (gain in usage share) to do before tooling should support it by default.
Protip: Search on GitHub and filter by language. Have a look here and see if any of these will do the trick: https://github.com/search?l=JavaScript&amp;q=docx&amp;type=Repositories&amp;utf8=%E2%9C%93
Writing for Medium in a nutshell :)
Awesome tip, I took it one step further and filtered by date to get up to date projects. I haven't found the silver bullet yet but there's lots on there.
If you use Chrome, you can use [this extension](https://chrome.google.com/webstore/detail/office-editing-for-docs-s/gbkeegbaiigmenfmjfclcdgdpimamgkj?hl=en). It works about 90% of the time for me.
It's not broken. Just learn how it works and use it properly. I've never in my more than ten years of experience thought that it's broken. 
Well even people like Douglas Crockford say `typeof` has problems. http://javascript.crockford.com/remedial.html
Couldn't the library just be published into 2 different libraries? One with the ES6 code and one with the compiled ES5 code?
Our grunt dist command removes all calls to console. There. Done. Way faster to implement than writing this article. 
It has 'problems' , or maybe behaviour other than we expect, but it is not broken. You can always use library like 'is.JS' if it's problem for you. There is no replacement as is. 
`typeof` does runtime type validation/differentiation. There are number of solutions: * Stop writing code that allow for ambiguously typed arguments/variables. ~~If the function expects a string, just cast the argument into a string immediately without caring what the content is.~~ * utility library that checks for exactly what you are looking for e.g. `lodash.isFinite()` * write your own runtime type checker utility with domain specific names e.g. `isOrange(fruit)` * Use TypeScript/Flow to provide compile time type check to remove ambiguity in your own code (this doesn't really solve the issue if 3rd party code gives ambiguous type) 
&gt; Stop writing code that allow for ambiguously typed arguments/variables. If the function expects a string, just cast the argument into a string immediately without caring what the content is. Doesn't this just make errors hard to find? Aren't there situations where typecasting to the expected type results in silent errors? 
I haven't updated it in a while, since it really doesn't need much updating but check [this](https://github.com/eorroe/nodelist.js) out
Thank you /r/javascript for not disappointing me with your response to this article. Pointed out as a bad article, good reasons given for why it's inconsistent. And even a plethora of better solutions! I'm proud of you, /r/javascript =)
1) Its apples and oranges. Microsoft products have certain strengths. However in recent survey's &amp; job posting audits indicate ASP.net is in decline. ASP.net has a different stack of security concerns than other languages. ASP.net also requires a fair bit of knowledge to setup and honestly I've found node far more straight forward to setup. But you can't compare the two. One is a Microsoft product and benefits/suffers from that ecosystem &amp; the exact same could be said of nodejs. However comparing a frontend framework to a backend is a very awkward comparison 2) Clients will generally buy what you can sell them on. If you are freelancing their #1 concern should be how they'll update the project in the future. You should be picking a language that will have support for the foreseeable future (don't give them Pearl/CGI based website) 3) Let your career evolve. You will be best served to work on your strengths unless the market where you are has a strong leaning towards a certain language. A smart employer will look at your flexibility as an asset. However if your experience is a little thin you might be better served learning models &amp; methods (more methodology stuff aka every language has MVC) as those overlap despite the languages. 4) JavaScript (ES5) isn't a very straight forward language. How you make an OOP class isn't 'verbose' (clearly indicated by the words the language uses) and there are more than 1 way to extend a class. Scoping can be confusing. Async is confusing. Non-blocking is confusing. Graphical Programming is challenging (when doing animations and lots of dynamic values). JS/Node doesn't HAVE to be functional... it just benefits from thinking of that model. When I code node I work in OOP; but focus on returning binded functions. I think as more people adopt nodejs a clearly sense in how to code with it will come forward. Already there is drum beating for event base programming. 5) I don't know but hear they don't run as well as native. [EDIT] As someone with 5+ years of ES5-type experience and 2 years of 'dabble' experience in C#; at this point I think nodejs &amp; js has more legs than c#/asp.net. If you really want to get into games/mods/phone-apps C# is a good way to go. But part of what makes JS so interesting is its adoption as a middleware (phone-apps language such as [FOAM](https://github.com/foam-framework/foam)), async focus and low bar of entry makes it a far more likely future than C#. However C# can always be updated with the same features (much like how Java has evolved). C# also gets your head into the Java/Android space. So don't discount that either. 
If you want to avoid libraries then one alternative is "Object.prototype.toString". It has clearly defined behaviour for all native objects.
[removed]
This "article" is literally a paraphrase of the [console API](https://developer.chrome.com/devtools/docs/console-api)
Please don't use "clever" tricks like these in your code. They make it harder for everyone (including yourself a week from now) to read.
"shorthand" as in "what the fuck does that mean?"
Something cool I built: the bot that powers my subreddit, /r/AskOuija: https://github.com/mattdiamond/ouijabot/blob/master/ouija.js It's a node script that I've scheduled to run every hour, checking the last 100 hot posts. It looks for potential Ouija sequences and flairs threads that contain a sequence meeting a specific threshold. You can learn more about the purpose of this bot by visiting /r/AskOuija and seeing it in action. I liked playing around with `Function.prototype.if` even though it only had a single use.
I'm not a fan of obfuscation. but several shorthand notations are extremely useful in making code more readable. a = a + 1; vs a++; it's a matter of fluency. I'd expect some of the style guides to cover this topic. having a quick look at this to see if they address this issue. https://github.com/airbnb/javascript
&gt; (4.4657 | 0) === 4 (4.4657 | 1) === 5
Bcaus
You got it :D
[String.prototype.includes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes) has been standardized and can be polyfilled in circumstances where it's not available. I've used the above before but I'd argue its time has come and gone.
I'm sick of people who constantly think they're better than everyone else in their team. Even the header image's caption is an example of that.
if(you are me) else(you have no idea)
Actually, I like to do something like `param || (param = defaultValue);` for default arguments.
Try it yourself: https://doclets.io Your feedback is very welcomed!
just found this little gem. raygun. An error tracking platform for javaScript. Let me know what do you think ? 
These are few of my favorite ones: __Coerce anything to boolean:__ Sometimes you want something in boolean. I like to use `!!x` shorthand instead of `x ? true : false` __Coerce anything to number:__ Use the unary `+` operator, same as the OP: `+something`. I think the above two shorthands are quite handy and are readable by average JavaScripters. I don’t use other shorthands (such as `~~`, `| 0`). Not even converting things to string (`''+`). I use `String(text)` instead. __Reduce mutations using arrow functions:__ By using `const` more in your code it makes your code look more like a mathematical expression. If I say `const x = 5` and I can be sure that it always have the same value throughout the scope. I found arrow functions to be very useful in this case: // Before: width and height initially have undefined values and gets overwritten some time later. let width, height if (originalWidth &gt; originalHeight) { width = maxSize height = maxSize * originalHeight / originalWidth } else { height = maxSize width = maxSize * originalWidth / originalHeight } // After: const [ width, height ] = (() =&gt; { if (originalWidth &gt; originalHeight) { return [ maxSize, maxSize * originalHeight / originalWidth ] } else { return [ maxSize * originalWidth / originalHeight, maxSize ] } })() 
Shorthand is great when used appropriately. However, obfuscated coercion is a terrible idea most of the time.
That's absolutely beautiful! I always wanted JSDoc pages to be as beautiful as TypeDoc-generated pages, and this project even comes with CI. Great work, I'll definitely try using it.
It’s great that you stated that you’re familiar C#, so I can tell you that it’s similar to a delegate. public delegate void ForEachIntDelegate(int number, int index, int[] arr); Then you can think as if `numbers.forEach(myFunction)` accepts a `ForEachIntDelegate`. In C#-speak, you can send a method A to another method B, and have that method B call the method A that you sent. In this case, `myFunction` is the delegate.
oh I get your point. for readability it should be written as Math.floor(4.4657) === 4 but I think there are other shorthand notations which fall into the 'acceptable to use because everyone recognises them'. NB: I generally prefer verboseness for readability. 
Ah okay, fair enough. But I imagine this will be less of a problem as the platform matures.
Thanks a lot! Hope doclets.io will be useful and fun for you.
It's tongue-in-cheek, that's how I read it. The author's been gracious enough in the Medium comments, he even mentions the target audience are people who don't know Console API, so... zee noobs. He mentions Performance API (+ memory leaks, modules and patterns) as his next article, so I'd say this is a series of articles, starting from simple, and growing in complexity. BTW, I'd even say that "Beyond" is wordplay, also tongue-in-cheek, 'cos he definitely seems to know it's beginner stuff.
 function findMax(arr) { return arr.reduce(function(max, num) { return max &gt; num ? max : num; }, 0); } var max = findMax([1,2,3]);
This isn't bad but I have yet to find anything that comes close to [Professor Frisby's Mostly Adequate Guide to Functional Programming](https://drboolean.gitbooks.io/mostly-adequate-guide/content/). Really made the concepts click for me, and of course all in JavaScript.
jamonterrel, leave him a comment there, man. He doesn't seem to be on reddit, otherwise he might have commented here, already. He doesn't seem to be against any kind of feedback, he has engaged in conversation there. I commented elsewhere that the whole thing has a tongue-in-cheek tone, and was written with noobs in mind. I don't even qualify as a JavaScript noob, but I might actually be more inclined to have full logs that I could grep, sed and/or awk. The kind of logs I parse are altogether different, though. I have no idea whether this would be helpful for JavaScript. That's actually something I'm intrigued about.
&gt;~~slightly~~ *completely* off-topic FTFY. This is a question for /r/css. Don't forget to provide code when you want to have code support.
Seems like you are not using a heavy solution light Angular or React, so I'd recommend looking at [page.js](https://visionmedia.github.io/page.js/). It provides routing functionality and is light.
it's pretty cool :) Although it seems to understand only dependencies from package.json/node_modules. It would be nice if it showed internal dependencies also (I mean between files in one package ( for example when somebody writes require('../blah.js') it would be nice if `blah.js` was in the tree). 
We wrote a custom solution to create the hash information and it's been kind of a pain. I don't know of any off-the-shelf solution that would do exactly what we want, though, so... *shrug* Looking at Page.js, I have to say that it looks pretty nice. If I had to do it today, I'd probably try to make it work instead... And for any standard projects, it should be perfectly fine.
This is my first big JS project. I have been working on implementing a Canvas 2D game engine in JavaScript. The API is heavily inspired by Unity. For now, many of the base classes has been implemented. * **Sprite** - Can take an image, spritesheet etc. Will do automatically slicing, and pre calculation of sprite directions. * **ParticleSystem** - Create various effects, * **Input** - Mange input, for now only keyboard support. * **AudioClip** - An easy way to manage audio * **Text** 2D text object that can be manipulated like Sprite It also has basic types implemented, like: * Vector2 * Component * Color * Transform * Time (Time.deltaTime etc) And many more features. Check out this basic demo of the latest dev branch here: http://alrek.no/demos/jsgame/example/ And the API documentation here: http://alrek.no/demos/jsgame/doc/index.html It is released under the GNU GPL v2 license.
Why is CommonJS better? This is on the client, are you asking him to add a dependency into the code like Webpack?
It was a design decision. I wanted it to be quite similar to Unity. So the global objects can be considered almost like a type definition.
This question isn't totally clear. Check out child_process, specifically spawn() or exec(), which allow you to run an executable and gain access to its stdin, stdout and stderr as streams. If you're just looking at executing a short-run program with arguments, you can use exec() and concatenate the arguments right onto the executable path. HTH
CommonJS was an example. Even using a single global namespace to put all the objects on would be better. Polluting the global namespace isn't ideal IMO. Having global objects like Constructor, Color and Input objects isn't best practice.
&gt; but several shorthand notations are extremely useful in making code more readable. &gt; a = a + 1; vs a++; It is by far more preferable to instead use: a += 1; Not only does that work consistently regardless of whether you are assigning a new variable or not, it also results in less work when you need to change the increment from 1 to 2. Whereas with a++, you are only inviting other terrible code such as ++a instead. What happens when you end up with the following? var a = 3; return a++ + ++a; Are the spaces around those plus signs correct? How do we know that the code is working correctly? What is the value of a and what is the return value supposed to be? If we have a hard time just trying to understand the code, what hope do we ever have to debug it? It's far easier to understand and debug when the code is more consistent as follows: a = 3; var result = a; a += 2; return result + a; 
I normally agree. But this was a concious design decision. I wanted it to be similar to Unity, and these global classes should be considered a type definition, since they are primitives that are used all over the framework.
Pretty impressive considering its your first big project! I know mine wasn't nearly as glamorous. Keep at it!
I thought about that. The problem is that Windows will tolerate only a certain maximum size for stdin (256kb) at which everything after is cropped. I will need some other way of injecting a string into the child process. I could write the string to a file, but that would be very slow as I don't want to retain that file.
I'll be tinkering around with this, probably tonight. Thanks for open sourcing! The community loves you!
Am I the only who learned about `console.trace()` and friends from this article?
nice job mate!
Cool! Let me know if there is anything you need help with
This is for those (like me) that thought that Redux was an architecture proposal that reinvented known patterns of the 70's. Let's be real, though, there is no mention of any design pattern (Event Sourcing or FRP) that redux implements in any of the official mainstream most popular videos or docs (or at least none that I know of, if it does, please prove me wrong), [only tools and design patterns that it was based upon (none of them explicitly mentioning Event Sourcing)](https://github.com/reactjs/redux/tree/0d4315ffeaec6767dbae9114f9b90fd25d6c203c#thanks). If the author says it is not an architecture, it is not! This kind of thing confuses everyone, and mostly beginners that will believe that Redux is the one real architecture, which leads to not spending enough their times in researching fundamentals that were built decades ago in order to understand better the details of how to use it and how to improve it on a per application basis. But who cares if we keep the cycle of programmers that only know how to use a framework, so that when abstractions leak they have no idea of how to fix it, right? ¯\\\_(ツ)_\/¯
Just that javascript is becoming a middleware. Thanks to sockets and the speed of nodejs/V8 there isn't much it can't do. I think apple has language that compiles to Obj-C that is written in JS. Other languages are working on their own async versions of their languages to take advantage of multithreaded CPUs. Its also the only language that works multiplatform. By that I mean by using middleware (FOAM/Xiamen) you can have 1 codebase working multiplatform. Also the more trivial aspect that monitoring tools, analytic tools and automation is being written in JS a lot. However C# can come out with a new version and render my opinion invalid. I counted ASP out before .net was released and I was very wrong then. JS is different because its still very young. These frameworks are a sort of academic paper. They are ideas that get folded into the code base; or eventually rejected like mootools. However looking at the current JS space they had a few ideas that were ahead of their time. In the case of jQuery it eventually embarrassed the browser vendors into updating their APIs to standard. It also got us querySelectorAll because of it. The case of react/angular/vuejs is the expression of a theory of how to implement web components as a whole.
FWIW, JawsJS accomplishes this by exposing the Jaws.unpack() method. When called, it copies all of the top-level constructors/objects to the global namespace. This keeps the library portable and contained by default but still allows for the scenario that you've outlined.
How about a cup of :? const [ width, height ] = (() =&gt; (originalWidth &gt; originalHeight) ? [ maxSize, maxSize * originalHeight / originalWidth ] : [ maxSize * originalWidth / originalHeight, maxSize ] )(); Actually you don't even need function here: const [ width, height ] = (originalWidth &gt; originalHeight ? [ maxSize, maxSize * originalHeight / originalWidth ] : [ maxSize * originalWidth / originalHeight, maxSize ] );
Thanks for sharing! I just hooked up 2 of my company's public repos. Looks great. We were hosting our own previously via. jsdoc, but having a doc gen. solution with a CI is a great asset! Do you have plans for supporting private repositories? 
Dat flair though! 
Uh... if you look at the docs, the [Prior Art](http://redux.js.org/docs/introduction/PriorArt.html) page specifically says that Redux was heavily inspired by Flux, Elm, Baobab, Immutable.js, and Rx. That's a pretty solid list of relevant concepts. For that matter, the [Motivation](http://redux.js.org/docs/introduction/Motivation.html) page directly says "Following in the steps of Flux, CQRS, and Event Sourcing, Redux attempts to make state mutations predictable by imposing certain restrictions on how and when updates can happen". But no, other than that, absolutely _no_ mentions of what inspired Redux at all, obviously. Certainly also not any mentions in any of the issues, like [#229](https://github.com/reactjs/redux/issues/229) or [#351](https://github.com/reactjs/redux/issues/351), which are absolutely not findable with a trivial search in the Github repo. Or in any of the other posts, interviews, or talks that Dan has given. /s More seriously: conceptually, all Redux really is is a stored value, a function to update that value, and a single change emitter. Not much there to learn. Now, there are certainly patterns that grow up _around_ that, and idiomatic architecture when using things like Redux and React together, but Redux itself is pretty trivial (as evidenced by several articles that walk you through [building your own mini-Redux from scratch](https://github.com/markerikson/react-redux-links/blob/master/redux-tutorials.md#redux-implementation-walkthroughs) ). All that said, I'm really not sure what your problem is overall. You seem to have something of a grudge against Dan and Redux because you think he's passing off his work as some kind of breakthrough and encouraging people to use Redux instead of some formalized pattern, and that's pretty much the opposite of what's happened.
Redux is an implementation of Flux, yes? Flux is an architecture.
But that takes out all the fun! :P
I love the answer/rebuttal. Shows a sense of humor, compassion, and matter-of-factly answers the question all at the same time. Instead of slaying trolls, hug them, apparently :)
So this tool is awesome, but it really has some trouble doing a first search for me. I tried in both Firefox and Chrome. It seems the probably is in how it populates the address. If I manually write in the correct path I don't have any problems, for example: npm.anvaka.com/#/2d/vue At first I searched for `lodash`, `jslint`, and `prettydiff`. Fast but boring. Then I searched for `vue` and watching the 2d graph build is like watching what happens when rabbits fuck without limitation. Finally I searched for `eslint` and it was like watching bacteria multiply.
You can set your parser as 'babel-eslint' so that it won't fuss about es6 syntax.
A convention for implementation. 
&gt; When a package is very far removed from your app, nested deep in the dependency tree, it’s easy to not be aware of it or forget about it altogether. This is not entirely true. Npm recently changed their publishing policy so that `left-pad` fiascos cant happen anymore.
Well considering many of the popular frameworks coming out these days are written in different forms of JavaScript like Angular 2 with TypeScript and Aurelia in ES6 it is more a question of what are you willing to maintain. if you setup a nice build system then it should be minimal hassles. Transpile compatible code with babel and use something like rollup for modules throw in a few polyfills and bob's your uncle both the old gods and the new are satisfied with your code offering. I'd say a big factor in why I don't use ES6 modules yet is because there is no major browser support yet and using an instant transpilation tool on a massive project can be such a hassle thats why I try to write code compatible with the latest versions of Chrome and Firefox then just transpile to old code.
TL;DR: The author spent 2 days sticking "any" into definition files to satisfy a compiler that provided him nothing in return other than basic linting. I would be much more interested in your writeup about creating real TS types for all of your code and using them to refactor your 10k LOC into something more lean and mean. Then I would like to hear if your total time spent converting to TS was worth it.
At my company, we recently started rebuilding parts of our existing Marionette.js and Backbone.js SPA in React, Redux, Immutable.js, redux-promise, and a smattering of other packages. React is easy - components, props, and JSX. Redux itself is easy, and easy to scale and test. Using a package like [redux-actions](https://github.com/acdlite/redux-actions) removes a lot of boilerplate, which is nice. It's also easy to plug Immutable.js into the mix. What gets complex and *really* hard to manage is duplicate entities **and their relationships** in a redux store. Libraries like [normalizer](https://github.com/paularmstrong/normalizr) help aggregate and reduce entities in a store by using ID references where appropriate, and [reselect](https://github.com/reactjs/reselect) using memo-ized functions to read something out of the store efficiently. But using all this together with a standard (albeit well-documented and internally maintained) REST API gets crazy. Combining and managing two sets of entities in the store where they have a one-to-many relationship raises a lot of questions, simply "how the hell do we do this", and has resulted in some seriously messy spaghetti code, in my opinion. Throw something like [redux-saga](https://github.com/yelouafi/redux-saga) into the mix like we did recently and it's almost table-flipping time. We're slowly going through and refactoring what we have so that while we might not have a fully normalized store, we can at least read the code and easily do what we need to do with data before and after it gets merged into the store. My advice? Stick to React, Redux, Immutable.js, and a Promise-based HTTP redux library (like redux-promise), and that's it. Sagas are cool, normalizr is a neat idea, and reselect promises some big efficiency gains, but using all of them together is a recipe for headaches right now. Give these tools more time to mature and I think there'll be some better patterns come out of it. tl;dr; redux is awesome, just stick with it and only it and you'll enjoy it.
I haven't dealt with data visualization libraries too much, but D3.js seems to be the standard go-to.
I thought OP posted this, because he wanted to make fun of the issue author. Then I noticed the nicknames... 
Sorry for the late reply, but thanks for this little write-up. It actually motivated me to start my own personal project. I had this in the back of my head for a long time, but as with so many other things, it was one of these "one day I really should..."-things. You provided the necessary nudge to move it from *one day* to **now**. So, thanks!
Also, has anyone ever heard of code reviews? I mean Jesus.
The framework itself is mobile compatible, but I haven't yet implemented support for touch and mouse events in the Input class. It is coming though. For now it only handles keyboard events. I have some issues in Safari regarding CORS for the sprite object. I am currently trying to work around it.
Thanks! :)
Yes I use require calls, but the build script fetches all require statemens, and concatenates it in one file. Then it gets minified. 
Yes i know how it Works. Then you dont need to expose it in the global scope. If I, for instance, want to require specific parts of your code I'd like for them to use commonjs syntax, or something. Everything would them be resolved. And no junk in global scope. I get what you try to do, and I think this is one thing you should change to make it more JS. as with the update names... again, I think Pixi js has solved this pretty good, take a look at their module syntax. Works fine I n whatever way you expect it to
Awesome, best of luck with it. Hopefully it's a fun learning experience.
I don't have to know how to build, or have built a car, to know what makes a car comfortable to drive. Just sayin. These are not hecklers, more or less questioning design decisions and suggestions to make the engine better. Every description should be made by an thought. If someone asks "why do it like this?" And you don't have a good answer you f'ed up basically. Also you need to take criticism without taking things personally. Hecklers was a bad word to use imo.
That's plain stupid. Can't use "", 0 or false... `param = typeof param !== 'undefined' ? param : default` is miles better.
Nope. 7 sprites generated
You can completely skip the first 4 minutes.
It **of course** depends on the specific case, I don't use it blindly. But in cases where we need e.g. an object or an array, it's quite useful. 
Same here.
Same. In addition to airbnb, also added plugin:import/errors preset which warns on a few more things.
It would be technically possible (docx is a zip of xml and binaries, and there are JavaScript parsers for these) but DOCX is a XML-ised version of DOC which is a very quirky format that is near impossible to successfully implement. The rendering changes in different versions of Microsoft Office. LibreOffice have been trying for years to mimic the rendering, and any other JavaScript-only and open source codebase would inherently be immature and not as good. The advice to use LibreOffice on the server to make PDFs and render them with pdf.js is good.
Yeah, I was in a mood this morning. I take back the heckler thing, but I know what it is like to be op. Realeasing OSS yourself and having it heavily criticized is not a rewarding experience, and it makes people not want to contribute in the future. I just think that most complaints about open source software should be submitted in the form of a patch. 
I don't mind critisism, it only makes me better, as long as it's constructive. It can be hard to do a good design/implementation, this is already the third iteration of the project. If you have any other suggestions I would really appreciate if you add an issue on github, thanks! :)
I don't mind critisism, it only makes me better, as long as it's constructive. It can be hard to do a good design/implementation, this is already the third iteration of the project. If you have any other suggestions I would really appreciate if you add an issue on github, thanks! :)
If you're ok with not targeting some older browsers, the [History API] (https://developer.mozilla.org/en/docs/Web/API/History) might be what you're after.
No. Being recursive by itself does not involve any asynchronicity. A function is asynchronous if it performs an asynchronous action, otherwise it's synchronous. "Perform an asynchronous action" usually is not directly achievable by user code, so what that really means is "call a built-in function that is asynchronous." For example, if your function calls `setTimeout()`, then your function is asynchronous, since `setTimeout()` implements asynchronous behavior. If it doesn't, then it's not. There's nothing inherent about recursion that forces asynchronicity. Recursion after all is just a normal function call. If a recursive function was automatically asynchronous, then all functions would be asynchronous, and there would not exist synchronous functions, which is quite impossible. 
I will soon! I'm currently in the process of converting it all to native ES6 modules (about 50% complete) using Babel and WebPack. Here's the end goal: import { HumanInput } from "humaninput" import { Keyboard } from "humaninput-keyboard" ...or something like that. Still just working the basics and wrestling with WebPack.
What a great preview image, it makes him look like an orchestrator of ~~evil~~ `eval`.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/emberjs] [Ember.js \/ Ember-i18n - Is it possible to iterate over properties within a translation file from within a Handlebars template? : javascript](https://np.reddit.com/r/emberjs/comments/4rfgto/emberjs_emberi18n_is_it_possible_to_iterate_over/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Reminds me of [Fyre](http://fyre.navi.cx/about.shtml). Beautiful stuff.
If you wanna criticize go on, as long as I can learn something from it.
I didn't RTFM, just blog posts. I guess that is the problem on relying on newsletter for keeping up with all the new things that come up. I blame all the blogs that say "Redux Architecture" that you can find here: https://www.google.com.au/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#safe=off&amp;q=redux+architecture
Yeah, that's basically the complaint Dan made a couple weeks ago: https://twitter.com/dan_abramov/status/746408401291223040 People either write short tiny TodoMVC tutorials, or long complicated "set up your project with everything INCLUDING the kitchen sink" tutorials, and either way people seem to go read those instead of reading the actual project documentation (for both React and for Redux). I'm working on a new page for the Redux docs about best practices for structuring reducers. While writing yesterday, I noted that a good chunk of what I want to say is already in the [Reducers](http://redux.js.org/docs/basics/Reducers.html) and [Reducing Boilerplate](http://redux.js.org/docs/recipes/ReducingBoilerplate.html) doc pages, but people seem to not have read those thoroughly. People also seem to get confused by concepts that Redux uses but are not Redux-specific, like ES6 syntax and updating data immutably.
It's not an implementation of any architecture, it is just a library.
I'd say that what you described is actually a valid first step towards a progressive refactor. Make the app, as it is, compile using 'any' definition files. Then start working your way through, replacing 'any' with strict types, refactoring code when necessary. However, just doing the first step and calling it a day smacks of a job half-done.
We use saga, normalizr, and reselect where I work to great success (I am the one who constructed our current stack). What about it gives you trouble? For a Web application where you need precise http request control, saga is a godsend. We recently started embracing container design instead of trickling props through components which has given reselect brand new usefulness since this approach gives you more opportunities to memoize your data. Our client side app can currently handle thousands of events per second and is capable of storing hundreds of thousands of users data and editing it in real time without any lag at all. I couldn't be more pleased with it. (Our app handles messages coming from connected clients) That all being said, I'm not sold on immutable.js. Don't confuse this with immutability. We make heavy use of immutability, but lately we just prefer object.assign although I've heard ramda has really improved lately. 
&gt; People also seem to get confused by concepts that Redux uses but are not Redux-specific, like ES6 syntax and updating data immutably. Didn't know about that. Even through blog posts I can definitely separate them, but I am probably biased. The thing I see we need more is to be critic about blog posts and definitions used in the wild, that's much more important than just documenting the api of a library. People like me read blog posts because Redux is not the only thing that exists. I need to keep up with a lot and reading the whole docs of everything is a waste of time. Everybody knows that. I have even responded to that Twitter message you posted explaining that.
To follow this up, Dan also has some pretty good tutorials for redux on egghead.io for free. Both beginning and advanced. That being said, when I was learning react and redux I didn't reference the documentation because so much of it was over my head. Reading it now it all makes sense. I don't know if it's been updated since or if it's just my exposure to concepts over time but I suspect all the new terminology scares people off.
It means they don't know what they are talking about.
I love javascript. It's so easy to work with. I really don't understand the haters.
underscore/lodash also have some nice type-detection methods.
Doesn't work. :-(
:( Are you getting an error or just empty value?
Checkout PixiJS: http://www.pixijs.com/ and this benchmark: http://www.goodboydigital.com/pixijs/bunnymark/
I found the solution. It's called MammothJS. https://github.com/mwilliamson/mammoth.js You can install it as a NPM package in Node or standalone in the browser.
I see that, but what is the point of doing it if the function will work correctly if you just call process(node); The only functions that are calling traverse are size() toArray() and those both work correctly even with multiple instantiations of the constructor function. 
fast but heavy, try to scroll the page after press "stream points"
Animated value changes! =D We need a codepen.io or jsfiddle of it. 
[removed]
[removed]
I think you misinterpreted the OPs use of the term "far removed". "far removed" doesnt actually mean the package has been unpublished (or removed), just that it is not a direct dependency of your application, or even a direct dependency of one of your apps direct dependencies, but rather that it is a dependency of a dependency of a dependency of a dependency.... of a dependency of your app.
&gt; I never implied anything that you think I did. &amp;nbsp; &gt; ... writing code in a niche language ... &amp;nbsp; &gt; Types are hardly niche ... &amp;nbsp; &gt; Types with javascript does not require Typescript. Does it really need to be spelled out further? &gt; Fuck off troll. Your comment history is rife with the same comment. Do you back down the second someone questions what you're saying? &gt; Having types in Javascript does not require transpiling, or writing source in a language that is not javascript. More than open to suggestions. &gt; Typescript will end up being just another footnote in bad practice history. Only time will tell. For now, TypeScript is saving a lot of companies and developers time, money, and headaches.
Did you get an image on the page? If so, the controls are A and D
No need to delete anything man, nobody is going to judge you, mistakes happen and that's why I posted my own mistake in Reddit for the whole world to see.
I thought of realtime as if it was rendering while moving the sliders.
i agree, but my comment would've just caused more flaming. in the end im happy that someone could help you, so i removed it.
Here is another preview I made of the engine. This was in the earlier builds. I expect to make a more fancy demo when all the features is implemented. https://drive.google.com/file/d/0B43hDJbqzEJDVUs5N1pmOXp0NFU/view Sorry for the potato quality. It was taken from my Snapchat story
while you could listen for interactions with the canvas with a throttle or debounce function and send the base64 canvas data to the other user, it would be a lot of redundant data to be sending. Since this canvas element has some type of user interaction, why not record all of the users events and then just play them back out on the persons canvas? For example if the user is using a red pen of circle radius of 4, and the canvas mousedown events brushed over certain pixels, then if you send that out to the other user and just call all the functions that respond to natural events, then you produce the exact same result. 
surprised they didn't have bower on the list too
Thanks! It's been a wild ride figuring out the best way to provide great tooling for other developers that can make their lives easier. It's not just with code itself, and I'm happy to help where I can. :)
I really love nodal, has been helping me a lot! 
I am missing a description of what problem this framework is solving
Author here: Perhaps the philosophy section can provide some insight as to why `choo` was built - https://github.com/yoshuawuyts/choo#philosophy
[EDIT] - (My original comment missed the fact process is passed in as a callback function) TLDR; The call method is used to ensure that the function passed as the argument "process" has a "this" reference to the BinarySearchTree prototype. In full: var utils = {}; utils.processFunction = function(node){ // You may expect this to refer to utils, or the bst instance // If it was called without explicit "this" binding it would have had the default (typically the global scope). // By using call the author passes though the "this" value of the traverse function at time of invocation (which can vary but typically will be a BinarySearchTree "instance", as it would be in this example (bst) ) }; var bst = new BinarySearchTree(); bst.traverse(utils.processFunction); What the author is doing is forcing the "this" binding of any function passed into traverse (the process argument) to be the same as traverse's at the time of it being called. In most cases this will be a object created by the BinarySearchTree constructor, and therefore have BinarySearchTree as it's prototype. In the above example the "this" value comes from the LHS (left hand side, of the .) of the traverse call, which is bst. This kind of makes sense as it's binding the "this" value to the same value as traverse, because in most instances you would call traverse from an instance via the prototype. However it could cause confusion, as in the following example: var utils = {}; var bst = new BinarySearchTree(); utils.traverse = bst.traverse; utils.traverse(function(node){ // This will be utils but not bst, is this intended? }); If the author wanted the "this" binding of the process argument function to always be an instance with a BinarySearchTree prototype, then they could have used the bind method to force it. This is all very confusing, but it's worth reading https://github.com/getify/You-Dont-Know-JS if you have time for a good overview of "this" binding and the lexical scopes of functions.
fair point. i guess my comparison was to compare it to svg/d3. thats a whole lot slower. 
I’m using this and it works great!
If I wish to retrieve more granular type information at runtime, then I often use `Object.prototype.constructor`: typeof [] =&gt; "object" vs [].constructor =&gt; function Array() { [native code] } That said, I agree with voidvector. Write code for predictable parameters.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/node] [CDN to store your encrypted files : javascript](https://np.reddit.com/r/node/comments/4rio1d/cdn_to_store_your_encrypted_files_javascript/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
The analogy is a non-sequitur. The confusion starts because Redux is treated as an architecture for a lot of blog posts and tutorials. Comparing a pattern (MVC) with a framework is ignoring the point of the question, where the author didn't know Redux was not sold as an architecture in the first place.
I never know that book. Thanks for mentioning it.
https://github.com/github/fetch#sending-cookies Does that help?
But... where do you store the configuration files with the api keys used to access your service?
Thanks that was the issue.
Here you go.. https://jsfiddle.net/3ekpLyq1/1/ If you don't want the js in separate file just add &lt;script&gt;&lt;/script&gt; around it, no need for src or anything like that
Cool. I did something similar, but it is animated: https://jsfiddle.net/88ffevvd/6/ Sadly I only get 6-7 fps... I assumed blitting is the fastest way to draw it, but maybe not. I'm gonna rewrite it in WebGL and see if I can get 60 fps.
UNLOQ (the mobile app) offers and delivers personal encryption keys directly in the browser (32 char cryptographically stable strings). This way, we can use that key to encrypt all the configuration content (along with its metadata) directly in the browser and use the sconfig API only as a storage app, holding dummy data by itself. When an API key is generated, it is also stored encrypted with your personal key, and also includes your application's secret key within it, so you can call the API providing only the access token (the big access token) to access your configuration in plaintext, or just use the small token to fetch your data in an encrypted form, later on you can decrypt it on your client. It also allows you to define custom firewall rules to filter out requests that are not made from your server IP's (something that AFAIK AWS s3 does not offer) The project was initially intended to be used with our node apps and make our life easier, also allowing us to share some configuration data with other users and allow them to edit them. edit: formatting
Could be true for very basic drawings (like this) but once you start manipulating more than 4 px bitmap data is the way to go. I'm actually using drawImage in my pen so I can get blending effects, and since it is such basic manipulation, I'm in the process of just changing actual pixel colors by brute force to see if that is faster.
That's not proper currying. Currying means that you can pass **any** number of arguments at a time and it will keep returning another function that accepts the remaining curried function's arguments until you've reached the curried functions arity at which point it will return the result.
That'll work! Thanks a lot, ShortSynapse.
Return ends a function and passes data back to the function's caller. For example: function foo() { return 5; } var bar = foo(); The return in `foo` gives the value 5 to `bar`.
Redux has always been treated as a solution to a problem by the author. I'm sure what your trying to achieve by pointing out that Dan didn't know his library is based on an existing pattern? Does it really matter? The javascript community is full of solutions to problems that have been seen and solved in countless other languages. 
'return' is used just as it sounds; at some resultant point determined by the individual coding, the closure/function will end and the parent scope will receive back some function/object/value/etc (if provided) and from there continue on with the parent scope. Let's say I had a large amount of numbers and I wanted to do the same math operation to all of them. Well, rather than typing the same math function over and over in my code, I can simply create a function that can be reusable between all of my original numbers (saving memory, processing time, etc). So, when I pass my numbers to this function, I need a way to get the result back and thus that is what 'return' handles for us. Here's a little example (note this example is rather useless, nobody would really bother to return values this way): var myNumbers = [0, 11, 22, 10, 9, 1]; for (let i = 0; i &lt; myNumbers.length; i++) { myNumbers[i] = add(myNumbers[i], 5); } console.log(myNumbers); function add(someNumber, addThis) { return someNumber + addThis; } That's my best shot, I would definitely recommend just reading over some JS tutorials. Good luck :)! Edit: Here's the MDN on it: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/return.
Well yeah I think pixel manipulation should be faster in theory, just that Canvas doesn't really make it easy for you to do that. Maybe I should try it again, it's possible I was doing something stupid last time. If I can get 60fps on this: https://jsfiddle.net/88ffevvd/6/ I'll be happy. 
Yep, no comparison. Brute-forcing an imageData object is fastest here. I've got 100k particles running at about 15fps, which is more than usable here. drop it to 60k and we're silky smooth :) Pixel manipulation in canvas is pretty easy if you understand the theory :) Feel free to use my method in the pen.
use `.slice(1)` `String` doesnt have splice, a throwback from before map,forEach?
That's a good suggestion, I'll have to add that! Thanks!
Free online material on Babel that answers these questions: * [Babel Handbook](https://github.com/thejameskyle/babel-handbook) * [Setting up ES6](https://leanpub.com/setting-up-es6/read) (disclaimer: my book)
Check out http://youmightnotneedjquery.com
If you mean unit tests for the generator, there is no tests for it yet. But the generated app with the cli tool would offer unit tests.
First make a css class that hides an element: &lt;style&gt; .hide-me{ display:none; } &lt;/style&gt; Then remove jQuery from your project because it's 2016: document.querySelector('#clickme').onclick = function(e) { var elem = e.target; if(elem.classList.contains('hide-me')){ elem.classList.remove('hide-me'); }else{ elem.classList.add('hide-me'); } } but if you don't want to use a class you could also just do **e.target.style.display === 'none' ? 'block' : 'none'** , keep in mind though a lot of buttons are actually "block-inline", so make sure you check that first. below is the the alternative: (similar to jQueries toggle) document.querySelector('#clickme').onclick = function(e) { e.target.style.display = e.target.style.display === 'none' ? 'block' : 'none' } 
* OOP. Anything to do with OOP, including inheritance. I avoided the subject for years and now I refuse to use it even with a comfortable understanding. When people try to push OOP I just walk away from their overly verbose and poorly organized mess. * Array.prototype.sort is implementation independent, which means its behavior can do wildly different things from one interpreter to the next. * the Date object and its methods * The concept of lexical scope and closure was hard to pick up at first, but it is the single most wonderful quality in the language. The lightbulb moment occurred when a variable declared in a parent function can be read across two unrelated child functions with a preserved value. * Type coercion is often not clear. I avoid type recasting as much as possible in my own code and view this as a serious problem in other people's code. * The pre and post increment/decrement operators still confuse the hell out of me. `(b + c) - ++a` versus `(b + c) - a++`. I also view this as horrible sloppy shit. There is never confusion with `(b + c) - (a += 1)`.
Could you please show or provide a typical use case of this?
yeah, perf should be comparable to React - though from the digging I've done through the source I think there's room to shrink the source and be smarter about updates - I'd settle for: "fast enough" at this point
I'll add to that. Not just the closure, but the async closure. The thought that a function could execute *later* and still have the current scopes data which could have changed was a pretty big eye opener. However shortly after it "clicking" I abused the hell out of it...
Sounds like your first problem is actually being able to understand what you're looking at. Learning how to research and evaluate third-party libraries is an important skill to have. Similarly, learning how to look inside the codebase of an unfamiliar project is also vital. Here are a few links on those topics: - Evaluating libraries: - https://medium.com/bpxl-craft/evaluating-third-party-libraries-81dce02aa465 - https://carpeaqua.com/2014/03/21/how-i-evaluate-third-party-dependencies/ - http://programmers.stackexchange.com/questions/102189/evaluating-third-party-libraries - http://danielcompton.net/2014/11/19/dependencies - Reading unfamiliar code: - http://prog21.dadgum.com/194.html - http://www.lihaoyi.com/post/DivingIntoOtherPeoplesCode.html - https://www.reddit.com/r/javascript/comments/4465bk/experienced_developers_how_do_you_read_a_complex/ 
I belive it's to make sure that the animation runs no faster then 60fps, judging by the value that he/she/it is passing. `1000/60 = 16.66ms~`
I've got no experience with shaders so definitely ping if you've got it up somewhere. I'm thinking about how to expand this into a simple language such that you can do nice animations from the browser. I will defend d3 a bit here tho, yes it is slow but that is because you're using svg vectors instead of mere pixels which allow for easy browser event handling. It has it's place, but speed def is a downside. 
What fps do you get at 60k particles? That's without WebGL, right? I'm not willing to settle for less than 60fps!
I agree that it is better to just get the delta and increase/decrease the main animation value based off the difference. Would probably see much smoother results that way. ^.^
HAHAH, No WebGL. Well, it's only rendering when the inputs actuallly change, so over the long-run it's probably averaging well into the high 50s, LOL. I haven't done any profiling, but it looks/feels well over 30. **EDIT** Just profiled it and on chrome it's running ~30ms/f which is about 33fps while running the profiler :)
Correct. I continue to use objects as a means to store data by property name. Examples could include a list of options or application flags to enable or disable certain key functionality. In this case I am only using the objects as simple data stores. I don't know if its true anymore, but in the early days it used to be much faster to iterate across arrays compared to objects. So, I use arrays for dynamically populated data and objects where I know the key names, because friendly key names are easy to understand when reading the code. When I say I don't prefer OOP I mean I don't prefer using objects to store application instructions. In my mind that is the job of functions. I also cringe when I see objects being extended, because at some later time I know I am going to have to troubleshoot this mess where the path of extension is not clear by reading the code. People new to this language always, **always**, get confused on how the `this` keyword works. The simple answer for people new to this language is to completely avoid and not use it. For those developers willing to accept such advice the result is extremely liberating, like waking up inside the Matrix. Just like on the Matrix movie many new programmers are utterly incapable of accepting the provided reality and must remain enslaved to their environment. I, personally, don't use prototypes. I never have. It is convenient to create custom methods and types that can naturally be extended and expressed across a variety of constructs. This is absolutely expressive in an elegant way, but its just not how I think about the problem. I prefer the most direct answer or resolution to any given problem, which means some extremely imperative logic wrapped in a single-use function. Wrapping this logic in a function is a quick and dirty way of allowing quick reuse. As the requirements of the problem grow wider I find over time my original resolution gets bigger to the point where it might eventually need to be reorganized, broken down into modules, or rewritten for efficiency. I tend write libraries that are large. Thousands of lines of code large. I only break them down into smaller segments as parts of these libraries must be made more available for reuse. The size of the code is never going to shrink as the business requirements grow. Hoping to hide from increased application size by reducing things into more numerous smaller files actually tends to make the total size of the application grows larger still as now there is a bit of convention and ceremony to account and package the ever more isolated bits of logic. I guess the way I think about it is in total contribution cost as an economic quality. It takes a certain amount of effort to write the initial code, to perform maintenance, to debug, and so forth. What nobody ever estimates for is the knowledge gathering. It takes time and exposure to become an expert in a given area. Increased knowledge molests how you perceive not only the problem and the solution, but also how you write code and use basic tools. As an imperative developer, somebody who wants to solve the problem directly without regard for your silly human emotions of fear and apprehension, the total size of the application is more important than the perceived size of a given file. If I have to spend time combing through numerous atomic fragments of code with breakpoints and stack traces your application has failed mankind. As an imperative developer the code is best organized in a way where its execution path mirrors how a human reads the code. Reading the code should provide the answer as to the general area where the problem occurs so that time is spent making creative decisions about the most efficient resolution. I mentioned earlier that knowledge gathering is a huge accounting of time and effort, but rarely estimated for. Well organized and structured code in an actual structure, not some dynamic OOP object linking madness that only occurs during execution, allows for the expression of how the code works and how the code is organized in a way that is easy to consume by a code reader. The only thing missing is the *why* certain decisions were made, which is what documentation and unit tests are for.
What ECMA version are modules supposed to be a part of?
Not sure what I said that wasn't civil. I questioned /u/leptons' statements and called him out for making asinine statements.
&gt; Then why did you delete your comment? I didn't. /u/kenman deleted both our comments. &gt; I think you should probably give up on this thread before you embarass yourself further. You still haven't provided further information on your assertions, nor have you provided suggestions, which I am still open to.
&gt; jQuery 3.0 now formally supports the promise syntax for listening to .ready(). &gt; jQuery.ready.then(function() { throw new Error('boom'); $('#app').text('hello world'); }).fail(function(error) { throw error; }); ... if jQuery supports the Promise API, why use `.fail` instead of the standard `.catch`? https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/prototype
If the documentation is unclear I recommend opening a bug to get clarity. Once the questions are answered fork the project, update the documentation, and submit a pull request.
JSDoc does not give you "types in JavaScript." It gives you documentation that some editors can consume to aid you in writing your code. There are reasons this falls over: * There is a high chance of JSDoc comments becoming unsynchronized from the code it's commenting. * Google's Closure compiler is the only compiler I'm aware of that actually makes use of code comments for type verification. * Linting, while useful, is not a substitute for a type system. * Comments, while useful, are not a substitute for a type system. While TypeScript does not (yet, anyway) provide constructs that type systems can provide (like reflection), it does provide other constructs like interfaces. If you are "too lazy to understand" why JSDoc, or code comments, are not a substitute for a type system, kindly educate yourself.
Call me when they have webrtc. 
Does anyone know the expected time line for stuff in the technology preview to make it into the stable release? Safari missing the Intl API is a giant pain for us because it means we have to load a 60kb polyfill, but it is in the technology preview. Apple is really dragging their feet on this one considering it's even in IE11.
&gt; Apple is really dragging their feet on this one They've been dragging their feet w/ Safari for years.
&gt; Probably because serviceworker kind of canibalizes the market for native mobile apps, and the App Store is kind of a big deal to Apple. This is exactly why. Anything that will compete with native apps Apple won't implement or will halt implementation of for as long as they can. Webrtc is another example of this. And Apple wont let other venders implement their own browser engines so the only browser engine you can use on iOS is Safari's.
It's pretty rare we have to add a polyfill just for Safari though. If something is missing in Safari it's usually missing in IE11 too. It's only going to get worse to since all the Windows 7/8 deployments are going to be stuck with IE, it will be a long time before we can drop IE support in favour of Edge.
What! OP not being offended or defensive but willing to take suggestions for improvement?! /s Good for you OP, I'm interested in learning more about debugging nodejs apps than console.log, mind pinging me when you are done?
Yeesh, pointlessly OOPified.
Also chapter five of eloquent JavaScript
Maybe you shouldn't call preventDefault?
Absolutely! I'd be glad to! :-)
&gt;Usage of Regex is not allowed. Why?
We use JSHint for ES6. Works fine. 
Mazel tof
Ahh thanks. With that and adding callback to the send it works. Not sure why it needs a callback though. 
Remind me a little bit of [CycleJS](https://github.com/cyclejs/core/), not necessarily in terms of implementation but the philosophy behind it.
This may in fact be the one of the cooler "programming-as-a-game" ideas I've seen, based on the stupidest monetization scheme I've ever witnessed.
I have mixed feelings about Eloquent Javascript. *So* many people get tripped up by that chapter that someone had to create Eloquent Javascript the Annotated version, and then even he gave up to pursue his own writing projects. I'm not saying it's not a valuable resource, but if that many people are thrown by it is it still worth recommending to beginners? 
Same here. For anyone hoping to see how the generator pattern leads to best practices in React apps, be warned that in this case, "generators" refers to code scaffolding from templates.
It's a kind of shim to add flexibility of limiting the FPS but with all the features of RAF being present. You can render easily at 30FPS, or 15FPS... RAF will just set the maximum FPS you can use.
Beautiful! Wow - it's nice and fast. WebGL...... oh yeah! I'm off to play with it - finding interesting arrangements just got a whole lot easier! Hm... needs a way of combining them and adding colours. Hey - what about instead of density... it also effects colour? =)
Maybe three years ago? All aboard the [Progressive Web App](https://codelabs.developers.google.com/codelabs/your-first-pwapp/#0) hype train.
Now I'm going to have to make something that generates a donkey from a reddit username so I can call people an ass and link to their generated donkey.
You don't need CSS, freedom of speech, or your left pinkie toe either.
Internally, regular expressions are parsed to finite state machines. You could simply write your own one, following its graphical representation with a few objects.
The reason for all these packages is the fact that babel isn't just es6 -&gt; es5 anymore. It's a general transpiler for JavaScript so it doesn't do anything out of the box. You have to install the right presets based on what you want to do. `babel-preset-es2015` is the actual preset that will transpile from ES2015 (formerly known as "ES6") to ES5. If you were using an alternate syntax like JSX for React, you would also want to install `babel-preset-react`, etc. I would definitely recommend taking a look at [this](http://babeljs.io/docs/setup/) page.
_You_ were the one to bring up speed, OP was just complaining about all those bugs making it unusable :)
&gt; Probably because serviceworker kind of canibalizes the market for native mobile apps, and the App Store is kind of a big deal to Apple. Which is a bit funny since Apple originally wanted _only_ web apps on the iPhone.
And half of it will be full of quirky bugs you need to work around! Yay! /s
I think it's safe to say we've gone full circle
Also `typeof /regex/ → object` function typeOf(arg) { if (Number.isNaN &amp;&amp; Number.isNaN(arg)) return 'nan' let type = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase() if (!Number.isNaN &amp;&amp; type === 'number' &amp;&amp; isNaN(arg)) return 'nan' return type } &gt;&gt; [null, undefined, true, false, NaN, 1, 's', {}, [], () =&gt; {}, new String, new Boolean, new Number, /r/].map( (arg) =&gt; `${typeOf(arg)} vs. ${typeof arg}` ) ← Array [ "null vs. object", "undefined vs. undefined", "boolean vs. boolean", "boolean vs. boolean", "nan vs. number", "number vs. number", "string vs. string", "object vs. object", "array vs. object", "function vs. function", "string vs. object", "boolean vs. object", "number vs. object", "regexp vs. object" ]
https://forums.adobe.com/thread/1246514 this may help 
The for ... in loop. It seems safe. You're chewing through all the things with it. You're a champion. One day your bulletproof code that's been running for three whole days starts to fault. When you finally get into it, you (maybe not so) quickly identify the problem. Some framework update added a toJson method to the array prototype! For ... in, being the headstrong sort figured that it would be remiss if it didn't include that method in each and every array iteration. Lesson learned. Don't use for ... in with arrays! It's meant for objects anyways, use the right hammer for each nail! So now you're tearing through objects exclusively with for ... in; the right way. Wrong! You end up encountering the same problem with any inherited properties on objects too! "But wait!" you barter into the abyss, "I did it right, I was using for ... in on objects this time, why won't you let this work?" The abyss is, as expected, non-forthcoming. You eventually google your way into some establishment for uptown coders that wear jackets with elbow patches, and drink their coffee from snifters. From these engineers you learn that there is a way. You can know if an object actually has a property! In short order you find yourself gingerly mincing your way through objects again. Reverently wrapping the body of each of your for ... in loops in an ```if (obj.hasOwnProperty(name)) check; as Crockford intended. Your code is solid. The garbage you wrote before? Child's play. Ravings of the uninitiated. You're past that. Welcome to the future of development... Population: you. A few short days later you see an alert from your ci pipeline. It's someone else's check-in, but your code appears to be choking on it! What could it be!? for ... in. It's laughing at you. You don't know how, but it is. It's an idea, it's syntax, it's a concept! Apparently it's also your nemesis. You end up bivouacking in the new code, searching for the giant X marking the spot where you need to dig. The wait isn't long. It turns out a newly added component carries implementation metadata, and has a method with a key, "hasOwnProperty." You trudge back to your desk, knowing this'll be your fix, and start fiddling. After a bit of time, you hit a solution in an ```if (Object.prototype.hasOwnProperty.call(obj,name) check. It's bulky and feels inelegant. You're borrowing your method from object because you can't trust objects; at least not any objects obtuse enough to willingly hang out with for ... in. It looks good, for now. You expect it to work. It makes sense. But now you know better. for ... in has made you wary. Not wary enough to have avoided binding this all over your latest module... But you don't need that done until next week. 
[Spotify wouldn't have to pay Apple 30% of it's subscription and Apple couldn't block Spotify updates](http://www.recode.net/2016/6/30/12067578/spotify-apple-app-store-rejection)
&gt; pre and post increment/decrement operators They are a throwback to C and its use for low-level stuff, in the past when optimising compilers were not nearly as good as they are today. They basically mirror specific instructions on some CPUs of the time and allowed knowledgeable programmers to save a clock cycle or few in some circumstances (which could be very valuable in a tight loop on an old processor). These days I would consider their use in a larger expression a smell even in C: someone is being tricksy to save a few characters (a good optimising compile for your target architecture should be able to spot the CPU instruction level tweak if supported and use it where it will help). In Javascript doubly so. Even `(b + c) - (a += 1)` is bad IMO, a single operator is doing two things (increment `a` and returning the value of `a`) so you effectively have a function with side effects. Use `a++; whatever = (b+c);` or `whatever = (b+c); a++;` (or with `a+=1` if you prefer that form over `a++`) and it is fully clear what order you mean things to be done in. Write your code for humans to read and let the JIT compiler do the tricksy stuff that might help the CPU.
Given that NaN stands for "not a number" I can understand the confusion. The fact that `typeof NaN == number` is true is just something I remember rather than something that particularly makes sense.
Hey, no problem. Just sharing the pain I've felt in having to support Safari. My only point with mentioning speed is because 1.) you mentioned it, and 2.) speed difference doesn't matter when the thing is broken. Just like I don't want a NASCAR car that can't turn left, I don't want a fast browser that bugs out on basic Javascript tasks. I don't necessarily think that the overall bugginess of Safari is related to its speed. The really gnarly thing about Safari (as opposed to, say, IE8) is that it's much harder to polyfill; you can't just feature-detect, because *technically* the feature is there. You have to browser-detect and overwrite the existing in-browser feature (where possible) with non-native Javascript code that at least behaves correctly.
For whatever it's worth, I've ran into a case where Regex performance on desktop Safari was gigantically worse than either Chrome of Firefox. Otherwise it seems fine.
You're trolling right?
I want to join making few easy-medium projects[sites]! If anyone into please PM me i'm interested to join one thanks!
Because this is probably some interview/test question.
This is educational. Thank you!
So true. Also 10$ month. Really?
Dates go hand in hand with i18n and l10n as two things Safari never seems to give a damn about. The sheer quantity I need to shim in for Safari people is ridiculous, and most developers' solutions are to simply assume everyone wants to read their date strings in English and/or like mm-dd-yyyy
Thanks. I tried it but can't get it working unfortunately. I guess it's too much for my coding skills :(
I can't even being to tell you how wrong you are!
Yeah, they tend to be the first, but not exactly the best, like their botched indexeddb implementation back in the day 
Because the default comparison function converts elements to strings and sorts in alphabetical order. So 32 comes first. You need to supply a sort function. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
I'm the opposite, I need the type annotations or it looks messy ;). Yea the it's very difficult to go from x + y to x + y + z. But once you see a nice demo or use case it can just click.
They arrived today, thank you so much ^^!
What's the anticipated level of proficiency for the viewers prior to the course presentation?
That's the syntax, not the importing. 
*facepalm* More than 4 years coding in JS and missed something like this. 
I'm looking forward to supporting for Linux 
What the alternative to global class names?
Thanks for pointing that out, didn't consider that.
Always start with the basics. Assuming no prior programming experience, the first topics should probably be: - Variable assignments (var, and why not to use it; let, const) - Value data types (number, string, boolean) - Complex data types (object, array, function) - Control flow (if/then, while, for) From there, it's probably best to cover topics like functions and prototypal inheritance and the actual difference between value and complex data types and how they occupy memory.
yeah, I installed it and it's looking very promising, the auto complete contexts are amazing. but few bugs and error handling requires CTRL+L - the upside is, it's all javascript so we can make it better :) 
Try out the competition then. My terminal project is similar in idea, is also in development but can actually be used as long as you can tolerate some bugs: [Extraterm](https://github.com/sedwards2009/extraterm) I use it as my 'normal' terminal emulator on Linux using fish, and on Windows with cygwin and fish. 
Crazy, right?
&gt; your trying to achieve by pointing out that Dan didn't know his library That's a misunderstanding caused by a improperly structured question that was made in 10 seconds with a few things in mind: * Use the "Event Sourcing" word in the title in conjunction with the "Redux" to be easily found while searching for "Event Sourcing" in the AMA search * Make it obvious that it is a question from an outsider perspective of the motivations/internals/deep docs of Redux (not as a library or pattern/architecture, but as a buzzword), and for that to be clear it is necessary to point out that the OP assumes that Redux is a synonymous of Even Sourcing. Correct concepts and namings matter when someone is in a position of influence. Our industry is full of people with less than 5 years of experience in programming, people that are starting do not understand fundamentals from decades ago. Failing to point them out is a mistake that just helps the programmers in the industry to keep committing the same mistakes that were already solved years ago.
https://github.com/zeit/hyperterm - another Electron-based terminal
+1 for "devil's avocado", I like.
Looks like they've figured out a good way to avoid using any sort of metadata or file extensions to do it: https://mobile.twitter.com/jdalton/status/750817391949389824 Essentially, to be recognized as an ES6 module instead of a commonjs module, all you need is an import or an export statement. 
no. I used to be obsessed with webrtc - the source code can be compiled and imported into a cordova or react-native app. I like that it's open source and what it's capable of - but it SHOULD NOT be turned on by default in browsers. It's broadcasts signals by default, it's trivial to fingerprint someone and find their IP address. It's probably the most privacy invasive API avail to javascript - and every privacy aware extension that's worth anything turns off webrtc. I think there should be a separation of concerns, some things are meant to be contained inside of apps, and not turned on by default in browsers. Why didn't Steve Jobs include flash on iOS? Maybe somebody at Apple knew the source code was shit and being used to hijack people's operating systems? Government contractors have been using it since 2011 (probably earlier) - that's how the zero day was discovered, hacking an italian firm. I think webrtc should be faded out of web standards.
Safari is still the new IE. 
...or just check the box for pausing on caught exceptions in your browser debugger.
Nice idea.
THANKS!
I'll have you know my dad invented bullshit, and he's right, this is bullshit. xXxREKTxXx360noscopexXx
I tried Extraterm out a bit and like the boxed output, but can't live with the fact that it eats the emacs keybindings. Black Screen at least says it works with emacs, so I'll check it out.
Thank you. I've updated the resource collection and added a section for general meta-programming. Very creative usage of valueOf in the examples you provide. I've used valueOf in some cases myself and played around with the idea of custom operators, but I didn't figure out a good way to do it. So this is very cool indeed.
X-Post referenced from /r/aureliajs by /u/Davismj [Fun Ninja Turtles example](https://www.reddit.com/r/aureliajs/comments/4rqajz/fun_ninja_turtles_example/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
If the level is zero I usually start with document.getElementById. New students want to see that their actions have a result, and innerhtml and style allow for quick visual feedback. Then expand with variables, prompt and if. 
I would write this out from scratch. *shrugs*
I still don't get what your actual concern is. Are you complaining that people throw around the phrase "Redux architecture" in blog posts? That Redux's README doesn't have the words "EVENT SOURCING" in the first paragraph with a blinking border and arrows pointing to it? That Redux doesn't link to a dozen CS papers in the docs citing every possible piece of prior art? What are you actually concerned about and trying to accomplish?
Mobx sound like exactly what you want. It's a library though. Framework wise would probably be Mobx+React.
Might look at it once they give you the fully offline version.
Time to put it in production :D
Vue is great for this. [Small example here](http://codepen.io/short/pen/grxdJv). Vue does a fantastic job of keeping everything nice and simple (while still powerful). More info on Vue here: http://vuejs.org/
I think React plays better with jQuery, but that might not matter.
It looks like a job for knockout. You can learn it very fast. 
Actually since you're good at guessing things, it's for my own personal benefit, but you're such a scholar, I bet you figured that out yourself, didn't you cupcake?
Well I tested that and you're right I had to redo it but for my earliert question, I managed to create this var urlValidation = [".com","mil",".gov",".int",".edu",".org",".net"]; // top level domains for (var s = 0; s &lt; urlValidation.length; s++) { var boolean = gatheredInfoFromFields[1].includes(urlValidation[s]); if (boolean == true) { break; } else { alert("domain typed incorrectly"); break; } } However, it only checks to see if users input contains the suffix domain and the text box strictly implies that top level domains are required.
For something like this, it's actually straightforward to roll your own. The main thing you need to maintain is the dependency graph, and the simplest way to do it is to attach a list of direct dependencies to each field (don't hardcode the ordering, or it'll get messy to maintain.) The only extra step is to ensure that there are no cycles, and you can track this in a "visited" map as you follow a path for recalculation.
It built and ran just fine on my Mint 17.3 Mate lappy. Really really beta tho.
You're right about that! The fact is that there is no bulletproof way to check the validity of an email address. I saw another comment on this thread to the effect that your code allows for malformed email addresses. Without regex the same would be true for a URL string. You would write a bunch of code that would ultimately fail in production one way or another. Using regex grants you some liberties. You can more quickly and appropriately match your pattern against the string, but it can still only get you so far. If this is for some kind of test, use the same index of method. If this is for a real world application you have regex at your disposal, and you should use it.
ala Angular v2.0.0-rc.4
&gt; If you're using a new syntax, read the docs to see how it works.
The prototypical inheritance paradigm (and why Javascript uses it as opposed to OOP), anonymous functions, closures and why they're useful and a preferred approach. Scopes, lexical environment, etc. The overall looseness and forgiving nature of Javascript as opposed to other languages. As a general point, I found the functional programming paradigm a bit difficult to wrap my head around. 
Javascript appears to be changing the transform3d and rotate properties of the watches as you scroll the page. For whatever reason they opted to use JPEGs with SVG masks (mask-image property) instead of transparent PNGs. Some of the watches, instead of images, have canvas elements that play a short "video" made up of a number of images where the watch physically rotates in addition to CSS rotation.
There are a few ways to write multi-line text: 1.The new grave / backtick operator supports muliline strings: let foo = `multiline strings also preserve whitespace `; 2.An array of multiple strings joined with `.join('\n')`: let foo = [ 'line one', 'line two', 'line three' ].join('\n'); I'm sure there are a few more as well. I am not sure I understand your escaping question, there is not really any reason to escape something like a comma. "Escaping" will be different depending on the context of where this string is going to be used.
&gt; return string.replace(/[.*+?^${}()|[\]\\\-\,\']/g, "\\$&amp;").replace(/\n/g, "\\n"); &gt; Offhand, it looks like there is something funky in that first RegExp statement. Are you missing a ']' maybe?
Thanks, but I'm not trying to write multi line text - I'm trying to CONVERT a clipboard/copy buffer INTO multi-line text.
I don't agree, no. To say that "you think I agree" that "my approach" has been "juvenile" is trying to be condescending without having any high ground from which to condescend. Tone-policing is the desperate gambit of the disproven. It's not juvenile to point out -- *with evidence* -- that Safari has a history of being broken. "Large" and "complex" are *not* good things in software. And Safari is only as successful as IE ever was: people use it because it's preinstalled (or, on iOS, because they don't actually have a choice). You could even argue it's *less* successful, because the Safari tream didn't even build their own rendering engine or Javascript engine like the IE team did; they just grabbed Webkit off-the-shelf and then left their Webkit version out of date with current upstream patches and bugfixes. And even IE, for all its major problems, introduced XHRs to the world. What has Safari ever introduced beyond tighter coupling to a single vertically-integrated OS? The "black-and-white statements" you find "juvenile" are concrete, provable bugs I've pointed out. If you take umbrage with objective fact, I'm not sure what to say to you besides "sorry I hurt your feelings by pointing out Safari's bugginess." 
Its not for a test, I can assure you, had it been for a interview question, I'd feel bad for the company offering that kind of question. I did end up using regex, I didn't want to, but realized its much simpler, although difficult to understand. I saw someone mention [Regex 101](https://regex101.com/) and that helped greatly develop a string that I needed. Thanks for looking out.
document.querySelectorAll usually gets the job done
I disagree with you. jQuery is still very useful in a handful of scenarios. And completely essential for server side rendered sites. You mustn't forget that there are thousands of companies that still have 10 year old sites coming from PHP and Java backends. I'm working in react full time right now, and we've found that react lacks in the XHR department. React doesn't have a native api for XHR. You can use fetch() but you'll need an es6 polyfill for use on the client side. We said "screw it let's just use jQuerys $.ajax()". This is becoming the case on a lot of things as we move further into the project. This is exciting news! Edit: Traditional server side rendered sites is what I meant.
TL;DR
&gt;React doesn't have a native api for XHR. It bears repeating that React is a view library, not an opinionated framework like Angular. The frontend I just built with React still uses jQuery's ajax because it's easy to use and everyone's already familiar with it, and switching to fetch won't be too hard in the future when browser support is solid.
Hi /u/SapioiT, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Don't you mean ng-fetish?
Wait, why didn't you just use a library like [xhr](https://www.npmjs.com/package/xhr)? You seriously pulled in all of jQuery for the ajax method?
If you're just using `$.ajax` you might as well look into better libraries like axios.
If you're into this kind of thing, check out [acko.net's TermKit](https://acko.net/blog/on-termkit/) ([source](https://github.com/unconed/TermKit)). Here's a screenshot: https://github.com/unconed/TermKit/raw/master/Mockups/Shot-0.3.png
Hmm, I don't think so. It's mostly copied from the MDN regexp escape code here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
Great! Time to test this with Onsen UI 2 for mobile apps :D
The polyfill would have been a more responsible choice. And after that, jQuery is completely useless server side. 
&gt;added this, it passes the argument cool so check how many arguments there are and add them to the fn definition, then you can use your data function foo() { console.log(arguments) } // [ 'foo', 'bar'] // this means you should be writing: function foo(item1, item2) { console.log('got data!', item1, item2 } &gt;pass name from the server to the website in an li it uses the success function do that, its like (psuedo code) success = function(value) { list.append( "&lt;li&gt;" + value + "&lt;/li&gt;" ) } getFromServer(success,fail) so you put your list item code in your success function - based on the data its called with. (this is called the callback paradigm)
maybe try irc.freenode.net #photoshop or ##photoshop, there are some really smart people there that write plugins 
Wow, you whiny prick. The truth is this is such a common kind of question it's not worth discussing here. Google it, or post on StackOverflow. In fact, I bet if you posted on StackOverflow, even they would flag it as a duplicate.
Wait, what? jQuery minimized is ~85kb (~35kb gziped). 
I would trust Vue 2 a whole lot more than the mess that Angular 2 is.
Other parts of the site still use jQuery so there wasn't any marginal cost for us
Or a fetch() polyfill.
http://youmightnotneedjquery.com/
Nice one. I like the 'success' method. It's interesting how it's possible to chain the methods like that.
Seriously, why waste thousands of man hours developing a library when you just need this one command.
Try your code in Chrome Dev console. If it renders correctly, its problem with your Terminal emulator. 
It's required because when you create a cli tool using "commander" or "vorpal" it requires to be the same instance of the main module to be used in all the commands, and this is not provided by any of them. The idea of using Commular is to make use of NPM packaging to add commands as modules, Commular takes care of use the same instance in all the commands, so that they can be reused.
Yep the chainable methods are pretty groovy. Here's a list of a [bunch of callbacks](http://api.jquery.com/category/deferred-object/) you can add to a jQuery deferred object like $.getJSON Also, in looking at that list you should use .done instead of .success. .success is the oldschool way of doing it and I apparently need to get with the times.
What do you mean? querySelectorAll didn't exist when jquery first came
Thanks. This isn't the usual way of thinking coming from object oriented programming. As I usually have to investigate what owns what etc. And chaining success after fail didn't quite make sense to me.
I dunno, I was mostly poking fun at the implication that the jquery can be replaced with that one command. As if it served no other purpose at all other than selecting elements.
please post your code on codepen.io or jsfiddle, so we can see what's going on and we can help you :).
hmm not picking up on my git config / aliases, what does this use for profile / shell ? 
Yeah, I'm with you guys. That was a really inefficient decision.
Thank you, if only I knew how much time it'd take to develop such an application, I'd have never started it. As of `keyCode`, I do use `key` from the new UI Events specification for the most important thing: when a person writes to stdin of running programs. https://github.com/shockone/black-screen/blob/a32e0aed5c7021fc97a977d9dc6a51aa3cba1def/src/shell/Job.ts#L85-L85 What you see throughout the code with `keyCode` is shortcuts handling, and they use it because I didn't know about `key` at the moment. But they're subject to change anyway, we'll need customizable shortcuts.
Thank you. I shamelessly stole the colors and autocompletion box appearance from the One Dark Atom theme. Although, I'm not sure autocompletion is a part of the theme. Hopefully the author will forgive me. https://github.com/atom/one-dark-ui
If you mean that your git aliases (like `git br` for `git branch`) aren't autocompletable, it's not implemented yet. https://github.com/shockone/black-screen/issues/450 If you mean that you execute a git command and it fails, something must be wrong, and I'd ask you to submit an issue: all not built-in commands are executed in your login shell session (like bash or zsh). Maybe you have some git config path related settings in your .bash_profile - or whatever you use - and it's not being interpreted, maybe something else.
I'm wondering is VS Code popular nowadays? I see a lot of typescript guys use it, but I wonder if it is popular in general in the js community. 
Choose whatever, they do the same thing if you just want to use ES6 syntax. Though there's less setup with Typescript required out of the box, idk what's the current status with Babel but I remember some uproar within the community with the 6.0 release where just installing Babels wasn't enough, you had to setup the transpilation pipeline yourself or it wouldn't transpile anything, or copy the configuration from somewhere, idk if they changed that. Personally I use Typescript as I value the typing system and there's excellent support for it in Visual Studio Code.
Can you let me know why do you think this way? Are there any strong reasons? Thanks.
How does autocompletion work? Can you customize it for various programs? Like how you can get autocompletition to work for django's python manage.py?
One of the design goals of TypeScript is to be a superset of (ever evolving) JavaScript, so your concern is unfounded. The TypeScript team sends a delegation to TC39 to ensure they are not only up to date but also get a chance to propose changes to core EcmaScript. 
While my personal preference is for Babel, I think TypeScript is a pretty safe option. It has pretty wide support, and Microsoft behind it, so it's not likely to go away overnight.
Congrats to authors for the great job and ver 2.0.
You'd have to write an *autocompletion provider*. You can find examples here: https://github.com/shockone/black-screen/tree/master/src/plugins/autocompletion_providers
With TypeScript you can compile to human readable ES6/7/etc, so if you ever wanted to stop using it (say ES9 has everything you ever wanted) you could just compile to that and delete your old .ts files.
I use it for JavaScript and Go projects. The autocomplete for JS in particular is fantastic; it even supports suggestions for ES and CommonJS modules!
I will give VS code another try when they integrate angular2 autocomplete. Angular2 is a nightmare when you have to import tons of directives and components. WebStorm and PHPStorm are partially mitigating this nightmare for me.
They use JPEGs with SVG masks to reduce the size of the images. JPEG is much better at compressing photographs than PNG, but they can't do transparency. The SVG mask essentially gives you a "transparent" JPEG. 
TL;DR: Use four numbers, one for the **release** (telling the users that you would like them to update to that version, because you're not offering support for older versions for much longer), one for **breaking** (so you know that if you update, you can't go back without a complete backup, but, either way, you might still have broken stuff), one for **features** (so you now know if the update adds something, because if you don't want anything new, you might as well save the data you would use to update the software, like a big app on your phone) and one for **fixes** (so you know that if one of those is up, it might be the reason you suddenly cannot do one thing you could do in the previous version(s), so you update to it). --- *(Sorry, I couldn't not say this:)* ### Are you not entertained?
Maybe you could install JSBin on your machine. Never tried it myself but should be easy enough since it's on npm [Manual](https://github.com/jsbin/jsbin/blob/master/docs/running-your-own-jsbin.md) Edit: Managed to get some time to try it out. Requires node version 0.10.27, to install: - npm i -g jsbin; - jsbin - Open browser in http://localhost:3000/
exactly, typescript is just javascript with type annotations so naturally if you tell the compiler to do no transpilation, you get your original ts file back but with all type definitions removed and since typescript is just javascript without type definitions you now have a 1:1 javascript copy of your ts code. simple as that
Genuinely didn't know about this library. Can't possibly know about everything can I? Thank you!
I'll have a look into axios! Thanks!
Things we find jQuery still useful for are for the simple things like showing or hiding a div up to complex things like animations and creating our own promises though jQuerys q/promise/deferred api.
Try to instead click the option element to select it i.e. document.querySelector('select').querySelectorAll('option')[1].click(); See if that works
&gt; How was this not included in the ES2015 spec? **Because it has been in JavaScript since almost the very beginning.** This isn't Java, so you don't explicitly declare privacy with a *private* keyword. Instead you have to use scope. Consider this example: var outer = function () { var a = 0, inner = function () { var b = 0; }; }, peer = function () { var c = 0; }; In that code example the scope of *outer* is available to *inner*, but *inner* is private to both *outer* and *peer*. The scopes of *outer* and *peer* are private to each other. This is privacy in JavaScript. Explicitly requiring use of a *private* keyword would break the semantics of the language in the most direct way or would require a bunch of unnecessary convention non-sense. EDIT: ES2015 introduced block scope, so scope and privacy are no longer just about functions.
/u/nazis_are_bad gave a great short summary. Beyond that, I maintain a big list of links to high-quality tutorials and articles on React and related topics over at https://github.com/markerikson/react-redux-links. Specifically intended to be a great starting point for anyone trying to learn the ecosystem. In particular, the [React Tutorials](https://github.com/markerikson/react-redux-links/blob/master/react-tutorials.md) page has a variety of tutorials and introductions.
 var contents = document.getElementById("myNewDiv").innerHTML; document.getElementById("hiddenFrame").innerHTML = contents; If there is not an easy way to identify that new div element then you will have to walk the DOM to get it. Here is a handy dandy guide to help get you started: http://prettydiff.com/guide/unrelated_dom.xhtml
If you generate Objects with a constructor (basically same as class) you can declare "private" variables with var inside the constructor, you can then use all these inside any methods you have for the object but any other function outside of the objects scope can't access them. Eg. var A = function (a) { var private = a; this.public = 3; this.addUp = function(){ private += this.public; } } var obj = new A(2); The obj can now access it's private property inside itself but anything calling from outside won't eg. obj.private doesn't work
A large portion of small projects use jQuery just for selection and event binding. I'm just advocating for not relying on jQuery for that since it's a native capability now. Obviously there are still cases where jQuery brings value (xhr, old browsers, etc) but not every project uses these features.
You can test for a combination of events. An actual user click cannot occur without either firing a *focus* or *mouseover* event. There would also be a *mousedown* event.
sneaky btw, I didn't see the author mention anything about [unsupported browsers](http://caniuse.com/#search=ServiceWorker). I'm guessing they just fail silently in the background and the end-user is none-the-wiser?
You can use `let` which is a block scoped version of `var`. For example: function run() { // creates new function scope { // creates a new block scope var funcScope = "funcScope"; let blockScope = "blockScope"; } console.log("func scoped", funcScope); // prints "func scoped funcScope" console.log("block scoped", blockScope); // throws Reference error: blockScope is not defined }
This effect has multiple parts: * Scaling, images are being scaled to create depth * Paralax, images are moving at different speeds relative to the camera ( screen ) in order to emphasize depth. * Sprite animation, very slight used to give the illusion of 3d. * Rotation, used to emphasize the Sprite animation without putting in extra work 
Does anyone have any experience building anything with it? How was your experience?
I've done similar as well. Completely agree with the recommendation to use an iframe. My only other additional comment was to really go overboard in whatever you have as documentation for installing this as 3rd parties have wildly varying degrees of technical competence.
Nice. What about distinguishing clicks based on position of the click? Presumably, click() can only click at the exact center, but a human with a mouse clicks all over the place. 
I get them constantly because I have all cookies created in a tab removed when that tab is closed.
Thanks a lot for your input :) We (the devs) tossed the iframe idea because of the design issue we might run into. The more I think about it, the more the "widget" plan seems like a hassle. Specially with all the js that Kendo brings, IFrame might be the easier route. It's a business application, so size is thankfully not such a big concern.
 let privateVar; class SomeClass { constructor() { privateVar = 1; this.publicVar = privateVar + 1 } }
you want the Event.IsTrusted property. That property is used to determine the difference between synthetic events an HID driven events.
React - stop this madness, please. 
Nice looks like a fun learning experiment. Did you enjoy Redux?
I'm certainly open to changing my view, but you're gonna have to send a couple links instead of just saying I'm wrong.
Selenium is clunky. Powerful but clunky. I found with Selenium I was using 'executeScript' more than I was using its emulation features. Its a bit of a battleship when you need a canoe type situation (as you describe it). If you website is a Single Page Application or otherwise makes heavy use of JavaScript; I'd highly recommend PhantomJS. Otherwise if its just a normal get request you should use nodejs (http.request) + cheerio. You can add extra headers to the http request to look more like a browser if you want to avoid getting blocked (even accept/send cookies). http.request will be 10x faster than phantomjs Nightmare is a flavour of Electron (kinda PhantomJS). PhantomJS is really node ran through phantomjs binary; I have used phantomJS inside of nodejs using a package called [phantom-node](https://github.com/amir20/phantomjs-node) if you want to use phantom inside of node.
Thanks! I love Redux. I've used other libraries for implementing Flux, such as Flummox, but I feel that Redux is the least boilerplatey and it's really easy to track the flow of data in one's app.
I can easily search for links, but it is of no consequence. If you are following news about angular 2, you would already aware of the state of router, scope creep and lack of migration path from ng1. That might not be a problem for you, but it is a big deal for many. PS: I really have no intention of turning this thread to ng2 vs vue2 or something.
Thanks! This is a little OT for the black_screen thread, so maybe we can take this elsewhere, but assuming others are interested as well, here's what I found so far: - meta (alt) prefix key doesn't work. this is a killer. - some control keys don't work: - ctrl-@ (set mark) -- no effect - ctrl-space (set mark) -- not sure what this did, but everything stopped. a second ctrl-space made it work again. - ctrl-^ -- no effect - ctrl-\ (set input method) -- no effect 
I use jQuery almost exclusively for jQueryUI widgets, and the Knockout plugins that have made for binding to them. I'd love to get away from using jQuery altogether though.
 var getOrdinal = function(n) { var s=["th","st","nd","rd"], v=n%100; return n+(s[(v-20)%10]||s[v]||s[0]); } function getOrdinals(s, e) { if (s &gt; e) { console.log(''); } else { while (s &lt;= e) { console.log(getOrdinal(s)); s++; } } } console.log('=== 1,4 =========='); getOrdinals(1,4); console.log('=== 'a',30 =========='); getOrdinals('a',30); console.log('=== 10,7 =========='); getOrdinals(10,7); console.log('=== 119,121 =========='); getOrdinals(119,121); Output: === 1,4 ========== 1st 2nd 3rd 4th === a,30 ========== === 10,7 ========== === 119,121 ========== 119th 120th 121st 
If you want it all in one returned string, then just store them in getOrdinals like this instead: function getOrdinals(s, e) { var results = []; if (s &gt; e) { results.push(''); } else { while (s &lt;= e) { results.push(getOrdinal(s)); s++; } } console.log(results.join(' ')); } Output: === 1,4 ========== 1st 2nd 3rd 4th === a,30 ========== === 10,7 ========== === 119,121 ========== 119th 120th 121st
I can't emphasize enough using your browser, Chrome and Firefox have excellent dev tools, I'm not sure about ff but Chrome has workspaces where you can load your files directly from the browser. If you need to run command line commands I'd suggest actually learning how to use the command line, you will grow immeasurably as a developer by learning this. Try and read how to use Unix as an IDE.
They can't even get mobile scrolling working correctly on their article. Why would I trust their advice?
That's just another shitty safari bug. Works fine in chrome on Android
He wants private variables that belong to each instance of a class.
I'm sorry, it's just that my mind is in a state of Flux. *badum-tsh*
I think typescript has some features in addition to type annotations that don't copy 1:1 (such as classes/extends etc) I think the closure compiler would be more akin to what your suggesting https://developers.google.com/closure/compiler/docs/js-for-compiler
I dont think it's worth it. I've used it and my current job is paying a lot of tech debt from it. Here is what another user said about it in reddit https://www.reddit.com/r/javascript/comments/4pzvi0/meteor_vs_electron/d4p5ccb
I’d be interested in seeing the results for the upcoming Mithril 1.0 ( https://github.com/lhorie/mithril.js/tree/rewrite ), which has a new engine that is significantly faster than v0.2.5 on dbmonster and vdom benchmark Truthfully, v0.2.5 hasn’t gotten much attention in terms of performance for a while, since I’m focusing primarily on the v1.0 engine.
That's where `var $ = document.querySelector.bind(document);`comes to help. Although it may confuse some people when they see things such as `$('#foo').addEventListener('click', function(e) {});`
Excellent! Now about the minimap...
Interesting that it never even began with having something as commonplace as tabs! Welcomes update though.
Don't worry, I have no allegiance to either framework but I do think you need to back those statements up with, you know, evidence. I've been following Angular 2 pretty closely and haven't heard of those as big issues, so please send a few links my way.
I'm quite sure there will be a round 4 ;-)
Yeah I figured this is what I'm going to have to do. So what is net beans mostly used for? 
Does anyone know of a way to make the error squiggles more prominent? In Atom I have a marker in the gutter that indicates a line with a problem, since a underline squiggle is pretty easy to miss when scanning a file.
If you need "realtime" websocket support, there are much worse choices than node.js. Socket.io tends to be what most people start with, but Deepstream.io and socketcluster.io are more framework-y alternatives (that are both built on the underlying libraries that socket.io uses). For persistence, you could use redis and some kind of actual database, or maybe look into rethinkDB, it promises the best of both worlds, but it's relatively new.
Doesn't MongoDB (with it's [J|B]SON stores) work hand-in-hand with JavaScript? What are alternative DB stores which take advantage of the "dynamic-ness" of the modern web? I am really looking for production-ready frameworks here, seems pointless to learn "toys", so what would you say is a good alternative?
A big bank in Denmark [used it in April](https://twitter.com/futurice/status/720942144689717248), might want to check with them.
RethinkDB blows Mongo out of the water and has way better JavaScript integration and real time built-in. It even has joins! The problem is that 90% of apps out there are relational, so Mongo doesn't fit them well.
Moved too slowly and did not innovate as fast as it should've. Fun to play with, would never build a business on it. Meteor came out in 2012 and well, I don't see it going anywhere big. At least they added React support which seems to be popular now. It's 2016 and there's tons of options for fullstack, realtime JS apps now that aren't tied to Mongo.
RethinkDB has been recommended quite a few times in this thread, so I will take a good look at it. Thanks!
I use it full-time for JavaScript / Angular 1.5 development. Switched from Atom and have been very happy. 
Someone else said to take a look at RethinkDB, so I will have a good look at switching from Mongo. Thank you for giving me some links to check out :)
&gt; Meteor came out in 2012 and well, I don't see it going anywhere big That's kind of the clincher, I don't have a lot of free time around working full-time, so something popular is my best shot at keeping up in the industry. In your experience, will Angular 2 (with Node and RethinkDB) be a "safe play" for future development? Angular has great community, it seems
Is there a way to use separate template files without using vueify? The post at https://vuejs.org/2015/10/28/why-no-template-url/ seems to indicate they intentionally didn't allow this, and I couldn't find any info about alternatives in the docs (aside from vueify).
Backend with an ARM processor? that's one novel development environment! I was hesitant with regards to MongoDB, but kind of accepted it. But it *would* be nice to be able to support other databases! Limiting what storage engine you can use is a huge deal for me. What frameworks for JS development are popular right now?
Classes are an ES6 feature.
Babel (and Typescript) will keep evolving way faster than browsers do, so I'm not sure that we'll ever get out of this transpiler world. And right now, there's a great deal of ES2017+ features that I'd be really annoyed to lose.
&gt; Angular2 is a nightmare FTFY ;)
Any of the common stacks allow you to learn to program web applications sensibly. I would recommend the stack that has the most use in your country/area (check job postings/local tech communities.) This'll make it easier to get developers to code your shit and/or to get a job using said skills. Asking randos online is probably about as random as it gets. Your situation is fairly non-descript, so there's really no way to restrict a technology choice on the basis that you "been in sales/biz dev for about 5 years". You can build anything on any of those stacks. 
The component model is indeed unclear, as is state management. But I think those issues can be sorted out with maturity, and the only way to get maturity is to get more attention to it. Like you, I appreciate that it does have a very good idea. And yes, xstream in my experience is much simpler. 
Thanks for the extra detail. I've put it in an issue: https://github.com/sedwards2009/extraterm/issues/21 I'm busy implementing a 'Command Palette' pop up like what you see in Atom, and after that I'll do another round of straight up bug fixing and get to this particular issue. oh, BTW, Ctrl+Space put you into the fantastic cursor mode as demonstrated in the animated GIF film shown at https://github.com/sedwards2009/extraterm 
Your problem is using angular2 in the first place. If your framework and/or language requires sophisticated tools and IDEs to let you get any work done...yeah, you're probably using the wrong framework/language. Say no to Java and Angular today!
TodoMVC is not an actual thing in the real world. Everything looks great if you do a TodoMVC with it. You won’t be making Todo apps all year long at your actual job which pays actual money. You need something that you can rely on.
Yea, I'm not building a app that's going to be consumed by thousands of people it's more like 1 or 2 people at most. But NodeJS gives me the benefit of being super lightweight so that's why I chose it. Right now, Express, Hapi.js, Strapi (It's super new but it has a great concept behind it.), and Feathers.js.
I use it and I code in vanilla javascript (recently especially in node) the thing is MS is very good at developer tools and seeing as this one is cross platform and free I see no reason to avoid it. It's faster than Atom (but has less plugins at the moment). It's being developed faster than Sublime (dev team vs 1-2 guys , but has less plugins at the moment) It's faster than Brackets and has tabs (but Brackets is still my favorite for small front end heavy projects) And the node debugger is a huge help.
All the things you point out is true. But are you saying that Angular is not to be trusted?
Of course it's the same, just like every single JS feature (well, at least stage-2 upwards) is the same. Typescript is a compile-time typed implementation of the ESNext specs, no more, no less.
It's cute, but not enough polish. "20 hours ago" tag under the price is confusing. (I realize it has to do with when the information was updated, but my first thought was that is when the flight left.) Flight prices can change by the minute. If this information is 20 hours old then it's almost useless. The nodes on the chart are too small. The buttons getting larger in the nav-bar due to the font bold causes the rest of the buttons to shift. It's super distracting. The style of the site makes me think it's a team of bootcamp graduates final project or a hackathon project. 
Ideally there would be a web service in place rather than localstorage, but as a small app to demo a new framework I think TodoMVC is great. Real world apps would be larger in scale but I still I think TodoMVC is a good indicator of what to expect from a framework.
You can do practically the same thing with Thinky and RethinkDB. And you're getting a lot better database.
I understand your point. But modern languages are written to leverage the power of ide . For example it's almost impossible to write c# code without a decent ide. 
How far do you want to go down in this rabbit hole? ReCaptcha basically tries to do this, plus a million other things to make sure the user is a human. Even for them, it is still a cat and mouse game, as hackers that are willing to pay would just send it off to a Mechnical Turk-like service and have humans in a 3rd world country generate 100 clicks for fraction of a penny 
&gt; nowadays Jquery makes developing harder You didn't say that anywhere above. Each reply makes a different set of claims. Read them yourself.
&gt; Jquery, in a modern workflow, is something that makes web developing harder Quoting myself here.
Yes, and I assume your proof was this: &gt; It's in Bootstrap, Semantic, Signalr and many other more or less essential dependencies. Every single one of them needs hacks now thanks to Jquery. You never backed that up. 
What do you mean hooking up? You can do http requests and websockets 
And that's pretty easy to do?
i'm using it since some months instead of Atom for developing React applications with Babel. It is faster, more solid, has a nicer UI, the autocomplete in JS, etc. I'm very happy with it. Also, vscode developers are great. 
I admit never tried cycle because I find its author rather arrogant on twitter :(
If you want to add customizable keyboard shortcuts to your app just use my brand new HumanInput lib! https://github.com/liftoff/HumanInput If you check out the "modernize" branch (which will soon become master; maybe this weekend) it will match your code, using ES6 classes and whatnot. It isn't as well-tested as master (yet) but the keyboard portion should work great.
That is why I avoided it. He bashes React any chance he gets. It's a pretty big turn-off. 
You will not get a honest answer here in /r/javascript. Everyone are react fans. *flameduck*
Nice seeing a visual overview of your whole document, and if it's long, you can generally figure out the block you need by looking at it and just clicking at that area in the map and your editor will scroll to it. Beats scrolling down until you find your spot.
You shouldn’t be using straight/dumb quotes in text anyway but quotation marks instead, ‘text’ and “text”. Now there is a proper use case for straight quotes, namely code examples but they should be the exception overall.
Redux is great, but have you looked at [MobX](https://github.com/mobxjs/mobx)? Any specific reason you chose Redux over other options?
MEAN sucks purely because it's bound to MongoDB and [don't use that](http://cryto.net/~joepie91/blog/2015/07/19/why-you-should-never-ever-ever-use-mongodb/). Personally I have been working on a boilerplate framework that I use for many of my projects and have ripped it out and turned it into a general boilerplate. [**Vulcan**](https://git.io/vulcan) runs on **Koa**, **Koa-Router**, **Bookshelf**, and **Jade** with a bunch of helpful additions. Right now it's on **v0.1.0-alpha.1** and I plan on cutting **v0.1.0-alpha.2** on Monday with **Gulp** integrated into the CLI to have built in asset pipeline like setup.
I like this: http://algorithms.openmymind.net/
It's pretty easy when you figure out to do it, for me the weirdest part was figuring out decoders (because Elm is typed). Give it a go, it's really nice
Shuts down tracker cookies that get by adblock and such.
Also means you're never logged into any site you use...
Nice! A minor comeback is all it took to trigger your true colors, bravo! I'm proud of you. Excellent impression you made, now everyone knows who to avoid when they ask a question here. You've been blocked from here on out. Enjoy buttercup s (^ .-)-b
WebStorm is just so far advanced I don't see Code (or any other IDE really) ever catching up. Most of Jet Brains' tools are amazing, but it took them a decade of refinement to get there. If I can't WebStorm, then Atom is my go to because it still has a far smaller footprint than most other IDEs.
RegExpies
React in general, but naturally it depends on the places you're applying to. If the company uses Angular obviously that will garner you more points. Lots of large companies are moving towards React though and it's the more exciting technology as of 2016. It's also the direction front-end development is heading (for instance, Angular 2 definitely got some inspiration from React). I'm not seeing enough excitement for Angular 2 to warrant investing your time in it at this juncture. Vue also seems to be really picking up steam. In the end I doubt most companies are really going to judge you too much on *which* frameworks you have experience in, but they will probably like to see that you have experience with at least one of them.
I think Meteor is worth looking into, even if its just as a build tool, which is what it seems to be moving towards(ish). There were a lot of really cool features that were added in version 1.3 that make it more in line with the rest of the javascript world with adding the ability to use NPM packages. It's also also ahead of the curve at the same time with native support for ES2015 modules, and ES2015 support in general. The Meteor team is also working on a project called Apollo that brings the reactivity of Meteor to GraphQL, meaning you can use pretty much any data source you want and it will work in real time, if you want it to. This also means Meteor isn't really even tied to MongoDB anymore. In the end I think Meteor is pretty awesome. It started out as a very opinionated full stack framework, but has evolved slowly (perhaps a bit too slowly) into an easy to set up all-in-one build tool for full stack javascript apps. The stack used to be Meteor as the server, Blaze as the front end and MongoDB as the database. Now its moving towards Meteor as the server (with the ability to add onto it with any NPM module), choose your front end (React being the most popular) and choose your own database (as long as its supported by GraphQL). 
yea theres a couple options save in the client but this only works for that one persons browser: localStorage.myDataKey = JSON.stringify(data) //then on page load: data = localStorage.myDataKey save to the server (have to write your own, but gas probably has one): saveToServer(data,success,fail) or read from the server every page load using document ready (may require save to server also): window.onload= function(){ ... } //or jquery: $(function() { ... } ) maybe that helps?
Typescript's support for privacy only extends such that private fields do not show up in their public type definitions and thus code completion. The fields are just as accessible as anything else.
Mongodb is in the name for MEAN, but i wouldn't say it's unequivocally BOUND. Anymore it's more of an abstraction. LAMP = Linux, Apache, &lt;open source relationaldb&gt;, [php|python|perl] I've seen that MEAN has come to be defined as being about "using JSON across the board" than tying to absolute specifics. Redis? Fine. React? Sure. Then again, that's what I've come away with from the things I've read over the past yr or so.
Consider using [Read the Docs](http://readthedocs.org/). Your documentation stays close the code and can be easily exported to other formats.
Yeah it is scary, but people already abuse JS nowadays. Lots of parallax sites out there max out the CPU on one core, which makes my poor laptop's fan spin up in overdrive to pump all the hot air out. Actually I don't mind, it's how I keep my family warm in the winters.
Seems pretty obvious, but have we stopped to think how powerful the documentation really is when building a JavaScript library? If a limitation is not documented, the damage is much bigger, right?
You can get Intellisense for packages/frameworks such as Angular via [typings](https://code.visualstudio.com/Docs/runtimes/nodejs#_intellisense-and-typings).
Yeah. I will still try it out. It does look interesting. 
Meteor sounds like a nice idea. A full stack framework in same language is quite intriguing. But it does have its problems. 1. meteor only support mongoDb. However mongoDb is quite shitty and most of the app data is relational, not documents. 2. ~~no support for npm~~ until quite recently, meteor has no support for npm. FWIW, They have improved in this area 3. Frontend hell. Meteor's official view layer was blaze which is deeply integrated into meteor. Then they added support for angularjs and react. Now the community is fragmented on which js framework to use.
This is a *terrible* API for your typical JavaScript developer. Far too low-level and difficult to use. I don't doubt that someone will build something useful on top of it, but good grief. The Web Worker API may be lower-performance, but I'd rather see effort put into improving that, rather than adding this primitive companion. 
I'd happily accept a pull-request. Any interest?
The last option is the best option - minify yourself at the end of your build process. Firstly, that browserify pipe command is a bit off - in your version, bundle.js will still contain the unminified code :P - I think you mean `browserify main.js | uglifyjs &gt; bundle.js` - hopefully you got that part right IRL :) Then I realized (never knew this before but) apparently `uglifyjs` and `uglify` on NPM are different, and I've always used `uglify`... I would assume they are equivalent but time to test. I made a file that `require`s `lodash` and `jquery`. `lodash.min.js` is 67.9KB and `jquery.min.js` is 86.3KB, so I'd expect a bundle size of ~154.2KB. When I run `browserify main.js | uglifyjs &gt; bundle.js &amp;&amp; wc -c bundle.js` I get 270.4KB - surprisingly, significantly larger. `uglify` strangely doesn't allow piping, but `browserify main.js &gt; bundle.js &amp;&amp; uglify -s bundle.js -o bundle.min.js &amp;&amp; wc -c bundle.min.js` gives me 154.2KB - right on the money. So I guess the answer is - use `uglify`, not `uglifyjs`. Edit to add: Also tested to see if this affects their gzip compression ratio. The `uglifyjs` bundle is 71KB gzipped and the `uglify` bundle is 54KB - so the same advice still applies, though the difference between them isn't quite as big.
`istanbul` which is a popular code coverage tool uses `esprima` and `escodegen` to its job. There are a few blogs out there on how to use those two in conjunction. 
Try this: http://stackoverflow.com/a/21037523
You can use a factory instead of a class if you want "private" against programmatic introspection: function createFoo(secret) { return { encrypt (text) { // implementation } }; } ---- JS classes is a direct descendant of the ES3 class constructor pattern, not Java/.NET class. ES3 class constructor pattern doesn't have private properties. Also in Java/.NET, you can use Reflection to read private properties/fields out of an object. In JavaScript, reflection is free/built-in ( https://en.wikipedia.org/wiki/Reflection_(computer_programming)#ECMAScript ). 
Okay Java guy here's how we roll in JavaScript. Look at their example page -&gt; view source -&gt; take the code you need (connectWebsocket) http://census.soe.com/ps2-websocket.html Here's a quick example - http://jsbin.com/pehasadenu/1/edit?js,console Need more detail about the SQL upload piece, I'd recommend dumping it in something like mongodb as the easiest way to start.
[How does this compare to black-screen?](https://github.com/shockone/black-screen)
&gt; I thought that assigning something to module.exports is synonymous with exporting a default function/object/const what have you As per my understanding (someone please correct me if I am wrong), this is not true. commonjs module.exports is a different format than ES 6 modules. The way they will interact with each other is still being discussed : https://github.com/nodejs/node-eps/blob/master/002-es6-modules.md. Now, babel does this by defining a "default" field on exports object for the default export and uses that when you import it. So to make you test work you would need in you App.spec file something like "require('../js/App').default" but not sure why you cannot use import here also.
[removed]
A lot of libraries contain debugging code that is only stripped when `process.env.NODE_ENV` equals `production`. Was a while ago that I used browserify but it shouldn't be too difficult to fix. Probably want to use this: https://github.com/hughsk/envify
Your test file is using `require`s – specifically requiring your `App.jsx` file, which is exporting via a ES2015 `export` via Babel. [Babel doesn't actually copy `export default`to`module.exports` anymore as of Babel 6](https://phabricator.babeljs.io/T2212). You have a few options: 1. as /u/sheshnag said, `require('../js/App').default` (*shudder*) 1. manually set `module.exports`, which as you mentioned works (you can do this in addition to `export default`) 1. use Babel 5 1. use [this Babel plugin](https://www.npmjs.com/package/babel-plugin-add-module-exports) that restores that behavior from Babel 5 1. use `import`s in your test file This behavior is pretty unfortunate, but I've found that it actually comes up in a pretty limited set of scenarios. Generally, you're writing ES2015 code that's run or transpiled using Babel, and may have a mix of ES2015 and ES5 dependencies – all of this works out of the box. You only run into this pickle when you want to transpile a *module* such that it can be `require`d by plain ES5 code. This would only ever happen with an npm module, and this would only affect the module's entrypoint. (For example, the code in your repo is contrived – there's no reason to ever use `require`s in that test file.)
I meant more details about what database you're going to use. Regardless, it's all the same basic idea - choose your database backend, find and install a package for it from npm, once you've set it up change the ws.onmessage call in the example I gave you to write the record to the database. Maybe you should get it working in Java first then look at JavaScript?
If you want to find well-payed job -- use AngularJS. If you just want to be a cool-guy - use React. I have 3-6 messages from recruiters everyday in LinkedIn. For a past six month only couple of times they mentioned React. 99.9% of projects require AngularJS knowledge. Anyway if you have a question 'angular vs react' it means that you do not understand what it is. Angular - application framework, React - view library. Edited: Just for information - i live in Netherlands, maybe somewhere else situation on the job market completely different.
Yes, I can build stuff, but I am bad at maintaining it :)
Not very well, as this is a few days old whereas black-screen is much more mature. It's an amazing project, but I couldn't surface it in GitHub's search, so I assumed nothing like it existed. Still going to continue with mine though.
Nope its Angular :) Angular is so bloated and hard that people have made a business out of writing guides and books for it.
Node has the drawback to be written in javascript which is a pretty crappy language where "0" == 0 either ruby, python or java are sane choice.
&gt; SHFIT + F11
Seems pretty obvious, but have we stopped to think how powerful the documentation really is when building a JavaScript library? If a limitation is not documented, the damage is much bigger. Does it make any sense? 
Instead of Color Gutter use [Pigments](https://github.com/abe33/atom-pigments)
http://www.discoversdk.com/blog/6-best-javascript-frameworks-to-learn-in-2016 fixed link for anyone interested.
I really want to get into Atom, but I just can't get that Remote FTP package to ever work. I guess I'll wait another year and try it again.
Yeah, it was changed in Babel 6 as u/AnHeroicHippo pointed out, and I was was unaware. I changed to ES6 module syntax in both importing and exporting and everything is kosher.
It's not clear from your code what you're trying to achieve. But, yes, you can call document.getElementById as many times as you like within the same function.
Are you able to show me how? I can't find it or figure it out myself. EDIT: Fixed it!
Another useful one is https://atom.io/packages/sync-settings I have so many plugins and specific settings that setting up Atom every time i move to another machine was a serious pain.
you're not my supervisor
How do you know that you're not replying to a minority right now? How do you know how much of the video I watched? How do you know that it's a "bait thread"? You make a lot of assumptions. Protip: Plenty of people, minorities included, are tired of being inundated with SJW nonsense at every turn.
&gt; safe space Do you not see the irony of complaining about your precious conferences being infiltrated by the evil SJW menace?
&gt; proclaiming your own version of reality doesn't make it so. I don't even know what to say. I guess I'll go back to reality now, where everything is perfect, nobody has ever harassed anybody and everybody is nice.
Or you could live in actual reality, in which those things do sometimes happen, but they're not everywhere, they're not everyone's/everything's fault, and don't require setting up a soapbox in every setting.
https://en.m.wiktionary.org/wiki/apropos_of_nothing She describes the relevance quite succinctly. You may not agree, but that's not what the definition includes: a clause for the inevitable reactionary baby opinion. While you're at it, look up "irony". 
Packtpub.com links are banned from this sub for spamming.
Hi /u/jonathanmh, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Because you did not declare the variable explicitly, it is automatically declared in global scope.
The Donald Trump posting history, combined with complaints about SJWs, is a pretty big hint—not unlike the hint you get a few moments after someone farts.
One of the projects I am leading uses React and Redux. It's quite large, over half a year with ~10 FTE devs now, and we do not experience any problems with this combo, neither from a performance nor from a maintainability perspective. But yes, there was definitely some time invested to build an architecture that fits our needs.
I didn't know. Removed the link.
This is the correct behavior. You're not inside any scope (global/local) and assigned a value to a new variable. JS is very lax in regards to variable declaration, the `var` keyword isn't required to declare a variable. When it's omitted and a new variable is declared it's automatically assigned to the global scope, if you're in the browser that's `window` or in node it's `process`. You'll be able to do `console.log(window.hello)` or `console.log(window['hello'])` as well with no errors. Take this example: var foo = 'bar', cat = 'meow'; function a() { var foo; console.log(foo = cat = 'hello'); console.log(foo); } console.log(foo); // What do you suppose this will output? console.log(cat); // How about this? **Edit:** It also help to know about [hoisting](http://www.w3schools.com/js/js_hoisting.asp). Essentially the interpreter runs through the code once and 'hoists' the variable declarations to the top of the block or scope. Then is runs through the code to actually execute it, with your variable declaration at the top.
If you want to turn auto global variable declaration off, start your script with "use strict". 'use strict'; myVar = 'yeeaaah'; console.log(myVar); This will throw the error you are looking for. 
Array.push() is a native JS function that 'pushes' a new value on top of an array. A simple use case would be a first-in-first-out queue, something like a stock ticker reader. Values can be added into the queue with [`.push()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push) and then a parser of some sort could then [`.shift()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift) the first element from the queue.
React in and of itself is not a framework. It's just a view render library. It's like a small piece of a diy-project or a puzzle. This is where angular2 is exceptionally great. They've worked closely with the react team to really take all the great things about react and turn those principles into a full fledged framework. It's really worth checking out. If you're just jumping onto the JS train now, I'd highly recommend you take a look at typescript, especially if you're coming from a statically typed language like C# or Java.
If you're just writing plain .js files (no compilers, etc.) then I recommend adding the following boilerplate to your script file(s): (function(){ "use strict"; var hello = "yeeaaah"; console.log(hello); }()); This puts your script in 'strict' mode (so you have to declare variables with var) and only applies that mode to your script, not to all other code on the page. It also keeps your variables locally scoped so they won't clash with other scripts.
Vue
I don't mean to be a dick (and plenty of other people on this page have already answered your question, but the single most useful lesson to learn when you're learning programming is [this one](https://www.google.co.uk/search?hl=en&amp;site=webhp&amp;source=hp&amp;q=javascript+push+function&amp;oq=javascript+push+function&amp;gs_l=hp.3..0l2j0i22i30l6j0i22i10i30j0i22i30.1682.4113.0.4219.24.18.0.6.6.0.135.1224.13j3.16.0....0...1c.1.64.hp..2.22.1236...0i131j0i3.WU326bZ252w). You know the keywords to use and you know what you want to know, so if you want to develop as a developer google should always be your first port of call - learning to self-educate and search for answers to the questions you need is a vital skill in programming - on par with learning to actually write code. Just avoid W3Schools in favour of MDN, because W3Schools is unreliable and often teaches bad habits.
Please stop trying to enforce concepts from other languages on javascript. LEAVE JAVASCRIPT ALONE!!!
Have you tried it with `new`? As in: var nightmare = new Nightmare()
Just tried it, still the same. Actually I think I may have failed to properly install Nightmare, as the npm install nightmare now displays an error in red about not being able to find the Windows SDK 8.1
https://github.com/conorhastings/match-default
Ah yeah, I know Electron has some challenges on Win/Linux at times. What version of node are you using?
The JS involved in parallax animation isn't likely very heavy.
Sorry, that was a mistake on my end, not sure where I was going with that. You're right, you're always in a scope. In OP's case, he was in global scope.
Looks a lot like the 'default parameters' behavior that is new in ES6: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters
no i mean like, for a major/intermediate project you don't just put that as simple as it is. There's a more complicated purpose.
I'm making a liberal assumption that the code you're showing above is your *'brouillon.js'*. The red flag for me would be that you're attempting to execute the file using PhantomJS, with the command: phantomjs brouillon.js Unless you explicitly intended this to be run in the PhantomJS engine (which is very, very strange, especially as Nightmare uses Electron, not Phantom), you should be executing the file with: node brouillon.js This will use Node rather than Phantom to run the code, which is what Nightmare expects. The errors you're getting, regarding *http*, *events*, etc are about Node inbuilt modules, that Nightmare is trying to require.
thank you for explaining this!
I don't know why I wasn't using developer.mozilla.org for reference in the first place. But thank you for pointing this out for me!
Alright, I'll do that... thanks a lot. (also yeah I wrote the command wrong in the post, lapsus heh)
something like this: https://www.npmjs.com/package/node-ssh
&gt; There's a more complicated purpose. Is there? It's a very basic function. It adds something to the end of an array. AFAIK there really is nothing more to it. 
Something something premature optimization mutter mutter. TL;DR use JSON until you know that the datagram is your bottleneck.
This must be a joke; looking at the source code and the author's history...
This very clearly demonstrates that your code works so you must have some other issues with your page. https://jsbin.com/lubiboquku/edit?html,js,output
I just dropped this into a quick mockup, typed '1' in the field and got redirected as expected. Have you included jQuery on your page?
&gt; messageUser(userName).run((error, result) =&gt; ...) &gt; We achieved composability and avoided callback hell without resorting to Promises. Check out the full example here (JSBin). Uhm... &gt; Promise(messageUser).then((result) =&gt; ...) Yeah OK. So the author figured out to implement Promises. Good job! &gt; Callback and Promise are Monads OK thanks for pointing that out... &gt; Proceeds to give an entire FP run down OK thanks for clearly explaining an entire paradigm in an article where you are trying to explain why composability rocks. You have completely lost my interest. &gt; In conclusion: Composability is the essence of any solution to the callback hell problem. ... You had to throw a ton of types out into the article to say that? You go out of your way to explain FP but then bring up Kleisli Categories and don't explain anything. This is confusing for readers, especially ones you are *just* introducing to FP. I don't expect anyone except intermediate FP programmers to understand this article. Hell, I consider myself between beginner and intermediate and it feels like you just went off the rails near the middle/end. This would've been great if it was concise, simple, and with a target audience in mind.
You need to include jQuery. http://www.w3schools.com/jquery/jquery_get_started.asp
The app is done. I've profiled. Now I'm looking to optimize. Also your tl;dr is longer than the rest of your post.
Encoding/decoding his structs to &amp; from a binary format (more compact than JSON presumably) would need to be written in JS.
So you can add a number to a string, someone thought it was a good idea. so certainly 3+4 + "" === "" + 3+4 No ? WTF ?
That's just an example. For my game most numbers are between 100 and 600.
javascript is the best option to do client side scripting, all the resources on the web are about it, but it is despite its flaws. If one should always use triple equal, why double equal even exists in the first place ?
If you really want to optimize the hell out of it I think you're going to have to roll your own. Then you can make use of arbitrarily sized values, eg. 6 bit numbers etc.
Exactly. Usually we have to write code to make things.
That's part of what makes my TLDR so good. So I would love to see your data that shows datagram transmission and JSON parsing making up the majority of your app processing. Happy to drink a steaming hot mug of STFU if I'm wrong. 
this part of ithare series is especially relevant http://ithare.com/64-network-dos-and-donts-for-game-engine-developers-part-iia-protocols-and-apis/ (the whole serie should worth reading )
if you just are learning javascript, then a frame work is not really the right place to start. 
Because sometimes you don't care about type? You should know, as a good programmer, when those instances are. Why does having more options make it a "bad language"?
Food for thought regarding client side buffer / processing - https://hacks.mozilla.org/2016/05/a-taste-of-javascripts-new-parallel-primitives/
Yeah I am in the very very beginning stages of learning JS so I haven't even come across that yet. But thanks for the info, I'll keep this in mind.
Reading the source? 
Looking at the [typescript types](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/threejs/three.d.ts) may not be a bad substitute.
You can try following the "inherits" link - somewhere along that chain the methods/props will be listed. 
Very interesting to hear. So you were not actually parsing? You were parsing JSON and then encoding to ArrayBuffer was taking 10ms? If I am not understanding correctly, which method of parsing binary did you use? I was mostly talking about parsing an array of objects with strings and numbers as keys.
Hooray for my [favorite framework](http://vanilla-js.com/) !
Atom? I prefer to use an editor that alow non US Keyboard to use alt gr on windows, to type characters as overrated as '[', '|', or '@'. A gigantic issue is open since 2014.
Like they have for every other piece of technology ...?
Wow, after this I'm definitely going to have to check out VanillaJS! 
+1 for MDN. As far as singular sources of information regarding web development go, it is far and away the best.
Cute to use the old Mac OS FTP client icon.
We're making the world a better place.
Because someone once told me I was a bad programmer for using for loops and I took the joke a little too far.
Rather than attach a property to the global scope, you can simply set the outer loop's control variable to the outer array's length before the break statement.
Also, glimmer components haven't really landed yet. Once that hits, gunna get that sweet dom diffing perf bump.
Yeah, that sounds accurate. I was sending a Kinect depth field (800x600) as a JSON array, but running JSON.parse on an array with 480000 elements 30 times per second was quite taxing. Sending it as an ArrayBuffer (which is what I wanted in the first place) was unsurprisingly dramatically faster.
 var color = 'red'; var switch = { red: 'The color is red.', green: 'The color is green.', blue: 'The color is blue.', }[color] || 'Who likes colors anyway?';
React and Node are not mutually exclusive. Both are popular within the web development community and both a good to at least have an understanding of.
Like some one else mentioned in this thread, your best resource is Google. Sharpen up your google-fu skills. You can also sign up to some paid sites, like pluralsite (idk spelling, on mobile atm) or frontendmasters. The later has some really good workshops for a range of Javascript topics. But to be honest, the best way to learn is by failing... Repeatedly. Think of a project, doesn't matter if it's done before, and start coding. Fail, rinse, repeat. Just make something and compete it. Then go back over it and see where you can improve it. If you ever need help with anything, PM me. I won't give you the answer, but I'll ask you the right questions that will get you to come to the answer yourself.
Associated blog post http://www.stefankrause.net/wp/?p=301 
Both
Those are not at all the same thing. Node is a platform for running Javascript programs outside the browser, same as you need the JRE to run Java, the Python runtime to run Python code, etc. React is primarily a library for organizing UI code. It can be used no matter what the backend server is built with, although it's certainly common to see servers built with Node serving up React client code.
Not at all. Unlike you SJWs, I don't have emotional responses to posts.
That's precisely they problem, XMLHttpRequest is not designed for rational human beings.
Why? Because it's not using jQuery?
https://yakovfain.com/2016/01/03/why-java-developers-will-embrace-angular-2-and-typescript/
What Acemarke said. React is just your view layer in your [MVC](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller). I'd suggest getting to grips with javascript &amp; node, then take a look at React.js :)
It's even worse in Android, so yes.
It's a low level API. It's one of those things that basically requires a wrapper of some sort to retain some level of sanity. Since you already need a wrapper, why not use a nicely polished one like jQuery?
espresso.js
No rational human being does that.
https://github.com/facebook/react/pull/7232
See the spec for details (This shim does not fully implement it) https://fetch.spec.whatwg.org/ The request object has a mode called "navigate" if you intend to make the request in a way which emulates the browser navigation rather than as a raw GET request. If you just want to bring the cookies along for the ride you may set a property separately to inform it to do this. Fetch is a granular api and intends to support raw GET requests directly like a proper application not tainted by browser concepts unless you wish to use those. 
So Aurelia isn't faster than Angular 2 like Rob Eisenberg claims...
If that's *really* what you want, Google's Closure library is basically Java in JS in terms of type-checking, class infrastructure, and a comprehensive standard library, although honestly I think you'd probably be better off just learning the proper way to express things in JS. If you wanted to learn Italian, you wouldn't try to learn a bastardized English/Italian hybrid--you'd want to learn proper Italian with all its stylistic idiosyncracies and idioms. Projecting the patterns of a very different language you already understand onto another is not the way to get the most out of it. Forks are great. Spoons are great. Sporks suck. (IMHO)
Yes. Just like we know success on status 200 etcetera etcetera. It's part of being a developer.
Please. JQuery has nothing to do with this.
I have never understood the desire for interfaces in a dynamic language... am I missing something? What is the need for interfaces when you already have dynamic typing? I would think just picking and sticking to strong method naming conventions would provide as much benefit as having interfaces would in a language like javascript.... Say you have a function that expects a dog as an argument, and then calls the dog's .eat() method.... if you pass in a cat instead of a dog, you will still be able to run the .eat() method on that cat... there is no need for an IEater interface to allow you to pass in any object that implements IEater, when you can already pass in any object that has an .eat() method on it and it will work just fine. Can someone please clarify what I am missing here? (I ask because time and time again I see people coming to javascript that want a way to use interfaces in javascript, and i feel like because of how common I see the request, there must be something I dont understand about interfaces that leads to people wanting the functionality in javascript)
Sounds like OP just doesn't do inheritance 
I know exactly what you mean. I only code in assembly, writing individual instructions for the CPU, manually allocating and de-allocating memory, etc. If such a thing is "complex", then perhaps software development isn't the right thing for you.
That wouldn't happen. There is a trade off between time for development and performance. Companies would rather lose performance in order to release their product quicker.
The point is to show that there are constructs other than Promises that have similar characteristics: handling continuation + propagating errors. Knowing this we can derive more general constructs like categories. 
Yes. Both.
Elm architecture with Flow + react + redux https://gist.github.com/gcanti/f6258257cb787ff42fb4d64af2c98577
I wasn't aware that was an issue, for me it works fine with altgr
So a chrome performance bug 
I agree, but I think vanilla is only used as normalization baseline. So everything is x% slower than vanilla
Not sure. Maybe check/ask on /r/typescript
[Link to the original article](https://www.symfony.fi/entry/the-javascript-language-reboot-is-done) that this one is reproducing.
And the same thing with async/await is even simpler.
The "new" example does a better job at abstracting what happens underneath, that is why it is objectively better. JavaScript IMO has been getting better. Combined with tech like TypeScript it is becoming more "industrial", which is great to me!
Cool, I wasn't aware you could chain `then`s like that. Although this version doesn't check if the status was ok =P
There's not going to be a definitive definition of a framework or a library. The general consensus tells us that, yes, Frameworks are opinionated to some degree in how code is structured and also tend to have vertical integration points. Libraries/toolkits are collections of tools designed to abstract, normalize or augment your code. &gt; I use frameworks, but I really like vanilla javascript A framework shouldn't prevent you from writing javascript. A framework should prevent you from writing annoying javascript. For example, consider the heavy-lifting you get from Angular or Vue when it comes to two-way binding. You could do it yourself, but ain't nobody got time for that...
I'm sure you have probably wrapped the raw XHR in a friendly helper function? That's part of being a developer too. 
You cannot abort a fetch though.
I understand what you mean. I am really using MDN to my advantage now. Thank you for the PM offer that means a lot for a beginner *beginner* like me :)
&gt;the two that seemed the best for my project were ReactJS and AngularJS. you must have quite an exotic project that the top 2, of you best choices, are polar opposite in terms of philosophy and architecture and rest. :P &gt;more valuable experience-wise vue.js Experience-wise, everything *--you learn now--* will be obsolete in a year. so it is better to learn a technology which is easier to learn and start hacking some apps. Vue.js is smaller and easier to learn. while angular 2 has a big learning curve and react makes you learn a completely different paradigm(functional programming) &gt;look best on a resume or down the future? angular 1 and react For anyone who is not js savvy, angular and react are the only 2 js framework. Note: while angular 2 is new, most jobs will ask for angular 1. 
EXACTLY! I don't understand why people think XHR without a wrapper is so difficult.
No it's not. And if anything it's only one or two lines over the jQuery version. That beats having to send jQuery over the pipes.
I'm not sending jQuery over the pipes just to use its ajax method.
Checking for the condition `req.readyState === 4` is definitely on the same caliber as programming in assembly. 
Please note that cycle.js v7 does pretty well.
Maybe there are some improvements that I overlooked. I've received a pull request for the aurelia benchmark. If it helps I'll publish an update soon.
https://github.com/krausest/js-framework-benchmark
That's not true, the promise returned by `fetch()` only rejects if there is a proper network error or the connection itself doesn't get established. No matter what the status code is, it'll still resolve. There's nothing wrong with returning JSON in the body of a 500 for instance. If there was a 404 with no JSON, your example would just throw an exception because `json` would be `undefined` so `undefined.filter` would be non-existant.
Lol seriously? Was JQuery your first language or something?
/s obviously. This is fucking sad. We're in /r/javascript and the only comments about the JavaScript TM* way of doing things are downvoted in favor of jquery. You guys obviously aren't systems programmers and it seems like you may not be able to code without Jquery?
Handling XMLHttpRequest is much more than 5 lines of code, unless you're doing incredibly rudimentary things. Even still, you're writing a whole bunch of redundant boilerplate code all over the place. You're free to write your own wrapper if you want, but you're just wasting time. jQuery is not the only library that handles AJAX stuff.
&gt; when you can include leaked properties on that, it will just hide them I'm not sure I'm following you. Could you explain why leaky abstractions are "fixed" by documentation any more than bugs are "fixed" by documentation? If I write an iPhone app that crashes when someone pushes a "Tweet this" button at the same time as content is loading, and I just tell users not to do this with some kind of helpful text, have I "fixed" my app? I'd make the same argument for an API that exposes a trim() method that behaves different based on the browser on which its running. Sure, it's best to document these things, but better would be to actually contain the leak and implement consistent behavior. So I maintain the "document it" argument isn't specifically relevant to leaky abstractions any more than it is to any other coding issue...
I actually find callbacks very manageable with observable streams, just as easy as promises. Code ends up just as comprehensible.
Once again we see this medium guy has no idea what hes talking about.
A complete AJAX call, with data body, and error and success handling, and line breaks is 6 lines. No redundant boilerplate required. Look I've got nothing against jQuery. Yes any programmer worth his salt will abstract it away into a function, in the realm of JS frameworks nearly _everything_ is abstracted, and that's cool! &gt; jQuery is not the only library that handles AJAX stuff. Agreed! So use one of those if all you need is AJAX! I'm not discrediting libraries or wrappers, if you find the XMLHttpRequest stuff daunting, use an _AJAX_ library. Using Jquery for that situation is like not being able to decide the shoes to bring camping, so you bring the whole damn department store instead. There is a special place in programmers hell for including the entirety of JQuery in order to accomplish a single AJAX call.
"packet management" does he mean package?
Thanks but no, thanks. Since we moved on to Purescript, descending back to javascript sends shivers down my spine. 
try `$('#main div:last .btn').hover(...)`
I'd be interested to hear how you build the frontend in purescript. Have you looked into Elm? What made you choose purescript?
Hi /u/qpbp, please submit links using the "Submit a new link" option. Thanks!
What's promise hell? Is that where you try to use promises without knowing how they work?
Isn't that a convoluted API then , compared to jquery, or any XMLHTTPRequest wrapping library? Do you feel superior now that you're able to write less clear code just because you can?
Thanks, dude!
Absolutely. Even after using arrow functions for nearly a year, I find them much more difficult to comprehend than the non-arrow version. The only two benefits that I can see are THIS and fewer characters to type. But the create a code comprehension and maintenance nightmare. 
Yes, IMO it is cleaner. I could explain why I think this, but judging from your sarcastic tone that probably won't help much, or be a useful discussion. So let's just say different strokes for different folks.
It looks like videos from thenewboston.com
Only someone who just started programming in JS would be naive enough to write an article like this.
There are a handful of libraries, usually surrounding interfaces, that have to handle many cases, and often enumerated codes are the best method of handling that. The keyboard API is another example. Http requests have lots of status codes that require a quick reference, javascript has a status code as well.
Imo, this is still far superior to the nested pyramids, full of cruft, that would be necessary to do this otherwise. If you come from a FP perspective, it's almost like a type signature itself, and makes it very clear how the function is meant to be called.
I don't know if this is your site or not. If it is you may consider adding [these design pattern videos](https://www.youtube.com/playlist?list=PLF206E906175C7E07) to your advanced Java section.
I got rustled, I admit it. This was a sanity thing.
This is my biggest problem with the JS community currently. I don't know how to say it without sounding like a dick but I wish people would stop writing strongly worded posts about JavaScript unless they're veterans. Good: "I learned how to use this cool tool, check it out!" Bad: "This is the future everything else sucks!" What's funny is that aside from a few exceptions the tool creators and "famous" devs never do this. It's always noob to medium skill people who seem to want fame more than anything else. Compare Dan Abramov with all the posts about how React/Redux are the only good choice and if you don't use it you suck. Don't get me started on all the "functional JS" posts are are just map filter reduce + couple of copy and pastes from Ramda docs and random claims about how OOP is the devil. We definitely need 100 of those. Rant over : )
Yes, very possible. Check out phantomjs.
&gt; There is a special place in programmers hell for including the entirety of JQuery in order to accomplish a single AJAX call. And where did I say you should do that? jQuery is already present in like 90% of the shit that I work on. My point was simply to use a library to skip unnecessary code and to not repeat yourself.
I actually noticed that as well when I editing and removed it; that was a remnant from a previous idea I had to solve the issue. That being said, I was finally able to solve the issue! It isn't the prettiest solution because of the , but here it is. I would love to know if you have any ideas on how to clean up the hover so I don't have to explicitly list each unique id. http://codepen.io/phantomMountain/pen/jAGLkx
Agreed. JS, and other parts of the web world in general is the only area of software development where you get people thinking that they have these amazing insights after a year of programming *anything.* I was utter shit for years and years after learning any new realm of software development. I'm still not an awesome JS dev, I prefer other stuff but I'm fascinated by it. And yet I wouldn't be arrogant enough to write an article about JS because I have seen the guys that are good and they're way fucking better than me.
I meant a object created with the "new" Keyword, a constructor kinda like var foo=function() { function bar() { //statement } } var test=new foo(); foo.bar(); "error" hope you could give me some insight on why this is not accessible? :)
The place I find it more readable is in functions like `map`, where something like... arr.map(thing =&gt; thing * 1000); reads as "map `thing` to `thing * 1000`". I do agree that it can be less immediately readable or intuitive in other cases like object methods or general-use callbacks, for instance.
Inside a constructor (a function called with `new`), the new object being created is known as `this`, and to attach properties to this object, you need to define them on `this`: var foo = function () { function bar() { // statements } this.baz = bar; // object property name does not need to equal function name }; var test = new foo(); test.bar(); // no error, also method is on the instance As I was typing that up, I noticed you tried to call `bar` as a method on the constructor, `foo`, instead; this is known as a "static method" and to make it work, you need to explicitly define it on `foo`, like `foo.bar = bar;` (works either inside or outside the function). With all that said, it's a better practice to define both instance methods and static methods outside the constructor, like var foo = function () {}; function bar() {} function baz() {} foo.bar = bar; foo.prototype.baz = baz; // one copy of the function object shared by all instances so that you don't make new copies of this function every time you run the constructor. As another link posted in this thread shows, the *only* good reason to define functions inside a constructor is to emulate private methods. --- Another way to put it is that functions defined inside other functions (whether constructors, methods, or ordinary functions), and not attached to an outer variable or to the function's return value, are indeed private. The way the title was worded was confusing, because functions defined on an object initializer aren't private for values in the same scope as that object; ES5 and earlier only recognizes function scope (except for the corner cases of `with` and `catch` blocks), and ES6 and later also have block scope, but there is no "object initializer scope".
I don't understand the attitude that some devs have about using libraries. As if writing your own code is somehow superior to using code that is already proven and tested. The *feeling* of being a "good developer" somehow outweighs the huge benefits of having code that you already know is as bug free, secure, and cross-compatible as possible, having been through the open source meat grinder for a long period of time. I get that loading the entire jQuery library just to make an AJAX request is overkill (though in most cases your end users probably won't even notice if you do that), but there is nothing wrong with something like import { ajax } from 'jquery'; to do your XHR requests if that's what you feel comfortable with.
JavaScript is a general purpose dynamically typed programming language. The argument ends there... People have written GBA emulators to NetBSD rump kernel to embedded products. If JavaScript isn't a real language then by that definition neither is LISP.
Why do you care? You do you
I do know other languages, I just prefer Javascript. What's wrong with being obsessed? If I understand correctly, specializing isn't always a bad thing.
I think that in the example you gave that yes readability does suffer. And readability is important to me when I have a team of developers with varying degrees of competency in JavaScript and ES2015. Arrow functions are great for quick returns, great to preserve context, beyond that I prefer the explicit nature of a function declaration / expression.
It's like hiring an entire construction to install a light, they would get it done, but you can save a lot of money and time with just one specialized guy. Money == bandwidth and time == processing cycles. Load times are important in web development, and jquery is a pretty big include.
The "toy language" argument simmered out quite a few years ago in my experience. I've noticed particularly in the last year or two an increasing interest in learning JavaScript from my C#, Java and PHP specialising friends. Most seem to really enjoy it.
so essentially they are really just asking for a statically typed language? in that case, shouldnt typescript give them exactly what they are asking for?
I embrace libraries, good developers don't shun libraries. &gt;I get that loading the entire jQuery library just to make an AJAX request is overkill This is what i'm arguing
I'm not sure about angular because of element functionality, so it might need a browser to run, but typescript itself looks good. Not being a huge Microsoft guy ts seems very Java inspired to me :P
Ask the two main questions for any philosophical difference: 1. What do you mean by 'real language'? Don't assume, listen and address their specific problems. Or, if the problem they have is legitimate, either acknowledge it as a limitation just as many things are limited, or point out the similar failings in languages that they hold in high regard. 2. How did you come to that conclusion? Many people hate things for illegitimate reasons. If they tell you the reasons, you may point out how silly or unrepresentative those reasons are. They might not even realize. In all this, be calm and kind. You're not going to change someone's mind with sneers or anger.
This is the typical mentality of programmers, my language is better than yours. You are just buying into the same thinking. Its a tool, not a part of your personality. Anyway C# is far better than Javascript.
This depends, can you create a windowed application? This gives you access to the `webview` tag. Are you familiar with background scripts and content scripts and the limitations of those? The background.js file which does cross domain Ajax would use the `message` API to pass that result to the content script. The limits of the Webview is that you have to create a windowed app. The limit to the Ajax solution is that you won't be able to run cross domain JavaScript without wrapping the output of the script in your own function. This means tracing the XHTML request and wrapping that. If those solutions are a problem for you. Run a headless browser on a server and use Ajax to send your requests to that.
Can you demonstrate a perceptible difference between the too approaches?
I'm afraid you missed the point. Fetch is designed as an improvement over XMLHttpRequest by abstracting out parts to make it easier for people to use, reducing the burden of knowledge, etc. Yeah it's not hard to check that ‘req.readyState === 4`, but: a: What does 4 even mean just to look at it? It's a member of an enumeration sure, but someone new looking at that wouldn't see that it means the request is complete and the body is ready to read. b: If 9 out of 10 times you don't give a shit about the other readyStates, why does it need to be there at all? Abstract it out. And that's the point. Part of software development is trying to make things easier for other developers, reduce the burden of knowledge, like jQuery did, like fetch is doing. Saying that rational people would only ever use XMLHttpRequest is a bit like saying that only idiots ever use libraries, abstractions, anything to make their lives easier, and your condescending attitude on the matter is rather insulting. Software development is about building things, about figuring out problems and making tasks/lives easier, it's not about who knows the most shit which realistically speaking should be abstracted out. If it was, then fuck everyone should just be writing in binary, no point in trying to do anything better.
&gt; the only difference is that JQuery detects the status codes for you and calls the appropriate functions Which is why I still like jQuery Ajax rather than rolling my own solution. That and jQuery receiving the data as an object and serializing it correctly, and then deserializing the response as well.
Thanks, I didn't know about MicroJS.
Is it that big of a deal? This is a JavaScript community on the Internet not an academic paper.
It is.
&gt; I wish people would stop writing strongly worded posts about JavaScript unless they're veterans. https://en.wikipedia.org/wiki/Argument_from_authority Being a veteran or well-known doesn't mean that you're right about everything. I disagree with some of Crockford's opinions, for example. But I do of course also agree with some of his views. Now, the great thing about opinions from non-authoritative people is that they have to work much harder to convince you. You also won't as easily agree to obviously false conclusions, because there's no perceived need to conform.
Yea, hit the lawyer in the face and gym up!
Your comment lacks critical thinking. Don't default to JSON because of a blind adherence to Donald Knuth's quote. Sometimes JSON is the wrong format, period, and using a different format is not a premature optimization. We might as well state to use XML for the same reason, following your line of reasoning.
Maybe `const json = await fetch('https://jsonplaceholder.typicode.com/posts').then(res =&gt; res.json());`? 
Not to sound like a dick, but I stopped reading at "catched on."
Good eye, thanks.
Interesting...
&gt; Angularjs &gt; &gt; Languages: C, Java Script Eeh, no.
&gt; what is with all the medium articles from people who have just started their Javascript careers? Because the rest of us are too busy actually accomplishing things in the language to take time to write articles.
&gt; but now those days are over They absolutely are not over, nothing has been removed from the language. The only thing making people use all these complicated systems are social pressures. The only person you have to blame for losing simplicity is yourself (or your team, if they're the instigators).
Javascript never needed a reboot.
I agree, and I'm a beginner who only started making websites for money a few weeks ago. This is just confusing. As a beginner I've often be influenced by people who, in the end, were arguably misguided. Also I don't get this guy. I think he's wrong on lots of points.
Nah.
~ 86KB of shit?
&gt; would recommend against doing more than one level of destructuring assignment at a time, even though it's possible to nest that infinitely deep +1000 I *fuggin love* ES6 destructuring but I've been seeing my coworkers tempted to do this (even just one extra nesting deep) and I've had to be very adamant in CR about why I don't think it sets a good precedent. If you go two levels deep someone new to the codebase might come in and think well I can go *just one more* this *one time*. Then someone else repeats and goes four... oof... until I can enforce with ESLint the exact level that is okay I'd prefer to keep it simple. **Edit: Forgot to say, great explanation too**
right, thanks for the correction, our mistake , now fixed
This is exactly wher arrow functions shine! The syntax is wayyyy easier to understand then nested returned functions. I come from a math background and it's very reminiscent of the syntax used in upper level analysis classes. With arrow function I can tell at a glance how a high order function behaves compared to struggling through a chain of function calls
Cool, thanks.
Callbacks aren't bad because of "callback hell" and the "pyramid of hell", it's about inversion of control and the [trust problem](https://blog.getify.com/promises-part-2/)
It is their site. The only posts they've submitted are about penciltree. 
I get that, I like JQuery too, but the context was general XMLHttpRequests, and I guess what I hated was people calling a simple native example convoluted
no problem, it's super useful now that there are a million libraries that do similar things, slightly different ways. Let's you find one specific to your needs without cruft.
agreed, it's that abstraction that makes utility libraries so appealing, nothing wrong with it.
Well, if you want to use a library, it is best practice to use one specific to your needs, rather than a "kitchen sink" approach. I like to use MicroJS.com to find JS libraries, it shows packages like MicroAjax and NanoAjax at just 0.4k and 0.6k, where Jquery comes in at around 86k.
Maybe it's just me but I feel like these snippets are great excuses to learn more alternative design patterns. I know I have a hard time drawing the line between flexibility and readability with my team. I tend to think everyone in development wants to go further down the rabbit hole like I do. But maybe I'm taking your comment in a negative context when it's really a sound choice, considering I'm currently dealing with a team member trying to keep their head from exploding when looking a typescript for the first time lol...
Yeah, I'm with you there. I've created a 'queue' wrapper to abstract away the nesting. The monad is a pretty great pattern. I had a complex animation I was doing where I was nesting inside the `complete` callback. The `queue` flattened that out beautifully.
&gt;a: What does 4 even mean just to look at it? It's a member of an enumeration sure, but someone new looking at that wouldn't see that it means the request is complete and the body is ready to read. You could just use XMLHttpRequest.DONE instead of 4 if you don't like magic numbers. I do agree with your part (a) otherwise, but it's immaterial with this constant. As for your other points, I understand the necessity to abstract some things away, but XMLHttpRequest? *Really?* Also, I understand if you're using jQuery already you might as well use jQuery.ajax but using a library like Fetch or even jQuery just to "simplify" making XHR is a little excessive, IMO. But that's just me.
The language just needed a critical mass of "missing" stuff to be implemented. I bet you this leads to significantly fewer "UGH #$*$ THIS" moments that may have led to someone trying to build another abstraction layer over something because the vanilla method was awful and the most popular alternatives still just weren't quite enough. I've been delighted at how little lodash I need and how my Webpack is under 100 lines for once. My standard scaffold for a React app seems to be getting simpler and simpler.
[I dont think so](https://www.reddit.com/r/javascript/comments/4s679v/how_to_make_an_ajax_request_with_javascript/d575g64)
yikes 
I tried your example with disabled cache and DSL throttling in devtools, and the actual request time for both apps were the same (~700ms), but it took ~300ms extra to load jQuery.
Thanks for fighting the fight, it must be hard modding this sub. I love JS and wish we could get some more unique, quality content on here.
Nope. That's precisely why async await is so awesome.
That's what has made the JS community get such a bad reputation in the rest of the software dev community, it's like the blind leading the blind via buzzword. I swear to god I think all the buzzwords just get passed around and used because of new people exposed to them via camps and thinking they're really important terms to know.
&gt; the blind leading the blind via buzzword Haha it's the perfect description. Some concepts make sense when you try to grasp what the vanilla code does. But sometimes it's just fancy words.
Totally agree. Adding so many variations to a single new feature is nuts. This combined with the spread operator, "enhanced" object literals and the destructuring variable declaration insanity has set the language back 15 years in terms of clarity and simplicity. Optional language features and syntax only appeal to the most pedantic geeks who love to brag about how compact and "clever" their code is. "You don't understand this? Huh, I guess you're not at my level... " ES6 has transformed a generally accessible language into a nightmare of complexity and maintainability. I predict a serious dropoff in interest in the language relatively soon as a result, as devs look for a less obtuse alternative.
Yeah, it's true that for most connection cases it doesn't matter, but it's the edge cases that matter most, and I think it's a sloppy mindset to not worry about it, especially in the mobile-centric age. There was that post recently about the forced Windows 10 update costing some facility in South Africa hundreds in bandwidth fees. Thats an extreme example but I think it's extreme to jump for jquery for a single task. 
As much as I do think the new JS features are cool, I agree with you that existing functional programming languages like Haskell, PureScript etc. are a million times more fun to work with.
I'm not 100% sure what you're trying to do (too many beers on me at the moment - it's summer vacation time here:) but perhaps this is helpful... function foo() { var x1 = function(drink) { return (drink || '').split('').reverse().join(''); } return { x2: function(drink) { return x1(drink) + x1(drink); } } } var foobar = new foo(); console.log(foobar.x2('beer')); // =&gt; "reebreeb" console.log(foobar.x1('beer')); // =&gt; TypeError: foobar.x1 is not a function ...then again, maybe not :) ... learn from this - never drink just one :D
Personally I don't care to use jQuery for anything at all. DOM manipulation is both simple and expressive in vanilla JS, and for XHR I'll use something like axios. And I agree that loading up jQuery for a single task is extreme. I just think some people exagerate the actual impact of library overuse. Why do edge cases matter the most? By definition they are the cases that occur the least often. Is it worth the extra development time and effort spent catering to them? Sometimes, maybe. But I think I'd rather spend that time creating the best experience possible for my main target audience.
No, default to JSON because it is a serialized data format that has built in support. Rolling your own over the wire data format in JS still seems like hubris and premature optimization. Don't equate a bad joke with lack of critical thinking. I considered the possibility that his desire to pack a binary datagram was the biggest bang for the buck in his performance profile. But JSON properly minifed is pretty lean on extraneous tokens, so I am still not convinced that this isn't a waste of OP's time just to gain a potential few milliseconds.
was I wrong to expect the final achieved perf numbers somewhere in the article? o_0
Yeah, this was definitely an overreaction, but I don't think it's unreasonable to support the common edge cases (different/outdated browsers) without busting out jQuery. In fact /u/EenAfleidingErbij posted what looks like a perfectly reasonable solution above, it doesn't look like the best, but it seems to account for a lot http://i.imgur.com/9B933fg.png
It's not ego-driven. It's one of the two suggestions over the last 15 years on how to keep yourself employable: write open-source software and blog. (In the consultant world, the stakes are raised to articles on InfoQ and books.) Most of the time, nobody will read it except the next person to google a name before an interview. However, it's a social signal and it's not going away.
In your example, the bar method is inaccessible because it's not in the same scope. This should work. var foo = function() { function bar() { alert("a"); } return { bar }; } var test = new foo(); test.bar(); 
You make a good point. I'll add some figures. Update: I created a benchmark test and checked it into [GitHub](https://github.com/fergalhanley/asmjs-v-js-bench-test) and you can run it in your browser [here](http://fergalhanley.com/asmjs-v-js-bench-test/). I've added a section to the end of the [article](https://medium.com/vizamp/how-to-shift-your-pixels-which-way-4076c167dc38#.63bvccihx) with results analysis. Interesting points: * asm.js is about 15 times faster than regular Js for this test * discovery that the 'use asm'; decoration is not required for the interpreter to optimise
Hello fellow 20 year programmer. I too find fat arrow bothersome, because the benefit is low and syntax terse. I think its primary effect is as a communication barrier between developers since it requires specific knowledge of the abstraction. 
I don't know anything about chrome extensions but I would first look to see if the info is available via an api. And if not use ajax to get the pages html, then you can either parse the html and get the info, or perhaps load the html in a hidden element and use the dom api to select the data.
This is just an object that writes the complete file to disk on a setInterval call, doesn't even keep the file open and append
I am absolutely fine with arrow functions. In the snippet however I fell confused by variables magically appearing. And that I feel is where we can get deeply wrong. 
Check out [NeDB](https://github.com/louischatriot/nedb) for more complete solution (also can be persistent), big fan of it. It's like SQLite for NoSQL databases.
It's really interesting to hear what the edge team has to say about PWA
I can understand why it seems that way, but I don't think it's about arrogance. It's about youth, passion, and probably above all, [innocence](http://thecodelesscode.com/case/107).
Still, little things like that are what make using a library for AJAX worth it. I completely agree that bringing in the entirety of jQuery just to call `$.ajax()` is ridiculous, but there are very real reasons why many (probably most) people *don't* actually use XMLHttpRequest directly.
Yea but the only way we all learn is by sharing and talking. If we all waited to be masters no one would ever post anything and learning would be that much harder. It's possible to learn something even if it isn't 100% polished. 
ES6 is eally hard to understand if you aren't familiar with it. But so is any language. If you are only a little familiar then the more ES6 the less readable is.
There isn't a plugin system as far as being able to update the nodes themselves before emit, but we do have a [compiler API](https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API) and a [language service API](https://github.com/Microsoft/TypeScript/wiki/Using-the-Language-Service-API) (which you probably don't need in this case). We are examining tree transformations and a plugin system for emit for the 2.1 time-frame. Edit: I should also mention, in the mean time, you can see how combining TypeScript and Babel handles this, by either emitting to ES2015 and letting Babel take the rest, or running with `--noEmit` and seeing if Babel can parse/emit the original TypeScript code, running TS only as a type checker.
You could use setTimeout to render the component in tiny steps. This way, you are not blocking ui since the different steps are all tiny enough to not bother the user. 
For the combo-box though, all that happens is an absolutely-positioned `ul` (representing the options) is changed from `display:none` to `display:block` and its width and position are set accordingly to make it look like a dropdown list. It's a pretty short segment, but when I click the dropdown button, there's a lag before the element shows up.
If the combo box has a lot of elements with scrolling, a simple infinite scrolling system can dramatically cut rendered elements per frame. Have you tried leaving hidden dom elements in the dom and only hiding them and showing them with classes, rather than removing or adding the elements to the page every time? Have you reduced the total number of dom element modifications to the minimal set? A vdom will help here. Have you tried reducing total used memory/object creation? Inline defined objects and simple, pure functions that operate only on parameters passed in use less memory than even prototype-based object oriented style code.
It is a sane default if you deal with CORS or JWT a lot. Maybe they are nudging people away from sessions. 
This dbjsond and neDB are of two different leagues. I think 'embeddable' is a key word here. 
I understood what you said until here: &gt;The way the title was worded was confusing, because functions defined on an object initializer aren't private for values in the same scope as that object; ES5 and earlier only recognizes function scope (except for the corner cases of with and catch blocks), and ES6 and later also have block scope, but there is no "object initializer scope". Can you give some examples to clarify what you're saying? Thanks
The usual v8 optimization killers apply, I guess. https://github.com/petkaantonov/bluebird/wiki/Optimization-killers It's also possible to profile DOM interaction. It, however, sounds like you're trying to shove a large package through a small pipe. Maybe consider breaking down the rendering UI, by doing all the work for the viewport and only the immediate viewport, and then pushing in the stuff that is off to the side later. The chrome profilers are your friend.
Are you suggesting only rendering elements that are visible in the current viewport? But how can I tell which elements are positioned inside the viewport without first rendering them? Also, I've tried profiling, but I don't know how to read and interpret the chrome://tracing output :/
Just to point this out, you realise that fetch is a browser standard and not another library right?
&gt; Are you suggesting only rendering elements that are visible in the current viewport? But how can I tell which elements are positioned inside the viewport without first rendering them? It can be complicated, depending on what your content is, but this is the gist of how windowing libraries work. (I maintain one for React, [react-virtualized](https://github.com/bvaughn/react-virtualized/)). You could potentially try to implement the basic approach using the following for inspiration: 1. Listen for resize events of your container with an approach like: https://github.com/sdecima/javascript-detect-element-resize 2. Use something like `react-virtualized`'s [`CellSizeAndPositionManager`](https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js) to determine which cells to render. *Edit* for formatting and disclaimer: I don't know off-hand, but a windowing library probably already exists that you could use rather than re-inventing the wheel. I just linked to the basic technique in case you were curious.
[removed]
Well node v6 has this built in, so I can say you are kinda late to the party. 
Can you provide an example of good code layout making callbacks not horrible to use?
Cycle 7.0 uses snabbdom instead of virtual-dom, and it shows :)
Well most of my day involves writing Javascript for node.js, so there'll be a lot of situations where an operation requires multiple asynchronous database calls, or to verify something in redis before continuing, and things down the line will depend on having access to the results of previous async operations. If this were to be done using callbacks it would involve a lot of unavoidable nesting.
That is exactly what i meant. Using libraries like react, redux, etc. you have a great power to create architecture especially for your application, but with great power comes great responsibility - if you have no experience in application architecture you will end up with complete mess. In other hand application frameworks like ember/angular - force you to use their generic application architecture. I think that react is great tool, but you have to use it really carefully and only if you know what you are doing. If you cannot explain why do you need redux,mobx,react, whatever you want to use -- you should use application framework. Everything above -- my personal opinion and not absolute truth.
&gt; I predict a serious dropoff in interest in the language relatively soon as a result, as devs look for a less obtuse alternative. or, your know, educate yourself and create sensible coding guidelines.
woops, sorry, how do I remove it?
Delete button :p 
Reading interpretation fail. 
"Confound your lousy toll, troll." Seriously though, well said.
says deleted :P
Yes, I actually have a whole presentation. We run kind of like a start up but but as of 2014, we are technically not, since we became profitable. But the two co-founders are definitely "start-up minded", since their previous start-ups have sold, their last one selling in '06 for $100 mil to Cisco.. I dont think I can link the presentation here, but whoever emails me, I can send it to them Mel 
And it is :)
&gt; Sure, it's best to document these things, but better would be to actually contain the leak and implement consistent behavior. Sometimes the leak cannot be fixed, and then the documentation will hide it. &gt; So I maintain the "document it" argument isn't specifically relevant to leaky abstractions any more than it is to any other coding issue... You are right. I am not saying it isn't relevant to other coding issues. The point is that leaky abstractions are more likely to have the only solution as documenting them. Bugs exist in all forms, and most of them can be fixed (they happen everyday, it is just an unintended behavior). A leaky abstraction that can be fixed is a bug, because it is an unintended behavior; a leaky abstraction that can't be fixed is a leaky abstraction that should be hidden, because there is no way to prevent the unintended behavior and the difference is if that can be fixed or not.
Well JavaScript is ECMAScript in a sense. You can't really use ECMAScript you can only use a technology that's based on the standard and JavaScript is the most prominent technology using the standard. How are you making your JavaScript code available to the browser/front end now? Including script files like this? &lt;script type="text/javascript" src="/my-script.js"&gt;&lt;/script&gt; or inline: &lt;script type="text/javascript"&gt; console.log('hello world!'); &lt;/script&gt; Or are you bundling code with a tool like Browserify or Webpack? A tool like those can really help organize code in the same way that code written for the node.js environment is organized with commonJS modules. For example you could have one file set up the canvas element: var $ = require('jquery'); var $canvas = $('#canvas'); // do other things to set up canvas how you want... module.exports = canvas; Name that file canvas.js In another file, say app.js you could write: var $canvas = require('./canvas'); // do something with canvas These are very contrived examples just to show the basic idea. You would then use Browserify or Webpack (I suggest researching both) to then bundle all your JS into one file that can be included on the front end like I did in the very first example. You can also make separate mini bundles for different pages of your app depending on what you need. The advantage to doing this would be reducing the number of files that you need to include in your final product while still allowing you to separate much of your front end code across many files, which is much better than having huge monolithic single files to work with while you are actually writing your code.
ECMAScript and JavaScript are the same thing. 
1. Ask their favorite language 2. compile and run it in asm.js 3. Laugh and watch their heads explode seeing there favorite language being javascripts bitch. 4. ... 5. Profit!
&gt; Well JavaScript is ECMAScript in a sense. In a sense?
Get a working version out the door even if its bug free and ugly. Write down good instructions on getting it running. Apply with a link to your GitHub page. I'd rather hire someone with a couple unfinished projects they're actively working on than someone with a couple finished projects they are no longer touching. If you're anything like me, no matter how much more work you put into that project, you'll never reach a state you'd consider "finished".
Well there are other languages based on ECMAScript, or at least there were at one point. Now that I think about it I guess that's what the ES in ES6/ES2015 is. I am an old JS dev. When I got started ActionScript 2.0 and 3.0 were still in heavy use and based on ECMAScript.
[removed]
Always "now". I don't understand why they don't teach this at school. In life, unless the words "shark" and "tank" are in there somewhere, any proposition "should i do this now or later" - is always a resounding "NOW!". Seriously, there's always room for improvement. But getting out of your comfort zone, even taking pride in something that isnt complete gives you generally much better results. 
For now I was writing it in ~5 files and concatenate it with gruntjs so the final result was in one file as you said. I'm rather confused with all these modules, do you know a good recourse that shows its benefits and how to get into it?
When you render/append each element, are you appending them one at a time? There's a few other options to add DOM content and using some selector.innerHTML+= someHTML is not always a bad thing. You could also create a document fragment and append that to the parent in one execution. My point here being is the slowest part of any JavaScript comes when you manipulate the DOM, so ideally you'd only want touch that once in your process.
I really like Airbnb's javascript style guide: https://github.com/airbnb/javascript/blob/master/README.md If you're using Angular the johnpapa guides are endorsed by the Angular team: https://github.com/johnpapa/angular-styleguide
angular dev here. i have a love/hate relationship with it. certain things it does really well, and you're like wow that was super easy. then other things, such as just making the first radio button in a group checked by default, and knowing if the form is dirty or not, are a pain in the ass. They have some really nice things, but to me it falls down when they don't want you to do something in plain javascript or jquery, but a lot of the times the only solution is to use a directive, write a link function that does the dom manipulation via their version of jquery. Lastly the learning curve to angular is very steep in my opinion. At the end of the day with whichever front end framework you choose, if you treat the code like software, you'll be fine. Each has their pros and cons. 
Apply now. You might be surprised if you found out how many people actually look at your github/portfolio during the application process. I've had literally just one person look at my github since 2008. And I have always asked during interviews because I'm hoping they'll ask *something* about it. The guy was a hiring manager who was a former developer, so he was technical. Non-technical managers won't bother because they don't know what they're looking at, they'll defer to the team developers but in most cases, they're too busy with all the day-to-day bullshit. You'll be lucky if they spend more than 5 minutes on your resume. You'll also very possibly get some interviewing experience out of anything you apply for now versus waiting. This is actually very valuable experience.
Hi /u/melissa_hola, this post was removed because /r/javascript is not a job board.
Now THAT'S how you learn JS. Looking for work?
Of course you can! What do you need help with? The more specific you can be, the easier it is to help.
For loops, creative ways to use if/else statement, although I do understand how to use if/else statements. Also how to use different aspects of Javascript to make a program/game.
In addition to codeacademy, check out w3schools' Javascript [guide and tutorial](http://www.w3schools.com/Js/). I found their site to be easier to understand because they explain exactly what each feature is.
Hi there, first can you maybe put the code that you don't understand ? It will help us understand your problem better :) Then, I'm not sure if it's part of your problem but "while loops" are not specific to Javascript, it's simple algorithmics and you may want to learn that first. Basically, Javascript is a programming language used mainly for building websites/webapplications. It can dynamically modify the content (HTML) or the design (CSS). You have to import the file by adding a tag in your HTML file. You can also run Javascript files without a browser with a tool called [Node](https://nodejs.org/en/) . You can find simple tutorials [here](http://nodeschool.io/#workshoppers) , it's free and all the steps are explained to you ;) 
It's just like every other skill, its hard and confusing at the start, but just keeping banging at it, and it'll all start to make sense and become easy.
Hi guys thanks to your awesome inputs. I was just quickly browsing and skipping things when I saw the snippet ( and gone crazy ), after read through the page in detail, all things make sense now and the expression does seem to be less confusing. But still some thoughts. I knew FP is going huge in JS world and I understand the basic concepts ( who doesn't ), but I am lacking the experience to work with it. which makes me unable to tell the currying pattern when seeing that =&gt; =&gt; =&gt;, intuitively. Should have the function to be a explicit curry ( like @itsnotlupus explained ), say using utils like lodash, it will make the code more friendly, and a hundred precent sense to junior ones like me. And I think that will be more preferable, because eventually there will be someone else start to read and maintain your code, and they will be caught up in confusion like I did if they were juniors as me.
Hm. Hard for me to say where you could optimize then without seeing your source. Maybe you could implement row limits then to help limit the lag from all the elements being displayed at once?
Hint: start small and with an example. This still isn't specific enough, I'd say. Show us an example of a for loop that does something you don't understand and tell us what about it you don't understand. Much easier to go from specific -&gt; general than the other way around.
Actually yes :) why ?
Apply now. The interview will go roughly the same regardless of your portfolio. I have gotten mixed reviews by providing access to a portfolio, which ironically turns out to be better for me in the long run. Sometimes companies have found my big open source project exciting and impressed with the time I put in. I have also been outright rejected because Java developers could not read the vanilla JS code. I have also gotten confusion from people (non-coders) who are troubled to understand why they would want to use a code beautifier. Virtually nobody reads the code to discern if I am actually a competent coder. tldr; My portfolio has gotten me some jobs and cost me others.
There are simple mantras for explaining advanced positions. Consider these: **Coding** -&gt; Solve for the business requirements in the given technology as cheaply as possible. This is literally all you have to do. When people ask me about stupid stuff, like frameworks, I just say they slow me down and make things more expensive. **Management** -&gt; Document and then delegate. Everything else comes from this. If you answer that you need to put fingers to keyboard you are wrong. **Architecture** -&gt; Putting things in boxes and connecting the boxes together. Imagine you are playing with a toddler's toys, because its got to be primitive and simple, or else you are a failure. Think in terms of woodblock trains, legos, cardboard boxes, or so forth. The Air Force prefers checklists, the Army prefers flowcharts and outlines, and I prefer hierarchies and tree diagrams. Just create boxes, put things in boxes, and link the boxes together. The ultimate goal is to keep things simple. They are going to try to confuse you and challenge you. Success is whether or not you deviate from simplicity. Stupid people make things complicated and attempt to appease people. An architect is not there to make people smile. An architect is there to organize things for maximum delivery.
Really? Reading source would do nothing for me. I wish I could read source and fully understand what is going on as a whole. I need to apply it to a problem, encounter an issue, then debug through the source to fully understand how the source is actually working.
If you want to learn how to program a game in JS, then I would absolutely recommend reading this from beginning to end: https://retrosnob.files.wordpress.com/2014/10/foundation-game-design-with-html5-and-javascript-v413hav-1.pdf. That being said, building a game in any programming language is one of the hardest concepts to wrap your head around initially; good luck!
yes, with [gulp-uglify](https://www.npmjs.com/package/gulp-uglify). i'd also recommend looking into [using npm as a build tool](http://blog.keithcirkel.co.uk/how-to-use-npm-as-a-build-tool/) if your build requirements are fairly standard. would probably save you on toolchain complexity and setup time.
Reading code is really good to enhance learning and at least see where things are going. You don't need to spend a weekend reading React's code (oh god) but you can try Preact for example. Actually I am thinking of taking 20 mins everyday to reading the code of small modules that I use but can't explain how they work off the top of my head. Plus nothing is stopping you from cloning a repo and testing/breaking it to see how it works.
 Don’t call my callback too early Don’t call my callback too late Don’t call my callback too few times Don’t call my callback too many times Make sure to provide my callback with any necessary state/parameters Make sure to notify me if my callback fails in some way Oh my god, these apply to every function call in my application! Promises are the hammers to all the nails!
There's nothing to be done outside of any possible legal remedy.
It is a fact that 20-somethings lack wisdom and experience, so I wouldn't expect you to understand anything I wrote. 
I kept reading, but only because I wasn't done with my coffee yet and wanted a few more chuckles. 
I'm not going to argue with an "expert beginner" about why your inexperience is superior to my experience. It's really obvious from what you wrote that you have no clue what you're talking about. You vastly overgeneralize "your older colleges" without even considering your own inexperience. Not interested in taking this further, I have things to create and build that are far more interesting than you telling me why I'm doing it wrong. 
"ads on reddit". Although I don't know how you can advertise a free framework integrated in another free framework :D
Thanks for posting this tutorial. Will definitely give it a try.
&gt; ... the only solution is to use a directive, write a link function that does the dom manipulation ... This is exactly what you are supposed to do. Directives are central to Angular 1. Any library or framework you fight against will give you a hard time. &gt; Lastly the learning curve to angular is very steep in my opinion. It is, but I think a large part of that is because the way Angular is intended to be used, at least when it was introduced, was quite unlike anything else out there. It also required some mental gymnastics to understand that a JavaScript application can be written the Angular way. It also doesn't help that the documentation, while extremely thorough and detailed, has always been too difficult to consume and learn from. &gt; Each has their pros and cons. Yep.
Yep. Javascript is in it's final form. All done. History stops here.
Hmm, 0 comment accounts appearing to chime in... My conspiracy theory alarms are ringing!
^ also another 0 comment account. Pretty certain besides myself, everyone else in here is the same person (lyub35) :D.
One week and you learning for loops. It's not bad. If you don't give up you would be there. Everybody experiencing hard time learning something new. More practice helps great. Meanwhile find something interesting like where you can use your new knowledge. For me it was casperJS. It's easy to start with. then you want something more sophisticated and you start doing things yourself. 
Can't wait to try new typings solution.
&gt; faux SPA
Yep I agree!
You should definitely try to learn how to use Google dude :) Or just cut off your conspiracy theory alarms when it comes to people or accounts in reddit. Maybe it will be best if you focus on improving your coding skills, rather than staying on reddit and playing it cool :D Or just focus on Pokemon Go to improve your account rating for a couple of days :P
&gt;I'm not saying that callbacks are best in every situation, but I am saying that promises also aren't best in every situation. I disagree, I find that promises are a very useful pattern for most situations. With Javascript being a single-threaded, async operations are a fundamental part of writing good Javascript, because especially with Node you really can't afford to have synchronous code blocking the stack, because it'll block the stack for literally every user connected to that specific instance of your application. A lot of our code at work is architected around promises as a standard interface. If we use a library or module that uses callbacks, we'll use [es6-promisify](https://www.npmjs.com/package/es6-promisify) to wrap that in a promise so that its easier to work with. The only instance I can think of where plain callbacks make sense are in event handlers, such as in node.js streams or event listeners in the browser.
HTML5 has a canvas element that allows you to add images and manipulate pixel by pixel; combining that with mouse movement listeners is where I recommend starting for a native JS approach. That being said, I would imagine most commercial applications avoid trying to program a solution in JS and do it through a photoshop or flash plugin/etc.
A bit salty aren't you?
Ok =\
Webpack changed my life. I actually don't worry about my build at all anymore. With Grunt &amp; Gulp I felt like I tinkered around a lot and failures happened a lot. Maybe I got better, maybe not. Either way Webpack is the bee's knees.
You'd be looking for a 'lasso selection'. The closest I coudld find is [this](http://bl.ocks.org/GerHobbelt/3732612)
Don't worry too much about it - as long as you understand the concept of "looping" you are good to go. As you start writing more code you'll just find sometimes they read nicer. For example, if (for some reason) you wanted to print "hello" until you got a random number that is greater or equal to 0.9: while (Math.random() &lt; 0.9) { console.log("hello"); } Unlike a `for` loop, you don't need a set start and end value. You just want something to happen over and over an unknown amount of times until the condition is true. If you tried to tackle the above problem with a `for` loop it would be weird (though it would work!): for (var i = 0; Math.random() &lt; 0.9; i++) { // Why do you need "i"?! console.log("hello"); } There isn't a "range" we need to loop over (there's no begin and end values) so we don't need the extra variable. A `for` loop is not "correct" here. Similarly, you can also make a range work in a while loop: var i = 0; while (i &lt; 10) { console.log(i + "!"); i++; } But it's "nicer" (more standard and concise) as a `for` loop: for (var i = 0; i &lt; 10; i++) { console.log(i + "!"); } But who cares! - as long as it works and solves your problem then it's good enough! The more problems you solve, the easier the tools will become. 
Java != JavaScript It really depends on how the website is built, but more than likely this isnt going to work. You could probably write a browser extension to do this for you, depending on what browser you are using, as well as how the website is actually doing things.
yippy, let's rewrite everything again pals.
without code, there isnt really anything sane we can suggest. if you wont post code, what all goes on when you click the dropdown button? Like, specifically how many li are in the ul? what event listeners are present, what elements are they listening on and to what events? if its taking a long time to just change a ul from display: none to display:block, then there is a major problem or something else is happening that you are overlooking. have you tried using a select and options for the dropdown, rather than making your own select functionality with a ul? Maybe this is a scenario where a view library / framework would be a better option than rolling your own with vanilla js? 
Perhaps my dialog isn't meaningful. The significant difference is that I'm willing to talk about and defend my points, where you want to attack people by attributes and labels. You've fought yourself out of the argument and now you're literally defending the fact's of how you failed to respond to anything I said prior. [And](https://www.reddit.com/r/technology/comments/4qu3jg/apple_is_suing_a_man_that_teaches_people_to/d4xsyyp) [now](https://www.reddit.com/r/technology/comments/4qu3jg/apple_is_suing_a_man_that_teaches_people_to/d4xu51s) [you've](https://www.reddit.com/r/technology/comments/4qu3jg/apple_is_suing_a_man_that_teaches_people_to/d4xruvq) [opted](https://www.reddit.com/r/technology/comments/4qu3jg/apple_is_suing_a_man_that_teaches_people_to/d4xel8x) [to](https://www.reddit.com/r/javascript/comments/4rccrs/migrating_a_10000line_legacy_javascript_codebase/d511jh6) [respond](https://www.reddit.com/r/javascript/comments/4rccrs/migrating_a_10000line_legacy_javascript_codebase/d51346s) [with](http://www.reddit.com/r/Roadcam/comments/4n5g1x/usa_jeep_tries_to_go_around_traffic_and_gets_hit/d41vyi3?context=3) [your](http://www.reddit.com/r/javascript/comments/4mtea0/google_deprecating_angular_1.x_material_library_and_is_just_closing_issues_/d3zmxst?context=3) [favorite](http://www.reddit.com/r/javascript/comments/4l52dg/what_the..._javascript_-_kyle_simpsons_explaining_some_quirks_of_js/d3lt0fc?context=3) [word](http://www.reddit.com/r/aws/comments/4jdplq/charged_1635.37_after_accidentally_hitting_an_http_endpoint_too_many_times_/d377g1q?context=3).
fuck off troll. You're just looking for a fight.
Thing is angular 1.x does not support dynamic loading of assets. There are hacks to circumvent this, but they are hacks and should be avoided (propiertary or not). Start looking into angular 2 instead.
Long time gulp user here, although my use is limited to concatenation and minification of scss and JS with a watch task. I like my tools to be simple, however, now it's time for Babel and ES5+, will webpack be suffice for me? If so I'd like to ditch gulp in the process.
It's like they're not even trying hard.
Quit being a bully and a liar. I read it and understood it. It's a tutorial advertising a paid product. Rails is obviously free. The tutorial uses "Trial version" licensed code. If you go check out the EULA you get. &gt;You may not redistribute the Software. The term of the Trial License shall be 30 days. If you wish to continue using the Software beyond expiration of the Trial License, you must purchase the applicable commercial license. Now please stop posting on your multiple accounts while posing as different people to promote your product. 
Thanks.
Typescript is definitely getting my love. In my humble and uninformed opinion, it deals with many of the common pitfalls and gotchas of JavaScript. The overhead is well worth the investment, would recommend to anyone using JavaScript looking for just a little more sanity.
noob alert in 3... 2 .... maybe a dumb question but....if I use nodejs as in the article to make apps/scripts, then do I have to host the final output on a host that supports nodejs? 
I hope this new null handling only applies to primitive types, because objects are nullable in all languages. 
To be tail recursive for tail call optimization you'd need the return. Though I suppose technically as long as it is the last statement in the function you may not need the return? I've not seen any language do it that way though. See https://en.wikipedia.org/wiki/Tail_call for more information. As for the continue, it indicates that you want to tail call optimize. This is not strictly necessary (and I actually prefer not having it) but it avoids having to try to detect possible tail calls then optimize them. It also lets you throw an error if the programmer thinks that it can be optimized but it can't.
I wouldn't worry about that. Just because a technology is deprecated from a specification does not mean the technology is removed from implementation. Furthermore WHATWG is kind of like a pet to the W3C. Don't forget that WHATWG decided to remove the attribute node type from *their* DOM specification. Therefore it was law... there were no more attribute node types in the DOM. Except that this implementation is necessary under the hood and has important use in XML, so everybody just pats the cute little WHATWG on the head and smiles. This change, even if law by the WHATWG, was never recognized by the W3C or any browser. For some additional information read this: https://github.com/whatwg/dom/issues/37
The comparison of our reddit comment history shows you're constantly looking for a fight, typically resulting in you calling someone else a troll as your side of the argument winds down. You won't find that in my comment history, especially at the frequency your's does.
Fuck. Off. Troll. I'm not even reading your asinine responses now, you're just looking for a fight.
You dismissed my perspective because it isn't in your limited (and uninformed) view. You dismissed my perspective because it isn't in your limited (and uninformed) view. You dismissed my perspective because it isn't in your limited (and uninformed) view. You dismissed my perspective because it isn't in your limited (and uninformed) view. You dismissed my perspective because it isn't in your limited (and uninformed) view. You dismissed my perspective because it isn't in your limited (and uninformed) view. DID THAT SINK IN? I'm not talking to you because you immediately went abusive towards me, after I tried to convey some wisdom to you in a non-threatening, non-harasing manner. Now all you want to do is shit on me and harass me. FUCK OFF TROLL.
Username checks out.
Yes, webpack can use babel as a preprocessor through its flexible loader interface.
As someone who has the misfortune of developing with Angular, I just can't imagine how there could be any advantages. . . . at all. 
For anyone who hasn't bothered yet, look into hot module loading. It's really cool and has done wonders for my productivity, particularly in tinkering with finicky bits (like styling).
Yes, the docs are shit though so be prepared to do a lot of googling and fiddling with it at first
That was worth the read, thank you op. Seems very useful.
Yeah one solution that was suggested by another commenter was to only render elements in the viewport. Clusterize.js looks nice, but unfortunately I'd have to get a license for my project, so I guess I'll have to roll out my own implementation :/
&gt; ...its coming out more than what the actual distance is. That's because you use `all.length` in the calculation. `all.length` is equal to the wrap-around index of "A", instead of the index of "?". So, the `all.length - all.indexOf("O")` counts the distance of "O" to "A", instead of "O" to "?". Thus, the calculation should be: count = (all.length - 1) - all.indexOf("O") + all.indexOf("G"); or... count = all.indexOf("?") - all.indexOf("O") + all.indexOf("G"); And BTW, you don't need to wrap it in a for-loop - unless you need to use the index of each round-trip step.
Well I only call `replaceChild` when switching tabs because the content is actually pre-generated, and I've heard using `innerHTML` is actually not preferred in this case. Regardless, I've gotten the tab switching to become pretty smooth using `setTimeout`, the combo-box is what's still giving me trouble :/
Well I only call `replaceChild` when switching tabs because the content is actually pre-generated, and I've heard using `innerHTML` is actually not preferred in this case. Regardless, I've gotten the tab switching to become pretty smooth using `setTimeout`, the combo-box is what's still giving me trouble :/
have you tried to make all the different ul/li that you will need during initial startup, and then only display the ul that you need for each page/tab, rather than creating the elements when they are needed at runtime? so instead creating the ul and all of its li then appending the ul to the actual document when a user clicks on a tab, have it all already created, and when a user clicks on a tab you simply hide one of the ul and then show the other ul in its place? I dont think the amount of content already on the page should have much effect on the time it takes to add other elements to the page... though I could be wrong
You can still use gulp if you want with [webpack-stream](https://github.com/shama/webpack-stream) or [gulp-webpack](https://www.npmjs.com/package/gulp-webpack) (I prefer the former). Webpack and gulp have different goals (one is a bundler, the other a task runner), so I personally use both. Was never really a fan of npm scripts triggering builds...
Yeah a lot of times innerHTML is not the best solution. I was just making a guess since I don't really get the context, a video showing the UI and issue may have helped. But maybe another possible issue (which is again a shot in the dark) is that you said there is a lot of content and that the content is pre-generated. Well if there is a lot of HTML content then repaints in general are more expensive. Also another thing you can do for Tabs is have a tab click just be a switching a class that effects the display property of nested elements. Here is an example. #tabDiv.on-tab-one &gt; .tab-one{ display:block; } #tabDiv.on-tab-one &gt; .tab-two{ display:none; } #tabDiv.on-tab-one &gt; .tab-three{ display:none; } #tabDiv.on-tab-two &gt; .tab-one{ display:none; } #tabDiv.on-tab-two &gt; .tab-two{ display:block; } #tabDiv.on-tab-two &gt; .tab-three{ display:none; } #tabDiv.on-tab-three &gt; .tab-one{ display:none; } #tabDiv.on-tab-three &gt; .tab-two{ display:none; } #tabDiv.on-tab-three &gt; .tab-three{ display:block; } I use this trick all the time, and the change always is in-sync with the render repaints, because when one shows, and the others hide is during the repaint. 
yes I also noticed dwighthouse mentioned the same thing. &gt; And even though the invisible elements will have display:none set, will they still affect performance (basically do invisible elements trigger repaints, reflows, events, etc.) I just did some research after you asked that question because I wasn't entirely sure. So there are apparently two Trees the DOM tree and the Render Tree, so a display:none element will no effect reflow or style changes while it's hidden.And also yes changing a wrapping parent Div's CSS class to hide or show nested wrapper elements WILL cause both a reflow and repaint. . . . but so will adding and removing elements. But generally I still think it's an ok method. Here is more info: http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/ Also I honestly think html strings is pretty fast, I mean they can be rendered in a web worker(non blocking) and you only touch the dom once, and when you do Yes there is a reflow and repaint, but that happens anyways. 
my suggestion is: * if its a tr you might want `parents('tr').find('[name=...]')` * if your using closest, `$(this).closest('tr [name="inv-price[]"]').val(price);` might be the answer... 
I would go about this differently. find the indexOf the first char, then subtract the index from the index of the 2nd char. BOOM. Distance. 
Modular styling is pretty insane with it, too, particularly when using React. After using Backbone and then Backbone Marrionette for years, Webpack + Babel + React is just a dream.
yeah I don't give a shit how old he is
Exactly what I was looking for! Thanks so much. I'll brush up on my css.. I've been concentrating so much on the js stuff that I forgot about that! 
They are not in C++. Pointers are, objects are not. If you do not use a pointer, it's not nullable. In Java, everything is nullable because everything except primitives is a pointer to the heap internally. 
I think it should be a "max" - if indexOf ("G") &gt; indexOf ("O") the result would be negative. I'm not sure it's 100% correct event after that, but now it's wrong.
You're right. As far as I'm concerned, I never meet a situation where I would need Webpack + Gulp, my usual workflow is Webpack + better-npm-run https://www.npmjs.com/package/better-npm-run 
*80 million
woops, sorry
We just had a competition, it was great! even the people who referred the developers to the challenge won a prize We had around 300 submissions 
It's not about if the host language supports nullable objects or not. It's that most of us agree that non-explicit nullable types is a mistake in every language that has it.
That's what I said - objects are nullable. And this is correct and expected behaviour.
A clear introduction for Webpack, thanks ! Is the use of the ExtractTextWebpackPlugin a best practice or is it ok to load CSS through JS?
I have NEVER heard that! NULLs is how you pass optional arguments and how you return errors when there's no need for exceptions. Where this idea is coming from?
No, it's true, and I've been guilty of being one of these arseholes. If anything, it's reminded me that becoming a great programmer takes _years_ of work.
Here's an article explaining how: http://jamesknelson.com/using-es6-in-the-browser-with-babel-6-and-webpack/ With webpack you can ditch gulp completely. If you look at his example on github, with that single config he's got an entire self contained build system that transpiles, bundles, serves dev preview + hot reload. With loaders for css, images, etc., plugins for minification and so on, you can easily extend it to your own needs. The biggest benefit is probably that by running Webpack you can tap into the world of npm out of the box. Need a polyfill? npm install requestidlecallback --save and in your .js import 'requestidlecallback'; requestIdleCallback(() =&gt; console.log("task")); Need some Node functionality? import EventEmitter from 'events'; class SomeClass extends EventEmitter { constructor() { super(); this.on('event', arg =&gt; console.log(`event ${arg} occurred!`)); } } new SomeClass().emit('event', "test"); Not a single thing changed in your config since Webpack is Node aware.
Blogs are a great place to practice your English.
Search for "C++ stack vs heap objects" and "C++ pointers vs references". C++ is a really flexible (and complex) language. You can choose to use pointers to objects (which can be null). You can also strictly use non-pointer objects and references. Every project is different and can have different coding conventions.
I saw something like that a day before on [r/webdev](https://reddit.com/r/webdev) https://www.reddit.com/r/webdev/comments/4s9k6v/reactjs_or_angularjs/ Just to give you a pretaste: &gt; The Flux architecture of React and JSX also isn’t helping React’s fans due to its convoluted nature. 
I don't think people will help you spam people. 
what year is this?
You could add more regions/formats to date too?
I don't think javascript will ever replace C++ where C++ does the best job (e.g. intensive, number-crunching computations). But given that javascript has evolved into a mature language with serious backing from open source community and enterprise, it makes perfect sense that someone would learn 1 language and be able to use it across the entire stack (in web development). There is absolutely nothing a language like PHP can offer that node.js isn't doing already, and mostly doing it better. I don't know if javascript is the future, but it sure is the present.
not bad actually! we will probably contact you soon! A lot did not make it, about half didnt qualify
Currently you could define the date format by using datePattern: https://github.com/nosir/cleave.js/blob/master/doc/options.md#datepattern Not sure if this suits what you want, if not, feel free to create issue in the project.
Recently got to use proxies in a project and already am really loving them. I personally just used them to create a electron IPC wrapper (sending messages between the electron main process and the renderer). I used it to allow me to instantiate objects on the main process from a renderer window and call methods as though it was an actual object on the renderer process. Kinda confusing when I explain it but basically in pseudo javascript: // Main electon process (similar to server) let myObj = ipcWrapperListener({ "doSomething": () =&gt; { return Promise.resolve(1000); } }); Then: // Renderer process (similar to client side) let myObj = ipcWrapper(); myObj.doSomething().then(() =&gt; { console.log(res); }); And it runs the doSomething function from the serverside. Its really handy and not possible without a lot of syntax changes to do currently in ES5 or creating an actual custom wrapper for each object. All I have to do currently is create a map that maps property names to the type they return and my proxy sorts out the rest. 
True, and it works with `type="tel"`. As for password, honestly, I forgot it, couldn't come up a case we need to format it though.
Very cool component but this functionality can be achieved by any other mask component with regex. Proper use of regex give you much more options. 
1. The image does not change. The ajax call fires and properly updates the db but the image does not change to reflect this. The console shows nothing. 2. Both are using windows 10 and chrome. 3. I know how to use the console, but I am not sure what you mean by debugger.
Discredited? Want to link to somewhere that shows Hola wasn't selling bandwidth to third parties? I mean https://luminati.io/ outright says it uses the Hola network. Unlike you, I don't need a presentation on its definition to grasp peer to peer technology.
What can I say? Pathetic individuals who use ad hominem attacks can't tolerate when someone talks back.
I'm currently trying to use proxies to present models from the server and post any method call back to the server as an action. It works fine, but so hard to debug. 
First, I love your username Second, I would strongly suggest testing this on a variety of versions of android. I just went through looking for a proper phone mask component, and slightly old android devices are the bitchiest things when it comes to input.
This is sweet. When working on stuff like this before, I've used https://www.npmjs.com/package/nanp but it only validates phones in North America, and doesn't have any sort of carrier information built in.
Nice post! I'm pumped about proxies as well. I [wrote a post last year](http://www.east5th.co/blog/2015/11/09/why-i-cant-wait-for-es6-proxies/) about how proxies can be used to provide an automatic layer of security around a (Meteor) application. The basic idea is that you can throw a runtime exception any time you try to access potentially unsafe user-provided data without having validated it first (and marked it clean). Meteor has some things that could make most of this automatic, but the real magic was proxies.
Regarding privacy: How would you stop access to RESTRICTED, wouldn't someone be able to mutate RESTRICTED by popping the value or editing index 0. Perhaps make it a property of the original value of api?
There's also [libphonenumber from Google](https://github.com/googlei18n/libphonenumber)
*practise ;) Edit: Aah, so in US English, _practice_ is also a verb. My mistake.
From my experience no matter how many N user cases you've anticipated there's always N+1 case which you didn't think about, and you already get feature requests about it. In this situation you need or adding custom behavior to 3rd part library or adding new dependency to cover this N+1 scenario, so why don't use library which will cover it from the beginning? I've opened a feature request here https://github.com/nosir/cleave.js/issues/19
you mention combo box.... is this a vb/asp.net app? (or are you just calling it a combo box?)
I have two: 1. A dating app. 2. Second hand selling app.
* I made a site where me and my friend record movies we'd like to see. The movies are saved in a database and linked to separate accounts. After you've seen the movie, you can check it off the list and it's no longer displayed in the list. * I made a calendar that you can share between friends/family. Using momentjs for the basic time tracking stuff, I drew the calendar myself using tables. You log in and have your own account, and you can share your calendar with any other account. * I made a calculator that helps me figure out how much I make each month, based on my hourly rate. I have some specific terms that makes me earn more after a certain amount of hours each month, and each month has a different amount of work hours in it. All I fill in is how much I make an hour and the app presents how much I make gross/net for the entire year * I was on my way to make a messenger.com-clone, but just a couple of days after I started, Facebook released messenger.com 
Why is modern Javascript now harder to refactor? With modules, classes, extensions, promises, async/await you can clearly structure and lay out your code. ES5 IIFE's or specific-order-gulp-concatenates are a thing of the past. As for being cut off npm or jumping through hoops to make it work. When i read through issues on their tracker (https://github.com/Microsoft/TypeScript/issues/247) i ask myself again, why are people doing that to themselves. They're giving up on the worlds biggest resource for functionality. Node alone is the webs stdlib. 
exactly. I am a Czech developer and every shop I know of that was using Backbone migrated to React/Angular long ago.
I dunno what to say about types; I find them useful and there are plenty of things modern JS linters and checkers won't catch. A lot of devs seem to agree. You can still use npm modules easily enough - just without types if they're lacking definitions. The setup/docs for using npm modules with types wasn't so great and that's improving rapidly.
Current mail servers don't respond to VRFY, or send a 252, any more so to try to verify an address exists you have to attempt an SMTP connection to hopefully get a 250 response code. The problem with this is you are not likely to get a 250 without being authenticated anymore. You will get a 252 at best and most likely a 354. Neither of which actually verifies if the user exists. The checking of signup pages for public providers is a bit of an end-run and I doubt they are that useful for real-time usage since the major providers have rate limiting. In the end, it's just much easier to do simple verification and handle bounces. 
hey! it worked! And the compiled result looks good. Thanks
That's epic. Thanks for linking this.
I think privacy on models is useful. Rate limiting methods, is much simpler without a proxy. I think several of these use cases would be better served by other clearer, more explicit means actually. Listening to changes on a model is also a good use case, but then I guess that wouldn't work on nested properties, but something could be written around that.
[removed]
Most apps boil down to fetching some data, and then displaying and manipulating it in some way. You can pick literally anything, it does not matter as much what you'll be building as the learning process. You can try to think of something, but what if nothing pops in your mind? Well. Try to build a replica of something you use or like. Doesn't have to be complete, build out only the "core" parts and see how it goes. Now, can't speak for Angular here, but I can recommend a few React resources and libs/approaches: * everything from their website — to get the idea and play quite a bit * webpack is powerful and you will probably end up using it in the end due to its popularity and the level of customizability BUT configuring it isn't the easiest thing on the earth, which, if you are only getting stared, will inevitably slow you down. You [might want](http://goshakkk.name/you-dont-need-learn-webpack-first-with-react/) to look at [Brunch](http://brunch.io) + its [react starter](http://github.com/brunch/with-react) *(disclaimer: I contributed to Brunch)* or a Webpack boilerplate project * [Redux](http://redux.js.org) to manage the state — the docs on the website are terrific, and there's also [an egghead series](https://egghead.io/courses/getting-started-with-redux) about it * Pro React is a terrific book that will take you through many common React patters and practices. I haven't read it personally, but a friend of mine has been saying *a lot* of amazing things about it * [redux-saga](https://github.com/yelouafi/redux-saga) — doing something asynchronous in response to user action (creating, fetching, etc) isn't at all uncommon, and while a bit advanced, Saga allows to manage the complexity of that pretty easily, and also to define other bits of business logic (like show a "Congrats" modal after the first to-do added as part of onboarding) --- Re: replicas. I've recently [built a clone](https://www.reddit.com/r/javascript/comments/4sip6j/rendering_to_canvas_with_react_under_the_hood/) of Buffer's Pablo tool, with the purpose of exploring ways to make drawing on canvas declarative, the same way you do to DOM with React.