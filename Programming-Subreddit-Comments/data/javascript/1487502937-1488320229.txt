I'm having trouble comparing the locations of two unique objects. Any ideas how I can refer to them in my code?
Ok, yeah I was thinking about saving the operations to localstorage and if the operation can be found from localstorage do not send the calculation to server. 
Javascript30.com is amazing. I learned so much from Wes Bos.
I recommend to use canvas and requestAnimationFrame for your game. Then you won't have to deal with images on the HTML/CSS side at all. You just load the images and draw them via drawImage. If you just need a list of images, you can generate them on the command line. E.g. with Windows, you could run something like `dir /b *.png &gt; images.txt` to dump the file names into "images.txt". Well, there probably is some pattern. Like, there is a base name ('foo', 'bar', ...) and a 2-digit frame counter. foo-00.png, foo-01.png, etc. In this case, you could just loop through them. With sprite sheets, things are somewhat simpler. There are just a few images to load and there is some JSON or whatever which specifies which sub rectangle corresponds to which image. The third and probably most complicated option is to use some archive. Once the archive is loaded, the entries (which are just Uint8Arrays) are transformed to something which can be used (e.g. an HTMLImageElement). They can then be accessed by their paths (e.g. this.data['images/title.svg']).
the function that calls `draw` will want to do a similar function where it loops over every puck and does a collision test with every other puck. alternatively, you could pass `pucks` to `bounce` and each puck could see if it's colliding with any of the other pucks when it calculates its position and velocity
I am getting them from an img folder in the same directory as my index.html The images load perfectly fine when i launch them from brackets but when I go into it from the website hosted from github, the images do take a while to load.
I get that. I don't understand how I can extract data for two objects in a sea of objects to see if they're in the same location (or close to each other, aka colliding). Can you help me with that?
 for (i = 0; i &lt; objects.length; i++) for (j = i + 1; j &lt; objects.length; j++) if (distance(objects[i], objects[j]) &lt; collisionDistance) // objects[i] and objects[j] are within collisionDistance of each other
I included the following code: In the draw function: for (var i = 0; i &lt; pucks.length; i++) { for (var j = 0; j &lt; pucks.length; j++) { if ((pucks[i].x - pucks[j].x) &lt;= 2.5) { if ((pucks[i].y - pucks[j].y) &lt;= 2.5) { pucks[i].rebound(); pucks[j].rebound(); } } } } And in the Puck object, this.rebound = function() { this.xspeed = this.xspeed * random(0.1, 1); this.yspeed = this.yspeed * random(0.1, 1); } However, all the pucks are now stationary. What's wrong? Did I misinterpret what you meant?
If you're just making an app for yourself and you're on windows, using UWP with JS is pretty easy. https://docs.microsoft.com/en-us/windows/uwp/get-started/create-a-hello-world-app-js-universal
First of all, your code doesn't just make the collision check for each set of pucks, its important the inner loop only runs from the puck after the one being checked by the outer loop (see the code example below to see how different the output is). Second, your rebound function is only gonna decrease the speed of the pucks, and the effect is cumulative, every call makes them slow down. s = "abc" for (i = 0; i &lt; s.length; i++) for (j = 0; j &lt; s.length; j++) log(s[i]+s[j]) log("---") for (i = 0; i &lt; s.length; i++) for (j = i + 1; j &lt; s.length; j++) log(s[i]+s[j]) output: aa ab ac ba bb bc ca cb cc --- ab ac bc
&gt; Are those libraries done by a building tools that simply append commands one after another? Is it a way to make reverse engineering harder? Yes, and partially. More importantly it reduces the file size of the code so it is faster to download and even parse. So its performance more so than obfuscation, especially when a lot of the JS code out there is open source and the code is readily available in its source state.
I'm pretty sure the point of not using a library for the exercise is to get you to figure it out on your own.
True.
1. Prepare a variable to contain the main result for the main array element index and set it -1 as default. 2. Create a for-loop (outer loop) to iterate the main array elements. 3. The iteration code should retrieve each element of the main array, whose value is an array. 4. Prepare a variable to contain the element result for whether the retrieved array matches the input array and set it to `true` as default. 5. Still within the loop, create another for-loop (inner loop) to iterate each element of the retrieved array. 6. The iteration code should retrieve the two elements from the retrieved array and the input array using the same element index. 7. Compare both element values. I they're not identical, set the element result variable to `false` the break the loop. Otherwise, do nothing and let the inner loop continues. 8. After exiting the inner loop, if the element result variable is `true`, set the main result variable to the index of the outer loop, then break the loop. 9. After exiting the outer loop, the main result variable should be zero or greater if the input array contents matches any element contents of the main array.
[removed]
Here is a quick version i made in codepen: http://codepen.io/anon/pen/NdZRPO The idea is to use sort function with the textContent, then sort from the first to the laste item. 
Oh, pardon me. You should add a protocol: location.replace('http://www.example.com'); location.replace('//www.example.com'); 
for-of is pretty neat, though.
Most open source packages will include the full javascript and the minified versions. You can use the full source in your debug and the minified in production.
Read about session/local storage, I find them easier to work with than cookies :) 
Would map and filter work here? Can you use ES5 higher order functions? [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) and [Filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
Well, they already are and taking it very seriously too. All major browser vendors are working on WebAssembly
Yes I can. How should I use them?
What's the point of modernizing your code if you aren't running a modern OS? :P
I'll cling to my Windows XP until Microsoft sends Bill Gates himself to pry it from my cold dead fingers. Seriously though, company I work for is mostly a MS shop and I'm one of the few that get the fun of playing in Node land. But, still have to have a Windows box sitting on my desk (VMs apparently don't count..)
Not to mention that not all of these wheels are as well tested as others. People are left with no idea what they're getting, and if they pick a random module, they no easy way to know that it handles all the edge cases they might run into.
Have you tried BashOnWindows? Seems like that could solve a lot of friction
Haven't tried it very recently. Last I used it (maybe 3-4 months ago) doing anything file I/O intensive (for instance, npm/yarn install) it was extremely slow. Think an order of magnitude slower than Windows itself. 
Maker here :) ah yes, I've been developing this on osx and testing on Linux via Travis, but unfortunately I don't have a windows machine nearby. However if you'd open an issue on GitHub and are okay to share some more feedback, I'd love to get it there!
Considering there's no emulation or other many layers of indirection, that strikes me as surprising. Then again, it's new and quite radical, so there's bound to be issues I suppose ..
Frameworks don't stunt your growth. Frameworks are simply a tool. Every tool has a purpose and ideal use case. The trouble some developers have is know which tools to use and when to use them. I encourage new developers to learn the fundamentals before jumping to frameworks, IDEs, and other tools.
Microsoft has put billions into pushing WM and other technologies. They're no stranger to shilling and brute force marketing. Next to no one is using Windows for web development or cross platform development. You're referring to .Net developers having to move from C# due to the desktop and asp.net market crashing. We're in that segment as well, ex-.Net, all of us on Windows computers, which is why i know the pain. Don't kid yourself, Windows gets support last for *all* prevalent web technologies, not just Flow. &gt; "Half the modern web" - you mean a few people who like playing with bleeding edge features. It's not half of anything. https://github.com/facebook/react/wiki/sites-using-react TS couldn't compile probably more than a handful of these just a month ago. It has a long history of blocking progress. 
If you are interested in going the mvmc route, there is a decent tutorial on monorail about getting that started. This is the model, view model, controller pattern if you are unfamiliar. I'm on mobile so don't have the link, but it shouldn't be too hard to find. It is interesting using getters and setters to set up the observable patterns. I don't have any suggestions for routing, but there are plenty of single page routing solutions out there to look through to get an idea of how to work with the history api or whatever it is you want to do. This shouldn't take too much. You can write a decent router in a few hundred (or less) lines of code. I wouldn't bother with writing a state management solution or http library though. There are so many good solutions to these that the amount you would learn writing them wouldn't be worth them time investment IMHO. That being said, learning is never a bad thing if you have the time, and if you only had to pick one, I'd go with the state management. If you feel comfortable with typescript, you can extend that observable pattern and look at how MobX does things in their repo, or rxjs. You could also peek into redux and it's many different corallaries. If you want to shoot me a message, I'd be happy to talk about this with you. This is something I've kind of wanted to do for a bit now so we might be able to kind of work and learn together, bounce some ideas off of each other or whatever. 
Opened an issue and PR. Don't really know if you had a specific solution in mind for this already but this solved it on my box. Win10v1607
Yes and no. Using a framework is a means to an end. So if your goal is to learn to deal with high level complexity in large projects, a framework can help you get a lot of mundane things out of the way so you can focus on things like data architecture, REST API design, etc. But a framework inherently does hide things from you if what you're trying to learn is what the framework is designed to do for you. So if you're trying to learn how memory allocations affect performance or when OPTIONS requests auto-trigger, yeah dive into vanilla js.
Using a single framework likely will. Learning multiple frameworks, however, will help you see different ways of solving the same problem, and can help broaden your horizon from "How to I make this thing" to "How do I build a system to make things?"
Had JS been so inadequate, then browser vendors would have added support for other languages looking for a competitive advantage during the browser wars. For the last 15+ years they didn't.
TypeScript's "type guards" are a pretty good example of what you're hoping for. (assuming I understand you correctly) If a variable can be either a string or a number, then I should double-check that it's a string before doing something like `.toUpperCase()`. TypeScript understands this: myVar.toUpperCase(); // Compiler warning: might be a number, not a string if(typeof myVar === 'string') { myVar.toUpperCase(); // All good! No warnings because I did a typeof check } It also understands the `instanceof` operator. But often in JS, those aren't enough. We have mixins or object literals or we're not using classes. So we can write custom type guards. function isADuck(d): d is Duck { return d &amp;&amp; _.isFunction(d.quack); // We can do whatever we want to prove that d is a Duck; TypeScript will trust us. } myAnimal.quack(); // warning: might not be a duck if(isADuck(myAnimal)) { myAnimal.quack(); // No problem! } ...or you can avoid the whole thing with a type assertion: (myAnimal as Duck).quack(); // compiles to "myAnimal.quack();" and the compiler trusts that we know what we're doing Finally, a typechecker avoids the need for many (not all) runtime typechecks because they happen at design-time instead.
&gt; Next to no one is using Windows for web development or cross platform development. Nonsense. *Maybe* within some circles using the Facebook technology stack Windows is the minority, but React still dwarfed by Angular 1. We deal with a lot of different freelancers, MacOS is more prevalent amongst designers and HTML/CSS builders but otherwise it's a fairly even spread. We also do Unity3D and Xamarin (cross-platform) work and those developers are heavily Windows biased. Anyway it's ridiculous in 2017 to choose a technology that isn't well-supported on both. Facebook is delusional if they think they can ignore Windows and see competitive adoption rates for Flow. Then again maybe they don't care. Unlike Microsoft which actively tries to win over developers, I get the sense that FB makes technology for themselves and if other people can make use of it fine, but they're not going out of their way to win developer mindshare. Right now I can choose a cross-platform compile-to language, or a MacOS &amp; Linux compile-to language. It's not really much of a choice.
Also working for a company that prefers Microsoft products (apparently there are a few) and I use git-bash whenever I can. Like any other bash implementation on Windows it gives you a sensible layer to interact with the nonsense beneath. It does mess up paths tho, that's the only downside I've encountered so far.
Check the facebook share button api
I might include in my CV that I can guess most xkcds from the context
[removed]
I recently came across InversifyJS that you can look into.
Wow, lots of assumptions there. I don't know if anybody have this guy requirements. Don't know if it's intended to work in an enterprise environment. Plus what the hell kind of enterprise security requirements don't handle the 3 major OSs. Plus doing a copy and delete isn't atomic. 
Wasn't this the popular transpiler before 6to5/babel came along or am I missing something here?
It was used before UglifyJS. It's a JS compressor. "It parses your JavaScript, analyzes it, removes dead code and rewrites and minimizes what's left. It also checks syntax, variable references, and types, and warns about common JavaScript pitfalls.".
So if I use some 3rd party jar in my Java project. I don't use 'plain java'? Same analogy with using jquery/bluebird _libraries_
üòÑ
You use a 3rd party jar to support concurrency?
Scala.js is awesome! Make sure you read Li Haoi's blog titled Why I Bet on Scala.js to make things clearer...
Es6 in chrome console??
Thank you so much! Just merged it! ‚ù§üëå
&gt; Why can't the comma simply mean "this is a distinct item in this list / set / array" or "all references to this element precede this marker?" Okay, I am fine with that. But characters used as syntax elements should be consistent throughout the language. When we use it in functions, we should be allowed to use it wherever you have more than one distinct item in a list.
Don't want to derail the discussion, but I personally think it's a humbling engineering effort and could solve quite some pains as it matures? Bash much like JavaScript has it bad parts. But the good part certainly is that it is everywhere, with BashOnWindows that holds even more true than before.
If it does this consistently and with throwing a proper exception/error message the developer can take care of, then yes.
Thank you, man! 
&gt; suppose a function add two numbers , if you pass it 2 and 3 it will output the correct answer of 5 [...] BUT if you (by mistake) in your code pass it a 4 and 'user' [...] http://codepen.io/anon/pen/KajZRP?editors=0011 &gt; the problem is that dynamic typing does't prevent you from shooting yourself in the foot Right, and therefore wear bulletproof security boots (i.e. in your function make sure that all input is validated and an exception is thrown - or anything else is done, it all depends on your programming style).
How is the Closure compiler nowadays ? A few years ago I dropped it for uglify because it was too slow (unless you removed most minifications but then it wasn't compressing enough) and because it was asking for a very java-like style of code. All the experienced JS coders I know dropped it at about the same time. As uglify still isn't at ease with ES6 this might be an opportunity for Closure but only if it massively improved.
Take a look at this article. I think it may help you. http://book.mixu.net/node/ch6.html
Maybe we can have it in the output at least? http://codepen.io/Linuxdirk/pen/BpgrLW?editors=0011
This type of micro-optimisation is most of the time an anti-pattern. Do not do it. There are thousands of writings why this is bad. If you have a project where even the hundredth of a millisecond is critical, you are either a liar or should use c++ for the critical parts.
I agree that micro-optimisations are not worth it if the code readability is going to suffer. I did this as a journey to understand Node.js performance pitfalls and some of the major learnings are that `.forEach` looping more than twice as slow as `for` loops... at the moment. Another learning is not to change shadow class, which can reduce your performance significantly. Agree that a ray tracer, or any performance critical code, should be written in C++ and not JavaScript if possible, but it's not always possible.
Thanks for the info. Do you have a link for the monorail tutorial that you mentioned...?
How slow was it that speed was a serious impediment? Uglifying is a production build step, so unless it's _very_ slow, that shouldn't be a real issue. The code style would be a bigger issue for me, I think.
The `new` keyword executes the function, and creates a new object from the result. Because the result of your `constructor` (`Test`) function does not reference the `something` method, it is not included with the resulting object. The prototype of the resulting object is not the `Test` function itself, but its prototype, which doesn't have the `something` method. You could make it work with function Test() { return { something: () =&gt; Test.something(), } } For example.
Ahhh got it thank you :) that makes more sense.
In this use case the `Test.something()`, will work as a static method. Isnt it ?
[This is a dated document on V8 Optimization killers](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers) I did hear that try catch no longer causes deopts, but I haven't had the time to test. [IRHydra 2](http://mrale.ph/irhydra/2/) is a great tuning tool for seeing what's happening under the hood.
It also uses the JSDOC annotations for optimisations during compression. see: https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler
&gt; 2 spaces after a period Who in the right mind does that! This is madness!
Webpack plugin: https://www.npmjs.com/package/webpack-closure-compiler
Yes, and this jsdoc thing is absolutely horrible. It looks like something which was designed by a Java project manager.
The first point is definitely not ideal and makes it non-starter for me. Second point: it comes with TS definitions so you still get the autocomplete, just from a different source.
[removed]
No. I just thought achen was jumping up and down on you for no reason.
It is doing great actually. Lots of improvements recently. Also Webpack is looking for a deep integration with it to solve optimization problems that UglifyJS is unable to solve https://twitter.com/TheLarkInn/status/833383430465388545 I wouldn't agree about GCC asking for ‚Äújava-like‚Äù code style. It doesn't require anything fancy except predictable code without JavaScript quirks like hoisting or global `this`. So basically the compiler forces to write a better code, imho. Here's the official JavaScript style guide from Google: https://google.github.io/styleguide/jsguide.html
Yes I agree. If you have the chrome devtools at hand you are maybe better of using it. It was intented for complex raw data objects (like you said) in Node.js.
The big problem with this document and similar ones is that there's nothing official and updated. It gives you hints for your optimizations, and sometimes it's very effective (I had very big performance improvements by remove all `delete` and by using prototypes) but frequently you just discover that there's no problem anymore with recent engines. 
The readme explains the most part. I recommend taking a look at the titles in the readme, I tried to explain as many things as possible in a detailed fashion.
&gt; This type of micro-optimisation is most of the time an anti-pattern. Do not do it. There are thousands of writings why this is bad. Of course there are thousands of writings. There's no better way to get clicks than to write blog posts that justify people's natural inclination to be sloppy and lazy. What's not an "anti-pattern" however is being curious and willing to learn more about the platform you're working with. And here we have OP who's discussing the internals of Node.JS and its implications on performance. You can learn and then you *still* choose to optimize or not optimize specific parts of a project, but at least you'll be making an informed decision. I, for one, don't need another thousand articles telling me "it's ok to mash your keyboard until it sort of works, don't put any effort into it". I need in-depth technical articles that teach me something. BTW, since the project being discussed is a "raytracer", optimization is pretty much most of the project here. A popular industry raytracer VRay recently won an **Oscar** for their work, and a lot of the innovation is how to make complex effects run faster, which makes them practical for Hollywood's rendering pipelines, rather than exotic math equations that go to die in an academic paper. Of course, I'd probably not use Node for a raytracer... but real world projects sometimes dictate even stranger platform requirements.
It does! I've just done a bit more reading too. I believe that passing objects that make the request keeps the function pure. Making the request in a function is not pure as this can introduce side effects e.g. if the server is down etc. However a pure function that merely executes a side effect which is wrapped in a higher order function that takes care of errors etc is still pure. I'm finding it hard to explain haha.
Simply put, a promise can never ever be pure. That's the nature of a promise. It can pass or fail. If your function accepts a promise, it is not pure. A pure function will always return the exact same response for any given input. 
Very true, but a promise in a higher order function that handles the error cases would be pure right? I think that's getting towards being an adapter in hexagonal architecture?
Nice work! [Code Wars](https://www.codewars.com/) also does exactly that, but it's never a bad thing to have options :)
I'm trying to give some structure to a front end. It's not a case of purity for purity's sake. I think the hexagonal architecture pattern is a really good fit for front end. I'm trying to grasp how the boundaries will work. I firmly believe that functional core code makes reasoning and testing a lot easier and is something that's lacking in a lot of front end projects. I agree shoe horning everything into a pure function is a waste of time - if you're doing it with no real aim. 
I made this project while learning React: Live version--&gt; https://strothj.github.io/twitch-split/#/ https://github.com/strothj/twitch-split 
&gt; but "js fatigue" is from people who are new to JS I don't think being new to JS has anything to do with it.
I think it does, we who have been doing it for a while are used to the pace and have no problems with it. We may find it amusing / even a tad irritating, but wouldn't go as far as labelling it "fatigue"
[removed]
&gt; I need this really urgently though! Shortest joke in the IT support sector: urgent.
But is it if it's in a higher order function that returns a promise that will never fail? I believe that is then pure. I understand nothing, especially front end JS, can be pure. We can push these side effects to the boundaries around core code though but we will eventually need boundaries between core code and side effects. This is where I'm wondering what the best approach is. This is all related to trying to apply hexagonal code pattern to JS code.
You are right, the benchmark I found is not correct. ForEach is still slower then for
Does anyone know any js libraries that have template matching and feature detection or other image processing techniques that are used in libraries like OpenCV?
I might be missing something, but what is the benefit of a library like this, over something like: import foo from './foo'; export function Bar(fooDep) { return function(someArgs) { // implementation } } export default Bar(foo); This allows you to use the module from the default export, or if you want to mock the dependencies, used the named export and inject them yourselves.
That's true. I'd say the exception could be .then if you control the values being passed through this.
A function is pure iff for a given unique input, x, there is only one output, y. Now there could be many x that return y but there can never be an x that might return y or z, or y and z. For example 2+2 is pure because it's only ever going to produce 4. f(x)=x^2 is also pure even though putting in 2 and -2 both give back 4 because it's a single input with one output. Multiple inputs can all have the same output but a single input cannot have multiple outputs. Edit: didn't really answer the question So, it could be pure using a promise if that promise is always going to return the same thing for a given input. If, however, it's requesting data from somewhere there's no guarantee what the output will be for an input, it could change, then it is not pure. 
I think [this](http://stackoverflow.com/questions/12152409/find-all-combinations-of-options-in-a-loop) is what you're looking for. Take a look at Phrogz's response.
I think it's because the server is under heavy load. Try clicking the link again? :/
Wow, that's nice!
Is there a better solution than what I'm thinking? What other way could I approach this problem?
&gt;The I/O they control is the browsers themselves You're thinking too high level I believe. It's also very easy to create a UI that is not hexagonal at all. When I say hexagonal, I mean coding style, and by that I mean isolating the side effects such as button clicks and data fetches from core code which should be functional. Hexagonal architecture is all about have functional core code and moving your side effects to the periphery, so to speak, as adapters. This creates testable, reusable code. I believe you're getting a bit muddled or looking too high level as hex architecture can't be applied to jQuery in the way you're stating. It's an abstraction, not an implementation of the hexagonal pattern. Even if every browser had a different implementation of each, it would still be functional. Did you get chance to read: http://engineering.laterooms.com/hexagonal-architecture-in-practice/ This is the key take away: &gt;The idea is that your core application logic is independent of both its clients and any services it uses That really explains it. The clients in this case are side effects such as manipulating DOM elements, fetching data. Any action that has the potential to give different outputs based on the same input. 
Having an understanding of these concepts isn't a problem, the over use of them, and unnecessary use of them are the problem. If you know of, and understand these small optimizations, you can easily see places to use them and begin writing non-bloated implementations of them by default. You can say the same about big optimizations like changing the O(n) of functions, if you don't fully understand O(n) or the function, spending time trying to improve it is a waste, but if you get to the point where O(n) is second nature, and you have complete domain knowledge, writing O(n) optimized code becomes second nature.
This is what I'm coming to understand and then my co-worker told me about hexagonal architecture which essentially is this. Isolating your impurities (because nothing is pure) and keeping as much as your core code as functional as possible.
IMO, a better resource is [on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Iteration_methods). Also, it kinda bothers me that the title is "without loops" when even in the post it is mentioned that there ARE loops, but now they are just hidden (complexity).
I did. It was both convincing and not reassuring. The act of taking a defensive position is shooting yourself in the foot. 
I use uglifyJS with the *--mangle-props* option. It takes quite a bit of configuration and testing to get it to actually work, though. Some here have pointed out that it is possible to understand minified code, which is true, but personally I feel better knowing my source isn't public.
There aren't many at all, I will try and find one. I think jQuery was a bad example for me to focus on though as it is heavily focused on DOM Manipulation. I'm just figuring out how it would be done and have only just started writing code in the manner. What I will say is that you still have to test UI but you can shift that testing into Acceptance testing and make more of your tests unit tests. I wasn't going to reply but I had to as I agree with what you've said here. I agree they are written I/O based but they're not entirely hexagonal. If they were then the interfaces would be $('someID') which would then be an interface for some core code that can take a list of IDs or whatever and return a value after filtering them. That way you can unit test the core business logic underneath. This would be browser/environment agnostic. You could then acceptance test the interface ($('someID')) using a browser environment or shim. This would be how you could turn jQuery into a full hex pattern. It might be a bit over engineered in jQuerys case to be honest but that would be how it could be achieved. The way I think of it is browser operations like DOM manip/ clicks etc are interfaces and what happens is the core code. 
You forgot completely to document clearInterval as a way to disable setInterval. Also the usage of new Date().valueOf() to measure the real time of calling when using setInterval in order to "adjust" internal measures (typical of games)
Depends on what you are doing. If you are creating a clock. you have the data "externally" (through instances of Date), so all you basically need to do is to update the clock every once in a while. For this kind of usage, recursive setTimeout is ideal because of the lack of extra executions. However, if you are applying more or less pure transforms to a state object periodically (for example if you are doing the tick loop of a game engine), it may be helpful to insert the ~~execution context~~ message to the event queue with an interval. Like the article said, there will always be some delay, but with setTimeout it will slow down your tick loop, creating inconsistencies in game speed and potentially desynchronizing your timer (if it's a multiplayer game, or, in non-game use cases, if you are using any sort of a cluster where two things have the same timer). With setInterval, the tick loop will always catch up automatically without a single line of extra code, and in a specific interval you will always have the desired amount of ticks.
&gt; You forgot ... It's not my article :). Good catch about clearInterval, but in the end - it wasn't the point of the article (I'm guessing people who are interested in this type of discussion already know what are setTimeout and setInterval, and how to use them).
Interesting point of view. Do you have a link to some article with more explanation, examples or anaysis?
If you use a JSX string as data you need a "XML parser" which is a lot more complicated than JSON parsers. Using a JSX parser in a server would just make things more complicated if you need to manipulate the data, sometimes the servers (in my case it is 100% of my servers) have no idea of what JSX is but they all understand JSON, so I can make the servers manipulate the JSON structure and send it to the client without having any idea of how it will be rendered.
That's a false feeling. Your source code is still public. Minification is nothing more than a minor speed bump even without special tooling, and there are a plethora of "de minifiers" on the internet. 
It is not but parsing a JSX string is not that different from parse a XML string. You have opening tags that have to match the closing tags with the same tag name and etc. A JSON parser is simpler (and faster maybe), which makes things a easier for servers to parse and generate a UI schema for later use.
Awesome! This is the primary reason why I switched off of uglifyjs2 in favor of [babili](https://github.com/babel/babili). I would also recommend giving it a shot, it's very well done and seamless if you already use Babel.
Nice. Thats a lot of effort put in :) The full API spec is posted [here](https://youtu.be/dQw4w9WgXcQ) though..
It really depends on what you consider "source". There is significant value in function, variable and object names, and recovering those from minified code isn't trivial.
If you're the author, why use processing.js instead of p5.js?
I've never said it wasn't unit tested. I know it is, I looked through them. What I'm saying is that there is a reliance on the Dom for the majority of those unit tests. I know there are a lot of methods that are unit tested that don't require the DOM. Those are irrelevant, they don't require the DOM, they meet hexagonal design by accident. To truly see if something is hexagonal, you need to see how it handles code that ties it to side effects e.g. Those that require the DOM. And it doesn't handle that code in a hexagonal pattern. Therefore jQuery is not hexagonal design by a conscious decision. Very very little is, it's relatively new, as I was saying. Some things may borrow principles from it but as a whole it being applied to software engineering is quite new. 
I took out the meta stuff and replaced it with just java script. Then I realized I could use an if and an else if statement to get what I wanted. Works fine now.
The second idea could be to put navigation informaiton into browser storage (localstorage, cookie, etc). To match more and more tags uppon the navigation
That's pretty cool! It's very similar to [http://multitwitch.tv/], but I do like the presentation and search feature. My only issue is that the searching is kind of slow, but I'm not sure if you can really do much better. 
If that's all you've picked up from that last comment then it's I who give up. You're just getting petty now. I've mentioned in another comment it's old but it's only newly being adopted today. As you said. Show me a front end that's fully adopted it. You missed the nuance of what I was saying. You keep rehashing old points. I'm not talking at an architectural service level. I'm talking at a code level. Very different. Look let's just agree to disagree. I'm going to stop replying now. 
Thanks for the comment. That's actually what I was cloning :-p. I added a debounce function to the search so it should now feel more responsive.
Forget about javascript and just switch to Brainfuck.
Thanks! This looks something I could use.
The new warnings from Chrome Canary about my setTimeout handlers violating some 100ms or greater timestep, and also my app not using passive event listeners, is getting me all riled up on optimizations/fixing scroll jank 
Such a good answer :) thank you for the detail
Fair enough!
I would suggest taking a look at Koa instead of express. Postgresql instead of Mongo. Just my personal opinion after having built systems with both the stack you mentioned and the one I'm suggesting.
Nice! I dig it. However when I click the "Run" button the console says "Running" with a spinner and then it just returns to the "ProTip" view without ever showing me the results of my code. That makes the IDE essentially useless. Fortunately these challenges are easy enough that it doesn't matter, but the moment you ask someone to work on a challenging problem they'll have to write and test their code somewhere else and then come back and paste in their solution. 
we were indeed opting for postgres instead of mongo. Not really any experience with Koa though. Will look into it, thanks for the help!
Client side routers, generally speaking, wrap the [History API](https://developer.mozilla.org/en/docs/Web/API/History) and call some function when particular url matches. In React's case, it will call the render method of whatever component is defined in your route. Basically it's "hijacking" the normal URL changing behaviour so it that doesn't make another request to the server and instead acts like a global variable which you, or a routing library, can respond to however you wish.
Koa v1 uses coroutines and generators, the forthcoming Koa v2 uses async/await ... both allow you to write much more synchronous looking code and avoid "callback hell" or ugly promise chains. It makes a big difference. I suppose you could do the same with Express, but it's baked in to Koa. Koa is the spiritual successor to Express, written by the same dude, TJ Holowaychuk. So consider he wrote Koa after learning things creating Express. For that reason, I consider it probably is better. I've never had trouble finding middleware for Koa, either. 
I have tried using it, still nothing. The right panel just spins and says "Running" and then goes back to the "ProTip" view and displays no results. I tried opening the chrome dev-tools console as well, and that prints out "execute returned: result:" every time I click run, regardless of what the code I write is supposed to do.
If it's a requirement by some customer, and they often want this, tell them that javascript code is never "secure". A user can do whatever he pleases with the javascript code that runs in his browser; minification/obfuscation is only a minor hurdle for someone who is dedicated to take or modify your code. Users will be able to debug through your code and thereby get a grasp of what each part does, and they can modify it in-place to do fun stuff. They will also be able to grab any resource they receive (binary data, images, etc) and do what they want with that. Obfuscation isn't going to secure your code or ressources, at least not against dedicated "thieves". Minification is, however, useful to reduce the file size of the code since it removes anything that isn't necessary for execution and it will replace all variable and function names with a few characters. If you want to secure something that youre sending to customers, do so with licensing terms. 
ProcessingJS is more like an interpreter I think, while P5 is a pure JavaScript. And last time I use P5JS they were still in beta.
So the "debug" version processes only the first element, and the only side-effect noticed is the time it takes to run? Hmm.
http://i.imgur.com/LloUwN3.gifv
Can't speak for the Express side of things, but I got all kinds of info and advice for React. The standard advice is to focus on learning React itself first. Once you have a good understanding of how React works, you will better appreciate why a state management library like Redux can be useful. Don't over-complicate the learning process by trying to learn many different things at once. You should start out by reading through the official React docs and tutorial at https://facebook.github.io/react/, and I'd encourage you to use the official Create-React-App tool ( https://github.com/facebookincubator/create-react-app ) for setting up projects. It creates a project with a solid build setup, with no configuration needed on your part. Past that, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. My list does have a category on "Project Structure", although it's focused just on the React part of things, and not trying to mix together React plus a server-side piece. It also has sections on Webpack configuration and usage if you do want to get hands-on with your own build config. One specific article that deals with a React+Redux CRUD app is [Building a Simple CRUD App with React and Redux](http://www.thegreatcodeadventure.com/building-a-simple-crud-app-with-react-redux-part-1/). Also, while it's not as much of a full-stack-ish tutorial, my ["Practical Redux" tutorial series](http://blog.isquaredsoftware.com/series/practical-redux) shows off a number of intermediate to advanced Redux concepts in a sample app that's more than just another TodoMVC example.
That's amazing feedback and advice, thank you very much! Just to be clear, I was planning on learning both React and Node/Express separately, as I am already doing. However, sooner or later there comes a moment when you want to combine both sides in one app and although i found some great resources for both technologies separate (and now even more thanks to you) I did not really find anything that nicely combines the two. But again, thanks for the help! Very, very useful :)
http://i.imgur.com/m0W7km1.gifv You were probably not calling the function.
Oh yeah, definitely was not. I assumed that's what the "Run" button was actually doing. 
Dude, this is pretty awesome. I've just started learning this stuff myself and am excited to use this is a tool to improve.
You are right...no errors where return so and the array was drop in Mongo. But yeah...only the first element was processed. Never assume anything... Thanks!
Well... I just got rolled...
[yep](https://scontent.cdninstagram.com/t51.2885-15/s640x640/sh0.08/e35/12543308_1035766393132355_693989785_n.jpg?ig_cache_key=MTE4MDIwMTM1NjI3NDg5MzU0NQ%3D%3D.2.l)
that's true, you get same result and indeed microdi does it pretty much that way. The whole benefit is in writing less code for definitions and injections, especially in ES6 notation.
&gt; I was like, oh yeah and then I left the room. Immediately forgetting what he stated. Since you know I didn‚Äôt like the guy‚Ä¶ If he didn't truly understand what the other person was saying, why dismiss it entirely just because they "disliked" them? The other person could have been driving at something insightful to dig deeper on. Instead, he acted like a child. The supposed "Mr. Stupid" phase doesn't excuse you from being a decent human being. Also, why even include that bit in the article? Maybe I'm being too sensitive... :p. Just got bad vibes. 
There's a big temptation to treat functional programming concepts as the next silver bullet, but I think a lot of them aren't going to turn out as well we think. &gt; Data is just data. It doesn‚Äôt have methods. It doesn‚Äôt have behaviors. It doesn‚Äôt have custom getters or setters. It‚Äôs just raw bits in the form of JSON or something similar to JSON. Here's the downside with doing that. Let's say your data holds the year, month, and day of a date. It turns out that manipulating that data is deceptively tricky. // Copy a date and add days const newDate = Object.assign({}, oldDate, {day: oldDate.day+2}) But it's not as simple as adding days. Should we roll over to the next month? What month is it? Is it a leap year? Now imagine thousands or millions of lines of code, all of which directly manipulates this raw data and has to get the logic right to keep that data in a valid state. That's not going to end well. The solution is to pick a small handful of functions and decide that only those few functions may directly access the data. Every other part of the application must manipulate the data only indirectly through one of those few privileged functions. Except... we've just re-invented methods. Ultimately a method is just a function that we grant permission to access data that we keep private from the rest of the application. &gt; Function currying is useful for pre-populating one or more function arguments with different values. *Partial application* is useful for pre-populating one or more function arguments, but *currying* is the more restrictive and less useful cousin. The problem with currying is that it doesn't let you pre-populate any arbitrary argument. It only lets you pre-populate the next one in the list. So, for example, the signature of xhr.open looks like this: `xhrReq.open(method, url, async, user, password)`, and if I wanted to pre-populate just the URL... currying can't do that. OK, well maybe that's xhr's fault for not having a curry-friendly parameter order. Let's pretend we can re-order xhr's parameters. Now the signature looks like this: `xhrReq.open(url, method, async, user, password)`. Great! Now currying can pre-populate the URL. But... what if in a difference place I actually want to pre-populate the user and password, not the URL? Once again, with currying we're stuck. There is no parameter order that will work everywhere. Partial application is useful, but currying seems arbitrarily restrictive. &gt; Function composition This one isn't bad per se, but it's severely over-hyped. `h(g(f(x)))` That's it. Using the output of one function as input to another. That's literally all it is. That's the kind of thing you'd find in the Intro to Functions chapter of a Programming for Dummies book because it's *that* basic. Yet the FP crowd seem to treat it as if it's the latest and greatest in programming. A special compose function might have been interesting if it let us read the functions from left to right (`f, g, h`), but Rambda.compose doesn't even do that. &gt; A pure function (sometimes known as a stateless function) is a function that has zero side-effects. This one too isn't bad. Pure functions are indeed one of the good parts of functional programming. The only bad part -- as was done in this article -- is pretending to contrast with OOP, as if OOP by definition cannot have pure functions (or pure methods, as the case may be). It absolutely can, and the best programmers have been advocating for it even before this recent functional craze. [Here's an excerpt](https://i.imgur.com/Zn2mApB.png), for example, from Robert Martin's Clean Code, a book which was published in 2008 and uses Java code examples, and in which he advocates avoiding side effects.
Maybe just a little too sensitive. I'm thinking it never happened and this was his place to try and insert some humor into the article, however contrived. 
lol 
Not possible. Here is a deobfuscator that uses statistical analysis to automatically re add scrambled variable names based on how they are used. Thus, even obfuscated variable names are not even a speed bump anymore. http://jsnice.org/
In your for loop you're not assigning a new value to count. `count + 1` won't work, but `count = count + 1` or `count++` will.
If you did this you cannot unit test Bar with a mocked foo
Can I be confused?
Of course, you can, but it is supposed to be the Bower logo: https://bower.io/
I feel like webpack could get you there, but I don't have any examples to provide you sorry. What you're probably looking for is an ES6 module and an ES5 compat library. The latter 2 would work well with webpack as it now transforms (in version 2) es6 module import export statements automatically. You could simply make 2 different outputs (scripts), one with the full kit (babel, whatever transforms you need - object rest spread etc) and one with just webpack itself (es6 module). The latter would work on newer node versions just fine (node doesn't yet like es6 import export statements). So I'd recommend using webpack 2 with 2 configurations exported to build both of these, which should work in most places as long as you're mindful what you write/transform. If you're writing es6 only, then my suggestion holds. If you like adding staged features to your code from es7 and beyond then you should transform those in your es6 module output too (with babel, but without es5 preset).
Awesome. Thanks man. I have started using electron. Thanks for the suggestion!
You're welcome.
You're welcome.
They basically are promises so yeah
Yea... cause asynchronous functions are for working with promises. 
Hey! So maybe the title of the post isn't great, wanted to come up with something punchy -- but the article is basically saying "even if you want to use pure async/await, you'll probably need to use raw promise constructs at some point also, there's no avoiding it". The first paragraph mentions how async/await is built around promises.
WebSocket server seems down..
Seems fine here, few people are playing. Could be that your ISP/Router blocks websockets. Try appending ?polling to the url to see if that's the issue.
You're welcome.
It's simply not true.
It actually did happen and I learned much from that experience. Which is the main reason I put it into the article. Web development is not only about code it's about social relationships as well. People should get the best out of every situation. It is sad to know that "tonybaronee" acted the same now. Instead of reading the tech side of the article he marked me as "jerk" and missed the whole point.
I am sad to read this. Everyone have freedom of talk, but in a same way everybody should use it wisely. You just marked me publicly as "jerk", which is not nice at all. You did all that without knowing me a bit... More than anything, by being offended you missed both tech and personal points from the article. Which are very important for anybody who works in this web development industry. Additionally please have in mind that when people talk bad about others they actually say a lot about themselves.
sorry just updated with what ive tried, the box shows up but not the images. 
I've used all of the frameworks on that list. Vue is by far the best progressive framework out there today.
You're welcome.
A lot of the `let`s in those code examples should be `const`s. :-)
[removed]
Oh wait, another garbage post that subtly promotes Aurelia. Nice, I missed these. 
Choosing the right JavaScript framework is never about the number of features that the particular framework can provide. It‚Äôs about the actual functionality of the framework and how that functionality can be utilized within your own development project. 
s/should/could/
Of course you're *looking* at the original code, but when it comes to actually debugging it statement-by-statement it doesn't always map correctly (sometimes it'll skip statements, or you need to click "step" multiple times, etc). You can't "step" over a transpiled await for example, because it is probably implemented with a Promise.then callback under the hood.
TypeScript, at least (which I use), compiles it in a way I can debug transparently. Under the hood my function becomes a big "switch...case" but the code is in order, and every source line has its out output line doing the identical thing, so it's fine. I also think if you target an engine that supports generators, then the output is even simpler, "await foo()" simply becomes "yield foo()". Also, you can debug with an async capable browser and then do final compile for a lower target. That's not uncommon. 
So you're saying you instantly deduced many of those "let" *should* be "const", while at the same time you need "const" to deduce author's intent. Those can't both be right.
&gt; With es2017, async/await is just around the corner. I don't understand when people talk about ES2015+ features as if they 'land' on a particular date. In order to use any of those features, due to backward-compatibility, you're going to have to transpile your code. If you do that then you have access to *all* of ES2015+ features (perhaps as a half measure you'll only take stage-2/3/4). Either you transpile and you can use those features *now*, or you want to wait for native support in which case its at least 5 years before you could do that for &gt;90% of users. It doesn't make sense to talk about ES2017 as 'right around the corner'. Edit: Solid article, though.
"I won't reassign this local variable" is not an absolute win for readability. It can be argued. If we were talking about declaring an object field, or a global variable as `const` then we can argue it's useful, because otherwise said field/var would be editable from different contexts, which may not have full knowledge of the contract the origin of the field/var is trying to enforce. But a local variable is a not a public contract. It's by definition an implementation detail within the scope of a 5-20 line function, typically. Declaring explicitly "I won't reassign" is just as interesting most of the time, as it'd be interesting to declare things like "I won't be reading fields on this object" or "I won't be calling methods on it" or "I won't be passing it to functions". It's basically not interesting at all, most of the time. May I remind you also that "const" doesn't do a thing for the immutability of objects? If you're willing to declare a **primitive value** (number, string, bool) as const, that is actually handy, but when you declare an *object* as const it can be downright **harmful** for readability, because the object is certainly not a `const` unless it's explicitly frozen, and all its exposed object fields also are frozen, which is completely independent of the `const` declaration. How is it exactly helping, say, if you have this: const date = new Date("February 21, 2017"); // Later... date.setYear(1984); It's not helping at all, it looks misleadingly as if it's communicating "this object won't change its state", but what it really says is "this reference won't change, although the object it points to can change". And that's not useful to readability at all. So, basically you need to think a bit more in depth about readability. "I can express this, therefore I should" is not where it ends. It's also "am I expressing what people expect" and "am I expressing something people would find valuable in the course of reading this code". Because if you don't consider these things, you're not making things more readable, just more noisy through excessive pedantry.
&gt; May I remind you also that "const" doesn't do a thing for the immutability of objects? I'm aware. I tend to change to `let` if I'll be mutating at all as an aid to readability, though it isn't strictly necessary. I appreciate where you're coming from. If `let`/`const` actually guaranteed immutability across the board, would you agree with me? (Very keen to add something like Immutable.js to my belt as it happens.)
&gt; If let/const actually guaranteed immutability across the board, would you agree with me? Well it'd be better, but it's not the case. Rust, for example, has the concept of compiler enforced read-only method and read-only pointers, which are enforced at depth. It'd be very useful if I could not just declare a local variable as const, but to *pass a variable as const* to another method, to ensure it won't mutate it. let mutableArray = [1, 2, 3, 4]; foo.bar(const mutableArray); // foo.bar() can't call mutating methods on mutableArray. But we're not talking about JavaScript at this point...
Yeah, I've heard a lot of good things about Rust. One of the web dev jobs I turned down recently was experimenting with it on the backend, plus I've seen some proponents of it in /r/linux.
Yeah, people tend to forget that IE still exists. Edge seems a bit less of a problem (actually, nowadays it's competing with Firefox in HTML5 support and the auto-updater is nice) but with all those companies sticking to Windows 7, I wouldn't trust any client code that doesn't run on Internet Explorer 11.
My friend, you need to spend some time over at /r/webpack. :) It can be daunting step, but it'll roll up all those assets of yours into one quick(er) loading file. 
It makes some pretty eyebrow-raising claims, like saying React is difficult to learn, but that Ember is easy to learn. It also mentions performance as a pro for Ember (even though Ember has historically done extremely poorly in benchmarks including its own), and that Angular is more innovative because it's backed by Google. I'm just finding very hard to take this article seriously. 
[removed]
Oh, and since the constructor function can return something, the result of calling .fork on the Task is not a new Task, but whatever the constructor function synchronously returned. That makes it an ideal place to return any controls over the original effect, such as cancelation. 
Yes that makes more sense. Although, there, it's more about a node version release than a spec finalisation so it still doesn't make sense to refer to ES2017 in this context.
The article assumes transpiling will be required for client side.
nub
This is way out of date information.
A lack of external dependencies, but I personally don't like the syntax, and jQuery's promise implementation is good IMO
Awesome work! I've built a few very simple javascript games myself. I feel that javascript is particularly well-suited for making games. The simple canvas api or webgl api make graphics a cinch. requestAnimationFrame() is PERFECT for animation. I am currently learning how to use Electron to package games in a cross-platform compatible way. Yay for js game developers! 
I mean, it's a name that's pretty fundamental to computer science and functional programming. And given that it could have been called "Sch√∂nfinkelizing," I think "currying" is pretty great.
And if you curry map, then you can just write: map(x =&gt; product(2, x)) And end up with a function that does that to any nums. In fact, looking at both functions being curried here is pretty instructive: map( product(2) ) That's a very generic, simplified expression of what you want done... with all the cruft and even the non-relevant specifics removed. For some Functor, map over the value(s) by * 2. Now we can assign it to a descriptive variable... //mapTimesTwo :: Functor -&gt; Functor const mapTimesTwo = map( product(2) ) And note from the type signature that it doesn't actually even need to involve arrays specifically: it's an operation that could do that work over _any_ Functor with a lawful .map method. The ability to make things much more generic in this way is very powerful. And while js doesn't have native currying, it's relatively easy to create curried functions out of non-curried ones.
Not sure what why /u/fuck_with_me is being so adamant against what I'm saying.. I can think of a number of apps that work like this. Anyways.. separating repos is completely up to you. At my work we have like 4 or 5 apps talking to our backend and everything is in separate repos. Another I app I work on has the API, the web front end and the mobile app all inside the same repo. I've lately been leaning towards keeping everything in the same repository, just split on up folders, or by "npm_modules" (each folder representing something I would expect to pull from npm)
You're not wrong - I get 138 requests (!) | 164 KB transferred | Finish 3.04s I had a look at the source to see if its something I could help with, but this project is deeeeep into the `require.js` rabbit hole and there's no way I'd want to try. To be fair, for a game like this which loads once and then is used for a significant amount of time, optimising initial load doesn't seem too important. @OP nice job - looks like a very accomplished game so far, I hope you take it far!
What you are saying about the activity of the project is false. Look at the commit history: https://github.com/Marak/faker.js/commits/master It's a highly active project which is constantly having issues opened and closed. We must have merged 20+ Pull Requests the past 3 months alone. People open new ones everyday.
Just to clarify, do you actually mean this? const product = (x, y) =&gt; x * y; const timesTwo = curry(product, 2) someArray.map( timesTwo ) // The x arg from map is passed into timesTwo which is now only expecting y since we curried x with 2.
Thanks! This makes sense. I just finished mapping it out on some paper to worth through the composition chains. I love this idea and I'm going to start using it. I love the lazy evaluation and compostability of it.
It's just a metric of what people find interesting, or show support for, without getting notifications for all discussions (watching a repository). It's basically a popularity contest.
I made JavaScript performance benchmarking playground, alternative to JSPerf. https://jsbench.me
Isn't this just a single page app? What makes this not a SPA? Everything is done client-side in SPAs: Routing, controllers, models etc.
Does anyone seriously believe JQuery's ajax requests are causing performance problems? What a joke. You're all brainwashed.
Ah, that would explain it. They do all work for a large company as well although that doesn't really excuse it, when others in the company are largely up to date. Actually been using Firefox 3 today for testing and it's an absolute nightmare.
So what? Show me one another Github project with 9000+ stars and less than 100 open issues. Collaboration at this scale is an ongoing communication process with 100s of developers. You want to see it done better? You should [try contributing](https://github.com/Marak/faker.js/network/members) sometime. 
Love the art style.
That does look easier to read, and probably preferable. Unfortunately maybe a little out of proportion as the tiles' art was not designed to look like this though...
Why do your reducers have side effects? Put side effects in action handlers, not reducers.
I avoid Bootstrap nowadays, but VueStrap and VueBoot exist. If I absolutely *need* the jQuery API for quickly porting code or necessary plugins, I'll try my hardest to stick to [zepto-modules](https://www.npmjs.com/package/zepto-modules) (uses as little as ~7kb gzipped).
The generator-based version isn't so bad - if you're compiling async/await back to just ES6, it's very close and readable. You're right though, back to ES5 or below is extremely painful.
Wow, looks really awesome! Totally gonna check out it later!
It helps, ok. But that's not how you make decisions. Programming is about time trade-offs. If we were all immortal, I'd have a different opinion. But unless you're going to personally devote your time to make this happen in a way that doesn't conflict with the other *real* work that needs to be done, pointing out a few tips from the peanut gallery doesn't mean they are important tips. If I were them, I'd just look into presenting the user with some sort of loading animation so the user knows that something is happening, and then I'd go back to the hard part of building a game instead of procrastinating with webpack.
I found your issue at: https://github.com/Marak/faker.js/issues/409 and responded. It's not that "no one gives a shit", but you aren't adding any new information to the conversation. This isn't a bug report or a new feature. It's a request for help on a topic which was previously discussed and resolved [two years ago](https://github.com/Marak/faker.js/issues/199), and is covered in the basic documentation.
Usually (assuming you're using redux) you'll use `models` (kind of confused by what you mean here?) and include `window.__PRELOADED_STATE__` in the document you serve. Allowing the client to pick it up and rehydrate the Redux store client side. [Here's a good example from Redux](https://github.com/reactjs/redux/tree/master/examples/universal). Of course this only works with non-sensitive information. If you're data is sensitive it probably shouldn't be sent over the wire in the document. Rather, should only be accessed with an API call from the client with some form of a csrf token system in place. If you want an example of this, the [Electrode project from Wal-Mart Labs does this well.](https://github.com/electrode-io/electrode/blob/master/samples/universal-react-node/src/server/plugins/csrf.js) 
Thanks for your feedback. I should definitely have talked more about my actual design. I will remember this for my future articles!
He's not even wrong? Programmers using javascript know it has many warts and work around those warts to the best of their ability. It seems to me that a growing trend among JS programmers is to go further up the hill of compilers/static checkers. People began with linters and now are "graduating" to static or gradual type-systems. I consider myself a javascript expert but, like the author, I look forward to a compilation target that isn't limited to javascript's semantics. 
Yeah, exactly. Bundling assets is pretty much the easiest part of building a game. Building a game is the hard part. These sort of optimizations tend to just slow down the hard part. We're talking about 165kb, a size smaller than most major blobs/news websites.
sounds cool will check it out
I also don't disagree. But he's presented this as a closer-to-the-end product, and inviting the internet-at-large to come and poke around. I bring it up because i was looking at a blank screen for 8.2 seconds. Webpack will speed that up, as well as obfuscate his code, so someone doesn't come along and steal all the work. But, a splash screen would be nice too. Perhaps [PACE](http://github.hubspot.com/pace/docs/welcome/).
&gt; The language is so bad that the use of a linter (such as JSLint or ESLint) is practically mandated for all JavaScript programmers. Is he really that hung up on a use of a linter? Linter's are as much about style guide enforcement as catching syntax errors. Also, attacking a language for wanting a helpful IDE-link environment seems like a stretch. &gt; I‚Äôve been writing web applications for over a decade and it‚Äôs utterly shocking how little JavaScript I know! Given his lack of JS knowledge, he probably isn't the best to be offering a critique. Sounds like he just has an axe to grind. 
&gt; What other modern programming language is so bad that a linter is most recommended for safety sake? Perl, PHP, everything really. There's no language that will not benefit from linter usage. I go multiple months between linter use in js. Then I run it and fix the five or six warnings I generated in those couple months. So no, linting is not "practically required." I would suggest the author learn the language he's using, rather than blaming it for his mistakes.
This is about number of "Stars" or likes of the repo, nothing to do with downloads.
Chances look good that it‚Äôll be in ECMAScript 2018 (the version after the upcoming ES2017).
Obfuscate code? It is opensourced, did you even read title?
Hi Hanehan17 Take a look at http://javascripttutorial.co/
I've worked on a few complex node apps and never needed any of these libs/tools. Configuration is usually just done via JSON file that gets required/imported, or via environment variables. Maybe with some more specific info, we can help with a more specific solution. What problems are you actually trying to solve?
Now, if only we had way to SSR it with PHP like react....
Just me though -- there are organizations/businesses out there that do absolutely nothing with github, but are day in and day out heavily dependent on jQuery for making their sites work.
Are you calling imagepicker() on the element like the docs say? 
I see your point but GitHub is not a common resource for people looking to use jQuery. Hence jQuery's GitHub page isn't likely to receive many GitHub-stars.
This sounds like someone who didn't actually learn javascript before they tried to use it! 
Any errors in your browser's console? 
Yeah could be, at home it seems fine. :)
I feel like I should light a candle for you or something!
Just my humble opinion: Add some DevOps to your skill set. Understanding how your app builds and deploys ties a lot of things together. Also - unit and integration testing.
Does this answer your question? ``` window.$ = window.jQuery = require('jquery') ```
&gt; `window`
First of all, to be honest, async / await and promises are more useful on the backend side than in frontend. However even if you dont really NEED promise or async/await in frontend, it is still nice to have. It makes easier to follow control flow. Of course if your website just loads some data and displays it, $.ajax with callback is sufficent. But what if you must make one ajax request, then based on result, either make two addtional request or display dialog window with yes/no options in HTML (not window.confirm) and if user answers "yes" then make another request? Easy: http://pastebin.com/zBRpzEVd However, could you provide your callback hell solution to this code? :) If you never did any complicated project, you wont understand the power of async/await. 
I've had the exact same question before and was equally disappointed in the answers: https://news.ycombinator.com/item?id=12791267
This is the only problem I have with const. I wish it would also forbid altering object in any way... however its not that easy to do in JS. What for example for methods of object? If you call them, they might alter object itself and JavaScript engine does not really know anything about method until the very moment when it is called (optimizations aside), so it is impossible to determine whenever object method is mutating or "const ok" method.
figured it out, I had added the &lt;script&gt; line for imagepicker before the line of adding jQuery. Thanks for your help. 
Thanks! Sorry about the post being broken. Thanks so much, I am just doing this on my own, I am watching YT and doing online classes, THANKS!
What is the problem with jQuery? I dont understand the people dislike it. It's a great tools and it was a big "evolution" to js developers. 
In terms of intelligibility, I go back and forth. For a single async operation, I agree it's probably overkill. But when a single operation decomposes into multiple and serially blocking calls, each of which contains some piece of information needed for a final result, it can be helpful/more descriptive. Consider needing to get a user's data AND all that user's recent comments, and that these are separate apis AND that the latter requires data from the former. If you want to return the entire user object plus the comments, it's not enough to just keep chaining with .then because you'll lose the user object along the way. There are ways to solve this with chained Promises, but it gets ugly again in a way that async/await can clear up. 
You're not truly full-stack unless you can write your browser only using nop.
I developed [Firmament Wars](https://github.com/Maelfyn/Firmament-Wars) and Nevergrind (and others) by myself and $.ajax worked every time. $.ajax({ url: 'somePath' }).done(function(data){ if (data.result === 'result1'){ // one thing } else if (data.result === 'result2'){ // another thing } else { // something else } });
More specifically, a developer who's well-versed in OOP, but stymied by the concept of prototype. 
Okay, it's great the author has to vent about his frustrations with JS; however, I find it funny how other languages are rushing to be more like Javascript these days (I'm looking at you, C++). There are things that Javascript does well like event handling; however, when you're new to JS, some of the quirks behind using a prototypal language seem to have a steep learning curve -- esp. if you have been strictly been using an OOP language for years. Then again, since I have worked contracts for Scientology in the past, have a fondness for Sweden (esp. Stockholm), and supported Trump, I suppose I have a cult mentality as it is.
Personally I just don't find it very useful anymore today.
Ya, Bower is probably the most common way people install and use jQuery if done through package manager and not just including it via CDN.
Could you provide some examples of the data you are trying to store in the state?
I think it's silly that the author seems to think Node.js is costing companies lots of money. Node micro services are small and easily replaceable. If someone ever decides to rewrite a Node service in another language they're free to do so, as long as the API behaves like the Node service did no one would notice, this risk is small. Now imagine deciding to rewrite a portion of a Rails/.Net monolith in another language. . . . . or even add a feature, well things WILL break. Old lumbering OO Monoliths are super fragile and interlinked like JENGA. 
Why, out of curiosity? I've never heard a compelling argument against Bootstrap.
Considering most vue users are using npmjs.org via npm or yarn, that's probably a better metric for comparison, and vue is nowhere near jQuery as it stands... jQuery has 8-10x the number of downloads on npm. [1] https://www.npmjs.com/package/vue [2] https://www.npmjs.com/package/jquery
IMO if you can create a web application from scratch with a back end server connected to a database, an API, and a front end that utilizes that API in some way, you're a full stack developer. Not necessarily a good one, but you are one.
I like using Bower from an organizational standpoint, as I like having the front-end and back-end packages separate. Otherwise, I would never use it.
Or, if using webpack, you can use the webpack.ProvidePlugin for it... which works most of the time.
I use react router for higher level routing with special match components (like in their examples) and then an &lt;Auth/&gt; component wrapped around anything that requires different levels of access. That just renders children or not based on whether the user state/types etc. match the criteria set as props on the component.
Well I have never used Vue, but what I do for Redux is I make sure nothing is more than one level deep. How I do this is I just reference nested data by the key of the data. Like for example if a user had something like a list of items to buy/seen then I would just store that list as an array of those items keys. I do this because 1. it makes it easier to create new copies and 2. If I ever need to reference the data someone where else then it's much much easier. Also Imagine if those item's prices/quantity changed dynamically, by some other service like a "marketplace activity feed", with flat Hash Table like data I don't need to alter the parent object(user) just to change a nested piece of data. 
use https://github.com/mourner/simpleheat demo: http://mourner.github.io/simpleheat/demo/
I use redux, so I just connect to the user part of the store. All the actual apis in my application use actual auth, so it doesn't really matter that someone could change the store values to get access to this or that view component: they still can't get at the data unless they can make authenticated requests.
I'll start by saying I'm quite new to JS as well and I started my serious learning path about 4-5 months ago. Callbacks are still difficult for me to explain but here is my best attempt of function and its arguments: A function is basically a piece of code that you want to reuse and an argument is a piece of data that you provide to your function in for it to work with. Eg.: function myFunction (arg) { return arg * 2 } myFunction(5) This will return 10 because when yoh called the function you passed in 5 as the argument (arg) which was then multiplied by 2 = 10 Im sure my explanation is missing something but I hope this can help you see things more clear, or if someone can put it to better words I will appreciate it
Good man!
isn't that like saying Ralph Lauren is more popular than BMW? I mean one can find overlapping areas, but they're essentially different things.
One thing I can't live without is the tabs.
This is a stupid comparison.
Here's another way to think about it: functions are just a special sort of value that you can combine with other values to by using a special operator: () that you can think of as "squish together" operator. const ten = 5 + 5; const increment = x=&gt;x+1 const anotherTen = increment () 1 Of course, the last one doesn't actually work, because that's not the actual syntax in javascript: you instead have to write: `increment(1)` But that's roughly the idea: squish `increment` and 1 together, and since increment is a "squishable" value, the 1 squishes into `increment` and we get 1+1, i.e. 2 Here's pretty much the simplest function: `x=&gt;x`, aka the "Identity" combinator. It can take any value at all and it'll just return that value unaltered. const I = x =&gt; x; One of the things you can squish into I is another I. The result, no matter how many times you do it, is just I again: `I(I)(I)(I) = I` Here's another famous combinator, K, which takes an argument and returns a function that takes another argument, and ignores that and returns the first argument: const K = x=&gt;y=&gt;x K(I)(9000)(9) = I(9) = 9 Squish squish squish.
Try this: describe('#expandChildren', function() { beforeEach(function() { // This should immediately resolve the promise spyOn(model, 'expandChildren').and.callFake(function() { return Promise.resolve(function(resolve) { resolve(testResponse); }); }); spyOn(view, 'update'); app.expandChildren(); }); // passing test it('calls model.expandChildren', function() { expect(model.expandChildren).toHaveBeenCalled(); }); // failing test that runs the REAL view.update method it('calls view.update', function() { expect(view.update).toHaveBeenCalled(); }); }); You are always allowed to have more than one spy in a jasmine test suite. I believe the issue is that your first spy does not immediately resolve, so if you were to log just above the view.update() call, you would get output, but it would be after the tests were completed. The solution should be that you return Promise.resolve(...), which is a promise that immediately resolves upon called. Hopefully this helps!
My argument would be it's now the Times New Roman of the internet. It is the lowest common denominator to develop and website that looks remotely usable. There's so many websites and applications made from it that it's instantly known if it was made with Bootstrap. None of this is inherently bad but the bootstrap look is very overdone to me personally.
It is way too strict with its styling to be just a wrapper for a big project. More often than not you'll waste more time tearing apart its features than actually profitting from having them. Besides the grid, the dropdown menus and the modals, most of the other stuff just ends up bloating your project because you don't want things as bootstrap intended them to be.
Thanks for the response! I'm actually trying to implement it in a typescript project: https://github.com/bitjson/typescript-starter/issues/12 I'm hoping to not require any runtime checking, but I'll definitely look at using `process.release` if necessary. Thanks!
Thanks for the response! It sounds like I'll need to use two pretty different build system configurations. I was hoping there was a more standard way to do it, but I guess it needs to be considered on a per-project basis. Thanks!
Yeah but that's the point. There's so many sites that haven't put the extra effort in (for a myriad of reasons I presume so I don't want to criticise them) so the look is everywhere. Even if you redesign and modify the classes it's still SO obvious that it is bootstrap to me as a web developer. Frankly, as long as your site works properly and the UX is decent, what framework one uses is of little concern to me personally but a lot of people are trying to get away from bootstrap because it makes a lot of sites look the same.
Very cool. Thank you for your advice!
Once again, a site looking "Bootstrappy" is not the fault of Bootstrap, it's the fault of the developer. It's the same argument as "A lot of application written in JavaScript are bad, therefore the language is bad." No, the language isn't (necessarily) bad, it's the developers using it that were bad. Scouring sites in the Bootstrap Expo such as https://trakt.tv/ and http://www.crit-research.it/ show that no, not every site that uses Bootstrap looks the same. Those that paste in elements from the Components page without adding custom styling do, however.
Target the div specifically in the code. This seems like an architecture problem. Can you paste some code to give an example? It sounds like you're going about this all wrong.
If you've really got solid foundations in JS, you'll be able to be productive in almost any C-style language within two weeks. You'll be able to ascertain typing fairly quickly, and most of the other constructs are similar (if not the exact same).
The OP stated in their post that they normalize data in Redux, which is what you are describing.
Now that I've read that zepto-modules link and the github readme, I know all about how to install, import and configure it. Now...what is it?
Yea for sure, there's tons of resources out there for learning javascript. Lots of decent youtuber series as well. 
have you tried it successfully? one redditor said that it is doable, but not feasible for them. And I have not tried it.
Do you feel like there are any areas of JavaScript itself that you aren't comfortable with? I like to focus on the core languages and standards, since libraries and frameworks come and go. Also, here is a great Q&amp;A about web technologies in general. Not all JS, but in the general vicinity of JS: http://softwareengineering.stackexchange.com/questions/46716/what-technical-details-should-a-programmer-of-a-web-application-consider-before Good question about good luck!
But More of a bot that would do this to a server and not a individual 
Functions: pieces of code behind labels, that you can re-use. function square_number(your_number) { return your_number * your_number; } Arguments: the pieces of information that you pass to a function. In the previous example, `your_number` is an argument to the function `square_number`. Callbacks: functions whose purpose is to indicate, by being called, that something has happened. A common form of controlling the path things take in an asynchronous system. function my_callback() { console.log('callback called!'); } function my_slow_actor(some_callback) { window.timeout(some_callback, 5000); } my_slow_actor(my_callback); It's okay to struggle at first. We all did.
&gt; functions are just a special sort of value that you can combine with other values to by using a special operator: () every part of this is wrong functions are not values, `()` is not an operator, and invokation is not combination this is going to very badly confuse people who listened to you when they get to the correct usages of those words
i second [substack's comment](https://www.reddit.com/r/javascript/comments/5vgf1q/what_are_essential_things_i_need_to_learn_as_a/de1ya08/). if you're not sure what kind of small project to make, consider making a web application. it seems that many people want to learn how to make web applications because that's what most of the jobs seem to want. more important than being familiar with the various frameworks is understanding the elements of a web application and how to create one. the best way to do that is to make one: write a server, run the server, make the site display something, make it do something with javascript. [here's a talk that substack gave on making a web app from scratch](https://www.youtube.com/watch?v=I_t_byKAL6U&amp;spfreload=5). 
The *mechanics* of related languages are often very similar, but there are quite often other influences (standard lib, third-party libs, community, etc) and conventions related thereto that will take you from *generally competent* to *native fluency*. I've been in this craft since '79, and over my career I've been paid to write in literally dozens of languages. I learned at least one and usually two languages a year right up until my third stroke three years ago. Each new language you learn *well* makes you better at *every other* language you know well, simply by getting you into the habit of looking at your problem space from different perspectives that aren't available to your monolingual colleagues. If the only tool you have is a hammer, then every problem starts looking like a nail ‚Äî up to and including a litre jug of pure nitroglycerin.
Bootstrap is great as long as you are content with coloring between the lines. But the second you try to go outside the lines, particularly with styling, the specificity and modification classes upon modification classes for even the simplest of elements basically becomes right click -- inspect element -- copy a paragraph worth of classes just to remove a border radius. Then again, most css frameworks - hell, css itself - are fucky in their own way. So I suppose it really boils down to whichever one is fucky in a way you don't mind so much.
tldr: YouTube playlist is static, this one is dynamic If you have used Play Music on Android phones, there is an option "Add to queue", this is equivalent to that thing. Otherwise you always have YouTube playlist. I usually use it for queuing myriad songs which come to my mind before starting some work, then I know that YT autoplay won't ruin my mood for quite a time
well, then I apologize. 
Seriously -- what the hell is with people not writing descriptions of what their code does?!
React-Bootstrap doesn't have a jQuery dependency, which is why I used it in a project I'm working on now because the client specifically requested Bootstrap styling. TBH, Bootstrap didn't really help me out in this case. Flexbox has long seceded Bootstrap's float based layouts for that portion of it to be useful, and the bootstrap components feel like they would've been just as easy enough to build as components without the Bootstrap framework.
Wow, that's quite the career! I can't imagine the ups and down you've experienced -- phenomenal. I agree completely with regard to &gt;there are quite often other influences (standard lib, third-party libs, community, etc) and conventions related thereto that will take you from generally competent to native fluency I said "you'll be able to be productive", but the caveat is that the productivity may be minimal. One example of the importance of conventions can be found in COBOL programming. A lot of people will advise learning COBOL to take advantage of old infrastructure's future lack of engineers, but the problem is that the old engineers are more valuable for their knowledge of everything **surrounding** a legacy COBOL program than for simply knowing the syntax. The more languages the better, I'd say. Thank you for posting your experience. 
If you're not being sarcastic, thanks! As much as I'm not a huge fan of bootstrap, I would never avoid using it just because of the reasons I posted unless I had a designer who would make something better. As long as the application proper works, I couldn't care less 
Variable scope
you qualify for the title however your experience is pretty limited.
That's the question I want answering haha. It's an inherited code base. I've moved most of them out but I want to create some sort of light weight library that can abstract this away so other people aren't tempted to do it again.
Same thing for angular.
A loading screen is also something I've put off doing for a long time but is definitely important :p Making players wait for things to happen isn't a great design decision and hopefully one I can rectify soon.
Period. I created a shitty MacBook touchbar app which just displays a nyan cat across the touchbar while playing the music (a literal github shitpost, or so i thought), it got major media coverage, trended on github, people started sending PRs, and it got +2000 stars for some reason TL;DR: stars mean nothing 
Shiiit now I _get_ that laptop.
Zepto is an API-compatible jQuery clone with a more modern Browser support list, hence a smaller code base.
jQuery is great for many things, but if you're building an web application instead of a website, then you're better off using an javascript application framework (such as Vue, Angular, or React).
as someone who hasn't coded websites in about 3-4 years... I thought jQuery was‚Äînot literally, but essentially obsolete these days. Guess not. Not knocking anything, but I'm so damn glad I left the world of webDev. 
&gt; learning a second language as a good way to improve my programing skills? Programming is a way to improve your programming skills. If you dig into the LOGIC of programs the language you use doesn't really matter. *Edit: Dear downvoters. Since you disagree with the statement I assume you think that for improving your skills you don't need to learn what you want to do but only need to learn another syntax.*
Stuff like Angular and React are not replacements for jQuery. They're not meant for the same thing, nor are they remotely mutually exclusive.
It depends on what you mean by essential. **Corporate world** If you mean get a corporate job or become a better programmer there is a difference. There is a low barrier to entry for this field, there is no regulation, and there is often no formalized training. In the corporate world most developers are just trying to get by and are probably half-way learning these skills while simultaneously working in unrelated technologies where they are formally trained. To survive here you need to master the trendy framework or some legacy framework the office uses. You need to have a solid understanding of OOP concepts. You will still need to have a solid understanding of jQuery even though it is largely a dead technology now. Bottom line: do what is easiest and conform to team code styles. **niche stuff** If, on the other hand, you want to work for an agency, start up, or write open source software or anything else niche you can largely ignore the prior advise. You will need to focus upon performance, code organization, smaller code, and solving hard problems. I prefer to avoid OOP concepts and poly-instantiation (no *new* and no *this*) unless some API makes me. OOP code tends to be poorly organized and all over the place, particularly as applications grow larger. I prefer to do everything just using legacy scope, which often means grotesquely large files but also an inescapable structure that imposes a clear organization. The code needs to execute as fast as possible at every step, because its only wasting your personal time. Automate everything as much as possible. Sometimes you might find you need to write a custom tool or convention to do something specialized. If that is what it takes to achieve greater autonomy and automation then it is an investment and not even a question. Keep everything simple. Simple code requires additional work. The goal is always predictability. If you know exactly what the code is doing by reading the code then you have good code. If this requires a crap ton of abstractions and many dependencies then you probably have a poor understanding of the problem and the code, while easy, absolutely isn't simple. Avoid abstractions as the further away you are isolated from the actual problem the less clear the actual problems become. Bottom line: be organized, keep is small and simple, and automate everything. In reflection my own personal software only became popular because I was able to extend JavaScript and XML parsers to support a whole bunch of different languages in a way that experienced programmers from other languages could easily modify or tinker with. If I had focused less upon organization or simplicity then nobody would have used the software. &gt; TCP/IP, DNS, packets, etc. Although I sit near a CCIE at work this stuff is foreign to me. I am about to leave for a military school where I am forced to learn this and pick up a CCNA. I am looking forward to how I can put those skills together with my programming experience.
Evey fucking time stars are brought up a comment like this appears. Stars aren't the end all, but they are not meaningless. It means people are using it, testing it, developing and growing it. Unless you are living in a vacuum this is very important. I'd take slightly inferior software that's heavily used vs slightly better software only used by the creator and Steve.... The first time you run into a problem and Google for a solution, you'll quickly see why stars are not meaningless. 
lol prettier is only a month old though
You can add your Redux state container in Vue using bindings (revue, vue-redux or [mixins](https://github.com/vuejs/vuex/issues/450)). That way you don't have to write things from scratch and re-use them later on. VueX is similar to Redux and MobX, but its patterns are incompatible, you can't re-use code, you can't use anything in the Redux eco system like middleware, tools and so on and that is bummer.
There's very little substance in this piece... it boils down to "it takes a long time, be patient".
That's not Haskell notation. It's just a list of arguments and output. So your argument here is basically "please, do not pay attention to what the type signatures of functions are, in even the vaguest of ways" which is silly, imo. Thinking about the type signatures of functions is useful in any language. 
Of course they're values. That's one of the critical differences between javascript and, say, java! I don't think you understand what you're taking about, but you sure do enjoy briefly skimming the internet for ways to troll people. 
Those do two different things, I have not tested the performance but I seriously doubt one is much faster than the other (logic tells me floor should be slightly faster). Perhaps some people use `Math.floor` when they really needed `Math.round` and they just got unlucky in testing their code so they got correct results with `Math.floor`, but you should use whatever fits your needs. I would not claim that `Math.round` is more accurate because `Math.floor` is not trying to do the same thing.
Can you give an example?
Can you give an example of when to use Math.floor vs Math.round?
First thing that come to mind due to the project I was just working on, we were implementing a live counter on the website that shows how much MWh was saved so far by using the technology that the client sells. The wording goes like this: ` have saved their clients over X MWh of energy` where X is a whole integer (we did not want to display a decimal number), and because of the wording, we can't round up for example 1500.6 to 1501 because it wouldn't technically be correct, so instead we round it down to 1500. It's a silly example but I immediately remembered it because I worked on it very recently :)
Seriously guys, [give Steve a break!](https://np.reddit.com/r/todayilearned/comments/5vc3zb/til_the_fbi_seized_a_server_that_was_being_used/de1a64u/?context=3) He's having a hard time already.
I would recommend reading the following: - You Don't Know Javascript (Free on github) - Secrets of a Javascript Ninja, 2nd Ed (John Resig) These two sources will give you a very firm grasp on the fundamentals of javascript.
If GitHub was a thing and as big as it is now when jQuery was released, you can bet jQuery would have more stars. Not that the number of stars have any meaning or relevance 
Applies to all languages. Every time I want to learn a new language and I start hunting for tutorials I always wonder "Why do I have to do yet another To-Do list?"
All these JavaScript frameworks and there is Foundation 6.3 easy as pie and has everything you need.
What exactly is the point of this post? Most people using jQuery have been doing it for ages and certainly didn't get it from github. Is this some crappy attempt to mislead people into thinking Vue &gt; jQuery or is more popular?
**Math.floor** - You have a rating system of stars, and you aren't breaking them up into half stars. You do a query to get all the votes and the math comes back to 4.7 stars. You would use **Math.floor** here so that you display 4 stars. &amp;nbsp; **Math.ceil** - You have a slider module that displays 3 slides at a time. This module contains 19 slides. 19/3 = 6.33. If you were to **floor** or **round** here you would end up with 6. But to make sure that all 19 slides are shown, you need 7 containers, so you use **Math.ceil**. &amp;nbsp; **Math.round** - Anytime you need the closest number without worrying about anything like the above scenarios.
Thanks for the reply! By models I mean whatever code is actually getting the data from your database. Maybe it's pass√© to actually self host you datastore these days? üë¥
That's mostly to compare and contrast. I think /u/chrissilich is talking about building different stuff in the same language.
Or, you could just use CSS transformations: @keyframes spinner { to { transform: rotate(360deg); } } @-webkit-keyframes spinner { to { -webkit-transform: rotate(360deg); } } .spinner { margin: auto; padding: 16px; width: 132px; height: 132px; } .spinner:before { content: 'LoadingÔøΩ'; position: absolute; width: 96px; height: 96px; } .spinner:not(:required):before { content: ''; border-radius: 50%; border: 4px solid rgba(0, 0, 0, .3); border-top-color: rgba(0, 0, 0, .6); animation: spinner .6s linear infinite; -webkit-animation: spinner .6s linear infinite; } 
That is exactly what I am talking about. Why would you use Math.floor in the stars example? IMO showing 5 stars for 4.7 rating would be the accurate implementation (simply because 4.7 is closer to 5 than 4). If you would use Math.floor in your star example, it would be near impossible to get 5 stars displayed (1 vote from a million could bring 5 to 4.99999 and therefor 5 to 4 stars).
GREAT NEWS!
I agree. 
hahah!
Yep. If you work somewhere that makes the same trendy long scroll single page website for small businesses over and over, you won't grow. Change it up or fall behind. If you can't change it up at work, you'll have to do freelance or side projects. Edit: Doing the same project again (todo list) in another language/framework is the best way to learn a new language/framework, because you're only learning the language/framework, and not figuring out how to build the product again.
There used to be this false sentiment in the field that you couldn't use npm for front-end stuff. That seems to have gone away though, thankfully. I do wish there was some way to organize node_modules into front-end and back-end stuff but I can live without that.
A mistake
&gt; , a massive chunk of polyfills and a runtime parser both larger than most functional frameworks which usually are just a few kb anyway. React is tons bigger , so is vue - did you actually check that? Whole polymer is 20kb gzipped (optional polyfills are another 20kb - and 60% of browsers don't need them already). Its smaller than jquery. &gt; It breaks HTML semantics with gibberish that changes from one version to another. Really? No one noticed, unless you confuse polymer with angular (angular 2.x has non-conforming syntax if im not mistaken). Polymer is standard html and javascript everywhere. In case you missed it, this is how it looks in vue: *:value="input" @input="update"*. In polymer you will have just *value="{{input}}" on-change="update"*. &gt; The standard itself does virtually nothing for you other than encapsulate. The standard moves the majority of the functionality inside browser itself. I'd rather discuss this with someone who actually used 1.x version even for a demo project. Because what you wrote is a prime example of FUD and incorrect information. I wonder what interest do people have to just blatantly lie on the web about things that can be easly verified. You know you use polymer already if you use chrome? Its ui is powered by polymer.
Thank you! I feel it fits! :)
~~I can't find it. Where is that mentioned?~~ Nevermind. It's in the v8 5.5 changelog.
touche! I don't use it, but calling it a mistake may be a bit harsh. Don't forget it originated in 2012, several years before Babel and ES6. I would argue it's simply less compelling now than it once was. Though, the people I've talked to who use it swear by it. I don't personally have any issue with ES6. Even on big apps, keeping everything in tight modules (fewer LOC) and using a good linter (ESLint + airbnb presets) solves a lot of problems, at least for us. We also rarely need to do refactoring, though ... honest caveat. Plus, with VS Code you get Salsa introspection on JS anyway, so you get some level of code completion, it just may not be as ubercool as TS. I've never found code completion to be a problem so far, though. I'm sure for certain code bases it's a huge help. I would argue for most stuff the average web dev works on, it's just not necessary anymore.
I disagree, but that's funny nonetheless :)
If you want people to take you seriously, don't start your arguments with "eeeeeeh" like some kind of bozo.
I was just joking (: it's got it's time and place
I think you need to reread it, but this time much more slowly. It might take a long time to do this, but be patient.
Thank you, I had the exact same question and was hella confused.
Did the Javascript Fix - Uninstall and reinstall node modules. Works
Wouldn't say that. Stars represent popularity of the codebase, whether it's growing interest, or something funny, whatever. Comparing Vue versus jQuery as to which is more popular, is misguided, in my opinion. jQuery is so ubiquitous within general front end development, stars on GitHub mean nothing in terms of general use, I'll agree with that. I do think jQuery developments (i.e. what the GitHub repository is representing) is losing interest to the newer frameworks. For example, people are more interested developments within Vue over jQuery, thus the star count on the project which houses the actual code will be higher.
Can you stop shilling for your site? Self-promotion guidelines dictate that you can post one self-promo for every 9 regular posts. Your post history is entirely shilling.
`Math.floor(Math.random() * length)` to get a random index. 
Or [use any of these CSS spinners](http://codepen.io/search/pens?q=css%20spinner&amp;limit=all&amp;order=popularity&amp;depth=everything&amp;show_forks=false) or [these CSS loaders](http://codepen.io/search/pens?q=css%20loader&amp;limit=all&amp;order=popularity&amp;depth=everything&amp;show_forks=false). 
Resolving is definitely another issue here, but even with the resolve my 2nd test is still failing. I may be misunderstanding, but I was under the impression that only one spy can be used per describe block, even if you have multiple spies in a test suite.
It already is production ready, it's just not officially supported yet because of Node.js lacking the `async`and `await` functionality. But still nice nevertheless.
Have they announced a planned LTS date for v7? I would love to get async-await, but won't upgrade without an LTS.
Odd-numbered Node versions don't get LTS support. v8 will be out in April, if all goes according to plan: https://github.com/nodejs/LTS#lts-plan
I tried it after watching MPJ talk about it and I quite like it. https://www.youtube.com/watch?v=Qlr-FGbhKaI
Yep all the projects at my work do not use them. When I started, it was hard to get used to. Now I can't stand them. We also use groovy in some places, and don't use them there either. All of my personal projects now exclude them as well. People often preach about all the problems you'll have, or weird scenarios. In 2 years I've not seen anything. I'd fully recommend trying it.
Been using koa2 with the harmony flag. Exciting. 
Really, a mistake? I use it all the time and love the heck out of it. I learned to program on Java, then made the switch to vanilla JavaScript (refused to touch jQuery even, lol). I nearly wanted to tear my face off in frustration, because of the severe paradigm shift in how to approach my code. Then ES6 came around and I thought, great, this solves a ton of my problems - except so few browsers were supporting it at the time, and babel was a little lacking. This is around when I found TypeScript. Strongly typed, syntactical classes that worked as I expected, abstracts, interfaces, inheritance, class members, proper scoping, compiler checking. It allowed me to code the way I wanted, and understood, and worst case scenario the compiled code is just JavaScript. Learning TypeScript is kinda like future proofing your skills, since it just targets the future iterations of JavaScript. Shits cash, yo. The only thing I'd really like to see change is how littered the code ends up with the 'this' keyword. I understand it's purpose, but man would I like to see it go just for the sake of my fingers, lol.
Hey everyone I started reading http://eloquentjavascript.net/ . Now I just need to test out the the interactive website you guys recommended.
It creates a global, which makes it easy to create conflicts, and there's a ton of issues related to it, it's almost universally seen as a bad practice. Bundlers and modules solve this problem, and is why they have become so popular so fast. jQuery needs it because plugins look for the global to attach to.
Example bug/problem I had awhile ago: * Had a list view, clicking on an item opened up a detail panel that slid out to the side. * There were various sections, where clicking on a button would open up a modal to modify some related data. * Modifying the data in the modals shouldn't be reflected in any other area if "Cancel" was clicked. * If OK was clicked - then the 'detail' object should be updated with the change - but that change shouldn't be reflected anywhere else in the system until the detail panel had clicked "Submit". * When clicking submit - it was actually a few API calls to update a few different things. * Once the API call succeeds - then the rest of the application needed to know about the change. This was back in an Angular 1.x app, and before I knew about Flux/Redux, and didn't really grok the use of Immutable JS at the time. Although I had sort of ended up with a rough 'roll my own flux' pattern going on. The bug: * Someone opens the detail view * Clicks on one of the buttons that opens up the modal * Removes a bunch of items * Then clicks cancel - not really wanting to remove them * User makes other changes to the record * User then clicks submit ... and then, I'm left scratching my head 'why did all of those items get removed?' -- I had passed in the sub-object by reference, not a clone - so when I was modifying that data - I was modifying the version that was shared in several parts of the application. Or another manifestation of the problem: there was another list view that listed all of these sub items - I went to the detail screen, opened the modal, removed a bunch of items, hit cancel, went to the list view of the 'sub items' - and they were not there. Why? I had accidentally mutated state. In this program, I was making liberal use of copying/cloning objects to try and avoid this - as I had been burned by it plenty in the past, but in this particular spot - I had forgotten to clone the object before passing it up to the modal window. In smaller applications, it can be easy enough to reason about 'what's updating what when' - but this can quickly change, especially when you are dealing with state that is used by multiple components / views / etc in your system, and potentially have those things triggering events that could change it. Simple example: * Your state is a list of todo's. * You have a list view of todo's - that is just title/checkbox, you can update the title, or mark done/not done here. * You can also click on todo to get a detail view - can change title, description, and mark done/not done here. * You also have an icon that shows the number of uncompleted todo items. Maybe in the click-handler on the list, and in the detail component you might do something like: todo[index].done = !todo[index].done; You now have two spots that are modifying state - how do you let the various components know that something has changed? Or, in the detail view - you mark it as done, but then hit 'cancel' - well, that change is already being reflected across your state - and if other parts of your application are trying to derive information based off of that, weird things can happen. Or, if that todo object is being passed around to a bunch of async stuff - that you don't always know what order / when it will be getting updated. It's been pretty rare that I've wanted my 'edits' to something to be propagated across the entire system in real-time until a user has done some sort of action to say 'done' (submit / continue / complete / whatever). There are obviously exceptions to this - but the use case of "look, I can edit the name in the detail view - and all of the application updates in real time!" is usually not the requirement, its more "edit the name, hit save - then all of the other parts of the application reflect that change". That said - immutable state is one thing, controlling access to how you modify state is another. You can control access w/o needing to have an immutable state. For example, instead of your component doing todo[index].done = !todo[index].done; and having this scattered across your code (although having a mutable state makes this easy and tempting), if you had todoList.toggleDone(todoId); and your todoList is what held onto the list of todo's - and controlled access to how you modify it, then yeah 'set the breakpoint - and you can look at the callstack' - but, with a mutable state - or not following immutable patterns - people can still reach up and modify that todo list however they want, and bypass the 'toggleDone' 
Semicolons are not optional in JavaScript: [ASI](http://www.ecma-international.org/ecma-262/6.0/#sec-automatic-semicolon-insertion) is an error correction scheme for novice programmers. The spec's parsing rules calls out the statements following where a semicolon should be "offending tokens". There is no leeway here for style or preference.
Haven't used semicolons for years now.
I used Polymer up to the last gen. The syntax you posted is non standard, real examples look worse. This is still gibberish: &lt;input value="{{searchString::input}}"&gt; &lt;template is="dom-repeat" items="{{employees}}" as="employee" filter="{{computeFilter(searchString)}}"&gt; &lt;template is="dom-if" if="{{user.isAdmin}}"&gt; &lt;template is="dom-repeat" items="{{data}}"&gt; It gets worse when you consider the MVC controlers driving these. Functional libs can boil down to nothing, some have 3kb under the belt, compats bring that to React with an alias. Vue is about 20kb, that's virtually nothing. Despite the size, they all do more and are forward oriented. When Google got started they were still stuck in MVVM era templates and Polymer never grew out of it. Like Angular, Elm, Aurelia and others, it will fade, because functional solves problems today that these libs won't be able to solve in years to come. And standards won't help, the barebones standard gives you encapsulation, imports and directives. It's nothing breathtaking. 
yes
It won't be LTS until October though.
What do you get out of LTS that you don't get out of current?
No, I prefer seeing semicolons, but with good linting tools it seems to matter less. 
&gt; Every major version covered by the LTS plan will be actively maintained for a period of 18 months from the date it enters LTS coverage. Following those 18 months of active support, the major version will transition into "maintenance" mode for 12 additional months. If you're running a sufficiently large app in production, you don't want to risk breaking changes by constantly updating. At the same time, you also don't want to miss out on critical bug fixes and security updates. 
In theory that's true, but new features inherently carry an increased risk of bugs. The point is that you're promised 30 month of updates without the additional risk of adding new features. Non-LTS releases only support six months worth of updates. 
&gt; Pure Javascript. You are joking... Pure JSX ;) const List = ({ items }) =&gt; ( &lt;ul&gt; {items.map(name =&gt; &lt;SayHi name={name} /&gt; )} &lt;/ul&gt; ) How is that pure Javascript - can I run that in my console? ;-) That is not even funny how it would look in "pure javascript react" But you picked react to show it can be different - we were discussing vue when you tried to prove that its syntax is better... So lets see: &lt;ul id="example-1"&gt; &lt;li v-for="item in items"&gt; {{ item.message }} &lt;/li&gt; &lt;/ul&gt; Vs polymer &lt;ul id="example-1"&gt; &lt;template is="dom-repeat" items="{{items}}"&gt; &lt;li&gt;{{ item.message }}&lt;/li&gt; &lt;/template&gt; &lt;/ul&gt; Vs angular 2 &lt;ul id="example-1"&gt; &lt;li *ngFor="let item of items"&gt;{{ item.message }}&lt;/li&gt; &lt;/ul&gt; They all look very similar to me (with angular being the ugly one) , i like vue version best, but the differences are cosmetic so I have no idea what you try to prove here. So far unfortunately I can only see you never used it really but you have a strong opinion and try really hard to justify it by weird cherry picking and fact twisting. Biggest enterprises in the world like Coca Cola, Electronic Arts, ING, IBM, General Electric, Google, Comcast are betting on polymer and adopting it in their products. You need to send them a memo that its "old era stuff" and they need to use new wheels that JS world reinvented ;-) Clearly they are all wrong.
[This is what Brendan Eich says (2012)](https://brendaneich.com/2012/04/the-infernal-semicolon/): &gt; [‚Ä¶] ASI as a newline-sensitive error correction procedure [‚Ä¶] &gt; &gt; My two cents: be careful not to use ASI as if it gave JS significant newlines.
JSX boils down to pure Javascript. It's not parsed but executed. These things you posted are strings, not HTML. Vue parses the string to functional at least. Angular and Polymer are left behind in their soup of ever changing gibberish while Vue *can* run purely functional code.
https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template You do understand the scope of DOM/HTML, which polymer is used for? Every polymer element is a real DOM that is interoperable with react/vue/jquery - whatever - web components are supposed to be black boxes. I think you are really confusing things here. Polymer is like new jquery for new HTML standards. It will never be react because it's goals are different, it is extension of web platform, it will never have "Polymer Native" etc. It makes no sense to think of it the way you do.
USE THEM, JavaScript will automatically insert them where it thinks they should go. There are a few small instances that this could effect you. Better to be safe than sorry troubleshooting something that should be done any ways. Check out 11.9.1 Rules of Automatic Semicolon Insertion and Douglas Crockford talks about making sure to use them. (if you care what The Godfather of JavaScript thinks) 
Only where they're needed.
There are three simple (and similar) rules to remember: - Don't start a new line with parentheses, - don't start a new line with a bracket, - don't start a new line with a backtick. And that's it. 
i write javascript without semicolons, but i'm not a guy.
I did c++ and then Java before Javascript, and have always used semicolons. It is so ingrained in my head, that even if I don't consciously look at the line and see it missing, I still have that feeling of something is wrong
Watch the video from this comment https://www.reddit.com/r/javascript/comments/5vkd5u/slug/de2qyg6 The important part to note is that you do need to know about ASI whether you use semicolons or not. 
There are plenty more that should be noted, those are good, but let's not say these are the only three. Plus, grammar is important to experienced programmers and omitting semi-colons takes-aways from good readable code only to gain the status of "look how fast I am", Take a look at the video where he discusses the why's - https://youtu.be/v2ifWcnQs6M?t=1h41m20s
Come on, "guys" covers all genders, also including attack helicopters from v1.3.0
Easy too: now = new Date(); date1 = new Date('1983-01-01') date2 = new Date('1986-02-02') date_meet = new Date('2010-01-01'); age_date1 = (now-date1); age_date2 = (now-date2); age_meet = (now-date_meet); percent_date1 = (age_meet/age_date1*100).toFixed(2)+'%'; percent_date2 = (age_meet/age_date2*100).toFixed(2)+'%'; 
You don't necessary need to use matrix (while it would be nicer), this one is valid too: transform: scale(0.6) rotate(15deg) translateX(50%) rotate(-12deg) Transform combinations like that have been supported since the beginning if I recall correctly, so they should work in all decent browsers &gt; dom.scale(0.6).rotate(15); I didn't mean that it's not possible, I meant that this example is not working while it is in the docs :)
Uhg. That burn is gonna sting me for weeks. Lol.
"Optional" would mean that you could omit them in *every* situation. If you can only omit them in certain situations, they aren't optional.
Why? What does it mean to you?
&gt; The point is that you're *promised* 30 month of updates So what do you do when that promise is broken? 
Why aren't you using const/let here? You're going to get people in the habit of creating global variables.
By the way (and not against you as you obviously didn't know better) I do think Java is very far from the ideal language for learning programming in general. It's definitely a nice language and it has its own use cases and purpose, but it's very opinionated. In Java, you can only code "the Java way", unlike for example C++ or JavaScript which have a clusterf**k of literally everything, and if you learn to navigate that mess you may develop valuable skills that you can use in any programming language. &gt; If one is to understand the great mystery one must study all its aspects, not just the dogmatic narrow view of Java. If you wish to become a complete and wise developer you must embrace a larger view of programming.
Yes its real. And its nothing new. Function expressions can be named, or not.
Yes it is real, and though I cannot track down an exact version, all modern versions of JS handle this. You could review https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript to see if there is a specific version you are looking for. Functions are just objects, so you are passing an object basically as a parameter. 
Hi /u/analourenco, last warning. You need to get your numbers way down before posting your site again.
It's a named function expression (NFE). https://kangax.github.io/nfe/
Ah, I apologize. But then you must agree that for all of the situations in which you *could* omit them, it **is** a matter of style or preference to include a semi-colon in the source text.
Yes, you're free to be inconsistent. Personally, I think that being consistent is simpler. I sometimes start lines with '(' or '[' and things like that.
I cannot think of a time I've ever had to use a semi-colon in my code aside from for-loops. Care to provide a real-world example of starting a line with `(` or `[` where a semi-colon at the end of the previous line would've changed the behavior?
I try to use breakpoints, but I'm usually already using them in IntelliJ for java and too many pauses in execution are usually troublesome - it's a last resort. I usually use a mix of console.log and print to the page to break up the stack / render queue.
Loved the article. Burning question: what theme are you using for Chrome in the thumbnail?
 var s = 'asdf' [...'foo'].forEach(c =&gt; console.log(c)) SyntaxError: Unexpected string var foo = function() { console.log('baa') } (function() { }()); Prints "baa".
[removed]
Heres a Fiddle https://jsfiddle.net/7fkmo8p7 (Remember to open Browser Console) Check out [Map](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/map), [replace](https://www.w3schools.com/jsref/jsref_replace.asp) 
Lol no response to the rest of the comment? No response why your consistency only applies to semicolons at the ends of lines? Do for loops keep you up at night with their inconsistent semis *not* at the ends of lines? Do multi-line arrays and objects torment you with their lack of semicolons? Do you end function definitions with semicolons just to keep that consistency up? Always fun seeing you in a thread Inu! You're always good for a nice dose of German pragmatism cranked up to the point of being insane.
Identical experience here. Someone suggested we start using standard to stop the bikeshedding over code style, stop the constant updates to style rc files, and the ever annoying issues needing to deal with new syntax ourselves. 2 years later and it's solved all the problems we wanted it to solve and we have yet to hit any of the scary things that people keep saying we will hit... But at the end of the day, it's code style. As long as you are consistent throughout a project and provide tools for others to help them conform to it you are fine.
Is this part of javascript API or a library?
There's one other use. I use this construct so stack traces contain useful function names for inline functions instead of "anonymous". Same when inspecting the stack during debugging.
ahh, now that crazy return makes sense. is using the String.prototype.replace, passing a function that cycles through A, B, C and D the best solution to replace each label, or is there a more efficient way? The string in my example only contains 2 groups, but i'll be applying this solution to one that has hundreds, maybe thousands of groups.
Took it like a champ, good on you.
We use Standard linting rules at work, only need to use them at the front of a line if it starts with brackets to prevent it trying to invoke the prior code
Depends a bit, usually when I want to identify where something goes wrong I'll log at various points in the code. When I've identified (or think I have) I'll throw in a debugger statement just before where I think the error is occurring and from there step-debug with breakpoints. Once you think you've fixed it the console logs should confirm this. You should probably be using unit tests and be able to run those to confirm the fix works. You should also update these to test for the case that caused the bug.
Great. Thanks for the advice :)
Breakpoints. What setup? I debug straight in browser. 
It can be as easy as: carsales.forEach(carsale=&gt; { var months = Object.keys(carsale.sold); months.forEach(month =&gt; console.log(month)); });
&gt;Best to stick to the standards, thats what enterprises do already I work for an enterprise and we support IE11. until few months back we supported IE 8. I assure you the standard bullshit is good *only if your target audience is not an enterprise.*
As a fellow hyperscript fan that sounds interesting. Could I trouble you for an example of what you mean?
var iframe = document.getElementById('youriframe'); iframe.src = iframe.src; put that in a setInterval
Oh I see how it is, apparently v1.2.9 isn't welcome here.
Block scoping. Basically, `var` is scoped only to functions. `let` is scoped to anytime you see these `{}`, which includes a for loop, while loop, etc. `const` is the same as let in terms of scoping, only it can't be changed once you declare. Also, neither can be declared more than once within the same scope, but you can do that with `var`. Tip: always use `const` unless you plan on changing the variable. So, default to `const`, not `let`.
If you don't use semicolons doesn't it slow down the parser? So, instead of reading a semicolon and knowing it's the end of a line, the parser has to read ahead and determine if it's the end of a line or not. If it is (99% of the time it is), then the parser has to go *back* and insert the semicolon, and read the other characters again as a new line. Does anyone know for certain about this? It seems like it could be an issue for larger codebases. 
These are the ones I live by and I have never (in my 2 years switch) had an issue with ASI. The main reason I omit semicolons is because it makes code far more legible for me, to me semicolons are clutter/noise. Other than that I don't really mind either way. There's also some minor pitfalls with using semicolons; some block do ‚Äòrequire‚Äô them, some don't. 
Downvoted for the username
That's what happens when you feed trolls.
üëã This is true. CoffeeScript was the language that started it all. It may not be as relevant today as it was 5 years ago, but even Brendan Eich [has said] CoffeeScript was a source of inspiration for ES6 and beyond. [has said]: https://brendaneich.com/2011/01/harmony-of-my-dreams/
This kind of thing? http://poignant.guide/ Who is your target audience?
You can still use `.catch()`. It's still just a promise, even if it's an async function or an awaited value. 
Haha, guys and girls, don't be too serious about this.
Node 8.0.0 is scheduled to *release* in April, it does not enter LTS until the release of node 9.0.0, scheduled for October.
It's not a front end-framework. You can use Meteor with react/angular
&gt; If they're always in that format Unfortunately, it's not always the same format and I need to match all commas `,` except if they appear after a closing parenthesis `),`.
&gt; There's a comma separating the two groups within parenthesis. It's this comma that I want to ignore, only getting all the commas between the numbers. I know that, but what you wrote is looking for "comma that's not followed by )" but nothing in any of your examples have a comma that *is* followed by ')' (only commas that are preceded by ')' and commas that are followed by '(') which is why your example matches every comma. 
&gt; CoffeeScript was a source of inspiration for ES6 and beyond Yes, it was - _was_ being the important word there. Which is why I wrote it has "served its purpose". 
&gt; No response why your consistency only applies to semicolons at the ends of lines? Do for loops keep you up at night with their inconsistent semis not at the ends of lines? Do multi-line arrays and objects torment you with their lack of semicolons? Do you end function definitions with semicolons just to keep that consistency up? The topic is semicolons at the end of statements.
I stick to always using them for good measure. One time I encountered a problem similar to this: let a = b (function() { })(); and unsurprisingly it assumed the IIFE was an argument to b. 
Similar story here. no ; @ work
wow :)
Thank you for the info :)
Still doesn't explain why you don't add semicolons to the ends of function definitions, class definitions, control flow statements, try/catch blocks, and more. All of which are statements. And if you think about it, needing to add semicolons to the start of a line if they start with `[`, \`, or `(` is less to worry about than if your statement is any one of the several things above. 
For example let's say you have m(".items", [ items.filter(item =&gt; item.id).map(item =&gt; { return m(".item", [ item.name, /*lots of lines of code here*/ ]); }) ]) Let's say you then notice that doing a filter every render is inefficient and that you want to refactor that into `store.item = items.filter(item =&gt; item.id)[0]` Now, you need to refactor the view into: m(".items", [ m(".item", [ store.item.name /*lots of lines of code here*/ ]) ]) Without the semicolon, I could collapse the indentation in my editor (by clicking on the arrow on the left line count rail), put my cursor after the return statement, shift-down to select the subtree, cut, remove the filter/map, paste. With the semicolon, I have to go look for it after the paste to remove it, otherwise I have a syntax error because I pasted a statement inside an expression.
Literally no difference, it's actually faster in un-minified codebases as it only needs to read in a newline instead of a semi+newline. But even that time is so insignificant as to be pretty much pointless to care about.
stopped using it. Configured eslint. Happy. Readable. No issues.
[removed]
https://www.reddit.com/r/javascript/comments/5vkd5u/any_of_you_guys_write_javascript_without/de3akgf/
The first thing that comes to mind is understanding scope. In particular, if you come from a C-esque language, this might be one of your biggest hangups. Understanding [how the scope works](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch3.md) before you write your code will inevitably lead to a better-written product. *(tl;dr for the rest of this: know the fundamentals)* The route I came up, I started as an OOP developer and thought JS was a toy language for much of my career. It wasn't until I took the time to understand the language that I came into my own as a JS dev, and it is currently my favorite language to develop for. If you're the book-reading sort, I would suggest the following resources in sequence: * JavaScript: The Definitive Guide (David Flanagan) * JavaScript: The Good Parts (Douglas Crockford) * JavaScript Patterns: Build Better Applications with Coding and Design Patterns (Stoyan Stefanov) If you follow [this link](https://www.amazon.com/JavaScript-Definitive-Guide-Activate-Guides/dp/0596805527/ref=dp_ob_title_bk) and look at the Frequently Bought Together section, you'll see that these three form a common trifecta. What you can expect: * The first book will give you a fundamental understanding of the language (I would personally skip the DOM-related parts, since that's more framework/environment than language) * The second book will tell you "Okay, we just gave you a drawer full of knives, here are the ones that won't send you to the hospital" * The third book gives you a rationale for how and why to apply the language in certain ways. It deals with JS-specific issues, and also brings in some of the Gang of Four patterns and other best practices. (edit: added link to Amazon page for the first of the three books, fixed formatting)
Debugger, of course. Once you get a good debugger you never go back. For client side, modern browsers have amazing Javascript debugger. For Node, VS Code has an amazing debugger. 
Well, you can play that the other way as well: var bar = { foo: x + 3; }; SyntaxError: Unexpected token ; for (var i=0; i &lt; 10; i++;) {/*actions*/} SyntaxError: Unexpected token ; if (true === false); { console.log('foo'); }; Prints 'foo' There are many more, but at the end of the day, we are arguing over the syntax of a language. You using or not using semicolons doesn't mean you get to not learn the syntax correctly. Regardless of their usage, you still need to know that they don't go after if statements, in object literals, you can't have one after the 3rd statement in a for loop, etc... But like I've said, if you want to resolve that issue for yourself in your linked comment, you can simply prepend a semicolon to the front of those lines: var s = 'asdf' ;[...'foo'].forEach(c =&gt; console.log(c)) Prints the elements of foo var foo = function() { console.log('baa') } ;(function() { }()); Prints nothing Remember the 3rd and only other issue (backticks) and you have 100% of cases covered. And luckily there are tools to prevent you from missing that, just like there are tools to help prevent you from putting bad semicolons where they don't belong.
That's a horrible and infantile comparison. There's a clear set of rules for how to terminate an expression in Javascript that doesn't require semicolons, as opposed to English.
Point 5 in that article is wrong, [Number.toFixed](http://devdocs.io/javascript/global_objects/number/tofixed) doesn't round a number, it returns a string representation of a number with the specified number of digits after the decimal point, it just chops the rest of the numbers off, no rounding arithmetic goes on at all. Rounding a Float in JS is actually quite complicated but there is an example of how to do it on the [Math.round page of the MDN docs](http://devdocs.io/javascript/global_objects/math/round) edit: as /u/Prince_Houdini points out toFixed does round when producing the string,
Hi /u/mavi888, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `youtu.be: Foo Bar`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [youtu.be](/search?q=%28and+site%3A%27youtu.be%27+author%3A%27mavi888%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|14|82% [youtube.com](/search?q=%28and+site%3A%27youtube.com%27+author%3A%27mavi888%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|3|18%
&gt; And I still do new development in coffeescript Why on earth?
I'm using the project partly as a way to learn BabylonJS, the Minos and effects are rendered in 3D. Writing the UI and business logic in vanilla OOP JS. A goal is to reproduce the TGM2 arcade experience, with a virtual joystick and virtual arcade buttons. May or may not be possible =) What I mean with basic is lack of fast drop and only being able to rotate one way. Also the buttons are a bit small maybe? 
Because I like the language. It's a more syntactically concise version of javascript. Because, as I said, I'm already maintaining a large coffeescript code base, so I don't want to introduce even more languages right now. And because I do front-end work probably only about 20% of the time, so I simply don't have the time to become an expert in every new compile-to-javascript language that comes down the pipeline. 
I'm really appreciate your advice. A revised version of items you mentioned will be released. :) Thank you!
You're assuming people are using a transpiler. It doesn't seem like the target audience for this article would even know about transpilers.
I think the recommended settings provide a sane default for code you'd publish, of course you are free to override them as you want to and it's easy to do. I also disagree with no-console as there's definitely a case not only for debugging, but using it in production as well (see Facebook protecting users with a console warning, for example). There's also not many relevant platforms where using console would cause issues or couldn't at least be solved very easily. But either way, it's good to have good baseline of rules and if you encounter something weird, check the rule description to understand why you might want to use it and then disable the rule if you disagree with that notion. I'm currently working at a client that had no linting process for any JavaScript and many people with very limited JS experience often contributing to projects. Introducing an ESLint configuration to all projects didn't just improve the code and consistency, but also teaches some good practices and new language features to the developers. I used recommended settings as a base and extended it a bit, but each project can further extend that base with specific rules very easily. I don't think there's a good argument for *not* using a linter if you write more than a couple lines of JS to test something. Some of the rules are subjective, but many of them are objectively great for beginners and seasoned pros alike. I get many ESLint warnings and errors and much rather see them immediately in the editor, rather than experience their effects in runtime and later on. Especially for a beginner, it's great to have the editor let you know "Hey, this won't work because X" or "You probably want to do Y here", if any of the warnings are confusing, there's examples to illustrate them. I certainly wish I had a tool like this from the beginning.
Exactly why one of those tips should've been to check out Babel.
`Math.floor` is often used as a "truncate to integer" function. Javascript is unusual in letting you pass floats as array indices, which is really unhelpful. For example `arr[1]` gives you the 2nd element, but `arr[1.1]` returns undefined, because it converts 1.1 to a string and accesses a missing string property. Yep, that's how it's specced. So I often use `Math.floor` to truncate an array index to ensure I access a valid element. `Math.round` is not appropriate for array indices, because if you have an array with 5 elements, the last element is index 4. So if you pass 4.9, `Math.floor` correctly rounds down to the last element 4, whereas `Math.round` will round to 5 and access the array out-of-bounds. That alone is probably why floor is much more common than round.
Use functional programming where you can. Basically learn all the array methods, and that functions can be passed as variables. 
it is not creating build system, it is using existing build system, but I agree that it is better to use create-react-app, unless you just want to educate yourself in subject of "build system creation" (or unless you have a lot of time to create something better for your own needs, or your needs are very small) 
Also, `let` is not hoisted, `var` is hoisted.
If you want to map a -&gt; b you can do this const result = ({ a: 'b', c: 'd' })[key] || 'fallback'
Definitely the first practical argument I have ever heard for it.
Yeah sorry, I meant Clojure Script. I was told that Clojure had more support and is better for embedded applications while Scala is harder to learn it is more mainstream. 
This website has bugs and thus not reliable. Example: **Challange** Replace Letters With Position In Alphabet **Solution** function alphabetIndex(str) { return str.toLowerCase().split('').map((x) =&gt; { if (/[a-z]/.test(x)) { return x.charCodeAt(0) - 96; } }).join(' ').trim(); } **Tests (Failed)** Expected: '3 8 5 3 11 2 1 3 11 20 15 13 15 18 18 15 23 9 23 9 12 12 19 5 5 9 6 20 8 5 2 15 15 11 8 1 19 1 18 18 9 22 5 4', instead got: '3 8 5 3 11 2 1 3 11 20 15 13 15 18 18 15 23 9 23 9 12 12 19 5 5 9 6 20 8 5 2 15 15 11 8 1 19 1 18 18 9 22 5 4' **Proof (Gives true)** "3 8 5 3 11 2 1 3 11 20 15 13 15 18 18 15 23 9 23 9 12 12 19 5 5 9 6 20 8 5 2 15 15 11 8 1 19 1 18 18 9 22 5 4" === "3 8 5 3 11 2 1 3 11 20 15 13 15 18 18 15 23 9 23 9 12 12 19 5 5 9 6 20 8 5 2 15 15 11 8 1 19 1 18 18 9 22 5 4" // true
Lexical scope and hoisting. Learn the concept, and learn it well. It is a relatively simple topic that is often misunderstood and this misunderstanding leads to a good portion of JS bugs. https://medium.com/@nickbalestra/javascripts-lexical-scope-hoisting-and-closures-without-mystery-c2324681d4be#.s8vvcafv5
Na-ugh! You're infantile! /s Mate, 'tis but a joke, lighten up... YoucanseefrommyprofilethatmelikespuncutationANDspaces ;) 
In the event that you want to get some advanced functionality out of your application, moment.js provides an nice API for doing date math. http://momentjs.com/
`let` and `const` are hoisted at the block level, this is so they can throw if you try to use them before they are declared, `var` does the same but gives you `undefined` rather than throwing, and of course `var` is hoisted at the function scope, not block.
I don't use semicolons; in my view, it clutters the view of the code; However, they are sometimes necessary, and that's just okay: const array = [1, 2, 3] (function () { // ... })() The code above tries to call `[1, 2, 3](...)`, which of course is not a function. This can be easily caught by a linter, and also if you know to never start a line with (, [, or `, then you are good: const array = [1, 2, 3] // semicolon at beginning of line fixes problem: ;(function () { // ... })()
Hey, that's the unfortunate reality that some of us deal with everyday :P
&gt; If you aren't a new programmer, but just new to JavaScript itself, it's also definitely worth it to read Mostly Adequate Guide to Functional Programming (free) Even if you're "new", I'd still give it a look. Better to learn these concepts early imho.
While all three are good books, I would no longer recommend JavaScript Patterns by Stoyan Stefanov. It still has a lot of ES3 stuff in it, and really needs a new edition. Doug's book shares the same problem, but the first book -- The Definitive Guide -- has since been updated for ES5. I would no longer recommend them to beginners as there is lots of great alternatives. ES2015 should be taught as a base, as it will definitely be the standard very quickly. I highly recommend [Dr. Axel Rauschmayer's Exploring JS](http://exploringjs.com/) (2ality.com author) series instead. [Eloquent JavaScript](http://eloquentjavascript.net/) also is a great book for beginners, it has some homework for them so if you're not the type of person that already has 10 ideas of what to make, it makes a great book. Lastly I'd recommend [YDKJS](https://github.com/getify/You-Dont-Know-JS) These books cover the language extremely well, and best of all, they are all free online.
Stephen Grider's Udemy course is the best resource I've found. https://www.udemy.com/webpack-2-the-complete-developers-guide/learn/v4/overview
Part of me wants to learn something new and I also read that Javascript has warts that ClojureScript &amp; ScalaJS helps you avoid. I have coding experience in Python and Java, is the change to Lisp be difficult or will it just take a little practice? 
http://learnyouahaskell.com/ You should also check out "Head First" books: http://shop.oreilly.com/category/series/head-first.do
[Option objects for keyword arguments](http://www.html5gamedevs.com/topic/28447-best-js-trick-ive-ever-learned-option-objects-for-keyword-arguments/)
The main webpage and documentation have been rewritten for webpack 2, it's gotten quite good. https://webpack.js.org/guides/ Pick a guide, "getting started" and "creating a bundle" will teach you everything to get going, make a first build and use it. You extend your config every once in a while, when you need something extra, be it a new loader, maybe for css or image compression, babel and so on. 
&gt; i've regretted using saga's already. What made you regret using redux-saga?
Hi, I've [written a humble guide to the topic](https://survivejs.com/webpack/introduction/). I also did [some slides](http://presentations.survivejs.com/advanced-webpack/).
&gt; I want to brag that I know ES6 and be an asshole about it. Fixed your comment for you.
We are using it to build a medical record application. It's been amazing. Team members new to the framework also learned it fast and code is very manageable since we are using single vue components. We are also using vuex, vue-router, and vue-resource. Development has been enjoyable.
Temporal Dead Zone.
I can see some parts where it's starting to become cumbersome. Imagine a wizard form--pretty common in user onboarding, even during sign up (email input -&gt; sign up pressed -&gt; enter secret -&gt; wrong secret! what now??). the code for making sagas work with that is a little obscene (I can provide an example in code if you'd like). the other option is....kinda nice. make an ajax call, get a return, oops there's an error! oh that's okay. i'm not worried about enforcing a flow on someone. maybe when they click this button again, they'll have the correct secret. that being said, i absolutely love sagas for certain things. will be checking out redux-observables though. i know the Rx/Observable movement has been building up steam slowly, but i wonder if it's a better organizational paradigm with real benefits or if it's...just an alternative
That doesn't mean newcomers should hold themselves from good and modern approach.
I cant speak for /u/whokilledmrburns. But we had no problems using vue with vue-router, vue-resource, and vuex in our app. I think the biggest challenge is just learning the concept of vuex because it just looks like you are writing more code. However, as your app grows you can start seeing the benefits. If your app is small I wouldn't bother with vuex.
dont learn it just copy/paste random config files from the internet until it works, then dont change your build process. ^/s
How big did you let your functions grow for the flows? and how big exactly was the use-case? curious for my own good, here
&gt;We looked into other solutions like redux-thunk and redux-saga, but given that we really love Rx and like to use reactive programming **to solve the complicated async problems presented by real-time dataviz apps**, we decided to try to create a new middleware that cleanly solved our problem using RxJS 5 ([quoted from a senior netflix engineer on a blog post about using redux-observable instead of saga or thunk](https://medium.com/@benlesh/redux-observable-ec0b00d2eb52#.71s6niy16)) Looks like a good idea for people who are heavily async with data visualization. I probably don't have a similar use case in a consumer-based app that's not data viz (I'm imagining a lot of websockets and a lot less "this user had incorrect input during a multi-step form"), but that'll be an interesting thing to keep in mind in the future.
Try this: https://www.sitepoint.com/beginners-guide-to-webpack-2-and-module-bundling/
we created sagas for all actions. Every user generated action would get caught by a saga. so 90% of what we used sagas for would have been easier and clearer with thunks and promises. There was a single complex case that was listening to websockets. Sagas worked out for this. But I prefer the mental model and programming style of observables over generators.
I cannot stress this enough. Having a complete understanding of how the language (and the browser) works is the difference between a Google level Javascript engineer and someone that creates simple JQuery widgets.
This resource contains a lot of good stuff. http://superherojs.com/
console.log, debugger
Take a look at create react app. Eject the app and see how they do their configs. They're quite readable.
It's drawing the text off the canvas. You're not doing anything with the coordinates passed to makeTextPath().
Hi /u/mafontes14, it looks like you're new to reddit, welcome! This post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (this post has nothing to do with Javascript). Also, thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `ckl.io`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [ckl.io](/search?q=%28and+site%3A%27ckl.io%27+author%3A%27mafontes14%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|11|92%
find, filter and map are particularely usefull. 
`let` and `const` are supported by every relatively modern browser.
Library doesn't really matter, but the steps involved do. 1. JS click handler on the button 1. JS `POST` to your server with the IDs of the reviews already shown 1. server determines the next 3 reviews, and responds to the `POST` with JSON of the next 3 reviews (eg `[{ id : 3421, title : "This is good", body : "I liked this because...", img : "http://yourdomain.com/img/reviews/3421.jpg"}, {}, {}]` 1. JS gets back the JSON data, and renders it on page Why are you using jquery 1.10 and prototype.js? Should probably update those.
You don't learn webpack. Webpack learns you
You just perfectly described my week.
Depends on your circumstances I guess. On a recent Node/React app I did with SSR we needed certain data on page load (things that fill in the navigation bar -- it would be weird if they loaded async we thought). So we stuck an async/await function in there then populated the Redux store before we renderedToString on server. So, we used models (you don't really hear this term a lot with React, caught me off guard lol). It looked like this: const store = configureStore( await InitialStoreData() ); const html = await getMarkup(req, res, store); const finalState = store.getState(); res.send(getTemplate(html, finalState)); Note: this was in an Express route and we had the good old try {} catch(err) {} there, too.
Especially if Babel makes transpilation down to ES5 so easy.
You don't need jQuery for that. Creating a new element and then using `innerHTML` will do the same job.
Stephen Grider on Udemy has a pretty good course. Kent C Dodds on FrontEndMasters has a course that goes pretty deep into Webpack 2. Also, the Webpack 2 documentation is pretty good. Their team has put in a lot of time on the documentation and making sure its as clear as possble. Back when I was learning, I found this post suuuuper helpful: https://blog.madewithlove.be/post/webpack-your-bags/ Even though it is on webpack 1, its still relevant atm imo. Not many things have changed. Other than that, I have seen a couple articles up on Medium.com, just search around, you'll find something good. Its a lot easier to learn it now than it was a while back. Also, I took WesBos's course on ES6 just a while ago, and he walks through modules and module bundlers and their setup, including webpack. It was a pretty good explanation.
This is called a spark line 
Thanks for this guide. I highly recommend it. Easy to read/follow, lots of examples .
Right, I forgot about innerHTML. let url= "http://reddit.com"; let linkname = "reddit"; let element = document.createElement("div"); element.innerHTML = ` &lt;div&gt; &lt;a href="${url}"&gt; ${linkname} &lt;/a&gt; &lt;/div&gt; `; document.body.appendChild(element); In that case my comment from before can be reduced to: take a look at template literals. They're awesome.
Literally 2 days ago Joseph Zimmerman published "A Detailed Introduction To Webpack" on smashing magazine. This article gives you everything that you need to know to get into Webpack. Fresh and comprehensive resource.
I didn't read through all the code, so I don't know exactly what you mean (added a space where?). All I did was add these two lines to makeTextPath() and the text becomes visible: text.setAttribute("x",x) text.setAttribute("y",y)
When learning JavaScript, try to do things for the first time without the use of a library, until you get the hang or understanding of things. For example, JQuery helps you to manipulate the DOM. Learn how to manipulate the DOM in regular JavaScript first, and then learn how to do it in JQuery. This will help you learn when to utilize regular JavaScript and when to use JQuery, as you don't need JQuery for everything. Learn the limitations. One frustrating part about Web Development is supporting numerous browsers. If you chose to develop using the latest of everything, then only the most modern browsers will/may support it. If you are supporting an older product (such as SharePoint 2010), you can face even more limitations as older products may force specific compatibility modes within Internet Explorer. For example, SharePoint 2010 forces IE8, which means you only have access to JavaScript before ECMAScript 5. However, you can use polyfills for missing functions (including CSS). But it won't be perfect, it may end up having an impact on performance, and may have a different outcome. There isn't a polyfill for everything though. 
Typo - says "React Tend" in headline 
I've had some issues in the past when manipulating the `xlink:href` attribute on a `use` element with JS. My guess is the source of your problem has to do with the XML namespace (xmlns). IIRC it's a one line solution but I can't remember it right now. I'll take a look at what I did to fix it later and update here. 
You are using the wrong namespace when setting the href attribute. It should be: textPath.setAttributeNS('http://www.w3.org/1999/xlink',"href","#"+pathid) 
Most people I know use momentjs when dealing with dates and timezones in javascript: https://momentjs.com/docs/. This method shoudl work: http://momentjs.com/docs/#/query/
This is the project formerly known as redux-elm for anyone who is curious
thanks!
Gah, can't edit it now. Maybe I should rename the project instead?
Good to know! Thanks.
Since the time in JS can be changed by the user, you would want to request permission from the server instead of just checking the local time.
kevinkace, thanks for your advice. Will follow it! To answer your question: prototype.js - cause that's what magento 1 pretty much built on, you can't really replace it. Will be updating library version to 1.7.3.0 so we can use google cdn. jquery 1.10 - will be updating pretty much for the same reason.
What exactly do you mean by &gt; to a defined area (Not the whole page) and have it be transparent. Explain your exact requirements from a user perspective and we could probably help you.
you're going to run into more problems than doing things the javascript way if client side work is so new to you. I think it's important you learn javascript. Do things the React Native way in JS and get familiar with how 90% of everyone is using React and React Native. You won't go wrong there. Skipping straight to clojurescript is skipping a step in my opinion. You should know JS, and have its massive ecosystem available to you first and foremost. The last thing you want to do when starting out in clientside work is be in clojurescript land trying to make things that "just work" in javascript available to you in clojurescript. That said, they likely do have pretty solid setups for react native, but you won't have the breadth of materials/documentation/tools available to you, showing you the way. For example, it's pretty clear that the following set of tools are the most popular (and therefore tested, complete, documented, etc): React Native, Redux, Jest, Apollo, Recompose, Reselect, TypeScript, VS Code, Babel, React Navigation, ...That basically is your stack. Because there is so much activity in the javascript world, it's very easy to pinpoint what's the most popular "one true way." The ClojureScript world will take more digging. And probably most importantly, updates will propagate through the javascript toolchain faster. Your likely in CLJS world waiting for various changes to have updates reflected in all the associated packages for a lot longer. 
Personally I'd not recommend reading through the survivejs book and instead start a project and use it as a reference. I found the book lacking context for specific use cases many times and simply reading through it barely taught me anything because it doesn't explain a lot of the concepts used in an effective manner. It is an excellent resource as a reference though
I utilize React a ton at work; the component life cycle events and passing mutable/immutable data between both flux patterns and/or high order components is a pretty massive benefit to me. I'm not super familiar with Vue =&gt; How does it compare in handling this? This would really be the only valuable selling point to me; not showing that they both render components with the same base principal (some DOM selector &amp; props/data). Obviously Vue has a virtual DOM, but what are some of the major concepts surrounding re-rendering, passing mutable/immutable data, etc? These hello world examples don't really show case any major benefit of either language for me unfortunately.
Thanks! I think I've got a setup I'm happy with here: https://github.com/bitjson/typescript-starter/pull/13
can you paste a gist to that redux sagas example?
You're moving player_sprite but you should be moving the image. Move the id onto the img tag, and get rid of the wrapping div, or move all the positioning stuff to the div. The player_sprite element is being updated correctly, but due to the image being nested, having position absolute, and the player_sprite having no position property set, the img stays exactly where it is. This worked for me: &lt;body onload="setInterval(function(){gameloop();},(1000/60))" onkeydown="keyPressed(event)" onkeyup="keyReleased(event)"&gt; &lt;!-- Load Player Graphics --&gt; &lt;img id = "player_sprite" src="ship.png" alt="Unable to load player sprite." style="position:absolute; height: 50px; width: 50px; z-index: 1; left: 635px; top: 550px;"&gt; &lt;!-- Create Backdrop --&gt; &lt;img id="backdrop" src="backdrop.gif" alt="Unable to load background." style="width: 1280px; height: 700px; position: absolute; top: 0px; left: 0px;" class="rotateimg180"&gt; &lt;/body&gt;
Oh wow that was simple, thanks!
My guess is that 8.5555 is 8.55 and a half and a little bit, while 8.555 is exactly 8.55 and a half. So when it's exactly split it defaults down.
NaN doesn't mean 'not numeric'. isNaN will only work with numbers when you've done something like divided by zero. Strings, nulls, booleans and undefined are **not** NaN. NaN represents an illegal or otherwise non-parsable number. [Read more about the NaN property](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/NaN).
So glad you interviewed Irene! I think she's a real hero, here in the Boston area &amp; beyond.
&gt; Strings, nulls, booleans and undefined are **not** NaN. In my mind that makes it seem like isNaN("") should return true. I'm asking specifically in the case of empty string. I can wrap my head around why null, and booleans return what they do. I do **not** know why empty string returns false for isNaN("") indicating it is not, not a number. To my mind-- meaning it *is* a number of some sort, although obviously it is not. That's why I'm asking for an ELI5 in the specific case of empty string.
Yep! [It turns out this worked](https://www.reddit.com/r/javascript/comments/5vsgyg/whenever_i_add_an_element_to_an_svg_file_in/de4sr7u/).
The first thing you need to do is to find out whether the media player actually provide the information you need (i.e. the song title). I suggest checking the media player user's manual. If it doesn't, then you've reached a dead end. If it does, find out how each song title is reported by the media player, and how to retrieve it. If the media player is outside of the computer that host the web server, figure out a way to send it to the web server. Depending on the media player, you might need a custom built software which is native to an OS (e.g. Windows EXE application, or Linux BIN file), in order to retrieve the song information.
Haven't watched Stephen's webpack2 course yet, but his react series has been great.
This right here. The new docs/guides for 2.0 are great for everything from beginner to advanced usage. If you do find an external guide, it might not reflect the 2.0 API and cause confusion.
I would advise against using MomentJS for this use case. It's ~50kb gzipped! It's worth its weight if you need to handle locales but this is straight forward date math. Just do it using VanillaJS; it's not that difficult. 
Hi /u/mmva2142, please post the source code or contact the developer of the game.
I've currently got two options on pulling our song data out of the system we use to report it, one being &gt;&lt;div id="spinitron-nowplaying" data-station="wuog"&gt;&lt;/div&gt; &gt;&lt;script src="//spinitron.com/js/npwidget.js"&gt; &gt;&lt;/script&gt; and one being &gt;&lt;iframe src="http://spinitron.com/radio/newestsong.php?station=wuog&amp;amp;stylesheet=http://spinitron.com/css/style-public.css" width=100% height="150" id=youriframe&gt;&lt;/iframe&gt; I feel as though there should be a way to convert both their outputs to strings and chuck that into the waiting text box, but I cannot for the life of me find a way to do that.
.catch don't work that way. you have to use try/catch
You don't learn webpack. It just comes to you in a vision. "I see it all now!"
Technically, there's a whole bunch of `NaN` values, but they aren't used very much. Hopefully, isNaN() can detect all of them.
Using isNaN ~~I understand Number("") returns 0, which would not NaN.~~ ~~I'm asking for the very specific case of: isNaN("")~~ ~~presumably the empty string must also equal 0 in this case, but I don't understand what operator is causing it to, unless empty string always == 0.~~ Edit: TIL about type coercion. 
I first learned it through a course on Lynda called **Learn Webpack: The Basics** by *Eve Porcello*. Its the sort of course that is great for absolute beginners (like how I was with Webpack). Check to see if your local library system has access to Lynda (if they do, it means you can access Lynda for free).
IMO the [Survive JS book on Webpack](https://leanpub.com/survivejs-webpack) is the best way to learn.
did the organisers acknowledge that their site said Feb 27th? 
&gt; The Number type has exactly 18437736874454810627 (that is, 264‚àí253+3) values, representing the double-precision 64-bit format IEEE 754 values as specified in the IEEE Standard for Binary Floating-Point Arithmetic, **except that the 9007199254740990 (that is, 253‚àí2) distinct ‚ÄúNot-a-Number‚Äù values of the IEEE Standard** are represented in ECMAScript as a single special NaN value. (Note that the NaN value is produced by the program expression NaN.) In some implementations, external code might be able to detect a difference between various Not-a-Number values, but such behaviour is implementation-dependent; to ECMAScript code, all NaN values are indistinguishable from each other. http://www.ecma-international.org/ecma-262/5.1/#sec-8.5 (Emphasis mine, to indicate what I was referring to.)
Perfect, this is the answer I was looking for. Thanks for such a well thought out response and saving me hours of headache!
glad i can help. ...not to mention my package for redux-first routing (which works for React Native, which gets you mileage for deep-linking and push notifications): https://github.com/faceyspacey/pure-redux-router It's if React Router was built for Redux. I will be releasing it in a few days. It let's you essentially attach URLs to various states, which allows users to deep-link into specific portions of your react app. 
Copy, thank you for the clear explanation. As is obvious, I am an amateur. I wasn't aware isNaN() itself caused coercion. 
Honestly, I can't keep it straight myself half the time. By the way, if you want to avoid the coercion, you should be able to use `Number.isNaN()` instead (docs [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN)).
Huh, I didn't know that. It seems like that's just at the implementation level though. &gt; to ECMAScript code, all NaN values are indistinguishable from each other. This seems like the important bit though, and since OP seemed like they weren't that familiar with JS I didn't want them to think isNaN might return true for something else. 
It's one of the 'artefacts of old', I suppose. When you run into other such problems with built-ins, I'd suggest looking them up on MDN. `Number.isNaN` was already linked, so here's [`window.isNaN`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN). Note the first line mentioning the type coercion ;) MDN is one of the great reasons why us developers don't have to remember every detail of every feature of every language we use - we just have to remember how to find that info on the web!
Everyone is saying the docs are excellent, but they're assuming some things where I've had to use YouTube videos to create my first bundle. Right from the start, after saving webpack as a dev dependency: https://webpack.js.org/guides/installation/ &gt;To run the local installation of webpack you can access its bin version as node_modules/.bin/webpack I can't do this on a Windows machine, and have seen a number of versions of this giving a path followed by an input and output file to run webpack before you have a script setup. with powershell (or commander): *'node_modules' is not recognized as an internal or external command, operable program or batch file.* webpack ./index.js bundle.js works -&gt; but I understand this is using the global install of webpack. Am I overlooking something they don't mention in their step-by-step like I need a config file first?
Run that shit in a linux VM, do Windows development on Windows machines.
So you're suggesting I should switch to a linux VM to perform one-step in my tooling?
I'm just learning and doing tutorials. Couldn't JavaScript my way out of a wet paper bag that was already open.
With javascript, the thing to remember is that nothing is really typed, so if you need a number, you need to convert it to a number and then see if that failed using isNaN(). "Verify your inputs" is a common mantra.
That's not an issue that's Webpack specific. That's "just" a Linux vs Windows issue - handling of slashes and filesystem paths. The Windows equivalent is: `node_modules\.bin\webpack`.
Is it safe to say that webpack is a solid substitute for things like gulp/grunt or is not apples to oranges? 
What's the advantage of this over using a Brunch Skeleton or Yeoman Generator?
Just wasn't my passion. While I'm glad I built a foundation of knowledge and skillsets to access it when needed in the future, it just isn't worth my time in the end. I code and work in 3d amongst other things, so more of a visual tech creative type I guess. Any field has constant changes happening and things to keep up with, but in the creative coding realm(not saying web can't be creative), but I feel like that energy spent learning is more lasting. I get to use code and render out photo-real images/animation in almost real time, and maybe even have stuff 40 years from now I have kept and be fond of as a keepsake. Never really saw myself..."oh yeah, look at this, this is that site I built in 2017_...such good memories"... With web, it's gone to some extent. There's always this new javascript library, sites need updating, security changes, better /new standards etc etc. Bootstrap ugh, and squarespace impacts...(small clients don't wanna spend ample $ for time, have to always explain design vs dev and cost when they are tight ie) You get my point. Like I said...this happens in other fields, but for me personally it was just this vicious cycle of "meh", and something I did not enjoy. A person has to really dig web, and I guess I don't. Felt like I was ultimately going to lose a couple decades of my life fiddling around with meaningless(to me) infusions of code. I'd rather make stuff, learn coding with math/animation etc.. Holds more value to me, and feels more like a lifelong hobby that grows... not unlike playing a musical instrument. apologies for the long response, and I commend all the people that do push boundaries. Glad there are smart people out there devoting their time to improving the matrix.
There are many footguns, but this is a Dick-Cheney-level footgun. Promote to production and shoot a reliable friend in the face.
This. is. so. true. 
Nice and simple. Cool project 
The sad thing is many people would probably benefit from adding this to their code and their workflow.
Bardzo dziƒôkujƒô! Zawsze jak testuje jakie≈õ pomys≈Çy to u≈ºywam abstrakcyjne nazwy, pierwsze s≈Çowo kt√≥re przyjdzie mi do g≈Çowy. Jako ≈ºe pierwszym s≈Çowem by≈Ço "siema" w tym wypadku nazwa wybra≈Ça siƒô sama. Logo zrobi≈Ç mi kolega i link do jego portfolio jest w dokumentacji w zak≈Çadce extra ‚Äî zdolny ch≈Çopaczek! Pozdrawiam :-)
It does. &gt; Zepto in CommonJS modules The linked project is just that, Zepto for CommonJS. The actual [Zepto project](https://github.com/madrobby/zepto) has a pretty good description about what Zepto is.
And they are seen as typical Javascript coder. They are reason Javascript is looked down 
This right here is some damn good advice! 
Yup. Well, browser-side Javascript. Node is fine :)
Try looking it up on Stack Overflow... ;-P
Shouldn't there be an `escape` in the construction of that url? And maybe it should be using `window.open` instead of just redirecting, because otherwise you're losing your current page context.
[removed]
Because it's not a NaN
1. Be clear and precise with your questions! 2. Validate your [HTML](https://validator.w3.org/) and [JavaScript](http://esprima.org/demo/validate.html) 3. Follow a common style guide for your [code](https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Coding_Style#JavaScript) and [markup](http://codeguide.co/#html) ... and be consistent with it 4. "Extrapolating" from your screenshot this might be a styling/formatting question instead ([CSS](/r/css)).
I'm just here for the downvotes.
Why even use them in dev-env
Reditards 
[removed]
He needs to lern2babel :P
Yea I understand that, I was referring to data management, re-rendering events, etc.
i'm not sure about its use in JS, but usually NaN refers to a specific property of a bit pattern that is not a valid floating point number, as specified in IEEE 754. https://en.wikipedia.org/wiki/IEEE_754-1985#NaN
docs are getting really [nice](https://webpack.js.org/guides/) I'd say yes. I mean it is complex as the thing you want to do is complex. but for me it's quite easy to set up the basic stuff ( minify, source map, etc ) and set up a web server w/ hot reloading for my projects which were kind of a pain (imo) using gulp/grunt
http://codeincomplete.com/posts/javascript-game-foundations-the-game-loop/
Since you only need to compare a time, not localise things, you should easily manage using vanilla JS, [as suggested](https://www.reddit.com/r/javascript/comments/5vtt63/best_way_to_handle_time_in_javascript/de52qmv/?utm_content=permalink&amp;utm_medium=front&amp;utm_source=reddit&amp;utm_name=javascript) by /u/HeathenForAllSeasons. [`Date.now()`](http://devdocs.io/javascript/global_objects/date/now) returns the Unix timestamp, which is always UTC. If you need to express UTC times in local time, [`Date.getTimezoneOffset()`](http://devdocs.io/javascript/global_objects/date/gettimezoneoffset) gives you the offset from UTC in minutes, which you can use for adjusting. (`Date` in the browser is _always_ rendered in local time, so you need to either adjust the time, or use [Intl.DateTimeformat](http://devdocs.io/javascript/global_objects/datetimeformat), which is unfortunately [poorly supported](http://caniuse.com/#search=intl) in all but the latest browsers.) Those should be enough for you to validate whether local time is within a timeframe that matches your activation/deactivation of functionality.
I would find a tutorial. Your game loop should run at a maximum of at least 60 FPS, and you want to use delta time. 
is there a port for Java ? 
Just use nodejs wrapper which allows executing java code in node from java
No.
Float fucks up heights.
You should consider what versions of the browsers you need to support, and check if they all support the querySelector API. I honestly believe that nowadays all browsers support that, so there isn't anything wrong with using them. Another concern might be performance, but you can check and compare the performance of the two approaches with benchmark tools. You should check out how to use the js benchmark tools, it's fun. But only consider the performance aspect if you are doing a LOT of dom operations, otherwise don't bother, choose the one that produces cleaner, more readable code.
I'm curious, why 30 FPS?
MOAR!!!
&gt;a11y checks I really need to work on accessibility. I'm never 100% sure I have a page that works for all color blindness. What's the significance of the "role" attributes?
I'm of the opinion that the idea is fundamentally wrong. Code should be shared and available for learning. And no obfuscation will ‚Äúprotect‚Äù anything if there's incentive to find out how it works. You're of course free to spend your time however you want, and someone might find this useful to appease some technically illiterate superior who might want something like it because he had some silly capitalist nightmare about someone ‚Äústealing‚Äù code. But IMHO in the interest of open source you should not waste time with this and do something more useful. Just choose a proper license if you want to protect your IP. Sorry, this is almost certainly not what you want to hear but you *did* ask for feedback.
I totally agree and just to add some more information, the way selectors work is they go from right to left. For example the selector `.myBox ul li`. The system will first grab all `li` then filter them out if they don't have a `ul` parent. Then filter them out if their ul parent doesn't have a `.myBox` parent. This means that it will work faster if you have `.class` or `#id` as the last identifier in a query. This is a micro-optimization which is totally not necessary in most cases I just thought it was interesting and I wanted to share.
keep in mind that you have a single thread. if your updates / renders take too long, your next render cycle will lag as your callback will get queued (or even dropped). if it continuously takes more time or about the same time to execute, your CPU use will go sky high and may end up being non-responsive / jerky. RAF may be a better approach - though it won't render when not in focus, otherwise, setTimeout to call next update. 
few comments here. 1. if you are using an id, you do not need any other selectors. IDs are meant to be unique throughout the whole document. thus doing something like document.querySelector('.myClass #id-child-of-myClass') is equivalent to document.getElementById('id-child-of-myClass'); 2. You should limit the scope of your CSS queries to the smallest query possible. While this gives a small performance boost, it also gives a very large robustness boost. Creating long CSS queries to find the element you're looking for is very fragile as any small change to the HTML can invalidate the query. An equivalent concept is class inheritance. The longer the inheritance chain, the more dangerous changes to parent classes can be.
I believe they're _usually_ hints to screen readers as to how to divide up the page, as well as what function certain elements perform (e.g. "tree"). I know there's way more I could do with them for labelling, but the `main`, `navigation`, etc. ones seem to be the main ones to get in. As for getting sites more accessible, I found that [this](http://a11yproject.com/checklist.html) is a **great** start :)
How about this: var frame_number = 0; function run() { Game.update(); if (frame_number%2) { Game.render(); } frame_number++; requestAnimationFrame(run); }
Honestly, for this type of use, it's better to use `requestAnimationFrame()` than to set an interval. You have no guarantee of what delta time you actually get with `setInterval`. `setInterval` doesn't actually execute the javascript, it only queues up the javascript to be executed every x milliseconds. That means that if your web page is in the middle of a really long script, you might get 5 calls to your function queued up, and then once that really long script is done, your function gets called 5 times as quickly as possible. `requestAnimationFrame` allows you to take a timestamp as a parameter, which means that by saving the previous timestamp at the end of every loop, you can calculate the change in time by simply doing: var previousTimestamp = performance.now(); function loop(timestamp) { var deltaTime = timestamp - previousTimestamp; // Do updating here previousTimestamp = timestamp; requestAnimationFrame(loop); } requestAnimationFrame(loop); /u/KPABA is right in saying that if the window isn't visible, you won't get any updates actually called (which can be either a good or bad thing), so if you need the game to be updated if the window isn't visible, you can do the same pattern with `setTimeout` instead.
Also, if you need to limit the frame rate to 30fps, then you can modify the above loop to conditionally update: var previousTimestamp = performance.now(); function loop(timestamp) { var deltaTime = timestamp - previousTimestamp; if (deltaTime &gt; 1000/30) { //Do updating here previousTimestamp = timestamp; } requestAnimationFrame(loop); } requestAnimationFrame(loop); 
If there's a competing product that works suspiciously similar to yours, you can start looking for your code in there and sue them for sweet $$$ if they really ripped you off. If someone else uses parts of your code to do something completely different, it doesn't hurt you in the slightest, so why hinder them?
To further explain, when you open those variables, you get the current state of it's data, not the state when it was logged.
False analogy. When someone takes my stuff it's gone. If everything I had to fear was someone walking in with a 3D printer for copying my stuff I wouldn't bother with a lock
imo, the first version is cleaner. However, perhaps you should drop the `&amp;&amp;` as it is not needed and may be a source of errors. check [the final example](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator) for how to do multiple operations with the ternary operator.
+1 the first version is much cleaner. Ternaries are great for cleaning up short bits of code, but when you have this much in there it gets really hard to read and understand what's going on. Rule of thumb: if a ternary doesn't fit before the 80 character limit suggested by most languages before you create a new line then it shouldn't be a ternary. It should all be able to fit on one line. 
I'm a swag style myself.
 this.prev = this.current++ if (this.current == this.total) { this.current = 0 }
Can we cap this branch of the thread with some upvotes? :D
Saves time. Not a bad idea for dev env
querySelectors are generally the preferred approach for interacting with the DOM as they are more declarative and far less code. However, they require a parsing step that the DOM methods do not and thus are about 2800x times slower. The only exception is when accessing elements by attribute value or attribute name if that name is something other than "id" and "class" at which point the querySelector approach is about 16x faster than the DOM methods. To put that in perspective 2800x difference is like comparing: * 1 second to 47 minutes. * distance from Sun to Jupiter versus Sun to Alpha Centauri * last year compared to before the founding of Judaism * a walk across the neighborhood versus a drive across the continental US * 57 cm versus 1 mile * the closest black hole is about 2800 light years away while the closest star to our sun is only 4 light years * a person of net worth $30 million is 1/2800th of Bill Gates net worth * The tallest building in the world is only 2717 feet tall.
I'm pretty sure original is from early 2015
Yep. `i` just needs to be a persistent iterator: https://jsfiddle.net/g426h4a8/
The reason they're behaving differently is: this.current = 0 &amp;&amp; this.prev = (this.total - 1) `this.current = 0` evaluates to 0, which is falsy, so the part after `&amp;&amp;` isn't evaluated. You can use `,` instead of `&amp;&amp;`. In general, stick with the original if/else for readability ‚Äì but sounds like you're just practicing, so practice on.
No! It used to be problematic because of browser support, but it's really not an issue today.
&gt; Edit: TIL about type coercion. You're in for a loooooong ride ...
This is the reason your code wasn't working... If you're trying to learn, understanding this will be important. You could also reverse the order of the operations and it should work.
You are asking what are the major concepts they use for re-rendering and passing data. I am saying, they can be the same across all 3 popular frameworks. There is even angular work for VDOM now. At this point there is little benefit between frameworks, only which people find more comfortable.
ajax. Either do the file upload via AJAX, and on complete update the DOM to display what you want it to display, or fire an event on upload completion to do an ajax call to get the image data to display on the page.
&gt; False analogy. Actually this is a false reply, he didn't mention theft only entry. Checkmate Stallman.
Possibly a dev who doesn't know the difference between a comment in a back-end language like PHP and a front-end one that gets sent to the client like HTML?
I guess I was just confused by this part in your comment then; &gt; not sure about Vue but maybe you were just specifically referring to the syntax Vue uses to invoke its internal state management change. Either way, looking over the docs led me to the answer https://vuejs.org/v2/guide/instance.html#Instance-Lifecycle-Hooks. Seems like they have an almost complete mirror to React.
He forgot to condescendingly comment on how it's obviously made by an idiot and how he would never make a mistake before handwaving away the offer to fix it as there's no use since it's clearly flawed from the start!
*Sigh*. I really think boilerplates are a good learning tool but I think they're a great source of confusion in the learning of react architecture. I can't count how many times I've had new react people come to me having started a project on a monolithic opinionated boilerplate "because it came with everything" with problems understanding the why / how because all the myriad of moving pieces don't fit their problem domain and they cannot progress because they don't understand how or what anything does. I was hoping with CRA and CRA-like setups we'd be seeing a positive shift into having a very basic ecosystem to build on-top of and pushing libraries &amp; practices away from heavily opinionated approaches allowing for developers to get the right tool for the job. My best hope is that a lot of new developers will look at boilerplates like this as a source on how to connect the pieces or architect their code but only apply the parts relevant to their project. /rant
This is really well done. This would be a perfect introduction for anyone that is new to Aurelia. I would definitely consider providing new starters to my projects with this if they aren't already familiar with Aurelia.
You could drop your current setup and use firebase. I love it and use it in three projects right now. It's a real time database that sends new data to the clients whenever it gets updated. What you would do is store images in firebase storage and save the url for the images in firebase realtime database. When your clients get a new url they download and show the image
After shooting his friend in the face, Dick Cheney's gun was still a quail gun. Besides, the correct tool for the face is the palm.
I don't know why people are down voting you - they clearly have zero experience with things like copyright, trademarks or patents. Everyone reading this: You can't copyright ideas. Your implementation is not protected and despite some countries offering patents for algorithms, their enforcement is... challenging (that said I am not a lawyer and that may no longer be true). This may upset you, but if you are concerned about competitors then you need to talk to a competent lawyer and have a business/marketing plan in place. Ideas are cheap - protecting them isn't. With that said my main concern is to do with user experience - obfuscation often results in lowered performance, especially on mobile devices, but I should test before judging :)
I get your point but that is a poor analogy. Unlawfully depriving someone of property is a lot different to IP violation.
I'm with /u/flying-sheep on this. There's no place for obfuscation in JavaScript beyond a novelty. Years ago I toyed with the idea but in hindsight I realise it was because I lacked humility, and genuinely thought my code was worth protecting. Now I realise any engineer of a certain level skill could emulate and analyze what I create in probably little more time than reading the original source. But with that said, it doesn't mean there are _no_ uses, so well done and I hope it solves the problem you were trying to solve! 
Explain that it does more than React. It's a framework not just a view layer. More similar to Angular than React really.
Were you on Freenode IRC asking about this a couple days ago? This looks EXACLY like I remember it being and I told you what you had to do but you wouldn't listen. You need to not use the `async` attribute there and you need to run your other code inside of `document.addEventListener('DOMContentLoaded', function () { ... });`
No this is the first time I have asked about it aside for a couple other subreddits in the past couple hours. So I would run the baguetteBox.run('.gallery'); inside of the code you posted? I'm sorry for asking but I literally am lost right now with js this is maybe the 3-4th time I've used it and this is the first time i've had issues
I currently prefer this little prototype-based pattern for chainable types, inspired by [daggy](https://github.com/fantasyland/daggy), which is pretty performant. The nice thing is that you don't have to explicitly call "new" to create a type, which makes it simpler and more composable. const Any = function(x){ if (!(this instanceof Any)) { return new Any(x); } this.x = x; } //you can add static methods on the function itself Any.empty = () =&gt; Any(false); //&amp; type instance methods to the prototype... //chaining, in this case semigroup Any.prototype.concat = function(y) { return Any(this.x || y.x); }; //chaining, but leaving/exiting the type Any.prototype.fold = function(f=(x=&gt;x)) { return f(this.x); }; If you want to add a whole bunch of things to the prototype you can of course Object.assign to it.
`[].forEach.call(document.querySelectorAll('.js-something'), function(node) { /* ... */})`
This kind of shit has no place on /r/javascript
 I was gunna write out a thing but this guy does a mich better[ job ](http://stackoverflow.com/questions/22581345/click-button-copy-to-clipboard-using-jquery)
Check what the "container" variable is, probably "context" is not in there.
`container` may or may not exist. `container.context` apparently doesn't exist... so when you try to read `container.context.className`, it blows up. My guess is that the example you are following had `container` already defined as pointing to some DOM element. Something like, `var container = $('.wodry');` 
Hmmm... So i tried going off of what you said: &lt;body&gt; &lt;div class="main-content"&gt; &lt;h1&gt;test &lt;span class='wodry'&gt;ONE|TWO|THREE&lt;/span&gt;&lt;/h1&gt; &lt;/div&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.js"&gt;&lt;/script&gt; &lt;script src="wodry.js"&gt;&lt;/script&gt; &lt;script src="scripts.js"&gt;&lt;/script&gt; &lt;script type='text/javascript'&gt; let container = $('.wodry') &lt;--- added that $('.wodry').wodry({ animation: 'rotateX', delay: 1000, animationDuration: 800 }); &lt;/script&gt; &lt;/body&gt; Im no where near as experienced as many others but im assuming this was what you meant. It still didnt work. Same error 
Just a bit of extra info, 'npm install' looks for a 'package.json' file in the current working directory. Based on what it finds in this file, it installs additional modules (dependencies) and performs other housekeeping tasks. Take a peek and you'll see that this file exists among the ones that you downloaded. Way more info than you probably want [can be found here](https://docs.npmjs.com/files/package.json).
thanks for the help. The error was that it doesnt work with jquery 3.0+ lol...
Shouldn't there be a manual somewhere?
When I input cd Desktop\twitter-contest-js-bot It tells me the path couldn't be found, would this be because I have my desktop on my E: Drive? [Screenshot](https://gyazo.com/9300c172802af291b732b21a6c3f4a88)
I believe that due to the fact my desktop is on my E: drive it's saying that "The system cannot find the path specified," how would I wourk around this? [Screenshot](https://gyazo.com/9300c172802af291b732b21a6c3f4a88)
&gt; (getElementById is always going to be more performant for ids, for instance) Just an idea (scribbled here and in no way tested or anything) but couldn't you do something like this? (function () { var querySelector_orig = document.querySelector.bind(document); document.querySelector = function (s) { return s.startsWith('#') ? document.getElementById(s.substr(1)) : querySelector_orig(s); }; }())
`querySelector()` and `querySelectorAll()` have advantages and disadvatages. They're slower than `getElementById()` and `getElementsBy...()`, but are more capable of selecting more specific element(s). Also, there's a difference. `querySelector()` and `querySelectorAll()` returns the element(s) that are found only at the time the function is called. OTOH, the list returned by `getElementById()` and `getElementsBy...()` may change at anytime when matching new elements are added into the DOM, even though the function was called only once and before the matching elements are added. e.g. function addElement() { var ele = document.createElement("DIV"); ele.className = "abcxyz"; document.body.appendChild(ele); } addElement(); var listFromQS = document.querySelectorAll(".abcxyz"); var listFromGE = document.getElementsByClassName("abcxyz"); console.log(listFromQS.length); //1 console.log(listFromGE.length); //1 addElement(); console.log(listFromQS.length); //1 console.log(listFromGE.length); //2 
 &lt;div id="myElement"&gt; I am some sweet, sweet text! &lt;/div&gt; &lt;textarea id="myStyle"&gt; background-color: red; border: 10px solid purple; color: green; &lt;/textarea&gt; &lt;button onclick=applyStyle()&gt; apply &lt;/button&gt; &lt;script&gt; function applyStyle() { var elem = document.getElementById("myElement"); var rawStyle = document.getElementById("myStyle").value; if( elem.style.cssText.length &lt;= 0 ){ //split on ';' and iterate over each of them using array.map var styleProperties = rawStyle.split(";").map(function(keyVal){ keyVal = keyVal.split(":") if(keyVal.length == 2) { //conver hyphen to camel case var key = keyVal[0].replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); }).trim(); //clean the value var val = keyVal[1].trim(); //apply the style elem.style[key] = val } }) } else { elem.style = ""; } } &lt;/script&gt; [jsfiddle](https://jsfiddle.net/ur9jvern/10/)
You could use css custom properties https://developers.google.com/web/updates/2016/02/css-variables-why-should-you-care
You can't change directory to another drive. Change to the E drive first with "e:" and then try the cd. 
That looks like es6 notation. why not just JSON.parse?
Yes, you're right. Although keep in mind Redux is just a way to manage state in your front end apps. Now, in many real world scenarios, this state ends up being data taken from a back end database, sure. But Redux isn't *only* for database data - it's useful for a lot of things. React and Redux are often used together as they're a great combo, but the two are completely seperate things. You can use Redux without React and vice versa.
Maybe it's a password to a mock or demo account.
I wrote a module a while back which might help you out https://github.com/Prismatik/mongoose-reverse-populate. It's no longer under active development though but I think this does what you want?
I edited this post a **bunch** and all the code blocks look like shit. It should work, though. Bunch of problems: - `".*"` captures everything it can find between two quotes - you want `".*?"` to capture as little as possible and get **"**123**"** instead of **"**123" "456" "789**"** etc. - with that fixed you're capturing the comma and space after "123" as part of the same group, so it'll never look like your desired output because $1 is `"123", ` not `"123"`. If you want to remove the `, ` from the output, use a non-capturing group - `(?:,\s*)` - with _that_ fixed, you need a space at the end of the replace string to fix `@@@@"101112". **So:** Resulting regex: /(".*?")(?:,\s*)(".*?")(?:,\s*)(".*?")(?:,\s*)/g (note you can just write this as-is straight into javascript - without having to new RegExp and escape all the escape characters) Resulting replace string: $1 ^^ $2 ### $3 @@@@ // with a space! Resulting... result: {"123" ^^ "456" ### "789" @@@@ "101112" ^^ "131415" ### "161718" @@@@ } Unfortunately the whitespace is a bit irregular, not so sure how to fix that. See it in action http://regexr.com/3fcro That look about right? Final code should be: var string = `{"123","456", "789", "101112", "131415", "161718", }`; var regexp = /(".*?")(?:,\s*)(".*?")(?:,\s*)(".*?")(?:,\s*)/g; var output = string.replace(regexp, `$1 ^^ $2 ### $3 @@@@ `); console.log(output); 
Thanks for your help 
I wouldn't do that, don't do anything the user isn't expecting from their actions. What if I wanted more than one filtered item?
React is responsible solely for what you see on the screen. It doesn't hold almost any of the data. Redux is responsible for managing the state of your front-end application, supplying the data your React component need in the format that they need it in, and dispatching actions whenever user does certain things with your react components. That also includes communication with your back-end whenever you want to send or receive some data. Yes, you will need a web server and a database if you want your application to work with persistent data. The communication between the Redux and server happens with HTTP requests. 
`[^"]*` is not the same as `.*?`. As the first matches newlines. Use `[^"\n]*` instead.
Obfuscation doesn't provide security: * https://en.wikipedia.org/wiki/Security_through_obscurity#Criticism * https://technet.microsoft.com/en-us/library/2008.06.obscurity.aspx * http://stackoverflow.com/questions/533965/why-is-security-through-obscurity-a-bad-idea * https://www.simple-talk.com/blogs/obfuscation-is-not-a-panacea/ You can easily reverse most aspects of obfuscation with a good code beautifier. The belief that mutilating your reference names and white space will provide security only fools you as everybody else can still access the code.
for most code, code coverage is about as useful a proxy for quality of tests as lines of code is for quality of code. meaning it's not very useful if you want to know if you have well tested code, particularly if you're writing a lot integration tests. if you write a lot of unit tests and you have simple functions with simple inputs and outputs, then code coverage might be a good metric to make sure you've hit every input/output combination. but it still doesn't give you much confidence that the tests are any good. but the core problem with using test coverage is the social way it's implemented. it's not usually implemented in isolation in your own project, it's implemented as some kind of target or goal in response to a problem. "our code is buggy, maybe we should require tests before anyone goes to prod. i know! we'll make it a hard requirement that any new code needs 70% test coverage before it can be shipped" the intent is right, but the implementation is usually hamfisted and poorly thought out, so it leads to a system that doesn't promote quality, but just slows engineers down and makes them game it to keep going. i think [this martin fowler](https://martinfowler.com/bliki/TestCoverage.html) post covers the pitfalls pretty well
Additionally you should remove the comma and whitespaces from the capturing group when you don't want them in your result. So `("[^"]*"),\s*`instead of `("[^"]*",\s*)`
Code obfuscated by defendjs cannot just be reversed with a beautifier, it takes significantly more than that.
I looked at the code, but did not run it. A good beautifier can adding missing syntax characters. My own has an option named `correct` that inserts missing semicolons, angle braces, conversion of ++ and --, and does some other things like this. I did not dive in enough to see how you are mangling literals, but this can be easily reverse engineered as well. Really the only thing that is hard to reverse is the name of references, but this irrelevant to how the code runs.
Hi :) Thank you, we added a [small example](https://github.com/alexhorn/defendjs#obfuscated-example) to the README.
If I understood correctly that product section has many tags as a attribute. You can get product sections having certain tag this way: ProductSection.find({ tags: { $in: [myTag] } })
I've found the solution, I've used mongo aggregation pipeline,$unwind tags, after $group by id and counting length,sorting in descending order and limiting by count of relation, and thats it. I am now populating the results after that I can paste the solution, if you want ))
Maybe, but reversing techniques like control flow obfuscation is harder than that
Agreed. You can get 100% coverage: function trimOrAddOne(bar) { if (typeof bar === 'string') { return bar.trim(); } else { return bar + 1; } } // Front trim assert.equal(trimOrAddOne(' some'), 'some', 'Left trim'); // Number assert.equal(trimOrAddOne(11), 12, 'Add one'); But that tells you very little about the intended operation of the function. If you later refactor, what else might it miss: // Missing Valid Cases: assert.equal(trimOrAddOne('more '), 'more', 'Right trim'); assert.equal(trimOrAddOne(''), '', 'Empty string'); assert.equal(trimOrAddOne('this or that'), 'this or that', 'Inside space'); assert.equal(trimOrAddOne('some'), 'some', 'No whitespace'); assert.equal(trimOrAddOne(' \t \v \n \r '), '', 'All types of whitespace'); // Missing Invalid Cases? // NaN, Array, Object, null, undefined EDIT: Submitted before finishing my thought, sorry. You don't have to write tests for every possibility, but you have to approach your tests *defensively*, because that's the point. Last month I fixed a passing test (and a bug) on a currency parser. The original code made a common mistake of using `.replace(',','')` instead of `.replace(/,/g,'')` so it only removes the *first* comma. The tests only accounted for numbers smaller than one million, so "everything was fine". We had tests that executed every line, but not defensive tests. When I updated it, I added tests for negative numbers, too.
Ha, nice.
Yep. I mean, you can build your own very minimal DOM selection/traversal/update lib using these base interfaces, and that's a good thing! This is basically what libs like jQuery do under the hood in more modern iterations that can drop legacy support. They just offer a lot more utilities as well as wrapping and enhancing native array methods with more functionality (like flatMapping). But as long as you can provide those things in other ways, you can get by really easily with the underlying native methods + arrays.
Really like the video and codepen examples. Super easy for someone to know what your product is about.
It's 2017 stop rewriting decades old articles. At the very least write them with a modern twist, where is the relationship of hoisting and `let` and `const`?
It's like writing article about how GoTo is bad in C
Some people don't know JavaScript does this, so it's certainly informative in those cases. However, people really just need to declare their variables before they use them, usually at the top of the function. Hoping they get hoisted correctly without managing that yourself is just asking for bugs.
Oh my.. Thank you so much. `window.onerror` is not deaf anymore. LOL.
&gt; `[\s\S]` For the JavaScript regex flavor one can use `[^]`.
wait. since when?
This week i created a lazy querying library, you can get it [here](https://www.npmjs.com/package/lazy-query) It allows for lazy evaluation, infinite lists and a bunch of other stuff. Unfortunately i don't have a lot of time to write about it here, but heres an example: let primes = lazy(range(2, 1)).filter(value =&gt; !primes.onlyMemoized().takeWhile(prime =&gt; prime * prime &lt;= value).any(prime =&gt; (value / prime) % 1 === 0)).memoize(); primes.exec(console.log); This outputs all primes
I encrypt data using the caesar cipher. It's so insecure it's secure
Good point, my suggestion pre-supposed valid input.
cd /d "E:\Users\Lucas Fern\Desktop\twitter-contest-js-bot-master" But you probably shouldnt be doing this if you dont understand it at all.
By the way, there are several models there which also look quite cool. The `trapez` one will not work as you'd expect since there's no way to make it animated.
Definitely the ES6 shorthand version. It's so much cleaner. 
Well shit that explains why linters suddenly gripe about variables with "dangling _'s"
Depending on how you configure Babel with something like babel-preset-env it'll leave those untouched for platforms that support it.
It shouldn't mess with Babel. Babel checks to see if there's already an existing variable with the generated name in scope, however it's possible that there's an edge case it misses.
Thanks, it's not actually homework, just something I wanted to figure out. 
It was a way of marking a property as "private", or not to be used outside of that class. Didn't actually do anything though. Got more confusing when underscore and lodash became a thing. 
From what I remember, having variables with leading underscores (or just `_`) signified the variable was unused. Most often this would be found in function signatures, where the function was implementing a specific api, but only cared about a later variable (e.g. `function onThing(_1, _2, thingICareAbout)`). It's also a convention in other languages, like Python, when destructuring return values (e.g. `(_, _, thing_i_care_about) = getSomeTuple()`)
It can mean a lot of things. It can mean it's a private variable, don't use it outside of its current scope, don't rely on it, or nothing at all (I've seen it being used in circumstances without any reason whatsoever).
Damn, that's impressive!
"I already understand this therefore everyone understands it and it's redundant."
the semantics aren't changing; these are existing language features used to replicate desirable behavior, similar to what you might write by hand. the drawback is performance, not correctness.
yep. let has block scoping, whereas var has function scoping. MDN has [an article](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Scoping_rules_2) that goes into more detail.
thx for your reply! guess i have to combine some tools to get the full amount of data i'd like to grep :-) lighthouse is a great tool for sure! thx again
Chrome's timeline will show you function calls in a flame chart, and you can always log stack traces.
Risky project name.
I didn't know this was something one could do in ES6. I've returned objects like this for so long: { name: name, age: age } I'm definitely using the shorthand. Thanks for this.
You're going to want to show us some code. 
easiest thing is to use lodash: `const cart = _.sample(items, 5)` to get 5 random items.
You will probably find it only does that transform if the let value is captured by an embedded function.
Huh? Really? In order to actually scope the var i, wouldn't this have to be wrapped with a function? 
In that particular case: var user = { firstName: 'Zlatko', lastName: 'Fedor', project: 'goodmodule' }
Fisher-Yates shuffle which only does N items. function shuffleN(array, n) { let a = array.slice(); for (let i = a.length - 1; i &gt;= 1 + n; --i) { let s = Math.random() * (i + 1) | 0; let tmp = a[s]; a[s] = a[i]; a[i] = tmp; } return a.slice(-n); } console.log(shuffleN([...'abcdefghij'], 2)); // 2 of those
I think JavaScript would really benefit from copying dart's ".." cascade operator. (https://www.dartlang.org/guides/language/language-tour#cascade-notation-) Basically, it works like the normal "." operator, except it discards the return value and always returns the left operand. That would allow you to write code like document.getElementById('whatever') ..addEventListener('click', e =&gt; console.log('clicked') ..textContent = 'Click me!' ..classList.add('clickable'); Without having to change the DOM library (or whatever other library you need to chain) or introducing any overhead and the feature could easily be transpiled.
Is there any example config for babel-preset-env. I tried to set it up on a personal project, because I don't need to support anything legacy, but it looks like it still turned all of my lets and consts in to vars.
You could also omit the `if (true)`. Basically, with `const` and `let`, code blocks such as `{}` are the new IIFEs.
I don't think I ever considered join having a default, I think I've always just passed it something. TIL
update: chainging innerHTML to innerText gives me this error: &gt;Uncaught DOMException: Failed to set the 'innerText' property on 'HTMLElement': The 'tbody' element does not support text insertion. at XMLHttpRequest.xmlhttp.onreadystatechange And the listener does not break
after several hours I found thsi thread which explains it: http://stackoverflow.com/questions/595808/is-it-possible-to-append-to-innerhtml-without-destroying-descendants-event-list
"AFAIK React handles data(json api) apps better?" Why would this be ? I am too trying to figure when to use Vue or React, since i like both. What i have gathered so far is that Vue is more easily pluggable to existing apps, and React if more focused towards full SPA apps. Overall i find Vue easier than React, but React seems better prepared for bigger projects. 
ESlint also has the shorthand property rule. http://eslint.org/docs/rules/object-shorthand, I have been using it since using ESlint with Airbnb configuration
Defensive tests is a good idea. I think TDD can also help with this - you may end up with 100% coverage without fully testing every behavior, but if you used TDD, you would have written a test to "cover" the particular line of code.
Agreed. Coverage seems to be most useful as a guideline rather than as a hard rule, plus you can use it to find out areas of code which have very few to no tests. The article you linked sums this up pretty nicely :)
Yep, I realized that babel-preset-env and https://github.com/babel/babili are actually super important together (babili is babel-minify)
I think that would only serve to make the example more complicated and not add any value to the topic of block scoping.
I just arrived at 71. (a=&gt;(a=document.createElement('a'),t=&gt;(a.textContent=t,a.innerHTML)))() Creates a dummy anchor element and then a function that uses its text escaping mechanism. If you want to sacrifice (a lot of) runtime cost for even fewer bytes you could re-create the anchor element every time t=&gt;(a=document.createElement('a'),a.textContent=t,a.innerHTML) Which is 62 characters. 
That is what `let` does in `for` loops.
Sure, but that's pretty heavy both syntactically and possibly performance-wise, so why do it?
I don't know Dart, but I assume it would transpile to something like this const _ref1 = document.getElementById('whatever'); _ref1.addEventListener('click', e =&gt; console.log('clicked')); _ref1.textContent = 'Click me!'; _ref1.classList.add('clickable'); The issue I can see is that it depends on significant whitespace.
If your application is state driven (for instance through Redux), it is very easy to inspect its flow, and since each action can be recorded you can rewind and forward the application from any point of time and see it build/deconstruct itself. You can inspect each call, see where it comes from, change its state, etc. This is how it looks with Redux dev-tools: https://camo.githubusercontent.com/cc9b9701f3984f3b8cfb6264c214217b0451df09/687474703a2f2f692e696d6775722e636f6d2f51624e7a4e57342e676966 Without a proper state manager like Redux this would be hard to achieve, if not impossible. The only thing you have at your disposal is AST analysis and debug timelines, but that doesn't make you understand the applications flow.
Thanks, much appreciate it!
How does it compile for different platforms and how does it detect the platform used by the user?
I don't recognize JS anymore. We're now having to juggle cross environment compiler presets? 
I've never worked on anything that wasn't supporting at the very least back to IE10 - is there any point in using babel-preset-env in this case? 
But how can you provide the correct version to the correct browser, assuming you target more than one browser? And what does that do, ignore all the other browsers? It's naive to trust the user-agent, at least without having a back-up plan. And a way to detect when it doesn't work.
-2 characters with tagged template literals \o/ t=&gt;(a=document.createElement`a`,a.textContent=t,a.innerHTML)
Other languages, sure, I meant it's not commonly used in JavaScript currently.
It does it at compile time - it computes the least common denominator of the browsers you specify when you provide multiple browsers. If you wanted multiple bundles then you'll need to setup something that uses multiple configs. Currently we don't support anything like that although thinking about the idea. Would probably need to integrate with Webpack or provide some service for it.
Yeah simply so that your config is easier and you don't have to update it it all the them with es2015,es2016, etc. Another thing you can do is make it target latest chrome when you are developing so it's a faster compile/less need for sourcemaps when debugging.
Yeah that must be it. If you are using babel-loader you can just use the query form. Maybe we should figure out how to throw an error if you have both
It's a single preset that compiles down to the least common denominator environment. It's up to you if it's worth doing multiple presets/bundles. (Most effective would probably be one for ie/safari and another for the others)
Why not use generators
Great work! I thought you'd be interested in knowing that I managed to get an Isleward server up and running on a Raspberry Pi 2 and the performance is great!
Yeah I have mixed feelings too.. and a bad Perl after taste. This is the kind of syntax magic that makes Perl so hard to grasp and error prone. Not sure if the bytes saved are really worth the problems (and debate) it will cause.
A much less ambiguous (in my opinion) way to do this would be let obj = { :var1, :var2 }
The idea is you can chain filters on existing collections (arrays, strings or generators), the main boon of this library is its lazily evaluated meaning the filters are only checked when you try to extract data from the collection and the elements are pulled through the filters as needed rather than checking all elements in the initial collection against the first filter before checking the passing elements against the second filter, this library finds the first passing element in the initial collection and checks it against the second filter, repeating until it finds an element that passes the first and second filter. This can in theory result in better performance than a naive implementation of some filtering, without having to put in a lot of effort on the part of the programmer, you can probably get slightly better performance by spending a lot of time optimizing for your specific case, but i think this library strikes a good balance between high performance and fast development speed. Edit: And the library is built on a generator.
Ah ok, so it does use generators! My bad :) This looks extremely similar to RxJS. Have you heard of it? In any case good job :)
Another one is addEventListener. The "useCapture" parameter defaults to false and can be omitted. (It was mandatory in old Firefox and Chrome versions which predate IE9. It's perfectly safe to omit it nowadays.) ES6 added default values for parameters which means that these things can be now expressed in the signature of a function. So, this is something you'd see in a call-tip.
I only did that for formatting. As far as I know, you can easily write everything in one line.
It looks good and works well until you add boards and stuff inside the boards. Sometimes it feels like it lags, sometimes it just doesn't update. A refresh shows that it works though. Overall, looking good, excited to see it.
Yep, I did that on my Pi 3, results can be found [here](https://www.reddit.com/r/isleward/comments/5v1e5q/delicious_slice_of_isleward_pi/). Next stop: Isleward server in Termux
&gt; This test will hopefully show that JavaScript is faster. You mean pure JavaScript? jQuery is also written in JS. To be honest it's obvious that pure JS will be faster than jQuery. Good written, pure JS is always the fastest.
here is what I got : [code] {"0":{"name":"jQuery[DOM].test","options":{"async":false,"defer":false,"delay":0.005,"initCount":1,"maxTime":5,"minSamples":5,"minTime":0.075},"async":false,"defer":false,"delay":0.005,"initCount":1,"maxTime":5,"minSamples":5,"minTime":0.075,"id":1,"stats":{"moe":0.0000018776127227802656,"rme":1.4242616715804708,"sem":9.579656748878906e-7,"deviation":0.000006208327136923706,"mean":0.00013183060109289618,"sample":[0.00013831967213114756,0.00014036885245901642,0.00013422131147540985,0.00013319672131147542,0.000132172131147541,0.00013114754098360657,0.00013319672131147542,0.00013422131147540985,0.00013114754098360657,0.0001454918032786885,0.0001290983606557377,0.00012602459016393443,0.00012397540983606558,0.00014856557377049178,0.0001290983606557377,0.00013012295081967214,0.0001362704918032787,0.00014036885245901642,0.0001362704918032787,0.00013012295081967214,0.000125,0.000125,0.00012397540983606558,0.00012704918032786886,0.00012704918032786886,0.00013114754098360657,0.00012602459016393443,0.00014241803278688527,0.00012704918032786886,0.00013012295081967214,0.00012602459016393443,0.000125,0.00012704918032786886,0.00014241803278688527,0.000139344262295082,0.0001290983606557377,0.0001290983606557377,0.00013012295081967214,0.0001290983606557377,0.00013729508196721313,0.000125,0.0001290983606557377],"variance":3.8543325839063305e-11},"times":{"cycle":0.12866666666666668,"elapsed":5.742,"period":0.00013183060109289618,"timeStamp":1488139191559},"running":false,"count":976,"cycles":2,"hz":7585.4922279792745},"1":{"name":"JS[DOM].test","options":{"async":false,"defer":false,"delay":0.005,"initCount":1,"maxTime":5,"minSamples":5,"minTime":0.075},"async":false,"defer":false,"delay":0.005,"initCount":1,"maxTime":5,"minSamples":5,"minTime":0.075,"id":2,"stats":{"moe":1.3710493347250121e-7,"rme":2.047369863206767,"sem":6.995149666964348e-8,"deviation":5.418419632876256e-7,"mean":0.000006696637277729372,"sample":[0.000006335529650278763,0.000007349214394323365,0.000006420003378949147,0.000006335529650278763,0.00000650447710761953,0.000007180266936982599,0.00000650447710761953,0.0000066734245649602974,0.000006420003378949147,0.000007095793208312215,0.000006588950836289914,0.00000650447710761953,0.00000912316269640142,0.000006335529650278763,0.000006420003378949147,0.000006335529650278763,0.000007011319479641832,0.000006335529650278763,0.00000633438906484414,0.000006413946221527835,0.00000781185757750185,0.000006413946221527835,0.000006413946221527835,0.0000065784063810541895,0.000007318477098922786,0.000006496176301291013,0.000006825096620343722,0.0000065784063810541895,0.000006413946221527835,0.0000069073267001069,0.000006825096620343722,0.000006989556779870077,0.000007400707178685963,0.0000069073267001069,0.000006496176301291013,0.000006496176301291013,0.000006496176301291013,0.0000065784063810541895,0.000006660636460817367,0.0000065784063810541895,0.000006413946221527835,0.000006496176301291013,0.000006496176301291013,0.000006413946221527835,0.000006989556779870077,0.000006496176301291013,0.000006413946221527835,0.000006331716141764657,0.000006331716141764657,0.000006496176301291013,0.000006413946221527835,0.000006496176301291013,0.000007647397417975495,0.000006331716141764657,0.000006413946221527835,0.000006331716141764657,0.000006331716141764657,0.0000087163884548968,0.000006331716141764657,0.000006496176301291013],"variance":2.9359271317938863e-13},"times":{"cycle":0.0814378059344669,"elapsed":5.649,"period":0.000006696637277729372,"timeStamp":1488139197301},"running":false,"count":12161,"cycles":6,"hz":149328.6792351205},"name":"tests","options":{},"length":2,"events":{"start":[null],"cycle":[null],"complete":[null]},"running":false} [/code] 
Well, *that* way of looking at it does seem to change the semantics of `for`. Particularly the example for (var _a of [1, 2,3]) { let a = _a; setTimeout(() =&gt; console.log(a)); } which is actually, I think, pretty close to how it's implemented, although you'd have to copy `a` back onto `_a` at the end of the loop. I also did some digging, and all of this is actually in the ES6 spec under [`for` runtime semantics](http://www.ecma-international.org/ecma-262/6.0/#sec-createperiterationenvironment), so I think the case for it being a semantic change to `for` is pretty strong. The reason I was thinking about this at all is that when I first came across it ( having not read about it before ), I didn't expect it to work like that. Although there's no excuse for not learning the language you're using, this being different to both how javascript worked before, and how this works in most other block scoped languages, seemed like it had the potential to unnecessarily catch out a lot of people. It felt like they could have dealt with it in a more explicit manner. That said, I know they talked over the different ways they could deal with this before settling on this one (I'm pretty sure it didn't work like this in the earlier ES6 drafts), and I've no reason to doubt their decision, and it's clearly quite powerful. edit: switched `_a` and `a` in opening para
you have to disable adblock, apparently.
jQuery is obviously going to be slower simply by virtue of it wrapping far far more functionality into its selected element type than something with a much smaller subset does. In short, this looks like it's just testing doing less against doing more. But we already know doing more takes more cycles, the question is really just: is having more functionality available on the base type worth it or not? The lol type has no traversal methods, no animation or prop methods, no removal or addition methods, whereas jQuery has tons of all of these (that's one reason why its `$('selector')` form is costly, and it's a good idea to save it and do work by traversal instead of selection). Its ajax method doesn't have the vast majority of the configuration options available to jQuery's ajax methods. Maybe I'm missing where typescript fits into this picture.
I'm sorry, Elm is a UNIX email client and that's that. 
There are several way to accomplish this. * I know you use P5 and probably don't want to go to vanilla js yet that would allow you to use the `moveTo` function which allows to move to a different point without drawing a line. * You could also save each continuous line in a separate array but this requires some overwork. * This is probably the solution you need. Basically find the distance between two consecutive vertexes and end the shape if the distance is too big. var SOME_BIG_DISTANCE = 20 beginShape(); noFill(); for (var i = 0; i &lt; this.history.length; i++) { var h = this.history var p = h[i]; if (i &gt; 0) // don't check for first point if (dist(h[i-1].x, h[i-1].y, h[i].x, h[i].y) &gt; SOME_BIG_DISTANCE) { endShape() beginShape() } vertex(p.x, p.y); } endShape(); Didn't test this but it should work.
It seems to be promising, I'd love to try it sometime later. However, don't start an introductory blog post saying that "**JavaScript** is awesome" while the product is being developed with **TypeScript**.
1. Because some people prefer callbacks? 2. Because ES6 modules aren't out in all browsers? Most compilers compiled down to CommonJS anyway. 3. I'm going to support old browsers, you caught me mid conversion 4. Read the code again mate, you might figure out why I did that :)
&gt; Because some people prefer callbacks? Just await the result and call your function or do your computation. &gt; old browsers If Babel or whatever is needed, you can also use ES6 modules. Compiling to any format is only an option if you go with the standard. It's also needed for static analysis. &gt; you might figure out why I did that Yea, you're having that non-descriptive signature because you want the optional callback in the last position. That's not a good trade-off.
For each point in p.history add a property *wasTeleported* and if p.wasTeleported just don't connect this point with the last point.
Very interesting. So is async / await a better way to manage promises flow over generators? 
Your question is a big ambiguous but I think you are asking for something like http://browserify.org/. 
This is what I got {"0":{"name":"jQuery[DOM].test","options":{"async":false,"defer":false,"delay":0.005,"initCount":1,"maxTime":5,"minSamples":5,"minTime":0.075},"async":false,"defer":false,"delay":0.005,"initCount":1,"maxTime":5,"minSamples":5,"minTime":0.075,"id":1,"stats":{"moe":0.000023693781057857664,"rme":3.0852199642389646,"sem":0.00001208866380502942,"deviation":0.00008109322207556115,"mean":0.0007679770432090485,"sample":[0.0011368421052631579,0.0008947368421052633,0.0007894736842105263,0.0008842105263157895,0.0008526315789473684,0.000831578947368421,0.0008842105263157895,0.0007575757575757576,0.0008080808080808081,0.0007009345794392523,0.0008037383177570093,0.0007476635514018691,0.0007289719626168224,0.0007196261682242991,0.0007383177570093458,0.0008037383177570093,0.0007102803738317756,0.0007009345794392523,0.0007476635514018691,0.0007383177570093458,0.0007289719626168224,0.0007289719626168224,0.0007196261682242991,0.0007196261682242991,0.0007102803738317756,0.0007102803738317756,0.0007476635514018691,0.0007943925233644861,0.0007196261682242991,0.0007009345794392523,0.0007289719626168224,0.0007102803738317756,0.0009065420560747663,0.0007196261682242991,0.0007102803738317756,0.0007196261682242991,0.0007383177570093458,0.0007476635514018691,0.0007196261682242991,0.0007289719626168224,0.0007196261682242991,0.0008504672897196262,0.0007476635514018691,0.0007196261682242991,0.0008317757009345794],"variance":6.576110666596279e-9},"times":{"cycle":0.08217354362336819,"elapsed":6.076,"period":0.0007679770432090485,"timeStamp":1488153554919},"running":false,"count":107,"cycles":3,"hz":1302.1222559224252},"1":{"name":"JS[DOM].test","options":{"async":false,"defer":false,"delay":0.005,"initCount":1,"maxTime":5,"minSamples":5,"minTime":0.075},"async":false,"defer":false,"delay":0.005,"initCount":1,"maxTime":5,"minSamples":5,"minTime":0.075,"id":2,"stats":{"moe":5.675698706756701e-7,"rme":1.353909453796099,"sem":2.8957646463044394e-7,"deviation":0.000001985236221911573,"mean":0.00004192081450382922,"sample":[0.000042841648590021695,0.00004446854663774404,0.000047180043383947936,0.00004175704989154013,0.00004175704989154013,0.000041198501872659175,0.00004066345639379347,0.000041198501872659175,0.00004066345639379347,0.000041198501872659175,0.000041198501872659175,0.00004226859283039058,0.000042803638309256285,0.00004226859283039058,0.00004173354735152488,0.00004226859283039058,0.00004226859283039058,0.000042803638309256285,0.00004066345639379347,0.00004012841091492777,0.000041198501872659175,0.00004012841091492777,0.00004066345639379347,0.00004173354735152488,0.000041198501872659175,0.00004066345639379347,0.00004066345639379347,0.000041198501872659175,0.00004066345639379347,0.00004066345639379347,0.000043338683788121995,0.00004226859283039058,0.000041198501872659175,0.00004226859283039058,0.000041198501872659175,0.00004066345639379347,0.00004173354735152488,0.00004066345639379347,0.000041198501872659175,0.00004547886570358481,0.000041198501872659175,0.000041198501872659175,0.00004173354735152488,0.000041198501872659175,0.00004173354735152488,0.000041198501872659175,0.000051899411449973246],"variance":3.941162856789737e-12},"times":{"cycle":0.07835000230765682,"elapsed":6.326,"period":0.00004192081450382922,"timeStamp":1488153560997},"running":false,"count":1869,"cycles":6,"hz":23854.498340165977},"name":"tests","options":{},"length":2,"events":{"start":[null],"cycle":[null],"complete":[null]},"running":false}
I don't use React, so I can't answer on the specifics of that, but in general there are three conditions necessary for an async callback or overridden class method to work: 1. The function that calls your function doesn't need your return value. (Since your function will return a Promise instead of a raw value.) 2. The calling function doesn't need to wait for your function to finish running (due to the way async functions work, your function will return a Promise as soon as the first `await` is reached). 3. You don't need to throw errors into the calling function. If you throw an error, and the code which calls your function isn't aware that your function is async, your error will be lost. Your function returns a Promise, which will be rejected, but the caller will not add a `.catch()` handler to your promise. Native JavaScript event handlers are absolutely fine to run as async functions, you may want to wrap the contents in a try/catch. Beware however that due to rule #1 `return false` does not work, you must use `e.preventDefault()` and `e.stopPropagation()` as appropriate. I suspect componentDidMount will be fine too.
It doesn't use user agent or anything. It's simply a babel preset that knows which features each browser version supports so you can have code compiled to whatever js features are supported in your environments. If all your target browsers support template string or arrow functions, then with the preset Babel won't compile them and now you get a smaller size file sent to the browser since compiling js is always going to be larger than the src language. It does work fine already, but the feature set of the browser is always changing. You might think at some point all of your supported browsers support ES6 so you don't need Babel but there's always new ES features coming and this tool helps you not have to think about what features are supported or not.
&gt; The lol type has no traversal methods, no animation or prop methods, no removal or addition methods, whereas jQuery has tons of all of these (that's one reason why its $('selector') form is costly, and it's a good idea to save it and do work by traversal instead of selection). I think you may be misunderstanding one thing here. The multitude of methods that may be available on a jQuery object have absolutely no effect on the performance of `$('selector')`. Those methods are all on the _prototype_ of the returned jQuery object. They are not part of the object itself, and even if you added thousands of methods to the prototype, it would have no impact at all on the performance of the `$()` aka `jQuery()` constructor. What takes time when you run `$('selector')` is the code that parses and queries the selector, along with the small bit of code that examines the parameters and decides which flavor of this function you are using. Prototype methods that you may or may not call later don't come into play here. The reason it can sometimes a good idea to cache the jQuery object returned by `$('selector')` is simply to avoid the cost of parsing and querying the selector again. BTW, don't be misled by the fact that jQuery plugin methods are traditionally added to `$.fn` or `jQuery.fn` instead of `$.prototype` or `jQuery.prototype`. All four of these are references to the very same `prototype` object. As a minor historical note, in the very first versions of jQuery in early 2006, `$.fn` actually was a separate object unrelated to the prototype, and `$()` looped through that object and _copied_ references to each method into the returned jQuery object. So back then, the number of methods added to `$.fn` did impact the performance of `$()`. But this was fixed long before jQuery 1.0 so that `$.fn`/`jQuery.fn` was simply a reference to `jQuery.prototype`. The only reason `$.fn` exists at all is for backwards compatibility with ancient pre-1.0 jQuery code and plugins.
[removed]
As a space/performance tradeoff, it only wraps in an IIFE if the variable is captured in a closure. See [here](https://www.reddit.com/r/javascript/comments/5w5qlr/how_babel_compiles_es2015_block_scope_in_one_image/de7krhj/) for how it looks like when wrapped.
Like anything else it's useful to think of Elm in terms of trade-offs. Yea there are some parts to Elm that are a little worse than in Javascript, but where Elm shines is in its pure functional guarantees, its separation of data and side-effects, and just as importantly how it constrains developers into writing applications that will be more maintainable over the long term. **Is there boilerplate?** To do some tasks, yes. Others, it's less than in JS. For example, how do you update a nested record in Elm? Like this: let myNestedRecord = myType.nestedRecord updatedNestedRecord = { myNestedRecord | value = "New Value" } in { myType | nestedRecord = updatedNestedRecord } There are two kinds of boilerplate there. The first is formatting. There is a standard formatter in the Elm community called [elm-format](https://github.com/avh4/elm-format) and while it does add more lines, it also makes code formatting opinions a non-issue. This is actually really great, but that's a side topic. More obviously the above code is taking several lines to update a nested record. In Elm, everything is immutable and there isn't yet a succinct way to perform such an update but there are interesting ideas being proposed [1](https://medium.com/elm-shorts/updating-nested-records-in-elm-15d162e80480#.lr97toi2a) [2](https://medium.com/@billperegoy/elm-effects-made-simple-83eb3c2846c3#.8ej2l8552). You'll find that sort of thing here and there, but in other places you'll find **far less boilerplate**. For example, in Javascript how do you guarantee immutability? How do you curry and compose functions? How do you make sure your data is the right type? Here's a complete example that demonstrates all that in Elm: import Html exposing (text) reverseUpper : String -&gt; String reverseUpper = String.reverse &gt;&gt; String.toUpper -- Function composition main = "Hello, World!" -- Piping data (think Unix pipe operator) |&gt; reverseUpper -- An auto-curried function waiting for a String to be supplied |&gt; text -- Same here What you don't see (but you could if you go [here](http://elm-lang.org/try)) is the lack of compiler errors because we aren't trying to mutate anything and the types match up. What you do see is a lack of boilerplate compared to using those same concepts in Javascript. **What's up with the coupling of the language and framework?** This question actually seems strange to me. It's sort of like asking why can't I break out of a Redux architecture in an app using Redux? Or why can't I mutate variables in a language that only allows immutable constants? Elm is a pure functional language which means immutability, pure functions, and other FP concepts are all first class citizens. In fact, the only Elm code that you can write will be *inside of a pure function*. As a result, the language needs to expose some way of performing side-effects: DOM manipulation, HTTP requests, HTTP responses, user input. All of these side-effects are handled by the Elm runtime and in order for there to be a consistent, simple interface between the Elm runtime and every single Elm application Elm provides a couple of opinions on architecture. 1. You must provide an **init** function that tells the Elm runtime the initial value of the app state on start up. 2. You must provide an **update** function, a pure function that accepts an event, the current app state, and will return a new app state. 3. You must provide a **view** function, another pure function that accepts the current app state and returns [Virtual DOM](http://elm-lang.org/blog/blazing-fast-html-round-two). Beyond that you are free to do whatever you want within the confines of the language. Without these few opinions Elm wouldn't be able to guarantee immutability and purity of functions. **Now let's ask some different questions.** In Elm, how does one mutate variables, or use prototypical inheritance, or how does `this` work, or how do I create stateful components, or hook into the view component life cycle, or directly mutuate DOM? The answer is you can't.. to all of those questions.. which is great. There is no "props vs state" debate in Elm. There aren't any hard-to-find stackoverflow answers about using `shouldComponentUpdate` or `$postLink`. There are no setTimeout hacks. **An Elm programmer's job is to think carefully about how to model their data, and to write pure functions.** Much of the other complexity that you see in the top JS frameworks today is a non-issue in Elm because those constructs literally don't exist in Elm. To answer your final question, I have an Elm app shipped to a very tiny number of production users (less than 90). Me and a team of 5 others built an application for internal use so please take all of my response with a grain of salt. Specifically, the experience was great. We built a fair amount in the first 3 days and had [something really cool to show off](https://www.youtube.com/watch?v=WteY4AqQ3xo). We have since added more in our free time and it continues to be a pleasant experience. Would I do it again? Absolutely. Having now done AngularJS, BackboneJS, AmpersandJS, KnockoutJS, Flux, Redux, and a little bit of CycleJS and ReactJS, I'd pick Elm every time if no other constraints were placed on me.
They're pretty different, but since async/await is compatible with plain promises then it's more straightforward.
Cool library, very feature rich, I may end up using this for my chat app. I am a little worried that it is over engineered, there might be a 80% of the functionality in 20% of the code, opportunity here. Also, it would be easier to gauge the size of the library if you stated the code size without the data files.
Very nice presentation. Thank you! I am digging async/await. Definitely a big step forward for JavaScript.
Nice, thanks.
Oh yeah. Javascript can be like driving a car without brakes, air bags, crumple zones, etc. How easily one can run into problems because of objects being mutable, or how loosely parameters are defined for a function, etc.
code: https://github.com/hepuxuan/hacker-news-pwa demo: https://hepuxuan.github.io/hacker-news-pwa
The size matters when you're building for the browser and in that case you _have_ to bundle the data files.
First of all, don't use jsFiddle. It's no longer the best JavaScript playground. Use other such as JSBin. Second is that, your CSV data format is incorrect. In CSV, each line contains the columns. If the column headers exist, they're placed on the first line then the data columns follow on next lines. In your CSN data format, each line contains the column header and its contents. While this can be used for and from your own script, it won't be usable for import from other script and applications. You can use ready to use CSV library from [GitHub](https://github.com/search?q=csv+language:javascript) or create your own. As for importing, iterate each item in the form's `elements` property. Each item is an element object such as INPUT, TEXTAREA, SELECT, etc. Assign the element's value from the imported CSV colum value if the CSV column header name matches with the form element's `name` property. Let's assume that the imported CSV file is stored in an array like below. var csv = [ "userName": "John Doe", "readPref": "no", "phone_to_email": "yes", "tel_number": "54321", "email_address": "johndoe@hismail.com", "timeZone": "Mountain" ]; The code to assign the form fields which are already exist on the HTML document, would be like below. var form = document.getElementById("contact-form"), i; for (i = 0; i &lt; form.elements.length; i++) { var eleField = form.elements[i]; if ("undefined" !== typeof csv[eleField.name]) { eleField.value = csv[eleField.name]; } } 
you make me sick. There's only one real way: const fooFunc= ((_this) =&gt; { const tempFunc = function(param_name) { /* do something */ } return tempFunc.bind(_this, arguments); })(this);
Pivotal wrote a nice [blog post](https://www.pivotaltracker.com/blog/Elm-pivotal-tracker/) about using Elm in production for a new dashboard in one of their products. It's a short read, but if you're lazy: &gt; To sum it up, our manager has mandated that all new code be written in Elm.
&gt; I suspect componentDidMount will be fine too. To chip in on that then, it wouldn't break anything but you should keep in mind that if the consumer of your method isn't relying on it being async, then it's not gonna do anything (other than push the logic inside your function out of the call stack). In this case React doesn't care about componentDidMount's return value, so turning it into a promise with async doesn't make any sense.
It skips HTML? How? Not with regex right?
That sounds like a really idea.
Why is that? I don't think there is any major problem with that solution if done only for testing purposes, especially when you remember about rolling it back to the original value, that would be side-effects free.
No. Not with regex.
This is exactly what I did at the beginning and I could detect it but I played badly with the endshape and beginshape, I will try it as soon as possible and give you the result, thanks a lot for helping me :). Also do you think my game will be faster with vanilla JS ?
In one project I needed to distinquish between mobile and desktop devices to have a different behaviour for handling videos, so I had a service that was checking if the app is accessed from a mobile device or not. To have some tests that make sense I had to stub out user agent. It's probably not the most elegant solution, but it gets the job done in such case and requires very little overhead.
Know that, `call()` and `apply()` methods of a function simply changes the value of `this` within the function, and the `new` keyword creates a new object. Calling a constructor function without using that keyword simply executes that function without creating a new object. When a constructor's task initializes the object by e.g. add a new property into it, it uses `this` to refer to object created by the `new` keyword. By using `call()`, you can use the constructor function to reinitialize an existing object. e.g. function MyObj() { this.data = 123; } MyObj.prototype = { reset: function() { MyObj.call(this); } } var obj = new MyObj(); console.log(obj.data); //123 obj.data = 456; console.log(obj.data); //456 obj.reset(); console.log(obj.data); //123 
Looks like a good start but what if I need to open multiple sockets to different end points at the same time? 
It's been around for a while but it's interesting to apply it specifically to JS. It's hexagonal architecture. I didn't mention it because someone started arguing everything was written this way intrinsically. What I was trying to get at is what Elm does really well by it's nature, manages side effects so your core logic is easy to reason about. I'm just learning Elm now, in attempt to get a much better handle on functional programming, and I am really impressed. I started it with the aim to go back to JS. Now I'm thinking that where I can I'll write in Elm. It doesn't suit every scenario for me quite yet.
myfunction != myFunction
Attach the events with JavaScript instead. See [this fiddle](https://jsfiddle.net/6q3vthxb/).
Got the same error Uncaught ReferenceError: myfunction is not defined at ?page_id=6:373 and when click on button got this Uncaught ReferenceError: myFunction is not defined at HTMLButtonElement.onclick (?page_id=6:379)
As montezume said, it allows user to install to your home screen, be able to display a splash screen when loading the app, work in offline mode, basically it means same look and feel as native apps
I think I know the problem, Im using wordpress and I'm connecting the file wich contains the javascript, wich is named by teste.js I put it on head with this code &lt;script type="text/javascript" src="http://localhost/wordpress/wp-content/themes/sydney/teste.js"&gt;&lt;/script&gt; I copy pasted another button I found: http://jsfiddle.net/bseth99/dJDHd/ and I got this error: Uncaught ReferenceError: $ is not defined at teste.js:1
I may have missed something but how is that different than a web app, except it loads slower? I opened in iOS Safari, added to my home screen, turned off my connection and it doesn't load anything except an error saying I have no connection. 
This will answer your feelings towards PWA https://www.youtube.com/watch?v=cmGr0RszHc8
They share global scopes, just reference the global after requiring the code. You don't need `module.exports`, but its a very good idea to add.
I've heard that raw generators are more powerful in some ways because async/await basically bakes in one version of what a wrapper like co gives you, but at the cost of some control about how that's modeled. Still trying to dig up the links from folks arguing this. async/await gets rid of the need to use something like co, of course, by formalizing what it does into syntax.
Maybe in the Midwest, out in the Valley they're already on disabled-brick-first.
Few things I noticed: 1. After opening the comments page for an article, there doesn't seem to be an easy way in the UI to go back. This is important for PWAs, which don't show browser chrome when installed to your home screen. 2. The comment links point to non-existent pages which give you a 404 when you actually try to visit them (e.g. by copying the URL and pasting it manually or by opening the page in a new tab). 3. Instead of using hash-fragment based URLs, consider using pushState instead.
Personally I would say generators and async/await solve two different issues so it's hard to compare them, and it's like comparing for loops to while loops. The intention is formalized asynchronous control flow but they both approach it from different angles. That said, I would argue that generators are useful for lazily reading streams of data (eg: reading IO from file handles or network sockets) whereas async/await is useful for plain asynchronous execution. Both are a reaction to callback hell.
[this](https://jsfiddle.net/owhp4mu2/2/) should work.
While you should definitely get an understanding of vanilla JavaScript and how events work, this is exactly the sort of thing jQuery was written for. First of all, you'll want to give that button an `id` attribute. Without an id, you're not going to be able to reference it uniquely within scripts. So we rewrite the button like so: &lt;button type="button" id="click-me"&gt;Click Me &lt;/button&gt; And I realize that your `compare(choice1, choice2)` was just filler, but you're going to want to really rewrite it so that it definitely is clear about just what you really are comparing. For now we'll just assume a function called `compareFunction`. Now that we have that set up‚Ä¶ Here's the code you'd have to write in vanilla JavaScript (keeping in mind that thankfully implementation of events handling is largely uniform now): document.getElementById('click-me').addEventListener("click", compareFunction, false); Here's the same code rewritten in jQuery: $('#click-me').click(compareFunction); And here it is rewritten to follow the recommendation to bind events onto the base document element and then filter them by the selector (e.g. '#click-me' above is the selector that points to the element with the id of "click-me"): $(document).on("click", "#click-me", compareFunction); Note that the advantage of writing it this way is also so that jQuery doesn't have to interpret the selector on load, just when there is a click event. 
This is what reduce is for. Please don't use a forEach here
&gt; Does it bubble to let's say &lt;ul class="filter" ?? You can find that out by looking [at the documentation](https://developer.mozilla.org/en-US/docs/Web/Events/change). The relevant part is "Bubbles: Yes". [Codepen example](http://codepen.io/anon/pen/XMbYNQ?editors=1010#0). 
Fair enough. Why is it a bad idea to use forEach?
Thank you! 
Hahaha yeah, the react conf video from the guy at Flipkart? Was good
I actually like the forEach for this. You're iterating *once*, outputting four things. As opposed to //provide implemenation of pluck(name) returns (ob) =&gt; ob[name] agesObj={name:'Ages',coolArray.map(pluck('age'))}; jobsObj={name:'Jobs',coolArray.map(pluck('job'))}; favColorsObj={name:'Favorite Colors',coolArray.map(pluck('fav_color'))}; favNumbersObj={name:'Favorite Numbers',coolArray.map(pluck('fav_number'))}; which iterates four times. Or function pluckFrom(sourceArray){ return function(strat){ return {name:strat.name,data:sourceArray.map(pluck(strat.propName))}; } } var strategy=[ {propName:'age',toName:'Ages'}, {propName:'job',toName:'Jobs'}, {propName:'fav_color',name:'Favorite Colors'}, {propName:'fav_number',toName:'Favorite Numbers'} ]; var objects=strategy.map(pluckFrom(coolArray)); which also iterates coolArray once per property to be plucked. You'd have to profile to see which way performed best for your use case, and then try to factor in ease of future maintenance. That would at least give you a way to measure for 'better'.
I like [this version](https://react-hn.appspot.com) better
Well, if it's the transient arrays that are irritating you, you could create the shells of the expected output objects first, then target their data attributes directly in the forEach...?
Well, I mean async/await ARE generators: they're just a subset focused on promises, with a particular co-routine pattern baked in.
If you want to implement the same algorithm that the OP used, you'd use reduce. In that case, the reducer is going to look a lot like the callback for the forEach, except the state is initialized in the accumulator and push gets changed to concat. But you're right that the algorithm itself is flawed. He essentially wants a tuple that looks like `[fetch(coolArray, 'key1'), fetch(coolArray, 'key2'), etc]`, which of course is a mapping on the keys of the object.
&gt;&gt; So is async / await a better way to manage promises flow over generators? I dislike questions like this. There is rarely, if ever, an objective "better-ness" in computing. promises aren't "better" than callbacks, observables aren't "better" than promises, async/await isn't "better" than using generators Some tools allow for more elegant solutions and typically more abstraction allows for easier management of the problem -- promises are typically easier to deal with than callbacks -- but that doesn't imply they are strictly "better".
 function reverseString(str){ if (!str || str === ""){ return ""; } return reverseString(str.substr(1)) + str.charAt(0); } function reverseUpper(str){ return String.toUpperCase(reverseString(str)); } function main(){ document.open(); document.write(reverseUpper("Hello World")); document.close(); } main(); I don't see much boiler plate, mutation or compiler errors.
Ha, thanks. So, that means until Apple supports it, it can't replace native apps. 
I had no idea what this was. So for anyone else in my boat: notie is a clean and simple notification, input, and selection suite for javascript, with no dependencies. demo: https://jaredreich.com/projects/notie 
Oh, ok great. Maybe put one in the github readme or project description. 
That's exactly it! You have adapters that are there for dealing with side effects and creating the input for your core logic. That interface are your boundaries. It makes testing and maintenance really nice in my opinion. 
I guess that's exactly the reason apple is bit hesitate to support service worker
Maybe try it like this: &lt;h2 class="hero-large-text"&gt;Learn and Master&lt;/h2&gt; &lt;h2 class="hero-large-text"&gt;&lt;span class="js-rotating"&gt;Calculus | PreCalculus | Trigonometry | Algebra | Geometry&lt;/span&gt;&lt;/h2&gt;
&gt; &lt;h2 class="hero-large-text"&gt;Learn and Master&lt;/h2&gt; &gt; &lt;h2 class="hero-large-text"&gt;&lt;span class="js-rotating"&gt;Calculus | PreCalculus | Trigonometry | Algebra | Geometry&lt;/span&gt;&lt;/h2&gt; But then the hero section becomes massive and ugly, I had something similar to try to push the rotating element into a different line but didn't like the look of it. I applied it so you can take a look. I'd like it to just say "Master bla bla bla" and be in one line
The person who is not lemminman and posted here is shadowbanned, by the way!
**THANK YOU.** ----
&gt;I'd like it to just say "Master bla bla bla" and be in one line [Change the appropriate header to be inline-block](http://imgur.com/a/ktp0i): .hero-content-style1 h2 You won't have any spacing between the h2s but you can edit that with css or [just throw in a couple `&amp;nbsp;` in your html](http://imgur.com/a/V4mQA).
I've not seen them backing out. They seem to try keeping steering forward.
to me it looks like they back out enough until they have enough space to go forward again, I managed to create a situation where they just back out for a bit and then drive right into the wall again [poor fellas](https://gfycat.com/KindheartedCreativeFugu) took me a while to make this gif, they're still going :/
Looks like a fun project, but I think it serves as a good example of where custom AI programming can easily outshine neural networks: http://i.imgur.com/R4aFiqc.png A custom AI would simply maintain a map of available space based on its sensors and calculate when it needs to steer or back up depending on what's around it and its memory of other available space.
I just made this the other day: http://codepen.io/lemmin/pen/bqNBpK
The point of JSX is that DOM operations like this only happen when necessary because they are significantly more expensive than managing simple JS objects (which is what React elements are). Also, in JSX you can have an array of React elements which renders as adjacent HTML.
/u/tme321 I just updated the readme.md, you can see how to open multiple sockets to different end points at the same time, thanks.
&gt;&gt; What's the best, most stable tech I should learn to make clean UIs quickly? I'm looking for something that would simulate a future where browsers' default styling of form elements wasn't straight out of windows 3.1... where aligning page elements wasn't 60% of the work... and where things continue to look reasonable when i resize a window... take a look at [css grid](https://css-tricks.com/snippets/css/complete-guide-grid/). It's not 100% supported, but it's getting closer. I've only played around with it, but I thought it was pretty cool. Stuff like this is nice: .container{ grid-template-columns: 50px 50px 50px 50px; grid-template-rows: auto; grid-template-areas: "header header header header" "main main . sidebar" "footer footer footer footer" } 
I appreciate the way this is written more than the way I did it, very nice job!
These operations are on non-rendered DOM objects. They are no more or less expensive than React's VDOM.
Looks fabulous 
Relevant (whenever time/dates are involved): https://youtu.be/-5wpm-gesOY
If you just post your issue in more detail, you'd probably get someone to help you for free. 
If you're plucking out data, map is the right answer. const ages = coolArray.map(item =&gt; item.age); Do this for each thing you're plucking. It doesn't matter that you have four `map` calls because they're all O(n). Coefficient doesn't matter; it's a microoptimization that leads you to sacrifice beautiful, functional readability for what amounts to a performance increase that isn't worth it. 4*N vs N operations doesn't matter at all for performance. **Edit** Excuse me: const ages = {name: 'Ages', values: coolArray.map(item =&gt; item.age)};
Can you describe the bug. You just described how it's supposed to work. So you want to make an Ajax request that pings a URL with some parameters. Is the URL on the same domain? If not, some additional work will be needed, possibly on the server that receives the request. Can you paste the code you have. James@faceyspacey.com
Just sent you an email James. Thanks!
If you need or expect to need what webpack provides, definitely. You get dependency bundling, transpiling, minification, and a dev server at the cost of some tools and configuration. It doesn't put significant (any?) overhead on your final product, so the additional complexity isn't very important.
Yeah thanks
Thanks for the advice. Do you think it's important to learn other frameworks like Angular, React etc.. after jQuery for a junior frontend dev?
Where can I find the HTML? I found my stylesheet but don't know where to get that.
Aurelia
I think you should use jQuery because it is really great and does all things.
Also, it's still getting pushed around after inline-block 
The fact that you need a "superset" tells how javascript isn't that awesome. 
would also love an answer to this. i keep hearing things like "angular is meant for enterprise apps, react is meant for smaller apps" and would love to know what specific apps angular is meant to do that react or vue can't. after delivering a project with ng2, i'm done with it. testing is a ton of boilerplate compared to react, and even wiring up components is a ton of boilerplate.
Can you give me an example of how it's mocked? It's trivial to unit test with DI. All our code, from Angular to backend is all written using the DI design pattern because of how easy it is to do TDD, and this seems to be the consensus best practice for TDD is to use the DI design pattern based on my interactions with people. I freely admit this could be my own echo chamber, though and am interested to learn another way if it's better. But if a library is just written such that DI is hard to do, to me that's an argument not to use the library, not an argument for why another design pattern is better.
When everything is const except things that need to change, the code is easier to reason about. Riddle me this; if you're never going to change a variable reference, what good is making it change-able? I default to const, use let when I know a variable may change, and never use var.
https://en.wikipedia.org/wiki/Enterprise_software
It's not a "grade" as in, level of quality, but rather a series of requirements that allow it to operate in an Enterprise Environment- specifically somewhere there are a lot of people available to work on projects, but many projects are being worked on at the same time and if you are a developer you'll often find yourself shuffled about for a day or two to balance out the resources. It also means that the company is probably operating under specific legislative or other legal restrictions, which means the network is designed to meet those requirements (bringing challenges of its own to online projects if they are forward-facing) and will likely be maintained by an entirely separate department to the developers, making it even harder to set up something as simple as a deployment. These aren't requirements for a framework so much as the environment it needs to exist within and often a stack is chosen because another similar business "made it work". That's not a shining recommendation for any framework, but it's the reality for many developers.
so just so we're on the same page, because I also bought into the whole "you need to DI container *ALL THE THINGS*!" sales pitch when I first started... this is an example of code with a dependency: const Welcome = () =&gt; { const greeter = new Greeter(); return greeter.greet(); } this is the same example but using the **principle** of dependency inversion: const Welcome = (greeter) =&gt; greeter.greet(); think about this for a second. technically, greeter is an interface. we've created an implicit contract that states, to use the Welcome function, you must supply an object that has a greet function. Welcome doesn't know where greeter comes from anymore. this isn't full blown "DI container instantiates everything" but does it have to be? you could unit test this function quite easily. 
From some reading earlier this week, the DOMParser doesn't eval/compile/whatever SCRIPT tags in the new doc, so you have to jump thru some hoops if you're using this to load templates with their own scripts defined (as I was/is).
thanks for all the comments, I've developed a todo list: https://github.com/hepuxuan/hacker-news-pwa/issues for 3, I use react router for routing, I am 90% sure it calls pushState during re-routing process.
Do a benchmark, then you'll see that you're mistaken.
If James cant figure it out, I'm pretty good with stuff like this drop me a line zscally@gmail.com --Z
All I remember from Angular2 is importing and requiring components everywhere. Like to an excessive degree. Moved to react/redux and will never look back. 
And Angular has the (imo superior) ngrx for single state store but at some point you still need to write components and services and those will need to use other objects you've written. And there you have DI for those and can still use redux/ngrx for state management.
Except now you have to pass the object in every time you call Welcome which is cumbersome. Do you think this pattern was never used before the development community as a whole decided on DI? Doing it this way causes headaches when you have a parent component that is responsible for supplying the greeter to a child component because now when you want to test the entire chain parent component must also be written to be supplied a greeter from the outside. Eventually this leads to some sort of initialization routine at the top of the application that creates all the greeters (and other objects) you need and passing them down all the way from there to every single component. If you don't do it this way there is some point in your code where a greeter is always the actual implementation type greeter which means you can't get clear isolation anymore. So you implement this top level object creator and... congratulations you have now reimplemented DI. Poorly.
This hasn't been necessary for Angular since RC when they moved to an NgModule approach. Before that I too was annoyed with having to manually create chains of providers and component heirarchies. But they moved to a new system where you just import the component into 1 place and are done with it. And if wiring up components is making you write a lot of boilerplate I suggest that maybe you just weren't using the right approach to them.
i'm pretty sure redux-devtools can actually generate tests for you. 
To answer the question you actually asked, op, you could certainly use react + friends over Angular but imo one of the biggest benefits of Angular is typescript. The larger the project the more useful static typing is and yes, you can use typescript with React or Vue or whatever but Angular was built with typescript from the ground up so the support is implicit instead of explicit. Also, I believe you are discounting rxjs way too quickly. It is very powerful and the more you use it the more useful it is. If you just treat it as a chore to have to subscribe to observables and move on with your life every time you see them then yes, it isn't doing much for you. But rxjs is at it's core a very functional approach to data streams. All those popular uses you see in js currently about using filter, map, and reduce can be done with rxjs and it provides even more operations that make really complicated functional composition easy. When I first started using Angular I wasn't sold on rxjs either but the more I've used it the more I've come to appreciate the way it handles data stream processing. edit: oh and if you do decide to use Angular, or even just give it a test spin, then I cannot stress this enough: use the angular cli. Use the cli. No really, use the cli. Some of the documentation for the cli has already been moved over to the [official Angular documentation](https://angular.io/docs/ts/latest/) but a lot of it is still only available on the [github page for the cli](https://github.com/angular/angular-cli).
Step 1) read the data from excel: Easiest way by far is to copy and paste into a text area. Then parse with JS. excelData.split('\n') is your array of rows and loop it again and do excelData[i].split('\t') to get your cells for each row. Step 2) Generate HTML: Use JS to create the HTML the way bootstrap likes, looping through the data and inserting it in the relevant places. Step 3) Insert it Put the content on the page. Boom, done!
jQuery is outdated and not needed anymore. Focus on react, node, webpack, angular2, vue and that whole eco system 
We used different strategies in term of providing offline experience. That author had to make another rest call in order for service worker to cache content data, but I did a bit differently, I chose to serialize the redux state into localStorage whenever redux triggers a state change, and I throttled that function to make sure that doesn't get run too often.
DOM objects have to do soooo much shit to meet specs, whether rendered or not. Algorithms upon algorithms
@lazyweb can you provide some rough stats? 
I would recommend hunkering down and teaching yourself sass/css. Bootstrap or Materialize or whatever will only get you so far before you have to put in your own styling. Don't get me wrong though, I love Bootstrap but having the know-how handy when Bootstrap doesn't get it right is indispensable
Thanks to James and his amazing patience, the issue was resolved within 35 mins. Thanks James!
Good answer. jQuery is the ugly girl at the end of the bar. All your friends will make fun of you for even looking in her direction, but she's got a bitchin' house that she won in the lawsuit from her previous husband and a nice warm bed for your to sleep in. I don't know where I was going with that, but learn jQuery. You can always move on to React(which also has growing demand) once you feel more comfortable. 
Redux, Angular, React, Immutable ...
This guy gets it
I don't use AWS so I could be wrong, but I have a feeling that you are already hacked. 
I would take the best of both worlds: React + TypeScript + RxJS. React makes it much easier to make and reuse components, TypeScript catches a lot of code issues and Redux is easily mimicked by RxJS. The disadvantage to this setup is that you'll have to do most of the setup yourself, because the JS crowd has a knack for choosing inferiour but flashy technologies.
Is this the state of /r/JavaScript?
I'm having a little trouble trying to understand what exactly you're trying to do. I would suggest that instead of using a badWords and a goodWords array you make an object where each bad word is mapped to the corresponding good word you want to replace it with. For example: replacements = {fuck : 'damn', dick : 'penis'}; Then you can just check whatever word you may want to replace using(for example): function wordSwap(word) { return replacements[word]; } When you call the wordSwap function with whatever bad word you want to swap it will return the corresponding good word. wordSwap('fuck') Will return "damn".
lines # 218-220 // server location. dynamodb = new AWS.DynamoDB({ region: 'us-west-2' }); // what we wish to use. docClient = new AWS.DynamoDB.DocumentClient({ service: dynamodb }); I'm not familiar with AWS, but I would be shocked if you could connect to your service simply by specifying the region. Maybe you added more information (endpoint, credentials, ect) somewhere else? [edit] p.s. don't post that information anywhere :)
The wired thing is, I tried the code separately and it works just fine. Not really sure why its not working hence why I made this post. 
"is not a constructor" generally means you're trying to use a thing as a constructor that isn't one. When I hit this error, generally it means the variable I thought was my constructor is undefined for some reason. 
Google uses Angular in Google Ads. That's about as core as any core product could be to Google.
I'm not trying to convince anyone to not use react but you can make reusable components in Angular just as easily. I don't understand what you think is easier about react components.
I think I see what you're saying. Can you use indexOf? var badWordIndex = badWords.indexOf('kuk'), goodWord = goodWords[badWordIndex]; Would set goodWord to 'penis'. You could always rename replacements in my original response if that was the issue though.
I cannot answer your specific technical error at the moment, but I'm not sure how this is intended to work. To allow your client to write to DynamoDB, it would need a key for AWS. This would either be hard coded (enormously bad) or provided by AWS Cognito. I don't see either of these things - so I'm not sure how you're planning to have your client authenticate with AWS.
Why not use https://www.npmjs.com/package/webworker-threads
9 years old account and only 126 comment karma, OP is a lucky one.
They clearly mean smaller apps like Instagram, Facebook and Twitter which all run React.
How so? Honest question. I always thought of it as a framework. You can't really pick pieces of it to use the way you can with jQuery. You kind of have to go balls to the wall with React right?
HyperApp. It's small, new and does everything with a minimum amount of code. Supports a ton of stuff and the TodosMVC example is about 5 kb gzipped, including hyperapp.
Good ones. I'd add Ramda to those.
JSX is not HTML. It is a simple DSL that translates into functions, not HTML mark up. Though compared to Angular it is very close to it.
That's way more backward motion than I've seen them doing. Which was more like 1-2 pixels. To me it looked as if it might as well be a rendering problem with turning the car at a small angle.
&gt; you can make reusable components in Angular just as easily React defines components functionally. Nothing allows you to make reusable components faster than this. const Header = ({ color, children }) =&gt; &lt;h1 style={{ color }}&gt;{children}&lt;/hi&gt; // using it ... &lt;Header color='red'&gt; &lt;span&gt;i'm a child&lt;/span&gt; &lt;/Header&gt; // re-using it const AnotherComponent = ({ name }) =&gt; ( &lt;div&gt; hi there, &lt;Header color={{ color: 'blue' }}&gt;{name}&lt;/Header&gt; &lt;/div&gt; ) Angular essentially prepares *strings,* not components. In order to use them you register their presence in the receiving component which finds and processes them. It wasn't a concise decision, they saw no other way. Handling state becomes another problem due to the architecture. React solved the component problem at the root. A component exists the moment you're finished writing it, and it can be scoped, imported and exported like any regular variable can. Since React components are functions that take data and return UI, state and injection are also solved, which is why you can simply plug Redux onto your component and now it reflects and reacts to the store. 
In this case you can also use an exclamation mark at the start: `!function() { ... }()`
You have that with angular as well except that obviously components are defined as objects instead of arrow functions. The idea of a component slots well into the oop model anyway that I don't see what you gain defining them as functions. And generally if you just want to pass data around you would use a service instead of a component in angular but it's the same idea.
I know it's not html. I was responding to the parents comment that says dsl offers no advantage except making it hard to switch off of. It's just as hard to switch off of jsx as it is to switch off of an angular template. Switching off either one is basically a rewrite.
It's not mine :) As you can see it's not GitHub account - i'm tunnckoCore everywhere :) But yea, it's not the best thing and isn't meant for very heavy usage. Everyone has some special or specific case and creates such libs. :)
React + Redux without a doubt. We do "enterprise app" and this is solid.
Not a fan myself. The repo reminds me of an enterprise java app from 2002.
Both can handle "enterprise" applications. But Angular has nothing over React + Redux. It is 100% arbitrary, mutating and changing from version to version, it doesn't base on principles or standards and it certainly didn't push the envelope like React did which sits on clear, functional principles while Angular still has runtime parsers tear through arbitrary mark-up strings in order to glue them to OOP controllers. Everything is going towards functional programming, Angular and a couple of others are the remainders. This article might be of interest: http://blog.wolksoftware.com/the-rise-of-functional-programming-and-the-death-of-angularjs And here's a quick glance over how many pages are built on top of React these days: https://github.com/facebook/react/wiki/sites-using-react
Thanks for suggestion :)
http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB/DocumentClient.html#constructor-property
There's no functional difference between passing data through a container component or through a service. In fact the idea that a component is doing the job of handling data is already backwards in my opinion. And your idea of code duplication makes no sense. Components can be stateless in angular as well. I would say 90% of the components I write are completely stateless. They are fed whatever values are needed to create the component itself, I want to say that would map to props in react, but all they do is display the values they are fed and emit events to anyone who cares to listen if some interaction occurs. It's the same model that people push with react. At some level you need "smart" components that actually do things but the majority of components are "dumb" and don't hold any state they just display what they are given and notify and listeners about events. Your assertion that components aren't reusable is just provably wrong. I don't know what else to say. Edit: Oh and stateless or not has nothing to do with the oop model. The point behind the oop model is the necessary data is encapsulated into a single object. Whether that object changes or not (stateless) has no bearing here.
Probably the use of Flow, with types, extensive docs, interfaces etc.
Huh, I see! That is a pretty neat idea. I've never used Webpack with that kind of per-file configuration before, only requiring it for an entire project. I can definitely see it as a useful shorthand during personal development. 
Yes, you can use JSX without React and vice versa, but by default, JSX compiles to React.createElement By the way, React elements and components are different things. Elements are the virtual DOM while components are the custom element-like things you write.
[hammerjs](http://hammerjs.github.io/) will help you out with the swipe events
I would run the command like [this](http://stackoverflow.com/questions/12941083/get-the-output-of-a-shell-command-in-node-js) and send the `stdout` in the server response. Should be straightforward, but you should probably only run safe or approved commands and ensure that you're not running your server on root.
Well angular does attribute binding just fine, but it doesn't support the spread operator here like you use it. I have to manually assign the attributes, so yeah its a bit wordier but it works just fine: import { Component, Input, OnInit } from '@angular/core'; @Component({ selector: 'stateless', template: ` &lt;div [ngClass]="props.class"&gt; &lt;div [attr.class]="props.class" [attr.value1]="props.value1" [attr.value2]="props.value2"&gt;&lt;/div&gt; &lt;/div&gt; `, styleUrls: ['./stateless.component.css'] }) export class StatelessComponent { @Input() props: {class: string, value1: string, value2: number}; } I have to say, I don't use data attributes very often so I don't have much experience with them. I personally don't see the reason for doing this in the first place but it is easier with the react syntax. Oh, fyi that produces: &lt;div class="my-class" value1="Hello World" value2="42"&gt;&lt;/div&gt;
 [ Ghost](https://github.com/TryGhost/Ghost) covers almost every aspect, and has helped me a lot.
That is still a whole lot of gibberish compared to one line in React. And according to this: https://angular.io/docs/ts/latest/tutorial/toh-pt3.html you still need declarations in order to use components. How else is he gonna make sense of `customheader` without knowing that it refers to your `CustomHeaderComponent`. Writing `CustomHeaderComponent` in your template, which would be logical, would amount to nothing because Angular doesn't have scope, except if it's injected somewhere. Try this in ng2, all the imports and declarations included, then let's compare: import React from 'react'; import { render } from 'react-dom'; const Say = ({ what }) =&gt; &lt;span&gt;{what}&lt;/span&gt; const Hi = () =&gt; &lt;Say what="hi" /&gt; render(&lt;Hi /&gt;, document.querySelector('#app'))
The aws sdk falls back on credentials stored on your computer. If OP is running this in a vm or elsewhere, it wouldn't work.
saved!
Pretty spot-on
DOM operations on non-rendered nodes do cost more than remaining in pure JavaScript, but **not** that much more. I have done lots of benchmarks on this. Years ago this point was entirely valid, but not so much now. There are some things to consider when working with the DOM for performance: * There will always be a minor performance hit because the DOM is not JavaScript. This means you have to bleed through an API to something else. * DOM operations are fast... as in nanosecond (billions of operations per second fast). * If you want to read from the DOM with maximum performance use the standard DOM methods as they average about 2800x faster than querySelectors, but querySelectors tend to be about 16x faster than the DOM methods when searching by attribute value or attribute name if that name isn't *id* or *class*. * There is a performance penalty to using innerHTML to write content to the DOM. This performance penalty is only offset if writing a large number of DOM nodes. * The biggest bottleneck when working the DOM is the *document* object as it is a single point of asynchronous entry. Instead create and manipulate DOM nodes and only add them to their proper place in the DOM as a final step. * Rendered nodes take (much) longer to manipulate if there is a repaint associated to the change. * If you know what you are doing the React VDOM isn't a significant performance gain as it is still JavaScript that still writes DOM nodes. You are still going to have to attach events and possibly styles. Odds are if you do your own benchmarks you will probably make discoveries of your own. Most people have trouble imagining what 2800x difference really means, because its so monstrously huge, so here are some examples: * 1 second to 47 minutes. * distance from Sun to Jupiter versus Sun to Alpha Centauri * last year compared to before the founding of Judaism * a walk across the neighborhood versus a drive across the continental US * 57 cm versus 1 mile * the closest black hole is about 2800 light years away while the closest star to our sun is only 4 light years * The tallest building in the world is only 2717 feet tall.
Angular is more wordy. So what? Components only need to be declared once in a single module. Here's the one the cli generated when I created the header component and another one for the above comment: import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { FormsModule } from '@angular/forms'; import { HttpModule } from '@angular/http'; import { AppComponent } from './app.component'; import { StatelessComponent } from './stateless/stateless.component'; import { CustomHeaderComponent } from './custom-header/custom-header.component'; @NgModule({ declarations: [ AppComponent, StatelessComponent, CustomHeaderComponent ], imports: [ BrowserModule, FormsModule, HttpModule ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } That's it. I don't have to specify the component in any other location ever. I don't have to import it into anything unless I specifically want another component to be able to read it with a @ViewChild statement or something similar. And that isn't a particularly common need. My entire root component for the same project looks like this, I specified a few small members to pass into the components: import { Component } from '@angular/core'; @Component({ selector: 'app-root', template: ` &lt;h1&gt; {{title}} &lt;/h1&gt; &lt;customheader color="blue"&gt;&lt;span&gt;i'm a child&lt;/span&gt;&lt;/customheader&gt; &lt;customheader color="green"&gt;{{name}}&lt;/customheader&gt; &lt;customheader color="red"&gt; &lt;ul&gt; &lt;li&gt; &lt;span&gt;Item 1&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;Item 2&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;Item 2&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/customheader&gt; &lt;stateless [props]="myProps"&gt;&lt;/stateless&gt; `, styleUrls: ['./app.component.css'] }) export class AppComponent { myProps = {class: 'my-class', value1: 'Hello World', value2: 42}; name = "Bob"; title = 'Stateless'; } See how I never once bother importing my custom header into there? Because it isn't needed. If your argument boils down to a component requiring a few less lines to write in react then fine, whatever. Most of those lines are autogenerated by the cli for me anyway so I personally have no issue with it. I prefer to worry about things like functionality that actually impact my ability to do work, not whether I can write a useless single line component to show that I can print out a passed string into a span tag.
&gt; Angular is more wordy. So what? "Wordy" is stretching it. I see a monstrosity. But that was the premise to which you replied that it isn't so or at least indicated it. At least we have established that React is indeed easier/simpler. &gt; Components only need to be declared once in a single module First and foremost, that is Angulars problem, not yours, but they offload it on your shoulder. A global component register is a flawed concept, it will cause troubles down the tree, name bleeding, overrides, etc. In reality Angular doesn't have components in the strict sense. Plug-and-play templates would be more apt. The point is that React doesn't fall in any of these pits, doesn't rely on arbitrary boilerplate while being smaller and simpler. Just by looking at these examples above you already know 50% of React. It can do this because it has clear principles and standards that have evolved for a long time. It didn't set out trying to "fix the dom" as Angular did, resulting in a huge, complicated hack on top of the dom, which is itself a hack. React treats the dom as a host, problem solved once and for all. 
It's my favorite language :D
Lucky how?
Link points to https://github.com/
Oh, ok, thanks for letting me know, I'll keep that in mind.
It seems now with create-react-app and a huge ecosystem of prewritten components, as well as the forthcoming performance improvements in Fiber, Vue just doesn't offer many compelling advantages over React and Redux. :-/ I've used both quite a bit. I can almost always find what I need in the React ecosystem ... with Vue, not yet. Maybe one day? It does seem like a lot of duplication of effort. :-(
You might need to draw clockwise and not counterclockwise?
&gt;&gt;But that was the premise to which you replied Bullshit. My statement was that you can make a reusable component just as easily. I proved that I can make a reusable component. The boilerplate around the component was generated for me by the cli. All I wrote was the template and the color member variable. You keep trying to move the goal posts and I don't know why I am even bothering to respond to you. You don't like Angular. Cool story bro. I don't care if you do or not. But when you spread baseless accusations like "You can't make reusable components" then yeah I'm going to speak up.
&gt; It is 100% arbitrary, mutating and changing from version to version, it doesn't base on principles or standards... It's been pretty stable since leaving RC.
I never said you can't, i said not as easily and not as fast &gt; you can make reusable components in Angular just as easily &gt;&gt; React defines components functionally. Nothing allows you to make reusable components faster than this. Your code blobs proved the point though. Cli having to help you cope with the Angular tax makes it even worse.
A lot of people will actually install jQuery and use it alongside React, I think the main reason is because `$()` is much easier to write than `document.getElementById` or `document.getElementByClassName`. I know it can be silly to include the whole library just for that, but people do do it and is currently being done in my current workplace. It just shows that React and jQuery can work together.
&gt; i said not as easily and **not as fast** &gt; No one spoke about **time** Ok dude, whatever. 
Would you mind sharing your opinion of why that's bad? Also curious if this implies that a java app in 2017 looks different.
This is probably the best definition of what it means for something to be "enterprise" that I've ever read. 
I don't work there, but I'd imagine there's more to Instagram than the front-end app for the general consumer. Companies tend to have all kinds of random apps available to actual stakeholders---because they're the ones who really pay the bills in big fat lump sums.
I can't find info whether it supports indexedDB - does it? 
You're using the wrong version of AWS/reading the wrong version of the docs. Try this script URL. `https://sdk.amazonaws.com/js/aws-sdk-2.22.0.min.js`
Meteor is just javascript. Do a bot using node is the same as doing a bot with Meteor BUT meteor has a few more plugins already configured for web, database etc. If your bot needs a web interface and database meteor is a good pick if you are already familiar with it or want to learn it. Otherwise pick node and install a specific library for bots (hubot is written in coffeescript but runs on node and is indeed just javascript). Everything is javascript. Sometimes I wonder... Am I just javascript? Kidding. Both are applicable for the job but node is a better choice if your bot does not need all the extra overhead that comes with meteor. 
Would you be willing to expand on why you feel they aren't clean? I personally picked those because I find them very clean, so I'm wondering where the disconnect is.
The AWS SDK running in the browser can't (and doesn't) use local credentials - it has no access to the files or environment variables. It can only use local credential files when running on Node.
https://github.com/marcuswestin/store.js/issues/181
Okay thanks :)
Many levels of nested statements inside one function, short non descriptive variable names etc.
Keep in mind when reading AngularJS files that you are reading exactly that...essentially Angular Code. You are basically learning a framework, not necessarily JS. 
lol, this was my suspicion.
Ah, I understand. I was subjectively looking at _clean_ from a design pattern/architectural viewpoint rather than from a syntax aesthetic viewpoint. Cheers üëç 
extensive docs and type safety always ruin a codebase for me.
One other suggestion - https://teropa.info/build-your-own-angular/. Highly recommend checking this out, especially if you want to learn Angular. The book takes you through implementing the core functionality behind Angular using TDD. Very helpful if you want to learn TDD and/or if you want a better understanding of Angular.
`store.each(function(value, key)` That signature seems really weird to me. I mean, I get the idea is to be simple to iterate over values if you don't care about keys, but I still feel like `key, value` would be the more intuitive approach. Also, these calls are all synchronous. That's going to cause problems if you ever decide to support asynchonous stores, like `chrome.storage`.
Thanks for sharing.
Going to suggest something a little different here: https://www.codewars.com/ It has a huge set of challenges available to train with, with many different levels of difficulty. The best part, in my opinion, is that once you complete a challenge (or you get stuck and decide to pass on it) you can see how others completed the same challenge. Solutions are voted on with tags like "Best practice" or "Clever".
Store.js was originally released on HN in 2010. It's now live on tens of thousands of websites (like cnn.com!) and has seen lots of improvements over the years. Store.js version 2 is a full revamp with pluggable storage (it will automatically fall back to one that works in every scenario by default), pluggable extra functionality (like expiration, default values, common array/object operations, etc), and fully cross-browser automatic testing using saucelabs.com. 
Thank you! I have thought of it and it's definitely something that I would want to do at some point, but unfortunately not in the near future. I'd be really interested to see if anyone else wants to add algorithms!
Author here. This is exactly the kind of constructive feedback I'm looking for. Thanks a lot. This chapter was by far the most difficult to write and it certainly needs some refining. Explaining both prototype-based and class-based OOP without overwhelming the audience is no small feat. When dealing with OOP in JS, it is pretty difficult to assess what knowledge is essential to a newcomer from the get-go and what can be safely sidestepped. Anyway, I'll try to be more nuanced in my statements about classes. 
Hi /u/code_barbarian, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `thecodebarbarian.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [thecodebarbarian.com](/search?q=%28and+site%3A%27thecodebarbarian.com%27+author%3A%27code_barbarian%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|19|100%
Hi /u/code_barbarian, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `thecodebarbarian.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [thecodebarbarian.com](/search?q=%28and+site%3A%27thecodebarbarian.com%27+author%3A%27code_barbarian%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|19|100%
Because JavaScript uses [floating point](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html) math, not arbitrary precision decimals. ([wiki](https://en.wikipedia.org/wiki/Floating_point))
more module boilerplate then code :D