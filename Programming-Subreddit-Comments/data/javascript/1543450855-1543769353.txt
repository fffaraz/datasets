The question then is, why didn't they spec it out to have the same or similar API? Noted, the APIs have changed considerably over the years, but it's not like these things were specified in a vacuum.
This is my first time realizing that the DOM *isn't* JavaScript. I need to look into this more.
Which part? It‚Äôs only weird if you refuse to consider the moral aspect, imo.
Any point mentioned here really: [https://svelte.technology/blog/frameworks-without-the-framework](https://svelte.technology/blog/frameworks-without-the-framework) &amp;#x200B;
Suggestion: switch to strict Typescript. On strict I mode, something like that won't even compile. Plus, strict mode allows you to catch tons of bugs
After i learned angular i knew i didnt want to work in it any more. Apologies to anyone who enjoys it. Both solutions reek of interim technologies to me, but I would rather waste my time with react. I learned angular first fwiw and spent a couple of years on it.
i just keep rot13'ing it for infinite passwords.
Be more picky, utilize the package locking features of yarn or newer versions of npm, and check out the [audit](https://docs.npmjs.com/cli/audit.html) feature. 
&gt; The problem with your argument is not that I have to test a package I install, but also every dependency that a package itself has, and the dependencies those packages have, and so on, and so on.. so it's really pointless to even go down the road of NPM and reviewing code, because that's all I'd be doing. then you are complicit in any problem you experience. that nobody cares about minimizing their dependency graph and then creates an ecosystem where it's inconceivable to remain vigilant is why this is an ecosystem problem. "it's too hard" is tempting but not a valid excuse for introducing vulnerabilities into your own project. you made a technical decision to depend on the collaboration every transitive dependency in your project every time you accumulated one. 
&gt;As a friend put it better than me: A random guy walked up to him on the street, Dominic gave him a mask and a shotgun and shoved him into a bank. What could go wrong? eh, so you think this situation would have been avoided if the attacker just acted like a legit contributor for 1 month, 6 months, 12 months (whatever you want) to win his trust first? 
Does vue have hooks? üòÖ
3.x does 
Agreed. What I like about React is you‚Äôre pretty fucked if you don‚Äôt know JS and want to use it. Not templates to save your bacon.
&gt; it‚Äôs not as easy as ‚Äúvet package before upgrading‚Äù unless you took a security conscious approach to your setup in the first place if you didn't take a security-conscious approach from the beginning, then you were gambling that everything would just work out, like not locking down your /admin panel in the hopes that nobody would find it. so if you do get pwned, then i have an incredibly hard time letting you point fingers.
 constructor(par1, par2, ..., parN) { Object.assign(this, { par1 }, { par2 }, ..., { parN }); } 
Ooo! I just heard about audit today. Thanks for your input! 
&gt; The entirety of human history is full of people gaming any and every system for their own completely selfish and individual benefit - screw everyone else sideways. Even just looking at NPM, the evidence is that the world is full of nice people doing helpful things for others for little personal benefit. Think about how many *millions* of open source packages there are on NPM being downloaded and having their code successfully reused billions of times every day. If you were to take any software engineer from the 60s when "code reuse" was a novel idea and show them this, it would be paradise beyond their wildest imagination. So, yes, there's been a couple of bad actors. But what *fraction*? From what I can tell, it looks like something like 99.99999% of NPM packages are non-malicious and providing value to people. Many if not most of those were developed for the intrinsic joy of programming and all are provided for free. If that doesn't give you faith in humanity, I don't know what would.
But think about how many times this happens with open source projects where the new maintainer *isn't* malicious. Every time a maintainer *doesn't* do this, they get attacked for letting their package rot instead of handing off the reins to someone who wants it. You can't win. The reality is that Dominic has *already* provided tons of value to many people for free. He owes no one nothing. If you don't like the way he maintains the library, he'll be happy to offer you a full refund.
&gt; there are far more amateurs masquerading as professionals, Who exactly is the amateur here? The person who made a useful, successful package and gave it to the world for free? Or the thousands of users who used it in their application without vetting whether or not it was being actively maintained? Who upgraded to a new version of it ‚Äî putting new code into *their* application ‚Äî without doing any review or inspection of the changes?
Be more picky, limit trust, (though not to the extent that you're suggesting) and lock package versions.
&gt; Yeah the naming is ridiculous, they really should have just called it something else. Should've been named Triangular because they introduced three major things, RxJS, TypeScript and non standard HTML 
Not sure if this is up in you alley, but you may want to check out Google Lighthouse. https://developers.google.com/web/tools/lighthouse/ Essentially it is a tool to analyze your website. 
We use package locking and a new app very few deps) of ours got hit because of jest-pupeteer (about 4 dep levels deep) The real answer is your last: how to stay updated on security? Unfortunately it's "stay updated on security". Fortunately npm audit does a good job since not every company is fortunate enough to have a dedicated security team. 
Google's remote assistance extension let's you control the entire computer remotely, including resizing the window.
It's weird because 1. toy factories and writing software have very, very little in common, 2. being "next to a preschool" is irrelevant, and 3. nobody died, some computers got exploited (presumably to mine crypto? I'm not entirely sure still what it actually did).
Might be a controversial opinion but Babel and Typescript really need to merge.
&gt; Who exactly is the amateur here? The person who made a useful, successful package and gave it to the world for free? Or the thousands of users who used it in their application without vetting whether or not it was being actively maintained? It could very well be both. Just because someone publishes an npm package and it gets popular does not mean they act professionally at all - and judging by the outcome of this debacle, I'm standing by that. Just because someone calls themselves a "senior engineer" does not mean they have any seniority, or act professionally. Nothing about publishing an npm package makes anyone more successful or advanced than anyone else, it's so simple any code monkey could do it. 
I really hate that syntax 
I'm not looking to control a users computer...I just want to develop a plugin that will resize the window.
It‚Äôs truly disgusting 
Agreed ü§Æ
The real trick is to just drop babel altogether. Using typescript alone these days and it‚Äôs great.
That‚Äôs not controversial, it‚Äôs asinine.
I agree with this sentiment, but also believe that we, as a community, could create a default environment that is more secure.
Agreed, it's more of a bad opinion than a controversial one.
If it's for a Junior Frontend role; you shouldn't stress out too much. They're going to expect you to freeze up at some point and that's 100% fine! Junior positions are filled even if they mess up every single problem. Juniors are there to learn and then eventually be up to speed with other devs as a long-term asset. If you're doing front-end; it honestly depends on the Stack. a Front-end job working with Node+React is much different than a front-end job working with other frameworks!
I think it‚Äôs genius. Even if you have no idea what a private class field is, that hash character is so foreign-looking that you‚Äôd hesitate to screw around with those fields, which is kind of whole point of private class fields in the first place.
The point should be encapsulation not obfuscation.
Do some dry runs. I was in the same position just a few years ago. Have a buddy find some JS interview questions and use google hangouts or something similar to run through them. You‚Äôll learn a lot about how to handle unexpected questions on the fly 
This is going to cause so many runtime bugs from user forgetting to prefix that silly hashtag. This is great. 
There's a security thing about this. Chrome and most browsers won't let you resize the main window. You can resize pop-ups, but not windows. That's because, imagine, you install a bad intentioned addon that put a download and freezes your browser with a heavy payload loop... And your browser is chaotically resizing. But, yes, you can resize windows that are created by the code (pop-ups). Here's an example: window1 = window.open("MyCreatedWindow.html", "", "width=300, height=200"); window1.resizeTo(800,600); 
If someone has no idea what a private class field is, they need to go back and learn the basics before touching anything. A hash will make them afraid to touch it? That's the stupidest thing I've read smh
This is the crux of it. I see it as a calculated risk: the chances of someone who has contributed at least once acting maliciously multiplied by the potential danger to projects (in this case, only one project was attacked) versus the impact on the community in having the package fall into disrepair. I think he acted in good faith.
I think the author was attempting to be funny, but the only thing I found funny was how petty the article felt, not to mention the poorly constructed arguments. Fresh off of the biased State of JS survey, it seems the Angular bashing continues. Let's make one thing clear, I don't even work with Angular at present, but I have worked on a large-scale Angular project previously. I think the most intimidating aspect of Angular is its verbosity and that is in part because developers these days are lazy and verbosity means more typing, more reading and more concepts to learn. In my opinion, Angular's verbosity is what makes it a solid choice for enterprise application development. Sure, React and Vue initially might be less code, but React has some serious issues once you start scaling it (especially to enterprise application levels). The lack of opinionated development with React and Vue also means you witness some unsightly architectures because you can put components wherever you want. People like to put React up on a pedestal, but admittedly, most people who work with it have never built serious large-scale applications. Once you reach a certain point in React, you actually start to notice that it makes it way too easy to introduce performance issues into your application and requires a lot of hand holding and workarounds to get it to work performantly. Dependency injection, reactive bindings and separation of concerns in Angular cannot be understated. Not to mention consistency, you write your view-models and views the same way every time and there are established patterns for where things go. React and Vue can be a footgun at times in that they allow you too much flexibility and less explicitness. You can compare two React projects side-by-side and they'll most likely be completely different. Another benefit of Angular is that it gives you everything you need out-of-the-box. It's rare a modern web application doesn't require validation, some kind of means of working with an API and routing at a minimum. Is Angular bigger? Absolutely, it contains more than libraries, it's a framework. Is it slower? That's debatable. I've seen some seriously slow React applications before, so I think it comes down to how you write code (if you write bad code, you'll get a bad result). If you take the time to develop a decent application, chances are the end user won't notice a difference in speed between Angular, React or Vue. And when the Ivy renderer is introduced shortly which is showing some serious rendering performance gains, we'll see the gap shorten. React's lack of opinion on anything other than the view means you end up gluing together a trove of third-party libraries (all built and maintained by different maintainers). People love to say React is just the view, but unless you're Facebook, you're probably not just using it for views. You end up creating a framework by the time you've run npm install on a few packages. I am not saying React is bad and it's hard to deny its popularity, but it's not the best tool for the job in some cases. Most people using React are doing so because it's the popular option, not because they actually did any kind of business use-case, benchmarking or prototyping before settling on it. React by itself is rarely ever good enough, you need more than a view library. This is where Vue is winning and why it's gaining momentum. Vue addresses some of the shortcomings in React because it's a library that has framework-like common additions; they have a http package, a library for routing, a library for state management and so on. They also seem to be a true community project, Vue even has a repo for people to request modules for Vue [over here](https://github.com/vuejs/vue-requests).
I've actually really enjoyed using it for individual projects. üòÖ
 #yuck() { const hashtag = document.querySelector('#yuck'); hashtag.innerHTML = 'hashtag yuck!'; } 
Not for your first job. You'll get stuck a lot and need to ask questions of more senior coworkers, and the bandwidth is too low and latency too high of doing that while remote. Even senior devs usually don't start out remote.. more common to spend some time on-site and prove yourself first, before moving remote later.
Is this saying that private class methods are denoted by a #? Why not use the word 'private'. Now Typescript uses private, Flow uses underscore, most people use underscore for pseudo-private within existing js libraries. They should gravitate towards one existing standard.
Agreed. A well-designed ES Module and object factory functions can do everything this can with much more flexibility and better tree shaking. 
Sure. See my suggested resources for [learning React](http://blog.isquaredsoftware.com/2017/12/blogged-answers-learn-react/) and [learning Redux](http://blog.isquaredsoftware.com/2017/12/blogged-answers-learn-redux/), and my [React/Redux links list](https://github.com/markerikson/react-redux-links). Also, come by the Reactiflux chat channels on Discord! It's a great place to ask questions and learn. Invite link is at https://reactiflux.com .
Because typing 'private' is just too much effort in this day and age. Plus, millennials love hashtags
`private` was the obvious choice, IMO. I mean, we already have `static`. Underscore, while a convention, would have probably broken a bunch of things.
Yes but I'd add that in ES6 this is obvious. Prior, you could be mistaken, and the language was much more of a clusterfuck.
why no `_foo()`??
It's the same thing as __ in python. When you see `obj.__modify_var__()` you don't generally try to modify it. Javascript now has # (which unfortunately is usually a line comment). 
Private would make the most sense since Java, C#, C++, and the list goes on use private. But let's not be like everyone else.
I think you're on track with onClick, my understanding is that when you click a box it does a corresponding thing (grow, turn blue, etc.)? as far as I know, there's not really a command to change color or grow, so to speak, it's all in the styling. So I would search for how to set the style of something through CSS and try and play around with that! Hope that helps!
&gt; Flow uses underscore Hm? I don't think that's on by default is it?
Okay, thank you, I'll look into that. 
I had these problems when I rolled my own webpack config, but then I also read ng-book 2 and some book by one of the engineers of angular about how essentially it all works and the mindset behind it. Angular is a beast, but it's easily tamable. I think people are pushed away because you're actually learning a framework and not a library like React. It requires you to understand how javascript modules kind of "work" and how certain modules load others. I've also read through all of their documentation and agree that the "Hero app" docs was a bad approach to teach the framework. Besides that though it's not super complex to figure out how to do anything with it.
It's been a _very_ longwinded discussion in TC39. Basically, these fields should not even be detectable (hard private). Using `private`, you could still use a try/catch block to detect the presence of a private variable (soft private) and modify your behavior based on that. The committee deemed that undesirable, and as such decided on a sigil. There's also what the [FAQ](https://github.com/tc39/proposal-private-fields/blob/master/FAQ.md) lists: &gt; This sort of declaration is what other languages use (notably Java), and implies that access would be done with this.x. Assuming that isn't the case (see below), in JavaScript this would silently create or access a public field, rather than throwing an error. This is a major potential source of bugs or invisibly making public fields which were intended to be private. Which basically comes down to the fact that JS can dynamically add fields to objects, unlike many other languages with this feature.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [tc39/proposal-private-fields/.../**FAQ.md** (master ‚Üí f92568d)](https://github.com/tc39/proposal-private-fields/blob/f92568d6624e06dc1786cf98315f729c66df163a/FAQ.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply eap1kq7.)
Check my [other comment](https://www.reddit.com/r/javascript/comments/a1c53y/private_class_methods_support_has_been_merged/eap1kd8/) for _why_ it was decided this way. Note that I don't necessarily agree, just that I understand why.
In TS you just tell it public or private and it auto assigns it to the class Constructor(private someProp)
Sponsored by 6ix9ine?
[removed]
Why wouldn't you use const though outside of "bah humbug" reasons? If you're using a linter, it will even auto correct let to const for you. Then when you do use let, it's obvious that the value is changing somewhere.
https://flow.org/en/docs/config/options/#toc-munge-underscores-boolean
Yeah just found it. I had no idea!
Electron is easy to pick, but have alot of overhead, as it's mostly an browser window. C++ GUI performance is much better. Idk about Qt libs performance. But, in my experience on C++ projects, Electron was always better to work in team (as JS/TS teamwork is a dream) than C++, C# and Java for Desktop apps. Maybe it's my affinity with JS teamwork. In summary: If you want performance, C++ will always be the cutting edge tech. But if you need to consider another topics, Electron can be a choice.
hear, hear!
To me, Vue is what Angular 2 should've been. 
Thanks for the FAQ. I think what it's implying is if you did something like: ``` class MyClass{ private x; public y; } const myClass = new MyClass(); myClass.y = true; // good myClass.x = false; // should throw exception but doesn't ``` Then setting myClass.x would be allowed in JS because it's elevating `x` to become a public property from the external method. The fix to this is to have the setter function check a map of private variables to see if the variable name being set is within the private list, then reject on that. Of course anyone can change the prototype's set function, but that's the nature of Javascript.
\&gt;literally everything is an object. what does DOM, stand for after all. why do my numbers have methods? because they're objects. That's a rather liberal definition of Object Oriented. It also ignores that you can be both object oriented and functional at the same time. I will say, as it has been said on this sub a lot, most JS you will run into falls almost more into a semi-procedural pattern than anything else, so I feel like this is a weird argument.
Angular will also take a huge hit when not including SSR (Universal). Plus as you mentioned with Vue, Angular 7 is going to have massive improvements when Ivy is integrated, supposedly up to 90% reduction in bundle sizes due to better tree shaking and 45% faster load time (those numbers could be slight off so don't quote me but I know they are close just can't find the talk about it right now, was at Google I/O)
Yeah, it was a bug that became a feature when they added the munge_underscores flag that would stop it from happening. Flow kept on removing methods from the types because they had underscores.
Did you read your first sentence??
This is a mistake. A serious, serious mistake. It isn't consistent or elegant, and can cause confusion with #'s other uses in a web environment.
I think I've offended one of the aforementioned trendy retards.
hmm. While I get that private has it's uses, as a guy who has spent an awful lot of time working in codebases where modifying the base code was forbidden, javascript has been really awesome for being able to muck with things that the authors of the underlying code didn't intend to be mucked with, to great effect. of course, also to other people's horror. :-D *shakes fist at all the "final" declarations in other projects that have made doing certain things damn near impossible* 
I don't understand why JavaScript needs private properties? It's one of the few great things about it - the fact that you can monkey patch almost everything or access almost anything should the need arise. Are we gonna get reflection with this? Because we still need a way to modify these fields, otherwise this will be an absolutely stupid change.
Awesome information from everyone. Thank you
I actually like Babel less now. :(
You don't have to use that plugin...
()oof\_?
Why the hell not use the "private" keyword!?
Your logic is flawed. Just because Google can do it is not relevant; they own chrome. Just like you can never make a chrome extension to save Youtube videos... and have to use Firefox.... 
`async *#foo() {}` a private asynchronous generator method in a class. i wonder how many people will ever use this.
RemindMe! 1 day
I will be messaging you on [**2018-11-30 06:40:11 UTC**](http://www.wolframalpha.com/input/?i=2018-11-30 06:40:11 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/javascript/comments/a1dgz2/are_there_full_time_js_jobs_jobs_remotely/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/javascript/comments/a1dgz2/are_there_full_time_js_jobs_jobs_remotely/]%0A%0ARemindMe! 1 day) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! eap84a3) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Never mind! I saw that you have indeed specified destructuring assignments in your proposal. Nicely done üëç I still don‚Äôt necessarily see it as being a common use case, but happy to see others‚Äô opinions there. I think JSDoc coverage of such a feature would be tricky however.. with the loss of explicit members.
Good luck at #googling that shit.
But Angular is NOT JavaScript though. It is Typescript with a bunch of decorators and rxjs, although Typescript learning curve is reduced if you've worked with statically typed languages before. Working in Angular doesnt FEEL like you are writing JavaScript anymore. Angular 2+ has insane number of gotchas, it kills productivity.
May be more difficult for entry level, but.. Yes. Yes. Google. Recruiters. Indeed. LinkedIn.
A lot of (middle+) developers in Russia work remotely in Europe. Smart in both sides, because everything is cheap in Russia: - as a developer, you work from home and get good money (closer to a European wage) - as a company, you get a good developer for half the price of one in Europe. My only problem is that I hate remote jobs (and I spent almost a year in this position). You basically sit there all day with your computer, becoming socially awkward. And yes, separating job from leisure is harder.
I wrote down a basic network cli - [https://github.com/anubhavsrivastava/blame-my-network](https://github.com/anubhavsrivastava/blame-my-network) which can be used to detect whether a site is available from external network or is not + available from internal network or not. \- Need feedback and opinion
I can attest to the fact that it's not a beneficial to a junior to be in a full remote position. I'm a junior dev and was able to find a full remote JS job with about half a year of experience under my belt in a small shop, using a different language. One of the biggest challenges I've faced is that imposter syndrome is 100x worse when you are remote and isolated. Sure, you can slack your team and ask for help but it was a challenge for me to find the right balance of banging my head at a problem versus messaging someone to ask for help. When you work in an office, there's much more contact with your team where you can more casually ask a question or for help. You could do it during lunch or coffee break, or any other more casual setting. I definitely feel my growth is slowed, compared to being in an office with a proper mentor. I can't give advice on how to find remote jobs though as my opportunity just came from a chance networking opportunity.
Thanks! And what do u think about the Further Idea section? In JS there is no way to gather all arguments directly in a object (without passing directly an object obv) like you can easily do with an array. So, to mantain this way to pass the arguments: `f(arg1, arg2, arg3);` you could do like that to store them into an array: `function f(...args){/* code */}` but something like that cannot work if u want them into a obj: `function f({...obj}){/* code */}` My proposal could solve this problem
yeah, it's not good, but it is shorter. :-D 
I learned Angular first &amp; loved it. Then I discovered React and will probably not ever choose Angular for anything.
 &gt;javascript doesnt specifically follow any paradigm It allows prototypal programming, which allows for an OOP style through ADTs. JS is also event driven, which inherently requires a functional style through callback functions. &gt;what does DOM, stand for after all That's a different standard and entirely separate to JS, the web api provides a built-in interface to it accessing the DOM though.
The other comment covers the base fix, but I wanted to provide some more context: If you want the beginnings of the strings to match, as in your example (so that "bean" wouldn't match), use `key.startsWith(search)` If you want larger browser support (IE doesn't have `.includes`), use `key.indexOf(search) !== -1` (or `=== 0` for `startsWith`). If you want to ignore case, throw `.toLowerCase` on both strings. Finally, if you also want to match on searches with typos, like "bytter", use a fuzzy search library such as fuse.js [http://fusejs.io](http://fusejs.io)
When first exposed to const some years ago I thought like you. Then, it dawned on me that using const everywhere is the way to go. By making it the default, you can basically ignore the const-ance of those variables and instead focus your attention on let variables, which you'll know they are not const for a reason.
sure, but you dont use production mode everyday even in this scenario. Your choice
I completely agree with that, and it could equally apply to all of those systems that have been gamed over the last many thousands of years. We improve ourselves by identifying problems and coming up with solutions. Unfortunately, almost without exception, we leave exploitable loopholes because it is mostly the case that people who are minded to make things better don't comprehend and cater for the ways of the narcissists and sociopaths. This is all getting a bit deep and philosophical. I didn't mean to present a hopeless picture of how I see things. I just felt the anger and frustration of this particular incident was being directed at the wrong target and tried to articulate why.
Do you mean AngularJs, version 1, right. As you say, two weeks later, React was released? Angular 2+ is in a completely different zone. I have used Angular 2+ for more than a year and most of the points in the article are incorrect. We can use any IDE, editor, I use VS Code, it works great. The author blames Angular for working on a licensed IDE. Angular 2+ might be difficult to start, but I personally have found it very easy and whenever I have faced any issue, have got resolution in less than 5 minutes or so. It is same with any framework I think. For me personally with a decade of web development experience, Angular is a much solid and excellent framework to work with. And with each version Angular is improving. 
Nope, no reflection. Technically, it's already possible to write web sites that are almost entirely tamperproof. Although nothing survives a few well placed conditional breakpoints, it's not an API currently available to userscripts. Maybe that'll evolve as a natural reaction if this sort of things become the norm.
It‚Äôs an analogy, obviously they aren‚Äôt the same thing (if they were, then it wouldn‚Äôt be an analogy). Being next to a preschool is absolutely relevant - if you do things in an environment that you know could potentially cause harm, wouldn‚Äôt you agree that‚Äôs a bad thing? Driving 60 mph in a residential neighborhood is extremely reckless, but 60 mph on the highway is totally fine. Context matters. Are you gonna just keep glossing over the moral responsibility part? Obviously no one died, but there was still negligence. This is a fact that no one is disputing (people are disputing who‚Äôs negligence it is). No, the attack did not mine crypto, it was programmed to steal btc directly from bitcoin wallets from users it detected using a specific library.
I'm not sure I understand. I haven't played Planechase so there's that, of course. But even so, I'm not sure I get what this "does". The code seems to speak about drawing a "deck" on the screen but all I get is one "card". And there seem to be some "actions" but I'm not even sure if there's something in the code that does something with those. Maybe it's too hard to review this without knowing the game itself and how things _will_ be supposed to work. Right now it feels like there are some things set up in place for the future but I can't know if they make sense or not. In any case, one really small detail that made me _Hmm?_ a bit: The name of the `constants` folder. It looks like it would contain... well, _constants_. Maybe some configurations or the data for the cards in a JSON file. But no, that one is directly on the root of the `src` folder. Instead, it contains a number of utilities for loading and setting up that data. Maybe a better name would make a reference to that action. 
From a consumer-perspective operating in macOS, I tend to avoid using apps developed using the Electron framework, mostly for the reasons u/cocorote-pedro stated regarding overhead, which manifests a noticeable drain on system resources for the user. &amp;#x200B; They have the benefit of being aesthetically pleasing, generally fluid and functional interfaces. But too many developers who choose Electron for its ease of development then neglect features such as accessibility and scriptability, which tends to blacklist an app for me, personally. &amp;#x200B; *Atom* is perhaps the singular exception being an exceptional text editing program that features great extensibility. But it's still extremely frustrating not to have any accessibility hooks into its UI, as so often, a text editor needs to be scriptable for the average so-called "power user". Thus, I find native text editing apps will still always be a required staple, which is a shame \[to have to install two apps that do the same thing, simply because they each falter in different areas\]. &amp;#x200B; Sorry this isn't strictly the type of answer you were directing your question towards. But it might provide a nugget for consideration.
Yes by deducting with the help of his wording it must be about angular js.
Just one question/doubt: [Why expose](https://github.com/bruno-lombardi/easy-spotify-ts/blob/272706af05480aa4290200cd4a1f837591067203/src/EasySpotify.ts#L28) axios out of your API?
Tiny bundle size and component portability - for example drop your component into and existing framework app.
Gotcha, so the salaries and bonuses can be high enough to make it worth, my wife is not in IT she is in early childhood education, so yeah that would be really tough I can't be 2 years away from her, but if she could stay with me without working so at least we could stay together would be enough for 2 years. I'm from the Sao Paulo state countryside but I loved my last year in Sao Paulo before coming to Canada I know what you mean by jungle D: 
The "enterprise scaling" argument is so worn out, what does that even mean. Seemingly half the internet that matters is React by now, there are thousands of React driven large-scale enterprise projects out there. The worlds biggest and most demanding sites run React, desktop and mobile apps are written in it. It seems to me there has to be something besides popularity to account for that. I like and use Angular myself, but there is nothing that inherently allows it to "scale better", in the end it's just more work and often more convoluted, and i don't seem to be the only person thinking that. 
Yes because there is only one way to write JavaScript.
between this and flatten I question their sanity
No thanks, I'll keep using private, if TypeScript decides to transform it into this syntax, fine, but I'm not writing that willingly
Yes. Angular 1.2 release candidate 3, if I remember correctly. We tried to upgrade to 1.2 proper, but were unable to without an unacceptable amount of rewriting because the final release had BREAKING CHANGES FROM THE RELEASE CANDIDATE! It is hard for me to express how dumb that is. So we were forever stuck on a release candidate version of a bad framework even when it was released. I attended an Angular class once, and because I was so familiar with its flaws and limitations at the time, I helped the teacher teach instead of actually learning anything. There were some fundamental limitations that the authors of Angular responded to on the issue tracker with ‚Äúyeah, that‚Äôs not possible to do because...‚Äù followed by a long winded explanation of the internals of directives and Angular itself. It was trivial to do with React day 1. Yes, I am extremely aware that Angular 2.0 is a totally different beast. Which, was all the more reason to move to React. If I was going to have to rewrite anyway, might as well move to the (imo) better system. &gt; And with each version Angular is improving. I certainly hope so, for your sake. As for me, I said goodbye to it a loooong time ago. Haven‚Äôt looked back.
It's not really that private if you know it exists. IMO hashtag is the only realistic solution.
Can I use Vue without the use of a domain-specific, declarative template language, and instead use JavaScript‚Äôs full power, with maybe some optional sugar, as React allows me to?
I don't think mastering vanilla JS is necessary in order to learn a framework. I don't get how my car exactly run, even though I have the general idea, I still drive my car fairly nice everyday. And then I need an expert to fix my car. Frameworks are the same, you choose the car you want to drive in. And you obviously don't build one prior to using a good mainstream one. This said, there is also a middle point in that, don't learn it without any grasp of what JS is, and understand clearly what a framework is. To be honest, I learned async and sockets using a angularjs, not only because schools does it like that, but also because it's simple that way. People that have problems with the async or similar systems like event or such don't need to deeply understand JS, they just need to grasp exactly what is async and what is executed when. Pragmatism is really under estimed in the ambient elitism of this industry. A good developer learns only what he needs to fulfill his project. But he should be able to determine what to learn for this.
Ok, sure, sorry, didn't know. 
I'll keep using my closures, thank you.
It's hard for Electron to beat a native C++ app, because Electron has the additional Chrome layer underneath it. However C++ development is way, way harder, mainly because C++ is so vast and complex, and it carries the legacy of decades. And it's worth mentioning that even in the C++ realm there are differences: a [Qt](https://www.qt.io/developers/) application can target Windows, Mac and Linux, and you pay a price for that. An app developed purely to one platform will be faster and more optimized, like a Windows-only app using [WinLamb](https://github.com/rodrigocfd/winlamb). Summarizing: * C++ has better performance and smaller sizes, but it's harder to develop; * Electron is easier to develop, but has worst performance and giant, huge app sizes. &gt; What's your opinion of it? I think Electron has its place, just like C++ has its place. There's no one-size-fits-all tool. Choose what you'll use based on your project requirements, and consider the knowledge of the team.
I've worked with React on several major projects before switching to Angular about 10 months ago. There are aspects I love about Angular. I adore working with rxjs. It has made async so much easier to reason about. Other aspects I don't like quite as much. (Looking at you NgModule and zone.js) There are things I reaaaally don't miss about React. Like when you jump into a project that makes excessive use of recompose, where the react vDOM tree is so deeply nested with anonymous components that it makes the the Mariana trench look like a puddle. I've also used Vue quite extensively over the past few weeks. It brings some fresh ideas to the table, although I feel that React does some things better I'd love to explore it further at some stage. You will always find things to dislike about any technology. Conversely you will always find things to love. My philosophy is to try everything at least once, and focus on the nett positives. Honestly none of these frameworks are so abysmally bad that they are practically useless. 
That part with performance might change in the future. First we have WASM. This way you can even use C++ in Electron apps (but maybe it's not a good idea for GUI). Also the web will get a bunch of very advanced paint, layout and animation [APIs](https://ishoudinireadyyet.com/) that will change a lot and allow smooth and fancy UI animations and other stuff.
My fear is that event-stream **may not be the only one**... my paranoid side says there are dozens of other packages with malicious codes, going undetected right now. Should we audit every package being used as a dependency? What do we do? What would you do?
Controversial opinion: ES5 was perfection
I honestly have no idea what you're asking
My first ask to reddit If you feel this hard read I'm sorry
It's totally ok to freeze up. In my experience it depends a lot on the expectation of the people conducting the interview. What I look for in a Junior is usually not JavaScript knowledge. What I look for in interviews: - how well you communicate - how you reason about the problem at hand - how you approach solving a bug That's just my expectation. Others might expect you to have memorized array methods. Good luck!
Yes
&gt; ‚Ä¶ access almost anything should the need arise. This is untrue; function scope has always been private, and there's good reasons for data hiding; specifically, separating implementation details from a public interface.
+1 for userscripts It definitely needs a reflection to access private properties, otherwise, it will be a nightmare for userscript developers.
I wrote down a basic network cli - [https://github.com/anubhavsrivastava/blame-my-network](https://github.com/anubhavsrivastava/blame-my-network) which can be used to detect whether a site is available from external network or is not + available from internal network or not. \- Need feedback and opinion
There were no breaking changes from 1.1 to 1.2. A angular class at the time of angular 1.2 rc? [That was around 2013 and it was a year old at that point. ](https://blog.angularjs.org/2013/10/angularjs-120-rc3-ferocious-twitch.html?m=1). There certainly were no classes anywhere near me. This post is very strange. 
&lt;&lt;looking at you NgModule and zone.js Oh for sure. That can be a god damn nightmare. How‚Äôs you form validation doing in react? Cause I‚Äôve waisted so much time of react forms and every other solution that I simply built my own. 
Yes, it has been, however no one would really use it unless it is really necessary for some reason since it would increase complexity in most cases, even more so with classes. Private accessors on the other hand are easily accessible.
No, he actually gave the candy.
He doesn't have to act professionnally if he isn't paid for it. The users are using something at their own risk, shame on them if they harm their clients.
Challenge accepted
90% of the people just underscores the variable name.
Private class fields aren‚Äôt even a finalized standard yet. In what world is this ‚Äúthe basics‚Äù? That‚Äôs the stupidest thing I‚Äôve read smh. And my point isn‚Äôt that a hash character will literally make people afraid to access private class fields and methods, it‚Äôs that they are clearly differentiated from public class fields. If you weren‚Äôt familiar with his new language feature and had no idea that it was a private class field, you‚Äôd still be inclined to see how it‚Äôs being used, which would naturally lead you to understand that it‚Äôs meant to be accessed by some other means than an attempt to directly manipulate it. It seems people are judging this syntax purely on aesthetic grounds, with no attempt whatsoever to understand the thought process behind it.
I see it as a stop gap solution. Right now it's the only way to create a vivid x-platform application with relatively little effort without drowning in expenses or wasting labour-force and time. The price for that is a bloated chrome wrappers, high ram, and being chained to the slow dom. At some point the electron will fade away, as well as chrome wrappers in general. Things like proton-native and reactxp already go in a native javascript driven direction.
I guess it's just not possible on most frameworks that have sizeable runtimes (&gt;60Kb gzipped for Vue, which is the smallest of the big three).
dom was literally created for javascript. functional programming has nothing to do with functions. the event stack is in no way "functional." I guess you didnt bother to finish reading my comment before replying.
*beep beep* Hi, I'm JobsHelperBot, your friendly neighborhood jobs helper bot! My job in life is to help you with your job search but I'm just 437.5 days old and I'm still learning, so please tell me if I screw up. *boop* It looks like you're asking about job search advice. But, I'm only ~6% sure of this. Let me know if I'm wrong! Have you checked out Forbes, LiveCareer, TalentWorks? They've got some great resources: * https://www.forbes.com/sites/karstenstrauss/2017/03/07/job-hunting-tips-for-2017/#794febea5c12 * https://www.livecareer.com/quintessential/15-job-hunting-tips * https://talent.works/automate-your-job-search
Underscores in front of `const`, `var` or `let` binding names are meant just for people reading or editing the code; the bindings aren't an interface unless you explicitly share them, because local scopes are private, and everyone relies on this separation between scope levels. There's no way to inspect a scope from the outside, and it's a good thing for writing robust code, and making this pattern simpler for object properties as well is good for the same reasons why it's good in the case of scopes.
It just seems like Ember is playing catch up in a lot of ways. I'm very interested in it but: * Very difficult to find jobs for it (I'm paid extremely extremely well, so the idea of finding a job that supports this just is not really realistic). * Ember is playing catchup. It recently played catchup in using Babel, they'll need to play catchup in dead code elimination, all the dumb magic shit (Rails is also known for this). * No CSS-in-JS (at least, any popular widespread solutions). * Support for bleeding edge stuff. Where is the support for custom elements? * Ember is going to be playing a lot of catchup in terms of React Suspect and its elegant handling of loading states.
A likely-to-be-standardized syntax intended to differentiate private class fields and methods from their public peers at a glance is not obfuscation by any stretch of the imagination, and it is in no way at odds with concept of encapsulation (although I‚Äôll gladly concede that encapsulation is truly the point of private class fields and methods). My point isn‚Äôt that this syntax makes private class fields unintelligible. It doesn‚Äôt. My point ‚Äî or at least, the point that I intended to convey ‚Äî is exactly the opposite: this syntax naturally lends itself to an understanding of the purpose of private class fields and methods. It discourages indiscriminate access and encourages a greater understanding of how these fields and methods are used in context. When properly used, this should either discourage their use outright or encourage the use of public accessors and mutators instead, whether one fully understands that these are actually private class fields or not. 
Agree on the loading full frameworks problem. But this kind of scenario shouldn‚Äôt be for everyday use, at least in my mind... I see this being very useful for integration projects where many teams are contributing with parts for an extended period of time (years). It seems crazy but it‚Äôs the norm in some industries. Also, if the spec is agreed upon, as it is now, then there‚Äôs a possible future where frameworks accept custom elements as their build targets for components (and build the framework stuff around that)
I know which is what, I am simply stating how 90% of the JavaScript software is made.
the only benefit to using const is making debugging easier for, well, new programmers. there is no performance benefit. its 5 chars long so it fucks with indentation. people who properly scope and use good variable naming conventions will never see any benefit from using it. but that's not to say there's anything wrong with it, just not something to get all religious about. people use const for the same reason they use semicolons. because occasionally it just might save them a headache. the stupid thing is that half the people using const have stopped using semicolons.
Wow you got downvoted to hell, but I'm at least one person who agrees with you. It'd be nice if TypeScript was more like Flow in this regard - a type checker and nothing more. It's simpler that way, Flow has shown it can work fine, and Babel is a better transpiler than Typescript (more features, more flexible, etc - many people run their TypeScript output through Babel anyway, which is kind of silly). Hopefully babel-preset-typescript is the first step towards this happening, and the dedicated TypeScript compiler can eventually go away or just be a thin wrapper around Babel.
All JS code relies on limited access to inner scopes.
So that FAQ, I've got one question. It states the problem is that this.x would silently turn "x" into a public field. &amp;#x200B; 1) Why would this be the case? Why would it not just throw an error instead? 2) How would this prevent this.#x from having the same side effect? Is it just relying on the use of the # to prevent users from accidentally clashing with the private field?
anyone up??
The other responder summed it up well, the answer is yes, absolutely. It‚Äôs also not exactly correct that the core is built around a templating language. Vue, like nearly all similar libraries, is composed of various modules. Vue 3.x in particular exposes these in a way that allows you to use very specific features, if you dont need the whole library. 
Not familiar with key.startsWith, so i'm gonna research that a little bit ! Thanks for letting me know about fusejs, thats going to be a real life saver later on !
You've got to give folks more information if you want a helpful answer. What's an 'intermediate'? What do you want to learn about? Etc
There is a convincing need for this... but the name `globalThis` is just so ugly!
You're asking if it's secure to send arbitrary queries over https to your database? No. Never. That's a massive security risk. You might as well just let hackers connect to your database directly.
I can't thank you guys enough for helping me ! I go on stack overflow and nobody provides the solution you guys just did. I've been working on this one for an abnormal amount of time, so it means alot !(: 
Mongoose is a ODM library for mongodb that runs on a nodejs server. I'm not planning to expose the database connection on frontend.
Pretty awesome article explaining and implementing hooks with a great example!
There were counter proposals that still allowed hard private while using the `private` keyword. The team was just being stubborn.
Yeah I've also struggled with forms in React. I used redux-forms at some stage, but it felt clunky and suffered from major performance issues when I last used it. (2017) It could be better now so maybe check it out. Since then I've also just built my own forms. That's another thing I like about Angular :) 
What‚Äôs the distinction? If a user can open a console, alter the JavaScript to query other parts of the database, then your system is insecure. 
No. Absolutely, categorically not. Send search or filter parameters from the client and then build the query on the server. 
What's the over/under on how long until a browser starts displaying *something* if integrity checks are not present for externally loaded scripts? You could also just copy the 3rd party script and host it locally, though that negates some larger caching.
&gt; and you having to micromanage how your devs are using it for large JavaScript projects. Doesn't sound like the private syntax is the root problem here.
I'm *cautiously* optimistic about hooks. I'm a bit unsure of how having global state will affect external libraries, as well as the testability of code. We'll see how it plays out. FWIW, I don't find classes confusing; and any competent JS developer should understand how `this` works. I don't think React hooks change that fact.
Agreed in theory, but in practice I could never remember something that complicated
Terribly complicated. It caused an memory leak in password manager 
No, more like a developer problem, but you now added another layer of complexity that was never a thing until now that also may cause slight confusion to others. Especially what JavaScript counts as a valid token expression...
What would be truly insane would be breaking millions of existing sites just to add a new feature to JS.
hell no
You're more than welcome to participate in the standards process! I know I do when there's something I'm interested in (or disagree with).
You realize that just because current syntax doesn't require a syntax to be inserted doesn't mean that the syntax won't changs in the future, causing it to be omitted by the ASI? It's for that reason that TC39 recommends always using semicolons.
Hi /u/gregsometimes, this post was removed. If you'd like to post a link, then please use the "Submit a new link" option. If there is additional commentary or links you wish to add, please do so in a comment. Thanks for your understanding.
Hi /u/hitler243, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (/r/javascript is not a job board). Thanks for your understanding.
Hi /u/geekgirldiva, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
&gt; Very difficult to find jobs for it (I'm paid extremely extremely well, so the idea of finding a job that supports this just is not really realistic). That's fair, But, I think people should adapt to whatever the job requires, and not always the other way around &gt; Ember is playing catchup. It's true, I'd say that Ember is much larger than the small libraries that can move fast due to their lack of size. I appreciate that ember does move slow and deliberately, and takes all the good ideas from everyone else. &gt; It recently played catchup in using Babel, what do you mean by this? They've been using babel forever &gt; they'll need to play catchup in dead code elimination, for sure. It's coming in mid 2019 though. Octane release is the priority atm. &gt; No CSS-in-JS (at least, any popular widespread solutions).Support for bleeding edge stuff. I'm personally against this (I've been using React for 2.5 years every day.) I look forward to this: https://css-blocks.com CSS-in-JS is not great for people who don't use your particular css-in-js library. It's just too fragmented. &gt; Where is the support for custom elements? here: https://github.com/rwjblue/sparkles-component &gt; Ember is going to be playing a lot of catchup in terms of React Suspect and its elegant handling of loading states. Naw, I think Ember does it better with http://ember-concurrency.com/docs/introduction/ But maybe the use cases are slightly different? 
One other bit I'll add. When you're inheriting the class you can now define your own public variables that are the same name as the private variables of the parent. class MyClassPrivate { private x; } class MyClassHash { #x; } class MyClass2 extends MyClassPrivate { x; // Error: Cannot make a private variable public. } class MyClass2 extends MyClassHash { x; // no problem }
TypeScript is just a superset of JavaScript. Angular absolutely is JavaScript. It runs in your browser as ES5. Just because you _style_ your JavaScript a particular way doesn't mean it isn't JavaScript. You are doing JavaScript things with the JavaScript language. You are just using syntactic sugar to do it. I think TypeScript feels the exact same as ES6, tbh.
I think a car is too specific of an example. Each framework isn't like a different _car_, it's like a different _mode of transportation_. You have a general idea of how a car runs, but junior developers _don't_. They have never seen a _mode of transportation_ before. They are given either a car, an airplane, a scooter, a motorcycle, a magic carpet, and a hoverboard; and then, given only one of the aforementioned tools, they are told to learn how motorized movement works. Having never seen any of them, they are debugging why it won't work. They put diesel in their scooter and suddenly they are having problems. Of course they are. How would they know not to do that? They have no fundamental knowledge before diving head first into an implementation of something they didn't understand in the first place. Support forums are riddled with "Why doesn't my scooter work?" They don't know what broke it, and helpers don't even know what to ask. Do you know how often support threads don't contain relevant information? ``` This code isn't working, what am I doing wrong? [code snippet that actually works as expected] ``` Clearly something else is wrong, but they don't even know what it could possibly be, because frameworks are not friendly towards developers with no vanilla experience with JavaScript. They don't say "Don't use diesel." They don't walk you through how to actually use JavaScript, because you should know it beforehand.
The article suggests hash checks should be done for anything stored on a CDN. A lot of their examples though are not to static scripts. Some examples are for including the current version of an external service. If you add a static check, you break every time they update. You break if they do A/B testing, etc. Being able to do these checks in the browser is a useful security feature. It's useful when you don't trust your CDN. When you're using an external payment provider to handle your payments, you trust their servers.
you could tweak your eslint rules to not allow it. we are all definitely gonna inherit some unreadable code but that isn't new. job security wins again.
When you include a script, you can include an hash (md5 I think) that the browser can use to verify the script matches. So he's talking about scripts that are included without hash checks. Note that HTTPS will still guarantee you get the script that the server provides. But it doesn't protect against 3rd party hosts serving you modified content that you weren't expecting. It's good for something like referencing a static library from a public CDN, eg a specific version of jquery.
Yea this article is pretty garbage, they say unauthenticated but they seem to mean externally hosted, which is not a security risk on it's own. The example they reference is a site that was hacked to add a script to the page... I don't know even see how thats relevant.
Agreed with the rest of the people, never write any database query on frontend javascript. This is a very serious security risk that you are exposing your application to public.
Since this isn't viable for third-party scripts that need to be continuously updated, the payment form can use an iframe on a different origin to keep the payment details secure. Shopify does something like this on their payment pages where each credit card input is actually inside its own iframe.
&gt; *a syntax to be inserted* I didnt understand any of that except the last sentance. I always use semicolons.
You're probably thinking of the mess of warnings relating to HTTPS over the years. Originally, people only cared that the main contents were sent over HTTPS, not guaranteeing that scripts, images, etc were as well. There have never been any warnings regarding hash checking scripts.
&gt; I like `constants` because it represents that the data there is immutable. Yeah, I guess something like that. The thing is that you're giving it a name not for **what it is/does** but for one characteristic of the data it produces. That's what I don't think is a good idea. Notice also how `shuffle` doesn't really fit at all under "constants"; it is really some helper function or utility function. I'm not really sure how I'd call it, but it needs to be something that expresses what it is or what it does. If you're going to have more stuff there, then yes, you'll probably have to end with a generic name like "helpers" or "utilities". You could be more specific if either you won't have more stuff there or you use another level; then a name like `loader` or `utilities/loader/` for the stuff that loads the data. It actually helps if you want to consider things in there as "stand-alone functions". Do go and extract them to their own place. I mean you don't need to actually set them up as a separate module, but just try to think about each of them on their own. If you did extract them, what would `shuffle` be? It's sort of a "collection transformation module" (yes, it's only one function, I know xD). What are `cards` and `sets`? Some sort of "card data loader module". That way you can get better, more descriptive names.
Have you never heard of the story of little Bobby tables??? His name was Robert&amp;query='DROP table Users;' &amp;#x200B; &amp;#x200B;
It is meant to be an extensible directory. It only coincidentally has few functions in it now, e.g. right now I'm adding a helper function for converting a card name to its associated action, so that that functionality isn't deeply nested. I think utilities is great. I've seen `util` often as a directory name. &gt;I mean you don't need to actually set them up as a separate module I suppose node_modules isn't descript, since it implies they are modules. I like having a `src/node_modules` directory for things that are accessed often in deeply nested directories so that they can be imported from short paths. It's probably more technically accurate to just add those paths as short paths instead of implying they are modules.
Got it, I realized now he meant the 3rd party site got hacked, so yea what he means is external scripts should have a hash check. I agree with that. 
The issue is that if you pass database queries from the client directly to Mongoose on the server, a malicious attacker could use the same API to send their own database queries. This is a huge security risk. Most people replying here (me included) will be very familiar with Mongoose and MongoDB, and the answer is exactly the same. Do. not. do. this.
Did.. did you really delete your reply and repost it?
I didnt say Typescript is not Javascript. Decorator is not Javascript. Angular also injects dependencies using typings you define in the constructor. That isnt Javascript either.
Yeah, for quite some time, _function was the defacto standard for private or "do not touch" but there were no rules behind it so people started using _function for all kinds of things including (this will only be used by this library by some other class, do not use.)
Yes, and because somebody's chain smoking grandfather lived to &gt;90 smoking does not kill you. I said "probably" because most things are on a probability distribution. Outliers exist but don't change the message at all. I just wish the outliers would not always think people talking about the average or mean are trying to contradict them because everybody lives in a binary world, except for a few people who comprehend statistics and immediately think of distribution curves when they hear such statements, instead of binary ones, so they don't feel the need to point out "but outliers..." each time.
Someone on the board has to be a Perl hold-out...
Not sure on the downvotes... it's very much a concern.
Basically, it boils down to this: 1. Sending an actual Mongoose query through an API = not okay. 2. Sending parameters through an API that you then use to build a query with on the server = totally okay.
&gt;I didnt say Typescript is not Javascript. "But Angular is NOT JavaScript though. It is Typescript" &gt;Decorator is not Javascript. Then can you explain how TypeScript transpiles them to JavaScript? [Decorator proposal for JS](https://github.com/tc39/proposal-decorators) &gt;Angular also injects dependencies using typings you define in the constructor. That isnt Javascript either. Then how does it transpile to JavaScript? Again, you are just using syntactic sugar for JavaScript. Angular isn't a language, and TypeScript is just a superset of JavaScript. Neither Angular nor TypeScript can do anything that JavaScript can't also do. JavaScript just uses a different syntax for it, but you are still using JavaScript to do these things.
You know how I know it might be the case? Because I use and love classes! The universe tends to try and deprecate me. 
Yes there I totally agree with you. But there the problem is another thing. The support forum are good but you can literally take advantage of an experienced dev in any stack freely by just asking a question. And that alone, no wonder why a good chunk of support is litterally "Read the docs, it's there".
I do participate, and so do many other community members. I even participated in the discussion of private fields. If you look at the majority of the feedback on this proposal from the community, it was expressed that the `#` sigil was not a good idea, and there were a large number of people calling to postpone and seperate that part of the class fields proposal. There were also several alternatives proposed, but usually shot down quickly by members of TC39, due in large part to what I view as personal preference. Private fields also hinder the prospect of adding private symbols which would have accounted for most of the communities use cases without the need for a sigil.
So why do you call it "authenticated" instead of "verified" or "integrity-checked"? They mean completely different things.
Yes, I've also used it to replace jQuery, especially if you don't have to support legacy browsers. They do have a polyfill package for that, now, though. 
That's a fascinating tick you've got. Does it make you feel better?
In British English (where I'm from) it conveys a sence of authenticity. If you were an auction house selling famous paintings, you would make sure they were authentic. If you didn't check them, or someone replaced them with fakes, then they would be unauthenticated. But, yes, I could have used verified, trusted, reviewed, genuine, legitimate, etc. The English language has many words which mean similar things. 
&gt; Starting to feel like JS is trying to be *Perl*. There you go...
Thanks pal, big fan of the basketball game. Anyways I have the opposite opinion of you... why can't typescript have native support in the browsers?
The breaking changes were between 1.2 Release Candidate 3, and 1.2, not between 1.1 and 1.2. If you say there were no breaking changes between those, I should have been able to just switch the angular version and all my code would work with no differences, right? That was not my experience. Did you not read the page you linked? ‚ÄúThis release also introduces some important **breaking changes** that in some cases could break your directives and templates.‚Äù No, the angular class I took was a couple years later, when I was still stuck on that infernal version. The subject matter covered in the class was compatible with my knowledge of angular, even if the version the teacher used was more recent.
I don't really have a problem with adding the `class` syntax as it removes a lot of boilerplate, however it's misleading because it doesn't create a class as JavaScript doesn't implement classical inheritance. I just wish it had used a different keyword and a method to specify multiple inheritance. Or if it has actually been a class.
I would personally prefer a slightly different syntax for defining types, I'd rather define them separately, either before the implementation or in a separate file similar to ocaml's module definitions. I also feel like I run into the limits of Typescripts ability to infer it create type holes more than I'd like. Although that's obviously a symptom of progressive typing. Overall it's about 1000x better than JS for a project of enough complexity though.
YDKJS is a great series and covers a lot of modern JavaScript. I still recommended it for all junior engineers just getting into JavaScript (and in fact I keep a copy near my desk so I can refresh my own knowledge from time to time). Here is another good set: http://exploringjs.com/
I think you can actually do this with the declare keyword.
I've been using Ember professionally for about 4 years and I have to say, the long term maintenance of Ember projects has been really good. I've never regretted using Ember on technical merits. There's been a solid upgrade path between versions longer than the current crop of popular frameworks have even existed and modern Ember (&gt; 3.0) looks and behaves very similarly to the competition. The testing story with Ember has also been ahead of the curve for a _long_ time. Ember-CLI was also an amazing benefit other frameworks lacked and then later cribbed. Unfortunately for Ember, React, Vue, Angular and Ember are all just about equal in what you can do with them nowadays and if you're already invested in any one of them, there seems to be little incentive to switch to another. I don't think Ember will overcome it's relative unpopularity because it doesn't offer any compelling reason to abandon your current modern setup. And you can do stuff like easily augment your legacy web pages with Vue and React in a way that's comparatively difficult to do with Ember.
It might be more successful if it paid real dollars instead of cryptoPesos
You Don't Know JavaScript 
&gt;He doesn't have to act professionnally if he isn't paid for it. Then when he makes a stupid mistake and becomes the laughing stock of the programming world for a few days, then paying for it or not, he's a laughing stock of the industry. This reflects poorly on him. And if you did it, then it would reflect poorly on you. Maybe it's free, but his reputation certainly is not. This is why your assessment of the situation is cockeyed. Sure, you can do whatever the fuck you want with your repo, but *there will be consequences* if it is being used by millions of other projects. Sorry, but that is reality, maybe you should familiarize yourself with it. If he had stopped to think for a moment about what he was doing, and then taken a different path, then we wouldn't be talking about him and his dubious actions, and nobody would be calling him unprofessional. This will only hurt him in the long run. But maybe you're perfectly fine with doing the same thing he did and getting the same kind of attention? 
It is written in typescript. No one is going to say SomethingTs. That's just silly. When I said Angular is Typescript with decorators and rxjs, I meant it is a mix of all of those. And when I said Angular is not Javascript, I meant when working with Angular, you are pretty far away from Javascript because you are forced to use what the Angular team thought was good to use. In React, you have similar issue because you use JSX, but it is still way simpler than Angular's complicated template syntax, AND you dont have to use JSX.
&gt; audit Note that audit only looks for known vulnerabilities in your dependency tree, it doesn't actually attempt to discover new ones (thats the job of a security researcher). So this wouldn't have been caught by that (although it should now show up on audit reports). From the docs: &gt; The audit command submits a description of the dependencies configured in your project to your default registry and asks for a report of known vulnerabilities.
I don't know as though I'd categorize YDKJS as "the basics". It is a pretty deep dive into the language itself. Are you looking for more general programming stuff like design patterns or...?
I think you need to strongly look at how tightly you are grasping to your flawed conceptualization of both how Angular and TypeScript work. You have made up your mind and won't listen to reason, and that mentality will hurt you in the long run.
The spec has been in the submission process for the last 2 years. You had plenty of time to comment on it.
Still regret picking Angular over Ember. RIP.
You should just think of js arrays as generic lists taking any type. The actual implementation is up to each browser anyway. Their job is to follow the spec.
This is as bad as when PHP used slashes for namespace separators. My\Namespace Makes me read My amedpace Now JS is using #, a common comment syntax for private methods!? Why? People having been using _ to denote private methods in languages that didn't support them for ever.
&gt; But I don't get the Angular-React thing by itself. Does anyone use "only React", though? I think it's implied that they use at least `react-router` plus some sort of state management library if the app is complicated. With CRA (especially CRA2), setting up React with router, state management and even TypeScript requires just a few CLI commands.
I'm pretty sure they're basically objects with numeric keys that are kept in sync via push, slice, etc. Essentially, [5,7,9] is the same thing as {0:5, 1:7, 2:9} at a basic level.
Strange, Manning has been high quality in my experience.
In javascript, arrays are list-like objects. The indices of an array are essentially the keys/value pairs of an object. The global Array object prototype also has a bunch of built in methods that allow for traversing and manipulating the array. As for freeing up data and stuff, javascript uses a process called garbage collection. From there, it's all magic to me at the moment. Sources: &amp;#x200B; [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) [https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec](https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec)
ugh disgusting OO people infecting JS‚Ä¶
I did not know they were stored as strings, that's interesting. Do you know why compared to storing them as numerics?
Why that if I may ask?
&gt; reason
but why? specifics lead to constructive conversation so we can make educated decisions :)
Exactly; it's not like people don't use [closures](https://en.wikipedia.org/wiki/Closure_(computer_programming\)) when doing FP.
Yes, we have a product with a 10 year old code base, during modernization I gave Ember a try since I value that it is battle tested and well supported, unfortunately it is not easy to integrate Ember into an existing application like it is with React/Vue so it didn't make the cut as rewriting is not an option. If it was I would have chosen Ember.
Our payment collection resides in an iframe pointing to our 3rd party payment provider. Would unverified scripts on our own site be able to interfere with the iframe? (Keylogger etc)
What's the reasoning behind the committee to not be detectable? I doubt that many people who want private want it to be non detectable. People want a built in way to shield code from being overwritten/declare intent that it is not supposed to be consumed outside of the implementation and not necessarily want it non detectable. Now we end up with that weird syntax.
So [because Flickr's ancient codebase broke](https://github.com/tc39/proposal-global/issues/20), we need to go from `global` to `globalThis`? Just kill me. &gt;("self" is a terrible name) ...then proceeds with "globalThis".
&gt; A lot of their examples though are not to static scripts. ... If you add a static check, you break every time they update. You break if they do A/B testing, etc. Most are versioned and those that aren't don't appear to belong on a payments page. &amp;#x200B; The more important, imo, excerpts in this link are: &gt;Don't load unauthenticated code on your website - and especially not on your payments page. &gt; &gt;If you absolutely have to load someone else's code, check to see if it has been altered. &amp;#x200B; I'm disappointed this top voted comment pushes back on best security practices. SRI will be ignored in browsers that don't support it. Major browsers for the majority of users support it, it should always be included with external \[versioned\] resources, there is no excuse.
Yeah it's really off, not like maths doesn't have constants. Hell even `2n` would be impure based on this explanation.
thank you
[Decentraleyes](https://decentraleyes.org/) ([FF](https://addons.mozilla.org/en-US/firefox/addon/decentraleyes/), [Chrome](https://chrome.google.com/webstore/detail/decentraleyes/ldpochfccmkkmhdbclfhpagapcfdljkj)) is a local CDN. While the chrome version is probably auto-approved, the FF reviewers use a script to confirm the hashes match the official ones.
&gt; const PI = 3.14 That's some shitty math lol
You can go through my post history and see that I've been using Angular since 2013. You can choose to ignore the experience of people who have been in the trenches and find out the hard way for yourself if you want.
The answer is that it depends on how you're using the array, and even then, it depends on the JavaScript engine that is executing the code. In V8, for example, if your array only contains integers, it'll be backed by a C++ array of integers. Typically, the backing array will be bigger than the number of integers it currently contains. If it contains a mixture of integers and floating point values or only floating point values, it'll be backed by an array of doubles. If it contains only objects, or a mixture of numbers and objects, it'll backed by an array of pointers. If you call `push()` when the backing array is full, it'll allocate a new, bigger backing array, copy the existing elements over, and then add the new value you pushed. This is similar to the implementation of `ArrayList` in Java or `vector` in C++. All of the above only is only sure to apply if your array is packed, and not sparse - i.e. you don't have any gaps in the array. If you do something like let abc = [1,2,3]; abc[100] = 50; you now have a sparse array. If is not too spare, it'll still be backed by an array, with empty array indices replaced with a 'hole' value. If you look at V8's C++ array source (linked below), you'll see calls to `element-&gt;is_the_hole(i)`. If an array is very sparse, it'll no longer be backed by an array in memory. Instead, it will be backed by a dictionary, and it'll take longer to both access elements and iterate through the array. If you're interested, you can read through V8's array implementation in C++ [here](https://github.com/v8/v8/blob/master/src/builtins/builtins-array.cc). You'll notice that it often checks the following constants: * PACKED\_SMI\_ELEMENTS - a packed integer array * PACKED\_DOUBLE\_ELEMENTS - a packed double array * PACKED\_ELEMENTS - a packed object array * HOLEY\_SMI\_ELEMENTS - a sparse integer array * HOLEY\_DOUBLE\_ELEMENTS - a sparse double array * HOLEY\_ELEMENTS - a sparse object array * DICTIONARY\_ELEMENTS - a very sparse array that is backed by a dictionary And you'll see that it always tries to do whatever will be fastest for the array it is operating on. Lots of builtin functions like push, pop, shift, unshift, and concat do different things depending on how the array's density and what kind of elements it contains. 
Leaving aside all the advice about why you shouldn't do this, there's libraries for blocking on async code written at the C++ level. See: [https://www.npmjs.com/package/deasync](https://www.npmjs.com/package/deasync)
&gt;When a software is provided without any kind of warranty, you accept the responsibility. This has nothing to do with **his** colossal fuck-up. It's the entire reason **he** is being talked about - not you, not I, and not any of the devs that had this package as a dependency 10 levels deep that came with 100 other packages. Your assessment is still very cockeyed. HE is the object of ridicule, not any devs that had this in a package. I mean, nodemon had this as a dependency - you really expect any dev using nodemon to read all the source of every single dependency from that? You're crazy if you think that's even worth suggesting. Nope, He deserves the ridicule he is getting for doing something stupid, and you would too if you did the same thing. 
My problem was with how Go 1.11 currently is setup for all functions to be async with WASM. I just ended up porting parts of this into my environment until Go 1.12 (I think it's 1.12) will introduce synchronous function calls at the beginning of next year. https://github.com/neelance/go/tree/wasm-sync-callbacks
Is this a joke?
&gt; It‚Äôs also not exactly correct that the core is built around a templating language. You should probably let the Vue development team know that, because on their website, they state: &gt; **At the core of Vue.js** is a system that enables us to **declaratively render data** to the DOM using straightforward **template syntax** I didn‚Äôt come up with the idea that Vue‚Äôs core idea is their declarative, template language, they did. https://vuejs.org/v2/guide/
I'm with you, friend.
Well, obviously I won't mess with release candidates NOW! Not after the circus that Angular put me through. See, people were pushing "go with the latest, cutting edge!" and "there's no way they'll release breaking changes in a release candidate, right? RIGHT?" Obviously not, in Google's case. As opposed to React, which gives in-browser warnings about deprecations and breaking changes two or three versions early, though the number of breaking changes and deprecations are so relatively low that I haven't seen but one or two in my entire time working on React. I only mentioned helping the teacher to indicate my level of understanding of Angular at the time. I went to a class to learn more about Angular. I could have taught the class, and I didn't learn a single thing about Angular I didn't already know, that's how familiar I was with its inner workings. Not only that, every time the teacher would say, "I don't know how you would handle this," I would jump in and volunteer exactly how you handled that. I'm not judging Angular 2+ relative to Angular in terms of what it is, I'm sure it's much better. I **AM** judging the people who made both versions. Those teams that thought it was a good idea to create a version 2 of a popular library by providing, at best, an awkward transition path that most devs (myself included) simply wrote off as a "required rewrite". Those teams that thought it was a good idea to create a release candidate that had breaking changes with the official release just a few weeks later, at the same time that other libraries were getting by just fine with no breaking changes at all. If your release candidate requires breaking changes to finish: it's not a release candidate. [From wikipedia](https://en.wikipedia.org/wiki/Software_release_life_cycle#Release_candidate): &gt; A release candidate (RC), also known as "going silver", is a beta version with potential to be a final product, which is ready to release unless significant bugs emerge. In this stage of product stabilization, all product features have been designed, coded and tested through one or more beta cycles with no known showstopper-class bugs. I also don't care about Angular. Not anymore.
With clickjacking yes, but there is no access to the DOM.
I feel like a caveman reading this post
Uh, no. That's not at all how that works. Hosting page cannot access contents of a payment provider's iframe, or vice versa. This is referred to as the same origin policy.
Surely it would have taken you less time to write a couple of quick bullet points on what sucks about it rather than two full comments saying it's too much work ;-) ?
1. reCPATCHA was mentioned within a list and not a sole example. Did you miss " If that gets hacked, half the planet is compromised."? That's not false. 2. reCAPTCHA doesn't need to be on the same page as sensitive information. Let's ignore this selective attention and not forget events [like this](https://blog.cloudflare.com/facebook-bug-takes-down-much-of-the-web-cloud/). Or [this](https://www.bleepingcomputer.com/news/security/british-airways-fell-victim-to-card-scraping-attack/). Even the Adyen example [isn't exempt from criticism](https://www.bleepingcomputer.com/news/security/feedify-hacked-with-magecart-information-stealing-script/). &amp;#x200B; &gt; For each page request your static webpage serves, how do you serve the the appropriate hash? If the page and assets are static, that's not an issue. If it's dynamic, then appropriate engineering measures need to be made to update caches as necessary. Protecting sensitive information does increase engineering complexity and it is very a reasonable expectation. This is why data classification levels exist; PII (personally identifiable information) should always be protected with a higher level of scrutiny.
No, your page and the payment provider reside on different domains. The payment frame probably returns results of their payment workflow to your page by redirecting back to a completion URL on your domain, including in the URL parameters the result and confirmation codes.
Good for them, but the bottom line is that Ember has no real traction in the industry. There is so much exciting new tech to learn and deal with, expecially if you are full stack, that I really do not see any benefits in dropping React for the sake of learning Ember. If it was one or two orders of magnitude faster, maybe. But it's just the same thing, except that it's opinionated (which is a good thing in some cases, but not so much in most). When U fancy trying something different I have Elm, Svelte, Purescript, and a few others in my play-with list, not Ember, sorry.
To each their own. I'd never try to convince someone to change a technology they've already started a project with. it's the fact that starting new projects is really fast with ember. you get a ton of stuff out of the box -- "batteries included". Conventions are a good things. Especially in teams. Especially when teaching new people. Conventions are like a set of rules that already have documentation. That alone is worth more to me, especially in the long term, than the new and shiny. I'm looking for things that don't have me exploring the bleeding edge just get things working.
Go with the flow. I recommend one week of reading nothing but [this chap](https://medium.com/@_ericelliott)'s posts. It should cure you of your classite.
Thanks /u/mikebpechousek!
Thanks for the help /u/Londomain 
This is really relieving. Thanks /u/Pringelman 
Oh I'm sorry but I actually see Eric Elliot as everything that is wrong with modern programming. Ego stinking, self-proclaimed expert or all things, bandwagon jumping, keyword using dude. Maybe I'm growing old and cynical but I feel like taking a step back and waiting to see what will hold in theses highly changing times. I'm too tired to follow everything, I just need things to work. Disclaimer: I have not read anything from Eric in a year or so. When I tired of his presence. He may not be today what how he was when I formed my opinion of his. But as an old man: Transducers... Get off my lawn!!!
Sorry, new here :)
What ridicule? Your opinion is not a "ridicule". You are just bullying him because you don't want to review your dependencies.
Classes are also nothing different than new way of describing object prototypes. It‚Äôs even evaluated to function in node. But it‚Äôs still nicer way in my opinion. 
You sound like you are ready to become a Java dev... 
Ha! good burn, I do come from a Java background. 
Some people on here are misinformed. If you are sending the query to the API and the requests require authentication then you are somewhat safe, from what you describe that seems like your situation. It could make it tricky to do access control, not impossible though since you could modify the query when it hits your API. Also Mongo queries don't have the same risks as sending an SQL query. A Mongo query can't write or update data.
Usually the password would be removed from the output during sanitization. But yes the query should also be sanitized as it comes to the api to remove any queries related to the password.
&gt; The English language has many words which mean similar things. Like 'extinguish' means to 'put out'. Who among us does not 'extinguish' their dog when it needs to go to the bathroom? 
This is awesome - thank you for taking the time to provide such a detailed and informative reply! I‚Äôll be sure to provide an update in due course!
This is great, how do you know all of this? Are you a Chrome developer?
I fail to see what meaning you give to authenticated though.
/u/learnjava ;)
Do they announce every minor version?
It can and I even do this in a few places in my organization, but compared to say, Vue, it's been considerably more heavyweight just to augment a form or something and there's not a lot of documentation or support on how to do it and get good results out of it in the process. Even Backbone and Angular 1.x handled this better IMO. Ember's docs and most of the community's blogging are written expecting you to author a SPA and also usually assume eventual inclusion of Ember Data. Ember does that really well, but deviating from that means knowing Ember well enough to stray off the beaten path. It's not impossible, but it puts Ember behind the pack when a developer with a legacy codebase or a junior web dev wants to make the leap from static pages to something bigger and wants to incrementally adopt something. They need some small wins to get the ball rolling.
We don't follow semantic versioning (this has been explained elsewhere, but the TL;DR is that it's pretty unreasonable for a type system to follow semver when stricter/more-correct checks can imply bumping a major version). But we usually have new features every minor release, and even if we didn't, we'd have some sort of post in the interest of consistency, predictability, and transparency.
Yep, this is pretty much how most vulnerability scanning systems work. Automatically auditing code for malicious behavior is still in it's infancy, but it is coming along nicely. Luckily the Node foundation has made the security of packages hosted through npm one of it's core missions (this is why they acquired the original nsp project and integrated it directly into the npm cli). In the meantime mixing the audit ability in with reasonable package reviewing policies, and locking will help mitigate your software from these kind of attacks. 
time to find an excuse so we can update to 3.2. this patch has so many great things.
That sounds awesome. 
&gt; Why? People having been using _ to denote private methods in languages that didn't support them for ever. You answered your own question, making `_` would break backward compatibility with thousands of existing programs. 
&gt; You are just bullying him because you don't want to review your dependencies. You don't have a clue, dipshit. In a comment above I said that I did work for a place that enforced reviewing all of the dependencies. You're completely out of your depth and arguing inane bullshit reasoning. So eat shit. Your argument is massively flawed, and yes, I'm laughing at him, and now I'm laughing at your dumb ass, too. 
Yes brother...
Looks right to me. What are you expecting?
It's outputting `[object Promise]` in my terminal and `Promise { '$55.99' }` using the console replit. It should be returning a value
Its async. async functions always return a promise... because they're async ;) Even though you're synchronously returning a value from the async function, as an async function, it will wrap that in a promise which inherently causes access to that value to be async.
I definitely want to get better at implementing this. 
I feel this post misses the point. Using a high profile CDN like googleapis is widespread and largely safe. It's incredibly unlikely they'll get hacked. The issue is with lower profile and less trustable sources. I would never use a CDN like Feedify if I ran a payment processor.
&gt;IDE shortcuts I agree, I try to keep a cheat sheet handy, I like to stay away from the mouse if possible.
there is no need for extractPrice to be a promise. So if you remove the async keyword from the function it'll work fine. Or you can await extractPrice. 
Meh
Any details? What makes it particularly smooth and can you extend it to do more than just slightly move some images?
No, I spend my days working on massive C# applications, with a fair amount of JS mixed in as well. Though over the years I've had the opportunity to do some C++ as well, which helps when it comes to understanding code like the file I linked to above. :) Earlier in my career, I did the [Building a Web Browser](https://jakku.udacity.com/course/programming-languages--cs262) course on Udacity. It covered parsing JavaScript and building interpreters, and ever since then I've been really interested in this stuff. So I now spend a fair amount of time poking around the Chromium, V8, and Firefox codebases. It's fun and interesting, and I think that trying to develop the ability to grok complex code makes you a better developer overall. It also becomes a lot easier to debug performance issues in JS applications when you have a good idea of what's going on under the hood. I figured it was worth writing what I did in case it inspires anyone to dig in and learn more about this stuff. All it takes is a bit of curiosity and a lot of stubbornness. For anyone looking for a gentle introduction to programming language parsing and interpreting, I recommend [Crafting Interpreters](http://www.craftinginterpreters.com/). 
It achieves constant 60fps by using CSS tranform and requestAnimationFrame. It is intended to create subtle animation effects like the one in this mockup: https://dribbble.com/shots/5594494-Molley-Heltz-Inspiration-Page-Animation Each Node can be independently configured in terms of how much it moves and how much it skews. Negative values are also valid. It's also possible to lock the x or y axis. To sum up, I think it's a nice visual effect that if used correctly can make a page feel a little more special. It degrades gracefully, doesn't break the layout of an existing page, and doesn't add additional markup.
Conceptually they are hashmaps, so you can do anything with them. Obviously VMs optimize it more.
Anyone else using --checkJs? You actually seem to be able to do way more things than are documented, including writing generic contraints and type guards using pure JS with jsdoc comments.
OP is say that by "unauthenticated" they meant "non-authentic" rather than "lacking expected credentials" 
I think it‚Äôs great that new features are steadily being added. Keep it up!
Or..use typescript
I have a lot of personal projects that I jump around between, and having a conventional setup is really nice, but easy to undervalue. Having to remember how a ton of things are configured and what conventions you settled on per project is a huge drag on productivity if you switch much. I remember back during the Backbone days, people would have their setups with Backbone and Marionette, Bower and Grunt or Gulp, and whatever they were using to deal with their data, and a million other packages, and then everyone was like, this is a huge pain in the ass, and then jumped ship to Angular, because it had cohesive models AND views. And then basically the same thing happened to Angular and everyone jumped ship to React because it had components and DDAU. And then I watch people patch together what they actually need with React Router and MobX, and whatever data fetching, and then it just seems like worse, bootleg Ember. When I use Ember, I feel like it's years ahead of the curve. Create React App feels like a crappy toy compared to Ember CLI. Tom Dale had this old blog post (I think he's since deleted) about the Pepsi Challenge, and how when you just took a sip, Pepsi beat Coke because it was sweeter, but when you drank a whole drink, the sweetness got to be too much. And he compared this to Backbone and Angular, where it was easier to go from not knowing anything to making something simple, compared to a more comprehensive framework like Ember, and how that was like that first sip of Pepsi. Ember's always offered a solid value, but the scope of it makes it hard to get that initial buy in, which has consistently hurt the size of its community. It's unfortunate. 
https://medium.com/appaloosa-store-engineering/how-to-slowly-replace-your-site-with-a-new-one-made-with-emberjs-4fc4fed7f11a Have you seen this?
Why can't the excuse just be that
Change the extension. No other option without restructuring your project, so that's probably the easiest. What editor are you using? It might have a "replace all throughout project" feature.
No, it‚Äôs the name of a book on some of the more... *unique* features of JavaScript. 
Maybe I don‚Äôt understand electron well enough, but I thought that most of the overhead was from running a chromium instance? Sure WASM will help, but would it be a dramatic difference? 
Still looking forward to the day we're allowed to have non-string keys (namely `Symbol`s)
&gt; never stopped to think of the consequences of what would happen if he let someone malicious take over his repo ***He didn't know they were malicious.*** It's not hard to understand. He should have checked their profile, yeah, I don't think anyone's denying that. But it's not like he did, found it sketchy, and then just said, "eh, whatever." &gt; his short term self-interest Not wanting to maintain a popular library for free is, apparently, selfishness.
Yep. I maintain a React "load more" style component that uses generators; that said, the generator doesn't need to be private, and the gen. function is a separate module, so it's fine.
What?
New shiny things are not a good reason to patch working software. "We" means this person is on a team, so a commit that changes a dependency without any issue signifying the need would hopefully raise some questions.
We use it on a legacy codebase. But there are limits, like the automatic string index signature on all object literals. And you can do generics, but you can't apply a constraint to a generic. (Can't `&lt;T extends Something&gt;`). And the syntax for type assertions is super annoying compared to writing ts. You can declare types in .d.ts files and refer to them from .JS, which is an awesome way to use ts's better type syntax to declare large interfaces within legacy .js projects.
Ooh, thank you, I had no idea!
You can log something as follows. extractPrice(output) .then(str =&gt; console.log(str))
very nice article, simple and straight to the point. &amp;#x200B; Do most people use nodejs with https like this in production though? &amp;#x200B; I was under the impression that common practice is to use nginx as the web server which redirects HTTP to HTTPS, and then reverse proxies HTTPS to whichever port your application is running on.
Two points I have: 1. I actually use static typing as a refactoring tool. I don't really care about typing every little thing. I only type things that are hard to refactor. 2. Code generating static typing from GraphQL SDL is only a temporary solution. The real ideal is TypeScript and Flow being able to interpret typings from what's inside `gql` tags and `.graphql` files. I want to point this out because it seems like people are giving up on it and instead just using code generation: https://github.com/facebook/flow/issues/2823. Code generation works for now, but having the return value from an apollo query and the inputs to an apollo mutation automatically inferred would be great for DX. But back to my first point: I think some of the conversation here is missing one of the great benefits of static typing. Sure it helps you catch errors, but in my day to day, the real reason I use static typing is for refactoring. For exmaple, in my database, there is a table called User with a column called name. My GraphQL server pull data from the database, thus turning a table row into a javascript object, so I now have `const user = {name: "croolsby"}`. There will be places in my GraphQL server code which says `user.name`. When I pass the user object to the frontend, there will be places in the frontend code which says `user.name`. But, now I want to refactor my database. I want to remove the `name` column, and turn it into `firstName` and `lastName`. How would you find every reference to `.name` in both your server and client code bases if you don't have static typing? Use `grep -r ".name" src`? What if you are using `lodash.get(user, "name")`? Use a more complicated `grep` command? If you don't want to use grep, you have to know your code base really well and remember every place you handled a user object. That's not practical when you're on a team of developers of varying skill level. It's tedious and gives me anxiety wondering if I caught everything. With static typing, I simply right click on `type User = {|...|}` and click "Find all usages". I also use `idx` instead of `lodash.get`. Now, if I'm sure that I annotated every entry point of a user object, then I can be sure that I will find every usage (assuming no use of `any`). I don't get caught up spending time with typing. If typing something is going to take me more than a several seconds, I just give it a `*` type and let flow infer it. The main benefit for me is the refactoring capabilities, namely keeping my database schema, graphql schema, and data usages in sync. &amp;#x200B;
You can do `Symbol` keys already! I forget when they added it.
Really? I was on 3.1.3 like 2 days ago and couldn't.
It definitely works; I was using it a couple days ago. If you're having trouble, post a playground link with some code and I can take a look.
Nope, not working on the playground with the simplest example possible. `const foo: { [key: string | symbol]: any } = {};` &gt; An index signature parameter type must be 'string' or 'number'.
Edited because of ugly code formatting.
I would combine the upgrade with the first code I write that requires newer features. At least on my team, they'd be fine with that.
No they dont, but for instance you are building a client side app with electron then you need it. Or when you wnat your connection to nginx to be on https too..then you need it. It's always good to have the knowledge.üòÖ
Oh I see, you're referring specifically to index signatures. It supports unique symbol keys, but apparently not "any symbol" index signatures. const S = Symbol(); // This works const foo: { [key: string | typeof S]?: any } = {}; // This does not const foo: { [key: string | symbol]?: any } = {}; What's your use-case for this? Just curious.
JS is nice language to learn overall. Can aid with front end and you can write back end in it as well. Honestly I recommend looking at jobs in your area and seeing whats desirable, I think this is a pragmatic path. But it also depends on what you like, front end, back end, full stack, or whatever else. &amp;#x200B; If you want front end learn html/css and js. If you want backend learn whatever is good in your area. I'm very partial to Golang myself for backend. If you want full stack you'll need to learn html/css and some js anyway. &amp;#x200B; My advice is be pragmatic, look what the job market is like. Think about what you like. Learn that thing, it doesn't take too long to get familiar with a language, and is good to have a diverse understanding anyway
Learn the language for the problems you like to solve. 
Without a CS degree, I'd say JavaScript and front end in general.
I'm of the opinion that dependencies should almost always be kept as updated as possible. A little for fun new tech, but mostly because small chunks of changes that break a little (confined to specific instances where functionality actually changed) are much easier to deal with (an hour or two) than gigantic upgrades once or twice a year that require a week of refactoring. Plus patches can often be performance or security and I'd rather keep those as good as possible.
I'm assuming the pound sign, because it's actually part of the method name, whereas the asterisk just denotes the method as a generator function.
Great! Good work all contributers and TS core team
Adding live chat at your website has not been that simple always. Even a few years before, having live chat at your site meant that you had to install the software on your own server and have to really lighten your pockets to maintain the system. Yes, you can try with joleadosystem, A live chat tool that helps to improve your customerQueries easily with [Website Support Cha](https://www.joleadosystem.com/features/)t.
No, I'd explicitly explain why I'm upgrading, and I'd have an example of using the new features to justify the upgrade, so the team could decide if it's worth it. And if necessary, I'd split the upgrade into a separate PR and submit that to our review process. We currently use checkJs so TS doesn't actually affect our runtime code. What news are you referring to? I think I know; just want to be sure.
Thnks...there are a lot of parts in that,it might help me thank a lot
It doesn't actually work when you try to assign a symbol property. const foo: { [key in string | symbol]: any } = {}; const S = Symbol(); foo[S] = 'this is a type error'; // &lt;-- &amp;#x200B;
You can do `key in Animal` instead of `key: Animal` const animalCount: { [key in Animal]?: number } = {}; It also appears to work if `Animal` is a string enum. But when it's a numeric enum, for some reason it allows subscripting with integers that are not in the enum, assigning values that are not `number`. 
That syntax is strange and I'm not sure why it's separated as such. I also don't even know what to call it to find it in the docs. However, thanks, that saves me some trouble knowing it's possible.
You cant say that. I don't have a cs degree and work as a back end dev.
Hi /u/mian_asif, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/Agua_de_limon, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Glad you have found a team which appreciates your skill in diplomatic backpedaling.
`root` üòé
They're called "mapped types", explained on this page: https://www.typescriptlang.org/docs/handbook/advanced-types.html Really powerful stuff. But they can get messy or confusing if you're not careful, so all things in moderation.
I can‚Äôt play the movies? 
He didn't backpedal, that was what he said the first time too.
I read all your announcements carefully and closely and very much appreciate you writing them. Thank you and to the team for the work you do on Typescript.
Java, C# or even php. It may depend on your locale. The only backend language you should avoid is probably Ruby, which is being pushed out by php and node for rapid development and by go in infrastracture automation. I see a lot of fuzz about Python, but I'm not sure it's related with prevailing webstack. Which leaves us with three mentioned above.
I really appreciate the explanation but by unncessary I meant the whole concept of private class fields/methods in JavaScript and not just the syntax. 
I always recommend python as the first language, because: - the syntax is pleasant and simple - you're not as likely to run into loopholes as in js - as a popular first language, it has an abundance of learning resources - your knowledge translates into most other popular languages. - it's widely used not only in web dev, but also in the data science community and for general scripting.
Did you not know that you're never supposed to upgrade a dependency? Especially from Microsoft - never know what sort of spyware they might have included
There's a compile flag to error on symbol keys, you might have had that set. Something like `--onlyStringIdentifiers`
you declared the functions, but you are not calling them. you then need to do setup(); draw();
I still can't seem to make a canvas show :( In google chrome, I can only see a white screen. I even tried changing the color of the canvas to black so that it would be easy to see, but still got nothing.
Nice 60fpc smooth motion, but it seems the use of fx can be much wider
Would be cool if you could also update the language specification. It's not been touched since version 1.8...
Two small bits of feedback. 1. The _skew_ isn't noticeable. In the demo, with what I understand are "typical settings", the skew applied is at most something like 0.35deg. This is completely unnoticeable and its effect is lost, leaving an impression that it either doesn't work or that we don't understand what it should be doing. 2. There's [special consideration](https://github.com/dinohamzic/displaceable/blob/3cb80c8ab377e3477630525be078cf43f890226d/src/displaceable.js#L69) for vertical scroll and while I'm aware that having horizontal scroll is very uncommon, I think it costs nothing to consider it. And not taking it into account, when actually present, does interfere with the effect and makes it work incorrectly.
IMHO this style is *much* easier to read than the event based stream api. Beware though, that Readable[Symbol.asyncIterator] is still an experimental feature.
I disagree. There must be a reason other than "it's newer" to update. The old adage says, that updating a specific version of a software means only one thing - replacing old and well-known bugs with new and unknown bugs.
Yes, and because somebody's chain smoking grandfather lived to &gt;90 smoking does not kill you. I said "probably" because most things are on a probability distribution. Outliers exist but don't change the message at all. I just wish the outliers would not always think people talking about the average or mean are trying to contradict them because everybody lives in a binary world, except for a few people who comprehend statistics and immediately think of distribution curves when they hear such statements, instead of binary ones, so they don't feel the need to point out "but outliers..." each time.
Thank you very much for the feedback and code review. 1. I wanted to keep it very subtle, but I agree that it's a bit too low. I will try to play a bit with the defaults. 2. Nicely spotted. In order to correctly calculate displacement the mouse position relative to the whole document is needed. I think you are correct in saying that it would break if the page is scrollable horizontally. Should be an easy fix.
Could you expand on "the use of fx can be much wider"?
I feel like it moves "on tracks", it's the downside with capturing mouse input and using it for transforms as is, it needs some kind of dampening to be smooth. Css cannot solve this with curves, have a look at "wobble" for instance for a really small spring implementation. I've made something like this a while ago using spring physics, maybe it helps: https://codesandbox.io/embed/ry6n155pkn and for the skew: https://codesandbox.io/embed/j1zol1nrq3
Arch vs Debian.
That's really cool. Compared to mine, the animation in your examples feels much more natural, I agree. I'll try to make some tweaks, thanks for suggesting "wobble".
indian nickname: check shitpost: check 
I just bumped it. No need for an excuse-just do it.
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), ‚Äúnobody‚Äù starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
We made a project that decouples CMS platforms: [https://github.com/deity-io/falcon](https://github.com/deity-io/falcon) Any feedback is appreciated!
&gt; it's been considerably more heavyweight just to augment a form with client side validation yeah, it's not really meant for 'just' a component today. Glimmer is though. And this should be possible in ember sometime in 2019 with Svelte builds and Glimmer components built in. &gt; but it puts Ember behind the pack when a developer with a legacy codebase or a junior web dev wants to make the leap from static pages to something bigger and wants to incrementally adopt something. yeah, it's a little more involved. People do it though: https://medium.com/appaloosa-store-engineering/how-to-slowly-replace-your-site-with-a-new-one-made-with-emberjs-4fc4fed7f11a &gt; different versions of Ember because they all want to own the same window.Ember. hmm that does sound tricky --- what kept things from all being on the same version? different repos? different projects? etc?
Tooootally not related to this post but I've always wondered in urls like this one blogs.msdn.microsoft.com, which one of "blogs" &amp; "msdn" is the subdomain ? And what's the remaining one called ?
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), ‚Äúnobody‚Äù starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
I've actually had another think about this and it works for this case but if you want to pass a variable to your action then this approach doesn't work ...
Like walking in to a crack house and asking what drug to try..
Personally I would choose the full-stack Javascript route. Simply because as you are new to this, this will expose you to all parts of a web-application - databases, APIs, back-end, front-end etc. From there you will get a solid understanding of each stack, and can choose to specialize in the stack you enjoy the most - or stick with full-stack. Also you should not worry about the "employability" of each language. Tech moves really fast, and it's more important for you to adapt to the changes and keep up with the latest best-practices. Be prepared to be constantly re-learning. &amp;#x200B; &amp;#x200B;
Nowadays, with the flight that Node.js has taken, and with no way to make it land, I'd suggest you to go with JavaScript. The leading frontend frameworks are all using JavaScript, and even if you require Angular one day, the learning curve from JavaScript to TypeScript is a breeze.
Hey everyone! I've been working on this small project called [EnumFP](https://github.com/phenax/enum-fp). But recently I ran into a circular dependency hellhole (due to a new types api that uses the main Enum factory) and after that the project kinda took a wrong direction even though it's pretty small. I'd like some suggestions as to how I can refactor it so that it is cleaner. Also some suggestions as to how to deal with circular dependencies in general. 
Recently became aware of this library: [https://github.com/python-trio/trio](https://github.com/python-trio/trio) 
Most companies will not hire backend developers with no experience, simply because poor code on the backend can introduce security vulnerabilities very easily. Your best bet is to study frontend then go from there. As you code frontend you can talk to your manager and backend devs to get acquainted with the backend. As time moves on, you can eventually consider yourself full stack. I will point out that "full stack" is often a trap. Most job postings I've found looking for full stack really just want one guy to do everything, so they don't have to pay two people to do it.
good bot
&amp;#x200B;
You're broken.
&gt;&gt;Following resume is fairly concise... Remove that. I get why you mentioned it but it just doesn't look professional. Being honest in resumes os a good thing in my opinion and it's quite rare. The problem though is that many companies want Seniors for Junior-Salary. I hate that principle very much and if I had a company myself I'd definitely give you a chance. But most companies don't see it that way. So I'd suggest removing passages like *I hesitated to apply... so I Applied to Junior...*. By removing this you're still honest but you won't sound too insecure. Your goal is to get invited to speak personally. Once there you can shine with knowledge by answering their questions. Just my two cents. Plus, there are 1-2 grammatical errors. Fix these! :)
90% of JavaScript is fucking garbage.
Yes I have an insecurity problem probably because of my disability, I will definitely change them. And thank you very much for your precious comments.
Which part are you unsure of? Have you tried the example final function you wrote? From a quick read (on mobile sry) there's no reason that shouldn't work assuming you've got the generate function in scope. You could write the generate function with async/await as well to tidy it up. The use of `this` in the generate func is probably redundant. I would just declare an object and return that at the end.
You really don't need to! See, every single person I met with a disability was somewhat insecure because they think about what others might think of them. Ignore that. The problem is that **those** people don't know how to handle the situation. **They** are the ones being insecure because they don't want to hurt you. Make them feel comfortable by just being you! Show them you can handle it and help them get loose by seeing you as a person and ignore the disability.
Your CV is way, way too self-deprecating. You need to greatly simplify it and remove all references to hesitation and inexperience. That cv makes you sound absolutely terrified. Even if you are terrified don't make your cv sound like you are. You are a person with sought-after technical skills. Explain why you'd be a GOOD hire without caveats and list your competencies snd experience.
Because newer versions contain patches for vulnerabilities in older versions
The problem with me is that I always find a problem with me and focus on that so it is because of my personality, I'll change its effects on my CV. And you are right, it should be simplified more. 
indeed, I overlooked that one. Well where is your `createCanvas` coming from? Is it something you expected the browser to have on its own? You need to add such function to your code.
Unrewarded complexity.
Thanks for the advice. If you have a specific critique that would be very helpful. Better yet would be advice on what I could change. 
I'd buy that for a dollar!
I second that. Check the local market.
Here's a sneak peek of /r/Python using the [top posts](https://np.reddit.com/r/Python/top/?sort=top&amp;t=year) of the year! \#1: [Automate the boring stuff with python - tinder](https://gfycat.com/PointlessSimplisticAmericanquarterhorse) | [348 comments](https://np.reddit.com/r/Python/comments/7kpme8/automate_the_boring_stuff_with_python_tinder/) \#2: [MS is considering official Python integration with Excel, and is asking for input](https://i.imgur.com/l2f9Zvb.jpg) | [412 comments](https://np.reddit.com/r/Python/comments/7jti46/ms_is_considering_official_python_integration/) \#3: [Python Cheet Sheet for begineers](https://i.redd.it/4iklecheyw601.jpg) | [124 comments](https://np.reddit.com/r/Python/comments/7mwgtw/python_cheet_sheet_for_begineers/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
:D
This is a very informative review, thank you very much.
That's what you call a business plan :-) Great advice.
The angular community is still strong. Of course easier libraries vs full frameworks are going to have a larger learning curve. I have seen that strength for those frameworks also be a downfall. Angular + NativeScript supports development with native mobile (yes actual native mobile, not a wrapper), Angular can be the front end for any backend.. and also Angular + Electron allows you to build cross platform app. Also, Angular Apollo for GraphQL is amazing to. There are enough people that recognize the power of angular.. we are a fast community so rabbit holes are easy to find üôÉ
The biggest thing is that it's way too complex for hobby projects. It doesn't really make sense as a framework until you scale up to the enterprise level with projects that warrant its complexity, so naturally it isn't going to appear very popular even though there's plenty of Angular jobs.
I care
Nice! Happy learning :)
It's funny, cause for me React is more complex. Angular is very prescriptive, which limits the decisions you have to make and enforces good practices. You don't have to decide which router to use, how to structure your project, how to setup a build pipeline or how to create self-contained modules. With React you have to set everything up yourself, and while there are good practices they are not enforced, which leads to really poor code quality (and I've suffered a lot of it). Angular is a framework with all included and possibility to expand, React is just a library and you have to build your own framework. 
&gt; i find myself taking way more time for doing the same thing. I guess that depends. For simple projects, Angular 2+ is an overkill, but with growing complexity Angular becomes a better solution than others, as it manages the complexity for you.
&gt; but with growing complexity Angular becomes a better solution than others Probably, it definitly feel more scaled for bigger projects indeed
Yes, little silly bot; I know you do.
That's basically why I like Angular, it's a framework. It handles a lot of things for you, so complex apps become manageble. Obviously, for simple apps it's an overkill, and for that I'd use React or Vue, but most apps I've worked on in the last 2 years were complex enough for Angular
Too bad, lot of peoples seem to learn with their "hobby projects"
For me it's actually good for the middle ground, somewhere between small hobby and large enterprise. If you just need one or two views, then Angular is an overkill. Above that, especially if you have multiple states or complex components in each view, Angular becomes very useful
Well many others find great use in them, it's not a requirement to use them though so if you don't find them useful you don't need to use them.
I use Angular and I love it. I think people are still sour about how the Angular team re-did the framework for version 2 without a better upgrade path. Honestly, they should‚Äôve just named Angular2 something different. AngularJS vs Angular is just silly. Also, I think someone pointed out that the people who made that survey are react devs, and it‚Äôs possible they didn‚Äôt get enough people outside of the react community to take the survey.
Cannot play on mobile? :(
Angular has been a case of literal trial and error and poor planning. Absolutely hated the convoluted mess. 
Yeah, it's very confusing having AngularJS and Angular. I'm a bit suspicious of the survey as well. Not because Angular looks bad in it but the demographics also seem a bit off, and other sections also have some unexpected results. Sample size should be enough to be reliable, but there might have been a sampling bias
Can you give an example? Angular 2+ looks very well designed to me, specially DI. Angular 1, yeah, that was a hot mess
That doesn't make it right, though. It's still wrong even after reading the arguments. `async private generator MyMethod() {}` Doesn't exist. Now it's: `async #*MyMethod() {}` It's just so senseless and ugly. I really hope this is simply rejected by the people developing webkit and Edge. Just have them say: "No, do it right." It's a sad day when JS starts to look as senseless as PHP.
"com" is the "top-level domain". "microsoft" is the "domain". "blogs" and "msdn" are "subdomains".
Thank you, I am editing right now, though, there is not much left on the page.
How is that not up to the developer using his brains? If they want to write bad code, let them. Hell, you might even say it's up to the browser to detect the collision and throw a warning about it. As for sniffing private variables... so what? What's the problem? Client-side JS lives in the browser anyway, it's not like you can't de-obfuscate the code and make sense of it. And assuming there's a good reason for that being a problem: why not simply treat `try { foo.x }` as if `foo.x` was actually and literally undefined? The people programming browsers could make sure that `private` variables and methods are simply hard inaccessible from the outside, no? JS starts to look stupid this way, like PHP. It's horrible.
&gt; There were also several alternatives proposed, but usually shot down quickly by members of TC39, due in large part to what I view as personal preference. That's exactly what makes PHP such a horrible mess. The opinionated BS ruining the language. I loathe PHP for that reason, and it looks like JS is headed the same direction. Is there nothing else to be done? Could the webkit and Edge teams simply overrule this by stepping away from this? It's such a terrible decision...
I have never learned Angular I much preferred React. To be honest with you I just see React as easier to learn and a lot more flexible. The only people I found who rave about Angular are Java devs and people who hate jsx.
I‚Äôm pretty new to JS - I‚Äôm a Sql and BI developer for the most part but we are starting to build out little JS enabled websites that present custom visualizations. It‚Äôs not really my main focus but I do enjoy it (which is why I lurk on this sub).
I understand tld and domain but didn't know we could have nested subdomain names. How many nested subdomains can we possibly have?
You must think very little of the next generation of web developers if you believe the choice of symbol here is too confusing.
There are reasons it is this way and private wasn't really an option. https://www.reddit.com/r/javascript/comments/a1c53y/private_class_methods_support_has_been_merged/eap1kd8/
I guess he refers to the whole Angular 2 RC process which was a huge mess. I will always forget how terrible managed was that with huge breaking changes in between release candidates and Angular team which didn't seem to understand what a release candidate mean (I think some members said that for them a RC meant for them request for advice). I haven't seen a Enterprise more poorly managed in a very long time and it got many of us burnt and to loose faith in the team. I still a Angularjs dev (it is still alive and kicking in corporate environment) and the whole naming was stupid as hell. Now when I need to search for something I get results for both Angular and AngularJS. And I ended disliking the whole Angular way. Where you have to learn all those concepts and solutions that are just designed in Angular and you have to embrace the whole package: Typescript etc. I think AngularJS was hugely over engineer (Factories, Services, Providers, Values, Constants, ... Wtf) and Angular still is. Then you take a look to VueJS and it all makes sense, documentation is excellent and it provides a pretty compelling package. I can understand that for huge applications having such a feature rich and opinionated solutions might help. But the to start being productive with it requires lots of training and learning since the learning curve is steep. For me it is just not worth spend again a big amount of time just to learn doing things in the Angular way when I could spend that time in more solutions and problems that are more generic. I've spent years learning about the quirks and advance weird things of AngularJS. 50% of that knowledge is too specific for AngularJS and it can't be reused anywhere else. I'm not willing to spent same amount with Angular. 
Once you are comfortable coding in js, learn frameworks too (e.g. Angular, React). Then try to apply to a company as a junior front-end developer. It will be a long ride tho.
Your question is really just ‚Äúhow do programmers make money‚Äù and the answer is ‚Äúour jobs‚Äù.
No limit on the depth/levels. Only total address length.
The other comments are helpful, but consider going to LinkedIn and seeing what other folks' profiles look like- especially if they're in similar fields and successful. Then make a resume with a similar tone but with your talents and experience showcased. Also consider making a LinkedIn profile yourself. It helps recruiters find you.
What sort of graphical environment are you looking for in your editor? I personally code JS in emacs most of the time, but I like Visual Sudio Code and Atom IDE too. 
Most front end jobs involve a framework like Angular, React, or Vue. jQuery is popular as well because of legacy browser support to some extent, although it's kind of frowned upon by the community.
Text editors are just tools. I'd watch some videos from different ones on youtube to see which one seems like it will help you "flow" the best. I've become attached to Sublime Text, but that can change any day if something helps me work faster.
VSCode is good. Atom and Sublime are good and are lightweight 
Got to wonder if these are "curated" or all including... 
Answer Fairly useful. &gt; &lt;a class="embedly-card" href="[https://www.reddit.com/r/javascript/comments/a1tfy4/could\_you\_help\_me\_to\_start\_in\_java\_script/easitu4](https://www.reddit.com/r/javascript/comments/a1tfy4/could_you_help_me_to_start_in_java_script/easitu4)"&gt;Card&lt;/a&gt; &gt; &gt;&lt;script async src="[//embed.redditmedia.com/widgets/platform.js](//embed.redditmedia.com/widgets/platform.js)" charset="UTF-8"&gt;&lt;/script&gt; &amp;#x200B;
Thanks
I just watched TheCodingTrain and copied whatever code he had to create a canvas. I don't know if he had an external function for createCanvas.
Nope, if this became a thing my students would know it and understand how to use it, because I‚Äôd teach it. But they‚Äôd also be good enough designers to understand how much of a stupid choice it is, because it breaks one of the fundamental principles of good design.
I am aware of that, I was giving a reason why you‚Äôd want to update your dependencies.
Word 
&gt; JS should mature without looking to stay backwards compatible. This is literally the dumbest thing in this entire comment thread, and there was a guy here earlier saying TypeScript and Babel should merge, so that‚Äôs really saying something. Lack of backwards compatibility would utterly decimate JavaScript. It‚Äôs a terrible idea for a number of reasons. Not least of which: * Browser vendors would still have to provide support for older versions of JavaScript, lest they break existing code. This would necessitate maintaining two separate runtimes and some way to bridge the two. * Library developers would have to either maintain two separate versions, drop support for the entirety of their existing user base, or simply not adopt ‚Äúnew‚Äù JavaScript. You‚Äôd honestly have a better argument in saying JavaScript ought to be replaced by some entirely new language.
Oh? And what principle is that?
You need p5.js library to do that!!!!
Repetition. Also called Consistency. If you define something in a context you use it consistently and don‚Äôt redefine it. This rule can be bent (like the + operator, as its used to ‚Äúadd things together‚Äù whether addition or concatenation), but it shouldn‚Äôt be broken (like # meaning ‚Äúunique identifier‚Äù as well as well as ‚Äúprivate function‚Äù *on top* of the use of keywords which ‚Äúprivate‚Äù would follow suit but was not used).
I build a web application in Vue.js at work, love it! I'm a Front-End Developer.
It falls under the category of regular maintenance. There are two general reasons why you should do this. First, if your application hasn't reached it's end-of-life and you are actively developing it, stale dependencies will lead to versioning conflicts and unexpected, difficult to estimate work. Second, the browsers your code runs on do not stop being maintained. There is no such thing as "working software", there is only actively maintained software and stuff that's past it's end of life.
Wow, the second paragraph in the conclusion is blatantly prejudiced, isn't it? Maybe there's selection bias in the media the poll was passed around in. I'm no genius, but I have noticed a correlation between the best developers I've met and not venerating forums and bloggy articles as a source of sage advice.
[top kek](https://cdn.discordapp.com/attachments/505431683558801408/509956285282648064/sygdzssb01x11.png)
Lol I troll where I can and you MAGA fucks are just too easy
Looks like that's objectively not the case :3 but I do admire your firm and unwavering commitment to shameless ignorance! 
Im using Visual Studio Code, imo best free code editor :)
Objectively, you all got played by the dumbest fucking person in America, and watching him cry about witch hunts on TV is getting me soooo hard üòÅ
I bet there's a faster 1 line way to do it, but off the top of my head you could iterate over the array and fill a dictionary (Id, count on an object)- adding + 1 once you find a duplicate. Whichever ids have more than 1 you can put those into an array. Here's some untested code I wrote sitting in bed next to my cat. Something like that. Var dict ={}; Videos.map(function(a){ dict[a.id] == null ? dict[a.id] = 1: dict[a.id]+=1}); Var dupes=[]; dupes= Videos.filter(function(a){return dict[a.id] &gt;1 &amp;&amp; dupes.indexOf(a) ==-1}); 
A prototype-based object model, and classes and classical inheritance, are not mutually exclusive. No one disputes that Python has classes and classical inheritance, and yet Python's and JavaScript's class and inheritance implementation is remarkably similar. [JavaScript and Python classes side-by-side](https://i.imgur.com/p9Kw815.png), demonstrating classes as objects and inheritance as delegation. In fact, since Python's classes are themselves objects, you can even create objects ex-nilo. [JavaScript and Python ex-nilo object creation side-by-side](https://i.imgur.com/o726cHj.png)
It's flow types, [for exact object typing](https://flow.org/en/docs/types/objects/), I believe. Flow is a superset of javascript that allows typing.
It's just amazing to me that this is your life! You're truly worthy of scientific study. Remarkable contribution to our collective understanding of cluster b personality disorders! 
Lol you post on t_d, I thought personality disorders were like you guys‚Äô thing
I mean, personality disorders and being basement dwelling incels, of course
Perfect, thanks!
Projection is a very common coping mechanism, so don't forget that you aren't alone. Help is only a phone call away when you finally manage to muster the courage. We're all rooting for you! 
I prefer Atom, just because the colours are easy at separating components, it can write things like loops for you, it will automatically format, or because it's easy to navigate through files.
Why AngularJs when there is a Angular? You have to work on some old projects?
Basically iterate over the array, and push if it's not been seen, if it's in the list, you can return true. I did this with filter, and an array to remove duplicates
It's so interesting that you would bring up tantrums. This is a truly remarkable spectacle if irony you've created here, probably completely unknowingly! Thank you. I really mean that. You're fascinating.
Lol, keep burying that head in the sand bitch. Mueller is coming!
Like please don‚Äôt block me, cuz I wanna continue this convo in like a month, cool?
Don't get me wrong, from homies that use Angular 2+ they like the productivity once you jump in and take the time to learn it well. However, I seem to pump out apps and projects as quickly as they do using Vue with much less ramp-up time (I was able to start using it to build non-trivial things after a day or two of fucking around with it). The other thing although more just a thought than a real critique, but it's full of abstractions that pull you away from writing just javascript. So once you need to jump, you have all this angular knowledge that isn't as readily transferable. Vs something like React, which is as they say "just javascript". Although the same argument can be said for Vue and their templates and directives, however, I find it to a lesser degree than Angular. &amp;#x200B;
Good point, but I can't help think what a huge swath of projects exist between the hobby and enterprise levels. All frameworks are probably appropriate for most projects.
Big companies hear "google made it" and jump on it, therefore there are a lot of jobs
You are going to be the light of some behavior researcher's life. Don't you ever forget that. ‚ù§Ô∏è
Don‚Äôt forget you elected a traitor, cuz I certainly won‚Äôt let you üòò
For filtering out duplicate values of an array I usually do the following trick: * I iterate through the array with duplicates * For each item, I check if the index of itself is also the first index of this element in the array * If it is not, I filter it out In code, this looks like this: const uniques = input.filter((item, idx, arr) =&gt; { return idx === arr.indexOf(item); }); In your specific case, however, we cannot use `indexOf` as that doesn't work for objects in an array. However, we can use the `findIndex` method which lets us specify what exactly we are looking for - in our case we are searching for an item with the same `id`: const uniques = input.filter((item, idx, arr) =&gt; { return idx === arr.findIndex(i =&gt; i.id === item.id); }); Advanced: If you want to get fancy, you can also make this its own method which you then just pass how to identify one element: function removeDuplicates(getIdentifierFn) { return (item, idx, arr) =&gt; { const id = getIdentifierFn(item); return idx === arr.findIndex(i =&gt; getIdentifierFn(i) === id); }; } const uniques = input.filter(removeDuplicates(item =&gt; item.id)); 
This is another **excellent** explanation of how lines are drawn, will fully interactive demos. https://www.redblobgames.com/grids/line-drawing.html
I personally try to avoid `reduce` - I find it makes code harder readable (but that's most likely just my opinion). Reduce has it's uses; It's great if you want to "reduce" some array to one simple value (might be a string or a number) but if the result should again be an array I'd normally try to use other methods instead.
I'd imagine there are quite a few more creepy assaulting nonconsensual behaviors you engage in than just reddit stalking! Remember, help is just a phone call away. You can't undo all the harm you've done to yourself and your interpersonal relationships, but you can always make a change. ‚ù§Ô∏è
Doesn't seem to work for me `var videos = [{id: 1, name: 'video1'}, {id: 2, name: 'video2'}, {id: 3, name: 'video3'}, {id: 1, name: 'video1'}, {id: 3, name: 'video3'}];` `var filtered = videos.reduce(function (acc, val) {` `if(!acc.some(function(item){ return` [`item.id`](https://item.id) `===` [`val.id`](https://val.id)`; })) {` `acc.push(val);` `}` &amp;#x200B; `return acc;` `}, []);` `console.log(filtered);` Result: (3) \[‚Ä¶\] ‚Äã0: Object { id: 1, name: "video1" } ‚Äã1: Object { id: 2, name: "video2" } ‚Äã2: Object { id: 3, name: "video3" } ‚Äãlength: 3 &amp;#x200B;
Until next time!
Yes indeed, I know better than to try words like "no", "stop", or "don't" with a person like yourself!
Man if only the guy you voted for did! Do you want me to stop? Cuz you haven‚Äôt asked me to. I‚Äôm will if you do though, you MAGA fucks need your safe spaces after all. Do you want me to stop?
Is this how far you normally go before asking for consent? I'm not surprised. I mean, when they post in the_donald, they let you. Right? :3
I was thinking along the same lines. With some minor changes and formatting: const uniqueIds = {}; const filteredVideos = videos.reduce((duplicates, video) =&gt; { if (uniqueIds[video.id]) { duplicates.push(video); } uniqueIds[video.id] = true; return duplicates; }); Uses `const` over `var`. Combines the two steps of counting ids and fetching duplicates into a single step. Simplifies our dictionary by storing only `true`, instead of a counter. One important difference is that your version returns exactly 1 instance of a duplicate object (always the 1st one), regardless of how many copies it has. Meanwhile my version returns *all* duplicate instances, beyond the first one. Which one is preferred isn't clear to me from OP. You could also alter mine to return 1 instance of a duplicate object (always the 2nd one), by adding ` &amp;&amp; !duplicates.some(dupe =&gt; dupe.id === video.id)` to the `if` condition.
I just had to check in with you to see if you were okay after the midterms! Don‚Äôt make this about me.
That's a very good point. I never thought of that. I have heard of companies putting new programmers through a "technical interview" Only to rip their code off afterward. 
Personally, I found Amplify to be so easy to use. The first 5 hours getting the library to work felt like 10 minutes, from the missing dependancies that only got resolved when setting up legacy AWS JS libraries - to the fact that authenticating against an identity pool in a React Native applications turned into a whole-day affair - I had so much fun. Really. I think my favourite part was also how wonderfully consistent everything was - if you couldn't find something on the main Amplify website, you could just spend 2 - 3 hours Googling why logging out of an authenticated session didn't destroy the cached session, only invalidating it with AWS. So much fun. Reminded of the time I went to the doctor for my annual prostate checkup.
That's a very good point. Thanks so much for the advice! 
Hey, I like to live dangerously. 
The last part would make the algorithm quadratic. Instead, save the number of previous seen instances in your uniqueIds map, and only add it to duplicates if uniqueIds[video.id] === 1. 
Only issue with the article is that it asks users to install express globally `npm i express -g` rather than locally. Other than that seems very good and straight to the point. 
maybe the wrong place for this question.
I like yours better- makes sense to just do it iteratively once than make a dictionary and loop twice. 
Does this person have their shit figured out or what? Now I feel like I can grab this coding situation by the horns. Can't thank you enough for the advice. Thanks for taking the time to write all of this. 
No as that wouldn't be how webrtc is set up and you would have to dive into webrtc deeper and recode the whole thing a handshake needs to take place for security that's why it is how it is 
Where do I sign up
Thank you for pointing that out. See og edit. Sorry /u/cspotcode for being a jerk.
Are these objects literally equal or just deep copies? var x = { id: 1 }; var y = { id: 1 }; console.log(x === y); // false var x = { id: 1 }; var y = x; console.log(x === y); // true Depending on that answer, the solution can be optimized differently.
The problem is that it doesn't offer anything extra even when the task demands high complexity. And you can always use flexibility no matter the scale.
No it doesn't.
This is the type of thing you want to keep private so they don't patch it. maybe delete this post
Well, either full-time jobs *or* freelance projects. However, if you start freelancing without prior experience or excellent sales skills, you risk getting stuck on low-paying jobs fixing WordPress.
DI is one of the things I miss when moving to another framework/library. Parts of it are weirdly implemented, I agree, but the module system they built on top of it, together with all the benefits of DI itself, makes Angular quite solid for non-trivial applications. You still have a lot of flexibility in Angular, but only on things that are not core. But as it is quite prescriptive, when you go against core you end up fighting an uphill battle. React can handle anything, if you can set it up correctly. There are many decisions, for example JSX or not providing a basic structure or module system, that make the code prone to messiness and bad practices (e.g. mixing code with markup). And trust me, many people setup React in a way that is impossible to debug. In general, I work with both. Lately more with React than Angular, but it still surprises me that there is such a difference in adoption rates and so many complaints about complexity.
JSX reminds me too much of PHP, it feels like we're going to repeat history here... I work with both, and I think I'm proficient on both of them. Each have good and bad things, but it seems people are more forgiving with React. And I agree, when I first saw Typescript I got flashbacks from Java and wanted to just burn it with fire. Now, I cannot live without it. All the issues it prevents...
It seems like you don‚Äôt need a server. That would be the most practical way, but each user could send the codes by email, sms or pigeon. 
To be honest, I was an Ember developer when Angular 2 was starting and I missed all that. I started using it shortly after they released the first stable version. I'm tempted by Vue, the only one of the three I haven't tried, but it feels too lightweight for most of my use cases. I work mostly with mid-sized apps that have multiple views or views with complex components. React can get messy at times in those cases. I like Angular's modules and services for managing everything, and I cannot find anything close to them in other libraries that doesn't require a lot of DIY
You're gonna need to offer up more than that. What are you making? What experience do you have? Have you looked at anything other than how they're spelled?
Wow, you really had to stretch to tie this to design, didn‚Äôt you? I‚Äôll disregard the fact that you are conflating design *principles* with *rules*, and focus on your argument for how the principle of ‚Äúrepetition‚Äù applies here. &gt; If you define something in a context you use it consistently and don‚Äôt redefine it. The keyword here is ‚Äúcontext‚Äù. `#` doesn‚Äôt mean ‚Äúunique identifier‚Äù in the context of programming in JavaScript (or any other programming language I‚Äôm aware of), so that‚Äôs really a moot point. Some APIs and libraries use strings prefIxed with `#` to mean a variety of things, but then you are dealing with a different context from JavaScript *the language*. The Selector API used to reference uniquely identified DOM elements from within JavaScript has nothing to do with the JS specification. It is defined by the DOM specification, and implemented as functions of individual browsers‚Äô runtimes. Node and other non-browser runtimes have no concept of using `#` to query the DOM for the existence of a particular selector. It is no more a part of JavaScript than a browser‚Äôs default ‚Äústart‚Äù page is a part of HTML. If you‚Äôre arguing against the use of a particular character because it means something different in a completely different context, then you might as well disavow every form of communication in existence, because *no symbol has universal meaning*. 
Whichever works best for you, it doesn't make that much of a difference
Well. I have worked with Express and Ember only till now and now to learn these new frameworks I want to choose whichever is good.
Is there a particular reason you are installing express globally with -g ?
For the job market, i will say go with react, its growing very huge, and also becoming popular for mobile too (React Native) 
so im just barely starting to get a grasp on hooks at this point, even after this article. i probably won't 100% understand them until i actually dive in and start writing code with them. &amp;#x200B; anyway, so it seems to me that hooks are a shortcut to avoid all of the things that require you to use a class-component instead of a function-component. callback functions (with this handled), changing state, and im assuming lifecycle hooks too, are all available this way. &amp;#x200B; some thoughts, and I would appreciate feedback on these points. &amp;#x200B; 1) I like the useState() stuff. The function to mutate that specific state properly seems especially nice because it might be able to avoid some of the state mutation boilerplate we usually have to deal with. &amp;#x200B; 2) Does this mean each function-component now has a state? otherwise, what does useState() work with for its state object? &amp;#x200B; 3) I'm assuming useEffect() is another way of implementing event callbacks?
If this is the case it's better for the creators to get the ad revenue compared to using an ad blocker. But I figure they have some way of tracking this, that request is sent multiple times when watching a video, along with the videoplayback request. I'm sure they're just not looking to see if you reached the end and are using a combination of the data sent.
Did you run the code? I think you need to include an empty array as an initial value for \`duplicates\`. Also, it still only returns 1 instance of duplicated objects when I run it. &amp;#x200B;
Well in the words of the philosopher C.H. Barbossa, they‚Äôre all ‚Äúguidelines rather than rules‚Äù. :-) But they are universal design guidelines for a damned good reason. To that, I also note that you did not address the second (and stronger) part of my argument: The use of a hashtag rather than a keyword breaks the already established paradigm in JavaScript. That kind of inconsistency has no real justification outside of ‚Äújust ‚Äòcause‚Äù.
&gt; Edge caches and Gateways solve this problem. Caches you don't control make it possible to hash dynamically generated scripts you don't control? LOL okay bud.
Lol. Yeah, just saying... asking if you should learn JS in a forum dedicated to JS; pretty sure you could have predicted the answer. :) Looks like you got some good responses though!
No, that is not possible. WebRTC uses a porotocol called ICE (Interactive Connectivity Establishment) which requires both peers to gather and exchange so called Candidates. Candidates are basically addresses and parameters under which a peer MIGHT be reached. Both peers than coordinate to try all possible combinations of candidates until they find a combination that actually connects them. 
corrected.
You are so incredibly conservative. People like you will lead to the destruction of javascript when the language stops making any kind of sense. YES we can safely let things slowly deprecate and break over time. That's nothing new. &gt; This is literally the dumbest thing in this entire comment thread, and there was a guy here earlier saying TypeScript and Babel should merge, so that‚Äôs really saying something. What's dumb about gradually phasing out old websites that are no longer being updated? If something like `private` is protected because it would break a minuscule amount of websites I'd say: great. Time for the old crap to update. &gt; Lack of backwards compatibility would utterly decimate JavaScript. It‚Äôs a terrible idea for a number of reasons. I'm not saying "leave 90% of the web in the graveyard", I'm saying: "it wouldn't be so bad if Chrome and others would display a warning for the outdated part of the web." &gt; Browser vendors would still have to provide support for older versions of JavaScript, lest they break existing code. This would necessitate maintaining two separate runtimes and some way to bridge the two. And I disagree. I'd be a fan of browser vendors letting javascript evolve. Old code is first deprecated but supported, though a warning is visibly present. And one could agree upon a timespan of, say, 3 months before the warnings turn into breaking errors. The current way of dealing with endless backwards compatibility leads to BS like this hashtag "private" and the BS asterisk "generator". &gt; Library developers would have to either maintain two separate versions, drop support for the entirety of their existing user base, or simply not adopt ‚Äúnew‚Äù JavaScript. No, library developers would simply state what browsers they support. Like React supports IE9 and up. Which simply means that nothing changes for developers: we transpile our modern code to whatever we need to run it on anyway. &gt; You‚Äôd honestly have a better argument in saying JavaScript ought to be replaced by some entirely new language. That's ***exactly*** what this stupid BS will lead to! Because javascript starts to look retarded people will find reasons to make something else take over. As if that isn't a boatload more work to maintain. They should just create private async generator methods this way: `private async generator MyMethod() {}` and not async #*MyMethod() {}`. Because that's what PHP does, and most of us generally agree that PHP is a filthy mess of ridiculously managed code.
Tip of the day: "Fake it 'til you make it." That works for personality, too. Spend a few weeks acting confident and I'll guarantee that you'll see improvements. Don't just be yourself, be a future &amp; better version of yourself.
Okay.
Own it up man, everybody has issues. Maybe not physical handicaps, but there's personality issues, insecurity issues, infertility, small dicks, crossed eyes, tinnitus, whatever. Plenty of reasons for everyone to feel insecure. What sounds like nothing to you can be the world's biggest problem to someone else. As for your disability and other people: those who matter won't care, and those who care don't matter.
ya I think the responses have been very informative. I mean, Java is a great language. But it seems like companies expect a lot more expertise from Java developers than front end JS developers for entry level. 
Why's a boys face on this question
Sure, but more frontends don't have a cs degree than backends. For non cs degree people, the path into frontend is a little more accessible for many people. Not true of everyone, and not a rule, but a tendency. 
It'll show up as a fraud because you didn't hit the 25% 50% 75% quartiles, so it's not like you're helping YT steal from the advertisers.
Tis' THEMINDSTORM!!!
Dude, you‚Äôre out of your head over the idea of having to adapt to a new symbol being used in a very specific, 100% optional syntax. Little snowflake is upset because hash tags remind him of PHP, but I‚Äôm the ‚Äúincredibly conservative‚Äù one? Get real.
You can use something like AWS IoT for signaling. This way you don't need to run a server yourself.
Mark up is syntatic sugar. Much like javascript classes aren't really classes, but functions. Calling it a class doesn't change how it behaves. Neither tags do. However, both make things more readable. Which goes to another of your points: &gt; Mixing code with markup is always a bad idea It's not mark up, it's javascript functions. However, putting it into markup, makes them easily recognizable, in a way signifies component interface. You would use these outside of your React components too, for example in polymorphism where you would have array of objects, in example, declarative routing which you would map in some of your actual component. Separation of concerns is there. There is separation between different kind of components, mainly containers from presentational components. Not even touching on things like state management etc. However, separating styles from component makes no sense. Style directly depends on state of the component. For example, we can agree that input field red coloring directly depends on the validity of the input. To separate this behavior wins nothing, as you will have to write styles and when couple the style back to the component by peppering your code with additional logic to map it on component. So effectively you win nothing, add layer which serves just to couple back what you initially separated. Complexity which could have been avoided. Prop propagation also is very handy when dealing with themes, not to mention, having flexibility of JS when working with stylesheets. There are some performance concerns ofc, and this can get out of hand when poorly implemented, but generally serves very well when you can think of Component as a whole independent unit, ready for reuse rather than part of the document. &gt; It's a different type of module management. ES6 only offers the very basic foundation. Pretty powerful if you care about encapsulation. DI containers like one in Java Spring or PHP Symfony can't really work with javascript. DI containers implementations rely on class metadata. Something JavaScript simply do not have. Most DI containers you come accross which are implemented in TypeScript are .. actually hacks. Like inversify js and similar. 
Dude, get it together.
love that you can see salary info
Thanks! We think this aspect is incredibly important, especially in a market like today's!
Do you feel better now you're resorting to insults? You "being open" to this change is you being the problem; the change isn't progressive, this "optional" (but official ECMAScript) change is worse than the encapsulation that already existed. It's ridiculous. And it looks stupid. It could've been done the right way and they didn't because they want to be backwards compatible. That just means there's not a very long future for JS when the past is constantly making the future bend in unnatural ways to support whatever stupidity happened long ago.
Provide jsFiddle and I help you out
I have a old adsense account with ‚Ç¨67 lol
Here's a "one-liner" using ES6 `Set`: const uniqueVideos = [ ...videos.reduce((set, v) =&gt; set.add(v.id), new Set()) ].map( id =&gt; videos.find(v =&gt; v.id === id) ) 
If you have primitive values to dedupe, and you don't **need** an array, I suggest using a Set: `const deduped = new Set(inputArray);` This will be *much* faster than `filter`, if that's important to you. If you *do* need an array, you can wrap the `Set` instance with `Array.from()`, but that is slightly slower than `filter`.
Would [https://peerjs.com/](https://peerjs.com/) help?
Thanks for the input! I will rewrite my mongoose method and see what I come up with. 
Not notepad. Use vscode or notepad++ or something
Don't write any code then and you'll be the best developer
JSX reminds you of PHP? Because there are markup and variable? [Angular seems to have the same](https://angular.io/tutorial/toh-pt2) but with {{variable}} instead of {variable} . I actually picked React because it felt like there were no magic binding, only es6 vars and modules. Feels simple and absolutly in control of everything. Which lends itself to too many structure that is true but I've decided to settle on mobx and I'm perfectly happy with my solution right now. 
VueJS is in between in React and Angular: it is more opinionated, it comes with official state management (Vuex) and router and it doesn't feel overengineer. It has the best documentation of the three by far and most of the design decisions they made make sense. Ah, it has the best CLI of the three. You can use it with Typescript if you want and yes it is more lightweight, and I don't think it is a bad thing. I think you can learn VueJS way faster than Angular (the framework size and features is way smaller than Angular) and it gives you more freedom to choose what you want. You can use it with JSX if that's your cap of tea. I think Angular modules and services are a bit overrated since JavaScript now has native modules. Yes, dependency injection is nice, but you can achieve similar results with native modules or native functionality without having to learn the "Angular way". And as I said, all the time you invest learning things that are not bound to any framework, is time will definitely pay off double in your career. All the knowledge you get that is specific very specific for Angular will be wasted once Angular is dead in the future. And I know because as I mentioned, I've invested so much time learning about all the weird things of AngularJS and a big majority is wasted effort. The future of front end looks like that it will relay more and more if native web technologies, like web component. I see the value of huge opinionated frameworks like angular in big corporate teams and big teams. I'm just not sure if it is worth it: is it better for each developer to spend 3 months learning the quirks and particularities of Angular? Or is it better to put a small team of seniors spending 3 months setting standard and took to enforce one way of doing things? For me, at this moment, it looks like the latter feels better and of course that is my experience. What I like the most of react (even though JSX is something that still causes friction with all the classical best engineering practices of 10+years) is that the framework is super tiny and you basically just use the language. I think that also has a positive effect on developers who will really learn more the language bad the native APIs. I've seen so many developers who only know AngularJS and couldn't do anything without the language. 
&gt; To broker connections, PeerJS connects to a PeerServer. Note that no peer-to-peer data goes through the server; The server acts only as a connection broker. 
The module is an if statement. I mean come on
Actually the more I read the better it gets. Still has enough shortcomings though that I only gave it 3 stars on Amazon.
Angular is the worst choice in all scenarios, ever
&gt; Mark up is syntatic sugar It's not a matter of what webpack spits out, which I agree is not markup, but the source is meant to be used by developers and the source mixes code with markup. `&lt;MyComponent ...&gt;` is markup before it is transpiled, and the readability of mixing code with markup is low. It's easier to have code on one file and markup on another, and keep logic separated from presentation. There's a reason templating languages limit the amount of logic you can include. CSS has classes that can be used to represent state. There are many tools that can be used to debug issues, and generally it has been forged through years of use. Yes, certain things are quite annoying, especially how browsers render, but those still affect CSS in JS. My frustration with CSS in JS is that it breaks the reusability of classes, duplicates code, and makes creating styles more confusing because, again, it mixes presentation with logic. In terms of presentation and logic, there is no separation of concerns. &gt; Pretty powerful if you care about encapsulation Agreed, import/export is amazing 
I'm targeting es6 just fine.
It is if you don't give it a chance. It is extremely case specific, but if you know it, having this option is good for you. You could change "all scenarios" and "ever" with "most of scenarios".
Thanks for the suggestion, but PeerJS requires a server, and when I try to get a [key over here](https://peerjs.com/peerserver), I don't get anything
+1 for the answer, but also for the use of "protocol". 
the problem is with class components. Because React only invokes components as `Functions()`, and doesn't care if they were defined as class. in ES6+, classes must be instantiated via `new`
I would add "use types". Optimization without types is a pain in the ass. So maybe the future is something like TS without stripping away the Typesystem. 
They should use TS instead!
Our submit it as a bug hunt, and get paid for it
Still not sure if this is sarcasm 
This, plus there will also be additional analytics tools firing in the ad to measure viewability, which depending on the campaign can have different requirements - how this plays out in YT's environment I don't know, but whilst a standard viewability requirement is 50% in view for 3 seconds, some have 5 seconds+ for example. I imagine this would give someone a headache to figure out if it became mainstream.
The disadvantage of using TS is that you‚Äôre at the mercy of TS to implement the newest ES features. If I recall, it took them quite a while to bring destructing into the language while the rest of the community was already enjoying it via Babel and latest proposal plugin. A more recent example is TS still doesn‚Äôt support optional chaining yet. I‚Äôve been using it in production for a few months now. 
Not only are you wrong, you also sound bitter and unfulfilled. I'm sorry you feel that way.
That's a bummer, so this problem is not isolated to TS? If you were writing native JS classes you'd get the same error? I wonder if you can write a converter function that wraps the class in a function that supports both `new` and non-`new` invocation. If you copy the prototype and all static fields I think it might work as a complete replacement for the original class.
Haselhoff
I'm still pretty new to programming so no idea if this is a good solution, but it seems to work. `let deduped = [];` `videos.forEach(function(video, index) {` `if (` `index ===` `videos.findIndex(function(element) {` `return element.id === video.id;` `})` `)` `deduped.push(video);` `});`
Ok, so no offense but you totally miss the point of why JS is hard to compile. It's because JS is dynamic, not because "its goal was to be portable and cross-platform". Java is also portable and cross-platform, but it's much easier to compile. Your optimization tips are also frustratingly unexplained and a mix of nonsense and real info.
This is how Dart came to be(and went)
Yeah, easy 50 bucks
I see bigger companies adopting Angular and React/Vue for startups. 
I misread the original post. This doesn't solve your problem. Sorry!
Wrong about what? I really want to know. All I‚Äôve heard from you is mindless blather about how the inclusion of a hash character in JavaScript marks the end of JavaScript as we know it, but you‚Äôve yet to make a single fact-based argument against it. I don‚Äôt think you‚Äôre capable.
turns out I was mistaken. A 3rd party library has this issue, not react. 
vue if you are new to js/frontend dev. 
I thought unity ditched JavaScript support a while ago? No?
Thx homie. First time doing OOP on .js, didn't know that abous javascript classes.
And...?
I made this exploit into an extension, just click the little (i) icon on ads to skip them. Download the extension file [here](https://ufile.io/qhon8)
There is some logic in `isElectron.js` that seems valuable to not repeat a bunch. I feel you on the component though.
Haven't tried it yet, but [Flutter](https://flutter.io/) might keep Dart around.
Yep. Should have called this package `is-electron`, but that package [already exists](https://www.npmjs.com/package/is-electron).
I don't know of any relevant conventions, but I generally try to go from least to most specific, which would probably be "imageLargeFixed" or "imageFixedLarge" in your case. This way, each word can almost be considered a subset of the previous word.
&gt; Mixing code with markup is always a bad idea Why? Markup is code. I've never understood this divide. In my experience, logic, markup, and styles are all coupled closely enough that separating them just creates additional overhead. I find thinking in terms of "components" is the best solution as it couples local logic, styles, and markup into a single unit.
use bem: image image--small image--fixed
It's a JS question, not CSS.
Do you have other `smallFixedSomething` things? If yes, then go with `smallFixedImage`. Do you have other `imageSmallSomething` things? Go with `imageSmallFixed`. 
Honestly I've never seen anyone name variables like that. Do you name your classes like that too? So would you do "SetSorted" instead of "SortedSet"? 
Naming things is like 90% of coding. :) I generally lean towards English phrasing because I find it makes it easier to scan/read the code. Consider the following: if (image.isSmallFixedImage) { // I read this as "if the image is a small fixed image then do something"... } Versus: if (image.isImageSmallFixed) { // I read this as "if the image is image small fixed then do something"... }
Thank you!
You can use Typescript as a plugin for Babel now, though Typescript is generally up-to-date enough for my taste. You don't get Flow's exact object types though.
Technically, it's _three_ if statements: https://github.com/anubhavsrivastava/react-for-electron-only/blob/master/src/isElectron.js
The problem is I use Less CSS modules, which make more sense to name using BEM. I also have graphql fragments, component classes, and then regular old JS variables. I use objects wherever possible, but obviously in some cases like graphql fragments, you can't, and you just have to have long-ass confusing names.
If I had multiple 'set' variables, then yes, I would do setSorted.
I think BEM works as a concept in any language. It's basically just broad-to-specific.
Pretty bad naming then, sounds like a function that would set value named sorted.
Hmm, that's kind of helpful, actually.
I can neutralize 95% of my problems by using objects, it's just that last 5% that's impossible to wrangle!
I just wouldn't use 'set' as a noun in a variable in the first place.
BEM works in any language, but my point is that you can't give a JavaScript variable 3 different names like he/she wrote.
Set is an actual thing though, https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set.
Right, but if the variable names are hard to manage because of an underlying code problem, you're better off identifying/fixing the underlying problem than worrying about the variable names.
Fair enough, I've never used sets before.
Don‚Äôt know why you are being downvoted...
There are two unsolved problems in computer science: cache invalidation and naming things.
I have no idea
Software is fun isn‚Äôt it?
One thing I tried was using the firebase real-time databse to send the SDPs. I generated a random number and saved it to the database. So another peer can use that same code to signal that client, the this client's SDP is added to the database, so the client who created the radnom code can signal the other peer automatically. However, this didn't work, and it said failed ICE. i hope you understood what I said ... 
&gt; With React you have to set everything up yourself Or you could just use [Next.js](https://nextjs.org/). The 3 file example on the homepage is literally all the code you need for a basic project. You can copy and paste it and it will work.
[https://www.youtube.com/watch?v=UnEPBQvkNrg](https://www.youtube.com/watch?v=UnEPBQvkNrg)
https://github.com/joshborup/drawthings.fun enjoy :)
Ill definitely do that when i get a break over christmas, here is the repo if you are cuious https://github.com/joshborup/drawthings.fun
It's so much fun. It's like Legos, but you get to design your own pieces.
Anybody??
Download a random .zip file from a random user on the internet... that‚Äôs gonna be a no from me dawg.
it‚Äôs just a manifest.json file and a 3 line javascript file that implements it. same exact code the guy wrote
There are two hard problems in computer science: cache invalidation, naming things, and off-by-one errors.
There are two hard problems in computer science: cache invalidation, naming things, and off-by-one errors.
What‚Äôs a native web config file?
Neither. I don't understand what either of them mean. 'Small's is contextual and 'fixed' means nothing. You should be naming variables so that when your pick the code up in 6 months (or someone else picks the code up) they should understand what it means. Variable names are like the keystones of code. They tie everything together and need to be as efficient as possible. 
That too
That might have been misleading. I meant native as in imported js files with windows objects as opposed to something fetched from a config server
Thanks for sharing your enthusiasm. Right now I'm looking at Mithril as a cleaner, freer alternative to React. You have a compelling argument!
Bookmarklet using this as URL: javascript:(function(){var VIDEO=document.querySelector('video');if(VIDEO)VIDEO.currentTime = VIDEO.duration})(); Skip all youtube ads on click
I‚Äôm not sure I follow,‚Ä¶ what do these files configure?
The best practice is what comes closest to reading natural language. image.smallFixed comes closest in my mind but I am not a native English speaker. BUT The purpose is to communicate purpose to the reader. If you do that, and do you that already with both naming schemes in my opinion, then it becomes it matter of how much time you want to spend on fiddling with code readability. Code does not get read a lot on general. Try not to get that stuff perfect. First thing that matters is, does it do what it is supposed to do. 
I _think_ the issue here is that it's going to return a new function component definition every time the parent component re-renders `&lt;Thinger.h1 /&gt;`, thus causing React to always throw away that portion of the component tree.
There are two difficult things in computer science: 1. Naming things 2. Cache Invalidation 3. Off-by-1 errors
Imagine you have a \`configuration.js\` file which gets loaded whenever your app starts Normally, you can just add stuff to this file and build, then fetch it like normal However, what happen if you have multiple environments (dev, prod, prodDR, ...) and a lot of things to configure, and all of these things are different across different environments? This set up allows you to specify everything using one templating source, manage all your environments and keys, then when compiled it will spit out the correct \`configuration.js\` file for each environment without you having to manually go editing each env config whenever you want to add/remove something. It also keeps everything close together which makes it easy to gain a holistic view of your current config across all environments. Hope that helps : ) &amp;#x200B;
Sarcasm.. rooted in cold harsh reality. :D
Doesn't matter as long as it's consistent.
if that's the case you should probably unzip and place that in a gist if you want to share it.
[removed]
Generally, I‚Äôd separate them like ‚Äúimage.fixedSmall‚Äù. Reason being that each is a class-type item (not in the programmatic sense of the word class). Therefore, you could have mutability, I.e: image.relativeSmall image.absoluteGrande image.fixedVenti coffee.blackNoSugar javascript.isEasy
I noticed you mentioning BEM for CSS. Have you considered using a style guide for javascript, to reduce the coginitive overhead in doing this? Remember what maybe convention for one language might not be the same for another. https://google.github.io/styleguide/jsguide.html#naming-rules-common-to-all-identifiers
I‚Äôd also like to add that all functions are not equal. Block-scoped arrow functions are not hoisted either. But yes, just as you couldn‚Äôt call a class function from it‚Äôs constructor, you can‚Äôt call a class that doesn‚Äôt exist yet üëç
Well damn. Hopes&amp;Dreams = crushed. You must be ‚Äúthat guy‚Äù on every team that sucks the life out of everyone else. You should try being encouraging and constructive with criticism if you want to actually have an impact.
The cleanest code reads like english.
I believe that might be created with Total.js (I could be wrong, not my specialty). https://www.totaljs.com/flow/ Possibly could be JS plumb https://jsplumbtoolkit.com/ If you don‚Äôt want total and don‚Äôt have the spare $3,000 laying around for JSPlumb, you can try this https://github.com/shamansir/rpd
The important thing is consistency.
Local proxy, redirect all http(s) requests to Rick roll. 
In general, no, do not use BEM as a naming rule in JS. It is both too strict and too tied to a single aspect of things (i.e. hierarchy and ownership). In particular, what _is_ that variable in that function? Are you managing various images? Are you producing them? Transforming one into other? Just what is the _role_ of that variable?
English matters only for spelling. I use to build up a compound identifier in a way that makes it easier to spot related things when sorted alphabetically. Example: printReport, printReportQuarter, printReportYear, printReportYearByMonth. Alphabetical sorting rules because it's the most commonly available method (implemented in pretty much every text tool, be it an editor or a terminal) to give some order to a list of items.
There are only two hard problems in distributed systems: 2. Exactly-once delivery 1. Guaranteed order of messages 2. Exactly-once delivery 
Thought I was in /r/csharp for a second there 
&gt; You can use Typescript as a plugin for Babel now, though Typescript is generally up-to-date enough for my taste. That doesn‚Äôt change the fact that you can‚Äôt use the newest ES features with TS. 
Very useful info. Thanks
I'm feeling violated reading that article. Please don't address readers like five year olds. And mix some facts and benchmarks inbetween your claims, some of which have no basis at all.
consistency is the most important thing, the rest is window dressing as long as it makes sense to you, and to whoever might read it. When you are working on your stuff, just do it as you like. When you are working for others, follow the existing standards.
I recommend trying all possible ways you can imagine. When you get back to your code in few months you will see what works best in which situation. There is no best convention. It always depends.
Wish TS could optimize code based on types. 
Call it what it contains. SortedThings.
Both are wrong to me. The implementation shouldn't leak in the name usually. You should name things by what they are. If that image is an avatar then call it avatar not smallFixedImage for instance.
Just include it like this: &lt;script src="p5.js"&gt;&lt;/script&gt;
Absolutely. Always name things so that they are completely readable. You‚Äôll most likely end up uglifying your JS in prod anyway. 
I would strongly suggest you use CSS(Sass) modules do you don‚Äôt have to worry about the naming convention of your CSS. Once your project reaches a certain size with large teams of devs BEM becomes not so scalable. 
Just use css modules. Problem solved 
The same argument can be used against separation of concerns. Separating things into their own modules just adds overhead, and in many cases there is a lot of overhead, but it makes sense for other reasons (e.g. clean, easily maintainable code). Thinking in components is great, I love it and do it with any framework/library I use. But thinking in components doesn't mean that it's all in one file or even in the same language. You can still think that components have 3 parts (logic, structure and styles) and delegate each of those parts to a specialized module. This is a matter of preference, but in my experience there are certain development paradigms you see coming up again and again. It's cool that we are trying _again_ to mix presentation and logic, maybe we'll get it right this time, but we have tried before and it didn't work out that well. It lead to complex, messy, unreliable code that is very difficult to maintain. Facebook is a PHP company, so it's only natural that they will try to build a better PHP in the same way that Google is a Python and Java company, and Angular is modeled after those.
1) 3.5 years 2) i wanted to be a geologist 3) i'm not sure what you mean here? I like to write backends 4) For me that would be the low-level languages
As if React was not made by Facebook...
100 /100 lmao. it's just a list of text with some ajax. 
I have chosen react over angular because I don't want a big black box under the hood. Also, I wanted to write JavaScript and not learning a framework. But in the end, it all boils down to what fits better for you and your team. You can build a great application with all popular frameworks nowadays.
It's hard to tell. I would recommend to try all 3 you mentioned and write the same simple app with it. Then you have a better feel for what is fitting more for you. :) &amp;#x200B;
This response just shows inexperience with Angular and some confusion with some concepts. Choosing React, Angular or Vue you always get locked in an ecosystem. Debuging in Angular is not particularly bad, but I agree is not great either. Tech debt should never be an option, especially cause "just for now" becomes "forever", but you can also add debt to Angular projects, it's just not necessary if you know how to use it. You can use Flux with Angular, there are actually 3-4 libraries to implement Redux. And Angular is also component-centric, not a traditional MVC.
\&gt; Choosing React, Angular or Vue you always get locked in an ecosystem. No. That's simple not true. You can only bring the view render library, and nothing else. \&gt; debuging in Angular is not particularly bad, It is particulary bad. The way its compiled will throw errors without being able to to point where the error is. \&gt; tech debt should never be an option, especially cause "just for now" becomes "forever", I suggest to fix proceedures in your company, if tech debt becomes "forever" where you work. That's a problem with management, not with code. \&gt; You can use Flux with Angular, there are actually 3-4 libraries to implement Redux. And Angular is also component-centric, not a traditional MVC. Yeah after they figured out that they previous approach is actually garbage and React is a lot better. Back in AngularJS days moving from 1.4 -&gt; 1.5. Angular is gigantic framework which still holds to a lot of MVC patterns. Reinventing one of it's own module system and trying to force DI is simply terrible concepts.
What I do is a simple timestamp of messages, the timestamp of the most recent message received by a user is stored, when they query new messages that timestamp is sent with it and only the newer messages are returned to the client.
It was not their type system, they didn't know and still don't know what their audience is - maybe Mobile now... 
Absolutely and I'm sure we will see this in the Future. Optional typing - use it if you want more performance and you get optimized AOT compilation, if not skip the type but you won't get the full performance. 
I really like it! Things that I think could use changing are: * Lower menu buttons don't need to show up if element isn't minimized. They just clutter up the space if the window is small. * There could be some snapping like in Windows 10 or Linux, where If you drag window to left or right side it will expand on that half of the screen (top side for fullscreen and corners for 50% of that side). I think that it's actually important for UX. * And lastly, hard problem to solve, what to do when user scales down his browser and some of your windows could be unobtainable.
Yes, this works well for 2 way scrolling. i.e. scrolling up to view older messages, and scrolling down to view newer messages (if looking at historic messages) But if some existing messages in the client have changed while the client was offline, the client will not know about it, as they are only requesting messages after the latest (based on timestamp)
Thank you for your feedback! * I'm planning to add an option to allow minimize window/show the docked buttons at all. Yes, you are right, sometimes the docked buttons are not needed. * Yes, the snapping is awesome and I'm planning to implement it. * What did you mean scale down? Did you mean zoom out the browser and make everything smaller?
May I ask why people have advised you to never rig up your own Auth system? 
I don't allow people to edit messages so that hasn't come up for me but if i had to i would pass an updated time with it or a version number that changes each update then that could be compared and the message updated if necessary
I might give Vue a good chance, it sounds like perfection. React has introduced many cool things I like, but JSX and a few other decisions make me be suspicious of it in the long term. When I said Vue looked too light-weight it's because the little I know about it, it feels like it has no solid concept of project structure. The same goes with React. It feels like you are building individual pieces that are not aggregated into a coherent whole. That's why I like Angular modules, it feels like they have a concept of App, not just components. I don't think it's a waste of effort learning technology that can go obsolete. All technology will be obsolete at some point, that's the nature of our profession. That's why we need to keep learning and stay up-to-date with new technologies. Having recruited many people for my teams, one of the biggest red flags is someone who stayed in a company for a very long time working with the same technology. So yeah, even if React or Angular will die out in 5-10 years, you still need to learn the ins and outs to be able to work those years. The technology that comes after will always be built to solve the issues we found in the previous generations (and sometimes we regress to an even earlier generation). About the time it takes to learn vs build with Angular and other frameworks, this is where I believe there is some confusion. Being able to write code using a specific library or framework is not the same as being able to develop an application with them. It's true you can learn React or Vue in a week, but knowing the ins and outs, best practices, etc, takes a long time with anyone you choose. Angular has a steeper learning curve, but in that learning curve you learn how to properly use it because the framework is highly opinionated. With React and Vue, you'll have to learn this on your own, and when things are inconvenient you'll cut corners because it's difficult to see why it was necessary to do it in a specific way and it was not enforced. So while it feels like you need a lot more time to learn Angular, I think any new framework/library you choose will take about the same time to use correctly. And yeah, I agree, learning a framework without learning the language is a terrible idea.
A really good read!
How would you pass the information to the client if it is offline? And when the client comes back online, how do you ensure the updated message appears in the client?
What does this have to do with Javascript? /r/webdev would be more fitting.
1) 10y 2) game dev 3) database 4) oop is not my things
Since console.log is a function, you can also write .forEach(console.log), eliminating the anonymous function.
Reminds me of using d3.js Check out d3js.org
I didn't mean the "ctrl +/-", but grabbing right edge of chrome to make it smaller in width. I guess that's a problem for when tablets switch from landscape mode to portrait as well.
We will have to agree to disagree here, as we are unable to reach an understanding. As I said on another response, this in the end is a matter of preference. I'm not seeing in JSX anything that is disruptingly new, just another attempt to mix presentation and logic. It's cool and all, but I have seen many in the past try and all of them failed for the same reasons, usually after years. Let's hope this time it works.
Again, I'm just reading some inexperience and fanatism here. You are not addressing the main discussion, just looking for ways to attack a system you don't like by using quite superficial arguments and childish attempts at insults.
You can use ES6 features: // Arrow function [ 'prev','exit','next' ].forEach(nav_el =&gt; console.log(nav_el)); // for-of loop for (const nav_el of [ 'prev','exit','next' ]) { console.log(nav_el); }
That would also log the other parameters that `.forEach()` passes to its callback.
I just realized you were making some great points on another thread, how come you decided to go down to this level?
Maybe, although it really depends. Consider the following example: imageWidth = 10 imageHeight = 20 imageQuality = QUALITY.HIGH imageSmallFixed = true I think the you‚Äôre throwing away the problem with `image.` because then the obvious solution becomes `image.isSmallFixed`. If there‚Äôs going to be more than one variable relating to the image (as above), I think it becomes more readable to know what you‚Äôre talking about first. I would write `imageIsFixedWidth` (or the same without the is) because in code I would write `image.is(FIXED_WIDTH)` or whatnot.
I know that's not answer to your question but why would you do that? Setting up mock server in express is super easy, and it really test if your app works well with network requests. Your mock with observables could hide some issues.
I mean, I carry no ill intent. And I can say I get the place you're coming from. And I can understand the concerns. And when taken under the premises you think, they seem to quite valid objections. The problem is that it's a strawman. Reasoning isn't faulty. The premises you base that reasoning is. So while you do maintain logical consistency you come to somewhat wrong conclusions. There are few common faulty premises: 1) JSX is a form of templating As I've demonstrated with a code sample, it isn't templating. It's an interface of a javascript function. It becomes even harder to justify "it's templating" position when we talk in higher order components. 2) JSX is new technology only used by facebook It came more than half a decade ago. It's not new. And in past few years it become industry standard. Not just react. For example Ionic team (same guys which work with Angular) made their web components compiler which relies on JSX to work. Stencil.js. 3) Separation of syntax === separation of concerns I'm yet to hear an argument why styles should not be mapped by props in flux architecture. The criticism levied against it usually is innate to class name mapping, which prop passed styles solves. If you care so much about separating logic, why you advocate for writing style mapping logic in your templates rather than just passing already resolved styles which require no additional logic in your 'template' to work? 
Yes, and because somebody's chain smoking grandfather lived to &gt;90 smoking does not kill you. I said "probably" because most things are on a probability distribution. Outliers exist but don't change the message at all. I just wish the outliers would not always think people talking about the average or mean are trying to contradict them because everybody lives in a binary world, except for a few people who comprehend statistics and immediately think of distribution curves when they hear such statements, instead of binary ones, so they don't feel the need to point out "but outliers..." each time.
Do you think we will look back at this point in programming history when every tech blog post was accompanied by infantile GIFS as some kind of weird cultural phenomena? Maybe I am wrong, and these posters are actually very advanced five year olds who we should encourage :) (I can't comment on the actual content, which might be great, I didn't read the article, the GIFs made me throw up so I could not continue...)
* ~11 Years * In the beginning I wanted to be a game developer. Now my passion is backend and I mostly work as full stack developer * can't really pinpoint it on one thing. I just enjoy working at the backend part * Driver Programming. Complex Machine Learning stuff...
You made claims out of thin air, failed to justify any of them: \&gt;with growing complexity Angular becomes a better solution than others Then you start being openly hostile, because someone doesn't see your way. Since that someone doesn't see your way, means that person is incompetent: \&gt;This response just shows inexperience with Angular and some confusion with some concepts. Still failing to provide any justification for the claim made above. \&gt;Choosing React, Angular or Vue you always get locked in an ecosystem. When lying about certain libraries, maybe out of ignorance, but since you already tried to establish authority from competence here by trying to belittle others, I can only assume that you actually know and choose to say things which are false. \&gt;tech debt should never be an option, especially cause "just for now" becomes "forever" This is a slogan which sounds smart. However, tech debt not being paid is cause of missmanagement. Your common start up usually doesn't have good management so it's a pitfall. If you're working in a company which is steadily operating for more than 3+ years and paid attention to it's proceedures, incrementally improving, occasional tech debt it's not an issue. Ticket will be created and it will be resolved, while it will allow for feature to ship when needed. Basic agile. &amp;#x200B; &amp;#x200B;
I've noticed a lot of beginner questions about APIs on this sub so I thought it might be helpful. Obviously you can create and use APIs in any language, but with single page apps dominating frontend these days, any JS dev needs to have a solid handle on API fundamentals.
thank you!!!
Thank you for breaking this down. It's going to be easier this way. 1. JSX is a form of templating. It's not templating per se, as the resulting code is not markup. But while you work with it, it looks and feels like markup. I know it works as another primitive type, you can assign it to variables and pass it to functions, but you still get files with logic and presentation blended together. So while it's not templating, it still brings the same issues of mixing up presentation and logic. 2. JSX is a new technology only used by Facebook. A technology that has been around for 5 years is still new. It's kind of a paradox, cause at the same time it's old, but 5 years is not enough time to be mature. JSX was created by Facebook, I believe, as an attempt to bring their XHP extension into Javascript. XHP was a hack to introduce XML markup in PHP, JSX follows the same idea by introducing XML into Javascript. There have been many other libraries, languages and extensions that were quite when they were created, widely adopted and quite useful that were trying to mix presentation and logic. See for example XHP above, or XSLT. PHP in itself was an attempt at this. That it's popular now doesn't mean it's good, so I just take it as an experiment. It's cool so far, but I've seen it happen before. 3. Separation of Syntax === Separation of Concerns Totally agree. You don't need to use different syntaxes for different concerns. It sometimes helps, as you can have domain specific languages or languages specialized in certain tasks (like Matlab for math), but it's not required. My problem with the current iteration is that it's mixing different syntaxes in the same file. `&lt;MyComponent ...&gt;` is not Javascript, `padding: 1em;` is not Javascript. Regarding managing style in templates, there are better options. I keep the logic in my component code and pass a variable with the resulting style classes to the template. Logic in the template should be minimal, and JSX follows the same principle. You should not have much code in a code block, and make it as dumb as possible, in the same way that you should have dumb components and smart containers, but you should never have smart JSX pieces. 
Like a lot of devs, I used to spend a lot of time carefully naming things. But it's better to think of it like English. There are plenty of different ways of describing things that all work. As long as you make an effort at accurately describing what something is or does, I've found the code is readable when you come back to it later. Getting obsessive about word order has almost never helped me understand code later on. But as a very loose rule, going from general to specific will keep similar variables together if you sort alphabetically. Far more importantly is to actually use your English to document your variables. A variable name is an abbreviation. kitchenChair works great when there is one chair in the kitchen. So at least leave a note for yourself that "kitchenChair is the red wooden tall chair made by Ikea (sticker underneath) that was purchased by David in Nov 2018 and is only ever used as a stepladder. If you use it as a chair you might be sitting on shoe dirt." You can't put all that in a variable name. But one sentence like that does wonders at jogging your memory when you come back to code six months later and there is more than one kitchen chair now.
i wanna be a node dev!!! so learn HTML then CSS then javascript then node.js?
The fact that it's a Proxy might only cause performance issues when you're in the thousands/hundreds of thousands ramge of compnents. 
I wonder when the first website completely written in console.log will be released.
Not my thing either. Elixir was such a breath of fresh air for me after spending years in state and inheritance hell.
1) 30 years 2) kinda, I'm doing something that could be a game with some small changes. 3) it‚Äôs still fun and has a lot of user-centric programming (I'm also very interested in user interaction design), but isn‚Äôt as abysmally badly paid as pure game development. 4) high reliability software for airplanes and spacecrafts
Nice one! `console.table` and `console.group` are two other helpful ones when it comes to organizing the data in the console!
This is awesome. 
Sorry for making you feel bad. Will try to do better next time. I'm just starting and I know that there might be some mistakes to fix. Anyway, advice has been noted.
[removed]
Not to mention that I wanted to avoid forEach() altogether.
Yep, phenomena. I used to have the same feeling some time ago, but the more of them I saw, the less annoying they became for me. But there's truth to your words. Maybe images might be better way to express some ideas. As for emojis - I don't think they are as bad as GIFs ü§î
The client would ask the server upon reconnection
It is cool you are writing articles! Glad you are taking the criticism positively, with this attitude you will reach all your goals and win.
Now I can console.log() debug with style!
&gt; with growing complexity, Angular becomes a better solution than others This is more a matter of personal preference, I guess. Vue or React don't have a concept of App as such, an all knowing entity that aggregates and coordinates everything while Angular does. It's possible to build apps without such an abstraction, but for me it is better to have it. &gt; This response just shows inexperience with Angular and some confusion with some concepts. Sorry about this, it was late at night and your first response didn't sound justified, just being dismissive. Some of your statements don't correspond with my experience with Angular, they were just common complaints that are unsubstantiated and anyone with experience using Angular wouldn't use. On top of that, you put together Flux, OOP, DI and MVC which all are completely different categories of things. &gt; Choosing React, Angular or Vue you always get locked in an ecosystem. How is this a lie and belittling? Each library/framework has its own ecosystem. You can generally mix and match things, but stepping outside your ecosystem always makes things more difficult. I agree that React and Vue are more flexible, they are just libraries and not frameworks after all, but you will always find that certain things work better or more easily than others. &gt; tech debt should never be an option, especially cause "just for now" becomes "forever" I've been working in development for nearly 20 years now and I have worked for big companies like IBM and EY and small startups, as a freelancer and as an employee. Technical debt is always there, no matter how big and established the project is. There are always parts of the code that no one dares to touch because it was written by an employee years ago and no one really knows what it does, just that it breaks when you remove it. There are other parts that are just unmaintainable, they aged poorly and became blobs. There are quick fixes that never get looked at again because people forget or there is never time to go back to that (it works, don't touch it). So yeah, in an ideal world software projects go perfectly well and there is no technical debt because we pay it. In reality, this is rearely the case, no matter how good the company is. And lately it's become even worse, as people believe that agile is about skipping documentation and planning and it's just keeping people stressed out fixing tickets.
Some updates in form components for Vue [https://github.com/antonreshetov/vue-form-components](https://github.com/antonreshetov/vue-form-components)
Release a free email signature generator [http://mysigmail.com](http://mysigmail.com) Stack: * Vue * Vuex * IndexedDB &amp;#x200B;
I thought CNN does something in their console?
I know [console.info](https://console.info) console.table [console.group](https://console.group) but this shiny experiment was fun. I will try this for organizing data in my next personal project.
Fair enough. However after their change in policy regarding its side, and it‚Äôs extremely vibrant open source community. I think one could make the argument that React has gone a bit past facebooks clutches
That's kind of true. They are both highly controlled by the companies behind them (think for example the controversy about GraphQL) but when I think of the React community I don't think of Facebook, while I do think of Google when I think of Angular. Funnily enough, React was built by Facebook, while Angular was "bought" by Google. ¬Ø\\\_(„ÉÑ)\_/¬Ø
You can‚Äôt think for yourself? I wouldn‚Äôt even think about hiring if you‚Äôre worried about ‚Äúkilling‚Äù an assessment. Maybe if you actually knew the language you wouldn‚Äôt have to ask internet strangers for help?
I have to ask, keep seeing people coding with emojis, is this a Mac thing? Or can you do it in other os?
You can copy/paste an emoji directly into source code and use it in a string. I generally use https://emojipedia.org/ to find/lookup emoji and then copy/paste it to where I need it. At work we use this in the console (like in the article) but really they can be used most anywhere these days. It's more of an issue of the OS of the consumer and whether or not it can properly display emoji.
I would first skim through [You Don't Know JS](https://github.com/getify/You-Dont-Know-JS) and make sure you are confident with the edge cases for stuff typically used to test depth of knowledge around JS: `this`, prototypical inheritance, closures, etc. For React it might be helpful to have to have [this image of the React lifecycle](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/) memorized. Others will hopefully comment with more specifics and when you've finally brushed up on everything you have time for, do yourself a big favor and find a friendly ear to try to explain some topics to **aloud**. When you try to teach / explain something to someone else, you'll quickly find out what you missed when brushing up. And you will definitely have missed some stuff. We almost always convince ourselves we have learned something before we actually have it nailed. Make sure you are prepared for *what to say when you don't know something*. Please don't try to fudge it. It's an automatic no-hire for me if you try to pretend to know something you don't know. Have something like this ready to say: "I only know a little about that and will probably get it wrong, but I can try to explain it if you'd like me to try. Either way, I'm very interested in learning if there is someone here who could mentor me and I could actually learn it on my own if needed. I love learning new stuff!". You just demonstrated: 1. You are honest. 2. You are willing to try even when you don't know. 3. You are enthusiastic and ended on a postive note. My apologies if this is already obvious to you, but I've seen it so often in interviews I felt like it's worth mentioning. &amp;#x200B; &amp;#x200B; &amp;#x200B;
It is really nice ! Tried it on my iPhone in Safari. It would be cool to be able to horizontally scroll the datatables even when they are focused.
I've been saying this to my students. Code is like Legos and logic puzzles. 
It‚Äôs easier on a Mac because you have a built-in virtual emoji keyboard.
What about you?
Windows also has it, try Win + . ü§ò
The issue is that I'm really curious why this doesn't work. Seems like i'm missing something conceptual about rxjs and wanna know whats is it.
1. 21y 2. software dev 3. I really like frontend development, and give people a nice UX/UI. Like to brainstorm about products as well 4. I think complex algorithms which could be from low level network protocols to complex AI software. &amp;#x200B;
Emojis are part of Unicode
Does point two really work?
If you wish to "whip out code faster", the best way is using AutoHotkey. Check out the 'hotstrings' functionality. There's no going back =)
On Windows 10 you can press Win key and period (.) combination to enter emoji mode: https://blogs.windows.com/windowsexperience/2018/02/05/windows-10-tip-get-started-emoji-keyboard-shortcut/
Yes, AngujarJS sucked. The new Angular is so different and beautiful that should have received a new name. Google messed up that.
Sorry, which is point two? I'll be happy to go into more detail.
I just released a small CLI tool to help a fellow lazy prettier maximalist initialise prettier in new/legacy repos: [https://www.npmjs.com/package/be-pretty](https://www.npmjs.com/package/be-pretty) [https://github.com/capaj/be-pretty](https://github.com/capaj/be-pretty)
The way you put it was like a general fact statement rather than what you prefer working with. Although I guess sometimes I can be too unforgiving and not acting under the principal of charity that is assuming the best of intentions as a default. &gt; Some of your statements don't correspond with my experience with Angular Well, I can actually name you quite a few exact examples if it's hard to believe. The problems usually arise due to compiler pointing to some Angular iternal receiving invalid value. I'm yet to encounter an error in React which would fail to indicate where exactly the problem is in my code. &gt; Each library/framework has its own ecosystem It has but it remains optional. You don't have to bring entire ecosystem when you don't need it. Or you can actually swap it for something else. For example, you are not forced to use Vuex for Vue, you can use Redux. You don't even need special kind of bridges for it to work. For angular, you need to go extra to integrate. I gave you an example with WebComponents because `customElements.define` doesn't freaking work out of the box. We are talking about core, browser native technology not working out of the box. Sorry for expression, but what the actual f*** ?! &gt; On top of that, you put together Flux, OOP, DI and MVC which all are completely different categories of things. My problem with Angular is that it tries to hold onto back end development way of doing things, repackage it and export to front-end. And turns out, it's not a good idea. Did Angular improved and rejected some of it's design concepts through the years? yeah, they did. However, it's still remains hostage as it can't simply reinvent itself from ground up. And I don't think that it has a future. By future I don't think that Angular way will be carried over to other tools and technologies as much as React. Again, I point to Stencil, most recent Ionic undertaking. &gt; So yeah, in an ideal world software projects go perfectly well and there is no technical debt because we pay it. Yeah, I know. But if you would analyze the big problematic parts of your entire software system, the unrepaid depth is usually inherited from the times until the right proceedures where even conceived. To actually orchestrate software development and rapid pace isn't easy and wasn't been done somewhat successfully until recently. Even languages themselves didn't really allowed for that or even tools we use. Like huge chunk of "good practices" aren't even related with software itself, but IDE support. As for tech debt. Well, sometimes it's really just lazyness. But other times, like if you work in fintech and you have to meet criteria of law regulators like, by the next month, you simply shit fix whatever you have, create a ticket documenting the case. Doing major refactoring on the rush is even worse than contained shit fix tech debt which gets the job done. 
Ah, that makes sense. Thanks!
In addition to the Windows Hotkey, on Mac you can hit ctrl command space to open the emoji keyboard 
Generated one signature and it works great. One little thing would be to allow the customization of the alt attribute of the base64 image. [Mail-tester.com](https://Mail-tester.com) gave me a -0.5 because of that. 
I stopped at "level up".
someone should inform the author about template strings.
emojis are unicode so you can just copy / paste from getemoji.com 
I've been programming for decades and I constantly ask for help. It's called brainstorming, using the power of the crowd. Even a junior programmer sometimes has something new for this old guy to learn from. Stop being so anti-social and give it a try. You might learn something you would have never thought of on your own.
The asking about a mentor thing.
 **üì∑**[**r/javascript**](https://www.reddit.com/r/javascript/)‚Ä¢Posted by[u/roecrew](https://www.reddit.com/user/roecrew)[32 minutes ago](https://www.reddit.com/r/javascript/comments/a23qyf/return_exkited_is_up_to_110x_faster_than_marko/) ## &lt;@ return `Exkited is up to 110x faster than Marko`; @&gt; üì∑ # Exkited ‚åØ easy ‚åØ fast ‚åØ minimal [https://github.com/roecrew/exkited](https://github.com/roecrew/exkited) \- 2 Stars [https://www.npmjs.com/package/exkited](https://www.npmjs.com/package/exkited) \- 237 Downloads This project is in development. If you have any suggestions or want to contribute to the project -- please leave a comment. &amp;#x200B; |Exkited|0.245418ms|0.257525ms|0.180703ms|0.225784ms|0.249669ms|0.26437ms| |:-|:-|:-|:-|:-|:-|:-| |Marko|19.833425ms|11.833084ms|12.146531ms|19.636367ms|22.645764ms|12.801573ms| |Pug|14.413408ms|21.414837ms|22.678451ms|26.420134ms|30.833197ms|22.386204ms| |EJS|49.199359ms|63.359911ms|56.826597ms|56.831579ms|51.514282ms|50.241439ms| &amp;#x200B; Exkited has crazy fast rendering times compared to some of the most popular template languages. However, it must be stressed that the above test ran single template files. The output for them was 50001 nodes. Each node held a text node with the current value of increment (loops were used). You might be wondering... "What's the catch? Well... Like any langauge, there are pros and cons. Exkited is not perfect (yet). &amp;#x200B; PROS: Exkited will nearly always be the fastest template language. This is because of "Smart Caching". Essentially, Exkited template construction is dependent upon changes in input data. For example, let's say we have five template files. One is home.exkited. Two is header.exkited. Three is section1.exkited. Four is section2.exkited. Five is footer.exkited. The home.exkited file contains four include(...) for the other four templates. Furthermore, let's say that section2.exkited uses some input data that changes occasionally -- how about the price of gold. And the price is fetched/stored every five minutes.This means that every five minutes both home.exkited and section2.exkited will have to be reprocessed. "Smart Caching" is what makes the Exkited Template Language so fast. &amp;#x200B; CONS: There is a certain downfall; however, it is highly unlikely to occur. Let's imagine a slightly different version of the last example. The price of gold is now fetched/stored every one second. So far this wouldn't be much of a problem -- Exkited rendering would still be wicked fast. Next, let's say the gold price data that's passed into section2.exkited isn't just used only a couple times, but 100,000 times! Why someone on Earth would do this... who knows. If it were to happen, Exkited's render time would then be slower than Marko's. Just keeps things reasonable.
Doesn't have to be from the touchbar. Can also use `ctrl + cmd + space` to pull up an emoji picker
Hi /u/Cloud_Strifeeee, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Thanks for your understanding.
Hi /u/gettintipped, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/Moonstorm0725, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/mhycc, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/Sad_Homework, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/One_Whole, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Please put it in your own words, but sure, I've chosen those words specifically and carefully because they are packed with a lot of positive messages. Now the interviewer knows you're willing to learn from others on your team. But the main point is to just show your enthusiasm and to be sincere enough about it that you aren't just trying to make the interviewer happy. Someone who asks if there is mentor available on that topic is clearly interested in taking the next steps to learn rather than just trying to brush of the question and move on. And it also forces the interviewer to visualize you being trained by one of the senior programmers. Act like your interview is just the first day on your new job. I hope that helps.
OS = Operating System OSS = Open Source Software 
Nice break from the usual medium, ‚Äúzomg, did you know there are more methods on console than log???‚Äù
I had always thought a game that is partially a website and partially in the console would be cool. Couldn't think of a decent story except maybe some evil corp is kidnapping programmers and they only way they can communicate is through the console and hidden messages on the site. Actually in my concept of the game its a series of sites like an ARG but I can have whatever crazy concept I want, cause I'm probably never gonna do it.
Do you know about `apply`,`call` and `bind`???
Ah the weekly console.medium() post that only copies this one Google developers help page. 
It's like Groundhog Day!
Thank you.
Yes, and because somebody's chain smoking grandfather lived to &gt;90 smoking does not kill you. I said "probably" because most things are on a probability distribution. Outliers exist but don't change the message at all. I just wish the outliers would not always think people talking about the average or mean are trying to contradict them because everybody lives in a binary world, except for a few people who comprehend statistics and immediately think of distribution curves when they hear such statements, instead of binary ones, so they don't feel the need to point out "but outliers..." each time.
Nice work! I noticed that when using the Chrome Dev tools and switching the viewport to phone/tablet that I was not able to drag the window components around. However, normal click events worked. Not sure if this is an accurate representation of what a real phone or tablet would experience though. &amp;#x200B; Keep up the awesome work. Hopefully I'll be able to do something this complicated in the future. Thanks for making it available for others to look at. :-)
[removed]
I applaud your persistence, even if I don't understand it at all.
# [Tagify](https://github.com/yairEO/tagify) I've created this Tags Vanilla Component out of necessity at the time, about 2 years ago, because nothing on the web was in lightweight yet flexible enough for my needs/taste. so here it is, after much evolution and many closed-issued. ### Vanilla JS / React / Angular * JS minified ~17kb (~6kb GZIP) * CSS minified ~5kb (~2kb GZIP) - well-crafted flexible code * Easily customized (SCSS, tags templates, etc.) * Easily change direction to RTL via the SCSS file only * Supports mixes tags &amp; strings (ex. tagging people in comments) * And many more goodies! 
A couple of unrelated ideas. 1. Please, for your own good, whenever you have a static link, like the one for the Github repo, do make it an **actual** link. Use `target="_blank"` if you want to. But using `window.open` for that kind of link is not a good idea and many people have it blocked. 2. When you post your link here, **make a link post** and then, if you feel the need, write a comment. A comment post just to copy and paste the blurb from your site is annoying. 3. When you throw a benchmark onto a table, here or in the page, put some meaningful names on each column. What are those numbers? Is the test run six times? Are there six different tests? What does each column mean? 4. Strangely, some tests seem to go back in time sometimes and render in negative time. [See here](https://i.imgur.com/fV7zdym.png) or [here](https://i.imgur.com/4GZ7j9R.png). But even more than that, the tests seem to offer **wildly** varying results. EJS will sometimes take ~50ms and others ~130ms. Marko will sometimes take ~12ms and others twice that. Pug results don't seem to fluctuate so much. In any case, both of these together largely undermine the confidence on your tests. They feel random and rigged. I'm not saying they _are_, just that this circumstance makes it feel so. At least they appear _unreliable_. 5. From your explanation, it feels like you've "just" implemented a cache. If so, does that warrant making a whole new template renderer? Isn't the benchmark intrinsically unfair as Exkited is not really rendering most of the time? Couldn't you just implement a similar cache on top of any or all of the other solutions?
If I `apply` a `bind`to my penis, I make a loud `call`.
I see. This is intended. The view port of a window is not scrollable. But you could put a scrollable div which has 100% height and width in the view port, and if you put nested window in that scroll view port, you will be able to scroll a bit to obtain that partially off screen window. The reason the window's view port is not scrollable is that the docker bar would be floating around if it would view port would scroll.
Hi there -&gt; Hello there!
Really helpful. Thanks!
Thank you for the feedback! &amp;#x200B; 1. Noted 2. I guess it's annoying. The site is only a day old. 3. Very good point. 4. I'm still trying to figure this one out. app.post('/benchmark-exkited', *function*(*req*, *res*) { *let* start = process.hrtime()\[1\]; res.render('basic.exkited', {}, (*err*, *html*) *=&gt;* { res.send({ name: 'exkited', time: (process.hrtime()\[1\] - start) / 1000000 + 'ms' }); }); }); app.post('/benchmark-ejs', *function*(*req*, *res*) { *let* start = process.hrtime()\[1\]; res.render('basic.ejs', {}, (*err*, *html*) *=&gt;* { res.send({ name: 'ejs', time: (process.hrtime()\[1\] - start) / 1000000 + 'ms' }); }); }); app.post('/benchmark-pug', *function*(*req*, *res*) { *let* start = process.hrtime()\[1\]; res.render('basic.pug', {}, (*err*, *html*) *=&gt;* { res.send({ name: 'pug', time: (process.hrtime()\[1\] - start) / 1000000 + 'ms' }); }); }); app.post('/benchmark-marko', *function*(*req*, *res*) { *let* start = process.hrtime()\[1\]; marko.render({}).then(() *=&gt;* { res.send({ name: 'marko', time: (process.hrtime()\[1\] - start) / 1000000 + 'ms' }); }); }); &amp;#x200B; 5. Intrinsically unfair. Ahhhh noooo. It's an improvement over other template languages. "Couldn't you just implement a similar cache on top of any or all of the other solutions?" Ahhhh yeaaaa. What's your point?
Because feedback loops are good? Code reviews and other forms of feedback exist for a reason.
I usually use this list, it shows what each is on every OS https://unicode.org/emoji/charts/full-emoji-list.html
&gt; `process.hrtime()[1] - start` It looks like you're not using `hrtime` correctly. Use this instead: let start = process.hrtime(); // then later... let diff = process.hrtime(start); // and then... diff[1] // if you expect this to take less than 1 second, or diff[0]*1e9+diff[1] // if you expect more than one second 
wow. Now i've learnt the most useless shortcut on windows. Thanks appreciate that 
Thank you!!!!
Instead of an image, actually copy and paste the code. Or better, put it up on codepen or jsfiddle so we can see how it fails. 
You can use `while` or `do`. But seriously, you can't iterate array elements without using an array method, or the most basic thing: looping.
Expressions and the like!
I think it should be done. The problem is probably in some other part of your code. A js fiddle would be great, we can‚Äôt really tell you more based on only that screenshot.
Lol, nice one!
I didn't want to avoid loops, I wanted to avoid invoking new function for every iteration.
This is funny
For the for-of-loop, naively that's not any fewer function calls because it's using the iterator protocol under the sugar. But I'm sure the browser optimises it into an index-based for-loop for arrays, so it's probably best.
Your snippet doesn't create a new function for every iteration
I literally never would have found this without your comment. Thank you kind stranger.
I'm glad you asked! Many different interesting engineering techniques can make a transpiled js faster. Let's take a concrete example! Imagine the code to be transpiled has a function like this: if(process.env.DEBUG_MODE) { // do something expensive } else { // do something fast } When you transpile with Webpack, you can tell that process.env.DEBUG_MODE is always false. The result of the transpilation will be: if(false) { // do something expensive, but it is now dead code. } else { // do something fast } Webpack will notice that there is some dead code, the block will get removed, so are all the functions used only by this block, so are all the imports and so on. Less code to parse, to include, to execute. Webpack bundles a lot of those techniques. I hope I convinced you that transpiled code may be faster than the original code, especially when you limit its possibilities. So now you should be able to grasp why transpiling Webpack with Webpack can produce you a transpiled, smaller, faster Webpack. That's what Zeit did and it's super cool.
Man that is a good idea. Your ideas are good. I‚Äôm a web dev so I could put together something like this. Though I have a thousand other obligations so I probably won‚Äôt ever do it. What we really need here is an investor.
Maybe I'll work on fleshing out some of the details. I'm in the same boat as you. Got the ideas, got the skill, don't have the time. 
Not sure about CNN (I'll look later) but a lot of websites have fancy XSS warnings to cut down on social engineering attacks.
There's a few puzzle sites where you have to investigate console and the source to get to the next puzzle. They're pretty interesting.
Thank you so much, I can't believe I never knew that! üèÜ
Congrats on your first npm package! But is dynamically creating a bunch of global variables on `window` really "a modern approach toward configuration which promote sound development practices"?
Specific to General, if it works with an image then put image first so that in a year when you're trying to remember what the name of that function was that does the thing with the image you can just look for ones that start with image. Whereas looking for ones that start with small will take you all over the domain
Then use `while` or `do` loop, if you don't want to use `for`. If you don't want neither, then it means that you don't want to use any loop.
If you take the advice of never setting up your own auth, then also never set up your own server stuff either. I was the same as you and wanted to learn everything before jumping onto frameworks/libraries, but even once you know it you should move to express because they've taken care of the hard stuff and it's a light framework as well so there's not too much abstraction. It just takes out some of the pain points. That being said, you're gonna need a database and you can encrypt passwords with something like argon2. To get started MongoDB is fine ( i also started with this) but something like postgresql could work great too with something like typeorm or prisma if you wanna do graphql stuff too.
Looks really cool! I would add a github social link.
I'd start with getting a strong navigation, where one can orient themselves.I'm super lost when i land on that link where i am. And there is some sort of arrow navigation which i've never seen. Seperate out some type of identity of the site, so i know what the site's purpose is, and then what purpose of this page is. Get inspiration from sites which do both of those well. Here is an exercise to know what i mean. * Go here: [https://alistapart.com/article/whereami](https://alistapart.com/article/whereami) * read * click "Topics" at the top * under "User Experience" * click "Information Architecture" * read any of those articles
Thanks. I see. I understand your point. I have been struggling with the resizing of the data table for quite some time. Now my strategy is to expand the whole data table frame and not allowing horizontal scroll bar. I was thinking if the horizontal size needs to be fixed, we can put the whole data table frame into a fixed width scrollable div. But I understand your point. What you said is better and more natural. I think I will improve it as what you said.
Thanks. I can reproduce the same problem. And it seems it takes a refresh after I switched to phone/tablet view for the drag to work. Not sure it happens the same way on your environment or not.
Nice project. You should try making the app responsive. I had to check it out on my laptop because it wasn't usable on a phone. 
It is creating a stack frame for every call. Every call new scope is created and initialized.
I don't think you'll notice it on 3 iterations ;)
Seems pretty useful :)
Remove () from your function in the HTML - &lt;input onchange=‚ÄúyourFunction‚Äù&gt; Let me know if that resolved your issue. Already browsing in the web on phone but tomorrow morning, I will post here another comment with alternative solution with cleaner code to your problem. Have a good night, OP. 
You‚Äôre in the JavaScript subreddit, I think everyone here is probably a developer of some sorts... üòõ
Wow you‚Äôre right. I probably sound so pretentious.
 fixed(small(image))
Hello, I tried your method but unfortunately it doesn't fire the function. Its only when i include () it invokes the given function. Thank you for your reply and good night. I hope i am able to solve this tomorrow somehow. Its been bugging me from yesterday :/
To be fair, though, English might not be the language of code forever. Maybe Spanish will takeover or something. Point being, I was just thinking BEM might be a more universal approach.\`
Actually, Less isn't the problem‚Äîit's mostly graphql right now that's bugging with me. My Less files are all broken up into small enough components that I don't need BEM.
I do, it's graphql that's the problem.
1 single call: `console.log(['prev', 'exit', 'next'].toString())` Oh yeah!
You are looking for the [blur event](https://developer.mozilla.org/en-US/docs/Web/Events/blur). It happens when an element looses focus on a page. The [change event](https://developer.mozilla.org/en-US/docs/Web/Events/change) has the unfortunate effect of running whenever it [appears appropriate](https://developer.mozilla.org/en-US/docs/Web/Events/change#Description). Just keep in mind that the user can deselect the input without having changed the value before submitting the form.
I was thinking more about this, and a slightly different way to approach it would be "most to least informative"‚Äîaka, order by which words tell you the most about what the thing is, and think, "If the name ended HERE, how much would I know about what it is?" For example, "fluid" doesn't tell me anything about what the variable is. However, "image" tells me a lot. 
I can't think of any major language that isn't natively in english the chances that it switches to spanish is so incredibly unlikely as to not be worth considering.
Sounds like you need to be sending a history of events, where an event could be a new message or edit or whatever else. The event stream should be immutable and seekable from an arbitrary
Windows key + ";" on win 10 machine to pull up the emoji picker btw.
I created a Forrest Generation Cellular Automata: [https://bitbucket.org/liamilan/forest-generation-cellular-automata/src/master/](https://bitbucket.org/liamilan/forest-generation-cellular-automata/src/master/) This program uses cellular automata to grow two dimensional, semi-random, tree like structures. The demo shows how it can be used for landscape generation in an interactive scenario. The node.js interactive demo runs in your terminal. The tree generation algorithm itself is provided in both node.js and python. &amp;#x200B; Let me know what you think!
Hey, I couldn‚Äôt fall asleep so I made this small demo for you with solution. https://codepen.io/marovargovcik/pen/MzLVXz I have iPhone 6 and I was experiencing the same behavior that you described and reason for it is - You are listening to change event - whenever input value changes fire your function and as the result form is submitted and page refreshed. Safari is setting input‚Äôs value to today date as soon as you click on your date input. This is causing your function being fired, form submitted and you being redirected (page refreshed in other words). Safari is also firing change event when you are scrolling of each day/month/year field eg. swiped from first day of the month to 2nd day of the month - your selection is interrupted because form is being submitted. I would suggest you using the blur event which is triggered when input lose its focus. In other words when iOS user press done button. My Codepen example is using this approach. One more thing unrelated to this thread. I do not recommend parsing date manually as you are doing. Your users may not have the same locale as you do and therefore your date parsing procedure would be incorrect. You are expecting that incoming date will be separated by dashes. There is a lot of other formats. Instead I recommend using timestamp and sending this timestamp to your backend server. Your server will then parse received timestamp to whichever format it needs. My Codepen example demonstrate this technique. I hope that this will be helpful. Let me know if you managed to solve your issue and how :) Happy coding. 
Why bother casting to a string? Most environments at this point will happily render it out.
This sounds like an unecessary micro optimization. Most environments have sufficiently sophisticated JIT compilers that your for each will be effectively equivalent to a for loop.
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), ‚Äúnobody‚Äù starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
This was very insightful! 
thanks. Still interested to hear news when you are done.
..... you do realize you just gave us your private IP and that no one other than you can do anything with this, right? üòõ
I'm an idiot, what's worse is I did it on a whole mother thread too
I'm ashamed of myself lol
Nothing to do now but delete this, followed by your account, then cancelling your internet and phone plan and hide in a cave for all of eternity! üòÇ
Way ahead of you lol
Code?
As cool as this looked, I scrolled through this pretty quickly because I thought it would be useful. Now I know aside from console.log, console.table and console.group are the best to use. 
I am a little saddened you got downvoted for this. I completely agree with your post. I think they are all well designed tools. Jest was originally quite different before it turned into its modern "painless" form. Even then, it was proudly built on top of Jasmine and only later started changing its APIs to evolve away. I think that Jasmine and Mocha still get the job done quite well. Obviously Jest brings convenient features, but it is possible to bring snapshots or anything else into the others if desired. e.g. https://github.com/bahmutov/snap-shot-it Don't listen to hype or bandwagons, focus on your problem and whatever tools help you deal with it most easily, whatever they may be! :)
I‚Äôd assume this quiets all the kvetching over not hitting Chroma &amp; co up privately first. Good to see the situation is progressing in a positive manner now. 
i thought i had a stroke
Might be helpful if you can provide a sample project to illustrate how to use your framework
good bot
Make a snippet. 
I think [this](https://marketplace.visualstudio.com/items?itemName=npacucci.bacol-snippets) is exactly what you're looking for. Never tried it myself, though..
``` "Anonymous Arrow function": { "prefix": "aaf", "body": [ "(${2:(${3:parameters})} =&gt; {", " $4", "})(${1:arguments});" ] }, "Arrow function": { "prefix": "af", "body": [ "${1:($2)} =&gt; $3" ] }, ```
Are you a NodeJS developer?
I'm still learning and can develop REST API backend to perform CRUD on mongodb and postgresql. I want to prepare myself for all the questions in order to get a better job. 
We always ask at lease one trick question to see of we can trust the developer. Like ask him how long it would take him to do (insert near impossible task)? A good developer would know that the task is near impossible to be complete by just one person, and will tell us that. While a inexperienced developer would maybe know its a lot of work but think he may can wing it and comes up with one crazy short timeframe and we would known she/he is not right for this job, it works everytime, and other questions to see of she/he is a good fit for our company and team. Most of the time we invite them back for a 2nd interview after and give them some task to complete to test their skills but never in the first interview. Not sure what others do I can only talk from my experience.
We always ask at lease one trick question to see of we can trust the developer. Like ask him how long it would take him to do (insert near impossible task)? A good developer would know that the task is near impossible to be complete by just one person, and will tell us that. While a inexperienced developer would maybe know its a lot of work but think he may can wing it and comes up with one crazy short timeframe and we would known she/he is not right for this job, it works everytime, and other questions to see of she/he is a good fit for our company and team. Most of the time we invite them back for a 2nd interview after and give them some task to complete to test their skills but never in the first interview. Not sure what others do I can only talk from my experience.
Can you give us an example or two of those types of "near-impossible" tasks?
Not unless you say you only use him for coding
I also want to know those tasks. And what are those must done/completed projects that you expect from a developer before she/he applies.
I also want to know those tasks. And what are those must done/completed projects that you expect from a developer before she/he applies.
Also right click &gt; emoji on any text input field
oh ok sure I can add questions from my previous posts on reddit as well which were describing react and javascript interview questions
Lmao
Haven't checked Wikipedia's API in a while, but it would be more useful if it could be done programmatically, a la: let summary = await hovercard.get("Stanford University")
You should be prepared to explain the event loop
Thanks, that's useful af!
Oh but I do 
What's your preferred way to manage dependencies and why? Do you ever use a transpiler? Why or why not? When writing a web application, what is your preferred bundling solution and why? What are some annoyances you have with the current ecosystem and tooling? Stuff like that. Open ended questions with no correct answer that give the candidate an opportunity to tell a story about the kind of engineer they are. 
I want to apply for nodejs developer position but I have only implemented few CRUD apps using MERN stack. How can I learn advance stuff in nodejs ? If possible can you name few concepts which I must learn in nodejs. 
Great idea! 
Add some GraphQL knowledge to that and it would help. Know your promises and async/await syntax. Know how to query JSON/JSONB columns in Postgres. Have a project showing some CRUD implementation. I actually skipped the coding part of the interview for my current job because I had a project similar to what they wanted me to do, but written with NodeJS instead of PHP which at the time was the most popular language. 
Thanks for the feedback. I have plans to make it responsive. Although initially I don‚Äôt quite understand why, as it is more convenient to use on the desktop version, since then you need to copy the signature and paste it for example gmail
Technical portion of node interviews I conducted eventually collapsed into a single question: &gt;You have an array of writers with ids and an array of books with an author id: const writers = [{ name: 'Hemingway', photo: '/old-ham.jpg', id: '1245', }, // ...100 more { name: 'Cortazar', photo: '/cortazar-at-un.jpg', id: '62' }]; const books = [{ title: 'Fiesta', authorId: '1245' }, // ...1000 more { title: 'Hopscotch', authorId: '62' }]; &gt;How would you make an array of books with embedded author data? { title: 'Hopscotch', author: { name: 'Cortazar', id: '62' } } This is not a trick question ‚Äî doing manual joins is one of the most common mid-back-end tasks. It also immediately shows wether the candidate knows a bit about complexity and data structures, which are good to know for a back-end developer. The optimal solution is linear, the obvious one is quadratic, the sort-based options are worth exploring. 
Thanks for the feedback. The fact is that the img tag is not used to set the image, it‚Äôs just a background image div
I ask a range of questions from NodeJS related stuff, previous projects and experience, what they want to work on, Linux knowledge because that's very important to us and finally security and networking. I'm not expecting a sysadmin level of knowledge on the last ones but basic knowledge for debugging and deployment is an absolute must. Also security wise he should be able to: prevent various injection attacks, prevent XSS attacks, know how to securely hash, salt and store passwords (bcrypt is my fav here) and in general be able to build a relatively secure application
Do you mean the icon in the Social media links section?
Do you mean the icon in the Social media links section?
Optimal solution should be "fix your SQL query to join that data".
Can you quickly outline the linear solution, please?
Hire a Node.js developer for what exactly?
Solve the halting problem?
Good point. But like I said I wanted to check out your project but couldn't because I was using a phone. Maybe you could add a feature that allows users to save the signature as a file or have it mailed to them. 
My guess would be to move the authors into a map with the id as key and then iterate over the books and replace each of the authors with the lookup from the map. As map lookups are O(1) this can be done in One(n+m).
I would reduce writers into an object, where keys are their ids, then map over the books and insert the author info based on the id. 
Create an object (i.e. lookup dictionary) of writers by ID first. Then `map` through `books` and replace `authorId` with `writersLookup[authorId]`.
I‚Äôd maybe try and ask about some limitations like threading and process management and then some fundamental JavaScript stuff like closure, lexical scoping, higher order functions and hoisting etc.
I don't think that exactly qualifies according to /u/RangerCoder's description.
I like to ask about promises and async/await. Junior devs often have general idea correct, but they misunderstand details. Like why it's pointless to write "return await promise" for example.
Those can be good frontend questions as well. 
"Don't worry, you can bill the client while you get up to speed"
What is this?
Yeah.
Yes, that's also a welcome question. However, you don't always get data directly from a database ‚Äî consider an API gateway that queries HTTP services.
Well it removes the brackets so it looks more like printed values. üò∂
You put the writers into a hash map (in JS, either a `Map` or an object). Constructing the map of authors takes `O(A)`, a lookup is `O(1)` for every book, `O(A) + O(B)` total. It's not very strict given the engine's polymorphic map implementation (also hash collisions and transpiled Map), which makes for great follow-up conversation.
I love reading these threads, being reminded that I'm an idiot. Welcome to the real world.
Sort the writers array by id. Sort the books array by author id. Traverse the writers array from the top. You'll take the first writer. Then you take books from the top until the ids no longer match. Then you take the next writer. You can manage it with two pointers. 
Not the OP but maybe something along the lines of building a complete application completely from scratch without using any libs of frameworks (maybe justify it quickly with some security I'm especially with having an npm disaster every few months). This would require enormous amount of work on both client and the server, including knowledge of security concerns and setting everything up regarding hosting, deployment, dev ops... While still keep the project readable and maintainable. I don't think a single person can manage that unless they're a genius. It goes well with OP's "but seems possible", because it should be obvious that in theory there's nothing impossible about that and that building a hello world demo alone is doable, but a more experienced developer should know it would turn into a nightmare. 
However, general sorting is \`O(N \* log(N))\`. Still a good solution since it can be done in-place.
Make sure to not make beginner mistakes like using `let` when a `const` would be enough. To me this usually shows that you don‚Äôt understand the difference and it‚Äôs very easy to avoid. Same with arrow functions/normal functions and implicit returns etc.. And to ensure consistency in your homework task, using a tool like prettier is a good idea. Knowledge-wise, I‚Äôd also learn devops/architectural stuff like why, where, and how to use a reverse proxy, Docker, basic SSH, etc.. If you have any GitHub projects, make sure that their readme is useful, readable, and feee from errors. It‚Äôs 90% of what people see in their first impression.
Done :)
Why is it though? Does it not wait if you‚Äôre returning it? Or should you generally just use that beforehand?
should work fine. css fonts tend to be based on css classes, font-family, and/or explicit textContent or via :after/:before pseudo elements. Even the psuedo elements use content: "whatever" property so theoretically I'd expect those would translate as literal text content. try textContent instead of innerHTML though I can't imagine that would be a difference.
Async/await is basically a wrapper around a promise, so returning an awaited promise is redundant.
Oh yeah I get it now thanks
&gt; Make sure to not make beginner mistakes like using let when a const would be enough. To me this usually shows that you don‚Äôt understand the difference and it‚Äôs very easy to avoid. Same with arrow functions/normal functions and implicit returns etc.. As someone who has done tons of interviews, I really don't care about this at all. Maybe some people care about this but I like to see how they attempt to solve a problem. Little things like `let` and `const` and arrow functions are all things easily changed.
Sure, but they show that people aren‚Äôt that experienced yet. It‚Äôll be hard to find a senior JavaScript developer that isn‚Äôt aware of the differences.
&gt; A good developer would know that the task is near impossible to be complete by just one person, and will tell us that. While a inexperienced developer would maybe know its a lot of work but think he may can wing it and comes up with one crazy short timeframe and we would known she/he is not right for this job, it works everytime, and other questions to see of she/he is a good fit for our company and team. Sounds like you're saying you want a senior developer but no junior / maybe mid level developers. I don't get this. Most developers I've met including myself are not that great with off the cuff estimates. Don't ever trust an off the cuff estimate and don't ask for one.
Added an MIT license
As any client usually said, "how long can you make a node app that has similar function with uber? It shouldn't be hard, right?"
I've met two senior JS devs who, because of the way their last job or two worked out, couldn't use ES6 (or newer) and weren't experienced with these. They picked pretty much all of the changes in like an hour and had no problem using them. This is not something I would ever focus on during an interview. There are far more important things when hiring a senior developer, IMO.
waiting for 3 weeks. Should i be worried?
A valid question?
 const authors = {} writers.forEach(writer =&gt; authors[writer.id] = writer) const bookList = books.map(({ title, authorId }) =&gt; ({ title, author: authors[authorsId] }))
Are you using `before` or `beforeEach`? `before` is executed once, before the entire module is run. `beforeEach` is executed before each individual test. 
Can't anyone Google this? Is it the core business of the job to write async/await?
For them or yourself? Why do you need them and what will they be doing? Ask yourself that, and then ask them questions about your answer. &amp;#x200B; eg, If I'm doing X with framework Y, then, " can you do X with framework Y, or something similar? Willing the show us?". &amp;#x200B; NOTE: I want to make a special point here. Communication is number one, but if they're going to be coding as a job they should be writing some code in the interview at some stage. Talking and answering questions for a dev that's going to code all day is the same as asking a sales person to code when they're going to be talking and answering questions all day.
Yup. Nailing syntax isn't a good indicator of problem solving ability. Probably not a good indicator of productivity either.
Thanks for your suggestion. It helped me a lot.
Thanks, I will make sure about **let** &amp; **const.** I do think known devops not at expert level but developer should be above basics.
I imagine each of your tests are of the form: describe("Feature", function(){ let object = null; before(function(){ object = {setup: true}; }); function auxiliary(obj) { // ... } it('should work', function() { interesting_function(object) }); }); Methods like "interestingFunction" will be able to see auxiliary, because it's inside the describe block. But it shouldn't be able to see similar methods declared inside other describe blocks. If that's not the case, can you post a minimal example?
Yes
I would suggest you to go through this one: [https://node.university/p/you-dont-know-node](https://node.university/p/you-dont-know-node) &amp;#x200B;
It sounds like you don't hire junior newbies for the backend, I would presume? This seems like a lot to ask, so would be for experienced back-end devs only.
Sure you can, but anybody more experienced than junior already knows this. So it's good question when you need to filter out people on roles which aren't for junior people.
Hi all! This is a python project I made a few months ago that I ported to javascript this weekend. I scraped approx 2400 pictures of shoes from Nike &amp; Adidas' website, and used that to train a DCGAN. The output is pretty crappy, but in a prediction of 64 shoes maybe you'll get 4-5 decent ones. It's very dumb &amp; useless, but hopefully you guys get a kick out of it (excuse the pun) :)
Can you please answer your own question ? &gt; What's your preferred way to manage dependencies and why ?
I like the idea of frontend-OPs and these are the sort of questions I‚Äôd imagine for that role 
I get it. What is "this". That's more of a javascript question though than node. 
"Ah, I actually have that in my GitHub repo"
Off the top of my head, I can see some potential choices here. You can manually add the dependencies in package.json vs just install and --save or --save-dev. Do you have a lock file or not?. What do you prefer, npm, yarn, pnmp, bower, and why. What would you install globally and what locally and why.
Minor technicality: strictly speaking lookup is O(A). Big O deals with the absolute worst case, and for this hash lookup the worst case is A collisions. Of course in practice it can be treated as constant time because that's exceedingly unlikely.
Another interesting point I've been asked about is how you decide on a dependency - checking the download count, looking at the github issues and activity, but also how you judge if you need it or not. It's one of those things that demonstrates thinking about your code and not just trying to solve your problem any way you can.
Yes. People want to know that you are really understand what you do...
I'd rather have the non-succinct version if this is the succinct version I have to maintain ‡≤†_‡≤†
Maybe you could talk about how you lock down dependency versions to prevent a security problem. Or what your standard is to justify adding a dependency. Do you require code reviews of new dependencies?
If you don't qualify for everything it doesn't mean you won't get hired. It's just to give us a good overview where you need to improve and what's already perfect. It's very hard to find people that check all boxes especially since a lot of js programmers come from frontend development.
I can send it to you now 
Looking at the code, using query selectors and binding event listeners in React is an anti pattern. 
we don't have access to the SQL since the data comes from two services and we're scraping them together. we thought of your "optimal" solution long ago and couldn't implement it. next time ask more questions before you tell us (arrogantly and dismissively) what optimal is. good luck in your next interview.
I don‚Äôt see ang React code.
depends on the level. senior: event loop, closures and promises, dependency management, real world discussion about sharing js code between the browser and node, application architecture (including non js things, like logging, FE/BE metrics), software development process and how they work it (tests, code review, acceptance testing etc), some discussion about code reviewing the more junior members to make sure they're writing performant and security-conscious code, and basically anything from the sections below: mid: promises, async / await, exception handling, es6 things like collection functions map/foreach and their implications, seeing them write some code for common things like transforming a collection of one shape to another shape (oh, i see you used `reduce` to create a collection, what the implications of doing it that way instead of in a `for` loop?), discussion about automated testing, logging, metrics, etc junior: var vs let vs const, map vs forEach, async / await and error handling, promises as a concept, basic object oriented analysis / design, basic functional programming design, some basic pair programming challenges (things like fizzbuzz, maybe looking at code that has obvious mistakes `(if x = 3) { doSideEffect(); }`, lots of talking, sussing out if they get the difference between node and js (e.g. why does node freak out at you when you try to add an element to the DOM? or why does the browser freak out when you try to read something from the file system?)
Oleg18 was saying, "a valid answer to this question OP asked, is: &gt;describe `this` in JavaScript" Oleg was not saying "what is this question doing on /r/javascript?"
Oops my mistake.
Yeah I assumed and deleted my comment.
You would need to store the "current" promise, and chain all operations from it. The basic idea would be like this, just apply it into your class: let current = Promise.resolve(); function doOperation() { current = current.then(function() { return doSomethingThatReturnsAPromise(); }); } If you keep calling `doOperation`, it will keep adding operations into the promise chain, which will all run in a sequence.
&gt; hash collisions There's no hash collision. The map is indexed by strings. When it's indexed by object it just stores the reference.
Then, my code should be like this? var blockChain = new Blockchain(levelDB); blockChain.addBlock(new Block('Adding second block in the chain')) .then(data =&gt; { blockChain.addBlock(new Block('Adding third block in the chain')) .then(data =&gt; { blockChain.addBlock(new Block('Adding fourth block in the chain')) }) })
Conceptually true, but you still need to translate a string into a memory location. If you use raw strings (like, C-strings), you'll end up with linear lookups. And JS strings may be backed by objects internally (that's how you get fast concatenation).
Of course you're right, it's constant amortized. A coding interview is not a CS exam though, "hash lookup is normally faster" is already good enough.
I have a friend who's team has a question that requires the testee to ask for help. I thought that was an interesting avenue. They had to ask for certain permissions to complete it.
lmao holy shit if an interviewer did that because they already thought of my first solution I'd be gone.
Hash lookup ftw
My thoughts exactly. And I'm saying this as a guy who interviews people - I would never dismiss anyone for saying solution "I marked as used before".
I get that they should be able to say that they don't know the answer, but how would they know that they are allowed to ask for help in an interview? 
hello marovargovcik, thank you very much for your answer. Sorry for my late replies, last night i spent lots of time to make it work so i was away from my computer until now. Somehow i fixed my problem by using "focusout" parameter but it was still not working the way i wanted. However, i used your trick and it works completely now. Also i got your point regarding timestamp, however, this application will be currently used only by few set of people in my firm and in the same country where i am right now. So for now same locale wouldn't cause me any problem. But i will keep in mind for the future. Thank you very much once again. 
hello yes, i used the blur event as shown in the code below. It works perfectly fine now. Thanks
Wow, I'm sure that'll really filter out the best talent! Give me a break.
You‚Äôre downvoted because your comment is extremely pedantic. I would quit if I had to work with someone like that.
It's not pointless. [There are actually some differences as explained in this Stackoverflow answer.](https://stackoverflow.com/questions/38708550/difference-between-return-await-promise-and-return-promise) In short, behavior inside a try-catch clause is different. Less importantly, there is actually one more promise in the chain with "return await promise" which is probably usually not desirable, but it's a big world out there so hard to say there would never be a use for that. This article about [await vs return vs return await](https://jakearchibald.com/2017/await-vs-return-vs-return-await/) explains in greater detail when it makes sense to use "return await promise". To be realistic, I'm probably not getting this job unless I keep my mouth shut because I just made the interviewer look stupid. This is why if I let candidates use the internet during the interview. Because that's how we work as programmers in real life. And I might just learn something from the person I'm interviewing. Memorizing stuff like this isn't useful unless you get it absolutely right including all the subtle edge cases. Which is a monumental task. So typically my answer to a question like the above is "I'm not 100% sure, let me check Stackoverflow". That's the real right answer unless you're Kyle Simpson.
This is the right answer. OP actually got it wrong!
You got it wrong though!
That would be one way of doing it yes. The other way is to make it so that you save the current promise within the Blockchain class, and whenever addBlock is called, instead of immediately executing, it would chain its logic from the current promise, similar to the example I showed.
What do you mean?
Why would you not get this job? This is roughly what I was looking for from someone senior.
In my experience the guy interviewing you is usually going to be your senior in the org. And it's often threatening to someone in a senior position to hire someone they perceive as being more knowledgeable than them. Depending on how insecure I think the interviewer is, I might give them the simpler answer I think they are looking for rather than to contradict their claim of "it is pointless to write...".
You said it was pointless to use "return await promise". It's not pointless. See my other comment with all the details about when to use it.
&gt; return await promise Huh? Who does that?
Electron is advanced stuff? Why?
If someone claimed to be an experienced JavaScript developer, I'd ask a few JavaScript trivia questions. Simple stuff like "what is const vs let?" or how to do dependency management (just say npm or yarn). The kind of things a real JS dev would know intimately and could give a very quick answer. After that, I'd veer off into generalist stuff which is what I really care about. HTTP basics, security, REST concepts, database stuff. Then I get to what I really care about which is the mentality, process and teamwork questions. How do you organize work, how to pair with other disciplines, how do you maintain quality. My POV might be a bit skewed since I pretty much never get to hire juniors, so I except a lot. In particular I'm looking for the right mix of strong opinions and flexibility.
How was the interview? :)
lol
&gt; npm audit 
Seeing the example made me think of 3rd party content service API I used once.
‚ÄúWe know your answer is the most efficient one, but we‚Äôre only interested in more obscure answers. NEXT.‚Äù
StreamDemux - A simpler and more flexible alternative to EventEmitter which allows you to consume async data using for-await-of loops. [https://github.com/SocketCluster/stream-demux](https://github.com/SocketCluster/stream-demux) \- I also wrote a simpler primitive called WritableAsyncIterableStream: [https://github.com/SocketCluster/writable-async-iterable-stream](https://github.com/SocketCluster/writable-async-iterable-stream)
You‚Äôre hired
The word join raises an eyebrow. Most common I've seen is NoSQL dbs with node like Mongoose. Joins are out for that. At the same time, I probably wouldn't want to work on a project with SQL. I'd do it for the money, but it irritates me.
Very cool. I tried to use it in the browser on my phone but after 30 minutes my phone was warmer than the tea i made lol. Still cool idea. Ill check it out on my desktop later
Only hire people more smarter than you. You don't want to work with people who don't get this anyway.
If he didn't give the examples that he did, I'd have said that he has a point. It's quite difficult to work with developers who don't care about naming precision or important terminology since they can end up writing code that is confusing for others to read. But the examples that he gave are simply being pedantic for the sake of it and serve no purpose but to irritate the hell out of teammates who could otherwise be more productive.
Just imagine you‚Äôre resum√© being rejected because it says Angular and not Angular JS. I wonder if the leadership knows about this guys hiring style.
Sure with try/catch it's desirable. But the question must be framed correctly to indicate that we're asking only for the simple case without try/catch.
Thanks :) Yeah I never tried it on a phone but I presume it would take ages considering even on my laptop it takes 10mins. It's unfortunately a limitation of TF.js which doesn't fully support WebGL yet
You picked an example where terminology is essential. Angular and AngularJS are in fact two completely different frameworks. Both are from Google, and both have "Angular" in their name. But that is about all they share.
How do I use this code in VS ? Where should I put it? 
Jesus, give it a rest.
Isn‚Äôt it worth pointing out that 100 * 1000 is‚Ä¶ really small? I think I would consciously say, before describing the reduce like others have written here, that brute force quadratic would almost certainly not be a big deal for a database of this size. Having decided the quadratic approach, then okay, you say, here are some thoughts about what I should do to make this a little more scalable. 
I was asked to do a technical interview for a front end developer position. The person passed to me stated during the call, after a few questions, that they are not a front end developer.
&gt; But the examples that he gave are simply being pedantic for the sake of it and serve no purpose [...]. * JSON vs JavaScript object literal: The former is a language-agnostic string-based data serialization format, the latter is a JavaScript object notation. They have different properties and you have to handle them differently. * Map vs JavaScript object: Both are collections of key/value pairs, but they have different semantics and a different API. The former only has been introduced in ES6. * AngularJS vs Angular: They are completely different JavaScript frameworks that happen to share a similar name. * JavaScript vs Java: They are two completely different programming languages that share a similar name. I don't think that differentiating them is pedantic.
are you using this interview to solve a real problem in your job and you're mad they didn't solve it for you 
Why not use a variable for the component directly? &amp;#x200B; let Thinger = "h1"; return &lt;Thinger&gt;Hello World&lt;/Thinger&gt;; &amp;#x200B;
trick questions are a great way for me to figure out who I don't want to work for. this is asshole behavior. 
Where and how can I learn this advanced Node from Home?
Manually add to package.json? I have no idea why anyone would do that other than lack of experience, you can pass the version you want to npm install.
Glad I was able to help! ‚ò∫
I'm not sure whether you are kidding or being serious. Comparing Angular with AngularJS is about the same as comparing jQuery with React.
How do you access the dom?
I‚Äôm well aware angular 1 is different than angular 2+.
Nothing framework-related, it's vanilla JS in a jsbin, but I'm quite proud of it in its own way. I wrote this up because I wanted to ask on here or elsewhere about how to insert elements as children of a wrapping element and have those elements be equal in width, so they all fit together snugly. https://jsbin.com/piqopiwema/edit?js,output Whipped this up and worked it out on the first go. Basically you just have to make each inserted element have CSS style of width: 100%. It will divide the space equally, so if there are two elements in a box they will each have 50%, three elements will have 33.3%, etc. The way in which I made this presents a nice visual stripe effect as well, which I just think is cool.
Cmd+Shift+P on Mac, Ctrl+Shift+P on Windows Then search for "configure user snippets", and place the snippets in the snippets object.
Everything you said is technically true and yet the distinction is obvious to almost everyone with some experience, and can be picked up or corrected in less than a minute by any developer with functioning senses, and is nearly irrelevant to a developer's actual productivity and problem-solving competency. 
It's pretty fundamental to know how to use the programming language for the job you're interviewing for. Its true you can be a problem solver even if you never bothered to learn the details of the language but don't be upset if someone dings you for not knowing. It's usually a prereq for the job.