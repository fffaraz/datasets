Aww sweet! Thanks I managed to get it to work. Here is the updated [JSFiddle](http://jsfiddle.net/wsk6985j/3/) if you are interested in how I did it. 
With any language, recursion only makes sense for iterative branching. If you don't have to use recursion, then don't. It has a lot more overhead than your standard loop blocks. So fibonacci, sure. Reverse a string, create a map function... never. 
Well, even fibonacci is way more efficient without recursion. You can write that with a simple loop and use a lot less memory. The point of the article (which I tried to be clear about but maybe failed) was really just to serve as a learning exercise. With ES6, this may change a bit, since it introduces proper tail call optimization. So recursion might become a more attractive option for some problems.
It's exactly the same because Hungarian Notation is the _concept_ of prefixing variable names with type annotations.
Doesn't work on mobile. 
Yeah... I don't know much about developing on mobile... other than @media queries and using window.innerHeight and the like to do responsive design. What's the equivalent of ondragstart on mobile browsers? Any idea?
I wouldn't generally bother trying to understand what that line does, as the rest of the code linked does not seem like a particularly sound source to learn from. Nothing terribly bad, but not the kind of code I would investigate too much (just my opinion). In any case, the line _does_ actually do something which may -or may not- have interesting effects: If moves potential `ReferenceError`s into potential `TypeError`s. I don't know if this may make a difference in the environment of Chrome extensions, but those two errors may, in theory, be treated differently. Why it does so is simple. If `mono` _hasn't been declared at all_, trying to use it may raise a `ReferenceError` because it simply does not exist. On the other hand, after executing that line, those same usages of `mono` would instead throw `TypeError`s because `mono` does exist but its value is `undefined`. I honestly don't think it's much of a gain. In general, if `mono` was not defined, you should instead initialize it some way. In the linked code, that is useless in any case, as `mono` is initialized with a new value just below.
Editor or IDE is what you're looking for. Atom or Webstorm are my favourites.
You never need this. You don't need "typeof ... === 'undefined'" in general. It's used to check if a variable wasn't declared or if its value is `undefined`. [Secondly, it was an ES3 specific guard against modifications of the global `undefined` property. `Infinity`, `NaN`, and `undefined` are read-only with ES5+. "if(foo === undefined)" is perfectly fine nowadays.] Your code should only interact with parameters and local variables. Those will always be declared. If you *really* need to interact with globals, be explicit. "*window*.foo".
I'm fine with that, but maybe a fat disclaimer at the bottom would be good :) **Edit** After reading, I saw a disclaimer, my fault haha. Also, I'm pretty sure tail calls don't work if you *do more* than return an invocation to a single function. Like in the case of fibonacci: function fibonacci(n) { if (n === 0) return 0; else if (n === 1) return 1; return fibonacci(n - 1) + fibonacci(n - 2); } is not a valid tail call. // tail call return f(arg); // non tail call return 1 + f(arg); In the case of quicksort, usually only one of the branches would be tail call optimized, which is even stranger. So I'd still suggest, use recursion sparingly or enhance it with techniques like memoization.
Well, you don't need to do it _by hand_. You could just use whatever editor you like best, write a small macro or write a script to do all the replacing... On the one hand you have the array... var words = [ "title", "xhrPool", "abortAll", "abort", "each", "length", "push", "indexOf", "splice", "ajaxSetup", 65 more… ] ...on the other hand you have the code... var code = "var lstMail;\ var lstSock;\ var maxFail;\ var docTitle = document[_0x78e6[0]];\ $[_0x78e6[1]] = [];\ $[_0x78e6[1]][_0x78e6[2]] = function() {\ ...\ "; And the first replacement would potentially be doing: code = code.replace(/_0x78e6\[(\d+)\]/g, function(f, i) { return words[i]; }); This, of course, only replaces the ones in the array. Giving names to function parameters is a whole different thing.
It's not the *only* way to do this, but it simplifies the directory issues. Also, take a look at [aliases](http://webpack.github.io/docs/configuration.html#resolve-alias). Can be helpful for mapping out the directory structure if you don't want to type: import * as angular-ui-router from 'angular-ui-router/release/angular-ui-router'; and instead get: import * as angular-ui-router from 'angular-ui-router'; which is what the `npm` build should give you.
Hi, The reason you can't find an ID for that particular node is because it is rendered in canvas. However, if you do a search in your console for 'Leaderboard', you will find an object called `i18n_dict` used for translating the game text into different languages. It has an `en` key for the English translations etc... If you paste this into your web console: i18n_dict.en.leaderboard = 'Test' It'll change the English text for the`leaderboard` property to `Test` Hope that helps
You don't need `typeof`: typeof undefined // undefined yet undefined is already undefined so var foo (foo !== undefined) ? foo : undefined;
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor
My guess it's so that they can statically declare the existence of the variable, so it can be used in a more dynamic manner later on. It uses the grunt closure compiler task, so I wonder if it's something to do with that?
Oh man, you are bringing me right back to 1993, when I was learning C++, SQL, state diagrams, Unix, etc. on a job. Enter [Hungarian notation](https://en.wikipedia.org/wiki/Hungarian_notation) Every once in awhile I still do think about it when I name a variable bDisabled (b = boolean for me, although I remember f being used for "flag"), but I don't look back fondly to being forced to use **rglpsz**....a: **r**an**g**e (array) of **l**ong **p**ointers to **s**tring **z**ero (null) terminated) before my variable names. Languages these days are either dynamically typed, or many of those using strongly typed languages are using Visual Studio, Eclipse, Android Studio, etc. which provide type information (and greatnesses like "show me all references to..." at a keystroke or mouseover. 
[Recursion in JavaScript](https://www.reddit.com/r/javascript/comments/3ek23j/recursion_in_javascript/)
[TextMate2](https://macromates.com/download) on Mac, [Notepad++](https://notepad-plus-plus.org/download/v6.8.html) on Windows
Drag and drop works for me on the ipad. I think it's a very nice demo and this could be used in very specific cases where no one will ever use a touch device. For the anecdote, JIRA does the same with their agile plugin and dashboards. And it's just impossible to scroll without randomly moving things when on a touch device. I asked, and people on windows 8 touchscreen enabled laptops are in the same boat. We have huge lists of prioritized items, and every now and then someone on a touchscreen moves something when scrolling. I guess the JIRA guys thought that at least it was useable on point and click desktop, so ship it! But then it's also the same interface for every other devices, and it screws it for everyone (why bother ordering things if they'll get shuffled every now and then ?) TLDR; It's a cool looking feature, but tneeds a lot of thought on how to deal with touch devices.
Import where? &gt; so if i hit a shortcut key, it would do the random int Do you have an example?
Throw an error on purpose :) function test () { asdfadsf; } test() // Uncaught ReferenceError: asdfadsf is not defined(…) Look at the stack trace. Voila!
lets say i wanted a random number between 1-100, how would i made so that the variable(random number) would be outputed on another client?
[Brackets](http://brackets.io)
no just one, the original client does not have to be connected to any server, it can just be for example my home computer(unless that is a server too) apparently you are meant to use classes?
JS is loosely typed, so doing this is kinda working against a core feature of the language. Despite that, I prefer strong typing, so either would recommend TypeScript, or JSDoc. If you set your ide up with JSDoc (e.g. DocBlockr), things are rather nice.
In the current application I'm working on, React classes are the only classes in the system. Everything else is just functions, closures, and objects, and it works very well. It's not that I like React classes better than other in the system -- the utility of React is worth putting up with classes at all. I'd be much more in favor of a system like [deku](https://github.com/dekujs/deku), where components are defined by basic objects and functions. Classes are not required. Doing it this way allows you to use decorators, combinators, and other functional techniques to make your life easier (without needing ES7 decorator syntax to make up for the shortcomings of ES6 classes). However, deku came out after I started working on this app, and React has much wider community support, so I'll stick with React for now. It's not that I particularly like React's classes -- it's just that they are tolerable for what React provides, and they have a couple neat features. ES6 classes are a step backwards.
gives a random number which is a multiple of three? Edit: im pretty sure this gives a random number between 1-100 == Math.floor((Math.random() * 100) + 1);
It's actually what's behind jsperf.
The smaller snippet in loz220's reply relies on the fact that global variables are also properties of the global object: If `mono` hadn't already been declared in any enclosing scope, then `window.mono` will still not throw an error, but if it is a global variable, then `window.mono` will have the value of that global variable.
Do it baby, do it baby.
The idea I had for recursive reversal was this, which should have half the stack size: function reverse(str) { 'use strict'; var len = str.length; if (len &lt; 2) return str; return str.charAt(len - 1) + reverse(str.substr(1, len - 2)) + str.charAt(0); } I used `charAt` to support older environments that don't support index notation for strings, and although I'm aware this doesn't support the astral planes, [MDN outlines a function that does](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charAt#Fixing_charAt%28%29_to_support_non-Basic-Multilingual-Plane_%28BMP%29_characters), and it may have inspired the [proposal for `String#at` in ES7](https://github.com/mathiasbynens/String.prototype.at/blob/master/at.js).
If I'm seeing it correctly, your regex should work. Just look at the second capturing group and not the first. The first always matches the whole expression, while the following match the parentheses. See: http://stackoverflow.com/questions/432493/how-do-you-access-the-matched-groups-in-a-javascript-regular-expression 
You could try copying it to your clipboard if that's what you're looking for? There are methods of doing that with JavaScript Other than that I've no idea what you're asking about. 
I think what you need is [`RegExp#exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec): var reg = /\[(.*?)\]/g, match, i; // cache in a variable so `lastIndex` is not reset while (match = reg.exec('[lol][omg][rofl[copter]guyz]')) { for(i = 1; i &lt; match.length; i++) console.log(match[i]); } Obviously this doesn't work well with nested delimiters, and I'm not sure a regex can help you there.
As stated there, meant to be used with nodejs. If using it in for in browser apps, be aware that minimisation will remove all commented out strings.
Am I missing something...any reason you wouldn't go straight to Sublime Text 3? I upgraded straight away and haven't found conflicts. Is this like the Python 2 vs 3 community divide?
Ah, I see foo !== undefined; // ReferenceError typeof foo; // "undefined"
This project is now a bit dated. Use ES6's template strings. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings#Multi-line_strings They already work in the stable versions of Firefox and Chrome. Io.js supports them and for Node (and older browsers) there is Babel. http://babeljs.io/docs/usage/require/
I think it's a misguided attempt at getting around strict mode. Try running this in your console: (function() {"use strict"; var foo = baz; return foo}()) That will throw because `baz` is undefined Now try this: (function() {"use strict"; var foo = (typeof baz !== 'undefined') ? baz : undefined; return foo}()) That one won't throw because `typeof` is a safe operation (not in es6 but i'm simplifying). You probably noticed I'm using two different variables here. Lets try using the same variable as you did in your example: // lets make sure we have a foo var foo = 'global'; (function() {"use strict"; var foo = foo; return foo}()) Now when you run that you get an unexpected result. Not only did it not throw like the example above, but your function didn't return 'foo' like you probably expect, you got `undefined`. Why? The location of `var` is actually meaningless. Before that function executes it will find all `var`s and allocate local variables setting everything to `undefined`. When the right hand `= foo` is evaluated it uses the innermost scope, where `foo` is undefined and sets that same variable to itself. You can verify this behavior with this code: var foo = 'global'; (function() { "use strict"; console.log('foo', foo); var foo = foo; return foo }()) The console will show you that `foo` does exist, and its undefined because the function's `foo` is shadowing your global `foo`. If you remove the `var foo` line you'll see that it no longer shadows the global variable and you get the string `"global"`
An awesome explanation by [CodingMath](https://www.youtube.com/watch?v=n6rDL8Y6iTA). Also a very good explanation from a [handmade hero episode](https://www.youtube.com/watch?v=ydiHNs1YQoI&amp;t=1h29m03s). So you want an integer from A to B, i.e an integer in the range [A, B]. If you start at A, and add B - A, you would go to B, right? Cause the As cancel. But if we multiply (B - A) with t, i.e A + t * (B - A), and t has only the values 0 and 1. So when t = 0, the result would be A. And when t = 1, the result would be B. Now if we allow t to be random (using Math.random() or equivalent) we get random real numbers which we can turn into integers using Math.floor or Math.round (use Math.floor!). But the problem is that we can never get B this way because t can never be 1 (Math.random()'s range is defined to be [0, 1),). So we add 1 to B and we get: A + t * ((B + 1) - A) or A + t * (B - A + 1). But we forgot to floor! So in the end we get (assume javascript): function random_integer(A, B) { var t = Math.random(); var random_real = A + t * (B - A + 1); var random_integer = Math.floor(random_real); return random_integer; } var random_integer_between_1_and_100 = random_integer(1, 100);
Hi /u/iahess, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Uhhhh..... no
Thank you. This works and I can at least get my head around how things work internally.
your logic is confusing. try this instead: if ( err ) throw err; doSomething();
In Javascript, [you can throw anything]( https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw). It doesn't have to be a specific "exception" type. For convenience though, you can inherit some basic error behavior by making a new exception type that [extends Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types). 
You don't really need to know what it is. If it's not on another copy you have on local or staging, purge it and figure out how it was inserted in the first place. Save local copies to figure out what it does later but your primary concern should be how they got there in the first place. 
https://news.ycombinator.com/item?id=9914045
Without looking at your code first I implemented it in 35 lines.. so let's see why there's a difference of 69 lines between yours and mine. http://codepen.io/anon/pen/dogKGr Aside from your extra lines between functions, you have things like this: function getNow() { return new Date(); } Which doesn't really make sense to me. Why make a function that literally does exactly what `new Date()` does? Fundamentally I think your approach was more complicated as well. What I did was used the built-in JS functions to `getFullYear`, `getDate`, etc. and subtracted from the forward year. If the number was negative I subtracted from the next larger category and pushed the category forward as many units as it needed (eg. 60, 24). It would have been way easier than using a modulus. For this though: `if (interval == null || interval == undefined)` I'd warn against the second condition. Instead if you want to check if it is undefined use: `if (typeof interval === "undefined")` Because if it doesn't exist, `typeof` will literally return "undefined", so it strong-matches. Also what's the point of running the interval twice a second? Seems needlessly intensive. --- Otherwise the code is very readable. Looking at your code makes me think you started programming in Java or C++ or another more strict language. That's not a bad thing of course, just sometimes more verbose than it has to be (hence the difference in length between your and my code).
Well he says that in his FAQ, but the extra info you provide is too correct.
give `error` a try - https://github.com/Raynos/error
source: https://github.com/hannyajin/flapmmo
ok so basically i want that random calculator to be outputted in another piece of software, can i use classes to do thiS?
Why should that be - you are NOT actually typecasting ffs! You are making more same-named-but-differently-casted names available. You are making your code more readable (coz you can see the type) Do you guys even KNOW javascript? (ohh BTW physics - in JS EVERYTHING is an object)
It was uploaded via a weak FTP account added by my client, and these were the only files of interest on the server. So yeah, at this point I'd like to take the time and see what it is.
I'm going to do this today. Looking at the whole scope of the files, I don't think giving function parameters / local variables relevant names will be too difficult. Thanks for your help!
Most of those are outdated. Not sure what you were trying to provide... The current caniuse (as you provided) shows if working for the 3 browsers I mentioned only.
Think backwards. Imagine the data or state you need to wind up with and work backwards from there. It may also be helpful to think of functions that accept callbacks as little programs that are going to go off and do their own thing with no communication back to the caller.
https://news.ycombinator.com/item?id=9950787
Pretty cool! Been using BaaS for the while, and get frustrated every time I need a server _just_ for AWS keys. Will be using this.
That's perfect, just what I was looking for. Thanks for the link.
I don't know if this will work for you. I've seen it work for some people but not for others. Forget about callbacks themselves for a moment. Instead, think about _events_. Try to decompose your functionality into things to do "when something happens". This is generally easy for most people to reason about when wiring up UI. It's easy to think about things like "setting a handler" for a certain user interaction. That is, it's generally easy to think stuff like "so, when the user clicks this, I need to do that". When you are comfortable with that thinking, try to think about _other kind of events_. Try to think things like "when the data arrives, I need to do that". This is not very different from procedural programming, actually. It's just that, where you would... // I call to get the data... data = getSomeData(options); // now that I got the data, I need to do this and that doSomething(data); doSomethingElse(data); ...you now think explicitly about things that happen ("I get the data") without assuming it happens sequentially. So now you would... // I call to get the data... getSomeData(options) // When I get it, I need to do this .on('dataReceived', processData); So, you explicitly start breaking down actions as responses to "events", to "things happening", just as you do with user interaction. As I said, I've seen some people get comfortable with this way of thinking but not other people.
This code could be greatly improved with document fragments. Also, I typically use a dictionary/hash map to implement a trie. In JavaScript, I would use an object.
It looks like you entered a pass phrase when you created your ssh key. That's not related to sudo. Your ssh key locally needs to not have a passphrase. See link below: http://stackoverflow.com/questions/112396/how-do-i-remove-the-passphrase-for-the-ssh-key-without-having-to-create-a-new-ke
Ahh thanks. I will this Monday thanks!
Death to servers! Viva la frontend revolutíon!
wish a bigger part of the community would adopt this attitude. 
I think it's fairly standard to expect users to start the server on their own before testing, especially with node. If you want to skip that step, you could always set up an npm task (or gulp, or grunt, or whatever) which would execute `node server` and then kick off the tests next. Might run into issues if you wanted to test while the server was already running, though.
You could use node's child_process module and spin up your server. A callback happens once that is up and would let you kill the server after your tests. On another note, testing APIs like that is great for final level integration tests but less than ideal for regular test suites. Making a full request (even to a server on the same machine) is going to cause your test suite to be really slow. If you plan on doing this for a big project, it might be worth investing some time up front to find a better way to unit test your requests without having to go through the server.
Thank you, that jQuery looked really simple. Had kind of set my mind to javascript - since that's what I'll be learning first when school starts. But heck - I'll use javascript somewhere else. 
This is not an answer to your question - but I use [supertest](https://github.com/visionmedia/supertest) to test my APIs and have been really happy. Supertest takes care of this issue, by waiting until the app that you pass into request() is listening.
jQuery *is* JavaScript. It just offers a nicer API than browsers do. I do think that the modern vanilla version above doesn't look that bad. However, if you were to add all the required workarounds for IE8+ support, it would be a lot longer and also a lot uglier. This is another advantage of jQuery. It takes care of browser normalization. You use a single API for all browsers.
Thanks!
Ah, that's a good point, I'll take a look at that and see what I can do. 
Yes! This is awesome!
If you're seriously interested in learning Javascript, I would maybe suggest holding off on the jquery at first. The javascript that is required to change the color of a button a couple of times is relatively simple. If you learn the steps to do it in javascript, then you're actually learning javascript. If you use jquery to change the color of a button, you'll find it's really easy, but you won't really know what the javascript is actually doing "behind the scenes." JQuery is really amazing. It is a god send when you're actually creating applications that need to perform across multiple browsers, because jquery takes care of all the differences in browsers. But if you're in the beginning of learning this stuff, then I would suggest avoiding jquery until you've got a good base knowledge of javascript. Good luck. Its a really great language once you've gotten the hang of it. 
Haha, nice! There's about 30 pipes in the level - I just haven't added camera follow yet, :|
Sure. It's just that management hates refactoring. As engineering, we pleaded for cycles to refactor and simplify the application. But it doesn't translate to sellable features so we can't sell that to sales and marketing. So we shouldn't do it. It's an uphill losing battle every single frigging time. 
Such perseverance! :D
The thing is that I had no problems changing the color once - everything just came crashing down when I wanted the whole thing to reverse (toggle). Then jgrosecl49 had some javascript - but that did only work on one button (the first button), so I'm kind of stuck. If you know how I should make this possible with Js, then please, tell me how. 
This looks amazing. Is it production ready?
Lack of easy windows support adds a hurdle to using. Ideally i'd love to just npm install something.
Indent your code block by 4 spaces or 1 tab. Create a test case on jsbin or jsfiddle.
You're welcome! Don't call it Java, though. Javascript has nothing do to with Java except the name because of marketing reasons.
It is incredibly tiresome to see the same arguments over and over and over and over and over. Which is usually prompted by the same blog posts being published over and over and over and over and over.
Good luck! Your code is clean so make sure to keep writing clean code. 
Yes, Windows support is an issue. To be honest it should work, but my Windows box is kinda hosed with an old copy of the Windows 10 preview! It's definitely a high priority, and another thing we're working on is supporting building your project in the cloud (actually using StackHut itself! :))
Cheers!
Yep - we love the idea of Lambda but some of it's restrictions really limited what we could do with it.
Why is it that changing the gosh darn color back and forth - is so much more complicated than just toggling an image? [Bulb](http://www.w3schools.com/js/tryit.asp?filename=tryjs_intro_lightbulb)
Here is some CSS example: http://jsfiddle.net/y7mbgL8s/3/
I think the best way to understand callbacks better is to learn that JavaScript (engine) is single-threaded using an event loop. http://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/ If you have used, for example, Java, how they deal with IO is that that your application waits until the (input/output) operation is done. So if you read in a file in Java, normally your whole application is halted until this is done. That's procedural programming in a nutshell. However, since JavaScript (engine) is single-threaded and using an event queue, its non-IO-blocking. Imagine a queue where each "function" is just appended to the queue. The engine just continuously invoking functions. This means that if JavaScript reads a file (for example, if you use the Node.js platform) your application doesn't get halted during IO-operation. It will just continue invoking the next function in the queue. (That's why ~~single-threaded~~ event-driven and asynchronous platforms are more efficient as it uses CPU all the time, during IO-operations, compared to platforms such as Java which halts everything.) So, as soon as you understand there is a queue, callbacks make sense. If you have a function that reads in a file, as the platform is single threaded and using an event queue, you need to provide with a new callback function to be invoked when the IO-operation is done. I hope this helps understanding more the reason behind callbacks and why they exist; to link code blocks together to maximize the use of the CPU! :-)
Not a single mention of the need for a towel, obviously not a complete guide.
https://developer.chrome.com/devtools/docs/javascript-memory-profiling
You only need to know where your towel is. You don't necessarily have to have it with you.
i`m using http://www.mkdocs.org/, liking so far.
Modules are just functions. When a function returns, the garbage collector automatically frees its local variables. The difference between a module and a regular function is that modules return references to variables inside of the function. Since there are now references, the garbage collector is not able to free its local variables, even after it returns. What you return from a module must be stored in a variable. If this variable is in a function, then all you have to do is wait for that function to return. The variable will be garbage collected, removing all the references to variables inside the module. Since the references are gone, those variables inside the module will now be garbage collected as well. If you store the module's return value as a global variable, i.e. connected to the window object, then it will never be garbage collected. If you are done with it, then you must use the [delete operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete).
It IS possible to make it with javascript, although I think it will be a bit complicated. Maybe you want to make something like https://languagetool.org/? Although that project is in Java. Btw I wonder if you are possibly from Denmark because of the firm rules about comma.
Helping what and how should it be done? On an unrelated side note I am familiar with most of the tools mentioned in the article and use them daily. The main exception is gulp, to which I use grunt because I think configuration over code is preferred in a enterprise setting. Otherwise this is pretty much my set up for daily work. 
Good idea, but unfortunately I think it will be too much for you. Imagine the algorithms you have to write to conclude if a comma is acceptable or not. Don't let me discourage you, just expect to do some serious research and ask yourself if it will be worth it.
&gt; (That's why single-threaded platforms are more efficient as it uses CPU all the time, during IO-operations, compared to platforms such as Java which halts everything.) The efficiency comes from event-driven or asynchronous platforms, not having a single thread.
&gt; this is a pretty realistic set of tools to use for a modern dev javascript tool kit Most people aren't using ESLint probably because most people aren't using pure javascript for everything (if you produce javascript in python/java/etc, you're going to use a native library) or thinking hey, my 2 year old codebase needs a tool that didn't exist before 2013! mocha/jasmine? More like &lt;CI tool dejour&gt; + Jasmine because anything that requires an elaborate set of build tools is going to be using a more robust CI workflow and not just Jasmine. There's just so many fantastical assumptions, that I don't understand where this is supposed to be helpful to someone looking to practice for industry. I really appreciate js, but the ecosystem is SO polluted and so maligned until only newish tools get kudos, it makes almost every /r/js article a misdirected circlejerk.
The simple answer is that the more complex the applications you're building get, the more you will have to dig in to the innards of some of those frameworks and libraries when something doesnt work or when you want a custom feature. But beyond that, another key step to progressing as a developer is to learn design patterns. To be honest, the projects that most of the front end developers I know are doing in their day jobs are not complex enough to advance their knowledge in a significant way. I feel like I had to really push myself on my personal projects, or spend any extra time I had at work digging in to parts of other frameworks and libraries where the functionality was a mystery to me. That, combined with a better understanding of design patterns, really helped to feel like I was more than just an intermediate developer.
If you're not writing "pure javascript for everything" then you're not the target of the article, so I'm not really sure where the relevance there is? The article has a pretty specific target, and a pretty specific goal to achieve. You'll still have to justify how on earth you think any of this information in inaccurate or unhelpful.
Callbacks suck, and the reason they suck is you aren't passing data to functions anymore, you are passing *control*. That's the hard part. You have to think of your program *stopping* and another program starting when the callback happens. Normally, you write something like this (no error handling in these examples): var data = readFile(myFilePath); var dataJSON = customParser(data); var result = complicatedOperation(dataJSON); renderInformation(result); Now, lets assume the functions `readFile` and `complicatedOperation` are asynchronous (leaving `customParser` as synchronous). You call readFile, but you can't run `customParser` until it's done. Your program stops, and you pass along a function to take control again when `readFile` is done. readFile(myFilePath, function(data) { var dataJSON = customParser(data); complicatedOperation(dataJSON, renderInformation); }); We add an anonymous function as the callback for `readFile`, because that function *assumes control* of the program execution when `readFile` gets around to finishing. Until it does, our program is doing *nothing*. When the callback is run, `readFile` passes data to it, so we can then perform our usual, synchronous actions like `customParser`, and then call another asynchronous action `complicatedOperation` and pass another callback.
I was reading over the website a few times and I was having trouble understanding what this service is selling and why I'd be interested in it. This answers my question.
This is hard regardless of the programming language you choose. No matter how good you are at programming, this is an incredibly hard problem to solve, because it has to deal with natural language processing. If you really want to do this, I suggest you look into natural language processing... Although I don't know too much about it. Normally I'd encourage people to do hard things, I think that creating an algorithm that can show where comma's are and aren't supposed to go would be thesis-level hard.
Single threaded applications are not more efficient. If I have two threads, each doing constant work, that's double the efficiency. Program structure and CPU utilisation are what effect efficiency. And btw, LibUV, the library Node is based on, uses a background threadpool in order to handle things like IO.
This isn't really a problem that a beginner could tackle. It's much more advanced. It's the type of problem a computer scientist would work on.
This is also valid (but redundant): ``` var myfunc = function somefunc() { }; ``` The function would be called somefunc but can be called with myfunc as well. 
Self is understood by many programmers. It is a convention used in python and rust as well. It is also more descriptive than "this". As it is a convention you can ignore it but if I inherited code with THIS in it I would not be happy. I find uppercase to be nasty and something that should be reserved for items you want to scream and pop out at the maintainer of the code.
If you want to use Frisby, you should start your REST server in either the npm test command: "scripts": { "start": "node app.js", "test": "npm start &amp;&amp; jasmine-node ." }, OR a slightly better way by using the npm pretest command: "scripts": { "start": "node app.js", "pretest": "npm start", "test": "jasmine-node ." }, Please note that this can impact you as your app progresses if you start performing REST requests while the application is still starting (e.g. your app needs to talk to a server to startup/initialize). You simply can't determine when your application has fully started when running it via the CLI so you run the risk of hitting it with requests before it is fully started. The fix to this problem is to have the server be automatically started in a "smarter" fashion. To do this you can use a Mocha-flavored fork of Frisby called [IcedFrisby](https://www.npmjs.com/package/icedfrisby), which has a [useApp\(app\)](https://github.com/RobertHerhold/IcedFrisby/blob/master/API.md#useapp) function built in or emulate this behavior yourself. To my knowledge, Frisby does not have this function yet. Lastly, if you want to, you can use [supertest](https://github.com/visionmedia/supertest) to perform your REST requests with either Jasmine or Mocha as another commenter pointed out. It has the capability of also starting your application automatically via its request(app) constructor.
I suggest that you learn to program before trying to do this. It's possible in any language at all, though it may be easier in some and harder in some, and they run in different places. But all of the languages are similar, so you should just start learning and if you need to pick up another language, just do that. I recommend Harvard's [CS 50](http://cs50.tv). The course is in C, but it covers the things you need to know, and when I went through it at least, the last problem set was in JavaScript. JS is really easy once you know C. So is PHP. So is everything else. Because, really, programming is difficult, but the languages are all basically interchangeable. You need to actually know programming before you can really prefer one language over another. Think of languages like cars. Some are big cars, some are small cars. Some are motorcycles. Some are stick shifts. Some take diesel. Some are plug-ins. Some are solar. Some are really fucking weird. But they all drive about the same.
I think the key to truly progressing as a developer is to try to gain a deep understanding of why something is happening. All too often we encounter a problem without truly understanding *why* it's happening, google a solution, and then move on. In that case, we've gotten past our road block, but we haven't actually gained any insight into the system. The better you understand the system at a low level, the easier it is for you to either avoid silly mistakes, or catch them early. For example, if you understand how browser events work at a low level, you now have a mental model that you can use to troubleshoot your bootstrap popover problem. You're no longer thinking about the problem in terms of code, you're thinking about the system itself and how it operates.
I really want to be onboard with the serverless revolution but then Google tells everyone they will get a big traffic boost if we serve up html for deep links.
As far as tools go, JavaScript is a good fit for your situation. It's not an easy problem at all though.
I assume this is particularly useful for specific types of applications, but I'm still struggling to understand what they are, and how it might work. I guess the main areas I have questions around are data storage, unit testing and performance.
Digging the 3.1 or 3.0.1 or whatever release I forget release. Loading bar is cool and it does the flat tree thing now I think. I dunno. My back hurts.
Currying is used more if your technical approach suits it. As is the case with pure data management in a functional style. You could be using transducers which are essentially curried, composed functions.
Won't run at all for me. ln 11 has an invalid operator(=&gt;). Also, like you stated, `math.random()` should be `Math.random()`. I did a bad formatting for the bracers in the previous gist. /u/TOPTRTA [This one](https://gist.github.com/anonymous/a27871e05cfc621afc8b) has propper formatting and runs fine(for me, at least). See what I did on line one? You can declare multiple variables with only one `var`. Just separate them with a colon.
I like the concept of having this stack and the video series is also great. I really think this is the future - having micro services backing you up so you don't have to think about scaling. A bit off topic but I have to say thanks for specially one of your videos! I literally used shazam on all the songs in the video.
Very strange question. Why would this be any different from, lets say, the use of callbacks? Like @Wince said, its an approach. If it makes sense, use it. "Have you guys used callbacks in production? How did it go???" I personally have used currying to decrease duplicated code, by preparing functions with certain arguments, without actually sending those arguments at the real execution time.
Man, thank you so much for these posts. It seems like you've been in the game for quite some time. I've certainly learned a lot. &gt;I'd end up recommending Postgres, because a lot of money is riding on not fucking this up and Postgres is stable, tested, trusted, and reliable for workloads like ours. Yeah, there's a reason DBAs and sysadmins are often pretty conservative. It's kind of unfair because if a DBA is conservative and everything goes well because of it, nobody notices or cares. But they *will* blame the DBA for being conservative and not keep up with new tech. If a DBA is not conservative, you'll easily end up with tons of problems... that will all be blamed on the DBA who will also have to solve those problems in the end anyway. So, considering the vastly larger responsibility that lies on the shoulders of DBAs... conservatism it is. &gt;Famously, Reddit uses Postgres as a dumb key-value store, which depending on who you ask is either a terrible design choice from their days as a startup without any DBAs, or an excellect design choice that has allowed them to scale to be in the top 25 sites on the internet. Hehe, yeah, well. I guess that isn't as much of a problem had it been the other way around, where you suddenly need a database that can do more and not less. &gt;"datastores are hard; give some thought to picking one and don't just go with what's cool" Yeah, this made me think about your original post. Considering how many database systems we have to choose from and how radically different they are, combined with how much experience it takes to actually evaluate them, the answer when people ask about a specific DB should most likely always be "probably not". At least it will make them think about it.
Callbacks are almost a necessity with DOM events. Currying, I think, is almost always optional. When exactly did you need to prepare functions with certain arguments? Can you provide an example?
Could you elaborate a bit? How did the resulting code look like? (Not all of it, of course, just the relevant parts)
The new Microsoft Visual Code also offers a pretty good 'out-of-the-box' Javascript experience. No need for configurations and/or plugins.
Pseudo code like this: function NotificationService() { function showMessage( type, message ) { alert( type + ": " + message ); } function createShowMessageFunction( type ) { return function( message ) { showMessage( type, message ); } } return { showConfirm: createShowMessageFunction("confirm"), showWarning: createShowMessageFunction("warning"), showError: createShowMessageFunction("error") } } and then the developer can write notificationService.showConfirm("This becomes a confirmation message!"); In above example, we have done a curry example by ensuring DRY (dont repeat yourself) and by avoiding code duplication. Otherwise you would have needed to write: return { showConfirm: function( message ) { showMessage("confirm", message ); }, showWarning: function( message ) { showMessage("warning", message ); }, showError: function( message ) { showMessage("error", message ); } } Which is duplicating the "showMessage" call.
I've used currying to pass configuration to an express middleware module. Pass the configuration in and return a function that you can use as a middleware. This is about the only solid use of currying that I'm able to think of. Most other times it just clouds the meaning of a function by hiding functionality. 
What's performance like? If you're only running the code when it's needed then does that mean that the micro-services are only started on demand? And if so, that's going to incur a performance penalty when they aren't used often. (I've not looked at AWS Lambda so I've no idea how it works. It's possible that what I'm saying here is rubbish)
or indent whole code with 4 spaces and you'll get: var choice = prompt("(a)Heads (b) Tails"); var compChoice = math.random(); if (choice === "a") { if (compChoice &lt;= 0.500) { alert("Heads! You win!"); } else { alert("Tails! You lose!"); } } else if (choice === "b") { if (compChoice =&gt; 0.500) { alert("Tails! You win!"); } else { alert("Heads! You lose!"); } } else { alert("Refresh the page, then try again"); }
Only if you are supplying bind with the arguments to curry the new function you are creating and null as the 'this' context.
Hey Matchu. These are great questions, let me clarify. You are correct in that the Hutfile is used to create a Docker image, and that Docker images are by definition portable. Where it goes outside of the realm of what can be directly deployed to a regular IaaS like AWS is the orchestration of these images, and routing requests into it. Each request to your service is actually run in a container which is then destroyed immediately after the request has been completed; so for each service you deploy, we actually have about 5-10 instances of it running and waiting for a message on a queue. One of them will get the message, execute it, and then restart itself. We did this for three reasons: * It scales ad infinitum. Because we are spinning up a container per request, it means that there are no side-effects to running your code; it is totally immutable. This is pretty key for services like browser [http://stackhut.com/#/u/lanthias/browser], because you can guarantee it will run the same every single time (and some packages will slowly memory leak, or leave files lying around, etc. if you do not do this). This is more important at scale. * It can run anything in parallel. Services which can not usually be run in parallel can be, as they are on different containers. * Immutability removes a lot of issues which plague servers. If it works once, it works again. So, to answer your question, something needs to sit there and orchestrate all of this. For this, we have a massive Kubernetes cluster, a Redis queue, and a few other things. Our thinking was that deploying these to your IaaS every-time you want to use StackHut is pretty heavy-weight for our users; not to mention that deploying a cluster can be prohibitively expensive (whereas with StackHut, we imagine you will pay for the milliseconds of active run-time). That said, we are exploring offering an on-prem solution. It would be awesome to hear exactly what your dream product would look like in this regard. Is this a blocker? On a side note, we are aware that requiring Docker to build / deploy services is a hurdle that most users shouldn't have to jump through. What are your opinions on this? Thanks for taking the time to reply. This is awesome feedback.
I use it all the time in React code. Usually when I'm mapping a list of items I'll partially apply the callback function with the list item key or something similar. Makes for very concise code. 
That he doesn't consider repetition a prime breeding ground for bugs is really concerning. Reducing repetition always reduces bugs... there's even a fairly upheld principle about it - DRY. But at least he gets that implicit magic is bad.
I'm not disagreeing with you, but I've seen damage done by taking DRY too far, usually as a second-order phenomenon: some bits of code look the same for a short while (so they get deduped into a function) and then diverge in their behaviour, which, rather than being inlined and altered in place, ends up receiving more parameters (often boolean flags) and results in complex code. It's a balance, I think, between refactoring too early versus bearing the risk of behaviour that ought to be the same diverging mistakenly.
Yep, there's a balance for sure. But "only abstract to FIX bugs" should include 'prevent bugs' too, and should also include 'style guide' concerns as well. for -&gt; each is a good example of where abstraction was a good thing. 
&gt; Reasons I don't use a framework, personally. Every time I read a statement like this in regard to javascript or front end development, I end up reading it as "I'm too much of an egomaniac to write good software." If you think that you're going to be writing layer upon layer of front end code, on each project, to achieve the things that are needed to support a highly functional and intelligent user interface without using any frameworks or libraries...well...you're never going to be 1/10th as productive as most of the rest of us. Anything you write will be far less superior than the code that is in the majority of even remotely popular open source frameworks. Why? Is it because the authors are smarter than you? That kind of dick measuring has no bearing here. The reason why that code will almost always be better is because thousands, or even millions of developers have used it to build their applications. They have found the bugs, the weak points, the areas needing improvement, and they have hacked away over nights, weekends, pizza slices, and cups of joe to fix those bugs and make that framework or library work better. Leveraging other people's code isn't about succumbing to some evil vortex of mediocrity; Rather, its about knowing how to leverage the combined intelligence of a sea of brilliant people to skyrocket your productivity.
I do know what typescript is and what it does and have had the distinct displeasure of using it. I am no "noob". I have been developing in Javascript for years (waaay before it was "cool") and have always been an advocate of the language even though it gets a bad rep. I personally don't find it helpful to have visual noise showing me type information all over. I break my code into many small functions with clear variable names, and use unit tests and integration tests. I document my interface and I avoid global variables. You will always know what is what when reading my code because the practices I have mentioned lead to clear code.
yes, but not often, and in my opinion it must be very well documented. in fact I can only think of one time, and it was an interface that allowed object literals to be accessed via function. e.g. var foods = { veggies: [], fruits: [] } function fruit(){ manageInternalValues(foods.fruit, arguments); } the way it was used was that it allowed a variable of a certain scope to be accessed outside of that scope without altering any bindings. It went well, and in this particular case was very useful, but I'm with you. Before this popped up, I couldn't imagine the use. It is also very necessary, in my opinion, to document this well. It can appear confusing to a developer who is not expecting it.
Yes so I've done stuff where I had a function like doStuff(knowInAdvance, learnLatter); with the stuff you learn latter coming from an event so I end up with function makeThings(thing1) { return doMoreStuff; function doMoreStuff(thing2) { return doStuff(thing1, thing2); } } obj.on('event', makeThings(data));
start math. functions with a capital letter Math.random()
Hey 3skil, you will still need a static host to serve the content (i.e. Github pages, Firebase, or just a plain-old S3 bucket.) In our experience, this isn't where the pain-point lies (with Github pages you just git push to it and it serves your content); it is the orchestration around building APIs, building authentication, implementing HTTP properly. Basically anything that lies between your function and the consumer of that function. Whilst 'serverless' development is an important use case, another pain-point which we keep hearing actually involves invoking StackHut from the server: when you have your core stack written in one language and need to do something in another language. For instance, if you are on Node need to do something which generally can only be done in Python (image similarity, things with OS dependencies, video/audio handling). Normally, you would have to deploy an entirely new server and hook them up somehow. We would like a setup where you can write your single functionality in Python (or w/e), have it live as a MicroService, and call it from Node (or w/e). This is where JSON-RPC comes in, as we are releasing client libraries to call these functions as if they were native libraries. Would love your thoughts on this. As you can probably tell, we are still thinking about a lot of these issues, and it's going to be users are going to be the ones who provide the answers. It would be awesome to hear your #1 painpoint which you think we could help with.
Thanks for this feedback. I'm going to update the website to reflect this. \o/
Same here curry is all over my React project. Mostly in the form of: R.compose( R.map(createChildComponent), R.map(transform(settings)), R.filter(isTrueOrFalse) )(data); R is this case is ramda which auto-curries most of it's methods and transform in this case is curried as well. 
It can be helpful to pick a framework with a minimal mental overhead. React is a good example of this. You're never going to be able to keep all the api's and internal workings of complex frameworks in your head.
Cool projects? Need a cool and revolutionary idea. Manage code base? Test Processes? take a look to the mozilla projects https://github.com/Mozilla :-)
This approach is good, but works only for single level objects. I wouldnt be able to interpolate nested values using your solution? Suppose I had an object ``` var obj = { hello: { world: 'foo' } } ``` I wouldnt be able to do this: ``` {{hello.world}} bar ``` But with curly I would ;-P
Lot's of people use Ramda.js, where currying is the default.
I would take a look at github repos of projects you find interesting. And then do research on the build-tools/libraries/patterns they are using.
some are functional. some are not.
&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"/&gt;&lt;title&gt; &lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;h1 id="the-h"&gt;&lt;/h1&gt; &lt;p id="the-p"&gt;&lt;/p&gt; &lt;input type="button" id="deco" value="previous"&gt;&lt;input type="button" id="inco" value="next"&gt; &lt;script type="text/javascript"&gt; var word = null; var explanation = null; var i=0; function updateDiv(id, content) { document.getElementById(id).innerHTML = content; //document.getElementById(id).innerHTML = content; } //updateDiv('the-h',word[i]); //updateDiv('the-p',explanation[i]) function counter (index, step){ if (word[index+step] !== undefined) { index+=step; i=index; updateDiv('the-h',word[index]); updateDiv('the-p',explanation[index]); } } var decos = document.getElementById('deco'); decos.addEventListener('click', function() { counter(i,-1); }, false); var incos = document.getElementById('inco'); incos.addEventListener('click', function() { counter(i,+1); }, false); function getViaAjax(url, callback) { // url being the url to external File holding the json var r = new XMLHttpRequest(); r.open("GET", url, true); r.onload = function() { if(this.status &lt; 400 &amp;&amp; this.status &gt; 199) { if(typeof callback === "function") callback(JSON.parse(this.response)); } else { console.log("err");// server reached but gave shitty status code} }; } r.onerror = function(err) {console.log("error Ajax.get "+url);console.log(err);} r.send(); } function yourLoadingFunction(jsonData) { word = jsonData.words; explanation = jsonData.explanation; updateDiv('the-h',word[i]); updateDiv('the-p',explanation[i]) // then call whatever it is to trigger the update within the page } getViaAjax("external-file.json", yourLoadingFunction) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;
I'd pass the results as an array or object. You can even use ES6 destructuring to convert them back into variables inside the second function. doAsync() .then(result1 =&gt; return {res1, res2: doAsync2(result1.id)}) .then(({res1, res2}) =&gt; doStuff(res1, res2)) 
Currying is absolutely fine to use in production - it's a prime feature of JavaScript. It's often used for hiding the scope of variables that have no business outside a certain function and instantiating that variable every time the function is called is not a good idea. Here's a really basic example of a function that returns the color of a teenage mutant ninja turtle. The key/value store can't be accessed outside of `getNinjaTurtleColor` and the data is only instantiated once. You could just use a switch statement, but in a more complicated example that may not be a possibility. var getNinjaTurtleColor = (function(){ var turtles = { donatello: 'purple', raphael: 'red', michelangelo: 'orange;, leonardo: 'blue' } return function(name){ return turtles[name] } })() Edit - that wasn't true currying, because `turtles` wasn't a parameter. True currying would look something like: var readOnlyData = function(data){ return function(name){ return data[name] } } var getNinjaTurtleColor = readOnlyData ({ donatello: 'purple', raphael: 'red', michelangelo: 'orange;, leonardo: 'blue' }) `getNinjaTurtleColor ` works the same way in both. 
One recommendation is to use labels for your inputs, they're there for a reason semantically and provide better interaction for your users (the checkbox in particular.) Other than that, is there anything in particular you're looking for help with? 
I've tinkered a bit with Lambda, and found this, from the FAQ, to hold true: "Q: What is the latency of invoking an AWS Lambda function in response to an event? AWS Lambda is designed to process events within milliseconds. Latency will be higher immediately after a Lambda function is created, updated, or if it has not been used recently." My benchmarking was fairly primitive, but on a Lambda that hadn't been used in 24hrs, there was about a +100ms in request time. On recently run Lambdas, the functions performed favorably when compared to a Node app running on Elastic Beanstalk for identical functionality (no remote calls made from the running code). Perhaps that's not super useful, but, that's where I got with it!
I find myself using more partial applications of functions more than currying itself. https://medium.com/javascript-scene/curry-or-partial-application-8150044c78b8
So what happens when I set a_foo = {}; ? Don't put type in your naming; it leads you to make assumptions that are not protected by a strong type system.
I use currying most of the time I use compose in order to reduce the function arity to 1. I also use it a lot in React when mapping to create an array to insert into the vdom (it allows me to keep the functions elsewhere but still keep the data injection where it is relevant). 
https://www.npmjs.com/package/promise-waterfall Waterfall is basically what you're looking for I think. There are a few different libraries out there to support it.
...what code?
No! Never! Why are people so obsessed with currying?!
I'd remove Bower and add SystemJS/jspm &amp; Karma, but otherwise it's a pretty solid list. You could also mention Slush, but it seems to not have the popularity of Yeoman...
there's an older version of kendo called kendo ui web that is free. and since you're working with a larger dataset, yes, server-side paging is probably a good idea. [Here](https://www.datatables.net/examples/data_sources/server_side.html) is a basic DataTables example of server-side processing, with a link to more complex scenarios.
Neat!
Because it makes for cleaner and more expressive code.
if you plan to do anything with your form elements on the server side, you'll want to give those elements name attributes. so, for example: &lt;input type="email" name="emailAddress" class="input1" placeholder="Email" &gt; also, i agree that you should give your classes more meaningful names. input1, style1, etc are too generic.
Perhaps not, but what if that hash is much larger, or populated from an ajax call, or if the function gets called 2000 times per second. In those cases, you probably don't want to instantiate that hash every time.
No, it's definitely not intensive. But if there were 10,000 turtles and you're going to be doing a lot of lookups, then I'd say it's worth it. Of course, it's costing you memory but that's a small price to pay if performance would be affected otherwise.
That was exactly it. Thank you! 
I think I love you. I love this point, few seem to recognize it. 
So the really simple way to do this would be to have an array or empty object that is scoped outside of your promise resolution functions that you just assign the result of each promise to. There is no need for some over complicated library here. var myObj = new Object(); $deferred .then(function(result1) { myObj.result1 = result1; return $deferred2(result1.id); }) .then(function(result2) { myObj.result2 = result2; return someOtherPromise(result2.someProperty); }).then(function(result3){ // You still have access to myObj.result1 and myObj.result2 }); I have used this pattern quite a bit if I need to store a value from one promise resolution for use in the next or at the end of the chain.
As a blanket statement, no. Situationally- yes.
Could you provide an example, please? I'm just beginning to familiarise myself with React, so this would be very helpful.
Seems like some people may be saying currying when they mean partial application -- http://benalman.com/news/2012/09/partial-application-in-javascript/#partial-application-vs-currying
Couldn't disagree more. Webpack configuration files define entry points and loaders and are less than 100 lines of JS. Webpack provides webpack-dev-server which hosts, watches, and recompiles all of your assets automatically during development. Everything else is simply using CommonJS to require your dependencies. Quick example I found: https://github.com/webpack/example-app/blob/master/webpack.config.js 
Honestly, no. To me currying seems like one of those things that academics or people who are trying to show off or get "ahead of the competition" use. It seems like it generally adds unnecessary complexity although I can think of a few occasional cases where it may be useful, perhaps in frameworks (or libraries) because then internal readability and complexity is not as much of a concern since a framework is usually an abstraction.
Here's a version that works with nested objects/arrays. function tmpl (string, data) { return string.replace(rx, use(data)); } function use (data) { return function replacer (m, key) { return get(data, key); }; } function get (data, path) { var chain = path.split(/\./); var key = chain.shift(); while (chain.length) { if (data[key]) { data = data[key]; key = chain.shift(); } else { return data[key]; } } return data[key]; }
From the article: "If you prefer explicitly configuring small single-purpose tools from the ground up, then Browserify with Gulp/Grunt is going to be more your style. Browserify is easier to understand initially since the conceptual surface area is so much smaller — assuming you already know Gulp or Grunt. When using Gulp with Browserify, the resulting build process can be easier to understand than the equivalent Webpack build. It’s often more explicit about intentions. Browserify’s rich plugin ecosystem means you can get just about anything done with enough wiring." While I agree there's an ultimately a preference presented, it's not quite fair to call it an ad.
Pretty cool, but you can't generate the expression dynamically. it has to be hard coded, which covers maybe half the use cases normal templating does. 
&gt; a new function which **accepts a single argument**, and either executes the original function when enough arguments have been accepted, or **returns a new function that accepts a single argument**. function multiplyByCurried(multiplier) { return function(x) { return multiplier * x; } }
[Thanks bro](http://pre13.deviantart.net/ac6e/th/pre/f/2011/288/7/a/i_know_that_feel_bro_by_rober_raik-d4cxn5a.png)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/reactjs] [Building an analytics dash with React and ZingChart \[xpost r/javascript\]](https://np.reddit.com/r/reactjs/comments/3est71/building_an_analytics_dash_with_react_and/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger/wiki/) ^/ ^[Contact](/message/compose/?to=\/r\/TotesMessenger))* [](#bot)
yeah this function is badly in need of some abstraction, at least on the order of exporting logic to named stand-alone functions. that way you separate behavior from implementation.
One option would be to use `$.when` to wait for all the data. var result1Promise = $deferred; var result2Promise = result1.then(function(result1){ return $deferred2(result1.id); }); $.when(result1Promise, result2Promise).then(function(result1, result2){ });
Yes. I use it constantly. It's absolutely invaluable. I've included a extremely simple example below just to demonstrate one real-world use case but almost every function I write is curried. I've been known to yell at people for writing APIs that aren't curried. let concat = a =&gt; b =&gt; a.concat(b); // set up a var in one place where your images are let imgPath = "localhost:1337/static/"; // then create a prefix function using currying let prefixPath = concat(imgPath); // then map over your urls to prefix. easy peasy let imageUrls = ["one.jpg", "b.jpg", "III.png"].map(prefixPath); //then later when you switch to production just change the var to whatever. imgPath = "http://coolCDN/ftw/user/"; 
While this does work, it means you're creating implicit dependencies in your promise chain, which is something I'd avoid in my own code. 
that's exactly what's written above.
I'd say pretty much always. You ever notice how when you have properly named functions, a promise .then chain reads like english? validateLogin().then(getFriends).then(showFriendsList); Currying basically accomplishes this in every situation it's used if used correctly. // no curry no map var ids = []; for (var i = 0; i &lt; users.length; i++) { ids.push(user.id); } // no curry with map var ids = users.map(function (user) { return user.id; }); // curry with map var ids = map(prop("id"), users); which is more readable?
I find currying in JavaScript especially useful when you want to execute some functionality in a similar context. Some concrete examples (in EcmaScript 6): - In an AngularJS application I've create a `waitForIt` service that waits until a certain variable is set on the scope. However, within a single controller you always have the same scope, so it isn't ideal to have to pass it to the service everytime I call it. Therefore the function is curried so that you can use it like this: const waitFor = waitForIt($scope); waitFor('someVar'); waitFor('someOtherVar'); - When you create a REST interface it often makes sense to curry your http function. E.g. suppose I have an (uncurried) http function with the signature `http(url, method, parameters)`, then currying this function (`http(url)(method)(parameters)`) can result in beautiful code to interface with a certain REST resource: const users = http('/api/user'); const createNewUser = users('POST'); // calling createNewUser(userObject) now does a POST to /api/user with userObject as parameter const listUsers = users('GET'); // calling listUsers() now does a GET to /api/user function user(userId) { const userApi = http('/api/user/' + userId); return { fetch : userApi('GET'), // user(3).fetch() -&gt; GET /api/user/3 remove : userApi('DELETE'), // user(3).remove() -&gt; DELETE /api/user/3 update : userApi('PUT') // user(3).update({ name : 'quabouter' }) -&gt; PUT /api/user/3 with body { name : 'quabouter'} }; } - Currying can beautifully be used to abstract callback error handling. E.g. in NodeJS the standard callback interface is `function(err, result)`, but often error handling is done entirely differently from success handling. So the first thing we can do is create an utility function that accepts an error callback and a result callback separately and returns a Node-style callback that will either call the error or the result callback: function cb(errorCb, successCb) { return (err, result) =&gt; { if(err) { errorCb(err); } else { successCb(result); } } //example in a server application: server.get('/some/url', (req, res) =&gt; { fs.readFile('someFile', 'utf8', cb((err) =&gt; res.status(500).send(err), (result) =&gt; { //Do stuff with the result })); }); However, you'll soon find out that most error callbacks do the same (return a status code 500 with an error message). So if we now instead use a curried version of `cb` then we can do the following: server.get('/some/url', (req, res) =&gt; { const onSuccess = cb((err) =&gt; res.status(500).send(err)); //In this example cb is curried. Therefore by supplying the error callback we're left with a function that accepts a success callback only fs.readFile('someFile', 'utf8', onSuccess((result) =&gt; { //do stuff with the result })); }); EDIT: One more bonus example: a typical (SQL) database connection layer requires you to write code something like this: const handle = DB.connect(username, password, host); const statement = handle.prepare('SELECT * FROM table WHERE id=?'); const result = statement.execute(3); // (Note: usually this is done asynchronous, but for the sake of the example I just let it return instantly). As you can see this requires 3 objects (db, handle and statement) and 3 separate functions (connect, prepare, execute) to execute a single query. By using a curried interface you can do this much more elegant: const query = curry(function(connectionSettings, query, parameters) { //implementation }); const prepare = query({ username, password, host}); const execute = prepare('SELECT * FROM table WHERE id=?'); const result = execute(3); There is now only a single function left, and no objects at all. We just happen to apply the 3 arguments separately instead of all at once. 
Is `Ramda` fast? I would love to use it but am concerned that there isn't a focus on speed, and that all of that auto-currying would slow things down. Is this the case?
To be precise, multiplyByCurried is the curried version of the multiplyBy function, while multiplyByCurried(3) is the function made by partially applying multiplyByCurried.
I guess...nobody knows 😢
All currying does is return a new function waiting on the remaining values to execute the requested code. It's basically free, from a execution standpoint. 
I am wondering this, too (since I live in Nashville and do JS programming for a career now). I think I'm going to plan to attend regardless. Not many JS-focused conferences come to town, so we (locals) need to support them.
I work here, and it is a great spot to be! :) Just moved into an amazing new office right downtown. Great projects, fun people.
http://ucrel.lancs.ac.uk/publications/CL2003/CL2001%20conference/papers/hardt.pdf
You got to pit them against each other so you can pick the one that suits you best :D
I think the conclusion is pretty spot on. 
&gt; I would love to use it but am concerned that there isn't a focus on speed Unless you've explicitly experienced any grief from it, you shouldn't be. It's a huge detriment to the JS community that people are needlessly obsessed with optimizing things like iteration into unintelligible garble.
When you're working on a large website that has a lot of javascript, speed _does_ become an issue. Switching data-manipulating frameworks (for lack of a better term) in big projects takes a lot of time, and if speed is a concern I'd rather not waste it. That said, coming from a Haskell background, I love Ramda and would love to use it. I just can't find any speed benchmarks.
Hey, maybe don't try to brute-force your teacher's password using an account that also posted personally identifying information?
gross
`mocha --ui tdd --compilers js:babel/register` i've been using that without issue
It's the same learning any subject. To become an expert you must read and work beyond your comfort zone. You must have enthusiasm for your subject and spend a significant amount of time on it. End of story.
As of late the performance of Ramda seems to be declining from release to release. There are several methods affected. In some cases the methods are slower than those in [eweda](https://github.com/CrossEye/eweda) which is described as *"A (probably im-)practical functional library"*. I suspect its perf issues are related to a combo of things.
Yes. I hate it, it makes me think too much - the function arguments and the returns and stuff is difficult to keep track of. Maybe I'm doing it wrong? async.waterfall([ function (callback) { validate.token(req, callback); }, function (callback) { validate.game_id(req.params.id, callback); }, function (game_id, callback) { model.Game.Get(game_id, callback); }, function (game, callback) { validate.game_admin(req, game, callback); }, function (game, callback) { model.Game.Update(game.game_id, req.body, callback); }, ], function (err) { if (err) res.json({'success': false, 'error': err }); else { res.json({ 'success': true, }); } }); 
&gt; other than using named functions over anonymous functions and relyning on modularization Yeah but those are *good* ideas :) This code's gonna be a pain in *any* paradigm if you insist on writing it as a monolith.
This is a really bad article, seems like it was written by someone who just learned javascript and read the chapter on scope.
Yeah. I just c/p in here, though, after making the quick adjustment.
What about jspm?
I'm a webpack convert after working on implementing it in our new project, one thing to be aware of which isn't really highlighted anywhere is that when you specify CommonJS as your target in you webpack config, it's actually pure CommonJS, as in exports.something = function() {...} What you really want is CommonJS2, which allows you to export functions with out the key value pair so you can go module.exports = function() { ... } This had us destroyed for a few days, we almost just accepted that things needed to be key value pairs until the guy I work with discovered CommonJS2 lurking in the dark corners of the docs. Overall I think webpack is a much more fuller build tool, it has the ability to highlight issues at build time rather than run time, it can do things like split out commonly used code using the common chunks plugin to reduce duplication, it's library of loaders and plugins do almost everything you'd want to do in a build process, but it does take a while to wrap your head around the configuration and I think that's going to be the area where it receives most resistance. 
Most of your nested callbacks don't use anything from the enclosing scope. Name and define those functions elsewhere and call them by name instead of nesting them inline.
&gt; var doThis = (x) =&gt; x &gt; 0 ? true : false; const gt0 = x =&gt; x &gt; 0; &gt; Anonymous functions (called Arrow Functions in ES6) ... &gt; Well because it’s no longer a String prototype. Aaaah. &gt; So now we see the issue with the global scope. The problem was that you changed the type. &gt; to get a list of objects from the DOM No, that's a jQuery collection. &gt; Guess where that $ resides? That’s right, in the global scope. Not necessarily. &gt; This let’s us know already that the global scope isn’t BAD. Yes, and guns may be used to shoot bad guys. Naturally, everyone should have a gun or two. Being able to stick useful things in the global object does not mean that doing that is a good thing. It's just what people did prior to modules. Man, this article is terrible.
(One of Ramda's authors here.) It's definitely not free. The goal is that its cheap enough that the improved API is worth a slight extra cost. jdalton claims above that it's getting too expensive, and I'd like to have details, because usually when we have them we can fix the issues. But we've heard almost no performance complaints from users, so it's not clear how much of an issue this is in the real world.
Thanks for this. I posted this before another user posted a link to the source. Much more in depth than the examples of manual currying you see online. I'm new to the idea of functional programming, but Ramda is so far the only thing that's made me see benefits. I'm trying to apply the ideas elsewhere now. 
 // in reality, this would be got from a environment config const prefix = "localhost:1337/static/" let prefixPath = (img) =&gt; prefix.concat(img); let imageUrls = ["one.jpg", "b.jpg", "III.png"].map(prefixPath); How is your example any different to writing a function to do the concatenation? What does currying give you here that a plain function doesn't? Edit: using arrow function
man that is some tightly coupled shit. 
Might want to take a look at your CSS [1]. It gets worse for 4+ dice with more overlapping and the total is hidden by the roll button. The rolling effect is definitely neat, although I agree with PING that it could use some polishing. [1] http://i.imgur.com/2oFa0Aq.png 
Hi /u/emberscreencasts, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `emberscreencasts.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [emberscreencasts.com](/search?q=%28and+site%3A%27emberscreencasts.com%27+author%3A%27emberscreencasts%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|12|100%
Why not use a Map instead of an object? 
yeah, it's actually the server side code i was having trouble with. converting the expressions passed by the grid to a linq lambda expressions was where I was struggling. I loaded up 10k records into a table with random data but I didn't have a shot to finish testing today as something else came up. I saw a MVC datatables project I will check out if the the loads times are unmanagable. Never worked with MVC but how hard could it be, right?
I've yet to try Webpack, so I couldn't say which is better or worse. But I do agree with [terrorTrain](https://www.reddit.com/user/terrorTrain) that this article is an ad for Webpack. It asserts rather than explains. Over the last few months I've been using Browserify for a few things. I've found it to be simple. Along with other tools, such as watchify and babelify, it covers all my requirements so far. I've also found that I don't need to use Gulp anymore either. I've found the following useful and informative: [browserify for webpack users](https://gist.github.com/substack/68f8d502be42d5cd4942) [task automation with npm run](http://substack.net/task_automation_with_npm_run) If I read something a bit more like these two from a Webpack advocate then it would be more likely to persuade me to give Webpack a try.
Why not just use `.bind` for partial application?
one is reusable, the other isn't. 
I see your point. But I don't really think one the above is "more readable" it's more understandable because you're familiar with the array.prototype.map function. The cost of typing ctrl + f in the docs is well worth the reusability currying offers. Calling inline as in the example above doesn't showcase this, but normally you'd write. export let getIds = map(prop("id")); then re-use this in multiple places in your application. When you read. let ids = getIds(users); it doesn't really get any clearer than that.
Angular has a massive API. I don't see many "Why would anyone ever use angular" posts. Currying is useful pattern. I think you might be missing the forest for the trees.
&gt; Grunt’s failure wasn’t configuration. It was a lack of opinion. The problem, is when you disagree with that opinion. Grunt/gulp are modular, and do what you want them to do. I don't really have experience with webpack, but this is the antithesis of a sales pitch. I'd rather be in control, not the other way around.
They don't. Most of the guides still use callback soups, lol.
Thanks! Great examples. I especially liked the REST API - really elegant.
Webworkers maybe.
Part 2 is here !!! https://underthehood.myob.com/changing-of-the-guard-in-web-technologies/ 
You just have to return the control to the UI thread every ~50 msec or so. http://jsfiddle.net/wm8n7kaL/ setImmediate would be nice for this, but only IE supports it. The '0' I pass to setTimeout is actually clamped to 4 ms. A Web Worker would of course also work.
Well, maybe your code is "too big", but really, you're not making it easy to help you at all by just showing images with pieces of code. In any case, what you _are_ showing us, indicates that there's more relevant stuff going on. As an example, you're inserting `id`s on some elements and you're hiding some of them. It's hard to diagnose a problem when you can see just a couple of captures, but it's even harder when you can't even see all of the relevant code. Please, do consider setting up a _small_ example with your code. Otherwise, you probably won't get much help.
&gt; It leaks memory and slows down program execution the longer you run. It does? Show me. http://i.imgur.com/k7z9dmG.png I added "&amp;&amp; false" in line 9 to make it run forever. I don't see it. I also don't see what's supposed to leak there. (This also isn't recursion.) By the way, games which use requestAnimationFrame do exactly the same thing.
you css classes should reflect the data. &lt;span class="first-name"&gt;Joe&lt;/span&gt;
Use some techniques from callbackhell.com
&gt; dynamically. it has to be hard coded, which covers maybe half the use cases normal templating does. Can you give me an example of what you're thinking of?
Well it supposes the existence of a `callBuilder` function, which takes `resource`, `loadingPromise`, `successPromise`, `errorPromise`, `finallyPromise` AND the object (`cust`) to put/post on the resource (maybe it should also take the method). It also assumes the existence of a `curry` function, that would take a function and allow it's arguments to be curried one by one, each time returning the function with it's arguments set at that point. So you're saying 'I wanna curry the `callBuilder`' and you start sending every argument there one by one except the last one (`cust`). You get that function and put it down as the handler for `saveCustomer`, which, as far as anyone else is concerned, only takes `cust` and saves it. But in reality it's a dynamically generated function enabled via currying because you were tired of repeating the same code.
I've opened it on a tablet first. It run slowly enough to make me think it's infinite loop. On desktop, result is being produced immediately. In some implementations (Old IEs and Firefoxes) fn = () =&gt; setTimeout(fn) is called recursively and can greatly slow down the browser (after 30 minutes of 1ms setTimeout) It basically looks like this: http://jsfiddle.net/6ohjfmqx/ (Console: too much recursion) I've rewritten your fiddle using setInterval. (Every millisecond 10'000 tries). Result is simpler, doesn't hang the browser and one can control the maximum throughput by controlling number of tries, rather than depend on the speed of the machine as is with your fiddle (tablet - 2 minutes, desktop - 2ms). setInterval: http://jsfiddle.net/ng1b3gwn/2/ 
It's slower, badly supported and the scope chain gets longer. In most cases it's better to use functional approach instead..
Even more compact version, but with coffeescript apiPath = "http://api-global.netflix.com/" func = (window, getJSON, showMovieLists, showError) -&gt; observeMovieList = getJSON(apiPath + "abTestInformation").concatMap (abTestInformation) -&gt; urlPrefix = abTestInformation.urlPrefix movieLists = getJSON(apiPath + urlPrefix + "/movieLists").pluck("list") Observable.concat movieLists, getJSON(apiPath + urlPrefix + "/config").concatMap (config) -&gt; return getJSON(apiPath + urlPrefix + "/queue").pluck("list") if config.showInstantQueue Observable.returnValue undefined return return Observable.zip(observeMovieList, Observable.fromEvent(window, "load"), ((movieLists, loadEvent) -&gt; movieLists) ).forEach showMovieLists, showError return 
That makes sense, I could always use asynchronous operations inside synchronous ones. Haven't heard of highland.js, thanks for the suggestion.
&gt; I think you should point us to the problematic piece of code, would be helpful. Unfortunately the PM2 logs only show exactly what I mentioned in the comment, no stack trace. &gt; Before you go any further... I have read through the readme regarding `nextTick` and the call stack, but I still wasn't clear on exactly *when* to be using it in the context of my application. &gt; I got to a file in your queue folder where you bind your task to async queue, looks like it happens a lot for each of your added tasks Are you referring to `@queue = async.queue @process.bind(@)`? That's only called once when the task is created. It just wraps around the async.js queue, specifying that the queue should run `this.process`, passing the task and callback. `process` then calls `next`. 
Because React automatically binds all component methods to the correct context, so using `.bind()` would mean passing an unnecessary first parameter. 
Thank you for the comment! I usually use the JSDoc comment template to document my work (and largely rely on that format for commenting my work, though I also tend to put some comments throughout my work). Do you think that JSDoc is a good idea? I usually have it on a Gulp task to generate documentation pages.
Thanks, but the promise2 request is dependent on the result from promise1.
Good job! glad to see the project growing.
I'd much rather get it closer with ES6 syntax (not a fan of coffeescript and sig whitespace) but sure. The string concatenation, more concise returns, etc. It still feels like a forced example to me.
Thank you kindly! 
&gt; A Promise is simply an Observable with one single emitted value. Rx streams go beyond promises by allowing many returned values. https://gist.github.com/staltz/868e7e9bc2a7b8c1f754
Hi /u/sporeganic, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Doh, my bad. Sorry about that, should have paid more attention. 
this is great stuff. keep it up! I get functional programming for data manipulation, but how do you handle user interaction?
My apologies. I wasn't aware those were testing frameworks. Whenever anyone comes on reddit and talks of their latest project using a dictionary list of frameworks I've never heard of, as if they came down from the mountain top with their stone tablets, I automatically think, "One who builds on the shoulders of other people's work" and wait for the wavering mess to tumble to the ground.
&gt; See, in .NET there is no such thing as the global scope per say." Uh, yes there is. You just don't hear about it because they've done such a good job promoting namespacing. https://msdn.microsoft.com/en-us/library/c3ay4x3d.aspx &gt; Guess where that $ resides? That’s right, in the global scope. This let’s us know already that the global scope isn’t BAD. Pointing to jQuery as an example of GOOD global scope pollution is laughably wrong. Maybe you should look into the history behind https://api.jquery.com/jquery.noconflict/. &gt; We just created a namespace! For all you .NET junkies out there, I think I may have just made your day when you work with JavaScript next time! No, you created an object literal. It kind of looks like a namespace, but you should use modules/revealing modules instead. .NET junkies (of which I am one) should know that javascript is not .NET, has different paradigms than .NET, and you should learn those and not expect javascript to ever be .NET. Read this: http://addyosmani.com/resources/essentialjsdesignpatterns/book/ 
I 2nd this question. And how does Functional programming differ from Functional Reactive programming?
In ES6 code - which for personal projects is all of it now - I use EsLint to enforce that "var" is never used. It's broken and causes pain. I use const almost everywhere. The only time that I don't use const is when a value is explicitly going to be reassigned - which is surprisingly rare - or annoyingly when a value is going to be assigned once but the value to assign to it is conditional - so where you'd assign a value differently in different branches of an if/else, for example. (Yes, Ternaries are an option, but they're harder to read)
var behaves very differently to both let and const, so if you're going to use const, use let with it for consistency. I use let if the value changes or I'm going to mutate the object, and const otherwise.
That is exactly what I you would use flux for. Flux takes a while to click but it becomes very easy to pull off, and react in general is very nicely readable and easy to organize, especially when you're using jsx as well.
I use `let` for variables I know will change, for example the iterator in `for` loops. Everywhere else, I use `const` and never use `var`. 
Sure, they are both valid choices. We went for webpack because it fits well with out Grunt based workflow: we have pretty complex build files that have to do a lot of stuff beyond transforming files and grunt+webpack fits that very well. If find gulp less suited for random tasks, and browserify to much hassle locating the modules you need and plumbing it together (they never quite work right together if you want the fancy stuff like multiple compile steps with sourcemaps).
`const` is the new `var`. `let` is only used when a variable's value will change (not common)
First: In this example, they just get converted to `var`'s with babel, and is also fully supported by babel. No longer of a scope chain in this example either. Second: Can you provide quantitative support of your claim of it being slower?
[**@misok**](https://twitter.com/misok/) &gt; [2015-05-14 06:57 UTC](https://twitter.com/misok/status/598743831769669632) &gt; @timorantalaiho @milankinen we ran into perf. problems and bugs a few too many times at the @ReaktorNow \#codecamp. Promising, but not yet. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Last year it had the feeling of a community gathering with exceptional talks ( mine excluded :) ). Really chill, relaxed, friendly vibe. The organizers put a code of conduct in place and even wrote their mobile numbers on the dry erase boards of each room. The space it was in was roomy and wasn't crowded for the amount of people that was there, except for the corridors. Several talks were going on at the same time, so there was always something to see. The provided lunch was good, the volunteers also kept everyone stocked on snacks, soda, and water. I came away with a bunch of new friends and neat stuff to try. This year I signed up to be a volunteer, just to help out. From what I've heard from the community, this year's space is bigger. There's scheduled keynotes from Doug Crockford and Yehuda Katz. This year is shaping up to build off the great success of the last one. I'm excited.
Use`const` as much as possible, use `let` when you can't, never use `var` for any reason because there is no reason to use `var` so never use it for any reason
I'd say "broken" is overstating it. Some people don't understand the hoisting that happens, but I don't have a problem with them, if you use a linting tool to make sure they're at the top of the function. EDIT: "Let" is definitely more intuitive, though.
I just meant it happily meets /u/_doingnumbers's definition of currying as /u/tencircles managed also to highlight, without being down-voted
you should check out [Brian Lonsdorf's talk](https://www.youtube.com/watch?v=0wgDGTgOPds) on the subject.
I do this too. 
I know that it can, but I think it’s more of a quirk. You’re sort of saying, ‘this value will not change’, and then changing the meaning of the object. I guess this is a lot more about opinion.
I do this on occasion, but I just personally don't like it. The problem comes when "condition" gets more complicated, and when you want to nest them as well. Especially something like: const suffix = (n == 1) ? 'st' : (n == 2) ? 'nd' : (n == 3) ? 'rd' : 'th'; That's just not pretty. Instead I'd just do: let suffix; switch (n) { case 1: suffix = 'st'; break; case 2: suffix = 'nd'; break; case 3: suffix = 'rd'; break; default: suffix = 'th'; break; } What I really wish I could do is to use if/switch/etc as an expression, so I can instead do: const suffix = switch (n) { case 1: 'st'; break; case 2: 'nd'; break; case 3: 'rd'; break; default: 'th'; break; } like some languages are starting to do these days, but that's not (yet) possible...
What do you think of this for more complex variable assignments? const value = (() =&gt; { if (condition) { return 'something'; } if (otherCondition) { return 'something else'; } return 'default'; })();
Solution for year 2015: use arrow function or `fn.bind`
how exactly is `var` broken? can only assume you imply people's understanding of hoisting and out of scope var declarations leave something to be desired. I would consider blanket statements like that more harmful as they don't promote understanding but drive fear instead. we are afraid of eval. we are afraid of with. we are afraid of coercion. we are afraid of extending native prototypes. damn it, we are afraid of undefined being reassigned. etc etc. all because it's hard to explain to people. 
In my experience, Flash and Silverlight developers tend to make much better Javascript developers than people who have only done Javascript since the early 2000's. 
That's because the only way to do anything interesting on the Web in the early 2000s was flash. JS was pretty much just used for form validation and whatnot back then.
Reminds me of the time I got my company to switch to an XSLT-based CMS...
I definitely agree with reducing as much dependencies as possible. I was even thinking of removing my dependency on caolan's async package by just utilizing the es6-promise package that I already use.
&gt; how exactly is var broken? Function scope just isn't the right one. You want stuff like counters for your loops or temporary variables inside loops or branches. Block scope does that. &gt; we are afraid of eval. Eval is rarely needed. Beginners often use it by accident (e.g. calling setTimeout with a string) or because they don't know that they can write foo['bar' + i] instead of foo.bar5. It also breaks optimizations and it may cause security issues. &gt; we are afraid of with. It's ambiguous and breaks optimizations. Without knowing every possible state of every object which is passed here, you can't tell what's happening. You can't use `with` in strict mode. &gt; we are afraid of coercion. Coercion hides errors. Getting a type error is preferred. &gt; we are afraid of extending native prototypes. http://www.nczonline.net/blog/2010/03/02/maintainable-javascript-dont-modify-objects-you-down-own/ By the way, this is also the reason why we can't write `someArray.contains(...)`. It was renamed to "includes" in order to avoid breaking shitty websites which use a shitty lib. &gt; damn it, we are afraid of undefined being reassigned. The global `Infinity`, `NaN`, and `undefined` properties are read-only since ES5.
Good [Read](http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html)
This, definitely. When I used grunt/gulp I never felt that their downfall was lack of opinion (which is what the OP's article argues). I found their downfall to be that they require a ton of boilerplate code/dependencies for seemingly trivial tasks. With npm scripts you get the freedom to do what you want, and the configuration is very straightforward. I have a number of websites/apps now that use TypeScript (tsc, tsd, and tslint), LESS, Browserify/Watchify, and Cordova. I'm able to manage everything using npm scripts in only about 20 lines of code in the package.json. What makes npm scripts really great is that most often you are requiring the exact dependency you want (i.e. if you want `typescript`, require `typescript` not `grunt-ts`). I am willing to give webpack a try if someone comes up with an informative article outlining how webpack can be minimally invasive and easy to work with, providing specific examples where possible.
Vue.js !
By the time silverlight came around, it was already easy to create very rich javascript-based web applications. If were talking about flash and 5 years earlier, you had a point... but I don't think there was ever a reason to do silverlight, unless you wanted to use their video components or heavy animation.
In term of flux implementation, we looked at several including Fluxxible, Flummox, Fluxxor and Reflux. The one that hit a cord with us was really Alt.js: http://alt.js.org/ We are keeping an eye on Redux as well as it comes with nice ideas but its API are evolving and it is not yet production ready. Also we are hopeful we will see some of Redux idea in Alt.js later on. 
I found most polyglot programmers are able to form better abstractions because they experienced different environments with different features and limitations. 
returns are optional. I just make sure that functionality is fully equal yours (no return values at all). IMHO. Callback hell is really better solvable with iced-coffee-script. Less LOC - more useful information on the screen.
One of the very, very few things I miss switching from Coffeescript to ES2015 is being able to use an if statement as an expression. processor = if reqType == 'html' htmlProcessor else jsonProcessor Whereas in ES2015, you end up with: let processor; if (reqType === 'html') { processor = htmlProcessor; } else { processor = jsonProcessor; } One thing you *can* do though is this: const processor = () =&gt; { if (reqType === 'html') { return htmlProcessor; } else { return jsonProcessor; } }(); Not sure how to evaluate the tradeoff; the IIFE adds some syntax noise, but it's nice to be able to correctly declare processor as a `const`. (All code written from memory without even checking for typos. Don't expect too much, but hopefully what I was trying to say comes through.)
How did that work out for you? Was it Symphony? I'm quite a fan of XSLT, even though that's an unfashionable opinion now. EDIT: Symphony rather than Symfony. 
Agreed. It's power was never really appreciated.
I just started a JS job after 7 years as an AS3 dev. The transition has been pretty painless. I love Flash and AIR. But the well is dry. I'll still tinker at home with them for fun though.
Chrome 45+ (current beta, next stable) also supports arrow functions and spread. That's probably a bit more exciting. `Array.from` can also be used to generate arrays. While I would have preferred something separate (à la Dart's `List.generate` constructor), it does the job just fine: &gt; Array.from({length: 5}, (v, k) =&gt; k * k) [0, 1, 4, 9, 16] What I would have preferred: Array.generate(5, x =&gt; x * x)
Symfony isnt a CMS edit: downvoted for correcting someone? Stay classy.
https://www.reddit.com/r/javascript/comments/3ewqi4/your_opinion_on_using_const_let_and_var/ Not a single mention of it being slower. In-fact it looks like everyone in that channel thinks `var` shouldn't be used anymore.
Had a feeling I'd get the spelling wrong I meant [Symphony](http://www.getsymphony.com)
Yeah. Python and JavaScript have made me a far better programmer than ActionScript did alone. I want to find time to poke at C++ or Java a lot more to get more depth into lower level stuff (while still resembling what I know). 
I don't recall. I remember bi-directional communication being an important feature and websockets were not available. We could hack it in WCF with SL4 I think... It was also helpful for us to be able to write once and have it look great on Mac and Windows, regardless of browsers. A lot of developers were able to transfer their C# and NET skill sets into the SL platform. We were able to interop with products through COM interop when running out of browser (was hoping that would make it to MAC's scripting environment). These are just some of the reasons why we went this path. I have no doubt you could make JS rich applications with IE6 &amp; 7, but there was also a lot of effort being put into making those platforms work well with Chrome &amp; FF. There was a lot of appeal in getting the same experience regardless of browser. We get that now (looking at you safari) with pretty good implementations across modern browsers.
Yet you hear people making this comparison as fact- particularly when HTML5 was a bigger buzz word. Then the more simple minded consumers start repeating it and people get confused, thinking JavaScript === application framework. All "Dude, JavaScript is so slow! It lags my browser so much!" because they're thrashing the DOM or something. Someone has to point out the difference, especially when many inexperienced/young developers come to this subreddit. It's like when an employer is interviewing a potential employee, they ask what languages they know and the reply is "I know jQuery!".
Thanks for ur reply, yes It is stupid of me to have written "!true" instead of "false". Well, it is not working when ever a bullet object is created and added to the array and collides with an invader it doesn't disappear neither does the invader :/
Block indent your code by 1 tab or 4 spaces before pasting it here. This line started with 4 spaces { 'this one with 6'; } // 4 again Also, post a test case on jsbin or jsfiddle. Alternatively, link to the live version.
It's a frustrating experience for sure; but I think of it as being similar to telling my parents what I do and why I get paid as much as I do. They are impressed by the numbers involved but clueless as to how there is any complexity in what I do.
Learn C. It's much simpler than either and will open your eyes to memory management.
https://esdiscuss.org/topic/performance-concern-with-let-const If your code is like this: function () { let a = 1 You could use var instead. No need for babel.
It's not a quirk. It's what "constant" means in programming languages. Constant means it always points to the same thing. So if `const x = 5` points to an integer value `5`, it will always point to that same value. Not 5, the integer, but the same *value* of 5. With primitive types like numbers and strings, these are equivalent, because they are **immutable**. Objects are mutable, though, so it's a little different. Put in a formal way, any operation we do to `x` must always equal the old `x`. A.k.a: f(x) === x // f is some operation Assigning a new value to `x` would negate that. Adding 1 to `x` would negate that. But... If `const x = { a: 1 }` points to an object, then it must always point to that object. We cannot create another object, e.g. `{ a: 2 }`, and assign `x = { a: 2 }`, because x is a constant (must always point to the same value aka the same object). However, setting `x.a = 2` is OK, because we are not changing the value (the object) that `x` is representing, only it's state. The object that `x` points to is still the same object. We could make it **immutable** using `Object.freeze` or any library that offers immutability. Then, even doing something like this: let x = Object.freeze({ a: 2 }); x.a = 3; // ERROR! Which is more in line with what you're thinking of.
Show me a proof it's better now. Also I think that: "If it ain't broken, don't fix it." - why add more complexity when "var" works just fine?
Exactly, if you wanted to make a RIA, Flash/Flex or Java was the way to do it. I was really resistant to moving over to JS, since AS3 had all the goodies I like with a class-based OO language. JS was a toy language for gluing AJAX calls to UI at best. But then all these engineers flooded the JS world and now we have mature frameworks, automated testing, ES6, transcompilers for strict typing, polymer, build tools, and I love it. Even though I'll complain every time there is something new, I do get a kick out of the variety.
01010101010111101010101011010101010110101101011010101011101011010101011011110110
I just don't see the point here to use "let". There might be some rare use cases for it, but I think having fewer scope layers is better (if you use let everywhere, compiler creates scope for every block, not just functions). Also makes code harder to read/understand with added complexity.
Hm. I was thinking the OO part would make it easier as I could make exercises out of reimplementing things I've done in other languages. But hmmm. Maybe that would break it up more, keeping it a bit more approachable. 
When it gets converted anyway, why to use "let" in the first place?
I would probably do something more along the lines of: function chooseSuffix(choice) { const suffixes = { 0: 'st', 1: 'nd', 2: 'rd' }; const default = 'th'; return suffixes[choice] || default; } const suffix = chooseSuffix(n);
The point is preventing scope clashes. Fewer scope layers is not better. Global variables are the devil.
I don't find "var" hard to understand and since having the scope flatter is better for performance and for V8 optimizations, I don't see any reason to use let/const. Plus: https://coderwall.com/p/ey0j_w/es6-tranceur-vs-standard-javascript-performance I also like JavaScript's minimalism and don't want to make the code harder to read/understand.
So what have you been using for hash structures? Tree structures? I lost interest in JS when I couldn't build performant data structure.
sorry about that, [jsbin](https://jsbin.com/qeducohoda/edit?html,js,output)
i would honestly say having var adds more complexity because it introduces way more open scopes, and more chance for bugs. Its definitely broken, it should be fixed.
Top comment ITT mentions that their agency now uses AngularJS so I'm not too sure about that.
It's slower to search from the outer scope and with let you get new scope for every if, for, function etc..
In for loops I understand why to use let, but that's the only case for it..
Huh? Those are two completely different things. Node doesn't do video and Silverlight doesn't do server-side programming.
Here is an example: http://jsfiddle.net/m3yw1gu7/ The interesting bit is the "intersect" method which returns `false` as soon as it finds a separating axis. If no separating axis can be found, the two rectangles must overlap. (Separating Axis Theorem aka SAT.)
 const suffix = ['st', 'nd', 'rd'][n - 1] || 'th';
I thought this was the purpose of JSON? Or am I misunderstanding?
&gt; [var] is better for performance and for V8 optimizations Citation needed. It also isn't "flatter". It's just less local. &gt; Plus: https://coderwall.com/p/ey0j_w/es6-tranceur-vs-standard-javascript-performance That article is over a year old. Traceur doesn't use try/catch anymore and neither does Babel. Also, Firefox, Chrome (strict mode), and IE11 already support let/const natively.
your collision detection would need to look something like this var Collision = function(object1, object2) { return !( object1 === object2 || (object1.position.x + (object1.size.x / 2)) &lt; (object2.position.x - (object2.size.x / 2)) || (object1.position.y + (object1.size.y / 2)) &lt; (object2.position.y - (object2.size.y / 2)) || (object1.position.x - (object1.size.x / 2)) &gt; (object2.position.x + (object2.size.x / 2)) || (object1.position.y - (object1.size.y / 2)) &gt; (object2.position.y + (object2.size.y / 2))); } If you would like further explanation, let me know. 
Map(), Set() Also if your application is limited by the performance of the data structures then don't write it in JS. (Unless you are just assuming it won't be fast enough, in which case actually test it first!) Use the tool that's best.
The trouble is that C++ is a big mess, and Java is a sort of mid-level language - it has garbage collection and all that, the main thing that makes it feel lower level than Javascript or Python is that it uses strict types. C on the other hand is a genuinely low level language. You still have modules and structs, which give you some OOish abilities. 
So you would say you saw a dramatic productivity increase switching to React + Flux vs Angular? How long does it take to get junior devs up to speed compared to Angular? I don't want to miss out on the next big thing and be stuck with legacy Angular code, the 2.0 rewrite is the only thing that really has me worried big time.
Map() and Set() indeed, but they're [ES6](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) and I was trying to do this two years ago. Any network/graph algorithms require fast data structures, so I gave up.
JSON is only for serializing JavaScript Objects [using a standard] Notation. JS Objects are **terrible** as key-value lookups due to performance, gotchas, reserved words, etc.
It's too bad you can't extend js in c or something. When I want a really tight loop in ruby, I'll write write the function in c and compile it into ruby. That way you can optimize the code that needs it and still have the rest of the app written at a higher level.
So long as I write simple code that targets older browsers without transpilation, polyfills are as far as I go in the world of ES6.
&gt; mutate the value I think you meant "reassign the variable" because that's specifically what you can't do when assigning with `const`; as NewazaBill elaborated, what you'd need to do to make an object *immutable* is with `Object.freeze()`, probably recursively so you can't change anything about it. If you're `const` assigning a primitive value, however, the distinction seems pedantic, because primitive values are inevitably immutable and have been since the beginning of JavaScript; this means if you can't reassign a variable containing a primitive value, you can't change anything about that variable.
Well its much better today. Also add in typed arrays and buffers in the browser as well. They are stupid fast when used correctly. Also don't just assume that the data structures in JS can't keep up. It might take a bit more knowledge of how the underlying VMs work, but with some tuning its possible to get pretty damn fast speeds from normal JSON objects or arrays. The VMs will do their best to use underlying performant structures when possible.
Wow, good to see things have gotten so much better. I still don't particularly care for the various JS inconguities/gotchas, but it's much more feature-complete than it used to be.
https://github.com/Khan/perseus https://github.com/rackt/react-router
You are, a little. There's two basic datastructures that nearly every js app is going to use: the Array, and the Object. An array is a little closer to its classic definition than, say, PHP's array is, but it's far from what an "array" is in C, and meant in general to represent any mutable dataset ordered by index. An object, conversely, has no predefined order, and it's just a hashmap (this is what JSON -- technically a separately defined format -- loads as). Even if you have an object `{a: 'foo', b: 'bar', c: 'baz'}`, it technically has no order, and without logic around it to enforce the behaviour, you can't rely on property "a" coming before property "b". If you're in a language like C or Java, much of the syntax and libs are dedicated to defining data structures based on their low-level behaviour. The syntax in JavaScript is focused more on high-level behaviour: the logic that your datastructure should follow as observed by those calling it. So as a JavaScript developer, you can look at a fairly complex dataset defined in JSON, but it's not necessarily optimized to run very quickly for what you're doing. I am noticing that this is changing quite a bit. In addition to the upcoming harmony datastructures /u/Klathmon mentions (Map and Set), there have also been `TypedArray`s out for a while. These look more like traditional arrays, which simply define an extent (over an arraybuffer), and then the Unit8Array or Float64Array, etc. you define simply defines how to iterate it and compute offsets within the buffer. I'd recently started using it to do some low-level work in rewriting a gameboy emulator as modern es6 JavaScript with ReactJS, and these TypedArrays were perfect for modelling a memory space with 8-bit registers: https://github.com/jkoudys/ReactGB/blob/master/js/utils/emulator/z80.js#L43 All that said, the v8 engine and its JIT can be downright magical, in both the best and worst possible ways. Sometimes it figures out exactly what you mean when you setup a more complex datastructure, and other times a tiny change takes efficient processing down to garbage. Probably the worst thing for it to figure out is in pruning trees and removing nodes -- downright trivial on a good C implementation, with simple pointers, but taking a large array (or even object) and deleting nodes can confuse the hell out of v8.
&gt; Also, Firefox, Chrome (strict mode), and IE11 already support let/const natively. I should go ahead and look up exactly which versions of Chrome are like this, and then update Emoji Polyfill accordingly; I had been holding off in the interest of supporting extremely old and rarely used versions of Chrome.
Yes and no. Most JS engines will already use the same "backend" for stuff like Map and Set of you ONLY stick to some of those features, so by letting the features enforce it, the transpiler can generate code that helps "hint" the VM about what you are doing so it can choose the best underlying tech and get the best performance. On the other hand many new ES6 features are very slow right now because they are "not optimized". Scroll down to the list of unsupported syntax [here](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers) to get an idea of what will cause slower JS code, then review your transpiler output every now and then to see if any of those are creeping into your code.
I understand I have a problem and I would like to fix it. I highly appreciate you taking the time to point out my flaws and provide me with insight how to do them. Why do you choose Angular over React? What do you use as far as backend goes? Database + routing/framework if you don't mind me asking, if there is a preference. I have a colleague who has the exact same mindset as you on the topic of my framework choice. His counterpoint is that I achieve many incredible things in a very short amount of time that don't fall apart, so I'm curious as to what the true drawbacks are. I do work alone, however. That is one benefit. I wrote a mini-framework that I believe people like myself would benefit from/want to conform to opposed to having to learn the nastiness that is Angular. I could be dead wrong though.
I spent the better part of last night reading this article and trying to understand the innards of Neural Networks. This is just the start to his book. All his examples are in JS. http://karpathy.github.io/neuralnets/
Thanks. I'll keep that in mind.
The data itself isn't stored, a reference to the data is stored. Think of the reference as a note that JavaScript uses to remind itself where to find the real data when it's needed.
Thank you for your detailed reply! That helps me understand much better :)
Most people I know have seen pretty massive productivity gains from using React. &gt; How long does it take to get junior devs up to speed compared to Angular? Much less time, as long as you can convince them that markup in JS isn't evil. The time required to truly learn Angular is pretty vast. Indeed, Angular has a reputation for being hard to learn. Besides, I wouldn't want a junior dev working on my Angular 1.x teams. Angular has countless pitfalls, and a few mistakes here and there will result in nearly impossible-to-diagnose bugs and performance problems. React is very easy to learn. You can become productive with it very quickly. Flux on the other hand is a bit difficult to wrap your head around. I've found that they pick it up pretty quickly if you have well-written Flux code in your project for them to base theirs on. I would recommend [Alt](http://alt.js.org/) for now.
Private...ish. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols &gt; let o = {[Symbol()]: 5} undefined &gt; let s = Object.getOwnPropertySymbols(o)[0] undefined &gt; o[s] 5
Good answer. My feelings as well.
This is fair. "You have to be able to debug at the level of abstraction". This was something a lot of xml technologies never got quite right.
There are people who have only done JavaScript since the early 2000's????? I don't believe you.
The online repl for babel doesn't seem to transpile the array methods, I wonder why? http://babeljs.io/repl/#?experimental=false&amp;evaluate=true&amp;loose=false&amp;spec=false&amp;code=%5B123%2C123%2C123%5D.fill(5)%3B%0A
It is not generally useful but it does come in handy with ES6 because we can now use this feature to emulate private properties by using Symbols as an object property.
Assembler for x86 is easier and will open eyes on everything inside a PC.
My worst memory was the CS version upgrades. Adobe continually strove for feature bloat, while breaking more basic features that worked. So if you opened an old project with the new version, it was like russian roulette whether previous apps would go to shit. One example was between CS3 and CS4, some undocumented bug with font formatting. Opened up an existing project after upgrading and half the text fields no longer rendered. This was before Stack Overflow had been created or became big, so it was much more painful crawling through "evangelist" blogs and Adobe forums for a reason. We wasted hours debugging only to find on their forum somewhere that it was a bug in CS4 itself.
Tout a high-powered, powerful framework for a period of time, only to learn that due to unprecedented usage scenarios/evolving web-app demands/requirements/technologies, it needs to be fundamentally redone (Angular 1.x &gt; 2.0, Flux &gt; Relay)
With the possible exception of people who never moved to AS3 once that rolled around. AS2 permitted absolutely hideous code and silently failed everything that didn't work.
And by ActionScript I think you meant AS2 ? Cause AS3 is pretty dope.
In that example, a is converted to a string, and then that string is used as the key, so you can access it also by b['[object Object]'], or really, using any other plain object as the key. You can use a map in ES6 if you want to use objects as keys, which might be useful for being able to store extra information on an object you don't own—especially if the object is frozen. You can even use a weak map to not keep that data if nobody is using the object.
i tried something: https://jsfiddle.net/ty79zxwf/1/ dont forget to check the values on the server-side 
I don't know if learning C++ has really helped me with anything other than using C++. I quite like C# though, it seems like a better version of Java.
I never even installed the plugin in all this time, let alone decided to write something with it. Seemed like a pretty obvious bad idea at the time.
flux isn't a framework; it's just a concept, as evidenced by tons of flux-like libraries in the wild. relay isn't even out yet; though I heard it may come out sometime in August. So, unless you're the kind of dev that likes to use the latest and greatest because it's shiny, I wouldn't really ditch your favourite flux library. They both encourage one-way data flow anyways, which is generally what you want in a react project.
Why is Flux and REST grouped together, Flux has nothing to do with REST.
Think of it as a graph. Each object (me, jake, john, tony) is a node. And each time you do x.friends, you draw a line. (in reality, as you create a new array to store the friends each time, you would have a new node 'friends', linked to your 'person' node on one side and to all its friend on the other). Yes, your graph could be traversed infinitely, but you are still able to count the number of nodes and the number of lines. Those are not infinite. And that's what your runtime stores: the nodes and the lines. So no, you don't have an infinite number of data. However, when you're writing code to work with that data, it's time to be careful because you can write infinite loops.
i dont know the adobe thing, but GA is just the snippet to paste for analytics. it common to see single letter variables in most code that gets delivered as "don't read it, just paste it" snippets. no one writes code like that, we use tools to transform/minify the code after (and use source maps if we need to reverse it)
If you want to print an entire array console.log(JSON.stringify(me.friends), 2); This should also help with each individual object. 
Only one video through, and I'm trying wrap my head around the idea that programs written in this style are "easier to reason about". In the example of the for-loop vs the the filter function, I prefer the for loop because I can come back to it at any time and understand it without looking outside its context. All I have to remember is what a for-loop does. I find it hard enough remembering all the inbuilt functions in JS let alone remembering a tonne of custom functions scattered around my code base. Is it just a personal preference thing? I have terrible memory but don't mind wrapping my head around longer functions if I can work through them sequentially without constantly having to refer to other parts of the program.
Ah, interesting! I guess it's only slightly more private than it used to be. Ha! Thanks for the link.
&gt; Citation needed. As of right now, v8 cannot optimize many ES6 functions. Generators, anything that contains a for-of, getters and setters and `__proto__`, and compound let and const assignments (as well as the ole try-catch and try-finally, and the obvious ones like debugger, eval(), and with) So any of those in a function will cause the optimizing compiler to bail out, and the entire function will run slower. If you want you can run v8 with the --trace_opt and --trace_deopt flags to find when your code can be optimized and which functions cannot. There is a bit more information [here](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#1-tooling) 
yes I had this written before but it still didn't work [here is the code](https://jsbin.com/totixebule/edit?html,js,output)
Personally prefer something like this, most people don't care but I think things can get out of hand when you have more than one return const value = (() =&gt; { let newValue = 'default'; if (condition) { newValue = 'something'; } if (otherCondition) { newValue = 'something else'; } return newValue; })();
In all that time you were never roped into more advanced stuff when the lead was sick or something? Amazing. 
That really wouldn't even be that much more difficult... Coming up with new names might be the most difficult part! :) No problem; anytime!
have you ever visited /r/jquery ? "I need a plugin ..."
Yep, it was Symphony. The big-picture architecture of Symphony is great, but using XML and XSLT is just not really necessary in this day and age. There are (or could easily be) simpler declarative templating layers. But the concept of clearly defining the semantic data layer from a declarative presentation layer is brilliant, and I wish there were similar systems using simpler DSLs. It worked out well until I decided to leave the company, at which point they promptly switched to Wordpress, since they had no chance of finding a decent XSLT developer.
&gt; I quite like C# though, it seems like a better version of Java. Yeah I got dragged kicking and screaming into learning C#, and actually enjoy it. :P
Actually it was written by somebody who has more than a decade of experience with JavaScript. You see, the problem with software engineers is the idealists, not realists. They will tell you that global scope is bad in one breathe and then in the next tell you how to declare an angular module with angular.module('name', []). Funny thing is they are using the global scope. The irony is sickening. Ideologies provide no value because that's not how reality works. Now, those same people will tell you to use RequireJS and then when people try and use that library they start running into all of the stupid complexities and problems with loading libraries through that framework. I've used RequireJS in a number of production projects and the problems that arise from that library, because every library isn't built for it, are limitless; unless of course you're building applications that don't do anything. The problem with software engineers is that they are arrogant beyond their own abilities and have nothing but that to offer.
No, I'm not offering that this is the type of solution to offer over modules, but I'd also note that modules were not included until ES6 and that adoption for that spec is still being implemented by vendors, you realize that right? You also realize that large scale applications that have 500k+ internal users in Fortune 500 and 100 companies often don't afford options to use things like ES6 right? You also realize that there are often reasons for not using modules because you're modifying an existing code base and need to make it better right? There are so many scenarios where discussing this fits right in.
Thank you, I will correct my mistake.
Ha, that's a fun concept... I'd have to disagree, though, respectfully of course, my kind friend. My strategy is a bit more refined than speaking to ducks. Ducks can't even understand English -- explaining things to a duck wouldn't make any sense... I wouldn't know when to stop. No, what I do is this: first I identify key concepts -- in this case, I knew that the problem was either in the formation of the .js file, or in the formation of the import statement -- and then I just kind of spaz-out on those concepts for awhile, opening 12-20 windows in Google, chasing links by intuition until fate graces me with a good idea. I should probably patent my technique. :) EDIT: Perhaps, "vagabond debugging". I'm a professionally-homeless searcher. If I stayed in one place counting lines, it wouldn't feel right.
You realize that there many many module systems built prior to ES6? We've solved this problem. It does not involve the global scope.
&gt; Uh, yes there is. You just don't hear about it because they've done such a good job promoting namespacing. Good call my friend, good call. I may weave that into the article! Had totally forgotten about this because as you well stated we've just hidden it so well. &gt; Pointing to jQuery as an example of GOOD global scope pollution is laughably wrong. Maybe you should look into the history behind https://api.jquery.com/jquery.noconflict/. I didn't say that there aren't issues with the global scope, the idea is that the idealistic view that "global scope is bad" in one breathe and then using it in the next with libraries like jQuery and angular is sickening in the community. Ideologies are peaceful but history is violent; keep that in mind. That means that ideologies are not reality. &gt; No, you created an object literal. It kind of looks like a namespace, but you should use modules/revealing modules instead. .NET junkies (of which I am one) should know that javascript is not .NET, has different paradigms than .NET, and you should learn those and not expect javascript to ever be .NET. Of course I created on object literal; that's called namespacing in JavaScript. And of course using modules would be awesome, but keep in mind that ES6 is still being adopted by vendors and in a lot of Fortune 500 and 100 companies where you have 500k+ internal users for a system, you are not afforded platforms that support ES6. What about when you inherit a system that's leveraged global scope heavily? You're not going to rewrite it, don't be ridiculous, it was a $500,000 investment the first time, you're going to make it better. Think a bit outside the box please when providing your feedback. You act like the only thing in life is the idealistic approach to everything. Again, ideologies are peaceful but history is violent.
Of course there are, but again I reiterate, that is not always a solution. Ideologies are not reality. I enjoy programming with modules, I do it all the time with Angular, and I look forward to using ES6 modules. However, when I inherit a project that's relied heavily on global scope I can't rewrite 500k+ lines of code, I need to make it better where I can. You realize that right? Maybe you live in a bubble where all you do is brand new development without constraints for platform support? Maybe all you build is idealistic code? I want you do keep this in mind though while you rest in your ideology; there are companies out there that make $5m+ per day running on technology that would "make you puke" based on your attitude of this article alone. I find that interesting and it broadened my horizons.
Backend stuff like php and ruby, or whatever it is the main application logic is made of. I ask because I always thought the frontend dev job was a myth. My original position was as frontend dev, but the lead quit, which means I now have to do everything.
&gt; It can work. Lots of things can work in JavaScript. If you're experimenting or writing a personal project you don't expect to publish, then I'm of the opinion that you should go nuts if that's what you desire. Doesn't mean there suddenly aren't better ways to do it when you're writing professional code. This comment is another example of ideologies. There is a quote that I hold very close, and you will too I think as you continue to grow into bigger, badder, and more volatile horizons. Ideologies are peaceful but history is violent. While it's wonderful to believe that you can always code in ideologies it's not reality. There are numerous situations where I can apply this code. A huge application that I've inherited that was built before the idea of modules in JavaScript (but it's been a cash cow for years helping an organization make more money per month than you make in a year). I dropped that in to put into perspective how useful ideologies are. What about a Fortune 500 or 100 company where you are not afforded platforms that support ES6 because you still have to support IE6 because some of their support applications haven't been or can't be upgraded? Keep in mind they are still raking in the cash with this "crap" as you'd call it. What about the issue surrounding the fact that in very large development teams, abstract concepts like commonJS or RequireJS are going to be circumvented because they simply just aren't understood and there is no good avenue for them to get direction? I want you to keep all of these types of things in mind when reading articles on the internet. Good luck in your endeavors my friend and I hope you continue to grow and see new horizons. One day you may even have to refer back to this post to make a project you've inherited or been forced into better!
Just because Phil Collins started singing when Peter Gabriel quit Genesis doesn't mean all drummers eventually become lead singers.
But now it looks like it'll be WebAssembly instead.
Thank you, this reply proves the relevance of this article to the community!
It just proves that sometimes you are forced to use bad patterns as a stop-gap to a better refactoring step.
This is me, I was a Java dude, but got some good opportunities working on .net stack, low and behold I love it
.NET doesn't get enough love, it really is great. That said, I still prefer a LAMP stack for web stuff. :)
Okay, I figured it out: &lt;script type="text/javascript"&gt; //&lt;![CDATA[ var GlobalCartNumber = "%%GLOBAL_CartItems%%"; if (GlobalCartNumber != "") { //Items in cart var GlobalCartNumber = GlobalCartNumber.replace("(", ""); var GlobalCartNumber = GlobalCartNumber.replace(" item)", ""); var GlobalCartNumber = GlobalCartNumber.replace(" items)", ""); document.writeln('&lt;p class="top-menu-lower"&gt;&lt;a href="%%GLOBAL_ShopPathNormal%%/cart.php"&gt;' + GlobalCartNumber + '&lt;/a&gt;&lt;/p&gt;'); } else { //Empty Cart document.writeln('&lt;p class="top-menu-lower"&gt;&lt;a href="%%GLOBAL_ShopPathNormal%%/cart.php"&gt;0&lt;/a&gt;&lt;/p&gt;'); }; //]]&gt; &lt;/script&gt;
That's not exactly true. Functionally, browsers could do almost everything that they can today it just took a *lot* more effort. In 2002 I worked at a company that was already building a social bookmark manager with real-time sharing, chat, drag&amp;drop and a responsive design. It was buggy and hard to maintain but it mostly worked. 
Totally! It's so versatile and easy to understand for how much power it gives you. I'm with you on web stuff, it's much faster to spin up a php or node server and be off to the races, whereas .net you've either got to use a template or spend a ton of time getting yourself in a good place. That being said mvc/web api are a joy once you are fully setup
Damn, you must've taken a lot of shit for your career choice in the early to mid 2000's. People used to actively fucking HATE JS back then.
Same... still there are plenty of things I miss about Flex like creating quick UI's of any type without having to strangle CSS for hours.
And now we get to bet on frameworks. Plain Javascript, Angular, React (+ 100,000 more)
I said nothing about ES6. The module pattern is a javascript (yes, ES5) pattern. You can (and should) use that today on all browsers. Read the link I provided before you tell me to "think outside the box", especially if you don't have a clue what you're talking about. Look at the section titled "MODULE PATTERN", and do, please, start thinking outside the box yourself. &gt; the idea is that the idealistic view that "global scope is bad" in one breathe and then using it in the next with libraries like jQuery and angular is sickening in the community. Just because a library puts its own namespace in the global scope doesn't - at all - mean you should use global scope. You could conceivably have the same argument about a .NET library; any top-level namespace is global. That doesn't mean you should put anything you want in global. No, really, global scope should not be polluted. Don't.
Yet writing small tools is easy and fun.
Use CommonJS to help organize your code's physical structure better as well
No it's not and [far behind every other browser](http://html5test.com/results/desktop.html).
I can't help but feel as if you've completely missed all of the points
There is /r/learnjavascript if you need to learn the basics. It really depends what you want to build: * Are you interested in frontend? Learn React * Interested in backend? Learn Node.js (with [Express](http://expressjs.com/)) * Interested in full-stack? Learn Meteor I mention these based on your own suggestions. Of course it is possible to mix and make use of different tools together. You can make full-stack apps with Express + Angular for example. So you need to figure out what you're interested in and then it is easier to know what to learn. After that I would try out the ones you find most interesting and make a sample project. You will find out what works best for you. Note: you will not get very far with React alone. It is _only_ the view. You will still need someting like [Flux](https://facebook.github.io/flux/) (or an implementation of Flux) to create a full application.
I enjoyed watching NBC's 2008 Olympic web casts. I believe it was Silverlight based. That was pretty amazing for 7 years ago.
You can cut through a LOT of the node install parts by just using [NVM](https://github.com/creationix/nvm). NVM installs node binaries in your home directory.
I am not sure what coach marks are. But by that site I think you mean prompts? if so you could try [This](http://nugetmusthaves.com/Package/angular-prompt) which relies on AngularJS UI Bootstrap. [Demo here](http://cgross.github.io/angular-prompt/demo/)
Thanks! I will take a look at Reactjs + Flux course. This one seems allright https://www.udemy.com/payment/success/?courseId=435258
couldn't have said any better... i am in the same boat as you..thinking of just staying with Angular1 and learn Angular2 on the side... I am having a tough time learning it, there doesn't seem to be many good resources online.
I've never heard the term "coach marks" and tbh I think that term is holding your googling back. Here you go good sir: http://daftmonk.github.io/angular-tour/
Wow, you have a point there. When I started this project I struggled to find the terminology for what I was looking for. I came across coach marks and I thought that's just what guided tours were called in the web world. Thanks for the link and the tip!
Some people use React with Angular. That may be an option. The other part is to learn and use the parts of Angular that are useful and to ignore the cruft that you don't need. That is, use directives, services, and maybe routing, and try to avoid everything else. &gt; Obviously at the cost of performance This really isn't obvious. Angular performs just fine; even if you're pushing its limits there are a handful of things you can do to "release the floodgates" so to speak.
I've considered using React and Angular...I'm using Meteor as my back end. I found it to be a recipe for spaghetti just using Meteor so I needed a way to manage the data that makes sense. I've been doing Angular dev for years now and I understand it. The idea of Meteor + React + Angular made me feel bad and ashamed haha. Even using Meteor + Angular still seems like framework overkill. 
Well for PHP you pretty much need a framework unless what you're doing is less than 200 lines of code, and my limited experience with node is that you absolutely need something that imposes some more structure like a framework as well. I still agree php is better for most simple things, but as soon as you think it might become a medium large project I'd rather get out of php and spend the time doing it in something else, if only because debugging is such a pita to get working well.
You don't have to use Flux. It helps with debugging and makes your app more predictable, but it can be overkill. Flux is hard to grasp initially. You can get by using `window.fetch` in `componentDidMount()`. If you want a "service" a la Angular, then just create a singleton object and import it, which won't be any harder to deal with than an Angular service. Indeed, you might be better off starting without Flux. Not using Flux makes you understand why Flux is a useful idea. Also, there is a sideways data loading mechanism in the works. (Unless it's been abandoned? Haven't kept up to date with that.) Should be easy to port over to that, if it becomes available. Unfortunately, the tooling and information around React is still in a lot of flux (sorry) so you might want to stay with what you're comfortable with for now. And as hahaNodeJS said, you can use React in an Angular app.
I've got Andreessen Horowitz on the line right now
That's an understandable sentiment. My experience is that it works nicely as long as you keep things simple. You may also want to take a peek at [JSData](http://www.js-data.io/). Otherwise, getting stuff done is the most important thing. Don't let perfect be the enemy of the good.
Sprinkle some full-stack CSS9 in there and that's a framework I'd pay for.
I've been looking at JSData since it was AngularData. Definitely...shit I didn't even think about it for this. It might have been exactly what I needed. I'll keep it in mind for the future. 
angular2 looks similar to react, thats why i have been thinking of playing with it now
\+ Sparkline + D3.js + Highcharts /* cause why not */ + add more here
&gt; "global scope" isn't "the big bad wolf of the world" Yes, it is. Just because it is abused in applications that still work doesn't mean it isn't a universally accepted bad practice, no matter how much you want to write articles counter to that. &gt; You should be ashamed of yourself. I'm not the one promoting acceptance of terrible code.
Noob here too, but wanted to mention that console.dir() instead of .log() quickly became my friend when trying to understand arrays of objects. Produces a nice nested / indented view of the data.
Nice. You might also want to mention [feross/standard](https://github.com/feross/standard) which has a pretty strong following in npm land. 
holy...shit... amazing.
Excellent point, sir. I wonder if Meteor has support for `/dev/null`? Oh wait same thing
Using your help and the help of the others. I think I have finally managed to do what I wanted to ad do it at least partially correct. The program I showed in the post was an example, but this is the real code I was trying to get working. loadPluginConfigs(plugins) { return new Promise (function (resolve, reject) { Promise.all(plugins.map(function (plugin) { let p = path.resolve(PLUGINS_PATH, plugin, 'config.json'); return new Promise(function (resolve, reject) { fs.readFileAsync(p) .then(function (contents) { resolve(JSON.parse(contents)); }) .catch(function (e) { resolve(null); }); }); })) .then(function (configs) { let c = {} plugins.forEach(function (plugin, index) { c[plugin] = configs[index]; }); resolve(c); }); }); }
I wrote my own "store" based on the idea of unidirectional data flow. It's a POJO with 3 things: getters, setters, an on update event (just a simple callback register/deregister). The react component registers to become an even listener for updates, and uses the store get method when rendering. The set method just updates the store, updates the server, and fires the event to let everyone know data has been updated. The code is very simple to read and understand, and no need for Yet Another JS Framework.
Three issues: - Line 33 of LockBackground.html: Missing opening " on id prefecture. - Lines 54, 55 of main.js: Calls document.getElementById for elements with the id's month and year which are not in your HTML. Either create these, or comment out/remove those lines. I've made those changes and now the page updates each time updateClock is called by setInterval. Note: I've resolved these issues simply by opening developer tools in Chrome and reading the console output. I suggest you do the same! 
Yes! That is similar. I am wanting to write a full story for it. It's pretty silly, but I think it will be fun to make. Basically the computer prompts questions and based on what the answer is it gives you an outcome. Edit: I am looking to build some sort of text-based game with commands and prompts. 
This is really cool!
Their comment, in the context of replying to the comments above and in this thread, was saying Netflix have replaced Silverlight with Node.
I forked your codepen http://codepen.io/anon/pen/RPqYgM Your problem is this; document.getElementById('spacer1-1').style.display="none"; document.getElementById('spacer2-1').style.display="none"; You don't have an id spacer1-1 and 2-1 javascript returned null
I'm sorry if my comments came across as venomous, it wasn't the tone I was trying to go for. For what it's worth, I get what you're saying. You're basically replying to the "___ considered evil. Avoid!" kinds of articles and mantras. I don't subscribe to those either. For instance, there is a place to use `==` over `===` (It annoys me when my linter pesters me about it when I know full well that I want type coercion in that one place). I think the main thing that made me reply was the lack of any mention about commonJS or ES6 modules, so it made it sound like it would be "This is the way you should do it" to the uninformed - and the whole point of the article is to inform the uninformed, I gather. As for whether I use libs/frameworks that populate the global scope, I tend to avoid it when I can (I don't even use jQuery, actually). 5, 10 years ago, accessing libs from global was a standard and common way of doing things, but JavaScript applications have gotten more and more complex and things are evolving for the better. As an aside, if you do build libraries, I'd appreciate it if you supported commonJS (you can detect and prefer it so it doesn't pollute global), as just the other day when I was trying to import/require cito.js, things weren't working because it exclusively used a global namespace. It's not future facing and can be frustrating when you're working in established code bases that use modules. In the past, I've used `myNameSpace = myNameSpace || {}` too. In small applications with little to no 3rd party dependencies, I started to prefer IIFEs or sometimes simply waiting for a DOMContentLoaded event and doing everything in the "anonymous function". It doesn't work for more complex applications, which is where the modules we're familiar with entered the equation. Finally, to address whether polluting global is bad or not, I agree with you. My opinion is that it's not inherently bad, however, I don't think it's best either.
Doesn't seem to work very well in safari.
Try omniscient (a flux implementation). Its got a very intuitive data model.
Yes this. Mithril is awesome.
This is great. Thank you!
Emberjs
Pretty good article. Even better is to avoid `Object.create` *and* `new`. The creator of `Object.create` himself, Douglas Crockford, has disavowed the use of `Object.create` and `this` as ES6 has rolled around in his talk [The Better Parts](https://www.youtube.com/watch?v=PSGEjv3Tqo0&amp;t=23m). Inheritance is almost always bad, whether you're using `extends` or `Object.create`. His new pattern is class-free and object-oriented, roughly (not exactly) like so: function Player({ name, level = 1, xp = 0 }) { const { isBanned } = bannable({ name }); const neededXP = function () { return level * 69; }; return { isBanned, neededXP }; } function bannable({ name }) { return { isBanned() { return name === 'clessg'; } }; } const bob = Player({ name: 'bob' }); bob.isBanned(); // false, woohoo ... Essentially allowing for multiple-inheritance type patterns without the pitfalls of inheritance. The most confusing parts of JS disappear: `this`, `prototype`, and "inheritance". Other links: http://stackoverflow.com/questions/27595749/douglas-crockford-on-class-free-oop-in-javascript http://weblogs.asp.net/bleroy/crockford%E2%80%99s-2014-object-creation-pattern
Hmm. Yes. I know some of these words.
Seconded. Visit /r/mithriljs too. It's not super active but hopefully can be with more users. The best part about Mithril (IMO) is that it doesn't feel like you're using a framework at all. Anything is possible, and it just seems to kind of do its thing without getting in your way. At first glance of code using it, it doesn't even look like you're using a framework, yet the code somehow still makes sense. It's an extremely small API as well that you can learn in an afternoon - the challenge comes from deciding on a structure that works well for your project and following conventions. In my experience, it really benefits from a FRP structure more akin to Elm than the demos and examples on the website. 
That's probably because Safari is a terrible browser. It works fine in Firefox, Chrome, and even IE11.
You might try another Flux-like framework such as [Redux](https://github.com/gaearon/redux). I'm a fan of the unidirectional data flow, but with all data in a single store which is treated as an in-memory database. To that end I have been working on [SunshineJS](https://github.com/hallettj/sunshine), with a goal of using [Immutable.js](http://facebook.github.io/immutable-js/) for the store, with lenses acting like first-class database queries. But Sunshine is a work-in-progress.
Personally, that code is extremely hard to follow because of how much destructuring is used. I was unaware you could use destructuring in the method signature on parameters. Question, shouldn't it be: const { isBanned } = bannable({ name: name }); As `name` was destructured from the Person signature, so `name` is an object. What is `bannable({ name })` doing? **Edit** Nvm, I tried it out with babel, seems `{name}` is literally translated to `{name: name}`.
Yeah, it's a bit hard to follow until you've learned ES6 in-depth. Can't be harder than explaining `this`, though. `{ name }` is syntax sugar for `{ name: name }` in ES6.
Dynamic typing on large code bases is a problem.
Take a look at redux. It's still complicated but it makes sense. Hopefully, more useful examples will come out soon for it.
why not contribute to angular or react instead of starting another framework?
Just awesome! Waiting for the next one :)
Does it? I've been working with npm for a long time now, and this is the first time I've heard of it. Maybe I'm living under a rock. Not a fan of some of the rules they enforce (like no semicolons -- I wish those shenanigans would just stop). ESLint is great, though.
Repo for anyone who wants to submit corrections/enhancements: https://github.com/hansifer/jsOperatorPrecedence
Writing bad code is much easier than reading good code. But if you've spent a lot of time reading and really understanding good code, your chances of actually writing it go up considerably.
I think d3.js is great for learning, because it uses a lot of interesting design patterns and concepts.
Give the flux library named "redux" a try, so many people like it, removes a lot of boilerplate 
Unfortunately that doesn't stop everyone from using it.
Ember is pretty legit. You should definitely check it out.
Props to you; way to stick with it!
Ember is where it's at. We could use more ember dev's.
[Uh...](http://i.imgur.com/FFV8Y5f.gif)
&gt; chances are you're including polyfills for certain things anyway If you're using polyfills, chances are it's to get things to work in IE. Quit blowing smoke. Almost every hack and polyfill is created to fix IE. Been that way for a decade. &gt;Stop hating it because you think it's cool to hate. I started questioning the capabilities of IE when I was first introduced to Firefox version 0.8. Obviously you didn't look at or understand my earlier link. IE can't hold up to any other browser. Known. Proven. Verifiable. &gt;Yes it's nothing spectacular if that's what you're trying to say. It's software. It works. Has much of what you'd expect to find in dev tools even when you're used to Chrome. It's even pretty. That's the first time, EVER, that I've ever heard anyone say that about IE dev tools. Which tells me everything I need to know about who I'm communicating with. &gt;Service Workers are still brand new Yes, and yet, ServiceWorkers works in Chrome and Opera but will NOT work in IE **or** Edge where Microsoft is only "considering" it. And that's the horse you're trying to ride? &gt;I'm sorry if you think you're too hip to think IE/Edge can ever be a good browser. I've been hearing that crap about "the next version will blow [insert browser here] out of the water!!" ever since the announcement for how great IE7 was going to be. And then I've had to listen to people like you who can't read facts to find out how wrong they've been up to and including Edge.
So, iow, "How to go from web standards to Microsoft proprietary code". Gotcha. Can anyone say JScript? Been there. Done that. Regretted it. We all learned our lessons over a decade ago.
The solution would be not to move your project to TypeScript. The problem is, someone thinks they need to move their project to TypeScript.
I'm talking about Edge which is ahead of Safari and catching up at an astonishing rate. Hell Edge has as much ES6 implemented as Chrome last I checked. I'm an outright Microsoft hating Unix fanboy but IE has come a long way.
Is this in java or javascript? Also, it's easier to get answers to an issue if you make the question simple. Your issues are pretty open ended, and can be implemented in multiple ways. I'll do my best though to point you in the right direction. 1. You're adding items to the map somewhere right? Try finding a way to re-add all the items, but only the ones you want to filter by. 2. You've figured out how to pop up the div on click, I'm sure you can figure out how to also add it on the left. 3. Analyze the code to understand if you need it or not. 
You said IE, not Edge. Edge is virtually even with the current version of Safari. When you consider Edge can only manage to pull even with Safari, and still be miles behind Chrome and Firefox, that's not much of an accomplishment. And the next version of Safari is about to be released soon, too. Where will that leave Edge? The same place IE always was, bringing up our rear ends. &gt;but IE has come a long way. I've been listening to that crap from every disappointed IE supporter since IE7.
I would hold off on any books if you're just starting out. There are a myriad of resources on the Internet. I would start at http://javascript.com and get your hands dirty. 
It has a scary amount of daily downloads (or the underlying library does, anyways). 
Try improving your written communication skills then? Not sure why you're blaming me for your shitty writing ability.
Honestly, even though it's not out yet I'm stoked for Relay, which pretty much addresses all the issues via componentizing data needs and getting them via graphql. For me I don't really think data model, I think "this component needs this data", which I think relay does very awesomely. It open sources in August apparently, and there's already a tech spec of graphql with many implementations being worked on via github, so I think the full awesomeness of react will be unleashed soon if you can wait that long :). 
It makes sense when you learn it, but it is still sugar that doesn't need to exist. JavaScript is already a mess of options and possibilities for how to write and structure your code - we don't need more options or styles. 
There are reasons abound to refactor your JS to TS.
Depends on if it degrades gracefully or not. Your design should not be dependant on it working 100% of the time. The animation just enhances the page content.
As a developer, I agree, but in practice some clients will insist on stuff working exactly the same in all (recent) browsers.
High charts depends on it too I think. Good call. 
Inheritance will always be there. Classes are just sugar on top of how people make classes already. Seems silly to introduce a new "right" way. (someone correct me if I'm wrong - I remember reading something a while back that this was the case)
That's exactly how I think too, I've paid some attention to GraphQL but wasn't sure about stability, or whether I'd be able to grasp it quick enough to implement it. 
&gt; If you're using polyfills, chances are it's to get things to work in IE. Not necessarily. You want to support a few versions back regardless when new API is added to the browser, even if you're ignoring IE. And not everyone's on the beta/dev channels. &gt; I started questioning the capabilities of IE when I was first introduced to Firefox version 0.8 IE has a history, yeah. I also didn't like it for years and used Firefox instead. Then I went to Chrome. Why did I go to Chrome? Why did you go to Chrome? Probably because it ran better. Now I'm telling you that all these years later, IE runs very well- better than Chrome and Firefox in some cases. That's a GOOD thing, wouldn't you agree? In my opinion, the main thing that's been missing from IE all this time is extension support. Apparently Edge will have extension support. This is also a GOOD thing, wouldn't you agree? So as I said originally, it's a space to watch and not something to dismiss automatically because "IE? lol". That's not something a rational person would do. As for your link, I agree it does lag behind the other browsers when implementing certain things. It also sometimes beats the other two with some implementations (Grid Layout?). As a developer, that can be frustrating, but as a user, I don't care. I switched to Chrome as a user because it ran better. IE/Edge is improving, and it is a pretty good browser lately. Furthermore, some of the things it hasn't implemented (which makes it somehow "verifiable worse") are probably things you've never come across or used in development (like a ton of random CSS selectors). It has most of the common important things you'll need, if not all (though I hope it implements fetch soon as I haven't seen anything about that). To say it's worse from a development standpoint without even thinking about it because you see some numbers on a website is again pretty irrational. Which takes me onto: &gt; That's the first time, EVER, that I've ever heard anyone say that about IE dev tools. Have you used them? Or was the last IE you used IE8? Maybe you're basing all your opinions off that. As for the small comment about them being pretty, Microsoft in general are pretty good when it comes to UI/UX in the past few years- say what you want about Win 8's Start Screen. They make pretty web products too (outlook.com?). A lot of other companies adopted flatter designs with primary colours too. &gt; I've been hearing that crap about... Sure, stay stuck in your ways. They can't redeem their software because past versions exist. Okay. If you say so. Let me just note no one is saying anything will blow the other browsers out of the water; I mean you're the only one with the hyperbole here, remember? The original comment was "pretty good these days", and then I chimed in, saying it has been a more pleasant experience recently- that it's a space to watch. Just to remind you :)
[Eloquent JavaScript](http://eloquentjavascript.net/) is IMO the best introductory book. You have it free in the website or you can buy it in Amazon if you want a paper copy
I'd have named it schneebly.js.
While I haven't personally used it, I like the look of and have heard good things about [FuncUnit] (http://funcunit.com/)
Good post. One thing I'd add: How to actually get the data out, none of the examples showed what parameters the callbacks get.
sorry that makes no sense I will take it down
Would rather too many than not enough.
Sorry my explanation was actually inaccurate. The exact line(s) of code were: &gt; document.getElementById('x').innerHTML If getElementById() does not find the element it will return a null value, which in itself is not a problem. The issue is caused by then setting innerHTML on the return, which means you're trying to set the innerHTML of null. This throws a TypeError which stops the script from running.
Hi, just released https://github.com/720kb/butler it uses highlighter.js to select the elements by voice commands, hope you'll enjoy. This is still at early stage, we have to develop even more, then if you'd like feel free to contribute!
Thanks, that article was useful. There's a shortage of good articles on using tools with ES6 at the moment. I've used JSLint (hated it) and JSHint (better). I'm going to try babel-eslint, hopefully it works well with ES6.
No it doesn't. feross/standard is little-known and little-used tool, largely because of it's insistence on (ironically) non-standard coding standards. I mean, I guess 5k downloads a day on npm could be considered strong, but eslint has over 5 times that, and jshint is more like 15 times that.
Solid work. I liked the length and the use of code snippets.
Nice! I'll add that tomorrow -- thanks :)
I had done something similar but letter-based to use on a Turkish anagram tumblr - http://sacmanagram.tumblr.com/
You having a stroke mate? It's on github. It's free hosting and sub domain with no hassle. What's your problem? 
 setTimeout(function () { someFunc('foo'); }, 10000); or in ES6/2015 setTimeout(() =&gt; { someFunc('foo'); }, 10000); 
setTimeout( someFunc.bind( null, "foo"), 1000); // replace null with whatever you want this to be... // e.g. to use console.log ... setInterval( console.log.bind(console, objectToWatch), 1000);
Function.prototype.bind(this_obj, [arg1, [arg2, [arg3, ...) https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind
Shallow rendering is not yet ready for prime time or at least it is still a bit limited. However it should become a major option with version 0.14.x onward. For the time being JSDOM + Jasmine (or mocha) does the trick. As well as anything like Karma + Jasmine (or mocha). Look also at the React test tools on the React website for helpers.
With Angular you would use something like protractor for example that has convenient functions for Angular but more importantly hook into Angular to know when a page is loaded or an AJAX call is done. It is a better solution than just waiting for a certain amount of time and crossing fingers everything is ready. Our problem with React based applications is to find the best way to test it (with webdriver/selenium by the way) in the most efficient manner possible, without time wasted waiting.
All other answers are correct, but setTimeout is even more awesome since in modern browsers (&gt;= 10) it supports this syntax: setTimeout(someFunc, 10000, "foo")
Thanks for the link. Looks like a Webdriver/Selenium alternative unless it also builds on top of it. Seems to offer the same functions we have with Webdriver and good "wait" functions. But there would be nothing to tell us all React components have rendered on the page for example, or more tricky all refreshed after an update.
The main issues are: - how to know when a React based page has finished rendering all its components - how to know when a React based page a finished re-rerendering some of the components after an update - how to know AJAX calls are finished (that one I admit might depend on the Ajax library used) And all that in a way that is not just about waiting a fixed amount of time hoping everything is ready.
Yeah, I accept that _for Angular_ I would get some benefits from learning/using Protractor, indeed, that's where I started my e2e journey. I quickly realised that I wasn't happy with my e2e tests knowing about Angular, not only because I actually dislike it as a framework, but also because I feel like it's putting "e2e" tests at too low a level. I ended up going with Selenium precisely to avoid the tests knowing about the framework. I don't have any tests using explicit waits. They all wait on elements to appear/disappear/have a value/no longer have a value/etc. - i.e. stuff that a user might see and react to. The only magic that happens is that I catch uncaught exceptions (the ones that Angular doesn't swallow, anyway) and fail any Selenium test that finds that an exception has been thrown. So my advice is to use changes to the visible-to-the-user structure of your page to trigger test execution via implicit waits. This is described in the [Selenium Docs](http://docs.seleniumhq.org/docs/04_webdriver_advanced.jsp). A big driver in my decision-making is that I will be moving framework and have no intention at all of coupling my e2e tests to any specific one. I appreciate that this may not suit you and that my advice may therefore not be as helpful as I intend it to be!
Guess I'm a big jerk. Looks like it's just safari on 10.11 beta. The text varied from not visible at all to only parts of it flickering 
&gt; a variable's value will change (not common) Let that sink in for just a moment...
this is overkill in my opinion. React offers much less than Angular, but I really don't think you should try to complement Angular by gluing React on top. Yes, it might solve your problem to have a directive rendered with react, but Angular is just as fast in most cases-just remember to use track-by. If not fast enough, render it by hand, don't load another 150Kb library just because you want to render a big table.
&gt; I thought about using Backbone but I don't have any real backbone experience. Backbone is not very good. It is not surprising-it was first JS MVC framework. In the time it was created, most people didn't even know what problems you need to solve in order to have a nice SPA. They focused on making it easier to hook your REST apis. Today we know that hooking up REST api is not the biggest problem we face when building an SPA. You really should consider other choices-React solves the biggest problem with the minimal technology footprint. Angular 2 will probably be quite good as well. Aurelia isn't too shabby, but seems a little bit too bloated.
This is the correct answer, imho.
And you can't think of one.
Pick a project of mine! https://github.com/Wildhoney :) I always need help with projects.
Myself, I don't think event emitter pattern(Flux) is the best pattern to solve the problem of "when do I rerender this component?". I think we can do better with components observing the stores. That way stores are simple trees of data. They shouldn't care about who is accessing and displaying that data. It should be components themselves, who are responsible for observation of changes. I even have a little weekend project for this based on observe-js: https://github.com/capaj/react-observe-store Try it, maybe you'll find that Flux is not needed after all.
TypeScript vs ES6? Microsoft's new version of JScript vs standard javascript supported by the world? Why is this a question?
Flux made my head hurt too, at first, but once I finally got it I fell in love. It makes life so much easier. Try these tutorials: * [Flux for Stupid People](http://blog.andrewray.me/flux-for-stupid-people/) * [Architecting React.js Apps with Flux.](http://tylermcginnis.com/reactjs-tutorial-pt-3-architecting-react-js-apps-with-flux/)
Suppose I want to reuse your Player code by introducing my own Player "type" but with a different way of calculating the neededXp: function neededXP() { return level * 500; } or the isBanned logic: function isBanned() { return Math.random() &lt; 0.5; } How would you do it?
Thanks. Got some stuff working with Karma + Jasmine, I still just don't really get Unit Testing when I have a flux app...mocking all the stores seems tedious.
Yeah. It still has a way to go and I'm fuzzy on the implementation. I understand the need to parse it etc but I'm unsure how to implement the actual fetching of the types etc server side in an efficient way. Luckily, I think a lot of people way smarter than me are invested in it as well so it should progress quickly. Edit: Just another note though, I rather enjoy flux despite its limitations. Any specific cases you have that are confusing? I'd be happy to talk through some of them and lend what (little) I know :)
99% of the time I bind scope so that it behaves like I'm used to in other languages. But I think if I were to really try to do it this way, it would probably go a long way. Still, wrapping a function in a function like that still looks unintuitive and silly, for no other reason than it would be odd to describe in words what you're doing.
Inheritance is evil. If you have yet to see why, then that's okay, but the rest of us who've had to deal with Java programmers with a CS degree don't want to go back to that world. This isn't necessarily the "right" way, just another way that avoids the pitfalls of inheritance. Stampit by Eric Elliott is good too. Ultimately though, classes are not the problem, inheritance is.
No. It's someone who doesn't need TypeScript. Javascript does everything you need without piling on more stuff.
Thanks. Decided to give ESLint a try after reading this and it looks like I'll be ditching JSHint.
Imagine working in an office where everyone screams CSS selectors all day long...
Yeah, it is very common. I guess my gripe with that isn't with this particular pattern, but a lot of JavaScript in general. It felt really weird going from Python or Java to using functions to do lots of metaprogramming. Hm. Maybe that's not the right term. Using functions to make your code behave in a certain way that isn't related directly to the business logic. Maybe I'm being way too pedantic?
That's why I'm writing my own framework. :P
You could write a function that takes a callback and fires it when a given amount of time passes. Is that the kind of behavior you're looking for?
Thanks for trying, but it appears to be solved now! 
Library? var obj = { tenSecLeft: function() { alert("10 secs left"); }, timesUp: function() { alert("time's up"); }, }; function timer(startingTimeAmount) { setInterval(function() { startingTimeAmount--; if (startingTimeAmount === 10) { obj.tenSecLeft(); } if (startingTimeAmount === 0) { obj.timesUp(); } }, 1000); } timer(20); Ya dig? *someone will probably say to do var setInt; function timer(startingTimeAmount) { setInt = setInterval(function() { for the interval. And then add clearInterval(setInt); to the obj.timesUp() function. So do that to keep things clean.
Step 1: Don't use Node unless you want to have to write low level shit or put your trust in some library to do it for you that was written by some guy on his summer vacation. Oh and he won't be supporting the library once he graduates.
Ah did not know about setInterval, thanks!!
Cringe
How do you know what I need again?
Are you specifically referring to the complexity of the data model itself? Meaning, you have different types of data that extend/inherit from others? If this is what you're looking to manage ... you could roll your own. Now, I know 'reinventing the wheel' is generally a bad idea, but hear me out. Warning: this is a non framework answer. Our team adopted Typescript in the last month or so, for an app that is pretty complex and completely vanilla-JS (save for a tiny bit of jquery). Typescript has made it really, really easy to roll our own stuff such as an event service as well as the data model. I haven't read enough about Typescript/react integrations but I'm certain there is tons of support out there. You could easily use Typescript modules (basically a javascript namespace, feels like an angular service) to manage UI state, the data model, broadcasting service, et al. These things aren't really hard to build if all you need is a structured data model. Your React components could talk to these pieces of your app, which then do the heavy lifting of state management and eventually changes the arrays/objects/whatever that are passed in via props. Realistically, all Typescript does is enforce structure and potentially less runtime bugs (if you use it correctly). Flux implementations are definitely well written and awesome to use if you really need them. But hey, maybe it's overkill for your use case? Sorry for the non-framework answer but this may be the path of least resistance! 
I used to think I'd waste a ton of time rolling my own stuff... but I learned a lot more about the language and realized that a lot of the stuff I actually needed was simple to implement.
My team just did exactly this for a large js project. Typescript has helped tremendously. Nice write up!
Except the entire article doesn't address the argument of increased complexity leading to increased costs. It is also a completely contrived scenario, where code is apparently deployed completely untested and written by monkeys. Managing microservices is a pain in the ass. Any breaking changes need to be versioned or deployed in a way that is synchronized. While errors in one microservice won't bring down the other, they still won't function independently if one is down (at least, not fully). All of that, on top of the fact that most applications won't ever need to scale beyond a single server, and the fact that premature optimization / scaling is a big cost, has me leaning towards sticking with 'monolith' architecture until otherwise required. Then again, if you are Google and you know your service will be hit by millions the first day it is in the wild, that's another thing entirely.
Responded to your comment about me. Why do you think everything is about you?
I want to know what the cost of coping the data cross is. I would take a bet and say with the react model, and if you only ever send the data that is being displayed (viewports) then it probably isn't bad as you are most likely not seeing everything. It would be important to do all the data processing of graphs though in the store on the web worker. Moving large chunks of data between web worker and the main thread isn't fast as it has to be copied (talking 100,000 to 1,000,000 objects)
I see... I'm still trying to sort out the interactions of the major web languages. I've got some basic .js stuff working; now I'm trying to get .php set up... Thanks a lot for the clarification.
Glad you're out promoting this...ESLint is awesome as hell. I use it with Atom and the Linter plugin so it all works really smoothly. Has really upped our code style and reduced errors.
This is more of a checklist of things you should include in your `package.json` file, plus a couple of ways to create low-impact modules to enhance your reputation in the tiny community of JavaScript insiders. While authoring a ton of npm modules might look impressive, I question the value of creating hundreds of them (especially one-liner modules, as suggested in one of the articles linked to in the article). The author includes the following disclaimer: &gt; P.S: It’s not just about getting to the top, rather it’s about doing one thing and doing it the best way. But really, almost everything in artice *is* about getting to the top.
http://jsfiddle.net/mayoung/Ctg8C/
this should almost be in the FAQ due to how often it's asked. especially when the answer basically boils down to "do you want intellisense and static typing (typescript), or do you just want future-proof code (es6 + babel)"
I partially wish I was a vim wizard since people seem to swear by it. How come you don't switch? Atom is great but nothing beats vim to do some quick editing when rocking the shell...necessary skill!
One of the advantages of micro services is that there doesn't have to be just 1 language. In a monolith you'd think about "what language is best for all my needs", where as in micro services you typically consider "what language is best for this specific need". That being said, rust is not a bad choice :)
This is actually a really good javascript interview question for those of you who do interviewing of candidates. Good stuff.
You said "everything you need" though. You probably meant "everything I need".
oh yeah, it is terrible with apple mouse. Thanks for letting me know!! 
Do any languages have private properties inaccessible via reflection?
All of your posts are really angry and inflammatory. Are you okay? I think maybe it might be good for you to talk someone about it.
A lot of neat ideas in here, and I'm glad the author mentions preferring const over let.
I'm still baffled by closures (and promises). I see the terms... no real idea. I barely understand what a callback is. Thanks for more info.
Really interesting read. Thanks!
I can imagine it is but is ESLint easy to setup with Atom for automatic linting? I would like to cover the major text editors, so I am thinking Vim, Atom, Sublime Text and maybe Emacs. Any other editor I should cover beside those?
&gt; Managing microservices is a pain in the ass. Any breaking changes need to be versioned or deployed in a way that is synchronized. While errors in one microservice won't bring down the other, they still won't function independently if one is down (at least, not fully). That sounds like trying to manually manage microservices by hand. At [http://hook.io](http://hook.io), all microservices function independently of each other and are fully functional if other services go down. All source code changes are automatically tracked via git. The only way one service's status could affect the other is if they are piped together as a composite service. The composite would fail because one of it's components would be offline. As for breaking changes and versioning, the interface for all microservices described here is function(req, res), where req and res are HTTP request and response streams. Everything is a stream transform that works with STDIN / STDOUT . If you are designing your microservices using the [Unix Philosophy](https://en.wikipedia.org/wiki/Unix_philosophy), breaking changes and versioning should not be a large concern.
Yeah, neovim has something called "job control" that should allow for async process communication, if I understand correctly. I'm not sure if any notable plugins actually make use of it yet. iirc the maintainers of Syntastic refused to bother, since they have philosophical issues with neovim. 
Also in ES6, `setTimeout(() =&gt; someFunc('foo'), 10000);`
No matter which way you put it, managing micro services will be more complicated than a single web app, full stop. And I just wanted to point out that the arguments in the article were poor. In all my years of development, I have never run into a situation where a single route in my application literally crashed the entire server. Do routes throw exceptions sometimes? Sure. But they are handled gracefully and the rest of the application still works fine. Using that as an argument for micro services is pretty silly. Beyond that, basic integration testing should catch any serious issues before deployment. Do what works for you, but don't pretend like micro services are objectively superior when they are just an over architected mess in most people's typical use case. Web servers behind load balancers with caching can easily scale to levels most people will never reach. *EDIT* - You know what, I just realized this whole thing is just an advertisement for your website/service anyway. I would never trust your website with any real production code. AWS Lambda is a better choice if I want this kind of micro service architecture.
or partial application
Yeah it was dead simple for me to setup. Download Atom, install the Linter plugin, the eslint-linter. .eslintrc file configures rules for the project, and then there's a main config file for some other things. Only other step was to npm eslint, and then download the react plugin as well as I needed JSX linting. Pretty awesome!
Comment this out and see how it behaves: blockError($('#edit-submitted-' + form_key.replace('_', '-')), Drupal.t('We were unable to find your representative by postal code. Please select from the list below.')); disclaimer: I have no idea what I'm doing.
Postcss is used as a utility tool in grunt/gulp that aims to unify the various CSS compiling and uglifing tools. Its pretty good once you get the hang of it
I recently posted an example over here: https://www.reddit.com/r/javascript/comments/3ezig4/using_es6_symbols_to_create_private_methods_and/ctkjcor
There's also mdn.io http://mdn.io/setTimeout
JavaScript is used in many more places than the browser. Microsoft created TypeScript because they needed something better than JavaScript for their large-scale web applications. Specifically, they needed it for the Microsoft Azure platform.
Typical redditor who can't contribute and can't say anything so they try to turn the thread around to make it about the poster and not the topic. 
Sure I can. However, I only have a limited capacity for communicating with stubborn people. It's not my job to convince you to appreciate technologies that I appreciate, nor am I particularly interested in offering you resources when it's clear your position is opinion based.
Sufficiently advanced sarcasm is indistinguishable from sincerity
I'm actually looking into implementing something akin to how nginx works. It covers a wide array of concepts I want to learn more about, event driven I/O, async execution, RPC of sorts when sending out jobs to the worker processes. Load balancing is a part of this. Huge project but I hope to get most of this by the end of this year.
Ie8 and ie9 don't support it, where is a simple polyfill you must use for them: http://stackoverflow.com/questions/12404528/ie-parameters-get-undefined-when-using-them-in-settimeout be sure to use window.setTimeout and window.setInterval with it.
Don't see a way to override it based on the code you've supplied. But I also don't see anything that actually runs it. Start the hunt there?
If it's a website, this stuff could be done by a so-called "user script" (Greasemonkey). How it's done in particular is implementation-specific. E.g. "showing a particular image" might be done by putting some element somewhere, by adding a class to an existing element, by translating an existing element, by drawing something to a canvas, and so forth. There are a million ways to do this and your script has to be written for that specific way which was chosen.
I have the shittiest memory of all time, but I don't need to remember what a function named "sort", "filter", "combine", "find" does, because it's obvious from the name. Most of these functions do very little (but well) and therefore tend to have simple names and very little to understand. In the case I do get confused, they are all super well documented. Like this: http://underscorejs.org/#find The tricky part about the "easy to reason about" is that it only really kicks in when things become more complex. A for loop works pretty okay in a very trivial example like this, but when a for loop starts doing a bunch of things it becomes way less readable. In addition, re-use is the big thing. When you do things in a for loop it becomes so garbled up that you might not even see that you're solving multiple problems at the same times, nor that you are re-solving problems that you've already solved multiple times in your program.
It's executed at definition. Note the `(jQuery)` at the end. Aside from that, you're right that there's no way to override it from what is shown. Unless maybe new code can be added *before* this code is parsed.
Yea I just wanna do the martingale strategy, so it would be very usefull if I had any sort of script that does that for me so I can let it run the entire night. Taken from wiki: The Martingale is one of the oldest betting systems around. Here's how it works: You make your standard bet, say $5, on an even-money bet, such as red in roulette or the Pass Line in craps. Every time you win you make the same bet for the next hand. But if you lose, you double your bet for the next hand. When you eventually have a winning hand after a series of losing hands, your net win will be $5. In fact, every time you win a bet, you'll be up another $5, regardless of past losses. Here's an example: You bet $5. You win, so you bet $5 again. Then you lose, so you bet $10. You lose again, so you bet $20. You lose again, so you bet $40. You lose again, so you bet $80. Man, it's not your night! Then you win. Your net win on that series was $5, and since you won $5 before your losing streak, now you're ahead a total of $10.
In the example, codeWhichRuinsMyDay is not invoked because init is not invoked which is not invoked because Something is never invoked.
Cool. What site? We need to see the site specific code to make it work.
:)
If I was the site developer I would block any such attempts at doing what OP wants to do. If I could block attempts, I could also possibly track attempts and ban offending users.
At your level, by itself Javascript won't make you anything. However if you take you Web work you can charge people for simple 5 page sites. You may not even need Javascript for them. Thinking outside the box here... Graduate Students in science majors often use web developers to create applications to aid in their research. If you can pick up some data skills, even SQLite you may be able to advertise that kind of service. Although I warn you work like this isn't a 'fiverr' type deal and you will likely find your self doing a lot of support and be a bit more involved. 
As stated elsewhere symbols are the way, If Object.getOwnPropertySymbols() is really a deal breaker then just make your private methods functions that take 'this' as the first argument. 
Pretty interesting! The "facets" concept seems very easy to do, I will definitely try this library the next time someone asks for charts.
Yeah, original author's mistake.
Destructuring is one of the worst features of ES6. http://teeohhem.com/why-destructuring-is-a-terrible-idea-in-es6/
Maybe a Raspberry Pi running different timers, that depend on having the time be perfect. I actually think a real time clock is needed for my needs.
Between that and the awfull function shorthand it's going to make for some insanely unreadable code.
All current browsers support at least 50% of the features of ES6
One liner weakmaps on es6 with the incognito npm package
Not even close. https://kangax.github.io/compat-table/es6/
He most likely means apps where timing is critical.
I have my Geocities t-shirt on. I'm ready.
Yeah, I tried a made up postal code "T9Z 9Z9," it appears to be a valid postal code but have 0 matches as it displays 12 error messages. 
Maybe some optimization could be done in terms of limiting the particles. Test case: click about 30 times really quick. Otherwise its oodles of fun! :)
It just says "I won't reassign this variable." Makes it easier to read a function, since you don't have to read ahead to know whether the variable was reassigned. Also helps to discourage mutation in general. It can be also cause confusion for people who aren't acquainted with ES6 if you later mutate the object the `const` is pointing to. In general, `let` and `const` are both fine. It's mostly a matter of preference. I have a weird feeling that semicolon haters will prefer `let`. [See raganwald's essay.](http://raganwald.com/2015/05/30/de-stijl.html)
Damn.
Yeah, we're definitely not seeing the whole picture.
That seems to be an odd case for a valid postal code to have 0 matches. If I search Z9Z 9Z9, I get an inline error message that says it's not a valid postal code. I didn't realize there was a distinction between the two before this. If I could choose, I would actually prefer that response to be used for T9Z 9Z9 as well, but the drupal module (https://www.drupal.org/project/represent) accesses the datasets on the creators server I think, as I do not have access to edit them, so they must have defined which postal codes are valid (even if there are no matches for some reason). If real people are using this site, then I think valid postal codes with no match would be quite rare compared to valid postal codes with matches, or invalid postal codes (typos), and am really more concerned about the person who inputs their actual valid code and sees 2 email recipients and 10 error messages :/. I did speak to the module creator and they just suggested that I make a simple change to the logic of the code that I provided here -_-. Thought it would be easier for a beginner haha... edit: the code I pasted in is actually from this module: https://www.drupal.org/project/webform_represent but the two modules need each other. 
&gt; You won't be able to deploy ES6 for years The evergreen browsers will most likely support all of it by the end of the year. In the meantime, there is Babel and Traceur. TypeScript is another option.
live demo app ..
 &gt;The evergreen browsers will most likely support all of it by the end of the year. IE only got auto-update 3 years ago. We have to wait for everyone who bought a PC before that date to get a new PC before we can celebrate the triumph of evergreen browsers. For example, IE 8 still has between 5 and 10% marketshare (depending on who you ask). Why? Because nervous/lazy IT guys, and people who are afraid of their computers don't run updates. The only reason those people ever get a new browser is because they get a new PC. IE8 it was released 6 years ago. I give it another year before it's gone enough to not worry about it for big sites. That means it (or really the computers it came preinstalled on) had a 7 year life. If IE 9 has the same 7 year life, we'll be waiting til at least 2018 before we can deploy ES6. Note that it's not like CSS3. You can deploy CSS3 to a CSS2 browser and it will have some issues, but still work. We all know that if you try to run JS code in a browser that doesn't support it, everything dies horribly. &gt;In the meantime, there is Babel and Traceur. TypeScript is another option. I said deploy. Babel, Traceur, and Typescript are compilers. I'm sure you know that you compile your ES6 into JS and deploy the JS. 
So a relatively small fraction of my users can use a relatively small portion of the features of ES6. Sign me up!
I don't use Array.forEach. Maybe I'm just weird. I like to write code as close to the way it will run as possible.
I really don't get what your argument is. Just compile your ES6 to ES5 and boom. Now you can write your code in ES6.
&gt; I want to know what the cost of coping the data cross is It's high when not using transferable objects which are only compatible with certain data structures. 
Its just any casino site, I already made about 800€ with that strategy. But there is a lot of math behind, because eventually, it will be 11 times black and you then dont have the money anymore to bet. I once made all the possible outcomes with the odds. Thing is, if you wanna do it right and not lose any money, it takes time, lots. But I have time, because otherwise im just playing league the entire day :D
Well, the strategy isnt illegal. Because eventually you will lose all your money. I just involves lots of math and if you have the right path you can make lots of money ! It just takes waaaay too long to do so.
Well, the load balancer is half the equation. The load balancer is sending requests to a worker pool. Each worker in the pool is responsible for executing untrusted code in a safe environment. The workers have no idea the type of services they are going to execute until the load balancer actually sends the service code to the worker. The important thing to note here is the workers are running "hot" services, as in the service code is evaluated at run-time in response to requests sent from the load-balancer. New services can be executed without taking down any processes. Workers are also capable of performing stream transformations on their input and output streams ( in this case, the request - response objects ).
What happens if all workers are busy executing an infinite loop?
It's hard to make money without offering a service of some kind, however you could certainly find a need that people have and could write a library with a dual license approach or even a fully commercial license I wouldn't expect to turn much of a profit from that though. A better approach would be to build a good portfolio of open source libraries that you've made that have viable real world use cases, using those as a resume builder is likely to make you far more in the future than in the short time. 
Oh... hmm...
Well... a script has to interact with a specific element on a webpage. The scripts would have to be specific to the pages is what I'm saying.
Did you get hired?
&gt; I said deploy. You don't deploy your code as-is anyways. You use a minifier, right? Using a compiler isn't any different. Either way, the code you write isn't the code you deploy. It's like that with most things. My CSS was SCSS and my HTML documents are a bunch of templates which were stuffed with data which came from somewhere and the "structured document" bits were probably Markdown or whatever. If you write some C++ application, you deploy an executable and what you can see of George R. R. Martin's work certainly aren't WordStar documents. Anyhow, there are already some companies and projects which only support evergreen browsers. My current primary project is like that, too. It actually doesn't even work in Firefox right now, but Firefox will support the things I'm using in about 3 months. As my project gets ready, Firefox gets ready, too.
So the improvements here are: * Multithreading * Per-request timeouts ? 
I'm not a front-end or JavaScript dev specifically, but it seems I need to brush up on **"this"**.
No these where for either mid or senior roles. The answer I gave for that was to use reverse search (ctrl+r) or if it's something I use often I would just write an alias for it.
Wow this is legend status posting. These are some fun ass questions too.
Please express your conclusion as a function. 
 let {length : len} = 'Tom Alexander'; // len = 13 I mean it's not common in any other part of the language for var (or in this case let) to be followed by something other than the new variable name (len), and that variable name was never after the thing it's being set equal to (length), and you don't often see a property name separated from or coming before it's object (the string). let obj = { t: [{ first: "Tom", last: "Alexander" }, {}], a: true }; let { a: [{t: f}] } = obj; What were you trying to explain here? It seems like you proved my point. I assume you wanted to get the first name, in which case this reads in a logical order: let first = obj.t[0].first; Or the value of a? let a = obj.a; Or the number of users in the t array? let users = obj.t.length; I don't care if you're proud of figuring out a very slightly shorter but far less logical syntax for something. As a teacher, and an every day user of javascript, "Make this equal that" will always be far more usable, teachable, learnable, and readable than "Make that from the thing I'll mention later equal this, and here's the thing".
Let me try... How much they should have paid OP: `x` = OP's hourly rate. `n` = number of hours a typical developer would finish the questions. f(x) = x * n QED
Did you get bonus points for pointing out defining a function in a for-loop is generally considered bad practice?
&gt; I mean it's not common in any other part of the language for var (or in this case let) to be followed by something other than the new variable name Sure, maybe it's a good idea not to rename variables as part of a destructuring assignment. I doubt I'd ever use it in my own code; it's a bit too terse and clever. But that doesn't make *destructuring* a bad feature. &gt; What were you trying to explain here? That's a quote from the blog post **you** linked. The author seemed to think it was confusing, but it's not; it's obviously incorrect. But it's also, as you point out, obviously contrived. Destructuring can be used—is being used, today—to make real code clearer and *more* readable. Can it also be used to do the reverse? Sure. But I have no idea what a blog post demonstrating that is meant to show, especially when written by someone who understands the feature so poorly he has multiple errors in his code snippets.
Risky move, the bonus points get cancelled out by the potential-smug-know-it-all points
I'm a senior type engineer (about 10 years experience) and these questions run the gamut from junior to experienced. Some advice you didn't ask for: tell the people who are interviewing you that you mix up `bind` `apply` and `call`. Talk through it and explain that you're aware they all do similar things but you get confused about the specifics. Explaining that you group them together and you're aware they're similar and have a vague idea about them is vastly preferred to saying "I dunno, I get them all mixed up." 
That is a perfect analogy. 
it doesn't really matter what you decide on. Decide on something as a team and make sure everyone follows it.
Thanks! Like I say, it's something I've been crazy about since programming c++ and Java. I'm glad it's in JS now. Just waiting on visibility (which isn't so much an issue since I program more functionally, but still...). And types. Typescript + ES6? Yes please!
Yeah, that was me. I was wondering if I should get someone to proof read this, and said, screw it I'm sure the Internet will. To be fair I still type my name Willaim sometimes. So, not embarrassing too much!
Can someone point me in the direction of a good explanation of the recursive problem listed above. Trampoline maybe?
That does not help in choosing what color to paint this bikeshed.
Doesn't seem to register all of the clicks?
Wow - good pick up. That almost makes me cry... As I say, tooling is a battle at the moment, and I'm not sure who it's against (cruft?) but it feels like somehow if we push hard enough, we might just turn the tide. Isparta does still do a good job at the moment, and if you have a look at the code, it isn't huge - one file does the majority of the work. I'm sure someone will get code coverage working nicely and have the strength of will to maintain it, but until then, to quote my favourite philosopher, "You Go To War With The Army You Have---not The Army You Might Want Or Wish To Have At A Later Time."
Oh sweet. I'll correct it to reference this. I thought it must be possible but didn't see it [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) but now you mention it see that it is there on line 8 of the Object destructuring example!
" Google Chrome 17+ and Firefox 18+ contain an additional way to pass certain types of objects (transferable objects, that is objects implementing the Transferable interface) to or from a worker with high performance. Transferable objects are transferred from one context to another with a zero-copy operation, which results in a vast performance improvement when sending large data sets. Think of it as pass-by-reference if you're from the C/C++ world. However, unlike pass-by-reference, the 'version' from the calling context is no longer available once transferred. Its ownership is transferred to the new context. For example, when transferring an ArrayBufferfrom your main app to a worker script, the originalArrayBuffer is cleared and no longer usable. Its content is (quite literally) transferred to the worker context." They are essentially pointers in ram the worker thread then picks up without a copy I make heavy use of them in the webhamsters library https://developer.mozilla.org/en-US/docs/Web/API/Transferable
If your codebase relies heavily on both underscore and lodash, it makes sense to use the long name for both. If underscore is used 90% of the time and lodash only 10%, use _ for underscore. If you only use lodash and underscore sparingly compared to unused var, use long names, otherwise name your unused variable anyway so that a future developer can know/understand if he needs to use it. Really, just agree as a team, that's all that's needed. The effect on readability, code management and writability is really minimal. Just use whatever you guys can decide on and start working on actual use cases!
&gt; Destructuring can be used—is being used, today—to make real code *clearer and more readable*. Still waiting on that example. And while you're at it, I've yet to see an example of why you'd want to break an object into discrete variables anyway, let alone named after the property names they had in the object. I've seen the extract() function in PHP before, which does the same thing with a better syntax, and it never gets used except for some quick and dirty debugging. I mean, imagine destructuring a user, or a comment, or a DOM element without renaming, as you suggest. Sounds like a great way to end up with variables you don't know or remember the purpose of. What is my *timestamp* variable a timestamp for again? What's this *id* variable for again; the interval ID or the user ID or the post ID or the DOM element ID? And how is a destructured *id* better than just using obj.id? &gt; But I have no idea what a blog post demonstrating that is meant to show, especially when written by someone who understands the feature so poorly he has multiple errors in his code snippets. Ahh, I see what you mean there. I didn't spend much time looking at that particular monstrosity and didn't recognize it when you quoted it.
Two minor points to add. ES5 will still work 10 years from now. It's not a gamble to stay with the old tech if the new tech is an extension of it. The exception would be if you're looking for a job and trying to impress. And moving to ES6 later will only be easier than it is now, because support will be better, browser differences will be worked out, there will be more tutorials, more on SO, more established "best practices," etc.
We always have them something we did in the past month. This way we know that they can do something that actually applies to what we are developing. Has worked like a charm so far. 
I was bored too so I converted it to canvas and added a few extra things: http://codepen.io/anon/pen/LVMYPo
Just remember: This is a cluster fuck.
&gt; Still waiting on that example. Passing in options hashes has already been mentioned. More generally, anywhere you might want to use a named parameter in a language like Python, destructuring can help. Also good for returning multiple values, also good for working with regular expressions (ie, the example [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Pulling_values_from_a_regular_expression_match). Etc.
&gt; The majority of users don't care about dev tools. You brought it up. Not me. &gt;That's what matters to users. UX. Now you're changing horses in mid stride. Hyperbole? What facts have you ever shown while I showed plenty (and have more in my arsenal). You're all talk with no substance and nothing to back up what you say. Just as I said. You don't know what you're talking about. You're a pretender.
variable declaration is hoisted, but assignment isn't. b isn't declared with var, so it's put on the global scope.
Surely asking someone to modify the prototype of a native data type should be a red flag. Define a repeatify function on the String object. The function accepts an integer that specifies how many times the string has to be repeated. The function returns the string repeated the number of times specified. For example: console.log('hello'.repeatify(3)); //Should print hellohellohello. 
Well that makes me feel more comfortable. I was scrolling down and I maybe didn't immediately know one or two. What region are these jobs in? All over? 
That makes sense. So does that mean `var a = b = 5` would fail in strict mode? edit: yeah
But if you're literally asking how much that person knows, and then they go "smug-know-it-all" wouldn't that be exceptional? 
:)
Yeah, but who wants a co-painter who's a Jackson Pollock?
On the other hand, you might just be an art groupie who knows everything about 'what the experts use' and 'the right way to do it' but can't actually paint your way out of a paper bag.
trampolining is one possible solution EDIT: might as well put the solution here var list = readHugeList(); function trampoline(f) { while (f &amp;&amp; f instanceof Function) { f = f(); } return f; } var nextListItem = function() { var process = function(item) { if (!item) { // no more items, do nothing return; } else { // log the item, or do some other processing console.log(item); // return another function to print the next value return process.bind(null, list.pop()); } } return trampoline(process.bind(null, list.pop())); }; nextListItem(); Here's a fiddle to play with: http://jsfiddle.net/acsb39gL/ More info here: http://www.integralist.co.uk/posts/js-recursion.html
 ^r try it. you'll love it. 
what's a little monkey patching between friends?
Paul Irish, Jake Archibald, Addy Osmani, Kyle Simpson to name a few of the most usual suspects.
Ass questions are the best questions!
That's really clever. I like it!
Any time you find yourself simply returning true in one part of your if and false in the other, just return the test itself. function isNumberEven(i) { return i % 2 === 0; } 
Eh... I like the closures question for JS devs. If they don't know what they are or how they work, they can create huge, weird, difficult to debug/resolve bugs. Knowing what a closure is and explaining it succinctly also suggests a good level of curiosity and precision in a candidate.
* revision control is an obvious one, so obvious that novices probably hear about it quite early these days. :-) * patch and diff tools. * how to use the command line. I know a lot of professionals who still have no idea how to get simple things done from the command line. It's a required skill if you are doing anything web related IMHO. * javadoc, jsdoc, tsdoc etc documentation tools. * proper logging. 
Senior dev here: gotta admit that some of these would have stressed me out hahaha.
If you use OS X, definitely check out [iTerm2](https://iterm2.com/index.html). [Atom](http://atom.io/) is a great text editor for a novice. After you have a few years of experience (but not before that), check out vim or emacs. *cough*vim*cough* Learn the command line. 
Jeezus fuck. Are you doing JS development for the NSA?
Usually something pretty simple, like a single page app that consumes an api and displays some data, let's the users route, then we go from there. This would be for a senior level position where we would expect they know how to architect and start building out something like that pretty quickly. The key is that we're not looking for feature completion but rather the thought and methodology on display while they work. Do they stub out unit tests? Are they following best practices in whatever framework they picked? When they hit a wall, how good are they at googling the problem?
I don't understand how that is even possible. 
How would that help? There is no processing that can be skipped by using a cache.
Using recursion here is horrible anyways, so I don't think that matters.
Yea, and a linter would also complain. **Edit:** &gt; var result = str = this; Dude.
Good analogy, although I'd keep in mind that many companies just want to hire wall painters.
I use the force to debug any errors, that and the log files. But mostly the force
Goes against what I would otherwise think to get the length verses checking if the first value exists
1 `setTimeout(someFunc, 10000, arg1, arg2, etc);` - not universally supported 2 `setTimeout(someFunc.bind(null, arg1, arg2), 10000);` 3 `setTimeout(function(){ someFunc(arg1, arg2); }, 10000);`
Thanks for this post. I've always hated programming interviews but I could never quite put my finger on why. From now on I'm going to insist on the one hour craft demo.
or the first value could simply not exist to begin with.
Most progrmmers spend countless hours immersed in their own coding bubble, focused and "in the zone". So then you throw them in a spotlight and expect to see how they code? That is an awful way to judge someone's programming ability. You may as well ask them to disrobe for the interview.
haha I'd never done that before. Bad habit I picked up from the precending question.
Is it intended for it to be misspelled Daedalus? Anyway, seems pretty nice, good job.
Regardless of the perceived performance benefit, this is a terrible idea. The first value is not a valid indicator of an array being empty. All of these would fail your emptyness test. var a = [0] var b = [undefined] var c = new Array(100); 
What are you trying to benchmark here? If you want to compare iteration constructs, you should perhaps actually iterate (and actually compute something). In your benchmark, "length" never changes because the length of the array doesn't change. I also don't see why you'd use "!!" there. "!!" is only useful if you want to turn a truthy/falsy thing into an actual boolean. It doesn't serve any purpose in an `if`. I *guess* you want to compare something like: let a = [...'abc']; while(a.length) { let v = a.pop(); console.log(v); // c b a } vs let a = [...'abc']; let v; while(v = a.pop()) { // stops at: false, null, undefined, 0, NaN, '', document.all console.log(v); // c b a } vs let a = [...'abc']; for(let i = a.length - 1; i &gt;= 0; --i) { let v = a[i]; console.log(v); // c b a } a.length = 0; // if trashing the array is actually important
I suppose 'dedalus' and 'daedalus' are both valid transcriptions of a non-English word. In any case, I might have a go and write a simple adventure game tonight.
Damn that's cool
Static analysis and code reviews should do the trick.
A coffee cup and a computer.
Did you know Facebook.com (not sure if they still do this), overwrote Array.prototype.reduce to a noop?
Hi /u/Mate_Marschalko, you're still posting your own site too much. Last warning.
In this case you could even go with return !!(i%2);
[**@developer_mike**](https://twitter.com/developer_mike): &gt;[2015-07-31 08:26:07 UTC](https://twitter.com/developer_mike/status/627032480978219008) &gt;Morning coders, little tester to keep you sharp on Fridays. Reply, RT or DM your answers [#FUNctionFridays](https://twitter.com/search?q=%23FUNctionFridays) [#javascript](https://twitter.com/search?q=%23javascript) [*pic.twitter.com*](http://pbs.twimg.com/media/CLOqt_MUAAAh2HN.png) [^[Imgur]](http://i.imgur.com/ASwTI4e.png) ---- [^[Mistake?]](/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/3fa8rx%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Since it doesn't return anything and since it doesn't have any side-effects, it does nothing. The compiler could discard the entire body and I'd be none the wiser.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/dojo] [Intern 3 \[testing framework\] is here! • /r/javascript](https://np.reddit.com/r/dojo/comments/3faa84/intern_3_testing_framework_is_here_rjavascript/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger/wiki/) ^/ ^[Contact](/message/compose/?to=\/r\/TotesMessenger))* [](#bot)
Just pushed some commits... https://github.com/dopatraman/curly A lightweight, dynamic string interpolation library for javascript. Now ES6 compatible =D
&gt;See, for example: [Why is extending native objects a bad practice?](http://stackoverflow.com/questions/14034180/why-is-extending-native-objects-a-bad-practice) If there isn't `Array.prototype.forEach` defined (like in IE8) and I want to use it because all the other browsers I support have it built in, then I'm going to damn well define it. &gt;The short version is: you're changing the behavior of *every* object in Javascript. Which might bite you in a 3rd party library where you didn't expect it. Which is the fault of the 3rd party library. There's coding defensively and then there's "can't do this because some fucktard in a library I don't control decided to dictate how I define *my* application". And you don't use that library as it isn't fit for purpose. 
I've always had a problem articulating concepts or remembering terms. However, I've done quite well on projects and am currently a team lead. Knowing and doing are two different things.
phew.
 String.prototype.repeatify = function(x) { return Array(x + 1).join(this); }
Or on bad days, a whiskey flask and a computer.
These are called chained selects
then they have no need for the best and brightest...
You can't make the symbols non-accessible without resorting to that "horrible hack" as you called it. It's awkward to write compared to using Symbols straight forwardly. You gain more privacy than the underscore convention, but it's still not totally private. Until we have ES7 :: I think that using Symbols is clear enough. If you can find a way to make totally private non-static methods/properties less awkward than using WeakMaps to keep references then please feel free to share. In the meantime, I'll stick with straight up Symbols.
I did this stuff like this in Flash years ago when learning programing...completely impractical but tons of fun. Nice work!
Wow, thank for pointing this out. I'm the author, so if you want to ask any question about it, ask away :)
Oh, sorry, sorry. My bad.
Thanks, I'm going to give them a look
Not only that, sometimes you find yourself writing `if(x === true)`, it's much better to just write `if(x){...}`. However, this should be utilized when you're in control of what values `x` can be. Beware of `truthy` in JS. It's still a good way reason your logic. 
&gt; If you can find a way to make totally private non-static methods/properties less awkward than using WeakMaps to keep references then please feel free to share. If those are your only requirements, a plain constructor will surely meet your needs, no? function SomeThing() { var somePrivate = 'whatever'; var somePrivateMethod = function() {}; this.privilegedMethod() { somePrivateMethod(); }; } Of course, the method is no longer static and will be instantiated for each object - but then, that is what you asked for.
You can also use the ternary operator in a similar manner when the values you want to return aren't straight up true/false. function getFileExtension(i) { var x = i.split('.'); return (x.length &gt; 1) ? x[x.length-1] : false; } Note that I changed the comparison here slightly because I like to list the "success" value in the first part of the ternary as a matter of style as opposed to it being the "right" way. Edit: If I was writing that function, I'd probably choose to return an empty string instead of false too. You could potentially cause a display error if you someone consumed your function and didn't check for false before displaying a value in a string concatenation. $(function () { $('#myDiv').html('File type: ' + getFileExtension('someFilenameWithNoExtension')); }); // outputs: 'File type: false' 
Some people just want to do a good job and get paid, they don't want to write a book on it.
So you say what I said was false then go on to admit that it's not false but rather, every language has the issue I said. Make up your mind. Also, Node isn't a language. That, my friend, is "just simply false".
I started collecting a bunch of interview question along the way and added some of my own and made a repo out of it. Take a look https://github.com/kolodny/exercises
No. I don't like the ES6 class syntax, and - currently, at least - intend to keep sticking with plain constructors until something unambiguously better comes along. So the onus isn't on me to prove ES6 classes don't suck ;-)
It's a terrible tool and is actually very similar to JSLint, in that it's perversely opinionated and non-configurable. It's an appeal to authority in the form of a CLI. 
Oh wow.
Do you work @ Intuit? 
Oh yeah definitely understandable. I usually try to be encouraging with newer devs and remind them that's it's totally ok to google stuff as they work. I'll also try and give them an out if it looks like they're totally stuck by suggesting some alternative problems to solve.
They're usually hooked up to a conference room screen or doing a screencast. Its definitely nerve wracking though, and we take that into account. Usually you can spot the difference between nerves and incompetence. 
Yes, history and bang! 
I see what you're saying but the key is that there's no expectation that they have to produce a working app at the end of the demo. It's more about process and we encourage the candidate to talk about their thought process as they work. If you froze up and forgot the syntax for something super basic and just said, "sorry, I'm a little nervous and I'm having a brain fart" I wouldn't fault you one bit. A github repo and a blog tells me that they have built stuff in the past that hopefully wasn't largely copy pasted from somewhere else and that they're articulate and knowledgeable. That definitely gets you through the door, but showing us live is what keeps you there. 
What I meant with "future-proof" is that you can use ES6's features, today, using TypeScript. Apart from that, you can optionally add Static Typing - which is future-proof in the sense that the type information is stripped from your code during compilation, so even if that does not make it into Javascript proper, you will still have valid ES6. But yeah, future-proofing is not the main reason for choosing TypeScript. I was merely pointing out that you're not losing out on that (or at least: not _[that much](https://kangax.github.io/compat-table/es6/)_) when choosing TypeScript over Babel.
All I need is the page's name or url.
[**@akras14**](https://twitter.com/akras14): &gt;[2015-07-30 22:09:58 UTC](https://twitter.com/akras14/status/626877422483415040) &gt;Q. Why did [#JavaScript](https://twitter.com/search?q=%23JavaScript) boxer goto see a chiropractor? A. Because his [#backbone](https://twitter.com/search?q=%23backbone) was [#angular](https://twitter.com/search?q=%23angular) from a [#knockout](https://twitter.com/search?q=%23knockout). [*elijahmanor.com*](http://elijahmanor.com/front-end-web-dev-jokes/) ---- [^[Mistake?]](/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/3fb3sx%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Tough? Seriously? Any decent front-end developer should know all of them (except the angular-js ones if you're not an angular dev).
They are mostly junior/student level questions.
Obviously it's going to be slow, but they didn't ask you to make it fast, they asked you to prevent the stack overflow.
The feeling of "I don't want to work with this guy" would overwhelm however much they know.
I had trouble reading this so I wrote it out step by step. Thought it might be helpful to others so here it is: function biggestGap(values) { var biggest = Math.max.apply(null, values); var biggestIndex = values.indexOf(biggest); var before = values.slice(0, biggestIndex); var smallestBefore = Math.min.apply(null, before); return biggest - smallestBefore; } Edit: unfortunately this answer is wrong, as it fails for [29, 30, 1, 10] Edit2: Here is my stab at a functional solution: function biggestGap(values) { function diff(curr, before) { return curr - Math.min.apply(null, before); } function diffs(values) { return values.map(function(x, i, ar) { return diff(x, ar.slice(0, i)); }); } return Math.max.apply(null, diffs(values)); }
http://codepen.io/anon/pen/vOvKzy
&gt; it's not MVC not a selling point. &gt; it loads logic piecemeal, so everything is lazy-loaded so it uses browserify &gt; it automatically handles routing has a well defined convention for URLs that you must follow otherwise life will suck. &gt; and manages data flow such that you don't have to worry about memory leaks to the same extent, ok?? &gt; it uses its own DSL on top of js What the hell for?
Also to reply to my own question, babel does TCO for self calling recursion! 
I believe you are referring to Bash's exclamation point operator, my favorite is "!$", which is alias'ed to the final argument of the last command given. For example, lets say your last command issued was `ls /home/user/scripts/` and then want to do `cd /home/user/scripts`. If you type: `ls /home/user/scripts; cd !$` then the "!$" will expand into `/home/user/scripts`. For further information please check the "man history 3" manpages and read the sections regarding **Event Designators** and **Word Designators**. Also the find/replace for the previous command operator is `!!:s/search/replace`. If you execute `curl www.example.com` then type `!!:s/example/google`; the command produced will be `curl www.google.com`. If you want to search/replace on a command besides the most recent one, use its history index! If history number 1050 is `echo Hello World`, then a `!1050:s/Hello/Goodbye` will produce `echo Goodbye World`.
Saved for later
&gt; This is one innovation that standard introduced Sorry if I was unclear, but my point is that this isn't an innovation. This is exactly JSLint's approach too (not to be confused with ESLint or JSHint), it is Crockford's opinions and cannot be reconfigured. That tool has been around since 2002, and while it was popular for a long time, it has fallen by the wayside precisely because it is rigid and not configurable, unlike JSHint and ESLint. I'd expect the same to happen to "standard", especially as the guidelines do not hold up when using e.g. ES6. I'm also not really buying the maintenance burden argument either, adding a .eslintrc file is not meaningfully different from adding `standard` to `package.json`.
Our team is actually interviewing candidates this week. Our shop primarily uses ExtJS or Angular+Bootstrap, and our questions tend to focus on understanding classes, manipulation of data, and debugging. Knowing how to debug and research answers is vital. Our in-seat coding demo is completely open-book, ask any of us, Google what you need to get the job done. Obviously I can't speak for every possible team or employer, but ability to ask the right questions and understand your problems can be easier than an inflexible candidate married to one framework.
http://games.usvsth3m.com/javascript-under-pressure/ All you'll ever need
By math you mean doubling a number?
I can see mixing up `apply` and `call`, I do it too since they are basically the same thing, but not groking `bind` sounds like a problem to me...
I don't think anyone would set out to explicitly block Googlebot from accessing JS, but it could result as a side effect of writing robots.txt using an "block everything but" mentality, e.g. User-agent: * Disallow: / Allow: /posts This assumes that the site has HTML under `/posts` that they want indexed, but they want everything else excluded, to prevent accidentally leaking something, but that inadvertently blocks JS under `/scripts/...` or something like that. I don't know, it seems plausible. Until relatively recently it didn't matter if Googlebot couldn't access your JS because it wouldn't use it. 
Don't WebWorkers use the structured clone algorithm? You shouldn't have to JSON.stringify/JSON.parse the message in most cases.
Nah dog, it'd be return !(i%2) 
Git. DevTools. Sublime. MacBook.
Still look difficult.
I dont really understand the question, but pdfjs from mozilla can probably do what you want.
Don't forget this one var a = { foo: 'abc' }; var b = { foo: 123 }; var fn = function (n) { return this.foo + n; }.bind(a); fn.call(b, 456); //=&gt; 'abc456' //and the ugly alternative -- since fat arrow has an implicit .bind() var fn = n =&gt; this.foo + n; fn.call(b, 456); //=&gt; 'abc456' This is why you should think twice about using 'this' inside of fat arrow functions and why you should avoid `.bind()` (also, if `this` actually occurs in fat arrows or if you use `.bind() then performance tanks by 20x or more)
Sure, but waiting 40 seconds to iterate over a 10,000 item array is not an acceptable solution. Ignoring that, it would solve the stack overflow but it would be fundamentally changing the function by making it asynchronous instead of being synchronous. This subtle change can introduce very hard to debug issues. Remember, an interview is just as much about the candidate finding a good employer as it is the employer finding a good candidate.
very cool! could you explain the exact use of socket.io in your game? i always thougt it was just a fallback to long polling if the browser doesn't support websockets. and the complete game state is saved in redis? sorry for obvious questions. will definitely look further into the code! thanks for sharing!
Was fun but I wrote some shitty ass code to beat the clock.
Shoul I feel smart for knowing the answer?
&gt; Its helping me maintain a consistent style across my modules, so it's enough reason for me to continue using it. Then you should absolutely continue to use whatever works for you :) Really my only objection is the name and the whole ; thing, but the name is *The Worst*
From my .inputrc &gt; "\e[A": history-search-backward &gt; "\e[B": history-search-forward These readline mappings mean I can partially type the start of the command and press up/down arrows to scroll through history. Recent grep? g&lt;up&gt;
If I asked you about call and apply in an interview and you said you always mixed them up, I would laugh and say, "me too." As long as you could explain what they're used for then you would probably be fine.
What part of the country are you in? 
Good article and very true.
I love that interview process. It seems like I hear that a lot, while all the horror stories are based on "coding on an island". If i were coding on an island, i'd never get anything finished because I can never remember "the parameters of the parameters" of whatever helpers I'm using.
As an avid civ player, I have a thing for hexagons.
aghhhhh wow first of all thanks for all the help! Unfortunately, its still giving me the exact same error messages as when I first started, even though I've copied in your updated code for the "success" part, and added in the element to my html on the page. :( I'm going to continue staring at your code for a really long time and research to try to understand whats going on. I agree that its tough if you can't just try a few things yourself :/
I agree. Isn't it better to pair with them on the productive code, on real problems? One could be a decent developer on green field and academic problems, but the truth is that most of our life, as developers, is spent on brown field. Why ask candidate theoretical questions or see them work on fake problems when we can pair with them (to pair means also letting them play the role of navigator) on the real code, with real problems? 
I'm curious about this too, so I've saved lists when I come across them: https://www.reddit.com/r/learnprogramming/comments/3cvvx3/how_does_somebody_know_if_they_are_ready_to_begin/cszoq2w https://www.reddit.com/r/cscareerquestions/comments/2q3sqc/if_i_do_squats_every_day_i_will_have_strong_gluts/ https://www.reddit.com/r/cscareerquestions/comments/3f6knf/how_important_is_it_to_be_good_at_questions_on/ 
They are both good choices considering the community they have. The reality is that a good developer will pull off good results with both. React is faster at rendering, specially with hundred of nodes. But I personally prefer angular; it plays nice with the way I like to code. 
I have been a mid to senior level front end developer forever, and I have never used call, apply, or bind in real life.
Damn, as a juniorish developer of 4 years I'm fucked, I'll never get a job. Could probably answer 60% of these things. 
Well, if you have never had to use (or seen) something along the lines of: Array.prototype.slice.call(arguments) to convert `arguments` to an ~~array-like object~~ array, then maybe you've not been a front-end developer long enough.
For the first two I wrote the most beautiful one-liners. For the rest my code looked like it was just vomited out.
Hi /u/muz3m, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `mist.io`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [blog.mist.io](/search?q=%28and+site%3A%27blog.mist.io%27+author%3A%27muz3m%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|18|69%
Hi /u/CreativePunch, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `creative-punch.net`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [creative-punch.net](/search?q=%28and+site%3A%27creative-punch.net%27+author%3A%27CreativePunch%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|150|43%
(A)pply takes an (A)rray.
At least, use setImmediate with a polyfill to get better performances. Using setTimeout to unstack is a hacky way that sure is working but will have bad side effects that you may not want.
So I tried out the game... started a game against the AI, got a nice little town going, then got murdered by a swarm of archers a few minutes in. I haven't played an RTS in a while... This is an awesome little game though, great work!
This is great! Well done!
In general, certifications are seen as a bit gimmicky by true professionals. Why would you show someone a cert if you could just show them real working code from your latest project? In my opinion, certifications are laughable and worthless. Instead spend the time applying yourself to a real project, THAT's how you prove you're a professional.
So much spite. "Please don't tell us what cool stuff you did, it's much better to pay Google to tell people that don't give a damn about your stuff"
I get my thing from MechWarrior tabletop ;)
:|
I would change the href in your 'learn how' button to go to the next page with a hash like '#/option1/suboption2/' Then I would do stuff based on the hash... // We have a hash like this #/parent1/child2/ var router, hash, path; hash = window.location.hash; router = {}; router.parent1_child1 = function () {}; router.parent1_child2 = function () {}; router.parent1_child3 = function () {}; // #/parent1/child2/ -&gt; parent1_child2 path = hash.replace(/\/$/, '').split('/').slice(1).join('_'); if (typeof router[path] === 'function') { // Run your initializations here router[path](); } else { throw 'Supplied hash: ' + hash ' does not point to a valid router.'; } Edited for a better/shorter version
took me 7 minutes, but like 3 of those were because I forgot to include a return statement on the last challenge and couldn't figure out what the problem was &gt;_&lt;
No way I'm not saving this for later.
Not even for mutual auth?
Nope, not worth it. Just have some projects on github and be prepared to answer some technical interview questions and you should be good.
would you mind posting your answer? or pointing me to somewhere i could read about how you did it?
What's the font on that page? It reminds me of LaTeX or a PDF. I'm attracted to it, but it also looks just awful on my screen at 100% page scale. It looks so thin the aliasing messes with the crispness.
Golfed the recursion example a little, to make it even less obvious: return str &amp;&amp; reverseString(str.substr(1)) + str.charAt(0); This replaces the unsightly ternary while functioning the same. 
If you find yourself playing with time - you might want to take a look at [moment.js](http://momentjs.com). Its my favorite time manipulation and formatting library. 
Thank you :) It's late here but I'll check out your snippet in the morning. You're right that the feature sets aren't entirely apples to apples but I still thought he benchmarks were interesting.
No it doesn't! It's `.call()` that takes an array!! Nice try, though! http://i.imgur.com/hYEuRuN.png
I code JS on a regular basis. I know about apply/call/bind but I almost never use them myself (Perhaps because I'm not making libraries?). I never seem to be able to remember details like that; my memory just doesn't work like that. And I don't see why I should, since I can always DuckDuckGo it when I need to. Programming is a lot of details. We have search engines, documentation and intellisense to help us with that. I would never judge anyone for not remembering details.
As with any Turing complete language the answer to "what is x theoretically capable of" is going to be "anything" and as with anything run on a computer that will be followed by the caveat "that you have the time, energy, and memory for" More specific to javascript though you're going to be limited by the fact that your program is running in a browser* which has to interpret the code at runtime (as opposed to something like c++ that is compiled beforehand and doesn't need to be interpreted at runtime). For this and probably other reasons that I'm not aware of, js can be a bit slow, but it's not likely to be an issue unless you're performing a lot of complex calculations and need them done really quickly (like calculating the distance between two points tens of thousands of times per second or something) Another problem it sounds like you might run into is cross-site scripting protection. This will stop you from doing things like embedding someone's web game in an iframe, and then writing js to manipulate the contents of the iframe to play the game for you. Of course, I haven't done any real web development in years so this is all coming from my fuzzy memory and could be wrong / innacurate. P.S. You are at the beginning of an amazing journey. Learn everything you can, and don't let anyone tell you you're doing it wrong or doing the wrong things. That being said, this question kind of smells like an [XY Problem](http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem) *see /u/ioloie's comment
no. That was Java. Java is not js
While it does have the performance limitations of being an interpreted language, you seem to have left out the fact that js is no longer confined to the browser thanks to projects like node.js and atom's electron. As an example, just last week I made a small Linux desktop app to monitor the temperature of my graphics card in under an hour (because psensor's graph is just so ugly).
The last one made me realize that I rely way too much on lodash.
Excellent point. And here I am injecting misinformation into a fresh untainted mind.
I would expect a function called arraySum to only with arrays as the argument. You're calling your method with any kind of object. I prefer it to crash if argument i cannot use forEach function. Otherwise yeah I have a vey similar recursive logic.
For me, the worst limitation of JS is that I can't control the memory usage. So, the basic question is: how to develop a client-side application that works with huge portions of data? For example, there are professional-quality text editors which can open a very big text file (say, 3-4 GB in size) consuming less than 200-300 MB of RAM! On a modern computer, the process will take 10-20 seconds. Ten seconds to open 3GB-sized text file containing millions of lines! I'd like to see such a text editor written in JS...
Thank you. It works. But why it does not work with the body?
Looks nice the only point is that is in TypeScript
Thanks. I just realised I still have a lot to learn.
Looks really neat, will try
That doesn't work for me personally. But I imagine it has something to do with event bubbling.
Everyone knows `.call()` takes a phone number
&gt; limitations of the VM implementations that run it Of course, limitations of the VM implementations are yet another problem, but there is no alternative... &gt; Also, Javascript isn't just in-browser anymore. For the user, it's actually in-browser. Well, maybe someone will use something like nw.js, but that will use the same JS engine as in Chrome, right? Nothing different. &gt; There are tons of scalable, performant high-load JS backends running on Node or io.js these days The same JS engine... And by the way, I am talking about client-side apps for the average user, not about "high-load JS backends" on the server.
It would be cool if it was possible to use nw.js/electron for mobile devices...
Thanks for the tip re XMLHttpRequest, I'll definitely look that up. Yeah given your domain needs to be whitelisted I think they must be taking the API slowly. But it seems to work well enough though! 
.getElementById() or use .getElementsByTagName()[0] to return the first result. You can also narrow the scope of getElementsByTagName by calling it from a node and not the document level.
It is the [zombo.com](http://www.zombo.com/) of languages
Thank you! now i know what to search (so its like with function declarations in function body, but this time only "var a;" part is evaluated first, then assignment is evaluated in proper order after alert)
document.querySelector('tag') only returns the first matched element with that tag, if the browser you're targeting supports it.
There's always the brute force option, there's only 262144 (8\^6) possible permutations. You would need to obtain AES, MD5, and SHA1 JavaScript libraries and run your data pieces through the respective libraries for each step. Good luck getting your piratesonline.co key if it hasn't been claimed already.
You may want to throttle or denounce that otherwise it is going to fire a ton and cause jenk.
No joke; I was just hoping to get a single element rather than a collection. I couldn't use .getElementById() because there are multiple elements I want to style the same. I just used a different method, but if this was a thing, it would have been convenient.
Thanks. Not sure I understand your comment about TypeScript though. Is that a point *against* it? :) The distributed version is ES5-friendly JavaScript so the source shouldn't matter too much.
Id's (=identifiers) are supposed to be unique. Only one element will be returned. @PlNG: You probably meant to write .getElementByTagName with *s* (two times).
The biggest hurdle to that are the compiler restrictions that prevent developers from running Node.js on iOS devices. I have high hopes for React Native though once they release [React Native for Android](http://www.reactnativeandroid.com/) to go with the iOS version.
Ah I see your change now. Nice addition! Haha.. :)
Linters should help with this. They should already complain if you reassign to const (JSHint does) and they could also complain about `let`s which are actually never written to. The editor/IDE could then furthermore provide "quick fixes" for turning `let` into `const` and vice versa.
There is no SIMD, multi threading, or 64-bit integers. Well, as a language which is meant for embedding, it can do anything if you expose some API for it. That's why scripts running in Node can read/write files. Just like PHP and Python, it can do blazingly fast bigint math... if you load a native library for that. The poor tooling is kinda limiting. I don't really see the point of this question, to be honest.
can they use google? do they get an ide with autocompletion?
If there are multiple elements how would a hypothetical `getElementByTagName()` know which to return?
What your thinking of is [Atwood's Law](http://blog.codinghorror.com/the-principle-of-least-power/): &gt; any application that *can* be written in JavaScript, *will* eventually be written in JavaScript.
Yep -- I just edited my comment because I said "defined" where I meant "declared." But due to variable hoisting, it's as though the function were written like this: (function() { var a; alert(a); a = 'value 2'; })(); That's why it was generally considered best practice to declare all variables at the top of your scope, so you don't run into gotchas like this (although `let` and `const` are not hoisted like `var`, and I don't use `var` anymore in production.)
Of course. Google all you want, use any ide you want. This is practical hands on stuff. Use any language, framework, whatever. 
Nice work! I've edited the benchmarks so that the lunr indexes do not include stemming or stop word filtering to make the comparison closer. I'll definitely be taking a look at your code to see if there are any optimisations that can make there way into lunr to improve the performance.
Since tags are valid query selectors, you could always do `document.getElementByTagName = document.querySelector` and get a method that's called what you want and does what you want.
Not that much more work to append a `[0]` to `.getElementsByTagName()`, as /u/PING suggested.
Thank you! :) I realize the comparison isn't entirely fair since Js Search isn't doing stop word filtering by default, (and doesn't yet support stemming). So I appreciate your updating the benchmarks! I'll be sure to update the links on the Js Search Github page to reference your edits. I'd welcome any feedback or suggestions you have if you do take a look. I've used Lunr in the past and was impressed by it. I really enjoy this type of programming though and I guess I couldn't resist taking a stab at it. :)
Thats the one. I never knew it had a name but thats cool. 
So would I. I'd definitely change it. Just what I ended up writing while working fast without thinking too hard, haha. I wasn't sure if the test would actually let you write a second function (probably yes, but I didn't test it). I'd also definitely not use a parameter named `i`. That felt really strange.
I'd LMAO if I had someone interviewing for frontend try to show me certs
Debounce*. I mean, I guess you could denounce it too, if you really wanted.
Pay you for polluting the global scope? ;)
I havn't used onclick in ages, so I am not sure how it works, but you need to use evt in the onclick definition. onclick="publik(evt)". I hope this helps. ;) Oh, and IDs are supposed to be unique id="plats". Most people use classes and use ".plates". Also r/learnjavascript is probably more appropriate.
The handler is triggered if you write "publik(evt)" instead of "publik(ev)", but I have no idea where that "evt" thing is coming from. Usually, you use "this" there: http://jsfiddle.net/g52Lq69q/
also as a function and not a constructor, each call to myObj is just overwriting the global `numbers` property. If you want that an instance variable of a new object, then you need `new` function myObj(numbers) { this.numbers = numbers.slice(); } var list = [1, 2, 3, 4]; var a = new myObj(list); var b = new myObj(list); list.push(5); console.log(list, a.numbers, b.numbers); // -&gt; [1, 2, 3, 4, 5] [1, 2, 3, 4] [1, 2, 3, 4] a.numbers.push(6); console.log(list, a.numbers, b.numbers); // -&gt; [1, 2, 3, 4, 5] [1, 2, 3, 4, 6] [1, 2, 3, 4]
Yep. That's what I ended up doing, but if there was the other one, I thought it would be easier to read.
&gt;Of course, limitations of the VM implementations are yet another problem, but there is no alternative... You're missing my point - I discuss resource restraints (like my example of UI and processing, or storage limitations, or the overhead of *having to maintain a DOM at all*) and compatibility as limitations of the specific VM implementation in-browser - these resource constraints aren't found in clientless usage and so aren't a limitation of *Javascript*. &gt;For the user, it's actually in-browser. Well, maybe someone will use something like nw.js, but that will use the same JS engine as in Chrome, right? Nothing different. Sure, but the point here is that there's no reason to be doing the type of resource-intensive processing that you discuss elsewhere in this thread solely in the context of a browser - browsers aren't *designed* to be slicing and dicing multi-gig datasets, they're *view* engines designed for interactivity. Hence my point about **choosing the right tool for the job** - there's no reason a piece of software written on Node can't provide a UI in the browser as a viewport into the heavy lifting being offloaded to Node instead of the browser's event loop. &gt;And by the way, I am talking about client-side apps for the average user, not about "high-load JS backends" on the server. That's exactly my criticism - this question asks what the limitations of *Javascript* are, not *Javascript in the browser*. Your viewpoint is lopsided because you're refusing to consider the question of load distribution - even if the end-user sees it all via the browser, the issues you have with client-side resource limitations can be overcome by utilizing JS in a *more appropriate context*. edit: more italics, because emPHAsis
What the fuck business is it of yours? You're free to use your choice of code in your projects, they have that freedom for theirs.
It finally wooooorksssss. So relieved after hours of trying to figure out this small issue. Really frustrating, thank you so much. I knew from the beginning it was some small thing but had no idea it had to be evt.. Anyway thank you And yeah you're right. Should use classes instead of id. And didn't know there was a learn JS reddit. Googled reddit JS and find this subreddit and saw some other posts about learning. Will use that in the future. 
You've spammed this across multiple boards. As someone else as said, why is it your business to push a company into releasing their code into the market? Releasing software as open source is the choice of the creator, and as a business I think reddit is more than welcome to make that choice.
Ya, doing it with regex turned out pretty ugly. function getFileExtension(i) { return (i.match(/\.([^\.]+)$/) || [])[1] || false; }
I would just pass an array around.
&gt; Have you never iterated over a NodeList? No, always used jQuery. 
&gt;why is it your business to push a company into releasing their code into the market? Thanks for your question. There is a [campaign](https://www.fsf.org/blogs/community/freejs-reddit) at the moment to try and make the internet a more free and accessible place. "...the JavaScript that reddit.com serves its users isn't actually labeled with the licensing information necessary for it to meet the free software definition." Raising this issue with Reddit is a request for it to comply with free and open standards. It is like Air Traffic Control having standard altitudes for planes on hold. I hope that you can see the value of the campaign, and I encourage you to join it.
Or you know, don't. Local mutation is the most common use-case for let and it's idiomatic style. Const as often as possible but don't avoid loop variables, reassignment of block scope names, etc
In all seriousness, it is their platform to do with what they want. Should I be forced to release my code, even if it serves as a communication platform? Open source is great and all, but not always the best idea, option, or business case. If you don't like it, do a pull, change whatever you don't like, and see if it gets pulled in. Or fork it. But really, don't we have more important things to worry about in our industry?
First you do the needful.
Thanks for your comments. People are generally glad to receive a bug report of their software. It is a sign that people are using it and value it enough to study and try and improve it. Solving this bug wouldn't cost Reddit much more than a bit of time. It would help make one of the best places on the Internet even better. Reddit isn't a free platform on git. It is better to work with the existing developers rather than losing patience and forking at each dispute. Maintaining a free and open Internet is very important right now. Issues like FreeJavascript, net neutrality, freedom of speech are at the forefront of the news right now. 
I understand the value of open source software. I will always try and release my software to the open source community. However we shouldn't push anyone to release code into the free market because its entirely up to the business and creator on how that code is handled. "Free and more accessible" - The website is entirely accessible. This isn't about making websites accessible this is a campaign about making code free. I don't think all code should be free. People should be entitled to sell, give away, license or do whatever they like with their code. The code we write in our business at the moment is completely closed source. Why? Well why would we want to give our competitors an advantage? The system we have written is miles ahead of the competition in what it can do, and if we just released all our code into the open source community we would be essentially be giving a way our product for free. We live in a world where people need to be paid for the work they do and businesses need to make money.
No, that doesn't make any sense.
&gt;That would be nice. Sure, that would be nice. Lack of out-of-box convenience does not a "limitation" make. &gt;The memory problem is the limitation of Javascript itself, not Javascript in the browser. Just not true - there are no concepts of `Stream`s, for example, in browser implementations, which avoid the cost of loading a large dataset entirely in memory before operating, or the ability to spawn child processes easily and repetitively (WebWorkers get close, but cooperative multitasking is just plain easier out-of-browser right now). Just two examples of improvements to memory management that aren't handled by your limited scope of analysis re: browser-only JS. &gt;What do you mean by "more appropriate context"?...Situation: the users have no Internet connection, but they want to do some resource-intensive processing...How would they overcome this and utilize JS? This is patently misleading - it's a limitation of any potential backend architecture, and the question asks specifically about limitations of Javascript. It would also be overcome in the same way that it would be overcome in Java, or Python, or...any other server language, by running the software *locally*. Just because a browser window is open doesn't mean the packets are leaving the machine-local network - you could even spin up multiple Node processes and have Nginx loadbalancing locally across them. This approach is proven - Google Refine uses a Java-backed web interface to enable ETL of large datasets. You can run it offline. You don't *need* a connection to process gigabytes of data, period. It's stream-based, so it could be implemented in JS as well. Also, it's arguably a terrible technological choice to require gigabytes of data be loaded fully into memory before handling. Distributed computing has moved far away from this necessity - Flume, Kafka, Hadoop, and Spark are all stream-oriented for a reason. It's not scalable. But to answer your question, yes. Resource-intensive tasks should be handled in the context of a backend or alternate thread, and NOT in the same runtime thread that's responsible for presentation and for being responsive to user interaction. That's just basic good application architecture principles.
[Create a new column with the product of the entire row. Generally we give 15 minutes to complete on a white board. This is part of our technical interview at my firm](http://codepen.io/TutTut/pen/XboaQN) Note: You cannot manipulate html or css
&lt;script&gt;&lt;/script&gt; Deliver it!
It looks like you could. I've never heard of fetch, thanks for mentioning it! The only problem is it's still experimental. All in due time, I guess. For those interested, here's the documentation for fetch: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
&gt; The website is entirely accessible. It is, if you are willing to run non-free javascript. If you are not, you can't, for example, use the "report a bug" link Reddit provide to raise an issue, or even open up a thumbnail of a front page image using the link. If one confines oneself to running only free software, it becomes a great disappointment to find that a loved site is running non-free code. There are free alternatives. Naturally, people urge one another to consider the merits of Libre software. &gt;People should be entitled to sell, give away, license or do whatever they like with their code. I agree. I do hope, however, that people become aware of the [importance of free software](https://www.fsf.org/about/what-is-free-software) and consequently choose to release their code under a free licence, like the GPL, or use a free alternative, if they are developing. 
Totally debounce and maybe add some smoothing CSS properties.
A week... You won't master the language, but you can know enough to learn on the job. Tell your boss the truth about where you end up in one week. Because honesty is a corner stone to a long career. You reminded me that I set myself a bit of a high bar... We can only do so much in the time we have. We'll do our best in our time--and our best is good enough. 
Looks good, getting the product is a good candidate to use reduce though. Here's what I wrote: $('tr').each(function(i, tr) { var sum = $(tr).find('td').get().reduce(function(cur, td){ return cur * +td.innerText; }, 1); $(tr).append('&lt;td&gt;' + sum + '&lt;/td&gt;'); });
Are you also going to be able to write the code for the library you're using within the 15 minute time-frame? 
You could more simply loop through rows[i].children instead of rows[i].childNodes and possibly want to call parseInt() on the innerHTML. [EDIT]: Not sure why I got downvoted - but looping through children instead of childNodes you can skip the whole nodeType checking. And parseInt() is both more explicit in what you're doing but also better at parsing ints than the default casting (F.ex, **parseInt("10 .") * 2** VS **"10 ." * 2**)
This took me a lot longer than 15 minutes: (function ($){ $('tr').each(function () { var product = 1; $(this).children().each(function () { product *= parseInt($(this).text(), 10); }) $(this).append('&lt;td&gt;' + product + '&lt;/td&gt;'); }); })(jQuery); Edit: Now calculates the product instead of the sum.
Yeah I've also noticed that inputting a loan of 1234 and a down payment of 234 returns the same thing. Very confused... I'll give that line a shot. Thanks! Edit: Fixed the downPayment &gt; cost issue by removing return false;
I updated my response with some overkill, because you don't need jQuery. You would want to listen to the 'keyup' event on the input to fire you automatic update.
Implement some of the Lodash functions. Benchmark them and see if you can tweak them to make your implementations faster. Alternately, consider contributing to an open source project. (I'm always looking for another contributed on Angular formFor!)
The advantage to listening on the body is that you have one subscriber.
&gt; $('.calcInput').on('keyup', functionNameHere); Right-click -&gt; paste won't trigger it. The correct event type is "input". However, it's unsupported by IE8 and broken in IE9. http://jsfiddle.net/Lkvq11ry/ https://developer.mozilla.org/en-US/docs/Web/Events/input Well, jQuery lets you list multiple events there. So, you could just write something like "keyup mouseup dragend change" and hope for the best.
Speed read through eloquent JS. Look at scopes/closures and this/objects from here: https://github.com/getify/You-Dont-Know-JS
I would do the formatting and calculations on blur rather than keyup. Blur will fire after the user moves off of the field and on to the next one. Keyup can also be kinda wonky from a UX perspective. 
They mainly get a bad rap because of the bad developers who tend to try hiding behind their certs as a show of competence. If you are good at what you do, you should be able to make it through my interview process without having to pull out the smoke and mirrors.
Why not? :p function $(selector, base) { let nodes = (base || document).querySelectorAll(selector); return Array.prototype.slice.call(nodes); } $('tr').forEach((row) =&gt; { let val = $('td', row).reduce((s, d) =&gt; s * parseInt(d.innerText), 1); let col = document.createElement('td'); col.innerText = val; row.appendChild(col); });
Honestly? Find something you care about. The best thing I ever did for my programming was finding projects that motivated me. At that point you can push yourself to any level because you really care about the work that you're doing. Find some of your hobbies and see how you can make them better with tech! 
Or better yet, why not just give them a project to work on at home and then have them come in and present and talk about it. Let them have their time to do what they do, then have them explain it.
Disappearing placeholder text is great for *examples*, not so good for labels. 
What if you want to check the numerical value of a string?
Parse it into a number first. 
Thanks for replying. I understood things a lot better once I read the github page of Netflix. If you are the author, I would recommend you add a paragraph or two that introduces the framework a little better for people who aren't familiar with Netflix's library. This sounds pretty cool, I think I'll give it a test drive.
If the console was opened at all during the browsing session, that can also increase the measurement time. I think it would be best to just dump that information to the DOM if you're using a browser anyway.
True, I didn't think of that. Yours fails for one element arrays, but it should be easy to fix.
I'm not going to promise you I'll stop.
But isn't meteorjs feels like too magical? For ex like the server, client folder and the serve folder, and you load all the javascript you've made in everypage and also the blaze syntax feels really weird compared to laravel blade syntax, and its feels scripty...
Considering even the [Fetch API](https://developer.mozilla.org/en/docs/Web/API/Fetch_API) uses promises I think you might be fighting an uphill battle.
 function getElementByTagName(name) { var tags = document.getElementsByTagName(name); if (tags) return tags[0]; return tags; } 
That's exactly why I think it's a critical time to face this issue.
dragula looks really good for drag and drop ive used jquery ui draggable for ok results
You can treat the final `.then()` as a callback.
Sorry can't see that bit anywhere. Could just be the mobile version of code pen though. I was basing my answer off his original post/instructions. 
&gt; I don't see much difference between "... function(err, result){}" and "...then(function (result){}).catch(function(err){})" There are some notable differences. For example: * a promise can't be cancelled * the function called when a promise is fulfilled can't be executed multiple times
"Although promises are widely applicable to asynchronous operations of many sorts, there are still situations where they are not appropriate, even for asynchronicity" http://www.w3.org/2001/tag/doc/promises-guide#when-not-to-use
&gt; Callbacks, on the other hand, are the most basic form of async programming Eh, not really, they're just the ~~first~~ way JavaScript did it (edit: come to think of it, second. The first was storing a string to be `eval`'d in the global scope, also known as event attributes.). Use a language with real parallel processing support and you'll consistently find a million and one ways to do async. The only thing that never changes is the logic, and that completely makes sense: the logic is what your library is actually implementing, the rest is just packaging. So I just write synchronous libraries and let people wrap it in a cool-kid style of their choosing if they wish. Which is actually always a straightforward task, unlike reversing it and going from an async library to synchronous code. I know, burn the heretic.
While the numbers will change browser to browser/computer to computer you could print console.log(new Date()) before and after the block is ran or you could use chrome developer tools which will tell you how long it took to execute all the javascript on the page.
You could just use a more specific selector?
IMHO, promises are a much better option in the long term. Not really because of how they work, but because they're a necessary common base for the real win, which is async/await (hopefully to be included in ES7) C# went through the same thing, and writing async code is vastly cleaner IMHO without the hacky approaches like spawn / co or (ab)using generators. As others have mentioned, if you want a callback to be accepted, call `then()` - it makes more sense to have api authors use the common ES6 approach and others that dislike it wrap to be callbacks than make it callback based and make people wrap it to be promise-based (with bluebird or whatnot if the callbacks follow the node convention). C# had the same issue, with a callback-like approach already existing, so there was a transition time for people to start supporting/using Task&lt;T&gt;, but once async/await becomes prevalent, Promise will hopefully be recognized as the key piece of supporting infrastructure that it is. :) TL;DR async/await will make Promises worth it.
Post back what went over your head in r/learnprogramming, I'm sure I or someone else can help you out!
Upvoting because it's definitely a good conversation to have, even if I don't agree with the premise. I'm on board with Promises for finite values (as opposed to Streams for 0..n values over time) because async/await will use them under the hood. Anything that returns a Promise will work with async/await for free. The best argument I can come up with against Promises is that I don't think they're pure functors so if you're aiming for pure functional code you can't use them. But then again if you're aiming for pure functions in JS you're already fighting an uphill battle. TMTOWTDI leads to lots of incompatible libraries, so I'll usually pick a mostly-good convention over a dozen great but incompatible solutions.
Sure, there are differences in principle, but if I'm using a library, I don't really care either way. I can bend it to my use case. Cancelling a promise: function takesCallBack(filename,cb){ fs.readFile(filename).then(function(fileContents){ if(fileContents!=='what I expected'){ //cancel further processing: throw new UnexpectedFileContentsError(); } return fileContents; }).then(function(fileContents){ var ret = parse(fileContents); cb(null,ret); }) .catch(UnexpectedFileContentsError,cb) .catch(function(err){ return cb(null,''); }) } Executing a function multiple times is a specific use case (you generally don't want that to happen, and one of the benefits of promises is to prevent that), but if you need it, you can make it happen. I have trouble imagining a use case, so here's a contrived example: function takesCallBack(filename,cb){ var max = 10; fs.readFile(filename).then(function(filecontents){ var lines = fileContents.split(/\n/); var i = 0, l = lines.length, doneIsCalled = false; function done(err){ if(doneIsCalled){return;} doneIsCalled = true; if(err){return cb(err);} return cb(); } (function next(err){ if(err){return done(err);} if(i&gt;=lines || i&gt;=max){return done();} var line = lines[i++]; cb({line:line,lines:lines},next) })() }) } I am not an advocate for promises. Far from it. I really dislike them, and prefer to use good old callbacks wherever possible. That in mind, all I'm saying is that it doesn't really matter. You can make any abstraction work for you in the way that pleases you most.
Or use getElementsByTagName() and have it work all the way back to IE 5.5 I was not trying to re-write code, just point out the bit I thought may have been a typo.
The second one; is this method used to make sure that numbers are not considered? I was about to use this method recently until I realised that one of my variables returned is a 0; I also have a question - I recently saw my professor do this at university: var telephone_str; { if (telephoneNumber !== null) { test_str = telephoneNumber; } } var mobile_str; { if (mobileNumber !== null) { mobile_str = mobileNumber; } } What does surrounding the if statement inside the variable actually do?
ERM, can you explain a bit more what you actually want to do?
I'm kinda high right now, but something like: var numberOfUsers = usercount ? usercount : 0 numberOfUsers = usercount !== empty ? usercount : 0 
A point being OP wanted to get the single node but used a non-existent (though cromulently named) method.
I want to make a script which creates a number between 1-100 and then outputs it to another client
just to reinforce this, remember that the integer 0, undefined and null they all result to false, so even though you are high, your example should be enough for OP.
Yeah, and some people still have IE installed.
If the condition evaluates to `false` then what do you want the value of `numberOfUsers` to be?
What you want is `val != null`. With coersion this will only be true if val is not null or undefined.
? is called the "ternary operator". It evaluates the expression to its left. If the expression is truthy, it returns the first value to the right; otherwise it returns the farthest right value. Examples: true? "yes" : "no" -&gt; "yes" false? "yes" : "no" -&gt; "no" If usercount is null, 0, or undefined: usercount = usercount? usercount : 100 -&gt; usercount is now 100 If usercount is any number other than 0: usercount = usercount? usercount : 100 -&gt; usercount remains unchanged Apologies for formatting, I'm on mobile.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator It's called a ternary. The link should explain it.
How about: var Something = ThatOtherThing || 0;
I'm not sure if that will work because I am working with 0 and boolean values.
OK, and if that's not the case, then what? Abort everything, or just don't set `numberOfUsers`?
It's not "in" the variable. There's a semicolon on the var statements.
Shorthand for an empty check I think. This is all mostly pseudocode
ES2015 &amp; ES2017 total emersion in Promises is exactly what I'm suggesting to reconsider. I believe that a language should only provide rudimentary building blocks, not momentarily popular abstractions.
True. You can also treat Kefir's "onValue" as a callback. Why can't we just treat a callback as a callback?
What do you mean? From your question I assumed that you were trying to assign a value to `usercount` if it was not already assigned, but that might not be correct.
 // Equals usercount if it is truthy (assigned and non-null, non-false, non-zero), otherwise zero. var numberOfUsers = usercount || 0; // Equals usercount if it is a positive number, otherwise zero. (Always returns a number.) var numberOfUsers = usercount &gt; 0 ? usercount : 0;
&gt; it makes more sense to have api authors use the common ES6 approach The ES6 approach is decided upon by mere mortal, like us, who are sometimes influenced by popularity hypes.
var numberOfUsers = usercount ? usercount !== empty ? usercount : 0 : 0; var numberOfUsers = userCount || (userCount !== empty) || 0;
You can do this in the console, or create an extension through ff or chrome. Give every user in reddit an avatar. 1. you'll need data on which users have what image, create a mock for this thread for example 2. modify the page html and insert the avatar for every user. make it look nice. 3. bonus: insert the avatars for comments that are loaded when you click "load more comments"
&gt;momentarily popular Uh, dude... async/await has proven a huge success in the C# world already (and has been around for over half a decade) I wouldn't describe this as adopting a flash in the pan feature
I understand, but I do not believe that OP's intention was to attach an event handler to *just one* of the text boxes, but to all of them. The error was in understanding how this is done. After all, if he wanted to isolate one of the inputs, why not add an ID to the HTML, then use getElementById(). And not that it matters, but you can still get the first DOM element with the IE5.5 method: document.getElementsByTagName('input')[0]
All the recommendations in this thread are good, but you have to be careful when a falsy value is a valid choice. As a contrived example, `numberOfUsers = numberOfUsers || 10`, will give you 10 users even if 0 was passed in and 0 is a valid case. That's a really contrived example, but you get the idea. If false values are valid, you need to do `userAcount = userAccount == null ? 0 : userAccount`, this takes advantage of `==` returning true for `null` and `undefined`, but if your shop forbids double equals (and really, it probably should), you have to get even more verbose. If `null` is a valid choice but `undefined` is not, then the best answer is `userAccount = typeof userAccount === 'undefined' ? 0 : userAccount` # The trap of || Using `foo = foo || defaultValue` is a very common bug when 0, false, or the empty string are valid values for foo. 
This seems to be what you're looking for: https://github.com/rmurphey/js-assessment
Rudimentary building blocks work only when the performance difference is nil for creating it as a library. In the world of JavaScript, every library adds download overhead and the inability to be implemented natively. Now you can point to the popularity of lodash and the argument becomes native implementations tend to be bad, but really the issue is a bad spec supporting use cases that shouldn't have been.
You can `await` the result of a Promise. You can't do that with a callback. Secondly, if everyone uses Promises, everything fits much better together. Just take a look at Dart for a good example. It supported Futures and Streams from the very beginning. Everything uses that stuff. Web application frameworks, database drivers, template engines, I/O stuff from the stdlib, and so forth. Same deal with the client side: XHR, IndexedDB, rAF, and so on. Everything works the same. Everything can be done concurrently or sequentially. while(true) { num now = await window.animationFrame; ... } That's how I can do my game loop in Dart. It's fantastic.
PS. I noticed a small optimization that could be made regarding stop words so I submitted a PR with a linked JS perf. :)
&gt; Yes, Promises are part of ES2015, but they are far from being a "perfect solution" (even today!) for managing async flows. You might be interested in my [Task Runner JS](http://taskrunnerjs.com/) library. :)
I agree, I've had better results with `new Date()` comparisons. Or with node, you can use `process.hrtime()` for more precision. Is it a perfect profiler? Of course not. But it's still a great tool for estimation.
Not in old IE (&lt;9). It's your decision to support that or not, of course.
Take a look at async/await.
That's sort of what OP is asking. What projects will help build those ideas and concepts.
Yeah, the imposter syndrome seems to hit everyone at some point. It would really be nice if we had some form of standard to judge proficiency by. If someone doesn't have guidance or is self taught, it's hard to know if they're going in the right direction. With so much to learn out there, and with so much changing constantly, there has to be done fundamental projects that anyone ought to be able to figure out. But there really isn't a core list everyone rallies behind, is there?
great plugin was actually building one very similar with added text cursor. I know i am a bit late but how would i stop at the last sentence instead of loop?
I would assume he/she means an empty string, which is falsy.
Yes, though the first one accepts any falsey-ish statement while yours accepts true/false. The first one will be more likely to fail than an if statement. (On mobile so I don't have a link, but check mdn for usage)
You'll have to explain a little more about what you mean by "another client". Server to User? User to User? What is your intended use case?
where is a good jS tutorial for something like this?
Lookup knockout.js for updating calculations as variables change. Observables are ducking awesome.
I've literally never used jQuery before, and barely JavaScript, but I decided to do this because I was bored. How's this? $("tr").each(function(_, row) { row = $(row); var product = 1; row.children("td").each(function(_, cell) { product *= parseInt(cell.innerHTML); }); row.append($("&lt;td&gt;"+product+"&lt;/td&gt;")); });
Promises and RxObservables are different things with different use cases. Neither is better than the other because they aren't competing.
Not exactly lol
Promises aren't perfect, but they're decent, and they exist now. And while we might end up wanting to shim them in the future, we sure as hell want to shim callbacks now, so I'm not seeing the advantage. &gt; Callbacks, on the other hand, are the most basic form of async programming, without any added abstraction or fluff - meaning that they will be here for long time to come. Just because they're the abstraction you're familiar with doesn't make them the most *basic* form. And in any case, promises are part of the language, so they're not going anywhere either.
For what exactly? Canvas? Collision detection?
I just can't make those kinds of assumptions, but agreed :)
It looks like `timeout` is a special event in `http2`. Although, I am unsure if this is the same as `ETIMEDOUT` as I am unfamiliar with the HTTP/2 spec. https://github.com/molnarg/node-http2/blob/26b1fa5aec7d8c60b1aac7b295c6df0b25c7fbb4/lib/http.js#L100 Try out the following code (we added a new listener to the `response` object): var http2 = require('http2'); var req = http2.raw.get('http://xxx.yyy.zzz.a:23/', function(response) { var content = ''; response.on('timeout', function(err) { console.error(err); }) response.on('data', function(chunk) { content += chunk; }) response.on('end', function() { console.log(content); console.log('end'); }); }); req.on('error', function(error) { console.error(error); });
awesome! thanks man!
I've found that it's usually more user error than malicious.
The perils of a loosely typed language :(
I would say there is a significant reduction in boilerplate in this library. Like I said in the title, compared to a lot of frameworks, this one requires very little boilerplate. I would suggest taking a look at the examples in the repository. https://github.com/twfarland/kilroy/tree/master/examples
Yeah, so that's how you would do it: keep your own application state with a `newTodoBody` field. new-todo.onchange: update the application state by setting `newTodoBody` to the input's current value add.onclick: update the application state by adding the `newTodoBody` value to the todo list, and setting `newTodoBody` to an empty string
 return ['li', ['span', todo.text], ['a .del', { href: '#' + i }, ' [&amp;times;]']], // element with the class you wanted, added to the right of the tag above ['button .add', { type: 'button' }, ' [+]']]; })]]; You use nested Arrays to add children to elements. Here is the order: ["elementName", { // attrs go here }, [ // children of this ], "Text Inside elementName"] Further Example: ["ul", { class: 'unstyled' }, ["li", "Item 1"]] // &lt;ul class="unstyled"&gt;&lt;li&gt;Item 1&lt;/li&gt;&lt;/ul&gt; Lazy classes and ids: ["ul #list .unstyled", ["li", "Item 1"]] // &lt;ul id="list" class="unstyled"&gt;&lt;li&gt;Item 1&lt;/li&gt;&lt;/ul&gt; This type of HTML is called JSON ML. http://www.jsonml.org/ (scroll to the bottom of this page)
i like the concept of rendering dom elements using js objects... something along the lines of [jxon](https://developer.mozilla.org/en-US/docs/JXON#Algorithm_.233.3A_a_synthetic_technique) used programmatically to bind the model and view.
I'm not sure what libraries or frameworks you are used to using, but that's quite a bit of boilerplate from my perspective.
I must not be explaining my question properly: When the add button is clicked, the events.click.add function gets called passing in the event and target. I want the value from a sibling item to the event target passed in. How do I get that value? In jquery I can use $(a.el).sibling('.new-todo').val(). In reactjs I can create a ref to the sibling item, and refer to it this.refs.refName. events: { keyup: { '.new-todo': function (a) { if (a.evt.which !== 13 &amp;&amp; a.evt.keyCode !== 13) return; this.addTodo(a.el.value); a.el.value = ''; } }, click: { '.del': function (a) { this.delTodo(a.el.getAttribute('href').slice(1)); }, // ADDED this event '.add':function(a){ // how do I get input.new-todo value here? console.log(a); } } }
That
Another option is to start with the event target, and navigate the DOM from there. Probably not a very sustainable solution, though.
Oh I see. There is nothing wrong with using jQuery in here. You can use `event.target.parentElement.children`. This should give you the the siblings. Or you can also use normal `document.getElement/querySelector...`. '.add':function(a){ // how do I get input.new-todo value here? console.log(a); // like so var val = document.querySelector('input.new-todo').value; // jQuery var val2 = jQuery(event.target).sibling('.new-todo').val(); console.log(val, val2); } Note: `this` becomes your top level application element. This is because Kilroy uses event delegation inside of the application element you have attached to.
You include 1 file via a script and create a class. How do you rate `jQuery(document).ready(function($) { ... });` on your boilerplate scale?
&gt;Read the specs Read the specs?!! I was downvoted into oblivion for telling someone to read the specs just two days ago! EDIT: Which mod edited out my link to the downvoting and why?
Javascript is single threaded. It can only do one thing at a time. Although you a not blocking immediately, in 4 milliseconds the code will block other code. When the setTimeout executes (4 milliseconds after the original call) the JSON.parse will block the UI if you parse a large JSON object. Try it yourself. The linked article is a workaround. Another option is putting the JSON.parse inside a webworker. If you have a simple JSON, it is not necessary, but there are times when you need to parse large JSON object.
Very nice. I like the use of $.each. Only parts I don't like are the _ as an index and the use of innerHTML when you're already using jQuery. But that's just me, others will probably find this perfectly okay. Good stuff
I never said node was a language, I said exactly what I meant: There are neglected code bases in every language. Your complaint about node is present in every single ecosystem which is large enough to actually have people create open source projects in. Of course, you're just nit picking here because you know everything I said is right. You are echoing sentiments against node that you have read else where on the internet but you forgot the valid arguments against it, so instead you just made some stuff up to join the band wagon. Granted, I am not saying node is without faults, but what you said has absolutely nothing to do with the real tangible faults which should make someone choose a different technology.
Ohh well then, this is awesome.
This is terrible advice. Fighting against the adoption of promises is not only an uphill battle, but a battle which should not be fought in the first place.
Have updated the OP with my plans. Would you mind if I ask you a few questions via PM, regarding what you look for in new recruits, and what you expect of your hired devs?
Try doing anything non-trivial with callbacks, as well as with promises and compare the resulting code.
Since the shaders are written in javascript, how hard would it to be get a canvas implementation of this? I just published https://github.com/inssein/jsfx/ in which filters have a shader, but also a pure javascript way of doing it, which (in most cases), is a direct translation of the shader. An interesting solution could have been to have a javascript function that gets converted by js2glsl for WebGL.