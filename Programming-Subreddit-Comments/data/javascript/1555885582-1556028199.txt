To play a bit of Devil's Advocate - in your example it would be about 10% as difficult as you implied. For example you could use VSCode's _Replace Symbol_ and be done in 3 seconds.
This. I love types. We use flow typing. The idea of type annotation (as opposed to another transpiled language) feels much better
Yeah, I don't like the TSLint ecosystem but it's absolutely a major part of the ecosystem. Look at it this way... It's like saying I don't like VSCode because VSCode extensions can't run on my computer but WebStorm extensions can so I use that instead. There's nothing wrong with VSCode itself so why would I complain about VSCode? Well because the extensions can't run so it's crippling to the end product. The ecosystem is a part of the product. That's the state of JS and open source programming communities. &gt;because TSLint default config is not exactly what you want It's not that it's not exactly what I want... it's that I have to spend a couple of hours mucking around with the config because it's the exact opposite of what I want. Then I have to spend time getting my team on the same page regarding Typescript config changes and standardize those config changes across multiple projects. Now if I inherit a project, I have to either respect the original programmers config leading to totally different code styles or update it. No. The team doesn't actually care about the import order -- so we update the config. No. The team doesn't care if you have a trailing space -- so we update the config. Why not just use Prettier to manage code styling and let the linter do the actual important stuff? &gt;People get used to seeing the linter as an **overzealous noisy gatekeeper** rather than a helpful tool. Useful warnings are drowned out by a sea of style nits. As a result, people don‚Äôt scan the linter messages while debugging, and miss helpful tips. Additionally, people who are less used to writing JavaScript (for example, designers) have a harder time working with the code. &gt; &gt;[https://overreacted.io/writing-resilient-components/](https://overreacted.io/writing-resilient-components/)
You know the benefits you get from prop types? Well, what if you could gain them _everywhere_, with no runtime costs, no need to maintain JSDoc comments, and no need to write unit tests to prove basic integration? _That's_ the benefit of a static type system.
Considering that I said that "If they use jsdoc", they don't have to change anything. Again, since we're only talking about the types here, writing the docblock is trivial, there's nothing difficult in it. Yes you need to keep it up to date, but the same applies to whatever the other option for docs is.
Yeah but you won't use VSCode inside your pipeline that runs your CI tests, right? TS fails in build time
&gt;I don't have to worry anymore about fracking types and definitions. Everything can become anything. In an untyped language like JavaScript, you **do** still have to worry about types and definitions, and not everything can become anything. The benefit of a compile-time type checker is that it reduces the burden of that worry. For example, try to write a program that prints "Hello world" in Javascript. You'd probably write something like this, right? console.log("Hello world") If you didn't have to worry about types and definitions, and if everything can become anything, then you have no guarantee that the above code will work. How do you know `console` has a method called `log`? How do you know `log` is a function that can take a single argument? How do you know `"Hello world"` is a String? How do you know it won't spontaneously change into `null`, if anything can become anything? Whether you realize it or not, you're always using types and definitions, and the fact that values retain their type, when programming.
Ok. Good luck.
Fair point. However your unit tests would pick up that error.
Ain't nuthin but a heart ache.
Thanks üëç
I would like to try it, but 99% of JS code I write (outside of my day job) is Vue.js, and though Vue 2.x has decent support for TS, I hear it‚Äôs going to get a lot better in v3 so I‚Äôm just holding off on that. I absolutely love how fast and productive I can be with vanilla JS, but I do want to give TS a fair shake. I‚Äôve been admittedly very dismissive about it, but it‚Äôs skyrocketing popularity has finally made me want to give it a go. Plus, it can only boost my resum√© so why not.
It's hit or miss for me. Some projects benefit from it, others it just gets in the way. In my current project, I [switched away from TS](https://github.com/r-spacex/Enceladus-LTI/issues/5) a couple weeks ago after encountering an issue that the language team has marked as "working as intended", despite it being fully supported by JavaScript. Also in the same project, getting data from APIs is a complete pain. Unless I were to write a fully typed wrapper, I have to explicitly tell it the type of everything to avoid warnings related to `any`. For a single request that's not an issue, but I have to do that in every location. One major feature that's lacking is the ability to destructure with type definitions easily. An example of this comes from my current project ‚Äî I had to write this: const { room, action, data_type, data, }: { room: string; action: 'create' | 'update' | 'delete'; data_type: 'thread' | 'section' | 'event'; data: CUD&lt;any&gt;; } = JSON.parse(event.data); when I _should_ be able to write something like this: const { room as string, action as 'create' | 'update' | 'delete', data_type as 'thread' | 'section' | 'event', data as CUD&lt;any&gt; } = JSON.parse(event.data); It's much clearer what type is related to what variable, and doesn't require you to jump back and forth to find the type definitions (absent a language server that provides you other capabilities). On a more minor note, having better type inference would be great. Rust is a good example of this; the only time I have to declare types is in the function header (by design, it could technically be inferred) and when the compiler isn't able to infer a specific type. Interoperability with ECMAScript proposals would also be great, though it's by no means a must-have. I know there was a proposal from the language team to follow Rust's ideology and provide nightly releases, which would have additional features that must be explicitly enabled (and have no stability guarantees). Perhaps the most minor of all, a TypeScript minifier would be outstanding. Of course, if anyone can point me in the right direction, I'm not opposed to going head-first and trying my hand at implementing (or at least assisting) in the development of some of these features.
&gt; It's like saying I don't like VSCode because VSCode extensions can't run on my computer but WebStorm extensions can so I use that instead. No it's not. It's like not liking vscode because it doesn't install your favorite extension by default and you don't want to install it manually. You can change the configs of TSLint, it's trivial and you only need to do it once and then you can copypaste it wherever you need it. &gt; Why not just use Prettier to manage code styling and let the linter do the actual important stuff? Yes, why don't you? I can't answer this question for you. It's quite funny you linked that article, because it's telling you exactly what I've been saying the whole time: &gt; Here‚Äôs what I suggest you to do on Monday. Gather your team for half an hour, go through every lint rule enabled in your project‚Äôs config, and ask yourself: ‚ÄúHas this rule ever helped us catch a bug?‚Äù If not, turn it off.
Yes, also you could be using the refactored function 700 times, but only 7 times to use the return value. TS will save you from having to look all the 700 times, and you'll just have to look at the 7 ones.
Then you should be using either openapi or graphql to build your response body. Our APIs support both graphql as well as openapi (swagger). All incoming request bodies are filtered by one or the other library respectively and anything in the response that doesn‚Äôt meet the response object spec will be removed (or throw a 500 error depending). I am a firm believer at having types at the edge of my application. Anything that can go in or out of my API needs to conform to a spec. What I don‚Äôt believe in is needing to build a new type every time I want to pass some assortment of the current finctions data to a new function. Typescript does not fix any problems that I have right now.
Having a good ESlint setup goes a long way too. We don‚Äôt use TS or flow much at my company, but most basic issues are caught in people‚Äôs editor before even saving the file.
Looks like TSLint is going away anyways. LOL. &gt;**TSLint will be deprecated some time in 2019**. See this issue for more details: [Roadmap: TSLint ‚Üí ESLint](https://github.com/palantir/tslint/issues/4534). &gt; &gt;[https://github.com/palantir/tslint/blob/master/README.md](https://github.com/palantir/tslint/blob/master/README.md)
What is Microsoft‚Äôs telemetry?
Well, now your imaginary problem is gone then. Do you like typescript now?
No, but I'll give it another shot.
You don't have to type out everything. If your function returns an object like: `{ status: 1, data: 'hello' } // notice the already assigned values` will correctly infer that this function will return an object of type `{status: string, data: text} // notice the type inferences`. So you don't have to type *anything* to gleam what kind of `someobj` is if `const someobj = theFuncIWasTalkingAbout()`.
I tried to use this approach after reading Eric Elliot‚Äôs _The Typescript Tax_ Long story short: jsdoc‚Äôs total lack of support for generics made it unusable on anything more complicated than a utility library.
I'd note that Flow catches this issue as does ReasonML. https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVUCuA7AxgFwEs5swBbAUwGcqBVABwBUALCgQQCcOBDATwApuXAFxhOPXgB4q+DoWwBzMAB8w2TGQBGFDgD4AlKIBucQgBMwAb1RhbYIRwB09TFWb8AzPoDcqAL7ouCQyYDJyilSi4nzSsvIKumAAvGAA2gDkUHBw6QA0YOmaQukAur6UNAws7Fx8-GHxVD6Bwfihog2KyaFxEakATGWoQdhUcDAUjvAK9Y74cAAyiDoAwtxUFPz6+qhAA
I've toyed around with this recently ‚Äî check out wasm-bindgen (along with js-sys and web-sys). That provides complete wasm bindings to _any_ ECMAScript or browser API. It generates the glue code for you, as well. It's still a bit rough around the edges, but gloo is in the making ‚Äî it hasn't even reached a 0.1 release yet! That's going to be a significant wrapper around wasm-bindgen, which should make things _far_ easier to work with.
Since TypeScript is a superset of JavaScript, it frankly is not much a lift to learn. There are a few extra bits of syntax. Otherwise, you are just using JS.
Regarding async, the OCaml language itself has recently gained a powerful generalized 'binding' syntax that can be used for async operations. I have proposed in BuckleScript (ReasonML's JavaScript compiler backend) that they backport it, similarly to how the OCaml native tooling is: https://github.com/BuckleScript/bucklescript/issues/1326 If that were done it would look like this: let getUserFriends(userId) = { let* user = UserService.get(userId); let* friends = List.map(UserService.get(_), user.friendIds); Js.Promise.resolve((user, friends)); }; In ES6 today it would look like this: async function getUserFriends(userId) { await user = UserService.get(userId); await friends = user.friendIds.map(friendId =&gt; UserService.get(friendId)); return {user, friends}; }
This is the reason (albeit a few years out of date, but you'll get the idea): [https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f](https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f) &amp;#x200B; Who knows where TypeScript will be in 5 years? &amp;#x200B; Vanilla JavaScript will remain workable.
I use Typescript wherever I can, and it works great with VSCode for faster debugging. But on the frontend, I find it difficult if I use a framework like Polymer. Both TS and Polymer have build steps, and I've had trouble trying to do both at the same time, especially when I'm also trying to serve the code from a local instance for debugging.
Name could be more relevant.
How big is your code base? ts-morph is great for parsing TS ASTs for large scale migrations.
&gt; ts-morph Nice! Thanks about that! We've already completed the migration!
JSDoc can update as you work; not really an argument there to be had. You just check in the latest documentation with your PR.
Keep it in mind for the next one :)
I don't know how. ( Õ°¬∞ Õú ñ Õ°¬∞)
Most JavaScript use cases rely heavily on I/O like API calls. What good is a static type system when all my objects have to be validated anyway? The one thing worse than not having a static type system is having an inaccurate type system, such as every time TypeScript inaccurately and silently converts `any` to my API response type. (ok I actually do use TypeScript and just started solving this problem with https://www.npmjs.com/package/json-schema-to-typescript and possible soon Swagger)
Cuz i dont write enough frontend js. But srsly, last time i dove into that world hard i was dismayed by the transpilation times. Even w/o adding typescript on top. The only language that didnt make me wanna pull my hair out (re transpile times) was elm. Ecmascript5 for this guy.
You should adopt immutability in your style guide. Rules out this problem (and others) entirely.
Hey, I‚Äôm the author of the tool. Here is the example of how to create ToDo app with FullCalendar: https://github.com/ipselon/prime_faces_react_todo_sample You may go through the building instruction to feel if this can be helpful for you.
Do you use anything to minifiy your code? Run eslint?
Thanks! I‚Äôll give it a try when I get the time
dat spread operator tho. Cannot live without it now. You say you like functional programming, but without easily creating immutable types using spread to copy on write, you are missing out my friend.
You can use `@template` for generics like [this](https://github.com/clshortfuse/materialdesignweb/blob/master/adapters/dom/index.js). And VSCode can read typescript specific syntax despite it not being valid jsdoc. So you can use stuff like `keyof` and `Extract&lt;T&gt;`.
Yeah, I feel the same when hear ‚Äúvisual builder‚Äù. But in this case it‚Äôs worth to try - drag and drop is not so important here. The drawing of a data flow makes the magic - there is the same flexibility as you write code, but much faster and understandable for others. Cheers.
True, but from the looks of it, the change was probably needed. Backward compatibility would be infeasible with the direction they are trying to go.
Because I‚Äôve never really run into any of the problems it supposedly solves, and I like to keep my build process and dependencies as lean as possible.
Gotcha. I definitely agree that those tools help, just wanted to note how tooling gets better with strong types. I also don't necessarily believe TS is "better" than JS. You can get very far in JS with project and team level discipline, good tests, and strong code review.
Flow works great, for one. It provides a lot of the same tooling. But lately I‚Äôve been loving PureScript, which expands the definition of ‚Äútypes‚Äù to mean broader categories like compatible function signatures, but obviously it‚Äôs a functional language, so it‚Äôs not for everyone I suppose.
\- Transpiler speed is a transgression on mankind. Code, f5, check, repeat,... very fast. Code, compile, wait, f5, check, repeat,... feels tedious by comparison. In complex project I have enough time to come to reddit, and we all know what happens when you come to reddit. \- Adding types back is going backwards in programming history. I am typing this as I am taking a break from a uint8 signature converted to a uint32 signature bug in a streaming API, and I just two months of work ethic because types are actual bullshit when they are not the point of what you are doing at the moment. \- Writing types before your system is fully flushed out is painful. Writting types after your system is fully flushed out and one guy want "a simple change, to add a few dozen features", is a nightmare. More time is spent pleasing the language than actual coding. \- Type problems are idiot developer problems, you cant redefine a type or miss use it in most other language, why would you try to do that here. \- All the stuff I've said about types, when I think they ARE a good idea for tracking down a bug. **I can enable it for that single occasion, and not have to use it all the time. JSDocs is enough.** \- Decorators, just like why? I already do not like classes. &amp;#x200B; I love types, for a completed project you have to hand off to others to interface with it is godly but they are really just cruffy documentation and linting. Then the type system is 100% tight when interfacing with "not so perfect" code and it just defeats the whole purpose of the thing.
It is a combination of Modulus, the operator it uses to display data, and Model, which it what it does to the data. Modulus Model Modol.
also I want to add that in JS you do not have method overloading, in TS you do not have it either, but since TS is introducing types, it should support overloading, otherwise I am getting behavior which I am not expecting, there might be other similar things for which I am not ready to invest my time in for the little benefits it provides.
FYI you can use Typescript without transpiling by writing your type annotations with JSDoc. It's kind of annoying but I had a co-worker who insisted on no transpiling and it was a compromise we landed on.
because it was written to help .net developers who didn't know javascript write javascript. and then half the stuff got put into javascript anyway. Since i'm not a 2011 .net developer i'll just stick with javascript.
What language would you like to use instead?
If you following good programming practices and design, you probably don't need TS. I use it for new projects partly because it future proofs against bad development practices creeping into the code base. I also feel additional layers of error management through TS saves developer time in the long run, which is an expensive resource.
If you're on babel 7, you can just add `preset-typescript` and not have to add an extra build step
You don't have to learn anything to use TypeScript, its just JavaScript with an optional type system. Often, TypeScript will just infer types and that should be good enough. However, TypeScript is very important for libraries because without types you'd need to check the docs anytime you used any function you can't remember the exact shape it has. Note: you don't need TypeScript to get the advantage of types, there are other options but TypeScript is a very good one.
Do you bundle, minify, lint, etc? I feel like if you're doing those things (which I think most people are), then adding an extra transpilation step shouldn't be that much more work
I view mocking as something of a last resort, rather than the default. By integrating as many modules/components as possible, tests will provide much more coverage and confidence. Mocking provides a couple of key benefits however: - Predictability. When working with external dependencies you require predictability around data which could change. Files, databases, APIs, config, time, are all good candidates for mocking. - Simplicity. By mocking out larger modules you may be able to reduce complexity of a test, and therefore reduce the time required to implement it.
I use ES5 because it is supported on the most platforms of any programming language, ever. I don't like transpilation of any kind because line numbers get all wonky, sourcemaps are NEVER fully configured in every possible place, and the debugger is sacrosanct the way I write code.
Processes are annoying, I like to spend my time writing code.
And your IDE should complain if they *are* out of date.
It's not just type errors. I have consistently found that refactoring/maintaining code with Typescript is much much easier, because it finds all the spots that I may have missed. Then when all the types check out again, I'm a lot more confident the change will work.
Because it's a Microsoft product. Really.
I feel most of my syntax errors are caught with my eslint setup.
I started .net only a couple years ago....
typescript isn't for syntax errors.
If you don't write any type definitions, but your file is .ts instead of .js (or you run it through tsc or whatever), it is still more type-safe than normal JS. It will not be as safe as if you wrote out all the declarations, but it will still be safer than normal JS
Because i like Javascript lol.
I've never found a library that doesn't have type definitions, or there wasn't an alternative that did
Seems like more work to add "any" to everything, and generally just needing to focus on type handling along the way.
So profile the backend and see where all that time is consumed. It should take a in the order of tens of milliseconds for the network request.
Nailed it. Such cleanness.
Your mention of PHP doesn't really work, since PHP 7 added typehints, most all of the community is for using them. There was a video once that suggested removing types to get rid of visual clutter and the entire community was outraged at even the thought of removing typehints
Hi /u/N8Programs, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
My company (Fortune 100 company) doesn‚Äôt use it, so I haven‚Äôt bothered to learn it.
I did C# and other MS stuff for several years before I switched to JS. TypeScript seems mainly to serve Microsoft more than anything. Its a lot of extra work in order to make Intellisense compatible with JavaScript. You are shoehorning types into a language not designed for them. So you lose the advantages of not being typed such as not needing to look at types in your cod and the flexibility of dynamic languages. Not having types can be a disadvantage also but TS means giving up any advantages. It is the sort of thing you would make if your ultimate goal was just to get everyone to use C#.
Typescript makes things refactorable. This is important to me when I'm designing a new api.
I use Typescript compiler in Standard ES7 with JSDocs to give myself code hints and type verification during development time. But i refuse to migrate from ES7 to TS because i prefer the portability of editing source without compilation. I also prefer having simplified typing. JSDoc itself is quite enough and quite cool. I can define template functions that take in Set&lt;T&gt; and output T[]. I can specify the input is an Union of (array, null, and undefined), and let TS flag up downstream operations if i tried to do array operations without doing a null check.
That's because you don't want any in everything, so you don't need to add it to everything. Typescript will save you work, proper intellisense alone is a great reason to use it. Just because you'll need a few characters more doesn't mean that it's more work, because by that logic one of the code golfing languages would be the lamguage that requires "least work".
I feel like this is the truest example of reality when it comes to something like TypeScript. Definitely agree.
Frankly I see the value of TypeScript but feel like it massively clutters the syntax and makes things generally less readable and shareable, especially for someone who doesn‚Äôt have intimate knowledge of typescript‚Äôs syntax. It bothers me when popular open source libraries switch over to typescript because there are still a lot of people, myself included, who don‚Äôt fully know the syntax. I just finished switching everything from coffeescript to ES6 a couple years ago, now I‚Äôm supposed to switch everything over again to typescript when ES6 is working just fine? I recognize that typescript has some nice tooling and makes things easier for large teams and large codebases, but right now I‚Äôm working on a solo project and have no need for it. It also adds extra onboarding overhead if I decided to bring someone else onto this project that doesn‚Äôt know typescript.
Hi /u/N8Programs, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
For me typing is just a bad habit trying to resurface. Typing is just a way of telling a static language the amount of memory a variable needs to use, so the compiler can sort things out at compile time. Basically, we are saying to the compiler, please reserve 2 memory boxes for my int, 4 memory boxes for a long, a random amount of memory for a string but you can no longer cast thing straightforwardly, you have to do all sort of gymnastics to be able to do a simple conversion. Yep, a string won't fit in a two memory box. You make your code more verbose and blur out the algorithmic behind some weird declarations. It does not make any sense to bring issues coming from the static world to the dynamic one. TypeScript has a cost. You‚Äôre losing flexibility, you‚Äôre coding in C# (same author btw) losing the power JavaScript gives you, You‚Äôre adding an extra build step. You‚Äôre coding much slower because you have to focus on other things than your algorithm. It's like people don't remember the pain we have in using all these static types in compiled languages.
Getting your code working is the best first step. Needing to supplement it with extra code along the way just creates artificial work.
Swagger is nice. Having a filter like that is interesting. My codebases have far more code than just at the boundaries where it is interacting with other services. The business logic gets typed. That goes for both backend and frontend.
Because I'm not the only person on my team and I can't dictate that we use something no one's familiar with.
C# for me. Don't know about OP.
LOL
That's my point. You won't see that stuff at compile time but you will at run time. Which, is the worst time to hit it. If you can sort it out before the code ever even runs, that's a code quality improvement in your shipped code.
Model. Modal. Modol. The first two can be confusing enough without a 3rd word to make it more "blurry" ;) That being said, cool little piece functionality! I've done something similar for human readable dates/durations.
&gt; For me typing is just a bad habit trying to resurface if this were true, we wouldn't have new languages like Rust taking off
I don't use typescript because prop types is good enough for our purposes.
We use libraries like redux to write optimal code enforcing data as a single source of truth and immutability for a functional language like Javascript. Using more advance patterns like hocs and pure functions to separate the view from business logic helps eliminate bugs. Other redux middleware like saga helps with async bugs that are bound to happen. Prop-types along with rigid user testing standards makes typescript seems overkill.
It‚Äôs not something you can really sort out before runtime.
Love this, haha. Thx for sharing
i use typescript for backend but not frontend. Why? i don't know, haven't really tried to get it to work with my vue/vuetify and vue-cli stack.
When Angular broke everything from v1 to v2, many migrated to other frameworks (or stuck to v1). I agree it‚Äôs much better, but they are taking a big chance. They are breaking all apps AND all existing ecosystem. I‚Äôm just worried about all the work I‚Äôll have to do to migrate my own code...
Unit + Exchange = Unix I will gladly accept bitcoin for my contribution
I don't need to. With ESLint and type annotations in VSCode I've never found a real reason to use TS.
Not sure. Or sure that an existing language would be appropriate. JSON should be a first class structure, IMHO. I‚Äôd like to see what the original scheme looked like. But I‚Äôd also probably want something static.
In term of popularity, Rust is far from being significant. On the other hand, JavaScript, Python even Php and Ruby are hugely popular. I have nothing against types, but they're here for a reason. To give a compiler enough information for it to be able to generate some code machine. With time, we‚Äôve sugar coated the whole thing.
I work on a React app team that's trying to switch to TypeScript, and I'm not liking it much at all. Problems specifically with React + Typescript: * Slower compile times * Higher order functions are a pain in the ass to write * It takes a LONG time to convert existing apps, and the fact that you have to start from the bottom of the component tree and work your way up is annoying af * LONG type errors that are really hard to read. * Types that are really hard to understand if you don't know how the packages you're depending on work (specifically with smaller libraries). * Arrow functions just aren't fun anymore. * Just seems to make components twice as large as they should be. The main things I need it for can be done with PropTypes, and that's a lot less difficult to setup and understand. * Errors are unhelpful a lot of the time and just turn me off to the language. * Some of the types are really hard to track down and get right (a lot of the developers on my project agree), resulting in a lot of \`type: any\` hacks. Problems with Node + TypeScript: * Package ecosystem is just not there (the types for cli frameworks are particularly terrible). * Not many others besides just knowing how to set it up. Still wouldn't use it though as the package problem is a major blocker to me. Typescript just slows me down tbh. I don't have a lot of type-related errors, so the costs of rewriting an entire app just to have a compiler scream at me just really doesn't appeal to me. In the apps that I have worked with, most of the problems that I've had have been the result of changing standards and shitty programmers not understanding how to write better code. That's not something that throwing Typescript at an app will fix. It might be great for some larger teams, but for smaller teams it's a pain in the ass for not much of any reason at all.
The only reason why I would use typescript would be for type security stuff. However vscode has that type checking built in any way, so I mostly just pass on using typescript. Here is my opinion on typescript. I think typescript has been mostly been adopted by those people coming from a computer engineering background that are trying to get into web programming. It seems to me that those people can't really handle the awkwardness of JavaScript. And I don't blame them, it is weird. I started out doing web programming, so all the weird stuff with JavaScript is fine by me and I just sort of deal with it. Now, I am also trying to get into computer programming with Rust Lang, in order to start using web assembly. With my web program background, I even still love using Rust! It's great.
JSON? What do you mean by that?
&gt; Its signature changes slightly (e.g. you now return 2 things instead of 1 Then that function is doing more than one thing and violating software engineering/clean code principles.
Right, I mean, you could lock in your current major version, and just maintain the app as it is. Migration is a choice, but I definitely feel your pain if you decide to go that route. But it won‚Äôt be breaking apps as long as they don‚Äôt migrate, right? The ecosystem, on the other hand, will suffer, as you said.
Ain't nothin' but a heartache..?
Doesn‚Äôt look like they will keep maintaining version 2 however? So we‚Äôre essentially stuck, either we upgrade or we stick to unmaintained code.
Yeah, maybe I should have named it Modolu or something like that. Ambiguous names probably aren't a good idea.
&gt; I'd argue the opposite, and say that using Javascript without types adds a lot of overhead, because you need to lookup what each function returns, or just try it, and see what it returns, which is much slower than the compiler / tooling telling you what it is before you use it. The problem is, at least in my experience, the compiler/tooling hasn't done a good job of doing this for me. I'm using Webstorm, which I think has decent Typescript integration, but the errors are still generally unhelpful to me. I tried writing a CLI with Typescript using `inquirer` and just couldn't wrap my head around what the errors were trying to tell me (specifically having trouble with getting the type of the thing resolved in the promise). Eventually I just gave up and went back to writing it in plain js. Having a compiler scream at me about types that I don't understand without providing me with useful information is not good DX and isn't appealing to me. It's quicker for me to hunt down the documentation to a function than to spend thirty minutes debugging one type.
Right. It sucks to deal with that. The main concern would be potential undiscovered security vulnerabilities, but bugs would certainly be a pain.
TypeScript looks a lot like C# (same author - Anders Hejlsberg)
This is a great argument. I feel like for me, Typescript violates DRY and makes things unnecessarily verbose, plus the compiler is generally unhelpful. Just makes me want to go back to working in plain js.
Sounds like a common theme. Our JS developers are very resistant to learning Java and are even pushing to use Node for the backend.
This is really interesting. You've inspired me to finally look into typescript.
I would recommend using a swagger based approach and serving the swagger file with an interactive page to test the api on a dedicated route. Docs are really old school with things like swagger and graphql providing great interactive experiences.
Exactly
Human + Readable + Units = Hudabits üòÇ
By mocking a module, you are codifying into a test that a specific internal dependency exists and is used in a specific way. If you refactor your implementation and remove the dependency (or swap in a different dependency, or refactor to use a new major version's API, etc), now your tests are going to be broken because of that codified assumption of how the internals were supposed to be coded. A good test tests semantics, a bad test tests implementation details.
That's interesting. I def agree that errors could be more useful, and the type errors could be more concise. What's even more interesting is that I've also done a CLI recently with inquirer and oclif, using typescript: https://github.com/developertown/react-cli/tree/master/packages/react-cli idk if I'm just used to the types or not though. But I found that I don't need to reference documentation that much, cause I can lean on the type errors to help me out.
&gt; JavaScript, Python even Php and Ruby are hugely popular. These languages of decades of history on Rust though.
I only mock imports (usually with [proxyquire](https://github.com/thlorenz/proxyquire)) that cause side-effects. No need to mock pure functions.
right, but you have to wait till runtime to encounter those errors
We do when pushing to prod, but not during development.
We only do that when pushing to prod, not during development.
This is too unnatural: https://cljs.github.io/api/cljs.core/js-GTclj
Why doesn‚Äôt your IDE do that for you?
Wow, pretty funny abbreviations.
yep, and 10 seconds later it's fixed. whoa! such savings! only need about 100 more of those before writing one type definition becomes a net positive.
But what should it do if they are out of date? One idea could be to scan and produce some form of warning or error to display to the user that they should correct the out of date documentation before continuing, otherwise they may forget and people who are relying on the old documentation would now have failing code. Congrats you just re-invented static typing ala typescript.
Sure, but it's hybrid typing isn't as useful, and it wouldn't perform near as well as compiled webassembly.
If you change the type of a function, your IDE can't tell you all the downstream effects. It can only point you to all the usages of that function, at best.
I'm not following, doesn't this just mean that you are dropping down to js-level typing in cases like that? Partial TS usage is still better than nothing at all. I don't get how this is a reason to not use it.
Try changing your app's code to: ``` &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Javascript&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var words = "Hello"; var moreWords = " world!"; var sentence = words + moreWords; document.write(sentence); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ``` It was mainly formatting issues that were giving your code bugs. Just so you know, Javascript Help questions should go on r/learnjavascript.
You don't have a closing head tag, and you have 2 closing html tags. You should just have one at the end. If you fix these up does it help?
I use it with frameworks that push it, like Angular 2+. But I hesitate to use it with things like server side Node as I may run into issues where I want to use a package that does not have TS typings. I understand there are projects like NestJS, but the are in too early of a stage and underutilized at this time.
Only during development due to typos, brain farts, etc.
A complaining IDE isn't a developer fixing it.
Intellisense won't tell me what a internal API is returning if it's not already set up to somehow (flow etc).
I'm just waiting for Blazor so I can ditch 90% of JS.
The important stuff like, you know, types didn't get put into JS.
A lot of people seem to think that Web Assembly is going to help them avoid JavaScript but, I am not sure about this. I think JavaScript is the best implementation of a language for browser oriented app . It‚Äôs been around for more than 20 years, always constantly evolving It is designed to work with CSS, Json and HTML It is designed to work with all sort of async extensive operations Its closure feature is impressive It is already the fastest dynamic language. I doubt, i‚Äôm not sure, web assembly will make things faster for other languages without increasing performances for JavaScript I bet if you put some inline whatever language in the HTML code, you would see some web assembly code for a while (just a supposition) Node is booming and pretty damn amazing, slowing down the adoption of using different languages on the client side. You won't have .Net on the client side straight away
&gt; Documentation easily falls out of date. Especially, if you aren't using JavaDoc style or something where it is right inline with the code, but even still. A function gets refactored, arguments are changed, and docs are missed. This is my favorite thing about strong, static-typing: self-documenting code.
I'm starting to use TypeScript and the community support around the tooling for it is abysmal. I'd rather write something in plain JS for its better integration for simple NPM packages that simply don't (and can't) have an `@types/&lt;npm&gt;` package yet. My working code has an `// @ts-ignore` almost every other line because it can't handle currying and function composition from libraries like `ramda` or `lodash/fp` and it's making me question why TypeScript is useful for the projects in the first place - the code ends up looking like vanila ES6 anyway.
Because in this case, only partially using TypeScript gives the illusion that everything is typed. You would have to discern that the function is or isn't written in TypeScript, which is hard because you need to write valid TypeScript to begin with (even if you use the `any` type) otherwise it won't run. So this kind of code will camouflage in the background while you're thinking of more important things. Good JS code would have made explicit checks for unknown data because you're 100% guaranteed that the types are dynamic, good TS code would have error'd if the types don't match. But partial TS application gets the worst of both worlds - you don't know when a type is supposed to be trusted. You'd have to fall back to full ES6 anyway. In my view, it has to be either 100% TS or no TS at all. Trying to strike a middle ground is just asking for trouble.
I don't think CoffeeScript is a good yardstick in which to measure all compile to JS languages, least not TypeScript. CoffeeScript was clearly an attempt to layer a more Ruby-esk syntax over JavaScript, but outside of that, it didn't really yield any benefit other than syntax. (Perhaps it helped Rails developers work across codebases) &amp;#x200B; Given that TypeScript makes every attempt to align syntactically with the underlying language (almost verbatim), provides optional static typing (where appropriate) and has an immense wealth of tools around it, I don't you think can really compare CoffeeScript to TypeScript other than they are both transpilers. Their goals are very different. &amp;#x200B; And I mean, in terms of transpilers, most JavaScript programmers are already on Babel anyway, so the transpiler step is already present in many codebases, you might as well opt for one that provides optional static typing. &amp;#x200B; Should maybe note, Babel supports TypeScript nowadays, however i found working through the Babel pipelines to be fairly horrific (layers upon layers), the option is there.
Actually, I realize removing the &lt;canvas&gt; would stop it from centering my text. My question was, why does it do this, and how can i manipulate position in other ways?
Don't know much about it
Well personally, TypeScript has caused me more work than it has saved me. If they add some actually useful features I might consider it but I highly doubt they'll ever do so. ESLint does a \*\*much\*\* better job than TypeScript does at providing quick feedback on simple mistakes and errors. And the strict typing seems blatantly ignorant of what JavaScript was meant to be. If you want a stricter syntax go to Rust or C++ (I would never curse anyone to use Java). Rust isn't that much harder than JavaScript and C++ has the best performance of the three.
JSDoc types are more verbose and can be more awkward to write than TypeScript code. If you're getting value from JSDoc types then TypeScript is much easier in the long run.
The syntax looks strange. Like some kind of MS ecosystem thing.
How do you use npm libraries in dev?
Literally was using the exact same setup for mine! Just couldn't figure out how to get the right interface type for the resolved promise, and the compiler honestly did nothing but piss me off. I tried switching over to vs code to see if the hints helped any more (they didn't), and ended up just switching back to vanilla js because it just wasn't worth the pain. I think to people experienced in typescript, the type errors can be great, but for anyone unfamiliar with the language it's just absolutely fucking awful to deal with.
I don‚Äôt.
Perhaps, but what prevents the implementer from just doing some dynamic type checking, in the relatively infrequent case that he has to rely on a library without type definitions, and using Typescript type checking in every other case? It‚Äôs not *that* hard to do, and the 90% of the code that‚Äôs not dynamically typed will offer better readability and type safety. It still has utility.
It's often hard to understand the benefits of something until you've experienced them yourself. Similarly, I remember back in about 2003 telling my boss "we don't need OOP for what we do"... when it reality it was just that I wasn't experienced enough to judge whether it was worth learning or not. &gt; seems to work just fine for us. Editplus 2 worked fine for me for a long time too, until I used better IDEs. Hope I'm not coming across smarmy or anything. I just know that I've held similar opinions about various things I haven't learnt yet. Right now I'm slowing coming to the realisation that maybe Docker can be more useful that I initially thought it would be. Haven't got to the point of learning it yet, but I'm less opinionated about it "not being needed" than I used to be. One way to judge whether one thing can be better than something else is to read and many "we changed from x to y" stories as you can. As well as "we changed from x to y" then back x" stories. Some examples of the amounts of stories I've personally come across, and often ended up agreeing with... * SQL -&gt; NoSQL ... plenty of stories of going back to SQL * MySQL -&gt; Postgres ... rarely people going back to MySQL for any medium-large projects at least * JS -&gt; Typescript ... rare that anyone that learns TypeScript goes back Also I think TypeScript isn't given enough credit, because a lot of what you read is just about it "adding types", but it actually does much more than this: * in terms of reporting code problems (even unrelated to types) * makes your intellisense/autocomplete IDE functionality much better - it was practically useless (too many irrelevant results) on plain JS in phpstorm at least before I added TypeScript * Warns you about many problems before you even execute your code * Refactoring is a bajillion times easier - not only because automatic refactoring functionality works better, but for all the parts that get missed, you usually get a bunch of typescript warnings about the remaining stuff you need to refactor manually * Also don't only think about how often/rarely you currently do refactoring... because when it works better, you'll be able to do it much more than you used to. I would rarely refactor JS/PHP, because too many things can break, and you won't find out until you run your code... maybe in production. Whereas TypeScript makes it super easy.
Finally a comment based on facts an not guts or opinions
I've never understood these points? What do you mean by "not using typescript?" as is actually manually editing code in .js files, or just not using all of it's functionality all of the time in your .ts files? Neither really make sense to me. All my code is written in .ts files, and I typehint most of the time, but why does it matter if your type hinting is below 100%? I don't see how 0% is better than 1-99%.
The biggest problem I've encountered is typescript library types being different than my compile time types, making it impossible to run the code without manually changing the library code. I'm sure there is a way around this problem, but spending hours debugging the engine that runs my code is not something I have the resources to deal with, especially because if I opt out of typescript everything runs smoothly. &amp;#x200B; My current velocity in the javascript ecosystem is incredibly fast, typescript forces me to slow down, this could be beneficial in some cases, but it is not beneficial in mine.
Because it doesn't solve for an unmet need. Adopting TS when there isn't a use case for it doesn't make sense for the engineering teams nor the business.
How is that an argument to not use typescript at all? You're saying you like intellisense and error checking, but you've chosen to use it 0% of the time, instead of 1-99% of the time. How is 0% better?
This is right. Mocking can be super valuable, but don't get "mock happy". Mocking a little is ok, usually to shortcut side effects that you don't want to test. Mock your API calls all you want. But mocking can decrease the value of your test suite, because you're no longer testing the interactions between modules.
This is false. VS Code will tell you all of the downstream effects. This is *the point* of a type system / linter.
Happy Cake Day SgtDirtyMike! To a person that‚Äôs charming, talented, and witty, and reminds me a lot of myself.
Well it basically is a kind of linter, but with even more OPTIONAL features. It does a lot of checks that have nothing to do with types. And makes refactoring a million times easier.
Good point , in our last two apps we had one single bug caused by expecting the `substr()` method on a number id, which we had incorrectly left as a number in the api translation layer- otherwise the biggest issues we've had were runtime null/undefined errors or react native android behaviors that didn't show up in our ios-heavy development cycle.
It tries to, but the refactoring functionality in your IDE works a fuckton better when it knows what things are.
What are you talking about? I'm referring to non-Typescript users. If you're not using a type system, then your IDE can't tell you about the downstream effects of e.g. changing a function's return type.
Learn how node callbacks work. If you‚Äôve been in react with a sync and await node at its core has asynchronous functions that are dependent on callbacks that you need to wrap regardless. As much as I love typescript node is much easier to work with in regular js and I recommend doing it that way. Also spending time using node devops tools or node as devops. Solving real world problems with node makes you better. Also don‚Äôt fall into the trap of making every project express and confusing express with node. Finally, make unit tests for everything.
We have a \~60kloc SPA codebase written over about 10 years, which does way too many things. We employ half a software developer, who mainly does maintenance and adds new features at the whim of our boss. In these circumstances, it's not trivial to strap a build system on. Also, users being able to open the developer console and do scripting within the app is a feature of the platform, so we're really restricted on things like name mangling.
That's assuming you'd have infrequent cases of libraries that don't have type definitions. I agree that having strong type checking is a good thing, but I don't agree that TypeScript fits the bill there yet. Also, [here's one useful package's open issue re: TS](https://github.com/origamitower/folktale/issues/65#issuecomment-273165042) that can't use TS as it is now because it doesn't fully support the kind of strong typing it needs and people have to fall back to using `any`. I'm specifically approaching this from a functional programming perspective in JS. The core libraries you'd want to use do not have TS support, and those are libraries you will be using a lot in your code. I can see that it's useful for something like a React-based setup. We use Flow and it's useful once you get the hang of it, and TypeScript is honestly not that different. But with things moving into FP, I'm struggling with the type systems, especially since the libraries I'm talking about would let you handle `any` data in a way that wouldn't crash and so functionally wouldn't need a strong type checker (though it would still be nice to have).
Hi there just curious, when you make that comment about express.. what exactly are you suggesting? Should you switch it up with different frameworks?
If you used flask in python, express in node is almost identical
It does a lot of other checking. But on the "this bug here is a typing problem" ... I would have assumed the same before using it. It's just very much more blatantly obvious that "this is a typing bug" when there's a message on your screen literally saying that. Otherwise it's much easier to not put much thought into "what technical category of bug is this"... you're normally just focusing on fixing it. Also often the bug itself might not be an immediate typing one, but all the typing checking going on further up the stack and elsewhere across the project is what helped you discover the bug sooner rather than later.
I went on a [rant](https://www.reddit.com/r/javascript/comments/bfgmn6/is_javascript_good_for_backend_development/eldoirr/?context=0) about this yesterday.
And have any of those made it to production? Those are all bugs and TS can guard against those exact things. Especially typos at its most basic utility.
To be honest, I wanted to hate it for this reason too. But it's just too good.
I'd rather that not make it out to production in the first place and throw errors on a highly critical system. In my case, a system that's running millions of dollars a day.
One of the hardest things we dealt with in the product was dealing with people who ‚Äúknow‚Äù or have opinions that are made on assumptions. Even though the product I worked on for over 3 years is still going, it‚Äôs almost impossible to overcome people‚Äôs preconceived notions. For instance it‚Äôs always interesting going into a team and telling them that the senior on their team creates the most defects because while they be the best on the team coding wise, they work on hard things that they aren‚Äôt skilled enough to do at a high quality. The most startling thing I saw was just how many teams don‚Äôt do even the most basic amounts of testing. I can‚Äôt go super into detail because of my employer but the vast majority of what I hear around defects and the causes are garbage.
Express is simply an easier way. It's definitely worth knowing how to do things without express
Because JSDoc and the odd `.d.ts` definition file gets me halfway there without having to buy in fully (though I must admit this method has its own set of pain points).
Absolutely you can. const obj = { foo: 'test', bar: 123, buzz: 'buzzbuzz' } function doStuff({ fooBar, buzz }) { console.log(fooBar); console.log(fooBar.moreDataThatIThoughtWouldBeHere); } doStuff(obj); Type script should show that fooBar is undefined. And if `fooBar` was a string, it would error for `moreDataThatIThoughtWouldBeThere`. Easy to make a mistake when an object gets mutated somewhere as things get passed around by reference and all of the sudden something is or isn't there that you didn't expect because something far away changed it.
Yes, especially because the core ways include things like making HTTP/HTTPS requests or setting up TLS without an external dependency.
It's an extra build step that can cause trouble if I want to bring in other libraries that don't have readily available TS definition files. &amp;#x200B; But if I'm working on a large project in an environment that supports TS, I like to use it. I actually prefer a more statically typed language, and I think TS is in a good spot between Java and JavaScript when it comes to that.
That‚Äôs awesome to know. I couldn‚Äôt find any info on how to make a generic type of use a generic type. React-redux + jsdoc taught me to just use TS.
While Svelte 3 components might 40% smaller than React's, I'd bet anything I can't set a break point on a Svelte template and get a debuggable context.
don't you need a &lt;/canvas&gt; for both of them?
And I‚Äôm not talking about that. I‚Äôm talking about responses from APIs and such at runtime that you dont have control over and don‚Äôt have TypeScript for. Those are where 90% of issues arise.
I'm glad. You have nothing to lose, go for it!
Hi glad, I'm dad!
I added it, but i don't see any difference. I don't understand why canvas centers my text. What can i do to slide it to the right?
Get a grib on reality dude. Programming language arguments are pointless. Asking a community why they don't use another community language of choose is like posting in r/english why they don't speak r/spanish
Definitely a TS one too
It has implicit typing and the ability to opt out of typing with "any". Granted, you should avoid using "any" but it's there as a last ditch effort when you're having trouble matching types.
&gt; In a well tested project \+ regular code reviews
Have you tried multiple browsers?
Types are never a cause of bugs, or haven‚Äôt been in any projects I‚Äôve worked on. Why add the complication? An argument could be made for server side Node.js and typings for direct references to database tables (essentially ActiveRecord or Entity Framework) but I honestly believe it is completely pointless client side unless ALL backend calls are equally typed (which will hardly ever be the case). Even if that were the case, maintaining contracts between client and server side code would be an absolute pain without loose typing and if we‚Äôre there,again, pointless. JS is wonderful just the way it is, beautiful chaos with a strong following and extremely helpful tooling. Why spoil the party with something that in the end adds so little?
Ctrl+r, ctrl+r
Apathy... just another thing to learn, add to your workflow, add to your CI pipeline, get your team members on board with + have the them time to learn as well, etc etc. When it really boils down to it, I wonder to myself what the long term benefit is by abstracting myself from vanilla JavaScript. We, as a community, already complain about libraries like jQuery abstracting vanilla JS away. TK takes it to another level and wouldn't it be better worth my while at spending as much time programming in JS and practicing my skills there than spending time on an abstraction layer?
Anyone on here who has used Typescript extensively and stopped? I've used both vanilla JS and TS, and taught both in both small and large projects. I'd never go back to a dynamic language. TS is too easy to use to ignore. I've also never met anyone who has made the switch to Typescript switch back. You can down vote me all you want, but dynamic languages are amazing for speed of development and as soon as large scale refactoring or maintenance comes into play it's pretty much essential to have typing if you want to be successful. At least in a short amount of time. My vanilla JS refactors we're a nightmare on moderately large projects, event with lots and lots of tests. It's just too hard to discover and remember the shape of parameters and returns, let alone variables you instantiate. Especially with object spreading. The best worst feature ever. So terse yet so hard to follow in any call stack.
Personally, I‚Äôve seen a lot of benefits from attempting to replicate basic, naive versions of what frameworks are doing under the hood. For one, you become a more knowledgeable programmer, and that knowledge carries over to any framework you might come across. It is then trivial to ‚Äúlearn a new framework,‚Äù because the underlying language (in this case JS), is well-understood. And you begin to see the specific problems that are being solved, at a fairly low level, which helps you understand why you might want to use a specific framework in the first place, not just because it‚Äôs cool and simple, but because you‚Äôre matching specific solutions to specific problems. All a framework is doing is a relatively simple task in a robust, structured way, while accounting for edge cases you might not think about. But there‚Äôs no reason you could not do that yourself. The real problem is not solving the problem in the first place, it‚Äôs avoiding all the pitfalls along the way. It‚Äôs nice to know when the pitfalls are truly negligible, and you can avoid bundling tons of extra code (that isn‚Äôt yours) when you don‚Äôt need it.
who said you'd put that in prod? don't you test your code?
TS has DefinitelyTyped, which has the majority of frontend libs available. The \`@types\` system is far better than anything Flow has to offer.
Not saying Flow is better, but that even popular libraries like react-spring don't have TS definitions in DefinitelyTyped or elsewhere. I'm sure this'll get better over time though
The biggest thing that would be unexpected coming from python is the whole single threaded thing. But that should be familiar coming from browser JavaScript. Just make sure to never use sync functions and it will pretty much feel like python
This. Also IMO in the Javascript ecosystem when you get aboard the train is only to realize it has a lot of freaking strange errors and bugs and the solucion is another new shit so the thing begins again.
react-spring is written in TS, it doesn't need DefinitelyTyped, so I'm not sure what you're getting at.
I tend to like to try things the vanialla way before using a tool or library just so I have a better idea of the pain points and why it's helpful. Man I probably wouldn't rewrite things in typescript but I'm at the point now where anything new is for sure a no brainier Intellisense and null checks alone are worth it. But I gotta transpile anyway so might as well. Plus eslint is now the default linter moving forward so no reason to mess around with tslint.
I guess my information is outdated. Looks like they rewrote it with typescirpt a couple of months ago!
It's like, 10 extra words per file. So on a smaller project it's even easier.
You add like 2 words per file
There's more than a handful of reasons to choose node over Java that have nothing to do with developers not wanting to learn something new. 1. It's Java
Well config‚Äôd linter ftw! I‚Äôve been using TS across the full stack of a relatively simple CRUD app for the last ~8 months. Feels like TS adds a lot of additional time and compilation / build complexity (especially with the serverless framework &amp; Node, that don‚Äôt even need transpiling) for little benefit. In Angular it‚Äôs not too bad but forcing everything to be TS is overkill and forcing OOP on a non-OOP language. Requirements change a lot from sprint to sprint, so the team ends out spending a large amount of time refactoring interfaces, classes and polymorphisms (and the library for sharing interfaces, types and enums across client/server) instead of building features; time that would be better spent on comprehensive tests; tests that would be easier to write without TS or the ‚Äúeverything OOP‚Äù focus (mocking is difficult with TS. Tests are easier to write for functional code). They didn‚Äôt following SOLID principles when they initially built the app, so the TS just adds bulk to the interdependent spaghetti code. The TS doesn‚Äôt really seem to stop bugs either. You still need to code defensively because you can‚Äôt be certain that an object isn‚Äôt going to be undefined, or the param passed as a string and converted via Number() won‚Äôt result in NaN. I learned to code JS in more of a functional, defensive way. Most of the bugs I come across are runtime errors from the OOP strong type backgrounded devs. It feels like they‚Äôve used TS as a crutch; as a way to avoid learning modern JS, the compiler or the cleaner, easier, more functional way of how to write it.
I forgot what it's like to write class components
He explained it as best he could, but I had to listen to it a couple times to get what he was saying. Apparently, a "cache" is just a reference to a single DOM element with a small descriptor to help with identification. So, you're absolutely right, it will "technically" increase memory-use; however, even with a huge, complex app; the caches will always be a small percentage of the size of the DOM, so it's likely that the caches will not be significant.
Because not everyone wants the OOP experience.
I'd give it another shot! In most projects I spin up, at most I'd have to write types for 1 library, and even then it's just the portion of the public API I use. You can also tell TS to just type it as `any` also.
This doesn't work with leap years does it?
Good on them for doing this.
If you use flow you must be using Babel or something similar, no?
Because my team uses Elm instead.
Take the benefits of PropTypes but make them more powerful, available everywhere and checked as you‚Äôre typing rather than at runtime. Sounds pretty cool, right? A lot of people have a bad impression of types from having worked in very verbose languages like Java. However, TS has type inference which means you‚Äôre not required to type nonsense like`String foo = ‚Äúbar‚Äù;` The type system is also very powerful. Say that you write `(foo === null) return null;` in the middle of a function - TS will infer that below that statement `foo` can no longer be null since that would‚Äôve meant an early return.
Relate to this a ton. I wasn't big on Typescript when I first got my current job for similar reasons of, "I just don't see a need for it if you write good JS to begin with." The amount of defensive coding it saves is actually pretty significant in the long run. Took many code reviews of, "You don't actually need to make this check here because Typescript," before I finally caught on and was sold.
Aside from component size, I'm curious if there is a real different in render speed on a properly optimized react app. I do wonder about what he mentioned about Hooks with the extra work from the garbage collector cleaning up so many references because it is completely functional. I also wonder when things like prepack hit their stride how react hooks will compare to something like this, it is interesting.
It is, but to me there's really only one question I realize that matter about frameworks these days. Does it use a template DSL. Pretty much anything which isn't JSX like is hard to debug and that's really all that matters most days. The rest can be optimized for; But if i can't set a break point and find out why my template doesn't work thats a show stopper.
I absolutely love TS, but I have to concede that their build/compilation errors really need to be addressed by a technical writer. There are often a very large number of words that aren't clearly explaining what the problem is. When combined with angular's "write War and Peace to the console on every error" strategy for error reporting you end up with errors of an ungodly length that somehow describe nothing at all.
Not ts problem, but flow
Java is not javascript. Choose JavaScript, it's better for the task.
 Getting the same pain points with TS and React +Redux. Finding ts more like an obstacle than a useful tool rn. The amount of `as any` we have is outrageous, but types of redux, react-redux, redux-thunk, hocs and hooks are a fucking pain. Im not seeing the benefit if you are using React. The history was different on Angular, actually helpful there. Might start migrating away from ts on React.
Did you try this at all? Because that's exactly what you get - a debuggable context.
Do you mean something else when you're talking about 'template' here? I'm considering template to be the view-specific code, and I don't remember the last time I had to debug mine in any framework.
Published [randomsac](https://www.npmjs.com/package/randomsac), [utilsac](https://www.npmjs.com/package/utilsac), [filesac](https://www.npmjs.com/package/filesac)
Congrats Svelte team! Anyone know how they're doing reactivity under the hood? I poked around quickly but there's a lot of tests with `$$invalidate`. :D
What i mean is the language a framework created to allow your html template to display information. Such as in angular an ngif or ngfor or or a let-value attror data binding etc.
Because my boss gets mad even when I use ES6
Depends on how sophisticated you expect your server side to be. &amp;#x200B; Node is very good at bootstrapping server side projects, but its hard to recommend it if you expect for your server-side to grow in complexity over time. There is a threshold that goes from manageable to unmanageable in node, with the unmanageable aspect directly proportional to the number of ways things interact with your node process. The complexity threshold is insidious and can creep up on you, and JavaScript as a language provides minimal functionality to deal with it. In general, if you suspect any complexity on the server-side, then you're better off using a typed language, ideally one with reflection and type introspection so that you can generate the parts you would otherwise need to manually author and manage yourself (particularly around server to server interactions, service contracts, JSON schemas | XSD and generally message types that are passed around). &amp;#x200B; Node can be good however, but if using it, be mindful of creeping complexity (and the things your do to try and manage it), use TypeScript (your on the server, its mission critical, use a type system) and try and leverage frameworks like [https://nestjs.com/](https://nestjs.com/) which help to manage application architecture (express is not going to help you when things scale up). &amp;#x200B; In my experience, (having worked on node systems since 2012), I'm generally of the opinion node shouldn't be used for anything other than prototyping and perhaps message forwarding in brokered systems. I feel the immediate gains you get at the beginning of a project generally give way to diminishing returns in the long term, and usually im left wishing I was using something else. &amp;#x200B; Just my thoughts anyway.
on the other hand, this breaks SOLID. you shouldn t have a reason to change the function in the first place. everything should be closed for modification/open for extension. I understand what you are saying but there are different ways to do the same thing. TS does not fix this for me.
Some of those problems you are describing are not TS related imo.
It's a discussion about `code` not a question.
We've been using Svelte for one of our really big apps and I can't recommend it for anything serious. I did some research on v3 (just to check how painful upgrade process from v2 will be) and it looks really bad. Poor documentation, no TypeScript support**^(1)**, no editor extensions, no devtools, IMHO overcomplicated store. &amp;#x200B; **^(1)** It's not just a matter of transpiling TS to JS. New Svelte syntax is "incopatible" with TypeScript and only solution to this is changing behavior of TS compiler (good luck with that).
&gt;Higher order functions are a pain in the ass to write exactly my experience, functional programming is just not good with ts
can anybody point me to a request-promise alternative?
But why have types for an app with such little data?
I have written a complete reference post about javascript arrays [https://learnersbucket.com/tutorials/array/javascript-array-complete-reference/](https://learnersbucket.com/tutorials/array/javascript-array-complete-reference/)
Great!
Yes. We use babel to smooth out browser differences; we can write es6+ without needing to worry about browser compatability.
I think he meant that is easier to bootstrap without the types.
Like most of other people, I haven't encountered any problems that typescript would be the solution to in normal javascript. I tried it multiple times, but to be perfectly honest it only adds a bit of overhead to something that can be simple, with little gain.
I think there's are three issues: You have to learn typescript, you have to write the additional code, and you have compile time before you see your code run. Obviously that third one doesn't really apply if you are already using some sort of build process which is pretty common on the front end these days, but I happen to work back end and we just run ES6 with node, and it's just about zero time between making a change and running the code. None of these are huge hurdles, but if you came into software development with Javascript as your main language, you're used to it being super fast and easy both to write and to run. I have little doubt we'd be saving work in the long run, but we haven't yet been motivated enough to overcome the hurdles.
Javascript arrays are flexible enough to provide the Queue features but you should know how to implement them completely with queue methods. Checkout [https://learnersbucket.com](https://learnersbucket.com) here i write about Data Structures and Algorithms in javascript, ES6. It may help as a beginner in implementing the DS.
I still haven't figured out how to set up webpack.
axios
Request‚Äôs creator has made R2 which might be what you‚Äôre looking for https://github.com/mikeal/r2
i love coding in js and don't see any reason I would want to code in something which transpiles to js.
I was one of the TS deniers. I said I don't need typescript. But I thought lets not try it out before dismissing it. Now I've been spending my time typing all my other projects in typescript. TS is one of the best things to happen to Javascript, its right at the top with ES6.
No idea what it is.
Can I ask which ones? Only one I think that's semi not TS related is package support but that's still a valid reason not to use TS.
Reason I ask for a static output is I use webpack on the server files and it strips out the comments, so swagger can't create json on live.
Exactly this. Between this and the longass types for React and ReactDOM, it just honestly makes me feel like I'm writing C++ again, which is NOT something I want.
&gt;hooks are a fucking pain. Hooks in general right now are a fucking pain, the errors that they give are nonspecific and unhelpful as fuck (basically "you did something wrong and we don't know what"). The errors should NOT be implemented with linting rules, as the edge cases are unpredictable and really annoying when you hit them. Just leads me to stick to classes in my newer apps. Also if you haven't yet, definitely check out `mobx-state-tree`. It's definitely a worthy alternative to Redux and has great Typescript integration (also works in vanilla JS!). Also you don't have to write longass spreads anymore, it's great.
On my last project we didn‚Äôt transpile, we just coded in es2015 and only minified when pushing to production which was about once a week. It was great. Production was rapid and seamless.
Redux specifically is uniquely awkward to statically type in my experience, but it can be done. If it's any help, [this](https://github.com/piotrwitek/react-redux-typescript-guide) is the best guide I've found.
This is a valid criticism. I believe the lack of variadic types makes typing both awkward and highly limited, though for what it's worth there's a massive issue about it open on GitHub that the devs are no doubt aware of.
Hi /u/gktrkulkr, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
That‚Äôs true, but if you‚Äôre gonna write jsdoc you might as well just write flow or ts types instead and get a little extra protection.
I love TypeScript, but like anything it has flaws. The below is terse only to try and help, not to dismiss criticism. &gt; slower compile times Look into forking the type-checker into a separate process in Webpack. &gt; Higher order functions What speciflically are you finding difficult here? Given this example: `const fn = (a: string) =&gt; (b: string) =&gt; a + b;` The return types are each inferred, so there's little that can go wrong. &gt; Convert existing apps Yeah, it can be a bit brutal, but it's a one-time cost. On the plus side, it can uncover a lot of issues you were unaware of, and you don't need to convert everything at once if you enable `allowJs`. Focus on the modules that are imported everywhere else first as their types propagate across the entire codebase. &gt; Types are hard to understand Valid criticism, they need improving. You can learn to read them more quickly however if you start from the bottom of the error message, that's where the root of the problem is. &gt; Arrow functions aren't fun anymore How so? Usually the return type can be inferred, for example the snippet I wrote above. &gt; Component bloat Personally my prop definitions are almost always the same size as my PropTypes definitions would have been, and for that you gain compile-time awareness of issues (rather than runtime) and much better typings (I don't believe you can specify what sort of function you receive as a prop with PropTypes, for example). Could you provide an example of the kind of bloat you're talking about? Generally I find it's very terse: import React, { FC } from 'react'; interface Props { name: string; age: number; } const Comp: FC&lt;Props&gt; = props =&gt; &lt;h1&gt;{props.name} is {props.age}&lt;/h1&gt;; export default Comp; &gt; Types hard to track down, using any The more you use `any`, the more you're opting-out of type-checking and the worse this problem will become. I'm very strict about rejecting use of `any` in code reviews for this reason. Could you provide an example of a type that was difficult to get right? &gt; Node ecosystem It's getting better. Simple libraries are also really easy to add type definitions for yourself if needs be (just create a new `.d.ts` / ambient), and major libraries virtually always have types available in my experience. &gt; Slows me down I've heard so many people say this. I used to say this. Then at a certain point you've learned how to workaround the pain points - typically but not always because you were doing something wrong to begin with - and it just clicks. I refuse to go back to untyped JavaScript now because it's plagued by issues that TypeScript allows me to avoid. &gt; Bad programmers All programmers make mistakes, all teams have weak links. TypeScript protects against this. It's a bit like the parallel discussion that other programmers have about memory safety in C(++). The argument goes that only bad programmers introduce memory safety flaws, yet the evidence suggests that by this metric everyone is a bad programmer. I think on this basis Rust is an obvious evolution. TypeScript is in a similar position with regards type-safety in JavaScript.
Writing terse static types that are "tested" by the compiler is, I think, a lot quicker and less error-prone than writing bloated unit tests yourself. Without a compiler guarantee regarding inputs you'll also have to resort to very defensive programming, which soon becomes a burden.
&gt; and usually im left wishing I was using something else. Like what?
Some stuff straight up can't be polyfilled, `Proxy` being a notable example.
Yes, due to the lack of runtime type-checking (experimental third-party compilers and plugins aside) you are fundamentally dropping type-safety when you import external data. That said, TypeScript is still beneficial here: - Your interfaces become a form of documentation regarding the API responses. - You can write type guards to ensure that the API returns what you're expecting. - If you're resorting to very defensive programming because you can't trust the API to reliably return what you're expecting, then that can also be modelled in TypeScript, either via a union of all possible responses, or with `unknown` and type guards as mentioned previously.
I've been using got lately and it's a godsend
On that final point, one of the most unrecognised benefits of a statically-typed codebase is that it's a lot easier to onboard people into a large codebase. They needn't spend weeks trying to grok what exact data structures are moving through your application, it's all self-documented in types. Granted, they need to understand TypeScript/Flow/whatever you're using to do so, but I don't think the syntax is very complex except in _very_ rare, very complex generic type definitions.
Seems like a school task üòÅ have you to do it in the browser or in a desktop app?
Getting it work is a lot easier if you know the types of every variable, every argument, immediately, without having to try and mentally keep track of it all.
TypeScript is just JavaScript with static typing.
Arguably you can even reduce code given you needn't defensively program, or test types anymore.
I would first make it strictly typed. Have been using Typescript for sometime having things strictly typed saves a lot of headaches
I started to use typescript after investigating a bit how it could be added to a JS codebase, how painful would it be, etc... I have to admit it was simple, and it made the refactoring great. Refactoring a large codebase in JS is a nightmare, with TS it‚Äôs really amazing. That being said, now that I use TS everywhere, I can tell you why I don‚Äôt want to use it sometimes: * Generating the declaration files sucks SO MUCH sometimes. You cannot bundle them automatically, the TS binary doesn‚Äôt do that. So you end up with a one to one mapping from your files to a declaration file. * The compiler doesn‚Äôt take into account the ¬´ basePath ¬ª and ¬´ path ¬ª variable of the configuration. Meaning that, if you use those two variables to create aliases (e.g ¬´ ../../lib/file.ts ¬ª to ¬´ lib/file.ts ¬ª), you are extremely screwed when generating the .d.ts. Actually, ¬´ basePath ¬ª and ¬´ path ¬ª have never been created to make aliases, and unfortunately we ¬´ all ¬ª used it the wrong way. * Having a non-typed dependency sucks. You can use ¬´ any ¬ª for sure, but that still sucks :) I am really hesitant now on wether I made the good choice or not because of all those points. But I have to admit, refactoring and reading the code is much quicker.
A function applied to every element of a set.
The difference between vscode and webstorm is huge, so if someone says that, doesn't know capabilities of both tools. For sure webstorm is much powerful, and team members that are using vscode are pissing me off, because they are doing everything slower and too lazy to learn something new. For sure price is worth benefits for power users. If someone is using IDE as text editor it doesn't matter.
I agree with this. Haven't used typescript yet but strict typing is great. Fewer errors and even more importantly: The IDE knows the type of arguments that each function accepts, as well as the available functions in an object. Both saves you a lot of looking up documentation or trial&amp;error.
I don't use TypeScript because I haven't learned it yet lel
I agree, though I'm unsure how we'd hypoethetically achieve this. Catching errors at compile-type is extremely helpful / required, however one of TypeScript's limitations is its lack of easy, deep runtime type-checking.
Usually some combination of .NET and Rust, Depending on the context. .NET mostly because the languages, platform and infrastructure provide enough hooks to reflect and introspect when you need to (and because a lot of the application architecture is largely a solved problem), and Rust for messaging and general networked components. I have also used Go in place of Rust to pretty good effect. &amp;#x200B; I should provision, in my experience, it only becomes apparent you need something else long into node project life cycle, and usually long past the point where its feasible to just up and replace what you have. I call this 'the node trap', and it can be quite the thing to deal with. In all cases, one can deal with the 'trap' in a variety of ways, but doing so usually just feels like re-solving problems already solved in more established platforms. Also the quick and nimble aspect of early nodejs development can replaced by laborious manual busy work as you really start to narrow down on the details. Generating documentation, service contracts, generating stubs for integration testings, service discovery, mocking infrastructure, it all gets very unwieldy in JavaScript, and manual work grows exponentially depending on your level of service sophistication. &amp;#x200B; Still, node is still good for some things, and I usually prefer to write web socket servers, small REST http stuff and just general prototyping of projects. (node network scripting is fun)
Build all these silly libraries like is-even into the standard library.
https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref_prompt W3 Schools isn‚Äôt the best resource, so keep that in mind for the future, however... they have an excellent example for your exact usage (linked above). Welcome to JS! Best of luck on your journey :)
thats "reduce"
This has been a long time coming. While request was one of the first available general/purpose easy http clients available in the earlier days of node, nowadays it feels fairly archaic: it‚Äôs huge in filesize (`mkdir raw-huge; npm init -y; npm i request; du -hsc node_modules`), it requires a wrapper package for promises/async-await support, and there are now a lot more alternatives. For people looking for an alternative, `axios` is quite popular and pretty close to the all-in-one toolkit that request is, sindresorhus‚Äôs `got` is lower level and more bare-bones, and there‚Äôs a handful of npm packages that implement the modern browser-side Fetch API. Use whichever of those is better for your workflow.
is-even and is-odd are completely useless "libraries" anyway since you can just use the % operator. And their supposed advantage of having error checking adds nothing because you either have to deal with those errors, in which case you can do the checking yourself in the first place, or you're making sure to only apply it to valid variables, so no attributes that change type at runtime.
There is a TS preprocessor for v3: https://github.com/PaulMaly/svelte-ts-preprocess, so I don't think it's incompatible.
Oh boy this hurts to read. &gt;* Slower compile times Because your project is most likely a dependency mess with flawed software architecture from the ground up. Tsc is very fast. &gt;* It takes a LONG time to convert existing apps, and the fact that you have to start from the bottom of the component tree and work your way up is annoying af Agree here but switching programming language during development isn't what you should do in the first place. For existing apps that's too bad, but porting between languages is easier with typescript than with most others. &gt;* Types that are really hard to understand if you don't know how the packages you're depending on work (specifically with smaller libraries). &gt;* Just seems to make components twice as large as they should be. The main things I need it for can be done with PropTypes, and that's a lot less difficult to setup and understand. Bad software design. &gt;* Errors are unhelpful a lot of the time and just turn me off to the language. &gt;* Some of the types are really hard to track down and get right (a lot of the developers on my project agree), resulting in a lot of `type: any` hacks. The lack of knowledge of you and your peers is not an argument against the language though. The language itself is easy, even the advanced types. If this is too complex for you should consider switching jobs. I'm sorry to be this rude but the incompetence and the fact that everyone is OK with said incompetence of JS devs is actually making me sick. &gt;* Not many others besides just knowing how to set it up. Still wouldn't use it though as the package problem is a major blocker to me. &gt; shitty programmers not understanding how to write better code. Pretty bold calling other programmers shitty while you lack the technical knowledge to properly set up a ts app and understand advanced types.
I bet you can!
&gt; I tend to like to try things the vanialla way before using a tool or library Yep I definitely agree with that. I'm pretty new to Node/TS in general, only started less than 2 years ago. So I started with just plain ES/Node to begin with, so that I could at least know what the differences are compared to adding TS. I missed a number of features from PHP within a couple of months though (plain JS is wayyy too accepting with `undefined` everywhere especially), I got a little itchy wondering if I'd made the right decision moving to Node on the backend. TypeScript cured almost all of it though, now I find my old PHP code hard to debug and refactor in comparison (19 years PHP-only background, less than 2 JS). I still really would love runtime type checking, but that's the only major downside I'm still thinking about now. I think I might have jumped ship again otherwise using plain ES on the backend. It's getting better, but it's still fairly loose (even in strict mode) compared to PHP with error exceptions enabled at all levels. Really loving TS though, even if JS has its problems, it's still going to take something huge for me to consider leaving all the possibilities of NPM + single language that can do ***everything*** just for a technically "better" language alone. There's many more practical considerations. JSON being a literal code format is very comforting too considering it's now the defacto standard of information exchange, even outside the web (many Linux tools like exiftool, smartctl etc are adding support for it). I wish it also killed yaml and .ini - but it won't.
but why \_wouldn't\_ I want to use that? Are the cases in which it doesn't make sense?
have you looked at MS things? TS is different
eslint and typescript aren't even trying to solve the same problem..
Think /u/kayimbo summed up that feeling I had with better understanding of the market context. &gt; because it was written to help .net developers who didn't know javascript write javascript
TS preprocessor can be used, but that is not a problem here. Store and components import statements are removed by TS compiler and this behavior cannot be fixed without changing TS compiler itself. I encountered the same issue like here [https://github.com/PaulMaly/svelte-ts-preprocess/issues/4](https://github.com/PaulMaly/svelte-ts-preprocess/issues/4)
fwiw, I know C# and F# (learned waaay after typescript though), and I don't think this take on TS is at all accurate.
And yet many common apps include these useless libraries. I agree with you, but the way I would "fundamentally change Javascript" it to encourage them to go away.
Was trying to nail down what it is about the syntax which had me seeing their style and best I could figure is there is something about how they make their decorators a little verbose so they're easy to parse and predictable for code-suggestion. After VB6 I grew a distaste for that style of writing, want everything to be shorter rather than longer, along with no suggestions or predictions slowing me down.
That‚Äôs not a breaking change.
‚ÄúPercent operator‚Äù
If it‚Äôs a popular library, you‚Äôll get them with a `yarn add -D @types/package-name` And have yourself the types. A few years ago this was pretty spotty, with out of date types and stuff. But these days it‚Äôs pretty rare that I come across types that aren‚Äôt right (or I discover I‚Äôve been using old type definitions).
Remove the ability to add inline styles. The most JS should ever be doing in the CSS realm is adding or removing a class. I have seen so many projects go terribly wrong because of this. At first, I blamed the ‚Äúshitty programmers‚Äù but then I realized that they were being actively shown to do this in JS books/tutorials.
You can manipulate position of DOM elements with CSS.
That looks like jQuery in Coffeescript.
Primary I would remove old fluff so there is room for some sanity. ‚ÄúWith statement‚Äù puff, gone. ‚ÄúLabel statements‚Äù, puff, gone. For example: const fn = args =&gt; { arguments: args } This should work as intended, not as it works now. I would kill all for loops without mercy. Underscored variable names would be private by default. Literal for Symbols. Mandatory versioning on per-module basis. No import statements (just a function). Much better Proxies, or some better meta-reflection layer. Immutability by default. Stable sort on arrays. Compare operator for object values, not identity. Standard lib, Lodash in the lang. Make backtick strings the default (but with normal (double) quotes). Get rid of this. I can do this all day.
That‚Äôs a lot of bad ideas
If we had better meta-reflectivity, we could do it easily.
No, only for constant rates of conversion.
Jsdoc doesn't require an extra step to transpile
https://www.npmjs.com/package/got
So then dates wouldn't be a good example for your documentation.
Look into something called css. It is for styling websites. It can be very helpful for positioning text. I can't cover it all in this comment, but it is definitely something to look into.
Hi /u/N8Programs, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
Literally all you have to do is if(x % 2 === 0). Build them into the standard library?? Really??
It's just to show what it can do. But good point. Maybe I'll remove it in the next release. (Or add a leap years option).
&gt; I would kill all for loops without mercy Why? üòÇ
Google document is the best resource out there to learn how to create a Chrome extension. You only need that one to create your own extension.
Tell me how you use label or with statement everyday. Also, comma operator. Those are all bad ideas in the first place and removing them should be a good idea.
I‚Äôd be most interested to hear from those that have used TS for at least a few months but switched back to JS. Or choose JS for new projects.
Hi /u/N8Programs, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
It'll be a breaking change if someone can make them dissapear from the dependency list of half the apps that use them.
For-loops reek of imperative mindset. Especially C for-loops. Swift got rid of them which is a step in a good direction. Once you study APL language family (array-oriented langs), it is kind of obvious that for-loops are a unnecessary burden from the past. Higher-order functions on the Array prototype (map, reduce, some, every, etc.) are a great example how you can avoid for-loops.
We do it as well.. we already used js doc and use the typescript check in our ci now since why not..
The first line ``` el = document.querySelector('.eq'); ``` I am not sure what `katex.render` is in that syntax, or how el became an array. But `el.html()` is ``` el.innerHTML ``` (or `el.outerHTML`)
Although those are good ideas, they don't fit with JavaScript's style/culture. You'd be better off using a transpiler or wasm.
1) Remove exceptions from the language. IMO, exceptions are terrible hygiene because they can interrupt control flow in unexpected ways. This is especially egregious in JS because functions that can throw aren't required to be labeled as such (as in Java for example). I'd take Go's solution (multiple return values) or Rust's (Result monads) any day. 2) Static typing would be desirable, but I do understand many people love JS because it's dynamically typed. Typescript is great, but because you don't get the runtime benefits of a true statically typed language I feel its utility is limited. At the very least, for the love of God, fix the type system we do have because it's horribly inconsistent / unintuitive. 3) While I do see merit in the Class syntax and additions of the OOP ilk, I think introducing more constructs to the language is for the most part an unnecessary complication, so I'd nuke that. I prefer when there's a small set of idiomatic solutions to known problems, rather than layers of syntax sugar which achieve very similar things. That's about it I think. I have small nitpicky things but they're not fundamental.
Normal JS is fine as long as you know what you're doing. TypeScript was made by Microsoft, and it's all just transpiled to THE SAME VERY THING.
Haha yes, [interpreter](https://github.com/mlajtos/L1) for now. But can you elaborate on the JS style/culture a bit more?
I read the docs before and still think it is not relevant.
Imperative programs are often far easier to understand because they obfuscate far fewer details than functional / array oriented languages.
Do Lisps look obfuscated to you? I am not advocating tersness of APL/J/K/Q. I am just in favour of high-level constructs (functions) that can be composed easily. Loop statements are anti-composable.
But you have to remember to update the documentation, whereas with ts if you don't update the types it won't work
"Modulo operator"...
I would make the object behaviour consistent and make it more functional programming friendly.
Then, let me [entertain you](https://www.reddit.com/r/ProgrammerHumor/comments/bfqb3s/swe_interview_in_saudi_arabia/).
Which is a super thin wrapper on node-fetch from looking at r2 source.
What were you expecting to happen with the Lambda. Did you mean to return an object? Can you clarify what you expect, what you're getting and what you would change there?
I thought array prototype methods can never return early? My impression was that if you are searching for a value and potentially only need to iterate over half the array, then it's better to use for loops.
 $(function () { const el = $('.eq'); katex.render(el.html(), el[0]); });
Well if you're curious about the downvotes, it could be one of several things. For 1, what you're referring to is actually part of the DOM API, not the JS language. For 2, people will write "shitty code" with whatever tools or APIs they have available if they want to write shitty code. For 3, you're being a bit aggressive and condescending about a really weird thing.
So, its not the same thing.
```js const range = (n) =&gt; Array.from({ length: n }, (v, i) =&gt; i + 1) const greaterThan3 = (v) =&gt; { console.log(`Checking ${v}`) return (v &gt; 3) } range(10).some(greaterThan3) ``` Checking 1 Checking 2 Checking 3 Checking 4 true
This is so weird, JS was designed to be easy to get into so people could do light scripting on the web. Now people want to use it for everything because they already know it, instead of just using a different language better suited for the job. It's cool if you want to use JS for whatever, but it's weird that devs want to change the whole language for whatever weird thing they're using it for. It's like building a weighted head on the back of a screwdriver do you could also use it for hammering instead of using a hammer for driving nails and a screw driver for screwing screws.
I couldn‚Äôt have said it better myself!
https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event This doesn‚Äôt use JQuery Ajax, but it doesn‚Äôt give you more in-depth into the onchange event. Give that a read. Can you give more detail about what you are trying to solve?
Isn't &lt;any&gt; here just for this kind of occasions you don't wanna typecast it?
Let me explain it clearly. Recently I started using typescript instead of JavaScript for both frontend and nodejs applications. At first I thought it was awesome because Vscode began spitting intellisense like it never used to. But I ran into a lot of problems. Like in typescript and react [this](https://stackoverflow.com/questions/55775251/using-a-html-element-as-a-jsx-element), no one in stack overflow even answered it as it looks like they're afraid of typescript or it may be because I'm dumb and didn't write the question properly. And one more reason I never questioned typescript is because VScode is written in typescript and electron which motivated me to use it as I liked VScode. Well I soon found myself googling typescript stuff instead of doing what I'm supposed to do. The issue that I've linked to above clearly explains what I mean. It is just an if else in react but adding typescript made me waste a significant amount of time. Types are cool but I then had to define types for everything I did as I didn't want any `any` types in my code. And setting up typescript environment is another hassle that wastes a lot of time and is not beginner friendly. Unless you use a boilerplate which doesn't waste time at the beginning but sometime later. So the **conclusion**: It might be of use to a big project like VScode but I'd recommend not to use it unless the project is bigger in complexity than VScode. As you clearly need to keep track of what's up with your variables.
The argument that things fall apart in node when a project gets too big is nonsensical in my opinion. For example if your project uses express, sequelize, and react, it doesn't start at 1 line of code, it uses thousands (maybe hundreds of thousands if you count their deps?) of lines of javascript. Whether or not your project has 1 or 100k lines of code is statistically insignificant. &amp;#x200B; If you're a good developer, you're splitting your code into small modules that have 100% test coverage and 0 circular dependencies, which gives you the same experience as importing modules from npm, instead you're importing your own code. &amp;#x200B; If you're using bad coding practices, then yeah you're gonna have a bad time with javascript.
\+1 on not enabling strict mode and the similiar settings (noImplicitAny, ...), unless you're starting a new project and all involved devs know TypeScript. Otherwise it'll just be very annoying.
Hmmm. It‚Äôs interesting that you think I‚Äôm being either aggressive or condescending. I‚Äôm not trying to be either. OP asked for opinions and I gave mine. ü§∑‚Äç‚ôÄÔ∏è
https://api.jquery.com/jQuery.get/
No, it's exactly the same thing, plus awesomesauce on top. A so called superset language. Any JS code is valid TS code, no modification needed.
Yes they have them. No, it isn't a V8 thing. [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else) [https://www.w3schools.com/js/js\_if\_else.asp](https://www.w3schools.com/js/js_if_else.asp)
Make strict mode permanent, and remove sloppy mode.
There was an issue with the content in the article, I've just fixed it.
&gt; Did you mean to return an object? Yes, exactly. What you get is a function body with labeled expression without the return statement. So every time you call the function, you will get undefined as a result. I don't know about other people, but I happen to use object-returning lambdas quite more than label statement, so...
Are you speaking about Conditional Operator ( ? : )? [ecma-262/6.0/#sec-conditional-operator](https://www.ecma-international.org/ecma-262/6.0/#sec-conditional-operator)
Nice. Btw are you a senior?
tl;dr; TS complicates everything. 1. Types are decoupled from the implementation in such a way that the number of dependencies explode (npm i @types/&lt;whatever&gt;). It also means that there are a lot of false positives in the error detection. True for both libraries and in-house code. There was on that was so awful, that I had to write an implementation in just plain JS just to get it to work once. 2. Writing the types themselves is complicated. It makes it harder to read and reason about what is being read. Even when it comes to documentation generation, it's more difficult to read. For example, I once tried to use Microsoft's Fabric UI. The docs are great, so long as you understand all the custom types. You see things like "IIconProps". Which is great if you know WTH that is, but if you don't you'd have to try and track that down. 3. Code bloat. Even though the types get stripped away at compile time, there's still so much more code to wade through, also making it harder to read. Whereas before, a responsible developer might leave a handy comment explaining to the reader in real words how to use the function, I find that authors now just delegate everything to the types, meaning harder to understand code. Sure, TS will complain if you call the function wrong, but given the really awful messages, it's difficult to understand how to call it correctly. 4. Really awful messages. This might just be a configuration issue, but when I'm running Webpack in watch mode, and it's building and type-checking on save, the messages I get are all one line gobbledygook. I have little choice but to open the file and try to read the block of code that it's complaining about. Now, having said that, running `tsc --noEmit` on the same file _does_ give me a nicer message. But I have no idea why I can't get that same kind of messaging from Webpack. 5. Testing is more complicated. I was the first to bring client-side testing to two of my projects. The projects have been around for years, although the others were less inclined to figure any of it out (even still, after all the hard work of setting it up, they still mostly refuse to test.) I've been trying to upgrade one of these projects to Babel 7 for a while. We (I) use Jest, which means I have to use TS-Jest. When I upgrade Babel, all my tests break. I tried upgrading both Jest and TS-Jest to the latest, but my tests continue to fail, and I have no idea why, but it all seems to be related to _needing_ TS-Jest because of TS. 6. Webpack build is slower and uses more memory. I'm having to give it `NODE_OPTIONS=--max_old_space_size=2560` just to keep it from running out of memory. Some of these are probably configuration problems. But then that kind of adds to my point. Adding TS causes an explosion in complexity. There are some niceties, but given the number of false-positives that I encounter, I mostly don't trust the information it gives me. I spend more time trying to confirm the problem, when I should be spending that time writing a test or something. And then when I confirm that it's wrong, that the object does in fact have that property, it ends up `//@ts-ignore`d We have another project that is just straight ES2015 with React/Redux that doesn't have these problems. It's a SPA that processes more modules but doesn't crash during build, Babel 7 upgrade was straightforward, testing config is simpler, etc. It currently boasts ~60% code coverage on the client. One of the biggest benefits of using TS is the developer experience, supposedly. The more helpful tool-tips, autocomplete, etc. What I found is that since most IDEs are using TS under the hood, that I don't necessarily need to implement TS in order to get some of those benefits. I started at this company on the React/Redux SPA I mentioned above. When I was asked to do work on the two other projects that use TS, I found that I actually lost some autocomplete. Things that would have shown up on the non-TS project, **didn't show up at all on the TS project**. This is likely due to the explicitness of a given type being specified somewhere, but still. If having a better auto-complete is the best reason, then maybe it should only be a tool only used by IDEs?
So you would prefer it to return an object by default, and then ({}) would be the function block instead?
More advanced programmers attempt to use techniques that reduce (or remove completely) if statements. [https://jscomplete.com/learn/beginning-javascript/special-practice](https://jscomplete.com/learn/beginning-javascript/special-practice)
&gt;Here is my opinion on typescript. I think typescript has been mostly been adopted by those people coming from a computer engineering background that are trying to get into web programming. It seems to me that those people can't really handle the awkwardness of JavaScript. And I don't blame them, it is weird. &gt; &gt;I started out doing web programming, so all the weird stuff with JavaScript is fine by me and I just sort of deal with it. I've started as a web dev, with JS being my first language. And I love TypeScript exactly because of the weird stuff you mentioned, because TypeScript embraces JS's nature to an incredible extent. It's not like CoffeeScript or others that tried to replace JS with another abomination, rather it's softly hugging around all the basic concepts of JS and allows you to add strict types and have fun with them, on top of being able to transpile to older JS versions. An example of this would be TypeScript interfaces. They're implicit and allow you to specify any members, not just functions. This allows you to specify an interface, which the compiler (and thus your IDE) will know to automatically assign to any plain object that has the same members as the interface. This makes the unusual way of JS using objects for a buttload of things that other languages use either value object classes or maps for really easy to work with in TypeScript.
[removed]
Sure. What I have to do is select one of the options from the drop-down list. This should trigger this function:- $('select').on('change', function() { }, and pass the option I selected as the parameter to the function().
Delete classes, privates, null, loops, let go of any backwards compatibility. Add pipe operator, templates, more metaprogramming and functional syntax.
Isn‚Äôt Python also single threaded because of GIL?
Its permanent if you use modules.
Hit up on our Gitter channel to find out more.
the requirements in web development have changed drastically in the past years. a few years ago we used some javascript snippets to make sever rendered HTML a bit more dynamic. Static typing was just not needed at this point. But the requirements have changed and people want huge SPAs, complex frontends and use js on the backend as well where static typing is more important and can make development easier. my dream solution would be for js core to add the typescript features and optionally enable them via a keyword like "use strict typing". This would keep js flexible enough to do rapid prototyping and being able to build complex SPAs and backends.
`this`
\[Ideally\]([https://github.com/mlajtos/L1/blob/master/GOAL.md#better-javascript](https://github.com/mlajtos/L1/blob/master/GOAL.md#better-javascript)), there would be no function block, just lambdas.
Templates?
That's not an expression :-)
got seems really nice. it seems like I can port over all my fetch/request-promise code with almost no changes
&gt; This might be the "Angular 2" moment of Svelte, sadly. I think there are several significant differences from the "Angular 2" change: * At the time Angular 2 was announced, Angular 1 was already massively popular and widely adopted (whereas Svelte is still a tiny player with few deployments). If there is any time for Svelte to make a significant breaking change, this is it. * With Angular, there was a two year gap between the announcement of Angular 2 and its final release. Because developers did not want to start new projects in Angular 1 during that time, many jumped to other frameworks in the long interim. By contracts, Svelte 3 has now been released only a few months after the initial RFCs. * For many who liked Angular 1, there was a lot of ambivalence about some aspects of the new Angular 2 architecture. There were also some attractive alternatives doing similar things, such as React and Vue. With Svelte 3, though, the changes appear to be all upside, with no other frameworks really doing anything similar. I'm not trying to minimize the inconvenience to those who have to migrate from Svelte 2, but "Angular 2" was a completely different kind of saga.
I agree with it being beneficial. But I think typescript *is* a good solution. If you're making webapps, then I don't think it's especially inconvenient to add a build step transpiling your ts. I don't think changing the language is the solution. A clear design goal/idea that was consistent and strictly enforced is what *I* would add to JS. Not stapling classes on, or adding pattern matching, or static typing, or whatever flavor some of it's features miss from other languages.
Call stack usually means the list of functions you‚Äôre in, like when f1 calls f2, and f2 calls f3, then in the middle of f3 executing, the call stack will be f1 | f2 | f3. The event loop isn‚Äôt checking that call stack. It‚Äôs just the loop that checks if any events (user inputs, timers, network callbacks, page load events, etc) have happened and need handling.
There's the ternary operator: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional\_Operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator) There are also alternative approaches like these: [https://ramdajs.com/docs/#ifElse](https://ramdajs.com/docs/#ifElse) [https://ramdajs.com/docs/#cond](https://ramdajs.com/docs/#cond) [https://z-pattern-matching.github.io/](https://z-pattern-matching.github.io/)
Most variadics have been supported since v3 and even better since 3.1, FYI. Tuple types got functional super poers
I could elaborate, but you could just take the rest of your replies as an example. JavaScript wasn't made to be Rust or Lisp, it was made to add interactivity in the web. It would be very hard to change the existing mindset as you can tell by the comments.
I had a similar situation recently where I created a function called ChangeVal() and passed that into my select element onchange=‚ÄúchangeVal()‚Äù From there in your client side script file you can say change = document.getElementById(&lt;your select element&gt;) and then assign a second variable changeValue = change.value; Whatever the value of the option element that is chosen will then be your value and you can pass that value into your function. Let me know if that makes enough sense. If it doesn‚Äôt I can make a quick Codepen link or something to show you. It‚Äôs very similar to the Mozilla doc example.
This is jquery still, just not coffee script.
What‚Äôs the goal for this? There‚Äôs not quite enough context to know what the desired output is here.
&gt; I don't think changing the language is the solution. adding x steps to the toolchain can be problematic. The toolchain is already quite large in the js world. Also, conflicting keywords and concepts of different js subsets can lead to a split of the community. Don't think this will do any good for js. webassembly now allows other languages to be used in frontend dev to some degree... meaning that if js can't keep up with it feature sets and performance it eventually will lose quite an amount of marketshare to other languages... and I don't want to deal with 5 language * 3 languages specific frameworks + toolchains just to feed my family...
The console will show the value of the last expression it executed when it runs code. But that does not mean the code itself evaluates to that value. So basically if you have a block statement with one or more expressions in it, the console will pick up on the last expression there and display it as a "return" value even if the statement (not being an expression) isn't actually returning a value. // In console switch(1) { case 1: 'hi' } // &lt;- 'hi' var x = switch(1) { case 1: 'hi' } // Error
Why was this removed? It's a good question for beginners
Really, that's kind of all TS is, thought right? A type-aware linter?
&gt; Whatever the value of the option element that is chosen will then be your value and you can pass that value into your function. &gt; &gt; Hey, Thank you for your help. A couple of doubts:- 1. This changeVal() function also goes inside the &lt;script&gt; tag? 2. Exact syntax for onchange = "changeVal()" ?
Oh, I see. Well that certainly explains it. I don't think I've ever encountered another REPL that behaves like that ü§î
Katex is a math library. https://codepen.io/ZevanRosser/pres/PwqMwe I don't know jquery, but I do know javascript. I want to play with those code, but I don't really know how to manipulate it unless it's in javascript.
Why are you being downvoted?
&gt; Every function without an explicit return still returns undefined That's because `doSomething(arg)` returns `undefined` in the first place.
Except a linter is basically plug-and-play, requiring virtually no overhead or investment to reap its benefits. Adding TS to an existing codebase is a major undertaking, and even using TS in a new project comes with costs, which in a lot of cases might very well outweigh the benefits.
I find that just knowing the types isn't enough for me to understand the function in many cases. So I end up reading or debugging the function in order to get the an idea of the context the original author had. This only really applies to changes, sure. But isn't that part of the whole TS idea?
JavaScript doesn't exist only in modules.
&gt; if js can't keep up with it feature sets and performance it eventually will lose quite an amount of marketshare to other languages wouldn't that be ok? then it could just do what it was created to do. arguably, it shouldn't have gotten into *those* languages market anyway
[removed]
Axios or node-fetch
Correct. If you give me a bit I‚Äôll write up a little codepen as an explanation. Try an experiment first as it‚Äôs more rewarding to learn it by yourself than have someone tell you, but I can give you a better example in a bit.
Definitely, but a Hindley‚ÄìMilner type system like Haskell instead of the bloated Java-style explicit typing.
i wrote why it's not okay (for me and probably many others) in the following sentence. Frontend fatigue is already awful and splitting everything further doesn't make it any better for the user and developers. &gt; then it could just do what it was created to do Javascript evolved into the language of the web and in order to keep doing its job it has to evolve further.
\&gt; It would be very hard to change the existing mindset as you can tell by the comments. &amp;#x200B; Yes, that's why TC39 is doing really good job keeping the language as-is without any breaking changes. However, OPs question was about changing the JS.
Thanks, this is a great perspective
Because one eventually runs into a problem where a useful library is not typed. Can't deficate time to just fix typescript issues.
It‚Äôs not a JavaScript concept.
jQuery selectors return a jQuery wrapper object that can be used as an array (whether they match 0, 1 or 20 elements). In this case "el" will be all the elements with the "eq" class but a call to html() on that will just return the innerHTML of the first element.
I checked again and I think the article doesn't claim that it's a JS concept. It only says that it became popular in JS with Redux. Anyway, this article walks you through reducers with JS code :)
I use to use it, I like it better for nodejs. But I have seen a lot of companies I have interviewed with recently for react jobs say they use typescript with react. I am not of fan, it bloats your code a lot. I mean a lot, I remember when I wrote a typescript react app, my component files were longer than I‚Äôve ever seen. I have heard React developers say using Flow is easier.
\`\`\` const el = document.querySelectorAll('.eq') katex.render(el\[0\].innerHTML, el\[0\]) \`\`\`
This video is old but gold in explaining the event loop. https://youtu.be/8aGhZQkoFbQ
This will pull an array but since you‚Äôre only using the first element found, you can just use querySelector and then reference it directly with el.
That's a very good point. I really liked the phrasing of "type-aware linter", because it doesn't change how the code runs and only provides "suggestions". But you're right. There is a tremendous amount of overhead and lack of configurability that's just not there when linting.
 document.addEventListener('DOMContentLoaded', () =&gt; { const el = document.querySelectorAll('.eq')[0] katex.render(el.innerHTML, el) })
That's probably just a matter of `querySelector` or `querySelectorAll`, jQuery does handle that a bit nicer than vanilla :P
If you want JavaScript where everything is an expression, you might want to look into [CoffeeScript](https://coffeescript.org). ... _runs away_
TLDR: Cache. I'm not a big fan of automatic memoization by matching parameters, though. It only works for very simple parameters, very simple functions, which, ironically wouldn't benefit from a cache in the first place. Caching should be done with purpose and thought, and in the real world would very rarely just match blindly the parameters 1:1. Cache might look into some of the parameters, or specific aspects of the information. Cache use may even be non-deterministic in some applications. Cache is everywhere, even at the hardware level. But never rely on silver bullet solutions to handle it for it.
That's true. However, I just copied he's example, I have no idea if he uses more than 1 .eq div ;D
I did... about seven years ago. (I mostly try and stay away from the front end world.)
This is fantastic man! You have no idea how many hours I have spent creating e-mail signatures that sooner or later I end up changing. You have my full support. Kudos again!
But how does it know to execute the events only when the callstack in empty?
I can see the benefits of TS if you find yourself doing a lot of defensive coding when passing data around, but I‚Äôve worked across a lot of different codebases in JS and really only come across or needed very small pockets of defensiveness in terms of checking data types. It‚Äôs never really made sense to shoehorn in a whole new ‚Äúlanguage‚Äù to justify it. YMMV of course.
True true. Hard to tell exactly what should happen here haha
Yeah this guy is awesome. I had gone 18 minutes into it earlier week. I will watch it again now that I have a better understanding!
I HATE this attitude that so many programmers have "THIS STUFF I LIKE WILL SOLVE YOUR PROBLEMS AND YOU'RE A MORON FOR NOT USING IT", and it seems that a lot of people on the JS community subscribe to this heavily... I have lost count on how many times I was getting into some cool language/framework/whatever and then they start to get into this awful awful argument. Typescript is AWESOME , I have no doubts, I've written code on it and loveed it... but you know what, I have a day job , I have several different codebases to mantain, I work 10 hours a day 6 days a week, I have stackeholders to make happy, I can't just say hey I'm going to put such and such hours into rewriting such and such code, or I'll use such technology from now on because it's cool... I envy you if you can just write code on whichever technology you feel like and still make a living from it
At the end of a function, execution ‚Äúfalls‚Äù back to the calling function (and brings the return value of the completed function). So conceptually, the path of execution travels back down the call stack until the call stack is at zero. That‚Äôs the point where the event loop looks for the next thing to do.
Perhaps because if you're below 100% you can't be sure you're safe after changes without checking. In that regard, 0% and 99% are the same
The best video explaining the event loop, amazing talk.
&gt;If you're using bad coding practices, then yeah you're gonna have a bad time with javascript. Good coding practices should be a given and It's not really what is being discussed here. But i would argue its impossible to have good programming practices in a language as permissive as JavaScript. And even when you add TypeScript to the mix to try and constrain it, you're still fighting an uphill battle taming complexities in the overall infrastructure and how fragmented and piecemeal everything is. &amp;#x200B; I still suggest something like [https://nestjs.com/](https://nestjs.com/) or [https://loopback.io/](https://loopback.io/) which aim to ease some of the challenges being referred to here, but are still pale in comparison to more established software frameworks on other platforms with more equipped languages backing them up. &amp;#x200B; I'm not saying node is impossible, i'm just saying it suffers diminishing returns that are not apparent early on in a project.
&gt; highly critical system I think you over value your work...
This isn‚Äôt quite right but it‚Äôs close. The event loop is essentially the concurrency model for JS. The event loop is looking into the task queue whenever the call stack is empty to see if new code/tasks from the queue can be put on the stack. Tasks run to completion before another is ever put on the stack, so the event loop does have to read from the stack in some sense to know when its empty. Code is put into the task queue via various WebAPIs, all of which (I think) utilize events and listeners under-the-hood. Simple examples are such are setInterval or and window.onLoad. For more info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop
So you don't want to transpile any code, but you're fine transpiling code? I'd also like to highlight that flow is very similar to TS in a lot of ways nowadays. And lastly I'd like to point out that Babel actually supports typescript as well!
Maybe it shouldn't be easy to make web applications
There are innumerable silly things to keep track of with dates. I would not include dates as an example.
Or `cross-fetch` for a universal lib.
I like the idea of TypeScript, but in practice I've always had a bad time. I think you've nailed it with the `type: any` hacks. How many devs do you know/work-with that would actually take the time to track down bindings (or write their own?!) vs just throwing up a one-liner hack of `type: any` -- thus defeating most of what TS offers. Plus I LoL'd at: &gt;Arrow functions just aren't fun anymore. Sounds like it'd be part of an infomercial, üòÇ
That's fair, but I never said I don't want to transpile code. The point here is that I don't want a transpiled language. I want Javascript. Flow is annotation to javascript, typescript is another language that transpiles to javascript
If you want the first element just use \`document.querySelector\`
Hmm yeah, this still makes zero sense to me. You're basically saying zero safety is better than some safety? Because when you have some safety, you might be silly enough to think that's the same as having 100% safety? So it's better to just have none! wat? I guess in this case we should shut down the police, hospitals, doctors, the army, and umm... like everything. Because nothing is 100% effective, and apparently if your thought in your head about the effectiveness is higher than reality, it's better is just have nothing. I'm probably going to sounding like an ass, but I get why most people in non-technical jobs could make these kind of illogical arguments, when logic isn't their job. But when programmers make them, I wonder wtf is going on. How can anyone whose job it is to judge and write logic, decide that a a thing with some flaws is worse than a thing that is completely flawed.
Hi /u/n33dstr3ngth, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/Murlock_Holmes, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/UnFukWit4ble, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/Isvara, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/know_prashant, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Interesting idea. Making a note to check out the code later. Thanks for sharing!
Hi /u/mementomoriok, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/Lorofthin, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/IAM_JTXVI, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Well, this is awkward. This subreddit is for **javascript**, which is different than **Java**. In other words, `javascript !== java`. Maybe try one of these instead: * /r/Java * /r/JavaHelp * /r/LearnJava Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/BiteSizedCookies, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
It's discussion about JavaScript the language itself, not beginner content, not about a framework or library, and not about general webdev. &gt; /r/javascript is for the discussion of ... especially, code Was it not? Anyway, it doesn't matter now‚Äîsomebody already provided a good explanation.
Yes in JS the events that the event loop handles are called ‚Äútasks‚Äù I guess because the word event is heavily used in DOM stuff. Shoulda called it a task loop, really. There‚Äôs also a bunch of fiddly stuff about microtasks too, that shuffle in front of the rest of the task list, and browsers manage the incoming tasks on multiple queues and can pick the next task from whichever queue they like. Plus web workers etc run their own event loops, so they‚Äôre not constrained by the cooperative concurrency that the ‚Äúmain‚Äù JS thread uses (I don‚Äôt know much about web worker event handling but I think they also use no-interrupt concurrency, just within their own threads). OP can explore those fun topics at their leisure...
I am mid-level :)
Ok I downloaded the template, fired up a very simple app and set a break point on the template, it fires once on init and but doesn't hit when name is updated. the page updates fine as expected. Is there something I am missing? It was really nice to be able to mouse over {name} and get "" while it was initializing but that's all ive been able to get out of it. &lt;script&gt; export let name; setTimeout(()=&gt;{ name= "bla" }, 1000) &lt;/script&gt; &lt;style&gt; h1 { color: purple; } &lt;/style&gt; &lt;div&gt; &lt;h1&gt;Hello {name}!&lt;/h1&gt; &lt;/div&gt;
I don't use typescript itself, but I do take advantage of it's features. I've worked on large typescript projects, and the parts I loved the most were the benefits to tooling. I'm not a VSCode user, but I do employ the typescript language server on my vanilla JS projects from my editor of choice. IMO, I get everything I enjoyed the most from a full TS solution. i.e. auto completion, jump to definition, function params, function docs, and errors in my editor.
Is there any tutorials to learn it efficiently ?
axios is universal üôÇ cross-fetch is great too if you want to use the fetch API üëçüëä
well you can just ignore the typing for this particular library... also there is a good chance that someone has written a type interfaces for that library that you just have to pull in.
Haven't had (m)any problems with Flow. Not worth switching to TS IMO
When you type a function name, the IDE shows the documentation in a tooltip. It‚Äôs incredible.
Noooooo
Same utility is provided by a test suite which you should have anyway. I don't see TS catching any bugs that tests wouldn't catch.
Sounds like you need to write more unit tests.
&gt; when the tooling fully supports and takes advantage of Typescript (the way say Eclipse or IntelliJ takes advantage of Java's strong typing) We passed that milestone years ago with VSCode and the TypeScript plugin for Atom. Where have you been? &gt; Webstorm oh, that's where you've been. You should try again this time using an editor which properly supports TS. You get the benefits of static typing in your IDE without the inflexibility that older languages like Java have.
Yeah so imagine if all of those brain farts went away. How much faster would development be?
When you write the name of the function, the documentation shows up in a tooltip. It‚Äôs beautiful.
If someone were to use it and set all the types to any would that meet your requirements?
Now that it's released `svelte-upgrade` will be updated to help with migrations. Though it's already helped me migrate some stuff as it is.
&gt;It been tough to get visitors though It might be worth noting that I had no idea what your app did after reading this. I understand the context and reasoning behind describing the technology. However, it would have been relevant to tell us what you app does as well. Perhaps, like myself, you have a pattern of not "selling" your ideas...
Svelte creator here. The performance stuff is far from theoretical ‚Äî I covered this in a talk that was published online today, particularly this section: [https://youtu.be/AdNJ3fydeao?t=1083](https://youtu.be/AdNJ3fydeao?t=1083)
But again, that's presuming the author was responsible enough to provide those details. It's my experience, that a lot of developers are lazy, and "expect the code to be the documentation". and provide no documentation whatsoever. I've actually seen this worsen \_due\_ to using TS since they believe the type-hints are enough.
It's pretty amazing. I used to make a `typings` file for projects but migrated to "JSDoc-like" everywhere. The project is called "Salsa" in Typescript, if you ever browser their Github repo. The intellisense in VSCode picks it up perfectly if you turn on type checking in javascript by including a `jsconfig.json`. I have an `eslint` rule for forcing JSDocs for functions, but wish I can have some sort of linter for typescript checking to never allow loose variables (`any`).
Check out [https://svelte.dev/examples#debug](https://svelte.dev/examples#debug). You can't just use a \`debugger\` statement like you can in a block of JSX because your code isn't \*running\*, as such (this is a feature, not a bug). &amp;#x200B; Anecdotally people have found the debugging experience ok ‚Äî for one thing, even if sourcemaps fail you the generated code is designed to be readable, and you don't have to step through KLOCs of library code to see your errors. But it's always an area that's open for improvement. &amp;#x200B; More philosophically, as compiler techniques get more and more widespread (hello Prepack!), the JS community is arguably going to need to rethink breakpoint-based debugging altogether.
That's exactly it ‚Äî every assignment to local state is instrumented with a call to \`$$invalidate\`, which is a component-provided function that marks a particular value as dirty and schedules an update for that component at the end of the event loop.
i want real 64 bit integer instead of the float but oh well if we could fundamentally change things, would we still be using html?
We weren't expecting this to hit Reddit and HN yet; there are still a few elements that need documenting. Nonetheless, I'd appreciate any feedback on what's poor about the documentation? Have you tried [https://svelte.dev/tutorial](https://svelte.dev/tutorial)? &amp;#x200B; TypeScript support is on the radar. Svelte is written in TS, and v3 was very largely about making Svelte TS-ready. &amp;#x200B; The store implementation looks like this: [http://unpkg.com/svelte/store.mjs](http://unpkg.com/svelte/store.mjs). That's the whole thing. It's documented at [https://svelte.dev/tutorial/writable-stores](https://svelte.dev/tutorial/writable-stores). Can you elaborate on why it's overcomplicated? &amp;#x200B; We do have an extension for VSCode, and it'll be updated for v3 very soon.
If you're client side, you can probably use fetch, which is built into the browser. If you need to support older browsers and/or node, then cross-fetch. I also have a library called 'supertest-fetch', which is like fetch and supertest melded together taking (hopefully) the best of both worlds (and it's typescript friendly).
Hi all ‚Äî Svelte creator here. Didn't expect this to pop up on Reddit yet, and we're still sanding down the last rough edges around docs etc, but happy to answer any questions you all have!
Thanks Rich, the {@debug} statement was reliably stopping on chrome and printing out the variable. I'd call that good enough to be effective. It's way better than what Angular brings to the table.
I mean you said that this was hypothetical about breaking changes. Lol
[removed]
Like I said, I'm waiting for the tooling to catch up; there is A LOT more to picking an IDE than just how well it supports Typescript!
A little chrome extension that saves the state of a page for (remote) analysis: [https://github.com/vrtdev/save-page-state](https://github.com/vrtdev/save-page-state) &amp;#x200B; **Highlights** * DOM Snapshot (HTML file) * Encapsulated HTML (MHTML file) * Screenshot (PNG image) * Metadata (extra data about the users' browser)
Transform it into ReasonML
Are you going to repost this every few days?. This is like the fifth time I have seen this within the past few weeks.
The author explains function purity is the key requirement to use memorization which I think answers your concerns about nondeterministic code
Get rid of the fake classic OOP
Put me in the used TypeScript and went back camp. Felt it was a monster waste of my time and actively caused it to take longer to deliver features while solving a problem that doesn‚Äôt exist and making it actively harder to design as you code (I don‚Äôt mean high level design). Not specifically pointing my finger at you, but I feel like a lot of the people who beat the TS drum don‚Äôt talk about the downsides at all.
One thing I don't quite understand are why compiler directives needed at all for dependencies when I would think the compiler would see the use of a tracked variable. Their trivial example of `count` and `double` seems to show my point there. There's also the forced "spread" or the reassignment to trigger invalidation. I'm also interested in seeing how Svelte 3 performs, since Svelte 2 was better than something like React, but didn't seem exceptional on https://github.com/krausest/js-framework-benchmark
It would be nice if you attach few examples showing the usage in the readme .
Good news: https://github.com/tc39/proposal-bigint
Can you elaborate on the \`count\`/\`double\` thing? Not sure I follow. The js-framework-benchmark isn't necessarily the best representation of real world apps. It also penalised Svelte quite heavily for some reason: [https://github.com/krausest/js-framework-benchmark/issues/549#issuecomment-483054081](https://github.com/krausest/js-framework-benchmark/issues/549#issuecomment-483054081). As I talk about here, Svelte is extremely fast: [https://youtu.be/AdNJ3fydeao](https://youtu.be/AdNJ3fydeao) (but don't trust benchmarks, always do your own measurements!)
I didn't have concerns about nondeterministic code, I meant the cache itself may be nondeterministic, for example it may depend on the free memory on the system or god knows what. Even functional languages manage memoization this way, they don't blindly save everything you ever called a function with.
Opt-in strict typing at the function/module level would be ok, but I will personally fight those who would make it mandatory. Remove this, class, and new entirely. Let people use closures, simple functions, and object attachments instead. Remove null, use undefined instead. Remove double equal entirely.
Superagent
I wouldn't recommend a library that throws on an HTTP status \`500\` which is a valid response that should be defined by the application, not a connection error or anything.
Code writing code. Templates are cooler things on c++.
Give regular functions the same 'this' scope as arrow functions. Make 'var' behave like 'let' and remove the other. Right now it is getting too bloated.
https://github.com/wsmd/reattempt/blob/master/README.md#usage
Thanks
Would really appreciate any feedback :) Web version is coming
One of the biggest benefits of modern frontend frameworks is decoupling of state and view and intelligent ways of re-rendering the view when state changes. Web components don't seem to solve that problem so there is still need of a library that keeps track of state and renders the view accordingly, which is why I fail to see how web components could replace frontend frameworks in its current state.
You can run ts on browser without transpile?
This is only true if you don't enable \`strict\` in tsconfig. I don't see much of a point to using TS if your code is sprinkled with \`any\` types.
Nice idea - all fun am games until you write code that should never be re-attempted - like resurrecting a zombie Jesus
Too verbose and you inherit typescript debt.
You know what it means... new frameworks! _ducks_
I was able to make it happen with only 4 lines of Perl. I looked at it 10 minutes after I wrote it and have no idea how it works.
I added this in multiple layers to an application I develop. Not only does it decrease load on my server, it also makes the application more performant. The first layer is API-level caching. If you make an API call, the results are cached with an expiration. Some API calls can be cached for a week, others for an hour, some not at all. The second layer is browser-level caching. Any time I receive the results of an API call I look at a custom header sent from my API that includes the cache expiration time. If set, I also store the results of that API call in memory so any further attempts to make the same API call will just return directly from the local cache. Let's say I have an API call that takes 3 seconds to compute that caches for a week. The first time in the application it will take 3 seconds, then be cached on the server and the browser. If I reload the app it will take 30ms because it will be cached in the API. As a bonus I can now call this API call as many times as I want locally because it's only going to ever fire off one HTTP request until the cache expires. This makes the code for fetching data very clean because the cache is always 100% transparent. Lots of fun to develop this kind of thing and the results are usually very obvious.
Are you building anything real?
Yes. I work for a Fortune 100 company building ‚Äúreal‚Äù stuff.
For count/double let count = 0 $: double = count * 2 You don't need to do $: for count, so my thought was why can't the compiler infer that it also needs to handle invalidating double? The same train of thought extends to all usage of $:. I wish I could test multiple frameworks and get my own measurements, but the unfortunate reality is that most places will continue to use React and won't be open to alternatives, even ones that are basically React-like. The measurements from others also help to limit choices on what to measure, since there are a ton of choices out there. Thanks for letting me know the results were messed up, I could have sworn it was faster when I looked prior, so I'll definitely keep it on my short list for what I can try on my own in the future. As an aside, the CSS support directly in Svelte seems like one of the nicer features as it sidesteps the pain of which css-in-js lib/framework and the different philosophies each one has. Is the code you show in the videos available anywhere to peruse like the send/receive transitions?
Then the function wouldn‚Äôt be pure. And you‚Äôd be right. But the author explicitly called for purity so...?
I wasn't saying it was theoretical, I think it's really cool what you guys are doing, and I get that it creates imperative components at compile time. I'm just saying if I write an app in Hooks, with prepack optimizing at compile time and proper memoization and of course packing your app correctly with tree shaking and proper inports. Since prepack does similar things to what svelte does with component folding, do I really see a real world difference in the end?
Thanks for your comment, even though I appreciate your input I would like to highlight some things I consider relevant. To better address your concerns I'll separate this answer into different "points": &amp;#x200B; **1st point:** &gt;"I'm not a big fan of automatic memoization by matching parameters, though. It only works for very simple parameters, very simple functions, which, ironically wouldn't benefit from a cache in the first place." The arguments of a function do not determine the complexity of it in any way. A function could receive primitive values and implement complex tasks such as data processing or it could receive more "complex" values such as objects, functions or arrays and just use the function passed to iterate over the array and generate an output. A very good example of automatic, efficient caching are [selectors](https://github.com/reduxjs/reselect) in redux architecture, [I took the liberty to look for the code they're using to cache](https://github.com/reduxjs/reselect/blob/master/src/index.js#L21) and you can see that the technique they're using is very simple, arguments based, flexible and yet powerful. &amp;#x200B; **2nd point:** &gt;"Caching should be done with purpose and thought" Totally agree. &amp;#x200B; **3rd point:** &gt;in the real world would very rarely just match blindly the parameters 1:1. &amp;#x200B; Actually, this is not true, and the very existence of the memoization technique is the proof: &gt;*"In computing, memoization or memoisation is an optimization technique* ***used primarily to speed up computer programs by storing the results of expensive function calls*** ***and returning the cached result when the same inputs occur again.****"* &amp;#x200B; this concept is available in the first paragraph of the definition on [wikipedia](https://en.wikipedia.org/wiki/Memoization) and you'll find the same concept in pretty much all the sites. As you can see the very concept of memoization follows that input based principle, checks the inputs passed to the function to make sure we're not recomputing expensive calls... If what you're saying here was true memoization wouldn't exist or even be used. &amp;#x200B; **4th point:** &gt;Cache might look into some of the parameters, or specific aspects of the information. Cache use may even be non-deterministic in some applications. This is a bit ambiguous, memoization is not the same as caching, memoization is a way of applying caching. In the article, I'm referencing memoization explicitly and that's why I explain explicitly [the conditions a function should have](https://enmascript.com/articles/2019/04/22/avoid-recomputing-heavy-tasks-by-leveraging-memoization-in-javascript#what-is-required-to-memoize-our-functions) to be memoizable. &amp;#x200B; **Last point** &gt;Cache is everywhere, even at the hardware level. But never rely on silver bullet solutions to handle it for it. Agree, caching is everywhere. In computer science, there are no silver bullets, in fact, I never said that about memoization, I used the article to explain its applications and proposed a reusable way to apply it, in fact, you will find out that I say: &amp;#x200B; &gt;**Important to know:** you don't explicitly need a function called *memoize* or an isolated function for that matter to apply this technique, as long as your implementation respects the principle behind memoization... &amp;#x200B; I'm very glad that you took the time to give your opinion on this, it's highly appreciated, hopefully this will help others to understand better the concepts behind this idea.
&gt; You don't need to do $: for count, so my thought was why can't the compiler infer that it also needs to handle invalidating double? You might want to just compute double once, and you must be able to tell the difference between that and something that can change always.
[removed]
Thanks got discounting my points and in general being unhelpful as fuck
Why is array.reduce called reduce? I know that reducers are a functional programming concept, which in my mind isn't really the same as array.reduce.
That's not the case. You can have non-deterministic code produce deterministic results. Not every implementation detail has to be executed in the exact same way as last time in order to preserve the same outcome. This is why I was very specific about saying "non-deterministic caching", I don't mean that the cache would result in different outcomes, I literally mean we can have different caching decisions for the same inputs (i.e. what to cache, when to cache it, when to discard it etc.). If you do the same computation on your CPU, the odds are it'll go through completely different paths in the chip the second time around. But 2+2 will still be 4.
Evidence seems contrary. People are very excited for what Svelte 3 brings to the table, and the number of people who join the Discord channel daily seems to be growing.
Hello again! I have added this functionality. There is a toggle switch in the account settings ;).
YEET! Trying again now
Why would you want to do extra work if there's no benefits?
Wow, was looking for something exactly like this, thank you!
Reminds me of [FUCKITJS](https://github.com/mattdiamond/fuckitjs)
Looks good! The immediate reaction I have is that you should look at [Polly.net](https://github.com/App-vNext/Polly) for further inspiration (and I'm sure other ecosystems have equivalents). Expotential backoff and other retry strategies would be a nice to have.
The option you selected doesn't get passed as a parameter to the function. An `Event` does, which you can get the value of by using e.target.value
Howdy! Biggest curiosity I'm still waiting for is \`custom element\` docs: [https://svelte.dev/docs#Custom\_element\_API](https://svelte.dev/docs#Custom_element_API) Been in between svelte and stencil for our design systems and central components, and this is an interesting part of that.
What makes TS a "poor man's static language"? What makes Go's type system better? The lack of generics has been the main reason I've avoided Go.
You lost me at bootstrap.
My question is, when is sapper enteribgthis game? What about a web redesign? The new site looks great!
Definitly something I was looking for ! I use Nest.js as my application backend and need to fetch some data from external APIs with strict rate limits. This can solve my problems ! Thank you very much (love the decorator !)
&gt; You might want to just compute double once, and you must be able to tell the difference between that and something that can change always. I'd prefer using a baked in language feature such as `const` to declare to the compiler that the value will not change.
Try without https for the URL.
Since you're missing out on JS modules, how do you manage files and include them in the page for dev and for prod? Do you have to do it the old way by manually placing script tags for each file and have everything in global scope, or do you have a better system than that?
This will do what you're asking https://codepen.io/anon/pen/bJjjdq?editors=1111
There is, though: https://www.reddit.com/r/learnjavascript/
Of course there is a r/learnjavascript.
getUserChoice returns "invalid user input" for any input except "rock", "paper", or "scissors". getUserChoice("rock") will make the parameter userInput == "rock" and the function will return the value. The switch statement on userInput is a bit of a mess and as far as I can see will never do anything, because if userInput is "rock", "paper", or "scissors" you return from the function, and the switch statement only runs if the value is invalid. You're not using userNum for anything so I guess it doesn't really matter, but you also shouldn't have that let statement inside the switch like that - the let will only be applied if it's a "rock", and otherwise you just created a new global variable. You probably meant to do `let userNum;` `switch (userInput) {` `case "rock":` `userNum = 2;` `case "scissors":` `userNum = 1;` `case "paper":` `userNum = 0;` `}`
Firstly: /r/learnjavascript does exist. Second: You‚Äôre getting the error because when you call userInput you‚Äôre not passing any arguments. Try something like &gt; console.log(userInput(‚Äúrock‚Äù)); And you should find it works
As for your question, getUserChoice is a function that has a `userInput` parameter. So it expects that when its called, an argument is passed in to give a value to `userInput`. When you call it, you're calling it as: console.log(getUserChoice()) Which passes nothing in. When nothing is passed in (or there is no argument to match to a parameter) the parameter is given a value of undefined which is not in your list of valid user inputs. You can fix this by passing something into `getUserChoice()` console.log(getUserChoice("rock")) Also note that your `switch` in that function is only ever run for invalid inputs because when it is valid, it's returning the value. When you return, you exit the function. The `switch` is also wrong in that: 1) you need to add `break` statments after each `case` and 2) `let` in the first statement will not work for the other statements. You need to declare `userNum` before the switch. let userNum; switch (userInput){ case "rock": userNum = 2; break; case "scissors": userNum = 1; break; case "paper": userNum = 0; break; } You can also skip your initial if-check if instead you use a `default` clause in your `switch` that will catch when none of the other values match. // ... case "paper": userNum = 0; break; default: console.log("Invalid user input."); break; }
From what i can see here, there are two mistakes. In `getUserChoice()`, you need to pass a parameter, which is the user choice. When you're doing `console.log(getUserChoice())`, as you didn't pass the parameter, `userInput` is `undefined`. This happens because your `userInput` variable isn't the same as your `getUserChoice()`'s function parameter (though they have the same name). There are two things to do here: remove the parameter in the function declaration, or use the variable as parameter in the function (like `console.log(getUserChoice(userInput))`) Next, your `switch() case:` is unreachable if the userInput matches the first if. This is because you put that `return` after your if. Try replacing the `return` with that `switch() case:`, it will work.
Ok fair enough, interesting. Of course there isn't zero reversions from TS, but they seem to be in the minority. &gt; making it actively harder to design as you code &gt; the downsides These are certainly things that people bring up against it all the time. I still have no fucking idea what they're on about though. Basically everything that typescript adds is optional when you use it. It's not really forcing you to do much of anything aside from a few basic things in line with ES strict mode. And certainly nothing is forced related to typing, you can implicit any on everything if you want, and any valid JS/ES code is valid TS. So you could use absolutely zero of TS's features if you find them annoying, because it doesn't force you to use any of them aside from a few basic things you might have done loosely in terms of assuming some global objects and stuff like that. So where exactly are these "forced downsides" ? I did have a few thing to figure out in the few few days, but they were mostly just around me misusing how imports/modules/globals working, because I didn't really know proper ES/JS to begin with coming from PHP. They were very much ES strict kind of things that you should be doing anyway. But after that, none of the "typing" stuff that people complain about ever got in my way. Just let it default to `any`, and you're no worse off compared to plain ES/JS.
So, first of all, the switch case is problematic: switch (userInput) { case "rock": let userNum = 2; case "scissors": userNum = 1; case "paper": userNum = 0; } The variable `userNum` will only be available for the `case 'rock'`, and not for the entire function. You don't break after each case, which means that each case will be run through (which is not what you want). Also, the `switch case` statement will never really be useful because when the input is one of rock, paper or scissor your function would return. Then we come to your function `getUserChoice`. const getUserChoice = userInput =&gt; { if (userInput === "rock" || userInput === "paper" || userInput === "scissors") { return userInput; } else { console.log("Invalid user input."); } } The variable `userInput` is expected as an argument. You invoke the function without any argument. It won't use the global variable that you defined. It expects `userInput` as an argument. You failed to provide that.
Isn't svelte compiled? It does check for errors already, so why do u need ts?
I can't claim to know, of course, but it could be because it _can_ be used the same way, and there isn't really a specific function for what reducers do. Maybe? But you're right - the use for Array.reduce has a different purpose, usually.
In my experience, IntelliJ's Intellisense/code completion can almost always determine the members of an object without types even when defined in another module.
If you are writing asynchronous code you may want to consider learning/ using RxJS. You can retry, transform your data, combine data from multiple asynchronous operations all in one library.
Didn't work, I didn't even expect this to work
My issues with TypeScript: \- The syntax is difficult to read. Maybe not \_all\_ the time, but in a sufficiently complicated function/method, it becomes overly verbose and difficult to parse for the uninitiated. \- Default non-standard syntax introduces major risk to projects \_and\_ to developers writing in them. I don't want to have to change every file I wrote to use \`#privateField\` instead of \`private privateField\` at some point. If a project were to explicitly choose to use non-standard syntax and compile with Babel, that's OK because it was a choice, not a default (ostensibly it is intentionally-added tech debt rather than tech debt that is introduced by design). \- I tend to write a lot of web components (as opposed to React/Angular/Vue) which has led me to errors where relying on TypeScript's type checking has actually backfired on me because TypeScript has a difficult time with extended built-ins (which custom elements necessarily are). \- When I'm not writing custom elements, I write in a generally functional format which introduces some issues as stated elsewhere in this thread. \- Most of the errors I run into on the apps I work on are not the kinds types are going to help fix. \- In five years, TypeScript could fall out of favor and there will be a new hotness for build languages and there will be a massive amount of technical debt in projects that have chosen to adopt TypeScript. I believe that sticking closer to the JS standard (or what the browser vendors have chosen to implement) is a more viable long-term strategy. \- Adding new features or syntax through Babel or some other compiler is OK in my book as long as the idea is to eventually deprecate the plugins that have added that syntax as the browsers implement the new features. TypeScript is diametrically opposed to that as much of the behavior that makes TypeScript valuable is necessarily proprietary and can't run natively in the browser.
`$:` is a baked in language feature. It's a label, but nobody uses gotos anymore, and if they do, it doesn't interfere anyway.
why do you think there are _no_ benefits?
what is this debt?
that's hardly using it. also, everything is already `any` by default, when you change a filename from .js to .ts. "implicit any" is what that's called
in what ways does Typescript bloat your code that is different / not present by using Flow?
The issue is that many devs don't know what they are doing. Especially when freshly starting a on a project.
&gt; tutorial "Dynamic Attributes" image made me lol, well played.
imo, an evaluation period for something should be no less than a year before forming an opinion that is worth sharing
the javascript community as a whole could def benefit from having some chill
Seriously, it's a much better abstraction and it's close to something you should be familiar with already (functional array methods).
Your response is fair. I bitched without providing examples - mostly because I was typing on my phone while walking to the office kitchen if I‚Äôm being honest. I will try to remember to give you a response that isn‚Äôt complete halfassed after work.
Its web browser adoption.
First, in some cases you might need to use `let` (e.g., for variables set inside `if..else`, or just for intermediate variables that are not needed elsewhere) but still do not want the value to be reactive. Second, `const` would not enable [reactive statements](https://svelte.dev/tutorial/reactive-statements).
This article explains it well. https://medium.com/javascript-scene/the-typescript-tax-132ff4cb175b Essentially you spend all this time writing typedefs and adding type annotations to every declaration and only see a menial improvements. I don't hate typescript. Typed languages are less error prone thats for sure, but I like to rapid prototype. I would rather spend time writing more tests than writing typedefs and annotations. I've never had a type error using vanilla JS. On my more recent applications I have been using a binary protocol instead of JSON. This enforces all types that leave the client without my having to annotate everything. I only really care about the type when its leaving the client and going to the server.
Will add those docs soon! Basically you just need to pass `customElement: true` to the compiler, and specify a tag name (either as a `tag: 'my-thing'` or as `&lt;svelte:options tag="my-thing"&gt;` in the component itself), and it'll generate a custom element. TODO: make shadow DOM optional, and only auto-register if a tag is provided (currently it's required).
Very soon! Sapper has been a bit neglected while we were finishing Svelte 3, but it's high on the priority list now.
&gt; Since prepack does similar things to what svelte does with component folding Citation needed ;) I'm as excited for Prepack as the next person, but it's far from clear exactly what form it will take when it eventually emerges from Duke Nukem Forever status (sorry Dominic if you're reading this ‚Äî please, give us an update!). Component folding doesn't imply that it will be able to make targeted granular updates in the way that Svelte can, it really just means that you won't have as much component creation overhead.
What is the retry delay? Logarithm, exponential, linear? It would be cool if you could customize the retry algo.
No one will get this :)
I personally love exceptions, and I think Go's error handling is awful. The sheer amount of boilerplate and opportunities for mistakes from having to follow every single function call with an if-statement is truly awful. f, err := os.Open("filename.ext") if err != nil { log.Fatal(err) } // do something with the open *File f // ... f, err := Sqrt(-1) if err != nil { fmt.Println(err) }
What made y'all go this route as opposed to using, say, PixiJS?
I haven't used Flow, I'm just going by someone else's opinion. They claimed Flow was less verbose than Typescript. I can't verify or deny it, I've never used Flow.
That exact same rust code can be written let f = File::open("hello. Txt")?;
I mean, I could go on for a long time so I'll be brief, but firstly you have to understand I don't think typescript has done a bad job bringing types to JavaScript. Given the enormity of the task I think it would be nigh impossible to make typescript as solid a "typed" language as an actually typed language. Error reporting is unclear and often unhelpful, tooling plugins for mocha and test viewers don't work very well, dependencies with incompatible types, typescript versions that break things, TS-node versions that break things, having to set a configuration for how your language behaves... lots of minor grievances. The two nails in the coffin for me though is the type system is all over the place. Most people don't even understand when to use an interface or a type and i don't blame them. And secondly the code is never typesafe. Proper static languages have serialization or marshaling/unmarshalling of data into types. So it's not a typesafe typed language. Plus all that any nonsense. Go doesn't have generics. It can be a pain at times. And sometimes you might have to copy paste something. But overall you realize that most of the time you didn't need generics and your code is simpler for it.
I would want `const` to be statements that aren't reactive, so exactly as you said "not enable reactive statements". Once again, why could the compiler not do the heavy lifting to see that you've created an variable that is not consumed elsewhere?
Mostly because we need *just* these features, nothing else. At this scale, software is very easy to maintain and extend when needed.
Promises handle async code pretty well. You can even have multiple promises resolved at the end using promise.all and combine data using a combination of es6 'let' which is blocked scoped and arrow functions to maintain the enclosing scope. Learning rxjs just for this is overkill and introduces dependency on another library. That said rxjs is useful if you are in need to observer pattern in a complex app where multiple sections might need to listen to updates
That's kinda my point. Typescript doesn't do anything different from js really. It is strongly typing all your values that you mean. While it is a good practice it's different enough to a lot of js developers that is should be directly addressed.
I can only speak to Rust's solution, but in my opinion it's objectively better than JS. Here are two JS solutions. The first is the most common (let's be honest) and just ignores the possibility of an exception, and the second handles it: const f = doSth(); --- try { const f = doSth(); } catch(e) { // handle it } Here are the Rust equivalents (syntax may be off, I'm a bit rusty (ha)): let f = do_sth()?; --- let f match do_sth() { Ok(r) =&gt; r, Err(e) =&gt; 'sth like r', } Note how they're very similar, however the Rust version forces you to acknowledge and handle the error possibility, and it does so functionally. I'm not doing a great job of explaining it, but it's a _very_ nice pattern that you'll appreciate once you get into it. Same goes for the `Option&lt;T&gt;` monad instead of `null` / `undefined`.
Wow, lots of dumb ideas in this thread.
The API should be rich enough to allow you to implement a custom retry strategy. Usecase: exponential back-off
&gt; all this time writing typedefs and adding type annotations to every declaration This just isn't true in my experience :-/
It's opt-in type-safety-assistance, imo
I'd prefer to declare things that aren't reactive rather than things that are reactive. My assumption is the default needs are going to be mostly reactive with non-reactive code being less likely.
I'd prefer `Option&lt;T&gt;` monad like Rust versus `null` / `undefined`. Also surely in this scenario we'd rather remove triple equals and shift the triple equal semantics onto double equals?
Seems reasonable. ü§üüèª
Seems reasonable. ü§üüèª
You want `Array.prototype.find`, `Array.prototype.findIndex`, or `Array.prototype.some`.
No, because it's JavaScript _with types on top_. If you strip out the type annotations _that_ will work, however, hence it's vanilla JS with types.
Newbie with programming but my gut reaction was the same - why not use Promises?
So what is the benefit of mocking every single import then? I'm not sure if you're confusing mocking to some other term, because mocking every single import makes absolutely no sense.
I get the same CORS restriction for both URLs, as expected.
JS got the name from Lisp, which got it from APL
Hi /u/Elektrochecker, this post was removed. Prohibited low-effort content includes: * Questions that are easily Google'd. * Memes, jokes, etc. Please post to /r/ProgrammerHumor instead. * Most images and gifs. * [Listicles](https://en.wikipedia.org/wiki/Listicle), "Curated lists", and similar content. * Polls, surveys, etc. unless from an accredited academic body or trusted source (StateofJS, etc.). Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/LaneHD, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/woahdotcom, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/tom_greaney, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/akhil_it18, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/nullvoxpopuli, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
That's what I'm trying to put into words, \_why\_ doesn't it make sense to mock imports? I'm having a hard time expressing my thoughts/feelings about this in a way that doesn't seem totally subjective
Hi /u/Lorofthin, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
I think you would have to use it to get a feeling for it. There are cases where you need code to execute when some variables change, but the code itself doesn't use the values of these. `$: changedVariable1, changedVariable2, dosomething()` would solve it. This is syntactic Javascript, but it accomplishes something that you can't do otherwise with 'const', or 'let' and it never modifies expected Javascript behavior in some inconvenient way.
The most reason that I don't daily use typing language is that it's hard to coexist with non typed modules or it needs a middleware to interop. That means that I can't slowly transition from es6 to TS or doing only some parts of an application in TS (without duplicating files). &amp;#x200B; Another grudge of mine against TS (and so much more for Flow) is that most of their errors and configuration isn't so friendly for newcomers. &amp;#x200B; I know the good parts and I really prefer TS over Flow (mainly because I had less friction on getting third part libraries without typing) and someday I want to give a chance for ReasonML or Elm (more FP driven)... &amp;#x200B; For faster compilation, I really like that Babel strategy and let \`tsc\` only for linting. And actually I'm using (TS) only for personal projects.
Because the modules you're testing obviously need those imports. Depending on what you're testing, mocking imports would pretty much mean simply rewriting the imports completely. Again, since you haven't really clarified your question, I'm not sure if you mean something else with mocking imports.
Hey thanks for the reply! &amp;#x200B; \&gt; Look into forking the type-checker into a separate process in Webpack. &amp;#x200B; Not an option for those of us on CRA. I work on a pretty large app that still likes to depend on it, and ejecting really isn't an option for us. It's already pretty slow for compiles, so adding Typescript with that only slows things down even more. &amp;#x200B; \&gt; What speciflically are you finding difficult here? &amp;#x200B; Long React typings (eg. \`React.Component&lt;LongPropsInterfaceName, LongStateInterfaceName&gt; | React.Component&lt;AnotherLongPropsInterfaceName, AnotherLongStateInterfaceName&gt;\`. In general, I've found React types to be ridiculously verbose and hard to read, similar to the problems I have with C++ typings. Plus, arrow functions are usually something I'll use inside the render function of a component, and having those typings in there just kinda removes the usefulness to me (often used to wrap a function the right way for a property). &amp;#x200B; \&gt; it's a one-time cost &amp;#x200B; This is sort of where it becomes not an option for me. I can't stop all development just to convert Typescript, cause we're a small team working on a time-sensitive app. That's just not doable, and frankly it's just frustrating as hell to rewrite components in TS. &amp;#x200B; \&gt; if you start from the bottom of the error message &amp;#x200B; This is actually really helpful, thanks! &amp;#x200B; \&gt; How so? Usually the return type can be inferred \[...\] &amp;#x200B; See above. Arrow functions are most useful to me for wrapping other functions in a specific way for a property, and, at least in my experience, the return types with React often can't be inferred well. &amp;#x200B; \&gt; Simple libraries are also really easy to add type definitions for yourself &amp;#x200B; I don't want to have to do this, especially as a Typescript newbie. I don't have any clue what this means or how even to go about doing it, so I just don't delve any further. I don't want to have to write typings for 10+ of the smaller, less maintained packages that some of my side projects depend on. I want to write my code. \&gt; I've heard so many people say this. I used to say this. &amp;#x200B; Yeah honestly it seems like it'd get better with time for me, but the initial "learning curve" with learning to let the compiler scream at you about types just isn't that appealing to me. I kinda get what people talk about with frameworks like Meteor, where they hate that the framework/tool is telling them how to write their code. It's annoying. &amp;#x200B; \&gt; All programmers make mistakes, all teams have weak links. TypeScript protects against this. &amp;#x200B; This isn't wholly true. Typescript protects only against **type errors**, and not anything else. It doesn't protect against poorly written or organized code, code that runs slower than it should, or poorly documented code, and it isn't a good substitution for unit tests. Typescript isn't the silver bullet that will magically fix all of your development problems. &amp;#x200B; \&gt; It's a bit like the parallel discussion that other programmers have about memory safety in C(++). &amp;#x200B; Not comparable. Memory problems are much more common, and often go overlooked much more than type errors. It's also **much** easier to understand the type errors in JS when they happen than it is to understand problems with memory in C++ (i.e. a random \`segfault\` is much harder to debug and find where the problem is coming from than with a type error in JS, as things are often weird in C++ for no reason at all). JS devs usually don't have to deal with type errors at the start when they're learning the language, but C++ is much less forgiving at the start with memory.
``` /* We stringify the arguments in case they're non-primitive values */ const cacheKey = JSON.stringify(args); ``` The implementation is left up to the user but the article doesn't warn the user that `stringify`ing the `args` could incur more processing than this is worth (what if your arguments are huge?.. or an argument has a recursive structure?) I guess readers of the article should know that this is not a copy-and-paste-into-your-code-and-go solution.
Promise / then mostly deal with; do something, do something more when done/failed. But what when you want to continuously listen to events from a data store in multiple locations in your app? What if you want to combine multiple (different) event streams? Mutations in your data? Or even more complex logic. Promises are good for what they do but they can quickly devolve into code hell with more complex logic. I think rxjs helps with keeping logic more readable. Mind you; this can also happen with rxjs if you don't know what you're doing.
&gt;You can have non-deterministic code produce deterministic results. In which case, it's not non-deterministic for those set of inputs, is it?
Since JS doesn't have any notion of access specifiers, my approach is to not think in term of access specification at all. These are relics from other (class-based, compiled) languages that do not translate cleanly into JS if at all. Prefer JS idioms to relics from other languages would be my advice.
I guess the function you pass into array.reduce takes a state arguement (the accumulator) and defines how the current value is applied to. Which is similar to a reducer but applied to items in an array, although that explanation disregards the "action" and "payload".
Don't think so. Most importantly, web components don't solve for storage. &amp;#x200B; More importantly, frameworks are beyond just 'how do I make this thing function', they're about organizing it in sensible ways and trying to simplify complex domains. It isn't any easier to plan and execute a large software project with web components, it's just a new way of containerizing and splitting up JS that is native to the browser. &amp;#x200B; Personally I'm more excited about existing frameworks leveraging these to speed things up. If React had to create a shadow DOM, hopefully a native shadow DOM would be an upgrade for them.
then shouldn't my other post about why people wouldn't use typescript also be removed? I'm confused. But LearnJavascript has like.. 1/10 as many subscribers, and I wanted as many opinions as possible :-\\
Because \`array.reduce\` reduces the array to a single value. At least that's how I've always thought of it. I think they're related because \`reduce\` uses a reducer function to reduce the array into a single value. So you could call an \`add(a, b)\` function a "reducer" and pass it to \`array.reduce\` to "reduce" an array of numbers into a single number. Though I'm not familiar with the concept of "reducers" in other languages.
Sure, I was just giving component folding as an example of an optimization, as well as yes prepack has been coming for a while. Let me clarify my question I guess, and I am not trying to be a naysayer, but genuinely asking. Is there something fundamentally different happening with svelte that I am missing? Because I know optimizing class based components at a compiler level is very difficult, and that is a reason why React and other languages have been moving to only functional components. If you write pure functional components in React, theoretically couldn't there be a compiler that does the same optimizations? Because when I run through your talks, the water gets a little muddied to me, and I have concerns about locking myself into an ecosystem that does EVERYTHING because of being burned by that in the past. It talks about notifying you about accessibility when writing code... but I already get that from eslint rules, which I can configure to my liking. It talks about CSS scoping and using JS variables in CSS... but I get that already with emotion(and I am a bit scared about removing my CSS even farther from its natural state with this compilation part). So it really boils down to the performance improvements, and I am not currently hitting performance issues with React, and if I write my React code in a good way, couldn't I theoretically get these compiler optimizations for free at some point, that was kind of my thought process with switching to hooks? I almost wish it was a little less all in one, and more of a drop in replacement, because in my experience over time is each different component evolves and you might want to switch from one thing to another without changing your entire stack, if that makes sense?
While loop?
These look like they‚Äôre from a test you‚Äôre taking...?
They are hw questions
If you want real encapsulation, and you don't want to wait for the private state proposal, then weakmaps are the best answer IMO. Closures require restructuring of code and become very hard to think about IMO. ```js const barField = new WeakMap(); class Foo { // or function if you like constructor(bar) { barField.set(this, bar); } myLittleMethod() { console.log('Doing stuff...', barField.get(this); } } ```
Strict vs. dynamic typing...arg! The same religious war over and over... How about you can set a flag per project/file that demands that included code meets that requirement? So, if you want strict typing, the engine will barf at dynamic typing, and if you want dynamic typing, strict typing will continue to work...just without type checking. "Why can't we all just get along?" [https://www.youtube.com/attribution\_link?a=KPfk2nSZqrc&amp;u=%2Fwatch%3Fv%3DMPMmC0UAnj0%26feature%3Dshare](https://www.youtube.com/attribution_link?a=KPfk2nSZqrc&amp;u=%2Fwatch%3Fv%3DMPMmC0UAnj0%26feature%3Dshare)
That makes sense. I'm on the side of "magic" as I want the compiler to do as much as possible, but understand the apprehension of magical behaviour.
‚öìÔ∏èüé£‚Ü™Ô∏èReact-Redux v7.1-alpha is now available.... AND IT'S GOT HOOKS!!!‚Ü©Ô∏èüé£‚öìÔ∏è We've added hooks like `useSelector()` and `useActions()` to our public APIs. Try them out today! Release notes: https://github.com/reduxjs/react-redux/releases/tag/v7.1.0-alpha.1 API docs: https://react-redux.js.org/next/api/hooks
Maybe take a stab at answering and someone can tell you if you're on the right track?
Yea these arnt super hard. Do some googling and try to find it on you own. If you still can‚Äôt then I will help you out. But google skills are gonna be key to be a dev
Im thinking 1. Passing by 2. Variable is used to store data 3. I have no idea
A promised-based module rejecting a 500 rather than resolving is a fair implementation IMO. If you disagree with that, you can define you're own acceptable range with *validateStatus*.
1. Invocation 2. It‚Äôs an index 3. I have no idea what the question is here and the code is terrible, so you‚Äôre on your own with that one.
A map tree is a better approach. More performance and you don't need to stringify. WeakMaps if you don't mind to compute the values again if you are low on memory.
I know this topic has been written about a lot over the years, but the whole thing with the TC39 choosing 'globalThis' as a name for top level context made me want to revisit it to give my own spin on explaining what the problems with 'this' are and how to avoid them in 2019.
Yes, but constructors are key to creating objects, and I think other people messing around with the properties they aren't supposed to mess around with isn't the best idea.
That's what closures are meant to solve. But closures work in terms of scope control rather than access. Ultimately it gets you there in a different way
Wow, this is cool. I like closures because they look pretty and provide more flexibility than class syntax, but this is a great way to implement private properties. Really cool!
Thanks a lot. I have one more question. Javascript function may contain special variables to recieve values. What are these variables and values formally called? Im thinking its parameters or objects
Parameters is correct. The parameters of a function make up its ‚Äúsignature‚Äù.
Thanks so much. I see a gold in your future
Yeah. I guess it is just two different sides of the same coin. The other thing I don't have a clue about would be protected properties.
No need. I don‚Äôt buy this whole preachy attitude when people ask for help. Homework, actually work, who cares. You‚Äôre stuck, you‚Äôve asked, help the man. Good luck with whatever this was for üëçüèª
No such thing. Don't think of them as properties bound to an object. Think of them as variables bound to a function closure only.
I suppose. It is a good emulation of private properties, but it isn't actually private properties.
finish your math degree and go into research - you‚Äôll make far more than you ever could as anprogrammer
What type of research? I actually like assembling software more than math and implementing linear programming. Linear Programming is used in R&amp;D but it's really just using python as a super calculator not so much solving logical issues. Discrete math and Logic puzzles are where my interests lie.
That was wonderful to read
Dude listeno the talk on youtube. You have a virtual dom. Even in inferno or any other fast fw. Svelte have no virtual dom. Check the huge demo on react concurrenr vs svelte..... I get it. React is trendy and backed by facebook. So what? That does not mean it's better, face it.
I never said they do, I simply said that for OP's one use case ESLint does a much better job at solving the specified problem in my personal opinion. Please, read my message fully and the context it is in before making assumptions.
I am 9 years in, completely self taught, no degree, working as a technical architect. You can make good coin as a programmer but you‚Äôre basically going to have to learn everything you would in a CS degree in order to get there. Might be worth switching courses and getting the practical stuff out of the way early.
If you add a forward slash on the end of an unpkg url it will give you a directory listing, eg: https://unpkg.com/typescript/
Critical security vulnerabilities will be patched.
Hey ;-) Quick reminder: React did not create a Shadow DOM, they implemented a virtual DOM. Those are completely different things. https://mobile.twitter.com/hsablonniere/status/1116053468354088961 https://mobile.twitter.com/hsablonniere/status/1116053470820352006
You're right my mistake, I already know the difference. I still think their virtual DOM could use the new Shadow DOM by preparing components in the background before they're needed.
I went to school for design and taught myself how to code. Now I‚Äôve worked as a developer for the last 6 years. All of my coworkers are in the same boat. You can definitely do it with no degree. People only really care how well you can do the work and not about the degree.
That's like saying Coffeescript isn't much to learn beyond JS. Except that's a bad comparison because TS introduces a 100% foreign concept to a dynamic language. Of course it's a lift to learn! Your way of thinking changes and all the JS code you find online needs does not contextualize those concepts at all. &amp;#x200B; The person just said they don't want to exert extra effort when learning vanilla JS. Saying it's easy to learn is basically grandstanding.
So is this somewhat similar to Lit HTML but more fully featured. Is this building webcomponents or does it have the option to create web components?
Ah shit, here we go again
Thanks. I wasn't familiar with the "?" syntax. Looks like they added that in 2016? My first thought was, "Nice, that makes it a lot easier to propagate errors." And my second thought was, "Wait... wasn't that one of the complaints against exceptions? Right in this very thread? That they interrupt control flow?" I also think you're going to end up writing an awful lot of those "?"'s. There are far more functions that can fail than not. I looked at some examples in the Rust Cookbook. Every [file](https://rust-lang-nursery.github.io/rust-cookbook/file/read-write.html) open, read, write, print, all need "?"'s attached. Or if you're doing [networking](https://rust-lang-nursery.github.io/rust-cookbook/net/server.html#listen-on-unused-port-tcpip), every listener, getter, or read all need "?"'s attached. [Parsing a URL](https://rust-lang-nursery.github.io/rust-cookbook/web/url.html#parse-a-url-from-a-string-to-a-url-type) needs a "?" attached. And so on. Personally, I think errors should propagate by default without having to litter your code with "?"'s everywhere, at which point we'd be back the the behavior that exceptions provide.
Mosaic alone does not create web components, however there is a function to convert Mosaic components to HTML elements. You can use the resulting element to create web components in your own application.
Surprisingly important
These are valid concerns! I'd argue that the lock-in situation isn't that much different from React (or Vue, Ember, Angular, whatever), but I hear where you're coming from. You certainly can use CSS-in-JS with Svelte ([https://svelte.dev/blog/svelte-css-in-js](https://svelte.dev/blog/svelte-css-in-js)), but a compiler that is aware of the structure of your markup as well as your CSS has the opportunity to get a lot smarter about things. (We're not taking full advantage of that yet though, just doing basic dead code removal etc.) And Svelte stores are very simple and portable, and work well with Redux, Immer, etc. If you're not hitting performance issues today with React, that's great ‚Äî I wouldn't advocate that someone rewrite an app that's working well. I do believe that there are some important trends we all need to be aware of: firstly, people aren't buying faster phones, they're buying *cheaper* phones. Secondly, user expectations are getting higher all the time. Thirdly, front end development is going to shift towards even lower-powered devices as the IoT market continues to boom (for better or worse). \&gt; Is there something fundamentally different happening with svelte that I am missing? In JSX, it's extremely hard ‚Äî impossible, in some cases! ‚Äî to know what's inside this expression: `&lt;p&gt;{literallyAnything}&lt;/p&gt;`. Does that expression evaluate to a component? An element? Text? A fragment? An array, containing... what? Because Svelte is more structured, the compiler can generate code that's highly optimised for each situation; it knows the possible states of your app ahead of time. With JSX, you just can't do that. Prepack gets you part of the way there, by literally 'running' your code, but it's not yet clear whether it'll be able to shift work to the compile step to the same extent. It's a much, much harder problem.
?
So what‚Äôs the selling point ca a react or litElemrnt?
Is Javascript and a modern library the only possibility or could I squeeze through the Java door?
Been thinking about this, as it seems to be a common complaint against Web Components. Personally, I've been using a separate module to import that contains template literals of my HTML/CSS - which I feel solves the decoupling of controller and view. To track component state, I've been leaning on attributes pretty heavily, especially given the attributeChangeCallback in the WC API. If you then use the light design pattern of reflection (which makes produces the same results whether you get/setAttribute or use JS dot notation to get/set the property). If then you need intelligent diffing to only change the HTML you need to change, I understand that lit-html handles this really nicely, though I'm not necessarily sure that an individual Web Component should be big enough to warrant this concern. I'm genuinely curious if there I'm missing something, especially because I skipped over React and went Web Components. I know I'm not using a framework, but also don't feel like I'm missing out for my needs.
I've taken two C++ courses, data structures, and a C programming course. I have worked with production databases, understand Linux administration, and I also understand Docker, kubernetes, and basic OS virtualization. Would this be a decent block to jump off of? My school has a poor CS program and I have learned more than I ever would have working, than taking any of their courses. The only things that would be relevant would be AI ML, or some of their computer vision stuff. However, these are theoretical courses with minimal python involved.
Unlike with JSX, Mosaic does not require a compiler since it uses tagged template literals. It is also more of a complete library than lit-html, which is more of a templating system. Mosaic also comes with an official client side router and global state manager.
I don‚Äôt really know anything about java. JavaScript and java are not the same at all. Modern web development tends to be rely pretty heavily on JavaScript.
This is a moronic comment, when did I mention anything about trendiness?
Rejected Promise != Exception. Rejected Promises are not used solely for undefined behavior.
Great project! One thing I noticed: the CardEditor.jsx component is super huge. I would recommend splitting it up into more files. For me, 'card editor' is more like a module. Maybe a folder 'cardEditor' containing all its components.
So, its not js hahahah.
That's like saying why use promises when you can just use callbacks?
 That's helpful considering I started with "newbie here" üôÑ
Okay gotcha! Thanks for the explanation, should‚Äôve read your docs more thoroughly haha I‚Äôll give it a whirl soon
One downside with closures is their privates can be _too_ private. It makes it impossible to implement, for example, an `isEqual` method. function createThing() { let somePrivate = 42; return { isEqual(otherThing) { return somePrivate === otherThing.???; } } }
Isn't HTML + CSS + JS web components a thing for building user interfaces? We also have React and Vue and Angular. How is this new thing any better?
`typeof null === "null"` `"strict mode";` is by default, a stricter mode (similar to Google's attempt) would be opt-in Delete `var` Related to JS but actually browsers: remove 80% of the outdated/deprecated DOM, so that you can't shoot yourself in the foot any more
Rejected promises are the same thing in JS land. If you use await you'll have to wrap then in a regular try catch
It would be fair if http was an RPC protocol, not Hypermedia-based.
Null and undefined are semantically different, though. I‚Äôve never understood the desire to consolidate.
\`\`\` delay?: number The duration in milliseconds between each attempt. Defaults to 0 If this property is not provided Reattempt will perform a reattempt as soon as the function fails. \`\`\`
lol wat ‚Äúthe other‚Äù? `const` is the correct declaration a vast majority of the time.
I forgot to answer the part about the go type system. It's just much less complicated. And it's type-safe. It just feels good to write in. Not much clutter. I would give it a try. Although you will find it to be a low level language compared to JavaScript.
There are a couple of things already existing in this area, I personally used QOwnNotes for a while. What do you think separates your app?
You don't need to do that. That sounds more like a complaint about modern JS development than React as a library.
You can also use symbols as a form of private access. const barKey = Symbol('bar'); class Foo { constructor(bar) { this[barKey] = bar; } myLittleMethod() { console.log('Doing stuff...', this[barKey]); } }
There should be a better backoff system...
I could see the confusion. If the title was ‚ÄúWhat is a reducer‚Äù I do not think the same confusion would arise. If someone is familiar with the concept, it would be pretty easy to think ‚Äúthey are different in JavaScript?!‚Äù
The lockin situation I meant was more about one, compile based framework, that does everything. With React it really only has opinions about how you structure your components, but doesn't care about CSS. Vue is a different story. I would be curious to see some more in-depth examples of where specifically it does things faster than React, I might dig into your benchmark to see the differences, because im curious at the end of the day the use cases where it creates the benefits, because that would cause me to switch. The issue is theres a lot of selling points on the site about things that you can already do in every other framework, so that doesn't make me want to switch, and then some benchmarks, which have become very hard to trust. I am still not 100% understanding what theoretically something like prepack couldn't do, especially when your templating language looks so similar. Is it because JSX is too flexible in allowing you to render anything, and your templating language is a more rigid so its defined to the compiler? Along with things like useMemo. You downplay stuff like useMemo, in which you say, basically now you don't have to worry about using that stuff. But I know cases where sometimes its faster to memoize, and sometimes it isn't, is the compiler able to differentiate these cases? Same with like useEffect(or shouldComponentUpdate, or whatever). Those functions give you control because sometimes it is faster to use it in one way, and other times its faster to use it in other ways, I am kind of curious how the compiler can always be right, or if its making its best guess. If it is making its "best guess" or the best path past for the average use case, but then you don't have tools like shouldComponentUpdate, aren't you theoretically losing out on performance you could have gained if you knew how to use them properly? Sorry might be a dumb question.
Nothing. That fact that JavaScript is backwards compatible back to the beginning is an amazing accomplishment and one of its strongest features. What would I _add_ to the language? More functional stuff like the pipeline operator and assimilating the remainder of underscore/lodash/ramda.
I say it, not you. And again, even optimizing, virtual dom.
It really just depends where you want to work and what you want to do. If you‚Äôre looking for larger companies like Microsoft, Netflix etc. then I‚Äôd say a CS degree will help you. Otherwise you‚Äôre probably good to go if you‚Äôre just wanting to cut code.
My god that‚Äôs an awesome package, thanks for the suggestion!
&gt; Remove exceptions from the language. Pretty much every modern language has exceptions. While I agree it can be abused, it is a very useful tool used in the right circumstances. Removing a useful feature simply because it has the potential to be misused is a horrible idea. &gt; While I do see merit in the Class syntax and additions of the OOP ilk, I think introducing more constructs to the language is for the most part an unnecessary complication, so I'd nuke that. Again, I don't understand this reasoning. First class OOP support makes JavaScript more useful. As a user of the language, how does an additional, completely optional feature a "complication"? Additionally, I don't think the original features of JavaScript should be seen as some kind of static benchmark that it should always be compared to. The fact that it didn't initially have classes is irrelevant, and taking the current feature set of JavaScript as it is, it's very far from being too complicated. &gt; I prefer when there's a small set of idiomatic solutions to known problems, rather than layers of syntax sugar which achieve very similar things. In my opinion, classes are an objectively superior abstraction over the prototype model. If we are going for one over the other, I'd say forget that the prototype model ever existed and fully embrace classes as the single idiomatic solution.
Promises are literally syntactic sugar for callbacks. Saying you shouldn't use RxJs when promises work just fine comes across as "Why change?! This works!" There's typically a reason there's a new way to do it. RxJs comes with a LOT of features that promises don't. But at the end of the day, I could still write it all with callbacks.
I mean virtual dom or no virtual dom, there has to be some sort of state management structure, thats why I am trying to get at the heart of the differences here. One of the reasons you use a virtual dom is so you can batch updates before writing to the real DOM, as you don't want to write every single change to the DOM if there is more changes coming down the pipe within a certain time. Virtual DOM is just an advanced state management representation of the state of the DOM, I understand they are saying there is no virtual dom, but they still have to store and manage all that state. Which is why I am asking questions, The framework docs doesn't give a lot of in depth answers to exactly what cases it is better, and it talks about a lot of features that are available already in React/Vue/Whatever. I am trying to understand exactly what makes it so much faster, especially compared to similar things like prepack, which say they accomplish similar goals.
Really bad if true! Relatedly, [Google is apparently retaliating against employees](https://www.wired.com/story/google-walkout-organizers-say-theyre-facing-retaliation/) who organized the recent walkout there. I hope the former employees win their complaints, just like those [fired from Lanetix for unionizing](https://www.bloomberg.com/news/articles/2018-11-10/software-startup-accused-of-union-busting-will-pay-ex-employees).
As far as I understand it it is much more simple. The compiler seems to compile each component to individual pure JS no virtual doms are used and as the videio tells, a $$invalidate function is called (check the compiled code in the video is shown). That function would just update the dom node. I have to try it out, but from the video i got pretty exited, and i was already willing to try the older version...
If you have to ask it‚Äôs probably too much :) Mainly it‚Äôs about functional intent. You separate api calls because you need different data at different times, or need to refresh different things at different times. So some of the answer has to do with intent. Also if you‚Äôre fetching hundreds of records you may want to introduce paging.
That's fucked, unions needs to be waaay stronger in IT in general but this kinda stuff is why it's so hard
Hi /u/johnjohn1477, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
The trade offs are either fewer requests so less 'back and forth' between the servers or calling and having to hold the page waiting on data that isn't necessary for initial render. You should think about how the page is structured. Are you pulling 2nd and 3rd tier data in the call and it's slowing the page down? If so, split out the information that the user is willing to wait on. Remember, don't test your website on the fastest possible internet, instead check what you expect slower internet to be like (phone internet as an example).
Math degrees are highly practical in dev work today. Especially Data Science dev work. Also degrees are becoming more and more important with modern tech like machine learning. You can find a job without one, but coming into the market today I'd definitely recommend pushing for that degree to anyone whom asks.
I like groovy for this reason. Dynamically typed, unless you specify you want classes to be @compilestatic and @typechecked. Its my favorite happy medium.
You'll find that you can find a job but you may struggle finding a good one. I also do not think you need to change degrees, look at data science which is super hot. If you can do python and have a math degree you are hire-able if you know things like logistic regression. Salaries are dependent upon where you are looking and exact degree. I think you will struggle to find a 70k a year job without a degree. You could find a lower job that builds experience. You really should finish that degree though, it'll make you so much more.
All I can do now is brainstorm anti-npm chants. &amp;#x200B; "npm / does workers harm / that's why I'm installing yarn" "npm is out of line / \`unionBust\` is undefined"
We need an alternative to npm hosting.
Those Commie bastards can take their Marxist bullshit to Stalin in Hell. "Progressives" really are abhorrent.
I wonder if there‚Äôs a disconnect between the definitions of ‚Äúretaliating.‚Äù Doesn‚Äôt look like organizing a walkout is protected under the EEOC. https://www.eeoc.gov/laws/types/retaliation.cfm
RemindMe! 2 hours
I will be messaging you on [**2019-04-23 02:22:27 UTC**](http://www.wolframalpha.com/input/?i=2019-04-23 02:22:27 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/javascript/comments/bg79fo/npm_layoffs_followed_attempt_to_unionize/eljbnlk/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/javascript/comments/bg79fo/npm_layoffs_followed_attempt_to_unionize/eljbnlk/]%0A%0ARemindMe! 2 hours) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Hey hey, ho ho, lay us off and we‚Äôll learn Go
These are amazing, dont stop now
"all for one and one for all / `npm uninstall`"
google is one of the most far left companies out there, holy shit their workers live in a bubble
Google is not "far left." It's a contradiction in terms to be a "far left" company and be run for shareholder profit, not to mention the way they treat their workforce, this very story demonstrates! &amp;#x200B; Anyhow [here are the demands made by the walkout organizers](https://www.thecut.com/2018/11/google-walkout-organizers-explain-demands.html), for reference.
Well if that's the case and it writes every change to the dom then that's fine for some use cases but not all, and react would give you a lot more performance in many cases because you can batch renders in complex apps, as well as prioritize certain renders over others(fiber), is it really as simple as you are saying because that doesn't sound very good.
You can always a private property read-only with: ``` get myProp(){ return myProp; } ``` But yeah, you are right.
TIL Canada isn't immune to racist inbred rednecks.
Why don't you consider pooling of resources at the worker level part of the "free market"?
https://techworkerscoalition.org/
Hi /u/LifeDebate, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
"Far left" just means "people who don't like racism" or "don't think social programs are bad" to some Americans
There are so many things Web Components just don‚Äôt solve for and based off the current standard I‚Äôd say many they don‚Äôt plant to either. Also, Web Components fail miserably at being declarative in nature and are far too low level to add any meaningful abstraction to a devs workflow. Their global reusablility is still in question as handling events on controlled Components is a pain due to their implementation of the shadow dom. Unless some significant changes are made I don‚Äôt see that happening ever. Even then, nah.
When politics meets /r/Javascript. A rarity indeed. But for real Reddit is basically the HQ for western liberal thought... soapboxing about Marxism here is hilariously ineffective.
You can thank unions for the 40 hour work week and labour protection laws you bootlicking idiot.
Does Svelte support SSR without using Node? Ie, if backend is written in Go or Python, can it share templates with Svelte and render on both server and client?
Why don't you cut the activist bullshit out and stop trying to "change the world"?
What do we want? Yarn! When do we want it? Now!
"Western liberal thought" is an oxymoron. Shutting your brain off and screaming "Drumpf! Free shit! Everybody that's not me a Nazi!" is the pinnacle of Western liberal "thought."
Find me a union man that will openly and unapologetically reject Communism and I'll show you a god damned unicorn. I'd love to be in favor of iron-clad labor protection laws (including sharp-as-hell punitive measures against violators), collectivization of tech workers, and nation-wide accreditation programmes, but I just can't get past the Commies, progressive supremacists, radical feminists, and open-borders pro-EU lunatics.
+1 to retry strategies
Oh here we go, the Stalin apologists. Funny how all the rats come out of the woodwork whenever their holy word "Communism" is denigrated.
To be the Debbie downer...I think you‚Äôre confusing npm the command line tool, with npm the package registry. By switching npm with yarn are just switching the command line interface that you use to connect to the npm registry. It would be like ‚Äúboycott google, don‚Äôt use chrome, use Firefox to access google.com‚Äù
I honestly have no idea what you're talking about. But, I am [no fan of NPM](https://twitter.com/maybekatz/status/771876666326908928). That doesn't make you any less of a [racist](https://i.imgur.com/gEUjCsu.jpg) inbred redneck nutcase, though.
If you are going to go down that road it would be best to avoid rejecting ever and instead create an ADT for error/result with a tagged union. Or you could be pragmatic and take advantage of the control flow that promises give you.
meet the new boss. same as the old boss.
Find me a union that will openly and unapologetically endorse communism.
Probably the most underrated comment in this thread.
You're a special kind of stupid, aren't you?
&gt; ‚Äúboycott google, don‚Äôt use chrome, use Firefox to access google.com‚Äù &amp;#x200B; That's a really bad chant, though
"Gamer-Americans"
If anyone can get access to a private property, then it isn't private. ;-) Your documentation would need to tell users not to actually use this getter for anything. Or, to communicate the same thing with code convention, you could name it with a prefix underscore. ;-)
No thanks. I don't like stagnation.
Hell no. That's quick ass way of reducing salaries all around. Making it impossible to fire people without spending a shit ton of money is not favoring the workers.
Hi /u/warriorCode777, welcome to reddit! Unfortunately, this post was removed because you are a new user. This is a spam-prevention measure, we hope you'll understand. You'll be able to post in a few days, however, you can start commenting now! We'd love to get to know you. In the meantime, please read the site [reddiquette](http://www.reddit.com/wiki/reddiquette) and [/r/javascript's guidelines](http://www.reddit.com/r/javascript/wiki/index). Also, **/r/javascript is not a support channel.** For help with javascript, please post to /r/LearnJavascript instead. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
Lol were you dropped on the head as a child?
Yeah, I suppose weakmaps are better.
I would just go with a flag of some sort stored in local storage. This flag would have something like 'modeType' which would equal your mode. Then upon document load, I would do some sort of css hotload based on the modeType.
So much of my stuff is there.....
&gt; I would want `const` to be statements that aren't reactive, so exactly as you said "not enable reactive statements". I think you misunderstood -- click the "[reactive statements](https://svelte.dev/tutorial/reactive-statements)" link and you'll see what I mean. The `$:` label is used not only for reactive variable declarations but also for arbitrary reactive statements and code blocks (so the entire code block will re-run whenever anything it refers to changes) -- `const` would not help you there. In other words, we still need something like `$:` for reactive *statements*, so might as well also use it for reactive variable *declarations* as well. &gt; For a let variable that is for an if/else you could also use `const obj = {val: null}` and mutate `val` That's somewhat of an ugly hack just to avoid use of `$:` in favor of `const`. &gt; or use ternary Sure, but not always viable. &gt; which is why I think reversing `$:` to declare non-reactive ambiguous statements makes more sense than a slew of `$:` for reactive statements. OK, but that's different from preferring to use "a baked in language feature such as `const`," as you originally stated.
Marx and the left in general has had a huge influence on the [The Western Tradition](https://i.imgur.com/aUQRt8D_d.jpg?maxwidth=640&amp;shape=thumb&amp;fidelity=medium)
US unions lean so heavily on seinority &gt; that having anything to do with them worries me.
Considering USA is neck deep into bipartisanship and their "left-wing" Democrats would be considered to be center-right in the vast majority of countries, this is not surprising.
What would unions get IT employees? They're already paid higher than most industries. They have better hours than anyone in the medical field. Tech companies started the notion of "take whatever vacation you need." The offices are generally nicer than most places. I don't understand how a union benefits IT professionals.
This is neat! I've been thinking about putting together a React+Electron note-type app myself, and then this popped up. I downloaded the binary for Windows, and here's my first impressions: * the menu navigation doesn't have Tool Tip text, which threw me off * the window should have opened up taller, because I had to scroll down to the "submit" button, causing me to lose my first note when I assumed it would save my changes when I clicked the 'X' (maybe have a submit button on the top row, as well?) * checking a todo in the view pane causes the markdown to update properly, but unchecking the todo doesn't (glancing at the commit log, I think this maybe was fixed and the patch hasn't made it to the binary yet?) &amp;#x200B; I'll keep playing with it and come back with more. Good work!
I'm not really sure how making firing people expensive leads to lower salaries. If anything the more logical result would seem to be _higher_ salaries if you need to make damn sure you're not going to have to fire anyone.
Seems weird to comment "you don't need unions, everything is fine" in a thread about a company fucking over workers for bad reasons.
I read the article. It said they were fired for trying to unionize, but didn't say why they wanted to unionize. My question is why would they want to unionize?
&gt; Promises are literally syntactic sugar for callbacks They have some significant differences. I agree that doing a bunch of `.then()` calls chained on each other can serve a similar purpose as some uses of callbacks. Callbacks don't have, e.g., a built in pollable resolution state. Promises have more overhead in terms of memory usage and garbage to collect. But I agree with the overall sentiment.
It emits a blob of JavaScript with a \`render\` method (either as CommonJS or ESM). So it needs JS to render, but not necessarily Node.js ‚Äî I expect you could persuade a different interpreter to work with it. On [https://svelte.dev/repl](https://svelte.dev/repl), if you click the 'JS Output' tab in the top right then select 'ssr' in the bottom right, you can see the code it generates.
Who cares how nice your office is if you work for a company that's known for sudden restructures and laying off workers over 45 years of age to keep younger, cheaper employees.
I believe updates are async and batched: https://github.com/sveltejs/rfcs/blob/master/text/0001-reactive-assignments.md#sync-vs-async-rendering
I never realized NPM was an actual company.
I was about to make an NPM joke but realized this actually has to do with NPM carry on
Do you? I've gotten on fine without it.
How do?
lol
Yes, 'flexible' is the word. It's the [Rule of Least Power](https://en.wikipedia.org/wiki/Rule_of_least_power) at work. Think about all the places where you can use JSON that you can't use JavaScript; all the ways you can analyse it, reshape it, put it to different purposes, use it in different languages. Svelte aims to thread the needle by having flexibility where it's needed, but also being amenable to the kind of thorough static analysis that JavaScript resists. It's not so much that you no longer have to use `useMemo` (though that is important: you basically need to use the official linter to use it safely, judging by the conversations I see on Twitter). It's that `useMemo` *itself* has a cost: every time your component is re-rendered, the first argument (the closure) and the second argument (the array of dependencies) have to be regenerated, *even if nothing changed*. It's a garbage collector's worst nightmare.
The `$$invalidate` function, which is called after an assignment to local state, marks a particular value as 'dirty' (unless it didn't actually change) and schedules an update at the end of the event loop (unless an update is already scheduled; i.e. changes are batched but take effect before the screen repaints). The update code is given an object representing which values have changed, meaning that everything gets updated in one go but it can trivially skip entire subtrees, with arbitrary granularity.
You can create private properties using closures. And you can create a *sort of protected* property by (instead of a variable) creating a private object inside that closure, and assigning properties to that private object with getters/setters to define the property behaviors. You can also use the `Object.create` or `Object.defineProperty` to set certain restrictions on object properties. In a sense, you could do all of the above using closures, if you use the right patterns.
Perhaps relative to Europe our Democrats are right, far right? But that misses the point. You can't change a political landscape all at once, so to constantly compare US Democrats to Europe is not very useful. We'll always lag behind. And that's assuming we should try to keep up at all. Not everything Europe does is good or right, nor can all of it be directly translated to the US. I think a lot of people on here would love it if we just copied everything the EU would do, forgetting that the US has a different culture and sudden culture shock could crumble the country. I also don't agree with wholesale adopting European countries idea of center or center right or whatever benchmark stick we're using these days. Look at candidates like Bernie Sanders or Elizabeth Warren. There's not a single social program they don't like, regardless of cost or ability to pay for it. There's got to be a balance between letting people die in the streets for lack of health care and... Free everything for everyone.
1. Working very long hours and weekend. Most tech workers will tell you they feel burnout regularly. 2. ‚ÄúUnlimited vacation‚Äù is a trap and people who work in companies with an unlimited vacation policy end up taking less vacation than those who have a set amount of time (eg 2 or 3 weeks) 3. Job instability like you can see in this very specific example I work in tech. Sure the nice offices are a nice perk, but it‚Äôs a much cheaper thing to do for the company than to actually give rights to the workers.
I don't like solving problems by brute force.
Hey look it's the person who doesn't work for a company with modern practices telling us that they are just fine with including jQuery in the index.html Please stop junking up threads like this
Guess I've been lucky on 1 and 2. Point 3 seems hard to help with since so many organizations and companies disappear in tech due to thr industry moving so fast.
This happens at large organizations that have been around for decades too. Amazon, Apple, Google were all created in the late 90s. Microsoft is over 40 years old. IBM is even older.
Why?
So we can take our money elsewhere if companies are up to no good.
Oh yeah üëç
&gt; they are just fine with including jQuery in the index.html Like copy-paste it? Or using script src? Because I don't think anyone would or have heard of anyone inlining jquery in an html pages. And I don't see a problem with using jquery in any pages including index. So I'm pretty confused on this comment.
No tech company is or will ever be on board with its employees doing anything resembling unionizing. Sure they virtue-signal support for all kinds of leftist causes, right up until the point where it would start costing them significant money. That is where their support abruptly stops. Green is the only color that matters in the corporate world, and tech unicorns are not exempt.
There‚Äôs nothing wrong with getting cheaper workers. I shouldn‚Äôt be paid above what I‚Äôm worth just for being old. If someone younger can and will do it for cheaper, there‚Äôs nothing wrong with that.
Unions never stopped layoffs. If anything, they accelerate them. See GM for reference.
It's fucking sad, my province just elected a party with a massive bigotry and racism problem.
I‚Äôm not sure what the comment above said, but inions aren‚Äôt really the same as pooling resources in a free market. That would be more like a contracting company. They pool their resources, but the hiring company can decide if they want to hire them or some other group of workers.
Unions stifle growth by following seniority like it‚Äôs the Bible.
When a union goes on strike, can the company replace them all or are there laws against that? If they can, then yeah, it‚Äôs pretty much the same. If they can‚Äôt, I don‚Äôt think it‚Äôs the same as pooling resources in a free market.
You sound like someone who is hard to work with.
Right, so to me, sure there isn't a Virtual DOM but there is still a state object somewhat reminiscent of a Virtual DOM, a collection of state of the UI and all associated props, however as I understand it can be linked to another level of granularity, where it sounds like it looks at each variable and how it links to each node, as opposed to variables linking to all the nodes associated with a component, I get the optimization there. I was just pointing out to the OP that this isn't some magic and sure it's not a VDom but it is still doing comparisons on a state object which represents the UI, but it's more tightly coupled. Is that analysis right?
Modern practices involve bundling your code and its dependencies in a single .js file, so you can get consistent page load speed, and keep tabs on the versions of the dependencies among other things. It's looked down upon to rely on dozens of CDNs to deliver your libraries, since it can comprise your page performance (varying latency, etc.) Using jQuery is not the issue u/leeharris100 brought up, it's the malpractice of dependency and page performance management.
Right but there is some cases where you don't want to memoize right? So is yours just internally memoizing all the time? Thats where I get confused. &gt; the first argument (the closure) and the second argument (the array of dependencies) have to be regenerated, *even if nothing changed*. It's a garbage collector's worst nightmare. I had this concern about hooks as well, but I've never seen a benchmark that ever shows this as becoming any sort of bottleneck because generating functions is very cheap and does not actually create a big problem with the garbage collector. I would guess you would point at embedded devices, but is that really the bottleneck there? I would think if you were doing something serious in an app you would probably hit limits on the actual rendering way before that garbage collector issue. For instance I worked at Amazon writing web apps for the fire TV stick and garbage collector references would never have been my concern, it was the actual render function speed. Not saying your way of handling it isn't better, but as someone else pointed out I am not sure if it's worth the cost of easily debugging or other tradeoffs. I will definitely try some sample apps in it.
Ok, yea I figured or it would be bad, which means there is some sort of state obiect similar to a VDom but different(and maybe better). It's a cool idea in not trying to be a negative nancy.
npm / no people matter npm / never provide money npm / not paying more
Egghead.io and scotch.io are my go to resources for tutorial learning.
Yarn?
jesus. yarn is just a shitty replacement for the cli by cuckbook.
I believe op's talking about the registry which hosts all npm packages, which yarn use as well
That's what I was guessing but had to mention so someone knowledgeable could chime in.
I open sourced (MIT) this project this week [https://github.com/sinclairzx81/smoke](https://github.com/sinclairzx81/smoke) which basically turns a browser into a web server. &amp;#x200B; It operates over WebRTC, is fashioned after nodejs, and provides 'ws' and 'express' router like infrastructure which allows one to build peer to peer web applications in much the same way as you might author an express application in nodejs (except your writing the server in the browser) &amp;#x200B; The library was built with one question in mind "What kinds of systems could be built if every user on a website was running their own web server?". This library is designed to experiment specifically around this idea. &amp;#x200B; Super experimental stuff.
Not a perfect replacement, but it's possible to publish to GitHub then use npm install username/repo or to get a specific version npm install username/repo#tag npm install username/repo#branch
&gt; Modern practices involve bundling your code and its dependencies in a single .js file Wtf? &gt; It's looked down upon to rely on dozens of CDNs to deliver your libraries Wtf!?! Wouldn't you use a single CDN the company pays for? Why the heck would you combine all your js into one file!?! http2 clearly allows a browser giving the server multiple files to download so there's no downtime between files. Having all your JS would just bloat pages? At work we have 1000+ pages, with some of them using graph libs, others using old style jquery plugins and new pages using angular (which I despise). Many pages have their own page specific JS or a shared js for a group of pages. Would all that go into a single page? That will be massive and take so much time to parse. But like my first comment I'm pretty sure I'm not understanding correctly.
Hopefully it's on Github or Gitlab, too, so that you can switch when a better alternative arrive.
This was the first thing I had in mind. Reattempt made it pretty easy to to "reattempt" for sure though, staying true to its name üôÇ I was thinking, maybe the decorator can accept a strategy (for retry, circuit-breaker, timeout, etc) ü§î
New union can be called **IBIT - International Brotherhood of Information Technologists.** (Though I'm in management so I can't join.)
That still uses npm.
It baffles me seeing devs trying to unionize, we work with technology developing the future, but somehow people want to get back to the industrial revolution days.. Fuck that and fuck unions. If you need a bunch of dudes to fight for your rights I can only feel sorry for you. Until last year in my country, you were demanded to pay a percentage of your salary to unions (not devs, other workers), I mean, are you fucking serious? I already have to work like crazy and still have to give money to people because they fight for some rights that are already in the Constitution? Haha it's a fucking joke.
A million should be just fine. With my limited experience with es I would say it works better when you need complex query and bugger baseline data.
That article needs to come with a trigger warning. I'm pretty sure my heart rate went up significantly while reading through it.
Well in a language like rust, it's a question of fully unwinding the stack and having an exception stack trace vs returning a result that you can either handle or punt up the call chain, just like in other languages. I've written a few thousand lines of game code at this point and I can say that the things that can have results *do* tend to have a lot of "?", but it's all sugar over the match expressions anyways which is a bit more legible. The bigest difference in rust is that the result monad (and the option monad) are an absolute contract which makes the programmer decide then and there whether to punt or play, rather than finding out months after the fact that some edge case can trigger an unforseen exception, which has been pretty nice to develop against. This is especially helpful for when you *do* have an error handler at the top level, since you need to either handle all cases or explicitly call out the catch all "_" =&gt; unreachable! case. There are times where panic! is used in libraries to absolutely kill a program but those are fairly rare in my experience. Plus, if you compare the rust and go versions, the rust version tends to be a bit more concise. One of my big headaches (probably unjustified and not trivially solvable tbh) in rust is composing multiple error types. For example, if a function can either return a Result&lt;T, Error1&gt; or a Result&lt;U, Error2&gt;, you don't have a ton of great options. But again, that's not an easy question to answer.
&gt;Democratic socialism is not the answer. &amp;#x200B; Counterpoint: yes it is
Oh, I forgot, I'm on Reddit. Free everything is the answer here. Always.
Many large American unions have long been anti-communist; unions (like the welfare state) have historically functioned as a bulwark against popular revolt, keeping capitalism from imploding by ensuring that workers have some bargaining power. These arrangements have historically been unstable, however.
You are part of the problem
They don't fight so much for your rights as much as they fight for you to get a higher wage. They're like a company who's job is to get it's people highest paycheck possible
Not very future proof. The point of a good package manager like Maven or NuGet is that an uploaded package is there forever and you can always retrieve it to build an older version of your software.
You never mentioned organizing your files and uploading them to a single CDN, I had just assumed ‚Äúcopy and paste CDN URLs from their GitHub repos‚Äù because that‚Äôs what some people do. I also didn‚Äôt know your specific use case, nor have I had to deal with that. Don‚Äôt come at me with ‚ÄúWtf‚Äùs when I‚Äôm only explaining what I know and what has worked very well for me, instead let‚Äôs have a productive conversation. Just upload the bundle to a CDN uses gzip. The payload never pushes 70KB when compressed, jQuery, ES6 polyfills for IE 10, among other things. And when the bundle is cached, then there‚Äôs not really any problem. I‚Äôd much rather have a few KBs left unused per page as opposed to having to manually determine what dependencies each page needs, when there may be only be a couple that can benefit by a couple tens of milliseconds. To me it sounds like that huge site could be separated into multiple different projects, but then again I don‚Äôt know anything about your environment.
What's wrong with wanting to unionize in any scenario? Making sure you're part of an organization that does what it can to make sure you get treated fairly is never a bad thing, regardless of if you're currently being treated poorly or not. I don't know anything about the culture at NPM, but from what I've read, the culture at a lot of big tech companies is toxic and very difficult on its workers. They could use a union.
How's that boot taste?
And you believe in Santa as well... Right?
I wrote react in 70ish lines: Here it is: [https://github.com/wanghao-public/Noact](https://github.com/wanghao-public/Noact) &amp;#x200B; Go read the source file, its super simple: Focus on the following: 1) How the render function works, it's just a simple recursion to produce the DOM tree. 2) How the reconciliate function works, another simple recursion that follows the [https://reactjs.org/docs/reconciliation.html](https://reactjs.org/docs/reconciliation.html) spec. All you need to realize is that the DOM is just a tree, and the simplest way to navigate a tree is to use either recursion, or a stack. I speculate that React Fiber probably uses the latter for the async rendering, but both should work the same way for sync rendering. &amp;#x200B; Don't worry about the rest, the memoization and closure stuff should probably be learned seperately.
Using eslint with typescript. I'm liking this move away from tslint. All my projects can now have the same base eslint prettier typescript and vscode config.
&gt; IBM is even older. Rather, yes: IBM was founded in 1911.
What are your thoughts on reacts method versus the reactive way that Vue and mobx do it Just curious
I don't think you should be as upset about someone not opting into NPM. Its not the centre of the universe, but its trying to be. JavaScript developers have viewed it as such, but without options, all you're left with is yet another mega centralised monopoly in big tech. And we need less of those (no matter how inevitable things will wind up) &amp;#x200B; Anyway, no need to be hostile, NPM is fine, but not using it is still a valid avenue to pursue, particularly in niche cases.
I like making smaller ones. You can update critical things faster and give progress updates.
I did my portfolio in vanilla JS (well typescript but same thing) and some web components. I ended up using web components only for super speicifc things. For example I have a little widget that changes the theme colors on every page. That was a good candidate as it's pretty self contained and reusable. Also a lazy loading image component was nice. Utility type components seem to be the best thing right now. The shadow dom being totally encapsulated makes them tough to use for UI/layout type stuff.
I said nothing about const. I meant to merge the two and remove the leftover.
I like the merit based culture in IT. I'd hate to have it be like auto where a guy won't go one foot beyond his work area to help with other tasks due to union rules. That kind of thing paralyzes companies
Because I like EcmaScript, so I use flowJS instead.
Structure your app like React. That‚Äôs how maintainable vanilla apps are written, check out todomvc vanilla for instance. You have something like components and they expose a render function which writes to the dom via innerHtml. It‚Äôs still all pretty ineffective, so the further you go with this you‚Äôll get closer to writing your own framework since you‚Äôre still missing change detection, state management, etc. The dom itself doesn‚Äôt give you anything to build structure, nor are there best practices, dom apps are mostly chaotic, fall apart or become impossible to maintain. To make a scalable app with the dom only is a reasonable challenge. Your best bet is to study how frameworks like React work internally, because they‚Äôve been made to make the dom manageable.
&gt;What would unions get IT employees? If you want to understand why tech workers are organizing, read through the [Tech Workers Coalition](https://twitter.com/techworkersco) feed. These articles all provide overviews of the movement: &amp;#x200B; [A New Kind of Labor Movement in Silicon Valley](https://www.theatlantic.com/technology/archive/2018/09/tech-labor-movement/567808/) [Why Silicon Valley workers are demanding their employers stop doing business with the Trump administration.](https://slate.com/technology/2018/06/the-tech-workers-coalition-explains-how-silicon-valley-employees-are-forcing-companies-to-stop-doing-business-with-trump.html) [Coders of the world, unite: can Silicon Valley workers curb the power of Big Tech?](https://www.theguardian.com/news/2017/oct/31/coders-of-the-world-unite-can-silicon-valley-workers-curb-the-power-of-big-tech) All the articles in the "[Technology and the Worker](https://notesfrombelow.org/article/technology-and-the-worker)" issue of Notes From Below, &amp;#x200B; The Google Walkout organizers made [several specific demands](https://www.thecut.com/2018/11/google-walkout-organizers-explain-demands.html). Previous internal organizing at Google uncovered [gender-based pay discrimination](https://www.theguardian.com/technology/2018/oct/26/google-gender-pay-gap-women-class-action-lawsuit) and got the company to agree to drop a military contract, although it seems unclear whether [the company will follow through](https://theintercept.com/2019/03/01/google-project-maven-contract/). Employees at SalesForce has demanded that the company to [end its contract with Customs and Border Patrol](https://www.usatoday.com/story/tech/2018/06/26/salesforce-employees-petition-ceo-reconsider-government-contract/734907002/). Similarly, employees at Microsoft have [demanded the end to a military contract](https://www.recode.net/2019/2/22/18236290/microsoft-military-contract-augmented-reality-ar-vr), while Amazon employees have demanded that the company stop [selling face-recognition](https://gizmodo.com/amazon-workers-demand-jeff-bezos-cancel-face-recognitio-1827037509) software to law enforcement, and [take action on climate change](https://www.wired.com/story/amazon-employees-try-new-activism-shareholders/). &amp;#x200B; &gt;They're already paid higher than most industries. &amp;#x200B; This is true, for a small subset of tech workers. But even where it's true, it's contingent. Engineers can be fired at any time with minimal protection or recourse (just like the ones in the OP!) And having high wages and good benefits now doesn't mean we'll have them in the future, which is why now, when the workers are in high demand and thus have more bargaining power, is the best time to unionize. Not later, when wages and benefits are being cut and we have less ability to make demands. &amp;#x200B; Also, the majority of employees of tech companies are not in the same boat as the highly paid software engineers. They're contract workers or service workers. Google has a [massive contract workforce](http://fortune.com/2018/07/25/google-contract-workers-contractor-jobs/) that doesn't get the pay or benefits of their fulltime workers, despite doing necessary work that's often similar to that of the full-timers. Facebook uses a similar "[shadow workforce.](https://www.cnbc.com/2018/10/22/silicon-valley-using-contract-employees-to-drive-profits.html)" Many the full-timers feel an obligation to demand better treatment for their colleagues who make their jobs possible or work alongside them but don't receive the same rewards. At Facebook, engineers and designers stood in [solidarity with cafeteria workers during their union campaign](https://www.thenation.com/article/500-workers-staffing-facebooks-cafeteria-just-voted-to-unionize/). &amp;#x200B; &gt;They have better hours than anyone in the medical field. &amp;#x200B; This isn't true for everyone. [This interview with a game developer](https://logicmag.io/06-game-workers-of-the-world-unite/), for instance, discussed the extreme overtime that they're expected to put in. &amp;#x200B; &gt;Tech companies started the notion of "take whatever vacation you need." &amp;#x200B; As someone else pointed out, "unlimited vacation" is a mirage. When benefits like this aren't well-defined, management can make up the rules as they go in ways that benefit them. People with "unlimited vacation" often take less vacation than they would otherwise. Also, when an employee with accrued PTO leaves a company, the employer is required to pay out the PTO in cash. But as far as the law is concerned, "unlimited" is the same as "none" -- employees with unlimited vacation aren't entitled to any unused vacation pay upon termination.
Because it sounds like power for the sake of power, rather then as a means to meaningful and nessisary change.
Union wages are [consistently higher than non-union wages](https://www.bls.gov/opub/mlr/2013/04/art2full.pdf). If that weren't true, nobody would ever form a union! On a large scale, the decline in union membership in the US [tracks very closely](https://www.epi.org/m/?src=http://www.epi.org/files/2012/snapshot-unionmembership.png&amp;w=608) with increasing wealth inequality / wage stagnation despite continued increases in productivity.
Yeah, I use B O W E R. **B** I'm stuck in a soul-crushing job maintaining **O** some asshole's legacy jQuery code for **W** substandard pay and everything's in MVC **E** and Razor and runs like shit why won't any **R** interviewers call me back please help
In what ways is yarn shitty?
Whatever dude. Wake me when we protest having a stable public education system. All this is going to end up in is rich, educated, gentrifing tech professionals getting there chance to call themselves oppressed for a while. This politically woke bourgeoisie class can really kiss my Whole ass.
Developers seem to think they're too smart for unions (among other things). &amp;#x200B; Ron Howard: They're not.
Smart
Importing templating literals is not decoupling view and state. What decoupling of view and state means is that you don't have to think about keeping your application state and view in sync. Achieving this in a reliable and efficient way is a difficult task and it is exactly what frameworks like React and Vue are intended for. I understand that you can achieve this without a framework as well, ofcourse this is possible, but chances are you are reinventing the wheel.
Isn't npm meant to be super woke? All I ever see of issacs is him being a social justice white knight type. Seems a bit mixed up
This is exactly how Go manages packages though. It's extremely future proof if you fork to a private repo, which is much simpler to setup and maintain than something like Artifactory.
It doesn't use the npm repo, which is what they were referring to. The client side package manager isn't as important.
If firing people is more expensive, then companies become aware of it and start planning for it i.e. they set aside money for the expect increased cost. That money has to come from somewhere, and since the cost goes up proportionally to the number of people you hire (higher chance of a costly firing with each subsequent hire), then it makes sense to take the money from the money allocated to hiring (the cost is effectively a hiring cost). To put it more another way, a business can afford a more expensive employee if they can fire them more easily.
/r/DevUnion is worth checking out too.
Just a nitpick- the article didn't say they were fired for trying, but that is only a claim at this stage- the evidence isn't there yet.
Check out this book. Lots of great stuff in there: https://frontendmasters.com/books/front-end-handbook/2019/
&gt; Amazon, Apple, Google were all created in the late 90s. One of these thing is not like the other.
superficial justice warriors
oh wow, i had no idea! that's awesome, thanks so much
If you are a bit familiar with jQuery this site is gold it translates jquery to vanilla js: youmightnotneedjquery.com
Right? How do they make money?
more fabulous worker's unions, less superficial justice warriors
100% serverless miniature forum [https://forum-gender.firebaseapp.com/](https://forum-gender.firebaseapp.com/)
God when did workers' rights become a political issue
\&gt; Free everything for everyone. &amp;#x200B; It's not free. It's paid for by taxes - we all pay for it and we all get it. Those who earn more pay more for it than those who earn less.
Because NPM is a company that now has come out as evil and some people don't want to support that.
Nope. Its not more expensive, we don't plan for it ahead and we definitely don't take money from payrolls to pay for some imagined cost of firing people. (source: been in the industry for almost 25 years in countries with unions, with over 10 years running IT companies).
Hey thanks for your effort. Just one question. How will the function get triggered on selecting an option of the drop down menu?
This is impressive
There are enterprise accounts that allow private packages and such other benefits.
https://www.quora.com/How-does-NPM-plan-to-make-money I've never used it myself, but apperently you can have the NPM repository in your own hardware. This is important for big companies due to security. For example, a company might have a whole private network with very restricted access to the Internet, and so they have their own NPM repository within this network so they are still able to download packages to their projects and work without issues. Scenarios like this are very common, and NPM makes a lot of money from this. I'm thinking about JIRA, for example. Many companies just have accounts in their website, but you can install JIRA in your own machines (Not sure if you pay for special licensing for it, but you might)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/lssmobtest] [Gvgg](https://www.reddit.com/r/LssMobTest/comments/bgdh52/gvgg/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I can't tell if this is sarcasm
Bruh do you even RequireJS
npm / is a gripe / unions aren't just a type
That is just your worthless ignorant opinion.
With Go the standard is to vendor the packages into your own codebase, very different to NPM-installing a moving target like git tags or master.
and fewer people will choose the path of being a developer if it means you gonna be without a job after you hit 45... that will lead to stagnation...
&gt; In a well tested project That's the real trick isn't it? If you have a well tested project then yes I can believe that there isn't much left for TS to catch. The real question is how best can you get to that position. TS is very effective at detecting and eliminating whole classes of annoying bugs in a cost effective way. TypeScript's benefit to development is much broader than being a "linter for types". Having up to date and checked type information in the code base makes it much easier to understand what your code is doing. It also makes it possible for your IDE to understand it too and help you with questions like: "What is calling this method? Where is this object property being used? What properties are on this object I got from elsewhere?"
Nice argument, really mature. Grow the fuck up and stop needing someone to fight for you, like a real adult.
&gt;That doesn't make you any less of a racist inbred redneck nutcase, though. Please say the following with a straight face: "the number of white man / black woman and black man / white woman couples in advertisement is proportional." If the opposite pattern could be observed in South Africa, where the % of whites and blacks is the opposite of that in the US, there would be all sorts of people calling it out -- journalists, academics, activists, etc etc, who [get up in arms about](https://en.wikipedia.org/wiki/Sheva_Alomar) every single time. &gt;Several sources have criticized Sheva's depiction for adhering to both gender and racial stereotypes. Andre Brock from Games and Culture opined that Sheva was a "videogame equivalent of Pocahontas: a woman of color coerced into 'guiding' White explorers across a foreign land", and also said that her alternate costumes "make it clear that she is window-dressing; a sexualized mule".[2] Anita Sarkeesian said the tribal outfit was particularly disconcerting, as it combined sexualizing a female character "with the racist tradition of exotifying women of color".[35] Writing for the Digital Games Research Association, Hanli Geyser and Pippa Tshabalala noted that the first shot of Sheva in the game is a close up of her buttocks, immediately objectifying and characterising her.[36] Eurogamer's Whitehead said that Sheva "neatly fits the approved Hollywood model of the light-skinned black heroine";[31] Geyser and Tshabalala similarly stated that her skin tone, outfit and job all conform to Western ideals.[36] Writing for The Philosophy of Computer Games Conference, Sibene Harrer and Pichlmair Martine said that Sheva was given the role of a "decorative side character", also stating that "gendered and racialized hierarchies" exist between Sheva and Chris; Chris's character is placed in charge of Sheva's resources, said to be reminiscent of "an abusive heteronormative relationship".[37]
Thank you for the feedback :) There's a huge refactor to the whole component library coming in the near future and the cardEditor.jsx contains alot of sub components aswell as the giant switch statement which produces the form from a json schema. &amp;#x200B; Thank you once again for your suggestion and have a great day :)
You can do pure client-side and then setup some SSR for bots / legacy browsers, along with some caching mecanism.
Well angular on its own is not working with google seo. I am working on a project for seo as well with angular. You need to use angular universal lucky for us there is an add command for that! Plus it runs on node. And for connections to a database and heavy algortihms let that happen on a node server wirh express or sumthing so you can make a api for that.
Woo watch the edge there chuck
You demonstrably fail to understand unions...
Website SEO is a mysterious thing and pseudo science; especially with respect to SPA. I'd be curious to hear what others have to say on the topic. &amp;#x200B; It seems natural to assume that a search engine would be able to render a page, inspect the generated content, but i not sure how this ties into things like synthetic page URL's and other such things. Hybrid client / server rendering has done in the past, but im at a loss to know if such things are even relevant anymore. &amp;#x200B; Will keep an eye on this thread, hope you get lots of responses. :)
There are a lot of things rxjs can do which promises can't. For example: lazy execution (code executes only if there are subscribers), stream of events (you can't resolve promise multiple times), event stream of streams, etc.
Hey, thanks for your comment. The basis for creating Mdyna was that I wanted to write my notes in markdown while still having the Google Keep 'board of post its' look and feel. I don't know about QOwnNotes, I've been using Boostnote and Notion to keep my notes synced cross-devices, and in the future, I will ideally use Mdyna to do so :)
I never used memoization before... until React hooks `useMemo` (and `useCallback` is also memoized I think). Now I find myself using it often. I suppose indirectly React hooks gave my code a performance boost?
No I don't. I know exactly how they work in the real world, at least where I'm from.. I have experience in my family with all kinds of unions and they all suck. They are only good to take a cut of your payment.
Well I‚Äôm sure your anecdotes are far more reliable then our laws...
Lol, sure you tell Reddit that. A main advertised purpose of unions is to deliberately make it more difficult to fire people. Making it difficult to fire increases costs (cost aren't just money) for the company. Those costs have to come from somewhere. In your fictional world in your fictional company where you never cared about the costs of hiring people. Sure, I believe you.
ES4 - [https://en.wikipedia.org/wiki/ECMAScript#4th\_Edition\_(abandoned)](https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_(abandoned)) &amp;#x200B; Proposal Main Points * [classes](https://en.wikipedia.org/wiki/Class_(computer_programming)) * [a module system](https://en.wikipedia.org/wiki/Modular_programming) * optional [type annotations](https://en.wikipedia.org/wiki/Type_signature) and [static typing](https://en.wikipedia.org/wiki/Static_typing), probably using a [structural type system](https://en.wikipedia.org/wiki/Structural_type_system) * [generators](https://en.wikipedia.org/wiki/Generator_(computer_programming)) and [iterators](https://en.wikipedia.org/wiki/Iterator) * [destructuring assignment](https://en.wikipedia.org/wiki/JavaScript_syntax#Destructuring_assignment) * [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) &amp;#x200B; Its funny how just on point ES4 was (back in 2007). Shame about the politics that lead to it being shelved. The naysayers were wrong (ultimately deferring this much needed functionality for near a decade). Oh well, such as JavaScript. &amp;#x200B; A type system would be high up on my list, and perhaps runtime type verification by incorporating JSON schema.
It‚Äôs a lyric from ‚ÄúWon‚Äôt Get Fooled Again‚Äù by The Who
Hey, thank you for downloading the app and for your great feedback :) I will take some actions based on it, some of them were already planned. \- I will be adding tooltips to all side menu items \- I will be positioning board navigation buttons on a more intuitive position \- Initial window height will be increased. \- In the future, I wanted to make the editor open in a tab instead of a modal. This would give me better control of the editor layout. For the moment, I'll follow your suggestion and put a 'Save' button next to the 'Close Editor' button. Regarding the bug with the task lists, like you said, there were some recent changes that were implemented because the tasks couldn't be clicked if they had markdown text in their description. It seems that it still needs to be tuned, expect a hotfix to be deployed today :) Also, the application has auto-update, so it will always prompt you to restart the application if it finds a more recent version has been deployed :) &amp;#x200B; Thanks again for your feedback and I hope these actions will persuade you to keep using Mdyna :)
&gt; All I ever see of issacs is him being a social justice white knight type. And also being aggressively unable to handle dissenting opinions, which is 100% in line with these layoffs.
The creator of Node has started a project called Deno that moves away from the NPM model. Perhaps now is the time for some of the community to start switching
I mean if this is Javascript related content now, let's go...
yarn?
Async / await is syntactic sugar for promises, but promises and callbacks have significant differences (e.g. called only once, monadic behavior). Callbacks are flexible enough to implement promises, I don't think the reverse is true.
Nuxt.js might be a good choice - it's Vue with server side rendering built in. Very SEO friendly. It's also really easy to get started!
I used to work in Poland where there are no unions in It, now I work in France where it's unionized. From my point of view I preferred non-unionized IT. The job market was more fluid, if your current employer is shit, there's no problem leaving and finding another one even when you're not hot shit. In France companies are very conservative when hiring people. Personally I think unions around here are stifling (French approach to seniority doesn't help either). Poland is not the USA though and we have some state imposed regulations (paid holidays you have to use every year, regulated workhours and overtime situation, etc). I can see why programmers in the USA would want to unionize.
Sounds cool, thanks for explaining. I dont have anything complex enough to use this yet but I'll keep it in mind. Any use cases that come to mind?
I used AngularJS on 4 sites over a couple of years. Despite the fact that AngularJS is / was googles own invention indexing (if any) was/is very poor. Even if googlebot confirmedly could read the pages, and confirmedly did read the pages, indexing was really bad, if existing at all. To make it even worse, when a page finally was indexed it disappeared from the google index after some time (not the entire domain, just the pages like `example.com/shoes/`). I tried carefully with [prerender.io](https://prerender.io), and it was the same story. Pages were indexed faster, could see that, but the overall indexing did not get better. If you look around Google really does index SPA's, and does it good and does it fast. But my impression is that when you have heavy JS scripted SPA's google more index a page per domain rather than per content. It is simply not possible to tweak (=="do SEO") on individual pages or "content level" when dealing with SPA's. This article seem to share my impression -&gt; [https://medium.com/js-dojo/is-my-single-page-app-seo-friendly-be2c827f1c38](https://medium.com/js-dojo/is-my-single-page-app-seo-friendly-be2c827f1c38) and IMO the conclusion "be sure to provide server rendered or prerendered pages" should be translated to "if you really insists...." Today I will never dare to use a SPA if we are talking about a lot of individual pages that need to be indexed, and if SEO / ranking is a concern. It is the same story with React, Vue, Angular. A SPA is excellent for your admin pages, your about, blog and so on, but not if you have 2.000 different products in rank competition. For one of the above mentioned sites, I plan a summer "hobby project" where I will replace all the product pages with individual products pages generated by a index.php (same urls). tl;dr: If you need oldschool SEO capabilities, then stay away from SPA unless you have a plan and know exactly what you are doing.
I really enjoyed building a smart network buffer with it. The idea was that you have an application (totally unaware of network implementation), which sends separate events to the network api &amp; this api then batches multiple of them into a single network request. There are important events and common events: for important ones, the buffer should send a batch immediately; but if there are no important ones for a some time, the buffer should increase it's batch interval. With rxjs it's all about 15-20 lines of clean readable code.
nah, we need more amazing unions like police and prison guard unions. So many great benefits to society comes from those /s
Don't know if Ember is an option, but I'm working on a similar project using Ember + Ember Fastboot for server side rendering. The SEO folks have been involved all along and are happy with the results.
How does npm make money and why does there need to be a company behind it? PyPi for python seems to manage just fine without being a for-profit company.
Does it still have 35,000 dependencies?
what do you like about flowJS that differs from typecsript?
I keep everything backed up on zip drives....
First of all was never big user of TypeScript, but what i like most, is that, I can use newest versions of EcmaScript. I have never worked on big project with flowJS or TypeScript (At work we have kinda legacy code using google closure and own modified compilers :/ ). But I am very used to EcmasScript2015-18 and fact, I can just add type control and do not have to change anything else makes FlowJS better for me.
yarn uses npm as its source.
[removed]
Yeah, so closures are powerful, but they are not to be overused. Got it.
[removed]
Hi /u/gokulnk, this comment was removed because you used a URL shortener. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/javascript) if you have any questions or concerns.*
Because the point of unions is to improve society and not work for the benefit of the member.
It was using npm initially, now it uses it's own registry at https://registry.yarnpkg.com
[removed]
Take a look at this example [https://github.com/nestjs/nest/tree/master/sample/19-auth](https://github.com/nestjs/nest/tree/master/sample/19-auth)
This is no longer true. See [Go Modules](https://github.com/golang/go/wiki/Modules).
Did you read the title of the article?
The Google bot also crawls SPAs. But to be safe I would use Vue + Nuxt for SSR. This way all your data will directly lie in the DOM. How you fetch the data is your decision. You could use a database connection, GraphQL or JSON API. I would prefer the database connection because its developed faster than GraphQL but GraphQL could be the better decision if your client's system need to be scalable.
Laying off people who tried to start a union is different than what I was asking about
Nice app! Congrats man!
&gt;Your library may be so small that it‚Äôs simply less work to not use a modern feature that will need polyfilling. I'm very much coming around the other way - with dropping IE support being more socially acceptable, you may just skip that polyfill. What's described as a good example is React due to its use of Set. Sets are fully supported even on browsers like Safari and Edge. The article talks about a new feature in Promise, .finally(). The last nine versions of Chrome and eight versions of Firefox have supported this. As does Edge, Opera, Safari, and so on. The "many environments" that don't support it end up including Internet Explorer, Opera Mini and something called QQ Browser. Same with async/await, which people very commonly feel needs to be polyfilled.
Why does it have to be a brotherhood?
&gt; Please say the following with a straight face: "the number of white man / black woman and black man / white woman couples in advertisement is proportional." Who fucking cares? The proportion of thin / fat people in used in advertising is not equal to society either. Do you bitch and moan about companies using thin attractive people to sell clothes?
The UK teaching unions have 800k members and the communist parties in the UK are almost non-existent. I have literally never met a communist. I don't know who informed you about unions but you have been lied to.
Do you expect your application to produce on the order of 100k errors continuously? Will you be producing so many errors that you need to optimize how they are emitted through your application?
FFS - which regressive came up with that name. Dumb Dumb Dumb
The question is not whether Google can index SPA's written in various frameworks. The question is not whether you can improve googles indexing with for example SSR. The question is: Does google handle SPA's different from other pages? Does google index a SPA page different than it index a plain HTML or a page generated by a Python-script? The answer seems to be a big green yes. This means, that while you as a programmer gain a lot of productivity, efficiency and joy by using a SPA, you loose some of the tools or techniques you have as a SEO'er.
Apparently, this is something that can happen. Game architecture inside of a web server that can depend on many inputs which will determine allowed actions through comparing errors.
 let temp1 = { c:30, getVal () { console.log(this.c); } } temp1.getVal(); using arrow functions only allows you to access the scope defined within it
That's a relief.
So there's no other options other than removing arrow function ah ?
I would focus on data structures. Specifically taking two different streams and merging them and outputting them as an API endpoint. I'd make sure you know how to make an API call from the Front-End using Vanilla JS. My guess is that you'll have to merge two arrays/add keys etc. Study up and have the basic syntax covered. Anything you don't quite have a handle on I'd write down in a small notebook.
IT doesn't need unions, period. When is the last time you've done a job search? The market is heavily in favour of the employee. You don't like something? Look for something else, there's absolutely no shortage of well compensated opportunity in this market.
It‚Äôs not about being old so much as being overly expensive. If someone is able and willing to do the same job as me for cheaper, they should be able to. People expect to be paid extra for having more years of experience even if that added experience isn‚Äôt actually very useful. If the industry has a problem attracting talent because of future job insecurity, it can adjust. It can change incentives based on the market to attract whomever they need. If they have a bunch of overpaid senior developers they can‚Äôt get rid of, that‚Äôs much more of a constraint. I‚Äôm personally not that worried. My responsibility is to build my skills and provide value if I want the relatively high pay this industry provides. If I just rest on my laurels I shouldn‚Äôt be able to block someone who provides the skills better and/cheaper. I was actually recently in the opposite situation trying to get a job in the government department where I work as a contractor. There aren‚Äôt open positions because they‚Äôre already taken by older guys who don‚Äôt hardly do anything. The government is hesitant to get stuck with those guys because it‚Äôs such a waste of money long term. So they go around it by paying contracting companies much more per hour. I was getting $70k while the government was paying at least $144k for me to be there. They would‚Äôve gladly met me in the middle if they could, but they don‚Äôt want to have to commit to a lifetime of employment when they don‚Äôt know how good of a job Ill do or whether I‚Äôll be like the old guys who have been phoning it in for a decade. This happens all over government because the cost of hiring a permanent employee are so high and the risk is so big.
You could be doing temp1.c But replacing it by an anonymous function is the way of doing it gatVal: function() { return this.c; }
Thanks. Although Javascript runtimes do exist in other languages, their performance is usually far enough from optimal to be used in production. How difficult would it be to emit a non interactive version of the code in a given language? I'm specially interested in having this in Go.
You could use `temp1.c` instead of `this.c`
Should be peoplehood
git hub has releases and hashes you can reference. in reality, someone should just make a package manner that overlays git hub and gitlab
And not that kind of ‚Äúgreen‚Äù either.
Sounds like paying money for something that isn't that hard to do - download the things you need from npm and host them on a nexus server which people mirror in a .npmrc or .yarnrc
Goes hand in hand with being ‚Äúwoke‚Äù doesn‚Äôt it?
Should be peoplehood üòÇ
It's true that a lot of applications only target the demographic that will be using a modern browser. But there is still *a lot* of apps that simply can't do that. They may need to support old browsers such as IE 9+ or obscure browsers such as browsers built into technology like TVs or consoles.
Not having unions stifle growth by letting workers be constantly fucked over by management with no recourse so idk maybe unions might be worth a try
What do you mean you don't need to stringify? Keep in mind that comparing objects compares just the pointers to the objects, not what's inside. So if there is a new object with the exact same contents looking it up in a Map will _always_ return empty, unless it really is the identical exact same object as before. So most likely you will indeed still have to stringify to get a comparison of the actual contents of objects.
Or use verdaccio or nexus or artifactory
But prevents 996. Companies don't care about your being so why care about theirs?
Its informative
Interesting. So if you just set your `.npmrc` to point to this as your canonical registry will installing and publishing work as expected? Do they just keep a mirror of what npm has? Are there packages that have fragmented by only publishing to yarn and not to npm?
That‚Äôs not very future proof. I‚Äôm thinking ‚Äúcarbonbasedlifeformhood‚Äù
It's some pretty neat tech, and he explains and promotes it really well. Interesting that while written in Typescript, it doesn't yet support Typescript.
I believe only about 70% of packages are mirrored (but I could be wrong)
&gt;Amazon, Apple, Google were all created in the late 90s Amazon, *Apple*, Google were all created in the late 90s &amp;#x200B; You need to do a bit of fact checking here buddy
`react-native-modal` feels great. Also, a lot of the professionalism comes from your styling of the modal.
That's incredibly short-sighted, just because the market is decent at the moment doesn't mean it Will continue that way. You also seem to undervalue job-security as a concept and the importance of it when the market inevitably have a downturn or as people get older it's important that they can be sure they won't be replaced with someone younger and more desperate. Unions are very important in all industries and even at the current moment stories like the one above highlight the problems of the weak unions in IT.
&gt;news website To jump on this first, your client probably doesn't need a CMS built from scratch when things like Strapi exist (or even Flamelink, if they need real-time updates without even a page refresh). To answer your question though, I'd take a look at Gatsby. As others have mentioned here, Angular SSR is a pain in the ass (source: multiple enterprise-level Angular apps). And my own take on Vue is that it's a toy when you compare it to Angular or the React ecosystem, though ymmv. Gatsby is fast, flexible, supports great SEO, and gives you access to all of the tooling that is React these days.
+1 for Nuxt.
how's that boot taste
The politically ‚Äòwoke‚Äô Bourgeois will be tomorrows galley slaves... just one for function and you‚Äôre free
I love how having an opinion you disagree with makes me a bit licking sheep. Thanks for the validation!
Hi /u/pverma8172, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/beefyjon, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/jasonmarkthomas, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/beefyjon, this post was removed. Prohibited low-effort content includes: * Questions that are easily Google'd. * Memes, jokes, etc. Please post to /r/ProgrammerHumor instead. * Most images and gifs. * [Listicles](https://en.wikipedia.org/wiki/Listicle), "Curated lists", and similar content. * Polls, surveys, etc. unless from an accredited academic body or trusted source (StateofJS, etc.). Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/ArizonaIcedOutTea, this post was removed. Job and job-related posts are prohibited * Job postings: Please post to /r/remotejs, /r/forhire, etc. instead of here. * Job/Career advice: Please post to /r/cscareerquestions instead of here. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/drdrero, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/karolis2017, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/MYTHiN07, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/soywod, this post was removed. Posts must directly relate to JavaScript. Content regarding CSS, HTML, general programming, etc. should be posted to their respective subreddits instead of here. Here's some related subs that might be useful: * /r/css * /r/php * /r/html and /r/html5 * /r/webdev * /r/frontend * /r/programming Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/ChaseMoskal, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/neomp, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Yes I'm of the opinion of not licking boots, correct.
Hi /u/N8Programs, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/JaredWilson11, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Hi /u/mikevhenderson, this post was removed. * For help with your javascript, please post to /r/LearnJavascript instead of here. * For beginner content, please post to /r/LearnJavascript instead of here. * For framework- or library-specific help, please seek out the support community for that project. * For general webdev help, such as for HTML, CSS, etc., then you may want to try /r/html, /r/css, etc.; please note that they have their own rules and guidelines! ---- /r/javascript is for the discussion of javascript news, projects, and especially, `code`! However, the community has requested that we not include help and support content, and we ask that you respect that wish. Thanks for your understanding, please see our [guidelines](http://www.reddit.com/r/javascript/wiki/index) for more info.
Wait, so your arbitrary distinction is that they can lay people off for attempting to gain the ability to strike, but not exercising the ability? OK.
Many are going to various ssr options, but I would suggest to keep it simple with old school server side templating with handlebars or twig or liquid. You don't need full client frameworks for friendly URLs. Express handles that easily. The extra money won't be worth the mental hassle of working with a database backed ssr with full client frameworks. You will be adding unnecessary layers that *will be* a nightmare to debug and maintain.
They don‚Äôt currently pay taxes, so it‚Äôs all gravy to them
&gt; "take whatever vacation you need. This only works when coupled with a minimum vacation policy, otherwise people compete to signal their workaholism and destroy their health the most.
Why complicate things? All your client-side widgets and interactive bits should be Angular/Vue (forms, search, comments, etc). Who cares if SEO works for these? All your content (home page, sections, news articles) should appear static and SEO-friendly. Of course, that doesn't prevent you from serving content from a database (server-side rendering) but the HTML result should be no different from static content. Likewise, if you want a fluid/dynamic SPA-like user experience you'd do it this way. Let's say you have a frame page and you want whole articles to "slide in" when you click "Article 1", "Article 2", etc. Make those links but in Vue/JavaScript intercept the click event to hit your server-side REST API to pull the article content then animate it sliding-in. However, a search engine would just follow the link to a static or server-side rendered Article 1 page that it can index. Anyway, the key idea is structure your content as plain HTML/links like it's 1995 but served by a modern back-end (AWS, node, whatever) and "decorated" as much you want on the front-end with dynamic Vue/Angular/React that doesn't break the one-link equals one-page structure.
There already is (or rather, was) such a package manager. [Bower](https://bower.io).
Is it still JavaScript? :P
Is there any anonymous polling that actually backs any of these ideals up? Guarantee plenty of people disagree with most of the points the organisers have raised, and for good reasons. But they know better than to actually speak up about it.
Absolutely not true with my employer. I'll have over 6 weeks of vacation days this year. I haven't heard one case of an individual's vacation being denied across dozens of teams.
&gt;Bower should be fine, those things are pretty much indestructible.
Yes because one is when a union exists and one isn‚Äôt
What does ‚Äûclear the code from innerHTML‚Äú mean? Right in the code here it‚Äôs obvious that you get an x, because you set it in the corresponding field.
How on earth is this not about code ? Ain‚Äôt no body talking about JavaScript in here anyways
&gt;Who fucking cares? The people behind those advertisements - the people who work in the media - the people whose peers are openly and increasingly hostile to white people, especially men. If you don't see it then you're blind, if you see it and don't care then you're a moron. Apathy is not a virtue. Boy, if you think that I'm spouting some alt-right-nazi-white-supremacist-trump-supporter conspiracy theories here, I implore you simply google "white male" and look at the headlines, rhetoric and narrative. Easy mode: append "site:cnn.com", "site:salon.com", "site:buzzfeed.com", "site:huffingtonpost.com", i.e. any of your favourite news outlets full of facts and expert opinions etc. And if you can't find anything good, somehow, then google "aclu white baby" for a relevant example of what kind of reaction does depicting white people in positive light triggers from those people. It's all out in the open. Nobody's bothering to deny it. Wake the fuck up and smell the coffee. &gt;Do you bitch and moan about companies using thin attractive people to sell clothes? Are black women ugly? Are white men ugly?
what i mean is if the text input field is cleared i.e. &amp;#x200B; Voucher(Form Field) = 212dsanbv (Dummy voucher code) =&gt; Voucher(Form Field) = \_\_\_\_\_\_\_\_\_\_ (Empty input form field).
It's also hilarious considering that all the major tech companies were colluding with each other a decade ago with no poach agreements. The only reason why software salaries are high is the result of this lawsuit from the DOJ (thanks Obama): https://en.wikipedia.org/wiki/High-Tech_Employee_Antitrust_Litigation
[Still a fucking thing](https://nodejs.org/api/esm.html)
The TS team moved away from TSLint itself. So this was bound to happen.
I don't understand why the act of pooling resources doesn't align with "free market" ideals, yet somehow exercising the power of already pooled resources does.
And where do you think their packages come from? Air?
Because if there's one thing that's not growing in America, it's tech companies. Just look at all those amazing huge tech companies in union-heaven Europe. Wish America had an IT industry like Europe. We're like Afghanistan right now.
&gt; Boy, if you think that I'm spouting some alt-right-nazi-white-supremacist-trump-supporter conspiracy theories here I absolutely do. I am a white man incredibly grateful with my position in the world. You have to be an absolute nancy to feel attacked by any of this. Yeah, there is some backswing after a few centuries of mistreatment but white people aren't getting lynched in the street. You should be embarrassed about the terror and fury you appear to live with.
&gt;If the industry has a problem attracting talent because of future job insecurity, it can adjust. It can change incentives based on the market to attract whomever they need. If they have a bunch of overpaid senior developers they can‚Äôt get rid of, that‚Äôs much more of a constraint. not sure if this is true. I'm from Europe and companies have a hard time adjusting to attract new talents. The pay for IT personnel is underwhelming compared to what unionized trade professions or other professions with a strong lobby like teachers and lawyers earn. Yet, there is a huge shortage of its professionals but the pay is rising very slowly. &gt;I‚Äôm personally not that worried. My responsibility is to build my skills and provide value if I want the relatively high pay this industry provides. If I just rest on my laurels I shouldn‚Äôt be able to block someone who provides the skills better and/cheaper. yeah, the thing is when you work years for the same company you kinda commit to a certain tech stack that will be replaced at some point. It's kinda unique to IT profession that your knowledge can get completely obsolete within a few years and a lot of companies are stingy when it comes to spending money and time on skilling employees beyond the tech stack they are currently using. Unions or a lobby could help a lot here. Sure, you can keep learning in your free time which works well if you are young but when you getting older and have a family you just don't have that much time and energy anymore. &gt;The government is hesitant to get stuck with those guys because it‚Äôs such a waste of money long term. So they go around it by paying contracting companies much more per hour. I was getting $70k while the government was paying at least $144k for me to be there. They would‚Äôve gladly met me in the middle if they could, but they don‚Äôt want to have to commit to a lifetime of employment when they don‚Äôt know how good of a job Ill do or whether I‚Äôll be like the old guys who have been phoning it in for a decade. This happens all over government because the cost of hiring a permanent employee are so high and the risk is so big. be glad that you can work as a contractor within the public sector. Probably the best balance between pay and workload. I worked on the other side for a while and the reasoning for the underwhelming pay wasn't commitment or anything like that... it simply because it is what "caseworker without personnel responsibility" earn. Period. no wonder that people getting demotivated and frustrated doing the same job for half the pay a contractor does even if they do better. That's why I left my job in the public sector. That's also a problem not being represented by a union or lobby... or in the public sector case represented by the wrong lobby/union (which usually represent all employees and not specifically people in it departments). Other professions in the public sector with their own lobby get much more without being in an executive position... at least where I'm from.... i mean it's so bad that I would had to climb to the CFO position just to reach the pay level of normal teacher...
How is Svelte different to [incremental DOM](https://github.com/google/incremental-dom)?
If it were about pooled resources, the company would still have the ability to fire employees, they‚Äôd just have to fire all or none (or some compromise worked out with the workers‚Äô organization). That‚Äôs why I was asking about the law. If they can just get a new crop of employees (but perhaps don‚Äôt want to because it would be disruptive and costly) that would be pooling resources in an open market.
Woah, that's pretty gross.
I haven't been fucked over by management. If I'm fired or if I'm underpaid, I can easily find another job. I have the leverage. Software is not the same as working in a town with one factory. Employers fight to see how many insane perks and benefits they can provide for good engineers.