Not a fan of the idea, but good luck.
&gt; JSX is just to JavaScript what *Faces was to Java, trying to pull everything we're not that comfortable with into our realm of comfort, despite all the kicking and screaming. You're comparing a server-side component framework, with a syntax for declaring React node trees on the client-side. "Apples and oranges" as a vast understatement for describing the ridiculously broad brushstrokes you're trying to use in your analogy. Surely you can do better, if you'll be saying "we've been there before (at least some of us)", implying you have great experience in that field. For the record I started programming in 1988, so I'm actually quite familiar with anything you'd like to throw at me. &gt; There are obvious benefits for projects made today but in time as the world moves on drawbacks prevail. I'm confused, are you describing React or Angular here? Because this is precisely what people leaving Angular in the last two years have been saying about it. What exactly are the drawbacks of React you're talking about? Everything has drawbacks, but React is extremely focused and you can use it for components that work well with it, and write other components in other ways, it's not an "all or nothing" proposition like Angular is. Are you familiar with React at all? &gt; Being religious about technology is pointless, there are more churches than faithful, and cycles are hella short. I'm wondering again... who are you talking about here. You're the guy who kept repeating "separation of markup is fundamental" in the previous comment. It sounds pretty religious to me, because if you had a technical argument, you never made it. You just have this unshakable belief in markup separation, for some reason. &gt; Angular and Vue are making more future proof bets. Like? I'd like to hear what future-proof bets a framework like Angular is making, whose user base is literally melting before our eyes. I wish Angular a bright future and everything, but the way it's going, I'm not even sure if there will be Angular at all 3-4 years into the future. Furthermore, Angular and Vue are quite different in many different ways. So you need to be more specific, because otherwise I'll have to conclude this is all about markup separation, which is quite superficial. 
I have noticed a lot of the best talks at conferences rarely have anything to do with the conference's main subject.
Maybe this post will help: http://stackoverflow.com/questions/17886578/refresh-part-of-page-div
If it's for educational purposes, you will probably like this [series of article](http://blog.klipse.tech/javascript/2017/02/08/tiny-compiler-intro.html) that features interactive code snippets (in the browser!) about a mini-compiler from LISP to js. It's far from being complete but it conveys the basics of a compiler.
On the flip side, are there any compile-from-js languages? 
Thank you.
Haha, wouldn't JS be the compile-from-js language?
You should write it that way if you are adding variables to your strings
This is no less normal than to what you referring to as normal. This is simply newer, the answer to your question lies in are you using a transpired, and if not what browsers do you are to support, basically do you care about IE?
I'm thinking somewhere along the lines of the opposite of Emcripten if you follow me. 
The the last answer you got, which you apparently don't understand is the dead simplest way to do what you want. There are many other ways to do it, each more complex. Using that wordpress shit will definitely make your life more difficult, but that in no way changes the solution. 
Objects can now have Symbols as keys.
*h* is silent
To be clear, I was suggesting distance from point to corners represents the balance of the three values from the user. To get a standard value, I'd have divided each distance by the sum of the three distances in order to determine the weighting that the user applied. That said, if that's a standard way that people tend to do this, that's better than my random approach üòÄ
It returns a JS object that seems to be a lot of the configuration/tracking information for the Khan Academy site. Copy and paste the code into your browser's dev tools JS console and start poking around in the object it returns. Basically it's giving you a starting point to start to understand and dig into the code they use to run the actual site
Others have already answered this, but if you're looking to use different types for your keys, you can look into using the new [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) that came with ES2015. Example: class Student { ... } const studentGrades = new Map() const student1 = new Student('John') const student2 = new Student('Mary') map.set(student1, 90) map.set(student2, 80) console.log(map.get(student1)) // 90 console.log(map.get(student2)) // 80
well you should make an effort to understand it. look up the concepts mentioned. you can't expect to use a programming language without learning any of it.
I used to do that, especially as it aligned with OOP practices back in the day when they were the dog's bollocks ( pizza.toppings.add() etc ) but I am not so fond of OOP anymore, and I find the Yoda-esque constructions tiring. I like to keep all my names as close to spoken english as possible ("add toppings"), so that reading software is almost like reading a book (a boring one, but hey :-). If I were to program in German I would do it your way ( vornameL√∂schen etc ) because it's natural in that language. I never waste time keeping functions in alphabetical order, again, I used to but now I have come around the idea that I shouldn't invest energy in something the IDE should make easier for me. It's just my preferences :-)
Although efficient, multiplying velocities/positions with a delta-time variable can cause rounding errors in the long run. Besides, how do you implement collision detection for a particle if it can move an unknown, perhaps huge distance each frame? Raycasting is not a fast method. I'm fan of implementing the `game.update` function to step my game by 16ms and then calling that by the amount of time elapsed divided by 16, adding the round error each time, like this: let lastTimeStamp = 0; let leftOver = 0; function update() { let thisTimeStamp = performance.now(); let difference = thisTimeStamp - lastTimeStamp + leftOver; leftOver = 0; if (difference &gt; 160) { // Always check if too much time has elapsed!! game.pause(); } else { while (difference &gt;= 16) { difference -= 16; game.update(); } leftOver = difference; lastTimeStamp = thisTimeStamp; } game.render(); window.requestAnimationFrame(update); } Basically, if my computer lags for 48ms, it will run update() function 3 times. But if it's a fast computer that runs update each 8ms, that `leftover` is added and `game.update` is ran every two update calls, this **caps** framerate at 60FPS. If your computer is too fast you could implement a 8ms step instead, to achieve 120 FPS. Also, not rendering between "batches" of updates is good for slow computers, so that when things are slow the cpu doesn't waste time rendering useless stuff. Edit: changed `+new Date()` to `performance.now()` as it's more precise. 
I actually do a simple `getShouldRender` ... which is not entirely nice to read, but at least is consistent with `shouldRender`. I wish I could come up with something that made it sound more like spoken English, but for now that does the job
Eckma's crypt
Or if you are using webpack/browserify :)
You need ajax. Let's say your text file is hosted at www.server.com/text.txt You simply write a function that sends an XHR request to www.server.com/text.txt and takes the response and fills whatever element of your page with it. Then just call that function every ten seconds with setInterval
I tend to use Sets quite a lot to remove all duplicates (like: [...new Set(arrDuplicates)]). Maps can be useful because instead of Objects you can actually use any primitive, function or even an object (if I remembered that correctly) as key. Besides that, figuring out the size of a Map is way easier because a Map has the 'size' property.
if you want anyone to read your docs, please add a max-width to your container so that you have between 60-75 characters on each line. https://i.gyazo.com/2d7052f1705a4b9c162eb2c7ef0a7929.png I didn't measure the amount of characters, but this is considerably easier to read/skim.
I recommend the personal MBA
https://www.youtube.com/watch?v=PlmsweSNhTw around 1:13
&gt;[**ECMAScript Harmony: Rise of the Compilers - Brendan Eich keynote [19:18]**](http://youtu.be/PlmsweSNhTw) &gt;&gt;From Fluent 2015. "JavaScript is almost 20 years old, and moving faster than ever. ES6/2015 was voted through Ecma TC39 in Paris last month, ES7/2016 is being developed concurrently to prime the annual release pump, and use of compilers, notably Babel and Traceur, is on the rise. Low-level APIs such as SIMD, WebGL2, and 64-bit integer Math methods combine with higher-level facilities from generators and promises to async/await to cover the space of safely programmable hardware. Is there anything JS cannot do? I‚Äôll give some answers. &gt; [*^O'Reilly*](https://www.youtube.com/channel/UC3BGlwmI-Vk6PWyMt15dKGw) ^in ^Science ^&amp; ^Technology &gt;*^35,368 ^views ^since ^Apr ^2015* [^bot ^info](/r/youtubefactsbot/wiki/index)
Sweet. Neat and simple.
No it's because the demo app is on the open source github repository and the demo app depends on the Bootstrap components let me know if that clears it up
I wasn't happy with react-bootstrap. When I used it I felt like I was recreating the things you normally would do with bootstrap without even using a React library and also I needed to import 3 different modules to do one thing. These were some complaints that led me to creating this library. I plan to support v4 I just don't like how bootswatch themes aren't yet available for it
Yeah way way smaller especially if you import based on filename because then only one component gets added to your bundle üòé
I agree with you, but is it just me or are sets and maps still really slow at the minute?
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#In_an_in‚Äìline_event_handler EDIT - Not sure why the downvotes. The code example on MDN is nearly identical and it even explains the rule.
Reactstrap does seem like a nice solution with more components available but this library will catch up. Not sure what ES2015 has to do with it it's more of an up to the user thing
As long as the backend is serving JSON it works fine. Doesn't matter if it's java/node/ruby or whatever. I recommend using axios for your calls. https://github.com/mzabriskie/axios
By default, the value of `this` within functions points back to the `window`. An exception to this rule is when you call a method that has been declared on a function's prototype, in which the value of `this` points back to the instance of the object (like when you create an instance of a class and invoke a method). Another exception is when you use the `bind` or `apply` function object to inject the value of `this` (more info on that can be found [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)). Under the hood, `element.addEventListener` is binding the element as the `this` value to the function you pass in as the second argument. In the third example, when you pass in `selectShape(shapeButton1)` as the event handler, `selectShape` is returning a function. `addEventListener` is using that function as the handler and injecting the element as the value of `this`. In the second example you provided, you were just invoking the `selectShape` function and since that was just a plain function that did not have a `this` value bound to it, the value of `this` was just the `window` object.
I understand but this library is all ES2015+ what do you see that isn't?
I meant that it's pure ES2015. No jQuery. I might have made an edit to my last post after you started your reply. 
If you're interested in learning React and/or Redux, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. Given your questions, you may be particularly interested in some of the topics like "Project Structure" and "Redux Architecture".
Thanks for the feedback https://github.com/axiom-team/bootstrap-components/issues/5
&gt; Do you also find including your own bootstrap CSS/JS to be annoying? I actually just use some of the JS pieces of Reactstrap. I wrote a React BS4 component library for our team, so we can brand it and compile it as we choose. I just pull the pieces out as I need them, because it's put together really well and none of it is complicated. It's MIT Licensed. &gt;I'm not sure if that's how Reactstrap does it but JQuery is way too much overhead to do some simple things. It's actually not too much overhead if you support IE10+. I am surprised that BS chose to include it in v4 and I'm still really hoping that they remove the dependency before it hits release. 
Passing along the `this` value solves the issue in the second one: shapeButton1.forEach(function(elem) { elem.addEventListener("click", function() { selectShape.call(this, shapeButton1); }); }); Because the event emitter code is setup like: const emitter = { listeners: {}, applyThis: null, setThis: function(newThis) { this.applyThis = newThis; }, on: function(eventName, cb) { if (this.listeners.hasOwnProperty(eventName)) { this.listeners[eventName].push(cb); } else { this.listeners[eventName] = [cb]; } }, emit: function(eventName, ...args) { if (this.listeners.hasOwnProperty(eventName)) { for (var i=0; i&lt;this.listeners[eventName].length; i++) { this.listeners[eventName][i].apply(this.applyThis, args); } } }, }; In action on [JsFiddle here](https://jsfiddle.net/2rcdbnyk/). 
`/^\s{4}/` to make code -- then it won't parse the backtick
I haven't checked out the differences between 4 and 2 fully but it sounds like they're not drastic. That said, I'm beginning to regret taking the angular path. Trying to lock down an understanding of 2 and they're releasing 4. Half of material out there is confusing because it's outdated, etc. Who has time for this crap? 
https://addyosmani.com/resources/essentialjsdesignpatterns/book/ is a great resource for people looking to expand their fundamental knowlege
&gt; user authentication The [auth0 docs](https://auth0.com/docs) have pretty interesting examples for all types of authentication in tons of languages. It's probably worth checking out if you're into authentication.
Can you iterate over the collection more than once without resetting it? I made a library that did some very similar stuff, but I had to choose between huge performance losses and the ability to iterate over a collection more than once. Also, I might be missing something, but isn't [this](https://github.com/felixfbecker/iterare/blob/e79e1f991f95522c2f1be2fc66358a3827c68489/src/benchmark.ts#L13) a `Set` of a single element?
The examples and points made are great, but I feel the title is a bit misleading. Async/await still relies on Promises (they are just handled differently), and in some cases you may still want to use the `then()` syntax. This is especially the case when you actually want to make use of the asynchronous functionality, and not have one larger operation stop the entire script's execution. 
Thanks for the additional details. :) Looking at the list here, it only mentions variables, whereas your earlier post mentioned functions (and doing things, like "calculate", that simple variables won't do on their own). It's the classification of function/method behavior that most intrigues me. And if "should" applies specifically to variables, it does narrow down the reasonable meanings fairly well.
Not just variables, but _boolean_ variables. Other variables get just names (hoursSpent modelId lang etc) I don't have a formalised system beyond starting with an (imperative) verb for functions. I simply imagine myself explaining the code to someone more junior than me - "this calculates the average" -&gt; calculateAverage, "you use this to check if the UI needs updating" -&gt; checkIfUINeedsUpdating etc 
So now, just a short time after introducing Promises, we're introducing something new to fix the problems with Promises, and all, essentially, because developers want to type less?? What the hell are we doing?! 
aren't these absolutely not comparable things? async/await is just a syntax extension (syntax sugar) over promises operations. While promises are runtime effects library. Obviously using syntax sugar makes code simpler and cleaner, but why compare?
&gt;Also, I might be missing something, but isn't this a Set of a single element? I don't think you're missing anything. Looks like that creates an array of 10000 copies of the string `'file:///foo/bar'`, and then makes a set out of it, which definitely results in a single-element set.
Ah, okay, you have generalized rules rather than a distilled list of verbs and such, got it. I was hoping for a cheatsheet to review or the like. I like the word "calculate" because it shows that some work is needed to get the result, contrasting a simple "get" or similar.
[Edit: Actually, I'm deleting this, because /r/javascript isn't remotely the place for chucklefuck political debates]
Native promises support landed in browsers about three years ago and various libraries like Q implemented them years before that. It's hardly bleeding-edge technology and has been in widespread production use for a couple of years now. More than enough time for developers to run into any potential inconveniences with them and suggest how things could be improved. Eventually the good suggestions turn into ECMAScript proposals and if the committee approves them, turn into useful new language features. Besides, promises and callbacks aren't going anywhere. We are just getting a couple of new keywords to simplify asynchronous code. &gt; and all, essentially, because developers want to type less?? This is a silly reasoning for anything. Minifying code wouldn't be a thing if developers only wanted to type as few characters as possible. The point is to describe what we want to do in a simple way that is easy to understand. Sometimes it's useful to have a keyword that implies a common construct. Also async/await brings more benefits than just the syntax, did you not read the article? It pretty clearly mentions the benefits to error handling and debugging.
It can compile to anything that's semantically correct and that includes CPS, native promises, coroutines, goto, interpreter pattern, visitor pattern, you name it. Pass any object with a .then() function to await and if .then() returns a promise await will work as expected. Try it... const x = await new Whatever() where Whatever constructs an obect with a then that returns a vanilla promise. In this way async await is syntax sugar for promises. PS, the article is BS because async/await handles a subset of what you can do with the Promise API... things like Promise.all. You can say await Promise.all(...), but there is no sugar for Promise.all itself.
React is the logical next step. You don't strictly learn a framework but principles. That cannot be said about Angular, Vue and other template based frameworks because they bring their own abstractions and you end up doing things their way. They don't necessarily fix the inherent problems in the web but work against it by short-circuiting or circumventing it in often cumbersome and limited ways. For instance if you know what this is: function print(text) { console.log(text) } you know how React components work: function Header(props) { return &lt;h1&gt;{props.children}&lt;/h1&gt; } or shorter: const Header = ({ children }) =&gt; &lt;h1&gt;{children}&lt;/h1&gt; It has a tiny API surface, a few semantics, maybe 1% or less of the learning amount the others ask for. But you can later apply this knowledge to other frameworks or stacks. 
Why depend on jquery?
Another option is TypeScript with either Visual Studio Code (free and pleasant to use) or a JS IDE by JetBrains (really good at refactoring and other type-related stuff).
wtf is "hyperlink"?
Nope. I don't. And i'm not sure what's your problem really. This is why we're here. I share my opinion, whenever i want to, you share yours. And if you don't like it, how about you make an argument yourself. I don't think what i wrote is wrong. Angular implements a limited scripting language in extended markup. String templates do have inherent limitations like scope. And the functional approach has been taken up by dozens of new frameworks and stacks. It is also evident that the learning effort is larger. I'm not the only one to tell you this.
ok, let's call it a tool for promises, but why then a tool for something blows that something away?
"Correct" way would be not to include jQuery at all and (re)write that jquery funcionality in react/pure JS. It needs jquery only for some small parts (tabs, ...) - react-bootstrap uses react-redux-tab instead of jquery
Are you importing css separately for each component? That react-bootstrap size is not caused by few react components, but by bootstrap style files (which are loaded whole). Few lines of js doesnt make difference
Atom and install Nuclide package, it comes with a lot of features ( go to definition, autocomplete... ) without having to look for other packages. You will probably find the same experience with IDE.
That is nice. But not the same. Most frameworks today can be fed JSX or functional layout and have a similar property-based architecture. React was different not because they had some FP in it (it's mostly OOP and gets more into FP with Redux). It was different because it expressed UI in functions that take properties and return layout. And this is the principle that has taken over.
Ah, yes. I see your point.
Your template is a string, and thereby suffers from not having access to the language or scope. All the effort and learning involved is due to that limitation. And yes, functions solve it. Implement the following in Angular and you'll get the idea: import range from 'lodash/range' const Item = ({ number }) =&gt; &lt;li&gt;{number}&lt;/li&gt; const App = () =&gt; ( &lt;ul&gt; {range(0, 20, 5) .map(index =&gt; &lt;Item number={index} /&gt; ) } &lt;/ul&gt; ) Two components, App and Item. It prints out a list that says: 1 5 10 15. You can run it [here](https://jsbin.com/xemojasudu/1/edit?html,output).
Well, i assume you want to save/load your application enviroment in some way by serializing your objects? In that case, even if that powerfull serialization existed, it would not solve your problems reliably. May i suggest to try some patterns like flux/redux/mobx to explicitly define your application state and then save/load that state by means of simple JSON serialization?
And it turns out, that many of us unconsciously depended on that implicit conversion and are suprised by whole new class of bugs :D But pleasantly suprised - our Java developers are happier when js.Map works in same way as java.Map :D
This. It should be easier for those who already know Angular.
I think the link is a joke?
Get this through your head: angular templates are not reduced to strings. I don't understand why you think they are but the code is freely available on github for you to look at. They are reduced to javascript node objects. Just like react. And the above is trivial to implement in angular. But I did that for you before and you bitched about the @Component syntax being too wordy for your taste. So I'm not even going to bother. Once again this isn't about you liking angular or not. It only has to do with you spreading ignorance about other frameworks. I've seen you do it to angular. I've seen you do it to vue. It's tiresome and your arguments are literally wrong. I don't care if you run around praising react but stop spreading bullshit misinformation about other frameworks. I don't even care if you understand this or not. It's not about you. It's about the fact that you spread bullshit and less informed people might be taking you at your word. I just want other people to realize your full of it.
Taken over... in the react echo chamber and literally no where else. That's not to say it's bad. But it isn't the perfect solution that everyone is now catching on to and why didn't they just see the light before. It's just another choice.
You can't use a try-catch in the outer async function to catch errors thrown from the inner function? 
What is Promise resolve value of async function that not have explicit `return`? Is `undefined`? edit: yes is. I have image prove but my internet very slow now cannot upload
There's a misunderstanding. I'm still waiting for your example for the simple task above. Paste an example and you will get a better picture.
Ah... that's really too bad, was hoping some of the knowledge would be transferable. But the general consensus seems to be to go down the React/Redux route.
This is one of the major reasons why I kind of was wondering if it's worth going down the Angular route... It's hard enough staying on top of tech stacks but if they keep re-hauling so quickly, it becomes a pain to keep up.
I had the same problem a few months ago and because Angular2 was still in RC and decided to give react/redux a go and thought it was pretty neat. One thing that bothered me was the get going, I know this whole "bring you own library" stuff gives you a lot of freedom and at least me it slowed me down hard. After the final release of angular2 I decided to give that a go as well and was very surprised by it. the tooling works great, a lot of stuff just works out of the box which I think was pretty nice to get something going really quick instead of spending weeks on finding the right libraries. As for now. I like Angular2/4 ...whatever you wanna call it.
The only misunderstanding is yours because you think this is some kind of argument about angular. It's not. It's about you not spreading bullshit that you know nothing about. There's nothing here for you to win. Just stop saying stuff that isn't true. It's simple.
If you don't want it to automate it sounds like you can just 4 different divs and show/hide the one the user is currently on? Not sure about plugins, but coding this yourself should be a lot less complex than say form validation.
What's the use case for this?
I've yet to use that, but it looks like a layer on top of promise. Low level and high level usually have their use, and don't really compete, so I'm not sure how it blows the Promises...
Eh, I don't think that function redefinition is such a big problem in JS and something a good linter would not warn you, that you have to redo the way you write functions in a statement, which is foreign to most programmers (outside JS). Why not try to pass a *const* for function in the next version of ECMAScript instead.
There are still people using MD5? Wow.
Feels like they took the enterprisey parts of angular 1 and doubled down on it. In Angular 1 it already didn't feel like you were writing JavaScript but with Angular 2 that feeling has tripled. 
You can just use the create-react-app to help you decide with some common choices. 
I like it, clean, saved for later if i need a new node app. 
Interesting. I don't doubt that Angular 2 is great, especially since I really liked Angular 1 but React seems to be the popular choice nowadays, I think I'll end up going down that route for now. Are there significant differences between Angular 2 and 4? My major gripe with Angular is that it took me a while to grasp Angular, and they re-hauled the whole thing. It makes it tough to keep up to date if I have to throw out my previous knowledge. It also sounds like the documentation is kind of all over the place right now from what I read. And I'd have to learn Typescript as well.
I've never worked with Typescript, so I don't know which plugins provides a good/decent Typescript completion, but here's my 2 cent: - for linting I'm sure that neomake has a linter for that (here it is: https://github.com/neomake/neomake/blob/master/autoload/neomake/makers/ft/typescript.vim) or ALE (https://github.com/w0rp/ale) that provides typescript linting through tslint or typecheck - for searching across file consider using `:grep` and something like fzf. fzf is a fuzzy finder, it's pretty fast, while the build-in `:grep` command (`:help grep`) use the `grepprg` to find stuff inside files (tip: ag is faster than grep) hope it helps :)
Node's async `fs` methods still don't have Promises built in. It's really annoying that I need to wrap them in order to use modern patterns. Anyone know if there are plans to fix this?
Oh. When you really want to take it to another level, try codingwars. They have these exercises on algorithms that force the use of the language in very interesting ways. You can also learn a LOT from seing other people's awnsers. 
No, there's plenty of knowledge that's transferable, especially if you've started using components in Angular 1.5+. Angular 2 fixes a lot of areas where AngularJS was lacking IMO, and it looks more different than it is - largely because of the focus on using TypeScript, which is something React is moving towards as well. Keep in mind React is just a view library and not directly comparable to Angular without additional tools. This article has a decent overview of migrating from Angular to React, might help you out with your decision :) https://medium.com/@jrwebdev/migrating-an-angular-1-application-to-react-8891ec73d462#.aapzxh9fj
Thanks :) I'll run these down and see if they help. What general dev stuff do you use for your env?
I tried that one as well. But something I missed is like a structure, like other framework have provided that. like ember as well. I like especially diving into a new technology to have some best practices, but with the amount of info out there it is hard to tell. 
Yes. I agree React is right now the cool kid on the block and I get why. The whole rewrite thing and still calling it Angular was maybe a bit of marketing mistake. I started with a Angular 2 stack and couple of days ago just switched the version numbers in my package.json and ... it worked. Nothing I had to change. I expected a sea of error knowing the history of angular2 a bit. Yes I agree. It takes a bit of time getting use to. the docs are not on angular 1 level. far from it. I miss some really nice features I loved in angular1 but overall. I like it. Typescript is not really a hurdle. You get very far with just javascript, the decorator stuff is really nice and helps to read your code and I see typescript just as a very strict linter which helps a lot to keep some common bugs in bay.
if you are curious enough my `init.vim` is here: https://github.com/omar-polo/dotfiles/blob/master/editors/nvim/init.vim ; but I don't have nothing *wooo* inside of it. A cool thing that I found too late is `undodir` and `undofile`: basically vim store the history of the edits as an in-memory tree. You can tell vim to save that tree so if you edit a file, close vim and re-open that file vim still remembers all the history. Oh, and `emmet.vim`. It's awesome :)
It's so trivial to wrap them in promises, you might as well just do it yourself. But there are NPM packages for it: https://www.npmjs.com/package/async-file
&gt; This is especially the case when you actually want to make use of the asynchronous functionality, and not have one larger operation stop the entire script's execution. Not really sure what you mean by this. If you have one larger operation that you don't want to block the current "thread" of execution, just don't `await` it until you absolutely need the result of that operation in order to continue.
That for loop doesn't end after printing the pages I want printed. It keeps, if I reset it at the end will it stop he for loop? 
AFAIK that won't work if either firstValue or secondValue is a promise that needs to be resolved before you can continue.
It is object oriented programming. I am unsure how to explain it. With prototypical inheritance, you can not cast an instance of derived back to base, because base was more or less overwritten. you have inheritance with prototypes, but extension with classes. With prototype inheritance, there is no proper encapsulation, no control over polymorphism, and no sense of class. Although two objects may come from the same prototype, they are not of the same class; one object can not access the privates of another. This opens the door for messy code to just achieve the effect. As your data structures become more complex, you want strict relationship and control of access, because code itself is the most important documentation. Ironically, in JavaScript, because it is not a compiled language, encapsulation also becomes a matter of security. I hope this answer's your question. I think your best bet is understanding of Object Oriented programming, and then trying out CrxOop for complex problems after trying out the two alternatives, procedural and prototype inheritance.
I don't want to diminish your efforts, but: There are ES2015 classes that provide inheritance. They are syntactic sugar for the prototype inheritance and allow for subclassing, etc. For more advanced OO-Features one might look at TypeScript. It offers strong typing, classes, scopes, enums, namespaces, generics and interfaces. 
Catching up to other languages.
This is what I do, and changes nothing about what I said.
In 2017 people are STILL using Mongo? *palm to forehead* 
If you find yourself with more than 2 or 3 levels of components and need to pass around methods and properties, just make your life easy and use Redux.
I think the point is to not have to rely on yet another library for something that should exist natively now.
I have some bad news about Node for you then...
Not sure what you're getting at here...what'd I miss?
Thanks 
Indeed, both ES2015 and TypeScript are used by transpiling them to ES5 most of the time. It is more load in the development pipeline. On the plus side you deal with language constructs instead of a library API. This is very hepful for IDE support, leads to cleaner code close to a official standard that eventually will be represented by all the browsers. I'm not sure what you mean with "web development should be easy". Today, web development is in my eyes no different than any other software development domain. In some aspects (e.g. compatablility) it sometimes was even harder. Considering JavaScript itself I'd even say development today is easier then ever, especially for all the asynchonous functionality web development asks for. So the cost of having a compile step is greatly outweighed by the benefits. EDIT: Cleaner code in the sense of readability. 
Yes, it's the same as `return;` (or just implicit return at the end of a function). 
What do you use these days? I personally like firebase as my DB.
Oh, I actually haven't tried that. I will give it a go and see how it turns out. Thank you
ATM it depends on changes to css-loader ([#402]) and style-loader ([#166]) that haven't been merged yet. [#402]: https://github.com/webpack-contrib/css-loader/pull/402 [#166]: https://github.com/webpack-contrib/style-loader/pull/166 
Nope I'm leaving it up to the user to load Bootstrap. Loading CSS could get messy I don't want to assume any project specifics say the user doesn't have a webpack config setup to load CSS 
Well that sucks. The other option that I think of is to do the same thing with JQuery .hover(). Remove the hover CSS and use .css to change it dynamically. 
The issue is that the browser is event-driven... you can't say "is the button being held down?", you can only react when the user clicks a button: `&lt;button onClick="doStuff"&gt;submit&lt;/button&gt;` Then in `doStuff` you do `if (health &gt; 0) {....}`. The code only runs every time the user hits the button. If it HAS to be in a while loop (it should really never be in a while loop - it should at least be in a setInterval or requestAnimationFrame loop... otherwise your game will lock up the browser and use 100% cpu!) then you could have a flag based on the button. Inside `doStuff` you could set a global variable: `buttonWasPressed = true`. The main loop would be like: let buttonWasPressed = false; while (health &gt; 0) { if (buttonWasPressed) { buttonWasPressed = false; // do input logic. } } `buttonWasPressed` will only be `true` for one frame after when the user hits the button.
I will have to do some reserach about this since I am still very much a beginner when it comes to JQuery, but I will try this method. Thank you!! :) 
I guess we have a very different understanding of "web development". I never did "web development" in the sense of throw together a handful of HTML and add some JS and jQuery: I talk about highly functional SPAs. The effort to setup a build pass for those is neglible. This is web development as well, and trust me, it isn't easy. It's like any other application software development targeted towards the user. What is easy in web development is that every computer user has all technical tools at hand to do web development: A browser and a texteditor. That's all. I develop software professionally for quite a long time in several different domains and I have seen messy code by lots of developers (myself included) in lots of domains. I agree, that it was easy to "enter" web development. We have seen many designers turned web developers that were very inexperienced software developers. That lead to bad code as it does with every inexperienced software developer. I don't understand, why you compare CrxOop with React Angular and the likes. CrxOop does not solve the problems those frameworks try to solve. I haven't tried but I'd say you could use CrxOop to implement a web application with React. &gt; Advanced developers, mainly engineers I am assuming, always come up with the simplest solution, without sacrificing the domain of the solution. So you say it is a simpler soultion to use a library that asks me to implement classes using an "JSON-Notation" full of declarations obfuscated in strings ("publicStaticVar": "classA::publicStaticVar") than using a version/variant of the language that supports most of the OO-features out of the box with language freatures that support code hinting in the IDE, linting while I type, debugging using developer tools directly in the code I write, just because it involves a compile step during production? 
&gt; I just want to say I can't really write code, [but] I have a client [and] I started doing a new website for them, You see the issue here? &gt; They currently have a PHP script [and I] thought Squarespace would be a good fit for their use [but] it looks like Squarespace doesn't accept PHP scripts. Obviously your thoughts were wrong then. &gt; Please have in mind I'm a total noob on the coding stuff Be honest to the client and back to school, kiddo.
* What are the downsides compared to Immutable.js? * Whats the browser support? (I saw ES proxy being one of the keywords) * How is graceful degradation handled?
The intention was not to compare CrxOop with AngularJS or React. They are different things. The intention was to show my position and understanding that code on the web is far more complex than it needs to be. The intention is to explain my disposition toward more tools and a "compile" step. I developed projects far more complicated, back ward compatible, and performant, and yet with down to Earth javascript, server side code, HTML and css. I have seen further projects half as complex, with far more complicated code, far less efficient and backward compatible, written with libraries like the afore mentioned. Such libraries exist for a reason, but most of the time they are used for the wrong reason. A canon to kill a fly. This is why for CrxOop, I say try procedural, then try prototypes, then try CrxOop. Do not simply use it because it exists. Each problem is different. It is also good to understand that CrxOop, particularly v1.0, was meant as a proof of concept to show that current browsers could implement proper object oriented programming on Javascript without much difficulty. As for the JSON notation, it is the javascript syntax on javascript, not a new syntax or new tools. Surely you wrote objects before, and I am assuming many if you use the prototype approach. I am not trying to convince you of anything, simply answering your questions. As for CrxOop, try it, after that your opinion is yours, and can then be said well formed, but not before.
Hm. I think you can conditionally call console.clear() to clear the console... maybe have a function firing on an interval that performs a GET to the socket URL and, on failure, firing console.clear()?
Looks great! I did the same thing a few weeks ago but with Arrays and Strings, and its under 700 bytes. We also use browserstack for testing cross browsers and use graceful degradation. https://github.com/trainyard/pico-lambda
Awesome- thanks for sharing! And for the BrowserStack tip too. I'll take a look into using that for mewt.
Yeah! They'll gladly let you use their services for free when using an open source product as well.
You could use a canvas animation: http://codepen.io/lemmin/pen/zZJENm
[Philip Roberts: What the heck is the event loop anyway? | JSConf EU 2014](https://www.youtube.com/watch?v=8aGhZQkoFbQ) I want to add I don't know if the specifics regarding `process.nextTick` and `setImmediate` are laid out in this talk but it gives a *very* good explanation of how the event loop works and it may clear up some of the confusing parts inside the article you linked.
&gt;[**Philip Roberts: What the heck is the event loop anyway? | JSConf EU 2014 [26:53]**](http://youtu.be/8aGhZQkoFbQ) &gt;&gt;JavaScript programmers like to use words like, ‚Äúevent-loop‚Äù, ‚Äúnon-blocking‚Äù, ‚Äúcallback‚Äù, ‚Äúasynchronous‚Äù, ‚Äúsingle-threaded‚Äù and ‚Äúconcurrency‚Äù. &gt; [*^JSConf*](https://www.youtube.com/channel/UCzoVCacndDCfGDf41P-z0iA) ^in ^Science ^&amp; ^Technology &gt;*^312,341 ^views ^since ^Oct ^2014* [^bot ^info](/r/youtubefactsbot/wiki/index)
This is usually the goto for questions about this stuff: https://www.youtube.com/watch?v=8aGhZQkoFbQ 
- Oh, probably many. If I had to guess the biggest, it would be that mewt lacks the extensive API of Immutable.js- it is certainly not meant to be a replacement for that library. - Out-of-the-box I believe it would work in the latest versions of Chrome (but I haven't tested it! Only Node 6.9.4), however with a Proxy polyfill and compilation down to ES-whatever it would run fine on older browsers. I'm going to look into testing it using BrowserStack, per the comment below, and then we'll find out for sure. - It isn't... to be honest it didn't cross my mind. I was really just focused on modern environments when writing it. Thanks for your questions!
Having worked with promises for years now, ##1. Concise and clean These are all misunderstandings. * You don't need anonymous functions. * You don't need to give variable names to data you don't need. * You don't need to nest code. You also don't need explicit try/catch, because it's provided for you. You can skip deep guard statements, too: // Skip the guards, write the code you need getJSON() .then(data =&gt; { showHistory(data.user.access.history) }) .catch(showAccessDenied) // Need the guards const data = await getJSON() if (data &amp;&amp; data.user &amp;&amp; data.user.access) { showHistory(data.user.access.history) } else { showAccessDenied() } // Manually add try/catch const data = await getJSON() try { showHistory(data.user.access.history) } catch(e) { showAccessDenied() } ##2. Error Handling The irony is the promise example has the correct, complete code commented out. const makeRequest = () =&gt; { getJSON() .then(result =&gt; { // this parse may fail const data = JSON.parse(result) console.log(data) }) // Handles get OR JSON.parse errors .catch((err) =&gt; { console.log(err) }); } Everything in a promise chain comes with a built-in try/catch functionality. If you use them for flow control, you can decide whether you skip over the next steps or "fix" the problem. I have two examples on #5. ##3. Conditionals I find using promise chains helps decouple functionality and write smaller, reusable functions. const makeRequest = () =&gt; { return getJSON() .then(data =&gt; { if (data.needsAnotherRequest) { return makeAnotherRequest(data) } else { return data } }).then(data =&gt; { console.log(data) return data }); } ##4. Intermediate Values Since we're in the ES6 sandbox here, might as well use destructuring for fun: const makeRequest = () =&gt; { return promise1() .then(value1 =&gt; { // do something return Promise.all([value1, promise2(value1)]) }) .then(([value1, value2]) =&gt; { // do something return promise3(value1, value2) }) } There are times it is appropriate or convenient to save off a promise, like when you need to re-use the asynchronous output but can't change the outer scope to wait for the first promise, but in this example `Promise.all` makes more sense. ##5. Error Stacks People often think of promises as chains of anonymous functions wrapping actual behavior, but forget you can pass the function itself. const makeRequest = () =&gt; { return callAPromise() .then(callAPromise) .then(callAPromise) .then(callAPromise) .then(callAPromise) .then(() =&gt; { throw new Error("oops"); }) } Since the data is passed around, I like to make or use the named functions. It really improves the readability. Taking the example from #2: const makeRequest = () =&gt; { getJSON() .then(JSON.parse) .then(console.log.bind(console)) .catch(console.log.bind(console)) } To provide an example of my own: getUserData() .then(JSON.parse) .catch(useDefaultData) .then(fetchContent) .then(render) .catch(displayError) I don't have to care if the steps are sync or async. I don't have any extra anonymous functions. I can handle different errors as they arise, without nesting, even re-throwing them to skip code: getUserData() .then(JSON.parse) .catch(formatAndThrowUserError) // Thrown error skips these two .then() .then(fetchContent) .then(render) .catch(displayError) ##Others To make simultaneous requests, async/await requires you to invoke promises without the `await` keyword and then wrap them in a `Promise.all()`: // Simultaneous requests need declarations before await. const makeRequest = () =&gt; { const p1 = promise1() const p2 = promise2() const [d1, d2] = await Promise.all([p1, p2]) } // Serial requests. const makeRequest = () =&gt; { const d1 = await promise1() const d2 = await promise2() } // Simultaneous requests with promises. No declarations needed. const makeRequest = () =&gt; { Promise.all([promise1(), promise2()) .then(([d1, d2]) =&gt; { }) } Edit: submitted early without #6. ##6. Debugging If you don't wrap everything in anonymous functions (previously discussed) debugging gets a lot easier, and so does readability. Also, if you write your promise chains understanding that you get error handling "for free", you should have a better time of it, needing less error handling. I've even suggested to coworkers that when building chains, start like this: // Start with a promise, so any function can be called // Even it if isn't async. Promise.resolve() .then(doSomething) // Leave some space for more steps. .catch(developmentErrorHandler) .catch(productionErrorHandler) Because of the chaining, you can write a much more descriptive error handler **and insert it anywhere in the chain at any time**. Read out the error and re-throw. No side effects other than inline debugging. You can even leave it there and disable the debugging behavior with a flag (though that's a bit messy for prod code, IMO). Promise chains are also great for adding logging and performance checks. Get logging *between* your functions rather than messing around with the internals. function inlinePerf(message) { return function(data) { console.log(message, performance.now); return data; } } getUserData() .then(inlinePerf('before parse')) .then(JSON.parse) .then(inlinePerf('after parse')) .catch(useDefaultData) .then(fetchContent) .then(inlinePerf('before render')) .then(render) .then(inlinePerf('after parse')) .catch(displayError) 
Under console tab click "filter" and check "Hide network", that will only hide them, but that's usually good enough
Wow, that looks awesome but seems very complicated. I am in a starting phase of javascript and feel like I want to start on a low level and move upwards. Thank you for this suggestion :) 
Thank you very much. Should I even use a while loop then? 
Using filters is not really a workaround tho ;-) Also just a side note, socket errors won't be hidden tho (bug?).
For a text adventure I'd say you don't need a loop: if there's no background processing you'd need to do, you only have to react to input.
Uh, how is better than just `Object.freeze(target)`?
Thanks for the super helpful feedback. I might be able to fix my problem now! /s About the coding part, I was generally talking about JavaScript. I know enough HTML and CSS to get me through making a website for a client, at the very least through Squarespace, which doesn't really require all that much. I might have worded myself strangely, but I both suggested Squaresapce and went through a lot of the building of the site before I knew they even had a script. Instead of saying "sorry, but all the work is for nothing" because of a single script felt wrong, and of course I am honest with the client about not knowing how to write one, they don't expect that I know either. I am a graphic designer, and the client knows it, they don't expect me to know every code language. I was upfront on what I knew and what I didn't. They were perfectly fine with me setting up a Squarespace site for them. I know you know more than me about this topic, but instead of ripping through stuff that doesn't get me anywhere, why not help? 
Postgresql.
I second this. Very visual, easy to understand. 
It actually does the opposite of blowing away Promises, it forces you to use them, because await expects a promise. Nonetheless it's a nice addition.
You can `Promise.all()` around it in that case, or just pull the variable out of the inner functions.
~~This is the way to do it. Using `.then()` with async/await will make for messy and confusing code.~~ I misread the code.
&gt; I know you know more than me about this topic, but instead of ripping through stuff that doesn't get me anywhere, why not help? Because this isn't /r/help-me-make-my-website
Which is the way to do it? I gave two options, one of which works way better than the other (hint: it's the 'messy and confusing' option).
i never asked someone to make my website, i asked for tips or if anyone knew if this script already existed. what the fuck is wrong with this sub? 
It's not, it's a pet project.
That's still spitting out the network errors I'm afraid ;)
Looks nice! Thank you for explaination!
I know symbols themselves aren't new. I was wondering if it was new to use them as keys.
Not new to programming, you mean? They're new to javascript, and the whole reason they were introduced is to be able to use them as object keys.
I think they are experimental attempts at a stack of libs mashed together and ready as is. It has good for sure... but its bad in the monolithic sense 
Wow. Look, I was only trying to provide you with code to work off of. I couldn't understand what you were talking about with your top-level comment, and you haven't yet provided an example. I was hoping you would pick up on what I'd put to provide your own context. I don't understand why that's so hard. Also, you clearly haven't understood what I've written, so I get the impression that you just don't understand the whole topic that well yourself.
Why do you need this so badly, out of curiosity?
This! I find `async/await` to be great for simple one liners, but for more complex chains, I tend to write code similar to yours. Simple small functions that are easily testable and can be chained together. A huge benefit is that the control flow of a program is much clearer imo.
I found a generic way which seems to work: http://stackoverflow.com/a/43055806/2441655
I found a generic way which seems to work: http://stackoverflow.com/a/43055806/2441655
Thanks for the tip! Pico looks great, I always searched for a smaller Ramda alternative &lt;3
No, if `expensiveOperation` is CPU-bound, then it will not be run in parallel no matter what, unless it's out-of-process. Both of your examples execute the first part of the promise in parallel (let's pretend they are I/O bound like `fetch`), and then they execute `expensiveOperation` sequentially. There's no difference in execution, only the scope of the final promise that wraps the work is shifted.
I'd say it's the opposite. As promise chains become more complex and gain intermediate dependencies/conditionals, then `await` becomes more useful. One-liners are easy regardless.
Bluebird just returns promises, though you can use Bluebird.coroutine to get async/await-like semantics with `yield`. Beyond that, you'd use Babel to compile async/await into ES5 which can execute in the browser. Though imo async/await is more useful on the server-side while on the client, you tend to have a single request/response you're waiting on rather than complex async logic. 
Thanks for the response, I'll check out those features on bluebird. Unfortunately with the environment/workflow/software I use, there's no real opportunity to be compiling JS :) But, we do have simple async logic, just thought it might be nice to try. Thanks again.
A lot of people are using ES6 with babel. So it is important to have updated sources. But JS is changing so fast that I have a feeling that books can't keep up. Maybe a good strategy would be study the old technologies and use online articles and mdn to learn the new technologies.
I‚Äôve written my JS books for programmers. They cover all of JavaScript (starting with ES5, continuing with what‚Äôs new in ES6, ES2016 and ES2017). You can check them out for free here: http://exploringjs.com
Any recommendations on which one I should start with (I have a CS degree but im rusty at programming) but basic stuff is probably "too" easy for me? if that makes any sense ha.
I agree, but some people think function expressions should be used exclusively, because of edge cases involving hoisting with function declarations (to me it's just a benefit because I can structure my code more flexibly). And then some people just use arrow functions because they have a massive aversion to the `function` keyword altogether, for some reason...
Top-level `await` is/was being debated, but it's very controversial, don't hold your breath. I personally would like to see it, but there are ways it could be misused, especially in relation to async module loading (`import()`).
Bluebird's Promise.map, compared to Promise.all, has been more useful to me in every scenario I can remember. The most annoying problem with Promise.all for me is that if any executed promise fails, it goes into the catch block. Also it has no support for concurrency limits.
You can catch most errors by attaching listeners to your window (e.g. window.onerror, window.onunhandledrejection, etc). Of course you have to be weary of your code base and design accordingly. That being said, I would never dump anything to localStorage like that - tons of privacy issues if you start dumping stacks that contain private information and saving it to the user's computer. If you have no other choice, at least do it in sessionStorage so it's destroyed when the browser closes. Good luck :). Oh one of my favorite tools for doing this stuff too is http://js.jsnlog.com/ in case you want to get some ideas.
Yes, eventually, but they've made little-to-no progress so far. The discussions are all over the place, but the most concrete one has probably been this one: https://github.com/nodejs/node/pull/5020 They even created a working group at one stage, which currently seems dead: https://github.com/nodejs/promises An issue opened 5 days ago: https://github.com/nodejs/node/issues/12000 (I like the round number)
Start here, the pacing should be OK for you: http://speakingjs.com/es5/
This is a *fantastic* resource!! Thank you very much for the share! It will not be taken for granted. 
They're not outdated and they're still relevant. I haven't read them personally, but I've skimmed them in bookstores. They look like solid reference materials for web fundamentals. Jon Duckett books seem like they'd be good complements to Mozilla Development Network documentation. MDN is dense and comprehensive while Jon Duckett is simple, colorful and to the point. If you've got the money, I'd recommend picking them up. Hell, I'm in month 8 of my programming journey, and I plan on getting copies of both when I get my first job.
thanks!
I thought it was called kebab-case, never heard of "spinal-case" before :)
What do you mean? Example please. 
The primary reason to use it is feature complete code-splitting. That means the chunks are properly server rendered and they can be easily and automatically prefetched. Code splitting isn't a solved problem outside of Next.js, even by React Loadable. Code splitting still requires a second request to get the chunk, which means additional latency and no server rendering of that chunk. Progress to synchronously load chunks when available is in the works, but there's a lot of work still to be done to get the chunks from the server to the client in a general-purpose way. Next.js nails this. If and when we can code split chunks (as just described) outside of Next.js, I can't see any reason for large apps which require supreme customizability to take on an inevitably leaky "framework" and its restrictions plus unnecessary code surface. For small apps it's a godsend though. I'm also not a fan of no first class support for params in the path. Using the query for params is no bueno.
problem is that in the the for loop is an infinity loop, if I try to print with that it wont stop printing. that's what I'm trying to fixed but lack the skill do it. I been googling but haven't found what's wrong with it. 
Google "closure tutorial" and "monad tutorial" and do some Dom manipulation on a local site.... Maybe download the meteor tutorial and play around with that a bit. JS Is going to set you back where tools are concerned. 
Are these native JS Date objects? Moment.js might be more helpful for you
I am using Google Apps scripts...so I think I am stuck with raw JS inside the .js file. I do use Moment.js inside the index.html file in order to take a date from a calendar widget and pass it back to the Google Apps Script functions.
Noteworthy that is doesn't freeze child objects (similar to const).
Ok think I figured out a solution. If the end result is &lt; 0, than I assume it's a date range that crossed that 24hr mark into the AM hours...so I can take whatever that negative number is, and subtract it from 24. 11pm to 1am would be -22, or 24 - 22 = 2 hours.
Hey guys, Just wanted to share a project we've been working on for almost two years now. Our mission was to provide front-end developers with a tool, that cuts most of your work but at the same time, gives all your project a really thought out design. So what we did is we combined Twitter's Bootstrap with Material Design from Google and it turned out to look really well. We've also brought some minor and major fixes to all the Bootstrap releases so far, to make it more stable and reliable and got number of components based on JS. Considering MDB as a full-grown project by now, we would like to hear a feedback from specialists, so feel free to discuss our work. Thanks!
It does what it is supposed to, what you are looking for is a different method - one that does not exist in the native promise method list. I've seen it called `settle(...list of promises...)`. The problem - and the reason this is a different method - is precisely that it does not invoke the normal promise error path, you have to look for errors yourself, "manually". 
??? Your "sequential" doesn't `await` anything individually, so it isn't sequential at all. It is not clear what's actually happening in the example anyway, since you wait for `results` and I don't know what that is about. Sequential would be a loop that is stopped during each iteration because you `await` something. A loop that runs all the way through within the same "tick" of the JS runtime isn't sequential. Also, from other replies of you I see that you confuse the subject. No idea why you bring "processing" (of asynchronously obtained) results in - this is *only* about those asynchronous processes themselves, whether you run them sequentially or in parallel.
You may want to replace the gif element with a clone of itself on repeat. 
I took a different approach in my attempt with https://github.com/Wildhoney/Moggy by determining whether the function causes mutations, and if so, yields both the mutation and the `return`. import m from 'moggy'; const a = m([1, 2, 3]); const [b] = a.push(4); const [, c] = a.pop(); console.log(a); // [1, 2, 3] console.log(b); // [1, 2, 3, 4] console.log(c); // 3
Alternatively, you can put it in the HTML code: [HTML onclick](https://www.w3schools.com/tags/ev_onclick.asp)
I'm sorry, but I don't understand the question. Non-promise values passed to Promise.all are wrapped in a promise, and the resolution of Promise.all is an array of the results.
&gt; i asked for tips or if anyone knew if this script already existed. Here is an easy example to map ZIP codes to city names in plain HTML+JS. Instead of mapping the code to a city and output it you can do whatever you want to. You just need to code it. http://codepen.io/anon/pen/OpoeZE?editors=1010
NOTE: eventually the second parameter for map's .map function is an index which passed to parseInt. And parseInt accepts two parameters number and base, therefore, parseInt(1, 1) === NaN
It's brought back an ugly bit of Visual Basic parameter handling... var [first, , second] = names; console.log(first, second); // 'Luke' 'Phil' Uck...... [a, b, , , , , , ,c , , , , d , , , , , , , , ,f]
[removed]
Facts twice?
&gt; The worker processes are spawned using the child_process.fork() method, so that they can communicate with the parent via IPC and pass server handles back and forth. https://nodejs.org/dist/latest-v7.x/docs/api/cluster.html#cluster_cluster_worker That is a fairly manual way to go about it compared to many other languages that account for multi-core management internally closer to the metal. I am not saying the Node way is bad, but just that it requires more from a developer.
Absolutely true. My biggest gripe is lack of support for Web Push. I don't expect to ever see it on iOS under Tim Cook.
I've never destructured an array in production code. Haven't found a use case for it yet. Might be nice destructuring args at a specific arity.
Not quite. He's assigning person.facts to userFacts but also assigning person.facts.hobby to hobby. I've done something similar but usually on the next line for readability. const { facts: userFacts } = person; const { hobby } = userFacts; console.log(userFacts, hobby); same code. Confusing thing to me about renaming while destructuring is that it looks like an object so we are used to: { property: assignment } and destructuring is: { destructeredProperty [: newName] }
Don't over do it. In the context of parameters, it is annoying more often than useful. Take this example: ``` ({foo, bar}) =&gt; { // Bunch of code that depends on foo, bar } ``` Looks pretty (?). Now you want to find out what are other properties available in the first parameter. Your options are: use `arguments`, use debugger or refactor the code to be able to dump the contents of the first parameter object. Furthermore, you don't know whats the significance of the parameter by scanning the code (compare with `(request) =&gt; {}`).
Glad you like it. Enjoy!
Check [RiTaJS](https://rednoise.org/rita/index.php), JavaScript implementation of RiTa and [NLP-Compromise](https://github.com/nlp-compromise/compromise).
We can use pm2, I find it useful for starting multiple instances.
Are you suggesting that 'someFunction' is in the global scope with JSX?
Node solved the problem of how to do non-blocking IO on the server using Javascript. If the author has a good idea how to modify Javascript to be both multithreaded *and thread-safe* without breaking compatibility with the entire ecosystem of JS modules already out there, he should probably just suggest that instead of being snarky. I'm really on the fence about node's single-threaded approach, requiring you to spin up separate entire copies of your application to use all the cores in your machine. On the one hand *at first* it seems like a weird and gross hack to get around JS's inherently single-threaded/async nature, but the more I think about it the more it seems like a valid approach, as it massively simplifies the constant tar-pit of reasoning about concurrency and debugging race conditions in multithreaded code that's such a stinging PITA in some other languages. Instead your code only ever has to worry about a single copy of itself, and if it needs to communicate with other copies of itself it generally has to do that via well-established atomic/race-condition-avoiding external mechanisms like filesystem access and database requests. Instead of pushing all those problems into your code, node pushes all of them into areas where they're already an issue you have to reason about and solve anyway, like filesystem/database accesses, etc. It kind of forces you to write isolated, easily-parallelisable code by default if you want to get good usage of your cores, which is an... interesting approach.
It's usually when a function returns multiple values, essentially when using an array as tuple. It's also neat to split the head and rest (`[a, ...b] = expr`) but without pattern matching to handle the empty case (and tco to recurse) it's less useful. 
Yeah, I considered something like that! The problem is that I don't know how to do it ^_^'
It's useful to iterate with recursivity instead of loops. const sumWithRecur = ([first, ...rest], acc = 0) =&gt; { if (first === undefined) return acc; return sumWithRecur(rest, (acc + first)); } const sum = sumWithRecur([1, 2, 4, 5, 10, 23, 25]); // =&gt; 70 Mandatory in Elixir, for example, since there are no for loops in it. 
What about: getUserById(id) .then(user =&gt; Promise.all({ user, friends: getUserFriends(user) }) ) .then(({ user, friends }) =&gt; { // Access to `friends` and `user`. }); I know using an object isn't supported natively, but I've seen a lot of Promise libraries solve the problem this way. I think it's a lot more readable than using the Array form of Promise.all.
yeah webpack is an opaque garbage machine
Haters gonna hate. No but really people simply dislike them for being mainstream now.
This is right. You can always write a version of Promise.all that handles flipping any other type inside a single promise: all you need is a consistent way to traverse it (which objects don't really have directly, but you can always bake that into your method). Promise.all is not magic: it's actually just a version of Array.prototype.sequence with Promises baked in as the inner-type. 
Kebab case only goes to 10. Spinal case goes to 11.
I personally don't understand the main complaint here. I've been doing web dev for a long time with various languages and systems. If you're making a node webserver, why wouldn't you start up 1 process per core and just load balance the requests between the processes? Sure, it doesn't completely remove the issue of a blocked thread from a bad implementation blocking a single process, but I'd consider that a true bug, and really one that's not all that hard to fix (offload processing to a separate service). In the web dev world, we're somewhere between 90 and 95 percent IO bound. Node definitely helps solve that problem. Of course, I do prefer Go's solution to this, I do think it's objectively better, but that type of concurrency architecture doesn't lend itself so well to JavaScript as a language (async/await changes this quite a bit).
Structural sharing is a big advantage of Immutable.js. Under the hood, data structures are represented as *tries.* When an element is added or removed, instead of copying the collection, a new leaf node is added (along with up to log(n) ancestor nodes to create the new path to it): http://hypirion.com/musings/understanding-persistent-vector-pt-1
Promise.all's result is my most common usage of this pattern.
Hi /u/MilkingMaleHorses, please keep it civil.
https://www.reddit.com/r/javascript/comments/61q44j/6_reasons_why_javascripts_asyncawait_blows/dfjy3k0/ For you, again: &gt; I feel like its pretty obvious... It is! &gt; I'm just trying to understand what you were talking about. Read what I wrote? :-) Your pseudo code stuff makes no sense - your "process the result" has no meaning. That "process" may or may not include an asynchronous part, which is it? I think you are thoroughly confused about the whole thing. &gt; For each promise: [Process the result] This means *nothing*! What do you mean by "for each promise"? Do you or do you not `await, and if so when and what??? The pseudo code you wrote is meaningless gibberish, I'm sorry to say. For example, the section &gt; Sequential: [Wait for all promises to resolve] -&gt; [For each promise: [Process the result]] How is this "sequential"??? You do a `Promise.all` according to that description - that is **parallel**!! &gt; Parallel: [For each promise: [Wait for the promise to resolve -&gt; process the result]] Well, how else would you do it? How exactly would you process the result of a promise *without* waiting for it to finish? Meaning, how do you start eating the cake that still is in the oven? That **NOTE:** Your "processing" has NOTHING to do with anything I said, it is ONLY ABOUT THE ASYNCHRONOUS CODE. Remove all that "processing" from your pseudo code. We are talking about ordering the asynchronous stuff. You can **always** do your "processing" whenever the asynchronous result is there, who cares. The point is do you wait for **the previous asynchronous(!) task** to finish before starting the next one or not? &gt; If it isn't correct write out what you do mean. I did! See my previous comments, for example &gt; Sequential would be a loop that is stopped during each iteration because you await something. A loop that runs all the way through within the same "tick" of the JS runtime isn't sequential. I *do* make the presumption the reader knows how the Javascript event loop works, i.e. how a Javascript runtime processes the code.
this is the same thing that is happening to me in my situation. I am hitting 'ctrl+v' and the paste event is registered, but the image is not recognized so the program spits out 'no image found' or the like. 
Look at radio syntax first, for example https://www.w3schools.com/html/tryit.asp?filename=tryhtml_input_radio
See http://www.reddit.com/r/javascript/comments/61q44j/-/dfi888g
See http://www.reddit.com/r/javascript/comments/61q44j/-/dfi888g
 const makeRequest = () =&gt; { const p1 = promise1() const p2 = promise2() const [d1, d2] = await Promise.all([p1, p2]) } That's not really necessary. You could have also done: const makeRequest = () =&gt; { const [d1, d2] = await Promise.all([promise1(), promise2()]) }
&gt; If your code does something expensive that is CPU bound it can block everything else. You see, before using a hammer we used to drive nails into wood with other pieces of wood. But the hammer, being harder and heavier than a piece of wood, has a problem: if you hammer your own hand it can break the bones.
Doesn't jQ accordion have a built in to collapse all? Or at the very least change settings to resting and not show by default? 
It matters how you structure your asyncronous code when you have expensive operations to run on the results.
What's the "weakest" problem that's preventing one of the fixes? Is it possible to redesign certain things (easily enough) to make it work? 
There's so much integration from other elements, but I am still checking to see if I can do a work around.
Good luck man! If I have any insights I'll let you know 
Thanks a lot :D!!
Hi Damian, I liked how 20% of your article is literally the word 'JavaScript'. That's some nifty SEO right there.
You should learn js first. you are doing too many things wrong. You define a function base() in which you declare variables c and ctx. they won't be visible from outside of the function. base() is not a "class" instances - it is a function - bear that in mind. accessing base.[anything] doesn't make much sense in OOP. To populate ctx and c with data you need to call the function first. that is why you need to use base() with parens. and finally, just like any function it can return values, so when you return an object that case ctx field you naturally can access it through base().ctx
I get you - but I was wondering about the situation with "ctx"? If base was an IIFC thingy? So base.ctx - as you can see in the final large section of code at the end of the post?
I would put a -2 on that, adding "are you serious?" as a comment. 
 // sane option window.base = { ctx: null } window.addEventListener("load", function() { var c = document.getElementById("canvas"); window.base.ctx = c.getContext("2d"); } // iifc window.base = (function () { var ctx = null; window.addEventListener("load", function() { var c = document.getElementById("canvas"); ctx = c.getContext("2d"); } return = { ctx: ctx } })() Bear in mind that base.ctx will be undefined until load() event is processed. so you'll have to account for that if your code uses this object
[field1, field2, field3, ...remaining] = inputLine.split(','); 
Hi! On my phone now.... thats my problem exactly! Ctx stays null..... it's some sort of closure hiding it. In my code on SO not in your example. I could do a codepen example tomorrow? I want to understand it you see. I've taken your other tips onboard already and changed my code.
In the IIFE case (it is an immediately-invoked function expression), you are returning `{ctx:null}`. The only thing you change later is the variable `ctx`, not the property. Fix: var obj = {}; ... obj.ctx = c.getContext("2d"); ... return obj;
Just make sure you execute your script on the bottom of the 'body' element, after any other important scripts are declared, then you don't need to add an event listener, and you can simply execute the following: window.base = (function () { var c = document.getElementById("canvas"); return = { ctx: c.getContext("2d") }; })(); console.log(base.ctx != undefined); // should work or even no need for the iifc window.base = { ctx: document.getElementById("canvas").getContext("2d") };
You seem pretty hung up on the descriptions of the processes. Ignore the names, then, and call it what you like. In one case we wait for all promises to resolve, and then process them. In the other case, we process the results as they arrive. It's often important to use the second approach where the promises resolve at very different times or where the processing is expensive. I was just presenting this because I thought it was what you were talking about to start with. I didn't realise you were so irrational and abusive.
You already know the answer.
Huh? I started it this month and wanted to get an idea of what people thought. It will have all components once I decide the best design for each. Not sure what you're asking. I used react-bootstrap previously and wasn't happy with it
I would **never** write code like that. But I know people who would. Edit: and think they were clever for doing so (minus the label... that's just ridiculous).
These components are different because they're all-encompassing. For an example look at the Button Toolbar example here https://getreactbootstrap.com/button-groups See how ButtonToolbar and ButtonGroup are two separate components that need to be imported? Even that bothers me so my next step with this component is to make toolbar a prop on the ButtonGroup component so basically all you will need to do is import a ButtonGroup component to do anything related to Button Groups. Let me know if that makes sense
On that same note, more than one component required to do a single thing is inherently more complex and requires more brainpower when looking at examples or your own code. This is what I'm addressing and hoping to perfect with this library so even beginners will be able to copy paste examples without too much thought like they did with Bootstrap. Anything involving state in my public API is off the table
Is anyone interested in contributing? Let me know
If `num` is 1 then the loop will not be entered because `i` is already greater than orcequal to `num`.
I see, thank you very much! so for a `for` loop, is this the order in which the interpreter works? 1. set starting increment value 2. check if loop termination condition has been reached. if so, terminate. if not, execute code block. 3. increment the `i` value. 4. go back to step 1
Abstract the onclick function and call it instead. What you're doing isn't terrible, but it indicates you have other problems. &gt;if you simply try to change the class there was an overlap with other items. Imo, This is the problem you should be addressing. Given that you're using bootstrap and JQ i assume you're not overly confident in your css skills, but this issue is not going away and it's only going to get worse. CSS is def worth learning, bootstrap will put a very low ceiling on what you can make, and will prevent you from learning a lot too. My advice: use as few id and classes as possible. Learn everything about descendent* selectors and use them instead.
thank you! this is crystal clear! and now i have docs to reference, awesome.
No problem; mozilla is great in general to read over centralized docs that tie to all the JS proposals/etc.
iife. i'm bad with acronyms - saw iifc in the original post and didn't give it much thought. of course it is **E**xpression.
Interesting to see firebase in there
As far as I know, this is mostly due to the glimmer 2 &lt;-&gt; Ember.js glue. Glimmer on its own is very fast and competing with preact and the like. I have no personal numbers though, that's what they have shown in the EmberConf slides some minutes ago.
ok, this is lib size comparison. they're comparing just the vdom engine to entire frameworks like Angular and Vue. Preact is a good benchmark here for filesize.
Shit thank you, just by saying that you gave me an idea. I tend to use css alot, I'm less familiar with bootstrap, but it's mandatory for this task otherwise I'd use it for the most part. Thanks you just made me think about another way to do jt lol. Thank you everyone 
Glimmer does not do vdom diffing. Educate yourself. https://madhatted.com/2016/11/30/5-things-to-know-about-ember-2-10-and-glimmer-2. Also, Glimmer.js is more directly comparable to Vue and React, as these only include view layer by default.
Glimmer has been an exciting piece of Ember and has shown its exceptional rendering speed real world. So excited to see this as a standalone component library. Ember offers our team amazing productivity but the old object model felt stale, so excited by this!
&gt; Glimmer does not do vdom diffing. Educate yourself. my education is sufficient [1] to draw these comparisons. i'm going to do exactly 0 reading until i see good numbers on *existing* benchmarks that are not biased by the framework authors who design them. &gt; Also, Glimmer.js is more directly comparable to Vue and React, as these only include view layer by default. k [1] https://github.com/leeoniya/domvm
Nah just replying in a friendlier tone to someone cussing. Wouldn't call it shady, there's no reason to spit out errors in huge bold red text for each re-connection attempt, etc. Requests and responses can be seen from the network panel anyways, so the only thing it achieves is messy console output. Which log is more readable? &gt; Connection lost, attempting to reconnect... &gt; &gt; WebSocket connection to 'ws://localhost:4000/' failed: Error in connection establishment: net::ERR_CONNECTION_REFUSED &gt; &gt; WebSocket connection to 'ws://localhost:4000/' failed: Error in connection establishment: net::ERR_CONNECTION_REFUSED &gt; &gt; WebSocket connection to 'ws://localhost:4000/' failed: Error in connection establishment: net::ERR_CONNECTION_REFUSED &gt; &gt; WebSocket connection to 'ws://localhost:4000/' failed: Error in connection establishment: net::ERR_CONNECTION_REFUSED &gt; &gt; WebSocket connection to 'ws://localhost:4000/' failed: Error in connection establishment: net::ERR_CONNECTION_REFUSED &gt; &gt; WebSocket connection to 'ws://localhost:4000/' failed: Error in connection establishment: net::ERR_CONNECTION_REFUSED &gt; &gt; WebSocket connection to 'ws://localhost:4000/' failed: Error in connection establishment: net::ERR_CONNECTION_REFUSED &gt; &gt; WebSocket connection to 'ws://localhost:4000/' failed: Error in connection establishment: net::ERR_CONNECTION_REFUSED &gt; &gt; WebSocket connection to 'ws://localhost:4000/' failed: Error in connection establishment: net::ERR_CONNECTION_REFUSED &gt; &gt; WebSocket connection to 'ws://localhost:4000/' failed: Error in connection establishment: net::ERR_CONNECTION_REFUSED &gt; &gt; WebSocket connection to 'ws://localhost:4000/' failed: Error in connection establishment: net::ERR_CONNECTION_REFUSED &gt; &gt; WebSocket connection to 'ws://localhost:4000/' failed: Error in connection establishment: net::ERR_CONNECTION_REFUSED &gt; &gt; WebSocket connection to 'ws://localhost:4000/' failed: Error in connection establishment: net::ERR_CONNECTION_REFUSED &gt; &gt; WebSocket connection to 'ws://localhost:4000/' failed: Error in connection establishment: net::ERR_CONNECTION_REFUSED &gt; &gt; WebSocket connection to 'ws://localhost:4000/' failed: Error in connection establishment: net::ERR_CONNECTION_REFUSED &gt; &gt; WebSocket connection to 'ws://localhost:4000/' failed: Error in connection establishment: net::ERR_CONNECTION_REFUSED &gt; &gt; WebSocket connection to 'ws://localhost:4000/' failed: Error in connection establishment: net::ERR_CONNECTION_REFUSED &gt; &gt; Connected to socket server on port 4000 &gt; Or... &gt; Connection lost, attempting to reconnect... &gt; &gt; Connected to socket server on port 4000 &gt;
As Chrome discovered recently, existing benchmarks don't reflect real apps and optimizing for them made Chrome slower.
i see this "real world" claim made a lot. usually by slow benchmark apologists. yet, i have never seen a framework that does well across a diverse set of benchmarks but performs poorly in "real world" cases. if you can point me in the direction of such a lib, i'd appreciate it.
`console.log(arguments)` inside function. Check what it will log, it might help you ;)
It made my real app twice as fast. That's better than any benchmark.
what matters is the end result. how it works internally is 100% irrelevant and only interesting if it performs better than the alternatives - a claim that has not been shown except in jpegs.
thanks, i read about that too, but what worries me is that `arguments` and spread syntax weren't in the reading material for this problem. oh well
you should re-read my original comment. i did not say it wasn't 2x as fast as ember 2.9. all i said is that it was not "close to the metal" (it isn't). and that the numbers it presents are meaningless without context. had you switched to another lib, your app would have been 4x as fast.
Switching to another lib would have required a rewrite, and probably wouldn't result in a fair comparison as it wouldn't end up with exactly the same functionality.
i don't know what to tell ya. when you get to huge apps, the architecture/implementation makes a much bigger difference than the framework - unless the framework is complete trash.
Well this announcement is about Glimmer.js not Ember so a number of your linked benchmarks aren't fair if you are trying to compare Glimmer rendering to react/vue/inferno etc. Glimmer components will be pluggable into Ember apps or standalone like the other view libraries of late. I'm sorry you don't like the lingo being used, but I think generally its been shown that Glimmer is quite competitive with its peers. We could argue the virtues of Ember forever but thats for another discussion IMO.
can you spot anything in the implementation that would indicate that some other part of ember is causing the difference? https://github.com/krausest/js-framework-benchmark/tree/master/ember-v2.10.0-beta.3 EDIT: the fact that *this* comment is getting downvoted is rather telling.
See you got it sorted, just want to add you only need to check up to the square root of *num* when *i* is an odd number, will save you **a lot** of time and help prevent the browser freezing when checking large numbers. Also, you don't have to check every single even number, just a single check if it's divisible by 2 at the beginning of the function then only check odd numbers in your loop by having *i* start at 3 then increment by 2 every iteration. Another good idea would be to make sure negative numbers don't return true. function isPrime(num) { if(num === 2) { return true; } else if (num &lt; 2 || num % 2 === 0) { return false; } for (var i = 3; i &lt;= Math.sqrt(num); i += 2) { if (num % i === 0) { return false; } } return true; }
They actually updated their site to [https://flow.org](https://flow.org/)! And I try to always use flow as well. It is best when you setup a specific type schema for objects, like you did, or you get this kind of thing: `doCollisions = ({post: {x, y}: { x:number, y:number } }: { post: Object }): boolean =&gt; ...`
Any source?
I think you're being a bit too nitpicky there. For all intents and purposes, "metal" in this context obviously refers to the DOM API. With that said, the claim of being "one of the fastest" engines is indeed marketing speak for "roughly on the same order of magnitude as dozens of similar libraries".
&gt; same order of magnitude in DOM frameworks, a single order of magnitude is the difference between 6fps and 60fps, not 6000fps and 600fps as would be with "bare metal"; context matters. given that we actually have web tech *today* that can get close to the metal, this comparison is extremely disingenuous. by this measure, all dom frameworks are the same speed. i'm very sensitive to unsubstantiated marketing BS :/
Well, you're first making a ridiculous comparison, then asking people to *prove* that your comparison is not not ridiculous. How about you dig into this enough to conclusively say that the remainder of Ember contributes marginal overhead to that benchmark? You're the one pushing a claim here.
naive question: what value does source code protection offer? If paranoia hits a certain point aren't you better off just making a SaaS? It always struck me as a selling point targeting pointy-haired bosses but I have 0 context. 
is any of this stuff actually used in this bench impl? i know the router is not.
So you don't know enough ember to make an optimal implementation, but are perfectly comfortable concluding that Glimmer (and *not* the rest of ember) is without any doubt the source of problems with the benchmarks you're citing? How do you not know enough about Ember to do work while simultaneously (apparently) knowing enough about it to make this conclusion?
Yeah, I find browser support for localStorage to be sketchy - I'd avoid it if you can. You can collect store stack traces into session snapshot objects (in memory), and use setInterval to periodically fire them off to a collector, wipe the object, and start over. As /u/nickgcattaneo said, use the default listeners to collect these, and you can also manually feed them in your throw/catches. That's a simplified explanation of how New Relic and similar tools report errors. 
And had they switched to standalone Glimmer it would have been "4x" as fast too. Ember !== Glimmer
Embers object model, and observers are a core part of Ember so yes it's using them. Also the router is being used in that benchmark, there just aren't any routes asides from the default index. Though I have not done it, I think you can use ember without the router.
We should constrain the discussion to Glimmer, not Ember. ~~This is not the same as Glimmer2 in Ember, it is a stand-alone library that they are working to port back into Ember to take the place of Glimmer2.~~ Edit: That's not exactly true - the Glimmer part is pretty similar. The component implementation is different. By your links, you seem to have some experience in this field, it'd be interesting if instead of railing about the marketing speak, you actually shared your experience constructively by looking at what they are doing and contrasting that with what you know about doing this kind of thing. I know I'd be interested in that. I'm sure within days there will be performance metrics for us all to look at, dissect, etc. You could also just add the comparison to the repo you linked, I'm sure they accept new submissions. (edit to add: I think the discussion you wanted to have is important, even if your method of broaching the subject was not great. It's unfortunate that people are downvoting it rather than having that discussion.)
I was trying to copy an image from my windows explorer. So i will try again tomorrow selecting an image from the web and see if that works. Thanks for the info!
Not naive at all! It's a fair question. First off, some products are not suited to being services. Secondly, JavaScript has just entered the desktop space which has been dominated by languages like C and Java for a very long time. Open source is great, but as soon as you want to monetise your app, it can, in some instances, become a concern, especially for investors. If you put money behind something, you generally would like to know someone can't take it from you for free. Think of enterprise type software or games. If a competing company could easily get the source code for Microsoft Excel or Skyrim, it might be bit problematic for those companies no? Bottom line, it's just another layer of security for your app and it's been a fairly controversial topic for Electron. Many people want it and NW.js already has it so if it's what you want, you might consider making the switch.
&gt; given that we actually have web tech today that can get close to the metal The problem, of course, is that WASM/WebGL definitely do **not** meet the "without sacrificing ease of use" criteria. I guess for an Ember outsider, it's somewhat old news that their marketing is not the most transparent around, but for those whose job largely involve doing things like Ember migrations, going from the old days of Ember doing low single digits in dbmon to where it is now is a change of hyperbolic proportions.
which is great
Why would you use that? Simply for reducing the bundle size?
Woah, so that's how ES6 imports work! import React, { Component } from 'react'
It should be `value`.
2015 called, they want their node hate back. Too late buddy, node already won.
&gt; The problem, of course, is that WASM/WebGL definitely do not meet the "without sacrificing ease of use" criteria. "Ease of use" is not only not a criterion of being near the metal, but also a classic reason that most people can't cope with machine-near programming.
&gt; Well, you're first making a ridiculous comparison, then asking people to prove that your comparison is not not ridiculous. Why do you assert that it's ridiculous? Why is it unreasonable to expect you to explain that?
The claim is useless without a benchmark, actually
You can create your own custom events which are separate from DOM events. See [this tutorial] (http://www.datchley.name/es6-eventemitter/)
Browserify produces pretty bloated builds. The Ember CLI build uses Rollup to treeshake unused modules. 
Web workers for multicore. Node didn't choose event loop, they made usable for servers. Huge difference This author really doesn't know what he is talking about. 
I'm excited about serverless for a few reasons: - For the same amount of work to set up a "serverless" server, you get near-infinite scaleability basically for free - If you have nearly zero traffic, the cost of running the server can be pennies per month, instead of $5-10 for a VPS - The server-side software you can access is limited, since it is all preinstalled (this is a downside), but managing the server's software and health is no longer your responsibility. No more "Oh no, the MySQL server crashed because we didn't set up the page file correctly!" Or "Oh no, Apache's configuration file has a syntax error and now all our websites are down!" Serverless at its best renders devops and database administration obsolete. Now this can be handled by a single dev without maintenance.
Eck muh script
You are right, thanks for the correction!
The web world **fucking loves** terminology subversion like this. I still remember the wave of "browser **operating systems**" which consisted of throwing some JavaScript on top of tables styled to look like desktop windows. One PHP back-end framework (Symfony) calls their core a **kernel**. Where in a kernel is just some component of a few hundred lines that emits events to subscribers. I also thought when the post claims this is a **renderer** ... then it **renders** which implies some sort of immediate mode drawing instructions. As you say: canvas, WebGL, something. Nope! Just messing around with DOM, and using the words that the Big Boys are using. I bet one can write a *mad "operating system"* in that *"renderer"* though.
&gt; For all intents and purposes, "metal" in this context obviously refers to the DOM API. Yeah **obviously**. Facepalm. Because there's nothing closer to the metal in the browser... say like the Canvas and WebGL APIs, which the parent commenter mentioned. Yeah? No. If I didn't know the average level of (lack of) self-awareness in the JavaScript world, I'd be convinced your post is sarcastic. Unfortunately, you're probably serious as hell.
So what's the problem?
See my other posts, you continue to write strangely irrelevant nonsense. "Sequential" would be a loop that is stopped during each iteration because you `await` something. A loop that runs all the way through within the same "tick" of the JS runtime isn't sequential. Also, from other replies of you I see that you confuse the subject. No idea why you bring "processing" (of asynchronously obtained) results in - this is *only* about those asynchronous processes themselves, whether you run them sequentially or in parallel. **THIS IS ABOUT ASYNCHRONOUS PROCESSES**, do your processing WHENEVER, that has nothing to do with anything! You keep coming up with some strange "processing" step, when **THIS IS ABOUT ASYNCHRONOUS TASKS** -- do your processing **whenever**, it doesn't matter! Not part of this discussion. This is only - **only!!!** - about the asynchronous tasks. https://www.reddit.com/r/javascript/comments/61q44j/6_reasons_why_javascripts_asyncawait_blows/dfjy3k0/
See https://www.reddit.com/r/javascript/comments/61q44j/6_reasons_why_javascripts_asyncawait_blows/dfjy3k0/
Here's an efficient imperative version that type-casts strings &amp; single-value arrays to numbers - if type-casting fails, then type errors are thrown (in JS, `NaN` is the only object not equal to itself): function allOrNothing (mod, /* ...nums */) { var i = arguments.length; var num; mod = Number(mod); if (i &lt; 2) { throw new ReferenceError('insufficient arguments'); } else if (mod !== mod) { throw new TypeError('expected mod to be numeric'); } else { while (i--) { if (i === 0) { return true; } else { num = Number(arguments[i]); if (num !== num) { throw new TypeError('expected argument:' + i + ' to be numeric'); } else if (num % mod !== 0) { return false; } } } } }
You could try [libgif](https://github.com/buzzfeed/libgif-js). I think, two of this features will be usefull: &gt; move_to(i) - Move to frame i of the gif &gt; play - Start playing the gif
If you want to see a basic glimmer app running, I set up this from the @glimmer/blueprint: - https://glimmer-test.glitch.me/ - https://glitch.com/edit/#!/glimmer-test Edit: - Production build: https://glimmer-test-kajipojfud.now.sh/
It does matter when you do your processing. If you `await Promise.all(fetches)` and then do your processing only once they've all completed, you are essentially tying all the fetches to the longest running one. If any one of those fetches takes a long time, then you have to wait that long time before you can do any useful work with the results. The alternative is to `await Promise.all(fetches.map(f =&gt; f.then(processResult)))` which enables you to do your processing while long running fetches are still going, which is clearly the better option. 
also to prevent calculating static things at runtime. If everything you use polished for is static, then it won't even need to include the runtime in the app.
I made this [example](https://jsfiddle.net/Lsva1jtd/) for you. the fastest way to restart gif is to reload it with additional timestamp parameter in url: var bg = "url(" + loaderImg + "?ts=" + Date.now() + ")"; But it will cause additional network payload. You can try combine this script with libgif: preload gif to separate hidden &lt;img&gt; and then call move_to(0) each time background shown. Another way is to put gif image under the text in your list item element, so you will be able to operate it with libgif.
The past year or two‚Ä¶ Basically, the idea of separating presentation and content is too simple for web apps. There is a grey zone, presentation influenced by content. Plain CSS doesn't cut it, and inline styles are cumbersome. CSS-in-JS allows you to paint your code grey :)
Declaring the separation of JS, CSS and HTML to be the waty to do separation of concerns in regards to frontend development is something I usually equate to going compu bankrupt. Sure, you're separating them into three different file types, but that's honestly not really separation of concerns, or at least only on a very basic level. Since a good deal of frontend development today is about developing complex applications that fetches data, does routing, takes user input etc., you should start looking at the higher level definition of separation of concerns, that is, creating extremely modular code. Most frameworks also encompass this. Vue does it by allowing you to have single file components where you define both your markup, JavaScript and CSS in one file, thus making that *component*, and thus, the feature it encompasses, a singular concern instead of attempting to make the different file extensions a concern. 
Being abusive doesn't make your point any more clear. Write some code to demonstrate it and then we might be able to understand what you're on about.
&gt; It does matter when you do your processing. As I already said: **THAT IS THE WHOLE POINT!!!** Why do you keep bringing up your "processing" (of the results), as you just recognized, the subject is **THE ASYNCHRONOUS TASKS** in the first place! And I said &gt; You can (re)write this using async/await just as fine - in your example it may actually be better. The problem becomes clear when you imagine iterating over an array and starting a number of `fetch` tasks at once! If you use async/await they are run sequentially - it's very unlikely you want that. Instead, create the promises but *don't `await` them*, collect the promises into an array and then `await` the entire array using `Promise.all`. So whenever you want to run several I/O tasks in parallel instead of waiting for each ones completion before starting the next do you need to use the pure promises and *not* `await` them individually. https://www.reddit.com/r/javascript/comments/61q44j/6_reasons_why_javascripts_asyncawait_blows/dfjy3k0/
"Mom, mom, look, I made readme, moooom you're not looking! I am here and I made a readme! Mom, look!"
Mm, do prefer the Vue.JS approach to single file components then. One file with: &lt;template&gt;...&lt;/template&gt; &lt;style lang="scss"&gt;...&lt;/style&gt; &lt;script&gt;...&lt;/script&gt;
See my other posts, you continue to write strangely irrelevant nonsense. "Sequential" would be a loop that is stopped during each iteration because you `await` something. A loop that runs all the way through within the same "tick" of the JS runtime isn't sequential. Also, from other replies of you I see that you confuse the subject. No idea why you bring "processing" (of asynchronously obtained) results in - this is *only* about those asynchronous processes themselves, whether you run them sequentially or in parallel. **THIS IS ABOUT ASYNCHRONOUS PROCESSES**, do your processing WHENEVER, that has nothing to do with anything! You keep coming up with some strange "processing" step, when **THIS IS ABOUT ASYNCHRONOUS TASKS** -- do your processing **whenever**, it doesn't matter! Not part of this discussion. This is only - **only!!!** - about the asynchronous tasks. https://www.reddit.com/r/javascript/comments/61q44j/6_reasons_why_javascripts_asyncawait_blows/dfjy3k0/
Go for it, no fear :)
I'm going to modify your examples to demonstrate the issues with both: // OPTION 1 for (let i=0; i&lt;n; i++) { const contents = await asyncFetchFile(fileName+n); ignore fileContentsBecauseWhoCares(contents); } --- // Change names for clarity and added context const urls = [...]; // Some list of urls const data = []; // Accumulator for the processed results for (let i = 0; i &lt; urls.length; i++) { const url = urls[i]; const result = await fetch(url); data.push(processResult(result)); } --- // This is the same as: const urls = [...]; // Some list of urls const data = urls.map(url =&gt; { const result = await fetch(url); return processResult(result); }); --- // OPTION 2 const promises = []; for (let i=0; i&lt;n; i++) { promises.push(asyncFetchFile(fileName+n)); } const contentsArray = await Promise.all(promises); for (let i=0; i&lt;n; i++) { ignore fileContentsBecauseWhoCares(contents); } --- // Change names for clarity and added context const urls = [...]; // Some list of urls const promises = []; // Accumulator for the promises const data = []; // Accumulator for the processed results for (let i = 0; i &lt; urls.length; i++) { const url = urls[i]; promises.push(fetch(url)); } const results = await Promise.all(promises); for (let i = 0; i &lt; promises.length; i++) { const result = promises[i]; data.push(processResult(result)); } --- // This is the same as: const urls = [...]; // Some list of urls const promises = urls.map(url =&gt; fetch(url)); const results = await Promise.all(promises); const data = results.map(result =&gt; processResult(result)); I hope you are following so far. I have kept your algorithm the same for options 1 and 2, but changed the structure and context so the point I want to make is more clear. I trust you are fine with that? Now let us imagine that we want to run those two options. We need to supply some urls, and say we have 2 of them: `urlA` and `urlB` - i.e. `const urls = [urlA, urlB];` in the above options. Now, imagine that `fetch(urlA)` takes 1 second to resolve, and `fetch(urlB)` takes 10 seconds to resolve. The function `processResult` always takes 5 seconds to run. Option 1 will run as follows: `fetch(urlA) -&gt; processResult(resultA) -&gt; fetch(urlB) -&gt; processResult(resultB)` for a total of 1 + 5 + 10 + 5 = 21 seconds. Option 2 will run as follows: `(fetch(urlA) + fetch(urlB)) -&gt; processResult(resultA) -&gt; processResult(resultB)` for a total of `max(1, 10)` + 5 + 5 = 20 seconds. An improvement. However, there is a third option, which demonstrates what you have missed: // OPTION 3 const urls = [...]; // Some list of urls const promises = urls.map(url =&gt; fetch(url)); const data = promises.map(promise =&gt; promise.then(result =&gt; processResult(result))); Option 3 will run as follows: `((fetch(urlA) -&gt; processResult(resultA)) + fetch(urlB)) -&gt; processResult(resultB)` for a total of `max(1 + 5, 10)` + 5 = 15 seconds - this is the optimum approach, and is better written using `.then` rather than `await` since `await` becomes messy, which is the point I was making in the first place. It is not accurate to say that the processing function is 'incidental'. Where you carry out your processing can dramatically change how your asynchronous code runs and I think I have demonstrated that here. Instead of waiting for all async tasks to resolve before proceeding - as in your option 2, you want to carry out synchronous processing as soon as results are available - as in my option 3. In this case, it is not true to say that it would be better to rewrite it using `await`, since the `then` syntax is more clear and concise. Hopefully you've understood all this and if you can appreciate that your thinking was deficient, then I can forgive your unreasonably abusive behaviour.
[removed]
When we talk about functional programming, there's often a lot of focus on things like currying and partial application. This is rather superficial type of syntax sugar, which is one line of code in just about any language. I wish we could step away from these things and start focusing on the meat of functional programming. Maybe one problem is that once we peel away this layer of gimmickry, what's left is basically the enforced immutability and separation of effects. Having a language guarantee about this is useful, but not *that* useful if you work in team where architecture is guided by an experienced developer. Of course there also things like first-class closures... but we're already programming using closures in most imperative/OOP languages. This is one FP feature that has become a traditional part of OOP vocabulary.
https://medium.com/javascript-scene/setstate-gate-abc10a9b2d82
I suppose that depends largely on what you're trying to do. 1. If you want a console gui, then stick with python and teach yourself ncurses. 2. If you want a local desktop gui, then stick with python and learn the Qt framework. 3. If you want a remote desktop gui, then stick with JS and use any number of solutions to communicate between your program and your JS code. If you pick #3 solely because of lack of experience AND a lack of time, then fair enough. But if you have the time, and don't NEED #3, then I'd recommend #1 or #2 just because learning new, relevant tricks, is never a bad thing. Assuming you're going with #3 no matter what, then you have several options: 1. Your python program can easily spool up its own web server and you can use Flask to very quickly build a REST API that can help you talk between your browser and your program. The benefits here is that it's rather neat and tidy and nothing is spread out all over the place. The downside is that it won't scale at all. This approach is suitable if you want something like option #2 above. A local application. 2. Your python program can start a basic TCP server. This will certainly take longer to develop and debug, but it is more robust and decouples your UI from your "business logic" so to speak. You can run the program on one computer, and run your web UI on another server, and they will communicate with each other over a basic network connection. 3. Use a message queue. This is complex and probably not necessary and I would not personally do it unless the message queue was necessary for other things. But if you can make use of something like Kafka or RabbitMQ for multiple projects, then it might be a viable solution. Your WebUI and your python program can send messages to one another and react to different messages in different ways. 4. Rewrite everything. The downside is that you don't learn python, which is a great and powerful language. The upside is that, assuming your program is not very complex, you might complete your project sooner. You'll have a simplified tool chain and dependency management and other simplicities that you get from sticking to a single tech stack. But if your console program is sufficiently complex and it works fine, then I personally would not bother with this approach. Don't fix what's not broken after all... 5. Have your console and your webUI poll a database of some kind and have them react to what they get back from said database. Don't actually do this though. It's the redneck equivalent of a message queue. 6. There are probably other, slightly more esoteric ways you could do this, but why bother... 
You're right, that's indeed the issue. presentation/content !== css/html. In web apps, it's a lot more complex than that.
[removed]
Oh god, not Eric Elliot. This guy spends like 99% of his time retweeting his old Medium posts. All of which can all be summarized as "function good! state bad! I BEST!". Oh, and promoting his online course which is "launching soon" for the last few years. He is a total self-aggrandizing zealot. Also probably doesn't even have a HDD to keep his computer "pure". Sadly, he keeps popping up on search results as much as W3schools does, but he's not half as useful.
Shrug. I'm not the one claiming to be "close to the metal", I'm just pointing out that's the interpretation the Glimmer team is using. The term "close to the metal" isn't necessarily absolute. It's perfectly fine to say that Java is "close to the metal" if the context of the conversation is about Groovy, even though Java is nowhere as near the metal as ASM. Similarly, if someone asked which one of vanilla js and jquery is close to the metal, you'd say vanilla, not "fool, real programmers write asm in hex!" because while the latter is a pedantically correct answer, it is also irrelevant to the topic at hand.
http://amol-mandhane.github.io/htmlPy/ maybe? Build for scenario's like yours There is also this http://stackoverflow.com/questions/32483246/python-creating-desktop-application-with-html-gui First answer &gt;Use PyQt, Qt WebEngine and Qt's builtin support for hosting HTML applications: &gt;http://doc.qt.io/qt-5/qtwebchannel-index.html &gt;The general architecture is a SPA (Single Page Application) running from local HTML and Javascript content bundled with your app ‚Äì no need for bundling in a web server. &gt;For anything complicated (like bypassing cross origin issues), use the Qt WebChannel to message to functionality built on the Python side. &gt;This is basically the same architecture that Cordova uses. &gt;Now, whether you should build an application this way (cough QML cough) is a completely different topic.
I don't really care who's the author as long as there's interesting content 
This basically boils down to the old dichotomy between programming ability vs productivity. The DOM is incredibly high level compared to raw pixels, yes, but it also gives you really nice things like text wrapping and search engine visibility. Claiming that WebGL is a suitable replacement for the DOM is itself a farce.
In a TL;DR, who's Ken Rockwell?
He's just another self-aggrandizing opinion peddler. http://anotherangle.eu/posts/why-ken-rockwell-is-bad-for-photography/
He can be insufferable at times with his elitist attitude but to say he provides no value to the community is inaccurate, imo.
I'm glad to find other people bothered by this guy.
Ok that makes sense. I see how it all fits together now. Previously I thought I'd like to try using glimmer in some other frameworks but it felt so tightly coupled to ember I wasn't sure if that was the intended use. Knowing the end goal sheds some light on things. Their landing page isn't that clear to someone who doesn't know the ember framework before. Thanks for clearing it up.
From the unchanged blueprint the glimmerjs.com site instructs you to start with as a demo (which also includes the glimmer resolver), `ember build --environment=production` produces the following for me: 154K app-555233242b93e9251b43dca5658505bc.js 34K app-555233242b93e9251b43dca5658505bc.js.gz 
&gt; Functions don't really store state Closures being an exception
Don't forget "Never hire anyone who likes classical inheritance"!
But he's a *compassionate entrepreneur on a mission to end homelessness*!
It hasn't had a final release yet, right?
Yeah, you're right. Wasn't thinking.
lol @ "all the 23 design patterns"
Still no webrtc. :-(
&gt; and other unknown fields such as Artificial Intelligence, Virtual Reality and Augmented Reality. Is this the most important article ever written? While writing this, supposedly 3 sub fields of science that were previously unknown were founded.
Who should we follow?
I got some numbers from the Ember CLI and it seems browserify is within 10-15kb when min+gzip (pretty huge margin IMO). I think 30kb min+gzip as the "app foundation" is great! Generally app components and wiring gets heavily minified down. At least this is true with the React/Backbone apps I've built. Awesome job shipping Glimmer btw :)
It's the same reason why Ogg is not a part of the html5 &lt;audio&gt; standard... because Apple are a bunch of control freaks about codecs &amp; insist we use the ones that 1) they partially own (MPEG LA), and 2) their devices have hardware acceleration for.
Does Vue has a large community? It has a Huge community, the best! The community is perfect and awesome, and we are going to send the bill of having a community to react! PS. quit comparing useless metrics to get a false sense of security
I don't really get the desire for WebRTC. With it I imagine a future where I am shopping online and instead of being bothered by sites to chat with some sales person (which happens now), I'm going to be pestered to video or audio chat with them. 
in IE? When I run it, IE freezes, the console message is not displayed and the class is not added to the surrounding div. If I remove the "d3map" function though, it runs as it's supposed to in IE.
Just manage the url yourself and listen for changes. It's not that hard 
I'd caution our more junior engineers against this kind of thing. GoF patterns are designed specifically with C++ in mind and JavaScript has different abilities and use cases. Things like abstract classes and interfaces don't really make sense in JavaScript, even when using something like TypeScript. Some of the patterns offered in the GoF book are handled by the JavaScript language itself for you. In my experience, people new to patterns often get them backwards. They learn about patterns then look for situations to implement them in their code. Generally they struggle with this for a while and give up on them. It takes some amount of time afterwards to realize that they are actually implementing these patterns naturally as part of their every day problem solving and that usually it's just a matter of tweaking a few things to make them conform to common idioms. Design patterns aren't some magical thing that suddenly make your code better when you put them into it. They're a shared language for problem solving that help people from different backgrounds and with different experience levels communicate consistently.
I never defended the WebGL position. I was simply pointing out that the phrase "bare metal" has nothing to do with ease of use. People seem to be trying to bend the meanings of phrases to win at arguments, here. 
It could be anything in the D3 code, really. My problem is it's being loaded and run, even if the test fails. Is there a way to force it to run the if/else and if it fails, totally completely kill it from running anything else? Or maybe I can just go through and fix the arrows.... 
Thanks, I got rid of the arrow functions, and it seems to work. http://codepen.io/joelf/pen/MpzapP
yes, you are right. It should not be used as a silver bullet. Also the most part of the patterns will have a totally different implementation as JS is a prototypal dynamic lang that supports high order functions and this patterns was created on the shadow of smalltalk and C++. This is pretty much what Peter Norving talked about (but comparing with dynamic languages in general).
That's correct. But Ogg was proposed to be part of the spec and Apple fought it tooth and nail to get it removed. So now we have an &lt;audio&gt; tag standard, but no standard codec, leaving support quite fractured across browser implementations. WebRTC *does* specify standard codecs - and guess what - they're not Apple's or MPEG LA. *That's* why you don't see WebRTC yet, because they really don't want to support those codecs. EDIT: See this [Wikipedia](https://en.wikipedia.org/wiki/Use_of_Ogg_formats_in_HTML5#Opposition) entry for more information. There's a lot of corporate opposition on this issue &amp; I don't believe its in our best interests for an open web.
This feels all over the place. It starts with a cute story about the author, then briefly talks about the history of lambda calculus, but these don't really have any practical value. It goes on to say that you can think of function composition in terms of graphs, but the graph makes no sense (i.e. why two arrows from append, didn't you just say functions are unary?). It spends several paragraphs talking about verbose monad definitions and then dismisses them saying you don't need to care about them. To me, a lot of this is just empty trivia that I happened upon while learning FP the hard way. I was almost expecting him to go off on yet another tangent about church numerals or some other academic curiosity. If I put my lets-pretend-I-dont-know-jack hat, almost none of it seems even remotely practical to my day-to-day. Like, what's the point of spending any time whatsoever explaining that `f . g` translates to `compose2 = f =&gt; g =&gt; x =&gt; f(g(x))`? It isn't explained at all why all those gymnastics are supposed to be better than just doing `(3 + 1) * 2` like any reasonable person would. It then spends a whole page talking about Javascript being a suitable learning tool because it's popular. Then it spends another page on ES6 features and mixes in some things that aren't actually part of JS yet (object spread is only at stage 3 yet). It goes from explaining basics to casually saying you can get `curry` from lodash. Really not sure who the target audience is anymore. Then it goes into the good old reduce, map, filter, etc. But with n-ary functions instead of unary as "true" lambda calculus would have. Oh, now's a good time for a tangent. Let's talk about Redux. Now let's go back to talking about functors and endofunctors. Remember how the definition of monad was intractable? Well, "a functor is a mapping from category to category" and "arrows represent morphisms". Awesome, right? 
I want to know about databases for Electron. Can I use MongoDB / PostgreSQL? Is it possible to bundle them via any installer? Otherwise, what do you use as a database in your Electron app?
I continued tweaking the CSS until I was satisfied. If you hadn't prompted me to do something about the appearance of my web page, it would probably still look very bad. I am very grateful to you for taking the time to comment. [prettier page](http://schalk.net:3055). 
You sound like the Donald Trump of code.
 SYSTEM REQUIREMENTS It looks like your browser will not be able to run Construct 3. Please download the latest version of Chrome then visit this page again. Currently the latest version of Chrome is the only browser that supports the advanced and exciting features we've built into Construct 3. We hope to add support for other browsers once they catch up with us! It suggests me to use 55.x.x.x version, while I've 59.x.x.x The fuck?
The key part of my comment was "If function A passes the return value of B, which may be null, to C, which doesn't accept null, then the bug is in A.". So, no, I don't at all advocate "hopefully takes an Integer but occasionally gets null". I advocate code like this: let a = subFunction(); if (a === null) { throw Error(); } subFunctionTwo(a); What I see in your writing isn't Either "forc[ing] you to deal with and resolve ambiguity", it's Either helping you coalesce errors into something generic and ignore the details. Returning errors - as null, constants, or C-style return codes - are what encourage great error handling. Another distance between us is that I'm not treating `null` as special, at all. It's just another value, like an object or an integer. It's silly to say "this value in particular should never be returned, all the other ones are OK". And I don't like how you throw that "implies" in there - all meaning of values is implicit, `4` doesn't have meaning except to the human knowing it was returned by `countUsers()`. Is it often better to use descriptive things like strings or constants, sure, but sometimes that's overkill. Don't confuse all this with an argument against types. I love types, I agree with their pros. What I object to is the notion that the value `null` has no place in (typed if you like) programming.
The real cost is the time and mindshare of remembering yet another command line API (nvm) versus using a well-established primitive that everyone already knows (ln). Couple extra commands versus going to https://www.npmjs.com/package/nvm and then to https://github.com/creationix/nvm/blob/master/README.markdown#usage every time you want to switch versions.
Yes but the problem is if I just .fadeOut the video, the video is still there playing. So it's invisible but you hear the audio. I'm .remove(ing) the video because I want to fully remove it and the audio. And because I was thinking if I .add the video back in it will restart. I want to the video to fade back in and restart. 
I went from Angular 1 to Angular 2 to Vue. Haven‚Äôt used it long at all, but so far I really like working with Vue. I looked into React and Vue and decided to go with Vue. It‚Äôs just a personal preference, coming from Angular, Vue felt more natural to work with for me. Both are really good options, but it‚Äôs comparing apples with peaches. In the end it‚Äôs all about getting the job done, right? So it doesn‚Äôt really matter that much which one you chose. But you might want to consider what the job market demands (that is if you are planning to look for a job with your new skills, if you already have a job / are self employed / are a pure hobbyist, then take whatever you prefer). Where I live (in Belgium) Angular and React are the big players for front-end jobs right now. Angular‚Äôs community is getting a bit divided by NG1 and NG2 people and some people like myself are leaving Angular behind. Vue isn‚Äôt that well known here (yet), I am hoping it will change soon because I really like it. So yeah, I‚Äôm taking a gamble here but look at your own situation and place and decide what will be best for you.
I mostly use it when passing objects around, which brings named parameters to js in a way. function person({ name, age }) { ... } person({ name: 'Hans', age: 42 })
I'm sorry, but to argue that "nvm use v7.6.0" is a meaningful mindshare burden is frankly ridiculous. Similarly there's no reasonable way one can claim that "nvm use v7.6.0" takes more time than typing in two to four commands (I use "nvm use" as the example here but the same holds true for every nvm command).
You could just pause the video: https://www.w3schools.com/tags/av_met_pause.asp
I need the video to restart, I could possibly pause on a loop. But I think it might be easier to reload the video div, or add it back in somehow.
1. How do I create installers for macOS, Windows and Linux distros (Primarily Ubuntu) ie. How do you do distribute your app when its production ready. 2. (just a shot in the dark, I think I know the answer here but I'd ask anyways =&gt;) Is there a way to get 'native' styles that are not just precoded but actually read system settings. eg. On windows I decide to change the theme and default button color is now blue.
Thank you. There is no need for an apology. You're passionate about your project and your understanding of things. Web development today has advanced tremendously from what it was in the 2000s. With the complex solutions it yields today and the complex problems it has to solve it is on par with other domains of software development, e.g. the implementation of desktop applications. HTML and JavaScript and the whole ecosystem has evolved over the years to accomodate these demands. The evolution of JavaScript, including the introduction of more class based OOP concepts is one example. Today, JavaScript is one of the most important programming languages simply because it targets the largest platform there is: The web browser on every device that is used around the world. In addition to this it targets the backend as well. In the light of this I think that your efforts will remain of an academic nature. Your approach tries to solve things that are already being solved on a different level, the language itself. In addition to that the introduction of class based OOP is not welcomed without critique in the community. One reason for this is the advent of functional programming and the functional aspects of JavaScript itself and the bad practices that are associated with class based OOP. From what I've seen, you put alot of effort into CrxOop. It has good concepts but I'm still convinced, that the basic approach of it is flawed. If your intention was to target very small scale implementations with this one might argue if OOP should even be necessary for these. For large scale projects, ES2015, Typescript and the likes provide alot of benefit in class based OOP (if one wants to use it) and beyond. In these the compile step will not be an issue. 
Gosh, a throwaway replies to a deeply nested comment on a 2-day old post. I wonder who it could be. If it makes it easier for you to understand, ignore that I've used the word 'parallel'. Replace it with 'promise-all' or something, I don't know. I do understand what `Promise.all` does - it creates a new promise that resolves with an array of the underlying promises once they have *all* resolved. It is this last part that is causing the issue. The point still stands that if you wait for all promises to resolve before doing work with any of the results, your code is not running optimally. See https://www.reddit.com/r/javascript/comments/61q44j/6_reasons_why_javascripts_asyncawait_blows/dfjywen/
I've seen a lot of companies move to React and other frameworks/libraries.
He produces well made, unique, and insightful content on js for beginning and advanced users as well as tips for workflow
My strategy is to hire them and then indoctrinate them to hate classic inheritance, under threat of getting fired. ^/s
Oh so it's him I have to blame for mixing up the "responsive" and "adaptive" terms.
Look. Self aggrandizing Eric Elliot is a very, very bad dude, believe me. Mediocre at JavaScript, and he has the *worst* tweets. Total disaster. He's selling fake opinions as truth - dangerous guy, out of control. Not in the same league as some really smart people I know at all. And I know the *best* people, you know that.
Lots of these libraries can be gutted and self-implimented in a short amount of time. And after a while they use the same modular functions. That's what I've done for most of my sites. 
[Why?](https://github.com/reactide/reactide/tree/master/lib/new-project-template/new-project/node_modules)
Look into for loops and see where that gets you. Note: not trying to be mean or lazy here. Just want to point you in the right direction instead of just feeding you the answer. Follow up questions welcome :)
We include a basic node modules to sidestep the need to npm install every time you create a new project, so you can get to coding right away.
Not me personally, but my wife's projects are on Angular 1.5
One tiny little issue I had right at the beginning that he asserts that functions are always anonymous. Horseshit. 1) They're not. 2) Anonymous functions have a huge performance impact, as we found that they get evaluated during run time, each time that they are run. So he's dictating a method of writing terse, incomprehensible, inefficient code.
Some would argue housing/downloading hundreds of megabytes is a bad practice for something that would otherwise maybe push a few hundred kb (let alone when you move a folder locally that contains deep nesting and thousands of individual files).
You could bootstrap the dependencies of your project template on the first start of the IDE. No need to put them under version control. But I would still prefer "fresh packages". With local caches it usually doesn't take long to download them anyway. Btw, right now they take up 99.5% of your repository (81.1 MB out of 81.5 total).
You, of course, run the risk of accidentally adding a security issue that wouldn't otherwise exist. Or, you might break your site for a less common browser. But yeah, too many people pull in jQuery when all they need is querySelector. 
is this what you are looking for. https://api.jquery.com/delay/ .delay(&lt;number of miliseconds&gt;) can be chained. $("#something").show(500).delay(600).hide(400);
If you mean google maps, app cache won't work... but you can add markers to static maps. https://developers.google.com/maps/documentation/static-maps/intro#Markers
Thats a great point, will look into how we can resolve this
When I wrap my code in this it doesnt work anymore!
This test is pointless. They test for libraries, don't consider their version. Of the 10 they tested against, 6 have "vulnerabelities" in versions from 2015 which are more than likely already patched. Also, exploiting most of those would require the attacket to get around Same Origin Policy, at which point you can just any JS you want?
The rabbit hole that is using Squirrel for handling auto-updates, version checking, etc.
I would guess using the full libraries is more of a security risk but I can see it both ways I suppose. 
Does this support (or can it reasonably be made to support) InfernoJS? 
Not the slickest looking game
Sorry, but you can't be better than all the people who designer, developed, reviewed major libraries, combined.
This is completely irrelevant. Also: async function demo3 () { const results = []; for (const fileName of files) { results.push(await wait(300, fileName)); } return results; }; Holy shit this needs to be written as: const demo3 = async () =&gt; files.map(fileName =&gt; await wait(300, fileName)); I really get the impression that you're a very low skilled developer, which would explain why you can't understand the point I'm trying to get across.
Yup, solid point. The existence of a vulnerability does not mean it is actually exploitable. That would be a study that wouldn't scale as well. :) I think it works alright as a general health check though. The frequency of known vulnerabilities combined with the frequency of sites using versions of libraries that are 4 and 5+ years old (34.4% of jQuery versions being used) at least hints that there are some problems with JavaScript security and maintenance that have not been fixed for the majority of sites.
Am I supposed to know who Eric Elliot is? Some kind of self-proclaimed JavaScript demigod perhaps? Let's just call it 'An opinionated (and mediocre) series on FP in JavaScript'. No need for fandom, we already have Crockford for that.
page.js
Vulnerable to what exactly? 
Is this a proper example of the data? Are your objects with 'no' props and 'no' array numbers guaranteed to be in order by 'no'?
Devs tend to do about 0 due diligence before pulling in a 3rd party lib. Oh, look at this shiny library from random.blog.com that twizzles my bits! IMO npm should warn if a library you are installing has known vulnerabilities.
&gt; interfaces don't really make sense in JavaScript Could you elaborate on this?
 var no= [1,2,3,4,5,6]; var keys = [ {no: 2,char: 20}, {no: 4,char: 2}, {no: 6,char: 20} ]; var charLookup = keys.reduce(function (charLookup, key) { charLookup[key.no] = key.char; return charLookup; }, {}) var newKeys = no.map(function (num) { var char = charLookup[num] === undefined ? null : charLookup[num]; return {no: num, char: char}; }); This works even if it's not guaranteed. If it is guaranteed you could just iterate through 'no' array and check to see if the number is less than the next element in the 'keys' array. If it is then unshift in a new object. If it's the same then add one to your keyIndex variable which will then point to the next key.
FP is not React or Redux, they are just libraries that use some FP concepts, and Redux is a library that partially implements the Event Sourcing architecture. (No /s so...)
Oh lol. I was at work earlier looking at my tiny phone screen
Interesting. Never though of that. I was using for loop all the time. Thanks for red-pill me
That's an object. The reduce method can take two arguments. The first argument would be the callback for your iterator. The second argument is an optional argument for the initial value of the accumulator. In this case that initial value is an empty object. We're adding key value pairs using square bracket notation to our empty accumulator object (Which I named charLookup).
We're still developing the React portion, but we can definitely look into it in the future! 
nvm takes less time if you remember it correctly. Maybe your memory is better than mine, I've got so many command line options and option formats in my head that I'm guaranteed to forget to specify 'use' or whether I need a 'v' or not. That ends up having to RTFM, and that's just too much work. On the other hand, I've been abusing `ln` for years so I don't forget that one :)
What is considered a vulnerability here? Isn't JavaScript insecure by nature?
He's referring to _lambda calculus_ functions, which are, in fact, anonymous, but then he gets confused and assumes that that has something to do with Javascript, when in fact, they are intentionally made anonymous for the purposes of elaborating on lambda calculus operations, i.e. alpha conversions and beta reductions (these are terms that are specific to the language used by lambda calculus) This is similar to how we can express the equation `y = x + 1` as `g(x) = x + 1`. Both mean the same thing, but the former notation is clearer when solving for y given an actual x value, whereas the latter is easier to deal with if we're going to be talking about the the mathematical properties of `f(g(h(x)))` (As opposed to the properties of whatever that expands into). The author apparently thinks the anonymity of the functions in lambda calculus terminology somehow grant them special properties. Needless to say, that anonymity has nothing to do with whether functions are named in a software environment, and in fact, as you say, anonymous functions in Javascript can be a drag on performance if used poorly. 
He's making a flipping joke. 
There's some typos in the code that are taking away from the potential here. Eg: "EquipamentComposition" (spelling), "AirPlane" (bad casing)
I use https://snyk.io/ hooked into my CI. Tests and PRs are automatically failed if a dependency is flagged. I get an email if a new vulnerability is discovered and added to their database.
"The existence of a vulnerability does not mean it is actually exploitable." and yet when a vulnerability in flash player was found over the past few years, everybody would scream "uninstall" ... i mean you can/should uninstall for several other reasons, but i always found this to be pretty funny.
I disabled JavaScript Edit: disabling JavaScript is like ad block plus... PLUS
Basic knowledge needed to learn Electron. Some code examples.
It seems those numbers are not vulnerable sites, but simple usage of those libraries/frameworks.
That's really neat, thank you! Going to use this! 
Didn't see the /s so I just have the benefit of the doubt 
Yeah I know. I'm just being stupid. ü§°
Why not answer them here? I don't generally watch videos.
you need to escape the ' in don't. don\'t
Karma whoring on reddit
I feel like I need to know the *"One Secret Method To Keep Your Site Safe"* ;-)
So, the problem itself is a little awkward, but to get the behavior it's asking for I think you need both `console.log`s. The idea they want you to understand is that the function you return from `dinerbreakfast` retains it's reference to the outer `order` list event when called outside of the body of `dinerbreakfast`. The `console.logs` are really beside the point. As for improving the code, I would just return a function as opposed to defining another variable in the function body, i.e., function dinerBreakfast() { const order = ['cheesy scrambled eggs']; console.log('I\'d like', order, 'please'); return function(food) { order.push(food); console.log(`"I'd like ${order.join(' and ')} please."`); } } Nothing wrong with the way you did it, but I think this way declutters a bit and makes it immediately clear that `dinerBreakfast` returns a function. Also, your use of `join` is perfect :)
It doesn't feel like its a real language like Java and C Edit- That wooshing is the sound of the joke going over your heads
I've removed Redux from 3 apps in the last year because they were complex state nightmares that didn't need to exist. It can go either way, I guess. 
Still can't make documentation that is readable on a phone
 vue init webpack my-project
weird title given the article is basically about jQuery vulnerabilities.
It definitely is a real language. It's been the language of the web for many years and much more to come.
Cross-site scripting attacks. Like [one](https://bugs.jquery.com/ticket/9521) with jquery, related to how $() can take a selector or html. Some sites would call $(location.hash) to get the element that the url # hash is pointing to, but if someone put html after the #, it would recognize it as html instead of a selector, running any script inside.
This was what i was looking for. Thanks!
Yeah, since its in early dev, I am just working with basic textures. After I get it working well, I plan on adding better textures and optimization.
javascript is overhyped
`import 'lodash'`means "load the default export of the file indicated by the field `main` in package.json of the lodash module". `import 'lodash/array'` on the other hand means "load the default export of the file array.js in the lodash module". The part after the / is a relative path within the package.
I am partial to Vue personally but if you care about ecosystem size and mature tooling react is a safer bet. Imo a lot of the interesting stuff in Vue is coming out of China which can make it frustrating when no English documentation is available (weird to be on that side of the issue) 
Ey, Node has released the version 7.7.4 with async/await full support (without *harmony* flag). So answering your question: **now**!!
You are being way too optimistic. You are assuming that most of that 77% of Alexa's top 5000: 1. don't use vulnerable parts of these libraries (which is fine, but...) 2. don't load third-party scripts, such as ads, JS tracking beacons, plugins, etc., that also have complete access to the vulnerable parts of these libraries in ways you can't control. If your site loads anything that is not under your direct control (that includes CDN-loaded content), you have a responsibility to your visitors to keep your libraries patched. If you don't, you share their vulnerabilities.
Your answer looks good to me. It seems like you understood the question. I would consider it completed.
Even when you say "GoF" it did not mean anything to me until I looked at Wikipedia. Even though I owned this book, I never saw it as mentioned "GoF" until now. This acronym may not be as popular as you might think it is.
 // jQuery $('.class'); // Native document.querySelectorAll('.class'); // or document.getElementsByClassName('class'); Looks good so far... // jQuery $el.fadeIn(3000); $el.fadeOut(3000); // Native el.style.transition = 'opacity 3s'; // fadeIn el.style.opacity = '1'; // fadeOut el.style.opacity = '0'; I can live with this... // jQuery $(document).ready(eventHandler); // Native // Check if the DOMContentLoaded has already been completed if (document.readyState === 'complete' || document.readyState !== 'loading') { eventHandler(); } else { document.addEventListener('DOMContentLoaded', eventHandler); } Uuhhh... // jQuery $el.height(); // Native function getHeight(el) { const styles = window.getComputedStyle(el); const height = el.offsetHeight; const borderTopWidth = parseFloat(styles.borderTopWidth); const borderBottomWidth = parseFloat(styles.borderBottomWidth); const paddingTop = parseFloat(styles.paddingTop); const paddingBottom = parseFloat(styles.paddingBottom); return height - borderBottomWidth - borderTopWidth - paddingTop - paddingBottom; } // accurate to integerÔºàwhen `border-box`, it's `height - border`; when `content-box`, it's `height + padding`Ôºâ el.clientHeight; // accurate to decimalÔºàwhen `border-box`, it's `height`; when `content-box`, it's `height + padding + border`Ôºâ el.getBoundingClientRect().height; How about... no? This belongs to /r/programmerhumor or /r/programmingcirclejerk more than here. Seriously this shows why you'd need jQuery in most cases unless you want to write 10x code. Not even mentioning half of the functions in this page had browser specific quirks at some point, and by using jQuery like library, you had the full support of the community to hide those bugs from you. The real question is do you need half of these functions anyways? I'd say if you truly need all of `parentsUntil`, `fadeToggle` or `trigger` functions, jQuery is truly made for you. If all you need is class selectors and basic loop utilities, then you really don't need jQuery.
This is consistently how "you don't need jQuery" articles end. By implicitly demonstrating you need jQuery.
&gt; Things like abstract classes and interfaces don't really make sense in JavaScript If you don't have interfaces, you're doomed to reinvent them poorly. Mostly as overly long README.md and block comments. Interfaces are compiler-enforced documentation about how your objects talk to one another. Even in JavaScript objects talk to one another, and hence have implicit interfaces, which JS simply can't express in code as a distinct primitive. When you expect a callback that takes in parameters of a specific type, that's an interface. When you expect an object with given properties of a given type, that's an interface. This is why all the large JS projects are written in TypeScript and Flow - they provide interfaces for JavaScript.
Oh no, you had to look something up. I'm so sorry for your terrible experience.
In static, compiled, class-based languages, you have to explicitly declare all the relationships of your objects in advance as classes before your program will compile. Sometimes they have parent/child relationships, other times you just want a guarantee one class will have the same methods as another. JS doesn't bother with all this, as it is dynamic and has a built-in prototype chain, freeing you of the need to write a bunch of boiler plate inheritance and type declarations. So you don't need to say, you just do. One example is you can just do `let obj1 = {key: obj2};` and that is valid JS. In another language, you would have to write out that class `obj1` has a property `key` of type `obj2`, and if it isn't that very specific type of `obj2`, your program will not compile. But say I want `obj3` in it's place and both `obj2` and `obj3` can make a gaurantee they have a method `doSomething()`, then the interface can be that contract. In JS, you can swap out `obj2` with any other type, nobody cares. If you call `doSomething()` and it's not there since you swapped `obj2` with a number, you just get a runtime error. 
Probably, JSON will be updated soon. I hope so. :) It should follow ES specs.
You can call an interface by many names: - Interface - Protocol - Contract - Abstract type - Schema - Format It's very counterproductive to bicker about the specific word to use about this. All of the above refer to "type shapes" that fit into one another. Even if JavaScript is fully dynamic, you can't program without having two or more sides that agree on the structure of their communication. If you don't like it and you have some sort of alternative, it'd probably make the argument more grounded if you say what it is (and what the perceived issue with interfaces is).
That visitor example is a WTF. Binops have no children. So is the explanation of the pattern, BTW. If you ARE implementing a compiler then the last thing you'd want would be to take knowledge of the visted structure out of the visitor. A visitor is more a replacement for multiple switch statements. It has nothing to do with visiting. You can use them in JS but it's different without static types... your visitor will need different named methods (not just visit()) for each type it will visit. 
Thanks
The first lesson from this tutorial series involves playing/tweaking a variety of audio files. https://javascript30.com . The other lessons are pretty great as well. It's all vanilla javascript so it should fit in well with angular or anything else used.
I don't consider it abuse, logical operators can be used for more than a list of conditions for an if-statement. It's useful to think of them as "continue if false" (`||`) and "continue if true" (`&amp;&amp;`) If you apply that logic, OPs example isn't hard to grasp at all. It's just a matter of most language examples using the operators exclusively for one thing only, so people can develop a bit wrong idea about what they do.
Even if you still use jQuery, knowing how to utilize native methods on the DOM is extremely important for as simple of a reason as debugging. Sure, that code for height doesn't look fun to write, and yeah, I have it as a function in my library that's basically just a re-written version of jQuery (perhaps slightly worse), but I found that knowing how to use all the native methods greatly enhanced my ability both to fix and build things.
Didn't Microsoft deprecated it? How are still people using it?
They're big companies / government departments with huge amounts of machines. So instead of rolling out potentially very expensive upgrades which then break a bunch of stuff they just pay Microsoft for support. They'll eventually move but they're always behind home users.
Dude sniffs his own farts
 // jQuery $(document).ready(eventHandler); // Native // Put your script at the end of the body and be done with it
Great example thanks! As I understood right, Can we say to worker if you are in Area A (A state) and you see box named Foo, change your Area to B (change state) and behave same as in Area A (state A) but with different boxes (values)? 
According to what you linked: 1. Unnecessary function 2. Unnecessary newline at the end of the function 3. Wrong indentation 4. Useless comment 5. Double-quotes instead of single quotes
The two W3C courses on HTML5 on edX have a multimedia part, don't remember if it was in part 1, 2 or both: - https://www.edx.org/course/html5-part-1-html5-coding-essentials-w3cx-html5-1x-1 - https://www.edx.org/course/html5-part-2-advanced-techniques-w3cx-html5-2x-1 It's free, and "archived" means all course content still is available.
&gt; How about... no? How about ... not making it unnecessarily complicated?
The joke is that JavaScript is insecure, in the sense that a person might feel insecure not in the sense that a house in insecure 
I don't really get the logic of saying it's your responsibility to make sure first party code is patched, but executing arbitrary third-party scripts is fine.
In old versions of jQuery, if you did something like `$(window.location.hash)` to select an element, then attackers could theoretically link a user to `http://example.com/#&lt;script&gt;alert(1);&lt;/script&gt;` and get code execution. I say theoretically because in practice browsers don't allow that. Arguably it's not even a vulnerability, it's devs failing to sanitize input, but they fixed it anyway because web devs :) I bet most of those 77% of sites, this is the vulnerability they mean, and they don't actually do `$(window.location.hash)` so there's no problem.
Web development doesn't need more people reinventing every wheel they see. It's fucking ridiculous.
Whether it's a MEAN stack or other it doesn't matter. AFAIK what you are asking is in the browser, frontend javascript. Check this out:https://www.youtube.com/watch?v=Pn1g1wjxl_0&amp;list=PLRqwX-V7Uu6aFcVjlDAkkGIixw70s7jpW It uses the p5.js library and seems to make it really easy.
Considering most of those who dislike OO are fairly experienced I don't really know if what you're saying is true at all in this case
That's only one of the example, there are 20 different samples of equally verbose code on the project's Readme. By the way, putting your code at the end of the body is not always possible. Reasons is explained here http://stackoverflow.com/questions/14328449/when-do-you-put-javascript-in-body-when-in-head-and-when-use-doc-load 
When you start a new project from scratch, is there any logic behind installing the latest, patched version of your library dependencies, rather than, say, whatever version you used in your last project last year? If there is, that's the logic you are asking about. Also, many sites have no choice in what third party code they run. Ads, analytics, plugins are all often technical requirements. It doesn't mean you get to throw in the towel.
But until ES6 classes, classical inheritance didn't exist in JS. I mean if you're going to be a purist, don't appropriate paradigms from other languages.
I do when people speak as an authority but disseminates misinformation.
I'm a dumbass
I'll just leave [this](http://youmightnotneedjquery.com/) here..
It's not about current websites, they have using certain software for years that not only needs maintenance but also needs new features to keep up with the market. Telling them where to go is a great way to lose business and these are usually the big contracts. So whilst I would absolutely love for them to move, the reality is they won't. Banks, Governments, very large organisations don't work by the same rules.
Again that's really great if you're making a new website from scratch but if you're doing any enterprise work then that doesn't work.
No, but the statement about if it was an anti-pattern it wouldn't be included in React is a good argument I believe. I've seen various things come and go in React but local state has persisted.
&gt; Just because these companies have computers with IE8 in them, doesn't mean you need to support IE8 If they employ or hire you to write intranet or internet solutions for them, of course they expect you to make it run on their junk and of course with the same speed and ease-of-use. 
\#k
I wouldn't call a basic understanding of the DOM methods *advanced*.
Other than that: - Your formula for gravitational force is incorrect. You need to first calculate the total force based on the absolute distance between the planets, then break it into x,y components. You can't calculate the x,y components individually. Think about it: with your formula, if the two planets were right above each other, you would calculate a very powerful x force, since the x distance is small to zero. But that's not correct, since their actual distance (length of the vector between them) is great. - you'll need much higher masses to have any kind of orbit like effect. The actual gravitational force between 5-20 kg masses is microscopic. Inertia will dominate, and they'll move in an indistinguishably straight line.
You don't need anything except vanilla JS, but no one likes to suffer.
Learn both, coming from angular you can learn enough of the basics to make your own personally informed decision inside of a week.
This is how I've always felt with all these types of articles about how you don't need jQuery or why it's bad etc... It's just another tool in the box and I don't view it as something that you always need or always should exclude, but just like everything else it depends on the situation. Leverage it when it makes sense to do so, but if you don't need it, don't use it. 
WHile this looks nice, I see little difference between it and Atom/Sublime/VSCode and HRM/Browser sync/Live reload.
Yes, your assumption is correct
Yes, you are correct
Thank you.
Its not really about "at some point". Closures by definition reference variables defined outside of their own function body. This creates a situation where the function can reference data that exists nowhere else, which effectively gives it state. For example, this behavior can be seen to give JS classes private variables by hiding the state in method closures. function MyClass(prop) { this.getProp = function() { return prop; } this.setProp = function(value) { prop = value; } } var myInstance = new MyClass(1); myInstance.getProp(); //-&gt; 1 myInstance.setProp(2); myInstance.getProp(); //-&gt; 2 The state here is the `prop` variable. Technically its part of the local scope of the MyClass constructor when it was called. Normally it would get destroyed with the completion of the constructor call, but the `getProp` and `setProp` closures hold on to the reference of that variable and use them as a state that only they can access. Here's another example that someone posted recently: https://www.reddit.com/r/javascript/comments/62awoe/closures_problem/ In that example, a function is used to create and return another function which accepts changes to and outputs a state represented by the `order` array. 
[removed]
People that are used to compiled static typed languages will need some time to get used to a different language like JavaScript. A common mistake is to code in JavaScript like you are coding in Java or C++ instead of really learn the language.
&gt; This is for people who start JS with jQuery so they're not even aware the same calls can be done in pure JS. Thus the serious problem with starting and continuing with jQuery as more and more articles have been appearing about how jQuery is no longer needed (by those who never learned the fundamentals of javascript).
Basic DOM and Javascript is reinventing the wheel?
The law would see it otherwise. There's an incredibly low bar for this stuff. And most hackers would agree with me that it's hacking. Especially since you need to figure out how to access the service, either by using something like Wireshark or by decompiling the code and seeing what it actually does. That's the essence of hacking.
[XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) with either one of the following two: responseType = 'arraybuffer' responseType = 'blob' 
Lol. Do you even know what an API is? &gt; A good API makes it easier to develop a computer program by providing all the building blocks, which are then put together by the programmer. &gt; An API is usually related to a software library.
[Math.PI MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/PI) Javascript has pi on the Math global object.
More featured added, including rainbow avatar, display options, etc.
You really don't want to use `$.fadeIn` and `$.fadeOut` though. jQuery animations don't make use of hardware acceleration and just tear through CPU cycles. Writing CSS (in CSS and just toggling classes on and off) is the right approach to doing this sort of stuff while making use of the user's hardware properly.
You are complaining about $el.height() being short and readable while the getHeight() is an utter mess, I get your point. I'd write a module like this: export function getHeight(element){ /*.. vanilla code*/ } and then import this function where it's actually needed like: import {getHeight} from "utils"; Then I'd write the vanilla implementation once and use it everywhere. Let's say I need some other specific jQuery function, I'd just copy the required code from jQuery into a small module and import it afterward. I don't say you shouldn't use jQuery, but complaining about getHeight() being too long is not a good reason to use jQuery instead of vanilla JS. Maybe we, as a community, can rewrite jQuery in a more modular way where you import every function you need and ignore the rest. So if you need ajax, parentsUntil and fadeToggle but not trigger etc. one could write: import {ajax, parentsUntil, fadeToggle} from "jquery"; Or let users download custom jquery builds, imagine you can include jquery but only the ajax component and the $.fn.closest function with all its dependencies and nothing more in a single url like this: https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.js?ajax&amp;closest 
$("ul").dblclick(function(){ alert("You clicked: UL"); }); With this I can get the right element, but idk how to get coordinates? Also, is there a way show the alert message only the first time when you double click element? Atm alert pops every time. Alert message for body also pops every time if I click h2 for example. That should not happen.
It sounds to me like you want to wrap all the html inside the body with a div, right? If so, you'll need to do something like var $bodyHTML = $("body").html(); $("body").empty().append("&lt;div id='area'&gt;&lt;/div&gt;"); $("body").children().first().append($bodyHTML); You can refactor and simplify that, but that's the gist if I understand you correctly.
No problem, I've actually opened an issue to tighten up the copy on the home page to make that more clear.
&gt; when creating websites nowadays When creating a website / product from scratch, absolutely. Usually they'll understand they have no access to these. However work on existing sites and adding functionality to those means you'll end up using jQuery unless you want to remake the wheel. But they definitely do let those systems access the wilder world, I can see it in Google Analytics when they access our site. A dizzying array of weird and wonderful versions, not just IE either. Got a very large company using Firefox 3.0.X, no idea why. 
Because this comment annoyed me so much. I just have to leave this link here. https://api.jquery.com/
I suppose I am biased then. I was working with XML and XML Schema before I started with JavaScript (JavaScript is my first programming language). The DOM just seemed obvious... more so than most of the rest of the language or even many basic programming paradigms. Honestly though with the correct reference this is only a 2 hour subject of study. If you don't use the methods very often you will probably still require a reference, which is fine, but that still doesn't make this an advanced subject.
&gt; The differences between the two paradigms is so vast that it's not a surprise at all that there would be vigorous debate between their users. Once you strip away the superficial elements, there are only two things that make FP different: - Always immutable (although there's always a "loophole" for expressing effects) - The majority of FP languages are lazy by default (in OOP this is opt-in). That's it. If you can be specific what other vast differences there are, please be specific. You can do what FP does in any modern imperative language, but it's typically optional, and might be slightly more verbose in some cases. There is a vigorous debate between their users, because just say "tabs vs. spaces" and you'll have a vigorous debate between users: not every vigorous debate is a proven substantial by its mere existence. Most of the time, programmers like to argue about B.S. &gt; It's that there's been bad things said about class-based OO in JavaScript. Which makes sense, given that JavaScript doesn't have classes. Case in point. Arguing about B.S. OOP is reliant on objects, where classes and prototypes are merely ways to group objects with the same implementation, mostly for pragmatic, rather than fundamental reasons (you don't need either classes or prototypes to do OOP). The distinction is so irrelevant, that ES added a "class" syntax sugar on top of prototypes to prove that point. Bikeshedding is very real, though. Vigorous debates.
&gt; Monadomaniac FTFY
&gt; This belongs to /r/programmerhumor or /r/programmingcirclejerk more than here. Exactly. Like, I don't need a cars, planes, trains, anything, I have two legs and can walk anywhere, but there's a reason those things exist.
You-dont-need-any-library: just write it yourself! ...These posts are always so frustrating because it feels like they aren't ever getting the right message across. Sure you don't *need* JQuery, but it can still be extremely helpful--like most popular libraries out there.
Because I'm aware redditors never read past the headline: &gt;jQuery is a fast, small, and feature-rich JavaScript **library**.
Do you ever know what a library is? Even jQuery calls itself a library. See the other post in this thread. Or go to the jQuery web site! Jeez.
It's been a while, but I'm pretty sure you can only accomplish this on the backend by forcing Content-Type to something the browser can't render (I think I used to use octet-stream like a decade ago for this purpose). There's also the Content-Disposition header that can be set to "attachment" along with a file name, but I've never used that. The last time I had to do something like this was a good 10+ years ago, so I'm sure things have changed.
addEventListener is supported by all modern browsers, so your third example is extreme. http://caniuse.com/#feat=addeventlistener
Instead of binding separate event handlers to every element, just bind a single handler to the root element (e.g. body) and look at the mouse events properties ([take a look at this](https://developer.mozilla.org/de/docs/Web/API/MouseEvent)). Also you don't need jQuery for this. Looking at the console output of the following code should get you started: function dblClickHandler(evnt){ console.log(evnt); } document.body.addEventListener('dblclick', dblClickHandler); 
This is true, but you're getting downvoted because it's like saying "my truck is a Ford, not a steering wheel." API doesn't have to be an http JSON returning service, it's simply the interface to a set of programming...In this case, a library.
Hi /u/shalotelli, please no more twitter posts. Please link to a complete article. Thanks.
The difference is kinda blurry to me, care to elaborate?
Can it be used as a normal note-taking app, or is it appropriate only for programming purposes?
For personal projects this is fine (and a great exercise in an case). IMO the difficulty comes when you work on code with other people
Needs some help with the copy on their website: &gt; "Just like spotlight of OS X, Search your note when working with other app." &gt; "Already using the Boostnote? Get Boostnote Team."
Teacher haven't explained how to use eventHandlers.. I really have no clue how to implement this in code. I have tried to find answers for this from youtube and google but with poor results. Can you show some example where you dblclick element and after that click alert message pops up?
It they were really worried about performance would they really be using jQuery at all?
Eh. Both approaches have their pros and cons that should be evaluated on a case by case basis.
Me too... hating on jQuery is apparently popular...
The anonymous function in your previous example is an event handler. I prefer binding named functions though, because then you can easily unbind them later. Just place the code for your alert message inside the dblClickHandler function like so: function dblClickHandler(evnt){ var target = evnt.target; alert( 'Target tag: ' + target.tagName + '\n' + 'Target parent tag: ' + target.parentElement.tagName + '\n' + 'Coordinates (relative to screen): ' + evnt.screenX + '/'+ evnt.screenY ); } document.body.addEventListener('dblclick', dblClickHandler); Take a look at [this fiddle](https://jsfiddle.net/ndeqtavg/) for a live example. Please don't use Youtube as a learning resource. A very great and comprehensive resource for beginners is [You don't know JS](https://github.com/getify/You-Dont-Know-JS).
You don't need jQuery. Here, use webpack and babel and idempotent react and redux.
I just want Web Components and Service Workers. And most of the things that got added this time.
&gt; **with an easy-to-use API** And my original post referenced understanding how the **API** works. Crawl back under your rock.
What are the pros of using fadeIn and fadeOut unless you're supporting VERY old browsers and graceful degradation is too much work for the project? It's pretty much a non-issue these days IMO.
Using most of jQuery won't produce any performance concerns for most things. Doing oldschool DOM based animations with constantly incrementing numbers and rerendering things all over the place gets costly for even simple things.
If you understood English you would realise (Queen's English) that my original post referenced the jQuery API - which the library provides. When did I say jQuery wasn't a library? 
&gt;Yes, I know that no one should write code like this. Let's all repeat this, over and over, and then never speak of this thread again.
https://twitter.com/jeresig/status/590199945174634497
Hi /u/icantthinkofone, last warning on the insults.
Hi /u/NORSE_, please don't antagonize others. If it's not constructive, leave it out. Thanks.
I agree but fadeIn and fadeOut vs CSS3 transitions on opacity are a whole different level of optimization concerns compared to most other jQuery operations. For almost everything I make the performance concerns of most of jQuery are a non-issue for me. It's animations always are though for any work I do.
Yes, I am heavily biased towards micro-teams, basically myself for like two hours every two weeks is what I can spare for most projects haha.
My wishlist for es48: - blogs add links to spec drafts for further technical information about each proposal - blogs explain stuff like async functions in terms of inner mechanics, we all know async/await gonna be cool... - blogs are more creative with their content, this is the fifth blog post which lists some proposed es_ feature in a brief summary. - I don't have to be such a dick in my comments. Your wishlist is fine tho.
I don't know, this sounds like a perfect tool for codegolf.
Unfortunately, as far as I know what you are looking for is a lot more complicated than it seems. I myself am wrapping up a full stack app which used to use a node /Express backend and authed using passport and oauth for (in my case twitter) social authentication. However there is not a good way to connect a React front end to the server...at all.. I've been looking for a few weeks now and all of the solutions have been too much of a compromise, or were unnecessarily complex. There are plenty of npm repos for node and oath using passport, so you can find one for each of the services you want to connect. (twitter, Facebook, Google, github) so that's not the issue. The issue is how to to get the client and server to communicate the auth status and protect routes / views. If you end up finding a good solution for how to do that, please let me know. I can point you in the right direction as far as server side auth goes. In my case, I eventually ended up going with client side Firebase and react-router to protect my routes on the front end to make my life a lot easier.
That comment is a masterpiece. Can you explain, say, how does "immutability enable recursion"? Indulge me.
I find this argument kinda annoying. Yes, adding jquery as a dependency in a module may be food for thought, but it serves a very big purpose, which is that boilerplate code in vanilla JavaScript is tiresome and prone to errors, especially cross browser stuff and with new developers. Not everyone is a JS whiz and lots of companies hire people who only know JavaScript through jQuery. Hopefully those people will get better over time and understand that there isn't a "jQuery method" to add two numbers, as that old stackoverflow parody image jokes about. Hating something because it's ubiquitous just becomes a bit smug. Including jquery when you're not doing DOM related stuff is of course insane, but being able to have someone whip up a clean chain of jQuery quickly to make something so what the client wants it to do is imo far better than getting someone to write dozens of lines of code that are already written in a library to avoid using a library. Plus jQuery is so massively cached across the whole internet that, if included in the correct way, the overhead is a piss in the ocean. I mean, you could say "why use react when you could do it in plain JavaScript". The reason is that someone's already done it in plain JavaScript and called it react, so fucking use it and save yourself a massive technical debt by trying to be that guy who did a full client side application in ancient vanilla JavaScript with no dependencies so you can brag about how shit all these modern frameworks are. I don't have time to write a load of code that does time zones and the rest when I could use a single-liner in moment. No end user would notice the millisecond delay of loading in the library, especially if cached correctly.
How does Boostnote compare to Org-mode?
&gt; What are the pros of using fadeIn and fadeOut unless you're supporting VERY old browsers and graceful degradation is too much work for the project? Those are the valid reasons. I think you're correct in that it's the limitation of it though. Personally I find animations via JS much easier to manage over CSS. Though I don't do them because of the reasons you mentioned. In the end, saying you might not need jquery as a sweeping argument isn't necessarily true :)
&gt; I'm working on a project right now that doesn't allow any libs/plugins That sounds terrible. My condolences.
I'd say a chain is fundamentally flawed because of the wrapping. A more elegant solution is a pipe (which the |&gt; syntax is about). function pipe() { const methods = [].slice.call(arguments) return function(value) { return methods.reduce(function(value, method) { return method(value) }, value) } } This performs a similar operation but without the wrapped method chaining. 
Speaking with some recent experience this stuff is interesting but first learn how to turn a function that uses callbacks into a promise. It has the greatest potential to make your life easier. 
Interesting, I didn't realize you could mix overloaded declarations with a single `any` implementation like that. I added a note to that section of the article.
Next blog post: a typed pipe? (That function looks like it would be very difficult to type correctly.)
I'd say the return type would be the return type of the last method, and the value argument type would be the first argument type of the first method. I couldn't say for sure, I prefer my JS Any (for now). 
I wouldn't use such strong words - jQuery helped Javascript to get popular, it does a good job for most people which just want their website get running. I never used jQuery but I would not regret using it, since it's idea is great, there is a lot impressive work behind it and it just popped up at the very right time. Time moves on, so does the web and libraries get deprecated every day, but I think the web profited a lot by John Resig's game-changing mind.
Try - if (savedUsers.some(savedUser =&gt; savedUser.login === user.login)) 
I've found after getting the hang of CSS transitions they're much easier to maintain and apply in comparison to JS ones. You also get more separation between presentation and app logic. I only use JS for animations when I need something that's interactive and dynamically animated and now options like GSAP make it easier to animate things in JS while making use of the user's hardware properly. In regards to not needing jQuery, I think that statement holds true today if you're supporting modernish browsers such as IE9+. Things like the Fetch API (and a polyfill for it) make things like $.ajax not as attractive as I think XMLHttpRequest is a clunky API to use for most people's needs. That said jQuery is likely to be in people's projects as so many other libs depend on it. I still avoid jQuery syntax as it's very easy for me to do and I don't see much advantage in using it but there's nothing wrong with using it if that's what somebody is comfortable with. It's totally worth the time investment in learning how to not be dependant on it.
I just made the same comment on the article. The implementation doesn't even need to use `any` types; it just needs to account for all possible invocations. For example: function foo(s: string): boolean; function foo(n: number): null; function foo(a: string | number): boolean | null { //
Works great. Will look later at the code.
If you go down this track, be sure to include this http://vanilla-js.com/
Adding "download" attribute on link elements should be enough. https://developers.google.com/web/updates/2011/08/Downloading-resources-in-HTML5-a-download
To alert if any of the four is NaN if (isNaN(n1) || isNaN(n2) || isNaN(n3) || isNaN(n4)) {} To alert if all numbers are NaN if (isNaN(n1) &amp;&amp; isNaN(n2) &amp;&amp; isNaN(n3) &amp;&amp; isNaN(n4)) {}
`isNaN()` only takes one argument. You can't pass four things, you have to check each one individually. Also, you may have a misconception about what NaN is if you are using this to validate a form. If a user didn't enter anything, `isNaN()` will return false if passed the empty string. This function checks for a specific thing, the NaN value, a special placeholder value. It does not check whether something is a valid number. This is not what you want to use to validate user input. 
I think I need a setInterval that gets reset if the user clicks. And the setInterval starts when the #id is shown.
Because we want full content here, not tiny little snippets that link out to your blog, which is also problematic because it's harder to audit which sources you're submitting. edit: It also falls into the category of "blogspam".
Better, but now you need a polyfill.
Not to mention you need a polyfill for most of the nice stuff anyway, in which case you might as well just include jQuery and be done with it...
And if anybody ever wondered why we call Perl a write-only language...
Understood. Just FYI none of the tweets I post are my own personal tweets, I post only from reputable personalities in the industry as they always have valuable micro-insights.
Love it. The other day I learned/realized: You can use defaults when you're destructuring too. &gt; const someObject = { foo: 'baz' } &gt; const { foo = 'bar' } = someObject &gt; foo 'baz' &gt; const { baz = 'bar' } = someObject &gt; baz 'bar' 
:( I know. I plan to replace them...just wasn't able to for this go around.
I'd argue that Vue's larger API and extra "complexity" is what allows you to build applications more easily. It's harder to build something complex with only the bare building blocks. You're also comparing the full Vue _API_ page against React's guide, which is something different.
How about a .includes thing? newSavedUsers = savedUsers.includes(user) ? savedUsers.concat(user) : savedUsers 
sounds like a great name for a browser...
Bump, any ideas? This block of code also removed functionality of a Bootstrap carousel
Ok, so if you want responsive, canvas is not the right tool for the job (canvas being a way to act on pixels directly). You probably want to turn your codepen into a flat svg, and do `background-image:url(theimage.svg);background-size:cover`. If you want canvas anyways, you'll want to look into ctx.fillStyle, ctx.beginPath, ctx.moveTo, ctx.lineTo, ctx.closePath and ctx.fill (see http://stackoverflow.com/questions/4839993/how-to-draw-polygons-on-an-html5-canvas for an example). You'll also need to redraw on the window.onresize event (see ctx.clearRect). As for portfolio: large images there are a mark of an inexperienced newbie. Instead of spending time on the looks of the site, you want to beef up your experience section instead, even if it's just simple projects like reddit clones or small freelance gigs.
I figured canvas would be tough for sure. So I guess the next question would be. I have some projects but saw that album artwork and wanted to go at it to see if I could do it. So would it make more sense to as opposed to clipPath since no MS browsers support it. Just make a hollowed out png and overlay it onto the div with the hexagons inside it? Since that would handle the responsiveness? EDIT: I greatly appreciate the help. 
Sure. Let's pretend that, for whatever reason, you wanted to create a recursive map function over an Immutable.List from [immutable.js](https://facebook.github.io/immutable-js/). I don't know why you would want to, since that's not really the way you do things in imperative languages, but that's kind of the original point I was making anyway. Doing this in a pure way...modifying the list through each step of the recursion by creating a new list that contains the results from prior recursion cycles plus the result from the current one...would require the creation of n + 1 lists, where n is the number of elements in the original list. This is true of both Immutable.Lists and lists in, say, Haskell. But creating a new Immutable.List isn't ideal because JavaScript doesn't have true immutable data structures and therefore is not able to implement some very nice optimizations. (Even Immutable.List is basically just a mutable list where they decided to hide the mutation functions.) Every time you create a new list, you allocate new memory and copy the elements (or references to them, if they're objects) into that new memory. In Haskell, et al, creating a new list is done differently. Because the list is truly immutable, there is no need to actually create a new list and copy new elements over. If list1 = [2, 3, 4] and list2 = 1 : list1, the 2, 3, and 4 are *shared* between the two lists. The creation of list two requires only 1) creating the new 1 element, 2) setting its pointer to the 2 element, and 3) putting the address of the 1 element into the lookup table for the variable names "list2". It does not require the creation of a new list. The JavaScript runtime (or the runtime of pretty much any other imperative language) couldn't do this, because mutability would ruin it. What if you changed the second element of list1 to 6? Then the third element of list2 would also become 6. We can't have that. So creating a new list and copying the elements of the old list into it are necessary. But since a Haskell list (or the lists of most all functional languages) are not mutable, there's no way to change the second element of list1 to 6 or anything else. Nothing changes. Elements can be shared because we know there's no way to change them in either list. The JavaScript solution would require the creation of 10,001 lists if you map over a 10,000 element list. The Haskell solution would require the creation of 1 list. Once you reach a certain size, recursion over an "immutable" list exceeds the memory available to an imperative language. That never happens with the functional language. Because data structures are truly immutable. How do you *really* handle that with Immutable.List? You basically do list.asMutable().push(value) and, at the very end, call list.asImmutable() on your end result. Because JavaScript can't handle general recursion. So it has to be done a different way, by getting rid of immutability temporarily when it's not convenient. Related is the lack of tail call optimization in imperative languages (even in JavaScript, where TCO is mandated by ES6 but isn't implemented either by Node or any major browser yet). So all 10,000 of those new lists are passed as parameters to the recursive function and are left on the stack to eat that up as well. With a language with TCO (pretty much every functional language), that turns into 1 function call with no lists on the stack. End result: recursion cannot be used in all cases in imperative languages. Iteration cannot be used in all cases in functional languages. Therefore, you do things completely differently in these two kinds of languages to reach the same result, and this is enforced by the language. Functional languages are very different from imperative languages.
Ugh LOL. I just used a brute force method. handleSearchUsersClick(user) { let that = this let {savedUsers} = this.state let sameUsers = false savedUsers.forEach((savedUser) =&gt; { if (savedUser.login === user.login) { sameUsers = true } }) if (!sameUsers) { that.setState({ savedUsers: [ ...savedUsers, { ...user } ] }) } THis works
Hey did you ever figure it out? The problem is you used a == there in your if statement. You should have used `this.vel.x *= -1;`
Maybe I'm just missing a subtlety here, but isn't the image just a collage of transparent hexagons? Why does it need a hollowed png?
No it is definitely just a collage of hollowed out hexagons. The reason for the png would be because IE/Edge have 0 support for clip-path. So the only way to really clip the hexagon shape short of using canvas would be to use a png with an alpha channel hexagon. 
Can't you just make the polygon in whatever shape you want instead of using a clipping mask? For example: https://codepen.io/anon/pen/XMoXNJ
Another good TIL title could be, "TIL i learned i can reference a variable in its own declaration so long as that reference isn't acted on at declaration time. 
So are you saying to just make a ton of polygons and calculate them to place them in the shape of a hexagon or just make a polygon svg and overlay it on top of the div using z-index so it acts like a mask? 
I think you would be better off searching for a "dashboard template" rather than "framework". IMO it wouldn't really be a framework if all it did was dashboards.
Should that throw an error or just log something?
Are you talking about [this article](https://robertnyman.com/2008/11/20/why-inline-css-and-javascript-code-is-such-a-bad-thing/)? I agree with you, this is not really a point, if the application needed javascript to work, it wouldn't change anything inlined or not. However, I agree with his other points. The main points for me are separation of concern and maintenance.
Would it be possible to make one large one and then place other ones inside of it? 
Sure, but think how many keystrokes you'll save this way!
I guess so, but from a glance, most of the image seems to be composed of small hexagons
That is correct. So I guess I am trying to envision getting a bunch of the svgs like you mentioned to form the shape of a hexagon.
Just don't try and do something like this (i.e. for dependency injection), it won't work because the param wants to reference itself, not the outer variable: const dep = "whatever"; const myFunc = (dep = dep) =&gt; ...
Reactstrap maintainer here, check out the UncontrolledTooltip - https://reactstrap.github.io/components/tooltips/. There are a few Uncontrolled components to help make simple things simple. Components like that were added after feedback through github issues and PRs. Feel free to create an issue for any other pain points.
&gt; You also get more separation between presentation and app logic Eh it's more of a separation of technologies. Animations are often done via data or by code in games for example. You just do them in a separate process or part of the application code. &gt; In regards to not needing jQuery, I think that statement holds true today if you're supporting modernish browsers such as IE9+. Things like the Fetch API (and a polyfill for it) make things like $.ajax not as attractive as I think XMLHttpRequest is a clunky API to use for most people's needs. I agree there for sure. I haven't had to use jQuery myself for well over a year. I did a workshop some months ago with WebGL. I just grabbed a small ajax library for loading some data files. Just I think when you have people from all walks of life and experience levels, it's dangerous to say absolutes. It's why I tend to like the titles "you may not need jquery" "you may not need redux".
One use I've run across is escaping parameters for SQL strings, so you can use interpolation directly like: sql`SELECT * FROM users WHERE id = ${params.id};` Of course, if you forget to tag the string with `sql` (very easy) you're completely vulnerable to SQL injection... But there a bunch of other uses, for example: https://github.com/declandewet/common-tags
I'm so tired of this. You don't *need* anything. Engineering on the web is a constant decision of what's worth including, and if jQuery fits the bill--great. You also don't *need* build tools, but try to imagine a blog post patting the author on their own back for that. You won't see it because our community is chock full of self-congratulatory people trying to tear each other down for not being on Vue with PostCSS and webpack. My shop uses all four, by the way. It's also fine to be on Ember, it's fine to use React. As long as your code is maintainable and has good performance, who cares if you're using mootools or prototype? Not likely, but you get the point. Now, if we started talking about *relying* on jQuery.... that's very, very different. That's the implication for all these articles, I wish they'd come out and say it so we could have an honest conversation.
If they are even slightly different (trust me, they are) you've entered a world of maintenance nightmare if anybody else has to touch your code.
If someone has trouble reading well documented code that has been written using best practices, then perhaps it's best that they do use jQuery. There's nothing wrong with that of course.
Why don't you write the vanilla version as a function and reuse it?
&gt; Perl's actually quite nice once you learn it, and you can write awful crap in any language. Well, yeah, but C# doesn't give you three dozen line-noise operators to make it *easier* to write illegible crap.
Are you saying that your "well-documented code that has been written using best practices" has a leg up on jQuery in this regard? I'm struggling to understand your point. If you're saying the developers are the problem: think of it this way. Who is the more frustrating developer, the one who uses existing tools or the one who has to reinvent the wheel so much that you need to RTFM to do a forEach on an element list? And finally: no matter how good your response to this is, you've had to write and document your own library that everyone else but you must now refer to instead of jQuery, which they already know. I say this as someone who on *principle* never includes jQuery in my own projects.
I was addressing your general point about favoring CSS over jQuery animation, but my response applies to fadeIn/Out as well I guess. To answer your question, a pro of jQuery animations over CSS is that they provide control and notification options (eg, progress, completion, failure) that are either cumbersome or impossible via CSS. Eg, something as common as animation completion notification with CSS requires some fuckery around adding/removing transitionend/animationend listeners on the fly... asynchronously via setTimeout for it to work across all modern browsers. Not the cleanest or most robust approach. The notion of triggering an animation (eg, onclick) by adding and then removing a class from an element is also kind of awkward and can lead to unexpected behaviors due to race conditions because we can't add and remove the animation class within the same call stack. It just depends on what you're trying to do, but I'm willing to bet in the majority of cases where animation is used solely to embellish the user experience that the pros/cons are mostly academic.
You're right. You know, come to think of it I don't see all that many complaints about C#. Of course, there are two kinds of programming languages. Ones everyone complains about, and ones nobody uses. ;) ^/s
I don't think anyone needs to be frustrated especially considering that most of those tools are already baked right into js nowadays. &gt; that you need to RTFM to do a forEach on an element list? If that's the case then that person might be doing it wrong. Look, I need the speed and granularity that comes with using vanilla. I just don't need jQuery. Maybe others do, and there's nothing wrong with that.
Hey man I agree. I always do vanilla when I can. I'm just saying‚Äîthe moment you start writing helpers, start thinking hard about what you're doing and why you're doing it. New devs are going to to be asking "why?" The vast majority of what jQuery offers these days (QOL for DOM interaction) is probably faster than what you and I would write. There's a lot of smart things happening in the Sizzle library, I highly recommend examining it.
You certainly make a compelling argument. I might just do that. :)
I had a super similar viewpoint to you just a few months ago‚Äîbefore I worked on a huge team! That's why I'm being such a stickler. You're coming from a smart angle. Vanilla JS is more important now than ever, and I don't want to discourage you in going nuts with it. Just don't lump in jQuery's super fast DOM stuff with their noob-friendly stuff (like animations, ugh). Most folks don't know: you can literally just include Sizzle and get the great DOM helpers. Then you can polyfill window.fetch on your own and boom, you're using 99.99% of what people include jQuery for.
Why are cache miss rates high?
Hi /u/zakhttp, this post was removed because /r/javascript is not a job board.
but I need to iterate through the array, otherwise it will not work? i will not be defined; var theSame = false; var myArray = [1, 1, 3, 1]; if (myArray[i] != myArray[0]) { theSame = false; } else { theSame = true; } while (theSame) { alert("equal"); theSame = false; }
Because the good people at jQuery already did that for me. :)
Seriously? It's not in the abomination called Emacs, for starters :)
Thanks! That means a lot! For real!
Thank you so much
Bravo! https://media.giphy.com/media/Xh1vgIUkJbPKo/giphy.gif
It depends on how "this" is used, in global execution context(outside any function) and when called inside a function in simple call "this" will refer to global window object. To pass the value of "this" to another function or context we can use bind, call and apply. Using a constructor, the value of "this" when function is called with new keyword refers to the new instance. Please correct me if am wrong.
The simple way would be to create six nested loops that iterate over the array of allowed characters and append them to a string, which you then consume as needed. A better way would be to do the same but using recursion. A weird way would be to generate random six-character strings, check them for uniqueness by comparing them to the list of previously generated ones, then (if no match found) adding them to the list and then consuming them. Another weird way would be to think of your list of allowed characters as numbers in base-however-much-it-is (62?), then just iterating over the numbers in the interval from 0 to 62^6 and converting the numbers to string. 
TIL : https://codegolf.stackexchange.com
Not meaning to complicate things, but this is a great opportunity for the `Array.every()` method. It's an ES6 feature, but good to know...it will execute a function on every item in the array and will break and return false if the function returns false for any item: let arr = [1,1,2,1]; let result = arr.every(function(item) { return item === arr[0]; } if(result) { alert('equal'); } else { alert('not equal') } and fancied up a little bit with more ES6: let arr = [1, 1, 2, 1]; alert(arr.every(i =&gt; i === arr[0]) ? 'Equal' : 'Not Equal'); 
&gt; new Function Any time you are using new Function with user-supplied input, you are asking for trouble. This is no mystery or WTF and certainly no 'gotcha'. Play stupid games, win stupid prizes. 
I've given the nestingnestingnesting (lol) a shot - I tried using js-combinatorics, which looks awesome, but it buckled trying to create the variants. Your nesting suggestion works a treat - thanks!
The whole time I was looking at this I thought of just using a shorter manner. Thinking about all() in python. Smart way though. Complexity may be difficult on a glance. 
It even short circuits! const items = [1, 2, 3, 4, 5, 6] items.every(item =&gt; { console.log(item) return item === items[0] }) // 1 // 2 // false
https://GitHub.com/substack/hyperx
I hate when factorial changes!
I usually only use the "this" keyword for referencing variables and methods inside JavaScript ES6 classes. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes
do you mean this: https://developer.mozilla.org/en-US/docs/Web/API/FileReader ?
hashids are great, I use them to transfer user ids. HAHAHAHAHAA that project is dead
No I know that. I don't know what you're describing above and I'm asking you to give me a code sample. 
This is neat! Dumb question: what are the practical applications of a this technology? All I can think of is encoding blank-and-white bitmap graphics. 
&gt; `sum(): T; // ideally this would only work for string or number.` You can actually rewrite the overload to something like this: ``` sum(this: WrappedArray&lt;number&gt;): number; ``` Basically what this means is that this overload is **only** ever available if it's accessed off of something that's a `WrappedArray&lt;number&gt;`. As a result, you don't need a new type. You can just make the method signature available depending on the type of the object that owns it.
Unless you are really pushing the limits there is no that much practical use case for this where it would be a better choice then plain boolean/array values. If you need pixels then it is faster to just use 24 bit canvas or unit32 arrays and have the browser do it's own fast path optimisation instead of running everything in slow JS with a ton of array lookups and function calls. (eg: trade more memory for less work) If you need a list with so many booleans that memory is becoming an issue then you likely have other problems, but if you really really have to then this would be a handy. But with multi gigabyte machines so common I doubt it'll happen often.
Cool library. I am amazed at the download count to issue ratio. It seems really low (in a good way). Quick question, is something encoded in one port of your library (say the js version) guaranteed to decode the same in a different port (say php)? 
This is what i always wanted when felt that boolean arrays are uncecessarily wasteful :D (i am not sure about practical usages, but like it anyway)
&gt; there are two kinds of programming languages. Ones everyone complains about, and ones nobody uses Then there's Perl which is in the superset of both.
&gt; if jQuery fits the bill--great That's the point, jQuery doesn't fit the bill.
My bad. I am not into this babel madness that everybody seems to love so much, and I consider working javascript code what I can run in my 100% ES compliant browser without having to "compile" it. Proposals are just... proposals. The OP should have clearly stated that they were using such a thing. That being said, benchmarking something like that is ridicolous.
https://mdbootstrap.com/
maps of bits for game
https://twitter.com/AdamRackis/status/844289020372901888
&gt; Would provide a link to it but on mobile right now. I think you are referring to https://github.com/tc39/proposal-class-public-fields. Stage 2. Long way to go.
Nice article. Personally, I've never had the need for the problem which Hashids solves, but your experience is exciting.
Don‚Äôt forget that starting with ES6, it is better to completely avoid `arguments` and use rest parameters, instead: function foo(...args) {} 
There could be other uses for large 2+ dimension boolean structures. All the ones I can't think of off the top of my head are fairly sparse so a fixed size array would be wasteful of space, but maybe there are circumstances where this would perform better time-wise and the space is worth the cost. The technique is probably applicable to other small numeric values, i.e. packing a large array of 4 or 8 bit values into smaller space - that would expand the applications it is useful for considerably. Regardless, it is nice coding "game" the creator presumably got some enjoyment &amp; useful optimising experience from putting together and others might be inspired by.
I'm pretty neutral about jQuery usage, it's a library, a tool like many others, it's written in javascript so you can work without it for sure. But if you're in stackoverflow answering a javascript question... Don't you fucking dare start your answer with that god damnned dollar sign as if that's the ONLY way to do things!
I like that tiny onClick/onTouch animation :D
&gt; Any time you are using new Function with user-supplied input, you are asking for trouble Indeed! The fun exercise here was figuring out _how exactly_ to create the exploit. It would be quite possible for someone during a code review to suspect a vulnerability, try a few test cases and erroneously conclude it was a false alarm. This was just an illustration that even though exploring crazy constructs isn't something to do in production, it can still be valuable to know the subtleties of the language given that in js, it's exceedingly common to run 3rd party code and consume 3rd party data.
That looks like really bad code. I would blame a human before I'd blame a tool.
What?
A filled out March Madness bracket can be represented as an array of 63 booleans. For large bracket contests it would be cool to load everyone's brackets in the browser and be able to do quick simulations or gather statistics on them.
 //var allPossibleChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; // Too predictable var allPossibleChars = "6bUDB8Hr50oa9PfOxpSvKiQEuh2FIc4zRC3yeXsAMlw7qLYVGknWjgNmdZ1JtT"; // amount of combinations = Math.pow(stringSize, allPossibleChars.length) function nextIteration(str) { if (!str) return ""; if (str.charAt(0) === allPossibleChars[0]) return allPossibleChars[allPossibleChars.length-1] + nextIteration(str.substr(1)); return allPossibleChars.charAt(allPossibleChars.indexOf(str.charAt(0))-1) + str.substr(1); } // Usage Example: var yourString = "D6jfj8"; // Arbitrary starting point of any size for (var i = 0; i&lt;15;i++) { yourString = nextIteration(yourString); console.log(yourString); if (yourString == allPossibleChars[0].repeat(yourString.length)) { // Wrap around last possibility yourString = allPossibleChars[allPossibleChars.length-1].repeat(yourString.length); } } Covers all 1.76e+48 possibilities before wrapping, no duplicates AFAIK. The nextIteration algorithm is recursive, so yourString can be any size. Although that changes the number of possibilities To understand what's happening, check this *permutation* of a base 3 (possible chars = 0, 1, 2) 000 // first 100 200 010 // changed next, reseted left 110 210 020 120 ... 001 101 201 011 ... 212 022 122 222 // last
The commonly cited use case is for sanitizing SQL query interpolations sql`SELECT * FROM things WHERE id = ${id}` Another popular use is in templating engines to produce something other than a string as an output t7`&lt;div&gt;Hello ${world}&lt;/div&gt;` One (admitedly super obscure) way I use them is to create "runnable comments" in a test library: o (n + 1).equals(2) `Addition works as expected` o (n - 1).equals(0) `Subtraction works as expected` The assertions above print the template string as the title of the assertion if they fails. 
So I gotta ask, what's the cpu cost compared to normal arrays? It can't be good. 
Liked how fluid it is! Nice work! The predictability of the drop is also pretty good, except for when you drag into an area without a blueish target (like in the middle of a window), but although I feel it's a strange behavior I can't think of a way to change it.
I've given you permission to edit the FAQ -- update as you see fit :)
 var div = document.createElement('div'); for (var i = 0, len = 5; i &lt;= len; i++) { var row = document.createElement('p'), j = 0; while ( j &lt; i ) { row.appendChild(document.createTextNode('*')); j++; } div.appendChild(row); } document.body.appendChild(div); Homework done - enjoy the weekend
Looks good, a few suggestions: 1) Speed up the animation in the demos. 2) Disable pointer events on the text elements so users don't select the text when trying to drag. 3) Make dragging more sensitive. Right now, I have to drag items too far over another item to make them switch. If I drag an item over another item, they should switch even if the overlap is small.
So. I always thought jQuery was a wonderful tool. I also always thought that to have a maintainable codebase, what you really wanted was an adapter layer between jQuery and your code, which I think is very reasonable and not asking for too much. I also always thought it would be nice to separate DOM logic from business logic. I don't believe that any of these are groundbreaking ideas. I also never had a bad experience with jQuery. What about you? What do you think?
Thank you! Can you please explain what i and j mean? I know they are the variables used for inner and outer loops, but as I'm not very good at variable assignments yet, it helps if I can use names. :) I hope you have a very great weekend, kind helper!
Because the data is read asynchronously, you need to supply an [`onload`](https://developer.mozilla.org/en-US/docs/Web/API/FileReader/onload) event handler to the FileReader which will be called after the data has been consumed. Like this: let fr = new FileReader(); fr.onload = function(event) { console.log(event.target.result); // contains the data }; fr.readAsArrayBuffer(e.dataTransfer.files[0]);
Not this shit again.
Its in the readme: Results | Structure | Time | Heap Size | % Memory | | -------------- | ----- | ---------- | -------- | | Dynamic Array | 740ms | 335,155,200 | 100% | | Pre-Init Array | 267ms | 81,068,032 | 24.19% | | BitArray | 479ms | 4,194,304 | 1.25% | 
That's not what a framework is. A framework is an abstraction that provides generic functionality for a specific purpose. Building dashboards is a specific purpose.
I don't want to redo all the dashboard-specific logic or widgets. Or design. I'm looking for something like this, but in JS: http://dashing.io/
Say you have a view `Button` which has a state `color`that depends on another view `Panel` which has a tab `Category`which itself hangs on `User` whose prop `loggedIn`should be `true` or `color` above should be `green` instead of `red`, and so on. Each of these views just blows their data into the dom, and they all go about mutating and reading from one another. It's not just slow and ineffective, it's downright scary. Even if you somewhat centralize state, it's not reactive, so somewhere you still have to call all handlers to write to their portion of the dom. This is what the Twitter guy above meant with dark ages. You must have crossed into hairy territory once apps got even slightly bigger. State has been a problem in making apps for decades, that is nothing new. But Jquery does about nothing to help you with this. The way i approach this is pretty clear. I avoid mutation. Redux solves that for instance. And i avoid JQ, view libs like React do these things without breaking a sweat. 
Not brute "brute forcing into" anything - been tasked to clean up a subdomain and don't want to miss pages. 
While you're right that it doesn't matter if it's true or false due to being arbitrary anyway. The double bang conveys that he explicitly wants to convert the value to true or false. It seems more meaningful.
I built a character generator in pure javascript YEARS ago and I stored all the information on the page in bit arrays. took forever to make. I then stored in on top of the page.
I'm not OP, but you can automate the process if you're not just renaming the executable and changing the icon by hand. https://github.com/electron/electron/blob/master/docs/tutorial/application-distribution.md
You have 6 digits, each of them can have A-Z, or a-z or 0-9, right? That makes 2x26 letters and 1x10 numbers being in total 62 possible characters for each of the digits in any combination. /u/Gravyness already gave you some code for that. But good luck in checking 6^62 URLs within time.
Mac mini + caffeine + no strict deadline = I'm fine. Super useful comments btw. 
Did
&gt; Yes, I know that no one should write code like this. Indeed. In my opinion, allowing anything other than "compile time constants" here was a mistake. There simply is no point in having that kind of flexibility. Default values should be something simple which can be shown in a call-tip.
yes I am trying to call "addieren" but it doesnt work 
I dont see that anywhere in what youve written. 
 if (option = +) { addieren(parseFloat(this.Inputform.Zahl1.value),parseFloat(this.Inputform.Zahl2.value),parseFloat(this.Inputform.Zahl3.value),parseFloat(this.Inputform.Zahl4.value)); alert(option);
‚Äùoption = +‚Äù are you trying to do a check that the value of ‚Äùoption‚Äù is equal to the string ‚Äù+‚Äù?
yes and when it is true the function addieren should be called
Can't get it to work :/ This is my code: var eventdate = document.forms["addneweventform"]["eventdate"].value; if (eventdate.match(/^[0-9]{4}\/[0-9]{2}\/[0-9]{2}/)) { replydate.innerHTML = "Enter valid date in the format yyyy/mm/dd with forard slashes"; return false; }
`this` represents a _context_. Context is a value that the currently running code can use to perform actions on. It can be an object value, including `global` (`window` in browsers); a primitive value (in strict mode); or even `undefined` (in strict mode). When in global code, `this` is the global object. Its mostly unneeded there because you don't really need or expect different contexts when writing code in global. // in browser where global is window var a = 1; b = 2; this.c = 3 console.log(a); // 1 console.log(window.a); // 1 console.log(this.a); // 1 console.log(b); // 2 console.log(window.b); // 2 console.log(this.b); // 2 console.log(c); // 3 console.log(window.c); // 3 console.log(this.c); // 3 Where context changes is in functions. Functions represent reusable blocks of code that can be run over and over again. To make them more useful, you can optionally supply them with arguments to make functions configurable so they do different things each time they're called. function mult(a, b) { return a*b; } console.log(mult(1, 2)); // 2 console.log(mult(3, 4)); // 12 Functions can be defined in objects and get called from those objects. Functions used this way are known as _methods_. var obj = { greet: function (name) { console.log('Hello, ' + name + '!'); } }; obj.greet('world'); // Hello, world! Sometimes a method may want to reference values stored in the object in which it is defined or being called from. We can use the function's input arguments to deal with this... var obj = { name: 'alice', greet: function (name) { console.log('Hello, ' + name + '!'); } }; obj.greet(obj.name); // Hello, alice! But that's a little redundant because we're already referencing `obj` when calling the function. Instead, the power of context can come into play representing an additional input for functions, one in addition to the explicit arguments. The context instead becomes a kind of implicit argument, one always available and always named `this`. The standard way JavaScript determines context (`this`) for a function call is by looking at the object from which the function was called. var obj = { name: 'alice', greet: function (name) { console.log('Hello, ' + this.name + '!'); } }; // greet is being called from the `obj` object, so for this // instance of the greet() function, `this` will be assigned // the value of `obj` obj.greet(); // Hello, alice! Context is determined for each call of a function. This means it has the opportunity to change if the same function is ever called from different objects. function commonGreet() { console.log('Hello, ' + this.name + '!'); } var aliceObj = { name: 'alice', greet: commonGreet }; var bobObj = { name: 'bob', greet: commonGreet }; aliceObj.greet(); // Hello, alice! bobObj.greet(); // Hello, bob! This behavior is what make prototype methods work. Prototype methods are defined in a single object - the prototype - but shared between many instances, all which reference the same function definition as one of their own. Each method call is able to target its respective instance using `this` since the call would be made from the instance object when used. In the previous example above, the same `commonGreet` function is used for both objects and its context changes (`this` has a different value) depending on which object called it. Given that `commonGreet` is its own function defined in global right now, it can also be called as a function and not as a method from another object. When that happens, the context defaults to the global object. // continued from above (in browser) window.name = "browser's window object"; commonGreet(); // Hello, browser's window object! This behavior is one of the gotchas to look out for when dealing with context in JavaScript. This will happen any time you take a method from an object and give it away to something else, such as an operation needing a callback. var eveObj = { name: 'eve', greet: function () { console.log('Hello, ' + this.name + '!'); } }; window.addEventListener('click', eveObj.greet); // *click* =&gt; Hello, browser's window object! Here, you no longer control how the greet function is controlled. You hand that over to the `addEventListener` function, giving it a string, 'click', and a function reference to the `greet` function. `addEventListener` doesn't even get a reference to `eveObj` so it couldn't call `greet` from it if it wanted to. Instead, when a click event happens, `greet` gets called in the global context of `window`. Even though `greet` was _defined_ in the `eveObj`, its how the function is called that determines context. When its called as a simple function reference and not as a method from an object, the default is used which will be global. Its not obvious from the example above, but the hand of context can be forced by the caller. The behavior calling the click handler given to `addEventListener` does this. Consider this example: var eveObj = { name: 'eve', greet: function () { console.log('Hello, ' + this.name + '!'); } }; // &lt;button id="btn" name="fred"&gt;Click me&lt;/button&gt; document.getElementById('btn').addEventListener('click', eveObj.greet); // *click* =&gt; Hello, fred! You can see now `greet` isn't actually being called with a global context after all (though many other callbacks _will_ use the global context for functions they're given, `addEventListener` is an exception). It instead uses the object from which `addEventListener` was called, or in this case, the button element with the name "fred". Normally, the object from which the function is called is used as the context, but that can be changed using a couple of different tools in JavaScript, not unlike with what is happening with the click listener above. These include `call`, `apply`, and `bind`. `call` and `apply` both let you set the context of a function when its called, overriding what it would normally be for that call. They only differ in how they provide arguments to a function, where `call` uses a comma-separated argument list and `apply` uses an array. // using previous objects from earlier commonGreet.call(aliceObj); // Hello, alice! commonGreet.call(bobObj); // Hello, bob! eveObj.greet.call(bobObj); // Hello, bob! eveObj.greet.call(document.getElementById('btn')); // Hello, fred! You can imagine the last example with the fred button doing something similar to what `addEventListener` does with its handlers. `bind` is similar to `call` and `apply` except it doesn't call the function. Instead it creates a new function and enforces a specific context that overrides any other attempts to change the context based on how that function is called later. This behavior is how the callback problem can be solved. If you want to pass a method from an object somewhere but make sure that `this` in that function continues to represent the owner object, no matter how its called, you can create a version of the function which is _bound_ to that object. This will make all function calls use that object for `this`. Revisiting a previous example, adding `bind`: var eveObj = { name: 'eve', greet: function () { console.log('Hello, ' + this.name + '!'); } }; // &lt;button id="btn" name="fred"&gt;Click me&lt;/button&gt; document.getElementById('btn').addEventListener('click', eveObj.greet.bind(eveObj)); // *click* =&gt; Hello, eve! Even though `addEventListener` may try to change the context of the greet function it was given, it can't because that function is bound to an overriding context (`eveObj`). Other examples: var eveGreet = commonGreet.bind(eveObj); eveGreet.call(aliceObj); // Hello, eve! eveGreet.call(bobObj); // Hello, eve! eveGreet.call(document.getElementById('btn')); // Hello, eve! Them's the basics, but the rules of context don't stop there. Another factor to consider is [strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode). When in strict mode, you no longer get global context in functions. Instead, context there is `undefined` when it would otherwise be global. "use strict"; function commonGreet() { console.log('Hello, ' + this.name + '!'); } window.name = "browser's window object"; commonGreet(); // Error: this is undefined Some other changes apply too, which all should be outlined in the strict mode docs. One other exception worth mentioning is arrow functions. Though they are functions, they're a special breed that do not have their own context. Their `this` is instead a _lexical_ this which is inherited from the context in which they're defined. This means it no matter how they're called, arrow functions always use the same `this` - a `this` dependent on place of creation instead of call. var oliverObj = { name: 'oliver', getGreet: function () { return () =&gt; { console.log('Hello, ' + this.name + '!'); }; } }; var greet = oliverObj.getGreet(); // context in getGreet is `oliverObj` greet(); // Hello, oliver! This makes arrow functions especially convenient for callbacks, at least when they're created in a context that you wish the arrow function to use. 
Try this and look at the console: var eventdate = document.forms["addneweventform"]["eventdate"].value; console.log("Date value",eventdate); console.log("Match?",eventdate.match(/^[0-9]{4}\/[0-9]{2}\/[0-9]{2}/)); if (eventdate.match(/^[0-9]{4}\/[0-9]{2}\/[0-9]{2}/)) { replydate.innerHTML = "Enter valid date in the format yyyy/mm/dd with forard slashes"; return false; }
So I tried that code, and it works but in the opposite way. It returns false if its right, and return true if its false. How can I create the if statement to check if eventdate does not match? Just as I will have more queries to check before returning true or false I can't just change the return state. Many thanks for the help btw!
&gt; Super useful comments btw. Yeah ... Just saying ... maybe, just maybe ... there are better solutions for what you want to do instead of checking 6^62 URLs.
Damn this bot is a savage!
Wasn't DOS one just *Basic*?
what do you mean? Where do I put that?
My code is if (eventdate.match (/^[0-9]{4}\/[0-9]{2}\/[0-9]{2}/)) {
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match If you just need to know if a string matches a regex, use `RegExp.test()`. It's more concise, and quite a bit faster. In your case, that would look like this: !/[0-9]{4}/[0-9]{2}/[0-9]{2}/.test(str);
Thanks, that works perfectly!
 if (!eventdate.match(/^[0-9]{4}\/[0-9]{2}\/[0-9]{2}/)) you want that if statement to pass if the date *doesn't* match the regex.
The community is big enough, but I did not find them responsive. Am I correct to say that the official chat place for vue is the gitter channel? Most of the questions there are not answered. In contrast, Polymer ha s a smaller community which is very responsive and helpful on slack. Maybe the fact a big chunk of Vue community is in China has something to do with the lack of responsiveness.
This is not quite enough code to see anything obvious. It's not really clear what you're even alerting.
it seems like the for loop is trying to get the value in order to execute if statement but the array is empty at the start so it is not possible, that's why I get undefined because it cannot reach the if statement. Still, I don't know exactly how I could fix that
https://momentjs.com/ ;) `moment("not a real date").isValid(); // false`
Make an example in http://codepen.io
Before Firefox 52: function twoSetTimeouts() { setTimeout(twoSetTimeouts); setTimeout(twoSetTimeouts); } twoSetTimeouts(); Would quickly add tens of thousands of setTimeouts into the js event queue. These calls would delay the refresh code causing your fps to drop because the refresh call is just added to the queue and called after all the other stuff is done. So if you have 100,000 setTimeouts to process, then 1 refresh... After Firefox 52, they now group timers and intersperse them with the refresh call with other special logic. So timers can no longer hog the ball, so to speak. 
I have no idea what should i do there should i copy the whole code? :( my knowledge of coding is null... 
 /\d{2}:\d{2}:\d{2}/.test(str) Note, I have used the `\d` special character, which is the same as `[0-9]`. Try playing with it on https://regex101.com/. Edit: The above only validates the hh:mm:ss pattern. If you want to validate if it's an actual valid time, you have to write a more advanced regex.
Oh wow. That *is* crazy
I suggest either learning the basics on https://www.codecademy.com/ or consider paying someone. The example files you game are hosted on your amazon web server. For someone to help, debug, and develop what you need they may need to host your files on a local server (super easy to to if you know what you're doing) and then make the necessary changes.
Actually I took a look. Have you tried just updating the config file 'data.js'? "infoHotspots": [ { "yaw": -2.5186532041608345, "pitch": -0.2534885174690942, "title": "Auto 1", "text": "iframe 1&lt;br&gt;" }, { "yaw": 2.6720894362982914, "pitch": -0.06309320230600513, "title": "Auto 2&lt;br&gt;", "text": "iframe 2&lt;br&gt;" }, { "yaw": 1.4238658486385045, "pitch": -0.063048684113447, "title": "auto 3&lt;br&gt;", "text": "Iframe 3&lt;br&gt;" }, { "yaw": -0.09879203152479832, "pitch": -0.05867814040746211, "title": "Auto 4&lt;br&gt;", "text": "Iframe 4&lt;br&gt;" } ] Change iframe 1&lt;br&gt; to: &lt;iframe src="https://s3.eu-west-2.amazonaws.com/newtestmotorgomez/TABS_example.html" style="border:0px #ffffff none;" name="myiFrame" scrolling="no" frameborder="1" marginheight="0px" marginwidth="0px" height="400px" width="600px" allowfullscreen&gt;&lt;/iframe&gt; And see what happens.
Without getting into an argument, I thought it should be interesting to use promises better for each section. For error handling, don't use try/catch explicitly since it's implicit in the .then() and .catch(). Every exception within the chain will go to the .catch() block. For conditional, I would assign the promise to a variable and just resolve it if no more data is needed. For intermediate values, I would wrap the data in an object and extend it at each step with the new data. That way you're bypassing the multiple arguments problem. [A fiddle](https://jsfiddle.net/2qL0tzm7/)! For errors, chrome identifies which "then" threw the exception (he logs that in his example). But this has more to do with anonymous functions than promises. Anonymous functions are hard to debug in general... if this becomes an issue, I would name them - or, in this case, simply pass the callAPromise function to the .then().
Wouldn't recommend using JSON for it, but presumably 63 bits per bracket plus maybe a 32 bit ID? So a million brackets would be about 12MB. Not saying it's a great idea, just trying to think of a potential use case.
&gt; Sigh. Vector tries are not the same thing as root-level structural sharing. &gt; I shouldn't have to tell you this, what with your decades of experience. You really shouldn't, because anyone who's been given the 101 on data structures would laugh at your ignorant ass. &gt; You cannot reasonably have the kind of structural sharing that you need to fully optimize list operations unless you have a engine-level list structure that allows the addition of new elements onto the front of the list in constant time. Really. I bet you never heard of **singly-linked lists** then. Which also *happens to be how Haskell represents lists*. Haskell doesn't compile to magic, genius. We're still talking concrete structures with concrete pros/cons. Everything Haskell does to internally represent a structure: you can do in an imperative language like JS. Of course JS is a dynamically typed script with a small runtime optimized for a browser, so it's kind of a nonsense to compare its raw performance to a compiled language, which is the point you're trying to lean on. Just one more random tangent to throw in "hey statically typed compiled languages are faster than a dynamically typed script!". No. Shit. Nothing to do with "functional", nothing to do with "immutable". Crapshoot after crapshoot. You're tireless. Try to have Haskell singly-linked lists compete with singly-linked lists in C. Oh wait, GHC can output Haskell as C. Well I guess then, **by fucking definition** what you can do in Haskell, you can do as efficiently in C. &gt; So, in conclusion, I don't honestly know anymore whether I'm feeding the troll. As usual, the first one to use the word "troll" is the troll. And you're continuing with the strategy of pouring out written garbage in attempt to obscure the question I was asking you. **How is immutability enabling recursion**. And there's a reason I'm focusing on that one thing. Because there like a several dozen hilarious statements in everything you've posted so far, but when I call you out on them (and I did on some) you just spew more unfocused garbage. So I want to focus you a little, answer that one question. And try to fit within a single paragraph, and not talk about everything under the sun, including what you had for dinner last night: **how is immutability enabling recursion**.
Yeah, I wasn't able to get it working. So would that be if (!eventstart.match(/[0-2][0-3]:([0-5][0-9]|60):([0-5][0-9]|60)|00:00:00/)) { replystart.innerHTML = "Enter valid start time in the format hh:mm:ss with colons"; }
 if (!/^([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/.test(evenstart)) { replystart.innerHTML = "Enter valid start time in the format hh:mm:ss with colons"; } 
Genes in w genetic algorithm?
It should work. Please post the rest of your code.
Hey sorry for not being more specific i was on my phone and i just thought that this would remind u something. Glad that u got the answer :)
Not a problem! I now understand that part, just didn't know where to put it at first lol
Arrrr, I got this! Thank you so much for your prompt support u/azium! You are awesome! Cheers!
are you actually writing `myArray.data` somewhere in your code?
SOLVED!
&gt; first type repl where?
That would be a poor technology choice.
Great explanation! Thanks. 
&gt;I just had to fix a moment.js bug where it was calculating both this month and next month the same. Can you give an example? I'm not sure what you mean by 'calculating both this month and next month the same'. I use moment.js for some critical stuff on an order UI. What issues are you having exactly?
yes, but the main problem is with the if statement. If you have like 30 values in the array, you don't want to specify each value like this: if ($(myArray[0]).data("text") != $(xps).data("text") &amp;&amp; $(myArray[1]).data("text") != $(xps).data("text") &amp;&amp; ... )
no I mean are you literally writing `myArray.data` like it shows in your alert? It would help a ton if you posted your `alert(..)` code
I will post the small quiz that I've already written when I get home tonight, it's a question-and-answer quiz so it's very simple. Let me rephrase my question, because I'm not asking anyone to do my work for me: I can't find any documentation for the Google API or the Bing API that would automatically call an image search. I've checked stack Overflow and other forums but it seems the old API has been deprecated. So I guess my question is is it even possible to query a Google image search and then migrate the results into my web page? If not, then I will manually find photos and build it into the existing quiz that I've already written. *Edit spelling
Thanks for the comment! :) This can be easily achieved by adding two lines of css: .visible-layer .lmdd-mirror{ opacity:0.7; } .visible-layer .lmdd-shadow{ opacity:0.3; }
Fantastic! For the first time, I'm in need of a task-scheduling module, and I have no experience using them. I will review this over the weekend and touch back. Thanks for the share! 
Your issue is that you're pushing to the array every time the check fails. So in an array of 5, even if 1 of the elements has the data, you're pushing the data 4 times (for the 4 elements that don't have the data). You need to have some var = false, set it to true if you find the element, and only push it if it's still false after the loop. E.g. (forgive crap formatting. I'm on mobile) var dataInArray = false; for ( ... ) { if ( ... ) dataInArray = true; } if (!dataInArray) array.push 
Thanks for your comment :-) 1. Animation speed can be altered with css: .visible-layer, .visible-layer * { transition: all 0.3s; } 2. LMDD is using a timeout function to delay the drag start for a short time to distinct it from other user intentions (such as selecting text). The default value for the timeout is 200ms. It can be changed through the instance settings to any other value (when set to 0, text selection will be impossible) 3. The positioning algorithm logic works like this: if the cursor is left of the item left border the dragged item will be positioned before the item. (same goes for top border)
I thought it was the issue with for loop. I am only trying to make the if statement less obtrusive, i.e. by applying for loop which was unsuccessful.
Hi! You have multiple options how to handle this, I would suggest that you for example add a url-friendly variable to your blog-post etc. So when you create a new post with the title "Leak Sensor", you could create your url-friendly variable when the model is saved, for example: function convertToSlug(Text) { return Text .toLowerCase() .replace(/ /g,'-') .replace(/[^\w-]+/g,'') ; } (From: http://stackoverflow.com/questions/1053902/how-to-convert-a-title-to-a-url-slug-in-jquery ) The result would be "leak-sensor". Then when you output the link in html, use the url-friendly one instead of just the title. Then in your route you search on url-friendly variable instead. Good luck! 
There is sometimes a "doesnt appear when you have good luck" bug if you pass a unix milliseconds string to moment it gets parsed as unix millis::: unless the timestamp appears to be a valid yyyymmdd with trailing zeroes which can be prevented by moment(+(val)) 
I noticed a button on an application which is using moment.js for dates was not working today. It's function is to 'view tomorrow's orders'. Might be related, not sure. Today is 31 March, tomorrow is 1st April.
&gt; 2) Anonymous functions have a huge performance impact, as we found that they get evaluated during run time, each time that they are run I don't know what you coded up but it's not true in general. Anonymous functions can be optimized at various levels just fine. Evidence: make some loop to ensure multiple executions, use the anonymous function, do profiling and check that no little triangle shows up (the presence of which would indicate it couldn't compile/optimize it, or it compiled/optimized it but had to deoptimize later). Of course, ensure that no condition exists in your code that would preclude optimization, i.e. it shouldn't have throw, debugger and there are a couple dozen other criteria. Of course this whole reddit topic is a purposeless hatefest so I apologize for not blending into the narrative here.
Hi /u/code_barbarian, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `thecodebarbarian.com`. Thanks for your consideration! Available submission history for code_barbarian: domain submitted from|count|% :-|-:|-: [thecodebarbarian.com](/search?q=%28and+site%3A%27thecodebarbarian.com%27+author%3A%27code_barbarian%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|29|97%
We did back to back tests with defined functions and anonymous functions using a high resolution timer rather than a profiler that gives you a nice little triangle. Promises were worse, much much worse. Interesting response until you soiled yourself with that rather snide little sentence at the end, so with the best will in the world, go fuck yourself.
Yeah I've had a few problems with agenda as well (like cancelling), opened up an issue with no response. I prefer it though because I know mongo way better than I know redis. I've considered forking, any thoughts?
Hey, agenda is on GitHub precisely so you **can** fork it. If you have the skill and endurance (and a +2 against global variables), have at it!
This is by design for performance. https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval#Inactive_tabs
So he rolled a natural 1?
&gt; set up a linter Or use an editor that would show this ...
I can reproduce with moment.js 2.0.0 at March 31, 7:00PM EST https://jsfiddle.net/Lurrcmnb/ Upgrading to 2.18.1 fixes it
This irritated me a little too much..
thank god. 
This worked. How could I have been so stupid. I knew it had something to do with the splitting. At first I thought perhaps the split didn't return an array or something, which it should do. I was so confused. Thanks a lot I got it working!
Thank you thank you
Looking forward to it. Video was very helpful.
Holy shit, I was getting so pissed off until I realized it was an April Fool's joke...
_"How could anyone think this was a good idea???"_ \- Me for a solid three minutes
I was losing my shit so hard. Well played 
Hook line and sinker up till the dot notation part lol
why even type that when you could say the same thing with . .. . .
I bet it is. It makes it so easy to replace everything with dots.
He would have had me for longer if he said it was easier to reason about. 
All that irritated me was April Fools videos before April.
b.l.e*
Saw this post while browsing Reddit in bed at 1:30 a.m. (1st April). Thought I should go downstairs to watch it on the 50" TV screen instead of a 5" phone screen, but didn't read these comments until I was downstairs in my dressing gown waiting for the PS4 to boot up. Damn you ;-)
Why? I was under the impression no one uses `function` at all now. 
Wow, well played, just replace all those annoying chsrscters witg a dot.... priceless
Well, for starters, the presenter has an American accent. Additionally, there have been a number of videos/articles today released before it was April 1 *anywhere* for April Fools. For finishers, who actually enjoys April Fools?
It's a bit sparse, but there are a few parts of the React docs that go into it: https://facebook.github.io/react/docs/react-without-jsx.html https://facebook.github.io/react/docs/react-without-es6.html https://facebook.github.io/react/docs/react-api.html#createelement There's not much you need to change if you don't want to use a transpiler. JSX is just syntactic sugar that gets compiled into `createElement()` calls. Also note that a lot of the ES2015+ code that typically gets transpiled (modules, classes, async, etc) is indeed JS, but the syntax isn't supported yet in all browsers.
Oh man. That's a relief. I was getting pissed. 
Fair enough. Some of the the April Fools content is already two days old *cough* StackOverflow *cough* This one seems to only be a few hours, so well within 01/04.
I felt the same way and tried doing so by making a simple project in that style. I wrote about it here: http://blog.jfo.click/how-react-do/ I hope that's helpful.
Missed a good opportunity to demo some fake intellisense support.
full disclosure that I start using babel half way through, but only for the stabby procs, class syntax, and jsx. No complex toolchains involved.
[removed]
Well you can't really reuse arrow functions unless you put it into an object. Also it always binds `this`...there are some scenarios where this arguably isn't wanted 
Some people dislike anonymous functions _(cough ‚Äî Kyle Simpson ‚Äî cough)_ Some people like function hoisting. ¬Ø\\_ („ÉÑ) _/¬Ø
That's fair. I mostly do when I write JS. Been doing a lot of Python lately (gag me). 
I see you are already using the new syntax
[removed]
And the output is after button is clicked on the menu, a string of text replaces the current text layer
 const doubleBy2 = x =&gt; x * 2; Is identical to your doubleBy2 function. 
Probably because other languages that have the same arrow function syntax (C#, Hack) don't have one. Yes yes, I know that CoffeeScript does. That and the use cases are very narrow. There's not really a reason to complicate the syntax if it's not necessary. If you really want to maintain `this`, you can just use regular function syntax. 
Actually you are right, what the hell i was thinking
Not a problem. I you're starting out now, you'll run into a lot of situations that a year or 3 months down the line will make you think. Why the hell did I do that like that. Even more annoying are he situations where you look at a block of code and thing, how did this ever work, and you can't really self explain it... programming, soooo much fun. 
jeezus I'm barely conversant in ES6, let alone 2017.
Oh
Honestly the main thing that annoys me about it is it makes the language totally inconsistent. If you want *this* binding you use () =&gt; but if you don't you use *function()*? Those are completely different. It makes me feel like I am using some patchwork language (which I am). 
&gt; If you want this binding you use () =&gt; but if you don't you use function()? How often do you not want `this` binding though? I feel like that's very rare.
I had a lot of fun building it :D
[removed]
Poor soul who decides to learn JavaScript for the first time and finds this video. 
happy april fool's day. I can't get the point that es2018 changed everything,just sugar syntax.do you?
Because you use export anyway.
[removed]
Just looking for opinions about UI and functionality. Currently doesn't support IOS Safari due to drag and drop limitations.
Even so, putting the public declarations at the top is good practice. Separating the concern of what to export from the function declaration is another good practice.
I didn't get to make it that far. At 0:19 in I see a tweet of... my own? And I'm saying something I never said. Apparently just two weeks ago? *Methinks something is amiss!* Hats off to them with all the sneaky tweet edits. 
If we're just writing a normal, ordinary function, what benefit does const myFunction = () =&gt; { doStuff; } have over function myFunction() { doStuff; } assuming the function doesn't invoke `this`? To put it another way - other than using shiny new features for the sake of using shiny new features (which is, honestly, the sort of thing I would do), why change how you write ordinary functions?
Welcome to nightmare.js. You have to go to battle to get every new setup working. One day per project. Just kidding. Yes, you would generally just clone a starter kit from Github. Nightmare.js still pops up occasionally though, beware.
Ah. Can't drag crap in chrome. 
Nope https://github.com/jashkenas/underscore/blob/master/underscore.js#L176
I was going to take a look at the changes, but then I realized that it will all be revised again in three weeks anyway, so I'll just wait till then to catch up. #javascriptEcosystem
Dot syntax doesn't fix the problem that `.. + .. = ''`
I hope this doesn't apply to multiprocess Firefox. Or does it?
OMG I know a few JS devs that would actually like this to be real... Thank God it's not!
After you have installed Node, [Webpack](https://webpack.js.org/) is often the only build tool you need, everything else is a loader away, like [Babel](https://webpack.js.org/loaders/babel-loader/#components/sidebar/sidebar.jsx), Sass, React, whatever you want. Grunt and Gulp are old and complex tools that need lots of manual labor, i would recommend you don't go into that right now unless you must. As for transpilation, it's a major asset or language feature, you will always transpile. As you have already noticed, frameworks have CLI's for this. React, Angular, Vue, etc., they all set up a generic Webpack project for you, Babel is already in there, or Typescript in Angulars case. But it is better if you understand how it works, later you can use a CLI for convenience. Webpack also has a server and live debugging inbuilt. Setting this up for every project you start is more or less the same and it doesn't take longer than a minute.
Wouldn't that use a function before it is being defined?
This comes from the same guy who proved setState is wrong by giving an example by setting 20 setState in single function.
It is quite innovative! My code, which only I understand, has never been easier to read. However, I have this bug in my code... can you help? It's: c f. . ... ... .... . .. . . .... . .a.. .. c.l."foo" But it always outputs `bar` when it should be `baz`. [Please help.](http://www.jsfuck.com/)
I did try that and did not work. Thank you very much anyway. A friend just solved it. 
Why Object.create? Just export the object literal. Anyhow, there are plenty of articles which explain why singletons in general are somewhat iffy. The main issue is that they make testing more difficult. Things are simpler if your modules don't contain any state. E.g. only things like constants, function declarations, and class declarations.
You don't need build tools &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.4.1/react.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/react/15.4.1/react-dom.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.21.1/babel.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; const Hello = ({ name }) =&gt; &lt;h1&gt; Hello {name} &lt;/h1&gt; ReactDOM.render(&lt;Hello name="World" /&gt;, document.getElementById('app')) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; But you should ask yourself why you want to avoid them, because you are shooting yourself in the foot. Being able to set up a project is more important than your Javascript skills in the beginning. Javascript is an easy language to learn, but its highest asset is its flexibility and community support. If you skip this, you will not be able to do much with it. And let no one tell you that build tools are hard. Webpack gets you up and running in a couple of lines: module.exports = { entry: './index.js', output: { filename: 'bundle.js', path: './dist' }, module: { loaders: [{ test: /\.(js|jsx)$/, loader: 'babel-loader', query: { presets: ['env', 'react'] } }] } } Now you have ES6 and up, you can use JSX, you will never worry about dependencies as you get modules from npm and node, no more messing around with script tags. It has a live-reload dev-server inbuilt. 10 minutes with Webpacks [getting started guide](https://webpack.js.org/guides/get-started/) will guide you through this.
Yea that's true, I could just do that. I agree that singletons can be misused, but I'm not asking 'Should I ever use singletons?' I want to know if I can rely on the es2015 modules as a way to implement a singleton if I need to. For record, the use case I am thinking of particularly is a logger, a common use case for singletons. 
&gt; The only benefit is that it shows newbies that JS has first-class functions. I.e. that you can assign them to variables. You don't need the short function syntax for that. const foo = function() { ... };
&gt; I want to know if I can rely on the es2015 modules as a way to implement a singleton if I need to. You certainly can do that. (I'm too not to worried about the two potential pitfalls that author mentioned.) &gt; For record, the use case I am thinking of particularly is a logger, a common use case for singletons. If you want different kinds of loggers which are taken from a cache or created as-needed, you could also use a factory constructor for this.
Meant that it's the only benefit of using an assignment instead of a declaration.
Son of a bitch xD
&gt; Not ideal, but I can't figure out a way of doing that without a singleton pattern. You'd need to create a single instance and hand that over to any class which needs it. Dependency Injection (DI) is supposed to help with that.
Yes, but dependency injection introduced purely for logging capabilities seems like overkill. 
Hi everyone! This week I finally finished "Advent of Code" in Node / JS. I knew almost zero JS when I started and it's been a great experience, I would recommend doing this or something similar to anyone learning JS (or any language for that matter). If you're an experienced JS guru and want to give a newbie like myself feedback on my code quality, please go ahead! And if you're a fellow newbie starting out your journey to learn Node and JS, let me know if you have any questions. One thing I was thinking of doing next with this would be taking the custom data structure I wrote for the day 19 part 2 puzzle and making it a reusable library that conforms to the interface of a regular array, i.e. is a drop in replacement for it, but gives better resize performance. Any tips for that greatly appreciated!! My code: https://github.com/daveonhols/advent2016 Thanks!
Perhaps toString().substr()?
I'm not disagreeing with the idea of using secure code. I'm saying if you execute untrusted third party code then your own scripts aren't the security issue.
To me it's more readable to use the arrow syntax simply because it's more standard: that's how most languages write it, so it's simpler and quicker to parse for me. It's like if instead of [1,2,3] we wrote Array 1 and 2 and 3 ArrayEnd , then ES2016 added the square bracket syntax. People primarily used to JS might see that as shortening for the sake of shortening, and say you still have to parse it as array. But anyone who knew or used multiple languages would see that as more natural and easier to parse. It's also simpler because the function keyword can be used in multiple configurations with different semantics but the arrow function feature always means the same thing. 
gonna try it!
You have to use a [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) to interpret the ArrayBuffer that is given by the FileReader. Using `Int8Array`: let data = new Int8Array(event.target.result); // Access the TypedArray like a normal array
don't use slice to get a value out of an array, slice should only be used to get a sub set of an array use this instead: var eventstarthour = eventstart[1]
418 i'm a teapot!
Handling timezones is a nightmare‚Ä¶
Try using 4,6 as parameters
Be sure to watch all the way to the end. The Flow/Typescript reference is great!
Part of learning to code is learning where to look for your answers. Type your problem into google and look for 'stack overflow' or 'mdn' in the the search results. Even the most experienced developers do this regularily.
You should post a link to the repo so people can see the code and see if it is something they want to get involved in. Also open some issues on github. Lots of people are looking for open-source commits and you just might get some. That being said, I always love building things so feel free to drop me a line. 
The second parameter in slice is not inclusive, meaning basically 'slice up to this index, but do not include it'.
H . f . d .... .... K. .:)
I wouldn't personally use this pattern because the module itself is already a singleton. I would do: const things = []; export function addThing(thing) { things.push(thing); }; then import * as thing from 'thing';
Worked out it was an April fools the second the dot feature broke out. Before that I was like 'what the actual fuck are you doing'. Almost got angry. 
My eyes are bleeding...
... What?
Consider this: Widget A contains a weakness that unexpectedly allows users to submit unsanitised text in certain conditions. Widget B has a weakness that allows this text to be injected directly into the page. Neither widget is especially dangerous on its own, but when put together they are very dangerous. Yet if you patch *either widget*, the danger is mitigated. Replace "Widget A" with something big and largely out of your control: say, a CMS or a user comment plugin or a headline syndication service or an ad network. And replace "Widget B" with jQuery-UI or Handlebars and you get an idea of the risks. There are [lots of examples](https://www.cvedetails.com/vulnerability-list/year-2017/opxss-1/xss.html) to choose from. You can't stop a malicious ad from hosing your users, true. But you can stop them from using your libraries as the hose. That's why keeping an eye on CVEs is really important. The bottom line here is this: it is actually *more important* to keep your libraries patched when you allow third party code into your applications, not less important. Just keep them patched.
It's April fool's day, not January fool's day. Good lord. 
This video gave me back problems
I think you mean .. + .. . ''
Terrifyingly so!
*const multiply = function multiply (a, b) { return a * b }* "multiply" twice?
Almost believed it...almost!
419 short and stout
I got so pissed off about the dot syntax... I am upset now...
I get pissed off about most of the new non-joke EC features, maybe this video helps you to see the irritation from my point of view. This language had almost 0 change for 2 decades, and now it's changing as fast as the node libraries. It's like Javascript is trying to catch up with Scala.
It took me longer than I'd like to admit. I started planning my retirement from Javascript haha. 
Ejecting takes out the Webpack config that's all, now you can add stuff to it, new loaders, etc. I'd just start with a fresh, simple WP config and go from there, add loaders when you need them. Boilerplate often makes things more complicated than they really are. 
Watched this last night before 4/1 and was taken back. I know I'm late to the ES game but this really had me worried. Glad to know it's a joke. 
FUCK! lmao. so many options and configurations. webpack-dev-server feels more logical to use with webpack though Thanks
motherfuck! I watched the entire video with a mix of anger, fear, and disbelief. 
I appreciate it, but I don't need so much functionality for what I'm doing. Plus it's not a hobby, it's my day job; I know how to write unit tests :) I just wanted to make sure there wasn't some tricky thing with how modules worked that I didn't know about. 
The Good - * Project page is smooth * Api is clean * It works (except for tooltip with template on mobile) * Dropped JQuery dependency * It is orthogonal (isolated components of css and js) The Bad * It depends on PopperJS. PopperJS has a tooltip piece already. * README should contain contents of project page or a quick subset as some developers rely on READMEs instead of marketing fluff pages. 
Annex B is titled "Additional ECMAScript Features for Web Browsers". This syntax extension isn't part of JS itself. The intro paragraph also contains this line: &gt; Programmers should not use or assume the existence of these features and behaviours when writing new ECMAScript code. So, you really shouldn't use this feature - even in environments where it works.
As soon as he started talking about dot syntax I was all "WHY?!?" But then i was like "oh FFS."
See ADsafe and Caja. You can check if some code stays within some restrictive boundaries, but you can't easily tell if it does something malicious.
I recently did a project with tessel and am super impressed. It's got so much baked in to start with and modules they have are great as well as the ability to interface with any sensor using GPIO or I2C. If you're interested in getting into the IoT world I highly suggest trying out the Tessel. 
Arrow functions are not the same thing god damnit. 
Getting 500 on this.
Where does the blog name come from? Are you from northern Germany?
Yes :) I'm originally from Bremen and had to get it when I saw the domain was still available üòÉ
Nit: Why not just 'Math.random() &gt; .5'? Would be more efficient.
the harmonoscope in the top center is incredibly distracting, may be broken in chrome.
the dot syntax made me angry. Thank God I read this comments . Lol 
&gt; If you like writing code the way you used to, with callbacks, you can still do so. That's for me _writing_ my code. I still need to know the new syntax when _reading_ other people's code.
Thank you for your time. Om nom nom. Nah, just my dry sense of humor. Most of you can tell what this is without throwing it in anything anyways.
great idea. little late to the party tho.
What's the benefit of this over using something like jsonwebtokens and storing the token inside local storage?
I did think about it üòÉüòÉ
How would one do this? What commands would you use to place a tile, for example?
use your code for good
As a front end developer you must know that UI is chock full of tasty problems to solve. That being said I feel ya man. 
I disagree on the ternary comment (`? :`). It's very useful when assigning a value to a variable depending on a contextual variable/value. If you're using block-scoped variable declarations like `let` and `const`, that means that if you wanted the same functionality in an `if/else` statement, you'd need an undefined `let` variable declaration above the if/else block, which then allows that set variable to be susceptible to (direct) mutation, since it is not a `const`.
God i wanna get into node bots so bad. I swear after graduation im gonna go full tony stark on my apartment
I abuse the heck out of `R.pipe` now. :) I've been trying to see where to go from here; you may be interested in checking `partial.lenses` as well. That said, Ramda covers the more basic building blocks (if not quite a bit beyond that as well).
If you need an example of how to structure your vue js app here is an example todo app I made, maybe it will help you out https://github.com/Slegrib/vue-todo
So why not go back to university and do a phd?
ESB anyone?
Thanks for the feedback. I've released a patch that should fix those issues.. it's really difficult trying to make it work nicely with mouse, touch or keyboard navigation and handling all the events properly. Also Chrome touch emulation doesn't actually mimic iOS properly so I need to test it on an actual device which makes it harder. I'll update the README soon
If anyone wants to checkout this todo app i made to get started here it is https://github.com/Slegrib/vue-todo . I love vue js I think its more intuitive than react
Wish I would have watched this sooner. Totally worth it!
The syntax changes won't be coming along as fast as the update from ES5 to ES6. It'll be incremental updates which you should be able to do hello worlds with in a few minutes and then just use them or understand them when you see them in other people's code. Observables which are coming soon on the other hand... Takes some effort to grock.
Hope that SIMD and rest/spread properties make the cut.
hehehe genious xD loved the quotes/tweets they were hilarious xD
I definitely plan to touch on `R.prop`/`R.compose` in a future post! Haven't fully wrapped my mind around lenses just yet.
Distracting in a good way I hope haha. The glitches are from floating-point rounding errors I believe, but I kind of like the glitchy aesthetic it gives off :)
Thank you! More to come
Try this: /\^[0-9]{4}-((0[1-9]{1})|(1[0-2]{1}))-([01][0-9]|2[0-9]|3[0-1])$/ It will validate months with 2 digits only: 2017-04-02 will be ok, but 2017-4-02 will not. Try https://regex101.com/ if you want to make some tests. 
Cool. Don't forget to add a $ at the end, as 2017-04-02123456789 would also be valid if you didn't put the $. Also, reddit hid the ^ at the start. Make sure you add that as well.
Would love to help, could you maybe put your code in a bit bucket or something similar? It's very hard to read here.
Starting with ES6, I‚Äôd rather try to get as much as possible out of the built-in classes. Tools for doing so are: * Decorators * Mixins via subclass factories 
What really taught me scoping was learning when and how to use the `this` keyword. I'd give it a go. Realizing the usefulness of it really helped me solve stuff quicker, and oftentimes it makes your code more readable for others. 
higher gpa
You could refactor your functions quite a bit without losing much readability, if any, but I guess that's always subjective. Especially since you're repeating cycles in your 3rd *if* statement, as those conditions have already been previously checked. For example: function toItalic(word) { const begin = (word.charAt(0) === "*") ? "&lt;em&gt;" : ""; const end = (word.charAt(word.length - 1) === "*") ? "&lt;/em&gt;" : ""; return begin + word.replace("*", "") + end; } I'd also suggest using constants at the beginning of your module, or referenced from a separate module, so you don't have to repeat the same strings and risking typos. This, of course, depends on how often those strings are used. For example: const DELIMITER = "*"; const BOLD_TAG_OPEN = "&lt;strong&gt;"; const BOLD_TAG_CLOSE = "&lt;/strong&gt;"; //etc.
If you wish to have (classical) object oriented support, and code that works on new and old code, the above does not give you that. However, you still have the right idea that we should make use of what we have before bringing in the new, except that in your case ES6 is the new and decorators are new but not new. We make use of what we have to retain the merit of what we had so far, while ES6 breaks the old without bringing in anything new. CrxOop is not meant to be a solution for everything. First try procedural, then prototypal, then CrxOop.
I think the concept people associate with "microservices" these days is the idea of a distributed system using a microservice philosophy. RESTful API's are pretty straight forward these days. Breaking applications into smaller parts that can be distributed across servers is much more novel. Most projects don't require the level of scalability that microservices in a distributed architecture offer. I also came here looking for more insight into such a system.
Kyle Simpson's book "You Don't Know JS: this and Object Protoypyes" is a wonderful crash course You can find it free on his GitHub (getify). It's really a great book and series. Quick one-day reads and references. Like I said it's free online, but buy it because it's worth it. 
`import { groupBy, prop } from 'ramda'` ;)
At the moment it's hard to decipher what this code actually does without reading it carefully from top to bottom. The first line is obvious - you have a message coming in via a socket. But then it's hard to follow. I think the first step is to give your functions and variables more descriptive names. For example, "checkUrl" - check for what? "processUrl" - process it how? Or "output" - you're using that to store HTML. So why not call it "html"? And so on. This is one of the more difficult things about writing code for any skill level. Ideally you have an overview of what happens when a message is received by a series of appropriately named high level functions - "OK, so a message is received, it's validated, it's checked for X, Y, and Z, it's turned into HTML", etc. Then you can explore what happens in those functions if you need to, but it's not mandatory.
&gt; In 5.6 we bring experimental support for WebAssembly, a new cross-browser technology designed to help improve the Unity WebGL experience. a little presumptuous eh
They explain the reasoning right here: &gt; anonymous functions can make it harder to locate the problem in an Error's call stack. When you're using a debugger and you look at a call stack, it's a lot easier to see what's happening when you see function names and not "(anonymous function)" on each frame. 
 // good - always go with the declarative option if there's one function foo() { // ... } // silly const foo = function () { // ... }; // lol no const foo = function bar() { // ... }; Function declarations are perfectly fine. ESLint and TS' compiler will tell you if you actually redeclare one of those. Using consts for this improves nothing.
There's some more discussion here: https://github.com/airbnb/javascript/issues/794 I'm pretty sure, with babel's help, writing const foo = () =&gt; {} will still give you a named function in browsers. I also just tried in node `v6.9.5`, and that same code gave me a named function, without any help from babel.
The main point here is that people/companies have opinions. If you're a novice, you can choose to take opinions from people who are more experienced than you, but don't treat their opinions as gospel. Try things out for yourself, and don't be afraid to experiment. Good luck out there :D
Just use https://github.com/gajus/babel-plugin-transform-export-default-name (for exports).
I like it; lets do it. Already a good bit of yellow forming on the square.
This has only been the case relatively recently, it was not always this way (and will not be this way on older browsers).
Maybe I'm not understanding what you're asking, but is that not the whole idea behind event listeners, to be asynchronous? Wait for Event A to happen, then call its callback? 
They so happen synchronously , I think
I thought they do happen asynchronously as well but it turns out they they happen synchronously , 
I was thinking the same thing, wondering what I was missing... Good to know it's not just me.
If you're doing a lot of date manipulation, you should look at moment.js. It's easy and works flawlessly. If this is just input validation, carry on... :)
i mean... the way most people use the airbnb style guide is via a linter
All events fired by an `EventEmitter` in Node will invoke their listeners **synchronously**.
I started learning JavaScript a month ago. Maybe two. This week I finished my first self-imposed challenge, to create a Yahtzee program from the ground up. I mean it's not *done* done, I still need to figure out the CSS and try to figure out a way to track high scores, but the basic functionality is up and running so I'm pretty excited about that.
What does a linter do besides enforce code conventions?
Wait, what is the difference between typed this? // bad const foo = function () { // ... }; // good const foo = function bar() { // ... }; Why not? const foo = function foo () {} ; What would each of these show in the debugger? 
This is nonsense. Just don't write functions outside of classes in the first place. One file per class. Keep things organised and the code will be incredibly easy to navigate.
Is it okay to nest functions? If I want to check if a word follows the format for bold text should I use something like: isBold(string) ? toBoldTags(string) : false; Or should I just nest the toBoldTags function in the isBold one? Edit: I used one function at first that covered both actions but isn't it better to give each function only ONE purpose?
I meant that not only did they fool me, but they also made me get out of bed to be pranked as I had only read the title.
I think this makes sense only when the function you're writing amounts to a one liner. Anything that is more than a 1 liner amounts in the same lines of code.
I actually really like exploiting this. module.exports = { func1, func2 } function func1(){} function func2(){} This lets you see what a module has immediately without going down to the bottom.
Visual Basic for MS DOS - https://en.wikipedia.org/wiki/Visual_Basic#/media/File:Microsoft_Visual_Basic_for_MS-DOS_(Professional_Edition_Version1.00.png ( sorry... can'remember how to format image links with brackets in the filename on Reddit :/ )
IMO it's still more of a tooling problem than a language one since we're talking about debuggers and call stacks 
:S the void took over?
I'm not talking about using a linter to enforce the convention of declaring functions like `const foo = function bar() {`. I'm talking about using it to spot when people try to use a function before it's declared -- which was the reason for that convention in the first place. So the linter spots the bug itself, rather than spotting someone not following the convention.
It's not homework and I already figured it out
In your last example the variable assignment shadows the function declaration which can create other issues I'd imagine.
Lighter to write but less readable, since it shares the same syntax as variable assignment, as opposed to function keyword + brackets. That means the reader has to pay closer attention when skimming through code. People who prefer that style come off as hipsters to me. I get it, you're special. Express it in other ways than coding style. Dye your hair blue and get a piercing, like everyone else.
I think one thing to take out of this thread, is that just because a large company prefers one style, doesn't mean you should hop on the bandwagon and take everything they say as gospel. I use AirBnB's style guide too, but my linter's configuration has about 10 custom settings to go against AirBnB's advice on specific things. 
Looking at the 3 examples provided by the op. * Example 1 gets hoisted to the top of the scope. * Example 2 is an anonymous function, which sucks balls when it comes to stacktraces, profiling, and general debugging * Example 3 is just right.
Thank you! I have discussed Matter.js in another comment. Regarding community size Box2D has a bigger and stronger community and Planck.js is just rewrite of it. Box2D was published in 2006 and is used in many popular games such as Angry Birds. For collision detection, I'm not sure what exactly is your use-case, do you want to detect collision between bodies (shapes) but do not resolve them? Integration is similar with Planck: `world.step(1 / 60)`. See github readme page. Also feel free to open a github issue for more discussion, I don't check reddit regularly.
A giant mess of random global scope functions is most definitely not organised.
Why not just function foo () {} ;
Airbnb is too damn strict. I've stopped using their lint rules
I havent touched JS in years but I'm going to assume this then allows function foo to be overwritten / reassigned which is what they are trying to avoid
Only if you set up a local web server
JavaScript *does* have them. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_methods
Damn, that's cool.
Modern web browsers are not allowed to read a file from disk. From node just use 'fs'.
Man.. you are amazing, keep it up! If tou talk about webpack 2 add one with code splitting base on route, and tree shaking.
That function would be hoisted, allowing behaviour like this: foo() function foo(){} They argue that this is confusing, since you use foo before it is defined. You can't do that with a variable. They name the function to get back the stack name they lose by using variables. Personally, I don't agree with this rule.
Thanks
You could try to add `console.log(r)` at line 67 or something or try logging it in console -- if it's in global scope just running `console.log(r)` will be informative. Personally, I couldn't see any reference to an `r` object, but I didn't look too closely either. 
Just an FYI. On my phone (iOS 10) there's a rather large fixed and practically empty navigation bar at the top.
[Here's another way](http://codepen.io/ajbogh/pen/LWqqYW). The script was too long to paste in a comment, so try it on codepen. The console will say "123". Also, try to make one [here](http://patriciopalladino.com/files/hieroglyphy/).
isn't this basically the same as `new Function("console.log(123)")`? I'm sure there are practically infinite ways of exposing `Function` without referencing it literally, but it's still essentially a repeat.
So lenses are just like "I have this thing and now wanna get/set/edit part of it". In Ramda, instead of lenses I mostly used path/prop/pathOr to get, `assocPath` to set, `evolve` to edit, which wouldn't directly cover editing by function for deeper properties but otherwise saves a few calls. In that `partial.lenses` lib it gets a bit more interesting because lens creation syntax is no worse than path/assocPath and it suddenly allows grabbing multiple values as well (Traversals), with extra aggregations built-in to save you from manually composing that on in Ramda.
Aside from three shaking, not all js runs in the browser. 
well, this implies it's cheating as this lib was tailored for this particular use-case, but you'll actually find it's broad enough that just this one lib could cover you on a whole bunch of your general use-cases. and I think demonstrating that was kind of the point.
Me neither, because I only use function statements when I want to call them by name, and only use arrow functions when I directly pass them as function arguments. So all functions are either imported or hoisted, and I can put my block of top-level code wherever. But I also avoid mixing top-level code with function definitions. Functions can be imported.
The above method has been discussed here: [stackoverflow.com/questions/18635387/advanced-syntax-0constructorconstructor-how-does-it-works-to-evalut](http://stackoverflow.com/questions/18635387/advanced-syntax-0constructorconstructor-how-does-it-works-to-evalut) 
Linux only shit. My work forces me to use windows
Why would you try to use a variable before you define it? That's an error.
Also: c.l.12.. using ES2018 dot syntax 