Coffeescript troll. Check his posts, has self-admittedly never coded any significant amount of coffeescript. Reminds me of friends at Microsoft that questioned why would ever need a new language since we already had C++.
Gasp! Not even C#? C++, C# same thing really. There's a C in it.
If you'd like a solution that doesn't depend on jquery, might I suggest https://github.com/component/emitter
I would just roll my own since it's only a couple of functions. Maybe in the next iteration. Thanks.
Sure thing. I meant This as a very simple api and an example of something that you could borrow from if necessary.
Thank you.
Check out the new samples in the /samples directory. There's an index.html file and an otherdomain/index.html which have some explanation on the setup. https://github.com/ajbogh/PM.js/tree/master/sample Yours is similar. I like how you allow it to take an existing iframe. I might add that to my system as well. I designed mine based on some very complex use cases I dealt with at Disney, such as creating n number of iframes and executing scripts on them. We had the potential to run 30+ postmessage iframes, given the various domain configurations. I'll dig into your code a bit more to see how you're handling returns and callbacks.
The only possible flag I see on OJJS is how will it effect Google results if the content is all in JS. Does any one know?
There is no way for me to detect that the returning class was referenced to MyClass. Thus the class could not know about it's own name. One could naturally argue that that might not be a necessary feature. For instance we would not be able to make console.log return [Class MyClass] without this feature. 
According to the HTML5 spec, self-closing tags aren't required. Why is it forcing my &lt;input&gt; to become &lt;input/&gt;?
You can run oj on the command line and export HTML / CSS: http://ojjs.org/docs.html#commandline
Tell you what, you might be right that that approach is a better way to do things.
It's pretty natural in JavaScript for classes to not have names. Usually even other JS OOP libraries also leave them unnamed. Either way demanding named classes is very ugly. If you really think it's important, still, just ask for a string input for naming the class instead.
And TIL the npm server is a CouchApp! That is true? I have always liked the idea and will once again take CouchDB and Cloudant more seriously in my tinkering.
You're both allowed to have that opinion, but who cares? It's an argument from your personal familiarity. X is better than Y because I'm used to X and have never even tried Y. Have the opinion, but he goes out of his way to post negative things about coffeescript. I welcome valid criticism, but this isn't that.
Shame on whoever wrote that website they broke the default shortcut to open a link in a new tab
&gt; Web Reflection dude...it is like someone posted something about Dreamweaver and you are saying how is this different from Eclipse or Visual Studio IDEs? People want choices bro...you make it sound like jsfiddle invented javascript. In my opinion Liveweave is really good in what it is doing...and I love it, so far. 
This (and porn) are why I disable allowing sites to override the context menu in my browser.
It is, actually.
"made up language"... as opposed to what? 30+ years. Congratulations, but that's an argument from authority. I have written javascript since the beginning as well my friend, and I have ported and written hundreds of Coffeescript files also. The same program written in coffeescript is always about 40% smaller than javascript. Syntax fetishist? Whatever. If I can accomplish the same thing consistently with 40% less code, then I'm all for it. Call that what you want.
You can even replicate it and have your own copy of npm. Last I checked all of npm was only 15gb or so.
great stuff. thanks for sharing.
yep...same here :)
@ggolemg...do you even know what resource upload means?? jsfiddle just adds the resource link in its head tag...it is just that the whole thing is hidden and not shown in the HTML panel. 
You keep saying "made up". Seriously, as opposed to what language which isn't "made up"? Btw- I still code both javascript AND coffeescript. I drastically prefer coffeescript and have no problem understanding either. The coffeescript is significantly easier to understand.
Jeremy Ashkenas said this: &gt;[If the question is "why is CoffeeScript not a DocumentCloud project?" - it's because I can't justify using it for the main DocumentCloud development. Imagine trying to hire someone. "You'll have to learn to use a new language that we made up..."](http://readwrite.com/2011/01/07/interview-coffeescript-jeremy-ashkenas#awesm=~oiBF6EzTw6tLFq) I've turned down jobs because part of the codebase was written in coffeescript. It's a sign that they aren't very good at decision making when it comes to technologies used in their stack. I've had enough of the headaches brought on by buzzword technologies. There's nothing to coffeescript that javascript can't do. People will need to master one or the other, but javascript is the only real best-practice choice for front-end web development in 2013. The creator of coffeescript himself was wary of it's use. He called it a "made up langauge", not me. &gt;The idea is to write your source code as if it were an essay for a person to read, instead of a series of instructions for a machine to execute. No thank you. I'd rather not have to read or write essays all day long. No. Code is code. It is intended for a machine. If you want to know what the machine is going to do, don't wrap it up in ambiguity. Machines and humans don't do ambiguity well. The for loop in coffeescript is probably the worst abstraction I've ever seen. insted of eng let's typ lIk DIS insted. It's much less frustrating 2 rED. DIS iz wot cs iz. A psuedo-lngwij dat letz U typ less whIl lozng SNshL elements dat mAk it EZer 2 rED. cs iz d lngwij 4 ppl hu tink txtN lingo iz :) 2 rED. iz DIS harder 2 read? It's 40% less txt. 
Author here=). This is a great comment and you definitely have a good grasp of the HTML and CSS syntax at the lowest level of OJ. The dream, though, is you won't need to write HTML/CSS in this style as often since OJ is all about creating much higher level Objects. I know it is not immediately intuitive, but by supporting all three you can make Objects that completely abstract the web. Not just a part of it. For example the BulletList object that creates it's own content, but it allows you to change it after it is inserted: http://jsfiddle.net/evanmoran/kDb7C/ This really can't be done in a any other system right now. Not only did you not need to know any ul,li tags (clearly not super hard, but nice anyway), but you didn't need to know jQuery to manipulate the DOM. If you want to take lists of form elements and bind them to models. OJ can do that as well: http://jsfiddle.net/evanmoran/uEWFh/ Again, that is not something you can do with simple templating engines. To show how having built in CSS support is powerful, check out how OJ does theming of objects: http://jsfiddle.net/evanmoran/RmM96/ Or maybe you want to use plugins and insert VimeoVideos with one line: http://jsfiddle.net/evanmoran/yPXuL/ I hope that gives you a sense of what it can do. You are absolutely right if OJ was just an uglier way to write HTML/CSS then there would be no purpose. The benefit is its objects create themselves AND change themselves. It is really quite powerful! 
This is only ever a problem if you have a compiler/parser on the browser. Otherwise, CoffeeScript still "compiles" to javascript.
It's just a hilarious argument to make, calling javascript "close to the machine". A scripting language designed to be interpreted for browser animations and form validation is somehow now "close to the machine". Btw, no modern javascript runtime actually "interprets" javascript. You really miss the point of a language being "closer to the machine" or not. The implication is that you can write code that is faster in a language closer to the machine, or that the code you write more directly maps to what the machine actually does. In this important regard there is absolutely zero difference between javascript and coffeescript. They are both equally "close to the machine". They both create equivalent code, and they both use the same tools. Your argument might have merit if coffeescript abstracted away your ability to do things in javascript. Then you might be farther from the machine... but it doesn't. There is nothing you can write in javascript that you can't write in coffeescript and in almost all cases it will be more concise in coffeescript.
Do you even understand why its a ridiculous argument? Javascript is like 10,000 feet from the machine and you're complaining that coffeescript is 10,003 feet away.
You made the orginal argument stating that JavaScript isn't closer to the machine than coffeescript. I proved that it is one step further away and **you agree**. I don't even know what we are talking about anymore. So on that note http://i.imgur.com/XNhfI.gif
Here is a lesson in the evils of abstraction for you. Taken from: http://stackoverflow.com/questions/10246422/simple-loop-in-coffeescript &gt;I have this code: &gt;count = $content.find('.post').length; &gt; for x in [1...count] &gt;I expected this to turn into &gt; for (x = 1; x &lt; count; x++) { &gt; &gt;but it turns into this: &gt; for (x = 1; 1 &lt;= count ? x &lt; count : x &gt; count; 1 &lt;= count ? x++ : x--) { &gt; Can somebody please explain why? This is one of many examples of what-the-hell-are-you-talking-about-coffeescript?? The first line of code is an abstraction for the last line of code above. At least when I write in javascript... for (x=0;x&lt;count;x++){ ...there isn't a layer of abstraction getting in the way. The coffeescript bug would also be more difficult to find because there isn't necessarily an error generated by this type of thing. Source maps won't be of much help for this either. You'll have to trace through the now obfuscated code that is compiled coffeescript. I can see lots of room for error here and a more difficult debugging experience as a result. 
Yes, you are right. The main problem I can see is that it often break encapsulation. It is difficult (but not impossible) to package components that contains all the HTML, CSS and JavaScript to obtain a single feature. I think that's the problem they want to solve. I don't like the approach thought. But the idea Is not that horrible as others build entire ecosystems on that: gwt, vaadin, etc.
Yea, there are some content management systems which kinda try this encapsulation or rather *packaging* thing. If you add one plugin/widget/component to the page, it automatically includes CSS and/or JS this thingy depends on. Now, the problem with that is that it quickly spirals out of control. If your page references dozens of JavaScript and CSS files, performance will suffer. Well, there is of course another plugin (or build/deploy step) for that which merges and minifies the CSS/JS files. This surely helps quite a bit, but there obviously won't be any reuse among those components. Your CSS and JS will quickly grow. Facebook had this kind of problem, for example. There were many small teams and everyone wrote their own CSS. The magical build system took care of the rest. Naturally, it grew like crazy. At some point they had like 1MB of highly redundant CSS. The only feasible solution to that problem is to create a library of reusable building blocks, which is pretty much the opposite of having one CSS file per plugin/widget/component.
&gt; The only feasible solution to that problem is to create a library of reusable building blocks This is exactly what OJ is -- a library of reusable building blocks! Did you see the plugins page? http://ojjs.org/plugins.html As for CSS, it is your choice if you want CSS per widget or globally or however you want to think about it. What OJ provides is functions to style either at the global level (css function) or per object (theming: http://jsfiddle.net/evanmoran/RmM96/). You get to choose how you want to organize CSS. If you like thinking about styling in widgets do it that way. If you want global styles, that is fine too. The main difference is the separation of concerns no longer have to be in separate files. It is in code instead. It turns out functions are pretty good at abstracting concerns=). &gt; Well, there is of course another plugin (or build/deploy step) for that which merges and minifies the CSS/JS files This is exactly right. OJ at its best is server-side built into the HTML/CSS/JS that people love. This makes SEO and fast load times quite reasonable. Think of it as a server-side templating language that just happens to do all of them at once + a powerful object system that creates reusable building blocks. 
Not sure 'abstraction' is the right word for this concept. This is more a case of 'translation'. Anyways, this is a well known case. The loop "for x in [1..count]" is not equivalent to "for (i = 0; i &lt; count; i++)". The former handles both positive and negative values, and can't know which count is because it's a variable. The fix is of course to write "for x in [1..count] by 1" if you know that count is positive. How often does this type of loop happen in practice??? I just searched one of my coffeescript projects. I found 65 for loops and not a single one did a loop of that form. They were all either "for in" an existing array, or "for of" key/values on an object. From my experience, I use loops of that form maybe 1% of the time. More important to me is how handy this is: foo?.bar?.x the equivalent javascript being var _ref; if (typeof foo !== "undefined" &amp;&amp; foo !== null) { if ((_ref = foo.bar) != null) { _ref.x; } } It's so handy in fact, that something equivalent will now be included in the Harmony release of Javascript. Whether you like coffeescript or not, it will improve javascript for everyone.
what they produced was garbage, took the other browsers to fix it and then MS finally got around to supporting the standard. Get your history straight, this is exactly why I will never use MS products. They are crap...and always have been.
I feel like the hype that angular has gotten over the past year is going to lead to a great deal of backlash very soon. People eventually reach a point in their app's development where it becomes nearly impossible to scale and where performance problems are difficult to pin down because of the mostly opaque framework code that people's application code sits on top of is incomprehensible. I know this because its currently happening to me. My team was drawn in by how easy it was to get complex UI's up and running with minimal amounts of plumbing; but abstracting a lot of that plumbing away from us is really screwing us over now.
Have you used require.js ( or something similiar ) ? Then the syntax should not be alien or convoluted. As far as I can tell between require.js and Angular, in the way objects are created and cached and the way they are injected, the sytax is pretty much the same. The automation obviously helps because you have to do soo much less. Also, I have heard a lot of claims that Angular is a blackbox and stuff like that - but, in my humble opinion, Angular is one of the most extendable high level framework I have come across. The point where you find out you can override every single thing the framework has - without feeling like you are doing something hacky is when you find out how well thought out it is. Did you know that you can completely override $http itself? How about all the $scope $digest, $watch etc ? Ofcourse, no normal developer who is just using the framework requires to do that - but the thing is the framework does expose points where you could override the whole thing and that is powerful. 
Can you mention specific points where you are getting into a bottleneck? I just put in another comment that the framework is anything but a blackbox. Over time - when more and more documentation seeps through this will become less of an issue. But until then, you always have SO, angular forum etc where people are more than happy to clear your confusion points. Or points where you think things are not making sense. I think it is completely wrong to blame the framework for your lack of knowledge. 
Time again, would you go backbone or emberjs? Or something else?
And a clearer documentation imo. I'm converting from should.js right now. :-) Thanks for posting (or coding if you're in someway behind the project).
You're right that all of those are interesting uses of OJ. Out of all of them, I find the list elements one the most compelling for ease of use. But when you break it all down, tear away the hype, you've abstracted away element creation and data binding. That's all very nice but I still have no intention of shoving all of my DOM creation in to Javascript whenever browsers have been optimized for pure HTML. Sure, you could export out HTML from some kind of OJ file but then your JS would have to be modified to access those same elements, likely through CSS selectors. Which, again, CSS is extremely simple. If you are doing *anything* on the web then you have at least a basic understanding of CSS meaning that selecting elements from the DOM becomes nearly trivial. The data binding is quite nice, I will say that but it's nothing you couldn't accomplish with a far less opinionated system like Backbone. Hell, I threw together [my own (poorly written)](https://github.com/MCluck90/jquery-lite-binder/blob/master/lite-binder.js) data binder when I was still getting my feet wet. I'm not saying your baby is ugly. It's a very well designed library with a simple and intuitive interface. But at this point in time, I don't see it being used for anything other than toy projects.
Be careful using $scope.$watch('object',function(){},true) with 'deep' objects. FTD: &gt; The listener is called only when the value from the current watchExpression and the previous call to watchExpression are not equal (with the exception of the initial run, see below). The inequality is determined according to angular.equals function. To save the value of the object for later comparison, the angular.copy function is used. It also means that **watching complex options will have adverse memory and performance implications.**
I made a couple of applications with Angular.js and I agree with your comment. When you first start there is some learning curve but nothing to crazy and two-way binding is great. After using it for a while I ran into some annoyances and limitations. The first annoyance is that there are way to many concepts in Angular.js and there are different ways so solve certain problems. For example I had a moment.js date I wanted to format in a certain way. The most basic solution is to format the date in your controller and set it to scope. You can also make a filter and use that on the moment.js object in your view. An other option is to make a directive. So I went for a filter since that made the most sense. There is one gotcha though with filters. &gt; Filters are called at least twice during every digest cycle. For that reason, it's best if they are lightweight. So if you are using a filter in for example an ng-repeat you might want to use it on the data in your controller before passing it to the view with $filter instead. This is only a trivial example and with experience you'll get better at understanding which to use where but even then you sometimes have multiple options. I am just a solo developer so for me it's not a super big issue but I can imagine if you work with a team you have to setup some strict rules so you don't have one guy using directives while an other guy is using filters and controllers. I also started using ui-router to have a better router experience but that added even more concepts (state, resolve, ...). Something else that grinds my gears is the module system and structuring your application. If you have a more non-trivial project you mostly want to add a build system. The most popular option seems to be a grunt task that will concatenate all your files. The problem with this is that the module system in Angular.js is just a giant bag of strings. This means that you can't have two modules named 'controllers' or they will overwrite each other. Since the module system isn't related to files it's can also be hard to track down where something was added when you application grows in size. Since I am a Node.js developer I am also familiar with CommonJS modules. But because you can only inject modules by their string name this means you have to require the module first so it gets registered by Angular.js and then inject it inside the your module by it's string name. So the two module systems don't compliment each other instead they live side by side. Two-way-binding is an other pitfall. When you first start using it you can be productive but when you application grows you start to realize that you don't get it for free at all. This is most noticeable with ng-repeat. If you are going to repeat data you really have to think about what you are repeating and how much data you want to feed it. For example I had a calendar app that shows events for each day. This means I have a ng-repeat for days and a nested one for the events. It looks something like [this](http://sproutsheet.site44.com/#/grows/0). If you try flipping through the days you'll notice that it's really slow. I recreated almost the same application with React.js and performance wasn't an issue. You can find it [here](http://sproutsheet.site44.com/react/index.html). The reason why angular is so slow is because it needs to setup watchers for all the bindings. There are a few ways to solve slow repeaters. Bind once directives and limiting the amount of data you show (paging, loading data on scroll, etc). In my first design I even showed all the days and events at once (not per week) but that didn't work at all (crash the browser). So when you start wireframing you application you should actually already know that ng-repeat might be slow and structure your design accordingly. This problem isn't Angular.js exclusive as you should always try and limit the amount of data you show but with Angular.js it seems you run into performance issues a lot sooner because of two-way-binding. **tldr** Angular.js can be productive and two-way-binding is great but when you app grows there are some serious pitfalls/limitations you have to consider.
I stopped using inheritance over 15 years ago back in the early days of Java with .NET and haven't looked back. Now that I'm coding in JavaScript, I don't have to worry about the THIS pointer everywhere in my code. A nightmare of overhead even with bind().
Per popular demand, version 2.0 is now released, using a more JavaScript alike syntax. **Changelog** * Changed syntax such that new classes are returned on creation and can be stored in any variable. * Classes no longer toString to a nice name of themselves. Rather they toString to what a JavaScript developer would expect. * Speed has been improved by about 30% for both initialization and method calls * Total code size has been reduced by about 20% * Code can now be compressed with uglify without the compressed code needing changes to work. 
&gt; If you try flipping through the days you'll notice that it's really slow. I honestly couldn't tell a difference, even when looking for it... 
No, "ES6" is D.O.A. Changing javascript to cater to different syntaxes is the tower of babel. Whatever becomes of ES6, it won't be Javascript and they should not attempt to call it such. foo?foo.bar?foo.bar.x:undefined:undefined I would rather read and write this than have Javascript syntax change, or use some shoddy macro-language. Your coffeescript version is also bloated and a bit obtuse. There are improvements to browsers that are welcome, but changing the lingua franca of the internet is nothing but catering to a small group of syntax fetishists who cry about typing too much. Throwing the baby out with the bathwater is what they are doing. ES6 has about as much chance as coffeescript in the browser. Far too many people already know and love Javascript, and have no interest in changing. It isn't that I don't like learning new things, I learn something new every day, but don't fuck with our most basic and trusted tool, which is Javascript. It hasn't gone well for JS 3, JS 4, JS 5, and no doubt "ES 6" will be another non-starter just like coffeescript. Keep dreaming scrogu! JS 1.5 is entrenched and will continue to dominate for many years to come. 
Like mozilla and webkit never come up with new things that aren't a standard? You're just another ignorant fool if you think MS hasn't contributed anything useful. Get off your fanboy highhorse.
I've been using TypeScript for a while now and it has a good implementation of the ES6-style classes and arrow-functions and I must say the two combined are utter bliss. They make working with objects really nice again, the .prototype. based OO was cumbersome to text-wrangle and indeed all that `var self = this;` was silly. In ES6 the `class` notation is compact without breaking JavaScript feel, and the arrow functions have a bound this. I use arrow functions a lot with promises. If you have methods returning promises that you handle using arrow functions you get this odd but very fluid and flexible asynchronous OO style. (tip: use Q for promises). It makes it very easy to composite little blocks of functionality into classes, and recombine those again by glueing their promises together into new blocks. And you *could* still do a little bit of inheritance if you must, it is just a tool.
Personally I wish you had copied the [plnkr](http://plnkr.co/) instead of the JSFiddle layout. While JSFiddle, and I guess Liveweave now, have everything in front of you on one page, which can be nice, I prefer to have more room to see what I am doing and plnkr's layout does that. edit: this also seems to have a lot of the features of plnkr and jsfiddle but between the 2 nothing new. Can you prove me wrong on this?
You'd rather write that? Really? How about for this example: option = alpha?.beta?.charlie?.delta ? false This is incredibly easy to read and understand. Your JavaScript would be: var option = alpha != null &amp;&amp; alpha.beta != null &amp;&amp; alpha.beta.charlie != null &amp;&amp; alpha.beta.charlie.delta != null ? alpha.beta.charlie.delta : false; This is not a contrived example either. It is very common to extract config values at the beginning of a function and provide default values. I just can't go back to vanilla JavaScript. Not without the existential operator. I can live without most other coffeescript features, but this one I must have. Not sure why you think harmony is doa. Features are slowly working their way into all major browsers. Yes, JavaScript will dominate for years to come. Not sure why people are so threatened by languages that are transpiled to JavaScript. It's a sign of javascripts strength, not it's weakness. Just like the presence of scala on the JVM. 
What browser are you using? I mostly notice it in chrome when I for example quickly try to move 4 weeks back or forward or when adding a few events it starts lagging.
Not sure if I can see what the twist is...
Yes, I use require.js, but the angular syntax for modules is foreign to me. For example, i will create unnamed modules using define and reference the modules by their filename path, not a string. In addition i write my defines with only the require object as a param, then list each dependency as one liners at the top of the define function. Doesn't seem like angular does either of these. The thing that trips me up is the factory, service, and overall DI pattern.
Agree 100%. It's not even the tooling story (intellisense etc) that got me using it; it just makes for a better and more self contained mental model of what my application is doing at any point than pure javascript.
the tolerance bit haha!
Ok, now that you explained the actions you took I can see the lag. Originally, I just casually browsed from one week to the next, and though there's the initial click lag, that's present in both implementations, and it's not until you rapidly click between weeks that the lag is noticeable. Is that a valid use-case, though? Or could it be solved in another way? I would think that if you needed to advance 4+ weeks, that navigation by month would be more natural and user-friendly... I know I'd get annoyed if I had to navigate from Sept to Dec by week, regardless of how snappy it was. Either way, thanks for the insight. I'm just starting to toy with AngularJS, and posts like yours are very helpful.
There will be a move to first and last event button and a move to today button. There is also a little overhead of filtering the 1000 events at the moment for each click (30-60ms). If you are looking into building client-side apps I liked converting my app to React.js from the facebook/instagram team (only used it a week and a half). It's requires a little more code for setting the events but it gives you more control. They also only give you the V in MVC so it works well with other libraries like backbone. But it depends on what you prefer as well. Angular.js is super popular at the moment so knowing it surely is a good thing if you are looking for work.
this really applies to all OOP programming languages. the "has-a" relationship is stronger/more useful than the "is-a" relationship.
To me it just seems he was trolled into such an answer. He's got an opinion, and even if it could be "wrong", he got a "you don't have the knowledge.".
It'd be good if this supported https://developers.google.com/closure/compiler/docs/js-for-compiler - Closure needs a good doc generator
Especially for languages that don't allow for multiple inheritance. 
Instead of polluting the link function with inline HTML, why not just use a template (or templateUrl) property and then use a built-in directive like ng-src to data-bind from your directive's $scope? return { restrict: 'E', template: '&lt;img ng-src="{{myImgSrc}}" class="{ 'someClass' : trueOrFalse }" /&gt;', link: function(scope,iElm,iAttrs) { //logic here scope.myImgSrc = 'http://something.somewhere.net/nowhere.jpg'; } } 
Maybe. I just wanted to make sure people understood that plugins, etc. will not "just work".
did not know this! But like the article (and commenters in the article) say, this is very bad practice to use and rely upon
&gt;as jsfiddle handles resource uploads. Do you even web bro? 
This is awful. Never use this.
I bet you have sleepless nights about semi colons too. Omission is just a deference to sloppy assholes, not a recommended strategy. Keeping your html well formed allows it to be parsed by a much wider range of tools.
I find it interesting that they removed the "weight" from jQuery like $.ajax... $.ajax is most of the reason I use jQuery!
This is kinda like when someone writes anything in BrainFuck. Cool... now make sure it never sees the light of day.
Anybody who relies on this should be taken out back and shot
If you want something small and jQuery-ish, wouldn't Zepto suit your purposes?
but if you are building with node you shouldn't need those ajax calls. if I understand this right it's a jquery subset with angular / node devs in mind.
Surprisingly playable, though a little slow, on Firefox. I like the widescreen...
Last supported version 1.4.6? I'm interested, but not in reverting that far.
That.. wins.. the internets..
&gt; `context = context ? typeof context === 'string' ? document.querySelector(context) : context.length ? context[0] : context : document;` Readability seems to be taking a backseat here.
I fail to see how any of this would be useful in an environment without a DOM (node).
I like this. I do not like using jQuery because of its bloat, so I usually end up writing many small utility functions like addClasss(), removeClass(). This would simplify that and has a familiar syntax for my coworkers who like jQuery (but don't get to use jQuery because I'm a dick and I said no). &amp;nbsp; The only issue I see with this library is the lack of cross browser support--when they say *modern* they mean it. I saw no support for things like attachEvent instead of addEventListener, so beware if you still need to support IE8.
There's no need to resort to name-calling. If it's not required by the spec, I shouldn't be forced to do it. If you are trying to get web developers to use your tool (for which there are many alternatives), don't force them into a specific coding style.
The point is if you keep your html well formed you can use tools that are only made for XML. It also improves parsing performance not having to process edge cases. If you want to lump yourself in with people I consider sloppy, that's your business, I wasn't saying you were, just succinctly voicing an opinion. There are parts of the HTML and JS specs which are simply there to ease the pain for those who find it difficult to conform to a rigid spec. However if you're doing this professionally you need to know why you shouldn't look to cut corners. If you have any regard to saving yourself time, you don't do it by dropping an optional slash, because the payoff is so minute. Instead use a preprocessing language like Slim, Jade or perhaps Haml. Then your html is generated perfectly while you can maintain a source file which has way less cruft than HTML. 
You seriously think I'm trolling? Is this a joke? I brought up a valid point about HTML in a subreddit revolving around JavaScript, which, with the exception of node, deals directly with HTML. Just because my opinion differs from yours doesn't mean I'm trolling.
There is also [jquip - jQuery-in-parts](http://jquip.ubixar.com/), if size and speed are a goal.
ok...so you are not trolling. very nice. now, be cool. you are either new to HTML or do not have much experience doing web development. *instant_sunshine* gave a really good explanation as to why it is super important to close mark up tags. It is always a much better coding style/practice and that is the sole reason even Adobe Dreamweaver or Microsoft Visual Studio, they all close tags for HTML/HTML5. Liveweave, I think is doing the same. Hopefully this is a helpful explanation for you.
I can understand that you may want to be compatible with XML, but there is a reason HTML and XHTML never converged. They solve different problems. The X in XHTML is for extensible; HTML is the very opposite of that. It has a well defined and limited set of elements. As for parsing, I would have to see benchmarks for that, because both could be considered edge cases depending on which version the browser deems is "correct". Is the *presence* of the / optional, or is the *absence* of the / optional? Because only a limited set of elements can be self-closing in order to validate, the parser would need explicit patterns for them anyway, so the element itself is one giant edge-case and the presence of a / doesn't change that. I do put semi-colons at the end of my JS statements, by the way, but even that is a two way street. Some languages require them, some don't. Does ECMAScript say that *adding* a semicolon is optional, or does it say *omitting* a semicolon is optional? Which one is the edge case? You could even argue that JavaScript's allowance of semicolons is to ease the pain for people like you who find it difficult to conform to its spec when coming from a different language. I'm not trying to save time by not adding the /. I'm just following the spec, and I feel that for your arguments to be valid, you would have to look at the browser implementation.
13+ years experienced web architect here. I just tried a code using self-closed "input" tag and tested in W3C Validator using the HTML5 doctype, and it passes just fine. Try this: [http://liveweave.com/Q2MxHb](http://liveweave.com/Q2MxHb).
I never said they weren't valid. I said LiveWeave shouldn't force them.
If you need to go benchmark, do that, it takes less time than spewing several paragraphs of baseless opinion.
Until you show me your benchmarks, you've also spewed several paragraphs of baseless opinion. I'm done.
I advised you to follow logic, you think following the soft option that's built in for newcomers with cognitive dissonance issues, is performant. I know it isn't, and I've done many tests over a couple of decades to know that's a hard fact. But go ahead stick your head in the sand and keep on cargo culting. Edit: note that my initial comments have nothing to do with browser performance anyway. It's really about how widely parse-able your source is.
I would not call that a twist though :)
JQuery is modular, so you can build it to only include the bits you need.
Very nicely done, right down to the character inertia! It also made me realise I'd never gotten beyond the first few levels of Mario (although I never owned a Nintendo system, so there's that too). 
I created a [LiveWeave](http://liveweave.com/yCt2c8) using your suggested &lt;input/&gt; markup. Chrome's element inspector corrects it and outputs &lt;input&gt; As far as I'm concerned, Chrome's inspector is proof that at least one mainstream browser considers omitting the / as the default markup.
In my experience Firefox has absolutely terrible Canvas performance compared to every major modern browser. Even IE10 has better speed.
I think this is another positive example of a movement towards smaller, single purpose libraries. The core of jQuery is DOM selection/traversal/manipulation/events. There's no good reason to create a tight coupling to AJAX functionality. Creating more modular and specific libraries gives the application developer more choices. This encourages you to substitute alternative libraries which are lighter/heavier in specific areas, which lets you optimise for the needs of the particular application.
It modifies built-in objects. Avoid. See: http://www.nczonline.net/blog/2010/03/02/maintainable-javascript-dont-modify-objects-you-down-own/
If you follow the more stringent spec of maintaining XML well-formed documents, which is completely ok with all HTML5 tools. The well formed markup is compliant with far more tools, and much more readily pliant. The only thing your checks with chrome and Firefox have illustrated is that even extremely high profile tools are not consistent. Behind those are literally thousands of HTML/XML tools and maintaining at least well formed documents ensures that your markup is pliable with as many of these as is reasonable. I have no other point than this.
You do realize that we are talking about "editors" here and what is the considered as the "best practice" in the web world. A closing tag is a perfectly valid HTML5 code and almost every UI developer I have met wants to see that in their mark up. Try using Dreamweaver or Visual Studio or any other IDE with auto-completion, you will probably see the same. If you dislike the closing tags so much, just remove them. right? May be that will give some peace to your soul :)
...but does it need to be repeated in a new blog post from time to time?
uber cool!
My 2p worth. I'm recently working on an application that uses Angular as the front end to a data logging system. The amount of data displayed isn't a problem - most of it is graphs (using http://www.flotcharts.org/, recommended) - but I've already got some pet peeves. I understand the need for dependancy injection for testing, but I find that many controllers end up with a lot if injections - 6, 7, 8 - and it is tedious and messy to have to list them all twice (so the code can be minified). OK, so the "angular" way makes it explicit, but it's still a pain. I've ended up creating a rather trivial "services" service that has each of the dependancies ($http, $timeout, ...., plus my own) as properties, then I can just inject $scope and the service (and reverence stuff like "myservice.$http). Testing is still OK, I just create mock service objects. Next up is inheritance. The idea that things exist in isolation is nice, but its taken to extremes. Eventually you end up with things A and B that you want to keep separate for managability and for testing, but you **know** that they are only used by C. Having to create extra services to allow communication between A and C, and B and C, is another pain, and, frankly, makes the system more convoluted rather than less. So I've created some more infrastructure to allow B and C to register themselves with their parent A, and for A to be able to access (set and get) B and C. I know this is subverting Angular, but tough! I'll almost certainly stick with Angular, partly because it does make manipulating the DOM quite easy (which is why I went for it), but to be honest partly because of the buzz, ie., because getting some Angular skills is likely more employment-worthy than other frameworks which might be better. In a way that's rather sad.
what? no. I mean a node backend; 
I believe the tribalism spawns from the steep learning curve with some of these frameworks. People invest time and energy into getting started with one of them, and they hope/want it to be worth their effort in retrospect. Personally I prefer libs that are dead simple to use, which is why I'm reluctant go far with Angular.
When you end a level there's no sound for the coins...
Hm, I had a buch of folks reporting that [my game](http://webclonk.flgr.me/) runs pretty well for them in Firefox. (Even though I always recommend the usage of Chrome â€” on my machine it's not really playable in FF.) I wonder how if limiting myself to ASM.js feature set (or annotating variables and function parameters with |0 and so on) would help. From your experience, is there specific canvas operations that tend to be much slower in FF than elsewhere?
Why did you go for AMD modules and not CommonJS (with something like a Browserify or component.io build script)?
using chrome...kind of chopping, sometimes it just hangs. otherwise cool!
In order: Thanks! :) Darn, I thought I fixed the vineworld glitches... You can close the tab, that glitch is reproducible. In the console, you can type in: game.setMap(4,2); game.shiftToLocation(5); *Technical expanation:* *~~There's a problem with how some sprites are formatted if they're incorrectly placed in the library, it gets all screwy. What you're seeing is a result of me forgetting to update the Shroom solids and ShroomTrunk scenery after some sprite&amp;library changes. I'll edit in when the glitch is fixed.~~* Fixed! Gamepad support would be pretty neat. It's a pretty big library so I'll put it on my super fancy to-do list, but until at least Chrome &amp; Firefox support it for their regular builds it's a bit iffy. Level sharing would be super awesome! I don't have much time to work on this now, but my general agenda is: * Add in Pipes and a few missing solids/characters/scenery to the editor * Start storing maps in JSON instead of function strings * Add in sharing via email, etc. of text files * Server-side accounts and storage * Facebook integration Pipes as hyperlinks is actually a cool idea, thanks! Right now they can: * Shift to a map ('setMap(X,Y)') * Shift to a random map ('setMapRandom(Type)') * Shift to a location ('shiftToLocation(X)') But adding in * Shift to a Custom ('setMapCustom(some sort of identifier(s))') would be totally awesome. Good idea! 
I get your point. I'm only targeting parsers that understand what an HTML5 DOCTYPE is and has implemented its spec. I just want LiveWeave to stop forcing its opinion on void elements.
Yeah the 60fps setting is definitely one of my least favorite parts of how I did the underlying engine for FSM. If only 2012 hurpadurpdeedurp knew what 2013 hurpadurpdeedurp does now... What I **should** have done from the start is force all movements to be adjusted for the actual FPS rate, rather than assume an even 60fps. It would be awesome for people to be able to play on 120Hz monitors at native refresh rates too... IIRC there should be about three things that need to be changed to allow requestAnimationFrame: * Regular x-velocity and y-velocity (easy, multiply by the fps ratio) * Fancier characters, such as Mario, that change or set their own velocities from movement functions. * Moving solids (probably easily, multiply by the fps ratio)
Haha excellent observation. There's no real benefit to stretching the game out vertically, since the only difference would it taking longer for things to reach the ground (and if you shoot a fireball over a cliff in 1-3, that will take forever...). That being said, http://www.fullscreenmario.com/stable/mario.html - if it runs well on your computer, knock yourself out!
Thanks for pointing that out! I'll edit in when that's fixed. Edit: You're right that the physics are a bit off~~, but I can't reproduce the water glitch. Could you please PM/email me with more details? Thanks!~~~ Oh it was in the random world, fixed!
Exactly, that's what I had in mind. There are a number of excellent libraries out there to do XHR (e.g. Reqwest and rest.js).
The intent of the library was not to be jQuery compatible per se. It can't be fully compatible because of the limited API. But, you have a good point about the behavior that I might need to change.
Yes it is, in fact most games have been doing that in the last many years. Game timing used to be tied to frame rate back on systems that were plugged to a TV, which is why some games ran faster in the US than in Europe as the current frequency coming out of the wall outlet is different (60Hz vs 50Hz). It was easy because (some of?) those systems would trigger an interrupt when the vblank started so you had a built in reliable timer. PCs didn't have an interrupt on vblank so you already had to use a timer to simulate that in the DOS days. Also CRT monitors for PC have supported varying refresh rates for a long time, so unless you locked the resolution down to a unique frequency, you have to come up with a better way. Web based games are so far removed from the hardware that your timer is arbitrary from the get go. I'm just a hobbyist but what I typically do at each loop iteration is extrapolate the position of everything based on the current time and their speed. It's a bit more math than doing +1 at each iteration but it's more reliable. Anyway that's probably more than you wanted to know.
Node and NodeList are part of the DOM, not Node.js. Different "Node". :)
That makes sense, but jQuery can be built to suit your purposes. You could build a version of jQuery that *just* does DOM manipulation and Ajax, if you wish. IMO that custom-built version of jQuery is superior to this, because I haven't seen a better API for just basic Ajax calls (frameworks like Ember, Angular, etc. change the way you do these calls and therefore are invalid in this category).
It mostly works in Firefox, if that helps! :P But yeah, it should be more cross-platform. IE9+ and Safari are pretty close to workable. Edit: That would be a terrific feature, but short of separating all the components of the game into interchangeable modules, a fork I wouldn't have the time to work on. Some day...
Yup, definitely. 
I'm using KineticJS right now, but in the past I've seen the same performance limitations on just normal Canvas. I too am making a game. Since it seems to be a canvas problem, I think it may just be drawing too many objects on the screen.
I tried it after =) it does indeed, just no music.. pretty good man!
Thanks! Try updating your Firefox, they only recently started to support MP3 files. http://stackoverflow.com/questions/4923136/why-doesnt-firefox-support-mp3-file-format-in-audio
A big part of the route taken was upgrading the existing system with small incremental steps. The loader had to be patched to support AMD. The existing system had a similar syntax so it was an easier path to take than rewriting everything to use module.exports as we were able to support both the old and the new style at the same time without breaking the system. Another benefit is it makes cleanup possible with incremental steps instead of one big huge change that disrupts other teams working on other parts of the system.
I'm on firefox 25 beta. That SO response seems to indicate mp3 is windows-only. One option would be to also supply some .ogg files. It's pretty easy to convert them.
I got distracted by SK Telecom vs Najin Sword, I will try it out today and get back you you.
Whoops, sorry for underestimating you haha. That's probably what I'll end up doing. Since IE doesn't play well with .ogg I'll probably end up defining a file extension variable based on the client browser. play("Sound.wav") becomes play("Sound") so in the source is function Play(name,...) { ... nameFull = name + '.' + fileExtensionVariable; .... }
Probably most jQuery plugins won't work indeed. Those that only use the limited API might work.
You should be able to use 'canPlayType' to determine whether the browser will support mp3, and then you can always fallback to .ogg.
Thanks for the link, unfortunately I'm on Windows :(
It does add methods to the prototype of Node and NodeList, but only if they are not already there.
IE is a piece nod shut up 
Good point. I should probably change that into expected behavior (and include cloning nodes).
Yeah, it isn't pretty.. I'll see if I can improve that one.
The "evergreen" support is the whole point of this library. Less code, less bugs, etc. If you really need support for IE8 you could maybe polyfill the gaps.
It's got CHEATS! http://www.fullscreenmario.com/ui.js
What do I do? Arrows pan screen, mouse button hold digs, wasd move, clicks take red/grey/gold nuggets..... But...... what do I do?
Awesome game!
That way is DEATH! Doing physics based calcs on delta time is great! Doing it for a SNES game? I imagine there'd be tons of physics rounding "errors" compared to the original game, and the play-feel would be different. 
dat console More are listed on https://github.com/Diogenesthecynic/FullScreenMario/ bonus points to whoever discovers what window.qcount does
Could you link a better tutorial then? Would like to get pointed to the right direction. Also, if you dont mind, would you list whats wrong with this approach?
cross-post to /r/admincraft maybe?
This is usually referred to as a "mixin" pattern. Just FYI.
Ah, you can also throw those nuggets by first selecting them using tab or shift-tab and mouse clicking. Right now the goal is to cause huge explosions. :) I think it will become vastly more interesting once multiplayer is implemented (which will be vastly complicated).
[Looks like you can use regular expressions](https://github.com/aaronblohowiak/routes.js#path-formats).
Some facts need to be repeated to introduce a new generation of learners to common knowledge.
&gt;drawimage implying I don't define my own sprites per pixel
oh nice, I stand corrected, I was just glancing at the examples.
Worst most inaccurate list ever. 
That's awesome! How long did it take you to write?
Maybe put the description of why you would use this in the first part of the readme instead of at the bottom. I read most of if but had to dig far to find out why you might use this. Then I was mystified about how that would work. The readme doesn't really mention how to define and use modules.
I think the key here is "strongly prefer to" rather than "blindly replace with". There are some instances (not so much in JavaScript, but in other C-family languages) in which inheritance is still the appropriate mechanism.
I can see there are advantages with composition, but there are advantages with inheritance too: Ease of porting code between JavaScript and other languages. Ease of generating JavaScript code alongside code in other languages using similar methodology. Shallow learning curve for a developer with experience in other languages in order to write OOJS. ------------------------------------------ I agree that there is the difference between 'has a' and 'is a', and sometimes that could make composition more appropriate. However, there are also times when 'is a' is the best way of describing a relationship between classes and it fits very neatly into the inheritance methodology. I use class inheritance in the framework / library I am writing, the inheritance system is in this module: https://github.com/metabench/jsgui-lang-essentials
Maybe a better list of MVC Frameworks with example code and working application. http://todomvc.com/
Nice. But, my question is; are we now just testing the stub/production interface? You are not actually testing the production code, or did I miss something?
I feel stupid
This looks interesting as it addresses some recent concerns I ran into trying to switch from Requirejs to Browserify. RequireJS has worked for me, with some drawbacks: - (the biggest disappoint) I can't use client and server javascript interchangeably because some uses CommonJS and some uses AMD - I can't reference NPM modules directly during development (uncompiled). I end up duplicating the NPM modules being referenced. - I maintain 3 requireJS config files to keep things working (production/compiled, localhost, and another for the karma/testacular test runner). - compiling jade and LESS seems harder than it should have been I spent a day or so seeing how things would work with Browserify. It seemed to address all the problems I had with RequireJS, except: - When running tests from karma, I didn't have stack traces to work with (this was a dealbreaker) - I haven't had the time to figure out how to run compilation on file change for localhost testing It looks like Needy will address at least the first two problems I had with RequireJS. So maybe I could use Needy during development (localhost testing and when running karma test runner) but then use Browserify to compile a bundle for production. Does that sound viable? One question I have is how Needy as able to load dependencies from the node_modules folder? (for NPM support) Suppose I use Needy to include a javascript that will call require("underscore"), how is Needy able to load the file from node_modules/underscore/underscore.js? My application doesn't necessary expose that resource via HTTP to the browser.
You're testing that a call was made, not if it worked. You would still need integration testing.
You're still testing the production code of the [System Under Test](http://xunitpatterns.com/SUT.html); we are just stubbing out all the external dependencies (eg: XHR, Timers, and other dependencies (objects) that the System Under Test calls). However this does bring about an interesting question of what happens if the interface of those dependencies changes (eg we change the parameters of a method) - in statically typed language the compiler would usually catch this before the test cases execute; however in dynamic languages everything will continue trucking as if nothing happened - your stubbed out tests will be green, but the code will fail at runtime in a production environment.
&gt; I haven't had the time to figure out how to run compilation on file change for localhost testing For that, you can run the [Browserify Grunt plugin](https://github.com/jmreidy/grunt-browserify) in conjunction with a [watch task](https://github.com/gruntjs/grunt-contrib-watch).
&gt;Of course there are more complex methods of achieving inheritance in javascript, but a lot of those require the use of an api that abstracts from bare bones javascript. Bare bones is good. I wouldn't call using jQuery "bare bones." Still a fine quick and dirty trick but should not replace actual prototypical inheritance.
OK, included some more optimizations that cache color pixels and simplify the update-loop in general. Lowered default settings of the pen for slower PCs. Framerate went up to about 30FPS on my 2013 Retina MBP...
Ah interesting. Yea I guess you are right, though normally I have seen the mixin pattern used for copying objects created without using new, or by mixing in additional properties after an object is returned from a constructor. But, all-in-all I need to learn more about the mixin pattern. Thanks for the FYI.
Yes thats true, this looks new to me, the list I added really looks old one. :)
Definitely don't rely on it, but if you have a variable that is shares a name with an element, you might want to change something.
And many of us love it. Many of us think it looks better, and is more readable. If you're writing for CoffeeScript users, you don't have to care about the opinions of CoffeeScript haters. That's right - we don't care that you hate CoffeeScript nearly as much as you care that we like it.
The short answer to your ending question is that you have to expose the full directory tree for your app, including the node_modules folders, over http. The slightly longer answer is that you can pass a "get" option to Needy and have it fetch them any way you want. And the even longer answer is that I'm working on two supporting projects, "needy-nodecore" and "needy-webapp" that will provide browserify's node core emulation, and a server-side module resolution service. check back in a week and I may have one or both going depending on work.
I think my favorite is the *x86 Emulator* written in JavaScript. You can essentially run Linux in browser.
This does sound pretty good. I think I'd prefer to keep using Browserify for production, but then have Needy for localhost testing. One reason not to run Needy in production is I do not want to expose my full source tree via HTTP. Do you use the Karma test runner? (formerly Testacular) It runs an HTTP server to serve your clientside files. I just wanted to consider if it would run well with Needy. Since Karma can be configured to expose whatever files you want in your source tree, and it would be easy to just make everything accessible via HTTP, it seems like Needy would be a good option for testing AMD code with Karma. One would have to configure Karma to run some code to tell Needy how to map paths to Karma's HTTP endpoint. Relatively, thats less configuration than using karma with requireJS code.
I'm not an iPhone user. I know accessing the webcam in browser works with Android. Does it in iOS? Do any of you have experience with using the iPhone webcam in-browser? Just curious. Thanks!
Could you then open another browser and navigate to the same emulator and continue the chain?
Ya, even I will probably browserify most of my sites before making them live :). I really did just want a better alternative for development when I started Needy and it evolved from there. A friend and I are actually using it to develop a game based on node-webkit. So I wanted a way to emulate having node in chrome, without having to compile. Truthfully though, I'm a little confused about your concern for exposing the source tree for development. Production I can kind of see, though truthfully a closed source web app seems sort of like a non-sequitur to me. You're going to have to send your source to a browser eventually I would think. Maybe obfuscated/minified for production? If you've got got supporting files in your source that should never be served, then ya you'd need some way to block them from being sent by the server. I use node-static actually when I need to setup a simple static only server, and it's flexible enough to let you filter out things that you shouldn't be able to see remotely. But for a dev server that should only be listening on localhost, I reallly never bother with that and instead just start a static server with a webroot pointing at the source tree root, and start hacking. I've never used Karma. It should be entirely possible for needy to get source from it though. I just don't know it's API. There are two ways Needy could be configured for it to get them though: 1) as mentioned before, write a custom get function. The documentation is pretty sparse for that right now, but basically, `new Needy({ get: function(path) {...} }).init("/main");`. The "path" value that the function receives should be an absolute client side path. so if your main script is http://foo.com/main.js, which calls `require("underscore");`, you'd see calls to get for path values: "/node_modules/underscore", "/node_modules/underscore.js", "/node_modules/underscore.json", "/node_modules/underscore.node", "/node_modules/underscore/package.json", etc. The get method should return the source if it can, or false otherwise, and it should do this synchronously which XMLHttpRequest can do. 2) Overload the Needy.Resolver class, which is trickier, but then you could have it only request "underscore" and do the resolution from that on the server, using an instance of Needy on the server even. That's what I am planning on doing in the needy-webapp project.
It would be slow as sin, but I would imagine so :-). Like.... really, really slow. It took about 20 seconds to compile "hello world" with the minimal linux kernel they have running. I can't imagine compiling and running even a text-based browser like Lynx.
I couldn't open the Dart one.. that's the only one I wanted to see :(
It does not work in iOS at the moment, even in iOS7 access does not seem to be allowed:(
This is super awesome and worked like a charm in chrom/xbox controller/win7. Very cool. More info here: http://www.html5rocks.com/en/tutorials/doodles/gamepad/
[needy-nodecore](https://npmjs.org/package/needy-nodecore) In your main module (or anywhere really, but it makes sense in the main module): require('needy-nodecore'); var path = require('path'); 
[This?](https://gist.github.com/munificent/1385015/revisions)
I am using gamepad API in [my game](http://qbqbqb.rezoner.net/play/) - it is awesome - really adds console feeling to the browser
Yes, that! Github kept telling me it didn't exist. Thanks! 
 You could use the Backbone.extend method which itself is based on goog.inherits. If you do use the Backbone.extend then you still have the instanceof working: http://backbonejs.org/docs/backbone.html#section-189
Unless you can change it without changing the minified size, don't. I'd rather use a lean library over a library made more verbose so some guy on a message board could read it. 
This could maybe be clearer with parenthesis/linebreaks, but nested ternarys aren't actually very complex to read, you can step through it sequentially and it reads fairly easily. Also, it would turn out much more verbose in if/else. example equivalent if/else: if(context) { if(typeof context === 'string') { context = document.querySelector(context); } else if(context.length) { context = context[0]; } else { context = context; } } else { context = document; } 
Why do people still think of jQuery as "bloat"? It's only 32kb sent to the browser. That's the equivalent of a small to medium sized image.
See http://www.reddit.com/r/javascript/comments/1n9e6g/modular_javascript/cch2nrh -- I think because of the migration path, switching to require.js directly wasn't an option. Long term, I expect the modified loader (that isn't named intentionally) will get replaced by a loader like require.js or something similar.
Not my library, written by a friend of mine, but really enjoy using it. Makes getting params out of the url super easy!
In the when to use directives services and Controllers, he manually emits a change event to root scope that the books array has changed. Isn't this not only horrible practice but completely unnecessary as angular will handle the dirty checking for one, and two, the controller holds a reference to the actual service array, so it's the same array? On my phone. Sorry for shitty sentences. 
Hey, I recognize your name. Great work with canvasquery, I've used it a ton!
"Right" would have been if I could pass in a url to be parsed instead of just assuming I want the page state only. Probably would have made the thing a lot easier to test too, the specs are resorting to using pushState to change the url tested against.
Where is the JS demo?
And time will prove your folly. In 10 years from now JavaScript will still be the standard and coffeescript will have a minuscule niche following as it does now. 
And that... won't really matter anyway. All my generated javascript is pretty printed and not far from what I would write... If I needed to switch back to pure JS it would hardly take any time. I really don't see what your problem is. How does me using CoffeeScript hurt you? The intention of CoffeeScript isn't to replace JavaScript, just to provide an alternative syntax. Go look up the word "alternative". We're not trying to get rid of JS. Also, a language's worth isn't defined by its user base. If it were, no new languages would ever be made. Though given your description of CoffeeScript as a "made up language" (what does that even mean?) I'm guessing this is flying over your head. But anyway, go look at the [most depended upon NPM packages](https://npmjs.org/). Look at [GitHub's JavaScript style guide](https://github.com/styleguide/javascript). See something?
cool, will have to check this out. For now I've been using this [snippet of code I found on stackoverflow](http://stackoverflow.com/questions/979975/how-to-get-the-value-from-url-parameter) that's been doing well for me. It's not perfect but for what I needed it for it was working fine
You probably wanted to link one level up https://github.com/marijnh/Eloquent-JavaScript
You can pass in a URL, but it does assume you want the current one if you don't pass one in. I think I'm ok with that. 
IE support? I've had to work around styling IE file fields and the usual trick is to just make them CSS hidden and positioned over a more styled element below them (kind of like click jacking). It looks like you're just applying CSS styles to existing fields which works in a lot of browsers... but IE 8 &amp; 9 (and maybe even 10?) don't like it much from what I recall.
Only catching 4 chapters here. I've never read the original eloquent Javascript. How many chapters was it? Is this part of the book or the whole thing?
http://jobot.maxthayer.org/
arg[]=param1&amp;arg[]=param2 is a PHP thing, I believe. Other languages accept arg=param1&amp;arg=param2 and would make arg == ['param1', 'param2']. Doesn't seem like this library has support for that.
I added an Overview section at the top. As far as defining modules... that's really not part of the scope of the readme. The CommonJS spec and Node's documentation both cover that, and the readme assumes you're familiar with one or both.
I'm on a Windows based system. But getting a PDF should be pretty easy right?
Rails also uses the array syntax when constructing `GET` parameters.
IT'S A STORM...*OF WEB*
with EJS template editor
I have a weird relationship with React. JSX is awful, and there's no use pretending it isn't a core feature even if it's technically 'optional.' But... on the current field it improves Backbone by filling in its under-opinionated approach to rendering. If you're a Backbone dev I would _seriously_ recommend looking into React, even if only to compare it with what you're currently doing. Everything about re-rendering is basically spot-on. Maybe it's overzealous. Maybe it's unrealistic when we're still tied to the old DOM. If I were to try to break React, I'd do it in two places--first, my go-to recursive challenge of a reddit front-end, but with active changes designed to smash the virtual DOM somehow; second, trying to find something about the (real) DOM that breaks an assumption of React. (Like, the new shadow DOM features making their way into browsers.) Slide 57 is like "Hey, we did Ember's run loop, but we did it _right_ and without 30k+ lines of code." And finally, React is _obviously_ a better choice than Angular, even with JSX. If you're going to put code in your html, it only makes sense to put html in your javascript. 
[14: link here](http://eloquentjavascript.net/contents.html)
It has nothing to do with git, there is no pdf in the repo.
&gt; JSX is awful, and there's no use pretending it isn't a core feature even if it's technically 'optional.' I'm holding off judgement until I try it, but it's certainly off-putting. &gt; If you're a Backbone dev I would seriously recommend looking into React, even if only to compare it with what you're currently doing. This is exactly my interest in React. I really want to dig into their code and see how their "virtual DOM" implementation works. Also could be an interesting way of getting javascript apps running on the server. This recent tweet by Spike Brehm suggests they might be moving that way with Rendr. https://twitter.com/spikebrehm/statuses/384810586338377728
It absolutely sucks on my system. I get 100% utilization and the app stops responding as soon as I touch a source file. I tried all the usual suspects like giving it a shit load of xms memory. Very disappointed.
Did you have similar problems with WebStorm 6? I haven't upgraded yet... WebStorm 6 is a bit of a hog on my system.
I've done it less so, recently, but I used to regularly repeat myself on how data-binding _tends to_ be a language modification to HTML that is foolhardy and short-sighted. &gt;I've had very little JavaScript in my Angular templates. That's because they are _Angular_ templates, which is to say they are their own separate animal of code. No Angular developer I've talked to has ever had a sensible reason for why [this recursive view bottoms out](http://koglerjs.com/example/angular/#/r/AskReddit/comments/17fjyb) at 10 (check console). It is an _arbitrary constant of the framework_ that you can't run $digest 10 times without throwing an error--because **dirty checking imposes a cost in uncertainty** that eventually catches up with you. But there's no reason that a recursive view isn't completely legitimate. Ember can do this without breaking. 
Have you read [this series](http://usepropeller.com/blog/posts/from-backbone-to-react/)? I recommend it. &gt;Also could be an interesting way of getting javascript apps running on the server. That's the beauty of the principle of mirroring the old page-refresh and being able to render your whole app, instantly, from one command. Doing a full-page render with Backbone is either way over-zealous or requires managing too much of the thought that goes into trying to make data-binding a full-scale framework. 
Can someone explain the purpose of this to me?
You should add a package.json/component.json/bower.json so you can easily use it with those build systems.
Anyone else having issues with the terminal? I pop it open, it says "Initializing..." then nothing. (Windows 7)
Github's style guide and NPM packages are NOT an indicator of anything. You're a fool if you think so. &gt;Though given your description of CoffeeScript as a "made up language" (what does that even mean?) http://www.reddit.com/r/javascript/comments/1n66ww/module_pattern_in_javascript_and_coffeescript/ccg71im Go read my other reply. &gt;I'm guessing this is flying over your head. Your ignorance is not flying over my head. If you don't believe me, then read this... http://www.igi-global.com/article/impact-programming-language-fragmentation-developer/44971 &gt;"However, the overhead of maintaining efficiency in more than one language may also outweigh those benefits. Further, development directors and programming team managers must make resource allocation, staff training, and technology acquisition decisions on a daily basis. Understanding the impact of language fragmentation on developer performance would enable software companies to make better-informed decisions regarding which programming languages to incorporate into a project, as well as regarding the division of developers and testers across those languages." There are many practical concerns about adopting coffeescript for production code. If you can't think of any then you haven't thought at all about it. 
This is a good place to keep track of development: http://blog.jetbrains.com/phpstorm/ The 7 EAP has a lot of these features already.
It's an indicator that it doesn't have a "minuscule niche following". Can you name a language that wasn't made up? He says "new language ***we*** made up" in the specific context of the people who invented CoffeeScript. Calling it a "made up language" in any other context is no more meaningful than calling JavaScript a "made up language". Also, that interview took place nearly three years ago. Adoption has increased since then. If a JS developer hasn't heard about CoffeeScript by now, they haven't been paying attention. Most new projects aren't going to split their code between JS and CS. They're going to pick one or the other, so I don't think that paper is especially relevant here. Either way, it doesn't answer the question of how *others* using CS hurts *you*. There are also practical benefits of adopting CS for production code. Assuming that you know what's best for every project is arrogant nonsense. Also, downvoting all my responses because you disagree is just silly and pointless.
Sorry, I don't mean to be a downer, and JetBrains does some great work, but I just don't see a point in all that power for frontend development. It confuses me more than helps. I'll stick to trusty, ol' Sublime Text.
Unfortunately the debugger seems to be broken for me. It's on the issue list at least tho: http://youtrack.jetbrains.com/issue/WEB-9343 But till it's fixed, I'll have to stick to 6 for now. Other than that, it looks like it could be pretty nice.
&gt; foo?foo.bar?foo.bar.x:undefined:undefined Surely someone with 16 years of javascript experience realizes why that code example is not the same thing? Ternary checks for truthiness, not existence. It's also a lot less immediately obvious what's going on, and you need to add another undefined for each step.
I have two examples. I definitely create directives in [this one](http://jsfiddle.net/qKG5g/), which I intended to be as close to a translation from the React sample as I could muster. It seems like you're looking at my other example, which in hindsight I probably shouldn't have included. Anyways, I do see the merits of this approach. I'm just trying to figure out why I should leave the realm of proven Angular/Ember approaches to custom dev for this. Anyone else see major similarities to ExtJS?
Here's the compiled HTML version: http://a5e0a8c37a0b13c7e2b8-ec30851c72adad794fe2f90d061aa306.r94.cf1.rackcdn.com/eloquent_js_2_preview.zip Enjoy
&gt; ng-repeat assumes you're going to render one element per item in the array, right? Nope. Angular has `ng-repeat-start` and `ng-repeat-end`. &gt; don't have a great notion of lifecycle nor composition Patently untrue. Directives have their own scope which handles lifecycle issues with GC. &gt; I've heard that there are issues with their encapsulation FUD. :)
&gt; requires writing the composition in a string that lives in your JS. Not true. You can use the `&lt;script&gt;` tag-style templates, or asynchronously load them from html files on your server.
FUD is an opportunity to deal with criticism. 
By letting them have the burden of proof, and reacting as if they actually have a point. I haven't done any differently. My burden of proof is [here](http://koglerjs.com/example/morebackbone/). It's clunky and odd-looking, but until Angular can precisely hit all 9 instances without overly duplicating Model _or_ View code, I'm uninterested. 
Burden of Proof: The person who makes the claim is burdened with the task of proving their claim, they should not force others to disprove them without first having proven themselves. ^^Created ^^at ^^/r/RequestABot ^^If ^^you ^^dont ^^like ^^me, ^^simply ^^reply ^^leave ^^me ^^alone ^^fallacybot ^^, ^^youll ^^never ^^see ^^me ^^again
Pretty sure I saw "early October" somewhere on their site but I can't recall where, exactly.
The Darcula theme changed enough to really bug me. I liked the old darcula theme better. The colors in the new theme are dull and dim.
you are crazy, stop posting this to this many subreddits. And worst of all, Javascript != Java. This shows that you don't have a clue what you are doing at all, so its even more important that you give way more details on this problem than you did. 
According to their page (http://www.jetbrains.com/phpstorm/nextversion/index.html) it's arriving in the next two months: &gt; PhpStorm 7 will be released in October/November 2013. In my opinion: the sooner the better.
it also contains debugging for node.js so it does server side too.
btford ng-repeat-start and ng-repeat-end don't solve that use case; please see the example. You'll need a custom directive. Lifecycle also includes batching reads and writes to the DOM, which Angular's linking functions can't express. Also, composability is hugely important. FUD? https://github.com/angular/angular.js/issues/1924
They're still pulled out of the DOM into JS strings, which makes them hard to statically analyze.
Looks great for existing projects, but a word of warning if you're implementing this in a new application: query strings invalidate the html5 appcache. If you're writing a web application with JS navigation you're only one step away from getting offline compatibility essentially for free, use slash-deliminated URLs instead of query strings if you think you might want to go offline.
[Works as I mentioned](http://jsfiddle.net/aR7zm/) And which spec are you talking about? I don't think it's the [html5](http://www.w3.org/TR/html5/forms.html#configuring-a-form-to-communicate-with-a-server) or any other w3c spec.
&gt; But we are talking about programming, and in the context of programming the first example gives much more structure and area of the function is clearly shown with a curly-bracket. There is nothing to guess at here. The mind does not need to do any extra steps to understand the meaning, because it is clearly shown. That is not the case with the second example. Why do you indent your code if you have braces to tell you where blocks start and end? If the braces make it so obvious, indenting isn't actually necessary, right? Wrong, you do indent because braces alone don't do *nearly* the job that indenting does at *guiding* your eyes along nested blocks. Whitespace makes it extremely obvious where the block begins and ends, and what code belongs to what block. &gt; "readable" does not always mean less text to look at. If that were the case then ppl wdnt h8 txt msgs. See what I did there? Less typing does not mean it is easy to understand. This is irrelevant. Of course there's a point where something can be shortened to an unreadable level. Well written coffeescript doesn't do that. All coffeescript does is remove parts of your code that are ***unrelated*** to the actual business logic contained in your code. The main reason it shortens your code is getting rid of countless lines that have ***nothing*** but }); - and these are *always* implied with a decrease in indent, even in *most* javascript. The second biggest reason is list comprehensions, which are conceptually simpler and less meta than looping over indices. The third biggest reason is shortening function(args) {} to (args) -&gt;. Whenever you see -&gt;, it means function. It's not hard to read. The word function, in my opinion, takes focus away from what you're doing and towards an unnecessary statement of the obvious - yes, we get it JavaScript, you have functions. A lot of functions. So many functions that the word "function" appears more than ***any*** of the words in the project's ubiquitous language. How often do you say "television"? "Cellular telephone"? "Personal computer"? "Automobile"? "Mathematics"? Language is full of shortened terms that retain the meaning of the original phrase, while reducing syllable count. Can you imagine the English language if we had no abbreviations, acronyms, or contractions? &gt; The second example looks open-ended. This is a very simple function and it no doubt is easier to understand than a larger function. If the function were, say, 50 lines then it would not be so easy to understand. The start and the end of the function would not be so easy to see. Honestly, I'm not sure I'd let a &gt;50 line function get into my code. I'd be thinking about refactoring long before it got to that point. If I can't summarize everything that a function does in one sentence, I don't want it in my team's code. If I can't see the entire function without scrolling, I don't want it in my team's code. It better be that long because of newline-separated array or object literals, or (maybe) comments. Otherwise, the function is probably trying to do *too damn much*. Part of good readability is that functions should do one thing, and do it well. If you have several &gt;50 line functions in your code, it's probably smelly and I wouldn't want to try and read it anyway. 
JSX is absolutely optional. I've built several apps with and without JSX and I don't feel incredibly strongly about either form, but the JSX helps you nest very large structures readably. I'd suggest keeping an open mind about it - it doesn't change the semantics of the language fundamentally, and it's just sugar for JS that you already know. Syntax is not the most important feature of a language so it probably doesn't make sense to consider it when evaluating technology in this case (especially since it truly is optional). But if you're interested in rendering on the server, try this: https://github.com/facebook/react-page - It renders your React page seamlessly on the server. Should be as easy as npm install (windows support coming soon).
That's an engineering trade off really. You could create that structure without 10 levels of recursion in any number of different ways. 
And PyCharm 3.0
To get something from url when changed. * Open translate.google.com * try to translate something * keep your eyes on url
There's a preview up at http://eloquentjavascript.net/2nd_edition/preview now (which is automatically updated as new patches are pushed). More chapters will appear over the coming months.
@floydophone : He is not using innerHTML to compose the directives. He is using it to pull out the templates ( and this is probably because he is using it in jsfiddle! ). Alternately you can specify a template URL - which points to a separate html file - Its much cleaner that way and I think that is how most people use it in production. I really did not understand what you meant when you said it cant be statically analyzed! Care to elaborate on that? Having said this, I really think that react is a neat solution and an interesting one at that. Except for the fact that react embraced imperative style as opposed to declarative ( which is what I think it should have done for its components! ) I have no qualms about it and it surely is in my radar for things to watch out for. But, I really dont want to hear any react advocates talk about the "magic" in Angular because there is a already a lot of magic going on in React too. But I really dont care about the magic as long as its some cool tech.
Nice game, used my logitech pad without a problem.
I have seen you show this off quite a few times. I want to take you up on this challenge and implement that with Angular. In that implementation, you have used 3 Backbone Model Classes ( apiChangeM, ClockM, TimerM ) and 4 instances. You have created 4 Backbone View classes ( digitalV,secondsV,winkyV,clocksV) with 1 more object (viewLib) which is like a base class. You have an additional util hanging off the jquery object. Now, what do you mean by "hitting all 9 instances" ? I would really appreciate if you could describe more precisely what the challenge is. 
Most routing libraries leverage the browsers hashchange event - https://developer.mozilla.org/en-US/docs/Web/Reference/Events/hashchange That should give you some idea of what this can be used for... 
Then you have yet to be enlightened.
Ignoring how atrocious of an idea this is, why the hell is your script tag outside of the body tag? 
Thank you for a comment. Yes, it is a bug and now we are fixing it.
The viewLib is a mixin. apiChangeM is more an abstract representation of any API dribbling change into the mix. clocksV is a parent container. So there are really 3 models and 3 views. The challenge is to create every single combination of them in one breath; that is, with Backbone I simply create 1 instance of each model, then create 1 instance of each view per model. In other words, pay attention to what I do in each $(document).ready(...) More precisely than that, though, I think the hard part will be getting winkyV right. winkyV maintains its own state, separate from the models. If you can do _that_, you've got me stumped. To put it another way, try to have a separate file for winkyV. Don't let it handle any logic for ticking within it--only for winking.
Hooray, I can set a limit to how deep I can recurse. The point is that there's a limit at _all_. 
This is an excellently written tutorial. d3 is a lot less scary now. Thank you.
Thanks a lot for your great feedback!
As awesome as this is, what's the likelihood the dmca is going to shut down my torrent-streaming web app?
[edit] In the interest of not being a total douche, and letting the OP have his fun, I've removed my answer. But I will say: - Decrypt this with the answer to verify the answer: "33173ED9CC619FFD1D2013F46633BF8D6336CB96686CE454" - I thought this was a Flash site - I probably still wouldn't hire you because you sound quite arrogant
If a certain amount of jobs require knowing coffeescript because some asshat stared using it for production code, then that does affect me and my ability to find work. Most front-end programmers don't know coffeescript and they rightly should not need to know it. I refuse to code in coffeescript. It is counterproductive. I've already had to refuse work outright because of coffeescript. So, it does affect me and every other programmer who has spent years mastering javascript. We really don't need coffeescript to get work done, nobody needs it except for people with a fetish for syntaxes with significant whitespace. Adopting CS is far from a best practice, and I would rather not work at any shop that uses it. 
unlikely because it will look like webrtc traffic
This needs a plugin to be installed, so seems no better than installing a desktop client to me. I'd rather see more web browsers implement BitTorrent like Opera and Konqueror do.
It's going fucking nuts on my TypeScript
You also live in a cave because doors are so confusing?
Wishing I'd read this 3 weeks ago before I started using D3 for interactive graphs...
What a classy dude.
For what it's worth, 1. The install process wasn't able to import my old settings, which was annoying and 2. I was able to crash it in 20 minutes. Maybe hold off on the update until 7.0.1. When did dot zero releases become beta?
Leanpub has their own proprietary publishing process, I don't compile it myself. But you can read the whole thing online, print it out, buy it and share the ebook with your friends, or cook up your own publishing system.
Would anyone recommend this book? What is the expertise level targeted?
In the section on decorators, the author gives the example of not(fn), which returns a new function which reverses the truth table of fn. The author describes it as 'ridiculous' and I've actually found it far from. When I'm working with a live data set in the console, I use not(fn) as a go to tool to reverse the truth of my [].filter() predicates. If I want to mark all employees who have isSuspended I can [emp].filter(isSuspended).forEach(mark), and then I can do something else with the rest very easily, by using the command line recall and [emp].filter(not(isSuspended)).forEach(somethingElse) Hence, I can remain very flexible (my upstream datasource is typically dirty, so it's hard to come up with a one size fits all conversion script) and just have a small set of composable functions and get whatever I need to get done with minimal fuss.
Lol, that's probably the most ridiculous thing I've ever read. All it amounts to is: &gt; I'm a stubborn, arrogant programmer stuck in my ways and afraid of change, who misuses the word "fetish" for rhetoric, who thinks he knows what's best for the projects offering me jobs to the point where I won't accept them, and that's ***their*** fault. ~~Maybe~~ ***you*** are the problem? You sound like you would be awful to work with, anyway.
agreed. sounds a bit pompous. is an 'expert', yet the site is terrible. can't even go back to the main index without hitting refresh.
That is the longest post I have ever seen about a book that doesn't actually tell us one thing about what the book contains.
The homepage says 'Turbulant' instead of 'Turbulent'.
In order to pass data from one directive to another you have to encode the expressions as strings at runtime (usually using the template parameter in a directive). That means you can't see the relationships between directives without actually running the program, which means linters, type checkers and minifiers can't assist you. Glad to hear that you think React is neat :) However I'm not sure what you mean by imperative style as your render() method declaratively specifies what your UI should look like at any point in time; can you explain what you mean by that? Maybe we didn't communicate that correctly? The magic-ness of Angular is where I fundamentally disagree with you. Angular's built on the idea of extending HTML to support two-way data binding. I don't think that this is a strong theoretical foundation. Evidence for this is the amount of neologisms that Angular has created to support real world apps (scopes, isolate scopes, directives, compile functions, linking functions, ngCloak, new DI framework, new module system, transclusion to name a few). Because they need to reinvent so many things the language isn't powerful enough to express concepts elegantly expressed in a mature programming language. Some examples would be koglerjs's example of recursion being very difficult, repeat expressions which look sort of like JavaScript but actually aren't, dependency injection breaking with minification (has this been fixed yet? even if it has, it's a symptom of poor design IMO), and isolate scopes being buggy. I've read the Angular source code. The code quality is good and I have a lot of respect for the engineers working on it. I just think it made some really poor design decisions from the beginning that they can't really get away from.
What about just using nvd3js? http://nvd3.org/
I interpreted the author as meaning 'ridiculously trivial' as opposed to 'ridiculous idea'.
I've recently finished my first pass through it. There are sections I need to go back and read more thoroughly. I would certainly recommend it. It starts out very basic, laying the groundwork for the more advanced functional concepts that you find later in the book. Most of the concepts and patterned introduced are built upon. It's fairly easy to follow along if you have experience playing around with Haskell or a lisp because the concepts are familiar, but will require a slower, more methodical read if you're new to a functional style. But if you're new to a functional approach you'll get much more value out of the new concepts. The style is a bit sophisticated and hard to parse for new-comers and if you were to adopt its style whole-heartedly on a team project, you're teammates are likely to wish you bodily harm. That doesn't mean it's not good fun or useful to know though. In the end it's a different approach to JavaScript than you'll find in most other places and shines a light on some of the more elegant parts of JavaScript the language.
Did you miss the part three paragraphs in? It read: &gt; Why are you still here? Why arenâ€™t you reading the book online, for free? If you kept reading, I cannot be responsible for the consequences. UPDATE: I was being unfair in my earlier reply. The first couple of paragraphs announce that the book is free. The very first mention of its name is a link to the landing page for the book that does a very ggod job of describing the book. The rest is really an a personal anecdote of why I chose to make it free. The text really could have done a better job of: 1. Telling you that what followed was a personal anecdote and; 2. Being clear that if you aren't familiar with the book, to go to the landing page to read more. Upon consideration, I am giving you an upvote. You make a good point.
How do you do that with v5? I've got 16GB of ram and the projects I'm working always max the pool and the GC chugs on cpu cycles trying to be helpful.
Fascinating. I'll investigate some more the next time Bitlet goes down.
It is the best book about Javascript I've ever read. Expertise-wise I'd say you should be comfortable with the syntax of Javascript and be proficient in programming in general. Listen to [this](http://javascriptjabber.com/070-jsj-book-club-javascript-allonge-with-reginald-braithwaite/) on your commute home to get a fuller sense of the book without diving straight in.
So I'm supposed to pay if I wanna read it on kindle? Would author mind if I make it epub/mobi? Did anyone do it so far?
Thank you, I really appreciate your kind words.
Ah :D That'd do it. Of course, I feel the same way about the "all", "some", and "any" async functions; Feynman remarked on that in Surely You're Joking Mr. Feynman: "it's trivial! it's trivial!" Sure, as soon as you know the pattern, it's blindingly obvious!
The instructions are pretty clear: First: git clone https://github.com/marijnh/Eloquent-JavaScript.git then run the following commands within that cloned directory npm install apt-get install asciidoc make html apt-get install dblatex make tex
You are arrogant if you think choosing coffeescript benefits anyone but your short-sighted self. There is no chance we would work together because your stack is crap.
I have no objection to your reproducing it in any format you like, that is explicitly allowed by the Sharealike license. I will probably make direct downloads the other formats pay-what-you-like in the fullness of time. But in the mean time, knock yourself out. If you post a link to your mobi, I will upvote it.
Keeping it in context, you cannot throw a stone at a JS convention without hitting a very experienced JS programmer who will tell you that most of the functional "tricks" in the books are ridiculous and not appropriate for production code bases. To that person, every page of the book is swollen with ridiculous notions :-)
Here is the version that exactly replicates everything you have done with Backbone. http://www.nebithi.com/code/challenge/index.html . Feel free to browse the source and you will notice that I have kept the structure exactly similiar to what you have done. Hopefully you are stumped :).
How do you build a big piece of UI without passing data between directives? Just one big directive? How is that any better than jQuery + data binding? Angular introduced a brand new module system (we had AMD/commonjs) and brand new DI framework. Also linking functions are certainly a new concept. Your point about Angular not being a language is the fundamental problem. They are trying to do the same things as a language (see repeat expressions and scopes) but are doing a bad job of it since they didn't actually build a full language. This is illustrated by lack of recursion, limitations of isolate scopes, and inflexibility of ng-repeat.
Probably we are not understanding each other. Care to elaborate with an example of what you mean by passing data between directives? Is it wrong to have a module system in Angular? Angular wants to have everything within it - so that you probably dont have to include anything else - perhaps thats why they put in a module system there. I really dont know the reason behind it. But , people introducing new things is wrong? If we follow that line of argument, Reactive should not have been created - right? Actually, linking function is not new either. If you see handlebars etc - its compile function actually returns a function. That function is called the linking function - because its the function that links the compiled template to the data. I think you are fundamentally confused about what angular is. Angular is - at its core a mechanism to extend HTML. All the ng things you have seen are examples of such extensions. Nothing is preventing you from writing your own ng-repeat - or any such repeating or control flow directives. In fact, you can even override ng-repeat or any other ng-* directive. Can one override a for loop in a language? lack of recursion? You can do recursion - and thats one of the powerful things in angular. In pretty much most languages, you cant do recursion to an infinite depth ( some get around it using tail call optimization etc.. but thats another topic ) because you run out of stack frames. Angular happens to run out of it at 10 - which I have already point out is a number that can be set at the beginning of an applications start. You can set it to 10000 if you wish (dont know the performance implications! ). Basically, you can do recursion in Angular - which other templating language can do that? Can you do recursion in Reactive? 
It's React (Reactive and ractive are different projects). Let's say that you want to write a directive that uses ng-repeat. You have to pass data from your directive scope to ng-repeat's scope, right? There's no way to know at compile time that you're doing that since you do composition in Angular by passing strings around (the template var). No matter how you get it in (template, constant string, whatever) it's still not statically analyzable because it can be an arbitrary expression. I'm really not confused about what Angular is, I just challenge the idea that extending HTML to support programming language-like primitives is a good idea. I see very little, if any advantages over just making JavaScript better at interfacing with the DOM and I see many, many disadvantages in expressivity, usability and performance. For example, the reason I think Angular limits recursion to 10 (Python, which is a far inferior runtime to V8/spidermonkey/jsc, limits it to 1000) is because they rebuilt the idea of stack frames in a slower and harder to reason about way. I know you *can* write a directive to do anything, but *why* are directives a good idea?
How is this different than Backbone's router?
Thanks! Will give it a go.
Thanks!
Just read through 1st chapter. It comes off pretentious at times and coffee analogies sound a bit awkward. But I really liked the overall structure â€” the fact that expressions and statements are talked about right from the beginning; as well as functions. That's really good. It's also refreshing to see environment records being brought up right from the start, when discussing closures. Author seems to have a good grasp of Javascript. Random comments: - `void ` has not really become a commonplace. It's barely used these days. - "The way we use functions is to apply them to zero or more values" Why not use the term "invoke with arguments"? Especially since "invoke" is brought up later anyway. - "So we have a function, that gives a function, that doesnâ€™t give anything" Maybe better to use already familiar term of "returning"? "a function that returns a function that returns nothing" - "A global environment in which many useful things are bound such as libraries full of standard functions." That sounds weird. Global environment is usually filled with libraries full of non-standard functions. Or with standard functions but not from the libraries (but defined in the language). - {x: 1, '..': {'..': global environment}} Shouldn't this be `{x: 1, '..': {global environment}}`? - bindingName.name Should probably mention that "name" is non-standard; might not exist in certain enviornments - arguments['length'] Why not `arguments.length`? Overall, nice introduction with unique approach.
Heh. Color me impressed. Of course, I'd award full marks if there weren't a loop in your template, but that's not something we're going to agree on I suspect :). It's nice reading some Angular code; this past week I've been trying to get a really simple Ember app up and it is _painfully frustrating._ 
What schmuck downboated you? You're only asking for help. I'm interested in knowing how to do this on a Windows box too (although I could do it in Linux). 
I really hate to be negative; and this isn't a put down for the author of OJ.js, but simply: No, no, no. I'm sorry, but no. This page makes me want to gouge my eyes out: http://ojjs.org/learn.html 
I think the author of D3 could have attempted to learn a little something about API design. Am I the only one who finds it funny that simple use cases like the ones outlined in the article are a lot more complicated than they actually need to be?
They also write "javascript" instead of "JavaScript." Grr.
Keep dreaming.
Eh, not everyone enjoys writing boilerplate and endless ceremony. You don't have to be writing "wordpress templates or facebook clones" to see the value in 3rd party libraries.
Yea, can someone release this as a plugin for sublime, that live updates a buffer or console or something with the jshint report?
Wow. That's really pretty. I like the concept of it jumping to and highlighting the code in question, though I'm finding it to be a little jarring in practice, especially on long lines. Maybe I'll get used to it.
Don't just fucking downvote, you prick. Try answering the question first.
Bit late but meh: http://www.chrome.com/racer made using paperjs
Did you totally ignore the pulled from html files from the server? 
the free version seems to be HTML only and i really hate reading long texts in HTML. is there a pdf version? if it's not, is the markdown source free to use/convert to pdf?
You must be new to "professional" web development. 
They're still pulled out of the html files from the server, which makes them hard to statically analyze.
So, html files pulled out of the server is harder compared to what exactly? Handlebars, mustache templates are easier to statically analyse? Or are you considering this point specifically because - maybe its very easy to statically analyse - React ? 
The JS highlighting reminds me of Lighttable
Yes, it is easy to statically analyze React. Or ExtJS. Since everything's in JS world you can use your normal JS tools for analysis (including type checkers). Basically anything that tries to augment the DOM to try to have programming language features I think is missing the point, Handlebars and Angular included (I talk about both of them in my slide deck). I think Angular is a little more guilty though since Handlebars templates are intentionally crippled (good luck encapsulating a handlebars template!) while Angular tries to make its directives approach the power of a real programming language without being designed like one.
It looks like your view of the world is completely constrained by what can and cant be statically analyzed. Your argument goes something like this : React uses javascript primarily ( and hence abstracts away html ) and hence since majority of it is javascript - the majority of the code can be statically analyzed. Am I right? But with Angular its the other way around. The surface area of what should be statically analyzed is much shorter - because you write re-usable components and then just use them again and again. Directives are a good idea because they get rid of DOM querying! It works on the principle of enhancing an already existing DOM node - and this is the future apparently as seen by web components and polymer etc... 
Seems less discoverable at first glance. For example, the only way to find out that the faint grey "Configure" menu exists is by reading the body text.
this doesn't feel like i'm reading a magazine at all.
Google chrome 32 on windows 7: spinning circle; never loads repo. Tested on: http://darcyclarke.me/dev/repojs/
Looks weird on large sceens.
It's busted for me, I get this on page load in the console: Uncaught SyntaxError: Unexpected token c scripts.min.js:4 (anonymous function) scripts.min.js:4 Uncaught TypeError: Object.keys called on non-object scripts.min.js:1 each scripts.min.js:1 setup scripts.min.js:1 main scripts.min.js:1 onload ?new:41 This is on Win7 Chrome 29.0.1547.76 (Official Build 223446) m.
You are aware of [this, yes?](https://github.com/uipoet/sublime-jshint) Works reasonably well for me...
Bug? var singleSearch = Restangular.oneUrl('betaSearch', 'http://beta.google.com/1'); // Trigger a request to GET http://google.com/1 singleSearch.get(); This is only my introduction to Restangular, though I'd expect the comment to say _"Trigger a request to GET http://**beta.**google.com/1"_...
I tried using dojo once. Then I realised it was a work satan and hitler and woody harrelson.
Are all of these features getting automatically rolled-up into PHPStorm, though? I think that was the crux of this question; not "when will the newest PHPStorm be released?"
I believe they are. It''s my understanding that PHPStorm has everything WebStorm has plus PHP specific addition.
Luckily this has existed for years! Was one of the reasons I originally switched to ST!
Additionally, when these errors started popping up the site became unresponsive about 10 minutes into the enrollment. I have to start all over and enter in all that crap again. I think I'll wait a couple weeks to do this again.
No! I miss it so :(
All your code samples are broken
I've used the JSHint that runs in sublime on save, or on ctrl+j, but I'm looking for one that's live like the jshint site now, and maybe can mark the busted lines in the gutters (similar to gitgutter)
I don't know how I feel about this... Seems like an ad, but you are a fellow 6 year Redditor... Oh well, thanks for sharing I guess 
Wat? Ok I'm going to check the documentation again. I don't remember live support being an option when I last looked at it 
I like the coffee/barista analogy. Perhaps you could include the function as a value concept by giving the baridta a recipe as well as the ingredients.
I meant to share the website as more of a resource. Happy to answer questions about D3.js in general or anything else data viz related. Free resources on the website: Dataviz &amp; D3.js weekly newsletter =&gt; https://www.dashingd3js.com/data-visualization-and-d3-newsletter D3.js Beginner Tutorial =&gt; https://www.dashingd3js.com/table-of-contents 
My usability concern with this is that it's not easy to identify the validation errors... which are the important pieces of information on the screen. I think it should highlight the lines with errors, and have the description of the error next to the line somewhere. You can't at all notice the correlation between the validation errors in the middle and the code on the left until you hover over one of them... which doesn't work at all on a touchscreen. Also, minimalist designs are great for making important information stand out... but in order to do that, you actually need to make it stand out. This is why I think the errant lines should be highlighted.
I like the concept but found the font-size too small and the layout breaks when I bump up the zoom. Also, I get "Mixed spaces and tabs." while using the text field. While, it's great that jshint finds these, I would expect the editor to handle this properly.
no problems detected here function main() { return main('Hello, World!'); } main();
I'm a big fan of reusable components and composition. It's nice to hear you are too -- I think we're speaking the same language :) What I'm saying is, since component reuse and composition are great ideas, why does Angular make it so hard to use? At some point you have to write your code and pass it through as a string! Said another way: the language you use to build directives (JS) is different than the language you use to invoke them (ng-attributes + the expression syntax). Static analysis is one of those things that prevents bugs as your app scales up. And your app is small and fits in your head until one day it's not, and you're going to wish you had static analysis tools that worked on your app. I'm not "constrained" by it per se, I just don't want to have to trade it unless I'm getting something great in return. I still fail to see the advantage of decorating DOM nodes with magic attributes to connect it with the JS. I think that the advantage is something like: "people want to write code in a .html file and then write JS to make it dynamic." And I think that's a really brittle foundation to build a whole framework on top of.
What's with the terrible scrollbars on Windows. ;)
hmm xhtml2pdf seems to have several serious problems with the bootstrap css mainly... do you use a tool like pandoc or a custom script to generate the epub/html ?
These are pretty nice for beginners. I also just wanted to join in on this fellow 6 year redditor circle jerk...
So... I pasted some code into the left portion of the screen. Nothing happens. This is in the latest version of Safari (6.0.5) Console gives me: scripts.min.js:4SyntaxError: JSON Parse error: Unexpected identifier "boss" scripts.min.js:1TypeError: Requested keys of a value that is not an object. In Chrome (31.0.1650.8 dev) I get: Uncaught SyntaxError: Unexpected token d jshint.com/:1 Uncaught TypeError: Object.keys called on non-object Loved the old site.
What's a real use case for this?
I think the people in this subreddit can be nice, but they will probably expect you to RTFM. (urban dictionary it). There is sort of a larval stage that every programmer goes through where everything is confusing and things kind of work "automagically." It's at this point where you just need to keep on truckin' no matter what. And it's also at this point when people in forums seem coldest or least likely to help. As for almost everyone, your best friend is teh Google. If you see something you don't recognize, it's extremely likely at this point that many others have also seen this problem and written up some examples on how to solve it. Besides Google, your next best friend is the Stack Overflow site(s). Sometimes you just have to work on your Google Fu in order to find the exact article you're needing. If you don't know how to do boolean expressions in Google search, you should search how to do those. It'll help you a lot. Also, it helps to bookmark (or have a bookmark service) track items you've already fixed, so that you can go back and "remember" what you did last time. There are plenty of problems in programming (and especially server/network administration) that only crop up once every few months - which is awful 'cause that gives you just long enough to forget what you did last time. I should also warn you of a sort of "anti-pattern" when it comes to asking for help. Sometimes when you ask for help, your brain shuts off before you ask the 2nd, 3rd and 4th questions. And pretty soon the person whose been nice enough to help you is starting to find you annoying. So, always give yourself at least a little bit of time trying to research something on your own before asking for help. Sometimes the answer is just a single Google search away.
Have been running since it was first out - can't say I even noticed the difference!
No, nothing should be touching the localStorage. Could it be due to interactions with the native reddit toolbar? I get this when visiting first with the toolbar: Uncaught SecurityError: An attempt was made to break through the security policy of the user agent. scripts.min.js:4 (2) Sandbox access violation: Blocked a frame at "http://jshint.com" from accessing a frame at "http://www.reddit.com". The frame requesting access is sandboxed and lacks the "allow-same-origin" flag. azcarbon_2_1_0_VERTDARK:1 Uncaught TypeError: Object.keys called on non-object scripts.min.js:1 Though, no matter what I do, I can't repro the original condition. I also do not ever see the `prefs` re-populated with data... Either way, it's working for me now, so don't waste any more time on it on my account! It looks nice, quite a change from the previous design.
From Chrome you can do: print -&gt; save as pdf. (at least in Linux, don't know about elsewhere)
Mainly, i'ts just an experiment of mine. I was insipired by this post by Christian Heilmann http://davidwalsh.name/write-css-javascript , and decided to hit the idea from a different approach. The module was written over the course of a few hours and is not anywhere near production usabillity. Thank you for your interest! 
yeah i know - it still isn't really readable though... thanks anyway
&gt;Who is Evan Moran The next jashkenas? This is another case of writing stuff nobody really needs, and just because you can doesn't mean you should. Abstraction is not always beneficial. Abstraction is useful, but not in the OJ.js way. "Keep It Simple Stupid" are words to live by. Don't throw the baby out with the bathwater, either. There is nothing you can accomplish with OJ.js (or other abstractions) that you can't do with plain old Javascript, CSS, and HTML. Nobody really needs this level of abstraction. 
It can ofcourse be done without an ng-repeat. I just chose to do it that way. 
Have you not seen SublimeLinter? 
You lost me at undocumented. :)
It's gone 1.30am here and I would have to create an account to comment on the article but I couldn't stay quiet about this so... NO! Please, please don't do this - it kills kittens. Labels and placeholders have different purposes - a label labels the field (e.g. "Date of birth") and a placeholder gives information on what's expected (e.g. "mm-dd-yyyy"). The approach described in the article is all kinds of wrong but the most immediate crime is: it's deliberately inaccessible - the dev has gone out of their way to break functionality they got for free. There are alternative ways to achieve a less inaccessible solution to this "problem".
ok. just trying to help. cool site tho.
This weirds me out a little bit. From a very brief look at that page, I get the impression that: - the syntax is nowhere near compatible with ES6 classes, and arguably worse. - there's a (likely significant) performance hit at runtime from using this, both at code initialization and for each object instantiation - adds a 30KB download to your page - doesn't work on older browsers (IE8 and below, mostly) In contrast, something like typescript provides the exact same syntax as ES6, no runtime cost, no additional download, and runs on anything newer than netscape 3. So, what does jTypes provide that typescript doesn't that'd make this a worthwhile tradeoff? Here's what I can come up with: - no compilation step required (but moving the processing cost to every user rather than just you doesn't seem like a win.) - strict enforcement of visibility modifiers. "private" in typescript can easily be bypassed at runtime. jTypes being more of a runtime system could have stricter rules, for some performance cost. - meta things. You won't be able to create new types at runtime with typescript, while it seems like jTypes would be okay with it. Typescript has generics, but that's still not as flexible, assuming there's a need for such flexibility. Am I missing some other benefits that might make a better case for jTypes? 
Thanks for your questions! First off, you are correct in that jTypes not requiring any pre-compliation allows you to have dynamic types. However, it is also worth noting that you can precompile classes with jTypes as well (even though the compile time is quite insignificant if you look at the performance data) using the export() function. This allows you to use a precompiled snippet of code during compilation and therefore bypass many of the checks being performed by the compiler at runtime. So jTypes offers the best of both worlds in that regard. You also touched on the topic that TypeScript does not enforce the actual keywords at runtime that they provide in the language. For example, if I was to define a private property in TypeScript, the property is not actually private at runtime, and is therefore nothing more than a compiler check. jTypes on the other hand is actually emulating classical inheritance by building an instance matrix that actually has separate public and private contexts. When building large applications or libraries, this functionality would be much more useful, as having a compiler check doesn't really help much when what you really care about is your product and not just preventing other developers on your team or who use the .ts file from relying on functionality with data properties that should have been encapsulated. (For example, I can't tell you how many times I saw employees at my previous job incorrectly use the Google Maps API because they simply inspected objects instead of referring to the documentation, so encapsulation can play a huge role in applications and libraries). Not to mention, since an instance matrix is built, this allows you to have something in JavaScript that you never usually see due to the native nature of prototype-chains, which is polymorphism. Sometimes you want to have complex objects that build upon the functionality of other classes, but without the ability to type-cast, you could never develop a really robust library or application that not only hides information through encapsulation, but also through polymorphism as well. Now it should be noted that having virtuals/abstracts/overrides and type-casting in JavaScript isn't for everyone, and as you mentioned, there is considerable overhead in this. So jTypes Lite was created as a much more lightweight version of jTypes that focuses soley on the functionality offered in ES6 using Symbols, which is encapsulation. Therefore, jTypes Lite only offers the public, protected, and private modifiers. Because of this, instead of building a large instance matrix with overhead as you mentioned, jTypes Lite builds a robust prototype-chain much like regular JavaScript classes. But instead of just having public prototypes, there are protected and private prototypes that inherit from one another. These private prototypes are then used for private instances, so that your "this" contexts in your methods and properties can see your entire definition set (since it has the full prototype chain of private -&gt; protected -&gt; public). But there is only one public instance created (just like in native JavaScript classes) that inherits from the full public prototype-chain, and this is what developers outside of your class see (and how the protected and private prototype-chain is hidden from them). Since this is a much more lightweight version, jTypes Lite only requires 5 KB gzipped (14 KB minified). So as you can see, jTypes is all about offering robust functionality for a wide array of JavaScript developers who are looking for different types of functionality. In terms of what else jTypes can offer, I can also tell you that 2.2.0 will be adding type-modifiers to jTypes as well, so you can quickly and easily force type-casts on public fields and properties. I would also encourage you to check out our new AIP syntax (https://scontent-a-lga.xx.fbcdn.net/hphotos-prn2/1383208_385694174892987_509646233_n.png http://www.youtube.com/watch?v=rTtCnnuVqd4), which will allow you to define classes in a really simple and concise manner. Remember, there is more here than just performance. While performance is always a consideration in jTypes, readability and maintainability are also very important aspects of application and library design, especially in business and when working on large teams of developers. Combine this with the robust features found in jTypes, and it can greatly simplify the development process for front-end engineers. If you have any other questions or comments, I would be happy to answer them!
Seabass, since it appears that you are promoting your business (which is totally cool with me), you said you are happy to answer questions, so I figured I'd take this opportunity to ask and I will definitely keep you in mind for a project I'm taking on at my company. How do you usually work with large sets of data? I've got potentially 20k lines of JSON split between 4 or 5 files that are loading into Highcharts and D3. They are simply static json files that are pulled into the DOM with ajax when the page is loaded. Am I doing this the right way or is there a more efficient server-side method? If so, what DB, etc would you recommend? By the way, I'm planning on "serving" the JSON data through a PHP framework like laravel, etc for admins/users of the application.
[LeanPub](http://leanpub.com) has their own process for generating the various formats. I would work straight from the markdown if I had to reproduce the functionality.
There are certainly cases where pub/sub is appropriate but I think this whole sale use of it is bullshit. To me pub/sub (and events for that matter) often give the appearance of decoupling, when really they just change an objects API from a method call to an event name. I definitely acknowledge that pub/sub is the best solution in some scenarios, but since picking up Backbone, I've been frustrated by its abuse (IMHO) in the Backbone community. Does anyone else think this or have counter arguments?
There's a little bit of doc on the readme
Marionette neatly namespaces pub/sub events as notifications and commands. Quite useful. 
Oh good. Another JS "framework" that no one will ever use or care about. Also, it looks kind of terrible.
We've been working on something just like this for a while for internal apps. I think they will be two a penny soon.
The problem is, I am sure you havent written a single application with Angular (surely nothing significant). Which makes all your assumptions and theories about Angular - just that -assumptions and theories. Unfortunately, there is no truth to it. As far as organisation goes - I was sold into the Angular Philosophy because it made writing large applications a breeze. I am currently working on an application that just caused 10k LOC and its still a extremely easy to maintain , reason about and make changes. You dont have to worry about 10 things that might be affected if you are refactoring 1. You dont have to keep all those things in your mind. The load on your head is extremely low. I know for a fact that this architecture will scale to even 100k LOC ( for want of a better metric ). Here is the thing. HTML is a declarative language invented because writing the DOM directly in JS or any other imperative language was going to be a pain. Are you saying that the introduction of new attributes and elements like say nav , input type=date and other ones like placeholder etc are a mistake because HTML was not designed for it? And why are angulars attributes called as magic attributes? And ofcourse you are tending to totally ignore any arguments about web components - for some reason. Are you suggesting that HTML and CSS should stay fixed ( and never change ? ) and that whatever changes we do should always happen with JS? Does that sound like a sound logic to you ? Is that progress? HTML spec was earlier designed and described to show static documents. Thats granted. Given the fact that we are now into an age where we need to describe a dynamic UI ( Most UI's out there are described with an XML based DSL - including the ones for writing UI for Android and iPhone ) - so HTML should evolve to cater to this need - and that is exactly what Angular and Web components are doing. Angular is just basic stuff - I am not sure what you have or not have heard about Polymer and web components - but guys there are doing ajax requests as a HTML tag.. ( go figure! ).. and apparently it makes complete sense and makes things extremely powerful and reusable... I dont know how that works.. But I am excited to find out..
&gt; To me pub/sub (and events for that matter) often give the appearance of decoupling, when really they just change an objects API from a method call to an event name. That would be a pretty terrible implementation of pub/sub. Do you have an example?
agreed, what is the bloody point of framewroks that a) are undocumented b) don't even state what it does 
Chaplin.js did this with the events whose names start with "!". They later realized that it was exactly the kind of abuse /u/pemmigiwhoseit is talking about and are moving away from it.
Yes, it's basically useless then. Did not know Opera had BT support, thanks :D
No updates in 9 months, seems a little dead.
Thanks for the info. I believe that the comments on the site talk about this. What else would you suggest BTW? Having a label and placeholder seems somewhat counter-intuitive unless the form is very specific on what data it will accept. 
:( That sucks, I have no idea what could cause that...
Awesome and so easy to use, thank you OP.
[Beware of this kind of microbenchmark](http://mrale.ph/blog/2013/08/14/hidden-classes-vs-jsperf.html). 
pretty easy, but then it goes ahead and gives you inputs that would never come up and expect you to just disregard them, when really you'd probably want to use them (like converting strings in to numbers)
true - but in this case they're right. There are performance benefits to using constructors because they create a class whereas the factory creates a closure and closures are still slow.
It's tricky to choose a WYSIWYG editor because there are so many of them. I'm currently doing research to choose one for a site I'm working on, and these are some of the other ones I'm considering: http://hackerwins.github.io/summernote/ http://ckeditor.com/ http://mindmup.github.io/bootstrap-wysiwyg/ http://jhollingworth.github.io/bootstrap-wysihtml5/
I think there's some sort of disconnect here. You define your Angular directives in JavaScript. You invoke them with a DOM attribute. Directives render DOM using string-based templates (whether they come from the DOM or not is insignificant). So if you want to compose one directive with another one, you must define it one way, call it another way, and bridge the two worlds with a string. At the very least this is added friction for no reason. What I think it really is is a hack to support composition because Angular is built on a shaky foundation that doesn't scale up to complex interactions. One of many such hacks. Another indication for poor support for composition is the fact that they need to use DI for a lot of stuff. DI is popular in the Java world and not so popular in other communities. I think one of the reasons it's popular is because Java can be quite verbose and functions aren't first-class values, making DI easier than threading a dependency throughout the call stack. I think the reason Angular uses it is because it's cumbersome to pass any sort of data throughout Angular (since it was not designed with composition in mind). I guess it comes down to this (performance excluded): if you reinvent scopes you better have a damn good reason to do it. Angular's reason is that they need directives. The reason they need directives is so they can annotate HTML with functionality. I don't think that this is worth reinventing scoping. Not by a long shot. This is frustrating for me because since Angular is entrenched, the burden of proof is on me to explain why I think it's a bad idea. But from my perspective Angular reinvented and half-implemented a bunch of things that already existed in JS or were unnecessary, so I feel like the burden of proof should be on *Angular*!
Or, as previously discussed... it's always going to be cheaper to create a method for objects once, than it is to create it for every object.
"closures are still slow" is folk wisdom based on interpretations of these horrid microbenchmarks, and that article goes out of its way to show why that is bad, because you can come up with testcases that show whichever result you want to believe. The reality is much more subtle and nuanced than "closures slow, prototypes fast." 
I don't think the 6 years counts for much, there's no sign of any activity on the account prior to 23 days ago. Also, 4/5 of their submissions have been promoting their own site, and the only comment is the one in this thread. So while they may have created the account 6 years ago, it's been dormant (or they've otherwise somehow managed to maintain 0/0 karma _and_ deleted all past activity). I am not so inclined to consider this person "a member of the /r/javascript community" by any means just yet.
I don't know if I were to consider Io for a real world application, although I am sure it's used. Learning the language in general is great academically for understanding Prototype based OO programming concept in my opinion.
After researching the ones listed in the original blog story, here are my personal opinions on those... http://www.themaninblue.com/experiment/widgEditor/ - Small, but the interface looks dated it isn't customizable. http://www.tinymce.com/ - A fairly good one. We've used it in the past. http://markitup.jaysalvat.com/home/ - Not really WYSIWYG, more of an html / tag editor. http://www.nicedit.com/demos.php - "This project is not actively developed anymore" http://developer.yahoo.com/yui/editor/ - Not sure about this one. Seems complex. Has been replaced with YUI3, which is apparently even more complex. 
Http://etchjs.com might be worth a look. It's a backbone.js based wysiwyg editor that focuses on being minimal. Disclaimer: I wrote it.
Thanks for finding one for me, when I started actually looking for some of course I couldn't find any quickly. Also as soon as I actually wrote down my thoughts, I realized that some of the cases I thought were "bad", may actually have very good reasons for being that way.
Yeah, I'm currently planning to just use TinyMCE since it's in active development and we've used it in the past. Aside from that, CKEditor has an incredible number of features if you need some advanced features or customization. SummerNote looks very nice and simple and is based on Bootstrap if you're already using that. So those are my current top 3 choices.
Warning: Don't click the link if your volume is turned on and you're at work. Autoplaying sound/ads are NEVER a good idea.
While I appreciate that there are gotchas associated with microbenchmarks, I think the attitude that they should be avoided like the plague is also problematic. A big part of building software is managing complexity; we have to do our best to simplify where we can. Of course if you're building something real, there is no substitute for testing that real thing, in a realistic environment. Microbenchmarks don't give you that. They can also, as the article points out, sometimes provide bad information because of unexpected subtleties in the underlying technology being tested. That doesn't mean they're ALWAYS bad or that the information they give you is NEVER valuable. Take the jsPerf referenced in the article as an example. What it is *really* testing is the cost of **method invocation**. After lifting the definitions outside of `Benchmark.prototype.setup`, the cost of calling `setName` appears to even out among the three implementations on display. What this is *not* testing is the cost of **object creation**, which has already taken place before the benchmark in each case. Now for the microbenchmark I referenced in my silly little protip: the real issue being tested hereâ€”though I admit it's a bit muddled by the fact that I have each test call several methods as well (perhaps a mistake, in retrospect)â€”is the cost of object creation, using either the "factory" approach, as I call it, or the prototype approach. My position is that this issue is actually more clear-cut, and not so subtle. See this revision where I lift the definitions outside of `Benchmark.prototype.setup`, with the same results: http://jsperf.com/prototype-vs-factory-performance/4 Again, I appreciate that we should be wary of accepting microbenchmarks as the be-all and end-all. But they can still be useful to illustrate a point.
can you imagine life without an interactive console or any debugging tools like firebug? Now that sucked. The new guys have it sooo easy, with all the interactive learning sites out there
Disappointed that the victory song isn't Queen's Under Pressure :(
I got 4 minutes and 39 seconds.
And I could understand that if this was a programming question, but I am at the stage before even asking things like that. I was just hoping for a book to work through. I appreciate all of your advice though.
Can you explain more what you mean? Specifically, what other approaches you might use and why they are not idiomatic JavaScript.
Strange he didn't mention ckeditor or aloha editor. I think for many users ckeditor may be the only one that has all of the features they expect (is everything).
Consider a traditional OOP language like Java. You *could* avoid using instance methods and just define classes with static methods, where the first argument passed to each static method is an instance of the class. In this way you would still achieve the goal of defining methods once and reusing them (not that the alternative of anonymous methods is particularly viable in Java anyway); but your code would seem odd to any experienced Java dev. That's basically what I'm referring to: the performance principle I am really highlighting here is that it's more efficient to define a method once (as kenman put it) than to define a new version of it for every object you create. Whether you define it on the prototype or as some standalone method is another matter. Does that make sense?
gotcha. yes, thanks
`this` inside the function and `this` outside the function are two different contexts. What `.call(this)` is doing is ensuring they're not different.
God damnit, took 6 minutes for the first 4, then got stuck on the last one. Couldn't complete it in 65 minutes. Still haven't figured it out.
Working with large sets of data depends on how you want to display them and what you mean by large. a) If it is a time series where you are entering and exiting data, then you want to load them sequentially as time goes by. If you are using PHP and the 20k lines of JSON data are being generated very quickly you might want to look at something like Ratchet (PHP Websockets http://socketo.me/). This example (http://blog.ollieglass.com/2012/04/21/bieber-fever-meter-with-html5s-web-socket-d3-js-and-pusher/) uses HTML5 websockets, d3.js and pusher. Though it's in python it the github repo python files are small enough (&lt; 100 loc each) that you should be able to follow how it is being done. b) If it is more of an exploratory data set where you already have the data but it's not being generated again, then you want to load the bare minimum and then as people explore the data, you want to call the ajax loading function as people are exploring the data. This way you only load what is initially needed. The Visual Information-Seeking Mantra [The eyes have it: A task by data type taxonomy for information visualizations - Shneiderman 1996] talks about the following way to build a data visualization: Overview First, Zoom and Filter, Then Details-on-Demand. So rather than pull in the 20k lines of JSON right off of the bat, pull in the Overview of the data first. Then if/when someone wants to zoom and/or filter you can pull in subsequent data. This helps to minimize the size of the data set that you are brining in. One place people run into this is when visualizing time series data that is based on second increments. The initial view is a year. Rather than downloading all of the data for each second over the year, you can do things like get the average reading for every hour and only bring in that data. Then when people zoom into the daily visualization, you can go back to your data source and request the "by second" data. Regarding the question about DB - whatever you are most comfortable using. Text file vs DB depends on how much filtering/querying you are going to do. Filtering on the server side could make it so that you load less data that is then filtered on the client side. Note - if you really want to do very large data visualizations, the Stanford Visualization Group is currently working on this -&gt; imMens (http://vis.stanford.edu/projects/immens/). The goal of this project is to support interactive visual exploration of large data sets with billions or more elements. 
Recursion is tough. And javascript considers arrays to be a typeof object.
https://www.dashingd3js.com/intro-course-sample-videos has 3 sample videos from the introductory course. Some of the screencasts will come from the introductory course as well as some from user requested topics (more advanced than the intro course).
&gt; The _why_ is a question for another post. I can't speak with authority on that, but I have a strong suspicion it relates to JS engines' use of hidden classes internally and the efficiency of vtables. I don't think the performance difference is mysterious, and I don't think it has anything to do with hidden classes or vtables. He's executing a ton more code in the constructor with the factory. The method invocations themselves are not significantly different in performance. Here's the jsperf with the constructors moved into the setup functions, so you're only comparing the methods: http://jsperf.com/prototype-vs-factory-performance/6
Well THAT explains a lot :/
I was proud of my code on the last one, I wish it gave me a chance to save it!
Buggy as heck.
That's actually the point I made in my response to Rhomboid's comment: &gt; ...the real issue being tested hereâ€”though I admit it's a bit muddled by the fact that I have each test call several methods as well (perhaps a mistake, in retrospect)â€”is the cost of object creation... So in retrospect, I probably should have left *out* the method calls and only kept the object creation *in* (i.e., the opposite of what you did). In my defense, the main purpose of the method calls was just to illustrate that in either case the end result is an object that exposes the same functionality. --- While I think you're right to break it down this way ("he's executing a ton more code in the constructor with the factory"), I don't think that's quite as obvious as you are implying. It would be theoretically possible, for example, for the JS engine to "lift" the function definitions out of the factory method and only bind them to the closure within the method itself. (Or, even if I'm wrong about that, that could very well be what some developers would *expect* to see.) I included the link to Eric Lippert's post because about halfway through he proposes a design that is actually remarkably similar to the factory pattern in the jsPerf: you could implement a class with pseudo-virtual methods by defining a field for every method, and assigning all of those fields for every instance of the class to the appropriate implementations. This is clearly less efficient than using a vtable, which implies only one reference per instanceâ€”which I think is analogous to what you get by using a prototype in the JavaScript world.
If I were to use sarcasm on the internet, I would use the ØŸ. I was genuine, it does explain a lot. Weird javascript :(
If you want draw the control as a custom canvas based element with a &lt; 1 opacity value or use the css opacity property on a standard control, if not then you can use var pixelData = canvas.getContext('2d').getImageData(x, y, 1, 1).data; to get a single images single pixel color, you'll just have to compute all the offsets for the controls and canvas
&gt; I don't think that's quite as obvious as you are implying. It would be theoretically possible, for example.... It's not obvious _a priori_ that one constructor would be so much faster than the other. But given that that's the case, it's obvious why. It's theoretically possible for a bunch of code to be optimized away, but looking at the benchmark it should be obvious that it's not in this case. Anyway, I think that your last paragraph strongly implies that the method calls themselves come with a performance penalty, and that's not the case. I'm not trying to make you explain why what you wrote is technically not incorrect. I'm just saying it's going to be misleading.
That's definitely fair. You've convinced me to update the post since the last thing I wanted to do was mislead anyone. Really my intention was to shine some light on one useful application of the prototype system in JavaScript, since in my experience a lot of JS devs are somewhat allergic to the `this` keyword. It wasn't to erroneously suggest that prototypes are always great and closures bad or anything nearly so broad.
Badly glitchy for me (latest Chrome on Ubuntu).
Should be fixed now
I just pushed a fix. Can you check again (with cleared cache)?
I got 16 mins and 42 seconds... Because I had too poop in the middle of it. Turns out I can't JavaScript under pressure :(
Don't feel bad. I can't poop under pressure. 
Ugh. 7 minutes, 12 seconds. Should have done it under 5 but those unexpected inputs...
I've been using Redactor lately - its NOT free, which makes support take a little longer than running a stackoverflow thread, but it lets me do file uploading to amazon, have embedded pictures and copy-paste formatting from just about anywhere.
My front-end neglect is showing. It took way too long for me at 15 minutes. I've been doing so much PHP lately that I could remember very few of the native js functions off hand. For shame 
Sorry for the delay. Out for the night. I'll answer tomorrow, promise!
Well I did poorly on two of them. The first one that tripped me up because "find the longest string in the array" reads a lot like "find the longest string in the array of strings" to me. Considering in later challenges the questions explicitly stated the types of the array elements, I wish they had done that. Using `i` as the input variable was annoying, you either waste time changing it, or waste time making sure you don't mistake it for a loop counter. As for the rest, how did people test whether an item was an integer or not? I used `x % 1 === 0` at first but I didn't expect '4' as input, and I was unaware `'4' % 1 === 0` is true... so I tacked on `typeof x === "number"` but that seems ugly.
using `(foo instanceof Array)` works
mm, i wish there were a few more levels with some more complex stuff. first time took 4:47, second took 2:57. actually, i think i'd rather have a timer that counted *down* for each problem. That seems like it would be more pressure.
I'm using Redactor for my project, too, and it's great. Responsive too, for mobile!
First go I did: if (I.length &amp;&amp; typeof i != "string")
Hell, Assembly code is your friend (if you care about perf). 
6 minutes, 13 seconds for all 5 levels. Well done! Could be better, if I would know what is this about. Also was not coding any javascript in last 3 months :) Still good. 
`typeof x === 'number'` is the way to go here. I don't think it looks ugly at all. Using a modulus like that just looks a bit confusing because it's not usually used in that manner.
Or maybe a clock sound that gets faster for each question :).
I am audibly groaning using this
Hrm, thanks. I included the modulus because `typeof 1.1 === "number"` evaluates to true, and if I recall correctly the requirements specified integer.
That is very true and probably should have been one of their test cases. But since it wasn't and my code passed anyway, then ultimately it was the right answer for this particular question :). If they did have floats in there, then `typeof n === 'number' &amp;&amp; n % 1 == 0` would have been the best way to go. It's a trade off of doing something quickly and just get it to work or write quality code that will work for practically any situation. Since the "situation" was only a set number of tests, then the smaller code is the way to go.
To be fair, whom is using touch events on Firefox? If this only worked on WebKit I don't think that would matter?
Works great for me coming from alien blue on iOS. Saving this for a near-future phonegap app!
Are you trolling, or do you actually think it doesn't matter whether a site works on 19% of the internet? What about IE at (total) 56%, should it not "matter" either? I don't even actually understand your remark, maybe.
19% of the Internet is mobile browsers that aren't WebKit? My remark is about which browsers are actually being used by mobile touch devices. I guess there might be a sliver using mobile trident for Windows phone, but AFAIK Firefox does not have any mobile share.
Oh sorry, didn't know we were talking mobile, but Fennec's market-share is certainly non-zero.
One way to solve it is to create a function inside the main function to take a value and check if it is an array or an integer. If integer, add to a total. If array, call the function again. Now create a for loop and check each value in the input to see if you have an integer or an array. If integer, add it to a total. If array run the function you created. To check for int: if( x === parseInt(x)) To check for array: if( x instanceof Array)
It's like 0.01%, so... eat a dick
looks cool man!
If you had trouble with the last one, it seems like people are tripping up on one of two things, either identifying arrays, or recursively walking arrays so I've posted an annotated solution in github: https://gist.github.com/sharkbrainguy/6821484
but its an anonymous function, immediately executed, so that really isnt necessary
Ugly bytes there : setTimeout("B()",5) Why not just setTimeout(B,5) ?
GAAAH I would have gotten under 5 mins, I did the recursion on perfectly... except I did for (j = 0; j &lt; i.length; j++) in the loop instead of for (***var*** j = 0; j &lt; i.length; j++) Took me a few minutes to realize the scoping issue. End result: 14 mins 19 sec
It's annoying that the parameter is always `i`. I reserve `i` strictly for loop iterators.
startClock = function() {} phew. i hate pressure. edit: script breaks the final level... this might work: startClock = function() { startTime = new Date().getTime(); inPlay = true; }
impressive! i'm not familiar with raytracing - what kind of algorithms are usually being used ?
As stated in the readme, it's a very naive implimentation, but one that gives good results. In each pass, on 'photon' is sent out for each pixel in the image, at the angle of that pixel. It marches forward at a certain interval, and then checks if it's inside any of the 3d solids (the 3 light spheres, and the heart shape). If so, if scatters in a random direction, multiplies it's values by the color of that shape, and continues. If it hits a light sphere, it stops and calculates it's final RGB value, adding it to a buffer. For every pass, that buffer is incremented, and then divided by the total number of passes to update the framebuffer. A smarter implementation wouldn't step each photon until it hits something, but would rather calculate the collision with the next sphere with trigonometry. Ironically, stepping them one unit at a time is closer to reality, and easier to code, but algorithmically much more expensive.
I'm using hammer.js to normalize the event behaviour.
Damn, I was trying to break 5, got 5:03 instead.
ha ha! Crockford has saved me on that one so many times. Declare and hoist your variables!
Why not just use sumOfArray itself?
Just use Array.isArray.
 function sumArray(i) { return i.reduce(function(v, x) {return v + (Array.isArray(x)? sumArray(x): typeof x == 'number'? x: 0)}, 0); } 
Few things I think might reduce the filesize a tiny bit more... * Create a variable for w*5 in createImageData (Line 16) * Change 0.003 to 3e-3 (Line 59) * Create a variable for A()/10 (Line 69)
That's not correct. Try running: var _this = { blah: function() { console.log("outer this is ", this); function inner() { console.log("inner this is ",this); } inner(); } }; _this.blah(); You'll see the outer this is `_this`, while the inner this is `window`.
apart from a particular edge case (creating arrays in an embedded frame's context causes issues with instanceof checks), I don't really see the advantage, unless you find `Array.isArray(foo)` more readable. 
Stealing 'temporal spaghetti'
In function z: Multiple var statements can be comma separated (save 4 bytes). Bonus: lose var altogether `h[2]*h[2] === h[2]^2 (save 3 bytes). Could maybe make all squared variables the same way for consistency. There's other places where using ^ would reduce size as well (i *i *i) Formatting this on a phone is hard...
Save 13 bytes by replacing all instances of "0." with ".", so that "0.003" becomes ".003", etc. I'm actually surprised minification doesn't do this for you. Two more bytes making this replacement: r=g=b=0;d=1;for(I=0;I++&lt;400;) d=1;for(r=g=b=I=0;I++&lt;400;) Two here: g=2;b=3;r=3; g=2;b=r=3; Two here: f[q*3]+=r+j*1.5;f[q*3+1]+=d*g+j;f[q*3+2]+=d*b+j; f[Q=q*3]+=r+j*1.5;f[++Q]+=d*g+j;f[++Q]+=d*b+j; Remove the first parentheses here for two: q=(++m)%(w*w) If `q` is known to be a Number (looks like it) you can save three here: if(i&gt;q&amp;&amp;q!=0) if(i&gt;q&amp;&amp;q)
But `^` doesn't exponentiate in JavaScript.
No worries! Thanks for replying!
Might not be your fault. The spec doesn't match the code. Comment in the task is: // i will be an array, containing integers, strings and/or arrays like itself. // Sum all the integers you find, anywhere in the nest of arrays. However, one of the tests do: Testing "arraySum([[1,2,false],'4','5'])".. So if you didn't include a test for bool, you would get errors.
No need to use cargo cult equality. typeof gives you a string. If you use "===" you're indicating to the casual reader, that this is a case where that may not be the true. Which is super confusing.
Yeah, every time I started a for loop I had to backtrack to fix that.
My solution (probably a little verbose): var total = 0; function arraySum(i) { // i will be an array, containing integers, strings and/or arrays like itself. // Sum all the integers you find, anywhere in the nest of arrays. for (var j = 0, len = i.length; j &lt; len; j++) { if (isArray(i[j])) { arraySum(i[j]); } else { if (isNumber(i[j])) { total += i[j]; } } } return total; } function isArray(obj) { return Object.prototype.toString.call(obj) === '[object Array]'; } function isNumber(obj) { return Object.prototype.toString.call(obj) === '[object Number]'; }
Yes, you're right that *in general* you could have a different value for `this` within a function versus its calling context. But in the case of this specific questionâ€”and in most cases where I see the [IIFE](http://benalman.com/news/2010/11/immediately-invoked-function-expression/) patternâ€”the function is being invoked at the top scope, inside a `&lt;script&gt;` tag, where `this` is `window`. I meant that in *this case* there's no effective difference between the two approaches in the question.
I think the title is absolutely wrong. jsPerf is a site to compare the perf of "A" to "B" and maybe "C". It's up to the dev to create meaningful benchmarks. If something looks too good to be true then it probably is. Then it's time to rethink what you are wanting to measure and why. Micro-optimizations are lousy anyways, nothing new there. jsPerf is responsible for catching JS engine bugs in Firefox &amp; Chrome and helping library authors produce real world perf gains.
Isn't Dojo already a JS framework for Java people?
discalimer: we use backbone all over the place and in general we love it. rant: It is so hard because backbone is a weakly typed, poorly documented, edge-case laden library where things just haven't been thought out very deeply. Also, when using backbone it is very helpful to choose a subset of the tools you like and can live with. For instance, we use the router, its eventing system, and views quite extensively. We use the models as well, but they suffer a number of problems. Do not, I repeat, do *not* use the models integrated with your backend. Unless you are using rails and have a backend specifically designed for bb, it will be nothing but a world of pain. The integration with the backend is way too deep, way too magicky. It assumes way too much and for no good reason. It breaks the fundamental tenet of decoupling all software designs should strive for. The truth is, it is trying to solve a problem that isn't very hard. We find it much easier to just make the jquery / ajax call to the backend and explicitly [ETL](http://en.wikipedia.org/wiki/Extract,_transform,_load) the data into a model. Loading is done 100x more often than saving, and using the models is done 100x more often than loading. It just isn't that common, or hard, to manage the backend calls. What is difficult is having to constantly override the built in "magic" functionality of the models. URLs, IDs, what URLs it calls to fetch, load, save, when it call verify, when parse gets called, when to silence this event or that, when an operation is done on a collection vs an individual element. Crazy. Separate the backend from the models. Explicitly build your models. Explicitly save your models to the backend. Doing it explicitly isn't hard, and saves you from a world of pain. 
~~Are you sure you posted this to the right subreddit?~~ Oh, I see, it's way down after the discussion about CNN's box colours. Right.
Derp attack. It's been a long day...
Instead of just presenting the library, I thought coming up with a clear use case would be better. I was most concerned no one would understand how this could be utilized. Probably a dumb idea in hindsight.
Thanks for the rant. I was starting to think in the type of direction you are describing, but it's good to hear from someone who has actually taken the plunge. I'm going to probably first give backbone-nested and/or backbone-deepmodel a try just because, but I agree that at some point rolling one's own modeling solution might just be the most efficient approach.
tl;dr: More-or-less the same conclusion as in that article: micro benchmarks on source-code level are meaningless since JIT compilers will optimise so you don't really know what you are measuring. Instead rethink the larger algorithms and gain a lot more provable performance.
Thanks for the long and very interesting response. I don't have time to click through all of the links right now but later today I will be sure to check them out. I do happen to know that this dev is not paid by the hour however. Thanks again for the helpful info. You should definitely do a blog post about this. 
Oh, we use the bb models quite a bit. With the eventing system, they hook in well with views to keep everything talking to each other. We're just learning that having the models deeply embedded with our back end is just not the way to go. So no automatic fetch and save for us. Nothing that uses that god method "sync". Those are the parts we'll do ourselves. And it's not like we weren't before -- we had to overload all of the built in functionality with our own calls anyway. But now we're also taking the step of making the calls explicitly, not implicitly.
I've recently made a tree structure (model that contains a collection of models). One thing to watch for is that on re-sync Backbone can create new models and collections you may still be hanging on to references to the old ones. This can be solved with a resource pool.
Sweet, I hadn't noticed the 0.xxxx thing. I deleted them in the source, but yuicompressor added them back in :| I switched to uglifyjs, and it does that automatically. I added the other changes as well, thanks! It's down to 941 bytes now!
Actually, in function z(), turns out I don't even need `var` at all, it's cheaper to pollute the global scope, which saves 8 bytes. Sweet!
I am also confused. Q has a pretty standard API for a promise library. 
Thank you! That does seem problematic. I wonder if there's anything to be done with respect of running the tests fully isolated in an iframe or something? While I agree that pre- and micro-optimization are often red herrings and/or simply unrepresentative of real-world use, I do think that they sometimes can provide value (ignoring invalid testing conditions of course).
Red Herring: Trying to distract an audience by deviating from the topic at hand ^^Created ^^at ^^/r/RequestABot ^^If ^^you ^^dont ^^like ^^me, ^^simply ^^reply ^^leave ^^me ^^alone ^^fallacybot ^^, ^^youll ^^never ^^see ^^me ^^again
Yep, I started off well but then derped into a different language...
why
 i.forEach(function (item) { ...stuff... });
This. @mraleph is making the case against microbenchmarks in general, including microbenchmarks on jsPerf. For that, heâ€™s using some bad examples he found on jsPerf. Just because you can use jsPerf to create a bad test case if you want to doesnâ€™t make jsPerf useless, though. Iâ€™ve given presentations before where I explain how to avoid common mistakes when creating benchmarks (including jsPerf benchmarks): http://www.youtube.com/watch?v=RLbAKxCAdI8 This one by @mraleph is similar, although much more hardcore and focused on micro-benchmarks specifically. /u/lennelpennel, please watch the actual video before making up sensationalist titles like this. Thanks.
Check it out: Array.isArray(i) // returns true if i is an array typeof i == "number" // returns true if i is a number 
Some of this is wrong... for example: [+!+[]]+[+![]] //"10" To get a number out of this you'd have to do: +([+!+[]]+[+![]]) //10 
Cool. Definitely more concise and intention revealing.
Yep, I agree. I never said that jsPerf is not useful. There *are* of benchmarks there that make sense. I even gave example of small size benchmark that makes perfect sense. My point is different: microbenchmarking is not that useful, if you don't try to understand what you are actually measuring. Next time I speak on this topic I will try to articulate this. (Actually even microbenchmarks on jsPerf are in some sense useful, because they often allow JS VMs implementors to see shortcomings of their VMs)
backbone isn't opinionated, it's just ignorant. There are two ways to implement your model layer - "change listeners" and "dirty checking". Change listeners are conceptually simple but they have a number of problems, such as making nested models very difficult. Dirty checking is much more complicated to implement (Angular has the digest loop, Facebook React has a reconciliation algorithm) but the usercode is simpler - you don't have to write dozens of onChange functions, and complex/nested models works great. A similar argument could be made for backbone views. They are internally very simple, at the cost of making usercode complex; Angular and React views are much more complicated internally (e.g. you need to understand the digest loop) but they make usercode way simpler. (I write [large enterprisey apps that look like this](http://wrapbootstrap.com/preview/WB0B30DGR). We started with backbone and knockout and pretty quickly got rid of them once we understood their philosophy and realized that change listeners forcing us to write really complicated code. We switched to a dirty-checking and cut out half our lines of code and a lower defect rate.)
Gotcha sorry didn't realize that. Read it again and got it.
Title of the page is "msRequestFullscreen method", but there is no example usage of this method. The code example at the bottom of the page uses the standard, webkit, and moz variants but not the ms variant. Gave me a chuckle, thought I would share. :)
Writing a Twitter bot takes way more than 20 minutes thanks to Twitters policy that lets you only make 15 requests/15 minutes. Takes awfully long to debug if you don't write perfect code the first try. 
But they do show you how to exit fullscreen with .msExitFullscreen() !
re: "by Java people"... Why is it a selling point that people steeped in a strict-typed single-paradigm OO language known for over-architected ManagerEntityFactorySingleton developed a framework for a dynamically-typed multi-paradigm function-based-if-not-functional language?
I love this attitude. Thanks, I'm buying the book.
It doesn't. We use bb models extensively. We just don't tie them so closely to our backend.
I like your app. We should work together.
Gotcha, thanks.
`this` is still a different context inside of that function--it just happens to inherit from `this` outside of the function (which is why everything still works as you expect). However, you'll notice that accessing variables is *ever so slightly* slower (these days, anyway--it used to be *considerably* slower) inside the function than outside. Of course, I'm talking microseconds at most here, so you may or may not notice the difference--but it's there.
8 minutes 31 seconds. No excuse to be that rusty at JS.
I just don't know why. Even from an experimental, let's think outside the box frame of mind I still can't understand why. 
Thanks! https://github.com/raganwald/javascript-allonge/issues/30
Ugh. Why not just implement it without prefix Microsoft?
Omg no you don't want nested models in backbone. Invest a few days in playing with angular or Facebook React (react is newer and better) and then decide. Nested models in backbone is a world of pain and you don't want to be writing that kind of code. I wrote another post in this thread that digs a little further into why.
I'm guessing it's the same reason Chrome and Firefox don't implement without -webkit and -moz prefix. Because until the standard can be solidified consistently cross-browser, it is good practice to add your prefixes. Ideally, when all browsers RequestFullscreen() mehtod works exactly the same, then they will get rid of the disambiguation. 
I disagree, I believe vendor prefixes are a terrible practice. Microsoft is providing a good example of why--developers screw this up by leaving one out or only including one, etc. Anyhow, Opera (Presto) had already shipped the fullscreen API without prefixes, and I believe the Blackberry browser did too. 
The problem with not having prefixes, though, is that the same method name exists, but has different expectations or results. That means that you either have to do more in-depth feature detection (if that's possible) or you have to use browser sniffing. If you have the prefix, you can do a simple "if (msRequestFullscreen)" and be assured that msRequestFullscreen will always work like msRequestFullscreen, even if that's different from mozRequestFullscreen or what-have-you.
The fact is jsperf runs each test in a single container, meaning that vm optimisations are not considered, meaning that is is in fact not a great measurement in testing performance of an application which is long living and as such not that useful. Non trivial performance tests which run in a single container repeatedly make a lot more sense. The title was aimed at pointing out that most benchmarks people link too are pretty useless. Note "not that useful" not useless in total, just most benchmarks are shit.
The chrome team is not using prefixes any more and instead are going to a system which forces the "user" to enable "experimentalâ€ features. This allows them to implement cutting edge stuff without fear of then breaking anything if it needs to change. And they can enable it by default when it's ready.
I get the "why" of that, but it's kind of disappointing. The end user likely won't care, in the same way nobody cared about plugins back in the day, so you'll have to wait for the feature to go legit before you can use it anyway.
I am not sure why do you think that "vm optimisations are not considered". jsPerf generated functions are looping enough to trigger optimizations. One could say that the optimizations are not reused, this is true, but it is a different story.
&gt; On a computer without a keyboard, pressing the Windows button will exit full-screen mode.
I completely agree with dustingetz. Backbone is marketed as being one of the most non opinionated frameworks - but it really is opinionated. I am not familiar with React ( so wont recommend it wholeheartedly ) - but from what I can see is - its pretty close to being a good solution. On the other hand I would surely recommend Angular( since thats what I have been using ) and its a breeze to work with - especially with complex models. I had put up a post earlier comparing and contrasting Backbone and Angular if you are interested. http://blog.nebithi.com/backbone-and-angular-demystifying-the-myths/
you're talking of IE &lt; 10 (even IE9 is not that bad). IE10/11 behave quite like the other majors browsers. An recent incompatibilty betwenn FF/Chrome : webrtc and data channel were implemented differently. They were utterly incompatible for like 4 ou 5 versions of theses browsers. IE / safari for mac and IOS still don't support it.
It is much better already. One problem that's left: if I scroll in a single motion from image 1 to image 3, it will center on image 2 (ie I can't scroll 2 images at a time although it feels like I could).
Surface and surface pro
Thanks! https://github.com/raganwald/javascript-allonge/issues/31 
Don't think it was a poor idea. It wont kill people to read a few paragraphs. 
&gt; array.empty() instead [of] array.length = 1 Shouldn't that be array.length = **0**? Edit: Copy-pasta error.
That used to trip me up constantly. Why would filtering a collection not just give you back a subcollection of models? Makes no fucking sense.
Spend a day on preparations by making a stub server mirroring the calls you are going to test a lot.
Neat idea.
Cool. It would be interesting to know if and how transpilers of ES6 to ES5 deal with this. As far as I can tell, a transpiler would not be able to emulate this.
And the monkeypatching begins... Sigh
It should be "clear" instead of "empty". It's called "clear" in Java, Dart, C#, Ruby, etc. Secondly, don't modify objects you don't own.
It's not a good idea to modify the prototype of native objects in javascript, it can lead to nasty bugs especially when including libraries that might also define one of those properties. http://www.nczonline.net/blog/2010/03/02/maintainable-javascript-dont-modify-objects-you-down-own/ 
Slides available at http://www.slideshare.net/TimPerry1/the-many-ways-to-build-modular-javascript-26805323
ah i meant across runs and such. the vm will optimize when it sees opportunity (as it should). My point is that two fold 1) most code get used in complex scenarios and 2) very little code tends to be the hotspot in an app. I don;tt disagree that jsperf is useful, but I don't think its use in the js world is useful (notice this was a js list post and not a prog post). I see "look at this jsperf" often and looking at it the problems cannot be benched in the way people do.
Gah, 41 minutes of that audio would drive me nuts - I wish the camera had a feed from the PA.
Nice use of `defineProperty`. If you're going to muck around with with the prototype of in-built objects, this is the least awful way to do it and least prone to introducing hard-to-find bugs. For instance, despite the fact that `for (var idx in array)` is bad practice, you can break code that does this by adding methods to `Array.prototype` without `defineProperty` + `enumerable: false` (which is default when using `defineProperty`, by the way). What problems can adding methods and properties to in-built objects cause when its done the wrong way? * **Documentation issues:** "`Math.epsilon`, what the hell is that? It's not mentioned on MDN anywhere" * The implementor didn't document it correctly * **Clash of the monkey-patchers:** "Whoa, my `String.titleCase` method now incorrectly capitalizes `the` after including library X" * The last monkey-patcher won * **Lack of future-proofing:** "Whoa, `Array.filter` is performing much slower than it should." * A shim didn't check for the existence of the method before adding it If you're careful, you can get away with it. Is the added convenience worth the potential maintenance problems? You decide.
http://www.nczonline.net/blog/2010/03/02/maintainable-javascript-dont-modify-objects-you-down-own/
Thanks
It sounds like he's at the end of a long tunnel.
You've convinced me. What is your take on doing something like... var SugaryArray = function() { this.clear = function() { ... } } var CreateSugaryArray = function(array) { SugaryArray.prototype = array; return new SugaryArray() } This would get you that same syntax. MyArray.clear() vs Sugary.clear(MyArray) 
Noticed Magento by default would see if you were a Firefox browser, if not it would define console.log to do nothing. As far as I know it still does that...
I think there is difference betweeen modifying document.getElementbyClass and adding a syntactic sugar for array.prototype. Especially when talking about node.js environment. I personally think this sugar should have been in ecmascript standart from day 1 and more people will use it, the better. Maybe in ES8 they will implement some of those.
Is it really that different? What if these functions will be added in the future? Can you guarantee that your functions do exactly the same thing as those which weren't written yet? What about edge cases? What do your first/last functions return if the array is empty? Is that what the real implementation will do, too? In Dart, for example, using the first/last getters on an empty List throws a StateError. I really like that. It makes finding bugs in your algorithm so much easier. Anyhow, your "last" getter would just return the element at index -1, which is exactly the same as the one at index Math.PI or index "your mom". It's `undefined`. The only difference is that you're the one who's doing it. Well, hate to break this to you, but you make the same mistakes as everyone else. When it comes to guessing, you simply won't be 100% right in each and every case. This hyper global stuff is super messy. There is a very high probability that it will cause some really ugly issues.
That audio "quality" makes it basically unwatchable. Anyone have a better link?
That's exactly the point. Modify *your* objects with your sugar, not someone elses. Do whatever you like in your playground, but don't touch the built in stuffs.
The number one 'related' link is 'How to Make Coffee So Good You'll Never Waste Money on Starbucks Again' :)
Thanks for this. Going to print it out and shove it in our front end developer's face on Monday. We've had never ending problems trying to do exactly what you've said we should not do. This doesn't surprise me in the least. BB models and basic polymorphism (the backend is java, spring, hibernate) just doesn't work. At all.
Have you looked into [component.io](http://github.com/component/component) and how it can help you use commonJS on the browser?
That's probably not what ES*whatever* would do though.
I actually had an issue too where someone added some 4rd party library that was exactly like this library and played with the Array prototype. Broke a whole bunch of stuff so we gave it the boot.
I've donated what I can. I really hope he is able to finish it.
Did my part too. I hope he can manage to get all the things in the list done too. 
At times like this I wish Youtube's automatic "Caption" would turn on. 
Bah they tracked me from last time and I can't even create a new account to ~~get without paying~~ sample their courses.
So just return null?
Well that's the JSPerf idiosyncrasy biting you - the setup is ran multiple times and you should never ever ever ever put static code there like that. Another problem is that chrome 31 has insane "perf boost" - not because it is actually that much faster but because the jsperf is setup in a way that allows compiler cheating. See http://jsperf.com/prototype-vs-factory-performance/9 But this is still really problematic since the perf comes from the ability to inline in the prototype example. The perf boosts from inlining are very sensitive to complex relationships with other code. Just to give you practical example: http://jsperf.com/charcode Here inlining gave x30 boost because it enabled dead code elimination and/or constant propagation (i.e. compiler cheating). Very radical difference from x1.5. It abuses the fact that [V8 can only inline String.fromCharCode if there is only 1 argument.](https://github.com/v8/v8/blob/4b20ee972f0eff1f87658295537aebe0a3b1f7b6/src/hydrogen.cc#L6829")
Bit of investigation suggests it's basically a package manager for CommonJS modules (like NPM), but with a build tool ('component build') like browserify, so you can use the modules in the browser. Is there something else I'm missing? I'm giving this talk again in a month anyway (hopefully with better audio), and it's certainly worth a mention, thanks!
Have you heard of [brainfuck](http://en.wikipedia.org/wiki/Brainfuck)? Some people just like obfuscation and a ridiculous challenge. I guess the interesting/surprising part here is that it's all valid JavaScript.
Looks very cool, gonna order it.
This style guide needs to be proofread, so many spelling mistakes
It'd be extra nice if this was connected to some webapp like documentor.io or something, and we could just press a button to push our docs to a subdomain like ourframework.documentor.io.
That was it. I've been using this to repurpose an enterprise webapp as self contained modules and found it very useful. Wanted to beat the drum for it a bit. 
Yeah, I'd argue it's worth it, in that it lets you bundle things into encapsulated parts with clear dependencies, and not then have to manage all of those in one place. You're right that this doesn't solve DI, but I'd argue that's a separate problem. Globals for modules aren't great, but the real issue is globally visible _state_; globally shared module names are less of an issue (and indeed every other language has them). Really the analogue to the more mainstream languages with this kind of thing built-in (say, Java), is that modules and their dependencies act as import statements, not constructor arguments. Most other languages include these kind of constructs that let you manage statically defined relationships between modules of code. Dependency injection meanwhile tends to act on the setup of individual instances; you'd typically depend on everything you don't want to actively inject, and then your module would return a constructor, which you'd use for DI for things that you do want to inject dynamically. DI tends to be less used in JS anyway though, since it's flexible enough that you can just mess around with things directly and avoid BuilderFactoryFactories (equivalently see [this classic](http://weblog.jamisbuck.org/2008/11/9/legos-play-doh-and-programming) on why Ruby doesn't really need DI tools). A quick google suggests some containers do exist, but I've never hugely played around with them myself. Notably the extra abstraction layer these tools give you means you can create things like [Squire.js](https://github.com/iammerrick/Squire.js/) which does let you dynamically swap out dependencies through RequireJS with mocks for testing and similar, and solves many of the problems you'd need full DI for anyway. Overall really the main benefit is encapsulation; you can easily mess around with each component separately in that one module only, and you've got a clear interface between that and everything else so you can reason about what other behaviour you might be changing. The loading and so on is very convenient and helps make this directly practical, but the core of the benefit is there once you get to IIFEs; the rest is just a drive to limit the extra boilerplate &amp; hassle that turns up otherwise (managing namespaces, file loading, inter-dependency ordering, etc). And yeah, it is lots of extra engineering, but the current system I'm building at work contains a few hundred modules, covering tens of thousands of lines of JS; there's no way it'd be manageable without some kind of scaffolding to hook it all together for us.
Made a markdown editor as well and was going to mark a snarky comment about image flickering but you actually solved that, so well done.
open a pull request? :)
Congratulations! It looks pretty slick! Did you run into any unexpected problems using node-webkit, or did it all go smoothly? How long did it take to complete the project? Edit: typo
Thanks, for the moment I'm hosting the binaries on my own servers. The repo is just there to fork.
Because I haven't gotten in creating one. Will get one up soon. Thanks! 
I didn't encounter any image flickering during development. 
I think you've been a bit too quick here. Why create a duplicate, when you can manipulate the original array? Also, there is no way to set using negative values. And in the get method, what is dummy? This would probably work a lot better: function negArray(arr) { return Proxy.create({ set: function (proxy, index, value) { index = parseInt(index); return index &lt; 0 ? (arr[arr.length + index] = value) : (arr[index] = value); }, get: function (proxy, index) { index = parseInt(index); return index &lt; 0 ? arr[arr.length + index] : arr[index]; } }); } But it's a nice idea and a cool use of proxies! Looking forward to them being available in all major browsers
I noticed they have a cache directory in the folder structure: &gt; services * cache What is that for? Never seen a cache folder (unless they mean for grunt temp folder?)
Can I quote you?
No, undefined. That's the kind of thing ES3 or ES5 would do. The question is, is this something ES7 or ES8 would do?
No just don't do it. 
I use forEach for arrays. Makes life so much more easier.
I wrote a CoffeeScript version of it. http://shovon.github.io/youcantcoffeescriptunderpressure/
Node.js for anything other than highly interactive client-server functionality is fools gold. It's a great little platform, but please don't abuse it.
can we keep this stuff in r/angularjs? 
Absolutely :) Preferred attribution is my twitter handle: @jeremymorrell
I agree to some extent. My problem with the module pattern in most languages is that they introduce tight coupling from a runtime perspective, and you need monkey-patching and similar techniques to break these couplings, in runtime. Code will import stuff and start instantiating objects using the API of the imported lib. This is where things go wrong. For true and efficient modularity, I think objects should state their dependencies in constructors and methods, as arguments. You should declare that you need an object that behaves in a certain way - you should not declare that you need a specific module with a certain name. Then use a few glue files that construct the object graphs. The glue files will not be modular and reusable, but the rest of the code will be. Perhaps module (import/export) pattern is appropriate in these glue files, in my opinion. To be clear, my opinion is that Node.js-introduced module pattern encourages bad design and tight coupling.
node+npm already do what you advocate in the package.json instead of as constructor arguments. Each package defines exactly the versions of dependencies it's compatible with and it gets only those versions, even if other modules in the dependency graph require different versions of those same depended-upon modules. node+npm resolves require() calls to the nearest node_modules directory so it's not quite true that module names are global.
For those that are curious: I'm using JavaScript on the client (obviously), and node.js on the server. This allows me to do nifty things like share code between the client and server. This is good for move validation. I use a handful of other new and sexy technologies: * react.js by Facebook * Typescript by Microsoft * Grunt by Yahoo * socket.io * raphael.js and some other cool stuff
As long as I can exit out of IE fullscreen, that is fine by me.
&gt;For session-level cache you can use $cacheFactory. This should be used to cache results from requests or heavy computations. http://docs.angularjs.org/api/ng.$cacheFactory
Also, did anyone manage to create an online game with someone other than me? EDIT: As of right now, there are about 10 online games that were created without my intervention, two of which were happening at the same time, and nothing broke! woot
It certainly would. I need a lot more traffic for there to be a reasonable waiting time. Fortunately, you can invite a friend to play with you via a private link! (this works for timed and casual games) EDIT: the number of active games and users at the bottom of the page is accurate, although this counts 'casual' games, which are largely inactive.
So, let me get this straight - in the example, because JavaScript is single threaded, it executes the for loop completely, before the event queue has time to start running - and in doing so, references the variable i as it was at the end of the loop. By wrapping our function in a closure, we are somehow associating a fixed, non-local variable with each function call which is then used when the console.log() function is invoked from the queue?
I didn't even know npm could do that, wow!
Very relevant for a lot of people I think, they are 3 less well known features, and the browser support is excellent: - insertAdjacentHTML() - getBoundingClientRect() - Table API
There are distinctions in some languages but I believe JavaScript considers all functions to be closures. Whatever variables were accessible in the scope that the function was defined in will also be accessible within the function, whether the function is actually returned out of that scope or not. 
&gt; The style is a bit sophisticated and hard to parse for new-comers and if you were to adopt its style whole-heartedly on a team project, you're teammates are likely to wish you bodily harm. That doesn't mean it's not good fun or useful to know though. &gt; In the end it's a different approach to JavaScript than you'll find in most other places and shines a light on some of the more elegant parts of JavaScript the language.--@jeremymorrell You sum up here why I don't do training and when I speak at conferences, I avoid technical talks. I'm not qualified to tell someone how to be a professional programmer.
I'm not sure why you're being downvoted but you are right so have some upvotes.
One thing to keep in mind is this sort of thing has been used by crackers before to inject code in websites. Someone may try to sanitize a string (like say it is invalid if it contains "function" or "eval") but this shows why that is very difficult to do effectively. If you allow a string to be executed as javascript somehow and it lets through the six +![]() characters, that is enough to do basically anything including evaling arbitrary code. That's why using JSON.parse is so important versus just evaling some text from user input (including the database). Edit: I'd also say that calling this jsfuck is a bit misleading. They both accomplish things with few characters and look a bit similar but while brainfuck is basically a simple stack-based language, this is more like a different way to encode a JS program within the language. Kind of like how a JS optimizer will replace variables with shorter names to save space, this is instead optimized for using as few kinds of characters as possible. It is still very clever but different from actually compiling brainfuck to JS (which I'm sure already exists out there).
Nice and clean introduction! Love the simplicity of explaining with GIFs.
Anyone else has issues with Vimeo? I feel like we're back in 2005 with all the buffering.
Go for the corners man. Try checkers. The AI there is brutal.
Hi, can you open an issue here? https://github.com/maxogden/requirebin/issues?state=open If you could include the chrome version you have, OS and any console messages that show up in Chrome Dev Tools that would help a lot, thanks.
But what happens when I want to use a mock or stub instead of the implementation in NPM, or equivalent? Dynamically, in runtime.
I'm not seeing any of the code load using the latest Chrome (30.0.1599.69) on OSX Mountain Lion. The error I see in the console is: `Uncaught SecurityError: An attempt was made to break through the security policy of the user agent`
Done
Cool, but forgive my newb questions: * are nodejs streams long lived connections? * Is the performance gain a trade-off by losing stateless connections? Anyone know how this works in more detail?
What's the difference with respect to BaconJS?
Much appreciated!
Most modern JS frameworks agree with that sentiment and include data binding.
* nodejs streams can be, or can not be, persistent connections, afaict. * yes, there are trade-offs in using persistent connections versus stateless.
No, it's better if experimental things aren't ever released in production browsers. Keep them in Nightly or Dev versions, for devs to mess around with and give feedback. Firefox and Chrome have been taking this approach for a while now, FYI.
Just look at the example that MSDN gave. They're trying to use all the prefixes, but leave off their own by accident. And there's literally no difference in behavior between all the different prefixes across browsers for this one simple API.
[::::][::]{''} I'm getting errors
I think you're thinking about streams the wrong way: in node streams are used as an api for all sorts of things, unrelated to http. You could make a stream that connects to the browser persistently via websockets or server-sent events, but you can use them in a totally stateless web server (or something unrelated to the web, like a file watcher or unix utility). For example, some database clients expose a stream interface, where each record returned by the query is an event in the stream. In a webserver context this could let you start rendering before all data has been returned, and stay totally stateless. 
Hey that's pretty cool, I can definitely see the value in this, since most other online gaming sites I've tried require registration, going through countless lobbies, tables, etc. Some even still use a Java applet... But this I like. No registration, no install, just share a link. &gt; There are 39 games being played, and 118 players online right now. It seems I'm not alone! That looks like a pretty quick success, if you ask me. [X-posted](http://www.reddit.com/r/WebGames/comments/1nyf18/checkers_chess_reversi_four_solo_vs_your_friend/) to /r/webgames :D
Curious about your experiences with react.js and socket.io?
AKA... process records as they are delivered instead of waiting an hour and a half for them all to transfer. Stream processing can also be useful for audio stream processing and all kinds of other fun stuff unrelated to text based data.
I agree, but it is what it is. I don't like when web developers use experimental features and don't update their code once it's standardised, so I think hiding some behind config options is alright in some circumstances.
Thanks for the x-post &lt;3
Socket.io: Documentation is non-existent. Once you get set up, it's beautifully elegant. All I really need are the .emit() and .on() functions, and the API is symmetrical between the server and client. It makes switching between server and client code a breeze. React.js: This one was a bit of a learning curve. I still may not be using the library in the best way. I think it's very innovative, and is really handy for things like the "my games" section and the move indicator in the game view. All of the markup is efficiently updated when I pass in just a few key value pairs. I also plan to implement switching between different layouts based on the screen size. This should be fairly easy. Once you get it, there's a lot of DOM bitch work you can forget about.
You're talking about making DI the default, right? This is an interesting idea and is how we do mocking for tests in React. Do you think it's markedly better than passing objects and functions as constructor params to objects in the module? Also, are you concerned that it will lead to ravioli code[1] situations that DI frameworks in other languages have caused? [1] http://c2.com/cgi/wiki?RavioliCode
Yes. Ravioli code? I think this is a problem mostly with people who are used to non-DI-style code. It's a problem of lacking experience and mindset - not of a general incomprehensibility of testable, modular code.
I find it amusing that a &lt; 100 line snippet has a name.
I like to name shit, fuck me right?
Conduit.pause() essentially fires a cancelAnimationFrame request. It is very possible to pass in time since last call. I will have a look into it.
Awesome, never thought of this! I'll have to play around with this concept now. :)
You're probably going to get a myriad of reactions to this question, but usually the consensus is usually [JavaScript: The Good Parts](http://www.amazon.com/dp/0596517742)
I you value your data (or your customer's data) it would be wise to reconsider using mongoloidDB. 
The consensus I've seen is that it's not for people new to JavaScript.
Professional Javascript
Great book, but definitely not a starting point.
Gotta love the second-to-last link :)
I'd look into getting either Professional JavaScript for Web Developers by Nicholas Zakas or JavaScript: The Definitive Guide by David Flanagan. After going through one of those two, Crockford's Good Parts book will be interesting reading. I wouldn't recommend it to learn from the ground up though.
You should probably add a check on your tick... for (var n in _t.pipeline) { if (_t.pipeline.hasOwnProperty(n)) { _t.pipeline[n](); } } ( edit: or if you are into it... shorthand: for (var n in _t.pipeline) { _t.pipeline.hasOwnProperty(n) &amp;&amp; _t.pipeline[n](); } ) If someone comes along and adds a prototype function to Object, you'll run their function every tick: Object.prototype.myFunction = function() { alert('this will be annoying'); }
Nope. I tried to open the video in Vimeo directly, still had massive buffering lags.
I more just need the delta time, now - then type of info.
Good point, I have added in your suggestion. Just to catch those times when people aren't using Object.defineProperty with enumerable as false.
Namespaces. Modular (prototypal) inheritance. That way you can write skeleton objects and extend from there, and reuse as you see fit. Take a read through this: http://addyosmani.com/resources/essentialjsdesignpatterns/book/
[Eloquent JavaScript](http://eloquentjavascript.net/) is a good starting point, although a bit outdated, you could wait for the second edition but that maybe a little while.
Look up the AMD pattern for javascript, it gives you a good structure to follow. It encourages you to break your different scripts into separate files which makes things more manageable. Also, look into closures, they are one of the main things that you need to understand when structuring functions and objects. Then look at prototype based inheritance (prototypical or prototypal). That's how inheritance is managed in the javascript worlds, which allows you to create more reusable code. Now, if you wanna look at something fun I've been working on to encourage people to structure their code, I've been working on an autoloading library that also encourages using namespaces. It also facilitates inheritance and generating different types of constructors using different patterns. So, shameless plug: https://github.com/b-heilman/bmoor More questions, feel free to message me 
Read Javascript the Good Parts by Crockford, watch his seminars. He isn't right about everything, however you can quickly learn about which parts of the language are detrimental to the health of your applications and how to properly utilise the awesome features of the langauge and embrace prototypal inheritance. Start using jslint or jshint, these tools will help you write better structured and correct code, static analysis is one of the easiest and fastest ways to spot errors. Learn to write unit tests, understanding how to write them will teach you important lessons on how to structure code correctly, it is also an excellent skill to have in a professional setting. Jasmine is a good toolkit for this. If you want to go further you can begin looking into the realm of more professional web app development, utilising dependancy management, commit hooks and automated builds. Yeoman is a great tool for this setup and when setup correctly will enable you to rapidly spin up and deliver new projects. Lastly, and necessary, learn to use a version control tool, SVN or Github, I suggest learning Git, just my opinion but it is a far richer set of tools for code management and social coding. Plus its nice to have a place to keep your projects ;) Good luck! 
Everyone's answers here are good, and they all go in different directions. This exposes one of the main features of contemporary Javascript development. The community is fragmented, with strong and often contradictory opinions that are not rooted in the language so much as in a philosophy or doctrine of development. It can be challenging to understand which bits of advice will help you with which approach. Javascript itself is breathtakingly flexible, and offers very little guidance around many of these issues. Alternately, you could see Javascript as frustratingly primitive, and requiring a coherent set of practices to address all these issues. But what are the issues? That's probably where you want to start. I will offer a handful of things you might like to think about, to make sure that you have all the pieces to the puzzle. * **Encapsulation.** The idea here is that "default" Javascript shits all over the global scope, which leads to poor reusability and spaghetti code. The module pattern and the namespace pattern both answer this concern. * **Object-orientation.** Straight prototypal inheritance is hard to understand, cumbersome to implement, fairly powerful, and framework-free. Personally, I prefer to work with frameworks, and to use an `extend`-style object orientation. Technically, you don't need this, but OO opens the world of design patterns, which might be useful in modeling your applications. * **Testing.** How are you going to write your unit tests? You are going to write unit tests, right? Just nod, we will believe you. Will you be using continuous integration? * **Internationalization.** God help you. * **Templating.** If you're doing serious AJAX/Web 2.0 development, you're probably going to have in-Javascript templates, and how you load them, compile them, etcetera will have consequence for how your code is structured. I think I'm in danger of rambling. For me, getting all the code laid out onto the filesystem takes two or three attempts, but several people have written many things about how it should be done. With each project, I reconsider each of my choices: Angular or Backbone? Qunit or Jasmine? Should I use Node and Mongo, or should I use Flask and an RDBMS? Jquery templates, Underscore templates, Mustache, something new? I still don't have concrete answers, but http://yeoman.io/ gives me plenty of new ways to shoot myself in the foot. 
If you like that de-minification you *must* look into [sourcemap](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/) It is supported by many minifiers (like UglifyJS, GWT, Closure Compiler), concatentors (like browserify, `grunt-concat-sourcemap` etc) and transpilers (like CoffeeScript, TypeScript etc). It works with Chrome and FireFox and can even work with node.js (using the `source-map-support` module). It is amazing.
Officially you can't recreate this in ES5, so there's not much you can do. Fortunately however, a previous version of this concept has been implemented and working in Chrome &amp; Firefox for a while. https://github.com/tvcutsem/harmony-reflect takes this and gives you a shim for the new spec (as here) that'll work based on that, so you can at least start playing around with it there in the meantime.
##AMD Pattern: Yes RequireJS is a good way to organize code. The best way? Maybe. Probably not everytime. ##Your pet project No. **I love that you're contributing to the JS community, but I don't think this project would be a good way for a newbie to learn JS.** I think if anything, it makes it harder to understand. From your examples: bMoor.constructor.factory({ name : 'HelloWorld', factory : function( message, definition ){ return new definition( message ); }, construct : function( message ){ this.log( message ); }, properties : { log : function( message ){ console.log( message ); } } }); var hw = helloWorld('HelloWorld'); console.log( 'derp' ); hw.log( 'HelloAgain' ); ... where did `helloWorld` get defined? Am I supposed to devine that from the thing above? Why do I need to write all that to create a simple class? How does that improve my experience as a developer? The above is functionally equivalent to: function HelloWorld(message) { this.log = function(msg) { console.log(msg); }; this.log(message); } var hw = new HelloWorld('HelloWorld'); console.log('derp'); hw.log('HelloAgain'); Perhaps you wanted a factory to create HelloWorld objects? That's simple too: function HelloWorldFactory(baseMessage) { var self = this; self.baseMessage = baseMessage; self.create = function() { return new HelloWorld(self.baseMessage); } } var factory = new HelloWorldFactory('Hello World'); var hw = factory.create(); var hw2 = factory.create(); 
It doesn't mention this, but in Chrome, if you set a breakpoint, then right click it and say "edit", you can make the breakpoint conditional.
One more slight modification. var myNS = myNS || {}; The benefit is that, while your namespace *can* be global, it isn't required to be. I have the option of keeping your third-party library locally scoped to only my library that uses it, or I have the option of keeping the library locally scoped to a module for a loader. Also, JavaScript is being used in more ways and in more places, NodeJS being the most well known. In most of these other environments, there won't be any DOM objects such as `window`. Your code will be more portable if you don't reference the DOM when you don't truly need to.
One popular solution today is to use Node Requires + Browserify to unify your libraries and expose them to other developers. See here: http://blakeembrey.com/articles/introduction-to-browserify/ Grunt is a really essential tool to read up on, too. I bring together Grunt, Bower, NPM and Browserify in the following little "starter kit", see here: https://github.com/mattdesl/browserify-template Further reading... http://killdream.github.io/2013/06/06/node-modules-to-rule-them-all.html http://esa-matti.suuronen.org/blog/2013/03/22/journey-from-requirejs-to-browserify/ http://codeofrob.com/entries/why-i-stopped-using-amd.html Prototypical inheritance important to understand, but tedious and ugly to use. In my experience, something like [jsOOP](https://github.com/MikkoH/jsOOP), [jsClass](http://jsclass.jcoglan.com/), or a compile-to-JS language like CoffeeScript is a good way to keep "object-oriented" JavaScript code clean and simple.
Namespaces are ugly and lead to cluttering the global object. A better solution is to use AMD or Node/CommonJS to manage your modules, and include a build to UMD for those stuck in the dark ages with global namespaces. See here: http://killdream.github.io/2013/06/06/node-modules-to-rule-them-all.html
Even if it's a single entry point namespace for an entire project?
Yeah; it still leads to cluttering and makes it harder for other devs to integrate into their AMD/CommonJS environment. Like I said; build to UMD if you really want to support non-module people.
Yeah, unfortunately prefixes will live in web content for a very long time (perhaps forever in some places). But hopefully future enhancements won't repeat these same mistakes. But sadly not everyone agrees (Apple, fore example), so who knows.
I disagree. DI has the very big downside of making it harder to statically follow the program flow (that is, reading the code without running it). I think this problem is amplified in a dynamically typed language where it's unclear what the set of objects that can be injected is. The upside is that you can swap out services for a new implementation which is great. But I think it's important to practice YAGNI when using DI: be sure that it's a service that you already need two separate implementations of. I'm really afraid that if a module system did this out of the box it would get really hairy really quickly.
I'm not sure if this will be helpful; I talk more about the language and learning it than I give practical advice. Practical advice might be, I recommend that you read [Backbone's source code.](http://backbonejs.org/docs/backbone.html) It is both an example of structuring javascript and a tool for structuring it. No matter what advanced tools have come up, the motivations and functions of Backbone have not become less valid. --- One of the key things you can do is figure out why more or less everyone uses immediately invoked function expressions. (function(){ //your code })() or: (function(context){ //your code }).call(this) This will introduce you to global and local scope as _important motivators_ for javascript modularity. We've gone through a lot of effort to avoid 'polluting the global namespace'--that is, just '[dumping] it all on one page' as you say. It's easy to tell you to look into AMD and CommonJS and namespacing in general. But they're _solutions_ to a problem that you have to understand first. IIFEs (Immediately Invoked Function Expressions) are a result of a language that gives you total control over your scope. Every time you begin the parentheses for `(function(){` you're creating your own private bubble. You're making a choice to hide away from the world, and somewhere in your function you will decide what to give back to it--even as you still have access to that global namespace. Unlike PHP's require (which runs code directly), C includes (which direct the preprocessor), Java's blocky packages or python's import (which essentially automatically wraps a script's namespace), because of how the browser runs code there is only _one execution path_ through your code when the page loads. This true whether or not you're adding multiple `&lt;script&gt;` tags or if you bundle your code together. Something like Require.js doesn't change this. Require.js is a means of building a bundle of your code that _doesn't_ rely on _ever_ touching the Global namespace. That bundling, or any other means of combining your javascript into one file, is very similar to the old practice of building an .exe, and Require.js is acting as a compiler's linker. Javascript programmers **continually re-implement and re-invent** features of other languages. CommonJS is similar to Python's imports, _but_ you control the name of the import. Java packages look like namespacing, except because javascript's namespaces are globally accessible they will be much more flexible. And if you continue further you'll find where javascript has built classes for itself, built inheritance and struggled with encapsulation. Underscore's \_.bindAll (as used in Backbone) replicates the instantiation of a new object by granting it copies of its class's functions--functions that you can _still modify_ because you're not bound by a language's `class` keyword. Because you're a javascript developer, you can study the _code_, the _concepts_ that *make other languages work*. --- There is not one single coding practice, I think, that delves so rapidly into concerns and conversation about javascript, the unique and powerful language which runs natively in the most ubiquitous platform on earth, as IIFEs. 
There are 2 main patterns to class-like Javascript and therefore namespaces. The first is object declaration with this.function inside the parent function: //also, function myNS(){ ... } var MyNS = function(val){ this.val = val; this.getVal = function(){ return this.val; }; }; The other is prototypical inheritance: function MyNS(val){ this.val = val; } MyNS.prototype.getVal = function(){ return this.val; } They both essentially do the same thing in this order, but the prototype method uses slightly less memory since the getVal function isn't copied to every myNS object, it's referenced by all myNS objects. Prototypes are good if you want to extend an object with some function, such as: var ns = new MyNS(2); var otherNs = new MyNS(4); var val = ns.getVal(); //2 var otherVal = otherNs.getVal(); //4 //extend MyNS MyNS.prototype.setVal = function(val){ this.val = val; }; ns.setVal(3); otherNs.setVal(5); val = ns.getVal(); //3 val = otherNs.getVal(); //5 This can be compared to the first type of class architecure (non-prototype): var ns = new MyNS(2); var otherNs = new MyNS(4); var val = ns.getVal(); //2 var otherVal = otherNs.getVal(); //4 ns.setVal = function(val){ this.val = val; }; ns.setVal(3); otherNs.setVal(5); //Exception: otherNs does not contain function setVal //the previous would stop Javascript execution, but here are the values anyway. var val = ns.getVal(); //3 var otherVal = otherNs.getVal(); //4
 else if (typeof global.define === 'function') { global.define(function(){return SomeClass; }); } ... Reads a little easier.
From my experience, trying to conform javascript to traditional class/object structure seems to cause a lot of hassle. It was natural for me to begin my project by structuring code into 'traditional' class format, but I'm starting to regret it. There are lots of required tricks and resulting snags in achieving that familiar look -- a lot of learning which is not necessary in writing proper javascript. Much is unintuitive to another novice reading the code. I recommend simply using the stripped-down, prototype inheritance with code grouping, comments, and well named files. It's easy to understand and teach the prototype technique, so long as people actually write javascript that way. As I said, I'm a novice, so take this with a cup of salt.
Verlet integration is awesome! http://mattdesl.github.io/knit.js/examples/web.html
nice!
It frustrates me that this is not further up with more support.
Can right click right away to put a conditional breakpoint!
An other great one is the debugger; statement Just put it somewhere in the code and open the inspector. it works just like a breakpoint, but less flexible.
I just broke up a 1200+ line js file into all of it's different backbone models/views/etcs and require.js has been super duper sexy. I can't complain too much since I wrote the core of the original file before I had a full grasp with what the project entailed but being able to take some time and clean it up had been quite lovely. (At the same times, took out dataTables which was nice but too cumbersome for what we needed at work and just made a simpler backbone based grid).
I'd add to your list **Functional programming**. One of the reasons Javascript is a compelling language is that you can use a function to build other, more specialized functions. Also, a functional approach limits side effects and dependencies, which makes things far easier to test.
It's also largely whats happening under the surface with jQuery. Unless you really are sticking to just modifying the DOM, getting positioning, or adding parts to a table, you're just as well off with jQuery. It provides common methods that most novices at jQuery will even recognize and understand how to use.
http://yuiblog.com/crockford/
If you want to debug JavaScript online in real-time, you can do so using [Liveweave](http://liveweave.com). It shows you the list of warnings/errors while you write your JavaScript code. Its worth a look.
That's quite a strong opinion. Any particular reasons why?
Oooo that's a good one
http://www.html5rocks.com/en/tutorials/webrtc/basics/
Keep doing it in whatever way makes sense to you, and change your approach when doing it that way starts to hurt. This will give you the best understanding of why it's a good idea to do things a certain way, and protect you from cults.
No, I get the gist of what node is doing here: pipes, stream sockets, etc. all have similar interfaces, but require different programming. It's very handy for Node to say "hey, this is just a stream, use it". But, I thought all streams have to be stateful to guarantee the correct sequence of their messages, right? Maybe we're talking about different layers in the OSI model? &gt; In a webserver context this could let you start rendering before all data has been returned, and stay totally stateless. Right, but... so what do you mean by 'totally stateless'? Let's say the original query was user names sorted alpha by last name. If the response is totally stateless, how does the client know the correct order to render the users since the individual users may arrive in a different sequence than they were sent? 
[Agreed!](http://bluethen.com/secretapplets/superFabric_Jello_JS/)
Event Listener breakpoints are another good trick. In a complex page it can get difficult to figure out who's stealing some event, or what the hell is going on with setTimeout()s and so on. In Chrome, you can go to, say, Event Listener breakpoints &gt; Mouse &gt; click, and the execution will pause the next time a click listener fires. Same for key events, touch events, timer events, and so on.
This was posted yesterday with a different title (same sub). &gt; [Thinking Inside The Box With Vanilla JavaScript](http://www.reddit.com/r/javascript/comments/1nwbyp/thinking_inside_the_box_with_vanilla_javascript/)
I suggest reading **[what have you tried?](http://mattgemmell.com/2008/12/08/what-have-you-tried/)**
**[JSFiddle](http://jsfiddle.net/sAZAN/)** function Profile() { localStorage.profileBack = prompt("What is the background color/image you want?"); localStorage.profileText = prompt("What color should the text be"); alert("Ok I have made the profile, what should the name be?"); localStorage.profile = prompt("Enter the name of the profile"); alert("Profile made now just type the name into the change background and you are set!"); } function Color() { localStorage.color = prompt("type a color you want. Or you can make a background image using this format: url('put image url here')"); document.body.style.background = localStorage.color; document.body.style.color = localStorage.Tcolor; //text color if (localStorage.color == "black") { document.body.style.background = localStorage.color; document.body.style.color = "white"; } if (localStorage.color == "nathan" || localStorage.color == "Nathan") { localStorage.color = "-webkit-gradient(linear, left top, left bottom, color-stop(0%,rgba(125,126,125,1)), color-stop(100%,rgba(14,14,14,1)))"; localStorage.Tcolor = "white"; document.body.style.color = localStorage.Tcolor; document.body.style.background = localStorage.color; } if (localStorage.color == localStorage.profile) { localStorage.color = localStorage.profileBack; localStorage.Tcolor = localStorage.profileText; document.body.style.color = localStorage.profileText; document.body.style.background = localStorage.profileBack; } if (localStorage.color == "") { alert("Please type in a color or image."); } } function TColor() { localStorage.Tcolor = prompt("What color should the text be?"); document.body.style.color = localStorage.Tcolor; }
lol, looking like promotional stuff to me.. 
Huh, never heard of "cargo cult equality" referring to `===` before :). Is that widely accepted? As for using it or not, you are correct that it could be a bit confusing. I think the reason I use it is because [JSLint](http://www.jslint.com/) complains when you don't use it.
Not complicated: The example is **defining** functions in the for loop, **not executing them**. Their reference to the variable i doesn't matter during the for loop because the function isn't executed until 100ms later, well after the for loop has finished, i is just sitting there with a value of 6 at that point.
Yes fuckin seriously, why not? 
One simple way to think of them comes from english. ie think of expressions as phrases or idioms and think of statements as being composed of them ie expressions put together make up a statement or statements are made of expressions + other elements. In Javascript, think of expressions as "having a value" and as statements as commands to the interpreter, terminated by a semi-colon. Here's a link with more info. [Ref](http://www.2ality.com/2012/09/expressions-vs-statements.html)
I think of expressions as calculations, e.g. `Math.PI * Math.pow(radius, 2)`. I then think of statements as commands to the interpreter, like `var area;` (i.e. "Hey JavaScript interpreter, declare a variable called num"). You can then have a statement that contains an expression: `area = Math.PI * Math.pow(radius, 2);`
The lines can get blurred a bit... this is a statement using an expression -- x is either true or false depending on if y is 5 or not : var x = y == 5; The following is ... usually a mistake... but there are no syntax errors, or anything. if( x=true ) { /* always true */ } else { } if( x=false ) { } else { /* always false */ } This is because of the single equals sign -- the x gets set to true/false &amp; this evaluation is returned to the if statement.
Checkout latest feature of "Object.observe" making way to browsers native javascript support.
Ha, at first I didn't even click on the presentation, thinking "why would you need to implement logins for your Javascript applications when there's Persona", and it actually was about Persona :) And I didn't even think of using a Node.js library to verify the user, so I took something away that just now comes in handy as well.
[*zing*](http://this-plt-life.tumblr.com/post/36425234294/when-i-see-that-a-new-language-makes-a-difference)
Vex looks like something I could use. Right now the UI for my project is just a big long list of HTML tags. 
It looks very neat and tidy, but the result makes me wonder: is there a trade-off with performance when using functional style in JavaScript? Is it worth it to loop the same array that many times, and call a function on every element? The original code did everything in one loop (which could've be a inline for-i loop instead of a each()), but now we have a huge bundle of function calls. I'm not saying this is wrong, but I'm curious what others think about this. What if you have 5000 elements in a complex app that has to do many other things besides this single method?
Thanks guys, like i said I'm new so could someone explain how to use an array i know what they are but i have never understood how to use them.
thanks this is something I will have to go over a couple times until i get it, but thanks! 
This question is a bit vague, but make sure you have read the [Chrome Dev Tools Docs](https://developers.google.com/chrome-developer-tools/). Especially Keyboard Shortcuts, Tips and Tricks, and Console/Debugging info. You'll definitely learn something useful if you haven't actually looked at the docs. Or even if you did some months ago, there's probably something new in there by now. Related to that, I haven't used it yet but [node-inspector](https://github.com/node-inspector/node-inspector) is supposed to let you debug node apps in Dev Tools. [Underscore.js](http://underscorejs.org/) is pretty necessary IMO. [Moment.js](http://momentjs.com/) if you need to do anything with dates and times. Edit: Use a linter in your editor! It will save you tons of time by preventing most silly mistakes and usually you can configure the options if it is too easy/strict on your code. I'm using [SublimeLinter](https://github.com/SublimeLinter/SublimeLinter) for ST2.
First off, read [this](http://stackoverflow.com/questions/14994391/how-do-i-think-in-angularjs-if-i-have-a-jquery-background) and try to use neither. Then use jQuery when you need it. For me, the best comparison of mootools and jQuery is looking at these two pages: [Mootools Github Pulse](https://github.com/mootools/mootools-core/pulse/monthly) [jQuery Github Pulse](https://github.com/jquery/jquery/pulse/monthly) The jQuery singularity, good or bad, is undeniable. For what it does, it's the best choice. But as you start moving toward the MVC "heavy front end" style, you'll start to see that what jQuery does is make trivial UI manipulations more bearable. So the war is over, but the importance of DOM manipulations has diminished. 
You can create Grunt tasks for absolutely anything you need to speed up your development, it's not just about dealing with frontend assets and running a server â€“ you could create a task to create a partial and include it, or run unit tests, or create documentation...oink.
This is by far the best article about functional programming I've read! Awesom-O!
&gt; hen Angular is a better replacement than Backbone or Ember by far, IMHO. Why? Why Ember, speceficly, as it's closer to angular, than backbone is to either 
Automation. Automated unit tests, texture packing, image optimization, minification, FTP deploy, LESS compilation, browser reload on file changes, doc generator, etc. Especially useful if you plan to use Node requires with browserify (i.e. CommonJS). Probably one of the most useful JavaScript tools I've adopted into my workflow. 
They can all be done with package.json scripts and node modules. I still don't see the point.
I've not seen much of AngularJS, but my first impression is that it is more widget-focussed than an MVC-framework. What makes AngJS a better MVC-framework than BackboneJS? What is the status of Vanilla? It didn't show up in my search for a stable, well developed MVC.
I don't know much about Mootools, but modern Dojo is nice to work with. It's a commitment to use it well, but at least in my use cases it has been very nice.
That's always a tradeoff and a concern that most functional developers overlook when starting off. I've seen a fair amount of code that could be optimized by changing the order (running filters before other operations), but some devs simply don't think about it. To more directly answer your question, yes, it will slow down the algorithm with that many loops vs. doing one loop with some integrated logic. Sometimes the compilers can negate some of that, but for the most part it will take longer to process the same amount of data using a functional approach unless it's very carefully crafted for performance reasons. That said, functional programming can be very freeing and awesome when it's done well. Also, when dealing with a small number of records where a few milliseconds won't matter anyway there's not much of a concern. Modern CPUs can tear through most of the operations you need in enough time to still remain responsive. If you are trying to optimize for several thousand/million records... it's almost always better to go with as few loops as you can get away with. You don't want to have to touch that data anymore than you have to.
Expressions must be evaluated, however statements do not necessarily need to be. If you think of a program there are choices it has to make. If it doesn't have to make a choice, its not an expression, its a statement. If it does have to make a choice its an expression AND a statement. This doesn't really have any use other than in compilers. Statements imply different optimization mechanisms than expressions. The goal of a compiler is to get everything to *pure* statements. For example: function q(a) { var a=a+1; for(var i=0; i &lt; 10; i++) { a=a+i; if(i==5) return a; } return a; } z=q(1); This is pretty silly statement made up of expressions. A compiler detects expressions by reduction until it cannot determine at compile time what the value would be. Even though above may look like a collection of expressions/statements the compiler is smart enough to determine this is actually a statement, not an expression. And the statement is: z=7; There are no choices. z will equal 7 no matter what happens. Pure statements are thought of as constants. But what happens if we change the last line to: z=q(Math.random()), well then we have an expression, an unknown value that choices must be made at runtime to determine. This one expression Math.random() has a compounding affect of making anything that uses it an expression as well. If "inlined" this would reduce to: z = Math.random()+6; Which is an expression Math.random() with a potential (non-pure) statement x = {} + 6;. Compilers can give up at this point as its unknown how to further reduce it to a pure statement (constant). "Pure" statements have a runtime of max 1-4 processor cycles. Compilers measure the amount of effort of each statement by how many approximate processor cycles it takes. Depending on compiler settings it may optimize to reduce the number of approximate processor cycles by getting items closer and closer to pure statements. This however can be a burden on memory. Consider if you let everything be expressions (e.g, non-constants) you can reuse quite a bit of memory. E.g., a = 1; ... something ... a++; ... something ... a++; ... something ... This would only take up 1 word of memory, but would require pushing and pulling data from memory wasting cpu cycles. This is an expression in this case. A compiler can either leave this as is if it wants to save memory, but if it decides to expend memory for cpu cycles it can rewrite it as statements: a = 1; ... something ... a_ = 2; ... something ... a__ = 3; ... something ... This takes up 3 words of memory, but does not require as many cpu cycles. Ultimately understanding expressions vs. statements allows a programmer to weight cpu vs. memory needs when programming, however this was only relevant when compilers didn't do amazing jobs at optimizations, there were types and there wasn't garbage collectors. In javascript its kind of a moot point as you have little control over it. **TL;DR: Statements take memory+cpu cycles, expression take cpu cycles, pure statements just take memory. Compilers use the abstract understanding of statements/expressions to make choices on how to optimize, but its fairly a moot point in javascript.** 
May I ask what kind of cases those are?
You're 100% right on that. But the article is more about DOM manipulations - not the language itself.
So... because an alternative exists it doesn't belong on his list?
Because grunt configuration is ridiculously verbose for what it does and composability is difficult/impossible?
There are some languages, e.g. Haskell, that are highly optimised to deal with this style of programming, because they have lazy evaluation. JavaScript, not so much. Using a single `each` in JavaScript is much more efficient, as it only iterates over the array once, instead of multiple times. In some ways, the final product of the article is a little easier to read, but I would argue that filtering the list should not be done as part of the `averageSalary` function. I would probably write it as function getAverageSalary(employees) { return average(_.pluck(employees, 'salary')); } then do var filteredEmployees = _.filter(employees, function () { ... }), averageSalary = getAverageSalary(filteredEmployees); Brian Lonsdorf has an article called [Hey Underscore, You're Doing It Wrong](http://www.youtube.com/watch?v=m3svKOdZijA)(YouTube), where he suggests rewriting Underscore itself such that `getAverageSalary` above would just be var getAverageSalary = _.compose(average, _.pluck('salary')); which is even clearer, and uses point-free style. For the most part, though, I prefer the look and style of dot notation. Since we don't care about efficiency, if readability is the end goal, and assuming I could rewrite Underscore, I would write the function as follows function averageSalary(employees, conditions) { return _(employees) .filter(conditions) .pluck('salary') .average(); } I'll leave with one of my favourite quotes about functional programming: &gt; Functional programming combines the flexibility and power of abstract mathematics with the intuitive clarity of abstract mathematics. -[xkcd](http://xkcd.com/1270/)
[Image](http://imgs.xkcd.com/comics/functional.png) **Title:** Functional **Alt-text:** Functional programming combines the flexibility and power of abstract mathematics with the intuitive clarity of abstract mathematics.
**Ember is great**. That said, **Angular is better**: 1. **Built-in Module Pattern** Newbies to JS don't need to know module patterns, as they're forced into one. 2. **Built-in Dependency Injection and DI container!!!** Angular was **built around the idea of DI and testability**. Newbies to OOP best practices (SOLID) are forced into better practices. 1. **Minimal Boilerplate.** 2. **Plain JavaScript objects as models** for.. 3. Two-way Binding 4. Routing 5. All binding to and from the DOM is handled with simple markup. No JS required unless you need a custom binding for something. 6. Reusable "controls" (directives) 7. Reusable formatting functionality called "filters" 8. No JQuery required, but it works well with existing JQuery plugins if necessary. 9. **Lots of great test harness tools built around Jasmine and WebDriver.** The list goes on and on. Ember has most of the above features, but it's not really "built around" DI... that's a problem for me as a JS Dev Lead. I need to force my junior devs into DI or they just won't do it... because they don't get it.
It's funny, I had that on the list to start, and then I took it off again. It was the inspiration for my "maybe I'm rambling" comment. I'm not convinced functional programming is a good thing, but it definitely appeals to a lot of people. I am reasonably confident that closures-as-used can make testing and debugging very challenging; the AMD module pattern is currently on my "reconsider your advocacy" list as a consequence.
Angular directives are the new jQuery plugin
worse than jquery plugins , at least you can use jquery plugins with any front end frameworks. How am i going to use a directive with Backbone or Ember ? The stupidity of this is the project could be seperated in a standalone text editor , and a directive for AngularJS. 
Stop trying to make SPA happen. It's not going to happen.
The term; not the architecture. SPA is a stupid term pushed by microsoft
&gt;What is the status of Vanilla? Vanilla JS is literally plain JavaScript. That website is a parody of people's overuse of JS libraries when many things can be accomplished with regular old JS that comes in every browser.
Never had an issue with angular fitting my projects and I've used it quite a bit at the startup I'm working at. Do you have an example of things that should be easy but aren't in Angular?
Do you mean something like this : http://jsfiddle.net/4Mw9E/ ? (Please test with Firefox only. Does not work with Chrome which pretends "textContent" has a data descriptor and not an accessor descriptor... x_x )
Yeoman changed my development process for client side apps. Seriously amazing and honestly I have no issue with Grunt.
Looks nice. Add some tooltips to the toolbar though. I honestly don't know what the circle with the slash through it is supposed to do. 
Sorry, I misunderstood your original question. Lack of coffee in the morning =] This might get you started down the right track: http://jacwright.com/438/javascript-data-binding/ Note that there will be limitations regarding certain nodes in the DOM. Not much you can do except work around them.
Expressions return a value. Statements have an effect.
Haha. That's pretty accurate, actually. Here comes another Angular/anti-Angular flamewar, I bet. 
Angular is not that far from classic JS. Do you have a JS constructor that you want to use in angular? Just wrap it in an angular factory and you are done! Doing it other way around might be trickier since the stuff that is injected cannot be injected if you take that component out, but still-if you have a component that works without angular you probably should not have any critical dependencies injected anyway.
It's silly. I don't like have abstractions forced on me unless they add value. Backbone's low level abstractions of models collections and views are where it's at.
someone should put it up on http://ngmodules.org/modules?query=textAngular
You haven't tested you frontend JS code much did you? That is all right. Most of us did not.
Angular directives are for extending the DOM with new widgets. A text-area is a widget. Good use of directives! I know what you mean about jQuery plugins - jQuery.DateParser, jQuery.Addition... ;) The problem in both cases in when they were not related to UI, not the concept itself.
You really need some kind of laziness to get reasonable performance with many loops. Then you can do: lazy(listOf1000Things).map(x).map(y).filter(z); and know you'll be iterating max 1000 times. [There are libraries](http://danieltao.com/lazy.js/) 
Lot less annoying than "SPA" imo
There's many ways to write testable js. I was doing it years before angularjs came onto the scene, and i'll be doing it for years after it's gone.
Expressions are something: statements do something. Values: flow control.
Seems that if you have duplicate properties then the log will show the `__proto__` value too. `console.dir(y)` to see what I mean. [\_\_proto\_\_](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto)
`reduce` is the general tool out of the functional enumerators, you can express the rest in its terms (not that it's a good idea). It's also nice, and more efficient, in cases you realise you need to map + filter (or other combinations). Map + filter: things.reduce(function(all,thing) { return test(thing) : all.concat(transform(thing)) : all; },[]);
Nothing specific to Javascript - just have a look at the arithmetic involved on Wikipedia etc.
Angular is one ecosystem, that's kind of the point. Yes directives are a huge chunk of Angular but that's what its based on, extending HTML. Even adding ng:app="App" to an element is a directive but thats how you initialize the app and ng:controller creates your scopes. I could see you're point when working with backends (which I use Flask vs Django) but for a frontend Angular is amazing. I can have a page controller, a data list controller on that page and hell I can even do data item controller. Because of those directives you don't like I now have scope inheritance with data binding included but each child scope is isolated from its parent. Services allow for cross controller communication. You can send events up and down the scope chain. If you are using Angular you know what you are buying in to. If you try to piece it apart of course it falls apart. If you are wanting the two way binding of Angular, the collections from Backbone and the non data binding DOM manipulation in jQuery then your project will become a mess fast. I would not want to work on that personally. Of course I prefer coding over structuring so maybe you have a system that works for you. More power to you.
I'm sympathetic to make over grunt, but requirejs is solving a completely different problem to commonjs: lazy loading and no compile requirement in the browser...
Interesting, thanks for the response!
Every time I have to admin our Joomla 1.5 site, I shake my fist in anger. Finding docs for my particular version of Mootools (I can't remember at the moment) is impossible. Half the examples I see don't apply to me, and therefore don't work. It's personal preference, but I hate it... with a passion. In my job I have to support Dojo, jQuery, ExtJS and Angular. And each has its quirks... but mootools just bugs me. But opinions are like belly-buttons... and mine doesn't mean any more than anyone else's. I try to write all new apps with no libraries unless absolutely necessary. Since I do quite a bit of webmap applications, Dojo is the first that gets injected as it's a requirement for ESRI's JS API. Otherwise, if I'm not doing a ton of DOM queries, standard JS is fine. Angular makes a ton of that go away.
I'd like to hear more on this, as I'm an avid backbone.js user and find it gives me plenty. And I'm not sure how a JS library can have an opinion :)
Internal "enterprise" web applications
I am actually surprised that you have not heard the term "opinionated" with respect to Javascript frameworks, especially working with backbone, because that is where I learned what it meant. 1st, the abramz definition of an opinionated framework - An opinionated framework is framework that makes decisions about things for you. For example, backbone has an opinion about how you will structure your backbone app, there is 1 way and it is the backbone way. Angular is opinionated in this regard as well. Another example in backbone would be how you interact with your views. 2nd, backbone is too opinionated for what it gives you. When you agree with the opinions a framework makes, then it doesn't really *feel* opinionated, you either have no problem doing it that way or you would have anyways. When you disagree, it feels *more* opinionated because you are kind of fighting the framework and wondering why they did X and what the point of Y is etc. Since I do not agree with several of the things backbone locks you into, I feel that it is too opinionated for what it gives you (basically a way to bootstrap your app and not much else IMO). 3rd, backbone is too big for what it gives you. 6kb packed and minified is actually really small. But this is just for backbone, underscore is mandatory and 5kb packed and minified. Now we are at 11kb. Backbone doesn't come with modelbinding in it's core library either, since every non-trivial app deals with data we should probably add Backbone.ModelBinder (10kb ish, I can't actually find how big the packed and minified version is but it looks to be around 10kb) or something else. Now we are up to 22kb and we only get one-way model binding. Contrast that with angular (without addons) at 30ish kb and what you get for the size weighs heavily in the favor of angular. If nothing else, I wouldn't use backbone because of the model binding. When angular, knockout, ember, and other frameworks give two-way model binding on top of a whole load of other features. Also, after angular 1.2 (soon^TM ) comes out they are going to work on splitting up angular into more files so that you can pick and choose the modules that you want for your app. This will decrease the size and allow an a la carte style offering. edit: formatting
There doesn't seem to be any correlation between these libraries. Or any common use case(s) - often the examples provided can't be used together or compete with each other. Am I expected to be able to leverage physics.js with LiveScript? On a harp server with keypress enabled? The statement may as well be "Existing code speeds up coding." - in which case no examples would be necessary.
This guy apparently never heard of RequireJS
The amount of errors and approximation in this thread is staggering. In JavaScript, an expression is anything that can be put at the right hand side of an assignment. a = what() + ever ? is_legal : here It can be a simple expression (a variable, number, string, function expression, function call, array or object literal...) or a compound expression (simple or compound expressions assembled with operators). Assignments are actually also expressions. a = (b = 5) Here, `b=5` assigns 5 to b and returns the number five, which is then assigned to `a`. A JavaScript program is a series of statements, optionally delimited by semi-columns. If semi-columns were mandatory, they would strictly delimit statements. Examples: var a = 5; foo(); 8; // any expression can be a statement. if (bar){ // the if block is a statement. // nested statements ... };
Well, this is really a bit more than the if statement, as you have to deal with obtaining the form value and modifying the style of the element(s) you want to change. Are you using straight JavaScript, or a library like jQuery or Dojo? 
Im trying, really not sure how to do it..
Or YUI3, which was doing asynchronous module inclusion before it was cool.
If you've got an image, like an &lt;IMG&gt; tag that is greyscale, I'm not sure if there's a particularly easy way to inject colour into it. Maybe you could load the related src in the background with an xmlhttprequest, look at the binary of it &amp; perform manipulations, turn it into a data uri and inject it back in to the page.... but that that would be incredibly difficult, if possible at all. I'd use some smoke/mirrors -- have two images, one with greyscale the other with colours, load both of them &amp; change positioning/display based upon user event .... unless this is like a dynamic image that people are uploading... come to think of it, there's tons of server-side libraries that can do image maniuplation ... maybe [gd](http://php.net/manual/en/book.image.php) can do that? I'm not sure and am not that familiar with it .... I bet you can find some way to inject colour into a greyscale image using free software, somewhere.
That looks pretty good! Thanks.
Yeoman is neither part of Grunt, nor a web server. But I'm not surprised that we can't get this right. There are so many new technologies, all tailored to do different and overlapping things. "Just attackclone the grit repo pushmerge, then rubygem the lymphnode js shawarma module" Personally, I'm not sure what the need for Harp is. Whatever niche it occupies is pretty fine-grained. Doubtless Harp will have wonderful things that other tools don't have, along with annoyances that other tools don't have. I don't see a need for it in my own workflow, but some people will see it as pure cookies and rainbows.
Mmhmm. No real web applications are built on these weird ass technologies... it's just for people to pad their resume and create blog posts.
If he doesn't understand Javascript, jumping to JQuery is a silly move. 
Take a look at the source code in my little [binders](https://github.com/dfellis/binders) library. It's possible to accomplish this with ES5 getters and setters.
sorry, I meant sticking to the grayscale, that is within the grayscale the pixalated values from the grayscale..Im not looking for color
Dirty checking (common in memory management) is a fair approach, but from my testing it seems both chrome, IE10, and firefox (their dom css,props,etc; along with normal objects) all allow overriding normal properties with get/set with properties. There's also the Proxy proposal which also does a similar (albeit has different strengths and weaknesses) than harmony's observe, and is already available. What i'm weirded out by, is actual native two-way binding with get/set props is completely doable. Why hasn't someone done it?
Seems somewhat to the point of the post. I'll have to look a little further, but it doesn't seem to implement two way, just one way. But one way very well. I'll have to look into it further, seems promising. 
Really? Didn't know that... :-P
Why is it wrong? The websites front page mainly focusses on data binding and dynamic texts, while Backbone's introduction has three important words: 'models', 'collections' and 'views' (OK, two of those are important, collections are a bit overrated). The whole live data-binding business is not really an important feature; I'm not afraid of a little DOM-manipulation. Moreover, the app i'm developing requires me to do DOM-manipulations, so the whole 'with AngularJS no DOM-manipulations no more' doesn't really cut it here. What do you mean by 'too opinionated'? Why are you not too opinionated about Angular? I think Backbone gives me a lot, namely an MVC-structure, just what I am looking for...
I've never had any problems with Mootools versioning. Personally I love Mootools because it is logical and structured the same way troughout, and it's very extendable. jQuery bothers me for having a different approach for every problem. But as you say, that's just my opinion. Working with no libraries is not really going to work for me. I'm writing an extensive one-screen web-app that requires a lot of dynamic interaction with the server and dynamic DOM-manipulations. 
Well, great. Thanks. One thing. I'm not an newbie. I love the whole 'let's make things easy'-approach, but I see myself as an experienced user. I've done a lot of back-end programming (PHP, then Python), so I know my OOP. I've done tons of front-end programming, mainly in Mootools, so I know my JS. DI. Awesome. But when I write my injections myself (which is quite easy in Backbone), I have more control. Boilerplates. Never have been afraid of a little Ctrl-C, Ctrl-V. Moreover, less is not always more. If a smaller boilerplate means I have less control, I'm not too exited immediately. I'm looking for the perfect balance, but haven't found it yet. So, really, I'm trying to find that one perfect framework for me to develop quick but well. I'm not interested in dumping JS, I'm interested in structuring it. If the main arguments for Angular remains that it is great in data-binding, I'm not convinced I should use it.
when your expressions are side effect free (as they should) it's kind of a [moot point](http://en.wikipedia.org/wiki/Predicate_transformer_semantics) to distinguish between expressions and statements
No argument, there are other libraries that do kinda the same thing. But, at some point we have a responsibility to our users. Should we really be loading all these different libraries and frameworks to accomplish something. Or, should we learn how to do it ourselves, and make it happen in just a few lines of code.
I don't get it. They talk about Backbone and Angular and whatnot, but it's a server that only serves static content. What's the point of using Backbone unless you have data that needs to be persisted to or retrieved from the server?
Does anybody else have anything to say on the matter? Soon I will be trying to push my team towards AngularJS, and I'd love any advice I can get. Nice article, btw.
&gt;The websites front page I have nothing to say
I got by just fine learning Angular before Javascript. They have very little in common so its more than just a little ajax service. Without directives you still get dependency injection and data bindings, along side of all the new html tags like ng-repeat. Using Angular for every spa project, and stripping it out at the end if I'm not using it for enough has served me well. In almost every case angular makes my life easier, but dealing with $resource was a nightmare initially.
[Here's an example.](http://jsfiddle.net/wQaD8/1/)
I'm not sure what you mean by "closures-as-used", can you elaborate? I think it's obvious that functional programming as an approach has immense value. There's a reason why languages like Haskell, Erlang, Clojure, and Scala exist; and there's a reason why they have good adoption for problems like large-scale data processing, parallelization, and analytics. Adhering to a functional paradigm can be challenging in Javascript because it's dynamically typed, because it has an implicit global scope, and because data structures are mutable. But all you really need for a functional language is a lexically-scoped first-class function primitive that can can return other lexically-scoped first-class function primitives. All the other beautiful things in FP fall out of that one language feature. 
Why should we use Harp? A little context would help, such as answering, "How does Harp compare to...?" * Express * Paperboy
how is this different than one of the many other logger suites available? 
 [enquire.js](http://wicky.nillia.ms/enquire.js/) is quite nice
Personally, I felt I was restraining myself from being a dick quite well. &gt; The websites front page mainly Please google "first impressions of angularjs", then compare the results with "I checked out their front page and based solely on that, I am going to say that angular is for widgets and you can't do DOM manipulation". Basically what I am saying is, you didn't get a first impression of the framework, you glanced at their website for 2 seconds and decided you know everything. (Assuming what you said in your previous post was truthful and accurate) &gt;What do you mean by 'too opinionated'? I talked about opinionated frameworks somewhere else in this thread, you can look at my comment history if you are interested. Otherwise google "what is opinionated software" and learn what it &gt;Why are you not too opinionated about Angular? That is not proper usage, please look up what opinionated software is. &gt;I think Backbone gives me a lot, namely an MVC-structure, just what I am looking for... Backbone does give you an MVC structure and not much else, which may be what some people need. People should not be locked into a particular framework as each framework is defined to solve a particular problem or set of problems. For your use case, backbone may make sense, but for mine it may not. The next project I work on, I might use flight, or ember, it all depends on what the problem is and which framework helps me solve it the best. 
Thanks for the explanation! Glad to hear you got it working once the "configuration" was done. So Angular looks for the global "jQuery" object, or the "jquery" AMD id?
It's still 90kb+ of minified JS to parse for the browser, after the download. And, for instance, mobile cpu's aren't that fast. But on the other hand, you're right in saying that very often performance can be improved even easier by removing some KB's in different ways.
Checked it out. It *does* look nice.
What about [Dragon Drop](https://github.com/btford/angular-dragon-drop)?
I can roughly guarantee that if most of your work has been in PHP and Python, you're probably not really used to, or even worried about SOLID and SOLID-principals. It's just not something that's pushed very hard in PHP and Python like it is in Java, C++ and C#. As such, using a framework that forces you to go "SOLID", to some degree, is a really good idea. A lot of Ruby/Python/PHP developers just don't see the benefits though, and I'm not sure how to sell it to them. &lt;shrug&gt;
Yeah man, good work on this project, it is very interesting. They look for the global "jQuery" object. edit: and then they doe some stuff with it before using it as well, if you ctrl-f for "bindJQuery" [here](http://code.angularjs.org/1.2.0-rc.2/angular.js) you can see it.
New to me, thanks for the suggestion. Edit: nah, it doesn't seem to be able to deal with cloning and dragging the items in the drop zone. 
Well, fair point. &gt; you glanced at their website for 2 seconds and decided you know everything Off course I've done more research than that. I've read trough the tutorial and read some quite elaborate comparisons between frameworks like Backbone, Ember, Sproutcore, etc. What I said earlier is based on that: many people emphasize the fact that Angular is great in bindings, and that's about it. I can't find anything good on the way the MVC structure is built, for instance. &gt; Otherwise google "what is opinionated software" and learn what it Sorry, I'm not a native Engelish speaker. So I googled the word 'opinionated' and found a definition like 'stubbornly keeping to your opinion'. Was not really helpful. In context it is understandable. Thanks for your input!
The [docs](https://github.com/fraywing/textAngular) say "Add the text-angular **directive** to it." but I think they mean **attribute** not **directive**.
You qualified your "1st impression" by talking about the front page of their website. You did not qualify it with all this research you may or may not have done. Again, I question how much of a first impression you got of angular when all you talk about is data binding, which is 1 piece of a very large puzzle.
By "closures-as-used" I'm thinking fairly specifically of the AMD module pattern, and related patterns, where an executing function is used as a namespace, and then controlled access is provided through a return. It's a pretty common pattern, and it's a fairly frustrating one -- often complex bits of state are held inside the closure, unavailable for inspection except when inside the closure. There's appeal to this because it increases the programmer's control, and in theory at least reduces the risk that someone might do something untoward with the contents of your namespace. But I find it frustrating and irritating, because far more often than it protects me from doing something bad because I'm stupid, it prevents me from fixing something stupid that the writer of the original closure did without rewriting all his code. Furthermore, it's hard to write unit tests that address internal state like this in an atomic way. Furthermore it's hard to debug code that's written like this because once you've discovered that there's something not quite right about what the closure is exposing, you need to set breakpoints such that you can climb inside the closure to be able to access its scope. I think you're right that functional programming has a lot of appeal, and I think it's particularly appealing for programmers of a certain mindset, and for problem spaces of a particular space. But I don't think it's necessarily an excellent model for development in general, and I'm not convinced that it's an excellent model for the problem domains that Javascript is typically employed to address. I know there are people who disagree with me, and I'm fine with that. Also, I really liked http://journal.stuffwithstuff.com/2013/07/18/javascript-isnt-scheme/ that article.
I came up with about exactly the same a bit earlier: https://github.com/branneman/css-js-module-states
The gists linked in the topic article are more than year old, your repo starts in april 2013... So I guess we were all a bit late without even knowing :)
As I try to explain, is that if I look up comparisons between frameworks, binding is mentioned as the most important feature of Angular. It might be that it's mentioned so often because it is something Angular is really good at, but it gave me the idea that that is the only 'killer function' of Angular. So, that brings me to the question what makes Angular better than the alternatives in other respects. &gt; You qualified your "1st impression" by talking about the front page of their website. Well, no. &gt; I've not seen much of AngularJS, but my first impression is that it is more widget-focussed than an MVC-framework. Later, I gave the front-page as an example of what I mentioned above: it is the renowned feature. Shall we stop this nonsense now? I've gotten the idea that Angular is way more than what my first (few hours of googling frameworks later) impression was. Thanks for that.
It's just a wrapper for `window.matchMedia`. I would say the linked script could just use `matchMedia` as well, but it seems to be aiming to only write media queries once, in the CSS.
Gotcha. I absolutely agree that hiding state within a closure is a bad idea. I can see why people would want to do it; It's a very tempting idea when you've had your ass kicked by a shared global namespace or you come from Java where hidden state is gospel. The only reason it works so well in Java is that a class/interface definition represents a contract, but Javascript is a contract-free language where that approach is unmaintainable. I also agree that Javascript is not Scheme. Scheme is a flavor of Lisp, and Javascript lacks (and will forever lack) some of the key feature that make Lisp-derived languages powerful. Most notably, [the last few features out lined here](http://www.paulgraham.com/icad.html). The language [Groovy](http://groovy.codehaus.org/) is also not a variant of Scheme, but it has taken pages from the functional programming playbook that make it very easy to manipulate data functionally. I have long and complex thoughts about functional programming generally, but I'll summarize by saying: I think it's the ideal way to implement all business logic of an application. I think it's a very solid way of implementing any sort of data-access interchange. I think it's terrible for actually pushing changes into a mutable pool of data. Most JS is written to manipulate DOM trees, so I think functional programming isn't the right tool for that job.
You're correct, I figured I'd link it because it allows you to provide callbacks for when the media queries change.
But it would still need to run a backend language (unless you are making calls strictly to another web API) to be useful... right?
The ability to be 100% dependent on a third party web api, of course!
So does matchMedia
Why not just use [modernizr](http://modernizr.com/docs/#mq) Modernizr.mq('only screen and (max-width: 768px)') // true
[I made this one](https://en.wikipedia.org/wiki/Reinventing_the_wheel).
I really liked this one for the simple draggable directive: http://stackoverflow.com/questions/15470666/angularjs-directive-attribute-binding-left-top-positions-after-dragging-with-ng 
Interesting. I guess I've never thought of it that way, since like you said, I would have done it the "backbone way" anyways. Thanks for this.
I made some modifications to the original version of this script to allow it to use matchMedia if available, but still fall back to width when it isn't (oldIE, basically). [jRespond](https://github.com/ten1seven/jRespond) &gt;Responsive websites that require JavaScript functionality for some breakpoints and not for others need some type of system for triggering the correct functions at the correct breakpoint and to also be aware of when a browser is resized across breakpoints. Although switching between breakpoints could be seen as an edge case, a few applications for jRespond are: &gt;Managing functionality for initial page load: * Even if the browser is never resized, jRespond can help manage what JavaScript functions are triggered when the page loads for a given breakpoint. * Development testing: jRespond makes it much easier to test in-browser. * Borderline device widths: Real user browser resizing and device rotation that crosses breakpoints.
The way I've looked at is that Backbone is v1 of MVC style apps. I put Knockout at about v1.3. Angular (and Ember) is the v2, and both are better than Backbone for most applications. There are always going to be people that refuse to use v2 because they are comfortable with how it works in v1, but that doesn't mean v2 is inferior (and in this case, v2 is much better in the end for most applications as it is more capable than the v1 that is Backbone.) You have to build an app in Angular to really get what it gives you. And it'll be a bit painful right off the bat as you learn how to set things up. But the same can be said of Backbone or any framework. In the end, Angular does a lot of things for you in a "standard" way, but still maintains the ability for you to dive in and do things the exact way you want if you need to do something different from the "standard".
Not a fun library to use on their 1.1 api using post_with_media status updates. Like not even a little. Elsewise, a fabulous npm.
Is there a changelog somewhere? I don't see a link to it on the site.
or just matchMedia (if your support matrix is modern enough): https://developer.mozilla.org/en-US/docs/Web/API/Window.matchMedia
Holy smokes that blog header/links is blurry on a retina MBP. *goes blind*
The changelog is right at the bottom: http://backbonejs.org/#changelog
There's no API, just use `console`
Doesn't work in Safari (http://github.hubspot.com/odometer/docs/welcome/): TypeError: Attempting to change access mechanism for an unconfigurable property. odometer.js:113
So, it seems as though this release has some breaking changes with 1.0.
It's quite nice but doesn't really make sense for the slot machine example. The numbers move as if they are a single 3 digit number: the rightmost number moves very quickly and the leftmost number hardly moves at all. In reality all the numbers would spin independently but at similar speeds.
That was the Tut that had made we want to play with Twit
I haven't got that deep into the API yet so I will hopefully get a better picture. 
Is anyone else less than impressed with the jsfiddle demo? http://jsfiddle.net/rx6BQ/2/
Nice comparison between frameworks, although we have work around for all of them to make it work in a efficient way.
I see no numbers on my iphone.
I don't think so. Recently, I've created a few apps that have absolutely no reliance on server-side scripting. They leverage HTML 5 storage, etc, etc. Totally client-side. A mobile site that's 100% HTML/CSS/JavaScript is a good example.
Nice Presentation! Note that KnockoutJS 3.0 also uses handlebars `{{ message }} ` http://blog.stevensanderson.com/2013/07/09/knockout-v2-3-0-released-v3-0-0-beta-available/ edit: correct link
Well, that's not the case always. I started having issues with chrome since it started using blink rendering engine.
For sure, I defiantly feel like overriding the global jQuery variable would be bad.
It depends on how many files you use. I've written complex applications with hundreds of files (including dojo framework files as well) and some versions of windows choke from all the small downloads. You could look into the dojo build system. With it, you can create targeted builds with everything compressed into one file. PS: I took a look at amdclean and seems to do this too, even more extreme optimizations than the dojo build system.
That's a great suggestion, thank you! But this is targeted at beginners so I want to keep it simple.
You need a close &lt;/style&gt; tag on the CSS section to make the resources work. ATM, none of the Odometer CSS/JS is loading. Try this: http://jsfiddle.net/adamschwartz/rx6BQ/
You might want to check out FRB: https://github.com/montagejs/frb It supports two-way binding, doesn't require a templating system, and it uses getters and setters rather than wrapping objects. I think that's pretty much what you are looking for.
The google closure library has an events prototype. The clojurescript library domina has a 'dispatch!' function that allows for sending custom events using this library. I have been using it to communicate messages between html dom nodes that would otherwise not be able to communicate without having a priori knowledge of the nodes they are communicating with. For example, I have a summary table that starts out blank. Only after new nodes are created does it have enough info to update. It is much nicer to have the new nodes just send an "update" event to the table than to have the table listen to a container div for clicks and update whenever it happens. On the surface, it seems "hacky" to be sending messages via custom events between dom nodes. However, I can think of no other way to do this without putting in an extra layer of complexity. I would appreciate any counterpoints to why using custom events as a messaging system is a bad idea. 
Yeah, unfortunately we've seen this as well. https://raw.github.com/HubSpot/odometer/master/promotional-images/odometer.gif We've done a lot to improve performance. (We use CSS transform: translate to do the animation, for example.) But as you noted, when they're moving that fast, the browser has a hard time painting the new regions as they come in. We're working on possible fixes for this though. You can follow our progress on this issue here: https://github.com/HubSpot/odometer/issues/3.
This is the line the disables your grade: $('#schoolSelection').change(function(){ ... **$('#grade option').not('option[value=empty]').prop('disabled', true);** You should comment it if you want your grade field not to get disabled by #schoolSelection, you also should be doing the check on :selected option.
That's better. Now to just get Safari support.
You may be able to work around the Knockout push issue by using a [throttled `computed` observable](http://knockoutjs.com/documentation/throttle-extender.html) (which is asynchronous), rather than an `observableArray`. 
I hate useless and annoying effects like this. Please don't inflict this nonsense on your users. 
could be done with CSS :hover...
This barely works on FF
Please don't.
http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752 This absolutely.
or something like this maybe: (very crude example use as guideline only) http://jsfiddle.net/jgy3183/wcTM5/
This framework is shit. 6 months, all work they have done is few fixes, changed default options for view and few return values for collection? Lame.
Have you considered switching to [browserify](http://browserify.org/)? It produces much smaller bundles, requires less boilerplate, and also lets you reuse modules from [npm](http://npmjs.org). A typical browserify build cycle looks like: browserify main.js | uglifyjs &gt; bundle.js And you can also get fast in browser live reloading when you are developing using tools like [beefy](http://didact.us/beefy/).
It's not a book, but I really enjoy reading through BackboneJS' TODOs annotated source: * http://backbonejs.org/docs/todos.html It's written using BackboneJS, but it's a great example of how to structure code such that it grows elegantly.
Sometimes people do things because they sound fun to do, with no end-goal of using it on a site that anyone but themselves will see. I may never use my completely elite scrollbar-styling skills and my awesome Javascript mousetrails, but one taught me about the power of stylesheets and the other about how to quickly customize seemingly-esoteric JS, and in formats that interested me.
I recently made this same move when I started working on a Mobile App. I found Addy Osmani's Developing Backbone.js Applications a huge help, and i'm really enjoying writing structured Backbone apps. http://addyosmani.github.io/backbone-fundamentals/
You can find problems with any browser but you will consistently find problems with IE that work fine in every other.
&gt; [Before I met you I spent **days** pulling out my (metaphoric) hair trying to do even **basic document manipulation**](http://imgur.com/eV6yc80)
I had fun with this. Here's a solution using CSS classes and transitions. The JavaScript is there to toggle and set random classes, but isn't ultimately what accomplishes your requirements. http://codepen.io/aholmes/pen/pwlHG
Done, thanks for letting us know!
Fixed, thanks!
[Backbone in Action](http://www.manning.com/breed/) by Sam Breed is good stuff.
It's not a book, but my screencast series [Let's Code: Test-Driven JavaScript](http://www.letscodejavascript.com) covers this sort of material in depth.
Holy crap that's amazing. Exactly what I wanted plus.. a lot more. I feel that entire thing should be suggested as an inclusion to the javascript standard.
cringeworthy
The second one is sick. Also, french.
learn to write functions, put them in an object literal for namespacing, put the object literal in an external file which you include on all necessary pages. if you do these things your life (and code) will be much better.
Ehhm
Care to elaborate?
I'm just noting he's saying ehhm a lot
The technical term for people who write this kind of stuff is dick headed wanker.
Nice. Looking great on my phone now. 
This book walks you through building a full application and should give you lots of ideas on how to structure your next project: [Single Page Web Applications](http://www.amazon.com/Single-Page-Applications-end---end/dp/1617290750/ref=sr_1_1?ie=UTF8&amp;qid=1381538032&amp;sr=8-1&amp;keywords=single+page+web+applications)
Did a miss a link?
If you're going to downvote him, at least provide an explanation that we could all benefit from.
I didn't downvote him/her, but the answer's a bit simplistic, and "learn to write functions" is really patronizing. Factoring repeating code into functions that are put into a common module (what GP suggested) is a good idea, but there's a lot more to design than that. It doesn't address what OP was really asking for, which was info on general design principles.
"JavaScript Web Applications" by Alex McCaw is a good choice that I believe addresses what you're after. 
i am jack's raging erection. god i love living in the future =P
I only know Knockout, but I'm willing to bet Ember and Angular users could point out how to fix their downsides too. It'd be nice if Knockout allowed other observables to be throttled too. That'd be a little less hackish than wrapping something in a `computed` just to throttle it. Consider how much easier to follow and less error-prone this is: var list = ko.observableArray([]).extend({throttle:500}); &lt;ul data-bind="foreach: list"&gt; Is a lot easier to follow than this: var list = ko.observableArray([]); var listC = ko.computed(list).extend({throttle:500}); &lt;ul data-bind="foreach: listC"&gt; If I screw up and use `list` rather than `listC` in a `data-bind` then I've lost the benefit of adding the throttle. I can't write using `listC`, only read, unless I do `var listC = ko.computed({write:list,read:list}).extend({throttle:500})`, but that only makes it more awkward. And even then `listC` is only mimicing an `observable`, not an `observableArray`, so I can't use `listC.push`. So I have to keep a separate reference to `list` if I want to use `push`.
Only knowing one of them, it was great to see a comparison that wasn't trying to woo me, just explain.
Not a book but take a look at angularjs. Welcome to the future.
The google maps API does this 
From an IP address? I don't think so.
That's pretty cool... do you have the link to their usage rules?
404 all over the place :(
This is a fantastic question; I would love if you added it in the comment section of the post! Yes, currying is slightly more optimal -- here's the[ jsperf](http://jsperf.com/bind-vs-curry). I also think that for readability it is better to use bind only for binding a function to a context, and currying for binding arguments.
Something I've always wondered about: what is the point/the practical purpose of currying? Store the first argument in a local variable and you can still make multiple calls with different second arguments. You are only saving a few characters this way. What am I missing here?
Syntactically, yes currying is lighter because it allows us to easily reuse code. Logically, currying is useful when you have a function that takes multiple arguments, but you only know some of the arguments values. Currying allows you to call a function with the known values, and then wait until you know the remaining values to finish running it. 
Also, currying is one of those techniques that will be most appreciated if you try to use it. And it's worth noting that currying only one function in a script will not seem very useful. If you're interested in understanding currying more, I suggest you write a js script that applies currying to the function.prototype, and see if you can find good use cases as you write your code :)
x = f(a, b, c, d, e, f) currying: x = f(a)(b)(c)(d)(e)(f) because some parameters are unknown, you can actually call it disordered with keyword parameter (especially in async programming) x1 = f(a)(c)(f), x2=x1(b), x3=x2(e)(d), x = x3 That's the point of currying. To break down multi paramters into single parameter partial functions.
Backbone and Angular + require.js are one way to get moving towards modular, maintainable code. AMD that require provides changed my life. Warning: require and backbone have changed a lot in the past 12 months, so make sure whatever resources you use for reference are &lt; 12 months old. These aren't books, but I thought I'd give you a more general suggestion before you spend any money
What what does throttle do 
JavaScript Ninja is a book you'll love, written by the author of jQuery himself
First of all I don't like the term "currying", partial function application makes more sense. You think of the function with the extra parameters as something similar to the "strategy pattern". You sort of "configure a function". The thing is the alternative way to configure functions involves making classes of "functional objects", this, especially in a typed language, can scale enough that it will be too much effort to maintain it. Obviously sometimes having classes will make it less of a mess, but otherwise the partial applicaion mechanism provides a way to get the configuration functionality without boilerplate code, plus I don't know "strategically" if you have your code doing things like that automatically, it will be much easier to combine behavior like pieces, you won't need wrappers and adapters for trivial conversions etc. Or worry too much if an exra argument down the line will ripple to a lot of changes in "strategy pattern" classes. 
&gt; using partial *application* FTFY Also, this does not really *curry* the function. In the sense that `currier` doesn't generally transform `f(a,b,c,d,e,f)` into `f(a)(b)(c)(d)(e)(f)`. Instead it only applies partial application once, going from `f(a,b,c,d,e,f)` to e.g. `f(a,b)(c,d,e,f)`. ^(as a side note: why do people use images to post code samples?)
I wish there was an equivalent `partial` function, which did not take the thisValue as the first parameter, for the use cases where I don't need the thisValue. Something like: Function.protoype.partial = function() { return this.bind.apply(this, [null].concat(arguments)) ; } 
Currying and partial application are related but distinct concepts. Where partial application pre-configures a single function, currying enforces a single argument structure and nests the calls to a chain of functions internally.
You can try Telize, a JSON IP and GeoIP REST API which is open source and has a free Public API : http://www.telize.com The site has basic usage examples as well to get you started.
If you're making the calls directly, sure, it only saves typing a few characters but doesn't offer any value over something like... var a = "some value"; doSomething(a, "something else"); doSomething(a, "blah blah"); But think about passing functions around instead. Let's say I have to call a `function smogrify` which takes a function as parameter and a value I have, and then calls that function with my value and some other values it generates... function smogrify(callback, value) { // do stuff here ... callback(value, "something", "something", "something"); // more stuff... } Of course, I could do it that way, and just call `smogrify`... var a = "some value"; smogrify(doSomething, a); No problem at all, right? Ah, but there *is* one problem. `"some value"` is **my** value, and `smogrify` has no business in messing with it. In fact I don't want `smogrify` to have access to my value, not even to read it. Also, it's not very elegant having to pass a value that is only used to call a function which you are also passing. It feels kind of crude. What I want to give to `smogrify` is a function which has `"some value"` embedded in it but is not accessible from outside. Sure, a closure. function smogrify(callback) { // do stuff here ... callback("something", "something", "something"); // more stuff... } smogrify(function( ... ) {doSomething("some value", ... )); // or more cleanly and reusable: function createCallback(value) { return function( ... ) { doSomething(value, ...) } } smogrify(createCallback("some value")); But, certainly that `createCallback` function there is more general than what I use it for in this example. It's a function which creates a closure over the first parameter... Oh, right, it's *emulating* partial application of the first parameter. It is in fact the first step in a path that will lead you to seek a more general partial application or even currying emulation. I leave the rest of that path for you to explore. Wait! But.. closures? Yes, closures. JavaScript doesn't actually support partial application natively so you have to *emulate* it somehow. Using closures over the arguments is the most straightforward way. The function is not *really* curried. We have to work with what we have.
Good explanation, thank you. I didn't think of data encapsulation in callbacks. For the interested: http://stackoverflow.com/questions/113780/javascript-curry-what-are-the-practical-applications
Not a book, but this tutorial is very clear about how backbone relates to plain jQuery, and it helped me a lot. https://github.com/kjbekkelund/writings/blob/master/published/understanding-backbone.md
Throttle doesn't make the observable update realtime, but only after # milliseconds after the last update. In the example 500ms.
Wow, absolutely. So far I'm only to his part about loops, but I didn't realize js didn't cache the length of my array on the onset. I also was falling into bad habits of not using var to name my variables. So less than a chapter in and I'm already going to be changing my code.
Yeah but the reason I don't like the use of term is that for the majority of the use cases, the technique is used for implementing some sort of partial function application. The term currying for this kind of thing sort of hides the actual purpose. And confuses the learner. It would be even better to give right away the analogy with the strategy pattern / higher order functions, than having a title like "Currying in C#". Secondly it's a term that comes from fields that have to do with the foundations of logic and mathematics (or at least the theoritical models for functional languages), where the focus is on simplifying it to "foundational" levels. But the tutorials are at the application level. It sounds like an article about solving numerical analysis algorithms that keeps mentioning the Zermeloâ€“Fraenkel axioms or something. Then even when we talk about the technique of "sequentially returning functions to produce a final one" itself, instead of partial function application, it's not currying case you don't necessarily decompose to one argument functions (so that the foundational theorems etc. will apply) And I am not sure of the benefit of doing this, you could have swith cases on each argument returning entirely different function bodies each, but that kind of thing would probably get too hard to maintain and understand. 
An example I've used recently... This is more an example of manual partial application, but it could be achieved through currying if JS had better native support. In a node application using express, before calling ``doOperation``, I want to verify that a particular header is set. I could do this ad-hoc, or I could have a reusable library of guards: //guards.js exports.guardHeader = function(name, values) { return function(req, res, next) { var value = req.headers[name]; if (values.indexOf(value) &lt; 0) { res.send(406); } else { next(); } }; }; //app.js app.get('/:some/:path', guardHeader('content-type', ['application/json']), guardHeader('connection', ['keep-alive']), doOperation);
Oh, that'd be awesome! I don't know very much about JS's internals, I just heard this from John-David Dalton (Lodash's creator) in JavaScript Jabber. 
Bind can be slower, but it's slower like Array.prototype.map is, so I will avoid it when I'm writing performance critical code that doesn't touch the DOM. If it's app code that touches the DOM or if it's code where readability is key over speed then I'll use bind.
also found www.iptolatlng.com maxmind seemed pretty neat but yea i couldn't find straight-laced JSON because i want this running server-side and i had to dig through service offering documents. telize.com also seems to work.
i read while googling some kind of google-based AJAX but couldn't find where the service existed or much else
thanks!
Odd timing for this article with the current trends in the JS community around MVC, two-way data binding, and the Vanilla JS diet that Christian Heilmann is promoting.
I've been talking about functional style around the office, and while it makes the code very clean and easy to read if you're into functional programming, the others in the office who are not js devs or functional devs, agree that it is harder to read. These non-js devs need to work on my code base, but don't have time to learn a new chunk of functional-specific language like `each`, `every`, `pluck`, and all the other fun stuff underscore adds. Just wondering what you folks think of that.
&gt; Currying is not a pattern that is native to javascript Function.prototype.bind would beg to differ.
&gt; What happens if the timer goes off when the event is being serviced? The function registered with the timer won't start executing until after the function registered with the handler finishes executing. Even if the event handler execution takes a long time and goes past the timer. &gt; Does JS interrupt the event and service the timer and come back to the event? From ejohn's blog on How JavaScript Timer Works, this is probably not what happens. Correct. Functions run one at a time. Whichever function started first has to end before the next one starts. (Never mind [generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators) for now). &gt; What happens if the timer goes off when the even is being serviced and the event handler executes clearTimeout(theTimerThatJustWentOff)? Will the timer service routine run after we exit the event handler? I don't think the timer will "go off" so much as the system clock will tick past that moment. I'm not sure but I suspect that the next time JS looks at the list of things it has to do, it will respect the fact that the timer was cleared. I.e. clearTimeout() will always remove a matching entry that it finds if it hasn't been run yet, despite what the system clock says at the moment. Someone correct me if I'm wrong. &gt; How much will these behaviours vary across browsers? No variance. This is ultimately down to the fact that JS is single threaded, so at the most fundamental level there's no ability of functions being interrupted in the middle of their work. There might be variance among browsers in what happens when, say, a timer fires at the exact same millisecond as the event fires, but either way the functions will be executed serially. [edit] Changed some stuff because I misread one of the Q's.
just set it to null (I'd set it to false or undefined but they are more characters)
You know what brings the most flexibility... CSS.
Are you purposefully not looking at Dojo?
Nope. I haven't heard much about Dojo obviously it sounds like I should have :) My experience programming is systems (C++), backend web apps in the websphere environment, a few mobile apps, some scientific computing, and a BS in computer science. I have not spent much time on front end development.
You know how not to look dumb on reddit... read the article.
vanilla
Avoid Prototype.js, it extends JavaScript in ways that cause problems with browser development tools, making work slow and painful. jQuery doesn't add new OO features to JavaScript so it's not really relevant the discussion. If you're keen on using classes and inheritance you might want to consider looking at coffeescript. It compiles down to plain javascript objects but it's easier to write when you're getting started.
If you really want to develop non-trivial applications in javascript, which are more then just a few nice scripts thrown onto a page, you need to go beyond what jQuery is giving you. jQuery is a good abstraction for DOM querying, ajax and other things, but it does not really lead you to structure your application. While you certainly can reach the same architectural quality with vanilla javascript and it certainly is vital to have a real understanding of javascript, the language, today there exist a million of libraries and tools to help you with that. In terms of libraries you could have a look at * [angularjs](http://angularjs.org/) which provides many things/concept you need for a good application architecture. Can be a bit slow if things get too complex * [React](http://facebook.github.io/react/) just focuses on components and leaves everything else to other libraries. 
Thank you. I will take a look into these. Indeed my application is going to be some heavy JS and I don't intend to use jquery for anything more than the DOM and ajax. I am leaning toward vanilla at the moment partially because this is my first major JS project and I'm getting the impression that to talk intelligently about these libraries I probably need a firm grasp on JS. Thanks.
Typescript might be worth a look if you're coming from another OO language and are using MS tools (Visual Studio). It won't teach you good JavaScript, but you'll be able to see how classes, inheritance, etc. 'should' look in JavaScript. 
If you want to minimize number of characters, you might as well pass in `0`. `null` seems more.. semantically clean, though.
You're asking about two mutually-exclusive things that really aren't. The single biggest problem with "JavaScript" developers these days is that a great many of them... far too many of them... don't actually know JavaScript! They know jQuery... or they know Dojo... or they know Angular... or whatever the Library Du Jour is. To be sure, all of those are good, valuable, and worth knowing. But if you don't know JavaScript at the end of the day, you're just fooling yourself if you think you're actually a competent developer. Learn to do it with plain old JavaScript way first, and *then* use the high-level abstractions when they make sense. Not only will you be a better overall JS developer, but you'll be able to answer questions like this yourself because you'll have the proper foundation from which to make such decisions. You'll likely find that frequently the best answer is to use one of the libraries... but sometimes it won't be the right answer, and you'll be able to see that *and* be able to continue working effectively.
I agree--putting in `null`s in all the `bind` calls gets cluttered quickly... I'd say the same applies for `apply` too, but luckily [spreads](http://wiki.ecmascript.org/doku.php?id=harmony:spread) will cover that for us in a syntactically prettier way, anyway.
If you're an otherwise experienced developer, you might find [Advanced Javascript](http://ejohn.org/apps/learn/) interesting, which is an interactive presentation about some of the intricacies of Javascript by John Resig, the author of jQuery. 
I think the more I read the more I think I'm just going to use vanilla JS for the class structure for precisely the reason you stated. Thank you.
Prototype is an awesome library/framework, but unfortunately the way that it extends JS is incompatible with a lot of other third party libraries, and the lack of activity on the project as a whole makes it something of an old elephant. Lately my own software stack has been [LoDash](http://lodash.com) and [Backbone](http://backbonejs.org), with jQuery relegated to strictly DOM manipulation. Lodash has a build the serves as a drop-in replacement for underscore.js, which backbone depends on. It's very lean, extremely fast, and provides most of all the utility functions you're likely to need working in JS. You can make a very basic no-frills class with Backbone like so: var Class = function () {}; Class.prototype = { class_name: 'Class' }; Class.extend = Backbone.Model.extend; Extending it like this: var Subclass = Class.extend({ class_name: 'Subclass', constructor: function () { } }); Example jsfiddle: http://jsfiddle.net/nURWu/ (open console to see the output). Mind you, this is only useful if you also want to make use of the functionality that underscore/lodash and backbone provide. Otherwise it's probably overkill if you just want simple inheritance. John Resig has a leaner classical inheritance lib that others have linked to.
I work on the [YUI Library](http://yuilibrary.com/), which is the open-source JavaScript library we use at Yahoo. We also have classes/inheritance for JS, but I have to admit it's not something you always want to use. It really depends on the scope of your project. For smaller projects, where you basically only have one main back-end service that you're pulling data from, and not that many elements on the screen that need to be augmented with JS, then vanilla JS is definitely the best way to go. It's not worth pulling in the extra dependency when that's the case. Classes/inheritance are most useful only once you find yourself having to write common patterns over and over again, such as data validation, data syncing with your backend, or wiring up the same DOM events to manipulate your data over and over. In that case, depending on the amount of abstraction you want to have in your code, definitely try out a framework like Backbone, Ember, YUI, or a lot of others.
Pretty cool. Thanks. I'll maybe try that.
Hmm, my initial reaction is a knee-jerk against it. Obviously architecture would play a role here, such as separate JS files for style versus, say, events. Otherwise mixing the two leaves a bad taste in my mouth. The examples were also kind of ... bad. They showed poorly-written CSS/Less examples as if there wasn't a better way to do it, and then solved a problem that they invented. The way I do Less is to make it part of our build, actually. The compilation is done at build time, and the reason I did it that way was because we wanted non-UI engineers to not have to run extra tools, and one of our "architects" (image me making airquotes there) is against pushing processing to the browser at all. So we check in the .less files, and let the build process generate the CSS and that's all that gets pushed to the web server, so really it's just a dev tool to us. I guess this JS solution kind of solves that problem, but it also seems like a big learning curve, just like Less/Compass/etc, except one without a lot of preexisting knowledge on teams. So I dunno, I'm having mixed feelings. 
A practical use is when you are just joining up methods together. For example: canvas.onMouseDown = function(ev) { startPainting( canvas, ev ); }; It would be much shorter to just do ... canvas.onMouseDown = curry( startPainting, canvas ); I write a lot of pure-JS applications, and I often find myself having to write this type of boiler plate code, where I'm just joining stuff up.
Since you have experience with C++ you may find the internals of node.js interesting, and not have such a steep learning curve when making node.js plugins.
Happy cakeday!
Thank you stranger! You are the first and probably one. P.S.: That reminds me- I should post some pictures of my cat...
Wow thank you, I glanced at this and it looks like a great tool for learning what is under the hood. One of the problems I am having learning javascript is that many of the tutorials and explanations seem to be for people or by people who aren't really developers. I can learn a lot from just a few select examples of code like this. Thank you so much, this is the kind of thing I was looking for.
learn javascript first and later if you think you need a framework learn one, jquery seems to be the most popular but don't start by learning jquery, imho frameworks make you lazy and do not promote learning the language most of the jquery users i know think they're badass because they can make things blink and jump all over the window, but have absolutely no idea about stuff like closures and prototypal inheritance
lol. Good advice. I'm more or less taking it. The consensus here seems to be that if I don't know javascript start there. I am using jquery as syntactic sugar for the DOM and ajax but the class structure I am going pure javascript. I've been playing around with it and love it so far. I usually hate working on front end code but this is pretty enjoyable. I'm using Jasmine for unit testing and building a class structure up for form validation and constructing models from ajax replies. So far I like what I see but I haven't gotten too deep into inheritance yet which is where i know things will get rough for me since I am used to C++, Java, and Ruby's style of inheritance. Thanks again! 
no problem, i strongly recommend that your read [javascript the good parts](http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742/) by Douglas Crockford who is considered the god of javascript, it's a short read which will clear a lot of confusion and teach you what a powerful and nice language js is
Definitely learn vanilla javascript first. You need to learn the language before you start using the libraries. One problem I've seen over and over again is that experienced developers "learn JS" by grabbing jQuery plugins and just writing spaghetti code in global scope and the declaring JS a stupid language that should only be used sparingly when there's a decently written jQuery plugin. The devs at my work who were previously "Javascript developers" weren't even aware that JS had an === operator, nor how to use it, and also didn't know the difference between the "null" and "undefined" types. Really, really basic stuff that all JS devs should know.
lol. If that is the case then I'm already ahead of the curve :) Hivemind has spoken and I am going with vanilla for precisely the reasons you listed. Tonight I've been working until my eyeballs bleed on basic form validation, ajax, some models, and unit testing. Honestly, vanilla JS is pretty neat so far. I haven't gotten into the part that will probably be the most uncomfortable for me, inheritance.
Awesome! I was dragged into the JS world kicking and screaming as one of the "bad" devs I mentioned. Eventually I learned more about JS and came to like some of the more elegant solutions cooked up, such as the standard Module pattern (if I'm remembering the name right) that takes advantage of self-executing functions and Javascript scope rules to enable a module to have both public and private functions or variables. Lately I've been into AngularJS, which is such a huge game-changer for JS that it's practically like learning another language. 
There is nothing wrong with using a framework. Understanding the language you are writing code for is of utmost importance. Coming from a C++ background, the areas you should focus on are scoping rules and prototypical inheritance. The rest will come naturally, most likely. When working with the DOM and browser api, understand the event loop and how it effects the call stack. This will help you use the correct design pattern. A framework (like angular or dojo or ember) will help keep your code separated by concerns which lends to easier testing and maintenance, and more reusable code. I course, you can do this yourself, but why reinvent the wheel? It will save you a lot of time in the end. If your hellbent on writing your own class system, I recommend angular. Finally, pick a good module system. There are a few to choose from, but I recommend either AMD or CommonJS. CommonJS is pretty much what Node uses and there are some great tools that will combine your modules into one script for the browser (namely browserify). Hope this helps. 
First time seeing Wayland in action! Well, more like in snapshots. Still, woohoo! 
Note: These are all jQuery plugins.
Note: JQuery is JavaScript 
jQuery is a monolithic javascript library that very rarely needs to be actually used.
Definitely not rarely 
&gt; ***all javascript libraries*** I have known of And what do we see? Only jQuery plugins. That is not a good sign. 
It might help if you could see what the licenses are. Personally, I can't see why someone would use this instead of just googling for the plugin they want. This site only has whatever plugins happen to have been submitted to it and it doesn't really give you any information on them. The only thing it really gives you is convenient access to the demo for the minority of plugins that have one.
Yes, sorry, I'm opinionated, I prefer lighter libraries that do specific things.
If recommend learning typescript over coffee script since you are just writing JavaScript but with the ability to add typing when developing
Looks like http://json.org/
look into applicationCache. all of your files will be downloaded by the client on first load.
Is there a subscription list for these weekly resources?
Type safety doesn't belong in runtime. It's there to reduce the amount of errors at runtime by pointing them out to you before they happen (i.e. at compile time.) The annotations are there to make the compiler able to statically verify some parts of your code. Could you give an example of type safety for runtime? I'm not sure I understand what you mean.
If you're relying on end-user submitted data, you still need to do all the type checking on your own. More importantly, if you plan to write a library/plugin/framework/whatever that other *programmers* will use, and they choose to use JavaScript/CoffeeScript/LiveScript/whatever, they don't get all that type safety that is shoehorned into the compiler but not the outputted code. I believe they wouldn't even get that type safety even if they use TypeScript! If you have a method that expects a string, you need to make sure that it only accepts a string at runtime, too. Type checking code absolutely belongs in runtime, especially in a dynamic, weakly typed scripting language like JavaScript. EDIT: For example, if your method takes a string and a numeric, you might need to do something like: function(str, num) { str = "" + str; num = +num; ... } Those cases both assume that your method will work by coercing the argument to a string/number. Sometimes that won't work and you will need to perform more in depth conversion or throw an error. You simply can't rely on a compiler for this. It might help reduce some errors in your code, but it seems like a lot of users would assume that's good enough and they don't need to do any further type checking. Another example is Google's Dart, which obviously goes far beyond the "JavaScript superset" ideology of TypeScript, but it implements its type safety into your compiled, JavaScript bytecode. It gives you type safety in the compiler *and* in your runtime code. [Here's an example of what I'm talking about.](http://www.reddit.com/r/programming/comments/1nnokk/you_cant_javascript_under_pressure/cck9pxl) TypeScript wouldn't have prevented this error, assuming you didn't have 100% control over the data source (i.e. most cases when using JavaScript) My point is that preventing issues like this is better done through proper automated testing, which you can do no matter what particular flavor of JavaScript you prefer. At the very least, you should do some duck typing - CoffeeScript makes this very simple using the existential (?) operator, e.g.: foo = bar.something?() ? 'fallback value' #or... foo = bar.something?() ? throw new Error 'debug text here' Compiles to: var foo, _ref; foo = (_ref = typeof bar.something === "function" ? bar.something() : void 0) != null ? _ref : 'fallback value'; foo = (function() { if ((_ref = typeof bar.something === "function" ? bar.something() : void 0) != null) { return _ref; } else { throw new Error('debug text here'); } })();
Still rather early stages but thought I'd shared anyway. You can view it here: http://isometric.beakable.com It allows for: HeightMaps, Fake lighting, Simple AI Pathfinding, Particle Engine. Incomplete: Q &amp; A rotates the map, however it doesn't keep focus on the current POV. Not does it relocate the fake lighting positions or particle locations (so pretty borked just now). A &amp; S zooms out, however doesn't take in the relocating of the player so will only appear to work from your initial position just now. Currently I plan to mould it to a particular game I have in mind so I'm not really sure how portable the engine is remaining... My main goal right now is just to get it back to the level of an initial game I made: http://www.youtube.com/watch?v=Qlsipfu5Qq4. The code was awful however! So trying to keep it tidy. 
One of the few libraries that goes "all the way" as a indutrial grade application library is the two libraries from Sencha. ExtJS and Sencha Touch. You will not miss anything there if you are developing "applications" if you are looking to create web sites dont bother with sencha. Its pure Javascript. No html involved at you end. Its MVC and has a suberp building tool called Sencha Cmd. Bonus. It costs money. They make money. 
https://github.com/jprichardson/string.js * parseCSV() * toCSV()
When I did this in Hammer.js I based it on the code at http://www.appliness.com/multitouch-with-hammer-js/ (sorry that's not using jQuery UI though)
Could you explain to me what you did and how you did it? I would greatly appreciate that. I've been trying to do it with hammer and it is not working for me. It is okay if it doesn't use jQuery UI.
Agreed, not only is it impossible to copy/paste, it looks awful on a high pixel density monitor.
I'm sorry about the spaghetti title. ^^I ^^need ^^some ^^sleep
&gt; I need some sleep
Fucking snitch. You must be popular at bot parties
Thanks :). Yeah true, that's a bad habit I've been in for years, automatically go with index.php instead of .html. I've only briefly looked at Tiled, but will take a proper look soon. One of the next things I plan to do is rather than have the Emitter effect settings hardcoded it should be no problem to store them, allowing for user generated ones. So I might need to make a more specific editor. I still need to switch it from XML to JSON as well.
Easier than adding a syntax highlighter for html? It definitely is pretty useless.
Yeah.. I wasn't implying that was the solution. I realize it kind of sounds that way. I meant it as an example of someone else making a library...meaning there may be a use case.
if its open source, could you add a license? just knit picking here. Love what you have done and again supporting tiled will make your live much easier.
Hey, I just wanted to thank you for your tutorials you've posted (about two years ago?) on the Glacial Flame blog. I was studying at that time and never had done anything in JavaScript (and no games at all) before, when a fellow student asked me to join him and develop a browser-game for a group-project. He wanted to have an isometric map and after I've googled, your blog came up. It became the very first base for our project (pic ouf our game: http://abload.de/img/543323_45284494807853vpscu.jpg) which got me into JavaScript-development and later surley helped me to get a job in the game-industry. Thanks!
For folks working with disturbingly large CSV files in, say, node.js, I'd warmly recommend to go with a native module. It was counter-intuitive to me, but CSV parsing is cpu-bound, particularly when the data is read from an SSD, so it's not one of those areas where JS will do great without help. (I just happened to bump into this myself, ended up using something built on top of [fast-cpp-csv-parser](https://code.google.com/p/fast-cpp-csv-parser/), which despite all its optimizations and being the fastest thing I've found, is still maxing out an overclocked i7 core easily.)
I built this one: http://imaginate.redbull.com/imaginate-worldwide It's using a mixture of D3.js with GeoJSON and jQueryUI.
Ooh, that's nice! I like it, but I don't think it will work for this specific project. I'm looking at a high number of un-named events, so I need a bar or line graph instead of a time line. It could be a starting point though, depending on what else I come across. 
Use pure JS, and listeners for touch events (https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent) In your event, you can find the amount of touches through event.touches.length, in which you want to check for 2. Then set your first and second touches through event.changedTouches[0] and event.changedTouches[1]. You can then get the mouse position via touch.clientX and touch.clientY. Calculate the change from the last touch to the current touch to find out if the client is enacting a pinch to your favor, and modify the html content accordingly.
The licence is in the source files apparently. It is GPL3 which is not a great licence for an engine IMHO.
Nice. Is it opensource?