To expand on this, Electron is a convenient way to combine NodeJS and browser code in one app. (Even in the same process - though Electron does run multiple process with one main Node-only process, and one browser-plus-node process for each application window.) Everything is packaged together for easy installation by end users. Electron also takes care of displaying a web ui, so that the user does not have to do something like run the app process in a terminal, and open a localhost URL in a browser.
That isn't a huge problem. If you have message passing then you have a thin JavaScript rendering engine that your core logic speaks to.
Is there an issue with moving to CoffeeScript? Many people (including me) prefer the syntax. Yes Coffeescript was made to fix XYZ and ES6 Fixed XYZ and added.... But it doesn't look anything like python-esk languages. Whether that is good or bad comes down to personal preference.
I KNOW RIGHT?!!! It must have been something in the water.
This is /r/javascript, so I expect this to get downvoted to hell, but still: Unless you are writing a web application (i.e. you are writing a server in python and C++ and the client in JS), don't use JS. There's just zero reason to do that if you know C++ well enough because there's Qt which does everything you want. And if you don't know C++ well enough then you definitely shouldn't be writing something complex in it. Also, check out QtQuick. No need to complicate things. A lot of the shit in the JS community is hipster technology and a lot of it stems from people only knowing one language (JS). Just because there are lots of blog posts about JS it doesn't mean that it's better than other platforms.
Are you using ES2015? If you are, you can do this: class Base { constructor({propertyA=10, propertyB='apple'}={}) { this.propertyA = propertyA; this.propertyB = propertyB; } } This has a couple of benefits: - It will throw an error if you accidentally call it without `new`. - You can call it with no arguments and get back an object with the default properties, whereas the original version would throw an error.
Currently (excluding webworkers), only one Javascript function is running at any moment in time. Calling a normal function will immediately switch execution to that function, then, when that function has finished, continue executing the original code. When you call an asynchronous function, say an AJAX request, you pass in a callback which you want to be executed, the request is sent off, and, rather than waiting for it to return, the original code continues straight away. When, sometime later, the AJAX request returns, the callback is found, and shoved at the end of a queue of code to be executed. If nothing is executing at the time, then the callback will be called immediately. If there is code running, the browser will finish executing it, then go through the queue, executing all the code in it. That way, there's only ever one bit of code running at a time - asynchronous functions (and likewise promises, which are asynchronous functions with a bit of sugar) will be added to a queue and run when all the other code has finished executing. The difference with WebAssembly is that the interpreter will be allowed to execute multiple threads *at the same time*. This would be useful if you were doing a complex calculation that took a long time to complete. Rather than having to wait until the calculation had finished before the browser processes the next callback, you could design the script to be able to run the calculation in a separate thread where it wouldn't block the callbacks from running.
Crystal could fill that niche quite well, I'd imagine.
The problem with passing in an object for an argument is that you function calls are obscured. Also you have missed the case where you call `new base()`. Try going to the babel REPL https://babeljs.io/repl/ and using es2015 syntax to see what the transpilation would be. Example: function example(x = 2, y = 3) { this.x = x; this.y = y; } Becomes "use strict"; function example() { var x = arguments.length &lt;= 0 || arguments[0] === undefined ? 2 : arguments[0]; var y = arguments.length &lt;= 1 || arguments[1] === undefined ? 3 : arguments[1]; this.x = x; this.y = y; }
 function base(constructorProperties) { function getOrDefault(propertyName, defaultValue) { return constructorProperties !== undefined &amp;&amp; constructorProperties.hasOwnProperty(propertyName) ? constructorProperties[propertyName] : defaultValue; } this.propertyA = getOrDefault('propertyA', 10); this.propertyB = getOrDefault('propertyB', 'apple'); } If you're not transpiling. Most "utility" libraries provide an `extend` method (or similarly named, such as `assign`). Underscore's `extendOwn` (which will extend only *own* properties) in this example: function base(constructorProperties) { _(this).extendOwn(constructorProperties); } 
I haven't dug into ES2015 yet.. It was my impression that it's still not highly supported by all major browsers, and that we should wait some time before making it the standard. How accurate would you say that is?
I like this a lot. I do have a question about it. Is there an advantage to using hasOwnProperty instead of just constructorProperties[propertyName]? 
Gotcha, thanks!
I have worked in one even worse place. We were using coffeescript, but the whole app was written in google closure. So not only you have badly readable coffee syntax, on top of it you have google Closure. I was so happy to get out of there, even though they paid handsomely.
Probably just for performance critical code that would have previously been written as a node plugin. It will cut down the need to build an npm package on every machine that installs it.
It's accurate. But if you use [Babel](https://github.com/babel/babel) as a es6 to es5 transpiler (which would be the recommended way to write es6 today), then it's a moot point.
I am making a start up, all I need is some funding (easy), and someone to build my app. Can you build me an app like facebook, but not facebook?
The browser support is improving, but it will still be a few months before it can be used natively for development, and a few years before it can be used natively in production. In the meantime, a lot of people are using [Babel](http://babeljs.io/), which converts ES2015 code to ES5, so it will work in all modern browsers. If you don't like the idea of adding a transpiler to your workflow, then you can stick to ES5, but there are lot of very useful additions to the language in ES2015, which you'll really miss once you've tried them. [Here's a rundown of the new features.](https://babeljs.io/docs/learn-es2015/) 
Side note: love the sliding desktop thingy, I'm going to steal your idea for my linux :o
If a function only operates on the properties of an Object - it should really be a method of that object. In the case where its just a `function(obj)` you know have to inspect and understand the structure of `obj` and the function to know what the function does. This is more of an opinion, so take it with a grain of salt. If you're always calling the function like so new Example({a : 2, b: 3}) Then its more readable, but having something like this (below) is a code smell for me. var obj = {a : 2, b : 3}; ... // Like a million lines later new Example(obj);
This guy is always dumping on Typescript
http://lmgtfy.com/?q=slack+node+js Have fun. And do listen to wreckedadvent.
What libraries are you using already? Are you using promises or callbacks? If you use something like [Promise.all](http://bluebirdjs.com/docs/api/promise.all.html) you can pretty easily accomplish it. Promise.all([ getImage1(), getImage2() ]) .spread( (image1, image2) =&gt; { /** All database operations are complete. **/ }); Similarly, depending on what you already have written, what you need to do with the data, etc, you might be able to use [Promise.map](http://bluebirdjs.com/docs/api/promise.map.html) instead. Promise.map(imageIds, (imageId) =&gt; db.getImageById(imageId)) .then( (images) =&gt; { /** Array of images, all database operations completed. **/ }); 
the youtube property appears to be undefined, and... it's not there. Perhaps the examples are out of date?
The hype train continues. Probably 99% of non-game, non-demo web apps don't need the performance gains from this and the real era being dawned here is one of closed source. Sure you'll still be able to decompile these binaries into some barely readable code but anyone who has ever learned something or borrowed something from viewing source is going see that come to an end for the most part. The ability to compile from any language sounds nice and all but the reality is you can already transpile anything you want to JS so that's hype as well. One thing for sure... this is going to make malware a lot easier to hide.
Same. I lost comprehension during the last couple videos. Definitely worth a rewatch.
Hum front end masters and code school have both a ES2015 course. Also I wrote a little web component using a class as a proof of concept if you want to look at it :p https://github.com/Rastikko/web-component-video-state-machine/blob/master/src/video-state-machine.js
Shouldn't line 13 be console.log(myInstance.constructor === myClass); (which does return true), instead of console.log(myInstance.constructor === myClass()); 
Basically there is no such thing as classes in JavaScript. You're really close to getting it in your fiddle. The way I like to think of it is that when you run "new X()" it duplicates the prototype to a new object, applies the constructor to the new object, and returns the new object. Any changes made to it afterwards don't effect the prototype unless you modify the actual prototype object. This goes hand in hand with the "this" keyword, which should never be trusted anywhere except in constructors and functions you call with .apply() . The object passed to .apply() as the first parameter will be what "this" is a reference to in the scope of the function. Weird, huh? I suggest reading You Don't Know JS for all this and more. Good luck!
I blame open-source. One used to buy libraries, and they were generally documented and worked. Now there are 100 libraries to choose from, and they are all 85% complete.
&gt; HYPOTHESIS: The popularity of a tool is proportional to the amount of time it makes their users waste. The more ways there are to configure a tool the more situations and use cases the tool can be applied to and the greater number of people who use the tool... so yeah, more configuration =&gt; more popularity.
Ah yes that was a my bad. I updated it.
Why would you ever need to re-define prototype? If feels like asking for troubles, so no surprise weird behavior comes out.
Mobile apps are the worst at this. Every time I open any app on android, it turns out it's been updated since last I used it, and forces me to walk through a manual, which I skip because I want to do stuff (naturally), then get confused because all the UI is different (for no good reason), and struggle for 5 minutes trying to figure out how to go back to the tutorial, before just getting fed up and deleting Snapchat... I mean... the app.
It's not that I am confused as to how to implement class based apps (not completely). I have written one: https://github.com/vrodriguez363/mimic/blob/master/src/js/selection.js I understand that it CAN work. My issues lie with the problems that come with it, and more importantly, if Javascript doesn't actually have a class - es6 class is just syntactical sugar - why do we use it? We can create object literals, and use factories and revealing modules. Why do we need the "new" operator when it adds confusing issues with instanceof and constructor? Is there a benefit that I am not seeing that overcomes the drawbacks?
I wish I could upvote you more.
&gt; It's a compiler. For ES6. That's the problem, it's not. It started life as 6to5, but they changed the name to Babel specifically because they started supporting non-ES6 input and non-ES5 output. One big example of that is that Babel is the official JSX transpiler, and JSX is most certainly not ES6. What would be awesome IMO is if the Babel team maintained the old 6to5 name as a Babel mirror preconfigured to only support ES6 to ES5.
As a 20 something, I totally agree with you. 
Oh, thank god I'm not alone. 
&gt; Dear all 20-somethings who think they can save the world if we just had the one true framework: You suck, you're just making it worse, and you should stop. If people want to go ahead and build frameworks they can, and you don't have to use them. I mean, I'm still using Grunt &amp; Sass with no intention of moving on anytime soon, and I have no issues whatsoever. I think the real issue isn't that frameworks are popping up faster than the speed of light, but that people feel they absolutely must stay up to date when they really don't.
Typescript is actually a superset of JavaScript
* PostCSS for auto prefixing, Sass for oo-css and variables. * Gulp and npm for helping with front-end tasks (eg transpilation, minification) ** Webpack instead if you're dealing with more than markup (eg react code) ... These are obviously solutions which are specific to my use-cases, but the beauty of having ample frameworks/libraries to choose from is that you can leverage them to create very modern full-stack applications and APIs. Developers love to cry about having too much to learn. But isn't that what you signed up for? You could still write applications in DHTML if you'd like. I'll be over here enjoying my real-time react-d3 charts. The point is, when something eclipses something else in popularity, it's generally for good reason. Gulp blows grunt out of the water performance-wise, and is way easier to configure &amp; manage. React encourages development patterns that make writing and maintaining enterprise-grade SPAs markedly easier (than the original angular 1.x). The face of web development is changing rapidly rdue to standardization of technologies (WebAssembly, es2015, etc.) and changes in the way we interact with the IoT. Lastly, you don't need to upgrade your libraries just because you heard buzz about something up-and-coming. Do enough research to build an MVP, see whether an expansion of that will meet your requirements and pass cost-benefit analysis, and if so, stay the course. Look for opportunities to upgrade libraries/frameworks and refactor technical debt in between major releases. 
I dunno. I use babel to-- oh wait, that's Webpack that uses Babel that I'm thinking about. God there's too many tools.
But here you run into the Dependency Graph problem: eventually you will upgrade your preferred framework, and it will have been modified to use version 74cb9a48 of another framework, which also pulls in *glorfindel-3.8*,*upsnort-84.3rc8*,*posole-0.0.07*, and *node-headless-vmware-fusion-runner-Docker-RHEL8-Oracle12*, and you're screwed. Totally screwed.
Hey, it's better than the windows version. While it has only one command per thing, it makes me type `nvm use x.x.x` after doing `nvm install x.x.x 64`. Because there was probably no way I was going to want to use the new node version I just installed.
Software development is all about making tradeoffs. Just because you disagree with their choices it doesn't mean that they're necessarily unreasonable. Babel is more modular now, which is great because it's more future-friendly. It's not meant to just be an ES2015 to ES5 transpiler. It also has support for things such as JSX, flowtype, and other future proposals. In fact, all plugins are now on equal footing (if we exclude stuff for extending the parser), which was not the case with Babel 5. I do agree that a lot of these tools are more complicated than is ideal. But achieving these goals takes additional time and effort, and I'd remind you that this is all FOSS. You're not paying for it, and you're welcome to contribute in order to help improve it. The truth is that a lot of these projects are built and maintained by a very small number of people, and a lot of times they do it because they're just passionate about the project. I think your point about nvm is good. Why not follow it up by opening an issue on their repo?
It supports a whole host of plugins, *not* just ES6 (thus the name change from 6to5). Your complaint is frankly nothing more than an uninformed opinion. Babel is a well designed tool with a scope way beyond what you have stated.
Nah, I use babel, it needs to transpile my webpack config file after all. Then I use webpack which uses babel.
All that said, I also feel like a lot of the complaints about tools (esp webpack and babel) being 'too configurable' could be mitigated substantially by including a set of sensible defaults, so the tool worked out of the box. That said defaults aren't included is a perfectly reasonable grounds for complains, imo. 
I'm 35 and I've pretty much given up on the bandwagoning. It's like climbing a hill, and as soon as you reach the top, there's another hill everyone has to go climb. I don't think it's possible to keep up with all of this while working full time unless keeping up _is_ your job. I work in web dev and if I spent all of my time learning these tools and applications, I'd never get any actual work done. I'd just keep switching hills.
&gt; I JUST got used to maven from ant, and now there's gradle? Eat a bowlful of dicks why don't you. "And now"? Gradle was released 9 years ago. You're complaining about having to learn a technology that's nearly a decade old? To put that into perspective: Gradle came out before the first generation iPhone. That's how old it is. The Java ecosystem moves at a snail's pace, if you can't keep up with that then it's your own damn fault.
Hey! That was exactly what I was looking for! Thanks!
https://github.com/jriecken/sat-js I googled "JavaScript collision detection". 
http://uivideos.wordpress.com/
IMO, I think this is partially the result of Agile/scrum approach to software development. I'm still young in the field, but from what I've read it really seems like people just don't sit down to consider what they want out of something long term. Yes, it's extremely hard to imagine what things will look like years, down the line - but some basic forethought would go a long way. I look at software from the 80's and 90's (or Linux development) and I see so much more thought and consideration given building a tool properly - including considerations like long term support and long term compatibility. It seems like everybody want to get their change in to "be apart" of something, but nobody really has the time to guide that thing.
It's not true in Chrome 47, his test is broken. The way he wrote it, the browser figured out the expression isn't needed and actually skips it. He's comparing `unshift` to a noop. Force the browser to actually do the work (eg by storing the result) and `unshift` is faster.
&gt; Is cross-platform compatibility important? What exactly are you planning to build? In functionality something similar to delicious library in OSX (but not for media files). Cross-platform is not the problem, only linux matters. 
&gt; If I am correct in my assumption that this was all an attempt to force familiar patterns into a language that didn't need it JS does not have classical inheritance; it has prototypal inheritance. It's not "good" or "bad", it's just what we have. It can be *confusing* for people who are used to other languages, but I wouldn't say anyone is trying to "force" JS to act lile another language. Even the ES6 `class` keyword is extremely simple sugar for a common (and extremely idiomatic) protoypal inheritance pattern. If anyone is trying to force JS to be something it's not, it's *Crockford*; he's been a longtime advocate for language changes which force JS away from it's prototypal heritage and towards what I suppose he considers to be more familar patterns. :) In any case, the constructor pattern is, in my view, fairly clear, but there's no denying that some people have been confused by it. And like any pattern it can certainly be abused. But calling it *harmful*? No. The difference between the factory pattern or constructors or the ES6 class keyword, or the Stamper helper lib, or Backbone/Coffeescript classes, or whatever is, let's be honest, nil. Do not construct deep inheritance chains, be extremely careful about changing the prototypes of code you didn't write, and be generally skeptical of clever prototype tricks and you'll be fine. Edit: &gt; I want to use objects and inheritance and I guess I want to hear some opinions on this matter. Favour composition over inheritance. Crockford's favoured inheritance pattern is, in real world usage, no better than more common inheritance patterns. More to the point, it's still inheritance.
Some of the Devs on my floor have been bugfixing an app running on ASP.Net 1.1 web forms, that dumps requests in a queue to be parsed by COBOL programs. Must be a lower level of hell I guess.
&gt; npm install --save-dev babel@\^5.0.0 Done.
Don't `sudo npm` and shame those who recommend it: https://docs.npmjs.com/getting-started/fixing-npm-permissions
While every ES2015 and default parameter value answers are right, you could also use base prototype to achieve the same result and IMHO it would make more sense since you're defining a class. var Base = function (a,b) { if (a!==undefined) this.propertyA = a; if (b!==undefined) this.propertyB = b; } Base.prototype.propertyA = 10; Base.prototype.propertyB = 'apple'; var item = new Base(30); //30-apple 
Isn't this just all about trade-offs, if babel 6 has that feature you've been waiting to use which will save you a lot of time in future projects, but it'll take you 10 hours to setup up. Just do it. If it doesn't have extra features, why would you ever upgrade unless they've created something that makes upgrading easy. This is something you can apply on a lot of software upgrades.
&gt; It supports a whole host of plugins, not just ES6 Well *just ES6* should be the default. If you want to use plugins, on top of that, then it's OK to have to specify them explicitly. The problem as highlighted in the rant is that there is no default.
I completely agree with the article, but as many mentioned Babel, including the author, I just wanted to point something out - Babel was created and maintained by one teenager with almost no previous software background.
X-Post referenced from /r/node by /u/keithwhor [Introduction to Nodal (Part 3): User Authentication with Access Tokens](https://www.reddit.com/r/node/comments/40fwek/introduction_to_nodal_part_3_user_authentication/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Why not use `React.DOM.div` instead of `React.createElement('div'`
PyQt may also be an option. (Python + Qt) 
I think you're missing the point. Babel 5 isn't an alternative to Babel 6, because it won't be maintained to support future standards. Right now they might be in the same state, but it won't be the case in a year from now. If we want something to change, we have to say it sooner than later.
http://www.phpied.com/3-ways-to-define-a-javascript-class/
Outdated.
Douglas Crockford is bad for your brain. Use some less arrogant and less opinionated source as a base for your thoughts.
Yeah well apparently the issue was something to do with an error in the search function which messed up the JS loading or w.e. Some guy ended up helping me out on stack overflow but thanks anyway ;) [Stack Overflow Answer](http://stackoverflow.com/questions/34713090/youtube-data-api-uncaught-typeerror-cannot-read-property-search-of-undefine)
I don't think you're doing your job properly if you don't want to spend time getting the architecture of your app right. If the configuration isn't granular you'll hit a point where the tool isn't doing what you want it to do, at which point you'll be just as annoyed. You should be looking exactly how your app is put together and whilst I agree all the config is frustrating at first, it allows you to create apps that do very complex things such as linting, transpiling, creating a distribution etc with minimal overhead. What other way can you do that without a bit of configuration overhead? Personally I think this author is living in fantasy land if you think you can get complexity without a bit of config.
the new keyword is because theres no deepcopy / its tricky to get a clean object (because the engine uses references everywhere (for arrays?)). theres also was no `.apply` function back in the day. modules were not available back in the day also new operator is really old. just my $0.02.
- Says Uncle Bob, if you know who he is :) - This was a feedback for the tutorial. The syntax needs to be explained. If I need to go and read Doc, what is the point of tutorial?
Unless using a build system, it's not suited for real world / small website *yet*.
https://en.wikipedia.org/wiki/Chromium_Embedded_Framework https://github.com/cztomczak/cefpython I don't know how to slim the dependencies down without going crazy\*, but QT + PySide + CEF gives you a chrome browser that you control 100%. Some stuff didn't work last time I used it for a project ( POS/kiosk system ) like WebGL Quick overview: Python instantiates CEF, gives it a QT view/panel, your python code can then expose new javascript builtins to your HTML/js project. Better still, you can pass callback references between the languages; backend exposes `events(callback)` JS frontend calls `events(function() { alert("event happened"); });`\** cztomczak just moved from Google projects and seems to be adapting slowly to github... but he still makes commits in a semi-reliable fashion. \* You can eliminate QT/Pyside as dependancies if you go the PyWin32 route. \** I can't remember if the CEF JS&lt;-&gt;Python bridge allows anonymous functions but it's happy with everything else.
Maybe. Take care.
https://github.com/hemanth/is-incognito
No, I knew that after installing babel 6, it failing me at every turn, and instead of wasting my time further, I went back to the version of babel that worked. There's nothing wrong with babel 5, it's not worse than babel 6; just different. A better different, currently.
I guess my point is that *no-one* writes React code by calling `React.createElement(` *directly*, so you doing that will only make things more difficult than they need to be.
(Disclaimer: I’m the author.)
I find Gulp so simple, so it is difficult for me to see why people may like to avoid it. Webpack looks much harder to use and to learn. The configuration is less intuitive and some things don't work as they are, including examples in the official Docs. 
I agree that tools should have sane defaults but if you must do configuration, a well documented succint config file (like yml configs in Rails, or nginx config files) are 10x better than any alternative (web ui, gui, cli, whatever). If you can't be arsed to use config files to configure stuff then your problem isn't with JavaScript but with computing and you should reconsider your career choice.
For multi-module ES6, you need a module bundler (such as webpack), gulp alone won’t do.
I have converted one quite large js projject to typescript and wrote a blog post about the [experience and the benefits brought by typescript](https://medium.com/@tomastrajan/use-typescript-it-s-easy-f9b5b909b52d#.mjcbgs3xz) tldr; As mentioned in other comments, most probably you will uncover problems and erros which you didnt find just by using linter and test + development speed increase
Congratulations for the book. Kudos for spending time writing it.
Is using a function for the replacement something that has been in the relevant standards for some time and therefore widely/universally supported? If so I have a couple of routines that could probably be simplified somewhat. The lack of warnings in https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace suggests so but I don't remember coming across it before. The use of the flags parameter is non-standard, as noted in the MDN link above, which some code I was recently debugging was affected by. Using it works fine in IE and Firefox but not Chrome.
Disagreeing with Crockford is just a matter of having different priorities. He doesn't value tooling at all and he also doesn't care about performance characteristics of contemporary JS VMs. To me, tooling is extremely important and good performance is nice to have. So, naturally, I don't like his ideas which only work in a "lone wolf with excellent memory" scenarios. I need meaningful signatures - even for my own projects. I also may create thousands or tens of thousands objects which I'd like to keep as lightweight as possible.
Technically it was copy-pasted (with a little rewrite from the mentioned MDN page, [see last snippet](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Use_an_inline_function_with_a_regular_expression_to_avoid_for_loops)) Anyways I agree with what you've said, this example is not that good because the String#replace is not used for what it is meant to be used (to return a string) and it has a side effect (modifies the array). The 'something like:' should've looked [something like this](http://jsperf.com/string-replace-replacer-vs-regexp) - I just threw together the exec() example, feel free to edit if you know a more optimal solution.
Doesn't care about tooling? You know he is the author os jslint right?
Question might be better answered in r/java
Now I understand what you've meant, and it looks beautiful. Tbh I prefer FP &amp; readability over micro-opt but I had an OCD-like moment to beat the String#replace in performance that resulted in that jsperf creation.
m4
Well not having type checking is a different debate -- that is a ramification of a language design decision. I've been using Atom, Webpack, and LiveReload to build my JS stuff and it's actually a pretty pleasant experience. If I really wanted a strongly-typed experience I would likely use Scala.js w/ ScalaIDE.
The problem is some people aren't JS-only devs. If you move to pretty much any other development tool chain, you're not lashed punished for trying to keep up with things. Sure, things don't move as fast in C# land, but do you know what I want to do if I want to switch how I write all of my unit tests to e.g Gherkin? I install a plugin. One button press. It's done, I can go start writing things. If I wanted to change *my entire compiler*? Yeah, that's installing one thing too. Installing is just the start of the adventure for javascript land. These tools need more plug-and-play. They need more meaningful defaults. The fact they're so configurable is a *good thing*, but the fact that we have to configure their 99% use case is not.
Just so you know# instead of linking to the bluebird repo, I (drum roll please), have setup [git.io/fast-v8](http://git.io/fast-v8).
Nothing against the author, but I found [this juxtaposition amusing](http://i.imgur.com/44Y6wxi.png). 
Read here about `null`: http://elm-lang.org/guide/model-the-problem &gt; The inventor, Tony Hoare, has this to say about it: &gt; I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.
jslint is a terrible tool that exists only to force you to write code "the way Douglas Crockford likes better".
I disagree about Agile. Agile became a huge moneymaking buzzword, so it got completely distorted. One of the original founders gave this great description: * Find out where you are * Take a small step towards your goal * Adjust your understanding based on what you learned * Repeat Goal being the key word there, you must be aware of your goal. His post is good: http://pragdave.me/blog/2014/03/04/time-to-kill-agile/
Sebastian, the **creator of babel** has actually spoken on this **exact** topic. Yes, you are uninformed. The less a programmer knows, the more they complain.
*~shiawase~*
How would you go about a actually using that promise? ;)
Precisely. I love the functionality of Webpack. However, getting it configured is a pain in the rear that requires a lot of Googling, especially if you want to use Webpack to manage something like Sass (or even plain CSS) in addition to your Javascript. Then if you're using something like Font Awesome, you have to do more configuration to get your fonts pulled in properly, and why aren't things like this just handled using sane defaults?
XPost Subreddit Link: /r/angularjs Original post: https://www.reddit.com/r/angularjs/comments/40h6f0/awesome_angularcordova_puzzle_game_example/
I completely agree with you in the sense of that's what Agile was intended to be. Like you said though, in reality Agile has been completely distorted.
Any hint on the meaning of "we will have some big news related to jQuery 3.0 coming soon"?
&gt;but I have not yet seen an example of that. https://app.pluralsight.com/library/courses/react-apps-with-relay-graphql-flux/table-of-contents You can register for free [here](https://www.reddit.com/r/gamedev/comments/3v7iub/free_pluralsight_plus_for_6_months_if_you_have_a/)
Cool. Glad you like it!
Nice meme.
I think one of the problems with not using the latest tools is that some may fear that they become less employable if they don't know the latest thing. Which I think is somewhat of a valid fear. But I agree, you shouldn't switch to the new hotness just because. But *be familiar* with the new hotness.
&gt; Well just ES6 should be the default. Based on what? Your opinion?
&gt; `.map((v) =&gt; v ? {high:true} : {high:false});` How about... .map(v =&gt; ({high: !!v})); Better or worse?
Yes, you can of course auto-complete local stuff and things from your "IntelliSense" catalog. All that "document.*whatever*" stuff in that video comes from such a catalog (jump to 2:30). This is essentially the same as using a d.ts file (which is what they do at 3:30). Well, if you use this stuff, you *are* using type annotations. You just aren't writing any yourself, which is why things fall apart as soon as the type can't be inferred. E.g. if you use `querySelector`, you get some kind of `Element`, but you won't be able to tell if it's a `HTMLCanvasElement`, because you don't know how that markup looks like. Without a hardcoded special case for `getContext`, you also won't be able to tell which kind of RenderingContext will be returned. But it actually looks like this special case was added. So, if you use an `HTMLCanvasElement`'s "getContext" method with "2d" as parameter, the analyzer will know that the return value is a `CanvasRenderingContext2D` instance. But you still need that one `HTMLCanvasElement` type cast to make that all happen. Everything hinges on knowing this variable's type.
You've got two distinctly different options: - Use React Native &amp; JavaScript. or - Use an alternative JVM language like Kotlin instead of Java. Kotlin is a multiparadigm language developed by JetBrains. It runs on the JVM and has 100% interoperability with Java, but is more modern and less boilerplatey. It's a fairly small language, and it has pretty good functional capabilities (kinda like C#)... If you want to do 100% native Android dev without web tech like React Native, Kotlin is probably your best option, IMO. You might also want to look at Scala or Clojure, but I'm not sure how easy Android dev would be with them.
I appreciate your work and I love your blog, but it bothers me that albeit free, I have to read a book on how to configure Babel 6. They should spend less time trying to make every line of code for the transpiler a module that is used as a plugin to a plugin module that plugs into plugins and more time creating documentation like this book for it's users.
NodeJS, express and Sequelize would be a handy combo even for a simple setup. Pretty easy to learn, too.
I don't see the problem. It literally takes 30 seconds to go to the docs if you're stuck and see exactly how to get up and running, which takes *maybe* a minute or two.
Do you think the fact that configuration of Babel 6 requires an entire ebook causes a little cognitive dissonance? Are you paid by the Babel 6 configuration lobby? ;)
Yes, you can of course auto-complete local stuff and things from your "IntelliSense" catalog. All that "document.*whatever*" stuff in that video comes from such a catalog (jump to 2:30). This is essentially the same as using a d.ts file (which is what they do at 3:30). Well, if you use this stuff, you *are* using type annotations. You just aren't writing any yourself, which is why things fall apart as soon as the type can't be inferred. E.g. if you use `querySelector`, you get some kind of `Element`, but you won't be able to tell if it's a `HTMLCanvasElement`, because you don't know how that markup looks like. Without a hardcoded special case for `getContext`, you also won't be able to tell which kind of RenderingContext will be returned. But it actually looks like this special case was added. So, if you use an `HTMLCanvasElement`'s "getContext" method with "2d" as parameter, the analyzer will know that the return value is a `CanvasRenderingContext2D` instance. But you still need that one `HTMLCanvasElement` type cast to make that all happen. Everything hinges on knowing this variable's type.
We need to go deeper.
Hey, you know, thinking about this further, I have certainly struggled with the "Why NOT just decorate the string prototype?". I know why not, but I'm not 100% satisfied that it is always bad. So maybe consider adopting *both* approaches, by doing the following: - Create a core library of your additional string functions as *standalone* methods. - Create an optional add-on module that decorates string prototype with those functions. - Create an optional add-on module that instead adopts your original chaining pattern. It's not the 'best of both worlds', but it provides not just both worlds to choose from, but the third world of the core string manipulation functionality (which is very much an important thing to have, we've all written various string functions to do things that are not native but are pretty commonly needed).
The way I like to think about dependencies is luggage. I am talking about physical luggage like a suitcase while you are standing at an airport. When I travel I see people packing along all kinds of shit that looks like it weighs a ton. Think about the ticket line when you see those people who can't even lift their own bags that they push along one at a time, and they always seem to have multiple, as the line slowly moves forward. I prefer to pack what I need in a backpack, if possible. That way I never have to claim luggage at the airport and everything is a lightweight carry-on. It is easily portable and requires so little extra effort that I don't even worry about it. Portability is helpful when travel disaster strikes. Imagine your flight it moved to a different gate and you have to quickly jog to a different terminal. If the ~~dependencies~~ luggage is 0 or included then quickly adjusting to disaster is easy. There is less risk that you forgot something and you can ~~deploy~~ move about ease and grace despite the slow people around you.
I considered making a version for Linux since now I only use Linux. The problem that I had with Linux was to find the API that I needed. If you know what API can move windows around let me know and when I finish my current projects I may start working again on it.
&gt; WebAssembly allows you to write code in one language and have it run in the javascript engine. Any language that compiles JS does that too. What WASM does is let you make a trade-off: if you can live without garbage collection, strings, the DOM, dynamic dispatch, etc., then you can get more C-like performance in return.
Not just the GC either, the entire object model. Say, for example, your language wants arrays/lists with slightly different semantics from JS one. OK, now what does it mean to send one of those arrays from your language to JS and back? Does it get wrapped? (Can screw up code that relies on object identity.) Does it get marshalled and converted? (O(n)!) Does it try to monkey-patch the JS array? (Can break other JS code.) Does it try to match JS semantics? (Can sacrifice some of the compelling advantages of your language.) Language interop is super hard.
Meteor is too much of a closed off, locked-in enterprisey solution, IMO. This site might help you: http://nodeframework.com/ Also, if you feel like learning a new language, a lot of people from the Rails community are currently working on the Elixir language and its Phoenix framework. It's quite good and pretty fun to use.
Thanks for the great info!! Based on the table you linked there is NO WAY a anyone can use es2015 in production without compilation. IE 11 support is almost non-existent, and using nightly's to test bleeding edge features is not "production". It is very naive to say that leaving off whole swaths of users is "production" ready code. AFAIK, using traceur and closure-compiler both are fully compatible with es5. So publishing es5 compatible code is perfectly valid. Do you have a project that I can look at that uses un-compiled code with one of theses so I can see what you are talking about?
&gt; I think the real issue isn't that frameworks are popping up faster than the speed of light, but that people feel they absolutely must stay up to date when they really don't. Or that often your choice is to either write everything yourself or learn every build/install/etc tool under the sun because the union dependencies from the libraries you'd like to use includes 3/4 of the JavaScript universe.
I'm going to be really dumb and suggest using a functional method like defaults ( https://lodash.com/docs#defaults ) this.settings = defaults({}, settingsFromArgument, defaultSettings) or if you desperately want it to be the same [as your example], you might be able to do something like this = defaults(arguments, defaultSettings) I'm not sure why using defaults would be a bad thing, but perhaps someone else could enlighten me. However since I've started using Typescript all I need would be: constructor( private propA = "apple" ){} see example: http://www.typescriptlang.org/Playground#src=class%20Foo%20%7B%0D%0A%09constructor(private%20propA%20%3D%20%22apple%22)%7B%7D%0D%0A%7D Also to be fair, if you have multiple properties, you really should be looping through the object and map it to its default value somehow, whether or not you're going to decide to use something like defaults/extend/merge. D.R.Y. and all that. var defaults = { propA: 'apple', propB: 10 } Object.keys(constructorProps).forEach(function(key){ this[key] = constructorProps[key] || this.defaults[key] }) Probably a lot of people going to hate, but keep in mind I'm just trying to give some alternatives I didn't see here. 
Or you know, sensible defaults. 
Well, the thing with auto-complete is that you don't even make those typos which would be caught by the analyzer. This helps with staying on track. Also, as my example has shown, type inference does cover quite a lot. You still have to annotate your functions and classes, but that's so much less work than JSDoc annotations. It's also way more compact. Plus, you immediately benefit from those annotations and they do document your intent. So, there really isn't any reason to not add them. JSDoc vs Dart: /** * Bogorizes the lazer shoe. * @param {number} x * @param {number} y * @returns {boolean} */ function bogorize (x, y) { ... } /// Bogorizes the lazer shoe. bool bogorize (num x, num y) { ... } Not much of a competition, really. Some IDEs can generate some of that JSDoc boilerplate, but I really dread writing that bloaty crap. Anyhow, [JS interop was improved with 1.13](http://news.dartlang.org/2015/11/dart-113-brings-improved-javascript.html), but you're usually working with Dart libraries.
We were dicks to each other, I was a complete dick and so were you. I've moved on, I suggest you do the same.
I think [Sails.js](http://sailsjs.org/) is supposed to be a Rails-like implementation in Node... I don't have any experience with it, however, only what I've read. [Express](http://expressjs.com/) is the de facto standard web framework for Node with [Hapi](http://hapijs.com/) being a sound alternative. That's all server side, for client-side JavaScript you might enjoy [Ember](http://emberjs.com/) for it's convention over coding principles.
No, you do, they are just in game tutorials now. Those that aren't rely on years of learnt behaviour. Button X Fires, button Y makes me jump.
They do say there's going to be breaking changes, question is, how big of a change are we talking about.
Express is more Sinatra-like though. I think I read something about Sails no longer being updated/supported soon a few days ago.
Funny timing on this. I actually just started a new project and went with Knockout because it has support for IE8. Really like working with it still - maybe the switch to Vue isn't complete :)
Looks nice. But just by looking at the palette I see it will not meet the WCAG AA requirement for color contrast. In fact only #313D4C with white text meet the requirement. While this may not be important to everyone, it is surely something to think about when publishing a ui-kit. 
I started pickin up react. I avoided it like the plague for months. Gotta face the music finally.
not sure what you mean by that, it should process everything in the elements folder. You can read [this](https://github.com/HyphnKnight/Teflon#how-to-create-an-element) for more info 
It's going to come pre-installed on every new Samsung refrigerator.
Sass loader? Webpack has a sensible default. you specify an entry file, and an bundle file. Then you start `require`ing your files. Babel on the other hand just doesn't do anything unless you configure it.
I suppose I was a little dismissive of es6 classes. It DOES help quite a bit. It sets the constructor and forces you to use the new keyword to prevent accidents. It is a lot more expressive and easier to read. I think the main point I was trying to make here, was that, with a proper design pattern, you do not even have to worry about the new keyword. 'this' is much easier to work with as you don't need call, bind, and apply as much, especially with calls to super. I wasn't calling class-based design worthless, I've been using classes far longer than factories, I was questioning the necessity of it in a prototypal language that can create objects without classes. Having said that, a standardized way to create objects is actually a really good point.
&gt; use one of the many "base" configurations files that people are sharing through Github Gists, Pastebins, etc. Except that's about as useful and smart as running a `curl -fsSL http://install.this.its.not.bad.i.swear.ru | sudo bash` in your terminal mindlessly without understanding what it's doing. The biggest problem with Babel 6 isn't so much it's basis of going completely modular in an attempt to be a better transpiler, but the fact that they did such a major change from v5 which just worked out of the box to v6 that does nothing out of the box and the documentation is seriously lacking. I feel it was rushed just so that it can be released during a conference presentation, and they sacrificed the know how to use the new version for the oh's and ah's of a mighty modular Babel release.
Oh man, that stinks. Thanks for further validating how much gulp sucks.
Douglas Crockford was not the "base for [my] thoughts". I learned about these ideas from other developers while discussing OOP in JS and then I watched his conference. As a matter of fact I disagree with a lot that CrockFord says. It is on the specific points of using JS without Classes or the new operator, that I became intrigued. I am postulating a question to that idea, not to the man. I am trying to promote discussion of the topic so I can hear other opinions and draw my own conclusions. I'm open to other opinions and this discussion has given me great insight already.
I don't think babel is hard to use to merit an ebook for it, but on the other hand, I'll buy an ebook for 'advanced' webpack configuration; if it exists.
never get it to work correctly :/
Yes, I would recommend using the updateIn method. As far as the filtering and creating a key path, I would create a function that creates the path for you then puts it in the updateIn argument. function createKeyPath(params) { const index = someFilterFunc(params); return ['state', 'elements', index]; } So finally you got: testing = testing.updateIn(createKeyPath(params), element =&gt; element.set('name', 'new name')); 
Do you have any hobbies? One of the things I did as a "small project" to show people I wasn't an idiot was to make a "keyboard", where if you hit keys you would get chords out of it in a C major scale. So if you hit "a" you would get C major, if you hit "s" you would get D minor, and so on. It was actually a little fun to play with too, since you could make music pretty easily just by hitting a few buttons. Chances are good you can do *something* with one of your hobbies like that.
Thanks for the comment / info :)
I was looking at vue.js briefly and it does seem very similar to knockoutjs just with a bit nicer syntax. My only concern is how everything is separated into predefined things like 'data', 'methods', 'computed'. It looks like it would be cumbersome to load and use multiple modules at once. In knockout I often have the main wrapper view model and then load in individual sub view models inside of it. I'll have to play around with it to see if I can create multiple nested vue instances to work around that.
It says minimum 6 dollars, how is that free? 
I usually package my unit tests with the custom element that they are testing. I wouldn't want the tests to be inlined with the element during the build. elements/ ...custom-element/ .......custom-element.html .......test/ ...........custom-element-test.html ...........index.html
How can we help if we see typos in the eBook? Is there a place to submit those?
no argument there.
angular 2.0 kind of changes :p
&gt; Software development is all about making tradeoffs. What was the tradeoff? What exactly did we gain by making this harder to use from the onset? 
The project is easier to maintain and it's more flexible. It enables users to target any platform they want. Babel 5 assumed everyone was targeting ES5, but this isn't the case. Some people want to transpile missing ES2015 features for Node. Heck, if you decide to target Microsoft Edge, you don't need to transpile as many features either.
1/3 of the author's post is asking for something akin to a simple tutorial rather than a stack trace. And no, a manual is not an ingame tutorial. One is in game and immersive andinteractive and lets you get into the game with no prior learning. The other is a manual. How you can equivocate those is beyond belief.
None of that required taking away the defaults. Want to try again?
Easily. I work in UX amongst other disciplines and instead of those large how tos or documentation on a site we replace them with step by step tutorials. It's an oft discussed thing in the UX world with gaming being cited often as a good example of this. How you can't see one as a form of the other is what I find baffling. 
Hi /u/webid11, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hi /u/I-fuck-animals, please be civil. It's ok to disagree, but try not to resort to name-calling.
PHP is why docker exists.
There is not as much "boilerplate" in Android's Java as in J2EE, so at least it's free of all the "entreprise" bullcrap. Anyway, as others said you can do Android dev in React Native or with Kotlin, but in any case it's good to have some knowledge with the native Java to get around. Typically Kotlin is very close to Java so you'll be reading the Javadoc, and with React Native you have to write Java code to wrap native code when it's not already in a React Native module. You can do Android dev in Scala which is a functional language or with Clojure which is a LISP, but I don't recommend it because the Android API will force you to write "Java-ish" code in a functional language. I believe that's much more frustrating than to write actual Java code. My advice would be to start doing Android+Java with an open mind, then switch to something else like React Native. 
Just starting out with Angular. So wouldn't consider myself intermediate at all. But I will attempt this none the less. Thanks!
What would help you as either? Recipe database? How about a website that gets your location and tells you what kinds of plants are worth growing in your area? Then how about integrating with google's solar map to see what sort of sun plants in your yard might get? Really, when I hire developers I care a lot less about their finer skills and way more about their creative processes. I'd probably not hire you if the answer to "What have you been doing while out of work?" was "Well, I don't know what web app I could build for my hobbies and interests, so I didn't do anything...". Build -something-.
That code isn't even syntactically correct. But regardless, object literal can be faster than prototypes in many circumstances, and especially if you're only going to create a few objects that don't require instance methods. If they're just data transfer objects, don't bother with classes, just use a literal.
I'm not sure if this is necessarily better, but you could also filter the entries as updateIn passes over them. e.g.: function whereKeyIs(key, value, updater) { return (v) =&gt; v.get(key) === value ? updater(v) : v; } testing = testing.updateIn( ['state', 'elements'], whereKeyIs('id', 689, (v) =&gt; v.set('name', 'new element index 1 name') ) ); We can simplify this a bit more if we create a new function for our specific requirements: function updateNameById(id, name) { return whereKeyIs('id', id, (v) =&gt; v.set('name', name') ); } testing = testing.updateIn( ['state', 'elements'], updateNameById(689, 'new element index 1 name') ); Although, IMO, the first one is a bit clearer on first read.
I don't know... gets you started maybe... http://codepen.io/anon/pen/ZQyJVe
[removed]
Another way I could do it would be to have a function that executes the stuff I want to put in the loop and only call the function at min-width&gt;767px; That's probably more intuitive. Help is appreciated either way.
[removed]
Yes, but I was careful to say ES6 and not javascript as a whole. Typescript does *not* support all ES6 syntax, which is relevant to the current discussion about learning ES6 or typescript.
good news
nice tutorial but a lot of reading
Thanks for asking! * Described here: http://exploringjs.com/setting-up-es6.html#support * Direct link: https://docs.google.com/forms/d/1u4XUU15C3--mdH7eCIHuRICbBqiFJ_iZX5PSo6H5iqs/viewform
Sturgeon's Law made this inevitable.
Not sure why you're being downvoted because you're right. Most of my ps4 games have some sort of in-game tutorial where you learn how to control the character in a specific way progressionally - as that particular movement is needed. 
I'd expect breaking changes on a nrw major. That's how semver works, after all.
When i read 'no semi colons' i felt my blood boil, punched a cat and stuck my foot through the wall, thats 2016 ruined for me.. thanks
 &gt; var node = document.body undefined &gt; node = node.parentNode &lt;html class=" js cssanimations csstransforms" lang="en-us" xml:lang="en-us" xmlns="http://www.w3.org/1999/xhtml"&gt; &gt; node = node.parentNode Document /r/javascript/comments/40itm0/help_getting_the_ids_and_classes_of_all_the/ &gt; node = node.parentNode null You can quit at the right spot if you compare your node with `document`: &gt; var node = document.body undefined &gt; node = node.parentNode, console.log(node === document, node) false &lt;html class=" js cssanimations csstransforms" lang="en-us" xml:lang="en-us" xmlns="http://www.w3.org/1999/xhtml"&gt; &gt; node = node.parentNode, console.log(node === document, node) true Document /r/javascript/comments/40itm0/help_getting_the_ids_and_classes_of_all_the/
This blogpost lists a bunch: https://blog.jquery.com/2015/07/13/jquery-3-0-and-jquery-compat-3-0-alpha-versions-released/
&gt;Audacious goal of 10K payload size for Hello, World I'd be interested to see how they're going to try get something down to about the size of mithril with the API surface area of angular. Still, these are just meeting notes. Let me know when they've got an official announcement or something. 
Your question doesn't really seem to make sense, if you are looking for the correct syntax for a loop it would be: for (var i = 0; i &lt; j; i++){}
You've got to admire their commitment. jQuery has been maintained steadily since 2006!
SVG class manipulation. Awesome. Been waiting for that. 
I'm just glad OP really engaged in this discussion. /s I don't think spoon feeding helps people learn to be self-sufficient. This is reminds of fresh grads that ask about every single error that pops up. Read it. Google it if you can't figure it out. Learn to fish. 
Haha, this is basically how I end up every single day. I progressively get angrier and angrier as I discover bullshit like this.
Any project management system can become easily distorted. Go try working in a waterfall organization, you'll see how bad it is in comparison and why people moved to Agile in the first place.
The point of using something like standard is to end the bike shedding talk about style and just have the autoformatter take care of it. It's like `gofmt` from the go language. 
&gt; The project is easier to maintain and it's more flexible. Uh no, not it's not.
The length should be mostly irrelevant if the content is good. There's this [impressively long full-stack react tutorial](http://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html) that is certainly worth the read.
Frontend is so complex and over-engineered that you need to actually read a book on using one tool. lol.
Here another one (in fairness, the one I discovered first): https://github.com/sindresorhus/guides/blob/master/npm-global-without-sudo.md It really changed my life! I wish I had seen it 5 years ago instead of the hundreds pages recommending sudo. I can't comment anything on the separate permission cases, this is not the problem I or anyone I know has. I believe 99% people don't have this problem. Also if you don't have sudo permission, how can you sudo? Basically what sudo npm does, it sets root permission for any new directory or file created. After which your legitimate npm without sudo will break not being able to write into those directories. So you are forced to continue sudo npm. Amasingly, even this breaks for other reasons I don't really understand. You end up in deep mess with randomly assigned permissions around your files and unpredictable behavior and tons of errors to disrupt your work.
Second this. If you wanna do android, but are worried about Java then take the Java out of it. 
Yes, I think that's what everyone seems to be agreeing on. The manual has evolved into an in-game, as-needed mini tutorial.
It surely is great to have choice! What is not great is to have tools that tempt you with their promises to save your time that, however, end up in you wasting your time due to the issues described in the article.
I'm not here to convince you to use one over the other. If you see value in it, that's good. If not, that's good too.
&gt; I believe 99% people don't have this problem. I can't speak for how common this kind of issue is, but it's definitely a concern with multi-user environments. If you're the only actual user on your box, then it's less of a concern. &gt; if you don't have sudo permission, how can you sudo? sudo allows for fine-grained user access to executables, so you can grant someone with root-based `sudo npm` powers without necessarily granting them full root. Also, you may not necessarily want all of your devs to install and modify npm packages. Again, mostly a concern for multi-user environments.
http://cdn.meme.am/instances/65251662.jpg
What if the terrorist is disguided as beautiful sirene tempting you into her "wonderful world"? And once you succumb to the temptation, you end up having the terrorists? The sirene never warns you about the rocky road ahead, does she? 
Take a look a http://loopback.io/ from the makers of expressJS
now we just need to collectively agree that jquery is deprecated 
The Arduino IDE or other specialized IOT IDE may not always suits your needs. In my case, I wanted to make a JavaScript project but support for it is not quite good. Plus, as a UI engineer, I already know the tools I use to work with JavaScript. But, using them, I am not able to code for IOT. By using PlatformIO, I can have both. I can deploy code not matter what tools I am using. I use Webstorm as an example but as PlatformIO is a command line utility you can simply deploy using the command line if you want. The extra steps for npm etc are here because in the article I'm making the setup of a JavaScript project.
Indeed, CDN is great for prototyping and [plunkring](http://plnkr.co) but not for your production app.
I've got no idea. When I finally learned how to use Grunt, all of sudden Gulp appears. Then after learning how to use Gulp...Webpack appears. It's a never ending cycle in the web world.
Why is "standard" any better than jslint, jshint, or eslint in their default configuration? Choosing a catchy name for bad practices doesn't suddenly make them good or standard. 
Standard offers you an auto formatter and a set of style rules. This makes it no better or worse than any other set of rules that comes with an auto formatter. However, unlike any of those tools, there's not any per-project configuration. It's a standard, as the name implies, and not a tool that has various rules you can turn on and off as you choose. This basically eliminates bike shedding and frivolous arguments about styling, since you just use the autoformatter and forget about it. Your personal preferences go out the window, but so does everyone else's. You just worry about writing code.
You miss the point. I made a suggestion that you claimed you would be open to. You were not. Think next time before you ask for suggestions.
Is it possible to mention few top things that jspm does better than webpack? Does it have good Gulp-integration?
You are only "nice" until you forget or do it by accident. 
Cool! Now, functional programming is difficult and definitely foreign to a lot of developers (myself included). Personally I think JavaScript makes functional programming worse because it is overly forgiving of mistakes and does not have static typing. For the very first code sample, I set out to demonstrate how an understanding of what the methods do can be achieved with the use of better parameter names, static types, and comments about what the functions do. I was confused toward the end of what I was writing because TypeScript wouldn't compile my version of `sortBy`. Turns out, I found a bug in the author's code (or wherever this code is from) with the use of types alone. In a language like F# you gain static typing more-or-less for free and easily through type inference (I highly recommend checking it out). If I saw this code in F#, it would not be difficult to discern what it does, and how it does it. For demonstrative purposes, I'm using TypeScript. You can view my finished code [here](http://www.typescriptlang.org/Playground#src=const%20has%20%3D%20%3CT%3E\(property%3A%20string%7Cnumber\)%20%3D%3E%20\(o%3A%20T\)%20%3D%3E%20o.hasOwnProperty\(%3Cstring%3Eproperty\)%3B%0D%0Aconst%20sortBy%20%3D%20%3CT%3E\(property%3A%20string%7Cnumber\)%20%3D%3E%20\(a%3A%20T%2C%20b%3A%20T\)%20%3D%3E%0D%0A%09a%5Bproperty%5D%20%3C%20b%5Bproperty%5D%0D%0A%09%3F%20-1%0D%0A%09%3A%20a%5Bproperty%5D%20%3E%20b%5Bproperty%5D%20%0D%0A%09%09%3F%201%0D%0A%09%09%3A%200%3B%0D%0A%0D%0Ainterface%20User%0D%0A%7B%0D%0A%09name%3A%20string%3B%0D%0A%09age%3A%20number%3B%0D%0A%09pets%3F%3A%20string%5B%5D%3B%0D%0A%09title%3F%20%3A%20string%3B%0D%0A%7D%0D%0A%0D%0Alet%20result%3B%0D%0Alet%20users%3A%20User%5B%5D%20%3D%20%5B%0D%0A%20%20%7B%20name%3A%20'Qian'%2C%20age%3A%2027%2C%20pets%20%3A%20%5B'Bao'%5D%2C%20title%20%3A%20'Consultant'%20%7D%2C%0D%0A%20%20%7B%20name%3A%20'Zeynep'%2C%20age%3A%2019%2C%20pets%20%3A%20%5B'Civelek'%2C%20'Muazzam'%5D%20%7D%2C%0D%0A%20%20%7B%20name%3A%20'Yael'%2C%20age%3A%201%2C%20title%20%3A%20'VP%20of%20Engineering'%7D%2C%0D%0A%20%20%7B%20name%3A%20'Yael'%2C%20age%3A%202%2C%20title%20%3A%20'VP%20of%20Engineering'%7D%2C%0D%0A%20%20%7B%20name%3A%20'Yael'%2C%20age%3A%203%2C%20title%20%3A%20'VP%20of%20Engineering'%7D%2C%0D%0A%20%20%7B%20name%3A%20'Yael'%2C%20age%3A%204%2C%20title%20%3A%20'VP%20of%20Engineering'%7D%2C%0D%0A%20%20%7B%20name%3A%20'Yael'%2C%20age%3A%205%2C%20title%20%3A%20'VP%20of%20Engineering'%7D%2C%0D%0A%20%20%7B%20name%3A%20'Yael'%2C%20age%3A%206%2C%20title%20%3A%20'VP%20of%20Engineering'%7D%2C%0D%0A%20%20%7B%20name%3A%20'Yael'%2C%20age%3A%207%2C%20title%20%3A%20'VP%20of%20Engineering'%7D%2C%0D%0A%20%20%7B%20name%3A%20'Yael'%2C%20age%3A%2099%2C%20title%20%3A%20'VP%20of%20Engineering'%7D%2C%0D%0A%20%20%7B%20name%3A%20'Yael'%2C%20age%3A%2088%2C%20title%20%3A%20'VP%20of%20Engineering'%7D%2C%0D%0A%20%20%7B%20name%3A%20'Yael'%2C%20age%3A%20100%2C%20title%20%3A%20'VP%20of%20Engineering'%7D%2C%0D%0A%20%20%7B%20name%3A%20'Yael'%2C%20age%3A%20101%2C%20title%20%3A%20'VP%20of%20Engineering'%7D%2C%0D%0A%20%20%7B%20name%3A%20'Yael'%2C%20age%3A%20100%2C%20title%20%3A%20'VP%20of%20Engineering'%7D%2C%0D%0A%20%20%7B%20name%3A%20'Yael'%2C%20age%3A%20100%2C%20title%20%3A%20'VP%20of%20Engineering'%7D%0D%0A%5D%3B%0D%0A%20%0D%0Aresult%20%3D%20users%0D%0A%20%20%2F%2F.filter\(has%3CUser%3E\('pets'\)\)%0D%0A%20%20.sort\(sortBy%3CUser%3E\('age'\)\)%3B). Let's step through it. The `has` method is fairly simple when you read it. `const has = &lt;T&gt;(property: string|number) =&gt; (o: T) =&gt; o.hasOwnProperty(&lt;string&gt;property);` This could be read as: &gt; Has is a constant lambda executed against type T. &gt; &gt; It take a parameter called 'property' that is a string or number (right here you're probably thinking it does something with an object or array). &gt; &gt; It returns a lambda that takes a parameter called "o" (object? unknown type? throw away var?) that is also of type T. &gt; &gt; On type T is executes hasOwnProperty against the property value specified previously. Okay, that's for sure a mouthful, but for me I know more than I knew when I only saw this: `const has = p =&gt; o =&gt; o.hasOwnProperty(p);` So from here I'd likely pop open my trusty REPL and see what happens when I do `has('a')`. You see that you end up with a function that says: `(thing of type T).hasOwnProperty('a');` Well that wasn't too bad. Now you can see that something like this works: hasA = has('A'); hasA({A:1}); Now technically there is a "bug" of sorts with this, but I masked it by explicitly casting the "property" value to a string. By not calling `property.toString()` before passing the value into hasOwnProperty, we're trusting JavaScript to do this for us, and to use a radix of 10 (See [toString](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString)). TypeScript's type system pointed this out to me. ------ Okay, onto the more severe bug, which is that the sort function doesn't actually work, but appears to for the set of data we're given. Reference [sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) for more information. Sort expects a `number` - either -1, 0, or 1, indicating, respectively, whether `a &lt; b`, `a == b`, or `a &gt; b`. The code sample is returning a boolean. This looks really innocent when you're comparing less than 10 numbers, but as soon as you hit that limit your sorted set is no longer sorted. Run this if you're interested in seeing how the numbers come out this way. `[10,9,8,7,6,5,4,3,2,1,0].sort(function(a,b) { console.log(a,b,a&gt;b); return a &gt; b; })` &gt; [5, 0, 1, 2, 3, 4, 6, 7, 8, 9, 10] So why does the broken sort "work" at all? Because JavaScript will treat `true` as `1`, and `false` and `0`. The sort function never allows for `a &lt; b`. TypeScript's type system made this very obvious with a simple "Type 'boolean' is not assignable to type 'number''" error. Thanks, types! Anyway, for completeness' sake, here's the breakdown of my version of the sort function. const sortBy = &lt;T&gt;(property: string|number) =&gt; // A lambda that executes against type T and accepts a parameter called "property" of type string or number. // The lambda returns a lambda that accepts two parameters, both of type T (a: T, b: T) =&gt; // The returned lambda returns a number based on comparisons of the value of the "property" property in the objects a and b a[property] &lt; b[property] ? -1 : a[property] &gt; b[property] ? 1 : 0; There is another subtle bug with this method, which is that it allows for comparisons of "undefined" values. For example, if you execute `[1,2,3].sort(sortBy('age'))`, a['age'] doesn't exist in the array, and you end up comparing `undefined &gt; undefined` and `undefined &lt; undefined`, which are false. ------ In conclusion, *be careful* please, especially with such high-level concepts. If the proponents, thought-leaders, and authors aren't being careful, where does that leave the audience?
As a new(ish) web developer, I honestly feel like the barrier of entry is too complex. I won't say "high", but the number of choices between languages to choose from, frameworks available, server or clientside relationships, design patterns and more... it jut sometimes feels overwhelming. I first studied in Javascript and now can write some cool jQuery toggles for WordPress websites I work on, but then I also tried to dabble in some PHP to make modifications to the DB and such. But, then you have options like Node.JS - where even seasoned PHP developers who I hired to help on my own projects would tell me "No man, just learn JS! Node is the future!". And I'm stuck there wanting to know what they know so I don't have to pay them (PHP), but then they tell me they see the future as this other language, so I end up conflicted on which path to choose. It just all becomes such noise in the community with the constant updates and changes in libraries and best practices. Sometimes I would remove subs from my frontpage (like /r/web_design or /r/webdev) because I never felt as though I could keep up. Every day brings some new shiny thing to learn that you have to stack up on the pile of "new stuff" growing bigger and bigger behind you. It sometimes feels like a race to the bottom, and for a newbie like myself, all of the complexity between tools/trends just wears you down. But hey, some people get a real kick out of the latest and greatest in tech, and they set the bar super high. I commend them, and recognize that without those people we wouldn't have this amazing ecosystem of apps and tools.
And most people who think they understand UX do not. If you're that adamant that they're different, then fine, but they're not. I'm not going to labour the point.
Sorry i should have worded that better. You're right, any good developer should keep up with what's occurring in their field. I simply meant you don't have to use the latest and greatest for every project, it should be what fits what you're trying to do. 
How do you make developing a jspm application fast? I'm making angular/typescript application. To see changes on a file, I need to refresh the whole browser page, and it takes multiple seconds to reload all of the files. And my app is not that big, maybe a dozen of directives. With webpack, I don't have that problem because only one or two bundle files are loaded.
Pretty interesting use case. What kind of finely grained interactions are happening on the server to the point you'd need a state management library like redux? Or do you have some sort of "universal js" setup where you're rendering your client on the server too?
Don't want to hijack this thread, but maybe we can help, we are hiring JS developer, work from anywhere, there is more than food we can offer ;) https://docs.google.com/document/d/1IRpvt-X8vlqt6cFlpG0qm0w5ayjZi_UA7o5YvA6Z6ZA
We switched to webpack at work as Gulp was seriously struggling with size of our projects - watches were incredibly CPU-consuming. Also we've gone from 200 line gulpfiles to 25 line webpack configs. 
Can you do the reverse where you figure out how many random numbers you need to buy to make a certain expected value?
Gulp, grunt, webpack etc are all good tools that *will* solve your problem. Some people are just desperate to try next cool thing (as opposed to building cool stuff).
yes https://github.com/glued/harp-babel vs https://github.com/glued/harp-babel/tree/babel-gulp-v6 
 import library from 'library'; is the same as const library = require('library');
Cancelled filling out the form when it required me to enter my email address. Should be optional, in my opinion.
Thanks! But what I see is: &gt; webpack is significantly faster at compiling Babel But "compiling" is not the job of Gulp! They have previously used *Browserify* and found Webpack faster, which is not surprising as the latter is more recent. But this has nothing to do with Gulp! Imo it is plain wrong and misleading to blame Gulp for that! Gulp is a runner, not a compiler or module packager. It does nothing but directs streams from plugin to plugin! [Webpack works great with Gulp.](http://webpack.github.io/docs/usage-with-gulp.html) So why not switching the plugins and get back your speed?
Yeah definitely. These types of articles are very intoxicating. They require some restraint on the part of the listener. There's infinite stuff to learn in the JS community at the moment. I sort of hope it calms down at some point, but there's also a lot of cool stuff resulting from all this.
I would challenge anyone to implement this Gulpfile from some of the top Github projects as `webpack.config.js`: https://github.com/FreeCodeCamp/FreeCodeCamp/blob/staging/gulpfile.js
Because Gulp is terrible. Maybe it's good for the specific website people write tutorials about, but I have yet to actually encounter a use case in which Gulp is an improvement. For example, let's say you want to minify JS, minify CSS, and then insert the two into a HTML template. With plain Node that's trivial, a few lines. With Gulp you need to spend hours wading through the package's implementation details, eventually discovering that the only possible way to do this with Gulp involves: - 10 MB of dependencies - Dozens of Gulp-specific plugins - Plugins that warn in their README that they hack Gulp to make this even possible and will probably break with Gulp's next release - Temporary files - Much dirtier, less readable code, at a higher level of abstraction Gulp doesn't solve problems, it turns easy problems into nightmares.
In this case, you don't need to use gulp at all because webpack handles the same job as gulp + browserify + uglify + sourcemaps without those additional dependancies. The majority of what people use gulp for is compiling.
Just like real life. I never get more than 3 numbers.
take a look at tj's frontend-boiler plate, much nicer, no bloat https://github.com/tj/frontend-boilerplate
TJ is one of the top programmers! And this might be easy and readable for him: 'css-loader?modules&amp;sourceMap&amp;importLoaders=1&amp;localIdentName=[name]__[local]___[hash:base64:5]', What I know for sure, this is not something I would like to have in my production code. TJ knows Node 1000x better, so he has no need for an abstraction layer that Gulp is. He can do it in Node 1K times faster. But what is best for him may not necessarily be the best for people with less knowledge/experience. 
Wow, that's hypnotic 
Love this output from running `npm start`: ... &lt;pages and pages&gt; ... [241] ./~/react/lib/onlyChild.js 1.21 kB {2} [built] [242] ./~/react/lib/deprecated.js 1.77 kB {2} [built] webpack: bundle is now VALID. Now where the heck should I point my browser??? Any Gulp plugin I know would tell me that! 
You can use (element.classList)[https://developer.mozilla.org/en-US/docs/Web/API/Element/classList] but it is not supported by IE10. Then you will have a simple and nice elem.classList.toggle("classname");
I watched the whole video and it doesn't show me how to replace Gulp or Grunt. It shows how to replace my bundler e.g. Browserify.
I need to support IE8-11 as it's part of my business environment. Also, it's not the class toggling that I'm having an issue with particularly, it's how I'm targeting the elements that toggle that is throwing UI errors. i.e. up arrows that should switch to down aren't switching back to up when clicked again because another instance of the button exists that has only been clicked once, as in the boolean trigger that says to show an up/down arrow isn't unique to each button but to the whole set of buttons using the same trigger.
Hate is well deserved. What is considered normal and mainstream nowadays is totally fucked-up. Badly.
Isnt the one powerball (not sure what its called in USA, the red one) plus one normal number the exact same payout as just having the red powerball on its own? Why does it make that distinction? Edit: Looks like this is built on top of an incremental game you are building 
The most interesting is his comment: &gt; A boilerplate of things that mostly shouldn't exist. I wonder what was the intended meaning :)
i am open to it. I'm all ears, why would you recommend using this over something else?
Half an hour later, still haven't won anything above $7. EDIT 1 Hour: Won 3 $100 prizes. Return on dollar at a solid 0.09
Angular 2 hasn't been released yet? It's been months. What are they doing?
Another interesting read : https://www.reddit.com/r/javascript/comments/40ef75/no_i_dont_want_to_configure_your_app/cytpcwl
Amen, Webpack config format is a shitemare. Npm scripts, browserify and watchify are still all you need. It's the past and the future imo.
Webpack is great at packaging, but once you start clutter your config with long-named plugins for simple tasks that Gulp can do better (as in my example above), this is the time to add Gulp and save your time and sanity. Especially given that [both can wonderfully co-exist together](http://webpack.github.io/docs/usage-with-gulp.html).
Mind sending me the github repository and I'll take a look.
Interesting App. I like that you have decided to monetize the site in an unobtrusive way. Given the nature of the simulation page, it would be a great idea to refresh the ad every x minutes. Looks like you are using AdSense, which doesn't allow that kind of behavior. But you can do this with [GPT tags](https://support.google.com/dfp_sb/answer/3058726?hl=en) using DoubleClick for Publishers. Relevant [stack overflow post](http://stackoverflow.com/questions/30294227/reload-adsense-ads-or-have-to-use-dfp) 
view page source..
Cool app, but there's some weird stuff in the source. Looks like it was originally a game for prisoners involving candy?
Find the arrow element by using a parent/child/sibling selector instead of a className. That should be local to that specific section, whereas className will find all elements in the document matching that pattern. If you show a more complete example in a fiddle or jsbin, we might be able to help you more.
You should use `map`, `reduce` and `filter` when it makes sense for the manipulation you wish to perform, and `forEach` when it doesn't really make sense to use any of the others (e.g. when you don't need a transformed output array). All are roughly similarly performant. Fall back to naked `for` loops when you need to do non trivial iteration, when performance is absolutely critical, or when you need the ability to short circuit the loop.
As far as performance goes not really. It will however make your coder slightly more readable, when used in the right situation.
Fatigue.... React.... framework something... tooling something... don't care. If you don't want to burn out and become something more than average then simply focus on the basics first. Learn the standard technologies most importantly, because you will always have to troubleshoot this. Prototype everything. Write quick prototypes for the proposed application as quickly as possibly in just vanilla code. It's ok... this will probably be throw away code anyways. If people tell you this will take longer than just building the production ready thing in the favorite framework X its because they suck and haven't learned the basics. Filter the advise you receive from people who lack confidence in the thing they are advising. A cool thing about prototyping is that it proves to the business whether their expectations are remotely realistic. Only after all this should you be prepared to dive into framework and build process insanity.
I can't comment on the performance but I'd like to point out that `forEach` and `reduce` are used for conceptually different things. `forEach` is used to create 'side effects' while `reduce` is used to calculate an aggregate value. Javascript being javascript. you could interchange them but it's usually clearer if constructs are used for cases that they were designed for.
The bigger difference between litteral object and prototyped object (because in JS it's about prototype and not "class") is in the instanciation of objects: var test = { /* attributes and methods duplicated for each object in the memory */ }; var test = new Test(); // all attributes duplicated but all stuff inside the prototype is instancied and if the prototype change, it change for all instances and not only for the current object. To understand you can run this code: function Test( id ){ this.id = id; } Test.prototype = {}; Test.prototype.sayHello = function(){ console.log( "hello" ); } var t1 = new Test( 1 ); var t2 = new Test( 2 ); console.log( t1.id, t2.id ); t1.sayHello(); t2.sayHello(); Test.prototype.sayHello = function(){ console.log( "not hello anymore" ); } t1.sayHello(); t2.sayHello(); // changed for both objects console.log( t1 ); // you can see sayHello isn't an attribute and is in __proto__ And now with litteral objects var t1 = { id: 1, sayHello: function(){ console.log( "hello" ); } }; var t2 = { id: 2, sayHello: function(){ console.log( "hello" ); } }; t1.sayHello(); t2.sayHello(); // if you want to change sayHello you have to do it for both objects, because it's not an instance, each method is "unique" console.log( t1 ); // sayHello is an attribute and is not in __proto__ So instances is better for methods because of the prototype, you use less memory in case of big applications, it's not that simple but it's a good example to let you understand on of the biggests differences in practice.
I'm sorry, I can't tell if this is satire or a long winded shitpost. Same thing I said about it when it was posted yesterday. 
&gt; when it doesn't really make sense to use any of the others (e.g. when you don't need a transformed output array) Do you mean when you need to, say, call a function for each item? Kind of like lodash/underscore's _.each function is used? Lately I've never come across a situation where forEach has been needed, but I've been thinking about when it *is*.
We're using koa as well. It is absolutely bliss to write async code as if it was synchronous.
r o f l
And added some Advt too
If you think js dependency hell is bad and React is "over engineered", just wait till you work on some backend code. Gradle, docker, and Kafka will make wish you could just write some damn code already. But that's how it works in modern development because spending a day, a week, or a month learning a tool may make your team more productive for the next year. It's like this in any non-trivial code project, and always has been. Yes, we should make improvements, but this is not a new problem. I've developing in several languages, C, Java, Clojure, JS, PHP, Python, AS3. Some are better than others, but dependency management and tooling is always difficult.
It shows you how to replace your *build* with webpack. That may or may not be all you use gulp or grunt for, but it's certainly what a lot of people use them for.
Let it me just say, I picked it from a tutorial by a very respectable writer. It makes perfect sense -- he needs to copy `index.html` from `src` to `dist` as part of bundling process. What I am saying is how inconvenient this plugin usage is, comparing to Gulp. I did play with webpack [with somewhat mixed experience](https://github.com/dmitriz/webpack-wish-list). &gt; ... before you decided it was a bad thing? I don't think I ever said that, it surely excels at packaging. But I find it counter-productive to claim it replaces Gulp for every possible task.
I think you should increase the size of the inputs that take the number. At first, I thought I could only enter in 1-6 because the placeholder value is cut off.
This is fun to run in the background while I work. Has anyone hit the jackpot? Does your app keep track of that?
It doesn't make sense though. If it was a dependency for a file, it would be `require`-d in and you wouldn't need to copy. If it's not a dependency, then it's not what webpack is for. No one says webpack will replace gulp or grunt or npm for every single task. Just that a majority of what people use these tools for, building, can be replaced by webpack. If all you need past that are running unit tests or copying some files, you hardly need gulp or grunt at all at that point -- just an npm script or two.
Man, you sound like every manager at every shitty corporate job I used to work at. 
It's the line written by one of the top programmers. People look at it to learn and copy. Soon everyone will use it. Ok, that was a stretch but you get the idea. &gt; everything that is implicit in webpack is explicit in gulp I love that! How true! But wait ... aren't there hundreds of serious articles by smart people in favour of explicit vs implicit?? And if the configuration json is more meaningful, why don't we replace all our code with it? 
Yes thank you for mentioning this! I see the JS community partly going the way of Ruby in this regard, with the ridiculous dependency management and version conflicts. *Back when I was a kid* we didn't have package.json files that ultimately load 1200 dependencies. 
Maybe if standard existed day one like `go fmt` did, I'd have a different position. But the js world is littered with formatting tools with different conventions. Standard suffers from the [xkcd standards](https://xkcd.com/927/) problem. Its actually worse though because it doesn't have the gumption to refer to itself as the be all end all of javascript formatters and tells you to use a fork (semistandard) if you disagree with its rules. How is that any better than changing my jscs preset to something else? Standard also bucks the trend of other javascript formatters. Virtually every javascript style guide recommends that you use semicolons. 4 spaces instead of tabs is the default in eslint, jslint and was in jshint. &gt; in the sense that whence you pick standard (or semi standard), the discussion about style is over I can take this statement and fill in any of my other pet favorite formatters in and make it make equal sense. &gt; in the sense that whence you pick the airbnb preset for jscs, the discussion about style is over How about, &gt; in the sense that whence you pick the the jslintrc from the last project, the discussion about style is over Picking standard vs semistandard is the same cognitive weight on your team as picking any other style, except now instead of configuring it I now have to search npm for the right x"standard" that matches my preferred coding style. Style questions almost always come at the start of a project. Realistically does anyone try to change the configuration after you've set it up? If so you're project has far larger management problems than your coding style. And frankly I'd rather distract those programmers with something meaningless than try to do something worse to the design of the code. Edit: Not to mention that "standard" gives you defaults of provably dangerous syntax (no semicolon) and disallows useful but common patterns such as `(() =&gt; { /* do some work */ })();` and `[1, 3, 7].map(sideEffect);`
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 2414 times, representing 2.5297% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cyvcbr4)
I heard they have a foosball table so maybe they're having a tournament?
A code example might make this easier to help with.
As other have mentioned, forEach and reduce are not equal. I want to point out another difference in the forEach and reduce concepts (not necessarily the JavaScript versions): forEach implies a strict order of operation, while reduce doesn't. forEach will always first operate on item 1, then item 2 etc. while reduce is free to use any order. This allows for further optimizations in some reduce implementations. Example: it would be possible to group items 1+2, 3+4 etc. together in a first phase, and reduce each pair to one output in parallel (using worker threads or something similar). At the end of the first stage, 1+2 got reduced to A, 3+4 got reduced to B etc. In the second stage, the process is applied again: A+B are grouped, C+D are grouped etc. More stages follow, the process is applied repeatedly, until only one item is left. This is not possible with forEach because of the implied operation order.
Uh-oh. One of the test subjects noticed, Bob. What the hell do we do now?!?!
If every project and every team you've ever been on has been totally fine with just picking a guide or file and going, great! Literally not a single team project I've been on has gone without a lengthy discussion about code style. When you pick something like airbnb or eslint, they openly invite you to configure them and change what you want. All standard is there to do is to preempt this discussion and end it before it starts. It asks you to stow your opinions and emotions about semi colons, tabs vs space, etc like any other auto-formatter in any other language. It doesn't have to be so hard. Standard is not meant to be a big discussion. It's just a tool people use to solve bikeshedding conversations about style. 
Interesting! When you say "convert", what kind of conversion is it? If JS is a subset of TS, why do you need any conversion in first place?
In the long long long term shouldn't it rest above 1 dollar? There is a 1 in 300 mil chance to win 1 billion. Expected value is at least 1/300mil * 1 bil &gt; 1.
How closely are you abiding by these strictures? I am a very passionate and dedicated developer with a few years of self-teaching experience. Only recently I've been a professional dev for a small company(who can't pay their bills, that's why I'm looking). I am in the Bay Area. Please take a look at my portfolio and let me know if I should even take a swing thanks! developerdaniel.com
Don't forget that in ES2015 you can use iterators: `for (const x of arr) {...}` Together with generators you can walk objects as well. https://ponyfoo.com/articles/es6-iterators-in-depth
Yeah, but if you're already in Webstorm there are other, easier ways to deploy. If I get a chance I'll reply back with some.
Everything [Axel Rauschmayer puts out is pretty much gold](http://rauschma.de/).
Another look into Ransom32 - if you've ever used node.js or nw.js, you'll be familiar with a lot of what it's doing: https://blog.malwarebytes.org/intelligence/2016/01/ransom32-look-at-the-malicious-package/
They could use tree shaking for it, because you don't need the full API for a simple hello world.
And once this branch is merged it will be up to date with standard, so that is the one i use right now: https://github.com/JedWatson/happiness/tree/standard-fork
I don't understand, you can write "plain node" code in a gulp file just fine and just run a gulp command that doesn't actually contain any gulp specific code inside it.
And here I was thinking things were fine.
For my org, i don't see a real reason to **switch** to webpack. If we were starting all over then I'd see value in using webpack to handle our concat, minification, etc. However, Gulp is so insanely flexible that I can't see us ditching it completely anytime soon
Maybe, but you don't need angular at all for a simple hello world. I'd be more interested in a 10k todo app, where you actually have to meaningfully use the library features.
Depends on a lot of things. If you actually named them `a`, `b`, `c`, then yes, I want the full namespace so I can figure out wtf they're supposed to do. But if you're talking about something like lodash, I'm perfectly fine just importing what I need out of it: import { first } from 'lodash' first([1, 2, 3, 4]) The name of the variable is meaningful enough that I can figure out what's going on from just looking at the variable. Similarly, import { Person } from './models' const john = new Person('John') Works just fine for me, I don't need the `models.Person` to figure out what's going on. Also, something else to keep in mind is if you import what you need out of it instead of the whole thing, we can eventually do tree-shaking on it and eliminate parts of the library you're not using. This is the impetus behind [rollup](http://rollupjs.org/) and will also be in webpack 2.0.
If your functions are appropriately named, I don't see why importing the functions directly should necessarily make your code hard to read. That said, this shows up most for me when I import action creators into my React project, and my general style is to do `import * as actions from '../path` and then call `actions.submitUser()`, etc. But in that case the module is only exporting functions, all of which are actions. Otherwise I think the former style would probably be fine, unless you had a whole lot of functions to import, in which case you'd have a very long import statement.
This is correct. For instance, that would be a "performance critical" consideration. Inside a canvas game, forEach, reduce, and map are all bad for performance, but inside a web app with a small [n] = 1000 it's trivial to fire a bunch of functions. Depends on the use case. A good rule of thumb would be to default to the Array.prototype functions until a bottleneck emerges. Then an optimization with surgical precision is indicated.
Both `map` and `forEach` will accomplish side-effects just the same, but they indicate different purposes in the code. `forEach` tells me that you want to run some side-effects based on each item in the array, but you don't care about the results from the iterator function. `map` tells me that you want to construct a new array based on transforming the old one. You care about the return value of the iterator function. IMO, you should use whichever best signifies your intent. Also, you can use [`Array.prototype.forEach`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) with an arrow function for brevity. const arr = [0, 1, 2]; arr.forEach(num =&gt; someSideEffect(num));
Sorry I can't find a way to remove automatic tags from Baconreader... 
Thanks. I tend to stick to for loops or forEach if I want to directly modify the input, but will use the others if I want a new dataset with the modified values. If you keep in mind performance bottlenecks during development then you don't have to go back and perform those micro-optimizations later.
For the record, I'm on the "use semicolons" side, but I recognize that there are some very smart programmers (including core contributors to Node) who choose not to use them except for in the few cases where they are required to because they understand how ASI works... My point was that people simply don't agree on it or many other things in JS. There are well known open source contributors on both sides.
Well you should split your reducers up in a fashion which is logical to the App. Which is commonly broken down by components or something else. Just do whatever is most manageable.
Good point. While one could use reduce everywhere, as is capable of everything map, filter and forEach can do, those other functions exist for clarity.
I'd say it's the other way around. Are the 15-20 pieces of state independent of each other? Then yes, you'd have 15-20 reducers. You would start out with one giant reducer that handles everything. When you identify parts of the state that are not inter-related, you can split them out (refactor) into multiple reducers that act independently. [The todo example in the Redux docs](http://rackt.org/redux/docs/basics/ExampleTodoList.html) is "visibility filter" being one reducer, "todos" being another. [The reddit example in the Redux docs](http://rackt.org/redux/docs/advanced/ExampleRedditAPI.html) has "selected reddit" being one reducer, "posts" being another, and "postsByReddit" doing all the heavy lifting. Remember to [design your desired state tree](http://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html#designing-the-application-state-tree) before just blindly coding. Diagramming it should make it clearer. Here's some info: * http://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html#a-taste-of-reducer-composition * https://egghead.io/lessons/javascript-redux-reducer-composition-with-arrays?series=getting-started-with-redux * https://egghead.io/lessons/javascript-redux-reducer-composition-with-objects?series=getting-started-with-redux * https://egghead.io/lessons/javascript-redux-reducer-composition-with-combinereducers?series=getting-started-with-redux
Yeah, you're right. Chrome on my MacBook clipped it so I can only see 1-6, but Chrome on my desktop shows me 1-69.
One thing I recently ran into with this is trying to use imports as enums/constants. If you want the compiler to warn you about usage of undeclared variables, you can't use the `import *` syntax: // constants.js export const MEANING_OF_LIFE = 42; // index1.js import { MEANING_OF_LIFE } from './constants' const foo = bar(THE_MEANING_OF_LIFE); // compilation error (good!) // index2.js import * as Constants from './constants' const foo = bar(Constants.THE_MEANING_OF_LIFE); // bar(undefined) (bad!) 
AKA CoffeeScript?
Or you can say *fuck it* like I did and start managing your state with much more ease and luxury. I mean some people need to run in ES3, but me personally, I am fine with my apps utilising ES5 getters/setters and focus on my app instead of redux's awful switch statements: https://github.com/mweststrate/mobservable
This is the attitude that makes the debate so painful. When you are self-righteous about style choices, everyone suffers. 
In case you're actually curious, javascript is a melting pot of people coming from a lot of languages. Functional languages in particular almost never use semi colons. Since babel/ts/coffee/uglify/whatever will insert them in for you, deciding to use them or not boils down to a style decision, and some people prefer how javascript looks without semi colons. 
If you're dead-set on having the logic contained in the key path, you'll have to do something similar to what /u/1nonlycrazi said. Here's what I came up with: function constructKeyPath(context, keyPath) { let kP = []; // this will be our computed key path keyPath.forEach((key) =&gt; { // if key path element is not a function, assume it's a valid key if (typeof key !== 'function') kP.push(key); else { // use findIndex at the current place in the key path to // compute index using function found in keyPath kP.push(context.getIn(kP).findIndex(key)); } }); return kP; } function getWhere(context, keyPath) { return context.getIn(constructKeyPath(context, keyPath)); } function updateWhere(context, keyPath, updater) { return context.updateIn(constructKeyPath(context, keyPath), updater); } The `getWhere` and `updateWhere` take a `context` (the Immutable.js structure we're working on) and an array of keys/functions to compute indexes. Example use: updateWhere( testing, ['state', 'elements', (element) =&gt; element.get('id') === 689], (v) =&gt; v.set('name', 'testing 123') ); It only works for `IndexedIterables` but could be easily modified to work with `KeyedIterables` as well. EDIT: added some comments
Generally you're going to need a reducer for every top level key in the state. If you have a search reducer and a results reducer being combined in the root reducer you *can't* update the results state from the search reducer. Rather, you might have both reducers respond to the same action or use asynchronous action creators (i.e. maybe you have a SET_SEARCH_STRING action which updates the search state, fetches data, then emits an action to update the results state on response) 
"The" compiler? If you care about errors like this, use typescript, and it'll warn you no matter what syntax you use. 
If you are doing pure javascript in there (no DOM manipulations), then your choice will be absolutely irrelevant performance-wise. Just get it out of your head. Right now. Just do the thing that is most readable. If you or your team are functional in nature, use map, filter, reduce. If you're imperative (most teams are), use forEach. 
&gt; when you need the ability to short circuit the loop If you aren't supporting &lt; IE9 then you can use [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).
The switch statement problem is solved. export default function(initialState, handlers) { return function(state = initialState, action) { const handler = handlers[action.type]; if (handler) { return handler(state, action); } else { return state; } }; } 
&gt; Rather, you might have both reducers respond to the same action this is what i was worried about, and am currently trying to avoid. I guess onClick i can just send two action calls, one from my search action and one from my results action to update the two states
Thanks, I've been using it instead of switch statement years already.
A library like lazy.js might be an option to speed this up.
Are you seriously suggesting I should rely on some third-party bullshit to fix my code? It doesn't boil down to style because it can change the meaning of the code. Sure, you CAN write JS without semicolons..but I am of the opinion that it is always better to be explicit rather than rely on the interpreter to put them in for you
Well, I should hope you're using at least uglify of those I listed ... But anyway, I didn't suggest you do anything at all. Just at the end of the day, the code that runs in the browser is exactly the same, so it won't do you much good to get worked up about it either way. 
Having both reducers respond to the same action is not necessarily a bad thing. I would avoid emitting two actions on click though... Much better to have both reducers respond to the same action or use an action creator that emits both actions.
I use AjaxMin instead, pretty much the same thing I think
I starkly disagree. if i have two reducers responding to the same action, i lose the unidirectional flow/endpoint thats crucial to flux. if there is more than one listener, once i emit an action, i no longer have a single destination, but many possible ones. so if something goes wrong / state isnt updating like i expect, i have to search every reducer in my application to see if theyre listening+updating (or should be listening+updating) instead of going directly to the one place i know should be listening+updating. 
Yea, it's Flux. I somehow confused the Flux paradigm with the library called Flux made by Facebook. Sorry.
Thanks! yeah, It's pretty tough out there. 
ah interesting. I don't think I will refresh the ads. they're there just to cover server costs. 
Yes :D
Not yet! we're all still going. There isn't an achievement for it, but it does keep count of the number of times you hit the jackpot. 
This is looking good mate thank you! I will test this out first thing tomorrow morning. &gt; If you're dead-set on having the logic contained in the key path, you'll have to do something similar to what /u/1nonlycrazi said. Actually I am not. Do you have any other ideas how to tackle this setup? As I have explained above I need to work with complex Maps of Lists and Maps. The structure of the map can change easily but the field update logic is the same for the entire process - I just need to calculate the path to the element I want to update. To keep design of new objects simple the end structure it self isn't defined anywhere - the components define what level of the map they currently are and the children are adding new depth on a go. To picture this let say I have this component structure: 'ads'[] -name 'creative' -name 'object_stor_spec' -name 'link_data' -message -link 'child_attachments'[] -id -name All the `-fields` are the leaf components that have updating function hooked up to it. All the `'fields'` define new level of depth(aka path) inside of the structure they can be objects or arrays. Lets say that I need to add/or construct a new object that have a new field `-description` inside of the `'link_data'` I can simply add a new updating component inside of the link data and the structure continue to work the same way. Same with removing - final data structure builds it self based on a child components. I welcome other ideas to tackle this problem my only requirement is easy maintenance or updating/changing the components structure 
Aaah I've fixed it now. Thank you for finding this bug. 
&gt; it's critical to at least be aware of the tools that are out there To some extent. Sometimes even just getting past all the bullshit marketing-speak in framework du jour and trying to figure out exactly what this tool offers you can take an hour or more.
I tend to be a bit more pragmatic - create smaller reducers where appropriate, and for individual areas of concern. In theory - if you wanted, you could just have one massive reducer that handles everything - although that file is going to grow in size pretty quickly. The application state needs to be handled somewhere - and in a more traditional 'Flux' application - you might end up with dozens of stores, or if say, in a non-flux Angular application that is being done poorly - your state is being managed as a smear across your application and no idea where it actually is, or how it's being handled. 
Is this using Regular Expressions?
"Sure, things don't move as fast in C# land, but do you know what I want to do if I want to switch how I write all of my unit tests to e.g Gherkin? I install a plugin." I wish the JS world would understand that more. Write tools that easily integrate (plug in) with IDEs and CI. Sure, my visual studio extensions for JS build tools don't have flashy names. But they just fucking work, in seconds. I just need to bundle, minify, test, deploy, smoke. If I need to paint the kitchen sink later, I still can, but usually I don't need to. Just ... stop with all the overhead. Some of us are trying to get -work- done over here.
You would have to hit those higher paying brackets first. 
Thanks for bringing this up. I've sent it over to our AV Labs team for further review. I apologize for the inconvenience that this has caused and hope to get it rectified soon.
This is pretty neat. I did take a look at co and vo but didn't particularly focus on this part of the code. Thanks. *Edit:- just realized that the code above is just how co is used and not how it's implemented I'll dig into co more to understand the inner workings of it.*
So the idea is to eyeball it, or run it through a visual comparison function? EDIT: doh, should click links instead of reading them. Thanks!
If you have a form, you totally definitely for sure really certain should use https://github.com/erikras/redux-form. It takes care of the form state management, so that all you need to do is write a function that validates the form values and set onSubmit that takes the form values and does whatever needs to be done. The form state gets stored in the Redux store, so you can keep it around if you like so that when the user navigates around your app and returns, they can continue where they left off.
To me 1 user interaction = 1 action.
What do you mean by "not good enough to be trusted"? I still use semicolons but [this blog post](http://blog.izs.me/post/2353458699/an-open-letter-to-javascript-leaders-regarding) makes the case the only time you need them is when with you start a statement on a new line with "(","[","/", "+", or "-". In that case you pre-pend a semi-colon to the line. Edit: s/bug/but
You can disagree, but the reason why redux makes you return the same state as a default, is because the same action is passed through every single reducer and only is processed when it's matched. Even if you decide not to use it, it's going through all of them anyway. That is why you lay out reducers this way: function cartReducer(state = initialCartState, action){ switch(action.type){ case ADD_ITEM_TO_CART: // do stuff default: return state; // &lt;--------- important!!! } } This is kind of the whole point behind redux having one megastore. If your actions are significantly different from each other then yes, two actions are ok, otherwise one is fine. 
I agree, otherwise you're component has to "know" about the structure of your app
map/filter/reduce/forEach shouldn't have much of any difference in performance. Map/filter each allocate an additional array. All four functions should be almost identical under the hood.
Wow, looks like they're rolling back a couple of big changes. I dropped it years ago, but it's somehow nice to still see it chugging along. 
I am using Webpack for both client and server side, so I am using async/await. While generators are similar, their intent is really different and I personally consider using generators for dealing with async tasks as a some kind of hack.
Ah, my apologies for misunderstanding, then. 
/u/wmertens is exactly right. 1. That would be one reducer 2. Don't write your own, use `redux-form`.
Lol was anyone ever suggesting calling the same action twice? This is a fine pattern, I'd assumed you were suggesting calling multiple action creators directly from the component onClick
You're getting into religion now. `forEach` will only do something through side-effects so it's verboten to functional programming.
i'm trying to grasp the concept of the state tree and the role reducers play in it. I've built several applications with flux, so translating from flux to redux, yes by piece of state i mean leafs of the tree. ie any information that would have been found in a flux store which would use setState in order to modify via action. in the examples, there are only 2-3 props that components get. these props would (in flux) be converted to state and the reducers naturally look like flux stores. so when i'm looking at these redux examples, i'm (in my head) translating them from their flux-like counterparts. what these example look like is having a store per state because each example has 3 stateful values and 3 stores. and i just couldnt fathom that being acceptable, which is why i made this post :]
&gt; These are obviously solutions which are specific to my use-cases, but the beauty of having ample frameworks/libraries to choose from is that you can leverage them to create very modern full-stack applications and APIs. Developers love to cry about having too much to learn. But isn't that what you signed up for? An ironic question to ask when the article is saying humans suck at making choices. &gt; The point is, when something eclipses something else in popularity, it's generally for good reason. I disagree. Popularity is very democratic, and often democracy favors wants over needs and there is plenty of precedent of inferior technology winning over superior technology. Shall we talk about systemd for example? :P
There's plenty of use cases for `forEach`, even if you're trying to maintain a mostly functional code base. DOM manipulations, writing to files...basically any time you want to perform some action that doesn't result in a new collection or value. That's not religion, it's just using the right tool for the problem.
its being suggested to dispatch a single action, and let multiple reducers catch it. I'd much rather dispatch twice from the component event handler. granted it would either be wrapped in a single function from the parent container or would be a new creator like your post
Does the lack of ordering apply specifically to the JS implementation of `reduce` or is that the semantics in general? I'd never dealt with that before but it does make a ton of sense. 
Uh, so that is why they suddenly started spamming my mailbox with mails of "trending links". (I got 2 of them in 3 days time.)
`map` and `filter` and `reduce` and the like are all built on top of conventional `for` loops. They won't improve performance; they only help to simplify your code. Post a sanitized example of the data returned from the API you're working with, along with sample code showing how you're working with it now, and I'm sure someone will have some ideas for optimizing it.
yeah a, b,c are obviously not the actual names :) And of course you don't want to have funtions like 'toString' imported, although technically that wouldn't be a problem, right?
Not a technical problem, but just use your best judgement when it comes to names. If it's not clear where it's coming from or what it's doing, particularly if the file is long or the variable name is common, you may want to use the full "namespace" approach with `import * as ...`.
Paper.js and maybe Rails or Django?
If you don't have any timers or render callbacks running, you can also just pause script execution in the debugger. The next time any event occurs that would execute any code, you'll be taken directly to it, paused in the debugger.
I do not know about Javascript specifically. I was referred to the general semantics. I doubt Javascript can parallelize anything in reduce, but other languages (especially purely functional languages) might be able to.
Probably better for you would be to use server for this. Cloud9 and others make available running editor and nodejs app - online editor looks like you are using node installed on your computer. Maybe this is a good way? You can also try https://github.com/systemjs/systemjs - as far as I know it allows to use it in the browser (so you can load various modules) 
I'm sure most people here aren't comparing small snippets of code across all the various runtimes as frequently as I am, but if you do, this tool is for you!
1. Create a much more detailed list of your requirements and use cases. 2. Retrieve much better reponses.
For DOM manipulation I use [NodeList.js](https://github.com/eorroe/NodeList.js) For AJAX I use [fetch.js](https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch)
Sure, would be nice to know more alternatives! But as I said in the article, this is not the only advantage of this method. For example, you can integrate PlatformIO in your CI process.
Dunno. I haven't learned RegEx yet. Codecademy doesn't have it as far as I know.
 // NO (() =&gt; {}()); Oh! I get to hear crockford [talk about dog balls](https://www.youtube.com/watch?feature=player_detailpage&amp;v=taaEzHI9xyY#t=2020s) again.
"Resume/stop Youtube clips with "space" key" use the "k" key instead of "space" and you are done. Also you can fast forward / back the video with "l" and "j".
Use map/reduce/filter when you want to receive a new list for which a method has operated on each value. Never cause side effects in these methods. The difference of side effects/no side effects is the only determinant for which method to use. Here's the [definition](https://en.wikipedia.org/wiki/Side_effect_\(computer_science\)). &gt; A function or expression is said to have a side effect if it modifies some state or has an observable interaction with calling functions or the outside world. Examples: Do this: var numbers = [1,2,3,4,5,6]; var numbersDoubled = numbers.map(x =&gt; x * 2); // [1, 4, 6, 8, 10, 12] Do not do this: var numbers = [1,2,3,4,5,6]; var numbersDoubled = []; numbers.map(x =&gt; numbersDoubled.push(x * 2)); ------ Use forEach when you want to cause side effects and you do not need a return value. Examples: Do this: var numbers = [1,2,3,4,5,6]; numbers.forEach(x =&gt; console.log(x)); Do not do this var numbers = [1,2,3,4,5,6]; numbers.forEach(x =&gt; x * 2); // This effectively does nothing. 
thanks brother. i'll look into these.
interesting idea. Will investigate.
The one thing I don't see mentioned is the rise of static analysis and dead code elimination. In the event a module isn't used the initial `import {a} from "path"` would and should theoretically only pull in module a.
If anyone's interested,... Map: ``` [1,2,3].reduce((acc, x) =&gt; acc.concat(((x) =&gt; x + 1)(x)), []) ``` forEach: ``` [1,2,3].reduce(function(acc, x) { doSideEffect(x); return acc }, false) ```
Hmm... if a javascript variable is defined locally, then it can be manipulated anywhere within the javascript code. So... walking through the code you have up there, not by actual lines but by relevant steps... - 1 declare a global variable and assign to it the numerical value 7 - 2 declare another global variable and assign to it a function with one parameter - 3 manipulate the first global variable within the function; it's saying the first global variable will be assigned a new value that is equal to a number passed to the function X 2 - 4 timesTwo(7) calls the function assigned to the timesTwo variable passing in the numerical value 7 as the local variable number (7 X 2 = 14) - 5 JavaScript typically flows sequentially from top to bottom so both console.logs() should log 7 X 2 = 14 to the console Does that make sense? tl;dr: Variables declared outside of a function can be changed anywhere (global); variables inside a function can only be changed within the scope of that function (local)
I'm not sure how well this be received, but I've certainly felt this problem. I think it's important to remove the emotion when you go to criticize something publicly. It's hard to do, I struggle with it myself. But when you try starting a discussion it's only going to go downhill when you bring in emotion. Frustration is a hard emotion to push past. We've all been there at 6pm on a Friday trying to figure out why someone else's code is keeping you there. We've all struggled to understand some undocumented API. But this is the nature of engineering, and professionalism is a requirement even when it's not someone you see everyday. After the release of Babel 6 (which we all recognize wasn't a good release) we never caught up on documenting everything (which is my own fault). Because of that, Babel has become the poster boy for JavaScript fatigue. It's configuration without documentation, which is a recipe for disaster. But the angry response has been overwhelming. Every single day I'm reading someone else rant about how awful of a job that we're doing. It's been hard to stay motivated– I've practically stopped looking at issues and pull requests. I would also like to note that when you go to complain on twitter. You are not opening up a discussion, you are not starting a dialogue on how to improve software, you are not being productive. You're bitching in 140 characters, and often you're pinging us throughout our normal workdays. I'm trying to focus on my job and I have a notification on my phone that says the software I care so much about is "useless by default". I don't have time to respond with a lengthy explanation about why we did what we did and apologize for not finishing the docs. And so out of my own frustration I often respond very snarky and bitter. I shouldn't– but I do, and I always regret it later. I don't want to snap at our users, I want to help them, but it's exhausting. Babel is not mature software, it's just over a year old and it is one of the most popular tools on npm. People compare it against software that has had years to sort themselves out, and that's unfair. I don't know what my goal is with this comment, I just hope we can all be nicer to one another.
React isn't a framework, it's just the view layer.
I built out my company's new site as a fully isomorphic React based SPA (https://revolt.tv/). Express on the server side, with React + Flummox (going to switch out to Redux eventually) + React Router bundled up with Browserify
As someone who has gotten [a little frustrated at babel](https://www.reddit.com/r/javascript/comments/40ef75/no_i_dont_want_to_configure_your_app/cytp25o) in the comments of these kinds of articles before, it really just breeds negativity all around. But I wouldn't complain about these things if I didn't think they could be better. The whole javascript ecosystem is moving so fast that whenever you have to stop you'll get some whiplash. It's growing pains, really. Here's to hoping 2016 is the year we get rid of that "javascript fatigue". Babel having sensible defaults would certainly go a long way.
&gt; its also probable there already exists an action to change that state on its own unless for some reason the only time that state is changing is when 10 other pieces of states are going to. Obviously it will depend on your app, but that doesn't sound obviously probable to me. &gt; additionally if you update 10 actions with one call, youre going to be sending an enormously bloated value to the action argument of your reducer. Either you have a very *very* unusual app design (and need to provide more details before we can really help you), or you completely misunderstand actions. The general pattern is a user clicks the "create new game" button; the onClick handler dispatches the createNewGame() action creator, which whirs away and dispatches an action that looks like `{type: NEW_GAME_CREATED}`, and your 10 reducers (or whatever) match it in the switch statement and update their branches of the global state tree to reflect this action. In some cases, you may need to attach some data to the action (maybe the user has filled out a game name, type, number of players, etc.), so you end up with `{type: NEW_GAME_CREATED, payload: {/*...*/}}`. But the number of reducers who want to know the game name doesn't change the size of the action; you still only have one copy of the game details being passed around. (And remember, every reducer gets every action; we're talking about changing which branch of the switch statement matches, not how many switch statements get run.) On the other hand, your suggestion *does* bloat things, since apparently you're thinking of dispatching `{type: NEW_GAME_CREATED_GAMETRACKER, payload: {/*...*/}}`, `{type: NEW_GAME_CREATED_CURRENTSESSION, payload: {/*...*/}}`, `{type: NEW_GAME_CREATED_PLAYSURFACE, payload: {/*...*/}}`, `{type: NEW_GAME_CREATED_HIGHSCORES, payload: {/*...*/}}`, etc. Which means: 1. 10 different reducers means you are duplicating the data 10 times 2. Every reducer is now getting 10 times more events (since every reducer gets every event). &gt; assuming each state is updating to something different This may be the core issue: This suggests you think the action is providing the new state to the reducers. **This is completely wrong**. The reducers are responsible for calculating the new state based on the action, not blindly accepting a new state *from* the action. &gt; what youre describing is the antithesis of single-responsibility programming I assume you understand single-responsibility programming; I don't think you understand actions, action creators, and reducers.
I totally understand that feeling, it was my initial response when /u/sebmck told me that's what he wanted to do. I make [fun of it](https://twitter.com/thejameskyle/status/686406212586344448) all the time. But docs *are* the fix to the problem. Babel 6 has more steps but it's not actually any harder to setup. i.e. to get 6to5 just: ``` $ npm install --save-dev babel-cli babel-preset-es2015 ``` Create a `.babelrc` that says: ``` { "presets": ["es2015"] } ``` And in npm scripts add a `build` script that runs: ```js babel src -o lib ``` Note that this is really only one step more, and one that when explained simply is very easy to get. I've gone into great detail about the reasoning why this explicit opt-in is better than implicit behavior. There's a lot to the reasoning so I won't get into it here, but I'll write about it in the future. &gt; Here's to hoping 2016 is the year we get rid of that "javascript fatigue". Don't hold your breath, 2015 was not the start by a long shot.
FIGHT FIGHT FIGHT FIGHT
glad to see lodash-fp make it
&gt;Criticism is a good thing. Actionable criticism is even better. But personally attacking each other out of frustration is just sad. The next time you make a comment or write a blog post, ask yourself if it’s actually productive. Less fighting is also good.
I won't claim that that interpretation is completely unreasonable, but I would say that if that's having you avoid lodash, re-evaluate. Disregarding any thoughts you might have as to the community management / etc, the engineering processes of lodash have been rock-solid for years, and it shows. Extensively unit tested, in all browsers, loads of powerful functions, etc. The readme says it well.
I can't believe just now I learned this exists, thanks!
The best advice I've seen on this topic is: &gt; "The only constant is change. Teach yourself how to learn new things faster and it won't be so bad" I don't remember who said it.
React + Flux/Redux is the best
I definitely don't want to pour over the babel source code to figure out how to set the darn thing up! Commenting your code is for a totally difference audience than the documentation for it.
This post wasn't a means to pull you into negativity, it was a means to give my side of the story, that I fit into on the opposite side of your story. We both were dicks to each other and what I am saying is I'm sorry, I realize yesterday when we were going back and forth I was being a huge dick, but I've never been reacted to when expressing frustration with a project. Normally people reach out and attempt to mitigate the issue, not attack. You and Sebastian are creating essentially THE most important tool for modern JavaScript. I am sorry for our back and forth, my negativity towards you, and I accept your apology, will you accept mine?
Front End: Paper.js | Back End: Nodejs or Python (if you use Nodejs have the client side of Socket.io also)
Have to say I'm not very happy about some of the aliases and such that were removed. Maybe it's just me, but I really preferred the names `any`, `all`, `pluck`, and `where` over `some`, `every`, `map`, and `filter`. Don't get me wrong, I totally know and use `map` and `filter` on their own, but the alternate names helped reflect intent.
Some advice to start: turn off Twitter notifications. You don't need to know about it the second anyone tweets you. Pick a time to look at Twitter and skim your mentions.
I'm not sure what it really is in January 2016, but I'll bet the answer will be different in December 2016!
Yes I accept your apology too. Thank you
The problem is I do want to see the things where people are genuinely asking for my help or letting me know something. Before the Babel community exploded we tried to respond to issues within a few minutes (which obviously doesn't scale but still). 
My understanding is that Ramda is painfully slow in comparison to Lodash. But I'm also not that informed on the matter.
*psst* try reading the article...
Intriguing to see how /r/javascript sees it versus /r/web_design For whatever reason, /r/javascript seems to agree, while /r/web_design strenuously disagrees: https://www.reddit.com/r/web_design/comments/40mmtk/the_sad_state_of_web_development/ I find the constant churn makes it very difficult to enter the field.
&gt; Wow, throughout this thread you seem extremely biased. Aren't we all? :-) My whole point was to have a factual and fruitful discussion and understand the real reason people want to "ditch" Gulp. &gt; Build systems and code are substantially different contexts. Why should they be? I find it much easier to re-use my modules and helpers for both. Why learn 2 languages if you can get away with 1? :) &gt; I just want some modules, ES6-to-5 translation, React handling, dev serving, sourcemap, minify, uglify, etc. as quickly as possible - with the possibility of explicitly modifying it later if necessary... And here we have the problem! As you just said, webpack is not explicit, Gulp is. &gt; I'm personally not a fan of most projects' Gulp files having a huge amount of slightly different boilerplate that's necessary to achieve the same goals. And now? Tons of slightly different webpack configs, half of which is broken? Or gets broken because people have to use babel for every minimal thing, and babel likes to play around and break those things. 
Babel 6 may have been a messy release, but I really like how it turned out. Using all plugins is exactly what I had been wishing for since I first saw it, and despite the people that will bitch that "nothing is included by default!?", it allows anyone to be lazy and install a preset, or go all out and only add the parts I need compiled. And holy shit it works fucking flawlessly for me! 
What are you serving your website from? Php / apache? CPanel? Wordpress? Nodejs? etc
Would you agree then, that for a developer who only needs what Webpack provides (bundling, sourcemaps, minification, transpilation, test server), that Webpack would be a viable solution over implementing the equivalent in Gulp?
The only thing I'm entitled about is for my boss not to pile on tasks (some very complex) on us like we're objects and tell us "It'll only take you 15 minutes"
Unless you use Jest, unfortunately. They're behind on getting it updated :( if you use it, you have to require().default everything ... why I haven't upgraded yet. Tried to ping the maintainer on how I could help contribute, but haven't heard much back from him.
This is literally now in that article: &gt;I removed the section where I called out the creator of Babel by name. Honestly I overlooked the statement as a personal attack. I apologized to him publicly and hope to talk to him more in the future. — Drew
You can use https://www.npmjs.com/package/babel-plugin-add-module-exports
I bet you don't hear enough from the appreciators. We use Babel at my work. We were comfortable recommending it for a mature product and we haven't had any issues. We're also not the kinds of people to complain about software on twitter, medium, etc. I suppose we're also not the kinds of people who praise it often enough, either, I bet. Thank you for your work. I know that in some cases it has helped get people excited about JavaScript who previously frowned at the mention of it. That's quite an accomplishment.
Cats don't need as much time. And turn off twitter while you work if at all possible.
This sums up why I do not make anything I develop publicly available for free. I did years ago and regretted it every time. I developed a very robust Wordpress listing plugin years ago and open sourced it. It got picked up by some prominent blogs and over the first month had over 30k downloads. It was a total nightmare! Request after request of things people wanted added and a crazy amount of support requests. I couldn't keep up and I got attacked for not jumping on every request. I later offered a paid option where I was willing to make customization or offer support for a fee but people flipped out over that. I ended up taking the plugin down and always go back to that when I feel like I want to open source something. I find that sad because I know a lot of other developers that have had similar experiences no longer open source either. There are so many small things I have wanted to put up publicly on GitHub but haven't.
[I haz cat.](https://www.instagram.com/p/s-if1dTQLZ/)
In my opinion there's a lot to be said for letting things be _done_; in particular I think this is true of CoffeeScript and Backbone. Features from CS made their way into ES6. And Backbone made its impact and then has been superceded by libraries/frameworks that provided more for interacting with the DOM. Unfortunately, Lodash is not nearly as concise as Underscore, and I'm feeling a little bit of a hole in that department. 
That is a very good idea, we should do that. I've opened an issue: https://phabricator.babeljs.io/T6956
That's right. Also, Ramda is still going through significant breaking API changes. Before v4, Ramda and lodash-fp were quite different. As of today, lodash-fp is fully immutable and has adopted many of the most popular methods from Ramda. Ramda is more purely functional, sometimes at the expense of usability and performance. Unless you want a purely and almost fully functional application, I don't see many wins for Ramda over v4, but it's hard to say since v4 just came out.
&gt; This is critical response but... This is a totally appropriate and reasonable response, I don't mind criticism at all as long as you do it appropriately. Which you have done so thank you. &gt; Every additional command you have to run might as well multiply the complexity by 10. People are used to npm install; fine. But when you get to I choose the word "difficulty" intentionally. Something with many steps may be complex but it is not inherently difficult. For getting started, people don't need to know everything. They need to be lead to success which is what documentation is for. However, I despise shortcuts. When tools have a "getting started" version that looks very different than what you need to do in order to accomplish anything more complicated you end up with people who never get passed the getting started phase. Setting up Babel is an opportunity to explain things to people like "Where does Babel configuration live?", "Why should I install things locally in my repo?", or "What are npm scripts?". At the end of the day you have better informed users who will ultimately be more successful. The response I gave above was an overly simplified explanation that was meant to make a point. I wouldn't say that this is good documentation. I have been working on a Babel User Handbook for the last two months to go into extreme detail about using Babel. Writing is slow and difficult but once published I think it will settle many of the frustrations people have.
But see even you don't quite understand what I meant. Babel *is* production-ready, some of the largest tech companies in the world use it. But being mature is something totally different. It means that it's out of the "hip" phase. The code may be good, but the community and documentation is in flux.
That's a shame dude. You should definitely open source your stuff and simply ignore the haters. There ARE cool guys that know you have a normal job, family and everything. This shouldn't stop for making open source.
Ah that's who it is. 
Where I work, software lasts about five years. This year we're approaching Year Five on things, and looking at the landscape of new tools, it's like we've opened our front door to discover that everything's on fire and the entire world is running naked through the streets with roman candles up their arses. And it's hard to make a business case for "Everything you know is wrong and not only are we replacing our development tools, but those tools have multiplied 10x." This happened ten years ago with RoR: "Hey, we're a java shop. What's the next big sea change in software?" And we opened the front door and everything was on fire. I raged (railed?) then. And now Rails is ...well... does anyone use Rails now that wasn't using Rails in 2009? For *business*, if you're a small shop doing things on the web, 2015 has been a horrible year from an "investing in technology" standpoint. Because with the death of IE8, and the settling of the Node Wars, development has come un-stuck, and now everything is tumbling about in chaos as frameworks vie for supremacy. And it's nigh impossible to look back over the past two years and say "it's okay to pick a winner now; things are about to settle down" when asked to invest money in training and development time. If my job were sitting in a coffee shop working on things freelance? Screw it, I'd be switching from Grunt to Gulp; hell, I'd invent a better Gulp, my github would be legion. But in a company that has to write its own checks, right now, this minute, the landscape of choices makes me want to step back, close the front door, and go back to JSF and ignore this orgy of battling-for-supremacy.
Note that lodash already has quite a bit of lazy evaluation, implemented here (and likely elsewhere as well): https://github.com/lodash/lodash/issues/274 This is reflected in recent performance tests: http://danieltao.com/lazy.js/comparisons.html https://jsperf.com/lodash-lazy 
Babel has had an enormous positive impact on the JavaScript language. It's helped shape language standards, and it's driven up adoption of new language versions immensely. JavaScript is less shitty and Babel has helped to get it there. There's a phenomenon where people are more likely to criticize small flaws in great tools because the flaws stand out among all of the awesome. You're right that you don't deserve the vitriol.
Nothing useful to add, but since you mostly only hear all the negativity, I wanted to share some positivity. I just started using Babel a few weeks before the v6 release. It worked fine for me before v6 and after a few minutes Googling it worked fine for me after v6, too. I mean, I had to set up an object, but that's no cause for complaining and sensationalism, you know? Thanks for your work on Babel, it really is a wonderful tool.
You don't necessarily have a problem if you need to use multiple loops. There are a huge number of algorithms and general problems that are solved with multiple loops. Even the highly efficient [merge sort](https://en.wikipedia.org/wiki/Merge_sort) uses nested loops. Everything that happens in JavaScript is the result of nested loops. Server daemons are often implemented with a large outer-loop that delegates to smaller inner-loops.
Even me? I'm just ordinary user :-) I've only meant it as example, a bad one, you are right, sorry :) "Production-ready" is actually a dangerous loaded term, which may be differently (mis-)understood by different people. Some people expect business-like support, some -- well written updated documentation. It is hard to change peoples expectations, unless you are 200% transparent about everything involved -- code, documentation, support, backward compatibility, deprecation cycles etc. 
I've been through this all before with jQuery, so here's my advice. A popular open source project that grows quickly is like any startup going through growth. You need a team of people who can share the load. You and sebmck shouldn't be bearing this all alone. I know it's easy to say "you need a team" but hard to do. Still, we often turn away people who are enthusiastic and willing to invest their time in the project, but who we think may not be "good enough" because they lack the technical chops similar to the existing team. This is one of the *worst* reasons to turn someone away because we don't need more of ourselves. We need people with different skills, especially as the project grows and its needs change. If you are incredibly frustrated by triaging clueless or angry bug reporters, find people who can empathize with them and guide them to the right place. Figure out why they're reporting misguided bugs and get someone to write documentation to set them on the right track. Babel is heavily used now, it should be possible to find people who would like to help in order to get some street cred. I'll also point out [this recent video](https://www.youtube.com/watch?v=HWzEF1P-bvI#t=6h24m19s) from John Resig with some of his thoughts on the subject. John did a great job getting the jQuery project started, and the team we built is still going strong today. Ping me if you want to talk, and congrats on a successful project! All the people on this thread who use Babel, why aren't *you* contributing to it right now? Have you considered how you could help? 
hey I love Old Bay too
You could store it in localStorage when you're using Cordova. As far as I know it will save the data across pages however I'm not sure how long this data persists in Cordova apps, it may only persist until the app is closed. In traditional web apps, localStorage only persists on the same subdomain and protocol. Local Storage stores key value string pairs, so the easiest way would probably be to create a JSON object with a key that's value is an array of strings with the data you are saving. When saving this to Local Storage you would use JSON.stringify() and on the page you're reading the data on you would turn it back into JSON by using JSON.parse() In order to save the data in a json file you would need to research some Cordova specific plugins for file IO, so I don't really have any knowledge there. All the Cordova apps that I have done I have written a server component and used AJAX to get/write data to a database.
&gt; I upgraded too soon Love that! :-)
honestly I see it as babel saying, "Some day v8 and node will be in a state that you no longer need me"
Sad to hear, but it might be just lack of transparency. Some people just need to be told 4 times. Having a visible disclaimer stating exactly what they should expect, may go a long way.
Because their community used to be the place where all the hip, cool people hung out. Now it's JS.
Yeah I believe that was part of the issue. I didn't really think it was going to get such as big response so I didn't think about adding support disclaimers. I added them after it was released with 1000s of downloads but that seemed to just make people more upset. If I release something OS again, I will absolutely put large bold disclaimers upfront.
That is a great suggestion. Maybe I will try again. I have a small piece of a project I am currently working on that I have been considering putting out there.
Might be because the Javascript field is currently configuration heavy which contradicts Rails' philosophy of "convention or configuration." 
Indeed, the early the better. But don't feel discouraged!
Won't sugar coat my experience trying to upgrade to Babel 6. Sure, I could of just stayed at the latest version of five that worked so I'm to blame as well. Reading through the comments, you hit the nail on the head in one of them. The lack of docs was pretty painful. Especially the transform plugins, and the difference between some of the similar sounding ones. Oh and the switch to the new bug reporting tool, I actually had to join the Slack channel to find out! Nevertheless, I mean...it is actually not that hard to put together now. People did pretty solid write ups about half a month into it and now I get it. There is quite a lot of whining recently about fatigue this and that. I actually agree with the direction you are taking Babel and the necessity you had in taking it there. 5to6 is going to be put to rest once all features are implemented across the board so you had to change your goal and what you are offering, along with plugins for multiple things, makes sense and is quite powerful. But to be the poster boy of JS fatigue?, that is just noise to me. Pure dumb noise. As an engineer, we like to tinker. I don't see the big names talking about this JS "fatigue" for good reason, most JS engineers don't mind. I like that I can pick and choose what I want to bring in from babel. I like that I'm responsible for what I put in there. This having a default and "being super easy plug and play" is an unrealistic pipe dream that doesn't fit with the industry in my opinion and has been that way since I can remember. You can't take a few minutes to configure software that is free to you and want to write a blog about it? Then don't use it. Write a script that configures it for you and share it. There is a wealth of options, and people are complaining about it? Pick one, use one. That simple. Any pains you have from changing are your own! Anyways, I can't imagine what it's like supporting a project for free and hearing that kind of noise. If it makes you feel any better, I felt really guilty afterwards after I told a coworker that "Babel is trash now" when I tried to upgrade and gave up after ten minutes. I felt like such an ungrateful ass. I try to be super apologetic when I open bug reports, so I think that feeling of guilt means I'm human.
I enjoy reading about all the new toys and playing around with them. When it comes to actually selecting libraries to use for work, I'm very, very picky and conservative.
Two reasons why this is only going to get worse. 1) Cargo cult programmers. 2) Bootcamps which are churning out cargo cult programmers. I am working with a couple now. They have no idea why software does what it does. They string together modules into different permutations until what they're stringing together "just works". They don't take the time to dive into the source they are actually working with to understand how it works because they are in a rush to slap something together to hide the fact that they are cargo cult programmers. I've tried to show them how important it is to take the time to dive into the source and write tests so you're not just changing a line of code, refreshing the browser, and repeat. They aren't contributing to OSS because they don't know how, but they are desperately consuming it as fast as they can.
Gulp doesn't suck, it is misunderstood. [Gulp task returns a stream](https://github.com/gulpjs/gulp/blob/master/docs/API.md#return-a-stream)
Hack? How so? If anything I think async/await is syntactic sugar for the pattern that generator uses for async tasks. My understanding was that async/await does something similar to what [task.js](http://taskjs.org/) did but with built in language support without having to add third-party libraries.
We don't want people configuring Babel globally that causes more issues than it solves. Here's an excerpt from the (hopefully) soon to be published user handbook. https://gist.github.com/thejameskyle/0a12e411a556bbf76130
"use strict"
We don't hope that Babel will some day go away. There's a *lot* of useful things in there that other tools can and should take advantage of. Even if JavaScript was declared complete and every browser supported all of the things. I would still use Babel every day for other things.
&gt; I don't see the big names talking about this JS "fatigue" for good reason You don't see it because they feel responsible for it. It's really a terrible feeling when people are upset about the software your pour your life into. There's a lot of discussion that happens behind the scenes about what to do about it that you are likely missing.
The change to config was not a change from default to non-default, it was a change from implicit to explicit. We can now think about Babel as a compiler separately from it as an implementation of a language. Babel is not a "to-JS" compiler, it's a general purpose compiler that hopes to unite a lot of broken and divided JavaScript tooling.
The problem is not Babel itself. It is the philosophy of front end dev. Too little modules. Dependency hell. Too many tools doing the same thing in slightly different ways. Leaking abstractions everywhere. For a simple SPA of one page one ends up downloading the entire fucking internet. Etc. It should not be this way. I think the article is saying this.
Yeah, I know. And yes, the fact that `_.map()` now takes a property name as a shorthand means it's basically a search and replace. On the other hand, we've got `_.pluck()` all over our codebase already. Ah, well. No need to upgrade to Lodash 4 any time soon, really. 3.x is fine for us for now.
If you're referring to the original article about the "state of web development", I understood what that part of the message was about, but it resorted to personal attacks which is unacceptable. Babel is actually the only popular tool that does what it does. A big part of the reason it was created was to avoid having to download half the internet because it avoided depending on a JS heavy runtime.
Sounds like you need a 'Cloud IDE' - e.g https://c9.io/
But I just started learning Go... fuck.
I didn't even realize that was Ryan Dahl. The author of that post is a huge asshole for going after the individuals behind these projects.
Browse some examples on [codepen](http://codepen.io/) and get inspired. You can even turn Babel on in the JS panel! This [black hole maker](http://codepen.io/akm2/full/rHIsa) has always got me making random canvas stuff.
Yeah I think ad hoc is the way to go with any project that isn't of a large scale or for an API that isn't going to be used by lots of projects across multiple teams. What initially drew me to it was the fact that you have a single endpoint for all your queries which sounds nice but when you really think about it, you're replacing the complexity of multiple endpoints with the complexity of a query language so I didn't see how that really bought you anything. Either you create and document/remember a bunch of endpoints or you learn a query language.
I never like to opensource anything mass-market like that. Strictly development centric stuff, particularly where there is already a strong emphasis on DIY and collaboration. Opensource isn't for free riders, it's for freedom.
I want to engage and ask "Why am I a bully?" but I know how this ends. However small, you're making a personal attack at me and engaging it seriously will not change your mind, it will only serve to bring you the attention you so desperately crave. Also– [take your sexism](https://www.reddit.com/r/javascript/comments/40pag0/the_sad_state_of_entitled_web_developers/cywdf9a) and fuck off.
I didn't see that anywhere. Link?
I have an idea. If you would like a ton of positive reinforcement, send out a Request For Support to the community, in the form of donations. Make sure you include an area for comments. Those who donate should have good things to say. Cash is cool too.
I don't want to ask for people's money. That *feels* wrong to me.
Oh, I'm just having fun. I'm not condoning "fighting". Take a joke, everyone.
It stops folks from talking crap, so there's that ;)
Not all loops that short circuit are looking for a value in an array.
https://github.com/thejameskyle/babel-plugin-handbook and http://astexplorer.net are good places to start
I would have liked the old names to hang around as aliases purely for the sake of backwards compatibility and making upgrades easier. 
And if you think Babel doc is shitty, just try reading the MSDN...
https://developer.mozilla.org/en-US/
What? I left it running overnight, and it's only at $190K Spent. What browser do you use?
When babel6 first was released, and I wanted to move to it, I had to actually go to someone's blog to find out that I needed to install the es2015 preset now. Having to install and configure something myself is not bad in and of itself though. The big problem was that there was no official documentation that was holding my hand when moving from "configured by default" to "configure yourself", and I think many people really tripped on that one. Though I think that is something you acknowledged yourself already. I really like writing in ES6 and babel has given me the opportunity to actually write production ready code in ES6 and have it work in many browsers, so thank you very, *very* much for all your hard work on babel. (On an unrelated note, I haven't been able to move to babel6 yet because of the change in transpilation of `export defaults` when using commonjs breaking compatibility with my ES5 modules. So maybe things have changed now. EDIT: found out there is a plugin now that restores the previous defaults behavior, so I am now using babel 6!)
Agreed. With the adoption of HTML5 finally going strong and how the bigger libraries and dependencies like Node have evolved, its much easier. Thing is though: its not easy anymore. You need skills in multiple areas now. First it was simply making some HTML, CSS and perhaps deploy it on a PHP server or whatever, but now you have to deal with CDNs, Plugins, security issues, hosting (i don't like hosting nodejs applications, its not as easy as with php yet), etc. And people expect you to be an expert in everything. And yes, the original post about Javascript was just abysmal. I didn't even get any further after he started trashing Javascript so bad. There are many things you can do to not let Javascript annoy you. Heck, what annoys me is that it is transforming into the languages i don't really like. How C++/C#/Java devs influenced Ecmascript 6 is terrible. It completely changes everything and i feel that its easier for them to go from Java to Ecmascript 6 then for me to go from Ecmascript 5 to 6. Big reason for the change is that they were forced to adapt certain ways to do stuff that they don't really know how to do it or to set some concepts aside that don't work for Javascript as it did for them. 
Hey, I just jumped into this React/ES6/Redux ship a few months ago and I'm bringing some friends, and I just want to say sure. It wasn't a walk in the park to figure all this stuff out, but it's not impossible either. Could it be better? Sure. People should work to make it better rather than shit on an amazing tool despite it's age. Keep on making great things, and hopefully one day I will consider myself good enough to help in that regard.
Years ago in the mid 90s Free and Open Source software was fringe phenomena which was just breaking through into the mainstream computing consciousness. Linux, Apache and other big open source projects were getting attention and a lot of virtual ink was spilled explaining what this open source and free software thing was and how it worked. A lot of time and text was spent looking at how to run a successful open source project and how to participate in an open source project. It is now about 20 years later and we have a whole generation of developers who have grown up surrounded by open source software (not to mention a ton of free and freemium stuff on the internet) and often don't understand that these project are often run by volunteers, nor how to interact with open source communities in a positive way. No one blogs about how to run and participate in open source communities anymore and we are now the worse for it. This is especially true for the JavaScript community which has a mostly young demographic and doesn't have many roots in the old code sharing *nix culture of the past. Here are some links I pulled off the google to get the ball rolling: * [A guide to participating in an open source software community](http://oss-watch.ac.uk/resources/toptipscommunities) * [How to build an open source community](http://oss-watch.ac.uk/resources/howtobuildcommunity) This has some good advice for anyone who is already in an open source project: * [How Open Source Projects Survive Poisonous People](https://www.youtube.com/watch?v=ZSFDm3UYkeE) 
babel-plugin-lodash-modularize now supports lodash version 4. https://github.com/gajus/babel-plugin-lodash-modularize 📣
Chrome. My work machine is really high specs though. It's been running overnight still and I've spent $1.6m. Highest win is 4 numbers and the bonus ball. Total wins $200k. It's officially impossible to win the powerball.
&gt; Arrow functions take the context of the surrounding code. It’s inherited from the enclosing scope. &gt; We all know that for traditional functions the context depends on where they are invoked. That's bullshit, in traditional JavaScript (ES5) every function is a closure over its lexical scope, with the notable exception of the very **this** keyword. The only difference is that arrow functions are closures without this (!) exception.
imo just use a Makefile.
&gt; "One thing that irritates me more than anything is the expectation people have to other people’s time, specifically open source project maintainers. They are not your tech support. They built a product you are using for free. You’re welcome." yeah. it has been fun providing RES for people over the years.. especially the last 2 days. fuck people.
Yes, I was referring to the original article. For what concern personal attach I think you are able to handle them as you are demonstrating. But take into account that under the personal attack (that is not nice), there could be a valid reasoning. I don'use Babel so I'm not here to say it's good or it isn't good. Only try to not get blinded by the personal attack itself. It is true that some solutions are provided as a workaround to a situation. But then when the situation resolve you have the workaround around and another system to maintain. So what was beneficial to the system in the early stage is now a damage. E.g. Spring vs CDI in the java world. We will have Spring around for the era to come. But I'm just reasoning, it is probably an problem that is not solvable. As with modularization: modularization is hard and it is the path to dependency hell. But try the alternative of a monolit. ;)
I think that proves my point. The tone of the original article bemoaned the current state of technology flux in the world of js. It's purpose wasn't to go out and trash devs and did so only in an inadvertent. If the author of the "Entitled Web developers" article's only response is to latch on to that one sentence personal attack, then they aren't capturing the context.
Looks good to me, so first let's see if the change event is raised. Replace : gulp.watch(['app/js/**/*.coffee'], ['coffee']); With : gulp.watch(['app/js/**/*.coffee'], ['coffee']).on('change', function(event) { console.log('File ' + event.path + ' was ' + event.type + ', running tasks coffee'); }); Change a couple of files and see if any console logs are raised. If you don't see anything then gaze might not be picking up the file changes. You can force it to poll by replacing your watcher with: gulp.watch(['app/js/**/*.coffee'],{mode:'poll'}, ['coffee']); I hope this helps.
Why would you use mine over String.js?
I've thought that was a recommendation not enforcement ;-) 
Now I feel bad. I wonder if it has anything to do with the 200+ tabs I have open in Chrome. Still, in task manager, I'm only at 5% CPU usage and 37% memory. On Windows 10 64bit btw. Bah...
I would go on a whim and say it probably is something to do with the 200+ tabs you have open. How isn't that eating the hell out of your memory? My chrome is such a memory hog these days.
Re: Edit: Good for you! Don't let your social life (I'm assuming you went drinking with friends or co-workers, right?) get ruined because some people on the internet want stuff from you ;)
So this is kind of like "lambda" functions in Python
[This?](https://github.com/lodash/babel-plugin-lodash)
I am always looking for help, suggestions, unit tests, documentation, and so forth in my project. I often hear that the code in my project is horrible to read and understand, but the people who are actually willing to provide pull requests seem to have no trouble finding the exactly most correct line to supply a minor change. This leaves me conflicted, because either the code is hard to understand or it isn't. I would love for somebody new to JavaScript to dive in and provide feedback. https://github.com/prettydiff/prettydiff
Keep learning. Go is an amazing language.
this is pretty easy to deal with, IMO "you can take you request/demand/whatever and fuck right off"
Just use **[fetch](https://developer.mozilla.org/en/docs/Web/API/Fetch_API)** Its a standard library implemented in modern browser. Return a promise so you can use it in [async/await](https://www.twilio.com/blog/2015/10/asyncawait-the-hero-javascript-deserved.html) function and there are [very light polyfill](https://github.com/github/fetch) for older browsers. Its simple, beautiful and standard. No other library offers that. short example : //my service function has only one line, returns the promise created by fetch. //This would be in another file named myServiceName.js export function loginOnServer(token){ return fetch(domain + '/webservice/login?token=token); } //my action in your action creators. async function login(token){ var loginResult = await loginOnServer(token);// here the function will pause and wait for "then" from the promise. return { type: ActionTypes.USER_LOGGED, user : loginResult .user } } Of course you can always just use it alone as its a promise and go : fetch(domain + '/webservice/login?token=token) .then(function(result){ doSomeThingWithIt(result); })
define "query completion" then
Hey James, I remember you talking about this huge problem elsewhere. It's a goddamn shame because you're obviously doing very popular work and in return get nothing but complaints. Would it possibly help you to find someone to act as a moderator for issues etc.? That person could make sure that a certain level of respect is maintained in the github community surrounding your project and you wouldn't have to deal with that stuff directly anymore, but instead could focus on actually maintaining. Plus it would be moral support which is what you desperately seem to need right now.
&gt;EDIT: Not sure why it isn't turning the HTML in to code format - I put the spaces at the start of the line... Sorry for the bad formatting guys! You'll need four spaces at the start of *each* line for *block* code. You can also write *inline* code with backticks (\`\`), so like \`&lt;td&gt;\` -&gt; `&lt;td&gt;`
I don't know when, but I remember using hidden frames too. I also don't remember it being "revolutionary" but it was certainly a hacky approach to something we wished we had a proper solution for. At that time I had no idea xmlhttprequest was a thing and wouldn't until I was already well into more Flash work where this wasn't a problem.
This is exactly how I feel. We were ready to start transitioning our business front end to React or Angular or something but it's ridiculous to start hedging bets with the current climate.
&gt;CSS in JS represents a fundamental change in how web apps get written — it throws away CSS in favor of a complex Javascript-based build chain that you’d be forced to use to implement CSS in JS. Even better, it actually extends the language. It has vendor lock-in built-in! Joy! &gt;Is it worth replacing something that is simple, and that virtually everyone either knows how to do, or can learn in a couple of days (CSS), with something that is highly complex, relies on a compiler maintained by a small group of people (really just one person), and requires re-training yourself, your entire team, and everyone in the future who joins your team? If you’re a consultant, it worth doing this to your clients? Are the benefits that great? The author does provide some other arguments against it.
&gt;lack of in depth tutorials Sorry I would have to disagree. If you're at the point where you're doing higher level and advanced stuff being able to read and comprehend source code from other libraries is essential. I'd rather go straight to the source than waste hours googling for tutorials that only a core dev could write.
That's because of this: [The Great Suspender](https://chrome.google.com/webstore/detail/the-great-suspender/klbibkeccnjlkjkiokjodocebajanakg?hl=en)
Only the dog balls version does what you want. So, it's not like you have a choice on this matter. Well, the good news is that you rarely need IIFEs in ES6. Thanks to block scope, there is rarely a need to shrink-wrap things for the sake of keeping the number of local variables at a reasonably low level. And if you really need another block to stow some things away, you can just create one: let foo; { let x, y, z; ... foo = ... } If [do-expressions](http://wiki.ecmascript.org/doku.php?id=strawman:do_expressions) (currently stage 0) ever make it into the language, you can even have your computed `const`s without having to resort to IIFEs: const foo = do { let x, y, z; ... [some expression which yields the desired value]; // kinda like an implicit return };
thanks, going to see what i can find for Cordova thjis afternoon
This looks like it might be exactly the issue I'm having, the data disappearing is probably a bug in my code. Thanks for the article I'll give it a full read over now
CSS serves two purposes: style and layout I get that style should be not of the opinion of the component. Set that on a per use basis. But layout is critical to many components making any sense and really ought to be part of the component. I would love a solution where the component informs its layout and may have a default style, but clearly indicates the options usable to override the default. I just hate when half my style is just to make the component look and behave properly. 
whee thanks!
Exactly right, the OP completely missed the reason why Facebook thought they needed to do this. His "they have lots of commits and think they're special" argument is nonsense.
This was a killer for me when I started my first job as a front end developer. Basically I was a noob that came from linking script src's in my index.html and had a more experienced developer that started the project and then was changed to other scope for some reason. I was left with what seemed like a huge codebase for me (it was only an app generated by angular-fullstack generator) that didn't even had any functionality implemented. Over time I had to implement a jenkins build and other stuff, and npm install was always the worst part of my day 
"Java trends"?
Genius!
You and the rest of the team have done a great job. Thanks specifically for the backup/restore feature! 
Oh. Find a reasonable employer then.
Couldn't you direct them to Stack Overflow or something? I mean, no one expects instant responses (and they shouldn't, of course) and they don't all have to come from you directly.
&gt;which makes maintaining the project positively dreadful when you don't know how the magic works. *All* code you don't know has magic in it. I'd argue that the magic-layers in Rails were actually relatively small; once you did a project or two you pretty much knew the whole shebang and the source code isn't too bad. The real winner about Rails tho is you can largely pick up a new project and hit the ground running since they all roughly work the same way. That's really not the case in most other 'frameworks' or 'strung together libraries'.
thank you for your work. i honestly wouldn't reddit anymore if RES for some reason got shut down.
Well so you know I got our entire company using ES6 and Babel and we've had nothing but a positive experience. So just want to say thanks for all your hard work. 
I've been using some form of a command line for over 20 years and never knew about the double asterisk. That is awesome! Thank you!
At least that one is just a global `s/_.pluck/_.map/g`. You have a great point about intent though. Developers not accustomed to lodash would figure out `_.pluck(users, 'name')` more readily than `_.map(users, 'name')`.
Flexbox stuff for example. The HTML (JSX) alone doesn't do enough to define the layout, only the toplogy. 
&gt; Vendor lock-in??? WTF does the author think libraries are? Do you expect to take your React code somewhere else? Or your Angular app? React and Angular are monolithic frameworks. Libraries are just typically small tools to use to solve a particular problem. Saying a library is equivalent to a vendor lock in is like saying a hammer is a vendor lock in. It's not really the same thing. I don't know Angular at all, but I've started playing around with React and it's becoming clearer to me how I can separate a component from the logic that drives it, allowing that logic to be reusable with non-react components should I ever decide to drop React.
What I'm asking is why layout is important to the component itself? why does it matter where a component is in a screen for it to be functional? A button is still a button, regardless of where it is on the screen. And the actions that are taken when a button is clicked, normally would not depend on where that button is on a screen. So in what circumstances or use cases, would the behavior of a button change based on where it is, and is this mixing of concerns preferable to alternative approaches that keep a good separation between behavior and design?
The text of the button should always appear in the center of the button. That's layout.
ok, let me reword my question Under what circumstances or use cases would layout affect behavior of the component it self? You're argument is that layout is critical to many components, but I'm not sure why this would even be a desirable trait of the component itself.
Sure. So what impact does the location of the text have on the button when it is clicked? What use cases might there be where the position of text on a button can affect the behavior of the button itself?
&gt; ...they tossed out browser-based CSS, *one of the simplest and most reliable parts of the web development stack*... Good joke. I had a laugh. Until CSS, as a language, solves the global namespace and scoping problems, at the very least, traditional CSS has nothing to offer me in terms of styling web apps.
Why should something have to change the behavior of a component, to be a responsibility of the component?
I have the other problem with CSS - it is just so lacking tool. I'd love to have an html-tree structure with data and .css style that puts those data into graphical layout. But NO, instead we must have some hacks here and there like some extra divs, some extra classess, because css limitations forces us to do so etc.
The good news is, it's all bullshit. Nothing is new; it's the same as it ever was. The people telling you it's new are just ignorant of history. If you look at React -- and Ember's theft of their good ideas -- it's not rocket surgery. It's just the realization that the naive solution of updating the entire dom on every cycle didn't scale. So, only update the parts of the dom that have changed and you'll win. It's great to have framework developers realize this because it means every framework will now get smart about updating the dom and they'll all be better. So, what's the difference? Marketing. I like Ember because it takes a lot of the mental overhead off of my team so we can focus on building our product and not bike-shedding each piece of the stack. At the end of the day, there's nothing special about programming in Ember, you still get burned by inefficient algorithms, you still need to be judicious with how often you hit the wire. Those are the things that matter. The rest, again, is just bullshit.
So long as you keep in mind that you can solve a lot of that just by using component-orientated CSS with a preprocessor, and that CSS in JS is not the only way to write CSS at scale. I'm sure they exist, but I haven't seen people writing huge blobs of CSS in projects I've participated in ever since things like SASS and includes got very popular. Now with module loaders being able to load in CSS, things have been able to get even *more* fine-tuned, to the point where you can have a small, scoped CSS file *for just one component* or *just one page*. 
Ah, I guess I only use it for unsupported es6 features in node/v8. I doubt I'll use it if/when es2015 is fully implemented.
I will check it out when I get home this evening.
Babel 6 may not have been stable on release, but it's nothing I can't work around until you have the time and motivation to fix it. I use it for every project and wouldn't think of using another. We all make mistakes, and its foolish to think open source software is immune. Consider this post a +1 for "yer doin' a good job"
If you want to make games, then [PlayCanvas](http://playcanvas.com) is pretty neat-o - you can do it all via the online IDE.
In my experience Angular is poorly built for really low level unit-based TDD. If you're not using a bundler you have to use protractor. angular .module("app") .factory("blah", ["serviceA", function(serviceA) { //your code is tightly coupled to the framework }]); If you're using a bundler: angular .module("app") .factory("blah", ["serviceA", require("./factory")] module.exports = function(serviceA) { //now we can require this anywhere since it's not coupled to angular }; It's not incredibly apparent to use a bundler with angular, however, since it comes with a built-in DI system. Funny, considering DI in 1.x has received Unlimited Flak over the years.
+ten million. This site is what gave me the tools to get the job I have now.
I have a lot of positive experiences on Twitter, I'm not going to be chased away from it. It's not just Twitter either– I'm not going to quit open source because of some bad eggs.
My company, CloudFlare, is hiring 😉
very good example, thank you.
I have to give credit to our amazing team, who have been the real people running the project lately. Logan Smyth, Amjad Masad, Henry Zhu, Jordan Harband, and others have been huge in maintaining the repo, issues, slack, stack overflow. It's very impressive.
It is technically completely optional, you can configure Babel in many ways. `.babelrc` is the easiest and recommended way. I also don't seem this as a problem. Create your own Babel Preset and you're set.
If anyone has any questions, I and many members of the Chakra team are around today!
In my mind the most important feature is: * Being able to prune CSS which is no longer in use. As someone who is working on a site which is not state of the art, this is a major feature. It's really, really hard to refactor a big site where you have no clue where the styles are being used, and how changing one class in one part of the site may subtly break some other part.
not that straight forward a change when using chaining api, eg. `_([]).filter(fn).map(fn).pluck('foo').value()`
Just out of curiosity, what were some of the pain points you faced when you developed your app in Elm compared to with React (or other JS libraries / frameworks)? I'm curious what might be some challenges or stumbling blocks!
I think you guys did a good job with Babel 6 but I'm a stupid asshole so my opinion probably doesn't mean much here.
Okay then: `s/\.pluck\(/.map(/g` Of course, this assumes that you don't have another object with a `pluck` method... which has held true in every single project I've ever worked on.
Haha yeah definitely was one of the most frustrating things to figure out. There a few issues tracking the bug, I'm sure enzyme will release a fix soon 
There is actually an active Linux branch being developed. Personally, I'm excited about being able to use it with Node - not that there's anything particularly wrong with V8, but it's just healthy to allow different underlying engines under the Node API.
This has the code to generate proper function tables for SEH support on Windows x64.
[removed]
And it *should* scare people. Coffeescript should have also not been considered "mature", and yet people still went with it. Language upgradates caused bugs, and some updates were breaking changes. Developing software against an iffy language 'transpiler' seems dubious to begin with. If you're looking for stability and peace of mind, then code against the established standard.
It's especially frustrating when I had no intention to even use sinion for most of my tests. For me it was some karma plugin - I think the chrome launcher. Then I look around about the issue and get that [sinon is webpack's "special" friend](https://github.com/webpack/webpack/issues/304#issuecomment-45557212). Aaaahh! Oh well. At least guides like these will help people to work through that stuff more easily.
We're working on it! There is some early work in [a pull request](https://github.com/Microsoft/ChakraCore/pull/63). There's a bit of info [on the roadmap](https://github.com/Microsoft/ChakraCore/wiki/Roadmap) too.
Quite frankly, I'm happy that edge [has gotten so much es6 implemented](https://kangax.github.io/compat-table/es6/), it's really lit a fire under the asses of chrome and firefox. After all, no one wants to be the new IE holding everyone back. ;)
It's always a good thing to have more things open source like this. More sensible competition is never a bad thing. Open-sourcing things helps to give back to communities. If you want something more practical for an answer though, MS has open-sourced other things in the past and [hasn't exactly gotten nothing out of it](http://mattwarren.org/2015/12/08/open-source-net-1-year-later/).
Glad to hear it!
I can't downvote this hard enough. It's a factually inaccurate and poorly thought out. JSS is not "CSS in JS". JSS is just some library somebody wrote, it wasn't even made by Facebook. It has competitors with different ways of doing things. CSS is not a programming language. CSS, like HTML, is purely static, and on that basis alone is an insane choice for dynamic web apps. You're looking at a rock and saying "every horse has its flaws". This isn't a question of scale, this is a question of what's possible. You can make a program with assembly, but you can't make Google or Photoshop or Fallout 4 with it. Just because CSS does a fine job of styling static documents doesn't mean it's even remotely suited for the future. Please, please don't aggressively insert yourself into discussions you don't understand.
Good to see more great OSS software! Thanks for this. Now I hope there will be news about trident soon... :) As a more general question, how does open sourcing chakra feed into Microsoft's corporate goals? People start using chakra on linux, in their node.js deployments... Profit? Where does the profit come from? 
It's an article arguing against mindless cargo-culting of overly complex solutions, something I see frequently in the javascript community. So some developers at Facebook decided to bet the farm (technologically speaking) on React and a components architecture. I get it. And it seems as part of that technology decision, they said, "Ok, now how do we do styling?", and they came to the conclusion to write all their CSS in javascript. That's fine for them. They explain the well-known problems of CSS in that slide deck I linked (that guy works at Facebook), and why they're especially problematic for Facebook. The point of the article is that you probably don't have that problem unless you work there. CSS has a lot of warts, but it's a constant build target, it's easily learned, and it's simple enough for most designers to participate in that part of the development process. &gt; If you need more than 30 seconds to learn it (implementing it is different) you're an idiot. Tell that to every designer/dev who would otherwise need to install a node environment and learn to use those tools because of that. 
I literally quoted a slide from one of the guys who works on this at Facebook, explaining their problems with CSS.
It doesn't necessarily have to be profit. When MS open-sourced .NET core, they were able to get [some contribution](http://mattwarren.org/2015/12/08/open-source-net-1-year-later/). Additionally, the more they open source the more they help to transition away from the old stodgy image of microsoft. I know a lot of people thought hell had frozen over when .NET core became open source. That's the kind of reaction you want if you're trying to pivot on your image.
Any plans of node with chakra?
&gt; The content of this article boils down to the author repeatedly saying "Don't do shit just because large companies do". While I agree with that in principle, there are zero reasons listed against actually doing this (other than "it's different"). Yep, you nailed it. Large companies invent complex solutions to solve their complex problems, and they open source it, and everyone cargo-cults these solutions because if Facebook does it, it must be great! Developers do lots of stupid bullshit b/c they like playing with new technology, and a big brand like Facebook behind a particular way of doing things is a damn good way of justifying it to your CTO. And your CTO probably loves playing with new shit too, so yay! The article is an argument against cargo-culting.
Here you go https://github.com/Microsoft/node. I would love to see what the performance comparison to v8 is. 
I like the plan :) I definitely feel that Mobservable needs an abstraction on top of it, to help dealing with data storage, history, visualization and such in an idiomatic way. And maybe Meteor stack is indeed actually a very good fit so that definitely deserves a closer look! Anyway, let's continue the discussion on https://forums.meteor.com/t/making-trp-predicable-pure-and-testable, which is a lot more readable then reddit :-P
Line 46 is your issue. Push returns the new length of the array, not the array itself. Numbers do not have a push method. As you are setting the result of the push back to the variable of the array itself the next time you try to push it fails because there is no push method on numbers.
We all know that MS is pushing hard to get people to upgrade to Windows 10 and Edge, but is there any chance that we will see a softening of this stance and maybe Edge running on Windows 7? In other words, how can we get IE11 out of the world faster? 
Oh yeah! You can see some info on our roadmap. Also, check out https://github.com/microsoft/node - we're working on making Chakra an option with Node!
No plans that I'm aware of, though I don't speak for the Edge team at all :)
To clarify. Change this: idList = idList.push(e.id); To this: idList.push(e.id); 
Nice. Looks like a great read! I'll get to it after work.
Just wanted to say thank you for your efforts. I've recently implemented a full setup using Babel 6 with a few plugins. While it wasn't the smoothest transition, it certainly wasn't hard. Any developer who expects brand new and immature software to work well out of the box is clearly ignorant of how things work. I did the sane thing and stuck with Babel 5 until I understood more about the new version and the plugins I needed made the transition. Javascript is moving at an incredible pace, but that doesn't mean you need to be on the front lines. Explore, learn, test, implement. I really don't understand the recent barrage of articles claiming fatigue. Use what you're comfortable with. No need to bash things you don't like (or use) and disrespect those who've put forth their time and effort in an attempt to make things better, or at least offer a different perspective.
Chrome and Firefox don't need a fire under their ass. Remember, they've led the way for over 10 years, and still do. They were the ones that lit the fire under Microsoft's ass.
I assume you've extensively looked at V8 and SpiderMonkey. How would you say Chakra differs? Better documentation? Faster in X? Slower in Y? Overall pros cons? Thank you.
Testing React is quite awesome because you can shallow render components on the server. Tools like Enzyme make it quite easy to write good tests that run fast and allow you to do BDD.
Do you know about Chakra integration with VS Code, along the lines of what they've done with Node?
Do you mean Chakra support for something like Github's Electron? I imagine it's possible, and our plan to get Chakra behind Node would help. Not sure about hooking up Chakra to the Blink/WK though.
What are the implementation of arrays in Chakra and their use cases? Does the implementation differ significantly from the others?
More on if you've heard anything from the VS Code team as far as their plans to integrate Chakra into VSCode like Node has been.
&gt; Angular/Backbone/Ember Unluckily for you, none of those are good choices for testing, and I can personally attest to Backbone being exceptionally frustrating. You may have more luck with Ember or Angular, but it's never going to be the pleasant experience React would be.
Cool! Browsing the source a bit... just out of curiosity (I haven't written any C++ for a very long time) why are some of the the cpp sources [so large](https://github.com/Microsoft/ChakraCore/blob/master/lib/Runtime/ByteCode/ByteCodeEmitter.cpp)?
&gt; All code you don't know has magic in it. What makes code *magical* isn't the not knowing how it works, it's how easy it is to find out how it works. There is a LOT of behavior in rails and ruby itself that "just works" without any indication of what code it is that makes it function. The mechanics of the act are all obscured behind a curtain, and pulling that curtain aside requires a massive learning curve. If I call a function explicitly and pass in something conforming to that API, then I have a pretty reasonable idea of where I can look to find out how that function works. If I'm just dropping some file into a specific place that matches a structure in a tutorial, I have absolutely no clue what code is interacting with that file and no idea what to look at when it doesn't work.
Ramda had very decent documentation, and a ton of thought has gone into making it's API extremely functional, in all senses of the word. Proposals to add a new feature will invariably stop for a lengthy philosophical discussion, which may sound silly, but the result is extremely polished and a joy to work with. On the other hand, that same attention to detail and unwavering attention to purity means that Ramda's API is a rapidly moving target (API methods *will* be renamed if someone presents an elegant argument in favour of such), and some useful features are simply not added. Anecdote: There was a useful deep merge function in Ramda, closely modeled after the equivalent function in underscore/lodash/etc. However, it was pointed out that while useful it had some weird issues in obscure edge cases, and after being renamed a couple of times it was eventually removed. Proposals to re-add it have foundered on the same arcane edge cases. Note: It's not that it didn't *work* on the edge cases, it's a question of figuring out the philosophically perfect approach to a strictly function deep merge. I think, anyhow; the comments on the various pull requests were really obscure. And every time a pull proposal gets close, the underlying API changes and work has to restart. Conversely, lodash seems to follow more of a "whatever seems to work" approach, all thrown into a pile. And lodash-fp is the same, except roughly translated into a functional style, and utterly undocumented (and it's not like the original lodash's documentation was any great prize). In short, both libraries have real (but entirely different) drawbacks. I'm currently using Ramda because of how polished it is, but lodash-fp is tempting just because it would do *everything*, even if it might do it in an ugly fashion.
Yeah but off the top of my head I can only think of controller rendering actions as the only place where the behaviour you describe is true. The amount of real magic is rather limited, I think. Most everything else is relatively well thought out and consistent - tho ofc ymmv.
Congrats on getting it under MIT #notyourfathersMS
Try jquery. $('.X').size() will be the count. Jquery docs will tell you how to use jquery to insert things into the Dom. 
Put it into either dollar amounts or maintenance costs, whichever he will understand more. Clients tend to understand when you say "you are wasting X amount of dollars by writing all this stuff by hand."
That's part of why we're really excited by this effort. It will be a big real-world scenario we can use to see how we stack up and hopefully will help guide future improvements.
I've been using [locally](https://github.com/ozantunca/locally) on recent project without any issues.
Haven't heard anything. Sorry!
The best part is that FSF agrees that MIT license is GPL compatible which (as far as I understand, don't quote me on this because i anal) means you can take code that is under MIT license, modify it and release it under the GPL. &gt; It means that the other license and the GNU GPL are compatible; you can combine code released under the other license with code released under the GNU GPL in one larger program. Quoted here https://programmers.stackexchange.com/a/204497/23642 from the source https://www.gnu.org/licenses/gpl-faq.html#WhatDoesCompatMean I'd strongly recommend anyone who intends to do this to consider AGPL https://en.wikipedia.org/wiki/Affero_General_Public_License 
Oh man this is actually a huge area. Arrays are extremely commonly used and also very perf sensitive so we have many representations and optimizations in play. Hard to describe concisely. Maybe a good topic for a blog? That said I would bet given that all the runtimes have similar constraints we all use similar representations and optimizations.
Cool. Thanks for the info. As an aside, is there anything you think your team is addressing better/more efficiently than Google or Mozilla?
I'm relatively new to the team so I can't comment on specifics, but to answer this question in general terms you can look at how we perform on JS benchmarks like [JetStream and Octane](http://az648995.vo.msecnd.net/win/2015/12/chakra-performance.png) and the level of ES6 and ES7 standards we have implemented. Some of that info is called out here: https://blogs.windows.com/msedgedev/2015/12/05/open-source-chakra-core/ See also the [Kangax Compatibility Table for ES6](http://kangax.github.io/compat-table/es6/) and [ES7](http://kangax.github.io/compat-table/es7/). And we've made some progress since the last Chakra/Edge release which is featured in that table (which was released with the Windows 10 November 2015 update). Edited to include link to benchmark results.
What kind of formatting is in Angular that isn't in some off the shelf microlib? Does it have some special features I'm not aware of?
What do you mean by you *anal* ;)
Strictly technical: If you are able to compile under Linux do you test executable application with valgrind or fuzzer? In other words: How do you benefit as a developer team from having cross-platform code? 
I don't get it. Open Source doesn't mean you get support as well by default since forever fucking ago when the graybeards of Linux and C made their code available and designed support business models around it. The source is there so you can have a go at it. No black boxing no propietary lock in. Who are these "entitled" fucks? Script kiddies that grifted their way in a web development job and can't deliver without adding 7 different versions of JQuery to their project? I mean... really like yes web development is chaotic and unpleasant at times because were taking in to account every single corner case in every platform the stupid javascript is running on. At the same time the aggressive innovation nature of the landscape is what makes it interesting and leading along side the other technologies of the industry. Freeloaders expecting support on top of the free code they're plastering all over the place to pretend they're cool code artisans need to get told to fuck off once their entitlement starts to itch. 
I don't think you are communicating with your partner and are failing to consider multiple points of view. I also think there is more going on that you are not mentioning. There were a couple of things in your post that struck me: &gt; My boss is a veteran server-side programmer, but much less experienced than I am (4 years) on the front-end. Business requirements don't differ significantly if the application is on the back end or front end. The goal is to build an application that accomplishes goal X for business objective Y without regard for how you get there. The biggest differences when moving into a JavaScript app are only: 1. the APIs 2. how the pieces come together and are organized internally &gt; Anyway, having worked exclusively on projects with frameworks for the last few years Last few years? You only have 4 years experience, so the last few years implies this is probably more than 80% of your capabilities. &gt; I spent about 8 hours writing methods to format strings and bind them to DOM elements That shouldn't take 8 hours. Formatting strings is uber easy. If you are not familiar with native string methods or regular expressions I can understand how this would take longer. **Assessment** A lack of experience and a lack of technical direction is causing frustration. Of course this assessment is only from the brief information you provided which is likely biased and possibly missing information considerations. **The problem as I see it** You are operating in an unfamiliar technical environment (lack of framework) and probably lack the professional experience to drive the necessary communication forward. The problem is not simply missing frameworks. **Most ideal, though unlikely, solution** Bring in another person to drive technical direction. This person should be a strong front-end developer capable of addressing multiple concerns simultaneously and advise multiple valid solutions for consideration. This should not be a democracy. Even though they should be able to provide options for consideration they need to be able to make a solid decision and crush opposition with an iron fist of epic death and they should also be able to win anybody to their point of view with persuasion, evidence, and empathy. **The practical solution** You just need to learn to talk to your partner and convey your concerns. You guys, since there are only two of you, need to move a common direction. You clearly have confidence concerns of a technical nature, which cannot be solved with technology magic. **The most relevant detail** &gt; It's a pre-beta product. Why the hell would you waste time on using some massive framework on a prototype? You need to learn to do your job so you can complete this in the shortest time possible as a mere proof of concept.
in your spare time, build a side-by-side demo that shows how you would accomplish something in both the old way and the new way you're recommending. And just politely recommend it, saying you did this for free on your own time. Be bold, do it.
Yea, I read the deck, **did you even read my article?** &gt; Now, the enumerated list on that slide is, in fact, an excellent summary of the core problems with CSS. But all languages have problems. One could argue that the problems of languages are like constants in a sea of variables, constants that we learn to live with. And unless you introduce some new variable, one that significantly compounds the effects of the other variables, the problems presented by those constants are livable and workable. &gt; Several hundred people committing to a single project (in this case, facebook.com) is, to put it bluntly, **fucking bananas.** That is one of those special new variables that, for lack of a better term, fucks all the shits up. I'm not saying that they re-invented CSS b/c they have hundreds of people working in the same project. I'm saying that CSS has lots of well-documented problems, which he documents in that deck, and those problems are manageable and workable, for the most part. **UNLESS**, say, you throw a real wrench into the mix, like having **hundreds of people** work within a single project. **That new, extreme variable, makes the existing workable problems with CSS effectively unusable.** (They had similar special scale problems with git) Do you see the difference? Of course CSS has problems, we all deal with them. But I posit that they're manageable unless they're being felt simultaneously by hundreds of people.
You can use TypeScript definitions files for your JavaScript files by installing the definitions on the `typings` folder. It gets completely isolated and never be in the middle of your code. Plugin ecosystem is the downside, I simply can't use VSCode at work because I can't find `editorconfig` and support for `ES7` &amp; linters. ES6 seems ok but ES7 is not supported. Not entirely sure about JSX but I think it is well supported. But I wouldn't recommend using it for development with the lack of plugins and mainly the ES7 support
Thanks for your response... some bits are helpful but I think you make a lot of assumptions here that don't match my situation. Maybe I just didn't communicate the situation clearly enough for you to make a clearer assessment. &gt; Why the hell would you waste time on using some massive framework on a prototype? It's pre-beta (no real customers signed up), but a pretty huge app already. I wouldn't call it a prototype either. It's being built by a large agency for a few of its customers, so there's pretty strong investment behind it. The product itself has been through a fair amount of small-scale user testing and research. I would say given the size of the app, if it was started with a framework it'd be wayy further than it is. You make a good point though -- he may be waiting until we move into more validated stages. &gt; Business requirements don't differ significantly if the application is on the back end or front end. I know, but the point is that he decided (or perhaps inherited a decision) that it will be front-end heavy app. I'm not saying he should move more of it to JavaScript. I'm saying it's already there, and he stays mostly busy with server-side work. &gt; That shouldn't take 8 hours. Formatting strings is uber easy. If you are not familiar with native string methods or regular expressions I can understand how this would take longer. Sorry, I probably could have been more clear here. I spent the day writing a class that accepts a variety of data types, configurations and transformers, preps them for the DOM, and binds them. I guess 'formatting strings' was the wrong way to say it. &gt; You are operating in an unfamiliar technical environment (lack of framework) and probably lack the professional experience to drive the necessary communication forward. The problem is not simply missing frameworks. I'm pretty comfortable framework-less with JS. All I'm saying is that frameworks are far more productive. I re-invented the wheel today. I understand if 4 years doesn't seem like much experience to you, but I feel pretty confident in my assessment of the codebase. This is more of a people/business-skills question I'm asking. I also have a pretty good relationship with my boss -- I'm just not sure whether it's appropriate and when/how to bring these sorts of things up. That is one area I'm inexperienced in, since I've only worked on professional projects where frameworks are used. &gt; Last few years? You only have 4 years experience, so the last few years implies this is probably more than 80% of your capabilities. Not sure how that's relevant.
&gt; Sorry, I probably could have been more clear here. I spent the day writing a class that accepts a variety of data types, configurations and transformers, preps them for the DOM, and binds them. I guess 'formatting strings' was the wrong way to say it.
I know that there is a Chakra build for Windows IoT environments (e.g. Raspberry Pi 2), but will there be a way to build Chakra for other environments (other Arm processors), like there is with node.js?
This is a good idea. I'm going to try this. Thanks!
Solid idea. I think I'm going to give this a go in a few weeks when we renegotiate my time commitment. 
Chakra dev here. As I see it, there are two main advantages of having a cross-platform build. 1. Our code can run in more places, which means more opportunities to reach more developers interested in integrating ChakraCore with their applications, and identifying more cases for real-world improvements to the engine. 2. Enabling greater developer and community engagement and productivity by not being limited to the Windows platform. Of course, I fully expect that tools like valgrind, fuzzer, and cpplint will be run on our code once it goes cross-platform and that opens up opportunities to improve the code beyond the tools we already use for those purposes. If the community doesn't, I'll probably run some of those tools myself :evil grin:
Some questions belong on Reddit, and some belong on Stack Overflow. I think this is the latter, and as it turns out there's already an answer: http://stackoverflow.com/questions/2869827/how-to-test-chrome-extensions Hope that helps.
How big is this app? How many devs working on it? You can use webdriver to test anything but it's flaky and slow in my experience with huge webapps and many devs. If it's a small project it will work well. React is awesome, I use that, although it isn't a framework. It makes things easy(er) to test because it encourages a pure functional data flow. I **do not** recommend using Jest. I've only had problems with it and it's incredibly slow. You also cannot run the tests in a browser easily which makes for a terrible debugging experience (you are basically back to using console.log to figure out wtf is broken). 
I don't think it's one or the other - we reserve the rights to these files under copyright law, and part of that right is to license the content. IANAL, though I have asked them to ensure that this is proper. If not, we'll change it!
We currently build and run on Arm v7 or higher (we emit Thumb2 instructions). So, if the ARM device runs Windows, Chakra will run there too :)
80% of all redditors are full of shit, couldn't justify anything they say, so downvotes don't mean anything here.
I think there's too much hate going on here so I'll provide some of my own thoughts. For *most* websites on the internet css in js really isn't needed, in fact the tooling supporting it can be downright confusing compared to a simple declarative objects like traditional css. That being said if you tend to use other peoples css or components in your app, or reuse your own components in multiple apps, the global namespace becomes a real pain in the ass. CSSinJS alleviates that, however you can also use bem or my personal favorite - css-loader?modules to hash your class names. Sure you have to learn a different way of importing styles but you don't have to do everything in js. Where I'm working now we have been doing a pseudo bem style for a while now, but we are getting lots of conflicts with legacy code. So we're moving over to css-modules. In addition to that we have a component library that we inject theme colors into (gulp-header) and compile server-side. This is a serious pain point for us, setting up a controller in all our apps, making sure they fingerprint the css etc. So we are actually moving all theming (yes **just** theming) to JSS, meaning we can finally ship actual static js/css to the browser and remove any html/css generation from our servers. We aren't a 1000 developer company but these small wins help to make our team much more productive over the long haul.
Think there will ever be Edge for Linux?
You're not addressing anything I wrote at all, you're trying to change the subject.
why would I want to use chakra over v8? 
"Am Not A Lawyer"
When you say 'bind to the dom', what do you mean? Keeping track of a reference to a dom element? Or something else?
Better ES6 support I'd guess.
2 way data binding. So that changes to the model update bound elements and changes to input values update the model &amp; other values rendered by it. 
Guess this makes me a coward. Edit: I'm also without a clue.
Can't we all just agree CSS is terrible, and that Håkon Wium Lie could do with some healthy introspection? https://dev.opera.com/articles/css-twenty-years-hakon/
Is there a way to script it to print page to pdf?
Couldn't you just compare using javascript benchmarks on edge then on chrome? 
I've used Mocha (as my test runner) and chai (as the assertion library) to test chrome extensions. I've done AJAX with mocha and chai as well. http://mochajs.org http://mochajs.org/#asynchronous-code http://chaijs.com I've also done it where I included a /test.html file in my extension which will run the tests in the browser. Here is something I started and have yet to finish. Small project to build anchor hrefs, no where near done but there is an example of how to package tests into you extension and how to run them locally on that computer. https://github.com/sgnl/kedge
I can hear a dictator, even if benevolent one :-) Imo, it is a dangerous path, you will never know all (non-)imaginable ways people will want to use your software. They will hit the wall, waste their time, get angry and go complain. Which will waste your time and nerves. People like freedom. Or at least illusion of it :-) In this particular case we are talking about the `.babelrc` file. It is **implicitly** in the same category as `.npmrc`, so it **should** behave **exactly the same**. People **expect** this. Which is a good thing. Implicit unambiguous conventions is a brilliant way to save people's time. If you don't want to conform to the way `.npmrc` is managed, **don't call it similarly**. Use explicitly distinguished name. But I'd rather you do. Would you really want to create and managed another piece of puzzle in your universe? Version management is hard, but is already brilliantly solved by `npm`. Can you simply let `npm` deal with it? Then you have one less responsibility and one less headache to deal with. All I want is to declare "presets" in a higher directory, so I don't need to repeat it again and again when managing multiple projects. Later, f you ever decide to deprecate this setting, you can always throw a warning whenever you see it. Is it unreasonable? 
It is interesting how the npm is addressing the *people's expectation problem*: &gt; npm’s philosophy &gt; &gt; npm’s core value is a desire to reduce friction for developers. Our preferred way to do this is by paving the cowpaths. That is to say: we don’t like to tell you what to do. We like to find out what you’re doing, and then get the obstacles out of your way. If lots of people are doing different things, we try to avoid picking a winner until it’s obviously the best.
Wouldn't it make more sense to have a single function that clicks the buttons? I started to write some simple code here but there were too many assumptions about the code here to continue. You say "B" appears and "when C appears" ... but are they just hidden, or disabled, or do they literally not exist on the DOM and are injected after some time? I guess I just don't understand exactly what you're trying to do =/ Sorry. If you can explain it differently or put your current code up on jsFiddle or something I'm sure I, or someone else here, can help you pretty quickly.
Not to be an asshole but you could have accidentally landed on one by the time it took to log into reddit and end up here if you had just Googled "javascript tutorial". For instance, here are the results for "[javascript tutorial web design](https://www.google.com/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=javascript%20tutorial%20web%20design)" What exactly do you mean "for web-design based uses" ?? 
I've box 3 times Too bad every time I've gotten click happy lol Good job though
CSS in JS for me is the same as HTML in JS. We see that writing JSX makes sense because it tights the component to its template which we anyway do virtually in our head. I don't mind doing the same for CSS. Of course we have things like main layout and typography styles. Those should be served as CSS files. The balance is somewhere in the middle. The good single page app is this that still shows something if JavaScript is not there. Not because the user can disable its JavaScript but because there are tons of stuff that can happen to/in our JavaScript files. 
Im curious, which ES standard do you consider to be the last good one?
&gt; If it is the latter, that is your job. Whether you want to or not is your decision, but to be dismissive and negative of suggestions like that goes against the title of your post.
Has anyone suggested you wear gems on your forehead and chest yet?
Careful, but doesn't look edited by HR and the Public Relations department - nice! 
What he say? Something about MS spawn of Satan?
Ideally not having to configure is always better. *This* should be the easiest way. (I know, you've heard it many times and probably tired of it, sorry to repeat it again, but I honestly have to agree with it.) &gt; Create your own Babel Preset and you're set. I would still have to explicitly declare it in every single project, so I don't see how this can help with the problem. 
Validation.
All rights reserved refers to trademarks. 
I don't see how you can pass value to `fibonacci` on your code there. Seems like that example just gives an example of `iterators` which is [similar](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of) in JS as well. Also, generators might have many purposes than just doing async flow but it also seems to solve the async issue in JS which I find a welcoming feature.
Please be aware that Java has nothing to do with JavaScript, these are distinct languages and have not much in common. Naming the language JavaScript was only a marketing trick by sun/mozilla. The official name nowadays is EcmaScript btw.
I've written this on another reddit and i have been redirected here .... They said the exact same opposite of java/javascript
&gt; so how can I reliably access the files I think you cannot since the package management is a kind of abstraction and the internals of a package can change at any time. What do you need the files for? Modification?
A is gonna alwayz be there . after i press A a small window(within the samee tab) the B button would appear. After some tries of the cycle A,b the C would randomly appear when i manage to get through the busy servers from this site. When C appears , A is still rhere and if it's clicked it's gonna head to B as asual. I don't wanna do that anymore when i have the C button available. I'll try to get some ss of the site . ( gonna see if i can from my phone)
Wonderful, let us hope this creates a great community to collaborate on building out its ecosystem and get it where it truly belongs.... On the server 
Just to hazard a guess... something like `display:none/block`, or `height:0px;overflow:hidden`, which is CSS yet it affects whether a user can interact with it.
How's that WinRT work in Linux? ;)
&gt; The point of the article is that you probably don't have that problem unless you work there. And I think the point of most of the feedback you're getting is that's completely wrong. &gt; a constant build target, it's easily learned, and it's simple enough for most designers to participate in that part of the development process I feel like you may be using a different version of CSS that the rest of us. It sounds quite nice though. &gt; Tell that to every designer/dev who would otherwise need to install a node environment and learn to use those tools because of that. So your argument is "CSS is fine because you can just use some node based build tools, but CSS in JS is terrible because you'd have to use some node based build tools!"? I'm not sold. (Disclosure: I'm not using any CSS in JS tool, and I'm very sceptical of the idea. And Jest proves Facebook is capable of terrible over-engineered disasters! But your arguments are absurd.)
Super rad!
i am using react yes
By you? I'm on mobile and the site header takes up nearly half my screen all the time.
I'm currently building a bot for Discord myself and also wanted it to be easily expandable by plugins. What I'm doing is basically: I'm creating a module for each plugin (like a music bot) which exports an object with commands. I'm gathering these loaded plugins in an array like object. Now when a message comes in, it gets handled by a parser which does a lot of things, like checking for permissions or checking for a command prefix (like `!command`) and also looks through the object with the loaded plugins if one of these plugins exposes this command. If it is so, it calls the function of this command which is also exposed by the plugin. To automatically load all plugins I have a `config.json` where plugins can be enabled or disabled. Then I have a loop which will loop over all enabled plugins and require/import the exposed module of the plugin. So far this works great for me. But I'm not afraid of rewriting the whole thing if I have a case where this method can be problematic. You can look at my repo if you are intereseted: https://github.com/simonknittel/discord-bot-api
That's because you can't really learn advanced knowledge from tutorials. The kind of knowledge that can take weeks, months or even years to obtain can't be filtered down to a tutorial containing the same amount of knowledge. It's more than just trial and error on your own. That knowledge can only be obtained by doing, experimenting, collaborating, and with time. And that's ok, skill and experience always take time and effort, there are no shortcuts (though there are certainly methods that only waste time). The problem is with people who, even given plenty of time, don't manage to progress past the [Expert Beginner](http://www.daedtech.com/how-developers-stop-learning-rise-of-the-expert-beginner/) stage. Either they're not learning how to learn because they're not doing it efficiently (failing to collaborate because they're insecure/arrogant, working with only one stack the entire time, not continuing their education, etc), or they simply are incapable of doing so. They could probably recreate one tutorial in another form, but they'd never be able to contribute something completely new to the community because even if they discovered/created something new, they wouldn't understand how it works.
Sorry to troll you, but the odds of your example are not 1 in ~293,000,000... actually the odds of 3/665 are 1 in 48,792,380 I just did a small function to calculate the odds: var odds = (function calculateOdds(a, b){ var fact = function(input){ var f = 1; for(var i = input - a + 1;i &lt;= input;i++){ f *= i; } return f; } return (fact(b) / fact(a)).toLocaleString(); }); Usage: console.log(odds(3, 665)); console.log(odds(6, 49));
I'm pretty sure [Chakra supports asm.js](https://blogs.windows.com/msedgedev/2015/05/07/bringing-asm-js-to-chakra-microsoft-edge/). It should be possible to use any language supported by llvm without paying a performance hit of calling a native library. Imagine using something like sqlite as pure JavaScript at near native speed.
I really learn how to test streams with this -&gt; https://github.com/Reactive-Extensions/RxJSKoans and also a few concepts or way of thinking with the introduction by andré statlz (the author of cycle.js) https://gist.github.com/staltz/868e7e9bc2a7b8c1f754 And now, halt a year after I use this book as a reference http://xgrommx.github.io/rx-book/index.html
I am just saying that generator is not a feature that fullfills purpose of async effects. The thing that it eases async programming is something I'd call eeemm "side effect". https://en.wikipedia.org/wiki/Generator_(computer_programming) But I agree that it solves async issue in JS, indeed. But please tell me, why not using Babel which uses "native" feature?
Gave your bot a look and that was pretty much what I was looking for. I'm probably going to use a similar system modified for my own needs. I'm not that good with JavaScript so your example will surely help me a lot! :) Just curious, what is that problem that may end up you rewriting the whole thing.
It is resolved now.. Thanks buddy!!
Ahh. I missed a word. I meant: "I'm NOT afraid ...". Sorry :D I just wanted to say, that this is my first time of writing a plugin system and I don't know if it can be done better. Therefore I don't know right now if my current implementation can cause a problem in the future, when I want to implement feature X.
Slidetoggle
I was searching this for long time. JS is one of my favorites..:)
Uh? Alt account for commenting? No one can possibly create a reddit account to comment on this shitty article.
&gt; or this just a new take on the embrace-extend-extinguish mantra? Much as I distrust MS because of previous behaviour, and for that matter corporations being helpful generally (always make sure you can see where their profit and market control comes from in the business plan, if that isn't plainly visible assume it isn't going to be something you'll like) their current changes make sense in the way that the relevant markets are moving. They were not going to be able to compete and survive as old MS long term, because of the quality of F/OSS options server-side, the plateau in need for new features in desktop OSs, the commoditisaion of the mobile OSs and apps, and so forth. The money in the up coming years is not going to be in selling home OSs and developer tools, it is going to be in providing infrastructure and selling resources on that platform. Opening their developer tools and relevant libraries more will encourage people towards their infrastructure and platform services. I think that in a few years Windows will be free for home users (probably not open for the most part, but free to use), the bulk of their development tools too and limited versions of Office (or perhaps not so limited) for home or potentially small business use, libraries and utilities will become more and more open. Of course for commercial users, at least large commercial ones, will still have to pay for the variants of the OS aimed at them, SQL Server will remain expensive for on-premises instances for commercial use and charged for indirectly via relevant Azure services. IAAS/PAAS will become the main revenue stream - that is where the profit potential and lockin/control points are going to be found so that is where it is important for them to concentrate their efforts. To give MS credit, under previous regimes they would have still tried to gauge everything last penny and ounce of control they could out of developers and Windows users for as long as they could *as well as* marking their place in the new world. Instead this time they have decided that being a bit nicer and playing well with others is much better than the little extra they would make from not. How much you assume that is genuine generosity and how much is just long term planning &amp; PR (good will can be a valuable commodity) depends how charitable you are! I'm going to be half way generous: there would be a short term gain of keeping *everything* locked down but a potential long term gain in being nicer, and instead of rabidly trying to achieve both those things as they would have done in the past they've decided to be both sensible &amp; nice. If it works out it will be a big "win" for them and also a win for everyone else. Of course keep a close eye on the licensing agreements to make sure they are compatible with your plans long term as well as short. We can't have a go at them in future for enforcing their terms if we don't like them, any more than we accept commercial entities deciding living by the GPL rules isn't for them *after* using GPL code.
This article is just full of catchphrases such as JavaScript technologies and overall sounds really weird, one of the commenters is obviously an alt account. I think you guys are trying too hard.
I'm not aware of PowerBall, but from what I'm seeing in the OP website, I have to find the exact one combination of 3 squares out of 665. Isn't it like the lottery 3 from 665 or like 6 from 49. If yes, the way it's calculated is like I wrote above. EDIT: Please, don't hate me that I just want you to learn something. To understand it better, let's scale it a bit. What are the odds of guessing 3 from 6? If bruteforce it: 1 2 3 1 2 4 1 2 5 1 2 6 1 3 4 1 3 5 1 3 6 1 4 5 1 4 6 1 5 6 2 3 4 2 3 5 2 3 6 2 4 5 2 4 6 2 5 6 3 4 5 3 4 6 3 5 6 4 5 6 ===== Total: 20 combinations According to my formulas: (6 * 5 * 4) / (1 * 2 * 3) =&gt; 120 / 6 =&gt; 20 Another example - 2 from 4 1 2 1 3 1 4 2 3 2 4 3 4 === Total: 6 combinations (4 * 3) / (1 * 2) =&gt; 12 / 2 =&gt; 6
&gt; I have never seen a short and clean Gulp file. https://github.com/dmitriz/gulp-automation/blob/master/Gulpfile.js &gt; Instead of using simple command line tools developers have to learn how to use some wrappers/plugins and whatnot that just call those tools. Nobody is forcing you to learn it. :)
Ah, of course it is! I'm a bit rusty on probability I see.
I've liked JavaScript so much because it's such a simple language. It's missing a lot of what I would consider to be useless cruft. That being said, I've been very happily using a lot of ES6 features, and I have no intention to go back. Sure, they're not necessary, but many of them are so nice.
I got 'You won the PowerBall jackpot!!! You should have bought a real ticket!'. What's my prize?
Array and object optimizations would definitely be good topics for blogs, especially if coming with insightful and explained performance advises. How a different implementation might change how we code (today mostly assuming V8) would be very interesting. Some precision about typed arrays (for example the Uint8ClampedArray used for canvas data manipulation) would also fit. 
I've run into weird bugs on codewars, when I was writing a (presumably) somewhat "alternative" solution to a problem, using generous amounts of recursion. The bug is very weird and most probably originating in Babel. I was frustrated, especially since it's not my first time seeing this. But I did not blame Babel. I made a mental note to avoid Babel, and transpilers in general (because I just try to use the stable, mature and minimal bases to build code upon) except if absolutely necessary. Transpiling sounds like a big task. Don't blame yourself or any of the decisisons. People are enjoying Babel and getting excited about it. I am not on of them, and am happy this way, but would not go and blame you if I had to use Babel one day, and surely not write mean messages and act all entitled. Besides, I'm sure there is much worse. It's also about respect and trying to be positive and constructive. I'm guessing those who are acting "entitled" are not aware of the complexities of programming for, and maintaining such projects. They're probably lousy programmers.
I agree and that's what I was saying. I would not blame whoever worked on Babel. It's rather impressive work actually. Really impressive. I would blame people who slap babel, browserify, grunt, lint, and a bunch of other things on any project they work on, indulging in a giant plugin orgy like there is no tomorrow.
Having spent hours hitting the wall trying to achieve [the functionality under construction here](https://github.com/dmitriz/min-karma/blob/master/README.md#or-install-with-npm-under-construction) and solve [this silly problem that shouldn't be there in first place](http://stackoverflow.com/questions/34781630/how-to-copy-files-from-package-to-local-directory-after-npm-installation), I have to say --- yes, sadly, the state is not great, entitled or not. :( 
This article makes me feel very good about the single page app we're about to launch - we've managed to avoid every single one of his downfalls by using a universal javascript approach. It loads fast because the HTML for the URL they navigated to initially is rendered and delivered from the server. There exists a unique and bookmarkable URL for every page and state, which the browser is updated with using push state so the history works correctly. Links are all `&lt;a href="..."&gt;`, so links open easily in new tabs. Most awesomely, if you disable javascript, the site still works perfectly. Most of these things are not hard to do, you've just gotta do it.
https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators
CoffeeScript was made so Python and Ruby programmers don't have to learn JavaScript. Trust me, I was a Python programmer and CS was what lured me back into JS. The truth is that you can't use CS without knowing any JS. You will be using JS libraries and JS APIs and your code will compile to JS under the hood. If you choose CS you're not choosing it *over* JS, you're choosing it *in addition to* JS. ES6 on the other hand *is* JS. You can convert from ES6 to ES5/3 using Babel but it's still just turning JS into JS. The difference between having new JS (ES5) devs on your team learn CS and having them learn ES6 is that ES6 will still be useful if they move to another project. CS on the other hand is just one altJS out of many that provides no real syntactic benefit over ES6 (compared to altJS langs like ClojureScript, which actually do something fundamentally different from JS) and unlike you're working in a Ruby shop you won't be guaranteed to use it in other projects.
Thanks! So this would work? return getBalance()&lt;currentBetAmount||moneylimit?(console.warn("BANKRUPT! Not enough balance for next bet, aborting."),clearInterval(refreshIntervalId),!1):!0;
Ok, let's unfuck your code first: function checkBalance() { if (getBalance() &lt; currentBetAmount) { console.warn("BANKRUPT! Not enough balance for next bet,aborting."); clearInterval(refreshIntervalId); return false; } else { return true; } } Now it's easy to add another check: function checkBalance() { if ((getBalance() &lt; currentBetAmount) || (getBalance() &lt; moneyLimit)) { console.warn("BANKRUPT! Not enough balance for next bet,aborting."); clearInterval(refreshIntervalId); return false; } else { return true; } } *Edit*: semi-colons are important.
React, Redux and React Router is what's giving us the isomorphism. Also using CSS Modules and plenty of other fancy Webpack loaders to help us out. We are extremely grateful that we agreed upon abstracting out all the 'database stuff' and business logic into a seperate API (and seperate mini-team!) before we started any of this, which made it stupid simple to run the same code on the server and client. 
Hi, I'm curious to know whether Chakra uses [NaN boxing](https://wingolog.org/archives/2011/05/18/value-representation-in-javascript-implementations) or some technique like this, and how objects are laid out in memory (are they compiled to structs with static offsets for field access as in V8, or are they like hash tables?) (well I suppose this is in the docs somewhere, so, otherwise - could you point the right part of the docs?)
Awesome. Will definitely be tackling something similar to this in the future. Separation of the API / "database stuff" seems very logical. Thanks for the insight!
And for real factual discussion, perhaps also ES6 shortcomings are to be mentioned, e.g. see https://github.com/joshburgess/not-awesome-es6-classes
Although I unfortunately know of many sites that have this issue (especially banking sites... ugh), all modern Javascript frameworks have solved the linking problem. Angular, React, Ember, whatever else anyone cares about, they all handle routing properly, as long as you're using their routing components and not trying to homebrew your own router (which is almost always going to be worse than something that's been tested by thousands of developers).
I personally think a webpage that is well designed should be able to channel your journey, not a superimposed back button. That said, most pages are not, and as a result having a back button is a habit. On another note, I think the Ember router aims to link certain URLs to certain resources, so going 'back' should link you to that (if the app is well designed) though I may be wrong. 
Sending network requests 
I think any halfway decent router handles most of his issues. I also object to the idea that a better architecture doesn't provide benefit to users. If the architecture is more maintainable or more scalable or more agile it's easier to change or add to it without consequences. If it's easier to maintain then your overhead is reduced and those savings can be passed onto users, etc. I think in the end it boils down to whether or not the app was coded and designed well, but that goes for any website, not just SPAs.
ChakraCore doesn't actually have the WinRT binding stuff, I was using JSRT (full chakra on windows). Doesn't really matter because our app supports multiple JS backends and we only use Chakra on Windows. On Linux (which we don't have plans on supporting outside the browser) we would likely go V8 to get JIT right now, which would be more of a pain for us in a number of ways.
Sounds like an ok approach. Look into localStorage for persistence (depending on how secure your app has to be ). always remember to keep things simple so you can easily refactor later.
I like it. Humans don't understand odds very well. 
Currently its jQuery hell. Don't know from where to begin to make it beautiful.
yes, the new grid is 31x39
Yup, LA is terrible. Stay away. 
For the people questioning the usefulness of a one line module, [Sindre Sorhus has a nice answer](https://github.com/sindresorhus/ama/issues/10#issuecomment-117766328). 
Hey there, I work for Auth0. Happy to answer any questions.
What makes you say that?
I just did the exact same thing. My thought process was this: The "mature" options are Angular, Ember, Backbone. Less mature is React, and even less so some of the recent additions (vue, mithril, etc). This matters for some businesses, not others. IMO Angular and Ember are very large for this kind of work (in size and loading speed). You won't be utilizing their benefits for something of this size, so it may not be worth that cost. That leaves Backbone or React. React would need a router and maybe a flux/redux add on. Backbone might need marionette/thorax/whatever to reduce boilerplate. Both are smaller and load quicker. There's a theoretical risk of React adding breaking changes in a release (still pre 1.0), but probably not. You probably aren't doing tons of dom changes that would benefit from virtual dom, so thats not a factor. Your choice from there, either can get the job done.
I use [VueJS](http://vuejs.org/) for that kind of things, it's a breeze! I'm in the process of making a wizard of 7 steps to configure some complicated part of site in a SPA kind of way. Super easy!
Huh? Most modern client side apps "solve" the linking issue by just using pushState or hash based routing (or using libraries that implement that under the covers.). This critique was probably valid 5 years ago.
Well he eats poop for once.
They're both OO; we're just using a pointer to one function instead of inlining two. 
That does not sound like using NPM to perform CI, but rather using a traditional CI system to perform a build which executes an NPM install step. At work there is an NPM instance that performs the CI directly, and sometimes its strange.
Hi /u/vscode, please don't post links as a self-post unless you have some significant commentary to add. Thanks.
Hi /u/ducktomguy, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
1. the point of UWP is that everything is resizable and runs on all devices and screen sizes. Maybe you better use a responsive design pattern to support all of them? There's a OnResize event handler to rebuild graphics and recalculate the content to fit the new window size. Another option for desktop would be to go fullscreen. 2. `DisplayInformation.AutoRotationPreferences = DisplayOrientations.Landscape | DisplayOrientations.LandscapeFlipped;` does it on C#, the WinJS examples might help: https://msdn.microsoft.com/en-us/library/windows/apps/windows.graphics.display.displayinformation.autorotationpreferences Better check /r/wpdev for questions about the windows platform
Nothing.
[removed]
https://en.wikipedia.org/wiki/Adapter_pattern I would read the wiki entry to determine why this Pattern is useful.
That's amazing thanks! Having a slight issue in that there are other &lt;td&gt;s with a class contained within the &lt;tr&gt; that I don't want to change at all (so a more accurate description would have been to give the "Hello World!" &lt;td&gt;s a class of, say, "A") - sorry about that. Also the "Number of Xs" text won't necessarily contain the class name. I have now changed it so that the query looks like this: &lt;script&gt; (function() { var tr = document.querySelector('tr'), tds = tr.querySelectorAll('td'), counts = {}; Array.prototype.forEach.call(tds, function(td) { if(td.classList.length) { var cls = td.classList[0]; counts[cls] = (counts[cls] || 0) + 1; td.parentNode.removeChild(td); } }); for(var item in counts) { var newtd = document.createElement('td'); if (item == 'X') { newtd.textContent = 'Number of items of type 1 = ' + counts[item]; tr.appendChild(newtd);} else if (item == 'Y') { newtd.textContent = 'Number of items of type 2 = ' + counts[item]; tr.appendChild(newtd);} else if (item == 'Z') { newtd.textContent = 'Number of items of type 3 ' + counts[item]; tr.appendChild(newtd);} } })(); &lt;/script&gt; This is close but it still gets rid of other &lt;td&gt;s that have classes other than X, Y or Z which I don't want to do. Can I add a final "else" statement to say if it's not one of these leave it as it is? EDIT: spacing
To me, this article is basically saying "Don't fuck with expected browser behavior in your SPA." Yeah, of course. Everyone's big critiques of SPAs these days seems to be "this shitty bank IT department made a janky Angular app so SPAs are bad". Guess what, their normal website was a nightmare before the redesign too, they just didn't have the ability to break as many things in 2007.
What does this entail for WebGl?
Really happy to hear this! Feel free to reach out if you find less good things :)
How did you handle submitting forms? Traditional way, currently mine does everything but the data which goes to the API on form submits is constructed in the JS. I'm considering changing the API to accept application/x-www-form-urlencoded and use forms to create the data, rather than sending JSON.
Heh, even considering 1 bad issue gives us a bit of pause. Practically speaking though we've had a lot of eyes on the code already so a flurry of 5-10 serious issues seems unlikely. I was also a bit upset that the first bug report we got was a typo in something I wrote. Felt pretty severe to me at the time :-P
Not much. WebGL is part of MSEdge and MSEdge's plans WRT OSS have not changed with this announcement.
Valid questions. This module doesn't really add anything of value, `return new Promise(require('domready'))` does not do anything other than change the usage signature from `require('domready')(function(){})` to `require('dr-promise').then(function() {})` You cannot `catch` or anything on it, because the wrapping in `Promise` does not reject on error. `domready` only passes a single argument. It `resolve`s no matter what.
ChakraCore is just a JS engine so no DOM like document.write, window, and etc. In terms of pure script engine things we didn't open source, I believe it's only our UWP API projection layer used by UWP apps written in JS/HTML to access UWP APIs and the interface we use to communicate with Edge in the browser.
Another one? Just put it in the pile...
Welcome to Reddit!
"Will you help me convince a client to refactor a large codebase to use a framework?" My rate is $105/hour. But sure!
As a rule of thumb, if your conditional *and its possible outcomes* is longer than, say, 20 characters, you should break it into a real `if` instead of using the ternary operator - it improves readability a lot, and makes it easier to figure out what it's doing. You don't win medals for shortest code by using `?` and removing spaces...
[removed]
[removed]
[removed]
I didn't mean it as an indictment. I meant that the perception of JS fatigue seems to be coming from users and not from the people that actually provide OSS to them. I'm sure there are internal discussions but not because they "feel" the fatigue but how users react to changes in their software and the trend to place the burden of configuration and selection to users. It just doesn't jive with me and feels like JS userland is getting a bit too, spoiled. People put out OSS and support it because they care. To complain about the myriad of options just seems unnatural to me. To demand that we fall to a default set of tools just goes against the grain of what OSS is all about if you ask me. Maybe I'm old school in that sense of appreciating someone else doing a job for you. Because what it comes down to is personal choice. You don't have to use anything out there. I don't have to use React, Angular or Aurelia. I don't have to write in ES6. I don't have to use JS in the back end. But I choose to. It seems like many developers passing judgement onto OSS developers seem to forget nobody is forcing their hand.
[removed]
Yep! See also: https://github.com/Microsoft/ChakraCore/issues/31.
[removed]
Instead of testing for each possibility, create an object that stores the desired class names as keys and their descriptions as values. Then you can use that to filter the elements so that you only remove the ones that match, and then reuse the object to create the strings at the end. [Example](http://codepen.io/anon/pen/adyJjW?editors=101). 
vim by default.
I can't think of any reason why anyone who does webdev not have some sort of emmet plugins
How do you do the disabling javascript part and keeping the app working? 
Am I wrong or you can find out about someone trolling you like this by simply going through commit history? Unless no version control - then you REALLY deserve this...
Though, if you're going to do that, make sure you have a linting rule that checks for and prevents you from using "var". Otherwise, if anyone on your project at any time in the future uses a "var" anywhere, then that's going to leak scope. Safety first. Make sure you don't risk bugs just to save a few keystrokes.
&gt;For added frustration, any of the following characters can be replaced with homgraphs / homoglyphs: !, (, ), +, ,, ., /, :, ;, &lt;, and &gt;. Not even CoffeeScript can save you.
You're an asshole. Well done.
Ah yeah, I think just about everybody is doing that. That is absolutely the way to go, because it allows you to solve the distribution piece first so that you can focus all your CI problems only on local code execution.
No, a primary use case for IIFE is to assign the value of a function to a reference without changing the order or operations, not polluting the current scope with additional references only necessary to create this one value, and not alter the data type of the reference being assigned. Here is an example: var a = (function () { return aNumberAfterDoingSomeMath; }()); // typeof a === "number"; This case has nothing to do with invoking a false block scope, which is the other major use case.
You don't need the parenthesis after assigning video.muted to true/false, try updating them to: video.muted = true; video.muted = false;
Fat arrow syntax is one of the things I like about ES6. I don't really get how it is ambiguous. Can you elaborate? The article you linked is helpful in explaining the detail behind FAFs, but it doesn't really make me less inclined to use it.
Should I create an SPA or an old school website with several webpages?
Hey man, I wrote you some demo code... https://jsfiddle.net/Lanlost/9d7a1yyg/1/ Don't copy anything past the: // ------------------------------------------------------- // OUTPUT ONLY DO NOT COPY THE FOLLOWING TO YOUR CODE! // ------------------------------------------------------- But everything before is made for you... This is a single loop that runs every `minInterval` seconds (200) but doesn't click the first button until `firstClickTime` which is 2 seconds. Then, every `minInterval` it clicks A or A AND B (if it's already clicked A at least once) and finally once button C appears it starts clicking that. The one part you would probably need to modify (besides the selector names) is this line: var btnCExists = $btnC.is(':visible'); It determines if button C exists by if it's visible or not. This will both work if it's just hidden OR if it doesn't exist at all and is later 'injected' into the page and displayed. Just saying, all you'll need to do is fill that variable out to be true once the button exists. Try it! &amp;nbsp; --- Here is an alternative version that clicks A only once and once it's done that will spam B until C appears: https://jsfiddle.net/Lanlost/eud22L71/ (The normal one spams both A and B after A has been clicked once but before C appears, like I think you intended...)
DUDE THANK YOU A TON FOR THIS ! i've found a method myself to rule the code , should i send you a PM ?
btw at some point when i tried a version of my code , after spamming the 2 button the site would become black. Cuz it multiplied some modal fades , didn't do anymore when i used my last version , but i am just courious xD!
You can still screw with them if they leave their machines unlocked.
leaving the machine unlocked is probably as lame as not using version control...
I think achen was trying to describe the module pattern. var MODULE = (function () { var my = {}, privateVariable = 1; function privateMethod() { // ... } my.moduleProperty = 1; my.moduleMethod = function () { // ... }; return my; }());
Good talk - would be really nice if the transcript wasn't a wall of text.
Respect. Serious respect. Even though in the React/WebSockets era I found myself no longer using jQuery much, I still remember making the PrototypeJS -&gt; jQuery transition back in the day and loving life. It was a game changer (and, don't get me wrong, jQuery is *still* fantastic for many applications). 
I remember seeing a blog, or YouTube video of some Ruby dev who stumbled across some weird character that showed like it was white-space, but it wasn't. He found he could use it as variables, method names, and something else. Wish I had a link to that.
This is the exact use case he was arguing wasn't primary. IIFE's don't really make sense with ES6 IMO.
I so complete agree with this. I suspect the article will get downvoted substantially compared to the prior article inspiring this. While both articles recognize a problem this one does not merely panhandle to whining. This actually proposes a solution.
How about web dev fatigue? I came out of a 2 year program not sure what I needed to get a job. I have spent anywhere from days to months studying: * Java * c# * XML * SQL * Mongo db * Functional programming * OOP * Ruby * Rails * Sinatra * rvm * chruby * rbenv * bundler * Opal * Javascript * CoffeeScript * JQery * Node * Meteor * React * Angular * KeystoneJS * Express * JSON * Bash * Zsh * Linux OS * Git * PHP * Drupal * Open Cart * PrestaShop * WordPress * Apache * Nginx * MAMP * Vagrant * Docker * Ansible * Capistrano * HTML * CSS * SEO * SASS * LESS * BootStrap * Foundation * Grunt * Gulp * Bower * Yeoman * and probably 100 things I forgot the name of I am not kidding and I am not trying to brag. Sadly I do not know much of anything about 70% of the list. I would often see a job and spend the weekend reading a book or going through a tutorial hoping it would be enough to get me in the door. Some of it was on projects I landed before I figured out I need to specialize or go insane. In my opinion there is too much out there in webland. I wish I started when it was HTML, CSS, and JS. Trying to catch up is hell for us noobs. 
We are working on new diagnostic APIs that will make integration of Chakra with VSCode much easier. It's a part of our diagnostics roadmap. More at https://github.com/Microsoft/ChakraCore/wiki/Roadmap Disclaimer: I work on Chakra team
1. var Withdraw = setInterval(function () { $('#showConfirmButton').click(); }, 1100); 1. var Confirm = setInterval(function () { $('#offerButton').click(); }, 1300); 1. var Check = setInterval(function () { $('#confirmButton').click(); }, 5000); 1. var el = document.getElementById("offerButton"); 1. 1. if (el.addEventListener) { 1. el.addEventListener("click", function() { 1. clearInterval(Withdraw); 1. clearInterval(Confirm); 1. setInterval(function () { $('#confirmButton').click(); }, 1800); 1. }, false); 1. } else { 1. el.attachEvent("onclick", function() { 1. setInterval(function () { $('#showConfirmButton').click(); }, 1100); 1. setInterval(function () { $('#offerButton').click(); }, 1300); 1. }); 1. } after the C button will be spammed enough there will appear a text. "Attempting mobile confirmation: succes" it's a div , and the id is = inlineAlert
It's crazy to imagine what the world of JS development would look like today if it wasn't for jQuery. Its effects were so far-reaching and fundamental that it influenced the entire web industry, probably in ways we can't even imagine. I never liked the dense, overloaded and over-decorated API, I just scratched my head whenever I looked at the source, and I'm happy to finally live and develop in a world where I don't always need to use it anymore (even if I still find some of my favorite libraries silently depending on it), but goddammit if it wasn't a godsend back in *those* days. My heartfelt thanks and congratulations to John and the entire jQuery team on this historical milestone. Happy birthday, you magnificent bastard!
I was going to convert a node app with a lot of callbacks I'm playing with to promises as an exercise. But...it seems like a huge pain and doesn't really improve readability. A lot of work to flatten out some nesting. Am I missing anything?
10 years goes by so quickly! In another 6 years jQuery will be driving.
An SPA may not be appropriate for a simple mostly static site. WE FUCKING GET IT. How many blog posts making this point do we need? But hey guess what? Many of us are working on complex client side applications. We do not use basic HTML/CSS/JS for very good reasons. So if you don't work on a large application like that, please shut the fuck up with your opinion on how to build them, because you don't know what you're talking about. /rant
variable declarations with `var` don't return a value. Assignments do. Doing something like `a = b = c = 5` will work and assign a, b, and c the value 5 because `c = 5` "returns" 5 which then gets assigned to b and so on. This does not happen with var.
`var a = "hi"` is a statement, whereas `b = "hi"` is an expression. That means that `b = "hi"` could be embedded in part of a larger expression, e.g. console.log((b = "hi") + " there"); In other words, the `=` operator evaluates to the value of the left hand operand. However, when you add in `var`, you turn the expression into a statement, which is a different beast grammatically speaking. A statement can't be arbitrarily embedded anywhere, only in the places where the language specifically allows it. This is a syntax error: console.log((var b = "hi") + " there"); You can't put a statement where an expression was expected. And because of that, it doesn't make any sense to talk about what a statement would evaluate to. A statement doesn't evaluate *to* anything. The best the REPL can do is print `undefined` when asked for what the result is when evaluating a statement, but really there is no result.
&gt; it seems like a huge pain It's actually very easy to make the conversion once you get used to it; a good Promise library (eg, Bluebird) has very strong support for automatically converting functions that expect a callback to Promise returning functions, and many key libraries either support Promises or have wrappers already. Once you get used to it you'll find that you basically never end up actually manually creating a promise or resolving it. &gt; doesn't really improve readability For simple code, it probably will a bit, once you're really used to reading promises; the chained `.then()` doesn't start looking natural for a while. For complex code, it'll make a bigger improvement faster. In particular: * Complex flow control is much easier with promises, especially if you use a good Promise library like Bluebird. Eg, do `A`, `B`, and `C` in serial, passing each one the result of the previous one, then once `C` finishes run `D`, `E`, `F`, and `G` in parallel, then start `H` once at least two of them have finished successfully, or `I` if three of them fail. 100% doable with vanilla callback code, but much clearer with Promises. * Error handling. Simple code (or code written by beginners) often can just assume that all those callbacks work. But complicated code (especially in production) cannot do this. And in callbacks you need to check the first argument for an error in **every** callback, and then handle it correctly. It's a pain, easy to mess up, and tends to cause massive code duplication. And your actual business logic is often hard to follow buried under all the repeated `if (err) { /*...*/}` blocks. With promises, it's often as easy as a `.catch()` at the end, because promises will bubble an error back up until it's handled in a way that can't. And if you do it right (again, use a good Promise library) you'll get really clear stack traces as a bonus.) It's clearer, easier, harder to get wrong, and follows DRY. &gt; A lot of work to flatten out some nesting. The nesting is really the least of the issues with callback code compared to orchestrating complex flow control and then properly handling errors throughout the callback pyramid. If the only benefit you're getting is fewer spaces, you may want to skip it.
Doesn't seem different than this, really: var a = 0, something = "blah", tab; { let aa = options.inchar, bb = options.insize, cc = []; for (bb = bb; bb &gt; 0; bb -= 1) { cc.push(aa); } tab = cc.join(""); } Unless you're just using it for cosmetic reasons.
&gt; Even though in the React/WebSockets era I found myself no longer using jQuery much Newbie web dev here. Why is that?
I would say that 90% of your time, you need JQuery for simple interactions : addClass, remove, show, hide, and somme event functions like onKeyUp, onClick and so on, which you don't need in react because you bind these types of event in your component, and you can transfer these events to the 'children' of your component. Maybe someone can explain it better than me, but I'm in the same situation, I don't need to use JQuery, or at least I don't need everything from JQuery, and now I try to do vanillaJS when I can. 
Looks like `options` are referenced externally which would lead to a closure and memory leak. So, things could absolutely be left behind and is dangerous if you were to pass in a huge dataset and not realize the implications. That function code should absolutely be a module (even if it's called once). The way this is written is impossible to test and gives no benefit over calling the code inline. All you've done is add an additional function call.
It is entirely the same, but that looks like a few extra lines of code and a bit less clear because I have to read more to see where tab is assigned a value.
You could be doing some heavy computation in a Worker/Isolate, for example.
Most people here have gotten the basics, but an interesting point is missed - some statements actually do produce values. How? Why? The answer is eval, of course! eval('1'); // 1 Clearly eval is evaluating 1 as a script (via script -&gt; expression statement -&gt; literal). Script and expression statements propagate completion values appropriately for this to work. Another interesting case: eval('if (true) { 1 } else { 2 }'); This will return 1. If you replace true with false, it will return 2. If statements are completion-value-producing statements. So why doesn't `var a = "hi"` produce the value `"hi"`? Var statements always produce a completion value of "Empty" which you will ultimately see as undefined. If I had to guess why, I'd say there isn't much use for it to do anything otherwise, whereas there are many patterns that depend on b = "hi" evaluating to "hi", eg. `while (next = getNext()) { }`. 
jQuery was especially useful in its ability to provide a single api for the browser that hid away all the complexity around the fragmented apis of older browsers. Now that most browsers utilize a modern, standardized api, jQuery's main use-case is essentially moot.
About when did that happen?
As a newer dev, this sounds incredibly useful. Please become a thing.
So now those job specifications asking for 10 years jQuery experience can finally be legit.
&gt; You could apply this same argument to a student using a calculator instead of solving a math problem by hand. http://www.fortheloveofwriting.net/dr-cheng-tells-colbert-im-not-a-calculator-im-a-mathematician/ "Colbert tried to show off by adding a complicated series of exponents in his head. When he asked, 'Is that right?' Cheng responded, 'How should I know? I’m not a calculator. I’m a mathematician.' ;-)
LOL. SO true. 
Yeah the others here pretty much summed it up. But I'll add: now that React (&amp; co.) are doing all the [DOM-diffing/updating](https://facebook.github.io/react/docs/reconciliation.html), now we just need to worry about updating the application state (Redux FTW). For awhile jQuery was the go-to library for at least getting the AJAX calls done, but now that working with web sockets is *much* easier, we can send messages through the pipe instead to sync state. 
Lord help us
Yup! We found it performs much better than our previous site - but that's not saying much because the old one is rubbish and does things really expensively (would take like 800ms - 1200ms to render a page). We can handle larger than our peak traffic with responses rendering in less than 350ms, which we're pretty happy about. We do have an Akamai cache in front of our site which offloads the large majority of requests, so we're never really impacted by slow render times, but it's important for us to make sure its fast to begin with :)
Because our SPA is running on the server as well which is isomorphic to our client JS. All links are just `&lt;a href="..."&gt;` tags. When the user has JS enabled, click handlers are added to them to do push state and rest of the AJAXy stuff and rendering. When not, the browser just does the full round trip and makes the server render the page and return it. We do all authentication and per-user stuff entirely client side, so people who have JS disabled are stuck with the logged out view of the site, which is perfectly acceptable for us.
&gt;why not using Babel which uses "native" feature? Not really suitable for quick prototyping in browsers or most online js editors. For medium to bigger project I'd definitely use babel but at times I want something readily available with no dependencies.
Wow seriously? Fuck I'm getting old.
Let me preface this by saying, jquery is awesome and used to be really useful. I got nothing against it. I just haven't used it professionally in years and don't see why I'd ever go back. Your response touches on a lot of things. I'm going to try to respond to it point by point. &gt;The DOM is still a steaming pile of garbage, it just completed some missing features (bizarrely recently!), and made it more cross-browser-compatible (except older IE, which was the main issue to begin with). I'm not sure how you came to this conclusion, but as a front end developer who writes a shit ton of javascript and interacts with the DOM ceaselessly, the DOM is really pretty simple and the API is pretty great when you're not on &lt;IE9. And &lt; IE9 isn't even supported by jquery 2.x anymore. &gt;The AJAX parts are obvious, There are better alternatives for AJAX that don't require a monolithic library. &gt;but my favorites are actually the event triggering system. Same thing here. If I want an event library, I'll grab [one off npm](https://github.com/asyncly/EventEmitter2). I don't need jquery for that. &gt;And honestly, even the simple DOM manipulation and traversal, looks all over the place. What? Need to get an element? One method and you're done: `document.querySelector`. Manipulation? There's plenty of standardized methods: `appendChild`, `style`, `textContent`, etc. As for traversal...you know honestly I can't remember the last time I actually needed to manually traverse the DOM. But you should be fine: `element.parentNode`, `element.children`, etc. &gt;Of course, if React does all of the DOM manipulation and event handling, and you don't use AJAX, those arguments aren't really relevant. And I suspect that this is the case here. Again, I've been using React daily at my day job for probably a bit over a year now, and React doesn't do anything except render really well. That's the beauty of it. It's a targeted library: it does one thing (render and update the DOM) and it does it well. This is as opposed to jquery which is this massive toolbox that most of the time you need maybe 10% of it at all. tl;dr I've been writing javascript targeted at browsers up and including IE8 for like 3 years now and haven't touched jquery in any of that time.
Yeah. But the op said you can pass a string or an array?
Yup. The people that bitch about jQuery obviously never had to do web dev before it existed.
$(".comment").filter("[redditUser='mmmicahhh']").find(".upvote").click();
I agree. I have been migrating a JS app into to a document-store, bucket to map/reduce, [flux-like](https://github.com/facebook/flux) implementation, and all the promises and shared state are naturally falling away. [unidirectional data flow](https://open.bekk.no/easier-reasoning-with-unidirectional-dataflow-and-immutable-data) FTW! That being said, promises are great for certain async requirements, http requests, etc
You must hate array literals, then, since [square brackets are mathematical symbols, too](https://en.wikipedia.org/wiki/Interval_(mathematics)).
Not in javascript code they aren't. 
&gt; This is as opposed to jquery which is this massive toolbox that most of the time you need maybe 10% of it at all. This is also the reason jquery was and still is popular. One library, almost anything you could ever want in the js ecosystem. Obviously the introduction of npm allowed everyone to fine tune their stack. But jquery is like the hammer of js. Of course it's downfall is that when you have a giant hammer everything looks like a nail. 
¬_¬
This is similar and if you want to have buttons like this you can use it as a starting point: https://bootswatch.com/lumen/
Check out `koa` (the spiritual successor to express). Koa is a slim middleware manager with `co` at it's heart. This allows you to `yield` a promise so that you can sequentially run promises like: `const name = yield getName(myId);` `const job = yield getJob(name);` This allows you to program with `asnyc` code in a linear fashion without worrying about `thenables`, as well as using standard `try` `catch` to catch errors. The long term goal with `es7` is to simply use `asnyc` and `await`, and when that occurs we will reach asnyc nirvana 
One part of this that confuses me, isn't `b = "hi"` a statement which implicitly sets `b` to `"hi"` at global scope in non-strict mode?
They happen neither concurrently nor in parallel. Only one thing happens at a time. Those things are tracked concurrently by the interpreter, and scheduled independently. If there are multiple threads of execution running then it would be in parallel. If there are multiple things runnable at once and executing non-sequentially, that is considered concurrent.
I just might be the guy who fits this requirement, and I'm not gonna claim it. 
So apparently, I now have a decade of experience with jQuery. That's pretty rad! Where would I be without .toggle()?
&gt; jQuery.Deferred is now Promises/A+ compatible Very wow. Much standard. So helping.
Almost getBalance() &lt; currentBetAmount || getBalance() &lt; moneylimit
This made me emotional for some reason
IMO IIFEs are best for having statements where expressions are expected. const sth = expr; // versus const sth = (() =&gt; { stmt })();
`$(function(){ (function($) { $.fn.upvoter = function() { $(document).find('div').filter(function() { return this.id.includes('cyyft5k') &amp;&amp; this.className.includes('comment') }).find('[data-event-action="upvote"]').first().click(); return this; }; }(jQuery)); $(window).upvoter(); });`
This. I like IIFEs because it allows you to compute complex things and assign the result to something and know from the beginning that it's an assignment. let sth = // aha! We're assigning something (() =&gt; { // okay, this is a function .... })(); // and we're assigning the result of it! // versus let sth; // okay, there's a variable 'sth' { // we're doing things. What do we do with the result? global var? nothing? assign 'sth'? ... sth = ... // ah, it was 'sth' all along! }
This does not leak memory as the function object is inaccessible after it's first called. All memory for closed-over objects that are not referenced anywhere else can be freed immediately after the function returns. The scope of the function call does not persist longer than the function call because no eay of accessing it is returned / leaked via side effect
`b = 'hi'` is an expression. In JS, there is a so-called 'expression statement'. It's a statement that consists of only an expression and a semicolon. Examples: 5 + 3; b = 'hi'; func1(); (function () { }); // this creates a function and does nothing with it
Damn people are very clearly being taught the wrong things nowadays. If you inspect the element you can see the classes `custom-btn custom-btn-red custom-btn-primary`. The styles for the button are on the right sidebar. http://imgur.com/Aq8Q1Tk
So you could handle all the image manipulation on the front-end and just send up the finished image. At that point it's all about saving the image and attributing it to a user. Pick whatever you are comfortable with. Literally any tool could be used here and it wouldn't be wrong. Like another user said, I think you are asking the wrong question as to what to use. Use what makes sense to you and will get the job done. Don't force yourself to use some framework for no reason.
`eval` produces returns for `if`s that have expression statements in them? I really have to take a deeper look at this... Sometimes you think you know all of JS and then someone slaps you over the head with stuff like this. Could it be that some statements don't re-write the value of completionValue and just take whatever is there? Like `if` taking the value of last-statement-in-executed-block?
Thabks! :)
Tried that already, did not work. I needed to create a div object and put the listener on that. which is then used as the content of the InfoWindow.
A promise that would cascade into another promise without modifying the global state (for example a filter that would alter the returned data in some way).
[**@BrendanEich**](https://twitter.com/BrendanEich/) &gt; [2015-12-17 00:11 UTC](https://twitter.com/BrendanEich/status/677279837317406720) &gt; @feross's http://standardjs.com/ is nice while in JS, but when switching to CSS or other such langs, sudden semicolons requirement hurts. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
 var userLink = document.querySelector('[href$="user/mmmicahhh"]'); var comment = userLink.parentNode.parentNode.parentNode; var upvote = comment.querySelector('[data-event-action="upvote"]'); upvote.click();
Yep. Also check out [exponent](https://exponentjs.com) which makes it really easy to run your react native project on your device/share your work with others.
Some of my best programming memories have been working with jquery. It changed the Web in so many ways, and for me, it made JS fun. 
"standard" also badly (meaning nobody does that) enforces a space after a function name: class Foo { name (arg) { ... } } function name (arg) { ... } Instead of: class Foo { name(arg) { ... } } function name(arg) { ... } [Airbnb - 28,656 stars btw](https://github.com/airbnb/javascript#functions), [Google](https://google.github.io/styleguide/javascriptguide.xml?showone=Method_and_property_definitions#Method_and_property_definitions), [Mozilla](https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Coding_Style#JavaScript_objects), [idiomatic.js](https://github.com/rwaldron/idiomatic.js#spacing), [Crockford](http://javascript.crockford.com/code.html#function), [jQuery](https://contribute.jquery.org/style-guide/js/#comments)... don't recommend that. None of the popular programming languages out there do that either: [Java](http://www.oracle.com/technetwork/java/javase/documentation/codeconventions-141270.html#381), [PHP](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-1-basic-coding-standard.md), [Python](https://www.python.org/dev/peps/pep-0008/), [Ruby](https://github.com/bbatsov/ruby-style-guide), [C#](https://msdn.microsoft.com/en-us/library/ff926074.aspx), [C++](http://www.stroustrup.com/bs_faq2.html#simple-program), [C](https://en.wikipedia.org/wiki/Indent_style#K.26R_style), [TypeScript](http://www.typescriptlang.org/Handbook#functions), [Scala](http://docs.scala-lang.org/style/types.html#functions), [Rust](http://rustbyexample.com/hello.html), [Swift](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html), [Go](https://github.com/golang/example/blob/master/hello/hello.go), [Dart](https://www.dartlang.org/effective-dart/style/)... In fact no-space-after-function-name is so obvious that most style guides don't even specify a rule for it: you can simply see that in all given examples there is no space. Recuring complains about it: - https://github.com/feross/standard/issues/311 (created by myself - locked) - https://github.com/feross/standard/issues/89 - https://github.com/feross/standard/issues/217 - https://github.com/feross/standard/issues/318 - https://github.com/feross/standard/issues/164 - https://github.com/feross/standard/issues/379 The only statistics about space-after-function-name (33%, see http://sideeffect.kr/popularconvention/#javascript) are wrong, see https://github.com/outsideris/popularconvention/issues/62 (created by myself). It checks for `function()` vs `function ()` without a function name, not for `function foo ()` vs `function foo()` like advertised. Those mistaken stats are used by "standard" author to explain that space-after-function-name is common, see: - https://www.reddit.com/r/javascript/comments/3tfpxa/githubs_atom_moving_from_coffeescript_to_es6/cx7h68a - https://github.com/feross/standard/issues/318#issuecomment-154184796 - https://www.reddit.com/r/javascript/comments/3tfpxa/githubs_atom_moving_from_coffeescript_to_es6/cx7h7na Edit: I'm made my own stats and **92%** of the repositories use no-space-after-function-name: https://github.com/tkrotoff/space-after-function-name
This. How does this guy claim a Standard when he uses a style the majority don't. Just pure BS.
But why not strict ES6 with babel so its more compatible across more browsers, unless you don't like using most of the new features in ES6...?
I find it best to treat the entire project as an amusing joke that a small number of people haven't got yet. :)
https://developer.mozilla.org/en-US/docs/Web/API/History_API history.pushState();
Yes, and I explained why I'd go for a different approach with a different signature.
 app.use('/admin', [ adminMiddleware ]); app.get( '/admin/a' , ( req,res ) =&gt; { ... } ); app.get( '/admin/b' , ( req,res ) =&gt; { ... } ); app.get( '/admin/c' , ( req,res ) =&gt; { ... } ); Note that this will make ALL `/admin` routes run adminMiddleware. To make it only some of them, you'd have to split it up into something like `/admin/withMiddleware` and then do the `app.use` on that along with changing all the routes.
Thank you!
probably. the caveat of react is css3 animation seems was not entirely planned for by the react devs (imho). if your not using it you will be fine. if you are its kind of annoying. if im wrong and someone has a good explanation of animating css3 with react id love a link / some data.
It's not easy to explain but yes you have to understand what the node is. But basically electron and NWJS is web browser with node integrations. You can make hybrid desktop apps with the help of node with using all node modules. Maybe you should check some tutorials on youtube to understand how you can use and what you can do with node first, then rest is basically writing JavaScript, nothing more... BTW if you want the check some sample app you can check my [nwMAME](https://github.com/ozguncagri/nwMAME) project or there is tons of open source applications that uses NWJS or electron.
Thanks for the reply. Been trying to wrap my head around Node for a bit. I guess I'll keep walking that path for a while and see where it gets me.
Nodejs is basically a desktop-class "standard library" for JavaScript. Electron mates that with a chrome webview. It's awesome for debugging. 
(zoom in to the left side, code checks out) 
You mean React v0.14.6 and React-native v0.17.0? Sure! Go wild.
&gt; ... whenever a user accesses your blog (with a working internet connection), all of your articles and pages will get deliberately added to this user's browser cache. That doesn't sound sinister at all.
\&gt; /dev/null
Check out express's [`Router`](http://expressjs.com/en/4x/api.html#router). Can be thought of as "sub-app" you `.use()` on your main one.
Wow, is there a big demand for dense linear solvers in node apps? 
I'm legitimately curious to hear your recommendation as an alternative to what he is currently looking in to.
There is definitely an increase in interest for machine learning, which in turn can benefit from high performance linear algebra. EDIT: I've also written [nBLAS](https://github.com/mateogianolio/nblas), C++ bindings to BLAS, if anyone's interested.
Yeah, css3 animation is a bit of a pain. I personally use the rather young [React Motion](https://github.com/chenglou/react-motion) library for non css3 animations. It is very nice to use and easy to set up. That being said, I've not played around with react native but as I understand it it uses literal native blocks which isnt html and as such css3 animations wouldnt be a part of it? (As I say, I do not know much about native but will look it up now to see if that is the case). Edit: From a quick glance it seems facebook react native implements their own subset of css. I doubt animations would be a part of this.
I think the angular team already killed angular by itself.
It's just a beta and we are actively working on new features, so any feedback would be greatly appreciated! On the plate next is time-travel state replacement, and in-browser NPM importing so you can require other components on the fly.
Not every project targets v1.0.0 as the first "stable" release. Node is a prime example. Before the merge with io.js, node was at 0.12.xx.
Did you read their [Quick Start Guide](https://github.com/atom/electron/blob/master/docs/tutorial/quick-start.md)?
Are you having trouble getting a hello, world app running? What kind of machine are you running? Windows? Mac? Linux?
https://github.com/isaacs/semicolons/blob/master/semicolons.js This is a joke, right?
Yeah I'm contracting for a big 5 web company trying to stay in sync with react updates. nightmare.
Taking this into production NOW! Cheers!
Awesome man! Glad you like it. We have some really cool stuff in the pipeline to make it even better. 
Sharing it with all 3 people I know, hope your servers can handle the load!
This is amazing - definitely a pain point of mine when working with simple examples. Thanks for putting this together! Is the source up anywhere? 
/r/shitpost
Amazing work! Great job.
Thanks for the kind words! It was a huge pain point for us as well. Especially for training the basics of what the core concepts of React are, without getting lost in the build-tools weeds. We have a couple more features and cleanup to do, and then we will likely open source it.
Thanks Tyler! We are big fans of your work
Ahh! Got it! You didn't add the head to the table. Add this: myTbl.appendChild(myTblHead);
You mean like all JavaScript? Seriously though, the proliferation of JavaScript frameworks and libraries means that there will be mountains of legacy JavaScript code to maintain in the future.
What's the benefit of using Javascript instead of Python for machine learning? 
Wut? EDIT: Of ffs... Jake Weary, not to be confused with JQuery...
sure go for it =) I'm always curious to see what people come up with.
ಠ_ಠ The semicolon is not a toy, Mr. brianleroux. Maybe since you're taking the "semicolons" name in npm, you could check for excessive or double semicolons and then run it on your own code. On a more serious note ["require.extensions" is Deprecated](https://nodejs.org/api/globals.html#globals_require_extensions).
Oh, I updated the post that shows you how to use generators w/o any libraries. Pretty sure that doesn't give you all the features that co gives you but it gets the job done. I'm happy with that. 
&gt; Too many semicolons. Too many, or not enough?
From the express docs var express = require('express'); var router = express.Router(); // middleware that is specific to this router router.use(function timeLog(req, res, next) { console.log('Time: ', Date.now()); next(); }); // define the home page route router.get('/', function(req, res) { res.send('Birds home page'); }); // define the about route router.get('/about', function(req, res) { res.send('About birds'); }); module.exports = router;
Thank you.
lol, we bumped up the CPU's just for you. Thanks for sharing!
That learning pattern sounds eerily familiar. I started forcing myself to read through things in their entirety before jumping right in. Life has been much easier ever since.
About a month ago I've stopped using semicolons and didn't run into any problems. I know it's only a correction mechanism but it works suprisingly well. In combination with ES6 it makes for some terse, noise-free code.
I blame Tyler McGinnis for sharing it on React Newsletter.
This guy gets it.
His coding style gives me fits. When you're writing just for yourself, you can use the fewest possible portions of the syntax of your language. Or to put it another way "Fo y'self, ya'll can jive." But for code you're sharing, by god you should speak The Queen's (*er...*) Javascript. I mean braces where there can be braces, semicolons where there can be semicolons, and indentation that moves statements to the right of their opening paren/curly. Why? Because when I have to read your code, or edit your code, I want it to be the *most obvious* what you mean. It may seem like omitting semicolons and braces makes sense for you if/else if/else one-liners, but if I have to add a line, well, shit gets dangerous and that's how bugs get made. 
On frontend while developing yes, but then I minify it, which then removes semicolons, so we're back to square one. Oh and my code isn't transpiled in the server and semicolon free.
Love the irony of this sub. Make a post making fun of you and it gets upvoted to the number one spot. State that I omit semicolons and get downvoted.
Brian Leroux was just someone who sent a pull request. The creator of this was the guy who actually created npm lol.
I wish more developers appreciate this. It doesn't apply just to code, but also to comments, commit messages, and log messages. I've lost countless hours trying to decipher the original developer's intent. If I'm lucky I can ask the person, but sometimes they've long since left the company. My plea to all developers is to write your code and docs with the reader in mind, and be sure to document your _intent_.
And I don't do those, so no problem for me. Semicolons or not. But hey, if you do those, use semicolons! Nobody is stopping you. 
Now that I've seen your code, try this version: https://jsfiddle.net/Lanlost/6n6027s0/ updated this based off what I saw on another thread of yours: https://jsfiddle.net/Lanlost/6n6027s0/1/
Thanks for the feedback! We are going to open source it soon, so there will be a good venue for feedback. 1) I will look into this. I haven't looked into frame security too much, but t seems like a combination of using the X-Frame-Options = SAMEORIGIN header and document.domain on the embedded &lt;iframe&gt; would mitigate this? 2) Yeah I already ran into that, should have a fix today Glad you like it!
It also protects you against something like this: foo(bar) (function() { }()) Which is parsed as foo(bar)(function() {}()) Which will almost certainly do the wrong thing. But people who don't use semi colons don't write IIFEs like that, and there's linters to check for those cases, so, in practice, it's rarely felt.
 function aiMove() { alert('Nah.'); return false; };
The more popular javascript is, the more influence it'll pick up from other languages. I don't think it's healthy to disregard the entire "no semi" movement as just rubyists. There are several languages, including most functional ones, which don't use them. If you want java though, just use GWT or Dart. Maybe even Typescript.
I would assume anyone caring about codestyle would use something like ESLint. So why wouldn't such a library be a joke?
There's also linters that check for issues common without using semi-colons, like in [standard](https://github.com/feross/standard) (though this is not regarded highly in this sub).
Yes, that's what I meant by: &gt; Likewise for an expression wrapped in parentheses instead of what looks like an array literal. It tries to call the result of the expression on the previous line. But I may have worded it better.
Lol! Thanks!!
You can put return true outside the else, even cleaner code 
Thanks for the link, i'll have to dig more into this.
There is an option to override that. Search for `methodchain`.
:D
I'll take a look, thanks!
Shhhh don't insult the hivemind. 
I'm only familiar with nw.js (an alternative to Electron), but I can help you with the Node portion. In short all Node does is let you use JavaScript outside of a browser. Use the [Node Package Manager](https://www.npmjs.com/) to search for libraries to accomplish your task. Typically installing a library is just typing in "npm i [library name]" then using a require statement in your code; consult the documentation for specifics. I know with NW.js I had to require a Window library to close the window from a menu, so you may have to do something similar with Electron. What project are yo working on? With more information I can recommend some libraries for you to look at.
Semi-free master race! I really do feel bad for people who get bugs due to omitted semi colons. So sad.
Inspired by the idea of https://www.reddit.com/r/dataisbeautiful/comments/40um8s/an_analysis_of_powerball_winning_numbers_since/ I decided create a number generator using basic statistics to do so. i come from using Java which is very similar so the code is very basic. I will edit this later with the source code 
This has been the case for objects since ES5 and has always been the case for class. I guess this tweet is a JSC bug fix. A long while ago I made this gist demonstrating an underhanded usage of this: class A { if (defineBar) { bar =&gt; { } } while(needsMoreMethods) { // add more methods } } 
They apparently don't know about prototype.
Here is a video showing that the spamming is not necessary. It DOES spam the third button until the success message comes up but the other two aren't necessary. The buttons are only active at specific times so instead of spamming non-existent buttons it 'spams' the checks for them continuously and then clicks them once they appear in the correct state.. https://www.youtube.com/watch?v=SewkU5xhPEA There are three versions of the code... [This optimized one that you see in the video...](https://jsfiddle.net/Lanlost/6n6027s0/1/) [Original Demo 2](https://jsfiddle.net/Lanlost/eud22L71/) that does AAAA,BBBB,CCCC [Original Demo 1](https://jsfiddle.net/Lanlost/9d7a1yyg/1/) that does ABABABA,CCCC Surely you can adopt what you need from those. The best one though is the first one since it runs on the site and everything and if you really need it to spam the A button for some reason you can simply modify the code in the first example to use an interval instead of a single timeout. I'm not sure how you're planning on running this anyway. Is this your server? If not you'll need to make this into a javascript bookmarklet OR grease monkey script for people or whatever. Like I said before, if you have any questions let me know.
If you use TypeScript then it's even 99.9999% a none issue.
You mean the javascript library that is not quite 1 year older than jQuery? 
As a front end developer who recently started at a place where Rails runs the back and it leaks up front, keep fighting good fight. Thanks. While I'm at it I'd like to hate on snake case. 
Semicolons, the new Spaces vs Tab. 
The good news, I guess, is that the JS ecosystem is so perfect that we have nothing more productive to debate or argue over than semicolons. I bet the other language communities are jealous.
Thank you, I am not too familiar with XHR actually. But I think what I meant by "disregarding page events" is "persisting". Whenever the audio is being played in 1 page, it should persist being played even if the user goes from one page to another. What is your advice into handling persistent JS data?
This was posted over in /r/reactjs, so I will share the same thing I shared there for others: https://auth0.com/docs/quickstart/spa/angular2/relay Nothing prevents you from using Relay and GraphQL with Angular2. 
RSA is probably the way to go, but WSSE might be an option as well: http://symfony.com/doc/current/cookbook/security/custom_authentication_provider.html Note: the above article shows how to implement it using symfony so the server-side parts are php.
I think you are missing the context of this plugin.
[minimax](http://neverstopbuilding.com/minimax) is the algorithm you are looking for. Let me know if you have any questions. I have implemented this in JavaScript. (The article is in Ruby)
Jesus, this sub is full of toxic users. You're being downvoted for being right, all because it goes against there [logical fallacy](https://yourlogicalfallacyis.com/slippery-slope).
Hi /u/withcheesepls, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
Oh. Sorry I just glimpse at the guidelines. Thanks. 
I've been working with electron for a bit now, feel free to ping me if you want me to walk you through setting up an app.
I learned to use semicolons in the late 90s when I first started with JavaScript. Just in the past year or so I've heard all this jive about not using semicolons. Well, I'll still be using them. It's a good habit to use them, in my opinion. Especially since I also develop in PHP, where semicolon line terminators are required. Also, it makes it just that much easier to read your own code, or someone else's code.
There are only 2 times that not using semicolons can possibly effect anything. When a line starts with a `(` and when a line starts with a `[`. And both of them can be solved by prepending a semicolon in front of them. So the above commenters code would work like this: function foo() { let check = doCheck() ;(check ? doSomething() : doSomethingElse()) }
Considering that there are only 2 cases that bugs can crop up! I too find it silly that people act like they can't possibly handle it. If you really can't handle the small formatting change of no semicolons, you probably are pretty set in stone in other ways too and i'd rather not have someone incapable of change on my team.
I love that you are getting upvoted here only because people don't think you are being ironic. I'm sorry that pointing this out will bring the downvotes!
And the best part is that Babel isn't magic... It's using the same rules to automatically insert semicolons as the JS engine is. So literally anything that would trip up a JS engine would also trip up babel!
ok, op shouldnt have a problem if using `react-native`. i hadn't considered that (facepalm). thanks for the link. i'll definitely check that out i need to do some react-animation
So are we gonna have to rewrite it at the top of every file we want to use the library in? Very un-meteor like, but worth it I guess.
 function makeWords(word) { var letters = "abcdefghijklmnopqrstuvwxyz"; var i = letters.indexOf(word.substr(word.length - 1)); while (i &gt;= 0) { i--; alert(word.slice(0, -1) + letters[i]); } } This is completely untested, but should give you the gist of how it should work.
Check out the 'file system' API in Node.
I upvoted both of you guys. *Coding JS semicolon-free since '15.*
Thanks, any chance you could explain the basics of how it works?
The Alphabet var letters = "abcdefghijklmnopqrstuvwxyz"; This is grabbing the index of the last letter of the word passed into the method, from the letters string. IE: word = sofa, i = 0; (It is a 0 indexed string, where the first letter is index 0); var i = letters.indexOf(word.substr(word.length - 1)); This is basically looping backwards through the alphabet replacing the last letter of the original word while (i &gt;= 0) { i--; alert(word.slice(0, -1) + letters[i]); } 
React can go die in a hole
Am I missing something?
when you click "click here to translate" the h2 and the table should pop up but it doesnt. pretty sure I have followed the instructors directions exactly unless I'm missing a symbol somewhere.
https://github.com/isaacs/semicolons/blob/master/semicolons.js Not sure if serious lmao
I like the idea of "one style to rule 'em all", but it should've appeared ages ago, together with jslint, like Go that came to life and there was already a style enforced by the language itself. It is now too spread to try to enforce a style, but it's good for people who's starting to learn. I use eslint since jshint doesn't go well with jsx.
You misspelled `innerHTML` - capitalization is important.
Check out codingame
Sorry for the delay! Your comment got buried a bit. We have our own implementations of concepts like unique or shared pointers, and we use them sometimes. If the object lifetime is highly localized there's no need for the extra object allocations which can individually subtlely hurt performance, but which adds up to a lot if you do it everywhere. Also, part of the engine is a Garbage Collector for Javascript Objects, and so explicitly managing memory through standardized C++ constructs doesn't really apply in that scenario. We rely on the GC to properly collect objects allocated on the GC heap and we use vanilla pointers for those objects. Also some of the code was written years ago and hasn't been modified since so it hasn't been brought up to a modern style (C++11, C++14, modern standard library additions). We try our best to incorporate new useful features (nullptr, lambdas) as much as possible and where applicable. Sometimes we didn't use the standard library because at the time the code was written, the Microsoft equivalent library was better. (And so on...) Every so often we go through active areas of the code base and update things. Feel free to submit pull requests if you think you found a place we'd benefit from such changes (in terms of performance or memory leaks). If you think you've found a security issue, please responsibly disclose by reporting it as indicated in the [Security](https://github.com/Microsoft/ChakraCore#security) section of our README, instead of in a public issue or pull request, so that we can mitigate widespread impact of the issue. There are several active conversations in the [issues](https://github.com/Microsoft/ChakraCore/issues) and [Gitter](https://gitter.im/Microsoft/ChakraCore) on style related issues such as this. TL;DR: Generally we consider things like this and make a deliberate decision. Sometimes we miss things, and for that we welcome pull requests.
It's pretty much that. If your long running operation can be put in a web worker that's another option. Just know that breaking up the operation into chunks will make it take longer in the end, but keeping the UI responsive is almost always worth it.
We hope to contribute to the Node development experience. By having our engine as an option we can address issues as they specifically apply to our engine and contribute back to node or make any necessary modifications to our engine. What scenarios are currently difficult for you? Maybe we can help. :)
By the way, you can reply to individual comments rather than to the whole post. When you do so that person will be notified so that they can come and continue the conversation.
&gt; as they specifically apply to our engine Not the engine, specifically the operating system -- Windows. Sorry if I did not make that clear. 
Web workers, compartmentalize the problem and find an async solution, or get the process to run on the server ahead of time. EDIT: The last thing you want to do is make the user wait for something to process. I highly recommend re-analyzing the situation and finding an async solution. It'll improve ux and code performance. EDIT THE SECOND: After looking at one of the comments on SO, you could probably get away with web workers. Send the web worker THREE.js and your data, get back the colored whateveritis. But why is it that you need to do this much all at once? Can you not do it sequentially (eg. Update 20 polygons at a time)? How the hell does the scene not lag with this many objects being rendered anyway? 
This
Thanks for the feedback. It's not my code, and I agree it stinks. The guy who wrote it got really pissy whenever someone mentioned his code being messy. He's gone now. I might tidy it up eventually.
All your points are legit if and only if your repo has a .eslintrc/.jshintrc/.jslintrc file to back your words;
&gt; Is it frowned upon to roll out the front end of an application without using a framework if you can build out an MVC style app without the use of the framework? It depends on what you are looking for. If you are already in senior or lead position then just do what the fuck you want. You are more likely to get hired (and at a higher rate) than most other developers. I suspect, if you actually have to ask this, that you are not in senior or lead position. If that is so then you **have to** play the framework game. The job market is more competitive for you and your chances of making independent decisions about how things should work are substantially reduced. You will most likely be interviewed by people who aren't rockstars and put on a team that is average. You are absolutely going to **need** a framework because average developers are not willing or generally capable of accepting the risks of making their own decisions when it puts their jobs on the line. I am sure this may sound elitist and harsh, but the reality is that there is a substantial talent gap in the market. Most companies just need to put bodies in chairs and occasionally tell em they just doing great like how adults talk to children in kindergarten. Top tier developers are more rare, and companies still have products that need to be produced and shipped. They can't afford to wait around for that magic candidate come running through the door. Personally, I chose to never play the framework game. I lost some job opportunities as a result. By not playing the game I have been allowed greater autonomous at work and free to make independent decisions that allowed me to grow into a more confident developer. My background is really atypical though. I started working as a developer for big corporations more than 8 years ago, and in that time I have been deployed by the military to Afghanistan twice. Over there the personal internet that you can buy from the civilians sucks. I have always been into open source and writing my own convenience tools for personal use and productivity. If I were reliant on massive frameworks to do everything I would spend more time downloading that bullshit than writing code. Over there you have **an unbelievable amount of time to write code**. You just learn to solve those problems (the stupid convenience things provided by frameworks) on your own so you can more easily move on to the real issues. Having a part time job in the military also means I can absolutely screw up this corporate career and still have steady employment doing cool stuff in the military. What that really means is that I can make decisions about what I really want to develop with less risk that I will be completely unemployed. It also means I can challenge trendy bullshit with honest opinions with less fear of repercussions. Fortunately, I have a really awesome employer right now that fosters all kinds of growth.
Would you stop already with your completely ignorant spamming of posts? https://i.imgur.com/zP91RAk.png 1) It's too many posts in parallel. Two or max three would be acceptable. 2) The posts need to mention the parallel posts so people are informed of the discussion and also don't invest unnecessary effort. 3) You are doing this ALL. THE. TIME! Also, you phrased this one sloppily, it's not clear what you really want.
&gt; Why programmers hate JavaScript? It isn't Java. They probably learned Java or C# in a school and so their precious little minds that is how programming should work. * JavaScript does not have real classes and everybody knows you can't do anything without classes extending each other. * Inheritance is not forced upon you like a holocaust camp. * Scope in JavaScript is like magic pixie dust compared to Java, which is simply too complicated to understand and so should not be written by humans. * Nested functions and any kind of structured logic must look like a flood of incompetence coming from Java when real code should be flat and clearly evidence through a convoluted call stack. * clearly JavaScript is just a toy language, because real computer science comes from Java (I still actually hear this).
I don't know if it's toxicity, but there's definitely stronger opinions about semi colons than I've seen about almost anything else on r/javascript. I just wish more people would just come out and say "I want to use semi-colons and prefer everyone else to" instead of some excuse like "not using them will cause tons of bugs!" as though we only discovered you can not use them in javascript yesterday or something. At least then we could have a frank and honest conversation about style, instead of this weird proxy conversation about bugs and ASI.
I've submitted the following for the challenge. No extra lines added to the initial HTML or CSS tabs, just the following ~~57~~31 lines of JavaScript. The O player is played by AI, which will first look for a winning move otherwise looks for an X winning block otherwise randomly picks an empty cell. 57 line solution: http://codepen.io/between2spaces/full/dGVZPL/ UPDATE: I've found a better way to arrange things to make a 31 line solution. 31 line solution: http://codepen.io/between2spaces/full/pgWQwp/ (function(){ var who="X", message="" for (var nodes = document.getElementsByClassName("cell"), cells=[], i = nodes.length; i--;) { var cell = nodes.item(i) cells.unshift(cell) cell.addEventListener("click", function(event) { click(event.target) }) } function click(cell){ if ("" !== message || "" !== cell.textContent) return document.body.innerHTML += '&lt;div style="color:green;font-size:62px"&gt;' + message + "&lt;/div&gt;" if (cell.textContent = who, score(who)) return message = who + " wins!", click() var unused=[] cells.forEach(function(cell) { "" === cell.textContent &amp;&amp; unused.push(cell) }) if (0 === unused.length) return message = "It's a draw", click() ;(who = "X" === who ? "O" : "X", "O" === who) &amp;&amp; click(ai("O", unused) || ai("X", unused) || unused[~~(Math.random() * unused.length)]) } function ai(who, unused) { for (i = unused.length; i--;) { var cell = unused[i] cell.textContent = who var win = score(who) cell.textContent = "" if (win) return cell } } function score(who) { return line(who,0,1,2) || line(who,3,4,5) || line(who,6,7,8) || line(who,0,3,6) || line(who,1,4,7) || line(who,2,5,8) || line(who,0,4,8) || line(who,2,4,6) } function line(who, a, b, c) { if (cells[a].textContent === who &amp;&amp; cells[b].textContent === who &amp;&amp; cells[c].textContent === who) return [cells[a], cells[b], cells[c]] } })()
The problem with these lists is -- they are always awesome at the beginning but as the links get old/outdated/broken/... it becomes increasingly hard from the list to tell which links are still of high interest and quality. I would suggest, as minimum, to add the date when the link was last updated next to the link, as immediate help to decide whether clicking there is worth it, especially with a long list can be of great help.
They aren't navigating to a new page. They are replacing content on the page, and changing the url in the address bar. That's how they achieve it. 
&gt; But, as it turns out, it’s quite easy to prefix those lines with semicolons if you don’t mean them to be continuations of the previous line. For example, instead of this: foo(); [1,2,3].forEach(bar); &gt; you could do this: foo() ;[1,2,3].forEach(bar) &gt; The advantage is that the prefixes are easier to notice, once you are accustomed to never seeing lines starting with ( or [ without semis. What. Who in their right mind looks at the second and considers it good style?
I agree with you, but keep in mind that these kind of module are so small that they rarelly need to be patched, once they are used by many people and battle-tested. One other problem could be that NPM small modules are really a lot. The list could possibly become to big to be useful. See [this discussion on github](https://github.com/sindresorhus/module-requests/issues/56)
I think, at least traditionally, most people don't keep build artifacts in source control (which is what these minified versions are). If you have the code, your tooling will be able to build those files for you on demand (to minimize, remove comments, etc... whatever you designed your process to do), so why keep a copy around?
Yes, but very low depending on the system environment. e.g. number of CPU cores, CPU speed, network bandwidth, network latency, file system performance, etc. - both client and server sides. If they're not cached or loaded for the first time from a cache, the process will requires more I/O tasks. When they're loaded from cache, the process will requires more lookups to resource objects.
There are a bunch of demos on the website: https://ghinda.net/jotted/
It sort of depends. In general, no, you don't want to commit build artifacts, for a variety of technical and philosophical reasons. As you note, there are drawbacks to not doing so, but I think they can usually be addressed. However, it does depend on what exactly you're doing. But a common pattern (as implemented in npm) would be: 1. Put original source files in git 2. Add whatever tools are needed to build the files in your `devDependencies`, and add build scripts to your `prepublish` hook. 3. When you publish to npm, your prepublish hook runs, builds your files, and uploads a tarball of your minified files for people to download. 4. When people install the package, or install a package which depends on your package, they get the prebuilt minified files 5. WHen someone clones your repo, they get the raw source files, and if they run `npm install` they'll get the tools they need to rebuild them if they edit them too. Note that all the above applies even if you aren't using the npm public registry, or aren't even using npm. When you want to publish a release, do all the "publish" steps, and create a tarball or docker file or VM image or a .deb file or whatever it is you need. If you don't want to publish a release, then you're consuming this in a dev environment, and you can certainly build or minify the scripts on demand. &gt; And what about if you want to have a cdn link to your minified library? How can you manage that if you take them out of your repository. Don't point the CDN directly at your repo then; in many cases that would be impossible or inadvisable anyhow. If all else fails get an AWS S3 account, setup a bucket, upload the file, and point the CDN at that, but really, putting files on the internet is a pretty solved problem these days. :) In short: I think you're making this too hard, but it may help if you define exactly what your problem is. Not vague stuff "people need access to the files", but specific stuff like "but when people do npm install myPackage, they aren't getting minified copies of the files, do I have something configured wrong?" (answer: yes). Or if you're having a problem with a CDN, which CDN is it, what are you doing, and how is it failing? Etc.
Github is for programmers and programmers know how to minify files. Really, you should not put files under version control which are automatically generated, the conflicts etc. are a really big pain. Mostly, when you have automated deployment, the files will be generated by your auto deployment tool.