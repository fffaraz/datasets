Cool, I'm not super familiar with react. At the very least I can say its not a whole application framework and you'll want other parts, whether that's Flux or more traditional MC* parts.
haha. I only realised because of your comment that the compass itself (rather than the needle) is oriented northwest, so there's that.
I use JSHint because I didn't need anything from ESLint that JSHint didn't already give me. I am definitely going to check it out as soon as I will use ES6 in a project. I also use [JSCS](http://jscs.info/) for code style validation.
I develop a point cloud renderer using three.js that others use in production. Here is a showcase: http://potree.org/wp/demo/ And source code is here: https://github.com/potree/potree I started a few years ago and switching to three.js was the best decision ever. I can concentrate on getting stuff done now, instead of reeinventing the wheel again and again. Besides, three.js is a well written and well tested library. 
I can't disagree with you! I've been thinking about develop a new view to use flux architecture with Backbone (and Backbone Dispatcher). Would you say it's a good reading material to help me with: https://medium.com/react-tutorials/react-state-14a6d4f736f5 ? Would you recomend some other material ? Thanks !
I'd say stay away from anything DOM and do the basics. I agree that functions are the probably the best thing to cover because they will be able to relate it to any math classes they've taken already
Shit, took me way to long to realize that, and I've used a compass a few times in my life. 
first learn javascript then worry about a framework there are a few things that confuse people coming from a C/Java type of language after you know JS go with Angular
Just a critique on two small points: "Slide 7 -Closures" shows code in which a variable in the global scope is accessed. There doesn't seem to be a closure in there. The introduction refers to "lambdas and closures", you then talk about "first-class functions and closures" with almost no mention of lambdas at all (just in passing it is said that "lambdas = function literals"), and in the wrap-up you mention "lambdas and first class functions". There seems to be some implication about there being 3 different things (lambdas, first-class functions, closures) but with some confusion about which is what. I understand these are just the slides for an accompanying talk, but imho the confusion will probably make the structure of the talk confusing in this regard.
Since you know python, Django or Flask could be a good choice for the back end of your stack. On the front end, i'd start with html and css, then move on to javascript and probably jquery before moving on to frameworks, etc.
It's possible that there was some sort of drive to port old legacy COBOL code to more modern languages.
Yea...but I got a 2mb email newletter the other day. I say don't prematurely decide what people are willing to download, let them decide if its too big. Sure if you have the skills to write in in cocoa or something, go for it, but if your option is a 70mb app or no app...its an easy choice for me.
You can only play a single piece of audio at a time. You cannot play audio without direct physical interaction from the user. You also cannot preload the audio using HTML5 audio. However, you can use XHRs to download the audio data into memory and then use the Web Audio API to schedule audio playback of that data. And because that data is already in memory, there should be virtually no delay between user interaction (click, touch, etc) and audio playback.
When you set an element's `innerHTML` property, this tells the browser to throw away all the existing nodes within that element. In this case, you're destroying everything inside the body tag. Then, you're building an entirely new HTML structure with brand new nodes based on the value you're assigning to `innerHTML`, forcing the browser to re-parse the entire body's content. Hence, why I called it destructive. So, let's say you had a button on the page with a click event bound to it. That button (along with everything else on the page) would be replaced with a new button. Any events you had bound to the original button would then be lost along with the original button element. The correct thing to do would, as you said, be to recursively go through every node in the document. Then when you find a text node, replace any instances of a custom entity within it. An additional complication here is that the browser doesn't only parse HTML entities in text content. HTML entities can be used to populate any number of properties of elements - href's on anchor tags, value's on input tags, etc... It's definitely not simple to account for all these different use cases. Here's a quick example that only handles text nodes: function textReplace(node, needle, replacement){ if(node.nodeName == 'SCRIPT') return; // don't mess with script tags if(node.nodeType == 3) // if node type is text, do a replacement node.nodeValue = node.nodeValue.replace(needle, replacement); for(var i = node.childNodes.length; i--;) // loop through all child nodes textReplace(node.childNodes[i], needle, replacement); // call recursively }; textReplace(document.body, /foo/g, 'bar'); // call starting at the body I also have some issue with your use of the `onload` event. This event fires off pretty late in terms of the page loading timeline. Your HTML entities would not be replaced until every resource on the page finished loading, such as images. The result would be that the user would see the entities getting replaced on the page. It would probably be better to wait for the DOM ready event (using onreadystatechange/ondomcontentloaded events) instead, as this would fire as soon as the browser finished parsing the page's HTML.
there is also [tint2](http://www.trueinteractions.com/tint2) which i am the most interested in :D
I realized I know 5 of the top 7 programming languages...this explains why I am harassed on linkedin. 
Thanks for responding. Sorry, I should have made this clearer in my post, but the delay is not from a click to the sound plays. The delay is when the sounds are all playing (after the click). Would XHRs still help with this?
/r/humblebrag
You sound like you have a good grip on programming in general, so you won't need much extra there. You have two major things to learn: the Javascript programming language in particular, and then the browser's execution environment (known as the 'DOM'). Naturally you'd want to get a good grasp of Javascript first. Your target will be the browser so you should learn how to handle the Chrome/Safari/Firefox developer tools: in the you'll find a REPL, a graphical representation of the current state of the DOM and a debugger. Indispensable for experimentation, both with the language and the execution environment. After getting at least a bit comfortable with Javascript, I'd look at doing experiments with the DOM and how to style a simple web page using CSS before looking at a particular framework. That way you'll be more comfortable when you start to actually look at frameworks. When you feel comfortable, I recommend Henrik Joreteg's "Opinionated rundown of JS frameworks" to get a quick grip about the different front-end frameworks that are out there: http://blog.andyet.com/2014/08/13/opinionated-rundown-of-js-frameworks
It's kind of neat to notice the falloff of Objective-C in 2014, since Apple announced Swift to replace it. Also I wonder if the spike up for Java came as a result of Java 8 catching on. 
I would recommend focusing on learning the frontend stack of HTML/CSS/JS at a basic level first. basic doesn't mean shallow though, i just mean learn them straight up rather than learning a technology that adds additional layers of abstraction to the frontend stack. learn html, css, and javascript in depth first. after that I highly recommend, at minimum, learning Boostrap, jQuery, and a frontend MVC framework of your choice (Meteor, Angular, Backbone, etc.). while you're learning a frontend framework you should re-familiarize yourself with the concepts behind asynchronous network requests and RESTful architecture. this means getting to know the ins and outs of HTTP as well, since that is the bridge that connects the frontend with the backend. 
Yep correct :)
wow
Woot
It's not like you just use one or the other... 
the arrow on the compass should be pointing to NW instead of NE
This is amazing. I've already sent this to my QA team. 
If you're starting with JavaScript. I recommend you to read these books: https://github.com/getify/You-Dont-Know-JS
I've written programs in all of the top 10 -- but I wont admit to knowing a couple of those languages anymore **cough**Perl**cough**PL-SQL**cough** And Visual Basic.Net can't die fast enough.
yeah all that ui fluff. Ok. But the meat is the back end: rdbm systems, application servers, domain models, rules engines, message queues, transaction processing, comms, dev ops, instrumentation, orm's, protocols, concurrency ... 
before looking at your code.... it's using html2canvas and then converting canvas to an image at X frames per second. **edit:** Yep I was close (but of course there's much more than that). This really nice by the way! 
I wish I'd seen this sooner. [Cornify.js]( http://www.cornify.com/) is my go to for basics. 
I guess I misc too much, thanks for the help. I'll check out that book
I wish it would.... It's not as bad a I thought it would be with the whole code behind model, but I like having more control over my routing versus using the web.config file. 
Your barista will spend 3 weeks preparing your punch cards, but boy will it be lovingly made and tasty. name spelled incorrectly though; that never changes.
did you try pasting the code in the console to see if that would work? https://github.com/yaronn/GifW00t/blob/master/README.md#2-you-surf-in-a-site-that-does-not-embedd-gifw00t
Ah I see. I just tried it and it works on this page using Chrome on Windows. I didn't try recording anything but the controls showed up.
Good luck :)
It's not working for me http://i.imgur.com/K7y8orO.png
About as fast as their ranking system is making a nosedive...
Thanks. This is a help. 
Great to know. You're not too late, I over talked another part of the course so they're not quite ready for JS. This is a big help. Thanks. 
It's a mix. I'm still learning the differences...so bear with me....I think it's actually webforms. 
You can definitely do that. When you open a window through JS, you can access the parent window through window.parent. https://developer.mozilla.org/en-US/docs/Web/API/Window.parent From experience there are restrictions to what you can do from the child to the parent, but you can get around them by creating functions on the parent window and calling them from the child: In the parent: window.someFn() { do stuff in parent; } In the child: window.parent.someFn(); 
I just sent this to my little baby intern, who's been struggling to figure regexes out. The automagic train diagrams are perfect! Now if only this had pluggable regex engines, so it could be used to visualise the regexes relevant to a particular environment. Unfortunately, my office is all .NET . . . :-/
The right part is evaluated first and passed in before you overwrite the list variable. After the first iteration it evaluates to list = { value: 3, rest: null } After the second pass it becomes list = { value: 2, rest: { value: 3, rest : null } } After the third and final pass it becomes list = { value: 1, rest: { value: 2, rest: { value: 3, rest: null } } } The array is basically built "from the inside out".
Fantastic, this is what I thought was happening but my brain just wasn't sure.
&gt; Any choice of third-party libraries must be standalone and not dependent on another library (although there is a difference between “plays nicely with” to “this requires the use of”). Bleh... Fear of dependencies is a horrible practice that can be mostly attributed to shitty package managers (i.e. bower). I would take the opposite approach. Don't trust a library that eschews dependencies and tries to copy/paste everything under a single hood.
It lists 4 different promises libraries and none of them are bluebird? Bluebird has plenty of features and [the best performanace](https://github.com/petkaantonov/bluebird/tree/master/benchmark).
It doesn't record the image on the screen like taking a screenshot. It looks at the DOM and records it at time intervals depending on the settings. In order to record the mouse, the library would have to constantly check for the cursor position. It probably wouldn't be too hard to implement into the library.
Cool. I use this one: http://www.regexr.com/
Nice. Yeah, by production I just meant doing stuff other than demos for fun type of stuff. Interested to hear what people's experience is and what tools they're using.
Nice. Thanks for the link!
Hey, Web Tracing Framework looks awesome! I'll have to check that out. You do some interesting work. So you don't use THREE.js? Doesn't Google "sponsor" or "back" the THREE.js project? One of the execs at famo.us (I did some contract work there) was explaining this to me. What made you decide NOT to use THREE.js (and maybe become commit on that project)?
I have actually done this. I stopped around the time when everything started going responsive and JS frameworks started appearing. However, I'm not starting with the most current (React) as it scares me. I feel I need to learn Backbone first and then I will feel a little more comfortable to eventually look into React. Also there's so much new stuff in front-end that I've missed. Sure some things won't require much time to learn (Sass, Gulp, Browserify, Vagrant, etc) but I just think any long period away from this industry is not a good idea.
Wait, where is Erlang, Haskell, Go? Oh, bottom 50. But Rust is up there, oh, not on the list.
Use Django.
WHOA!!!!! well, unless it includes iframes or flash or is on a phone or 2015 &lt; is &lt; 2016. and as long as the user isn't zoomed in or is using user accessibility tools or has a slow computer or moves the mouse outside the window or closes the lid on their laptop and the site hasnt changed between their recording time and the time they want to do a playback and they actually want to playback which no one ever ever EVER would. 
What do you recommend instead of bower? It's already annoyed me a few times.
npm is solid, but encourages a bit of a [different style](http://maxogden.com/nested-dependencies.html). For example, isolated modules and pure functions are preferred over singletons and plugin-based frameworks (e.g. jQuery). I still tend to use Bower for some non-code assets (like FontAwesome, normalize.css, etc). 
Using Firefox Nightly on tablet and Firefox on mobile: The only thing I saw that was weird was that you can zoom out and it gets a little weird (CSS problem) and the bottom bar is slightly cut off (CSS yet again...) The content loaded and responded well though. What browser are you on? BTW OP: Nice.
Seems like the bottom row should be flipped over, so all the innies are on the left and bottom, and outies are on the right and top. Each piece can then go in only two ways -- just flip it over, no rotations. Is there a non-brute-force solution?
Google Maps has to run on anything from low-end netbooks to beefy desktops with 4k monitors - using three.js or any other WebGL wrapper would add additional overhead that we can't afford. Since we're rendering an extremely limited set of basic primitives (roads, areas, labels, buildings), we gain a lot of performance by writing directly to WebGL and building shaders and buffers optimized for those particular cases.
Just wondering, what's your issue with bower?
Let's compare Apples and Oranges to a Fruit Processing Factory.
It's easy. I'm not going to use official terminology in an effort to explain it a bit easier. `this` depends on the way you call the function. If you call a function directly, without specifying who it *belongs* to, it will be in the global scope: myFunc() /* global (probably, keep reading) */ If you specify the object to which it belongs **in the call**, `this` will be set to that object a.myFunc() /* this == a */ OR you can force *this* to be a fixed value using call/apply myFunc.apply(a, [argOne, argTwo]) /* this == a */ So when you do `myFunc.bind(a)` it creates a new function that remembers `a` (captures with a closure) and uses apply later on so: myFunc.bind(a) could be seen as myFunc = function() { myFunc.apply(a, [argOne, argTwo]) } **Don't be fooled into thinking it's set by the way you reference it!!** setTimeout(a.myFunc, 500) /* this = global */ because imagine setTimeout is something like this: function setTimeout(aFunc, aTime) { /* wait aTime */ aFunc() // &lt;--- note no owning object } It's the way you *call* it 
Haven't tried it yet, but http://duojs.org sounds pretty cool
I can't make it accept lookahead, like this: (?=\.?\d)\d*(\.\d*)? (This is a pattern to recognize a floating point number, without exponentiation) Also, I'm forced to use `(PAT)` instead of `(?:PAT)` 
I think while learning something you sometimes hit a block. Often the block can come due to many external reasons. But most commonly the block is there because you have left a critical part of learning the concept which you might have put aside thinking wrongly that you can get to it later. In your case maybe you have missed some important part in understanding how functions work or something else. Learning is like constructing a building, with weak foundations you can build something. But it can fall anytime and you can easily see the cracks. Better revisit the foundation and make sure your foundation is strong.
When I first saw *this* I though it was bullshit and didn't understand it at all. I just left it and the next time I looked at it much later it made sense straight away.
I'm not saying you should never look at jQuery or that it's totally bad. It has some really nice ideas. However, saying you're going to teach someone Javascript and then teaching them jQuery is disingenuous. Firstly, knowing jQuery doesn't particularly make learning JavaScript any easier, whereas knowing JS will make learning jQuery easier. jQuery also makes it easy, maybe even promotes, writing bad and unperformant code. Teaching jQuery as lesson one also reinforces the idea that (cross browser compatible) javascript is hard. It really isn't anymore. There's no need to be including this large library when you're really just writing javascript with a different (perhaps easier) syntax. 
Thanks! It does look pretty good. I'll give it a try.
This was exactly my problem. Read what I wrote below to see what worked and why it makes no sense that it does according to what I understand.
If you use this.somemethod alone it can't be found because this references the global object within setInterval. It stands to reason that this.somemethod.anything couldn't be found as well because there is no somemethod off the global object.
Every time you try to do a build with clean bower install, some of the dependency of the dependency of the dependency repos is broken.
I'm really struggling to find the best practices for building these isomorphic apps, specifically related to data structures. I'll definitely go over the source code! I'd like to share my views on this whole 'isomorphic app' thing. Isomorphism implies a *flat* structure. The word *two* is inherent within the definition of isomophism: &gt; In mathematics, an isomorphism (from the Greek: ἴσος isos "equal", and μορφή morphe "shape") is a homomorphism (or more generally a morphism) that admits an inverse. **Two** mathematical objects are isomorphic if an isomorphism exists between them. An automorphism is an isomorphism whose source and target coincide. The interest of isomorphisms lies in the fact that **two** isomorphic objects cannot be distinguished by using only the properties used to define morphisms; thus isomorphic objects may be considered the same as long as one considers only these properties and their consequences. - [source](https://en.wikipedia.org/wiki/Isomorphism) I emphasize the word **two** because that's why I call it *flat -- it's a two-dimensional structure*. I'm trying to propagate a different meme (buzz word), more relevant towards forming a vision of the concept we're trying to express. &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;*Holographic apps*&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; Holography is a technique that enables a light field, which is generally the product of a light source scattered off objects, to be recorded and later reconstructed when the original light field is no longer present, due to the absence of the original objects. Holography can be thought of as somewhat similar to sound recording, whereby a sound field created by vibrating matter like musical instruments or vocal cords, is encoded in such a way that it can be reproduced later, without the presence of the original vibrating matter. - [source](https://en.wikipedia.org/wiki/Holography#How_holography_works) I'd also recommend reading the intro for the [holographic principal](https://en.wikipedia.org/wiki/Holographic_principle). IMO the goal of building *holographic apps* is not to reuse code or optimization (which are awesome side affects), the goal is to: &gt; design applications in such a manner that it can be reproduced in the browser, without the presence of the original ~~vibrating matter~~ server/data. (while maintaining the integrity and continuity of the data structure) Data is first class in React. Data renders UI. If you have one blank template whose UI structure is 100% dependent on the data, and you'd like to reconstruct that template using a wide variety of data sources, (eg: server -&gt; firefox/safari/chrome/phonegap/mobile) - I think *holographic* is more descriptive word that sounds way cooler. Honestly - this rant is about my frustration with syncing data structures between server/client. How can we design API's that work *identical on the client AND the server*, in such a way that *the client uses local data as it's only source of truth??* 1) The API for accessing data on server to pre-render the app must be identical to the API for accessing local data on the client. The internals must also distinguish between environments and act accordingly to handle server vs. client (including browser differences). 2) Syncing data should happen behind the scenes (webworker?) and have completely separation from the UI in 90% of use cases. Two exceptions I can think of are login and merge conflicts (like in git) where the user should have the option of choosing local vs. server if there happens to be a conflict I'll end with this quote below, because I'm struggling to implement it's practicality: &gt; A holograph is a document written entirely in the handwriting of the person whose signature it bears. - [source](https://en.wikipedia.org/wiki/Holograph) If you replace the word *document* with *data-structure*, and the word *signature* with a *crypto-hash*, it takes on a very different meaning: &gt; *A holograph is an encrypted data-structure using the hash of the person whose key-signature it bears.* As above - so below. - *minor edits in syntax / language* 
Arguments have to be evaluated before the function is evluated. setInterval(this.somemethod.bind(this), 1); could be rewritten var method = this.somemethod.bind(this); setInterval(method, 1); bind could be rewritten as: var that = this; var method = function() { that.somemethod(); }; setInterval(method, 1); Hope that helps!
The "this" parameter you pass to `bind()` is retained via a closure and explicitly set as "this" when the function is later called, using `Function.prototype.apply()`. Here's an incomplete implementation of `bind()` which only covers what's pertinent to the bit you're trying to understand (the real `bind()` also does partial application): Function.prototype.bind = function(context) { // In your example, func will === somemethod var func = this return function() { // When setInterval calls this inner function, "this" will be undefined // if you're using strict mode, or the global variable if you're not. // (Protip: use strict mode!) // But that's moot, because we don't use "this" inside this function. // .apply() explicitly sets whatever argument we passed to .bind() as // "this" when calling the function we called .bind() on. func.apply(context, arguments) } }
 function call(fn) { fn() } var obj = { logThis() { return this } }; obj.logThis(); // this call(obj.logThis); // global object The best conceptual model IMO is to think of this as an implicit parameter you pass every time you call a function, keeping in mind that sometimes library code like setTimeout can sometimes be the one calling the function. Consider above: `obj.logThis()` calls the logThis function passing obj as the this parameter because when you get a function by using the dot that's what happens. The second case we pass obj.logThis to call. Note that we do not make the call at this point. The call function does via `fn()`. In this case there is no dot, so this defaults to the global object (or undefined in strict mode). Bind returns you a function that when called will always pass along the this value you give it regardless of how that function is called. 
Is it just me, or does this seem like Design Trends of 2013?
Sorry to have done this and i will keep this in mind, Thanks.
think if it this way: javascript uses function scope, so the runtime only knows what *this* is as long as you're in the current function scope. when you put it on a subsequent iteration of the event loop, the runtime won't know what *this* is, since you left the current function scope. hence, it defaults to the global object as didctated by the scope chain. *bind* fixes this by manipulating what *this* is when the runtime calls the function. another option would be to create a closure and passing in *this*, which would keep the scope chain in place. helpful stuff: http://vimeo.com/96425312
I like the cloth rendering. it works great on mobile. and it feels great too! (:
For that, you might need to have something like `&lt;input&gt;` field in your browser. &lt;html&gt; .... ..... &lt;body&gt; &lt;input id="myInput"&gt; &lt;script&gt; var input = document.getElementById("myInput").innerHTML; //do something with your input &lt;/script&gt; &lt;body&gt;
[Image](http://imgs.xkcd.com/comics/password_strength.png) **Title:** Password Strength **Title-text:** To anyone who understands information theory and security and is in an infuriating argument with someone who does not (possibly involving mixed case), I sincerely apologize. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=936#Explanation) **Stats:** This comic has been referenced 1044 times, representing 2.1799% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cnquzid)
They use slightly different way of working things out, so the results will vary. The open source version is actually a more up to date version than the current website, so the results will be different from those in your table for some of the results ("correcthorsebatterystaple" comes out as "cracked instantly" for example). Unfortunately I don't know enough about how zxcvbn works to comment on what the differences actually are.
Challenge accepted, started bio bruteforce attack... password
No, you don't really? How about this one: 11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 Pretty strong eh? 
Think I need to update the top 10,000 list. It's about three years old now.
I would add quick comment about using 'self' If you use web workers, 'self' is the word used to reference the web workers global scope (instead of window), so you need to use something like 'me' instead in those cases. JavaScript really does have a quirk for everything. 
hunter2 estimated at 14 minutes
My comment was made up, I have no idea how popular the password is. I actually suspect not that popular because so many sites use poor password rules. Probably not a bad idea to update the list, though:)
[Image](http://imgs.xkcd.com/comics/password_strength.png) **Title:** Password Strength **Title-text:** To anyone who understands information theory and security and is in an infuriating argument with someone who does not (possibly involving mixed case), I sincerely apologize. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=936#Explanation) **Stats:** This comic has been referenced 1046 times, representing 2.1830% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cnr0xql)
Nice meme bro
Strength is how likely it can be guessed. Given one million five-character passwords, a tiny subset of them are much more guessable than the rest and will be tried first, e.g. "7dx9_" is less likely to be guessed than "horse" so length isn't the only factor. [edit] for clarity
[A quintillion years!](http://xkcd.com/936/)
yes, the dom is converted to a canvas image (via html2canvas) and then all images to an animated gif. if you use a large frame rate and the DOM you record is large than it will be slow (single thread and all that).
The problem with your question is that it's fundamentally the wrong way to approach javascript programming - at least in the browser. The example code you've given is very procedural - you print something out to the screen, you wait for input from the keyboard, then you do something with that input. It's the way you do basic programming in the [console](http://en.wikipedia.org/wiki/Command-line_interface) (in languages like C, Java, etc), but it's completely the wrong approach for writing javascript in the browser (which is [event-driven](http://en.wikipedia.org/wiki/Event-driven_programming) rather than procedural. There's no real equivalent of STDIN or the comman-line in C, Java or similar languages, and no output-&gt;input-&gt;output-&gt;input cycle as you're imagining it. Instead you listen for *events* in the system ("page finished loading", "user hit a key", etc) and register chunks of code that run when the event you're listening for occurs. Instead of printing to the screen, waiting for input and then printing to the screen again, you do one of: 1\. Create a text-input field and a submit button, and register a javascript event-handler that is run then the user enters something into the input box and clicks "submit" - something [like this](http://jsfiddle.net/5p0d1nde/). 2\. Use a text-input field, but instead run your event-handler code every time the user changes the value of the field (eg, by pressing or releasing a key), but only output the value when they press enter at the end [like this](http://jsfiddle.net/5p0d1nde/1/). **Note**: This "pressing enter to submit a value you typed into a text field" is a pretty weird, non-standard way to enter information into a web page, so it's likely to confuse a lot of users. In general you'll want to use a submit button because it's what they expect, regardless of what you personally find quicker or more convenient (or, once you get a bit more advanced, change the code to process the input both on the enter-key *and* on a button-click). 3\. Allow the user to type whatever they like into the input field, and read the value when they tab away from it or click anywhere else on the page - [like this](http://jsfiddle.net/5p0d1nde/2/). This is commonly used for things like inline validation where the user's completing a form with multiple fields, since it allows you to check the value as soon as the user's *finished* entering it (no point in checking while they're still typing!), but also give feedback as soon as they've finished in case they made a mistake in the last thing they entered. 4\. Lastly, it is possible to allow users to type things straight on your web page (ie, not input field or anything similar), capture each individual keypress and try to reconstruct the message they typed - [example here](http://jsfiddle.net/5p0d1nde/4/). This is most similar to what you're asking for, but it's a weird, complicated, fiddly and deeply counter-intuitive method, so it's **almost certainly not what you want** outside of a few unusual and very specific edge-cases. For example the `KeyboardEvent` ([the type of variable](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent) that ends up being passed into the "event" variable in the example) only reliably reports which **key** was pressed - not which character that represents - so you have to inspect the event object and determine whether the shift key was pressed at the time (and keeping track of caps-lock, special characters like &amp; and £ and similar remaining problems are left as an exercise to the reader). This last option is mostly used for situations where you're controlling something on the web-page (eg, moving an object with the keyboard, playing a game, etc) rather than entering free-form text input, since it's easy to tell if key X was pressed, but much harder to tell whether you should be recording "x", "X" or even ^X (control+x), alt+x or numerous other possibilities.
I prefer to keep them separated under a different directory. That way it's easier to not include them in production code during the build process.
We have a strong *separation of concerns* principle when developing. Indeed, keeping the tests with the modules seems to be more modular, but we would have to remove them when deploying and in our point of view it is better to have a centralized place for them.
node [doesn't require an installation](https://github.com/joyent/node/issues/3978), the installer is just a convenience package. [Node binary .exe](http://nodejs.org/dist/latest/) Have [NPM](http://nodejs.org/dist/npm/) in the same directory and you're set.
Definitely keep them out of production code. It's best to put them in another file. Or if you have many tests, use separate scripts in another folder. Test runners can concat them all and run them together. I'm personally a fan of [tape](https://www.npmjs.com/package/tape) since it's simple, works in node and the browser, and doesn't depend on any globals or "magic." [Example test](https://github.com/mattdesl/webgl-context/blob/master/test/test.js). 
They both serve different purposes. Read eloquent first and then read JS The Good Parts.
Can you also add one of those crazy long passwords that services like PassKey use?
I'm not sure I understand what you mean by 'working'? Where are obj.item[i] and .item[i] coming from? Can you give a specific example? I think that would be easier. If I'm reading what you're asking what you're asking correctly (which I'm probably not): Say you have an object like this: var obj = { 'item': ["value"] }; Now you want x to equal something like: var x = { 'item': [{ 'item': ["value"] }] }; ?
You are correct sir. Thanks for the catch fixed it.
This is very neat and impressive. This post comes at a perfect time for me as well, since I was just starting to look into options for email in a js web app. Just doing a cursory glance -- ~~CSP comment~~ How are you handling the problem of storing unencrypted private key(s) between sessions? That seems like the last big hurdle for these sorts of applications until the webCrypto API becomes more prevalent. Edit: Whoops, obviously wasn't looking close enough, ignore that CSP comment
When the two charts are shown I was a little confused about how they related. I'd suggest you use the same colors in the pie and bar chart to connect which is which. You might also consider whether you need both.
if and only if * acces to hased password * hash algorithm known * no salts used last point is the major one to avaoid rainbow attacks, always use salts.
 var ItemList = function(x) { for (var i = 0; i &lt; x.materials.length; i++) { console.log(x.materials[i].name); if (x.materials[i].build !== "BasicFactory" &amp;&amp; i !== 0) { for (var j = 1; j &lt; x.materials[i].materials.length; j++) { console.log(x.materials[i].materials[j].name); if (x.materials[i].materials[j].build !== "BasicFactory" &amp;&amp; j !== 0) { for (var k = 1; k &lt; x.materials[i].materials[j].materials.length; k++) { console.log(x.materials[i].materials[j].materials[k].name); } } } } } }; Ok, so basically I have this code that cycles through objects within array of objects like a huge tree graph. This code only goes three deep though i.e. x.materials[i].materials[j].materials[k].name Instead I want to create a for loop that only uses the first four lines and then create a function that adds an extra .material onto the end so it can keep cycling through depending on how deep the tree extends.
"Make sure it is not" sounds to me like the password would be rejected.
I totally agree with your point of view. It's probably better to keep the tests centralized if your application isn't completely made of separate modules and you see it more as a whole. 
&gt; The code this.something.something is not executed in the scope of "setInterval", but in the scope of "a". That is why this.something.something works. What's different between that and just using this.something. Is it because it's not executed? I had the setInterval in a method off of an object. In one case it mysteriously can't find this.method (another method on the same object) but when you use this.method.bind(this)....oh snap...it suddenly magically knows where it's at. I know bind creates a new function with this bound to the provide object but still it had to find the object to bind to. Doesn't seem much different to this.somemethod to me. Both have to be found. In one instance it's blind and in the other it knows right where to find it. I think the first answer here is correct. I really don't know though. I'm guessing that when the () is added to run bind, it has to do that first and doesn't do it inside the setInterval function which really is global.setInterval so it runs bind inside the method of the object I have it in...I dunno http://www.reddit.com/r/javascript/comments/2smals/setintervalthissomemethodbindthis1_works/
I can't speak for Eloquent JS but I've read the Good Parts several times. It's extremely light reading so you can probably blast through it and get to both.
Surprised this hasn't gotten more love. Excellent share, thank you!
4 billion a second? John does about 3.5 million on a modern core. You can parallelize that to about 15 or so. What technology is being used to get that hundred fold increase?
Something like what /u/g3bj45hg34857 wrote is what I was going to suggest, although I'm still not sure what you mean by &gt; create a function that adds an extra .material onto the end so it can keep cycling through depending on how deep the tree extends.
If you use Chrome you can pass a setting to disable this: http://www.chrome-allow-file-access-from-file.com/
Errr... 2014? No? 2012? No? When does Twitter Bootstrap introduced? Errr... when does Metro UI introduced? And all the flat-flat thing
I wish I could help you out. But out of curiousity what is your end goal?
There is no difference. It seems you still don't know how the scopes work. There is no difference in scope with or without bind. Neither is executed in the setInterval scope. Lets look at this function again: function a() { setInterval(this.something, 1); } let's also make our own setInterval that stores the info function setInterval(func, interval) { eventList.push({f: func, i: interval}); } How many scopes are there when "a" is called? Let's build up an execution list of what happens when we call "a" create empty argument list call a create scope for a resolve this resolve this.something create empty argument list add value/reference of this.something to argument list add 1 to argument list call setInterval create scope for setInterval create object with f being arguments[0] and i being arguments[1] create empty argument list add just created object to argument list call eventList.push create push scope ... // left out the array.push stuff here return destroy scope of push return destroy scope of setInterval return destroy scope of a As you can see we end up with a scope for every function call. And as you can also see, arguments are resolved before a function is called at all. This is regardless of what that argument is. Lets change function a so that it uses bind and again see what happens function a() { setInterval(this.something.bind(this), 1); } create empty argument list call a create scope for a resolve this resolve this.something create empty argument list // changes start here add this to argument list call bind on this.something create scope for bind ... // leaving out bind because I explained already how bind works in the previous post return store result destroy scope of bind create empty argument list add result of bind to argument list // changes stop here add 1 to argument list call setInterval create scope for setInterval create object with f being arguments[0] and i being arguments[1] create empty argument list add just created object to argument list call eventList.push create push scope ... // left out the array.push stuff here return destroy scope of push return destroy scope of setInterval return destroy scope of a As you can see, all changes happen before setInterval is even invoked. And the resolving of this and this.something is also done before setInterval is called. And has to be done for both whether you call bind or not. Meaning there is no difference there. ----- Now, when the actual interval elapses and executes the function you gave it, there is a difference because of bind. Because without the bind you give it a simple function that will be called directly from the setInterval scope. Meaning that the `this` in your function scope will be global or null. When you add the bind, the function that bind generates will also be called in that context(with `this` being global or null). But because that generated function has stored the object you gave it(using closures), it is able to call your original function with the object you gave it making `this` in your function that object.
Unless you only have a week to live, you should have time to read both at some point in your life. If you do only have a week to live, read neither. Go do something fun.
Javascript The Good Parts changed my career as a programmer.
It would really help if you made a jsfiddle or codepen so we could see the whole code. 
You may want to look up [recursion](http://en.wikipedia.org/wiki/Recursion_%28computer_science%29). First hit on "recursion in javascript" results a [code academy course](http://www.codecademy.com/courses/javascript-lesson-205/0/1) that from the index looks pretty good. 
I'm curious what exactly you mean by pixel manipulation, a specific canvas feature or any writing/reading of pixels? I hadn't heard this and have messed around a ton with canvas on my local box via file:// building simple canvas based games and drawing apps without running into issues.
Can someone provide some good context in what it means in these situations to have your password hacked? By brute force? In what situations? I use "dan" as my password for unimportant things (I don't care if people know that), and no hacking yet. When would this happen? If someone gets access to a database and they have the hashing algorithm, and the hashing algorithm is really easy (10 billion tries per second I guess)? I'm just looking for some context.
Always good to see what Microsoft are doing with Typescript, just wish it had a better workflow outside of VS. Managing file references for larger projects results in either messy transpile arguments or ///&lt;reference&gt; headers that are a mile long.
GPU based crackers running on 1000s of cores.
You need something like object.offsetLeft or object.offsetTop that will give you the position in a basic sense. Now depending how buried in wrappers and other div's the object is it may not be accurate but there is a work around for that too. Basically it works like this [link](http://codepen.io/tourn171/pen/LEWKEV)
Have you played around with http://flowtype.org/? I think it may be a more concise alternative.
you aren't mistaken. Over 6 cores I can get about 15-17 million a second ... that's about 250 ... 
**Game features:** - fast puzzle block game core - Super Rotation System - 5 previews - hold function - lock delay - ghost piece - bag randomizer - customizable controls and DAS, remembered This game has already passed inspection by the Tetris geeks at Hard Drop: [http://harddrop.com/forums/index.php?showtopic=7087](http://harddrop.com/forums/index.php?showtopic=7087)
I don't quite follow. To use jQuery, you need the jQuery javascript files. These may or may not be minified files. Most people use minified files to save bandwidth, e.g. "jquery.min.js". If you want to add static typing you need to add type definition files. You can download these from "DefinitelyTyped". Alternatively you can use a TypeScript definition file downloader (TSD). The TypeScript compiler merely needs the definition files to do the type checking. jQuery can be downloaded either manually or using a tool. This tool may be npm or bower, for example.
My approach is to leave the server description as clean as possible, and integrate thin modules with express router exports that hang on to the main server, it can be useful for unit testing and decoupling. Check this example composition: https://gist.github.com/arathael/56c05271dd7c7367a90e
Will it let you create the template with script tags via the api?
You've tried the following framework [Sketch.js](https://github.com/soulwire/sketch.js)? And not just the math, this type of problem requires a lot of physics. Keep going!
No I haven't tried the framework. I want an understanding of all the core concepts before starting to use a framework. A framework is great but if I don't understand how the framework works whats the point. I just wish I knew where to start looking. If you try googling anything curve or arc related in regards to JS and canvas all I can seem to find is context.arc() context.bezierCurve() etc. I know how to draw an arc on canvas lol I need to know how to animate a particle to follow an arc. So yeah no help there so far. 
again, setInterval **is not resolving this.something**. Your function that calls setInterval is. The reason for that setInterval implementation there is to show how the scopes work and that setInterval **is not doing any resolving of what you supply** Here, try this out: var a = { function start() { setInterval(this.something, 1000); } function something() { console.log("This is a test: " + JSON.stringify(this)); } } a.start(); You will see that it will function fine, but that the `this` in the function something is **not** the same `this` as in the function start. But if you change `start` to setInterval(this.something.bind(this), 1000); you will see that it **is** the same. Does this have *anything* whatsoever to do with how setInterval works? **NO**. This is because `bind` creates a new function. That function when called will call the original function with the object you give it. In this case the original `this`. ----- Let's check a few more things: function start() { var f = this.something; setInterval(f, 1000); } same result as the first time; function start() { var f = this.something.bind(this); setInterval(f, 1000); } same result as the second time. function start() { var f = this.something(); setInterval(f, 1000); } oh dear. everything is bonkers. setInterval is trying to call `undefined` because the function `something` is not returning anything. function start() { var f= this.something; f(); } No repeat, but the output is the same as the first time. function start() { var f = this.something.bind(this); f(); } Also no repeat, but output is the same as the second time. ----- So, does *setInterval* has to do with anything? **NO**. It has no relation to your problem at all.
well sure. The "fastest" supercomputer has a peak of 54,902 Tflops/second. It also has 3,120,000 cores, 16,000 nodes, 1.35TB of memory, 12,400 TB of storage, and consumes 17.6 MW of power + another 6.4MW for cooling. It cost $390 million and covers 7,750 square feet. An average household averages about 0.0012 MW for comparison and an average house is 1,054 square feet. A modern i5 will clock in at about 0.0012 Tflops. So yes, if you scale out the estimation here, you'll get 732 trillion / second. But I'm also sure that with 1.35 TB of memory other options open up.
I copied and pasted your code in node and it doesn't work. I appreciate your thoughts. I really do, but there are about 10 different opinions here on how this works so I'm going to go with what makes sense to me. Thank you
I see. Apparently http://hashcat.net/oclhashcat/ claims to see at least a 100 fold performance gain compared to my experience with John on CPUs. 
I guess I already understood all of that. But it's really not just a measure of my password strength. It's 1) How secure is the database. 2) How secure is the hashing algorithm (why isn't it more common for sites to use unique hashing algorithms?) 3) How strong is the hashing (Are there really computers out there who can hash 10 billion passwords per second?) 4) Are the passwords salted? I assume salting would also greatly slow the hackers down. Then 5) How strong is my password? After all that, I really feel like my true password strength is 90% up to the people storing it. I could have a 50-character password with every letter different, but it's strength is 0 if those storing my password do so in clear-text in an easily accessible database.
FWIW, Webstorm supports the jsdoc format and ES6
Also, people should realize that these things are generally not applicable to websites. It's applicable when brute forcing. So like for encrypted data, yes. Most websites will just block you after too many invalid attempts. In the case of encryption, like KeePass databases or TrueCrypt volumes, just use really long passwords that are easy to remember like a long sentence.
It's self contained though, and you shouldn't check these into source control. Typescript definitions can be the same way, just have a `tsd.json` spec file and `tsd reinstall -s` on checkout. I actually have this hooked up to execute when I install bower deps in my `.bowerrc` file: { "storage" : { "packages" : ".bower-cache", "registry" : ".bower-registry" }, "tmp" : ".bower-tmp", "scripts": { "preinstall": "tsd reinstall -s", "postinstall": "tsd link" } } `tsd link` actually pulls definition files from other bower packages, that have them specified in `bower` or `npm`. https://github.com/DefinitelyTyped/tsd#link-to-bundled-definitions One thing to point out, if you're looking for good `bower` packages build integration, use [wiredep](https://github.com/taptapship/wiredep). You can override the "main" files in for each dependency in your own `bower.json`. Overriding `ignore` doesn't work though, so bower still downloads everything... [bower-installer](https://github.com/blittle/bower-installer) solves that issue.
[Neat!](http://imgur.com/k1cqsrz) 
your best bet is to generate a static image using a console based tool. and generate the associated image map. the options for implementing this are varied; you can try a headless browser in the command line and take a screenshot using a plugin. the options, in my mind: - phantom.js - node.js + zombiejs - java/scala/python (insert your favorite language) based image generation **Edit:** To expand on my answer, all email clients reject templates with script tags or inline JavaScript. It's more efficient for email assembly servers to just shortcut that process for their users to simulate the same experience. 
For better or worse, select2 has set the expected behavior for tagging controls: https://select2.github.io/examples.html That behavior includes selection on enter. Not having it makes your control feel "broken"
this is the best answer
My penis can get only so erect
Javascript Patterns (Stefanov) and You Don't Know JS (Simpson) are also quite good for rudimentary/foundational reading.
Hmm...I was testing in node. It does some odd things. Maybe that was my problem. Try it, you'll see what I'm talking about. Try your first example here. The one I altered below. I think you'll be surprised.
How? It just get's evaluated here and produces a new function so what is the magic sauce that does that? Thanks
Hey, I just read my comment and it seemed rude...sorry. I'm just confused and terribly frustrated. If you'd like to walk me through stuff in smaller chunks, that would help a lot. Also, at this point, I don't know who or what to believe. 
Yesssssssss, exactly what I wanted. Thank you so much. I had trouble searching for what I wanted because google results would give me regular transitions and positioning. Ah, so happy :D Thank you very much once again, made my life a lot easier. Sorry I didn't have a jsfiddle ready, and thank you again. Hope you have a great day!
No, it absolutely does not. It creates a new function with its own operating procedure, it never overrides an existing one.
I have no idea on how to answer your question, but I've been looking into javascript barcode stuff lately and came across this: http://serratus.github.io/quaggaJS/ Maybe it can help you figure out how to solve the problem you're having.
[HERE](http://codepen.io/tourn171/pen/MYpqLm?editors=001) specifically because you asked.
I'm getting a FOUC-like issue, where the spacing between paragraphs changes right after page load.
'bound' is a string object here?
Yes, it's the result of calling `Object('bound')`. When I wrote that I didn't remember that the context is casted to an `Object`, so I've edited the example to simplify by using something that's already an `Object`.
Any object? I'm having trouble with 'bound'. It seems like it should be bound to an object.
Thank you so much!
I feel like you might be limiting yourself with only a single line of pixels, after all, one of the defining features of a barcode is the vertical lines. I think my approach to this problem would be to build a model which scored the probability that any individual pixel in the horizontal line was a start or stop point based on its surrounding pixels. Do this for each pixel in your horizontal line and then pick the pixels with the highest rating. Take lots of photos of barcodes, manually mark the start and stop points, then train up a model which you can execute in your javascript.
No, dictionary attacks if you use plain words makes things much easier to get. Say a dictionary has 90,000 words in it, and you used "trafficbenchmark" as a password, that's 90k x 90k, a MUCH smaller space to look in than the 16 letters/numbers/symbols it could be. There's also mixed attacks.... Some programs run through the dictionary words, and also check the numerical substitutions: password, pa55word, passw0rd, pa5sw0rd... and so on. You can configure olc Hashcat Plus (graphics card hash calculator) to mix dictionary with random letters between words, and with substitutions, so Pa55word1 would be hacked quickly, and so too would Rainb0ws28.. Harder to hack are words (easy to remember) and stick a random symbol/letter/number in the middle. "Reinve#g5#stigate" for instance, would really fuck with the password cracking algorithms... it's as good as a 17 character password, but MUCH easier to remember than "hau&amp;GEEu3#23£fj$h" 
Isn't hashcat faster than Mr ripper?
I used it for the boss to demonstrate some weaknesses... A week on an old GTX450 and I'd got 60% of the passwords on the system. Two Titans, or GTX990's in SLI mode...... weeeee........
and?
if you have set a passphrase, you enter it at startup, and the private key is decrypted in memory. 
If it doesn't exist, try studying something similar. If you want to work from scratch, you have to write your own functions. This is a fairly good example of creating something with canvas and vanilla (no framework): [HTML5 Experiment: A Rotating Solid Cube](http://codentronix.com/2011/05/10/html5-experiment-a-rotating-solid-cube/)
Not sure if it's quite relevant to your needs but I used [Scandit](http://www.scandit.com/) in a phonegap app and it works really well.
Sounds like you should wrap your app in some thing like phonegap. This would give you easy hooks into native code that would be able to run the code at the speed your looking for.
That is the perfect example to explain how bind works, and to show that there is no magic sauce at all. [This polyfill](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Polyfill) cleans up the rough edges.
Flow looks great! Does it work with es6 classes? If not, I would really miss the classes.
It does, but "normal operating procedure" here refers to the standard way that JavaScript functions are executed, not to the function object itself.
Hate to be that guy, but a video is not code. Sorry but that was my first thought.
It looks like you already posted this 4 days ago: http://www.reddit.com/r/javascript/comments/2s7r25/my_javascript_game_after_6_weeks_in_development/ Has anything changed with the project since then? Are you prepared to give any more details, or share your code?
same here!
this.something immediately returns the function. This function is what setInterval will call, rather than executing the code "this.something()". The this object is bound when the function is invoked and this happens when the interval expires. Since the function is invoked globally, this is bound to the global object.
He also apparently posted it from future, since 4 days ago it was 6 weeks in development and now it's only 30 days in development. :3
You're not wrong, but I don't want to have to install an app just to run this code. The goal is to have a quick-running application available directly to the web browser.
You can fix this by using bind. Try setInterval(this.something.bind(this), 5000);
Why did you choose to go the Terraria-style of blocky terrain instead of the Lemmings/Worms-style of pixel-based destruction?
This one? http://www.reddit.com/r/javascript/comments/2smtlm/essential_javascript_links/
Does anyone have examples of good insights that you can get from a system like this? It seems cool, but I can't imagine why I would use it other than the novelty.
Kenman, you are the man!!!! That is it!
I don't really mind it, but it does look like an advertisement as this link was submitted by the content creators. 
If you want to learn the language, read Eloquent JavaScript. If you want to learn someone's opinion about what the useful parts of the language are, read The Good Parts.
I don't think it belongs on /r/javascript. 
You assign "this.something" as the interval function but it doesn't remember that it was attached to "this". You should look up the magic that is JavaScript's " this", it sometimes doesn't behave how you would expect. Anyway, two solutions: setInterval(this.something.bind(this), 1000) In this we call "bind" which returns a new function that is always bound to the given argument, i.e. "this". Or this way: var that = this; setInterval(function(){ that.something() }, 1000); Here we put a reference to the current "this" in a var and the in the interval we create a new function which references the old "this" via the variable. Referencing variables defined outside of the function is called a "closure". They can be very useful. 
It's for navigating around in large JavaScript codebases. The idea being that since IDE support for "goto definition" and "find usages" is not very good, you can use this to dump your object relationships out to graphml then find what-calls-what using your favorite graph query language.
That'd be boring as shit to watch.
I love the ideas behind Angular, and we know now that there will be a migration path to Angular 2. I think it works great for corporate apps, but I am not sure if Angular 1 is a good fit for public web / mobile applications, and if that is not one of the major reasons for the rewrite. For me one problem of using it on the public internet is the initial bootstrapping of the page. If a page relies heavily on Angular, then there is not much to render when it hits the browser. You can hide the "curly brace" sections with ng-cloak but it only solves part of the problem. That extra initial half a second/second that a fully-based angular app takes to load might not look like much, but it kills your user engagement as users leave the page, even if you put a please wait dialog briefly. Studies show that that an extra second to load a page reduces a lot the likelihood that a user sticks around. Also the fact that page does not have content when first loaded (only angular components waiting to be replaced with the actual HTML/CSS), it kills your SEO, although Google is working on it. Another problem I heard reported but have no direct evidence, if someone can confirm it / disclaim it: angular-heavy apps consume a lot of CPU due to dirty checking and kill battery quickly. React seems like a more natural fit for mobile: it allows to deliver html/css initially from the server and take it over as a SPA in the frontend if needed, so good SEO and startup times are a given. Performance is reported to be 10 fold for some use cases, which is always welcome in mobile devices even though they are getting more powerful. All in all, React does seem to be a better fit for the public web/mobile use cases while Angular is great for form-intensive applications (for which React is fine too). EDIT: adding links, this is a report on Angular [consuming battery](https://medium.com/este-js-framework/whats-wrong-with-angular-js-97b0a787f903) on mobile devices, I have my doubts too if this is true. For the importance of site speed, see [here](http://searchengineland.com/google-now-counts-site-speed-as-ranking-factor-39708) how google includes it for SEO ranking. 
It was "popular" [last time it came around](http://www.reddit.com/r/javascript/comments/2rj4l4/devwars_live_now_battle_of_developers_join_us/) I'm not advocating it, just pointing out some history.
The parallel you're trying to draw here makes far less sense than the quote you're attributing it to. He correctly states that they aren't fully comparable, but let's not pretend that no comparisons can or should be drawn. There is some overlap in functionality and if you want to use react, it does actually make sense to toss out angular.
I found devwars because of posts like this; I don't know if we need a post every time they go live but we also don't need people from /r/javascript interrupting the stream to start a fight. (Pakistanner)
I think the problem with this view I've been seeing online is that everyone sees Angular as a SPA only framework. I've seen some large scale apps that are multi-page apps using Angular. They do so for many reasons, with the main one being performance, especially load time on mobile devices. 
Needs to be reconfigured to work with other versions of cardboard + browsers lag a lot on android phones as far as i know 
I'd recommend playing with classes rather than directly with css, because if you can define the desired state with a css class, changing that in javascript is trivial. 
What news sites or ecommerce sites are in the forms of SPA instead of discrete pages? Again, I'd be interested in checking them out. The top contenders in both (Amazon, NYT / Al Jazeera) both use traditional page loading.
Yo! Here are some *great* talks on web performance. [Breaking the 1000ms Time to Glass Mobile Barrier](https://www.youtube.com/watch?v=Il4swGfTOSM) [CSS performance tooling](https://www.youtube.com/watch?v=FEs2jgZBaQA) The following two are the same talk delivered with marginally different stats here and there. At any rate, it's such an interesting talk that I'd definitely recommend having two goes at it! [CSS and the critical path](https://www.youtube.com/watch?v=-W0FBNbMLs0#t=229) [Breaking news at 1000ms](https://www.youtube.com/watch?v=dfweWyVScaI) As for whether or not they're the studies you're after I'm not sure. I'm not having a crack, I promise. I'm just really into this sort of thing at the moment and I thought I'd share a bit of what I've been watching. Enjoy! I've also just learned that Ilya Gregorik's book [High Performance Browser Networking](http://chimera.labs.oreilly.com/books/1230000000545/index.html) is available online, for free! **Edit: Spelling**
Table and... chair?
I'd be happy to throw the site into a Github repo for forking etc., but you can totally just copy the source code if you want.
http://superherojs.com/
Every time I come across an SPA website the first thing you see is a spinning wheel of some sorts. A lot like Flash based websites from the olden days. And now everyone is talking about rendering SPA everything on the server! So what's the benefit of this transition to this style of building websites as opposed to build them with RoR/Django/PHP etc...+Sprinklings of JavaScript. Especially, soon you can use ES6 modules and get super modular clean JS code.
This is true, Angular multi-page apps work well as well. Angular is also good for being used in a minimal way, just adding form validation with almost no javascript needed ([example](https://www.youtube.com/watch?v=t6XUPVmlYbY)). This is much closer to what Angular was initially designed to do: quickly enhance HTML with a few built-in directives. The prevailing view somehow became that it's a SPA only framework.
bad analogy, more like, "why I ditched my okay cruiser bike for a really sweet racing bike frame (and then had to find a new pair of wheels and handlebars)."
[LOL I meant to do that](https://www.youtube.com/watch?v=9hNIX7V21pU)
More like: it discourages you from working with the DOM directly, and makes it pretty difficult in some cases. Oh yeah, and if you do decide to work with the DOM directly, you will be shunned by society for not doing things The Angular Way^TM
What cancel button? I have no idea what you are talking about. I assume you're talking about some specific form/modal type case? My point was that in general two way data binding features can be stopped, at any time its rendered. 
SPA's take a long time to render on first page load, but then they are faster/more pleasant to use from that point forward. Ideally you would have both: server side rendering to deliver the first html page, and then do everything SPA style from that point forward. But that can really increase the amount of dev work you have to do. So it's about resources (money).
It's a performance nightmare. One of many that makes Angular difficult to recommend for mobile applications.
I also initially thought that Angularjs was main for SPA. Lately though, the two way binding between html elements and a javascript object, combined with an REST api made dev incredibly simple with little code.
Can someone explain to me how you'd write a web app with one way data binding? How do you get data from a form unless you're using an `ng-model`-like directive? Surely you don't have to manually serialize the form?
Why not React?
There is more to web apps than forms -.- you can selectively disable two-way bindings. For forms you likely never would, since forms don't tend to display large enough volumes of data to slow things down. The problem really is with big tables or visualisations, where angular puts watchers on everything to handle the two-way part. Thing is, most of the time you don't need a watcher on a rendered table or visualisation etc.
Should you make some assumption if you only read a single line of the image? just like single line laser barcode reader, the user will adjust the rotation of the barcode to let the device to scan it. Anyway, this is not js problem, try to go to another subreddit, there may be more people can help.
Good article... but the real point of promises is that you can yield them inside generator functions (or await them in ES7 async functions).
Maybe I should expand on this in a post, but promises are not a replacement for async code. Neither are generators. A promise is a composable abstraction around a **single value** that eventually results in success or failure. A generator is a composable abstraction over a **sequence of values** which may throw exceptions. A callback is a tool to handle an event which **triggers zero or more** times. There are valid cases to use all of these. Callbacks are general enough to fit all of the use cases, but are syntactically awkward to compose or sequence.
Yes i read your comments. I still stand by what i say.
When you say "editing", it seems like you're implying typing text into an input element. If that's the case, then my response is that there are many other cases where two-way binding would be useful. If not, then perhaps you're not being clear or I'm misunderstanding you. 
I completely agree that promises are not a replacement for all async code but most async code in my experience involves quing up a runtime event and chaining actions to be performed with that data. That includes executing another async action. Generators are much lower level than aggregating sequences. A generator is a type of datatype that is similar to a function in that it encodes some operation. However, unlike a function, it can be stopped via yield and restarted from some external code. Declaring and calling a generator and calling it won't resolve that promise its resolved. You need another function to take a controller and run it while responding to whatever comes out when you yield and restart it with appropriate values. a generator alone does not do this. for a good example of such a controller function, check out [https://github.com/tj/co' co. if you want an abstraction to deal with a sequence of values, what you need is a reactive stream. Rxjs is a good example and you don't need generators to use it.
This is awesome. I'm hoping to soon start applying/interviewing for Web Development positions and this is going to be a great resource. I do have question. What level of developer do you think these questions would be geared towards? A junior, mid-level, senior? There are some that I fully understand, and then some that I do not have answers to. Yet. Thanks for posting! 
Derp
Much better analogy, given they're both different approaches to a similar use case.
Agreed, lots of (personal) opinions flying about on JS frameworks &amp; libraries these days.
I learned at a summer student camp about computer in 1998. It's a boring lecture about html and js, everybody was sleeping but I was impressed by what JS can do, which begins my life of javascript.
In addition to performance, it can make data flow really obscure in larger apps.
Wasn't even promoting Angular, just that those specific ideas from Angular are in fact really good ideas. Stop being a dick, too. 
Where was the file located? He probably accidentally saved it. As to what it is, it looks like he was trying to connect to a website http://Fhackcanl2o4lvmnv.onion/blackcrawl/hack.html that is only available through a Tor connection. Verizon's DNS couldn't resolve the address so it pooped him out to this page http://searchassist.verizon.com/main?InterceptSource=0&amp;ClientLocation=us&amp;ParticipantID=euekiz39ksg8nwp7iqj2fp5wzfwi5q76&amp;FailureMode=1&amp;SearchQuery=&amp;FailedURI=http%3A%2F%2Fhackcanl2o4lvmnv.onion%2Fblackcrawl%2Fhack.html&amp;AddInType=4&amp;Version=2.1.8-1.90base&amp;Referer=&amp;Implementation=0&amp;method=GET and then he accidentally saved it. 
Two data binding is just an inherent part of any data rendering in angular. It doesn't need to be part of an edit or use a db. You're making a ton of assumptions here. I'm talking about general angular usage, not specific form implementations.
Well, I learnt a few things from it, unlike your comment, which is pointless karma whoring imo.
Differential.com! Meteorjs ftw!
Also a reactive stream of 1 item that then completes is the same as a promise, so aren't promises a bit redundant?
For Node.js or are you looking for a client-side library? Forms should always be validated server-side, but depending on your environment, there are libraries that will conveniently allow you to define restrictions and input formats that will then be evaluated both server-side and client-side (ASP.NET for example is extremely handy in this area).
I'm not sure where the issue is though. The promotional/landing pages for web apps are never done in the framework of the actual app and those are the important ones for SEO ranking and consequently ultra-fast loading times. If you're building a larger web applications users have come to expect the minimal loading time delay of a second to two. We're building a large web application using Angular and I'm really having issues understanding these comments since our tests and comparisons with other major web applications in terms of loading times and responsiveness always resulted in no noticeable difference. We did however invest significant research at the start of the project to make sure we've structured the app in a way that allows for no issues in the initial bootstrap, as you call it. The data gets to the browser in a fraction of a second after the app does and there is no need for ng-cloak or whatever if you know what you're doing.
&gt; From a technical perspective, it really is nice to reduce your server to an API and then keep your client separate from it. Upvote for that. &gt; If you're writing a classic document based app like Reddit or a forum system or Wikipedia, you'll want to stick with server-side rendering. Downvote for that.
The initial load happens once. If you cache files properly, your initial load should not happen more than once. If you have an app with a lot of UX features, then initializing scripts every time a user clicks a link is much more constly than one initial load.
In React, there's an optional architecture called Flux that can be used with it. It enforces the one-way binding by having data only flow one way. To give a bit more detail, it involves three parts, a Dispatcher, one or many Stores and the views. A click of a button would fire an Action, which is captured by the Dispatcher and distributed across the Stores which then trickles down the updates to the views. See https://github.com/facebook/flux/blob/master/README.md for more info about it.
It's not a complaint about the concept of two-way data binding. I just meant that the way two-way binding is handled in AngularJS can lead to performance disasters, **if not handled well**. The watchers and consecutive digest cycles can be a pain. It's not easily felt with CRUD based applications but when it comes to building web editors and heavy interaction based apps, it definitely counts.
I think you need to look at what you can do with two way data binding as your knowledge seems limited to forms only. 
Modifying the variable you are iterating on is _generaly_ bad code design. You might want to think about an other way to do what you want. If you can describe what you are trying to achieve, it may be easier to help you. My 2c
Thanks for your understanding. I think if we keep the DevWars posts to a minimum we'll be ok, so I guess try not to post about it again unless it's a significant announcement or something (other than just another battle).
Because just the example with Reddit is not very fitting- clients which consume JSON and are web or native apps are in my opinion better, than classic web app. Wikipedia could have much better UX as SPA. Yet Wikipedia is not about UX, it is about content, so I grant you that.
I'd definitely prefer to add it to the collection outside (ie. `var x = new Class(); classInstances.push(x);`), but it sounds like OP wants to keep track of the instances without necessarily knowing where/when they were created.
This post seems like pointless karma whoring to me. I was just commenting on the obvious.
WeakMaps or WeakSets wouldn't help here: you can't enumerate their entries/elements.
What Google sites do they use Angular on? I thought this was one of the main complaints - Google does not use it themselves. Facebook uses React on Facebook.com. 
I was just checking.
I don't know, the case melted.
I understand this, and my counterpoint was that I disagree that it is a problem. Its very easy to manage.
I do this sort of thing the other way around, so you'd have a separate class to manage your instances. // Your class. Note that I've changed it to accept a single params // object to the constructor. I find it much easier to pass around. var MyClass = function( params ) { this.a = params.a; this.b = params.b; this.c = params.c; } // Manages an array of the objects you want. You can add other methods, // search as searching, multiple-indexing, pooling, etc. as needed. var MyClassManager = function() { this.instances = []; } // Create method that create the object for you, automatically storing it. // Again you can handle indexing, pooling, etc. at this stage as needed. // This example returns the instance here, but you could return an index // or something (or nothing). MyClassManager.prototype.create = function( params ) { var myClassInstance = new MyClass( params ); this.instances.push( myClassInstance ); return myClassInstance; } // Example of creating a new class manager and adding a simple object. var myClassManager = new MyClassManager(); var myClassObject = myClassManager.create( { a: 1, b: 2, c: 3 } ); This way your entity class is clean, it doesn't reference any global variables and in no ways knows what's going on elsewhere, which is what we want. You can then expand on the manager class to provide more functionality as needed, for example you could add other indexes that are automatically maintained (e.g. on property 'a' of your class). You could add methods to bulk load / save the data from other formats - e.g. from an array of arrays/objects. You could implement object pooling if you wanted to form the basis for something, and so on. Or, as you can see, you could easily make this a generic class for managing lists / pools of all sorts of objects in your program(s). EDIT: I just re-read what you said and I think you might be looking for a way to define the objects in data and instantiate them? This might be the sort of thing you're after: // Example method to show how you could instantiate all your objects using // data defined in JSON. This accepts an array of objects where each object // has the properties to construct your object. MyClassManager.prototype.createFromJSON = function( jsonData ) { if( jsonData.length &gt; 0 ) { for( var i = 0 ; i &lt; jsonData.length ; i++ ) this.create( jsonData[ i ] ); } } // Define some more objects to create in JSON, then create them. var jsonData = [ { a: 2, b: 3, c: 4 }, { a: 3, b: 4, c: 5 }, { a: 4, b: 5, c: 6 } ]; myClassManager.createFromJSON( jsonData ); So you can see that having that manager class gives you a lot of flexibility with things like this, while keeping everything clean. EDIT2: I know that's not JSON data, I'm too lazy to go and add all the quotes. You get what I mean though!
the implication being you cannot have a good presentation without making your website a SPA? There is a time and place for SPA – it is not every time and every where. But I am totally down with using ideas/functionalities of SPA in widgets/components on any website.
If you're using React.js you can use [tcomb-form](https://gcanti.github.io/tcomb-form/) client-side and [tcomb-validation](https://github.com/gcanti/tcomb-validation) server-side to validate the payload in order to share the domain models between client and server. Disclaimer: I'm the author of both the libraries.
Nice write up! In one of the examples, you mentioned the risk of race conditions. Can you explain further? It's my understanding JS is inherently single-threaded, so I wouldn't expect that ref counting the reads would be a problem. Or were you more specifically referring to the contents being out of order? 
I can't fathom how there's any question about this. Look at OP's post history. All he does is post and talk about his own site while contributing absolutely nothing. He's the very definition of a spammer.
This feedback is kinda prescriptive. Why is it dangerous?
The primary problem here is that it has *[high coupling](http://en.wikipedia.org/wiki/Coupling_\(computer_programming\))*. In essence what this means is that the code isn't very re-usable, and it's not very portable. Sorry, I've got to go.. but I'll explain more later if you like. Think about: * What if you wanted more than one list of objects? * What if the class was defined in a separate file as a module? * What if you extended the class to have different specializations? * Where are you defining the classInstances array? What if you wanted to use the list in more than one place in the code? How would you access it?
var values = ... ; var p = _.map(values, Item);
Most of the arguments that Webpack can do more than Browserify are addressed here: https://gist.github.com/substack/68f8d502be42d5cd4942
When it comes to web development (i.e. browser, not Node), I think the SystemJS library deserves more attention. I cannot praise it enough. You don't need to worry about bundling until production and can write all your code using AMD, CommonJS, or ES6 syntax. At the moment the ES6 is compiled using Traceur, but I think 6to5 support is coming very soon. Personally I just stick to the CommonJS format, but it's there if that's what you're into. 
This, if you're willing to use underscore. A less elegant (but dependency-free) way would be a simple for-loop.
As long as developers offer a non-SPA version of their content-based website, I'm okay with it. The world-wide web was created with the premise of being available to everyone. And not everyone has (or chooses not to have) the technology to render SPA websites. Think of people with visual impairments, or those who prefer text-based browsers (I was one of the latter for some time. They were fun for a bit). Or people who cannot afford a modern computer with a modern browser (yes, believe it or not, there are millions of them). In a more recent example, I like saving reddit discussions for later when I don't have an Internet connection (i.e., while flying). If it was an SPA, I think it would be more painful to open links in background tabs and, worse, save the content to a file (~~offline pages~~ SPA content tend to execute Javascript to prepare the page for rendering, and pages saved for offline viewing on my phone won't run Javascript). 
I came here to learn any insight into which is better for my needs. Oh well.
Do you know if Angular 2 will support multi-page and minimal use cases?
that is why we leave the passphrase out by default. if you want to, you can set one, though.
Thanks your awesome!
I was just checking this out. I like that you can run RequireJS side-by-side, it seems like it makes it easier to convert your app over to using something other than RequireJS.
Why do you assume that you don't have access to URL variables? You can do this in JavaScript and is common functionality in client-side routers. A quick Google should turn up some code on how to do it. I would recommend using LocalStorage for most things though.
It's a good start. Needs a stronger demo.
This would be the "simple gist" mentioned in the article.
You may find the Jspm project interesting too. This works with SystemJS and can be used to pull libraries from places like Github and Npm, and will manage all of the dependencies between them for you. I've been using it for a huge modular web app and it really does make things much simpler, letting you concentrate on the important stuff. EDIT: Just who is downvoting these comments and why? In the topic of modular web apps and bundling, this is all very relevant and I thought others may find it of interest too.
Ignore them, just a bunch of butthurt assholes. We are using bower and are pretty happy with that so far, thanks though. I like RequireJS a lot but we have quite a few apps written around it and there will definitely be more. But now I am thinking I don't want to pigeon hole us into only being able to use AMD/RequireJS going forward.
I resonate with this article. Although I'm trying to diversify my skillset, I'm starting to call myself a UI developer.
Maybe try to wrap them inside a root object, then you can check all its keys. var ROOT = {}; function Item(a, b, c) { this.a = a; this.b = b; this.c = c; }; ROOT.x = new Item("hi", "afternoon", 4); ROOT.y = new Item("bye", "evening", 4); ROOT.z = new Item("oh", "morning", 4); var p = Object.keys(ROOT); // =&gt; ['x', 'y', 'z']
Cool, made me remember a project preseneted at 31C3: https://www.youtube.com/watch?v=291hpUE5-3g https://github.com/fabsx00/joern
I appreciate and understand where you're coming from. I may be alone in this sentiment but I consider dynamic requires to be a fairly *obvious* and *expected* feature from this type of framework, and I'm just not the type that wants to interact with the framework for very long. "I have apps to write and clients to make happy. Merr!" When I last used browserify, bulkify wasn't an option and it was less friction to simply use another framework that supported what I consider to be an obvious feature for complexity reduction in workflow. I'll edit my post to show that you're correct in that there is a way to support the feature in browserify. The rest is just my opinion on the feature.
I am on a crusade to popularize [JSPM](https://github.com/jspm/jspm-cli) myself. They might be alergic by now, because I usually bring it up. BTW It could once and for all end the debate on frontend script management- like npm did for Node. That would be huuge! We could finally work with the same power and simplicity on the frontend as we work in Node. We just need the library authors to start writing their libraries in modules, not as globals. That would be a true revolution.
You can also use symlinks, I use this with marionette projects so ../../src/modules/header/module becomes src/modules/header/module
Or "I can't believe that worked."
&gt; ... Javascript &gt; C++/Java &gt; Device Drivers I'm pretty sure that there's more in between!
You can use [window.addEventListener](https://developer.mozilla.org/en/docs/Web/API/EventTarget.addEventListener): window.addEventListener("load", headerKlein, false); window.addEventListener("load", lol, false); window.addEventListener("load", fu, false);
You should be using addEventListener to attach multiple events. In the code you provided, you are replacing the load event. [read the docs](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget.addEventListener)
The documentation /u/Blacker_Jesus linked to is pretty comprehensive. Here's an example: wp_enqueue_script('my-script-name', '/path/to/script.js');
np, i read these even though i have a job and am not interviewing. they go pretty deep into a lot of topics that i rarely focus enough time on so it is like curated intelligencehha
My company's primary backend language is Go. Much of the intercommunication between the server and browser is done over websockets, and all the packets are often framed in rather complex custom binary formats. I'm experimenting with reusing existing Go packages to eliminate large swaths of logic rewrites that would otherwise need to be done in Javascript.
Thanks, that makes sense :). Obviously most jQuery-era DOM-changing libraries are obsoleted by Angular/React but that doesn't stop people from using them anyway :). But, from what you said, I'm guesing making something like jQuery-UI Draggable work with React is not really painless either, is it? (Assuming you allow changes to the contents once rendered and don't want such a change to reset your draggable state anyway.) But maybe easier than in angular because most of the time React doesn't change *everything*, I guess. I must say my understanding of state in React is rather ..incomplete, from what I gathered, you can use simple POJO's but then you have to trigger a render manually, or you can use ..state? and have React automatically rererender? But in such case, it's not `foo.bar = 5`, but `foo.set('bar', 5)`? Either way, it seems it's neither simpler nor more difficult than adding `$apply` (or `$timeout`)? I'm still interested in trying React out some day, it's just, that particular point in the article triggered my bullshit alarm and I had to check :).
Yes. This is the programmer equivalent of [a New Yorker's perspective on everything not New York](http://i.stack.imgur.com/SX2CA.jpg). ...nevermind the browser, the app framework, the OS, and the kernel... each of which is by itself orders of magnitude larger (measure in programmer-years or lines of code) than anything in the red circle. Oh, and there's the back end too! :-)
Would it be odd that my JS is working, even without that in the functions.php?
Your claim is that there are orders of magnitude more LOCs written for, say, web browsers than all web apps written in JavaScript?
Well what you're doing is effectively Event Delegation and it's a very good thing in most situations. Event listeners can get costly in terms of memory usage especially if they are not cleaned up (e.g. element I have a listener attached to is removed but the listener is not). Now one thing I'm not certain of is if you're actually achieving full event delegation with the $('body').on('click', 'foo', fn). After a bit of reading it appears that is now the recommended way, but in earlier versions of jQuery it was recommended to use "delegate" - http://api.jquery.com/delegate/. The idea behind even delegation is that you have one event listener (click, for instance) attached to the highest level element (body). Due to event bubbling when I click anything in the DOM these messages will bubble up to the body click handler unless something stopped propagation. This allows you to handle multiple click behaviors with a single event listener, theoretically saving a bit of memory.
The script must be included in some other way. E.g. perhaps there is a &lt;script&gt; tag in your template. It's considered best practise to use wp_enqueue_script() instead.
Adding the handler on the body element has the same problem that using global variables do, i.e. could get annoying trying to track down where things get changed when change happens unexpectedly. But for under 1000 lines of code, it might not really matter. The "correct" way to do things, as in, the way that is best maintainable when the application grows, is to bind the handler as close to the element you intended it to work on, but at the common parent where all child elements would have the same handler and only differ on data, not code. So, in your example, the `ol` or `ul` parent of all of those `li` items, which you've given the id `#list`, is where the event handler goes.
I was thinking more "any one" than "all." If would be an interesting exercise to total up all the LoC written for all the 'front end' apps and compare it to all the LoC written for all the browsers. There might even be some interesting insight gained by graphing the change over time.
&gt;My immediate reaction was "that would make a great blog post". I'd read it. ..or an XKCD infographic -- what's the reddit trick to invoke Randall Munroe? There are lots of factors at play here, and it would be really interesting to get data on which dominates. One way to get a reasonable estimate would be to count programmers working in each area. I'm certain there are far more people doing front end development than writing browsers. However, my experience suggests front end programmers spend more time writing less code, due to the 'agile' churn. (You don't get to sit down and crank out code, there's a lot more time looking up how to glue libraries or frameworks together and then debugging the result, and I'm not sure we're counting the HTML and CSS and resulting layout/asset efforts here.) Also while the numbed of web apps is high, I suspect the lines of code in each is relatively small. I know it's pretty routine for the framework and libraries to dwarf the web app in size, and I don't think it's fair to count the millions of copies of jQuery towards web app LoC! EDIT: Quick sniff test: todomvc's backbone variant has 12K LoC in the bower_components subdir, and only 368 lines of JS in the app itself. It'll take 50,000 todomvc-sized apps to make one Chrome.
i really like that webpack extends this into your css/less and html too. Webpack also has -w, which compiles in memory.
yee_cmon, the author notes the option of using promises instead. The author is using forEach to *implement* a mapping function, as is evident from the article. Also, almost every map function is built on top of some type of 'eaching' function, so this is a completely normal practice. So, why should the author have **focused on the fact that Map isn't forEach**? That is tangential to his topic.
Actually I am the same way, the harder something is for me the more it attracts me as a challenge. I am not an expert myself (my education is mostly in digital hardware design) but I did take two formal programming classes and I think the reason they allow me to get by is that they introduced me to the programming structures common to a lot of languages. You can basically look at these structures as tools in your programming toolbox which you can use to solve a given problem. In that sense then it sort of removes some of the intimidation factor because you can start looking at a programming problem as piecing together these blocks that each serve to solve a portion of the total problem you are trying to solve. So for example like a for loop would be one such tool, case statement would be another, an object another and they can all be pieced together to get something useful. Javascript is in this sense no different and I think that, if you could find a very good intro to any C like programming language book for cheap and just start building these associations, then you should be on your way in no time. I mean look at it this way you are not looking to create complex algorithms right, just get some scripting language to move around some data for you so really math is not so much the issue. 
I think I might be able to explain a little on the state issue. I've not yet approached drag/drop, but I've been using React for a few months in production and I love the flow and thought process. There are a few examples out there on handling drag/drop in React which I've yet to read through entirely, but with anything there are multiple approaches. I would probably avoid using something like jQueryUI draggable since I believe it relies on it's own internal tracking and React has no real way to tell when someone modifies data out of it's control. You can read properties and arguments of elements, but if you move them around React doesn't have a way to know you did that without ugly hacks. I'd have to play with that more, but I would assume React would move the item back because it doesn't match the virtual DOM it maintains. http://webcloud.se/sortable-list-component-react-js/ http://kentwilliam.com/articles/rich-drag-and-drop-in-react-js Anyway, if I can get away with it, I generally approach React projects by building up a representation of the component in a JSON hierarchy. I did this for WorthingtonIndustries.com for the menu system. If I need to change an element, I modify the data that React uses to render it. Within the menu I have a history array that I modify to track changes to the internal navigation. When you select an item from the hierarchy, it is added to a history array and that is used when rendering the menu. If I need to go back a level, I simply drop the last item of the history array before setting the history state. This, unfortunately was written on an older version of React and I can say there would be changes I'd do different today, but that's the gist of it's operation. You are correct, it's not as simple as saying `foo.bar = 5` but I'm not sure it would be in any library without some incredibly boilerplate object listeners. React state is updated with `this.setState()` where you pass an object with key/value pairs you want to change. You do not need to send the entire state, though: only what you want to change. React applies those values to the component's internal state and calls a render. During the render, if the component uses `this.state.something` and you modified `something` in your setState call it will generate virtual Dom elements and diff them automatically making necessary changes. As you may guess, this makes (as mods_ said above) services pretty simple to implent by updating state. If you build your component based on the data provided and if that data changes, so will your view and you didn't really have to do anything. You declare what it will look like given a set of information. If that information changes, of course it will update. The drag and drop thing would be approached not by moving the elements in the DOM, but by modifying the location of objects in an array. [If I had my way on the stock ticker of the WorthingtonIndustries page, the stock ticker would have been this way. Just a simple service call to a JSON object that updates state and let the renderer do it's thing.] One way flows, dashboards, charts, etc. Are incredibly easy to build in React. Pushing data the other way requires a bit more thought. The first form you write in React you'll hit a brick wall because you're bound to set the value of an input to something and if you try to type in that input, you're going to notice that it doesn't change. This is because React resets the input to the value you give it. You could use defaultValue and just scan it later, but I like to invoke state on forms and manage it based on events the user does. If they clear the input, I update the state of the form. If they paste something in, it triggers the onChange and I update the state with the new data. This way there's one central location to find the data you need to deal with (run validations, submit, etc.) and it's a raw JavaScript object with no fancy library tweaking values or getting in the way. Just data. Of course, not many people are used to working this way. As far as the bullshit alarm thing... I agree mostly. I assume the author was talking about data libraries. Angular kind of forces your hand to wrap the data library in a module or something so that you can inject that library in the controller, service, or whatever you need it in. In React you just include it with whatever module system or inclusion system you use. In Angular I always feel like I'm encouraged to work around the Angular way and with React, it feels more like working the JavaScript way. I can use whatever packaging I need and I don't have to form my services a special way so the minifier doesn't break my code... It just feels like there are fewer hoops to jump through.
Thanks for pointing that out! So what's your opinion on the matter?
You're actually going to want to add an event handler instead of setting the "onclick". So like this: document.querySelectorAll("#buttonImage").addEventListener("click", changeFont);
Interesting. Both you and OP are brand-new accounts, both of which have posted 100% from `clarkfeusier.com`. This might not be so odd, except for the fact that [you two are responsible for 100% of the clarkfeusier.com content on reddit](http://www.reddit.com/domain/clarkfeusier.com/). Additionally, neither of you have yet to participate in any post that isn't `clarkfeusier.com`. I really hope that you didn't create another account just to post the same site, since this new account was created sometime after [this warning](http://www.reddit.com/r/javascript/comments/2s0811/node_basics_how_to_create_a_simple_server_and/cnl567u). If so, you run a very real risk of having both your user accounts banned, as well as having your domain banned for all of reddit.
Well like tourn mentioned this may not be the best resource to start out with so don't be too hard on yourself for not getting their approach. Maybe a better way of looking at it would be to come with some some basic project you think would be cool to do and then maybe look for some similar examples on the web you could use as a spring-board. Maybe try something with the canvas element--thats always fun to play around with. Also, the javascript section on the mozilla developer's network website is an excellent resource imo. 
&gt; If your head isn’t spinning by now, you shouldn’t be reading this. Go build a compiler or something. I think this drastically overstates the difficulty of the problem. (Now back to building my compiler.)
Learning to code and coding itself is harder. Programming needs a lot of practice and patience. I myself read through 3 books to learn visual basic... But after than learning new languages became much easier. After that I learnt Javascript in less than a month(though I wasn't really a skilled javascripter that time) and could be able to solve common programming problems that time. I would suggest at this point you might wanna try reading a javascript book. [Elequent Javascript](http://eloquentjavascript.net/) is a great book and explains things nicely. You can also try [Khan Academy CS course](https://www.khanacademy.org/computing/computer-programming) which also teaches Javascript if you are fond of interactive tutorials.
You should re-read the article because I think you agree with the author.
Disagree with who?
Thanks for that rock solid advice. I am presently co-studying JAVA 8, and network penetration. I know it sounds stupid when I say Wizard Hacker, but I'm serious, I want to be able to like, blow it up with a tiny computer and just know all the ways in and out. Presently, I'm barely a n00b, more of a b00b.
Well people replying seem to be indicating the blog agrees with you, and in theory I also agree with you, but what do you do when somebody has JavaScript disabled or when your target audience tends to run js poorly in general?
The intent is that someone said "why client-side templating is wrong", and then this person experimentally verified it. In his verifying, he found it wasn't necessarily true. Much like a title "Myth busting 'client-side templating is slow'" wouldn't necessarily imply that it was false, either.
Except the title says the author verified that client side templating is wrong. 
When you find yourself in a situation where it's your responsibility to make something come together, you as a coder, could be sitting on a problem for hours or days before you reveal the answer you're looking for. When there's a paycheck on the line, you'll destroy code and rewrite it like your brain is thinking from different starting points of logic. Sometimes the logic will just appear when I'm not working, and that's when it gets fun because I'll be in my car or in bed but already writing my 'next attempt' in my head. 
THIS. TIMES 1000. The modularity nazis drive me nuts when they say stuff like "well if you just used such and such module you'd be able to get that functionality, we don't want it cluttering up core". WE DON"T HAVE FUCKING TIME TO TRAWL THROUGH 80 BILLION GODDAMN MODULES TO PIECE TOGETHER SHIT THAT WE JUST NEED TO WORK. MODULE BUNDLERS ARE PIECES OF TECHNOLOGY THAT SHOULD JUST FUCKING WORK. FIN.
&gt;Then the web came along, triggering the influx of a massive new community of developers who didn't have the inclination, background and/or mindset to hack traditional imperative code. Initially they were mainly writing templates in languages like PHP and ColdFusion (and later JSP and ASP.net) What is this I don't even... The first language aimed at producing dynamic web pages hosted on web servers was Perl. If that isn't an imperative language I don't know what is. The follow-ups to that were PHP targeting CGI hosted on Apache, and VBScript (or JScript) targeting ASP/IIS hosted on Windows Server PHP and VBScript were both imperative *languages* and JScript is MS JavaScript implementation (for Internet Explorer) Finally around 2000 JSP was released which is Java targeting servlets hosted on Apache. 
I think this should be nuanced. If my website is Google Docs, for example, it seems perfectly fine to me to make a separate read-only version for non-javascript browsers. Even for reddit or Facebook it might make sense, as a lot of functionality (upvote/like, comment replies...) aren't easily implemented for non-javascript browsers.
But what about interaction with the web page? Like users clicking on buttons and say something like typing in a text box and being presented with options (eg the tag box on stack overflow)
He is merely complaining that the *title* says that the article verified that client-side templating is wrong. Which it kind of does.
This essentially means you have to use node.js or some language which is easily transpiled to js like dart. Otherwise you can't just run your controllers on the client. 
You're telling me you just have your C# code running in the browser on the client side. Hmm...
that is not what he is saying. Using a rendering library like moustache or soy allows you to render with the same templates in both the server and the client. What he is suggesting is a common technique to speed up perceived performance of a site.
oh using same templates. I thought he was talking about code too.
You wait for the data to become available. What else would you do?
Lol, I didn't write the other ones but yes, I will definitely switch to something else after one year or so because technologies change for the good and we also must keep ourselves updated. Also, I didn't mean that AngularJS isn't cool anymore, it is cool and AngularJS 2.0 would be awesome as it solves most of concerns I talked about in the article.
&gt; websites you would look at on a mobile device So that narrows it down to practially all websites :)
The server needs access to any variables in the template. Strictly client-side stored values should be avoided in any templates when using this method. It's just a cost of doing it that way. The goal is to avoid the cost of page-load time for the first time they visit. Bounce rates go up a **lot** the longer a page takes to load the first time someone visits. If they have to wait 10 seconds on a slow connection for the framework and custom JS to load, there's a good chance they're going to leave before they ever even interact with your page. Hybrid templating addresses that issue. There are some frameworks that handle that sort of thing seamlessly (Meteor and an upcoming Ember version come to mind), but I agree with you, it's messy. As I said, I've never personally messed with it, though I'm intrigued by the idea.
You could define one click handler on body and then determine which element was actually clicked (the event target) and call appropriate function based on that.
That requires to setup the server to push the JSON, having a fallback for clients without HTTP2/SPDY, and then it's mostly equivalent to bundling it with the HTML with the same issues. It's a bit better because you can cache the HTML (but note that since HTML is the entry point, caching doesn't improve latency unless you set infinite cache age and then put a front-end version number in the JSON and have the HTML reload itself if it's a newer version number that the one in the HTML). 
Yes. See: - [Popcorn Time](https://git.popcorntime.io/stash/projects/PT) - [Brackets](https://github.com/adobe/brackets) - [Atom](https://github.com/atom/atom) It's becoming more and more common!
If you then go and namespace these events, you can easily remove them all if you don't want the slight performance hit.
Don't be jealous. I've been through a lot. Just because a peabrain like you can't seem to understand anything beyond your own perception, indicating that you are not up to speed on your conceptualization of frequency, the universal language, doesn't mean that the rest of the world must be condemned to your limited and devolved understanding.
I almost mentioned that in the piece. I think the UX is between design and HTML as a skillset, but as a workflow it's obviously the other way around.
You can render html from any web page using stuff like https://github.com/kapouer/express-dom. Mind that it depends on node-webkitgtk (linux only for now), and i plan to either port it to jsdom or port node-webkitgtk to use osx webkit on that platform. But not soon.
Also note that further technology for efficient caching/updating of the DOM is being developed at https://github.com/kapouer/raja. This is in alpha/near beta stage.
&gt; then this person experimentally verified it. In his verifying, he found it wasn't necessarily true The trouble is that "verify" [can mean either](https://www.google.co.uk/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=define%20verify) *testing* to see whether something is true, or *confirming* that it *definitely is* true. Not appreciating this dual meaning is what's causing all the confusion on this thread. That said, to be fair the title is badly phrased and arguably a bit misleading, because in general when someone uses "verify" in the present or future tense they usually mean "testing", but when they use it in the past tense (as the title does) they generally mean "has been proven correct".
As I mentioned above you can add the (often wrong) behavior you'd like using: input.addEventListener('keypress', function (e) { if (e.keyCode === 13) { tagInput.convert(); e.preventDefault(); // prevent form submission } }); 
Yep, this is how you do it in meteor.
 var intervalID = setInterval(function () { //stuff.. if (you want to stop) { clearInterval(intervalID); } }, 1000); 
I might miss something but how that can help in the following scenario: 1. I have an Angular/React/Ember/CanJS app 2. I want the server to send the rendered HTML of the requested URL 3. The page is boostraped/initialized, controller/component events are bound to the proper DOM elements, models are bound to views etc I'm not talking about blog-like applications but a complex application where clicking on different elements determine modals to be opened, items to be deleted/updated.
I’m continually updating the post with new material.
I wonder if CoffeeScript will eventually be fully replaced by ES6/7 similar to the way ES5/6 "replaced" Prototype.js (sans DOM helpers) back in the days. Similar to CoffeeScript, Prototype also influenced ES development, serving its "filler" purpose for few years before slowly disappearing.
It isn't stopping because you are comparing a number to a character string. Wrong: if(b == '50') Right: if(b == 50) See how that works for you.
If your server is only in one geographic location, your app rendering will depend a lot on where the client is. If you can serve a page through CDN (un-filled) that the client can show straight away, they'll see something much faster, after which the server would then fill in dynamic data. So if you do complete server-side rendering you miss out on a lot of possible CDN benefits.
I think there's a distinction between showing off all the major features and seriously highlighting the most important features in an emphasized way. To put it another way: I rely upon a tech demo to inspire me as well as inform me. Dedicating ourselves to learning a new framework is non-trivial so it is extra-important to me that demos truly highlight each feature in an inspiring way.
V-dom supports IE6 and up, so second option is only for webcrawlers and someone with disabled JS. It also gives a "faster loading" feeling for devices with slow connection (you donwload prerendered html and only then start downloading js and rerendering v-dom). &gt; waste computing power Rerendering is the same thing as rendering any SPA for the first time. The only thing that's "wasted" is prerendered HTML. That's as wasteful as PHP server side rendering. If you are concerned about wasting power, you probably should use something more efficient than JavaScript. &gt; And man power to develop and maintains such a dual solution? None? You build your app as usual and your server acts as a browser and prerenders HTML the first time you try to get url(or renders every page if you are a webcrawler/no JS/IE5). Notice, that this solution is probably useful only with React or V-dom, and useless with older mvc frameworks like Angular/Ember. I haven't seen any good isomorphic solution for those frameworks (they might exist, I just don't know). 
 document.querySelectorAll("#bait").style.fontFamily = "'9/10"; 
Depending on what you mean by nasty trickery, that's not true. Install ServiceStack so you get the *ToJson* extension method or write your own *ToJson* extension method. Then in your razor view, do something like: &lt;script&gt; var pageData = @Html.Raw(Model.ToJson()); &lt;/script&gt;
It's been a long time since I've worked on a site where the layout is defined in the HTML. The performance argument doesn't make much sense to me, as the JSON still has to be rendered; I can't believe that a lightweight HTML templating system like Twig, in combination with server side caching, really adds much compared to churning business logic and accessing a database - it's just doing a few conditionals and sticking values into a string. The webservice angle is significant, but it's not that hard for a separate service to consume the JSON and spit out HTML.
Try using it with Angular or any other JS framework..
It's not anymore, but a lot of people are clinging to the old wisdom and paradigm. They should stop... I mean, unless they've got very *specific* needs of course, but generally, yes, assuming JS is available is the right answer. JS is pretty much on the same level as HTML and CSS nowadays in terms of simply *expecting* it to be available and if it's not then too bad for the client. Yes, every now and again someone comes along that has it disabled, or is on such an old device that it actually doesn't support it... but those cases are few and far between these days... so infrequent in fact that they are extreme edge cases that can be ignored, just like whether a site works on IE4 is an extreme edge case that can be ignored. This is also why the whole progressive enhancement approach has faded almost entirely. I mean, it still kinda exists, but now we call it responsive design (no, it's not *exactly* the same thing, but it's goal is roughly the same: content that works across many form factors without writing multiple versions of code). But PE as it was invented, which considered how to deal with clients without JS (primarily JS anyway), has pretty much gone the way of the dodo. So too should the consideration of clients without JS. The extinction of this thought is a good extinction event :)
[**@haxor**](https://twitter.com/haxor/) &gt; [2015-01-19 05:17:24 UTC](https://twitter.com/haxor/status/557044131038363648) &gt; @ChiperSoft @HenrikJoreteg I wondered the same and did that test here: https://github.com/bslatkin/template-perf/blob/master/static/server_divs_render.tpl It makes a difference but not enough. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot%20Report) 
I love coffeescript so I'm happy to see ES6/7 doing their own take on the feature set. Except for the indented syntax and other ruby-isms, most of what makes coffeescript great is in the ES6 spec. I will continue to use coffeescript because of browser support and I personally prefer indented syntax for no other reason than I am lazy. If the time comes, I won't hesitate to adopt whatever new methodology makes my life easier.
Can't really tell is there client-side templating wrong. But I'm certainly sure that direct DOM manipulation in Angular style is lame.
The fact it doesn't have dependencies is not a good sign, you know ? 
Nothing serious, no. And I would definitely caution that it's in the early stages. That said, I used nw.js to bundle a little React app I had built and it launched without any issue.
Cool, that's incredibly useful (and appreciated).
Additionally I’d change the comparison to: if (b &gt;= 50) In general, it is better to use `===` instead of `==` and to compare numbers with numbers and strings with strings, not a number with a string (as you do). `==` is permissive, so what you do works (once – later `b` is too large), but I wouldn’t rely on that permissiveness.
It's used by some commercial products. NW site has links.
You are writing a lot of redundant code that repeats itself... Try to use arrays and loops in a way where you only need to write an instruction at once. Can you show me the rest as well? If I can try it out life, i can get a better idea. Maybe make a jsfiddle.
/u/tokyokyoto 's answer works then.
I would always make optional arguments an object. http://pastebin.com/2Tq88td2
Guess i am, but im all new to JS, so that probably why.. Well, i think i done the JSfiddle correct, so heres the link: http://jsfiddle.net/9gbxky2e/1/ But for somehow it wont show the cards.. :I 
I might be completely missing something here... But why would you not just use an anchor.
&gt; Back-end should have nothing to do with views. Separation of concerns. Then your back-end developers don't need to know anything about front-end languages and vice-versa. Front-end developers shouldn't be installing Java or ASP.NET locally just to edit/test a few view changes. I don't believe this to be necessarily true. If you're really talking about separation of concerns, then you should have APIs that don't cater to the UI. As a result, you may end up having data that is in a format that is not applicable to the UI. Changing/transforming this data for the UI is really presentation logic, and it's the kind of presentation logic that is best suited for a server to handle.
probably because you expect them to be there, without having uploaded them. I assume that you need to make links to pictures which are on the internet. I am taking a loot at it, but can't promise anything
Thanks alot, i appreciate that! I have to admit that i don't know how to to the following you said, because i have imported it very stupid.. 
HTML is a markup language. It's like "here's a picture"... "Here's a paragraph".... "Here's a div"... These are all elements, not objects, not data, etc. CSS is there to help you identify different properties (styles) of elements. JavaScript and other programming languages do much much more. They control the behavior of the elements in the DOM. That is where programming "begins" on the web. HTML and raw CSS are nowhere close to having that type of ability. Think about it this way.. When you open up Microsoft word, you aren't programming a document, you're just writing it. That's what HTML is for (writing/framing up something to view).
Ooo! I just read this one. $ is brilliant!
&gt; None of the other mainstream websites will be working for this person either. I guess that depends on what's "mainstream." Amazon supports searching, configuring, adding to cart, and checking out without JS. I'm guessing they have a mission to eliminate as many obstacles to purchasing as possible, even if it means having a no-JS path. My ecommerce sites also support the core shopping functionality without JS just to eliminate as many barriers to buying as possible. Google Search silently falls back to a version that runs pretty well without JS. You can access advanced search and settings and stuff, but some things like multiple accounts fail. Facebook maintains an older mobile site that it sends you to if you don't have Javascript. Gmail still has the plain HTML site to support no-JS users. Wikipedia isn't really affected at all by having JS off. Microsoft's webpage is *amazing* without JS. The homepage navigation dropdown elements still function without JS, but they require a page load to update their display. I found it fascinating to look at. So, it's not like it's impossible to go without JS and it's not like all mainstream sites have said "Use JS or GTFO." I think it comes more down to identifying what functionality you want to have available no matter what and what functionality will go out the door if something happens to the JS. If, for your use case, it's not an issue to have everything go out the door, then so be it.
&gt; Incomplete. Check the issues page for outstanding bugs and incomplete features. This project should not yet be relied upon for production us
Cool story, bro.
 angular.element(document).ready(function () { $scope.[whatever] = [object we added to our razor view] }); Am I missing something?
Why are you sharing this?
Smells hackish to me, especially with postbacks.
Correct me if I am wrong but this project is not really finished &gt; I really like to see SSR(may be not this package) natively integrated into the Meteor core in the future. But there is a ton of more stuff needed to be done before that. The whole JS disabled argument seems to be the main subject of the post actually. It is also quite important for bots that do not support JS. For example, none of the social network bots support JS today. I could be also a solution for old browsers which don't support the APIs used to write a SPA. 
That is called prerendering and it's trivial with React using Node but impossible with AngularJS (unless you restrict yourself to a subset).
The package may not be complete for full integration into Meteor core, but that does not mean it's not usable currently. Regardless, going back to what we're actually commenting on &gt;Populating an HTML page with default data is a server-side job because there is no reason to do it on the client, and every reason for not doing it on the client. It is a needless performance hit that can easily be avoided by a server-side templating system such as JSP or ASP. Which is exactly how you do it in meteor. There's no argument or discussion here, it's how to do it exactly how the author of the article we're commenting on suggested.
Very nice, but if I may ask, what does this have over chipmunk/physicsjs/box2d? Or is it simply your own spin on js physics?
If you want desktop (any platform) + mobile (any platform), yes, web technologies.
Built this over a day or so with Matter.js. Fun engine to work with. http://brettdavidconnolly.com/crazy_conveyor/
hes quoting it meaning, hes quoting someone else.
HTML is designed for rendering documents, and we are horribly misusing it to write applications. It does seem like time to start from scratch with something designed for right purpose.
I really like this. Thanks!
IMO, I see CoffeeScript would likely to be replaced by 6to5 which has additional optional transforms which isn't part of ES6: https://6to5.org/docs/usage/transformers/#playground
Well, I thought that was the default (in memory), this is how I use it right now in dev mode
Funny, I was just toying with this during the weekend. The Box2D site didn't load, so I went with the next one. It's got pretty nice methods to build everything, I quite like the API. I build some experiments to test a Powermate as input device, like [a rotating box](https://vine.co/v/OjXaEzivvJe) and [a Labyrinth game](https://vine.co/v/OjYTwi1gdB1).
Excuse my ignorance, but would this library fit together with other rendering libraries such as pixi.js or three.js to utilize hardware acceleration?
Works for me. I'll post a link to the app when I deploy it to the cloud. How is it different from a text input box, except that it doesn't open a up a new page with a form or popup a dialog box? 
Ah well thanks for trying it out for me anyways. Its kind of hard to ensure it works on every platform and I definitely wasn't meaning for this to be any sort of grand release just hoping to grab some quick feedback from a couple of knowledgeable js people so this is still definitely useful to know. 
Thanks!
Bloat? IF I BUY A FUCKING CAR, I EXPECT THE MOTHERFUCKING CAR TO COME WITH SEATBELTS. IF I WAS TOLD BY THE DEALERSHIP THAT I'D HAVE TO GO SOMEHWERE ELSE TO GET SEATBELTS I'D RAGE THE FUCK OUT
Yeah, those emscripten Box2D ports are just barely serviceable. You can get by if you're doing something simple, but you'll have to dig into emscripten internals if you need to do anything complicated. 
Have another one, faggot.
Which ones are the defective ones? They are all perfectly manufactured polygons.
Not sure what the goal of this is… is the author hoping to standardize a set of event names together with keyboard shortcuts for those events?
It only matters if you're passing an argument. edit* Just read /u/Rhomboid 's stackoverflow link... it explains it better than me &gt;.&lt;
If you use Visual Studio, WebEssentials is the way to go. Files are auto-minified with each save, including a min.map.js
When you've got a bunch of ands and ors in your expression like you're doing, this can be a problem. Think about the parts of that expression that you're comparing. You're not comparing all identical items, so you need to do some grouping of your comparisons. Instead of trying to compare all items at once, break it into chunks. And just like in math class, parenthesis help here: spendingMoney &gt;= 20 &amp;&amp; temperature &gt;= 40 &amp;&amp; (forecast == clear || forecast == overcast || forecast == rain) Since you want to know 3 different things are true, you need to treat them as 3 things, not 5.
It looks like webcomponents.js replaces document.querySelector(All) / Element.querySelector(All) if the browser doesn't have native shadow DOM support (so everything other than a very recent Chrome). It might be the case that some other library is expecting some selector to work that webcomponents.js's version can't handle. It could also be the case that some other library expects to have their own version of querySelector (perhaps so that they could use some special CSS selectors). A few things to try might be: * See if document.querySelector and Element.prototype.querySelector are the native browser implementations in your page under Chrome, this will tell you if another library you have wants to overwrite it * Try removing a few of the other libraries at a time to see which one is conflicting * Load the webcomponents.js script as the very first script in your page
Thanks for the help! Will try to determine which library's selector is conflicting with webcomponents. Hopefully it's still possible to integrate Polymer into the existing application. After slowly becoming accustomed to using Polymer I'm finding it more and more useful.
We're using Polymer as an experiment, transitioning some non-critical UI elements to web components as a trial run. At first everything was a dream, but we've discovered that partial integration into an existing application may not be ideal. Thanks for the pointers though!
The major issues are - handling of markup when pasting formatted text from other applications (fun fact: when you paste content from MS word into a contenteditable field on older IE versions, it includes ms:o XML namespaces that will break IE's rendering engine if that text is submitted and returned on page refresh) - many implementations of contenteditable create a mix of semantic and unsemantic markup that can be very hard to unpick. Even if you don't care about semantics, you might care if you're relying on CSS to style the content later down the line. - Different browsers will affect styling in different ways, e.g. Firefox will wrap bold text in &lt;b&gt;, Safari will use &lt;span style="..."&gt;. This gets annoying if you want to intercept these styles. I would seriously recommend only using contenteditable through another abstraction layer, or perhaps a library that implements its own editing surface (there is a reason why Google Docs do this rather than using contenteditable).
~~IIRC the steam client, the spotify client &amp; the battle.net desktop client are built with it~~ nvm, I think it was chromium emedded framework instead. 
Isomorphic apps don't need precomposing IFF they rely on Truth In DOM (i.e. the DOM contains the entire application state). This is becoming exceedingly rare: React doesn't do it at all, Angular only does it in part (which is why prerendering Angular is a pain in the ass). In addition to the rendered markup you usually also need to pass along the data that was used to generate that markup. Typically this is done by dumping it in JSON somewhere for the app to pick up on the client at initialisation. I don't think services like prerender.io which provide static SPA rendering for SEO qualify as "prerendering" in the intuitive sense of the word: they *render* it, yes, but they also strip out the interaction entirely and provide just static markup (because otherwise Angular would be confused and break).
this looks pretty sweet. The new inference in closure is not 100% ready yet, but is close to what you are doing here (and flow). Obviously closure has a bucket load of features which are as important (apart from just the type checking) which I would want * tree shaking * being able to write my own compile pass * ability to compile the ast into modules (for staggerd loading) those are the most important features IMO which flow/typescript/everything is still missing. 
for the karam 
- Build your index.html with the server time hardcoded in it. - Use https://www.npmjs.com/package/ntp-client to keed in sync 
Those look really slick. Great job! What did you use for the 3d effect?
No, and I think it's because it's a security hole if you are allowed to run scripts upon opening an email. When you think about it, it's a terrible idea lol. Just finding other methods isn't as easy.
It's actual 3d. Using three.js 
ooo! egghead.io! Thanks!
If I were you, I'd dive into MDN. They've got articles, tutorials, and walkthroughs on important topics, like Object Oriented programming and Prototypal Inheritance.
As a guy who cares a lot about standards and usability (&amp; UX)... For some reason I just can't get behind this... I feel as though there are far too many possible 'actions' to map. No site will be able to map them the same with the same feel unless they were built damn near the same. In addition so many 'actions' depend a lot on the context of the action.. And so would need special love and care every time they are included... Its a good idea.. But in practice I can't see myself using it at all.
Depends on how you think about your APIs. Sometimes HTTP APIs return **entities** that represent business or domain objects and then browser-side logic does some manipulation to those data structures to get it in a form the UI needs. Othertimes, before APIs return objects over HTTP to the browser, they'll themselves call server-side services for business or domain entities and convert them to **view models** that are already in the shape/form that the UI needs them to be in.
Is there a source where I can read about the decision that exports should be bindings rather than values / references? I'm interested to know the reasoning. Edit: I found a relevant discussion: https://esdiscuss.org/topic/import-and-aliasing-bindings
The 3D rendering is using three.js, a phong material with a couple of lights. I created a repo with the code, if anyone's interested https://github.com/spite/powermate-input
So your point is that an HTTP API should never return a view model? I think a lot of people would disagree. 
There's a tricky thing about shortcuts: There are a lot of conventions out there, like standards, and it's really hard for yours to be The One. For example, I suspect the reason behind j is because of vi. Why not just use an up/down arrow? Well, because of normal mode vs. insertion mode in the vi editor. Why / for search? Again, vi. Why not F for **f**ind? or S for **s**earch? G for a**g**ain? Those particular keyboard shortcuts were likely selected by a set of engineers and have become a very limited set of conventions. There are more out there and you'll be hard pressed convincing everyone that these are best.
Fair point, my only thought here was to look at all of the most popular sites and find all of the keyboard shortcuts they all share. They all do seem to have a vi heritage, but I'm thinking that if you're used to using Gmail or Facebook or Twitter, it would be nice if those common shortcuts carried through on smaller sites too.
Thanks for the feedback! That does seem fair although my hope was to fire events generic enough that they would work for any site. Ideally, you could capture a shortcutNextItem event and then do a check yourself for where the current focus is / what you should do next.
Without the code it is hard to say. Jsfiddle might be something to think about here. Have you tried using the browser developer tools to inspect the HTML and CSS ? Maybe you have a typo or missing some styles... or the event is not firing due to binding issues (again... can be a typo or something like that) ? Edit: Misunderstood. You have provided the link. Checking out! Edit: You have put the HTML modal code into a &lt;script&gt;&lt;/script&gt; tag (therefor parsed as javascript not HTML as it should be).Move the HTML out of there, like this: &lt;span id="urlp" style="display:none"&gt;http://deforiginal.com&lt;/span&gt; &lt;div id="my-modal" class="modal hide fade"&gt; &lt;div class="modal-header"&gt; &lt;a href="#" class="close" data-dismiss="modal"&gt;×&lt;/a&gt; &lt;h3&gt;&lt;/h3&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; $(document).ready(function() { var hash = window.location.hash; if (hash == '#reviews') { ActiveProductTab('ProductReviews_Tab'); } }); &lt;/script&gt;
As /u/SCPoPo said, it only matters for arguments. new Date == new Date() == new Date(undefined)
I like the idea. You're headed into holy war area talking about standards though. Be prepared for that. I'd personally like a nice shortcut key library I can customize and just throw into my sites and be done. Even better if it comes with preset standard ones. I say if anyone doesn't see the point or if it doesn't suit their needs then they could just not use it.
If preloading the data is quick, then do it. Normally I'd say that if the user isn't going to be able to notice the additional data up front, then send it up front. That may even be embedded in the HTML in a &lt;script&gt; element, or just an initial AJAX request for all data.
&gt; If preloading the data is quick, then do it. It's almost instant, and the user still has to choose between geolocation or geocoding to find their location so it takes time anyways. I'm using Processwire to store my data in the backend and I fetch it with their selectors, right in the template file ! If there was a NodeJS Processwire, it would be amazing !
sweet, you even use jQuery now :) I can't do everything for you, but as a hint, use some variable, which saves, how many cards are flipped right now. The best would be to put it in a function, something like "checkCountOfFlippedCards". If there are two flipped cards, you will just apply the source "back.png" again. Either remember which cards you already flipped or all of them. If you do it on all of them (worse solution) keep in mind that if you find a match, it has to stay flipped up from then on. Probably the best would be to make a solution which checks if two cards are a match and then either let them flipped or flip them back. Give it an array of cards or something.
If thats a reference to lazy.js, then yeah, thats true.
What is this concept, 'Desktop Application', you speak of? I thought we got rid of those.
If you like the article, I would appreciate a re-tweet. https://twitter.com/kuizinas/status/557561350185308160 By the way, Lo-Dash v3 is going to be released before the end of the week.
JUST GIVE ME A GODDAMN SEATBELT!!! AAAAARHGHGHGHGHG
fabric.js is a framework (library), so you would have to make the HTML document and load fabric.js. Simplest would be to do something like this: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="my-canvas"&gt;&lt;/canvas&gt; &lt;script src="fabric.min.js"&gt;&lt;/script&gt; &lt;script src="my-code.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Then in "my-code" you would make your program. Look at the examples here: http://fabricjs.com/demos/ Full documentation: http://fabricjs.com/docs/ **Edit:** Also some tutorials there http://fabricjs.com/articles/ **Edit:** Just saw that they actually have this info in the README :P https://github.com/kangax/fabric.js/#examples-of-use
Oh, whispers. : )
Thanks so much!
I let out a little "woooo" and did an ass wiggle when I saw this. Lo-Dash is probably my favourite library.
 export let counter = 1; export function increment() { counter++; } // program.js import { increment, counter } from 'library'; console.log(counter); // 1 increment(); console.log(counter); // 2 !!! That is really interesting and it raises some more questions for me. Should we just be treating these values as object properties without the dot? Or are there more gotchas within this gotcha? What happens when you mess with the counter variable in the importing scope? increment it? reassign it to another number? reassign it to a string? What happens when counter is imported into multiple scopes/files? does counter update in all of them? Seems like you would have to be really careful not to break the module from one of the importing scopes. Or design your modules to not ever expose values in such a way, exposing only getters and setters.
Functions are passed by reference. They also contain a pointer to their execution context, so you can access closure variables.
I browsed the page source- there's a section injected about being out of stock. Definitely possible on the back end.
Is it ok for me to post jdalton's commit message? ;)
I thought I understood what it meant to be passed by reference but I do not. I thought to pass by reference meant it simpy used the variable name. This clearly isn't the case: var test = function() {console.log('blue')}; setInterval(test,3000); var test = function() {console.log('red')};
True, but how is that better? Isn't that basically similar but with less nice syntax than chained click handlers? $('body') .on('click', '.thing', handler1) .on('click', '.whatsit', handler2) .on('click', '.whoops', handler3);
lololol better luck next time
I'm sure there's a better way of doing this but this works in a pinch. Just throw it in your templates footer. $(document).ready(function(){ if($('.VariationProductInventory').text().match(/Out of stock/g)[0] === "Out of stock"){ $('button').hide(); } }); You can confirm by opening up the page and pasting it into the console. I would highly advise at the very least adding a class to that button within the template and changing $('button').hide(); to reflect the new class instead since I didn't bother looking to see if any other buttons existo n the page, but I don't think there are.
Hey awesome website / idea. However when I re-sized my window, the nav bar does not turn into a hamburger (dropdown menu). See if you can use bootstrap for the navbar at least! Otherwise fantastic website! Edit: Seems criticism is not appreciated here..thanks for the downvotes?
What is the filesize of the new version?
They're just social media links. If you wish to post to them all just get their share URLs. Theres no special JS involved.
the voting buttons aren't in an obvious location. users might not see them if they don't scroll all the way down to the bottom. 
The closest thing I've seen to what you are looking for is [Sails.js](http://sailsjs.org/); I don't think they have migrations and my sense is that there isn't the robust server security that Django has, but the thing about working with Express, which is also middleware-based, is that there is a plugin for everything ([including ORM](http://sequelizejs.com/)). This also means that if you don't like something about Sails (or whatever framework you end up using), you can cobble together your own system very easily with [npm](https://www.npmjs.com/).
YMLP is the mailing service that mails these, but they don't send bout to 130 social media widgets. I wanted to know how to do this. 
Like mikeyberman pointed out, it's impossible to really answer your question with knowing exactly what you're trying to do. But maybe this could help: &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="content"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var i, len, user, userTpl, userElement, eventListener, content = document.getElementById('content'); users = [{ userName: 'jsein', firstName: 'Jerry', lastName: 'Seinfeld' }, { userName: 'cantstandya', firstName: 'George', lastName: 'Costanza' }, { userName: 'kramer_123', firstName: 'Cosmo', lastName: 'Kramer' }, { userName: 'eb', firstName: 'Elaine', lastName: 'Benes' }]; // create a closure on the user object var generateListenerFn = function(user) { return function() { var msg = ''; for (attr in user) { if (user.hasOwnProperty(attr)) { msg += attr + ': ' + user[attr] + ' '; } } alert(msg); } } for (i = 0, len = users.length; i &lt; len; i += 1) { user = users[i]; userTpl = '&lt;h1&gt;' + (user.userName || 'Unknown') + '&lt;/h1&gt;'; userElement = document.createElement('div'); userElement.addEventListener('click', generateListenerFn(user)); userElement.innerHTML = userTpl content.appendChild(userElement); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
Yeah, you know a project is off to a good start when it feels it has to defend its choice of language.
Does that mean `0.1` would be invalid input since `0.1` can't be precisely stored as a 64-bit floating-point number?
Yeah!!!!!!!!!!!!, definitely my favorite library.
Why so? The idea is good. The Nav Bar does not turn into a hamburger/hotdog. For how extravagant the website is, there should be some responsiveness to it. I was being nice and I get downvoted? Edit: You do know what a hamburger is right? The three little bars that drop down a menu when you click them. 
&gt; Go no-backend with ... a ... back end
I don't know why you're getting downvoted; maybe it's because "nav bar turning into a hamburger" sounds so hilariously off-topic (I know what you mean, by the way). Perhaps just saying "Work on the responsiveness of your site" should suffice? I don't know. Edit: Or....... it could be that the submitter is not necessarily the site's developer. Edit 2: Well, Endel seems to be a contributor. I don't know what to tell you anymore. 
Does SJS assume that provided code already acts as if it were statically typed (as Flow does)? Would be great if the checker supported constructs such as Object.assign as well. On an unrelated note, the name may be somewhat problematic (assuming SJS is also the name of the binary), as it conflicts with [sweet.js](http://sweetjs.org/).
Even the reasoning is terrible. If they wanted something platform agnostic I'd think they'd go with python which is installed by default on pretty much every distro. If you have to install and configure it anyway go with something better.
With the [hogan engine](https://github.com/vol4ok/hogan-express) if OP doesn't want to learn Jade for templates.
Its something that takes a lot of code (can't really do it on just the browser) but like others have said you can use something like [eclincher](https://eclincher.com/) to do the posting
Parse is actually really popular among mobile app developers and used quite a bit.
I had to give you an upvote to offset the downvote brigade. Indeed the website does not seem mobile friendly and that is a very valid complaint in 2015 when lots of people are browsing on their phones. 
And my netbook, too
His class isn't actually ready yet, but yeah, it's a little unsettling that the site is down.
Why PHP? Exactly. *closes tab*
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 1173 times, representing 2.4152% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cnvtlr9)
I don't know sberder, SOAP is a **protocol**, whereas this is merely a suggestion of **archetypes**. The document looked to contain minimal 'SOAP nonsense in JSON', but maybe we have different ideas of 'SOAP nonsense' -- maybe you could let me know what looks to be the 'SOAP nonsense' that they are smuggling into JSON?
yeah, I see less soap nonsense and more bringing strong typing and classes into a loosely-typed, prototype-oriented language. but rather than having the type system loaded in a runtime *as a type system,* it's loaded in the runtime as data itself - this is interesting but represents a branching from the rest of JavaScript. if we want a strongly typed language, with type discovery at service boundaries, we should use one - not put strongly-typed icing on a loosely-typed cake.
Conrad, that's actually closer to the goal (and far less convoluted) than what I did have. Thank you. I'm now trying to change the code so that the users array is parsed from a separate JSON file, called json.test, which has the user objects inside. However, it no longer prints. Do you know where I'm going wrong? &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="content"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var xmlhttp = new XMLHttpRequest(); var url = "test.json"; xmlhttp.onreadystatechange=function() { if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) { myFunction(xmlhttp.responseText); } } xmlhttp.open("GET", url, true); xmlhttp.send(); var i, len, user, userTpl, userElement, eventListener, content = document.getElementById('content'); users = JSON.parse(xmlhttp.responseText); document.getElementById("id01").innerHTML = out; // create a closure on the user object var generateListenerFn = function(user) { return function() { var msg = ''; for (attr in user) { if (user.hasOwnProperty(attr)) { msg += attr + ': ' + user[attr] + ' '; } } alert(msg); } } for (i = 0, len = users.length; i &lt; len; i += 1) { user = users[i]; userTpl = '&lt;h1&gt;' + (user.userName || 'Unknown') + '&lt;/h1&gt;'; userElement = document.createElement('div'); userElement.addEventListener('click', generateListenerFn(user)); userElement.innerHTML = userTpl content.appendChild(userElement); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;
Because it's ubiquitous, fast, and progressive?
Serious question, what's with the PHP hate? I know the cool kids went onto Python then Ruby then somewhere else this old man doesn't even know the name to... but PHP isn't horrible... is it?
They clearly want to build a database of 'things' in a structured way that can have apps built around it. Freebase https://www.freebase.com/ went down this route with Google backing. It's currently being ended with some data going into Wikimedia backed Wikidata. It's not clear to me why Servant is the future of structured data rather than Google or the Wikipedia folks - you better bring something pretty impressive to take on those guys. 
Try reading 'Learning Javascript Design Patterns' by Addy Osmani - http://addyosmani.com/resources/essentialjsdesignpatterns/book/ 
This is a PHP project. Why on earth is this posted in /r/javascript?
There are a number of issues with the first Browserify example. First of all `require('add')` is not going to find a module file called `Add.js` unless it's in node_modules. Secondly, the modules don't export functions but objects, so in stead of calling `addObj(3,4)`, you should call `addObj.add(3,4)`. Finally, in Math.js there's an i missing in `multplyObj`. 
For vanilla and jQuery-ful javascript, we've settled on [qUnit.js](http://qunitjs.com/) for testing. It took our test engineer ~ 3 days to get it set up and comfortable enough to have test templates set up for a few of our projects. [This post on StackExchange](http://stackoverflow.com/questions/300855/javascript-unit-test-tools-for-tdd) has had a ton of traffic; the top answer has 840 votes as of now. Last updated a month ago, - [Karma](http://karma-runner.github.io/0.12/index.html) and - [Buster.js](http://docs.busterjs.org/en/latest/) are the two Node-centric platforms they call out. I've used neither, but I'd comfortably fall back on the collective wisdom of the nerd power on that post. 
Thanks, that was an oversight on my part. I put them inline now which should be more obvious.
We use mocha+chai for test setup and assertions respectively. Node-only tests can be run directly from the commandline with mocha, and browser-specific functionality can be tested using Karma to execute the mocha+chai tests across a matrix of browsers.
Nose is cool, but the library support isn't there. Case in point, I was recently looking for something to do a data merge on a word document (XML template). The only solution I found for Node involved utilizing a payware cloud API and sending my documents to God-knows-where. That wouldn't be **legal** for me to use, much less preferable. 
I'm really in need to test it out. I'have done a similar tool in Java at work during last year. The main difference is main extract metadata also from SOAP services and have a client side portal attached to the API layer. But the nodejs thing make me curious.
No, [PHP is a horrible language](http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/). It's so bad that Facebook had to invent [a new language](http://hacklang.org/) to make PHP bearable.
At least that is cloud based though. With this you have to install/configure/run yourself
Looks interesting. Sounds similar to [Sails](http://sailsjs.org/) but with the addition of native SDKs. Might have to check it out.
You may want to consider [Intern](http://theintern.io) (full disclosure: I'm an Intern developer). It's a very flexible Node-based testing system that can run unit tests in Node directly and in browsers (among its many other features). You can check out the [tutorial](https://github.com/theintern/intern-tutorial) and some [examples of using Intern](https://github.com/theintern/intern-examples) to get a sense of what Intern tests look like.
Again, why are you sharing programming documentation?
Is it possible to create codecs? Such as support for embedding mkv files?
We do, but I'd rather see more contributions to JSDoc. A lot of projects (including mine) already use it. Now that it finally runs on Node.js (and not Java, like before) it's pretty good. Just needs some work — https://github.com/jsdoc3/jsdoc/issues
Yes, script is included as follows: &lt;script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt;window.jQuery || document.write('&lt;script src="js/vendor/jquery-1.10.2.min.js"&gt;&lt;\/script&gt;')&lt;/script&gt; &lt;script src="js/plugins.js"&gt;&lt;/script&gt; &lt;script src="js/main.js"&gt;&lt;/script&gt; &lt;script src="js/skrollr.min.js"&lt;/script&gt; &lt;script type="text/javascript"&gt; var s = skrollr.init(); &lt;/script&gt; Some of that script there is default boilerplate script. You asking that question makes me think Skrollr should be relatively easy to implement? EDIT: that code has formatted horribly, sorry. I can't quite find how to get onto the extended text editor.
Glad to. Yeah, that's one of those cool instances where a post got enough love to turn into a community wiki. 
Python, Ruby, and PHP all have very similar performance statistics. 
I'd rather have better tools for manually writing documentation, like an update to [Sphinx's JavaScript domain](http://sphinx-doc.org/domains.html#the-javascript-domain) to make it better suited for describing JavaScript in terms of constructors, prototypes, plain old objects and the different roles functions can play based on their context. Every time I've tried to autogenerate API docs (which I'd never describe with a bare "documentation") I've ended up fighting with the tool to try to get it to express what I actually mean.
Well then... I think [this](https://github.com/DynamicTyped/Griddle/blob/master/scripts/griddle.jsx) is the longest Component I've ever seen with the largest number of properties! Edit: Also, *highly* maintainable code: resultContent = (&lt;div className='griddle-body'&gt;&lt;GridTable useGriddleStyles={this.props.useGriddleStyles} isSubGriddle={this.props.isSubGriddle} useGriddleIcons={this.props.useGriddleIcons} useFixedLayout={this.props.useFixedLayout} columnMetadata={this.props.columnMetadata} showPager={this.props.showPager} pagingContent={pagingContent} data={data} columns={cols} metadataColumns={meta} className={this.props.tableClassName} enableInfiniteScroll={this.isInfiniteScrollEnabled()} enableSort={this.props.enableSort} nextPage={this.nextPage} changeSort={this.changeSort} sortColumn={this.getCurrentSort()} sortAscending={this.getCurrentSortAscending()} showTableHeading={this.props.showTableHeading} useFixedHeader={this.props.useFixedHeader} sortAscendingClassName={this.props.sortAscendingClassName} sortDescendingClassName={this.props.sortDescendingClassName} parentRowCollapsedClassName={this.props.parentRowCollapsedClassName} parentRowExpandedClassName={this.props.parentRowExpandedClassName} sortAscendingComponent={this.props.sortAscendingComponent} sortDescendingComponent={this.props.sortDescendingComponent} parentRowCollapsedComponent={this.props.parentRowCollapsedComponent} parentRowExpandedComponent={this.props.parentRowExpandedComponent} bodyHeight={this.props.bodyHeight} infiniteScrollSpacerHeight={this.props.infiniteScrollSpacerHeight} externalLoadingComponent={this.props.externalLoadingComponent} externalIsLoading={this.props.externalIsLoading} hasMorePages={hasMorePages} /&gt;&lt;/div&gt;)
First of all you don't encrypt passwords. You hash them. Second, never ever hash passwords on the client. 
For pure JavaScript unit testing I ended up with [mocha](http://mochajs.org/), using [Sinon.js](http://sinonjs.org/) and [Proxyquire](https://github.com/thlorenz/proxyquire) for stubs and mocking `require()` calls.
As in hogs or haar cascades? 
...you've still misunderstood what I said. Because you're focused too much on the words I used and not enough on the way I used them. I didn't mean the _low level details_, I meant _the way that JavaScript executes a thing_, as a turn of phrase.
1password?
Coding / Decoding video with WebGL would be one hell of a hack. If there's a way to send the data streams to the WebGL side as RGB / RGBA data, yes I don't see why not. Making the GLSL code to perform such operations would probably be really hard though. Apparently a couple of projects have done similar things: * [Broadway](https://github.com/mbebenita/Broadway) * [ogv.js](https://github.com/brion/ogv.js/) Here's a good discussion on this topic, including a tutorial on how to build your own JPEG codec using webgl: * [Link](http://multimedia.cx/eggs/developing-a-shader-based-video-codec/)
Without an explanation about why you made these assertions, your comment is somewhat useless.
 var add = function (x, y) { return y != null ? x + y : function (y) { return x + y; }; };
[http://stackoverflow.com/questions/2272902/make-this-syntax-possible-var-a-add23-5](http://stackoverflow.com/questions/2272902/make-this-syntax-possible-var-a-add23-5) Yay interview questions. 
There are a few that come pretty close, but the initial question leaves out the `add(1,2,3,...)` syntax out.
to get easy karma?
You should be using watchify for continuous builds with browserify. Webpack is a lot faster, I would probably mention that in my blog post, but I have seen cases where Webpack is slower so I can't be sure it's always faster. Watchify is plenty fast though. About Aliasing: Again, as browserify wants to maintain node compatibility, it doesn't promote aliases. Browserify suggests that you put commonly used modules in node_modules/app and add an exception for that in your .gitignore. Again that's Browserify picking convention over configuration. That said, it IS possible to do aliases with Browserify.
Thanks! Looking through both now. 
Using the third answer from the stack overflow question /u/speakoN posted and modified to loop over arguments instead of taking fixed arguments. function add() { //initialize x var x = 0; //sum arguments for(var i=0,len=arguments.length;i&lt;len;i++){ x += arguments[i]; } return function() { //if there were any arguments passed if (arguments.length &gt; 0) { //loop over arguments summing for(var i=0,len=arguments.length;i&lt;len;i++){ x += arguments[i]; } return arguments.callee; } else { return x; } }; }
This is an implementation of the Flux architecture - Full overview of Flux can be found here: http://martyjs.org/guides/flux/
Hi! Yes! ideally, any of those scenarios should work. To be fair, I don't NEED to, I just want to understand HOW I'd do something like this and how it'd work. Your code gives me an idea, so thank you!
I like this. I know I didn't say this before, but I cannot use `callee` since I'm in strict mode. This is also ALWAYS returning a `function` rather than the result. For this to work, I need to make a last call without arguments. It works, yes, but does not really satisfy what I'm wondering how to do. Thank you!
The client code is not secure. That's why you don't do any security based coding on the client. 
I think this modified version might work: function add(){ var a = arguments[0]; function _addlist(){ if( arguments.length &gt; 1 ){ return _add( Array.prototype.reduce.call( arguments, function( mine, acc ){ return acc + mine; }) ); } else { return _add( arguments[0] ); } } function _add(b){ if( typeof b !== 'undefined' ){ a = a + b; return _addlist; } else { return a; } } _add.valueOf = function(){ return _addlist(); }; _addlist.valueOf = function(){ return _addlist(); }; return _addlist.apply(null, arguments); }
I'm digging this! The one drawback is that I need to add an extra `()` at the end of the chain to finally get the result (rather than a function). I'm starting to think this might be unavoidable, but will keep trying. Thank you!
Damn, that is nice.
I think your best option is `delete`ing every single property the code adds to the global `window` object. But that definitely won't remove everything – for instance all functions bound to events would live on. body.addEventListener("click", function() { // I will only be garbage collected if you unbind me }); Generally I'd say there is no way to achieve this.
If you have your code namespaced in some fashion, couldn't you free it/mark it for GC by deleting it or setting it to undefined? Simple namespace example: var WEE = { doSomethingWonderful: function() { ... }, wow: function() { ... }, willNeverRefactorThisGarbage: function(undefined, null, window, new Date(Math.PI), [0]) { ... }, init: function() { ... } }; When you no longer need it, free it up via: delete WEE; Or: WEE = undefined; You would also need to make sure there are no closure/references inside WEE...You want WEE to be the only reference to what's inside WEE. Also, are you looking for a solution in search of a problem? Why do you want to do this?
Firefox is returning the mutable object, Chrome returns the immutable object.
Motiation: I work on a very memory restricted device (for example, it is not possible to open FaceBook. Reddit is fine). So I'm wondering how to add a bunch of JavaScript and then unload it when I need to load up some more. Just adding JS functionality causes a crash. 
Plain and simple. Thank you!
I think this is throwing away some of the best parts of React and then trying to replicate it in a DSL. One beautiful aspect of React is that you can use the full power of JavaScript when constructing the virtual dom. "Clear separation of presentation and logic - almost zero HTML in component files." I don't think anything worthwhile is being separated here, there is still plenty of logic in the templates, now it is just in some mini language strapped onto html.
It is using the best practices of react just in a template way....since it compiles straight to react code.
Had some trouble with MySQL. Should be fixed now. Please let me know if you have any more issues.
From the react site: "We strongly believe that components are the right way to separate concerns rather than 'templates' and 'display logic.' We think that markup and the code that generates it are intimately tied together. Additionally, display logic is often very complex and using template languages to express it becomes cumbersome." Not only that, this project allows you to have arbitrary code in parts of the template: onClick="()=&gt;this.toggle()" Which means you've got handler code all over the place. This is just Not Nice and the project just feels like it's missed the point of react.
how is jsx different in this ???? it seems that you are putting markup in your code. and code in your markup! form reactjs website: &lt;div id={if (condition) { 'msg' }}&gt;Hello World!&lt;/div&gt; and &lt;div onClick={this.handleClick.bind(this, i)} key={i}&gt;{item}&lt;/div&gt; 
I totally just understood everything that was just mentioned in this thread of comments. ^^Wat.
The explanation of the various flux concepts seems clear, which is good. Also the chrome extension is intriguing. However, the api seems like syntactic sugar on top of a relatively simple pattern. Are there any other benefits besides 'fewer keystrokes' to justify the layer of complexity?
The main reason is: * WebGL shaders cannot read textures with float values (there's an extension called oes_texture_float, [but you may have problems with it](http://stackoverflow.com/questions/17476632/webgl-extension-support-across-browsers)) [Click here for an overview of 2 methods that attempt to solve this.](https://lab.concord.org/experiments/webgl-gpgpu/webgl.html) TL;DR - you'd have to encode float data to RGBA and send it to the WebGL side as textures. Then decode them back into floats. After you perform your calculations on the WebGL shader, you'll probably want to read the results on the JS side. This would require another set of RGBA - float conversions, because the only form of communication between WebGL shaders and the JS side is through the readPixels() function (at least that I know of), which is limited to RGBA pixel reads from the canvas. In other words, you'd get: * performance bottlenecks * additional GLSL and JS code * errors associated with the float-RGBA and RGBA-float conversions You'd have to store the data at least three times - once as regular data, another time as RGBA data and finally store it as textures in the GPU. This would not go well with large/average sized data sets. The same thing with the results (there's probably some better ways to do this though). Also, [WebGL textures have a size limit](https://www.khronos.org/registry/webgl/sdk/tests/conformance/limits/gl-max-texture-dimensions.html), so if you want to work with large datasets you'd need some workarounds there also. Texture size limit is dependant on what device you're using. [The performance of some WebGL functions is also dependant on the device.](http://krpano.com/ios/bugs/ios8-webgl-video-performance/)
&gt; passing a variable by reference means you pass the in-memory pointer to that variable around from one function to another. I am confused by this. It seems like you're saying I'm passing an in-memory pointer to test around which, to me, would mean that when the value of test changes, it would print "red". Did you mean it passes the in-memory pointer to whatever the variable is set equal to? I dunno...that would make more sense to me based on the behavior. So if the variable is set equal to a function and I use that variable as a parameter in another function, the other function set's a local scope variable with the same name to whatever the passed variable was set equal to at the time. Sorry to be so confused.
You are right in that there are some similarities, but those eventually start to break down. A react components render function is not a template, its a JS function most times decorated with some JSX sugar. With a templating language i need to learn a whole new set of constructs to do things I can already easily do in raw JS. The differences can easily be seen in the cases of loops and conditionals (rt-repeat and rt-if). In react, even when using JSX, I can just use pure javascript to express these things. Also, the main idea behind a template is to seperate the view portion of a component from the JS. This is not the goal of react's render function. 
nulling (assigning null) is probably safer overall. And MDN itself says delete does not free memory.
You would fail this interview.
Refresh the browser! But seriously, this is one reason that putting your entire application on one page may not be the best architecture. Others are: losing ability to bookmark state and slower initial load times.
The main idea that a problem like this is trying to expose you to is that of partial evaluation and currying, since Javascript can return functions. There is a great write up about that here: [currying-javascript](http://www.crockford.com/javascript/www_svendtofte_com/code/curried_javascript/index.html)
something like [SuperGenPass](http://www.supergenpass.com/)?
Can you give me a practical example of when something like this would actually be useful? I find it a little frustrating, actually, because if there's no point in ever doing this, why is this a good interview question? It would be like applying to be a hairdresser and having them be like, "Okay, you can have the job if you can cut this person's hair with a spoon."
Thanks for that, I have installed it and bookmarked the website, looks like an interesting project, hopefully I will get round to having a proper look at it soon. For the time being, today at least I have been taking a look at Mocha, will likely try a number of frameworks before settling but really want to get into the habit of writing tests. 
Thanks, I am using Mocha (or learning to) right now, enjoying it so far. 
Open your debugger, set a break point, and see which what is happening, or if there are any error messages. What is it that you expect to happen? Is this all of your code? If you are using Firefox, error messages might not show up (when using GreaseMonkey), so you need to use CTRL-J to open the console.
My suggestion works fine for the OP's original input, and doesn't rely on any `valueOf` or `arguments.callee` sorcery. As they say: KISS. &gt; You would fail this interview. Heh, probably.
Just FYI, someone beat you to the punch: http://www.reddit.com/r/javascript/comments/2t65ak/martyjs_a_javascript_library_for_state_management/
I am not sure this will help, just looking at options. Partly habit- I work with microcontrollers in the daytime. Partly it is for an ancient tablet.
 add(2, 3) === 5 //false add(2, 3) == 5 //true It's not returning 5, it's returning a function that coerces to 5. Only looks right in Chrome because it's coerced. Not coerced in Node.
It's not what the benchmarks are saying. Actually they're pretty the same, it just depends on your architecture: https://philsturgeon.uk/blog/2013/11/benchmarking-codswallop-nodejs-v-php/
Hey, why in your `for` loops do you define `len`? Are you expecting `arguments.length` to change? Can we replace `arguments.callee` with `add`, such that the code doesn't fail in strict mode? *([arguments.callee is deprecated](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee))*
This is a pretty terrible question for an interview... unless the position for some reason requires the candidate to use functional programming techniques (and no, "using underscore.js" does not qualify) on a daily basis. If anyone is interested, I wrote up a blog on building somewhat advanced curried functions, including even "argument holes". http://tech.pro/tutorial/2011/functional-javascript-part-4-function-currying But regardless... whoever decided this was a good interview question should probably get off their high horse... lol And just to be clear: it *is impossible* to write a function that works for all cases of the example above. You could either do one that counts the number of arguments and waits until the expected number of arguments has been satisfied, or you could have a parameterless invocation of the function mean "i'm done". For instance: add(1)(2)(3)() // 6 add(1,2,3)() // 6 add(1)(2)(3)(4)() // 10 OR, it could expect a specific number of args (ie, 3): add(1)(2)(3) // 6 add(1,2,3) // 6 add(1, 2)(3) // 6 add(1)(2)(3)(4) // throws -&gt; TypeError: number is not a function 
the job really has nothing to do with knowing how to do specific tasks. we often say "the right tool for the job." but how do you choose the right tool for the job, when the tools are often things that have never existed before, and the job is often something that has also never existed before? **that** is the real job. and the right tools for that are deep insight, wise judgement, and a flexible mind. in an ideal situation, an interview question like this exposes those qualities in the interviewee, by prompting an interesting conversation.
arguments.length calls a getter function, setting the value to to len at the beginning of the loop prevents the function call from happening every iteration. This is more useful when iterating over large arrays, but it's a good habit to have in general. 
&gt; *arguments.length calls a getter function* I didn't know that until now, thank you!
Hello! I thought the same thing and came to a similar solution using currying. /u/Resure 's [answer here](http://www.reddit.com/r/javascript/comments/2t6riw/a_frontend_developer_interview_question_thats/cnwbavm) and /u/Minjammben 's [reply here](http://www.reddit.com/r/javascript/comments/2t6riw/a_frontend_developer_interview_question_thats/cnwa73r) both contain solutions that work with all the above examples, though.
I thought front end development involved kegel exercises. Boy was that an awkward interview
One really bad way to interview is to ask narrow short-sighted questions about the knowledge the candidate has *today*, rather than focusing on the foundational skills they might have to build for the future. Remember that you're not just hiring (or getting hired) to finish a single project; you're hiring/getting hired to hopefully be a long-term employee that will help direct the success of the company as a whole. That means you have to show growth potential, and that means being able to stretch beyond the "current" problem and show that you can handle the bigger more complicated one down the road. Most companies don't want you to be doing the same task forever. It's not good for them, and it's not good for your career, either. tl;dr: Don't hire for what your candidate knows today. Hire for what your candidate shows they can learn tomorrow.
Cannot upvote this enough.
You almost have to use requireJS in order to use Knockout components (and I would stress to you that components are the only sane way to build a large knockout app). I would also recommend either Lodash or Ramda (if you are familiar with things like higher-order functions, closures, and curry/partial application). Bluebird or WhenJS get my recommendation for promise libraries (WhenJS perhaps gets the edge because because it can lift jQuery "promises" while bluebird cannot -- as far as I know). Jasmine is my recommendation for unit testing. I recommend gulp for your build process. If you want a full-blown framework, look up Durandal. That said, I still recommend you use React instead of Knockout/Durandal. Having used both quite a bit, I believe that React is superior in pretty much every way (ease of use, performance, data flow, etc). As a final note, if you hate JS, then you are going to hate your life every time you code in it. Learn the language and it's design patterns (read the 'Eloquent Javascript' and 'Javascript Allonge' ebooks if you have not already). I disliked JS until I took the time to understand it. The JavaScript take on higher order functions and its use of prototypal inheritance makes for a good programming experience despite the warts. If you love typed languages, there is a superset of JS called TypeScript that adds static typing. I'm not a fan, but if you love static typing then I think you'll enjoy working with it.
well... whether that's a "working" solution is up for debate IMO. Those answers are basically functions type-coerced into numeric values. They aren't returning proper numbers in this case. Still a very cool / clever way to get an actual solution to the question... but my guess is the original interviewer didn't even realize that the examples given would require such hacks to forge a solution.
// don't ever use this
It's more the pattern of calling reduce on the input dataset and carrying over the previous item's promise, that I'm focusing on here
Very informative, thanks! It's true I still haven't try React even if a lot of people suggest it. My fear is that it would be hard to use third-party libraries with it. Am I wrong? Let's say, again, widgets like [vis.js](http://visjs.org) or [DataTables](http://www.datatables.net/), would it be a pain to use them with React? My understanding is that Knockout is superior in that regard. And since I *definitively* don't want to create from scratch all the widgets I'll use on the frontend, I *need* something that plays well with third-party libraries! I may check TypeScript, thanks for the suggestion.
PHP? Heck no. I'll find something else.
I am not sure about that, most of the people I know still use mp3s. 
Here is an article presenting something similar to resolve an antipattern http://taoofcode.net/promise-anti-patterns/ I don't know if there is a name for it but I use it pretty often. 
hey cool, good find. I had no allusions of being the only one with this pattern, but it still seems like its uncommon enough to not be named / well known. The rest of that article is pretty solid too.
anObj instanceof aPrototype
I have to admit if you asked me why I decided to stop Backbone + Marionette to check Knockout instead, I wouldn't know what to answer exactly. I think it's not that I dislike those, but more that I don't really *like* them. I'm still reading about Knockout and didn't do real coding yet except for their live tutorial (which is really nice by the way!). The difference with Backbone is I actually quite like Knockout. At least I'm feeling "ok" with it. Maybe my opinion will change once I start coding for real with it but, for now, it's the first of the library/framework I've tried that I don't dislike (I find jQuery ok too, but this is something else right?). 
It's async reduce with no concurrency... a queued reduce or reduce queue, perhaps? I don't entirely understand the design, though. The promises are really only for flow control, since you aren't accumulating the promises. If you were accumulating the success and failures, I would suggest $.when(), but you aren't rejecting the final if an async calls is rejected. Your _.reduce returns a promise, which you swap out for the output value with the last always, so you get the *feeling* of a reduce. Incidentally, you need to use .then(), and not .always() to change the promise output. As tested (pulled up the console on a site with jQuery 1.8.3, so YMMV), the reduce returns nothing. I still think a regular queue is easier to read (the following may not work, it's a thrown-together example): var asyncQueue = (function(){ function nextItem(inputQueue, callback, outputArray, defer) { var current; if (inputQueue.length) { // Pull the first element off the inputQueue current = inputQueue.shift(); // Use the promise from the async command to trigger the callback // Use the same promise to trigger the next queue element externalAsyncCommand.then(function(data){ // callback no longer take a promise, but the actual data. callback(current, data, outputArray); }).always(function(){ nextItem(inputQueue, callback, outputArray, defer); }); } else { // Queue is empty, resolve the promise and pass the data. defer.resolve(output); } } function startQueue(inputQueue, callback, outputArray) { var defer = $.Deferred(); nextItem(inputQueue, callback, outputArray, defer); return defer.promise(); } return startQueue; }());
Have you seen http://trackingjs.com and https://github.com/auduno/headtrackr ?
Probably would be using rust on the client via emscriptrn.
Im not proud of it but here's my [answer](http://jsfiddle.net/dLt92n2b/): function add(a, b) { add.value = add.value === undefined ? 0 : add.value; add.value += a ? a : 0; add.value += b ? b : 0; add.tmp = add.value; add.value = b ? 0 : add.value; return b ? add.tmp : add; } var ten = add(1)(2)(3,4); var nine = add(4, 5); alert("ten: " + ten + "\r\nnine: " + nine); 
&gt; add(2, 3) { [Function: fn] toString: [Function] } &gt; add(2)(3) { [Function: fn] toString: [Function] } &gt; add(2, 3).toString(); 5
So then simply if (page[check] instanceof 'Url') would work?
 I think these solutions depend on the environment calling valueOf on the return value (which is a function, so I think the environment will then call it to get a primitive). Have you tried them in a REPL instead of a browser? Edit: on mobile, so I can't myself Other edit: sorry...only read the code the first time, I see you addressed this
It would be something like `if (page[check] instanceof Url)` where `Url` is a constructor function
I'm fairly sure that modern javascript engines optimised the .length call for for-loops so it only calls once now.
My simple solution that'll work for the two conditions: function add(a, b) { // sanity checks: if not defined, set to 0 a = a || 0; b = b || 0; return function(c) { // base condition (empty parens) if(typeof c == 'undefined') return a + b; // non-base condition: prefill first arg return add(a + b, c); } } add(2, 5)(); // 7 add(2)(5)(); // 7 Ugh - I hate this. I work with JavaScript everyday but anything like this always throws me for a loop at first, even though I generally know a working approach. If you've worked with anything recursive you will be familiar with a "base condition" that stops the recursion and finally outputs. In this case I couldn't figure out how to get that working with just add(a)(b) and gave up. Thankfully I came back to the comments and folks were saying add(a)(b) won't work, it'll only work in a form that provides a base condition, like this: add(a)(b)(). Phew! Also, I got way too involved (i.e. I have no life) and figured out a way to make it even more flexible, so you can do stuff like this: add(2, 3)(1)(4, 5, 6)(); // 21 Here's the slightly crazy solution that makes this work (but don't expect me to remember how to do this when you ask me tomorrow): function add() { // capture scoped arguments, arrayify var args = Array.prototype.slice.call(arguments); return function() { // capture scoped arguments, arrayify var args2 = Array.prototype.slice.call(arguments); // base condition (empty parens) if(typeof args2[0] == 'undefined') { // abuse Array.reduce to sum all args from first fn return args.reduce(function(a, b){ return a + b; }, 0); } // non-base condition // prefill add with all previous numbers as separate args // e.g. add(1)(2) will become add(1, 2), add(1, 2)(3, 4) becomes add(1, 2, 3, 4), etc. return add.apply(this, args.concat(args2)); } } add(2, 3)(1)(4, 5, 6)(); // 21 add(2, 3)(1)(4, 5, 6)(3)(2)(10, 8)(0)(23)(); // 67
 function add() { // The 'sum' variable will now be in the closure scope that the rest of add // will use. This means that 'sum' refers to this one variable from here out. var sum = 0; var fn = function fn() { // The 'arguments' variable is available inside any javascript function // it is an array-like object that contains the function parameters for (var i = 0; i &lt; arguments.length; i++) { sum += parseInt(arguments[i]); } // Return the function itself - this allows for chaining like add(2)(3) return fn; }; // The 'toString' bit is here to make the OPs specification work. The returned // object will always be a function (so that it can chain like add(2)(3)), but if // it is printed this will be used so it will output '5' instead. fn.toString = function () { return sum; } for (var i = 0; i &lt; arguments.length; i++) { sum += parseInt(arguments[i]); } return fn; }; 
require.js, lodash, Durandal, rsvp.js Also consider (depending on your application): moment.js, numeral.js &gt; what it does is easy to grasp and, really important point for me, it seems to play way better with third-party libraries than other libraries/frameworks. Yup, that's the best feature of Knockout, and although it should be such an obvious things, so few javascript libraries do this.
I build the menu page for JimmyJohns.com (it was a few years ago now, I am probably ashamed to admit to having written some of that code, it's way to convoluted for it's own good) using KnockoutJS because at the time I wrote it, Angular was really just starting to be popular. Anyways, the two most helpful libraries I used were: * [LoDash](https://lodash.com/) is extremely helpful in helping filter and manipulate your model objects * [PathJS](https://github.com/mtrpcic/pathjs) for handling the routing on hash-change (or HTML5 pushstate)
It's probably not so much micro-optimization as "this is not worth my time". There are very few cases in web development where there's a tangible benefit to un-including a script that has already been loaded into memory; OP would most likely be better off just abandoning this problem and improving performance in other ways.
What I usually do is load few branches to fill the page/screen at the beginning (depends on your UI, 5 or 6 branches could fill up the whole page/screen). Then asynchronously load the rest via ajax and cache it in client's browser/app, so I don't have to load it again (you shouldn't reload branch's data if the user select another branch). You should use cache more often. I heard someone said: "Cache is like sex, it hides all the real problems". You maybe able to load the page instantly, but other people might suffer from slow connection. It's better to make your app/website run seamlessly. If it's a website, and SEO is important to you, you should be careful with ajax calls. More efforts might be needed to make it SEO friendly. 
 iterate: function(check, func) { if (!!page[check]) return for (i in page) { if (!page.hasOwnProperty(i)) continue if (typeof page[i] == 'array') for (var prop in page[i]) if (page[i].hasOwnProperty(prop) &amp;&amp; typeof page[i][prop] != 'boolean') page[i][prop][check] = func(); else page[i][check] = func(); } }
&gt;You should be using watchify for continuous builds with browserify. Webpack is a lot faster, I would probably mention that in my blog post, but I have seen cases where Webpack is slower so I can't be sure it's always faster. Watchify is plenty fast though. I already watch my scripts! and is nearly not even comparable with browserify in no case (I had found). Show me your faster case. &gt;About Aliasing: Again, as browserify wants to maintain node compatibility, it doesn't promote aliases. Browserify suggests that you put commonly used modules in node_modules/app and add an exception for that in your .gitignore. Again that's Browserify picking convention over configuration. That said, it IS possible to do aliases with Browserify. I've done that in my other app and the hierarchy of my source code looks so bad! That was a really bad decision. You can use aliases on client side, but what you'll do on the server side. I need isomorphic apps. With webpack I can do all of that, why bother about browserify at all? 
I think that is the correct answer to the interview question. I think it's a good interview question to demonstrate depth of understanding. Not knowing the answer demonstrates a certain level of depth, that's all. 
This is a great article on the topic: http://hughfdjackson.com/javascript/why-curry-helps/ If I was on the receiving end of this interview, and I didn't know the answer from memory (I don't), I'd state my intention of using npm / github to learn how to implement this solution. They shouldn't expect you to know the answer to every question, it's okay to admit you don't know. They're more curious about how you could handle being thrown things that you don't know how to do initially (problem solving skills). But at the same time, if you couldn't figure it out in 10 minutes using the internet, (without using stack overflow or reddit), or if you didn't realize this was a curry/partial function, I'd be hesitant to hire you. This would be my response (using internet): 1) search for 'curry' or 'partial' in NPM. 2) github the source: https://github.com/dominictarr/curry/blob/master/curry.js (lodash, ramda, and probably 50 other libraries implement this function too). 3) Read the source, learn from the source, recognize the pattern. If no internet was involved (which is common in interviews), I would write some pseudo-code demonstrating sort-of how it could be done in the most simple way possible (maybe too simple): function add(sum) { console.log(sum); if (Array.prototype.slice.call(arguments)[1].length &gt; 0) { Array.prototype.slice.call(arguments)[1].forEach(function(item) { sum+=item; }) return add.bind(null, sum); } } Not sure if that works (i'll test it) * and recursion isn't always best is JS - but it might impress the interviewer, even if it's not perfect 
Thanks!
Why don't you share your resume and recent work you've done, with us?
Agreed. There's not really a shortage of jobs for this particular skillset (at least not where I live), so chances are that their resume could be holding them back a bit. Nothing like a bit of constructive criticism to help things along.
This is how a javascript frameworks should work - Everything else is bloat and abstraction from necessity.
Holy... this is awesome! So much more concise than react. I think this'll be truly blissful to work with.
Might be a bit of cheating but I came up with this: var add = function () { var args = Array.prototype.slice.call(arguments); var result = args.reduce( function (a,b) { return a + b }, 0); var response = function () { return add.apply(this, Array.prototype.slice.call(arguments).concat(result)); } response.valueOf = function () { return result }; response.toString = function () { return result }; return response; }
no.
&gt; have you add script tags for every dependency &gt; maintaining load order Use [wiredep](https://github.com/taptapship/wiredep) with grunt or gulp. It will also resolve load order for you. &gt; Most of the popular boilerplates (bootstrap etc) are meant to be customized, not to have their CSS just dumped in your project. Then just do that. The Bootstrap bower also includes the LESS or Sass source files so you can customize and compile them yourself.
Honestly, I would like to learn about `Backbone` (if someone has really good resources then please let me know). Why? Because it seems to have all the basic foundations of what it should be there without any magic. I've used `knockout` and still do but wouldn't call it a framework. Like in the article, it's a library that does binding great. Backbone on the other hand seems to give you the structure for your app that front-end technology is missing. I don't know about future but I'm thinking `Web Components` and JavaScript would be all we need to create web-apps. I still haven't found the perfect solution but I hope someone can shed some light. And before someone asks what's wrong with `Ember` or `Angular`. They both have their shortcomings so I rather not speak about them.
Yes, these guys are generally assumed to have no programming experience. I agree that dropping jQuery and the like probably makes sense or at very least, moving it to the end. I plan on including discussion about scope as part of the functions sessions and I'll probably touch upon it while covering variables, too. I'll make sure to cover DOM methods and probably only cover OOP if someone asks. Thanks for the feedback!
Very impressive, I think I'm going to use this in a personal project Any idea how much the IE8 support effects the size and performance? Would forking a modern browser alternative make any sense, for when IE10+ or even 11+ is enough?
depends.
It wouldn't surprise me if the arrow indicates that the code follows on the next line. This means that you should type all the code on one line. This is done because magazines often cannot reproduce code as it is on screen (limited width).
I've been thinking for a long time now that the future is not to bring Java into JavaScript or extend the language for a problem that does not need solving but to use micro frameworks, that do one purpose really well and are written in vanilla.js/es6.
Is `.toString` only being called because of the console? When would this `.toString` method not be called properly at the end of this type of currying.
Wow. This is just pure wow.
dosnt run in node (yet?) =/ cmon how can u call it react-like.
&gt; For a applications SEO is usually irrelevant While I totally agree, some customers will just insist that we optimize *everything* for SEO. And they pay well for this, so...
Yes, but sadly no Node.js on the projects I'm mentioning :/
One solution I've seen is to have a separate server-process dedicated for serving the frontend assets in addition to the backend handling your business logic. I've also seen couple of project rendering React components on Java backend. There's probably solutions for other languages too.
I believe he was trying to use Java as an analogy for bloat/lots of boilerplate.
It might help yourself and others if you put the code in a jsfiddle (http://jsfiddle.net/). Generally it's easier to help someone with code that way. To directly answer your question, one path is to use the keypress (or keyup) event to do the validation.
IE8 support is a big red flag for me personally. There probably will be issues I do not want to deal with because I have the luxury of supporting modern browsers only.
Yeah I hate how everything in the KO docs is a bit skewed to working with requireJS. Took me a bit longer than I wanted to get everything setup using browserify/commonjs however I definitely prefer it.
I've taught Intro to JavaScript to beginners at Seattle Central College for about three years now. Here are some of the things I've learned: * Get people into jQuery as fast as possible. Teaching the raw DOM methods is a great way to frustrate your students and yourself, since A) the API is awful, and B) most people don't use it anyway. * Don't try to teach inheritance to beginners. They're not doing anything that requires understanding prototypes. You'll just confuse them. * Assume it's going to take them a lot longer to learn looping than you think it will. As a long-time programmer, I thought loops were simple, but it turns out that they're surprisingly hard for a lot of people, probably because they're the first time coders need to start thinking at multiple levels of abstraction. * Remember that for most people, if they haven't done browser scripting, do not think about the HTML document as a tree. They think of it as more like a Word document. You're going to need to spend some time talking about the DOM structure and CSS selectors. * You can start with console.log and prompt as a way to introduce basic syntax without having to get the DOM involved. That will get you through conditionals, loops, and possibly functions. My usual weekly structure for the class goes something like this: 1. Script tags, variables, console.log, prompt(), primitive types and operations. Homework: produce a basic page with inline and external scripts. 2. Conditional statements, falsiness, comparison/boolean operators. Homework: write a choose-your-own-adventure. 3. Arrays and loops. Homework: perform some kind of sum/average/max operation on an array that's provided. 4. Objects, arrays of objects, and object loops. Homework: perform some analysis on an array of objects that describes Samuel L. Jackson's movie career. 5. Basic jQuery selection and page manipulation. Homework: given a page of test cases, use jQuery to turn the tests green by manipulating the page. 6. jQuery events and functions. Homework: write a simple tab menu implementation. Beyond this, we usually cover AJAX, a little bit of canvas, and cookies or local storage, depending on how much time is in the quarter. And this is actually a pretty aggressive schedule: I often get comments from students that they enjoy and appreciate my class, but the pace of it is much higher than they're used to.
This is really awesome feedback! The sample homework is great too. It's interesting that your experience runs counter to some of the other feedback I have seen regarding reliance on jQuery. I mean, I use it every day and hardly write plain javascript anymore, but it is helpful to at least know a bit of it too.
I was looking for something extremely simple, and a coworker recommended PathJS, so I didn't look for another solution. I have not used pager.js, and so cannot make a good comparison. Looks interesting though. I do like that Path doesn't have Knockout as a requirement, which means I can be familiar with it and use it for project regardless of whether they use Knockout or not.
I've used Backbone as well and this is true. If I'd start a new front end codebase probably I'd look into Angular2 and Flux. None of them is 1.0 yet, but they both look really promising. http://eisenbergeffect.bluespire.com/all-about-angular-2-0/ http://facebook.github.io/flux/ 
I would suggest using Intravenous or Cujo for dependency injection and EventEmitter for... emitting events. I've just finished an SPA project using Knockout quite heavily and would argue that the best ways to tackle the problem are to split things up into lots of thin components, have them talk over events, and then use a DI library if you plan to unit test your viewmodels. My two pence.
There are dozens of us! DOZENS!
I really like the syntax of 'html first' and putting it the view logic inside each tag. Other than that, this seems similar to other view libraries. I still think mithril is my favourite 'minimist' library out there. It intelligently covers so many edge cases and the documentation is pretty thorough. Also: this issue is pretty funny, I wonder how they're going to get around all the parsing issues that will undoubtedly come up https://github.com/muut/riotjs/issues/140 Easiest way is probably to only allow code in the top-level tags and don't allow plain text to be floating around. 
Hi /u/fluxusfrequency, please read reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. In short, you should post from a variety of sources, and not just `blog.engineyard.com`. **Consider this your only warning.** Continued posting of only a single source will force us to take action. Thanks for your understanding.
Since the JS one has already been done, I thought I'd post my solution in Python. It's worth noting that you can't do nearly the same method done with JS, as `__init__` has to return `None`. class add: def __init__(self, *numbers): self.total = sum(numbers) def __call__(self, *numbers): self.total += sum(numbers) return self def __repr__(self): return self.total def __str__(self): return str(self.total) print add(3, 4) print add(3)(4)
Any benchmarks? The speed is a selling point for React.
Literally none of that is exclusive to bower, and ng publishes to NPM now
&gt; Everything else is bloat and abstraction from necessity. I agree to a point. &gt;This is a toy. And I also agree with this to a point. I actually believe (and I include myself in this) that there isn't enough expertise in this area to mean that we only need *micro* frameworks like riot. The whole reason angular is so popular is in a ridiculously short period of time you can be productive. I've been playing with riot for about an hour and although I've made a basic implementation of the todo app onboarding wasn't particularly easy. `bower install riotjs` doesn't work yet (no compiled assets) `npm install riotjs` installs version 1.0 and `npm install riot` suffers the same problem as the bower version. (**temp fix**: cd node_modules/riot &amp;&amp; npm install &amp;&amp; make dist) I can think of many use-cases where I'd pick this over the other libraries out there.
The last time I looked at Vue it had so little documentation I didn't even know how to get started. It seems a bit better now, put I feel they lost a lot of momentum from people hopping in "too late."
He didn't say it was on client side
React is a couple years old (plus whatever time before it was open-sourced). My experience more than six months in is that it does everything I want, yet is still easy enough to teach in a couple of hours. Everyone heard "Google uses Angular", but nobody realized that Google's biggest apps don't use Angular. It seems that Google's would rather rewrite Angular from the ground up than attempt to use in for something like their office suite. In contrast, Facebook decided to use React for their most important software and instead of backing away when the first parts were live, they liked it so much that they decided to start converting everything. The ideas in react have been so liked that they have taken over future framework design. The idea of a virtual DOM is now a requirement and one-way dataflow is seen as necessary (in complete contrast to the two-way databinding pushof a year ago). Even existing frameworks like Ember are rearchitecting themselves to use these ideas. I would encourage you to build a sample app. It only takes a few minutes to do so and only a couple hours to learn almost everything. It's not angular (or knockout to a lesser extent) where you build a hello world example only to find that nothing works like that in real apps. What you do in a small React app is the same stuff you do in a large React app because the components are turtles all the way down.
Are you the author? Will this work with a table? If so, I'd love to get rid of a jQuery UI dependency I have...
Because people think the virtual dom is react's main selling point.
It sounds like your project would benefit a lot from structuring the view and data layers. Have you looked into frameworks like Angular, React, Backbone, or Ember? I think the basic gist is that you should send your data over JSON and have a "model" object that stores all of your data, then have a "view" object that renders all of the widgets into the right elements with the right arguments.
How are you applying for jobs? Where are you looking for them?
That diagram is highly suspicious. The only reason stores are not emitting actions as well is to not break the illusion of unidirectionality, since it would mean stores go "backwards" into the dispatcher, right? :/
Could you give me a quick and dirty example of creating/passing model objects, and view objects? Currently I have this: Main "Bar" object is created. It determines that user wants "footer" object. It calls a load to "footer.js" and it's done. "footer.js" then searches for a div with the appropriate ID. If it finds one, it uses that div to create the rest. If not, it creates one and appends it to the end of the &lt;body&gt;. At this point, the "footer" may or may not need to load specific "widgets". However, it needs to tell those "widgets" a.) What type they are, and b.) what they contain (based on the XML that the "footer" loaded.) I can't seem to find a way to load the "widgets.js" file, wait for it to load, and THEN pass it the XML to actually create everything. Particularly when there may be a "widgets.linklist.js, widgets.motd.js, widgets.quote.js" etc. being loaded or not. 
Yes. Something like: $( "myfield" ).keypress(function() { ..do something... }); This is, of course, just one way to do it. If you are looking for the simplest, fastest, then this should get you there. Be careful that you don't move the focus (like with an alert) or the user will have to keep clicking back in the field.
The fact that Facebook use it heavily in production is certainly a plus point, but I'd like to wait and see how people using it in other use cases find it. If nothing else, I think it's usually a good idea to wait for other organizations to make mistakes with a new framework and reflect on them before we start down potentially the same road ourselves. Still, perhaps I will try it out in my next personal project.
Have a look at jQuery's $.when function. That might be shorthand for what you're up to.
Can you put up some sample code? It sounds like there's a lot of ways to do what you need, but without seeing the code it's difficult to give a specific answer.
Nice, thanks.
My understanding so far is isomorphism only provides code reuse benefits if you will be rendering on both client and server for, like you mentioned, older agents or initial loads.
Always really great to see great open source projects. Especially if they fill in very important gaps like email, which is arguably the most important thing on the internet (besides cat videos of course)
Post the code here and we'll have a look at it 
Try something like this, xmlContainers = xmlDoc.documentElement.childNodes; for (var intIndex = 0; intIndex &lt; xmlContainers.length; intIndex++) { if(xmlContainers[intIndex].nodeName !== "container") continue; var strName = xmlContainers[intIndex].getElementsByTagName("name")[0].childNodes[0].nodeValue; alert(strName); } edit: changed my answer
Make our lives easier if you use either one of these to post your snippet: - [jsfiddle](http://jsfiddle.net) - [jsbin](http://jsbin.com)
Posted exactly when I had to do a sortable list that worked on touch devices. Looks fantastic!
Try looking at this http://jsbin.com/voluxexunu/2/edit
Math.random()
Have you considered setting ALL the elements to hide before you allow the new selection. That puts you at a blank state without having to have any stateful information.
thanks for the resources and the outline of the different libraries and frameworks. this reinforces what i have managed to glean elsewhere - that underscore/backbone is a good starting point for branching out. i am definitely still struggling to come up with ideas for projects that are achievable with my current skill set and that would help me grow in my abilities. i had a little help from a redditor on /r/learnjavascript and managed to get a working quiz app going based on an assignment outlined on the javascript is sexy blog. the curriculum there suggested to extend the functionality by using cookies for login credentials but i never got that far.
Maybe I'm crazy, but map and each are different (and should be). Each iterates over a collection and does some action on each item in place, while map iterates over a collection, copies each item, takes action on the item, and then in the end returns a new collection. Or am I thinking of this wrong?
As some of the others have said, stick with the language and don't tie yourself to frameworks. Take LoDash for example. A lot of people use it because it's fast and useful. But... you can get by without it probably 95% of the time. Most of us don't need to iterate 10000+ items looking for performance gains. I use libraries not because I have to, but because I don't have the time to re-invent the wheel. That mentality will hit you like a bag of bricks some day. You'll start to notice how many libraries there are, how many of them are just half-ass hacks or poorly implemented. You'll ask yourself, do I have the time? All I need is X, Y, Z. Do any of my options solve these problems? The reason Angular and React are so popular is because they solve a specific popular problem which takes a lot of time. If you've read about Angular 2.0, they're going to scrap almost everything in favor of looking more like VanillaJs (es6). Tl;dr - use frameworks/libraries if you don't have the time to implement them yourself. Or if you like the framework and plan on using it extensively.
Right, so anything contained outside of a named function is "main". It will just run top to bottom...sort of. In JavaScript there is this thing called hoisting where anything declared in a particular scope is moved to the top. So you don't need to necessarily be concerned with the order in which you declare things, except for your own sanity. Changed it around a bit and added an anonymous function which should make you feel more comfortable and we can pretend its "main". Also, I like the style of verbNoun for my function names. I know C# is prob not like that but that's what I do. function getRandomHexValue() { var hexadecimal = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "A", "B", "C", "D", "E", "F"]; return hexadecimal[Math.floor((Math.random()*16))]; } function getLineOfCharacters(){ var v = ""; for (i = 1; i &lt;= 1096; i++) { v += getRandomHexValue(); } return v; } function getStringOfCharacters() { var stringOfCharacters = []; for (i = 0; i &lt;= 99; i++) { stringOfCharacters[i] = getLineOfCharacters(); } return stringOfCharacters; } (function(){ console.log(getStringOfCharacters()); })() Now if you truly want to make this re-usable you'd make an object or "class" out of it. function HexString(lines, lineLength){ this.lineLength = lineLength; this.lines = lines; this.hexString = ""; this.getRandomHexValue = function() { var hexadecimal = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "A", "B", "C", "D", "E", "F"]; return hexadecimal[Math.floor((Math.random()*16))]; } this.getLineOfCharacters = function(){ var v = ""; for (i = 1; i &lt;= lineLength; i++) { v += this.getRandomHexValue(); } return v; } this.generateString = function() { var stringOfCharacters = []; for (i = 0; i &lt;= this.lines; i++) { stringOfCharacters[i] = this.getLineOfCharacters(); } this.hexString = stringOfCharacters.join(); } this.generateString(); this.outputHexString = function(){ console.log(this.hexString); } return this; } (function(){ new HexString(1,1096).outputHexString(); })()
Posting a link, [jsfiddle](http://jsfiddle.net/), or other code sharing snippet would help people point you in the right direction. A screenshot of the console is very limited in its usefulness.
All the document.getElement(s)By... functions checks every level of the DOM not just the first. So as previously mentioned to get the elements you were expecting you need to check just the children of the first element and filter by tagname.
and with es6, it's even more simple to get by without those. I never use jQuery anymore either. 
10's of thousands doesn't sound like a lot to support IE8 considering the cost of developers.
In all honesty, I'd take a look at mithrilJS. It's only about 1000 LOC, so recreating it from scratch shouldn't be terrible. It would give you a good micro-framework. Certainly better than writing from scratch.
I don't mean this in a personal way, but I've seen this a number of times... &gt; I've been programming javascript proffessionally [sic] for almost X years and yet even this threw me for a loop. ...and I've always asked myself: how long do people consider it takes to get to the point of knowing everything about a language / about programming, such that (almost) nothing will "throw you for a loop"?
Can I ask something? I know my way around web stuff generally, but lately I've been confused with the browser and EcmaScript updates. Like this Chrome beta 41 for example; how do I know whetever normal users and web surfers can run the newest JavaScript stuff that the Chrome beta 41 adds? Where does the basic JavaScript runtime even exist and how and when it is updated? Why is it a Chrome update that adds JavaScript functionality? Because browsers run JavaScript? Wouldn't that be useless then because it's only Chrome 41 that supports string templates? Take for example DirectX - you need to download and install it by yourself and you know you now have bunch of dlls and stuff on your computer. If there is a new DirectX version available - you download and update it manually and you now know your computer supports the latest DirectX stuff. I don't get how this works with JavaScript. Do different browsers have different version of JavaScript installed? Is JavaScript base open source and can I modify, say, the core alert method deep within to make it always alert "LELELE"? Where is the core JavaScript stuff even located? If JavaScript / EcmaScript gets and update such as ES 5.1 -&gt; ES 6, how do I know that everyone can run the new stuff? 
Short version: - Check [kangax](http://kangax.github.io/compat-table/es6/) to see which browsers support the feature you want to use. - When all the browsers you care about support a feature, you can rely on it. If you care about all 4 major browsers, consider Chrome 41 getting you 1/4 closer to being able to use template strings in production. - Some features, like String.endsWith can be polyfilled. This means you write your own version in JavaScript (or more likely, copy it from a place like MDN) that will add the feature to browsers that don't support it natively.
if add function is declared instead of represented as an expression, you can self reference inside of the function: e.g. function add(){ var sum = (this instanceof Number) ? this : 0; for(var i=0,l=arguments.length;i&lt;l;i++) sum += arguments[i]; var x = add.bind(sum); x.valueOf = function(){ return sum; } return x; } 
I would suggest you read Dale Carnegie's How To Win Friends and Influence People book. http://www.amazon.com/How-Win-Friends-Influence-People/dp/0671027034 I've seen it change a lot of socially awkward techies and definitely a quick read. As far as JS jobs, do a couple personal projects such as a portfolio site that displays your design skills, create a game, or some app that would be useful to you. Post the code on github and see where it goes from there. 
OK, will do. Thanks for the head's up.
The *more correct* quote from the ECMA262 spec: "The activation object is purely a specification mechanism." The activation object is a mechanism to define the specification of scope. Implementations probably use some HashMap but they certainly do not expose the scope as an object in any way.
Had a pretty site though. Just no traction.
Thanks for the explanation. Seems like I was confused about the JavaScript engine part. I thought there would be a single, say, "JavaScript.dll" somewhere in our devices and browsers would all use that same base. Apparently it's the job of a browser developer to develop a JavaScript engine for the browser as well.
This looks cool, but for time being Vue.js makes a lot of sense to me.. Maybe I will try it for some side apps
/r/learnjavascript
Yup that's right. We couldn't really have a unified JS runtime (a JavaScript.dll) because there's no definitive implementation of JS. Java has Oracle's JRE, C# has Microsoft's .NET framework, and Python has CPython, but JavaScript is just a standard which has to be implemented. I mean V8 is pretty close since it's the best implementation out there, but it's probably better to have different people using different approaches to making the best implementation of JS. For example Firefox tried out parallel/multithreaded JS for a while, which could have encouraged other browsers to do the same. I'm pretty sure WebGL is another example of an experiment that didn't conform to the standard but was still a great idea.
That's right, Chrome 41 is an incremental update of the browser, and included in this update is the addition of a few more features defined in the ES6 spec. As /u/theillustratedlife mentioned, evergreen browsers (Chrome, Firefox and soon to be Project Spartan ect) allow for more regular automatic updates in smaller chunks instead of less regular major releases. Instead of waiting months, if not years for a big update to include every single change from ES5.1 to 6, these changes roll out steadily over time. This way, browser vendors can react more rapidly to changes in the webdev community. The concern with a single engine (or even a single browser engine), is stagnation through lack of competition, which we painfully witnessed during the predominant years of Internet Explorer. There was little innovation and a slow release cycle. Just think of the massive changes witnessed over the last five years as new browsers (and their respective engines) have successfully emerged (mobile web, hybrid apps, native APIs, [an entire mobile OS for the open web](https://www.mozilla.org/en-US/firefox/os/), just to name a few). The web as a platform is rapidly and forever changing and I think we're in a good position now where browser vendors and standards writers are flexible in nature to adjust to these changes and new needs. Yes, it comes with downfalls such a this game of catch up between browsers, but hopefully it's reassuring to see these new additions and changes take place. 
Proffessionals have standards
Thanks for all the replies guys. You guys are awesome. 
&gt; If you've read about Angular 2.0, they're going to scrap almost everything in favor of looking more like VanillaJs (es6). I thought this was the opposite, in that Angular2.0 will not even be in plain JS but some weird language (AtScript) that compiles to JS.
It would be interesting to read about the insights form this experiment: How did your knowledge of git or version control improved by doing this ? Perhaps an idea for a follow up post
The problem is that 99% of it is going over old ground unless you do something groundbreaking or go looking for the other 1%
&gt; We want our client application to be small. It’s unacceptable that the underlying framework is bigger than the application itself. I'm not even going to address this, I just hope you understand how thoroughly ridiculous this sounds. Honestly. &gt; We want a small framework API that we understand thoroughly. We want to be able to make sense from the stack traces. All the popular frameworks come with too many API methods, properties, and personal flavors. Full control was especially important as we had a plethora of special needs on a fully embeddable forum software. Sounds very similar to React which has a whopping 21 (omg) component level methods, a third of which are lifecycle hooks. &gt; To some extent we questioned whether anyone needed a framework at all. jfc &gt; The syntax was too verbose for our taste: a lot of React-specific idioms, too many colons and curly brackets, a big list of method names to remember. Just too much “boilerplate” for our uses. *21* I memorized more letters than that in kindergarten, sounds and shapes and everything, swear on my life. Overall, 5/10 not modular enough for my tastes
While these are strong and important updates to drive the web forward, when is google going to unbreak its android interface ...? Its gone to hell with material design updates. Having to drop into a menu to refresh? Merging tabs with apps by default? Stop.
I use vuejs a lot and didn't feel that it is hard or the documentation wasnt sufficient
I'm surprised no one has mentioned EmberJS or React. Unless you're starting with Angular 2.0, I would avoid it. 
That's a pretty cool app. Although your code mostly *is* event handlers and DOM manipulations at the moment. Imagine what it'd be like if (like reddit) each page were 30 times as large, and there were several pages worth of scripts you had to write? I think you could do that app in maybe 10 lines with the right framework. And using a framework is good experience anyway. (Also tip, look into JSDoc commenting and also a module pattern so you're not making all your variables globals). 
A worthy alternative on the same principle if you're trying to keep your library usage minimal is [virtual-dom](https://github.com/Matt-Esch/virtual-dom) which gives you the virtual DOM part without the React part.
Don't bother with w3schools (w3fools.com) MDN is a better resource: https://developer.mozilla.org/en-US/docs/Web/JavaScript
Update:- I'm not the author of this. But I think Mary Rose Cook and all her work is awesome. My intention was only to share it to the community.
This works great, thanks. Is there any way to stop it automatically scrolling to the top of the page on each click? 
why
I've used this http://www.kryogenix.org/code/browser/sorttable/ on tables. works well. 
Hrm. You know, oddly enough, for my purposes, I think this will actually end up inadvertently solving another problem I had. Thanks!
I'm not sure what the rest of your code looks like, but I assume you have a click event handler which is on a link and that link has an `href` of "#". If that's the case you simply have to call `.preventDefault()` on the argument that gets passed to your function. Either that or return false in the function.
This is where I give OP the benefit of the doubt. Because he's asking about it I assume he's already done the relevant case-specific testing - something we don't have enough information to do. And, in fact, before you wrote that post he had said elsewhere in this thread that he is programming for a very memory-constrained system.
FWIW, I think one of the reasons IE is being renamed ("Project Spartan") is because they are going to be evergreen now too.
I do indeed. Thanks man. 
thanks for chiming into this thread! programming isn't something i pick up easily, but i am extremely encouraged by how helpful people in this field are to newcomers. i would love to know why you chose not to use jquery and what if anything you use in its place. as i have been reading up on this it seemed like jquery was a no-brainer if you wanted to do any kind of animations. i know these things are available in plain js but it just looked incredibly complex compared to how things can be implemented in jquery. other than animations, i'm not sure what i might want jquery for, as i can figure out how to do most of what i want in plain js. i would love to hear your reasoning behind this comment - why you avoid jquery and what type of stuff *would* you use it for?
C was just too performant.
couldn't help it: [Hipster Hacker](https://twitter.com/hipsterhacker/status/401409240578797568)
wow, just, wow. Hard to believe we've come full circle.
This seems a bit roundabout, unless there's something I am missing here? I notice that windows instructions are missing, is this a feature that's not available on other platforms?
&gt;Sometimes, I can only understand something by implementing it. So, I wrote Gitlet, my own version of Git. I pored over tutorials. I read articles about internals. I tried to understand how API commands work by reading the docs, then gave up and ran hundreds of experiments on repositories and rummaged throught the .git directory to figure out the results. &gt; &gt;I discovered that, if approached from the inside out, Git is easy to understand. It is the product of simple ideas that, when combined, produce something very deep and beautiful. So this person did everything to learn Git "from the inside out" *except read the source code.* Hmmmmmm... 
I believe that it was a rhetorical why.
Also, Node.js exists. This could save yourself a daemon and a whole lot of resources if you're server is already only running Node.JS.
I respectfully disagree. A modern app has 4 core aspects: * Application Core * Interface * Storage * Service (transmission, routing, negotiation) A well built application will separate those four as much as possible. DOM interactions (which are going to exist no matter what) should only be found in one of those four aspects of the app (interface), and even still may only be present in a few flavors of many different interfaces of that aspect. Commonly I find that people generally don't like the DOM as an API. Of people I have worked with in the past I have found one of the following traits associated with the most vocal DOM haters: * The don't understand the DOM as well as they might claim * Their experience debugging DOM related problems is shallow, at best * They are new to JavaScript and come from something like Java * Their code is horribly organized with regard to an API &gt; It might be physically possible to query a database from the client using AJAX (client ↔ database) but you should never do that because it means your database is exposed to the entire world so anyone can add or delete data from it. I also take issue with that. You can implement access controls so that access by a certain means is limited in some way, for example read only or only parts of the data are available. The only worry is to ensure that the public facing access point is not vulnerable to application vulnerabilities that allow unintended behaviors.
i like the idea of building an address book and i think i will give it a shot. i recently signed up for an account at cloud9 (cloud IDE) and this gives me a good goal for testing the waters there. i have absolutely no idea how to use node right now and only a cursory understanding of what REST and nosql are.... i've got a lot of work to do! thanks for the ideas! 
I believe reading source is what she means by going through the .git directory
Hopefully you aren't automating git commits
&gt; The concern with a single engine (or even a single browser engine), is stagnation through lack of competition, which we painfully witnessed during the predominant years of Internet Explorer. There was little innovation and a slow release cycle. It's always a concern, but a centralized JS engine could actually serve to promote new core language features, while still leaving browser vendors the ability to iterate and innovate. If this hypothetical centralized engine updated independently of the browser it would help the fragmentation issue, and let new standards iterate faster. Browsers would still have to implement the DOM API and other surrounding APIs (anything not a core JS language feature), and they would still have reason to compete. Microsoft's unwillingness to innovate after achieving domination is what stagnated the web; however Google and Mozilla are fundamentally different companies who strive to push the web forward - something Microsoft never did (it wanted to push it's own vision of the web). Open collaboration and effective standardization are a key part of why the web has been changing so rapidly recently, and centralizing the engine talent down to a standard implementation with independent rapid releases, could ultimately be a net benefit. Of course, this is fundamentally pie in the sky thinking, and given that Google and Mozilla would likely be the only implementors [it would leave us in a difficult position for a good while.](http://xkcd.com/927/)
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 1184 times, representing 2.4184% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cnyjkum)
You mean [this source code](https://github.com/git/git)? You'd need to be very comfortable in C to have that be any help.
It's the JS library we built for our own needs at Muut.com (fairly large scale these days). We simply like to share the work *for free* that we're doing internally. Also we haven't really been spamming. We didn't post this to reddit or anywhere else aside from HN. Not that I think there's a problem if we were sharing stuff we're giving for free all over the place. If it's not useful for you, no problem! It's free stuff.
 gulp.task("default", function(){ gulp.watch("./src/**/*", function(){ shell.task(["git commit -a -m 'stuff'", "git push -f"]); }); });
If you want to do stuff with git on node.js then there are more richly featured modules on npm. You can get all streamy and stuff, run it in browsers and all the things. 
Don't master the framework, master the concept. They're transferable from one framework to another although each framework do it a little differently. But I agree, it can be a little overwhelming from the new technology that's coming to front-end. But it's a good thing. 
http://tom.lokhorst.eu/2010/09/why-libraries-are-better-than-frameworks
Yo this is a great writeup. I really appreciated the balance between mathematics and english. The article also had a nice flavor of banter that made it seem more alive and written by a human being with actual feelings about things. I would love to know your reasons for doing this work. I suspect one doesn't do all this background research and experimentation simply to write a blog post. I have personally felt EXACTLY the way you felt about the experience of searching for physics libraries in javascript. If this should happen to mean that you are looking into authoring some of this stuff yourself please let me know as I would be extremely interested in working with you on that project. 
Web Components( http://webcomponents.org ) is an emerging W3C standard that is already implemented in chrome and ff in some form and safari has support for html template piece of Web Components.
Place for small libraries: http://microjs.com/
Doesn't work. Tons of errors in the console.
I don't think so. http://i.imgur.com/UgfZFjS.png
http://i.imgur.com/zaJH4MX.png perhaps they only work as non-inlines
They are *mostly* the same... The "problem" is kangax's article is a bit old now. It is using the terminology that was defined in [ECMA262 3rd edition](http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf) (see section 8.6.1). At that point, `ReadOnly`, `DontEnum`, etc were the names used for those attributes. And it wasn't terribly important back then because those attributes were *internal to the engine*, not available to the user. In [ECMA262 5th edition](http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf) (again section 8.6.1), the names `enumerable`, `writeable`, `configurable` were used instead probably thinking they were *better* names now that such attributes would actually be available to the user via the also new `defineProperty` function. If you look at the bottom of the MDN entry on `defineProperty` you linked, you'll see it was introduced in the 5th edition.
&gt; I believe reading source is what she means by going through the .git directory I assumed that meant literally looking at the git repo's internals as represented by the contents of the project's .git directory
I've heard good things about [Mithril](http://lhorie.github.io/mithril/) and [Riot.js](https://muut.com/blog/technology/riotjs-the-1kb-mvp-framework.html)
Look at the compiled JS, you'll see why `B` is not a constructor: var A = function A() { this.classB = new B(); }; var B = (function () { var B = function B() {}; B.prototype.myMethod = function () { console.log("test"); }; return B; })(); So you are using `class` correctly, but `B` is not available when `A` is defined.
Skills for decades? Consider learning backend dev. Anyhow, catch up on [Shadow DOM](http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/) to see what all these frameworks are *trying* to do prematurely. Then go learn jQuery, jQuery, and some more jQuery. If you're in a hurry to jump ship, check out [React](http://facebook.github.io/react/) or [Dust](http://linkedin.github.io/dustjs/). Frameworks will keep you working within the constraints of another developer (or team) mentality. We know this because there are several frameworks attempting to do the same thing, with different opinions on how to do it, and teams dedicated to a certain one. Which do I use? None of them.
Actually, your solution is the best, for another reason. I also needed to go through and create an array of "widgets" found in a container. With your method, I can do that in one pass.
IMO showing your experience with Angular should be sufficient; while you may be tired of learning new frameworks, it shows that you can and would be a versatile employee
Not that I know of. But fun fact — back in the days, Blackberry browser implemented _Activation Object_ in such way that it would inherit from `Object.prototype`, meaning that it was regular JS object (just not directly accessible). Because of that you could define something on `Object.prototype` and it would be accessible as local variable :) Object.prototype.x = 'outer'; (function(){ var x = 'inner'; (function(){ alert(x); // alerts 'outer' })(); })(); In other words, they leaked implementation detail and of course violated scope rules (`x` should be resolved to 'inner'). See http://kangax.github.io/nfe/#activation-object-in-blackberry-browser for more
You're very welcome - infact I just watched the google summit bit on it (or whatever it's called) they are making big improvements to polymer, I would consider waiting until it hits a 1.0 to really work with it, but it has some awesome ideas. Also, in the summit talk they mentioned you can get polyfills for shadowdom.
My first couple jobs came from job ads posted to a mailing list the univ's CS department ran. The jobs were all entry-level/intern-type. Will still take time to find one, but in terms of breaking into industry, that worked for me. Might also try breaking into tech support at a smaller company. As for the other part. You can be good at your job. You can be experienced. You can be friendly. By and large, you need at least 1, and usually 2. You're going to be uncomfortable with it and that sucks. It does. But if you don't have any demonstrable talent or experience, improving socially is your best bet. You don't need to be a social butterfly. You don't need to small-talk. You do need to be able to talk to people, look people in the eye, and not scare people off. Not knowing what your last coworker said or saw, question what constitutes a serial killer vibe? Is it how you're dressed? Do you keep headphones in all the time? Honestly answer that question: what made him say that? You're never going to want to change that, you'll feel defensive like it's dumb or shouldn't need to. And then do it anyway. Because THAT is social development. EDIT: grammar.
Sorry this is fragmented - here is the talk on polymer https://www.youtube.com/watch?v=0LT6W5QVCJI
`input.value = ''` in the example on the home page is very un-react-like. You don't ever have manual DOM updates in pure React code unless you're interacting with some 3rd party code that doesn't follow React conventions. add(e) { var input = e.target[0] this.items.push(input.value) input.value = '' } I guess in my mind "no dom updates" is the core selling point for React, and this 'react-like' library violates that principle in the first example displayed on the home page.
[Related.](http://javascript.about.com/library/blxhtml.htm) I believe the history is that, in the off-chance that your browser didn't support `&lt;script&gt;`, then commenting-out the code would prevent it from being rendered to the screen.
I have always wanted the ability to drop-in UI components (as well as develop them for others to drop-in). Shadow DOM will get us there eventually! [Here](http://glazkov.com/2011/01/14/what-the-heck-is-shadow-dom/) is another good article on it. I see some murky waters in the near future for frontend devs, possibly a few ice bergs even, but after that we should be smooth sailing. Hang in there :)
Hi /u/cburgdorf, please read reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. In short, you should post from a variety of sources, and not just `thoughtram.io`. **Consider this your only warning.** Continued posting of only a single source will force us to take action. Thanks for your understanding.
https://ampersandjs.com/
Not bad advice. It could be [Meteor](https://www.meteor.com/) or [Derby](http://derbyjs.com/) coming up as the next fad, but then again it could be Angular 2.0 which means you're back in the same boat, with a different paddle. Did your jQuery knowledge pay off?
If you're comfortable with Angular, Backbone will seem a bit tedious but you'll be fine. Don't forget to immediately make them go Marionette/Stickit. It's the same from framework to framework.... after learning a couple you get good at tracking the differences and you start to put more code into your own modules; slimming the UI code down further.
How can I get started on ES6?
Check out [~~6to5~~ Babel](https://babeljs.io), download [Chrome Canary](https://www.google.com/chrome/browser/canary.html), start using [io.js](https://iojs.org).
The problem is that frameworks like Angular, libraries like jQuery, languages like JavaScript, platforms like Chrome, operating systems like Windows... they are just tools. They aren't the work. A carpenter isn't a hammer or saw user. A doctor isn't a scalpel user. An architect isn't an AutoCAD user. A photographer isn't a camera or Photoshop user. The work is to fulfill goals. You have to learn what sort of goals you're good at fulfilling. I'm particularly good at making sense out of numbers. This turns out to be a wildly and widely applicable skill. Are you particularly good at figuring out how to arrange information so people can understand it more easily? That's called graphic design. Study that. Not Adobe Illustrator. Not Cocos2D. Not Objective-C. If all you do is take inputs A and churn them through the framework du jour into outputs B as you're told to do, then you yourself are just a tool for someone else who is doing the real work, fulfilling the real goals. COBOL programmers are obsolete today not because they studied COBOL, but because that was all they studied. They let themselves become tools to the real people doing the real work and never became anything other than COBOL programmers. Some people are fine with that. I'm not.
I totally agree with you that it's the carpenter not his tools. I just have to work on my craft without focusing too much on the ever changing tools. I also think that COBOL programmers are the extreme example of not wanting to learn new things (or maybe they just &lt;3 old banking systems?). I'm willing to learn and keep learning new things. I'm asking everyone how I can deal with the rate of changes in the community.
*Not* Derby, trust me. I was [involved](https://github.com/lefnire?tab=repositories) on the project, ran the only [auth module](https://github.com/lefnire/derby-auth) for a while (may be superseded). I built [HabitRPG](https://habitrpg.com) on Derby - was there for a year on the largest AWS instance I could afford (because the framework doesn't scale horizontally), restarting the server hourly due to framework memory leaks. I lost tens of thousands of users to the experience, and we finally migrated to Angular + Express, sputtering and gasping for breath. We actually celebrate the migration within HabitRPG as a "holiday" called [Derby Day](http://habitrpg.wikia.com/wiki/Derby_Day). However, Firebase &amp; Meteor are platforms I'm very interested in. jQuery paid off well enough, was worth learning - though I'm seeing more and more frameworks weening off it. I actually think MV* platform knowledge will pay off well, as getting the basics there will transfer from one to the next. Take React - it's a modularized V in the stack, and coming from Angular the transition would be much smoother than starting from scratch. 
Not entirely sure jQuery will come to a stop for webapps just yet. I built these with jQuery, though I do agree we could use some data binding to really bring the code together: https://www.youtube.com/watch?v=dfQ1sOnCvHs https://www.youtube.com/watch?v=bYpOtAr1WiI That drag-drop and zooming UI stuff is not done with jQuery UI, it's custom built for CSS 3D transforms like those provided by impress.js. These apps gracefully work offline too. This one I built with pure Javascript, it ran on a Desktop, iPhone or iPad and could stream mp3's while driving around town: http://glassocean.net/nest/ It had scrobbling and supports Winamp playlists.
... by learning the right things.
Thanks for the insight, very useful. Derby Day gave me a laugh :) Big fan of RPGs by the way! Let us not forget Derby is still pre-1.0, but I hear ya. EDIT: checked out your game, amazing idea. If you need free music I produced some under creative commons license [here](http://glassocean.net/music-productions/song-releases/). Some can be heard on radioreddit. Soundcloud preview: https://soundcloud.com/iosys/iosys-strain https://soundcloud.com/iosys/iosys-abandoned-forest-trail
Here is my 2 cents: 1. Check your source. Lint those files away my man. 2. Check again your source. Does it run while non-browserified? AKA lots of &lt;script&gt;s. 3. Does it run bundled, unminified? 4. Does it use motherfucking angular? use a transformer (google "browserify transforms") 5. Does it use any node module that has an issue with browserify and/or require special implementation? Look at how brfs is handled. (this is the google of googles here) 6. You can test-run your bundles with node-enchilada, so you don't have to build or pipe your bundles with gulp/grunt/make/any build routine.
I enjoy working with browserify and npm, without big frameworks.. it brings back the feeling of consistency, it just feels friendlier to my brain. Obviously there is some learning curve, but it makes sense. And working with tiny modules from npm is great. 
I've been into front-end development for more than 13 years now. I was there when you had to check if `document.all`existed to distinguish your browser, back when all this shit was called DHTML, back when `div` elements were also called _layers_... I've seen the evolution of front-end technologies and, honestly, the last 6 or 7 years have been **chaotic**. I honestly think that the front-end scene in general, and the JavaScript scene in particular has been saturated with hipsters that need to follow new trends every week. It's great to have evolution, but changing things for the sake of it is absurd. Are some things really that bad to ditch them, when we were using them a week ago? Hey! Grunt is the devil, use gulp! Angular? The 1.x branch is dead! Use something else! Etc, etc, etc. There are so many examples out there, I'm sure you know some. I'm sorry, but I'm not going to change my entire stack every month just because some retarded hipster and his beard have decided, while hacking on his macbook on a Starbucks of San Francisco, that jQuery is bad or that we should design our CSS files using a smart-tv first design. 
This!!!!! I hear this constantly, "oh i need training on this before i can user it." "I don't have time to learn a framework" "Can't i just program it in WebForms?" What did you get into this profession for writing "hello world" applications? We are software engineers, people give us problems and create solutions with what ever is available to our tool kit.
Two main issues I can see just from a quick glance. First... `source` is never defined, anywhere. That's where you're getting your `ReferenceError` from. I think you probably mean `video.source`? Second... You're using `i` inside your handler. Sure you don't mean to use `1` there? It will *work* as you've written it but not for any meaningful reason.
I don't agree. Take C++, for example. We've had the same standard for more than ten years and it's not been bad. Then C++11 came, and C++14 after that. Those are great additions, some of them you could use before with things like Boost. But no one is forcing you to use them. No one is gonna say your skills are old if you only use the STL, some Boost and vanilla C++98. In job postings, you'll likely find requirements like "Experience with C++", or "Experience with C++ and X and Y libraries". For front-end development is quite the opposite. It's always "use the latest technology", always "are you using Grunt? That's old", always "Experience with Angular" -- What about vanilla JS?
Firefox Nightly/Dev supports even more ES6 than Canary. If you've not played around with the new dev tool or Scratchpad, you should check it out.
The problem is it's a bottomless toolkit with more and more new tools to learn. I'm a backend dev, mainly PHP and Laravel framework, but I have to do lots of frontend stuff too. I'm okay in Angular and started using LoDash recently but when I looked at Ember it just seems so tedious. The documentation is a mile long.
Instanly went to console. CTRL+V (Array(16).join( 'wat'-1) + " Batman"; ) Enter LOL! The bitch happens when you're that person that reads those out fully. I get it, its not a number. I had a friend give me the question of "What is the difference between i++ and ++i" and ever sense, even though it doesn't matter, I always use ++i. (unless of course I need i++).
Your code works fine: http://6to5.org/repl/#?experimental=true&amp;playground=true&amp;evaluate=true&amp;loose=false&amp;=&amp;code=class%20A%20%7B%0A%20%20constructor()%20%7B%0A%20%20%20%20this.classB%20%3D%20new%20B()%3B%0A%20%20%7D%0A%7D%0A%0Aclass%20B%20%7B%0A%20%20myMethod()%20%7B%0A%20%20%20%20console.log('test')%3B%0A%20%20%7D%0A%7D%0A%0Avar%20a%20%3D%20new%20A()%3B%0Aa.classB.myMethod()%3B%0A%0A
&gt; any place that sees them as mandatory isn't somewhere you want to work. Well he may be going in the right direction but that is sort of generalizing.
Well, one of the main reasons people used jQuery was not because it's more simple to code, but the inconsistency between browsers and the DOM api. jQuery made life much more simple back then. But now, browsers have come a long way and most of the DOM api vanilla JavaScript things work well now. Now you can still use jQuery just fine, many new library's/frameworks still support its use. But vanilla JS is faster as your not going through a 3rd party library for every little thing and I actually like native syntax way better. jQuery is never needed, I don't think I've used it in quite awhile. Also, as far as other developers, I don't mind people using jQuery, IF they know vanilla JS, but when someone comes along with 'JavaScript' all over their resume and come to find out they only know jQuery, it's rather annoying. Learn actual JavaScript, learn it well. Then you can adapt to any framework/library. Even coffeescript is stupid simple to pick up if you know vanilla JS. 
I feel like most of the framework churn right now is due to the obsolescence of jQuery and the lack of a mature ecma6 framework. Its not unlike back in 2006-07 when jQuery was duking it out with Script.aculo.us Moo tools and YUI to see what would be the dominant framework. My advice would be to help fix the problem. Find an open source library, learn its ins and out &amp; work to improve it to work with ecma6 features. Even if your framework isn't the winner you will be a much better programmer in the end. In programming staying still with your programming knowledge is moving backwards. You need to be constantly learning to survive in this industry.
Do you guys use this in production? It looks cool. I was familiar with Traceur and it being backed by Google gives you a certain sense of safety, but it looks like 6to5 supports more features and also has a browserify transformer. Shame that it doesn't support Proxies. But they are trivial to implement on your code. Somewhat
Not yet for anything live, but soon. My team recently added the transforms for Traceur and 6to5 to our Browserify compilation.
Ah cool, thanks a lot. 
Incidentally, I've had a beard and worn flannel for about that long, too. We just called it "living in a small, rural town" back then.
Why would you use both? Is there something Traceur can do that 6to5 cant?
No, [the opposite, actually](http://kangax.github.io/compat-table/es6/#_6to5). We just figured it would be good to give both a try.
Here's a brief explanation. [].toString(); //=&gt; "" [] + [] "" + [] "" + ""; //=&gt; "" {} is sometimes an object literal, but at the beginning of a statement, it becomes an empty block instead. Number(""); //=&gt; 0 {} + [] //block goes away + [] //the {} is ignored since it's empty + "" //convert to number 0 Note the parenthesis. If they weren't there, you would get a syntax error in the console (because the block goes away and '.toString()' isn't valid JS). ({}.toString()); //=&gt; "[object Object]" [] + {} //now an object literal instead of a block "" + {} "" + "[object Object]" //=&gt; "[object Object]" While '+' tends to convert numbers to strings, '-' (minus) tends to convert strings to numbers. In JS, 'NaN' is 'not a number' and is there because JS uses only 64-bit floats for numbers and the IEEE spec requires NaN (that's also the reason for '-0', 'Infinity', and '-Infinity'). NaN is toxic. Any operator that tries to do anything with NaN returns NaN instead. - "1234"; //=&gt; -1234 (a number) Number("[object Object]"); //=&gt; NaN - [] - "" - 0; //=&gt; -0 (note: -0 === 0 in JS according to the spec) [] - {} "" - {} "" - "[object Object]" 0 - "[object Object]" 0 - NaN; //=&gt; NaN {} + {} + {}; //=&gt; "[object Object]" And for sake of completeness {} - {} - {} "[object Object]"; //=&gt; NaN "wat" - 1 NaN - 1; //=&gt; NaN 
Nice to see some love for Elm here :)
Damn, you're gettin' old. As am I. I remember layers, and CSS 1, and I remember building websites with framesets, and using preloads for mouseovers....remember how we used to put HTML comment tags inside `&lt;script&gt;` tags so that browsers that didn't support JS would ignore it? Sigh. I personally like the JS evolution. Some things go a little too fast, yeah, but I tend to adopt the things I think will really shine, or the things that already do. Grunt vs Gulp? I never adopted Grunt, but I took to Gulp immediately. Angular? The 1.x branch won't die for quite a while. jQuery - it was created for a purpose that is becoming unnecessary. Tech marches on. Don't change your stack every month, but don't discount the innovations that are out there. Like everything, the good ones will rise to the top, and the bad ones will disappear.
Won't it be like 10 years until we can use ES6 though*? I support back to IE7 right now (close to dropping it), which came out in 2006. IE11 doesn't support ES6 yet, though the dev preview supports most of it. *I use "we" to mean developers making websites for broad audiences. If you're making sites just for mobile, or just for geeks, or you're making something other than websites, like node/io apps, this doesn't apply.
All these dudes are just trying to be you.
Well, I am pretty awesome, so I can sort of understand why.
For fun, try doing a plain javascript es6 project with no libraries and keep in mind the MV* pattern as used in Backbone. Aim for compatibility with latest Chrome, Firefox, and IE. You may find JavaScript with no framework is not difficult but instead a remarkably well done platform.
Unfortunetly I have never used Phaser so I can't be of much assistance, also your question is somewhat vague... A quick search on google comes up with this tutorial http://blog.mega-art.com/getting-started-with-phaser-and-webstorm-on-osx/ You also might find some similar questions at stackoverflow, http://stackoverflow.com/questions/tagged/phaser+javascript
well yeah but if i wanted to do a es6 app without spending all my time consulting the kangax compatibility table and working around the browsers that are lagging behind, that means i need to pick an es6 transpiler, an es6 module loader polyfill, i need to pick a package manager to install them, i need to pick a build tool to spit out browser-compatible es5... I'm tired and I echo op's sentiment. I come from a strong CS background and I feel productive in almost every language I've met, except for javascript. With javascript I spend 90% of my time trawling github issues and stack overflow questions and watching the constant stream of unanswered questions on all js-related channels on freenode...
It's already been touched on by a couple other comments but here is how I avoid being overwhelmed when looking at the morphing front end landscape: just keep getting better at two things, javascript itself and design patterns. Maybe a third thing which is CS topics that we could all learn more about like algorithms, algebra, etc. I think it's so funny/annoying that many job postings have 'X years using backbone is a must'. My issue with it is if I know js (really solid/deep understanding I mean) and I have plenty of practical knowledge on design patterns then I should have no issues getting into a backbone code base. Sure I'll be referencing the docs heavily at first, but that's just referencing syntax and 'how backbone does this'. I think a requirement of having X years in Y framework is garbage *unless* the job is for someone who will be playing an architect type role where framework specific knowledge will be important in making design decisions. Sorry for the text well, hit a button. Tl;dr: chin up buttercup, just be good at the language and at software in general.
It's just emulation. Instead of running on actual hardware, you write a program that simulates a 386 (or whatever) CPU, along with the associated trimmings of such a vintage system (BIOS, VGA, hard drive, etc.) That program reads the hardware instructions one at a time and runs a simulation of what the real hardware would have done in response. This program doesn't need access to any actual hardware to do this as every aspect of the simulation is completely emulated, so it has no problem running in the browser. It can display the results of the simulation using a HTML canvas element since that's just a bitmap image that's regularly updated, and it can take keyboard and mouse events from the browser and funnel them into the simulation as if they were real hardware events, and so on. In this case they took an existing emulator (DOSBox) that normally runs as native code and ported it to the browser using Emscripten. But that's really just an implementation detail which is not essential to the story; you could have sat down and written it in JavaScript from scratch, it just would have taken you a lot more time than doing it this way.
I generally Dev it to standard and test afterwards. If I find an error, I determine if I need to polyfill and go from there. I find JavaScript incredibly easy to work with and other languages just too verbose, or cumbersome. But we all have our calling, so I can never convince someone to my way unless they want to be there. I've met a lot of folks who bring the (Java mostly) classical inheritance thought process drilled into them from college into a JavaScript project and they screwed a lot of stuff up. Maybe focus more on supporting the work of the front end guys if you don't feel comfortable with it? I have some high quality service guys that just don't understand how I do my job and sometimes I echo the same back to them. You just gotta find your groove.
Sort of... See http://www.reddit.com/r/javascript/comments/2s2cvi/jquery_versus_reactjs_thinking/cnlwk8c That component I wrote in another thread. If you consider AccordionList as the template, you can feed it a list of children and it will render them how the template desires. You can take the children you are given and render them however you like. You can pass them to another component if you like. You could even give AccordionList another component via the property to use as the template (as confusing as that would be...) Edit: you could potentially pass a template as a child and render with that as well. The options are pretty large.
Yeah sorry that my question wasn't the best wording but using stack overflow helped
Nice! Thank you for the link. 
wait until you have 3 decades worth of mastered technologies that are now barely interesting history. then we can talk ...
Ember. Meh.
(ง ͠° ͟ل͜ ͡°)ง
You see things like [this](http://www.theie7countdown.com/) and get hopeful.. only to acquire clients who require legacy support. But, to be honest, if they're willing to pay the fee - who cares?
I hate to say it, but I'd just suggest you get used to it. It's been this way in frontend tech for a decade, and it's just getting faster every year. It's pretty normal to have to relearn whatever language you work in every 3-5 years, and in fronted, it's probably every 18-36 months that you have to retool because the technology moves on. Here come Web Components! And there's a host of new browser technologies about to hit right after that. It's so much better now than it used to be. You used to have to create your own libraries, or hodgepodge a couple of libs together to make stuff work. Then jquery came along and standardized the web. Still, only 1/2 of 1% of websites run on a framework like angular.js, so there's going to be a TON more as these techs mature... the whole set of stacks are in their infancy. Obviously, focus on the core compsci and javascript, but beyond that, it *is* exactly as you describe. And it's not going away. Pros and cons of that though. Imagine if it took a decade to become and expert, and that was it. That would be a hard business to break into. I just roll with it. A lot of companies wait for stuff to mature before investing in the stack — that's why there is an enterprise market for things. People wait until there are clear winners before bringing them into corporate projects. The bleeding edge is always full of emerging technologies, most (not many, most) of which will fall away and never gain broad acceptance and which can be very difficult time sinks for programmers that yield less than the investment it took to learn. There is also the counterpoint of technologies that gain broad acceptance and build incredible markets that "age in place" and take entire careers and people with them. There's a ton of languages and frameworks that are like that: a good place to get stuck. That's just a risk of working in tech. You could kick back and only invest in things that get momentum, which would alleviate your learning curve somewhat and definitely expose you to the risk of becoming a known leader in a legacy technology platform that's increasingly irrelevant. You would risk missing major advancements and becoming a dinosaur quickly. Or you could burn yourself out working through every new advancement to hit, and keeping up with the w3c specs, and basically just do it for as long as you can before you burn out or become irrelevant (see: http://www.sfgate.com/business/bottomline/article/In-Silicon-Valley-age-can-be-a-curse-4742365.php). Striking that balance between investment of time in technologies that are emerging, and not getting over invested in things that may not stick is one of the hardest things in Web Engineering. But honestly, what an exciting industry with so much to learn and so many new ways of doing things all the — at least you won't get bored! I think the biggest challenge is making sure you take advantage of your time in tech, because your career won't last forever in this business.
But it reported 'hello' as undefined..... it wasn't a comment.
You monster ;) It's the greatest temptation for bored corporate coders to write their own frameworks. I wrote a couple myself ;) And I hate to admit you're right when you say we need a different job to be free and code for fun again. I for example want to be engine driver, but I cannot afford it for various, country specific reasons. Ok, it's really not that bad. Our job as good (if not 1337) corporate coders is to use whatever new tool is popular this season and do our jobs the best we can. It's always a little challenge, always a little stress involved. But it can be fun anyway. I chose to continue at my job, to develop Open Source in my spare time and to look for another (more interesting) job at the same time. Dealing with burnout is tough. There are no easy solutions.
You got the syntax of that method completely wrong. When used in real XHTML, that hides the script completely. The minimal correct way of writing that which works in modern HTML browsers and real XHTML &lt;script&gt;//&lt;![CDATA[ ... //]]&gt;&lt;/script&gt; The full, theoretical approach designed to work for every browser that ever existed is: &lt;script type="text/javascript"&gt;&lt;!--//--&gt;&lt;![CDATA[//&gt;&lt;!-- ... //--&gt;&lt;!]]&gt;&lt;/script&gt; Although such techniques were widely used for a while, it was never actually needed. It was more theoretical exercise done to show how what it would take to effectively hide scripts from obsolete browsers and still work in real XHTML. Yet, by the time it came out, there were literally zero browsers still in use that needed scripts to be hidden in HTML; and real XHTML needed to be served with an XML MIME type, like `application/xhtml+xml` that almost no-one used and which would not actually be supported by any obsolete browser anyway. The reason it got used at all was because people copied and pasted it as boilerplate without actually thinking about how it works or what it was for. If using real XHTML, then all you need is: &lt;script&gt;&lt;![CDATA[ ]]&gt;&lt;/script&gt; But that will not work in HTML. Demos: 1. [XHTML document](http://html5.lachy.id.au/output?data=%3C!DOCTYPE+html%3E%0D%0A%3Chtml+xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxhtml%22%3E%0D%0A%3Chead%3E%0D%0A%3Ctitle%3EXHTML+Script+Example%3C%2Ftitle%3E%0D%0A%3C%2Fhead%3E%0D%0A%3Cbody%3E%0D%0A%3Cp+class%3D%22one%22%3EScript+%231+did+not+execute.%3C%2Fp%3E%0D%0A%3Cp+class%3D%22two%22%3EScript+%232+did+not+execute.%3C%2Fp%3E%0D%0A%3Cp+class%3D%22three%22%3EScript+%233+did+not+execute.%3C%2Fp%3E%0D%0A%3Cp+class%3D%22four%22%3EScript+%234+did+not+execute.%3C%2Fp%3E%0D%0A%0D%0A%3C!--+1+--%3E%0D%0A%3Cscript%3E%0D%0A%2F%2F%3C!--%5BCDATA%5B+%0D%0A%0D%0A++++document.querySelector%28%22.one%22%29.innerHTML+%3D+%22Script+%231+successfully+executed%22%3B%0D%0A%0D%0A%2F%2F%5D%5D--%3E%0D%0A%3C%2Fscript%3E%0D%0A%0D%0A%3C!--+2+--%3E%0D%0A%3Cscript%3E%2F%2F%3C!%5BCDATA%5B%0D%0A%0D%0A++++void+1+%3C+2%3B+%2F%2F+Without+the+CDATA+section%2C+this+would+cause+a+syntax+error+in+XML.%0D%0A++++document.querySelector%28%22.two%22%29.innerHTML+%3D+%22Script+%232+successfully+executed%22%3B%0D%0A%0D%0A%2F%2F%5D%5D%3E%3C%2Fscript%3E%0D%0A%0D%0A%3C!--+3+--%3E%0D%0A%3Cscript+type%3D%22text%2Fjavascript%22%3E%3C!--%2F%2F--%3E%3C!%5BCDATA%5B%2F%2F%3E%3C!--%0D%0A%0D%0A++++void+true+%26+false%3B+%2F%2F+Without+the+CDATA+section%2C+this+would+cause+a+syntax+error+in+XML.%0D%0A++++document.querySelector%28%22.three%22%29.innerHTML+%3D+%22Script+%233+successfully+executed%22%3B%0D%0A%0D%0A%2F%2F--%3E%3C!%5D%5D%3E%3C%2Fscript%3E%0D%0A%0D%0A%3C!--+4+--%3E%0D%0A%3Cscript%3E%3C!%5BCDATA%5B%0D%0A%0D%0A++++void+true+%26+false%3B+%2F%2F+Without+the+CDATA+section%2C+this+would+cause+a+syntax+error+in+XML.%0D%0A++++document.querySelector%28%22.four%22%29.innerHTML+%3D+%22Script+%234+successfully+executed%22%3B%0D%0A%0D%0A%5D%5D%3E%3C%2Fscript%3E%0D%0A%0D%0A%0D%0A%3C%2Fbody%3E%0D%0A%3C%2Fhtml%3E%0D%0A&amp;type=application%2Fxhtml%2Bxml) 2. [HTML document](http://html5.lachy.id.au/output?data=%3C!DOCTYPE+html%3E%0D%0A%3Chtml+xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxhtml%22%3E%0D%0A%3Chead%3E%0D%0A%3Ctitle%3EHTML+Script+Example%3C%2Ftitle%3E%0D%0A%3C%2Fhead%3E%0D%0A%3Cbody%3E%0D%0A%3Cp+class%3D%22one%22%3EScript+%231+did+not+execute.%3C%2Fp%3E%0D%0A%3Cp+class%3D%22two%22%3EScript+%232+did+not+execute.%3C%2Fp%3E%0D%0A%3Cp+class%3D%22three%22%3EScript+%233+did+not+execute.%3C%2Fp%3E%0D%0A%3Cp+class%3D%22four%22%3EScript+%234+did+not+execute.%3C%2Fp%3E%0D%0A%0D%0A%3C!--+1+--%3E%0D%0A%3Cscript%3E%0D%0A%2F%2F%3C!--%5BCDATA%5B+%0D%0A%0D%0A++++document.querySelector%28%22.one%22%29.innerHTML+%3D+%22Script+%231+successfully+executed%22%3B%0D%0A%0D%0A%2F%2F%5D%5D--%3E%0D%0A%3C%2Fscript%3E%0D%0A%0D%0A%3C!--+2+--%3E%0D%0A%3Cscript%3E%2F%2F%3C!%5BCDATA%5B%0D%0A%0D%0A++++void+1+%3C+2%3B+%2F%2F+Without+the+CDATA+section%2C+this+would+cause+a+syntax+error+in+XML.%0D%0A++++document.querySelector%28%22.two%22%29.innerHTML+%3D+%22Script+%232+successfully+executed%22%3B%0D%0A%0D%0A%2F%2F%5D%5D%3E%3C%2Fscript%3E%0D%0A%0D%0A%3C!--+3+--%3E%0D%0A%3Cscript+type%3D%22text%2Fjavascript%22%3E%3C!--%2F%2F--%3E%3C!%5BCDATA%5B%2F%2F%3E%3C!--%0D%0A%0D%0A++++void+true+%26+false%3B+%2F%2F+Without+the+CDATA+section%2C+this+would+cause+a+syntax+error+in+XML.%0D%0A++++document.querySelector%28%22.three%22%29.innerHTML+%3D+%22Script+%233+successfully+executed%22%3B%0D%0A%0D%0A%2F%2F--%3E%3C!%5D%5D%3E%3C%2Fscript%3E%0D%0A%0D%0A%3C!--+4+--%3E%0D%0A%3Cscript%3E%3C!%5BCDATA%5B%0D%0A%0D%0A++++void+true+%26+false%3B+%2F%2F+Without+the+CDATA+section%2C+this+would+cause+a+syntax+error+in+XML.%0D%0A++++document.querySelector%28%22.four%22%29.innerHTML+%3D+%22Script+%234+successfully+executed%22%3B%0D%0A%0D%0A%5D%5D%3E%3C%2Fscript%3E%0D%0A%0D%0A%0D%0A%3C%2Fbody%3E%0D%0A%3C%2Fhtml%3E%0D%0A&amp;type=text%2Fhtml%3B+charset%3DUTF-8) For more info, see [a much longer explanation I wrote in 2005](http://lachy.id.au/log/2005/05/script-comments) about it. 
Except it's not being updated.
I know that feeling, but you know what, umder the hood there always be JS, so you better stick to its roots, gotchas and magic (and now ES6)
As others have said, just focus on vanilla JS, but I'd also add that you should learn how CSS actually works. It's not hard, but most developers are depending on CSS frameworks and don't understand the most basic things about CSS. Frameworks will always change. That's how it should be. We had a long period during the IE6 monoculture days where nothing changed, and it sucked. Personally, I hope there is never a Rails-like monoculture for JS. That would mean the web wasn't getting any better. Embrace change. As long as you know how the underlying technologies work (JavaScript, CSS, HTTP), you can always apply that knowledge in whatever circumstance you need to. Learning a new framework isn't that big of a challenge. If you only know frameworks and don't understand the underlying technologies, you'll always have anxiety that you're being made obsolete.
This is the curse of the front-end programmer. I started programming professionally in the 80's on alpha-numeric terminals. Then moved on to GUIs, on a variety of completely different platforms, with widely different drawing/event/window management paradigms: MacOS, Cedar, display Postscript, X, X/Motif, Interviews, QT, Views, MacOSX, Win32... We had to get learned in all of them, many of those systems got hyped, the best ones were not the ones that got mainstream. To make it funnier, all those technologies are now pretty obsolete. All in all you should consider yourself lucky that at least the low level layers are quite uniform, and that by now, there is widespread competence in how to design a toolkit. After a few years, you'll start to notice that there are not that many sound principles that govern an end-user application. So your experience and skillset is not obsolete, quite the contrary. Picking-up a new framework should become easier, much like learning a new language is easier when you master more than a few already. MVC is what it is and has always been. Prototyping with easy access to representative users is the most important to avoid wasting time developing needless features. So, congratulations, you've grown up and have gotten to the next level of professionalism: keep constantly updating your skills, and don't jump too early on the latest overhyped framework.
I have been away from JS for some years. The time I left Backbone and Angular weren't really a thing. How come they've grown to be the two dominant libraries in frontend development?
As a seasoned front/back end dev, I'll advocate you change job. because: I'm doing it since 1998, and had seen passing so much caravans I just can't remember ( hello, Shockwave, realPlayer, how are you? ) I mean: your problem is just part of the job. Angular just annonced they change EVERYTHING in v2, so you can drop all your habit of 1.0 Angular MVC And yes, JAVASCRIPT ninjas are needed, and here to stay ( like JS ) Some unix back-end knowledge ( server admin ) are forever Some server-side preprocessing namely: PHP, python, ASP are here too for quite some time and not dying. Client-side processing is bozo my friend. SO dive into php/js/css MASTERY ( ninja level ) and you'll never be outdated anytime soon. Keep an eye and test any new tech but just stick to broad use techs, even if you don't like it.
Classes are not hoisted like functions are, so you need to define them before you use them. In this case move the definition of B before the definition of A.
Try setting forceHeight to true
That's pretty good, thanks!
Microsoft will be happy to see this post. .NET framework is all about consistency 
I've got a pretty deep seated hatred for frameworks. Let's learn a whole new "technology" to do an AJAX for us and obfuscate onchange events. No, that's not stupid enough. We need to introduce obscure javascript design patterns that accomplish nothing we couldn't do already. The one redeeming quality about frameworks was they got everyone on the same page but now with a zillion frameworks, all of which are changing, they don't even do that. Fuck frameworks. 
I've been doing this for two decades as well and, while I am aware of the latest new hipster shit frameworks, I'm not such a fucking sad sack that I spend my precious weekends staring into a screen like I do all week.
Yep, I've hit this rather frustrating issue myself. IIRC, you can set the alpha value to either 0 or 255 to maintain the RGB values correctly, but you lose the ability to alter the alpha, obviously.
Agh, I guess you are right then. Every framework seems simple and lean to its mom! ;)
http://imgur.com/Vcljn1X
I have used Angular for a while. I can do pretty complex things with it. But honestly I always felt it was too much complex! On the other hand with React I liked the concepts behind it but not the implementation. But I haven't used it to the point to become blind to the pain points. Returning to Riot it obviously can't be really compared. But it's simplicity is something I was looking for. I want to try building something more complex of a todo list. Just to see what happens. :) 
Anyone want to sponsor a Jr Dev :)
What is a *good* module loading framework I can *use to write* a library. My apologies for not being clear.
I work for a multinational financial software company whose clients consist of banks and the like... So, not the most advanced industry out there. Even everything we make is IE9+. The easiest way to break people away from IE7-8 (and soon to be 9) is to reinforce the fact that Microsoft no longer supports them and it's a security risk to keep supporting them ourselves. 
I love how this comment is a direct manifestation of OPs worries. I'm not saying it's bad advice, just hilarious in the shadow of the thread. "Just download this nightly and this framework to get started on new hotness."
Those are most of the reasons I hate my career path and somehow managed to hate programming, the thing I used to love the most. I wanted to code and get even better at coding, but all they cared about was if I knew how an accident is reported and how it is handled. An work accident show be handled that way, a car accident in any other way and a plain accident show be handled by a special guy responsible for handling plain insurance. And when you get rid of the insurance stuff, you have to learn about banking, and the steps of a transaction, deposit, withdraw, credit card payment, deposit card payment, online bank transfer, international transactions. So fucking boring. I don't care about their processes, I'm not allowed to talk with the client or even knowing who the client is. Managers do that stuff and they are payed a shitload of money to do it, just leave me alone with my IDE. I just want to code in java/c/c++ without having to know how my boring client does his stuff and make enough to afford a room and food, but I'm too qualified for that stuff and end up with all the boring stuff.
why hello there fruit :-)
Yeah, it's kind of a bummer in that aspect as you'd think things like [virtual-dom](https://github.com/Matt-Esch/virtual-dom) would make it, but it *is* where I found [Ramda](http://ramdajs.com/docs/).
Hmm. A lot of these features are provided by native web components. I'd probably use web components instead of 3rd party libraries. Polyfills can be used until native support becomes widespread. In addition, I tend to prefer small modules instead of a "large" framework, as it's easier to switch a single module instead of switching a complete framework.
Sorry to hear this. Sounds like it's been frustrating for you. Maybe I've just been easily amused during my career.
Well, if you weren't already using or interested in using frameworks that provide those or similar features (angular, ember, etc)...then yes this framework would also not be for you.
:/ Sorry T_T
Then would you mind cleaning it up? There are definitely multiple statements in that code - would you mind breaking them up and putting them on different lines? The newline character doesn't bite.
&gt; jQuery - it was created for a purpose that is becoming unnecessary. If you have a minute or two, would you mind elaborating. I'm a little late to all of this, so I don't quite get what you're saying. jQuery abstracts away browser differences—isn't that still something that's needed. Are you thinking of something else? Thanks.
Part of the trick here is using the code itself to generate the required characters. It won't work anymore if the code is restructured. edit: That said, here is a formatted version, it won't work but will make it easier to read: https://gist.github.com/dylanbr/893de8a076cce5165131/1e1e6cdb06d21aecfe43cc0fc66f43b9560118dc
Fair enough...then this is not for you. edit: I would encourage you to not discount all frameworks because of your poor experience with Angular...if anything this framework is (and other frameworks are) an alternative possibly better solution.
&gt; spend weekends getting your feet wet on new tech and frameworks. I think you missed the point of his post. Some people want to spend their weekends doing other things besides programming.
Reminds me of: https://twitter.com/tjholowaychuk/status/530765636642033664
The ES6 solution doesn't seem to work. [Plunker here.](http://embed.plnkr.co/arcys4lDsis4JQUY6STG/preview)
&gt; I am a ~~frontend~~ developer who's exhausted from the churn rates of new technologies. This may not be the career for you then. The longer you are in the profession the more you will realize that the churn is always going on and, yes, it is even getting faster. It doesn't matter which stack you are developing on. You are focused on JS but this is a reality across the industry. I advise junior devs all the time that if they don't want to learn constantly, and forever, than this is not the profession for them.
3 already upgraded, 2 merged, 1 abandoned by its creator for a fresh approach.
Wow, that's definitely a typo. Everywhere you see an arrow should be a "&gt;" greater than sign. The first line is saying "if age is greater than or equal to 21" if(age &gt;= 21){} This is a terrible example. If I wasn't on mobile right now I would put together a jsfiddle for you. I'll try to help you out later.
Thanks. I really enjoyed the process of putting this together and I'm sharing it because I thought the someone else may enjoy the process of pulling it apart and figuring out how it works. It's more of a puzzle than something you'd ever use in real world code. Disclaimer: Anyone new to JavaScript development, never do any of these things!
As an internet software engineer, you can't ever really take pride in mastering a technology (because, as you point out, they change too fast.) You can only take pride in mastering your ability to learn and work with whatever new challenge comes your way.
I was so surprised about that solution that I had to check it myself. Because if for-let works like that then.. JavaScript is even weirder than usual. It would mean that a lot of C/C++ programmers would walk into that trap, because the "let" keyword is typically advertised as making JavaScript variable scoping work like "normal" languages.
&gt; Then go learn jQuery, jQuery, and some more jQuery. My Angular.js apps do not import jQuery at all.
I like this. Maybe not for industry projects yet but for my pet projects for sure.
That's neat :)
Test coverage appears really bad. Low confidence therefore that the framework is not buggy.
by "completely wrong", you mean the line breaks are significant? otherwise we've typed exactly the same symbols as each other in the same order. which is interesting. i never saw an instance where it mattered in real practice, but we just used it as voodoo magic back then because browser compatibility hadn't been invented yet (and if you wrote JS snippets you never knew how they were gonna be used). from everything i know about XML, though, you're probably wrong about the line breaks.
No. The line breaks immediately after `&lt;script&gt;` and before `&lt;/script&gt;` are not significant. Look again. This is the first line from yours and my first version together: //&lt;!--[CDATA[ (incorrect) //&lt;![CDATA[ (correct) And the last lines: //]]--&gt; (incorrect) //]]&gt; (correct) Your version is basically just commenting out the entire script in XHTML. See the XHTML demo I linked to. The first script is yours. The second, third and fourth are mine. Note how yours doesn't execute in XHTML.
Open up dev tools (in chrome its F12), put a console.log(x) after you've assigned some value to it. (x is your variable) You will be able to see the content in the console. if it's a large object, you might want to try console.log(JSON.stringify(x, ' ', 2)) copy -&gt; paste
This is just my experience: my front-end enjoyment went up 10 fold after doing everything in LiveScript with a decent framework. I found Angular too complex, so we went with React. It's super simple and doesn't get in the way. My 2c is do whatever is simplest, quickest, and most enjoyable. Could you do it all in raw js without a framework? Sure. Would it hypothetically better if you did it perfectly? Sure, it might be. Does any of this really matter when you're building a product in comparison to everything else? No. Do whatever you enjoy most so you are as efficient as possible. For me this was doing it in LiveScript and ditching vanilla js, and using a front-end library. Find what it is for you and go with that.
Sure, I'll elaborate. jQuery was created to abstract browser differences a long time ago, back when web standards were almost nonexistent. You couldn't rely on browsers to treat anything uniformly; jQuery was created to normalize that and abstract the differences away from the developer. jQuery was awesome! These days, though, web standards, as well as browser javascript - they've become very uniform. We no longer have to support IE5, 6, and 7. We no longer have to support old versions of Firefox and Netscape. Web standards have come a long way, as has the DOM; browsers are becoming unified in the way they handle DOM manipulation. As such, jQuery has really become a superfluous layer, unless you're dealing with very old browsers. The jQuery team knows this; their new library drops support for older browsers, making the library much leaner (because calls are uniform across newer browsers). jQueryUI is still pretty awesome, though. TL;DR: jQuery abstracts browser differences, but browsers have become pretty uniform and will only continue to do so.
oh. you don't know how HTML comments work? the -- is optional, and can be any multiple of 2 in length (0 is a multiple of 2 for these purposes). you use the double dash version yourself later in the "full" version of the code. i have no XHTML browser to test it in, but it's possible they miscoded something in yours if the standard html comment part is restricted like you say. they should be 100% equivalent. i only used the double-dash version so the original poster would see the html comment part easier, since that was what his question was on. if i'm wrong, TIL.
Sorry I didn't expalin my self well, is there a way to use the pastebin api with JavaScript to upload the variable?
In the end, most developers don't have time to sit there and look at YET ANOTHER FRAMEWORK, especially ones made by a single developer. If you want help and want it to be adopted at all, finish the damn thing first, then you might actually attract competent developers to it. Regardless, what are you trying to accomplish? Are you going to maintain this forever? A successful open source project needs a community behind it and a core set of developers to lead the project. If you're simply relying on the community to do that in the long run, well then this project is ultimately not worth looking into because it won't be maintained.
&gt; everything changes. Sure. But some changes are important and most aren't. 
To be fair, she said this was for teaching, not for using, so while performance is a goal for git, it isn't for gitlet. :)
That's what I thought too.
jQueryUI is pretty good. I've had some troubles when trying to push it, and usually find these things listed as known issues; but overall I've been very happy. I'm still supporting IE 8 in corporate intranets though, and so I worry about trying to make use of some of the newer frameworks and libraries. I guess I should be glad that I wasn't doing this back in the Bad Old Days, and just count my blessings, but IE 8 (and XP) are the bane of my existence.
I do appreciate the convenience that jQuery offers though. I'm doing corporate intranet work (IE 8 and XP), so the additional loading time for jQuery doesn't seem to be such a big deal (since we load it from the corporate network). I only wish I were supporting only modern browsers.
But these are tools to help OP get ahead of the curve when it comes to vanilla JavaScript, which is explicitly stated as a goal. 6to5 is technically a new tool, but the project's maintainers are committed to keeping it in line with the spec. Familiarity with the new features coming to JavaScript will help OP without being transient like, say, Angular. 
I didn't see anyone mention traceur. Write ES6 today and transpile to the old way. https://github.com/google/traceur-compiler
Thanks, I'll try it when I'm back at my pc. I will remove this post now, because I was told I'd have a better chance in a Qualtrics focused forum. Thanks for the help :)
Wodry.js is a simple jQuery plugin for a text flipping/rotating written in CoffeeScript. It was inspired by the Adjector.js. Wodry.js does the same things but it has new features that allow you to set animation from animations collection, set your own callback on content flipping, etc
Learn vanilla js as much as possible. Learn es6. Learn node, go full stack. Having a strong fundamental understanding of the language (and programming in general) is gonna help you more than mastering the current flavor of the month.
same same
This is really nice. BUT... Does/Can (already, or can be implemented) footwork.js resolve this https://twitter.com/kentcdodds/status/558775978416029697 ? (correct module distinction and namespacing of custom components) (my idea: http://t.co/UxKxy041hx )
First off, I wouldn't sweat it. Building something &gt; not building something. Have fun. Basically, the JS ecosystem is really diverse. If I were you, I would recommend building something relatively complex using the following set of tools: * Keep your code organized in different files using Browserify and CommonJS modules. * Use jQuery to abstract away browser differences. * Use the Chrome debugger to set breakpoints, inspect variables, etc. There are millions of tools out there, but I'd start with those because they have a shallow learning curve and don't actually abstract away that much. After using these you'll have a good understanding of the benefits of more complex frameworks. 
yes, do it. off the top of my head: pros: super fast app development/high productivity cons: fibers make node server code hard to debug sometimes
LOL. &gt; ho hum webscale node.js blah blah In the words of Jacque Fresco, **this shit's got to go.** People need to stop pretending that javascript is the language for literally *everything*. Seriously, replacing a strongly typed language with a retarded untyped crap intended to be a toy language for DOM manipulation isn't going to help anyone. And this is from someone who despises java.
&gt; The format MUST be like this: &lt;![CDATA[ ]]&gt;. apparently, that is correct, now. but it's also correct to say &lt;! ... &gt; is still treated as an HTML comment. &gt; It is funny that, starting from discussing JavaScript, suddenly we go into how XML works. LOL to be honest, when they started putting stuff like the combined HTML/XML comment hider into the HTML spec like this, and started filtering JS at the HTML layer for comments, is when i stopped reading them. apparently that's the same time browsers stopped supporting SGML comments. "back in my day blah blah blah uphill both ways". lol the correct answer no matter what (now) is to use the external scripts, though. good call. this is why i haven't had to formulate a correct, working version of this since they introduced the `src` attribute. ;D
Everybody's framework has to have custom web components feature it would seem. I don't mind-from when Angular came up with it, I have loved my custom components.
Excellent response. Learn patterns, study languages, pick up on idioms - don't tie yourself to one framework or language. At my current job, we recently hired a principle software engineer, and while he knows a lot about node and angular, I probably know just as much if not more (and I'm much more junior). What he really brings to the table is an ability to quickly digest problems and implement sound strategies, generally language/framework agnostic. That's the kind of developer that is going to get a job anywhere.
Nah, see you are just trying to make things sound more complex than they really are. These are just choices about how you prefer to use/implement JavaScript. It has nothing to do with JS itself, or JavaScript 'defying common wisdom.' All you listed are helpful tools to improve development. If you don't like them don't use them. It's really simple, actually.
That is a result of how that application is built and not how footwork works in general. I agree though I need to fix that. **edit:** It has been fixed.
Exactly. If you aren't getting paid well as a web-dev, find a new company or consult/freelance.
&gt; These are all subjective quality words, not technical differences--not to mention, you're describing your own code as expressive, consistent and clean. Yes I understand that...the post wasn't meant to be a technical breakdown of the benefits of footwork vs others...a more detailed explanation (as well as some comparison) is on its way...I began working on a video introduction/tutorial which should allow me to clear up the technical merits. &gt; I did take a look at it, and what I'm seeing (aside from the annoying unnecessary animations and oddly slow loading and fully separate domain/page(?) for docs&amp;annotated code) is that it's an extension and modernization of Knockout, which I always have felt didn't get the credit it deserved. That is a relatively apt description, at its core it is an extension on top of knockout. &gt; But that still makes it just another 2-way data-binding approach when 2-way binding is finally losing popularity. I am not entirely sure it is...React is around and some have jumped to it...but angular and others with 2-way binding are as popular as ever. I personally feel 2-way binding is overall beneficial...and regardless of your personal opinion on its popularity I feel it is a good solution to the problem it solves. **edit**: Those animations on-load are actually not supposed to be there...thats a bug with the layout manager i wrote for that site...it needs fixing, its not an intrinsic behavior with the framework. **edit2**: it wasn't *my* code I was talking about being clean and consistent...I was more talking about the API and the code you can write *with footwork* that is consistent and clean 
I have to disagree with OP, I also had a background in Java before transitioning to being a full stack JS developer, however I think bringing Classes to JS is going to revolutionize JS. Once you start writing large JS web apps, with thousands or tens of thousands of lines of code it becomes very difficult to maintain. While you can already implement the behavior of classes, it is messy and bug prone. I am greatly looking forward to when I can use classes (and native custom elements) to remove all the polyfill to make that semi maintainable.
Check out other libraries you use, and copy them. I'm a big fan of [q.js](https://github.com/kriskowal/q/blob/v1/q.js) and have copied that pattern quite a bit. In your case you can decide if you want to implement a full UMD pattern, or just support a global definition, but it's a good structure to get in the habit of using. You should also make sure to not pollute the global scope, and only expose one base object for your library. Here is a little example: (function(global, definition) { // only support global usage, for now global.MyLib = definition(); })(this, function() { // define your library function MjLib() {...} // add functionality MyLib.prototype... // return library upon definition invocation return MyLib; }); Edit: this is generally called the [module pattern](https://carldanley.com/js-module-pattern/). 
[Essential JavaScript Links](https://gist.github.com/ericelliott/d576f72441fc1b27dace)
Yeah I like learning new things all the time. The rewards come in when you get to get good at it and implement it. I'm not complaining about learning new things at all. I'm complaining about the churn rate. I'm willing to deal with it because I really like front end development. I guess I should have worded it better. I'm just looking for suggestions on dealing with it, and to open a discussion.
&gt; How do you know your framework won't suffer the exact same fate? I don't presume to know...all I can do is what I love, and be passionate about what I feel is right. If I gave up every time I came up against a potential roadblock or issue, nothing would ever get done. &gt; I'm all about people creating frameworks for fun, but in the end, quite a few world-class developers are involved in those other projects, why do you think you're so much better at future-proofing than they are? This was never about being better than them (although if that is the eventual outcome, cool), and this was never 'just for fun' (although yes, I do find a lot of joy in my work, thankfully). This is about a set of patterns and pieces of code I found to be very extensible and usable. Patterns and tools I personally felt were 'better' (more extensible, expressive, easier to maintain, etc) than what I was using in other frameworks. I felt that if I iterated on them enough and composed them in a proper manner it could be very useful to many people...maybe they would see what I see. Maybe they might want to help make it better...who knows. But then again maybe they won't, and maybe I am wrong...that is fine.
We're going to use React on a new project to test it out rather than Backbone and it certainly seems significantly better. That said, Meteor has so far some off to me as too much magic for a production system, but nice for rapid prototyping and early work like that. To be clear though, that's just how I see it at the moment, and I can't speak for everyone.
If you want more explicit and less magic, why not just use backbone and a plug-in like backbone.stickit? That being said (since it looks like you've dug into react a little bit), I'd argue react is so good at what it does specifically because it says two way binding is the *wrong* answer. Spend enough time with react and you'll start to see that a large majority of what your Ms, Vs, and Cs were doing can be accomplished more easily/simply with truly modular components and proper data flow/state management. 
2nd this, jQuery, in my opinion is probably the best library to start off with, Angular is one of the more popular frameworks. MDN has tons of excellent documentation. I might recommend this book [Professional JavaScript](http://books.google.com/books/about/Professional_JavaScript_for_Web_Develope.html?id=PIQCtwAACAAJ) by Zakas as well. Some concepts I remember having a somewhat difficult time grasping were; OOP with js; there are literally a dozen different approaches to building "classes", some are better than others in different situations. Callbacks/promises and the concept of passing functions through parameters. As with any other language; there's a crap ton of bad practices on the web so mdn is really gonna be your friend. 
'Node.js performance and resource consumption is better than Java' either you dont know java or you dont know node, either way thats far from the truth.
not a bad thing. javascript was made to look like Java/C but being less verbose then those languages. Just look at the languages name.
https://en.wikipedia.org/wiki/Hypergraph
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Hypergraph**](https://en.wikipedia.org/wiki/Hypergraph): [](#nsfw-start)**^NSFW** [^^(?)](http://www.reddit.com/message/compose?to=%28This%20is%20a%20placeholder%29&amp;subject=NSFW%20toggled:&amp;message=NSFW%20was%20toggled%20ON%20by%20parent%20commenter%20for%20this%20comment.)[](#nsfw-end)[](#nsfw-toggled) --- &gt; &gt;In [mathematics](https://en.wikipedia.org/wiki/Mathematics), a __hypergraph__ is a generalization of a [graph](https://en.wikipedia.org/wiki/Graph_(mathematics\)) in which an [edge](https://en.wikipedia.org/wiki/Graph_theory) can connect any number of [vertices](https://en.wikipedia.org/wiki/Vertex_(graph_theory\)). Formally, a hypergraph is a pair where is a set of elements called *nodes* or *vertices*, and is a set of non-empty subsets of called __hyperedges__ or __edges__. Therefore, is a subset of , where is the [power set](https://en.wikipedia.org/wiki/Power_set) of . &gt;While graph edges are pairs of nodes, hyperedges are arbitrary sets of nodes, and can therefore contain an arbitrary number of nodes. However, it is often desirable to study hypergraphs where all hyperedges have the same cardinality; a *k*-__uniform hypergraph__ is a hypergraph such that all its hyperedges have size *k*. (In other words, it is a collection of sets of size *k*.) So a 2-uniform hypergraph is a graph, a 3-uniform hypergraph is a collection of unordered triples, and so on. &gt;A hypergraph is also called a __set system__ or a __[family of sets](https://en.wikipedia.org/wiki/Family_of_sets)__ drawn from the __universal set__ *X*. The difference between a set system and a hypergraph is in the questions being asked. Hypergraph theory tends to concern questions similar to those of graph theory, such as connectivity and colorability, while the theory of set systems tends to ask non-graph-theoretical questions, such as those of [Sperner theory](https://en.wikipedia.org/wiki/Sperner%27s_theorem). &gt;==== &gt;[**Image from article**](https://i.imgur.com/yaXQ8vB.png) [^(i)](https://commons.wikimedia.org/wiki/File:Hypergraph-wikipedia.svg) --- ^Interesting: [^Altair ^Engineering](https://en.wikipedia.org/wiki/Altair_Engineering) ^| [^Symmetric ^hypergraph ^theorem](https://en.wikipedia.org/wiki/Symmetric_hypergraph_theorem) ^| [^Constraint ^graph](https://en.wikipedia.org/wiki/Constraint_graph) ^| [^Line ^graph ^of ^a ^hypergraph](https://en.wikipedia.org/wiki/Line_graph_of_a_hypergraph) ^Parent ^commenter ^can [](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cnzyn6k) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cnzyn6k)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
&gt; The syntax seems easy enough You owe it to yourself to watch Crockfords 'javascript, the good parts'. https://www.youtube.com/watch?v=hQVTIJBZook He talks exactly about what you just did there. Plenty of people see the syntax is similar to C or java and make the false assumption that it is similar enough. It is not. It is closer to schema, a language you didnt list as a skill. For example, what is the value of x? function foo() { return { p = 5; } } x = foo(); If you said 'undefined' you win a prize. Now explain why. Its part of why javascript gets a bad rap, and its completely understandable. 
Meteor makes sense for a specific set of real-time applications, but it is extremely resource heavy. A huge amount of Javascript has to be loaded before the page starts rendering, and render time itself is slowed by the fact that templating is done on the client. Client-side rendering also has big impacts on SEO and caching; Making a Meteor app crawlable requires a number of workarounds, as there isn't any plain HTML to crawl. Being relatively new, Meteor lacks a lot of the community support of a more established framework like Rails. If you're building a large and complex app, then these compromises are relatively minor. Meteor massively reduces development time for highly interactive apps, and the greater load time will be compensated for by the excellent responsiveness of Meteor apps. For more general use, you need to think carefully about whether the costs outweigh the benefits. I think a good rule of thumb is that if your project would make sense as a desktop client app, then it would probably work well as a Meteor app; If your project is primarily static pages with some added interactivity, then you're better off with Express or Rails.
He did say lisp
*JavaScript ecosystem is a complex and sophisticated collection of software written and maintained by different companies and individuals and a bunch of people vocal on twitter about their opinions.* Examples include: - package managers: npm, bower, jam, meteor, duo.js, jspm, volo, apm, ... - front-end frameworks: angular, ember, react, vue.js, ractive, blaze, riot, ... - build tools: grunt, gulp, brocolli, celery, carrot.js, mimosa, jake, brunch, modjs, bud, fez, ... - server-side frameworks: express, meteor, sails, rendr, loopback, koa, harp, hapi, hippy, hoppy, ... - testing frameworks: jasmine, mocha, chai, oolong, mate, blooming, rooibo, ... - FRP: bacon.js, rx.js - old and not hot anymore: yeoman, mootools, yui, kendo, etc - **YOU DONT NEED IT**: jquery - + 100500 untested, poorly designed, written over a hackathon projects Welcome!
As far as I know ES6 doesn't have anything to do with the pub/sub pattern, so this solution will work in any version of JS. In node we have the EventEmitter class, so you'd make your Player inherit from EventEmitter like this: `util.inherits(Player, events.EventEmitter);` Then you could use `player.on("die", ...)` as you mentioned. You probably would also have a `die()` method like you had, and this would call `this.emit("die", ...)`, which would alert all the listeners. In the browser you have two options. The first option is to use the exact same code as for node and just use [browserify](https://github.com/substack/node-browserify), which is a pretty good solution anyway (it provides a shim for `util.inherits` and `events.EventEmitter`). The second option is to find a browser implementation of an EventEmitter ([Like this one](https://github.com/asyncly/EventEmitter2)). Then you just inherit, browser style, like this (which is what `util.inherits` does internally in node anyway afaik): `Player.prototype = Object.create(EventEmitter.prototype);` 
&gt; jQuery, in my opinion is probably the best library to start off with Completely disagree. jQuery does some things really well, but too many people use it as a crutch. 95% of what you want to do with jQuery is available natively with querySelectorAll, anyways. Learn JavaScript, not libraries.
Two kinds of reply: 1. Force your users out of old browsers faster! Yeah ok, easier said than done. Convincing a client to alienate a potential source of income, no matter how small, is always an uphill battle. 2. Write ES6 and compile it to ES5! I'll look into it. If it's like the LESS/SASS workflow (saves a zillion hours, super easy), I'm all for it. If it's like CoffeeScript (easy enough, questionable whether it's worth it) I'll just wait a little longer. I'm damn good at vanilla (ES5 with a couple of shims) JS.
My take on it is that `p = 5` inside of an object isn't a proper object property instantiation.
It's a side effect of automatic semicolon insertion. The [MDN `return` reference page](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/return#Automatic_semicolon_insertion) covers the simple case and this [section on the grammar page](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Automatic_semicolon_insertion) gives more detail. MDN is an invaluable resource.
Noboby is forcing anyone to learn "another framework". Some JavaScript developers learn by experimentation which kinda leads to a "framework" and they might as well give it a name that hasn't been taken already and release it to the public because they're curious as to what the world will say about it. There is a lot of pollution in the JavaScript ecosystem, but again, nobody is forcing you to learn anything. If you think it will benefit you then learn it and contribute to it but it's everyone to their own.
Damn, you got me badly here ! I did think that the semicolons seemed a little off but I would never have thought of that. What kind of a langage implicitely puts semicolons at critical places ? Thank you for the problem, I'm glad to see that there is still lots to learn in this world :)
There's a lot of pollution in the JS ecosystem. Master straight JavaScript first, and especially on how to properly debug with breakpoints and debuggers. Remember, frameworks are just abstractions from vanilla JS.
I too would like to give you support and say fuck the haters. I've been cobbling together an [Angular](http://opensourcetaekwondo.com/ngcss/) and [Vanilla JS](http://opensourcetaekwondo.com/cjsss/) binder into CSS that can be characterized as a CSS Preprocessor but is really Javascript Binding in CSS and I've gotten very little from /r/CSS or /r/webdev other than downvotes. Keep up the good fight! I've been doing Angular for the last year and love the approach; RESTful + frontend MVC/MVVM. I cannot see doing a C# MVC or webform site again! I'll likely use your project as my toe-dipping into Knockout. In any case, you've got another stargazer.
&gt; What kind of a langage implicitely puts semicolons at critical places ? This one. Heh. There's a lot to love in JavaScript, but there are parts of the language that you have to get used to and/or avoid via a disciplined, careful approach. I am not sure there's consensus that automatic semicolon insertion should be avoided, but here are more ways it can go wrong: https://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Semicolons#Semicolons Here's another fun one: if (null == undefined) console.log('foo'); else console.log('bar'); Null and undefined are two separate values (yes! there ARE two), so the answer should be clear. Right? ... Right? edit: also, the fun thing about modern web browsers is that you can run code very quickly. for me, Cmd-Option-J to bring up the Chrome dev tools console, then just type away.
As someone who is building a production app with meteor that will hopefully serve thousands of customers one day, this is the comment you should pay attention to. If you are building any complex or innovative application meteor is a boon for development. We can do more with less. If you aren't doing anything innovative just use node.
&gt;Take dosbox emulator C/C++ code &gt;Compile it into llvm code &gt; Run llvm code through emscripten, which turns the code into javascript. Basically, you have a german and an american having a conversation, but neither of them speak the other's language. Emscripten is a transcompiler, meaning it can compile from one language into another. In short, take a spaniard who speaks fluent german and english, and throw him in the middle. The german and the american can have a conversation through the spaniard, and everyone is happy. 
Hot code pushes are just one of the advantages of meteor. There are plenty of reasons to use it. 
No there really arent, and if there were, go and show me all the useful apps that are built using meteor that actually use it properly. I'm not saying its bad because it's not, it just has particular few use cases. 
It's kinda verbose with Object.observe but is certainly doable natively (will work in Chrome Canary afaik). Have a look at [this](https://gist.github.com/zeusdeux/cceee7dea9efd132429c). On the other hand, you can use browserify and just use EventEmitter in the browser. Better yet, find a pub/sub package ([like this one](https://github.com/zeusdeux/preach)) and just inherit from it. Cheers! PS: on mobile, ignore the lack of formatting
I am one of the developers of Meteor and one of the things I like to tell people is: "Meteor provides a good full stack of magic, but if you want to replace a part of it, it is usually possible once you are good at it". Examples: - meteor-react: https://github.com/mystor/meteor-routecore - meteor-angular: http://angularjs.meteor.com/
There really *are* plenty of reasons other than the real-time aspect. Single-language codebase, same APIs on client and server, code sharing between both environments, easy database access and user accounts… I mean, you might not agree that those are *good* reasons to use it. But it seems a bit over the top to say there are no reasons at all. 
The next step: a JavaScript interpreter in JavaScript.
What are you trying to achieve? The length of an array is determined by the contents of the array and doesn't exist independently. The getter returns the actual length of the array. It makes no sense to set the length of an array as the length is dependent on other properties. The setter is instead used to truncate an array as a convenience method. I might be missing something. Are you just looking to peak under the hood and poke around? I'm a practical learner myself so I can understand if that's the case. If so, take a look back and try to understand why it is this way (although be warned you will not always find good reasons when it comes to js language design)
Exactly, how would I form the ajax post call though? what code would I need to run?
Since you know python.. I recommend trying coffeescript when you're free. Site has online environment when you can try it out - it generates JS.
I'm sure Meteor is a fine framework, but to me defending it by saying that most parts are replaceable is a cop-out. With enough effort any part of any software is replaceable.
Worked for me, on mobile, which is especially impressive.
The Backbone.Events object is perfect for this. It also has the reverse 'listenTo', 'stopListening' logic which I find makes a world of difference to creating a good design. I know it's silly using the library for one feature, but I don't know of any other that works in the same way?
stop() and .until() are already there , they were updated later you can find them on github documentation as they were updated later. 
You should try MeteorJS if you are tired of "a lot moving parts" in the client-side javascript world. You can do almost the same things without Meteor, but then you need to keep in sync a lot of projects like Angular, grunt, gulp, Minimongo, SocketIO, nodejs, undescore, bower, ..
Never trust a framework that depends on investor's money (11 million US$). VCs are not coders and surely have 'more' important goals than "open source community".
Without server side ? How?
Please see the button at bottom of the result frame. It's working.
Is... Object.keys(arr).length ...what you want?
does nothing for me
Because you shift all the workload on client side, and you musn't. Don't forget clients are clients, like in shops. They just appear at the door, and your work as a content provider is to serve them well, NOT putting them to work ;) JSON is great, live DOM manipulation/update with small data I/O is very useful, and wishable. BUT never do what can be achieved server-side on the client side. Now people access your content on tiny computers ( called smartphone ) that have reduced workpower vs laptop. If you don't carefully segregate what's fair to process on client side vs what's you task ( serving preprocessed content ) you are quickly begining to put your audience to contribution to save some server workload, and this is a nasty confortable habit nowadays. Now imagine your " client" is a crawler ( or SE ): do you really believe he'll execute your funky exploit-like bunch of packed intel you call your " regular MVC js framework?" - POP! you just disapeared from the indexes! I just saw a website that is just a js mammoth library, almost no HTML, a bunch of json content, and A.FUCKING.CLIENT.LOCAL.DB! I mean the guy just REPLICATED his db on client side on EACH Client connection! How sick is that? To me it's not a web anymore, that's a virus that replicates all his content from host to host 
I appreciate the encouragement...it helps. Check out knockout even if you don't like footwork...knockout is really a great library...and observables need to be used more in the front-end (the pattern not just the feature....EmberJS uses observables as well...one of the things I liked about it). (also, the better you are at knockout, the better you will be with footwork...footwork is knockout++, essentially)
Likewise.
You have a proto or a site where I can see?
Because that's a syntax error, but not actually the point trying to be made
webcam works... saving image does nothing... still impressive! it's been a while since I last looked at UserMedia... what's the current stand on browser/platform support?
Still just Chrome, Opera and Firefox
* `()` Parentheses * `{}` Braces * `[]` Brackets
JSLint will shit on you if you do this, but yes it is allowed. 
I think it depends on where you're from. To me they're all a type of 'brackets'. I mean [wikipedia says](http://en.wikipedia.org/wiki/Bracket#Parentheses) &gt;Parentheses [...] also called round brackets
Long story short, it uses [WebRTC](http://en.wikipedia.org/wiki/WebRTC) to make WebSocket-like connections directly between browsers.
&gt; Are you just looking to peak under the hood and poke around? I'm a practical learner myself so I can understand if that's the case. Yes, this is exactly my intent. 
VC's money is not an asset but a future obligation. No sane coder should bind his/her productive code to such a volatile environment. For prototyping &amp; having fun, Meteor's OK. For productive code: no way.
It seems like Meteor have died a bit since last summer or so? Haven't heard much about it in the last year
Pretty cool, mobile and desktop (Firefox for both) activating camera works. The save button is a little weird, I'll have my go at it and upload the code
I switched over completely 18 months ago, and it remains my favorite web app framework — and we're building a dev shop that is Meteor only (http://differential.com).
Show me evidence that Meteor affects SEO? We've consistently seen our Meteor apps show as high in search engine results as non-Meteor apps.
The actual length is a so-called internal property; internal meaning that it is mainly a specification device and may or may not exist in implementations. As far as you can tell from within JavaScript, `length` is a mutable own data property (not a getter or setter) of array instances: &gt; Object.getOwnPropertyDescriptor([], 'length') { value: 0, writable: true, enumerable: false, configurable: false } You may be interested in ECMAScript 6 proxies, though, they allow you to simulate all kinds of behaviors.
What open-source, VC-backed frameworks have you been burnt by in the past?
npm is probably the greatest part of the JavaScript ecosystem right now.
Also I would say that it's best to use modules + browserify rather than frameworks.
ok, if you go through the link http://www.attuts.com/webcam-and-video-using-html5-send-video-image-to-server/ you see that, save button is introduced to save captured image to server which is php part. 
The beauty is that semicolon insertion makes them optional, and a lot of people write code without them. https://github.com/yyx990803/vue/blob/master/src/api/data.js Just be aware of [the gotchas](http://mattdesl.svbtle.com/to-semicolon-or-not). 
brakmic: Stupidest Thing I've Ever Heard.
I've used Differential packages many times in the past, thanks! Have a burger on me /u/changetip
I'm using a single rate limited api and caching periodically into json files. It seems an easy way to go and I'd have thought a fairly scalable method, although maybe a document-based db would be better. I prefer the idea of caching periodically - just think it's a nice controlled way of going about it.