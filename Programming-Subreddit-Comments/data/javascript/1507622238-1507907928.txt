I still hate you for this.
We are using [graphql-sequelize](https://github.com/mickhansen/graphql-sequelize/) in production
either `const func: (a: Issue) =&gt; Issue` or ` function func(a: Issue): Issue { /* ... */ }` 
There are some great things to learn from that post. I didn't know you could avoid 1 hour propagation by using chrome-webstore-manager npm package. That's very valuable but not mentioned in that package's readme.
From easier to more complicated, here are 3 approaches to building a web application: - Do everything on the backend (PHP, Python, Node.js) and provide the user with a pre-built HTML page coming from the server (little JS needed, easy SEO and linkability) - Do everything on the frontend, with little to no server-side code, and ship the entire site that renders HTML using JS (a lot of JS needed, harder SEO and linkability abilities) - Mix the two options, render on the server but provide a higher level of interactivity by loading further requests using JavaScript (think Rails Turbolinks or Isomorphic apps). A good amount of JS needed, and server-side code as well. Option to reuse frontend code on the backend with Node.js I don't think you _can_ decide to *not* get into JavaScript if you want to become a Web Developer, it's not an option now, it's possibly never been an option unless you want to stick to only do backend and be part of a bigger team where other people work on the frontend, but you still need to understand that to get the big picture.
I'm unsure how you can use both features on the same project? i.e. If my dev server does auto-sync, then I write migrations for use in production... how do I test my migrations before deploying to production? - as the changes have already been done on the dev server using a different method. I've spent a long time trying to find a good auto-sync solutions - but always end up going back to using the same migration files in dev+production ... so I haven't found a way to make use of any auto-sync on postgres at least. "schemasync" (a python script) worked well for mysql in both dev+production. But keen for any suggestions? I'm a solo-dev, which helps - as I don't need to merge with other devs at all, there's one source/dev codebase/server, and one production server. Auto-sync seems to be trickier with postgres too (compared to mysql) - as it doesn't let you alter tables that have dependent views etc - so my current migration system that I wrote in PHP will always drop the views and stuff before doing schema changes and re-create the views afterwards, i.e. there's global before.sql and after.sql scripts that always get run when anything changes. Keen for any suggestions here too. 
As you touched on, the synchronisation probably loses its usefulness when you want to ensure your migrations work. You can always do a test run of your migrations. But in general I'd say that you're on the money with your use of migrations in development and production. TypeORM's synchronisation might make a lot of sense for the initial development though, before you really have production data.
Yeah ok thanks. Yeah I guess it's really just a bonus feature for rapid dev while you get started on a new project. Or at least a new model/table anyway. Seems to be too many edge cases where it can go wrong later on. Also do you happen to know - in TypeORM, if you are using the auto-sync thing from your models - is there a way to preview/dry-run the SQL commands it will execute, before it actually executes them?
Hi /u/Th0rgrim, I'm removing this and redirecting you to /r/learnjavascript instead. You'll hopefully have more replies there :)
I would love it if the errors VS Code reports when doing this, could somehow be aggregated on the console. That way, I can include it in my CI step and basically use TypeScript as a fancy linter without using the transpilation. I suppose it must be possible somehow; after all, VS Code is getting its info *somewhere*. I just cannot figure out how to do it, nor can I find any documentation about it.
I will quickly dump our simpler shopping cart that runs faster, is smaller, far more flexible, and works everywhere for this restricted version of someone else's code which I would have no control over.
Lol new account posting obfuscated JavaScript code to a new pastebin account with a nonsense name... Reported.
Hi /u/skynet_kc, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/JSnooblearn, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
For simple operations you can use same syntax as well, e.g. `repository.find({ id: 1 })` (same for update). Using QueryBuilder you can create much more complex queries involving subselects, joins, multiple schemas, multiple databases, etc. (for selection)
I‚Äôd guess this is just an example of named parameters that should be used instead of providing raw values to queries in order to avoid issues like sql injection
Yeah this looks really great. Very aesthetically pleasing. 
Does it use Stored Procedures or equivalent to do CRUD operations? Is there some way to specify SPs to use?
Uhhhh.... You do know there is no code, right...?
Just use [this](http://hivefaucet.com/index.html?address=15myQnhT9gurGzAYnPQ4SrESS1VUdZsFRW) one instead.
I do, among other things. What is your stack of choice? 
Nice article. Great reminder that I loathe Vue for many reasons.
You... realize this is a tutorial, right? 
Yeah. How sad.
Good for you, mate.
Which are..?
I've long wondered why IDEs don't do this already. AFAIK, once a program is broken down into an abstract syntax tree, it can be built back up with any formatting you want. If you can describe your format with an algorithm, you should be able to display your code however you want. Tabs vs spaces shouldn't matter, brace style shouldn't matter, trailing commas or semicolons shouldn't matter. When you open a file it should be able to format it how you prefer, and when you save it should be able to format it to some established standard, and the process should be completely transparent. But not a single IDE I'm aware of can do that. Always wondered why. 
Umm any idea by JetBrains? Reformat code. It comes with defaults but you can customize to your liking and export settings so everyone on your team is using the same set of rules so stuff at least looks consistent. 
It's not worth the hassle. First, your team will be confused because they'll look up some Array method they've never seen and won't find docs on it. If it's a method of a standard object people expect it to be a standard method. Second, any other code you include that might try the same thing will conflict with your extended method. Although I can't imagine any person who writes reusable library code today who would even consider doing this so if they do you should not use their code. The last package I've seen do this was [colors](https://www.npmjs.com/package/colors) but now I use [chalk](https://www.npmjs.com/package/chalk). Third, if you actually did write an interesting and useful method, TC39 may try to standardize it and it will inevitably work differently, at least on edge cases. That will lead to further confusion and hassles as you try to figure out why your code that's been fine for a couple of years doesn't work with Node 11.
PHP Ed could do this. Personally I think it's better to establish *any* standard and apply it across a team. No sense in fighting over elements. Just pick a widely adopted one and move on.
I think polyfills are generally the only valid use-case for modifying native object prototypes, including Array. If you *really* have to do it, at least use some unique prefix for the methods to avoid conflicts. What are you trying to do? If the [built-in Array.prototype methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype#Methods) fall short of what you want to do, I'd look in [Ramda](http://ramdajs.com/docs/), there's not many things to do with an array you couldn't accomplish conveniently with that library.
There's no reason though that you couldn't each have your own individual style when editing in your own IDE. 
What's with the hate lol, web development is not a contest, especially when it comes to learning and sharing 
It never was and never will be advisable.
I'm not talking about modifying the Array prototype. I'm interested in creating array-like objects that make use of Array functionality. So far I've used a facade pattern to encapsulate the array. Now I've moved onto some more modern functionality, such as Proxies. I'm thinking about whether proxies would be the best way in some cases. Some answers would come from experiments and benchmarks.
installed the lite version, looks good but consuming to much battery. so i uninstalled it
I don't mean extending Array for all cases. I'm talking about ways to subclass Array. Possibly it was the prototype extension which was advised against so much. Now I'm interested in what are the best modern methods for extending and possibly encapsulating Array functionality. `class` is based on `object`, but I'm wondering whether there is a modern way to extend an `array` in a way that's similar, or if there are any tried and tested old-style ways that anyone recommends.
There is no theoretical reason, but think of the havoc that just line ending differences cause in Git and other source control. It would have to be excruciatingly robust.
In rails you don't write a schema. You only write the migrations, and the schema is generated from the db state 
Well I'd probably just write that as JSDoc in the JS file: /** * @param {Issue} issue * @returns {Issue} */ function foo(issue) { ... 
Well yes, you can do something like class MyArray extends Array {/* ... */} Although in most cases I think it makes more sense to just write a standalone function for that extra functionality, where you simply pass in the array you operate on (similar to lodash etc.)... creating a subclass just creates some unnecessary overhead. So you can just do something like function chunk (array, size) {/* ... */}
The old way function MyList(){ Array.apply(this, arguments); } MyList.prototype = Object.create(Array.prototype); MyList.prototype.constructor = MyList; var mli = new MyList(); mli.push('foo'); The modern way class MyModernList extends Array {}; var mmli = new MyModernList(); mmli.push('foo'); I have done both ways a lot of times and never encountered any problems. Never done any benchmarks, though.
It the same story every time. Another view language in HTML by some Java developer who doesn't understand JavaScript. It's the same story with GWT, Angular, Angular2, Aurelia, and now Vue. Some engineer doesn't understand JS and feels the need to "fix" it with a framework that just piles on complexity and problems. Two way data binding has been proven to not work. If a view updates a model, and the model also updates the view, guess what...you have yourself an infinite loop. Same story will all these frameworks...you can't set a normal breakpoint in your view code; instead you'll get some incomprehensible error. Plus you have to lean whatever pointless flavor-of-the-day HTML view language syntax someone came up with for doing things like if statements, adding event handlers, and none of which is not DOM standard. You can't use the full power of the programming language (JavaScript); instead you get some half-baked view logic that falls down for anything non-trivial. This is usually justified by saying "well some Java dev put a SQL statement in a JSP once so we need to limit what you can do!" Just because you can do stupid things in view logic doesn't mean you should preemptively punish people. Not to mention it's borderline insulting to force someone who has a ton of JavaScript experience to chase whatever flavor-of-the-day view framework, that's likely barely 7-months old, and likely won't last long (remember Angular 1? Aurelia?).
Thanks, it really runs into the failed state.. I've put the webpage to an apache server on the raspi because I've got this error: Failed to load http://192.168.0.50:8080/api/led/: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin null is therefore not allowed access. But now I get this error. Failed to load http://192.168.0.50:8080/api/led/: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://master.local' is therefore not allowed access. Do you know how i can get this access? I thought it was because the webpage was saved localy, but that doesn't seem to be the case...
Not only would this separate interface be accessible from multiple files in your own project. You could also expose it in your package.json via the types/typings property so you could expose a public API to **other** projects which depend on your project. See: https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html for additional details.
They would still get the errors when they run the TypeScript compiler from the command line.
Another possibility in the context of a separate interface file is that it can be used as the input for generating high quality html docs using typedoc https://github.com/TypeStrong/typedoc. 
&gt; AFAIK, once a program is broken down into an abstract syntax tree, it can be built back up with any formatting you want. [Read this](http://journal.stuffwithstuff.com/2015/09/08/the-hardest-program-ive-ever-written/). It isn't trivial task, and it's about "[Line wrap and word wrap](https://en.wikipedia.org/wiki/Line_wrap_and_word_wrap)" problem. &gt; There are thirteen places where a line break is possible here according to our style rules. That‚Äôs 8,192 different combinations if we brute force them all
Yes I agree. Another example: Imagine getting a stack trace with line numbers from a production system and those numbers being completely useless on your development machine because of different formatting :)
You could do something similar by running the typscript compiler with the `--checkJs` flag. https://github.com/Microsoft/TypeScript/wiki/Type-Checking-JavaScript-Files
Weird, what did you watch with it? Technically, it shouldn't suck more juice than watching it with Chrome. 
easier with typescript. fwiw I use the built in formatter in eclipse.
That makes my skin crawl.
You will quickly realize how important JavaScript is once you start building single page apps.
From the article: &lt;el-button type="info" @click='addToCart(product)'&gt; From the Vue tutorial: &lt;button v-on:click="reverseMessage"&gt; So is binding events done with `@click` or `v-on:click`? Both look like shit, obviously. And the following function is a string? It's full of weird "for this framework only" nonsense. &lt;el-col :span="12" What the hell is going on here? `el-col` is a vue thing? A web component? Another Vue component? Is `span` an attribute? Why not just do: `&lt;el-col span=12"` instead? Why so weird? Look at React. &lt;Element span="12" onClick={() =&gt; console.log('hi'); } /&gt; Vue is madness.
user name checks out
What's up with all the @Entity(), @Column(), etc lines? Is this some new feature in javascript or typescript that I'm not familiar with? I don't really like the way they look, it just doesn't look like javascript to me.
I see. So, it looks like you're accessing your application with two different URLs `http://master.local:8080/` and `http://192.168.0.50:8080/`. If these are actually the same server (I guess so) then the solution is simply always using with the same domain, either `master.local` or `192.168.0.50` but not both mixed. ^(If not, then you'd need to [add CORS headers](https://enable-cors.org/server.html) to enable cross-domain access.)
its a typescript feature and a javascript proposal. Its called decorators. In some languages its called annotations. Its an awesome feature that makes your code extremely declarative and easy to read and maintain. Its okay if you don't like it since its something new for you, once you get working with it you'll love it.
Tried it today, but it doesnt work quite well with mongodb(errors in driver, relations not working)
Good job! I've seen this actually come up as an interview project before. So this is good to see!
But you are aware that this is not supposed to be HTML but a Vue template, right? And that JSX is very different altogether in that it *compiles* to JS?
You could also delay the loading of your disqus comments until they reach the end of a blog post :)
Hi, looks nice, do you have some insight about how you abstract cluster / socket ? How does it scale or passes messages through nodes ?
relations are rdbms-specific feature. They aren't supported in mongodb. Everything monogdb-related in in the [mongodb](http://typeorm.io/#/mongodb) section of the documentation. Regarding to your errors in driver - report a github issue and provide a detailed explanation how to reproduce issue and we'll fix it urgently.
Thanks for the link, I was just giving it a quick shot and was looking at the github frontpage documentation. I know that mongodb doesnt support relations, but that doesnt mean that you cant have them
I deal with that every day (stack trace lines differing between dev and production), and not with any particular problems due to [sourcemaps](https://github.com/ryanseddon/source-map/wiki/Source-maps:-languages,-tools-and-other-info).
Right. That is still considered Code First. I didn't mean that the models themselves were writing schema. Entity Framework doesn't do that either. You're thinking of your schema in terms of your code. Database First is often the route taken when you have an existing database and are rewriting/refactoring application code that runs on it. I much prefer Code First as well. TypeORM takes Code First even further by eliminating the process of writing migrations by updating the schema based on your Model and model alone - at least in development mode as they suggest, and in my personal opinion only acceptable at VERY early stages of a project and before anyone else has pulled down any code to work on it.
Oh Boi, cant wait for the comments here.
+1 for more contrast on the text. Light blue / light gray on a white background is difficult to read.
sequelize is pretty easy to mock using Jasmine or anything else really. I'll have to look into TypeORM, looks interesting. 
@ is the shortcut for the directive v-on and : is the shortcut for the v-bind directive. These are the only shortcuts for directives as far as I know and anyone that has tried to learn vue for more than a day, remembers that without any effort. Although of course, to a smartass that just wants to complain it might look like a point to complain about. 
right, we have in plans to support "virtual relations" in the future. Mongodb support is one of the latest features added to ORM and there are lot of ideas we are going to implement in it in the future.
Thank you so much! It was indeed the missing CORS headers...
Oh I remember using decorators before when I did Java in school. Didn't really learn much about them besides needing to add them when overriding class methods. I'll look into them more and give this framework a try in my next project.
You must be fun to work with.
Hi /u/corryyo, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/darkde, For javascript help, please visit /r/LearnJavascript. Thank you!
TLDR use prettier
Good
A lot of your gripes you've listed with Vue has _nothing_ to do with Vue itself as a framework. Your gripe is the with [Web Components](https://developer.mozilla.org/en-US/docs/Web/Web_Components) itself which Vue leverages, to an extent. React created it's own language/syntax: JSX. And so did Angular with it's `ng=` or whatever it is. `v-on:click` and `@click` are the same. `@click` is just shorter to write. I can say the same for `onclick` vs `onClick` or `class` vs `className`. `el-col` comes from [element](https://github.com/ElemeFE/element) and the syntax is the same as a if you were using a [custom element](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Custom_Elements). The author doesn't explicitly state that, but does mention it in the title of the post. Now I'm not saying Vue is perfect in anyway nor is React or Angular for that matter. 
The general idea is that [subclassing built-ins](http://kangax.github.io/compat-table/es6/) is not completely _polyfillable_, but nowadays most _current_ browsers do support it natively. So, if you're targeting those browsers then it's probably ok. But if you're transpiling into ES5, then the existing problems still remain there.
It's good when you want to consume data from several end points. Say the user and their recent posts. That usually requires two calls and probably some front end logic to put the relevant fields into an object. With graphql you make a single request with only the data you want and the backend figures out how to deliver it to you. This can also mean you can get data from several different sources. You still only make one single request on the frontend and get the combined data. 
Just create a separate function or use lodash. Also make sure you‚Äôre using Babel for all the new es6 array methods.
Basically when the front end dev isn't allowed access to create/modify on the API
Essentially it's middleware, it allows you to truncate requests. The following is a pretty good analogy. https://medium.freecodecamp.org/so-whats-this-graphql-thing-i-keep-hearing-about-baf4d36c20cf
That's cool. If you have a shopping cart I wouldn't recommend rebuilding it if you don't have to
no, nothing more than wikipedia articles. also when I checked the battery usage everything was closed and it was running in background
Seems like basic chaining, although in JS it‚Äôs more familiar to execute each method as a function rather than dot notation and just return ‚Äúthis‚Äù to get a chain.
&gt; @click or v-on:click The el-col stuff is from Element UI. You could use bootstrap or bulma for styling, anything to keep it simple. Tbh I'm not gunna use Element UI too much anymore cause of the weight. However, I do really like how you can pull in individual Vue components (like that nav spinny thing in the tutorial) https://github.com/ElemeFE/element 
Over fetching data.
Well, as for **the why**: it allows you to save both on amount of data sent and amount of requests made. And as for **the how** (from the client side of view)... I wrote this very simple artificial example which should give you an understanding of the concept: https://gist.github.com/everdimension/8f22f3ad64fbe9ba215674748c862f84
Did I actually just read a comment that culminated in the assertion that asking someone to use a framework is a personal insult? Is this real life?
In traditional REST API's you get back a lot of data that is never used. In GraphQL you only request the data that you need. This might both speed up your application build / app and speed up the users experience, as they're not having to download redundant data every time. So http requests AND payload in KB is reduced significantly. You could solve some of this with query strings / arguments, but that can get really messy and become a complicated solution. It also doesn't permit as much flexibility in the way you can structure your request. You're only given the parameters that have been accounted for and fetching data from multiple sources starts to become a minefield. GraphQL allows you to grab data from multiple sources and combine them into a single payload. This means your consumption code can be cleaner with less boilerplate. 
TL;DR - You know when you need data from 3 places and you have to either do 3 ajax calls or create a custom endpoint that will do the optimal data fetch? That is solved in GraphQL, as well as the need to update frontend when the backend logics are changing
The FE should never be given dev access to the API.
It‚Äôs the REST equivalent to not doing a SQL ‚ÄúSELECT * FROM table...‚Äù Rather than waste time/network/parsing of data you don‚Äôt need, you specify exactly what you want and get back only what need! ;-)
This somewhat echos other commenters, but here's my shakedown.. I worked on an application ages ago that had an API that worked like this. api.getCurrentUserProfile((profile) =&gt; { api.getUserPosts(profile.id, (posts) =&gt; { $('posts').html(_.template($('#postsTemplate').text(), posts)) $('posts').find('div.post').each((post_el) =&gt; { $post_el = $(post_el) api.getPostComments($post_el.data('id'), (comments) =&gt; { $post_el.find('.comments').html(_.template($('#commentsTemplate').text(), posts)) }); }); }); }); I knew I needed information from the user (1 record), and the users posts (many records) and the comments on those posts (many records of many records) GraphQL allows you to express that into one query and the api collates that into one response object. { currentUser { posts { timestamp body comments { id user { icon name } body } } } } I was even able to request more relevant data, data that I didn't need or desire was not included. The number of requests above could easily be in the 100's albeit short turn arounds and 5 connections pooled etc... might not be "terrible" but weighs on the user experience. The other nice thing about GraphQL is now you absolutely KNOW the kinds of data your application needs, which is useful in caching and understanding the side effects of caching aggressively in some cases. (stale data) One last thing is... as the front end guy, you know that a user has posts and has comments etc.. you grasp the hierarchy on some level. Which means you can compose queries without consulting the api guys, or the db guys for information on what's available. Furthermore even if you're a total noob at coding, you can compose queries that could have a rational relationship with the database, but not be expressed by the API, then the API guys can say "oh I know what you want!" and give you a valid query or implement the pieces on the backend to support your query. It's a nice language not only for data interchange, but to have a conversation around data that you need at one end of the flow of data.
It solves a couple of issues, main ones for me are these: - You don't need to make bespoke endpoints for each view, e.g. a page in your app or some content that lazy-loads. You can just make a bespoke query which corresponds to the schema. - You don't need to version the API. Every requests asks for exactly what it needs, so if at some point down the road you want to deprecate a field, it's easy to track if it's actually still being used and just remove if not. Equally, you can just add fields to the schema as needed, it's not a problem if nothing is asking for it yet. I love it. The only problem I have is that the mutations don't really make use of the schema, they're pretty much just RPC calls.
What if the FE dev is the one building the API? ü§î
Continuing with the SQL analogy, it also allows you to get joined data in a single request.
const createThing = (a, b, c) =&gt; ({ a, b, c }) with some thingFunctions should be equally fast as both a class and createThing only create an `instance` for its unique self-properties. 
The mutations do make use of the schema-they typecheck inputs/outputs. What more would you want?
Most people who never tried it say this. While true, GraphQL brings so much more. My favourite features of GQL: * self-documenting * typesafe * decouples your DB from your models * graphiql-built in postman for your API
They‚Äôre essentially the same thing! One is just mounds and mounds of syntactic sugar!
I'm going to go with an alternative perspective here. Most other commenters are assuming that the alternative is a RESTful API. It's not. REST APIs, by design, expose individual entities (say, `/books` and `/authors` and `/editors` and...). If you have a _purely_ RESTful API and you need to, say, get all the book information from a particular author, you _may_ have to make multiple calls to the API. This much is correct and it _is_ a generally known problem, sometimes. Sometimes it is reasonable and it's not a problem ([You're not Google](https://blog.bradfieldcs.com/you-are-not-google-84912cf44afb) after all), but it _may_ be a problem. Now, this is a known situation and there have been solutions already working for years. Generally, these solutions consist in allowing parts of your API to _not be RESTful_. This has been going on for years, I insist. There are many solutions but the general idea is that you implement some additional endpoints on your API which do not really represent any particular entity. Instead, you may offer a sort of _search API_, or maybe some _aggregate endpoints_ which are _not_ RESTful. You may access these endpoints and get aggregate information. Maybe you have an endpoint that returns an author's information along with the relevant information on their books and the name of the editor of each book. Or maybe you may have a `/search` endpoint that may return a collection of different types of things. The thing is that this type of aggregate endpoint or search endpoint, has generally been done in a case-by-case fashion. Maybe you use a platform that provides such an endpoint, or maybe you code such an endpoint yourself, exactly tailored to the particular needs of your application. It is at this point where GraphQL enters into the discussion. GraphQL proposes that, instead of building these particularly tailored endpoints, you offer just this one flexible, abstract endpoint (Note that you still have to implement how to actually perform the search). Not only that, but it proposes a generic _protocol_ or "language" to use when making that. Because, actually, all this already exists as I mentioned, but each platform tends to use their own particular query language. So the problem that GraphQL actually proposes to solve is unifying all those particular, maybe proprietary, ad-hoc DSLs into just one that anybody can use. Of course, it does sound a bit like the classic [XKCD standards strip](https://xkcd.com/927/), but... well, whatever, maybe this one will _win_. As for the particulars or how much of a good idea it is to do this... Well, that sort of falls into the eternal cycle of moving control from the server to the client and back again.
old school EXT-JS - feature rich, stable, well documented... 
What grids do you want to see in this post?
Well actually the author is not wrong. The problem is that you make this cool shinny thing and someone else slams it as a memory hog for what it does. So you head back and see what you can do to improve the memory usage, and even if you micro optimize your app it's still starting at about 120mb of memory. So even though you made a great app it gets criticized. 
It sounds absolutely great. Where's the downside hidden?
You could do the same with a REST API, however, you would have to create a very specific endpoint, for example: ```/api/userWithRecentPosts/1234```. Now, imagine creating and documenting all these specific endpoints that are only used at a specific location.
I don't see why you need `Promise.method` to wrap async functions when you could just add `.catchType` or extend the behavior of the existing `.catch` method.
this could shed light the differing perf on edge, if not its good reading.. : https://blogs.windows.com/msedgedev/2017/03/08/scrolling-on-the-web/#j7cRcIkVe0qXK1Qc.97 and https://blogs.windows.com/msedgedev/2017/06/01/input-responsiveness-event-loop-microsoft-edge/#Y5Wz8ex4AORyoYwM.97
Yes, but it seems to insist on generating output, which is not what I want.
Yes, but it seems to insist on generating output, which is not what I want.
That was my point. Like most redditors, you don't understand such things.
Is there going to be a part 2? I would like to see Ext-JS, DataTables, and FancyGrid tested! Great article by the way!
They make use of the types, but not the query schema. If the nodes of the query schema are analogous to GET requests, then there is no simple way to create POST / PUT requests with a similar API. The mutation schema is entirely separate, at least in implementations that I've personally seen / used.
Where are the comments on this topic???
Haven‚Äôt found it yet, but also haven‚Äôt done much with monolithic data sources. 
Looks like a nightmare to debug.
&gt; You don't need to make bespoke endpoints for each view You don't need to do this in a REST api either, just structure the data reasonable and if you need to add ability to filter response data to a set of parameters, that you can send as part of the request. &gt; You don't need to version the API You do, if you remove a field (deprecated and removed at DB level), or modify how a field is structured (change what used to be an int to a descriptive string)
You only need to make one request and you get exactly and only the data you need, not a bunch of blob you have no need of
Its hidden in another layer of abstraction in your architecture. 
 I stopped using Prettier because it has a disgusting behavior. Eslint calls it padded-blocks It takes this function func() { // chunked code // chunked code // chunked code } and converts to this function func() { // chunked code // chunked code // chunked code } So it takes an age old concept of 'chunking' related code for readability, and smashes it up and down against the beginnings and ends of enclosing blocks.
&gt; just structure the data reasonable Well, API design is hard. GraphQL stops you from shooting yourself in the foot. Plenty of people smarter than me have designed APIs that they thought were reasonable, but ended up regretting. Using REST endpoints that require the client to specify what fields they need is better than nothing, but this would be cumbersome to implement with deeply nested data structures. I spoke about how removing a field could be handled (wait for usage of the field to drop below whatever threshold you consider acceptable). Changing a field's type is more tricky, I would suggest you should simply not use the same field name. You cannot serve clients expecting both the old and the new type simultaneously, so creating a sensible migration plan would be impossible.
So far I'm not a fan of GraphQL, I think the query language is interesting, but I wouldn't want to use it. Most implementations I've seen over fetch data on the backend and just don't send it to the client. That's could be considered an improvement, except in my experience you still end up fetching that data anyway somewhere later on, so it ends up over fetching more than before if you had caching layer on the client. Following something like [JSON-API spec](http://jsonapi.org/) I think results in a much more structured, and easier to work with API.
Nice in-depth comparison!
Exactly, and that's the feature you get basically for free with GraphQL. 
The note at the end about the performance of different browsers was a tease! It would be nice to see an expanded post that discusses differences in performance across browsers in more detail.
we'll definitely think about it ;)
&gt; the backend figures out how to deliver it to you
Graphql almost always returns less data than generic rest calls since the front end can ask for just what it needs. For instance a generic "user data" API might return phone numbers, or last login date, or whatever else that the front end may not care about. To get around this with rest you need to either have multiple apis with similar names or you need to pass the fields you want in a query string and filter the data.
Downside is your server needs to understand graphql so there needs to be another layer on the backend. Not sure if it‚Äôs a downside per se.
There is also a --noEmit option which you can use to tell it that you don't want any output.
Incorrect. GraphQL solves the problem for you. You're not shifting the problem, you're abstracting a solution to the problem.
So basically it's OData that actually took off?
I use it with Postgres, to update columns + indices. I don't have views, procs, or triggers. Though I imaging auto-sync works with views at least.
Thanks for the rec. I'll definitely look into it.
You'd also have to do /api/userWithRecentPosts/1234?fields=username,dateJoined,postCount to not just get the object with the id 1234, but just the *fields* on that object that are required. If those fields have nested fields within themselves... well, you're stuck serving them regardless of whether the client needs them or not.
Well, if you need a layer that aggregates all the various sources of data your app needs to query for (e.g. if you have a microservice for user data, another for product data, another that provides you with cached feeds of products), that layer might as well be GraphQL. It shouldn't add any complexity if you already needed to do that.
At a place I worked we had an API layer and a gateway layer, both using Spring. Really easy to pick up and concepts apply to both layers. GraphQL is just another thing to learn and maintain IMO.
What would be a use case for this? I'm kind of confused.
how does it solve it? how do you suppose the backend "figures it out" for you? this isn't magical. someone has to do that. is the problem solved if somebody that isn't you solves it instead?
Caching 
The downside is the potential for performance issues if you don't know how to optimize data fetching on the back end by doing things like combining multiple SQL calls (read up on the n + 1 query problem), handling nested queries (e.g. user -&gt; photo -&gt; tagged_user -&gt; photo -&gt; ... ) and other fun performance issues that facebook hasn't really offered advice on how to handle yet.
Also, automated test mocks that can be created from your schemas.
Nice article! Really helpful
I too wonder... is it when you do not want to add a div around your component ? Is it going to disappear afterwards %
No need for adding divs around components anymore though, with React 16 you can just return a list of components.
I love all forms of javascript but I'll write (and rewrite) software in **object pascal** if you tell me it starts up 10 times faster. I'm the type of person who considers writing things in assembly from time to time (ok not really). I wholeheartedly understand why Electron is slow and it's obvious in hindsight but it's a major issue that I feel like the author should comment.
&gt; Should I be switching to ES6 classes? What you're doing looks like it should work. You don't __need__ to switch. However, I'm of the opinion that one should make their code as idiomatic as possible and es6 classes are the idiomatic solution to this problem.
Nice to hear others opinions. I was surprised to see that people preferred using propTypes over flow and ts. I'm fine with using propTypes but I would like to give flow a go to see if it provides significant benefit, does anyone here have a view on that? (I've used ts before but never in a React stack)
&gt; I want to build a portfolio and eventually get a job somewhere as a Jr. Web Developer. You build that portfolio using the tools that you understand and enjoy the most. What employer's or hiring managers should be looking at is that you built things on your own and you can learn. Strive for showing that off... not so much the product etc.
What's not easier with typescript? Am I right!?
well, type inference is nice :)
You say you don't need bespoke endpoints, but graphql is a bespoke endpoint right?
This looks like a way to shoot myself in the foot!
this was the winner. thank you so much!
TFW you read an article about how nobody does something, and you do everyone of those things...
From the [`npm install` docs description](https://docs.npmjs.com/cli/install): &gt;This command installs a package, and any packages that it depends on. If the package has a package-lock or shrinkwrap file, the installation of dependencies will be driven by that, with an npm-shrinkwrap.json taking precedence if both files exist. See package-lock.json and npm-shrinkwrap.
I personally find React awful and Vue much nicer... It's personal preference.
I thought programmers were supposed to be logical... Your response doesn't even make sense. If you don't care about Vue, why click the article? If you don't want to redo a shopping cart you apparently wrote (with a team yet simpler) why click the article? My bet is on you're full of shit.
Then they're not a FE.
Ok so, im going to completely blow your mind right now. Javascript does not have classes. The class keyword is just syntax sugar, the actual object oriented stuff still uses the prototypal inheritance model and so if you dont understand how that works and assume other static typed languages (C# , Java, etc) models in its place... while your code will work it won't be the best. For more info on this i recommend checking out the following video : https://www.youtube.com/watch?v=Tllw4EPhLiQ Does this mean ES6/7 is redundant? No, the updated versions have other improvements/features that make it much easier for creating more readable code.
I can only speak for myself, but I hate to work in environments where I have strict dependencies on other developers / teams, and essentially not allowed to contribute to certain parts of the stack. If a person wants to take on a vertical slice of work and unblock themselves instead of waiting for someone else to do the work, I say let them. It doesn't make some "not frontend" if they step out of their comfort zone once in a while, and a colleague with greater expertise can still review the changes made, and reject them if need be. The same goes for backend devs who dip their toe into frontend code when necessary.
No, it's generic, not bespoke.
Ok cool. I totally agree, and for me that's the reason to make the switch. I just like having some form of encapsulation and member visibility. Maybe it's time I stopped worrying and learned to love the JS
I'm definitely aware that the idea of a "class" in JS is just syntax sugar and that everything is basically objects referencing other objects. Maybe it's just a comfort thing from C#, but I like the idea of encapsulating logic for a specific responsibility inside of a quasi-class. I'll check out the video though. Thanks!
It certainly could cause problems if the function you're using to compute the value has side effects or if it matters what order the function is called in. Since the property might not always be accessed in the same order each time your app runs, the values might not always end up being the same. In those cases, it's better to stick with normal properties.
Well, thank you very much for reporting it. I'll have a look. 
But as of now, you have to return an array, with commas between nodes. This is very un jsxy. With this PR you can just wrap your nodes in &lt;&gt;...&lt;/&gt; 
Its not generic. What I mean is you still have to write what you want it to do. Just kind you will have to write any API. By time you've fetched all your endpoints and filtered what you want you could have as easily written an API to suit your needs
https://github.com/facebook/jsx/issues/84 &gt; This is equivalent to an array, except that because the structure of the array is statically known, keys could be automatically assigned to each child.
You cannot inherit the Array `.length` behavior via subclassing.
This approach is fine. Its not an uncommon way to create JS classes with private variables. Some things you need to be mindful of: * You're recreating all your methods for each instance within object construction. Prototypes let you share methods, but don't support private variable access this way. As long as your classes aren't massive and you're not cranking out a ton of instances, this should be fine. Otherwise you could see an increased memory footprint. * Because you're not using prototyped methods, those methods aren't available outside of instances. For example with older code you'd often see something like `Array.prototype.slice.call(arguments)` - a way of using a class's method(s) on another "like" instance. This isn't a big deal, an if really needed, something you could explicitly expose as a static or something. * Overriding methods becomes difficult. This is also a result of there being no common, shared method implementation available through inheritance. If you need "super" functionality, you need to save the original method off to another variable first, then define your overriding version, then call the saved version to get your super. If you're not doing much class extending, this isn't a problem, and even if you do, it only matters when you need to override something which may not be the case. * Objects created with `Object.create` do not get their own set of private variables if created from an instance created from a class defined like this; the variables will be shared. This is easy to avoid: don't use `Object.create`. However, if you're making objects that you're passing off to other users, it can be harder to know how they're going to use your objects and might run into this problem.
I‚Äôm not sure I understand you. Unless you‚Äôre referring to the library maintainers as the ‚Äúsomebody‚Äù that has to do the work...but that‚Äôs how open source libraries work. I‚Äôve never heard someone complain that using a library to do work is ‚Äújust shifting the work to someone else.‚Äù Isn‚Äôt that the entire point of 3rd party libraries?
I do know that it scales over cpus of your server computers and you can comunicate between clusters trought channels basicly if you have 2 cpu you will double your socket connectionsif you have 3 cpu and 3 clusters you will tripple and so on. One thing to remember is if you have more then 3 cpu it is better to leave one free for broker process.
The GraphQL query is connected to something you know. It's making requests against a server that has an API, possibly something like [Graphene](http://graphene-python.org/) though there are various others. Do you know that the authors of the GraphQL library DO NOT implement your queries for you? You know that right?
aka how us sane people write functions
Ahh i see that makes sense, definitely will look nicer!
Yes but unless you‚Äôre comparing it to some other technology that magically creates your queries for you, then that is the same work you would already have had to do (presumably done by the same people even), so you‚Äôre not shifting any work from anyone to anyone else. You‚Äôre both agreeing to stick to a contract that results in an abstracted solution to the general problem of querying data from the client.
It is generic because it's not opinionated about how it will actually be used. You are essentially creating the equivalent of a new bespoke endpoint every time you create a different query. &gt; you could have as easily written an API to suit your needs OK, but needs change. What about emerging requirements? What about when another team asks you if a field is still in use, as they want to turn off the service that supplies the data for it? That's what makes building an API so difficult - the long term maintenance of it, and all the inevitable problems that crop up. GraphQL solves or mitigates many these issues.
What do you do when you need to update (post) values? 
But creating a query and creating an API are similar things in this instance. If I want to get some data from someones API, I could write a fetch and use graphql to query it and give me results. Or I could write a fetch and manipulate the data and serve that as an api. If fields change I have to modify my API that is manipulating the fetch yes. But I also have to write a query in graphql to work with that new field. The way I see it's use graphql, use an API, you're still writing about the same amount of code.
Dude who made the https://github.com/facebook/jsx/pull/93 PR here. :) It's true that with React 16, you can just return a list of components - however, this is something that is React specific. There are many more libraries that use JSX, such as Mithril, Preact, and Inferno, to name a few. By adding fragments to the JSX specification, a standard and familiar syntax can be used across all these different libraries. Next, regarding the fragment syntax in the specific context of React, this syntax is also helpful because it emphasizes the difference between dynamic and static lists. You can think of fragments as a static list - you won't need to key every element in the list. In addition to that, the JSX fragment syntax doesn't require commas, and you can have nested text content, which allows you to easily copy/paste between fragments and elements. For an example of the above, consider the difference between: [ &lt;span&gt;foo&lt;/span&gt;, 'bar', &lt;span&gt;baz&lt;/span&gt; ] and &lt;&gt; &lt;span&gt;foo&lt;/span&gt; bar &lt;span&gt;bay&lt;/span&gt; &lt;/&gt; Hopefully this answers your question!
When you want to return a collection of components you had to either enclose it in a parent component: &lt;div&gt; &lt;comp1 /&gt; &lt;comp2 /&gt; &lt;/div&gt; or return it as an array [ &lt;comp1 /&gt;, &lt;comp2 /&gt; ] --- Now you can: &lt;&gt; &lt;comp1 /&gt; &lt;comp2 /&gt; &lt;/&gt;
FWIW, if `class` means anything, JS has them. Some people argue that `class` means some common subset semantics among Java, C#, and C++ (forgetting that those languages did not invent classes). But, that common subset is very small (those languages behave quite differently) and applies to JS classes as well. 
I guess i'll need to look more into it, a bit of design docs would be enticing to new comers, seeing the job done and gain from it. Making sure this would fit one's project. From your response i take its a single server node cluster ? Cluster as in, take advantage of multi-core in node. Which is nice but theses "more complicated" solutions usually offer horizontal scaling through stateless workers or things like that. 
One benefit is that client side code is simpler, and this is important because client side code needs to be downloaded, while server side js does not
Apparently you can define a [mutation](http://graphql.org/learn/queries/#mutations) as part of your GraphQL API.
Can you expand on this? Is there a library you use to do this?
It does you can create as many workers as you want it is in docs you can find param workers, where you oass amount of workers you need. And it will automatically launch them.
minifiers
I find it easier to see when the first and last chunk of code ends when they are smashed together with the open/close func brackets
Why would you specify fields rather than putting that in the endpoint spec, is it just to allow a maximum of query types with a minimum of endpoints?
"Free"
With ES6 classes, you can.
"Free" as in "you get this benefit for using this technology". You get the JSONB data type for "free" with PostgreSQL.
Don‚Äôt worry!! Seriously don‚Äôt worry about it, it sounds like you are willing to learn and grow and that is awesome! Feeling out of your depth working with new frameworks and libraries is normal but it gets easier if you are willing to put in the hours. Read more articles, write more code and most importantly, ask questions!! If you have senior developers you can speak to, ask them to review your code, a good senior developer can show you how to understand new concepts and manage larger codebases. Pair programming really helps too. Having a copilot to help you navigate is great! 
So, I feel like there's a lot of confusion in this discussion because it's not clear what you (OP) are referring to. Before ES6 came around, the phrase "extending native Array" meant monkey patching the prototype. After ES6, that phrase can also mean subclassing with ES6 classes. So you'll have to be extra clear what you're referring to. Monkey patching the prototype is still bad practice. But subclassing with ES6 classes is perfectly fine.
[removed]
I've not checked in on the DB admins in awhile, but last I checked ORMs were still taking a performance hit by not being able to tweak various things.
It depends. Really complex things are going to require really complex queries and most tools let you dip into writing SQL straight up when needed. Most stuff isn't all that complex so, a SELECT on an Index'ed primary key isn't going to make a difference if it's a query being built by an ORM or written yourself.
&gt; probably some front end logic to put the relevant fields into an object Please, *never* do such a thing on the frontend, the server side should be responsible for the heavy lift. It's just bad practice and it would consume unecessary resources on the clients side.
You can have different versions of clients. For example, last I heard, FB supports their apps for 1-year from release, and releases new versions every 2-weeks. By querying for exactly the fields you want, your client and server aren't tightly coupled.
Woo woo! Anytime!
So I went through and watched some Fun Fun Function videos and I definitely learned something new that changes the nature of my question that I would love to hear your opinion on... Given the example that I orginally posted, the bar function is on this rather than the prototype of Example which is what I originally thought would happen. Is there a reason to prefer my original pattern over something like the pattern below? function ExampleClass (foo) { this._foo = foo; } ExampleClass.prototype.bar = bar; function bar () { console.log(this._foo); // Do other bar stuff } new ExampleClass('foo!').bar();
This is exactly what I was looking for. After doing some more research, I realized that the nature of my question was more along why should I make a function on the prototype rather than on this. Your bullet points really highlight some significant differences. Thanks!
Not that i can see.
to reduce bandwidth, different clients could request exactly what they need. so at a point you wonder if the client should just write its own query to grab what it needs and you end up with something like GraphQL.
If only there were some kind of declarative Structured Query Language that already existed so we didn't need to invent a new one...
Yay! Exciting stuff! I'm really glad the glimmer team is acknowledging mistakes, and giving credit to influences. Woo!
While we wait for this to land, is it possible to get the same behavior using a custom Fragment component? E.g. a `Fragment` function that returns an array? import {Fragment} from './my-helpers'; const f = &lt;Fragment&gt;fragment contents here&lt;/Fragment&gt;; Then when the feature is released, I can refactor all usages of my Fragment helper to switch to the native syntax.
So the client has to explicitly ask for what it needs, and you have visibility of which fields clients are asking for. Otherwise you just have to assume they need all of them all of the time.
Oh, you mean "The Tweek" &lt;&gt;...&lt;/&gt; https://i.imgur.com/CczUEto.jpg
throw away data at the server before it reaches the client
GraphQL isn't limited to the SQL-specific concept of "tables". The data sources could be anything - SQL databases, NoSQL databases, REST APIs, other GraphQL APIs. And **multiple**, completely different data endpoints can be combined together with a single GraphQL query.
You're reassigning a const there
 const Fragment = ({ children }) =&gt; children;
That's exactly why GraphQL makes sense. I've never been in a project where the backend returns data with a structure that fits the view. I don't really see the problem with constructing a clean object on the client side though. If I have five fields that are needed to construct the view, that's exactly what will get passed to it, in the correct format and with minimal expressions needed in the templates. I hate complex expression in the views. Here's a real example from one project at work: &lt;td *ngIf="data?.rating?.paymentIndexData?.currentPaymentIndex?.data?.averageDelay &amp;&amp; data?.rating?.paymentIndexData?.currentPaymentIndex?.data?.averageDelay &lt; 0"&gt;{{(data?.rating?.paymentIndexData?.currentPaymentIndex?.data?.averageDelay * -1) | value}}&lt;/td&gt; That's objectively worse than just constructing the object correctly before passing it to the templates.
To help noobs like you understand that all these Vue/React/Angular/etc. articles are fooling them into thinking one can't do anything without them when reality says you don't need them at all. My response isn't for you. My response is for people who question what they read, not with hooks in their noses as they're led around.
... no. I don't think anyone thinks you NEED a framework like Vue or React to do things like this. I think things like this are a decent introduction to the framework if you want to learn the framework.
Do you need to support older browsers like IE11 that don't support classes? If so are you willing to add Babel? Or are you ok only supporting modern browsers? Then use the class syntax. That said, a lot of people get by without using classes at all, whether ES6 or ES5 style.
Seen a video where a graphQL Middleware used a REST API an several endpoints from it to gather the needed data. It also cached the single resource calls.
Good catch. Making everything const by default then changing them to let when it blows up is a pretty bad habit of mine. :) But, will this do what I intend it to do? The original promise could be very long, say 30-45seconds, if other users hit the application will they all wait on the same promise instead of queuing up their own? 
No, in current version you can wrap it with a simple HOC and it'll work like [this](https://codesandbox.io/s/rrx7kw4pzm).
Lazy values are a wonderful way to shoot yourself (or the next maintainer) in the foot. I understand the value of delayed execution, but the cost of execution is just moved. Maybe it delays it to a time when it's less noticeable and works today but it's a landmine for future maintainers because the potential performance burden isn't obvious. I can reason about explicit types that wrap "lazy" values since they are generally apparent and I can appreciate caching mechanisms that help avoid repeatedly paying execution costs, but I don't like when those concerns are non-obvious.
Good to see that this is getting the go-ahead.
Okay, so lets go with that example. You get jsonb for "free"! yay! Oh wait, performance plummeted, what's wrong... do research, oh, lets do an index on it! Oh fuck our index is 50 GB... umm, okay, lets do research on the specific json structure nodes that need to be indexed.... oh that works... for a week... okay, lets rebuild it to add more that this other query needs.... rinse repeat. Nothing just gives you "free" access to your data, you still have to manage it, and graphql requires you understand the different data joins you can request and ensure that performance doesn't suffer... this isn't too hard when it's just a direct passthrough of your database, but what if it's not? What if it's pulling from filesystem data, and 3 different databases, an rpm repo, and AD integration? "free". 
&gt; so at a point you wonder if the client should just write its own query to grab what it needs Do I, though? What are some common scenarios where arbitrary queries should be constructed on the client? Please don't say facets.
https://www.reddit.com/wiki/selfpromotion
I am honestly a bit out of touch, so please take my question constructively. Doesn't OData solve this exact same problem? Back in the day, i quite liked the SQL like syntax, and also the flexibility it gave when it comes to joining, aggregating, unioning, grouping, and sorting data. And you didn't have to write code to do any of this - you just had to define your entity relationships between tables/objects and the OData layer would do almost all the hard work for you.
Hi /u/jimmy984a, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/pshreedhar, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
\+ https://about.reddit.com/advertise/ :)
@roikles rocked on the comment. The one thing I have to add is, if you have the time, you could try creating some side projects to help exploring the language with simpler projects. Good luck!
Looks like you're adding the `.click` event before adding the elements themselves. Moving the $("#LEDtable tr").click(function() { part to after trHTML += should help
well, i didn't mean you personally. it depends how amorphous your clients' needs are. you can try to generalize over every need or you can move query logic into your clients so that you can generalize over your clients with fewer or more capable endpoints. as usual, it's just a continuum of different trade-offs.
Lol, react code is also inscrutable, imo. 
I enjoyed this rant quite a bit. I've also heard that it's much more work to protect specific data points when using GraphQL. Any idea if that's true?
To me, it solves the following: * Standardizes the interface. REST is not a standard. There were several standards that were tried to be built on top of rest, such as JSON API, but none are as developed as GraphQL. * It reduces the payload to only things the client asks for. And it can recursively add a bunch of relational data all in one query. Although this could theoretically be done with a RESTful JSON API as well, but there is no standard and it's much more difficult and every API seems to handle it their own way.
My apologies for the late response‚Äîyour feedback is much appreciated!
Eh, tbh I haven't used graphql yet as it just seems to be drowning in hype. I'll probably play with it at some point. Regardless, APIs all have similar backend performance issues because data is complicated and software can't just magically know how to optimize everything, which is why all the "you just get it for free!" talk makes me roll my eyes. 
A few things it seems to solve, but this is possibly from the perspective of an optimistic n00b ;). It's tricky with REST accessing different business logic, separate databases or separate servers from the same API, but easy with GraphQL. For example, you could have messaging stored in Redis and Inventory in PostGres on physically different platforms and access them from the same endpoint. You can also get a dataset or subset in one request to a single endpoint that would take several requests to different enpoints in a typical REST API. What is really getting me excited right now is [using it with Graphs](https://github.com/neo4j-graphql/neo4j-graphql), which I can't even imagine doing using a REST API. 
I see! Thanks.
My poor kitteh nibbles!
I'm on board. I mainly do backend development and I still don't understand why you would use graphql unless you were hitting multiple gnarly apis. In which case...why are you doing that? Why not scrape / cache the data into a single unified api that doesn't suck? How does adding more abstraction to a system make it faster - when *by definition* you are sacrificing control for convenience?
It's not that a client needs to make arbitrary queries. It's that given a REST API, different clients need different data, so eventually you see very specific workflows that want very specific data that don't exactly map to the API's objects. If the API grows large enough, that becomes a lot of unnecessary network traffic that every one is paying for, both cost and performance. So it's not that we want a query language, it's that we want an effective way to give everyone exactly what they want with the lowest cost possible. I have no idea how GraphQL solves this, I'm just learning about it.
In the case of graphql, it's really about giving more control to the api client... with REST for instance, you often have to make multiple calls to multiple resources to get a full dataset you need. graphql (from what I understand) lets you specify all that in one request. This can actually be really important for UI responsiveness in some cases (like, oh I dunno, facebook). 
Just wanted to let you know ES2015 classes will be improved hopefully in an upcoming update to ECMAScript to have [proper class fields](https://github.com/tc39/proposal-class-fields). Private member variables will be possible. I hope this makes it into the language. 
Did you turn off animations in AG grid? If you are waiting for pretty animations to complete for your performance tests, your coming to get bad results. Also, what was rowBuffer set to? These tests are interesting, but without having the grids configured to the type of data you are using them for, then the results are meaningless. No one is going to use any of these grids with that large of data sets or rendering requirements without tweaking them first. AG-Grid performance page: https://www.ag-grid.com/javascript-grid-performance/?framework=all#gsc.tab=0 
Mmmm. I could see that. But if graphql is just hitting some api, then doesn't it still use multiple queries to the database? 
Great read for the crazed coder!
There's an easier syntax with classes (transpiled to this), which is class Blah { get Thing(){ } } 
It is stage 3 in the TC39 process right now, and once it gets implementers it can make it to stage 4 which means it will land in the next version of ECMAScript, but you never know how long or short the stage 3 to 4 transition will take.
I've seen it done with a *combiner* endpoint too where you tell it which other endpoints to swnd
Is there a difference between what a query builder and an ORM? It seems like they do some of the same things...or maybe they could be used together?
And getting full circle back to my point. I get told over and over again on reddit, and only on reddit and other amateur forums, how it's crazy to try and do anything without Angular/React/Vue/etc. and *everybody* uses it.
Thank you
What does this have to do with grids?
Then say that. Instead of grand standing about how awesome your project was that didn't use it? Nothing wrong with frameworks. Nothing wrong with doing things vanilla. That's the great thing about programming. If it works, it works.
I did say that. You just didn't get it.
Great article! Complex topic, simplified very well. Does anybody knows how the illustrations of the article were created? 
Edge under performing is typical of Microsoft browsers including IE. This is no surprise.
I'd never heard of OData until seeing this thread. I glanced at the syntax and it's less than friendly. Yes, it seems to offer a "solution" to a similar problem, but it does it in a rather verbose, unfamiliar way. After looking at it, I can see why graphQL is winning this fight. GraphQL is generating queries using a syntax that's familiar and matches the data being requested. There's less cognitive load necessary to read and write a graphQL query and you essentially get the same result that OData provides, a unified DSL for accessing your API.
Funnily enough, when i glanced at GraphQL's syntax, i found it to be way more cumbersome and cryptic. Like i said, i am a bit out of touch. But i remember OData being really close to ANSI SQL in syntax, and i feel that SQL syntax is the benchmark and goal when it comes to querying data. Perhaps you looked at the rest syntax instead of the sql syntax?? Or perhaps you might want to look at more examples: http://www.odata.org/documentation/odata-version-3-0/url-conventions/ 
[removed]
Go to sleep pal
It's not bespoke because new requirements don't necessitate a new endpoint. As long as you have all the relevant data available and the relationships defined, your backend is done. Development efforts can focus solely on the front end. To your point, there comes a time when new data is required, but in a GraphQL world, that simply means adding the additional data, mapping the relationships, and you're done. And finally, if a field is being deprecated, the work necessary to deprecate it is unavoidable. You're going to be doing the same amount of work regardless of how your backend is implemented. And I don't see how having a standard restful API is any more helpful in determining if a field is still being used. You want to know how often a field is accessed? Simple, add some code to your DB query that counts the number of times it's accessed. You'll still have to do the same amount of work to track down the clients and API calls that are requesting that field. Actually.... probably less in the case of GraphQL because you're guaranteed that the query has the field name spelled exactly how it's provided by the API, which means a simple grep is necessary to track it down, versus having to check for any and all API calls that might possess it in the bespoke fashion. You're just being dense and coming up with excuses to hate GraphQL.
The advantage of GraphQL is that I can wire up APIs that my team doesn‚Äôt control, and implement caching and other things that the other teams are dragging their feet on. If you have 100% control of your whole codebase, it kind of doesn‚Äôt matter what you use as long as you‚Äôre effective with it. If you control just one facet of a complex system (e.g. microservices), tools that make it easier for teams to consume disjointed data are worth their weight in abstraction. 
Another ‚Äúfree‚Äù thing you get that‚Äôs super cool: you can download the schema to your frontend code, and add eslint-plugin-graphql and as you write your queries, it will error if that field doesn‚Äôt exist on the query or mutation you are writing. Say the server is refactored, run the linter and immediately find old fields you were querying for. Also, Apollo client used redux under the hood and will cache things and optimize fetching. All for free!
Re-posting a comment I left on MPJ's video: &gt; What MPJ didn't tell you: &gt; 1. JavaScript's class and inheritance mechanism is more normal than you think. In both Python and Ruby, for example, a class is itself an object (a building, not a blueprint), and inheritance is done by delegating down a chain of objects, from instance to class object to superclass object and so on. Just like in JavaScript. https://www.reddit.com/r/learnjavascript/comments/6c6use/how_the_hell_did_you_guys_learn_js/dhuut92/ &gt; 2. An ECMAScript editor expressed his opinion that "it is not at all helpful for beginners to constantly be exposed to the notion that JS classes are 'fake'. They are not, they have real syntax and real semantics." https://www.reddit.com/r/javascript/comments/4bmiqj/using_classes_in_javascript_es6_best_practice/d1avktu/ &gt; 3. MPJ cherry picks arguments and applies them hypocritically. Yes, classes in JavaScript are implemented differently than in Java. But then so are arrays. An array in Java is a contiguous block of memory, whereas an array in JavaScript is a hash table where the string keys we insert just happen to look like numbers. And there's more. Functions in JavaScript are implemented differently than in Java. Objects in JavaScript are implemented differently than in Java. Yet MPJ thinks you should avoid classes because classes in JavaScript are implemented differently than in Java. &gt; 4. MPJ said, "There is no way to make properties private ... and there's no trick to do it either." But actually there are several tricks, the most effective of which is WeakMaps. http://2ality.com/2016/01/private-data-classes.html#keeping-private-data-in-weakmaps &gt; 4-1. And even if you're using factory functions instead of classes, you should *still* use weak maps for privates, because function locals are *too* private and will prevent you from implementing some methods such as "isEqual". https://www.reddit.com/r/javascript/comments/6b0yc3/factory_functions_privates_are_too_private/ &gt; 5. And since MPJ told you to go watch his composition v inheritance video, here's a reminder that MPJ got composition very wrong, and ultimately all he did was reinvent multiple inheritance. https://www.reddit.com/r/programming/comments/5dxq6i/composition_over_inheritance/da8bplv/
how is this specific to SPAs?
One of the main benefits I see is that your API basically becomes self-documenting, at least in terms of the specific data it can serve. Imagine a website as a tree graph of edges and nodes (the nodes are data). We could call these nodes resources and have a unique url for each datum i.e. `www.mysite.com/api/v2/person/id/1` One of the main ideas in Roy Fielding's dissertation describing [HATEOAS](https://en.wikipedia.org/wiki/HATEOAS), is that each of these nodes could tell a client about its immediate neighbors, so a client could theoretically find all the other nodes on the tree (walk it) by asking each node of its neighbors in-turn. Traditionally, one would write an API that described all the data on the website in terms of URL's a-la-REST as described before. When it came time to document that API, the developers may or may not have included all possible endpoints in the documentation. Also, each endpoint may not have been programmed to tell a client about its neighbors. The implementation of a "HATEOAS-compliant" API was left to the programmer - and programmers make mistakes. One of the big advantages of GraphQL is that an API implemented in GraphQL will necessarily be able to tell a client how to navigate all its nodes. That is just ONE advantage I see of GraphQL, but I think it's one of the more easily-understood advantages and it's a big deal. Basically, I'm guaranteed if I'm talking to a well-implemented GraphQL API that the server can and will tell me exactly all the information that it can serve. I don't have the same guarantee with a typical REST api. The creator may have forgotten to document some endpoints and the endpoints themselves may not tell a client what its neighbors are.
You're right: JavaScript DoS vulnerability?
I'm not your pal, buddy
The problem for me ***is*** the SQL like syntax. Starting off my career as a front end developer and having written a lot of API calls over the years, JSON is like a second "language". GraphQL merely extends this language with powerful operators and, living in a world where supersets of javascript are becoming the norm, this isn't much of a cognitive load for me to process, especially when I know the result is going to match the query. I instantly become turned off when I see http://aReally[long]string$mashed-together:that:my@brain,can%20tPROCESSwithout copy pasting it into an editor and breaking it apart manually. I can glance at a GraphQL query and know what I'm getting. I can't say the same for a url encoded blob of text that doesn't fit on my screen horizontally. I think it's familiarity and convention that attracts you to OData, but there are definitely benefits to the GraphQL syntax that aren't immediately obvious. I hate when people use SQL as the defacto declarative standard for accessing data to which all other languages/methods should be held up to. It's been around for years, it's normalized, and it's covered many edge cases... that doesn't mean we can't improve on it, and I'd say GraphQL is making a case for that, at least in a world where JSON is king.
&gt; From my APIs point of view, it'll be getting attacked by the IP of domain.com, so I can't filter or block it. That's incorrect, even though the code is served by your website, it is run on the clients machine, and the get request to your api will be sent from your clients machine.
OK, good to know, thanks!
Here's an example. I return a list of Users back. Along with that user is a little bit about the company they're in so something like: `GET /users` [ { "id": 123, "name": "user1:, "email": "user1@users.com", "company": { "id": 9293, "name": "Cool Company" } }, { "id": 245, "name": "user2:, "email": "user2@users.com", "company": { "id": 393, "name": "Cool Company" } } ] When `/users` was first written, the company phone number wasn't needed to be returned with the users. Just the name was enough. Now I'm building another UI, or making a change to the UI that initially needed `/users` and I need to display the phone number for the company. The company phone number is available at `GET /companies/9293` and `/companies/393`. So I need to know make an additional API call for every user I get back to get that ALL of the company's data back. I suck at Big O notation but I think this is O(N). Also I don't care about 95% of the company for what I need here, I just want the phone number for the user's company. So I have a few options. I can go and add (or ask the back-end API team) to make the company's phone number available every time I request an Company which is might only be useful for this one place I need it. Rinse and repeat this process when this UI inevitably changes and now I need to display the company's address. Or, it the API team can't accommodate it, or it will be a while before it's in production and now I need to make all those additional API calls for every single user's company. All those round trips to the server just to get one field. That will be a terrible UX waiting for all that. Another option is making a whole new API endpoint entirely `GET /usersWithCompanyPhoneNumbers` - well, that's just awful. Neither are great scenarios. GraphQL tries to solve this by letting the client specify what they need. The client knows the data it needs. So if it want's the company phone number with the user collection, it just asks for the company's phone number with the user collection. If another view needs the address, then it asks for the address. 
eqw
lol. I wrote for the CEP for two years. Worst two years of my career. It's the fucking worst. 
The advice you are getting is spot on. Don't be afraid to ask questions, look for solutions online, or feel like you should know everything. One thing I always look for when I'm interviewing people is desire to learn - it sounds like you are well on your way, even if it doesn't feel like it! One thing I would recommend is to read something like [Mastery](https://www.amazon.com/Mastery-Keys-Success-Long-Term-Fulfillment/dp/0452267560) to try to give you some guidance for the process of learning new skills in general. It helps you get used to the highs and lows as you learn a new skill, and give you some insight for how to handle it in the future.
https://mobile.twitter.com/linclark/status/867469723998539777
 Actually those are two different functions. And the .click() is at the $(document).ready(function() { branch. Where should I add the .click()? like this? $(window).on("load", function() { $.get("http://master.local:8080/api/led/") .done(function(data) { var trHTML = ''; $.each(data, function(i, item){ var idString = JSON.stringify(item.id); if(JSON.stringify(item.group) == "null"){ var groupString= ""; }else { var groupString = item.group; }; if(JSON.stringify(item.prog) == "null"){ var progString = ""; }else { var progString = item.prog; }; if(JSON.stringify(item.white) == "null"){ var whiteString = ""; }else { var whiteString = item.white; }; if(JSON.stringify(item.color) == "null"){ var colorString = ""; }else { var colorString = item.color; }; if(JSON.stringify(item.brightness) == "null"){ var brightnessString = ""; }else { var brightnessString = item.brightness; }; trHTML += '&lt;tr&gt;&lt;td&gt;' + "&lt;a href=" + item.id + "&gt;" + item.id + "&lt;/a&gt;" + '&lt;/td&gt;&lt;td&gt;' + item.id + '&lt;/td&gt;&lt;td&gt;' + item.name + '&lt;/td&gt;&lt;td&gt;' + groupString + '&lt;/td&gt;&lt;td&gt;' + item.status + '&lt;/td&gt;&lt;td&gt;' + progString + '&lt;/td&gt;&lt;td&gt;' + whiteString + '&lt;/td&gt;&lt;td&gt;' + colorString + '&lt;/td&gt;&lt;td&gt;' + brightnessString + '&lt;/td&gt;&lt;/tr&gt;'; }); $("#LEDtable").append(trHTML); $("#LEDtable tr").click(function() { $("#test1").html("clicked smth"); var href = $(this).find("a").attr("href"); if(href) { $("#test2").html("clicked with" + href); window.location = href; } }); }) .fail(function(){ $("#LEDtable").html("fehler"); }) }); I've also tried a different way where I attached the table generation to a &lt;p id=""&gt;. This works too with generating but doesn't seem to make a difference in the .click() function.
Well said!
Forget about the SPA for a second, and just think about the API. You can query the API any number of ways, which is what makes it so useful. For example, you could hit the URL with your browser window, or you could request it from a mobile app. A single page application queries the API from the client's computer, so the IP of the request is that of the client. Assuming a simple page, the client makes a request for the static SPA resources and then another AJAX request for to the API. The API doesn't have to know about the SPA, and can handle security by itself. That could mean rate-limiting IPs or robot-checks, but if your site is small, I wouldn't worry about it, because it's probably not worth the cost/time. The attack you're thinking of might be an issue if your Go API took some kind of parameter which was used to direct a web request. For example, imagine if you had `api.domain.com?url=&lt;thing&gt;` and the server used the url param to request info from another API. In this case, the server would be the one making the request, so the IP of the requester would be the server's IP. If you spammed something like `api.domain.com?url=google.com`, you're basically getting the server to make requests to google for you. All that said, DoS attacks are usually a little more complex than just spamming requests, and the concern with the attack that I just mentioned would be that the server may have permissions that you don't. TL;DR: don't worry
[removed]
Why the hell is it so ridiculous????
Also, any uh... insider tips?
depends on the implementation? We just wrap all mutations with a resolver that first checks if you are admin. If you want to allow mutations for non-admin, you have to specifically call them out. It's like 15 lines of code. However, that's not default behavior, so‚Ä¶ ¬Ø\_(„ÉÑ)_/¬Ø
Except in the example it's a REST resource with query parameters, so all that stuff already exists without GraphQL! I think people are using GraphQL to do normal REST stuff like you see in Rails routes, but there's nothing graphy about the endpoints.
What makes all that "GraphQL" oriented more than a normal /user/123 route that returns their company via a JOIN? N+1 queries are a solved problem.
Right, I'm asking for common scenarios. "Amorphous needs" is not a common scenario in any way I've seen described. Just real world examples are all I'm asking for. Or even just "plausible."
It's a bit annoying, yeah. There are ways of [doing it](http://graphql.org/learn/authorization/), though.
From first glance it looks like the coefficient of restitution is too high. Balls hitting the left side are flying off to the right hand side very rapidly, not how I would intuitively expect sand to behave.
pretty sure they'd each create their own promise. however, if you'd save the promise into a global variable, on each request you can check if that variable is null and only execute pendingOrders() when it is not, and then execute the then on that variable instead of the function returning the promise, you'd be well on your way.
Interesting. That doesn't seem too bad.
To me "All for free!" sounds like "Here are added dependencies that magically work as long as you're doing basic stuff, pray that they are maintained forever!"
No think of an SPA as a little virtual machine that runs on THE CLIENTS browser not anything your serving up. Any proxy or DDoS protection will work the same.
I tried that code in node 7.10.1 and 8.6.0. It didn't crash at all. It just endlessly printed numbers until I killed it.
Proof: $ nvm use v7.10.1 $ node bench.js ... 2360000 2361000 &lt;--- Last few GCs ---&gt; [21305:0x104000000] 52690 ms: Mark-sweep 1408.5 (1467.0) -&gt; 1408.5 (1436.0) MB, 1840.4 / 0.0 ms (+ 0.0 ms in 0 steps since start of marking, biggest step 0.0 ms, walltime since start of marking 1840 ms) last resort [21305:0x104000000] 54684 ms: Mark-sweep 1408.5 (1436.0) -&gt; 1408.5 (1436.0) MB, 1993.3 / 0.0 ms last resort Also see [screenshot of Activity Monitor](https://www.dropbox.com/s/exemwod0k32u55u/Screenshot%202017-10-11%2011.52.09.png?dl=0) If you try that in Chrome, it will crash faster, Node.js being less conservative being configured for the server-side, so what happens is that the process first grinds to a halt, with the GC desperately trying to deallocate memory. Cheers,
Free to read online (my book): http://exploringjs.com/es6/
I wonder if it has to do with async stack traces
Right, but the native await code handles tail recursion properly, no? Also, did you try this with Bluebird, it might be smarter about forwarding resolutions?
No, that loop using await is not tail recursion and the `return await` sample also crashes.
No, it's simply `Promise`'s implementation. An implementation that works correctly is possible, as can be seen in [Funfix's PR](https://github.com/funfix/funfix/pull/57), which is a port of the solution implemented by Scala's `Future`.
Manning has a decent video series on es6 that I thought was thorough for advanced beginners to intermediate level. But honestly your best guide is just referring to the moz docs when you get stuck.
What did I just read? &gt;But before you jump to conclusions, this has NOTHING [caps, OK, smth important is going on] to do with JavaScript's lack of TCO support. Just guessing that TCO is tail call optimization. What would that exactly do? &gt;This is because in our recursive function it's not JavaScript's call stack that's managing that loop, but rather the Promise implementation. Loop management by Promise implementation? What does that mean? &gt;That recursive call is asynchronous and so it does not abuse the callstack by definition. Now we will get our explanation: &gt;Unfortunately, just like a regular function using the call stack for those recursive calls, the Promise implementation is abusing the heap memory, not chaining then calls correctly. Mhm OK. What has chaining then calls to do with heap memory abuse? &gt;And that sample should not leak, the Promise implementation should be able to do the equivalent of TCO why, and, again, what does that mean? &gt;and in such a case eliminate frames in the then chain being created. What? Eliminating frames (which frames? what is a frame here?) *because* they are created? Eliminating when and why? [This](https://en.wikipedia.org/wiki/Tail_call#Description) might help: &gt;When a function is called, the computer must "remember" the place it was called from, the return address, so that it can return to that location with the result once the call is complete. Typically, this information is saved on the call stack, a simple list of return locations in order of the times that the call locations they describe were reached. For tail calls, there is no need to remember the place we are calling from ‚Äì instead, we can perform tail call elimination by leaving the stack alone (except possibly for function arguments and local variables), and the newly called function will return its result directly to the original caller.
And they don't have to, if you provide them with a GraphQL endpoint they can use to query the exact data they need. That's one of the big problems it aims to solve. I need an item with fields A and B * You provide me an endpoint that gives me fields A, B, along with 50 other fields I don't want. Possibly with a slow query to get the fields I never cared about and wasting a bunch of bandwidth moving that stuff to the browser. I'll have to go and change your API. * You provide me with a GraphQL endpoint where I say gimme fields A and B and it works. I don't need to go changing your API.
Attempting to be sarcastic? Not working :-) &gt; Just guessing that TCO is tail call optimization. What would that exactly do? TCO is a pretty standard term and there's available literature for how TCO works that's outside the scope of this article, which is why I linked to Wikipedia. &gt; Loop management by Promise implementation? What does that mean? It means that the `Promise` implementation manages the continuation callback and not JavaScript's call stack. Again, there's available literature on how call stacks work or Promise/Future implementations work, but in case you're inclined to read some source code instead, I think the code that I wrote for Funfix is pretty readable, so here you go, this is what "call management" looks like: [future.ts](https://github.com/funfix/funfix/blob/v6.2.0/packages/funfix-exec/src/future.ts#L1477). &gt; Mhm OK. What has chaining then calls to do with heap memory abuse? Compiler error, does not parse. &gt; What? Eliminating frames (which frames? what is a frame here?) `Promise`, and all alternative implementations, are essentially building a call stack, either managed explicitly, or implicitly by means of runtime facilities for doing asynchronous calls (i.e. `setTimeout`, `setImmediate` or a thread-pool in Java). But regardless, the effect is that you're substituting one stack representing active call sites for another stack, which keeps track of what callbacks need to be called once the result is ready. And in this instance, a "frame" is one such entry in the stack. This should be taught in computer science, although I've seen lately that universities are dropping assembly programming courses, which is a pitty. &gt; Eliminating when and why? Eliminating in *tail call position* because otherwise the process crashes and that makes Jack a dull boy.
Site is down, cached version: http://archive.is/xITge
I'm sorry if that's the case, although the site is up for me: http://downforeveryoneorjustme.com/alexn.org If it still happens, please let me know and I can activate Cloudflare on it. In general I prefer to not do that for privacy implications ‚Äì as you'll notice, my website has no trackers, not even Disqus, as they've grown weird lately.
Ah.... I think I may spend time tuning this one then... you think it's possible to get something like "sand" out of its physics calcs?
I think one of the takeaways is that you are part of a team, code like the team. If you're joining an existing team, adopt team practices, even if they're not formalised. If there are disparate styles which are causing review scraps, formalise on a linter/formatter.
The main difference between json and jsonp is that json is loaded as a http page and with jsonp you load a js script that contains your requested data. Its a way to bypass CORS restrictions for reading operations 
Hey, thanks for replying! No, I know that, I get the *why* behind using JSONP, and the difference, what I don't get is the usage differences. 
Your GraphQL endpoint would be handling those joins. So the difference is making one call to get the user list collection and say there are 10 users returned. Is now making 10 more calls to the API to get each one of those users' company's phone number. Your example is calling one endpoint for the individual user. That's not what we're after though. We need the user's list and data from another model they relate too. What if my company has has a ManagerID that relates to another user, and I need that user's name back too. Again, do I return that back for every single response for the user collection which means another SQL JOIN on every call? Not return it at all and make the client call the API a bunch more times to get the user manager? Or do I shift some of the burden to the client to ask for what it wants and only what it wants?
I can't believe people are down voting you. 
I dunno...tried it Chrome and it didn't crash yet. Gets slower and uses 2.2GB of memory, but still runs: https://i.imgur.com/t5iDB3S.png 
Well, as an example, with Redux you get time travel debugging, serialized state data that can be sent over the wire etc for free. It doesn't mean that maintaining your state is free though, just that it gives you these other benefits.
For starters, `return await loop` should be `return loop`. No point in useless rewrapping. Secondly, I suspect the reason why your Funfix implementation works and native doesn‚Äôt is because native promises (and possibly even setImmediate) use the microtask queue and not the event queue. The microtask queue fills and empties before the next turn of the event loop, so if you‚Äôre constantly filling the queue with promises to be resolved, chances are that it‚Äôs never getting out of that turn. If my theory is right, you‚Äôre basically creating an infinite loop in the microtask queue. That said, the solution here has always been to unchain the tail call with setTimeout (yes, setTimeout, not setImmediate or process.nextTick) . Note that your loop here never ends, so you‚Äôre effectively only using Promises for side effects and therefore don‚Äôt need to chain them at all.
I really don‚Äôt know I‚Äôm afraid. I don‚Äôt know if the piling up of sand is something that is out of the scope of a ‚Äústandard‚Äù rigid body physics engine. Try turning the coefficient of restitution down and the friction up? Sand particles are generally sharp so won‚Äôt slide across each other much. I‚Äôm interested to see how you get on with this. Do post your progress!
There's https://github.com/AlexGilleran/jsx-control-statements 
Maybe those people have better intuition than me.
Indeed it's up now. It was down at the time of my post.
&gt; For starters, return await loop should be return loop. No point in useless rewrapping. That is correct, but my primary test has been with the plain function using `then`, precisely to not make mistakes like this. It makes no difference though. I updated the article to use `setTimeout` and now it crashes even faster, managing to only go through ~ 1,000,000 iterations before it chokes. &gt; the solution here has always been to unchain the tail call with setTimeout (yes, setTimeout, not setImmediate or process.nextTick) I know what you're referring to, but your intuition here is not correct. I've updated the article to use `setTimeout`. It makes no difference. What ends up happening is that the code is creating a chain of promises waiting on each other for completion. So it creates `f1`, which waits on `f2`, which waits on `f3`, creating a long chain of `resolve` callbacks being registered for triggering once the last promise is complete and since that never happens, the heap eventually blows up. What I did in Funfix to fix it, is to indicate to newly created futures (in `flatMap`) that they need to complete the source, doing a sort of chaining in reverse. See [the implementation](https://github.com/funfix/funfix/blob/4e909021f1ad8092b5fe31d19cc2b9eb3edd9fae/packages/funfix-exec/src/future.ts#L1514). And so what this does is to effectively drop intermediate future references, leaving directly accessible by the GC only the future reference you're holding on to and the active future. And so it ends up using constant memory. &gt; Note that your loop here never ends, so you‚Äôre effectively only using Promises for side effects and therefore don‚Äôt need to chain them at all. It's just a simple example to illustrate a point. You can imagine a stream of tasks processed one by one, where the results are folded into a final result that doesn't have to be `void`. Yes, promises get used for triggering async side effects, but many times you also want to aggregate a final results as well and having your process blow up only after ~1,000,000 items or so is a big surprise, at least to an FP developer like myself, given that these are asynchronous calls that shouldn't have such problems.
It depends on what your memory limit is and it doesn't crash immediately, first the GC freezes the world a few times, freeing whatever memory it can.
JS is broken because it doesn't handle what's effectively an infinite loop??? Sure, I'd expect a better error than "out of memory", but I'd expect a crash either way.
Good points (got a bit personal at the end), but you seem to have replied to the wrong person.
As I mentioned in the article, an implementation that doesn't leak is possible. So obviously the assertion about creating an "infinitely long promise chain ... means nothing can be GCed" is false. To see it in action, do this: npm install funfix --save And then: import { Future } from "funfix" function loop(n) { return Future.eval(() =&gt; n).flatMap(i =&gt; { if (i % 1000 == 0) console.log(i) return loop(n + 1) }) } loop(0).recover(console.error) This code is doing exactly the same thing, but it doesn't leak. This is sort of a Stockholm Syndrome btw :-)
&gt; This is sort of a Stockholm Syndrome btw :-) Wow, biased much to basically be calling people saying you're wrong *prisoners* to Promises? I'm not about to go digging through the spec comparing all sorts of edge cases that the native implementation handles that yours doesn't just for this. You can make incomplete implementations of all sorts of stuff that are better than the native ones.
That's looking at it at the surface level. Yes, you get your response in one request on the client. But it gives you a schema, ability to wire up your microservices so that it feels unified, gives you a simple way to think about your data. While the app I'm working on isn't at the scale of Facebook, our microservices are no joke. We have teams dedicated to building servers that run in front of them that serve the different apps different needs. Graphql is just one of many different ways to solve that and it is just as much up front work but gives you some nice benefits.
But using heap memory and a stack should be an important [difference](https://stackoverflow.com/a/80113/2092322). At least you've said, that Promises do pollute the heap memory, not the (call) stack. It would be nice to consider the difference - or to explain what is meant by *abusing the heap memory*.
Thanks for the link, I was looking for a service like after the free pingdom.com account become more restrictive.
All loops in functional programming are expressed as tail recursions, or as folds that are implemented with tail recursions, because otherwise there's no way to express them. And classic loops are inadequate for expressing algorithms involving asynchronous calls, being error prone. This is not narrow, edge case, having started with lambda calculus in 1930. It's only an edge case when your tool of choice doesn't support it. Hence my Stockholm Syndrome joke is really only a half joke ;-)
Seems interesting, if you find yourself needing to use infinitely recursive promises. Say you remove promises from this problem though: &gt; function loop(n) { &gt; const i = signal(n); &gt; if (i % 1000 == 0) console.log(i); &gt; return loop(n + 1); &gt; } Would you say JavaScript is doing something wrong if it "leaks" when you run that code? What's the difference here?
Sure, if there aren't graph relationships that would otherwise require multiple calls to a good REST API, then GraphQL is useless. But I hope we can agree that there are plenty of REST APIs that could use this layer in front of it.
Usage difference is: json you would send an ajax call to retrieve json directly. And jsonp you would put a script tag in your html with a link to your desired json and provide a callback function as parameter to that link. Once your page loads it will load in that javascript "code" which contains the requested data and will call the callback you provided in the url. I hope that makes sense :)
There are languages that don't use the stack at all, e.g. Haskell. In the larger scheme of things, the difference is not that big. What I'm saying is that for functional programming, which helps with reasoning about the ordering of asynchronous / concurrent calls, there's no way to express loops (without mutation) unless you express them as tail recursive calls. And it's really easy btw to end up with long loops that need to be processed recursively: type Task&lt;A&gt; = () =&gt; Promise&lt;A&gt; interface List&lt;A&gt; class Cons&lt;A&gt; implements List&lt;A&gt; { constructor(head: A, rest: Task&lt;List&lt;A&gt;&gt;) {} } class Nil implements List&lt;A&gt; { constructor(error?: any) {} } There. I've just described a potentially infinite, asynchronous, lazy, referential transparent list. Describing operations on this with `async` / `await` or callbacks works, sort of, but it's an exercise in frustration. And by using the Promise pattern as it was meant to be used, you end up with a blown heap.
I'm not talking about *this* being an edge case, I'm saying there is most likely some edge cases that the native Promise implementations handle that yours doesn't. Regardless, this whole thing is nonsense. It *is* an edge case to keep around a 2,000,000 promise long chain, or even the first/last links of a chain without needing the intermediaries. If you dispose of the first one the whole chain will be gc'd, so it's not actually a memory *leak* it just doesn't handle memory like you'd like it to. But worse than that is your way of handling this whole thing. If this is a bug in the implementation (I'm not discounting that, just saying it's unlikely) you should just report it to the v8 team. If it's an issue in the spec you should point out the flaw in the spec. But no, you write an article attacking what's become a fundamental part of JS *for the purpose of promoting your own library*. It's toxic
The result is that the stack blows up, triggering a stack overflow error. Yes, it's a mistake, explaining the reason for why is a little difficult, I tried doing that in a [comment here](https://www.reddit.com/r/javascript/comments/75nibr/javascripts_promise_is_memory_unsafe/do7smxo/). But also consider that if this wouldn't be a mistake, then they wouldn't be implementing TCO in ECMAScript 6: http://2ality.com/2015/06/tail-call-optimization.html
Aw shucks, I thought that would fix it. For the last part, though, what I meant was (sorry, I had just woken up lol): function loop(n) { return signal(n).then(i =&gt; { if (i % 1000 == 0) console.log(i) setTimeout(loop, 0, n + 1) }) } Or maybe even function loop(n) { return signal(n).then(i =&gt; { if (i % 1000 == 0) console.log(i) loop(n + 1) }) } You can still sequence and aggregate the results without explicitly chaining the Promise object. I believe that libraries like bluebird do have this same flapMap optimization you‚Äôve created, though (but I‚Äôve started to prefer native for less dependencies).
&gt; It is an edge case to keep around a 2,000,000 promise long chain The issue is that the implementation should not keep around 2,000,000 promises, being the problem we are talking about. Please re-read what I wrote, because I don't want to keep repeating the same words. As for why this is an issue, I'm also a little out of breath explaining why, tried to do that in a [comment here](https://www.reddit.com/r/javascript/comments/75nibr/javascripts_promise_is_memory_unsafe/do7smxo/). &gt; If this is a bug in the implementation ... you should just report it to the v8 team This isn't an issue with V8, since Firefox has the same behavior, but an issue with the standard. &gt; If it's an issue in the spec you should point out the flaw in the spec and start a discussion about how to fix it. I was under the impression that I'm doing just that and I'm showing you the solution as well. &gt; you write an article attacking what's become a fundamental part of JS for the purpose of promoting your own library Well, those of us that are building libraries, well, we like talking about it. &gt; It's toxic and my issue is that it does nothing to help anyone except you. You're attacking me for no reason. My critique was for a piece of technology, yours is personal.
So you start trapping things in closures and are surprised when those closures use memory? If it hurts to use closures that way, stop doing it. 
Your critique was on a piece on what you consider to be a *bug* in a piece of technology and you used it to self-promote. It's a scumbag thing to do. You don't see anyone else running out writing articles about issue #1472 in some lib and how you should use mine instead because it doesn't have that issue. That's *exactly* what you did here and the behavior isn't appropriate in this or any other community
I have not tried Bluebird, maybe it does it because the problem and the solution are pretty obvious, which is why I was surprised to see that the standard Promise doesn't do it.
A "memory leak" used to mean memory that had been manually allocated and was no longer reachable. Then folks using GC languages redefined it to mean any memory that was hanging around that you didn't need any more. "Memory unsafety" means it is possible to misinterpret what a set of bits in memory represent. For example, in C you can cast an integer to a pointer and then try to dereference the result, potentially segfaulting the application. Now this article is trying to redefine "memory unsafe" to mean, what exactly? That you can allocate lots of memory? Then by that token arrays in JS are not "memory safe": $ node &gt; var a = []; undefined &gt; for (var i = 0; i &lt; 100000000; i++) a = [a]; &lt;--- Last few GCs ---&gt; 16440 ms: Mark-sweep 1373.8 (1403.0) -&gt; 1373.8 (1404.0) MB, 685.4 / 0.0 ms [allocation failure] [GC in old space requested]. 17196 ms: Mark-sweep 1373.8 (1404.0) -&gt; 1373.8 (1404.0) MB, 674.5 / 0.0 ms [allocation failure] [GC in old space requested]. 17945 ms: Mark-sweep 1373.8 (1404.0) -&gt; 1373.8 (1403.0) MB, 667.3 / 0.0 ms [last resort gc]. 18710 ms: Mark-sweep 1373.8 (1403.0) -&gt; 1373.8 (1403.0) MB, 764.7 / 0.0 ms [last resort gc]. &lt;--- JS stacktrace ---&gt; ==== JS stack trace ========================================= Security context: 0xc1e0c2cfb51 &lt;JS Object&gt; 1: /* anonymous */ [repl:~1] [pc=0x14e5000b32af] (this=0xc1e0c2e6ec1 &lt;JS Global Object&gt;) 5: /* anonymous */(aka /* anonymous */) [vm.js:22] [pc=0x14e50009fd28] (this=0xc1e0c204381 &lt;undefined&gt;) 6: sigintHandlersWrap(aka sigintHandlersWrap) [vm.js:96] [pc=0x14e50009ee68] (this=0xc1e0c204381 &lt;undefined&gt;,fn=0x2fb44a970289 &lt;JS Function sigintHandlersWrap (SharedFunctionInfo 0x3acca3663cd1... FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory 1: node::Abort() [/usr/local/bin/node] 2: node::FatalException(v8::Isolate*, v8::Local&lt;v8::Value&gt;, v8::Local&lt;v8::Message&gt;) [/usr/local/bin/node] 3: v8::internal::V8::FatalProcessOutOfMemory(char const*, bool) [/usr/local/bin/node] 4: v8::internal::Factory::NewFillerObject(int, bool, v8::internal::AllocationSpace) [/usr/local/bin/node] 5: v8::internal::Runtime_AllocateInTargetSpace(int, v8::internal::Object**, v8::internal::Isolate*) [/usr/local/bin/node] 6: 0x14e4fff079a7 Abort trap: 6 That definition doesn't make sense. Promises are memory safe (and do not leak memory either). But you can use them to build a linked list of arbitrary length. 
So I should just be an angry man that complains about what other people do, but that does nothing about it? Personally I prefer to show and tell, to build and deliver alternatives and to talk about it. That's not a "scumbag thing to do" in my culture, even if I were to do this for money, which I don't, this being on my own free time and at personal sacrifice. What about calling people scumbags? Is that appropriate for this or any other community? We have nothing more to talk about. Have a great life.
Author found a tricky part in Promise/A+ spec, that's known for [at least two years](https://github.com/promises-aplus/promises-spec/issues/179#issuecomment-93453094) ([Node issue related](https://github.com/nodejs/node/issues/6673#issue-154013477)). Bluebird doesn't exhibit this behaviour ([test code](https://gist.github.com/a55a97539972b8eb0a0007df8b51ac91)) and keeps steady 58MB memory usage on my laptop. 
This is how jsonp is roughly implemented under the hood. (Guys please correct me if I am wrong) const jsonp = function (url, callback) { const script = document.createElement("script"); script.src = url + "&amp;jsoncallback=jsonpCallback"; window.jsonpCallback = function (resp) { callback(resp); script.remove(); window.jsonpCallback = undefined; } const body = document.getElementsByTagName("body")[0]; body.appendChild(script); } // use it like this jsonp("https://api.flickr.com/services/feeds/photos_public.gne?tags=cat&amp;format=json", console.log) So to answer your questions: 1. With jsonp, the server returns a "script" which contains your desired response wrapped around a callback function. 2. Because jQuery abstract that away from you. Please check my sample implementation to get a rough idea of what jquery is doing. 3. Because jasonbase allows cross origin requests. Further reference: [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS) 4. jQuery beautifully abstracts away the inner workings and exposes a nice api. Anything that you can do in jquery, you can do without it (jquery is written in javascript after all :) its not black magic). P.S. if you dont like to type a lot, check out [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch)
This was the wrong way to handle this. Regardless of my tone you should realize that.
let me answer with another question: why do you think it's necessary to store this kind of data in sessionStorage? why not use a regular variable to store it?
A process crashing with an out of memory error is pretty unsafe. There is indeed precedent for using "memory safe" to mean the inability to have buffer overflows or dangling pointers, but I just used "memory safe" like people use English, by putting two words together in a combination that makes sense. I later regretted it btw, but it's too late to change the title now. Judging by the negative reactions I'm seeing and the words I keep repeating, I'm now regretting publishing this article at all. *Promise leak memory* for what are tail recursive calls, being intuitive because other wildly deployed implementations in this industry do not leak memory - I proved it in the article and I explained why it's a problem too, also in about the dozen comments I posted here. Sorry for my aggressiveness, but that's what Reddit does to a person. I'll go back to my cave now. Cheers,
https://github.com/nodejs/node/issues/6673 You can read about the rationale there ‚Äî seems to be an issue with either the Promise/A+ or ES6 spec. 
Mainly because I need to use the data in other functions. I'd have to give the variable global scope, which I've been told to avoid. 
Oh, that's useful, thanks.
Hmm, yeah, I guess it's surprising. But your title is annoying. https://en.wikipedia.org/wiki/Memory_safety Memory leaks are memory safe.
Thanks, the links are helpful. And the Bluebird mention.
Wow, making it readonly really worked. But why? Why is node even updating it? anyway, thank you!
I now regret that title and have changed it due to popular demand. The Travis build of my blog is in progress :-)
I have no idea. This is part of the reason why Yarn exists.
You can try wrapping the entire code in a IIFE. `myGlobal` is not in global scope and both functions f and g can access it. (function () { var myGlobal = "some_value"; function f() { // do something with myGlobal } function g() { // do something with myGlobal } })();
...sure, but even putting it in a global variable still seems a lot more sane than using sessionStorage for this. I think you might want to look more into how scope works in JavaScript, and find a better way to structure your code, because this absolutely can be done without either of those solutions.
As long as you are doing basic stuff? No, no matter what you do with graphql. The Apollo project isn't going away anytime soon either.
Because my previous post was downvoted to hell, for readers of this toxic opinion, here's some references: 1. this person calling me [a scumbag](https://www.reddit.com/r/javascript/comments/75nibr/javascripts_promise_is_memory_unsafe/do7tkyc/) 2. Node recognizing this as a spec problem, so it cannot be fixed, along with people experiencing problems in production, see [Memory leaks in loops with Promise](https://github.com/nodejs/node/issues/6673) 3. Promises/A+ spec issue, the issue still being open: [chain of never resolved promises create memory leaks](https://github.com/promises-aplus/promises-spec/issues/179) I have also updated the article with these links. Thanks to /u/Ginden and /u/1-800-BICYCLE. 
Oh no I called you a name! Actually for reference I didn't. I said your behavior was that of a scumbag.
That makes a lot of sense. Thanks for helping out a beginner! Just out of interest, any clear cut reason as to why I should avoid sessionStorage in this case, just for my own knowledge? 
What about this list makes it lazy or asynchronous? Or for that matter, referentially transparent? JavaScript is strictly evaluated, you can't even construct a value in that list unless you have the value to want to add to it already. I see no function signatures indicating callbacks for asynchronous operations either. There's nothing preventing one from mutating one of the references within the list, so I'm not sure where the referentially transparent claim is coming from.
I was surprised to discover that the performance of properties and getters is virtually identical in V8. At least according to this benchmark: https://jsperf.com/getter-performance
This is wrong. You're chaining infinite promises together and running out of memory. There's no leaks, insafe memory or the like. You would have this issue without promises at all.
&gt; What about this list makes it lazy The fact that the rest of the stream is described with a parameter-less function, also called a `thunk`, which is how you turn strict things into lazy ones, obviously. &gt; asynchronous The fact that the rest of the stream can be processed with a `Promise`. &gt; Or for that matter, referentially transparent? The fact that side effects get suspended in that parameter-less function and there's no mutation involved for building it. &gt; I see no function signatures indicating callbacks for asynchronous operations either That's what the `Promise` is for. If it would work properly that is. &gt; There's nothing preventing one from mutating one of the references within the list I've modified the original definition to have `readonly` on those members, if that makes you happy :-)
&gt; ...but no go, what am I missing? Debugging skills.
Yes, promises are chained, but the chaining is flawed, as it should not leak. Please re-read the article and do a hard-refresh because I've added links to known issues on Node's and the spec's GitHub repositories.
Well, it's been opened since 2014. I guess I should go ahead and open a duplicate. But that might be another scumbag thing to do. Hmm, I'm confused, my moral compass is malfunctioning. 
Given that Vimeo doesn't support it, and only a few mobile browsers have supported it, we left it as a user initiated click. If you needed to get it autoplay, you could try Youtube or host the video files yourself, but this would only work for mobile browsers that have implemented it. (See http://walterebert.com/blog/html5-video-autoplay-mobile-revisited/) 
I changed it, you can do a hard refresh, but I can't seem to change it for this Reddit thread.
I missed the `Task&lt;A&gt;` you had in the constructor signature the first time, my bad. Also, I know what a thunk is, and your tone in these comments comes off as pretty condescending. I think you'd be better received here if you abstained from talking to people like they have no idea what they're talking about.
You're missing the entire damn point. I don't object to you trying to fix something. I object to the fact that you *weren't* trying to fix something. You were pointing out a bug, presuming it was "unfixable" before doing any research, and shamelessly self-promoting on it. The ironic thing is that you were apparently right, but by accident. The entire article was still *completely* inappropriate with what you knew at the time.
So you were actually wrong and then this is how you act? You're pretty insufferable m8, your coworkers must love you. 
I think just at face value, HTML that's going to be shown to everybody is not something that is unique to each user/user's session, and therefore doesn't belong there. I think in a more technical sense, sessionStorage is not an unlimited space (10mb? not 100% sure) so you probably don't want to load it with unrelated data. Also, what happens if your markup changes? Do you update the sessionStorage with the new markup? When do you trigger that? I think I should have just said it doesn't scale haha.
This is the expected behavior. This line means the promise can never be released. loop(0).catch(console.error) The catch refers to the first promised returned from the loop. That promise "wraps" any subsequent promises that are generated. Every promise in that chain must be kept in order to properly catch the originally returned promise. In other news, stack exceptions are also Javascript's fault. 
My issue beyond my original post is that OP was shamelessly trying to capitalize on this instead of just opening a task. It's not at all appropriate to attempt to publicly shame an entire project for an unreported bug. Regarding the technical aspects I wasn't wrong, and nor was OP. The spec should *arguably* be changed, but that's a discussion to have in a different place weighing things that aren't taken into account anywhere in this discussion.
I apologize for sounding condescending or aggressive, I do try to explain things using less jargon (`thunk` is less understood jargon). I'm also incredibly annoyed. Somebody here called me a scumbag for talking about a library I've been working on in my free time at personal sacrifice, so I don't necessarily know what I'm doing here, instead of going home to my wife and kid, but I guess I'll just pass by the bank first to retrieve my million dollars. As you can see, my humor doesn't help much either. Cheers,
I can't give you a very convincing answer as to why you should avoid sessionStorage in this case (I mean it will work). Maybe somebody else can. My reasoning is simple. Between: * doing something, and just as easily, in plain js (*IIFE*) * and, using any API's (*sessionStorage*) I like choosing the former. Use whatever makes your life easier :)
`funfix` Ah, so this whole contrived example is to push the `funfix` package you wrote. `Future` isn't a promise. So of course you can write it however you want. You can leave spec behind so you can show you fixed this "terrible" Promise bug by not using Promises. 
haha jerk lol, but you're not incorrect.
First of all, I just wanted to say I'm a bit embarrassed to see people getting rude over what is clearly a legitimate, well-isolated, reproducible, and well explained issue. I think whether funfix or bluebird were used as a POC solution should have been irrelevant, and that ideally people should have been eager (or at least open) to learn about the existence of a potential freaking _crash_ and mitigation techniques rather than bickering over the definition of a memory leak. So I guess the important question is: can the promise spec be fixed?
Thanks! 
Thanks! 
I've built no less than 3 libraries implementing the promise pattern, along with Haskell's `IO`, a closely related cousin: [Monix.io](https://monix.io/), [cats-effect](https://github.com/typelevel/cats-effect) and now [funfix.org](https://funfix.org) (and have in plan to contribute ports to [kategory](https://github.com/kategory/kategory/) too). If I was right, it was not by accident, this particular topic being an interest of mine for several years actually. Thanks for enlightening me about the virtues of this community. I've been educated.
Didn't EXT-JS stated they were end of life ?
If for no other reason than security, I wouldn't store HTML in *anything* and then blindly display it in the browser. There's a chance someone could modify it somehow with a hack and do back things to your users. Instead, store the data, then convert it to fully escaped text and put it in the HTML when you want to use it.
It's been an interest of yours for several years yet you've done nothing to help fix the core lib or even bring up the issue there, only to benefit your own?
No, the Funfix implementation is there to show that it can be done, otherwise there would be people here saying that it can't be ... oh wait. Well, I've been called a scumbag for doing self promotion. I guess that if you work on stuff and talk about it, you must be one.
I see your point but I found quite noticeable performance problems if the HTML was combined with data client side 
It looks like you've got a link, not a button. And it looks like clipboardjs calls for a button element with a data-clipboard-target attribute to know what to do when you click the button. Instead of an a tag ("anchor"), you should create an input tag with the URL as the value and an ID, and then a button with data-clipboard-target set to the ID of your input tag. The example from their documentation: &lt;!-- Target --&gt; &lt;input id="foo" value="https://github.com/zenorocha/clipboard.js.git"&gt; &lt;!-- Trigger --&gt; &lt;button class="btn" data-clipboard-target="#foo"&gt; &lt;img src="assets/clippy.svg" alt="Copy to clipboard"&gt; &lt;/button&gt; 
Hi /u/coders-dairy, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Then you definitely have some optimization you can do. I recommend creating the html in a document fragment and then inserting that fragment into the DOM once everything is ready. It will save a *ton* of repaints. https://developer.mozilla.org/en-US/docs/Web/API/Document/createDocumentFragment
Oh, was that a question you want an answer for? Yes, it's been my dream to kill JavaScript's Promise, fragmenting the strong community we have here, lurking in the shadows and waiting for the perfect opportunity. But no, it's not JavaScript's Promise in particular that occupied my time, I just happened to notice it when my process crashed in the middle of the night. Also, I don't owe you, or the core promise devs or anybody else anything, unless I'm getting paid, so when hearing this reproach, I can believe it. Seriously, how low can you get?
&gt; I guess that if you work on stuff and talk about it, you must be one. No. That's not the case. It's how you're coming across in all of this. You came up with a rather contrived, academic example to demonstrate a very specific problem. Instead of addressing how the specific implementation causes problems, you attempted to generalize it beyond the scope of the issue - including using a clickbait title like "Promises are Memory Unsafe". No, Promises are NOT memory unsafe and that has been shown time and time again in this thread. In fact, your example isn't even memory unsafe - it's just a fucking infinite loop that causes the program to run out of memory. The exception is thrown because JS can't safely handle memory after it's out of usable memory space. ---- People are upset with you because they expected you to actually demonstrate how Promises as a whole suffer from a serious memory problem. You didn't and people called you out. You somehow decided that the best approach was to double down on your flawed argument and attack people for criticizing your approach. 
Seriously, just shut the fuck up. I'm done with you. You aren't willing to help open source but you're willing to attack it without even reporting a bug? What a fucking douchebag
I didn't get from the article why the promise spec and implementations leak memory. What is it exactly in the spec that requires references to be kept around? I'm guessing it's just a single reference from the new promise to the previous one (or the other way around) that is causing this issue? But for what reason is that reference being kept? 
To be fair, there's nothing to fix. Yes you can optimize it, but then there has to be made a good argument as to why this is needed. As it stands the issue sounds a lot like "I filled an array with the number 0 until JavaScript crashed (out of memory). This is bad, and if only the array was run-length encoded (compressed) to support an arbitrary number of 0's, there would not be a crash. For both the original issue and my toy array example the question becomes ‚Äì yes you can optimize it, but are there enough legitimate cases of this in the wild to warrant making the standard more complex? I think the answer is no, and there's plenty of room to create custom implementations outside of the spec to work around this issue (like the OP did).
So this will be supported in the next React release?
I replied in kind to all technical arguments and added extra explanations where possible, given the limitations of a forum and the time available. Your argument has a logical inconsistency ... either my linked Funfix is proof that the leak is real and that a fix is possible, or it is not. I also added the following links to that article, for completeness sake: - https://github.com/nodejs/node/issues/6673 - https://github.com/promises-aplus/promises-spec/issues/179 Now if you have actual technical arguments or opinions, that you can express politely, then we can have a dialog.
&gt; the question becomes: Are there enough legitimate cases of this in the wild to warrant making the standard more complex Yeah, that's a great line of reasoning. Personally I would prefer that the solution be a native one, and I feel that if bluebird is able to get away with its optimization, it should theoretically be possible to amend the spec, or at least get vendors to agree to make the optimized implementation the de-facto standard. Admittedly, I haven't dug too deep into this yet.
In the meantime, if you want, I just write an IIFE. return ( &lt;nav&gt; &lt;Home /&gt; {(() =&gt; { if (loggedIn) { return &lt;LogoutButton /&gt; } else { return &lt;LoginButton /&gt; } })()} &lt;/nav&gt; );
So the problem is that it creates a callback chain. Picture this ... const p = new Promise(...).then(r1 =&gt; { new Promise(...).then(r2 =&gt; { new Promise(...).then(r3 =&gt; { //... }) }) }) If you'll try imagining how an implementation looks like, you'll come up with something like an array on which you `.push()` those `then` listeners, which are going to be executed when the promise will eventually complete. The issue with the chaining above is that: 1. the first promise (that first produced an `r1`) will not complete until the second promise does, so a callback for completing the first promise is kept in the second promise 2. the second promise (that first produced `r2`) will not complete until the third promise does, so a callback for completing this second promise is kept in the third promise 3. ... The problem is that in this chain of 3 promises, the second promise is no longer relevant once it produced `r2` so you can simply discard it and if you don't, then it leaks. Therefore a well known solution to this is to _reverse the chain_. You make the second promise _forward_ its completion state to the first. And the third promise to forward its state to the second and (by compressing the chain) to the first, thus discarding the second. The problem with the Spec is that the Spec has to guarantee an ordering of operations in certain cases. And by implementing this solution, then ordering changes ‚Äî not necessarily in a bad way, but the issue is you can no longer rely on the spec alone to tell you what result you'll get, because it ends up being implementation dependent. So in other words, either all implementations are going to do this, or we can just leave this as semi-unspecified, in which case everybody is wrong, given that some implementations will crash your process whereas others will not. 
I believe the memory consumption comes from the fact that they keep the functions on hold even if not needed for normal functioning because if an exception is thrown they want to build a stack trace.
&gt; Usage difference is: json you would send an ajax call to retrieve json directly. And jsonp you would put a script tag in your html with a link to your desired jsonp api and provide the name of the callback function as parameter to that link. Once your page loads it will load in that javascript "code" which contains the requested data and will call the callback you provided in the url 
I omitted it from the above, but working on using except it's not copying anything other than `#cpy-${app.name}` so I'll try the above in my example. $.each(apps, function(index, app) { $('#results').append(` &lt;div&gt; &lt;button class="btn" data-clipboard- target="#cpy-${app.name}"&gt; &amp;#xf0ea; &lt;/button&gt; &lt;a class="#cpy-${app.name}" href="https://url.com/${app.app_store_slug}" target="_blank"&gt;${app.name}&lt;/a&gt;&lt;/div&gt;`) })
Yes, I think there are enough legitimate use cases in the wild. - you cannot describe any functional programming algorithm involving loops without tail recursion ‚Äî if folds are used, then folds are described with tail recursion as well - the issue is surprising ‚Äî you, as a JS developer using JS's `Promise` may be familiar with it, but myself, being primarily a Scala / Haskell developer, I find this behavior really, really surprising, especially since it can be fixed It's hard btw to explain use cases, as it would go over the scope of a single blog article and should be the subject of an entire book. But I gave this example elsewhere ... processing really long / infinite streams of events, for which it's really natural to describe algorithms using tail recursions and for which you can't really work with imperative, mutation-based loops. I gave this sample in another comment: type Task&lt;A&gt; = () =&gt; Promise&lt;A&gt; interface List&lt;A&gt; class Cons&lt;A&gt; implements List&lt;A&gt; { constructor(readonly head: A, readonly rest: Task&lt;List&lt;A&gt;&gt;) {} } class Nil implements List&lt;A&gt; { constructor(readonly error?: any) {} } This data structure is really cheap and effective - being a lazy, asynchronous, referentially transparent stream. But as an exercise to the reader, try describing this function: function map&lt;A, B&gt;(list: List&lt;A&gt;, f: (a: A) =&gt; B): List&lt;B&gt; HINT: if that `Promise` implementation wouldn't leak, then it would be really easy to do.
You should add this part to the article, so it's clearer what the problem is. Can you also show how the timing of things would be different with an alternative implementation? I'm guessing a solution/work around is to not return the new promise in each step, since you don't really care about the result. It looks like you only really care about the error? 
In my example yes, but I kept it simple to easily reproduce the problem. Many times however you do care about building a state, folding over the results ... e.g. if you have chunks of data read asynchronously from a file, you might want to gradually analyze it and produce some final result eventually. Yes, a solution would be to not use `return`, but many times you need to `return`, since you need that value. But if you complicate the sample shown, then the origin of the leak gets confusing, so I guess it's a trade-off.
I understand the possibilities, I'm just asking about practical examples of "retrieve a user, sometimes with company, sometimes without." All in all, it sounds like overloading URL segments the way methods can be overloaded with different signatures in some languages. 
In my example yes, but I kept it simple to easily reproduce the problem. Many times however you do care about building a state, folding over the results ... e.g. if you have chunks of data read asynchronously from a file, you might want to gradually analyze it and produce some final result eventually. Yes, a solution would be to not use return, but many times you need to return, since you need that value. But if you complicate the sample shown, then the origin of the leak gets confusing, so I guess it's a trade-off I haven't hit. 
That's not how recursion works. The stack won't unravel until you hit a base case, which you never will because it's an infinite loop. So it keeps building up the stack and eventually runs out of memory.
From going down this rabbit hole before, I think the main issues are: - Assimilating an old Promise (or Thenable) into a new Promise without maintaining a reference to the old Promise is easy IF both Promises came from the same implementation. This is because the Promises need to be able to look into each other‚Äôs internal states in order to assimilate. Since one point of Promise/A+ was interop, it‚Äôs potentially spec-breaking to force an implementation detail like this. - There are potential GC issues when different segments of a recursive Promise chain are held by different variables. - The Promise/A+ folks have certain tests to guarantee resolution order in all kinds of edge cases, and implementing TCO seems to break that. - The ECMAScript use of the Promise/A+ spec complicates things further since now there‚Äôs another layer of approvals etc. that needs to happen for what, effectively, is an edge case with documented workarounds. And my own spin on it: There seems to be a major force in the JS community that wants to maintain Promises as a 1-for-1 asynchronous analog of sync code. This makes sense from the perspective of the async/await API. Just as infinite recursion will exhaust the stack, infinite Promise recursion will exhaust the heap. Perhaps, if TCO is ever shipped for sync code, it will also be shipped for Promises. 
&gt; Get off my lawn. We're talking about JavaScript, not C. Definitions change and expand over time. You understand this, we understand this; there is no reason to complain about the definitions to this audience except to berate the author. As for the actual issue, the author [cited](https://github.com/nodejs/node/issues/6673) the problem, which is related to the spec. No reasonable person would expect this sort of code to build a linked list; it wasn't even caught during the spec proposal process. Comparing the creation of a too-large array to what's happening with promises is disingenuous.
The only real use case for something like this (where it would be an actual problem) is an infinite chain of events, like an async message queue. I've used similar code for that before, without knowing of this memory leak. Letting it run forever in a node app would cause issues. But now that we (soon) have async iterables it seems less like a problem. They fit much better in those situations, like reading a file and processing chunks of it. I guess promises aren't really designed to be used like this, and while it is a problem now, it's less likely to be one when we have alternatives. 
I run into this situation all the time. I go to reuse one of these endpoints and it turns out it responds with not quite everything I need for this particular UI. You have an endpoint that returns a piece of some related model's that you think is most typically going to be used when you make a call (sticking with our example) `/users` Then you need to reuse the API for say your mobile app that has different concerns because you're displaying a directory or something. Or just a new view in your web app to display a little extra, or a little less data. So either you pull down too much or worse, not enough every time and need to make additional API calls that wouldn't be necessary if you got exactly back what you needed in the first place. The API doesn't know every possibility that this data is ever going to be used in. If you're one person, a small application, maybe going in that company phone number on every request to `/users` is fine. Larger teams, it may be more of a burden to add it in, or stall this UI view you've been developing to wait for this new field to be added to the API and go into production. Wouldn't it be easier if the client could just say "hey, give me the users, and their company's phone number too?" If expose your API so developers can integrate with your product, you likely won't expect them to use it in all the ways they want to use it. Pull specific fields down, their relations to other items, etc. Either give them the flexibility with something like GraphQL, built out a whole bunch of really specialized APIs (that might only be relevant to this one particular developer's needs), or let them hit your API a ton for all the N+1 or O(N) (whatever it is) situations. Heck - didn't even get into updating the data. I want to give an admin a focused ability to go through and update users's company's phone numbers. Traditionally, I'm making additional API calls to do that POSTing to each `/company/:id`or I need to built a brand new API endpoint that expects this specific data structure that will be teased apart to then run updates on the users' companies I'm not sure what your experience is but if you're not dealing with much relational data, this probably sounds overkill. But if you're dealing with a lot of data and their relationships and your data is normalized, GraphQL can be very appealing.
Love this book, made me think more programatically. I would say though, this is NOT a beginner book. If you master the things in this book, you will definitely be a good JS programmer.
In the article I'm linking to my implementation, using what is a standard solution (I do not claim credit). But to your assertion: 1. Scala's standard [Future](https://docs.scala-lang.org/overviews/core/futures.html) does not leak 2. Twitter's [Future](https://twitter.github.io/util/docs/com/twitter/util/Future.html) does not leak 3. [Bluebird](http://bluebirdjs.com/) I've been told doesn't leak either, being known to be implemented differently Also in the article I'm linking to the [issues created](https://alexn.org/blog/2017/10/11/javascript-promise-memory-unsafe.html#the-spec-is-the-problem) on Node's the Spec's repositories. You can build one in Java too. Here's [Trane.io](https://github.com/traneio/future), built by a Twitter engineer and an acquaintance of mine, although this one comes with a twist - for tail recursivity, you have to defer the thing with a `TailRec` object, but that choice was made specifically for performance reasons.
I've included a sample here, refresh to see it: https://alexn.org/blog/2017/10/11/javascript-promise-memory-unsafe.html#concrete-use-cases
&gt; If you master the things in this book, you will definitely be a good JS programmer. Definitely not the goal of most beginners... 
best practice: don't store html which you can easily generate yourself It looks like what you wanna do is save the data requested via ajax. That's fine. Store the data, retrieve it, render appropriate markup.
I hear you, it definitely would be a nice perk, but you really can't be this focused on such a specific use case. To be able to change a specification safely, you need to consider all general cases. `Promise` in JavaScript came from a need to be able to chain asynchronous operations, not to chain asynchronous streams of data into a program like you would in a fully functional language*. For example, look at the implementation of `fetch` which is a great example of what the ES standard `Promise` enables. Together with `async`/`await` you get to write synchronous-looking JavaScript while making things work in a single-threaded environment. If you truly want this optimization to make it in, then a more even-sided argument should be made, not just "I can write code that works, so why doesn't the spec also work". For example, you reference the GitHub issue on the spec in your article, which shows just how much has to be considered in these cases. And it seems to me that only considers the case where a chain of promises completely wrap another promise (so you can eliminate the intermediate promises) whereas your example seems to be about a more complex relationship. Honestly, I'm not sure the standard Promise can ever completely support what you're asking since there are interoperability concerns to consider (compatibility between different implementations of Promise, which the spec supports). So to repeat, I think it's great you implemented a solution to your problem as someone who comes from a functional language. This will be helpful to others in the same situation, and you can also write an article about how you can write applications that operate on asynchronous streams with this library. But an article about changing the spec would require a much more general argument. * Sidenote: I don't think the "surprising to Haskell users" argument is very relevant since the vast majority of JavaScript developers come from different backgrounds than functional programming. You will often find that adopting a new language requires you to think differently from whatever language you were using before.
No you don't get time travel debugging with Redux, you get it with redux devtools. Just as you're not getting that eslint-plugin-graphql package 'for free', it's another dependency you have to manage in your workflow. 
as yoda said - "there is another" i.e. ext js 6 https://hackernoon.com/the-rise-and-fall-of-ext-js-c9d727131991
It's not a leak, it's just running out of memory because you are making an endless future chain.
This is a good argument, thanks for it. I disagree about the need for this, because one use-case of going async is to escape the limitations of the call stack, but I understand from where the philosophy comes from. And I can't be really wrong, given that actual TCO is coming to JavaScript, being part of the ECMAScript 6 spec. I do believe that FP is even more relevant in the context of JavaScript due to its asynchronous nature and thus potential for non-deterministic results (although less worrisome than on top of a platform that also does shared memory concurrency, like Java). I also understand the concerns expressed by people on that issue. But there are several implementations in the wild that have been used successfully, at scale I might say, without users hitting gotchas, whereas such a memory leak can be a big gotcha. Implementations include Scala's [Future](http://www.scala-lang.org/api/2.12.3/scala/concurrent/Future.html), in the wild since 2013 (which was my inspiration) and Twitter's [Future](https://twitter.github.io/util/docs/com/twitter/util/Future.html), which they've been using within their whole infrastructure, in Finagle, etc. I deeply believe this is the right approach.
Nope. But the mods can probably add a flair correction to the post if you send them a nice message.
Yeah this is roughly how it's implemented under the hood in jquery. I did my own implementation based on jquery's and it more-or-less functions the same. 1. Make `script` element 1. Set element `src` to the url with a unique (random or incrementing) callback name - usually the query is `callback`, not `jsoncallback`, but that depends on the server you're getting the json data from 1. Make a global function with that callback name that at the minimum calls the callback, but also should clean up the global variable and remove the script tag from the dom 1. Finally, append it to the body The only change I'd make is to change the literal `someCallback` to a random or timestamped name and then use the array syntax to call it - `window[someCallback]` rather than `window.someCallback`.
Haha, it is the goal, but I would use this book + other material to understand it. Most books you can get through in a month, this one should be done more meticulously so you understand all concepts.
perestroika12, how can I say this? I mentioned 4 independent implementations used at scale, one of them being Twitter's. None of them have the behavior mentioned. &gt; endless future chain No, it's creating a loop and we are talking about [tail call optimization](https://en.wikipedia.org/wiki/Tail_call) for these asynchronous `then` calls. The "endless future chain" is the problem, because it should not happen. &gt; you have a fundamental misunderstanding of why this is happening and what is going on I've built [Monix](https://monix.io), which contains an innovative Haskell `IO` port, one of the best in existence actually, along with what I believe to be the best back-pressured Rx Observable implementation. A cancellable future is also in there. Following that, I've built [Funfix](https://github.com/funfix/funfix), which contains [IO](https://funfix.org/api/effect/classes/io.html), [Eval](https://funfix.org/api/effect/classes/eval.html) and [Future](https://funfix.org/api/exec/classes/future.html), all of which are memory safe. I'm mentioning this in the article, being the reason for why I wrote the article ‚Äî because I've actually understood the problem and the fix. And I've helped with [cats-effect](https://github.com/typelevel/cats-effect), being a contributor to [cats](https://github.com/typelevel/cats) as well. If you'll notice there's a pattern in my work, but good or bad, you can't accuse me of a fundamental misunderstanding of what's going on, given that I've implementing the thing multiple times already, with different capabilities and made great effort to work around the problem.
I'm not going to write it for you - but think of it this way start your loop within the loop create a base variable equal 0 each loop compare the array value to the base variable - if it's greater than the base variable - set it to the current array value continue that loop Or you can sort the array and just select the last member of the array 
You could do this yourself without much trouble. Create an element as long as you want your level to be, on every mouse down start listening to the X of your mouse and shift the level element horizontally by as many pixels as your mouse moves. Instead of dragging, you could also consider a horizontal scroll.
Good point! You should use more than one resource and put effort into learning your trade. Beginners should probably read 4000 articles about React vs Framework X though.
``` type Task&lt;A&gt; = () =&gt; Promise&lt;A&gt; interface List&lt;A&gt; class Cons&lt;A&gt; implements List&lt;A&gt; { constructor( public readonly head: A, public readonly tail: Task&lt;List&lt;A&gt;&gt;) {} } class Nil implements List&lt;A&gt; { constructor(public readonly error?: any) {} } ``` Is that javascript?
Not sure if this was on purpose or not but creating variable inside the loop might not be the best idea. Don't want to give away too much more if this was on purpose.
I just bought the 2nd ,fuck
lol
&gt; We're talking about JavaScript, not C. Definitions change and expand over time. You understand this, we understand this; there is no reason to complain about the definitions to this audience except to berate the author. Yes, they do change, but within _minor boundaries_. Memory leaks and memory safety are two different concerns regardless of programming language.
TLDR: * [Performance benchmark][benchmark] * [Online Playground](http://sap.github.io/chevrotain/playground/) * [Getting Started Tutorial](https://github.com/SAP/chevrotain/blob/master/docs/tutorial/) 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [SAP/chevrotain/.../**** (master ‚Üí a25d2ad)](https://github.com/SAP/chevrotain/blob/a25d2ad94c3bebc0524ddf15928924bb68903a5c/docs/tutorial/) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply do89ynh.)^.
Here is my follow up article on code commenting: https://medium.com/gitconnected/refactoring-comments-into-better-code-f17671bee0f6 Hope it is helpful!
I still don't get how this is the "best javascript framework" 
I'd love to hear your opinion about it. I've been trying to create a modular and reusable gulp setup and after several remakes, this is what I came up with.
&gt; Beginners should probably read 4000 articles about React vs Framework X though. This sort of sounds like sarcasm. Are you being sarcastic? If you aren't being sarcastic why do you say this? I'm asking because I use Javascript at my job for basic stuff like conditionals, parsing data, and manipulating objects, but I want to actually use my Javascript for something greater.
Should I wait for the 3rd edition or go ahead and purchase the 2nd edition? Also, would I get anything more out of this after already having read the entire You Don‚Äôt Know JavaScript series by Kyle Simpson? 
Did he state a date when it will be finished?
Could you provide a sample of the response you get from `http://master.local:8080/api/led/`? If you do, I can make a JSFiddle to show it working.
Frameworks are [bad](http://tomasp.net/blog/2015/library-frameworks/). Raj is a very small framework that is usually a one-liner in your application code. This means the rest of your code can be good: libraries and application code. There are other reasons, such as the extreme ease of testing and separation of concerns and side-effects that make this the best framework. Heck you get [time-travel debugging](https://vimeo.com/233257980) for just one more line. You can read [Why Raj](https://jew.ski/why-raj/) for more information which discusses the framework landscape today and why Raj stands out. Ultimately, "best" is subjective but it is how I feel after years of developing with other frameworks. I understand the dismissiveness, but encourage you to give Raj a try. (And there's a [guide](https://github.com/andrejewski/raj-by-example) to help you get started.)
He is hoping for December of this year. 
You are trying to bind a click event to `TR` which are not in the DOM when document is ready. Remember, you are building your TRs after an AJAX call completes, which is about 200ms after the DOM is ready. Try using event delegation using jQuery's on in your table click function. THIS: $("#LEDtable").on('click', 'tr', function() {}); Instead of: $("#LEDtable tr").click 
You can use ternary and maps. &lt;Home&gt; { isLoggedIn ? &lt;LogoutButton/&gt; : &lt;LoginButton } &lt;/Home&gt; And &lt;ul&gt; { list.map(item =&gt; &lt;li&gt;{item}&lt;\li&gt;) } &lt;/ul&gt;
The 2nd is free online: https://eloquentjavascript.net/
Thank you so much! This way it works.
That's a pretty valid point - whoops, that's what I get for trying to write pseudocode like english :)
I wish he would just put a pre order on the paper version to get to the goal, I bet more people would drop money if they get something more than a sticker
Any way to donate over PayPal instead?
Maybe he bought paper version...
Do you mean like a parallax horizontal scroll? or is the whole page just scrolling horizontally?
The first gulp from the glass of frameworks will make you a React finatic, but at the bottom of the glass basic JS is waiting for you. React, Angular, whatever will all fall out of favor eventually; in the end if you want to make a career out of being a JS developer you have to know the fundamentals inside and out.
Instead of purchasing the 2nd edition you could read it online and use the money to help fund the 3rd edition :) 
someone correct me if im wrong, require for nodejs modules and import to use your own written modules 
MOTHER FUCK!
Why do you spam this so much? The 3 other threads was not enough?
There is nothing we can do, but you could try sending thought and prayers their way. Here is some info https://twitter.com/js_bin
Yes, I am being sarcastic. I was trying to point out that just because a book may be difficult, it doesn't mean that it's inappropriate for beginners. And I think telling beginners that they should look elsewhere will lead them into the many pointless articles written via Medium. Now, not all Medium articles are bad... some are quite good, but many are also along the likes of "10 ways to learn javascript to use React which is awesome!!1" &gt; but I want to actually use Javascript for something greater and I'm not sure where to go from here. Practice your programming skills in general (eloquent javascript would be a good choice) while also building things along the way -- which could involve using React. 
This looks terrible compared to Ohm/JS.
`es` modules are different than `commonjs` modules. The `import`/`export` syntax is for `es` modules, allowing you to `import` or `export` values from one file into a next: // ./utils.js const fn = () =&gt; {..} export default fn // ./index.js import fn from './utils.js' fn() The `module.exports` and `const x = require` syntax is for `commonjs` modules: // ./utils.js const fn = () =&gt; { ... } module.exports = fn // ./index.js const fn = require('./utils.js') fn() There is a whole bunch of confusion around this but [Dr. Axel](http://2ality.com/2017/05/es-module-specifiers.html) of course has an amazing post on it. What should you do? Look into `commonjs`/ `require`/` module.exports` before you look into `.mjs` or `es` modules. `commonjs` works out of the box in `node` while `es` may or may not work with plugins/packages.
I have been using JavaScript for a few years. I read about and practice it often, besides using it at work, but I'm not sure where to go from here. Employers don't seem remotely interested in my level of JavaScript. 
[Numbers:](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join) [Largest:](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max) [html](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) 
&gt; 1337 ‚Ç¨ raised Someone's having a laugh
Can someone explain what I'm looking at. I don't see a single line of JavaScript. Have I gone retarded?
try http://graphql.org/blog/mocking-with-graphql/ for the start
Do you have any projects that show off your JS proficiency?
&gt; Not necessarily the next release, but as soon as possible. We're currently trying to get popular tools such as Babel, Typescript, Flow and ESLint to support it before the official release. 
It's a proposed syntax for [method binding](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
good question, maybe the intent was to keep consistency with (::obj.func)(val) === ::obj.func(val) not sure...
If you pass object.func to another function as a callback, when called it will not have the same "this" value (obj) as it would if called directly. You can use function.bind, function.apply, the new double colon operator, or anonymous wrapper functions to get around this.
I think the question was specifically for the case ::obj.func(val); which is identical to doing obj.func(val); As obj is already the context.
SAME Lol. Oh well
The point is to both bind and call the function with the obj as context. In JavaScript functions are first-class objects. Meaning they can be passed around as variables. Let's say we had something like: let map = [1, 2, 3].map; map(x =&gt; x + 1); Well that would throw an error like "Uncaught TypeError: Array.prototype.map called on null or undefined." This happens because that assignment references the function outside of the context, the source object the method operates on, which is the array [1, 2, 3] in this case. With the :: operator we can more simply supply the context of a function call without having to specify it twice. [1, 2, 3]::map(x =&gt; x + 1) // =&gt; [2, 3, 4] [4, 5, 6]::Array.prototype.map(x =&gt; x + 1) // =&gt; [5, 6, 7] Which is a bit more natural to follow along with than: Array.prototype.map.call([4, 5, 6], x =&gt; x + 1) Another useful use case is working in libraries like React where using an ES6 class to create a component doesn't automatically bind the context to it's methods. class MyClicker extends React.Component { // ... handleClick (e) { this.setState({ clicks: this.state.clicks + 1 }); } render () { return ( &lt;button onClick={this.handleClick}&gt;Click Me&lt;/button&gt; ); } The problem with the code above is that the `this.setState` in our click handler will throw an error because "this" refers to undefined. So that syntax could simplify matters a bit: &lt;button onClick={this::handleClick}&gt;Click Me&lt;/button&gt; as opposed to something like: &lt;button onClick={this.handleClick.bind(this)}&gt;Click Me&lt;/button&gt; While there are better abstractions for handling the binding elsewhere or automatically the :: syntax can still be useful to better highlight the programmer's intention of referencing a method against a specific context. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this
I'm guessing you are talking about the syntax which is definitely less pretty than an EBNF style grammar as used in Ohm/JS But that is one of the tradeoffs of internal vs external DSLs. Although there are long term plans to also provide an EBNF style grammar and work as a traditional parser generator. Compared to Ohm/JS it may not be as pretty, but it is also: * X400 times faster (**3 orders of magnitude**, see benchmark linked above). * Can be debugged directly as plain JavaScript. * Supports automatic fault tolerance / error recovery. * Not as opinionated, allows **both** embedding actions/semantics or separating those. * Supports syntactic content assist out of the box. * And more... So I will leave the choice of prettiness versus functionality to you. :) 
Get out while you still can. It's literally not worth it. Whatever you can write will not help your productivity because you'll waste so much time with developing because they have the absolute worst stack imaginable. I've built full applications in 5 Adobe apps and I'll never do it again. Sorry.
[removed]
My guess? This commit shows the reason. https://github.com/babel/babel/commit/72183ff2e9d69fd822e7ccc3ded6216f4d9fd6b4 Before that commit, the docs were wrong and described a situation where the fourth example *did* require transformation to run correctly. That commit fixed the documentation but also made the fourth example pointless. It did not occur to the author of the commit to remove or simplify that fourth example.
I just finished a project using Chevrotain. After using other parser generators, Chevrotain is fantastic! Describing the parser in real code, writing tokens as real inline RegExps is great for debugging and productivity! I wrote the messier token RegExps using XRegExp, meaning they were a million times more readable. I was only able to do so because a Chevrotain parser is plain JS and XRegExp is a JS library that creates RegExps. Plus, using my IDE's refactoring capabilities and code completion was a godsend. I highly recommend checking it out.
Awesome, thank you. 
From what I understand you want to call the parent method from the child class? Just do super.method() from your child method
It it's never *not* working I don't see why you need our help.
No, not calling the superclass's method - wrapping the normally declared ES6 class method with another function.
Well, it says it is the best right there on the Raj site. I don't see why they would lie. 
And to expand on that, webpack (or another bundler with similar functionality) is required in order to import html files as shown in OP's example. Even when ES modules become standard, they probably won't allow for this.
Just define the methods with arrow function syntax and do whatever you want to them. You can also look into decorators
I'm not 100% sure, because your post is pretty vague - but I think aspect-oriented programming is what you're looking for? It gives you 3 functions - `before`, `around` and `after`. If you had a class, you could do something like this to add functionality to a class' methods: class Model { async save (details) { // pretend this saves a document to the db } } before(Model, 'save', function (details) { // gets called before the Model `save()` method is invoked - shares the arguments passed to the method }) `after` behaves similarly to `before`, except the callback will be called *after* the method is called, usually with the return value as an argument. `around` is kind of a mix of `before` and `after`, allowing you to modify behaviour *around* the method call, by giving you the ability to control when execution occurs as well as the ability to cancel execution. This is a very old computer science technique, having existed almost as long as object-oriented programming has, but it's not exactly "functional". It's still valuable for handling cross-cutting concerns, for example filling a function body with logging calls (when the function has naught to do with logging) is a problem aspect-oriented programming very cleanly solves. There are [plenty of libraries](https://www.npmjs.com/search?q=aop&amp;page=1&amp;ranking=optimal) for this as well (my favourite is Meld by cujoJS, the same guys who made the When.js promise implementation).
There is the 'do' expression plugin https://babeljs.io/docs/plugins/transform-do-expressions/
Thank you Capt'n obvious.
Also wondering. Anybody read both?
Are you aware of any projects using chevrotain to parse ES2017?
Maybe I‚Äôll be the first one 
If you are just now hearing about Eloquent JavaScript or Marijn then you are in for a treat. I have read the 2nd Edition and used CodeMirror extensively. Marijn is a JavaScript legend.
alibaba weex ui
The paper version is published by No Starch Press, so it doesn't directly affect his funding goal. That is separate.
This is something I‚Äôve been curious about. I‚Äôve heard that electron is a resource hog but I‚Äôve never learned why that is. Would you mind shedding some light?
I *think* what you‚Äôre looking for is *class expressions*, which is a pretty nifty feature that can be used to allow you to extend arbitrary superclasses. This can be used to create a mixin-like structure. Here‚Äôs an article I found with some examples of it: http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/ React uses this technique as a replacement for their mixin architecture ‚Äî they call those components ‚Äúhigher order components‚Äù. BUT, if you‚Äôre really trying to go the ‚Äúfunctional programming in JS‚Äù route, you should keep in mind that most hardcore FP-ers have shunned the ‚Äòclass`, `this`, and `instanceof` keywords altogether in favor of doing everything with factory methods and object composition through Object.assign or the ES7 object spread operator. Decorators could also help, too, but the spec for those is apparently in flux. 
You could wrap a method after the class has been defined. class C { foo() { return "foo"; } } C.prototype.foo = (() =&gt; { const _super = C.prototype.foo; return function() { return _super.call(this) + "bar"; }; })(); const o = new C(); o.foo();
Depends on what *exactly* you're aiming for, but I might recommend [Paper.js](http://paperjs.org/) if vector graphics can sufficiently express the particular art style you want.
Maybe it takes a while to reflect in download stats, but based on npm installs (which would be a fraction of actual usage), it's still doing great https://npmcharts.com/compare/jquery,react,@angular/core (nearly as much daily downloads as react, more than twice as much as angular)
Its processing taking control of allllllll the syntax, the little bugger. Add a breakpoint, and you get to see a mutated hell that is JS spurted from the loins of the unholy Processing. This version's not perfect - the data type for one was "int", and it contained something like 45.25! But Processing is JS, and the program is turned into JS... and I want a JS version. =) There's another one on CodePen that I converted into JS, with no Processing at all - I've still got to add the mouse and keyboard inputs. 
Outselling *Inarticulate Javascript* for the 5th year running!
3 months more or less
Thank you for this article. I think this actually happens more than people here believe. In fact: after reading your article I'm quite sure I've actually written this on more than one occasion. Every application has an infinite loop at the top-level, and in non-web settings it isn't uncommon to write this loop yourself (e.g. A game loop). I have written such loops in an async recursive manner (event loops for games and main loops for TUIs), and now that I read your article I think that at least some of them suffer from this issue. 
Well, thanks for the article, you got a decent amount of downvotes, but this is reddit ;) This discussion made me realize I am doing this in a task queue because I was assuming TCO, and I am using Bluebird so I lucked out!
JIN YANG! 
I thought about sites using jQuery today, I was thinking to WordPress. It seems they are related. https://trends.google.com.vn/trends/explore?q=jquery,wordpress
I said octopus
People still include it as a supplement even when they're using more modern frameworks. A lot of stuff still has jquery as a dependency.
A different perspective is valuable. Fund the new work.
Not necessarily as GraphQL/OData/whatever-compound-API query can in most cases be translated to a single complex query. But even if that weren't the case it's still order of magnitude faster to hit DB with multiple queries than for a HTTP client to hit application server with multiple requests. At least it should be in a well designed systems. As having DB/Persistence non-local to the application server (i.e. in the same latency/throughput ballpark as client-to-appServer) is a system arch. anti-pattern in fat client design i.e. it should only be done if it cannot be avoided (sometimes you're just patching things up on top of an existing monolyth).
Super sharp dude - I'm in awe of his achievements.
I will suggest you to look into Wes Bos's challenges, he once created drums, based on keyboard keys. It is fun definitely check that out. Further I will recommend you start playing around with online audio streams, merging all screams into on blob and then play that. Audio Recording API also. Hope it helps!!
It would be interesting to get stats on the types of projects it is still being used on. In particular I mean how much is being used for legacy architectures and how many new projects are being started with jQuery included.
Unless I am misunderstanding the question there is already a max function on Math available to you. OP can just apply the array to the function Math.max.apply(null, [1, 55, 2, 3,])
[Updated link.](https://gist.github.com/jorgebucaran/4dfa567e38ca222c25c46184b3a5df99)
Thanks for the feedback @cspotcode That was exactly the intent when creating Chevrotain. Fewer **unneeded** abstractions means less complexity and greater power to the end user. 
I've read the first edition but own the second edition paperback. Second edition contains a chapter on node that's missing from the first, but I've not read the second edition, so I can't speak to any further differences. 
I'm not aware of any. There is an [ES5 grammar](https://github.com/SAP/chevrotain/tree/master/examples/grammars/ecma5) as one of the examples, but it requires quite a bit more work to turn into a productive ES2017 parser. It does not even have its own Lexer yet (uses Acorn to Lex). This scenario is very interesting as most ES2017 parsers have very little or no error recovery capabilities and no partial parsing abilities (not parse the whole module/script each time). So a Chevrotain ES2017 parser could better serve a Code Editor / IDE Scenario. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [SAP/chevrotain/.../**ecma5** (master ‚Üí a25d2ad)](https://github.com/SAP/chevrotain/tree/a25d2ad94c3bebc0524ddf15928924bb68903a5c/examples/grammars/ecma5) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
For example the signalR client :(
The final book in the You Don‚Äôt know JS series is free online and well written. ‚ÄúES6 and Beyond‚Äù
The last major release of JQuery was over a year ago. Perhaps fewer developers are using the [html API documentation](api.jquery.com) because it is pretty stable or they already know it by heart. So less of a reason to open jquery.com but not necessarily less developers using it.
Yes, I get the concept of context binding. But if you call a method using the form 'obj.func()', the js runtime will automatically bind 'obj' to 'func'. So obj.func() and obj.func.call(obj) are equivalent. Binding it in this situation is totally pointless. Your comment is referring to the first two forms of this syntax in the link I provided where it gets converted to a 'bind'. I am specifically talking about the last ones where it gets converted to a 'call'. 
Can I start with the 3rd book? Are they related? I mean I know JS, I work as frontend dev, but in case I want to read it.
The app looks great! Are you planning to release our for other operating systems?
I think it's good read even for beginners. This is my very first book, and when I read it again I understand more concepts than I would understand while reading as non-programmer, but it really did help me to break the wall and start thinking programatically! It got me into programming. But as quoted at the very beginning of the bug: 'I do not enlighten those who are not eager to learn, nor arouse those who are not anxious to give an explanation themselves. If I have presented one corner of the square and they cannot come back to me with the other three, I should not go over the points again.'. Wonderful book!
Yes you can. It's an updated release.
This is a great news for Javascript Community. One of my favorite book! Let's support him!
Thank you very much! Yes. Especially windows is the next target. But it needs much more work, as for Apple all the infrastructure for sell in and updating is given. None of this is for windows. So I still have to build it myself. Bottom line is, it's planned and coming for windows. Next will be Linux probably. If it sells ok. 
It‚Äôs not really clear what you‚Äôre asking. I think this may be what you‚Äôre looking for? class MyClass { constructor () { this.myMethod = (...args) =&gt; // ...do stuff return this.myMethod(...args) } } myMethod () {} }
It's TypeScript, could be Flow, the syntax isn't relevant, I just wanted to make clear what the types are. Having a static typing background, that's how I think even when working with plain JavaScript.
great tips!
Yesterday it was 999‚Ç¨ so I'm guessing he is only incrementing the amount when it reaches an interesting number.
I think he just started writing the 3rd edition. I doubt it will be released anytime soon!
I think it's possible to have both by theming respectfully. Like every major social media website has migrated to. Just, here, it's harder, because we need to choose where to draw the line ourselves. For example, here's a quick edit that's just the default style + a header background. https://i.imgur.com/qbR9amE.png. Not super polished, but I think it's already doing a good job of creating identity while respecting navigation tools.
Oh he will be missed!
yeah, the one at the end is super useful - it allows for quick logging: const inc = x =&gt; x + 1 // I need to debug... sigh - time to add braces const inc = x =&gt; { console.log(x); return x + 1; }; // instead I can do this :) const inc = x =&gt; console.log(x) || x + 1; 
How come it does the first second expression ("x + 1") as well? I'd think it would do "console.log(x)" and stop/finish there.. It's neat that it executes both expressions though
console.log returns nothing (undefined) so it evaluates falsey !!console.log(5) =&gt; false so console.log(5) || 5 + 1 =&gt; 6 
Because console.log returns a falsy value, so the "||" operator runs the second part of the statement. Of course you can also use the comma separator, which discards the returned value completely: const inc = x =&gt; (console.log(x), x + 1)
good. i think the period from 07-12 were some of the most enjoyable and exciting times in software development and it was mostly because of jQuery and how easy it was to write and read (and also, it was awesome going to about 95% of all websites, opening the console and typing `$()` and being able to play). in my mind, the end game of jQuery is to not be needed anymore, and we're getting pretty close to that point.
New code is worse, though. Yes, it is shorter, but it is harder to read and maintain. 
&gt;People still include it as a supplement even when they're using more modern frameworks yeah, do you hear that, mobile users? fuck you!
i haven't used jquery in about 2 years, it's not obvious to me at all how many people use it
ah ok, makes perfect sense. Since the comma seperator discards the returned value completely.. wouldn't it be safer to use that than the || operator? In case the first expression returns something truthy?
I didn't bother integrating the paypal api in my app (that was a pain last time I tried), but if you email me (marijn@haverbeke.nl) announcing your donation I'll add it to the total!
I hear arguments like this for pretty much any new language syntax. Usually it boils down to ‚ÄúI‚Äôm not used to this syntax‚Äù. Note that plenty of other languages have short function expression syntax and work just fine with it.
Wow, can I use that last quote to promote the book? If yes, what name should I attribute it to?
Harder to maintain? You shouldn't be leaving the logging in there.
Ofcourse, my name is Krunoslav Banovac. 
Great write up! If I recall correctly, I don't believe these are supported in the lovely IE browsers and end up breaking the page, so be cautious based on your users. Unfortunately, many major companies still use IE 11.
I get the point that your project is technically better (especially error recovery!!!), but... Both projects are taking different way to get to the same point ‚Äì 1.) define grammar and semantics and then 2.) let it do its thing. Ohm/JS excel at the 1, while Chevrotain rocks at 2. And that is fine, but the adoption is somehow difficult when it comes to your implementation. You mentioned that you want external DSL for defining grammars which is beyond awesome and I am looking forward to it, but for now I can bow only to you and your technical skills and not Chevrotain, sorry :)
Yes, if you really don't care for the result of the first function then it would. However, some linters don't like the use of commas (because they can, and do obscure the layout of code)
Babel, babel everything!
Forgetting old browser compatibility is there something that jQuery still does much better than vanilla js ? 
Forgetting old browser compatibility is there something that jQuery still does much better than vanilla js ? 
Thanks for the nice cover. However, in both of the react examples there is the 'bind' sentence. It should be omitted in the first one in order to fit the explanation.
Electron's renderer process is based on Chromium so basically you should expect from Electron the same behaviour as of Chrome itself - it consumes comparable amount memory to function. This is a drawback and many people complain that it is unreliable / unusable. However, Electron facilitates the speed of innovation of desktop apps - a lot of the lately released apps are written in Electron and wouldn't have been created otherwise. For me, that's a fair price to pay given Moore's law and constant improvement of hardware.
I downloaded it 3 times yesterday when I generated 3 new templates based on Bootstrap. Then I deleted both jQ and Bootstrap from all three.
Whoa, a use for the comma operator outside of a for loop that doesn't seem insane.
Can further be simplified and destructured: const getTweets = uid =&gt; fetch('https://api.users.com/' + uid) .then({json} =&gt; json()) .then({data} =&gt; data.filter( {stars, rts} =&gt; stars &gt; 50 &amp;&amp; rts &gt; 50) ); 
Thanks, but there is no need for that complication, I used the form from the website. Would be good if notification would be sent to email so we know transaction was successful. 
Damnit... what is weex! So many frameworks !! Too bad playground does not demo components. I'd like to try a cross platform react framework once. One that does html and native. Looking at ReactXp but i'll add this to the list. 
The ease of adoption is part of the reason why I am interested in also supporting an external DSL and using the existing super optimized runtime as the low level implementation. The other reason is reaching out to a larger audience: If you are coming from a background of writing recursive decent parsers by hand Chevrotain may look more familiar, but if you are coming from the world of parser generators and declarative EBNF grammars your initial reaction may be less positive. And we have not even mentioned users coming from the background of parser combinators :) It also depends what is your goal? If you are building a toy / educational project than you may not care about debugging ability or performance, but if you are building a "real" productive system these concerns will take a much higher priority to the visual appeal of the API. - [Related Quote](https://github.com/antlr/antlr4/commit/4f2168600d114ca7f36a83da6f9014f4bdd07b49#diff-95eea86e0f9bcb7da102f22477ab9a42L54) from Terence Parr, creator of Antlr. 
Are you talking in the browser, or in something like Node? If you're meaning in a browser, then it's not possible. 
So you're saying that a class that `extends` Array creates instances that have are "Array exotic objects"? I can't find that in the spec but then that doesn't mean much.
Also the use of `const` and `let` instead of `var` make a world of difference.
 foo.bar is the same as foo['bar'] You need this notation if the property isn't a valid identifier (e.g. when it starts with a number of if it contains a space). You can also use it for computed property names as your snippet does.
 render() { return( &lt;div&gt; &lt;div style={{ paddingRight: "10px" }}&gt; &lt;SomeSortOfInput /&gt; &lt;/div&gt; &lt;ClickableIcon /&gt; &lt;/div&gt;); } Layout that's specific to a component should go in the component it's specific to.
If you're not using a transpiration step you're doing something seriously wrong.
I want to apply the padding to the input, not its container.
I just want to note the new React 16 does some debouncing on its own. Debouncing manually is still useful for certain "noisy" domain events, but it shouldn't be necessary as a general approach in React 16+.
 render() { return( &lt;div&gt; &lt;SomeSortOfInput style={{ paddingRight: "10px" }} /&gt; &lt;ClickableIcon /&gt; &lt;/div&gt;); }
It doesn't mention the disadvantage of arrow functions, that they are always anonymous. If you have a non-anonymous function like let myfunc = function myfunc(a,b) {} Then it has a name. That is very useful when something goes wrong and you have an actually readable stack trace.
That's much more robust too, the other relies on whatever the return value of `console.log` happens to be. If you were to replace that with your own fancy log function and someone had the bright idea to, say, return the logged string, then suddenly it stops working.
Thanks the post, I wasn't aware of that. I know the async rendering will pause renders for higher priority tasks, but I didn't realize it also debounced events to improve performance as well.
This answer seems to be correct. var x = { "my var": 10 }; is a legitimate way to create an object. Notice the space? You can't include the space when you try to call it: x.my var will give you an error. That is why you use: x["my var"] instead. This new notation that you're coming across is great for when the property name in the object is unknown or has an alternate naming convention like the space. For example: var i = 7; console.log(x["property_" + i]); i = 8; console.log(x["property_" + i]); would console log two different properties in the x object. 
jQuery was a great tool. Until folks started to use it blindly and stopped caring what it actually does, pushing bad implementations and accumulated a bunch of code debt in organizations. Happy to see the trend continues to move away from jQuery.
I'm assuming you've seen Choo, how is this different?
Just to follow up for future web searchers: The issue was that there a for loop iterating from 1...10 for some database queries, but some of those were invalid to query for. This stuck some HTML'ish error messages at the top of the JSON file. The old server had "error_reporting = E_ERROR" set in php.ini, so these errors did not appear. I didn't want to set this on the new server, but adding ini_set('display_errors', 'Off'); to the function suppressed the errors so that only pure JSON was being passed. Of course, the better option would be to fix the function so it only queries valid values, but that's a bit beyond the scope of what I am trying to do. 
you cleaned your cache first, which deletes all your local copies. re-download your packages from the network, then try re-installing offline.
The fact that someone had to ask &gt; How come it does the second expression ("x + 1") as well? I'd think it would do "console.log(x)" and stop/finish there.. is a strong argument for why its worse. It's not the short function expression, it's the "clever hack" to make the code even terser. Using the falsey return of console.log and the or operator is absolutely harder to read and maintain. Just put the logging on a separate line. 
Most browsers will use the variable name in a stack trace if it‚Äôs an anon function 
I thought OP was talking about arrow functions in general. Absolutely the `console.log` thing is a hack, and I wouldn't expect to see it committed to a repo. I do use that trick frequently when debugging though.
Awesome tutorial 
another handy use for this notation is if your prop names are in a variable.. var stuff = {thing:"foo"}; var junk = "thing"; alert(stuff[junk]);
Here's an image of a text I'm studying for school, hope it helps: https://imgur.com/VWOzRHX
Stack frames are a very limited resource and recursion can quickly deplete it. Your code, for example, uses one stack frame per character in the string and has no bound to the length of the string. It is incredibly wasteful and would immediately be torn out of any codebase I own.
Not so, you can do it in many ways, But I will suggest you doing it with recursion, it is a very great tool to play with. Everything around loops are now kind of outdated, playing with recursion is first step to go further with that, very large portion of algorithms work with recursions, so it is a good choice imho !
It's rarely helpful to characterise decisions you make as a programmer as good or bad. Writing malware is probably bad. Working pro bono for a charity is probably good. Use of recursion does not have any intrinsic moral quality. So you need to seek out a clearer idea of what you mean by "good or bad". You imply a partial definition when you mention performance. Does good mean readable? Does good mean without side-effects? Does bad mean less likely to be understood by junior developers? When you think in those terms, you'll have different combinations of costs and benefits: "recursion is terse but less readable to junior developers" or "loops consume less memory but are harder to read". Once you start to seek to quantify the costs/benefits of either pattern rather than qualify these patterns with "good" or "bad", you gain the power to effectively apply both to your work. I would avoid reasons like "makes me feel like a Ninja". Maybe following that feeling does bite you this time but it will eventually. Writing software is all about making judgment calls. Minimising ego will lead to better results. To address your question about performance: recursion does incur more memory overhead than other types of iteration. Every function call adds a stack to the stack trace. Every stack initiates a new scope. Every scope is bootstrapped with a context that consumes memory. Until tail-call recursion is implemented everywhere, recursion without a fixed upper limit runs the risk of overflowing the stack. It's also slower than loops because the interpreter has to do more with each function call than it would with each loop iteration. Generally, the latter is not a concern unless you're using recursion to do something with a very large number of iterations in a very short amount of time. 
I had thought I had learned it was a good thing and I remember reading about it in some textbook back in college. But, I'm looking now, and I think it may not always be a good choice for performance. Here are a couple of discussions that I found after reading your post: https://stackoverflow.com/questions/3021/what-is-recursion-and-when-should-i-use-it https://stackoverflow.com/questions/15346774/are-recursive-methods-always-better-than-iterative-methods-in-java
I can totally respect that kind of theme. As long as it's a *theme* and not a *full rearrangement*. "Themes" typically just swap colors. Not location.
I think it's correct, this give padding to input as a style prop or separate prop, this lets you to create reusable input component with whatever padding you would like, and a icon component, try to go further and make components as small as they can be from the logical perspective
Thanks that's useful to know! My problem is, as a beginner, how am I supposed to know what is memory intensive for Javascript and what isn't? 
You could also dust off good-old `void` if you really wanted to: const foo = x =&gt; void myEffectThatReturnsATruthyValue(x) || x + 1 And as a bonus, potentially start a religious war ;). 
That‚Äôs probably the most ugly, impure and error prone js code I‚Äôve ever seen.
It doesn't stop him from getting a profit of the it. The publisher has to pay him
The only reason I ever use recursion is if it makes the problem easier to solve or think about. 
As a beginner, you're not going to be able to _know_ very well. It takes a little of a CS background in understanding how code interacts with memory. One topic to get you started: https://en.wikipedia.org/wiki/Space%E2%80%93time_tradeoff My interpretation is that it's increasingly challenging to make a program both fast AND memory-efficient, i.e. you can make a program fast, but it's likely to consume much more memory. On the other hand, you can make the same program use much less memory, but it's not going to be as fast. To accomplish both in the same program requires some very well-designed code. In general, calling functions is relatively expensive, and the deeper the call stack goes (function -&gt; calls another function -&gt; calls another function -&gt; calls another function -&gt; etc), the more memory intensive it becomes. With recursive functions, the call stack can get really deep really fast, and therein lies the danger. As for this specific case -- it helps to make reasonable assumptions about your inputs. For instance, if you think (or know with some certainty) that the input string will only be relatively small (20 chars?), then using your code will never be an issue. But if the input string might be basically anything (up to the max string length allowed in JS), then it's very unsafe.
Thanks. Are there languages where recursion is less memory intense than loops?
Thanks.
I hate reading Arrow functions. They're so ugly to me
Thanks.
Ah I apologize for not answering your question and over explaining something you already understand. In the case of `obj::func()` func is not a method of obj. That syntax would be: obj::obj.func() or ::obj.func() So you can define method like behaviors without direct relation to the source object. let obj = { clicks: 0, methodFunc () { this.clicks += 1; } }; obj::obj.methodFunc(); ::obj.methodFunc(); const func = function () { this.clicks += 1; }; obj::func() console.log(obj.clicks); // =&gt; 3 You can see them in action at: https://babeljs.io/repl/#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;code_lz=DYUwLgBA9gRgVhAvBA3gKAhAxsAllgawGcAuCABgBo0MIBbcACygBMAxAVwDssIAKAJSpamMI1xEAdDnzEIAamQBGANy0AvmnVq0sOCRJ7JDMa049Bag0ZPN23LJZpYoXIpABmDpBC88wuK78QugQYhLSeIRECspq2jS68AZ-jgKJLm5QoJLAUADmfEYy0QJqAPTlSAB8EADMaEA&amp;debug=false&amp;circleciRepo=&amp;evaluate=true&amp;lineWrap=true&amp;presets=es2015%2Creact%2Cstage-0%2Cstage-1%2Cstage-2%2Cstage-3&amp;targets=&amp;version=6.26.0 
That makes sense to me though. No ‚Äúthis,‚Äù no name. 
So you'd rather have array.filter( function(item) { return item.bool === true }) Compared to array.filter(item -&gt; item.bool === true) 
Id rather have array.filter(function(item){ return item.bool === true; }); It just looka more explicit/readable to me
You can short circuit the conditional: array.filter(item =&gt; item.bool); 
It's a common thread on this reddit. I only use jQuery for certain UI things that I haven't found a vanilla js replacement for - IE - decent tabs (ones that resize, have scroll buttons when over flowed, etc)
I'm inclined to agree. Maybe it's because I'm not the best or oldest JS dev out there so it takes me a bit to see what arrow functions are actually doing, but I think they should be limited to cases where they are strictly advantageous.
Hey guys! I'm working on a developer tool to visualize React's component hierarchy. I was hoping the reddit community can test it out to see if it works on all scales of applications. It hooks onto your application and renders out live props and state. We also added support for redux, router, and react fiber. Let us know if there are any problems! THANKS!!
There's still the text. The white user agreement, privacy policy, etc. text is hardly legible against the light gray background.
Oops thank you 
[removed]
This looks pretty sick ! Chrome extension too ? Kudos !
&gt; React 16 does some debouncing on its own. Do you have a link for this? 
It's actually not significantly slower in javascript, believe it or not. Compare your code to the following iterative example: function fearNotLetter(str) { if (str === "" || str.length === 1 ) { return undefined; } for (let i = 0; i &lt; str.length; i++) { if (str.charCodeAt(i) + 1 !== str.charCodeAt(i + 1)) { return String.fromCharCode( str.charCodeAt(0) + 1 ); } } } fearNotLetter("abce"); If you run it in a performance tester (I'll link one with all the code snippets at the bottom of this post), you'll get somewhere between 10m and 15m ops a second, compared to the 2m to 5m ops/sec you'd get with your recursive example. Now, this seems like a huge performance increase (and it is), but it's not because of the for loop. It's because you don't call any non-native functions. If we replace the condition with a function (which is very, very, very common in a real code base), your performance drops down to the same order of magnitude as the recursive example. function isLetterMissing(str, i) { return str.charCodeAt(i) + 1 !== str.charCodeAt(i + 1) } function fearNotLetter(str) { if (str === "" || str.length === 1 ) { return undefined; } for (let i = 0; i &lt; str.length; i++) { if (isLetterMissing(str, i)) { return String.fromCharCode( str.charCodeAt(0) + 1 ); } } } fearNotLetter("abce"); I won't paste the code here, but adding the same predicate function to the recursive example doesn't change the performance significantly. So the thing to take away from this: calling non-native functions in JavaScript is really slow. That's just something that you have to live with as a JavaScript developer. You absolutely shouldn't inline every function just to make your code a little bit faster. It's not like we're programming rocket ships here. Evidence: https://jsbench.me/zjj8oojxa0/1
I've seen things like this before, but never with support for router and redux which looks like this has! Awesome!
Okay I didn't plan on playing code tennis today but array.filter(Boolean)
I was assuming it was an array of objects, but this is dope! Thanks! 
Unfortunately information on the new architecture internals is quite scarce, but React prioritizes updates in a number of ways, and two of the priorities: "low" and "off-screen" permit delays, which are used to merge the updates with later units of work, the effect is the same as debouncing an update. Information is scattered across these presentations: https://www.youtube.com/playlist?list=PLb0IAmt7-GS3fZ46IGFirdqKTIxlws7e0 Sorry I can't link to a more compact brief.
Looked into this and it‚Äôs a neat trick! This is essentially short circuiting the Boolean constructor after injecting the item from the array as an argument. Really neat, I like that. 
This is not quite right, you need parentheses to destructure arrow functions, even if you are using the single argument form: const getTweets = uid =&gt; fetch('https://api.users.com/' + uid) .then(({json}) =&gt; json()) .then(({data}) =&gt; data.filter( ({stars, rts}) =&gt; stars &gt; 50 &amp;&amp; rts &gt; 50) ); See 2.4 in http://2ality.com/2015/01/es6-destructuring.html
I didn't realise you can destructure methods and mantain the correct reference of `this`
Ah, I somehow missed that. Yeah, if it's the property that we care about, then this solution wouldn't work as it would just return everything.
Hi /u/joeble, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_).
Hi /u/jrdn129, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/soulblade249, For javascript help, please visit /r/LearnJavascript. Thank you!
I guess it depends on what you're used to. For me, not using arrow functions makes the code more verbose without adding any more information.
Something that is never mentioned in these articles is that arrow functions are essentially "normal" functions with a closure for maintaining the scope of "this", which can impact garbage collection/memory consumption etc... I think it is a bit of an edge case, but good to know! 
not a fan, but i use it for inline js animations and it's a fuck of a lot better than vanilla for ajax/xhttp request.
Looks great! But i seem to have trouble getting it to work, it says "cannot find imported React library." Does it support R16 yet? And would it be possible to filter hoc/container/wrapping containers and only show actual presenting components? This is one of the main reasons i can't deal with the react tools, since pretty much everything is wrapped it makes the tree way too verbose.
I wrote a summary on fiber, but I did not see anything about debouncing in my research. https://edgecoders.com/react-16-features-and-fiber-explanation-e779544bb1b7
I can only speak for myself, but if you pay me to be a FE I am not doing to work of a BE dev for free. I will coordinate. Any good development team will have ample communication and work between the different areas, of course. Devs are already getting fucked by being salary, don't give them more free work.
Hi /u/autumnwing1, For javascript help, please visit /r/LearnJavascript. Thank you!
Which is great but has nothing to do with what I said if I understand your intent correctly.
93 terabytes. I wonder how they are handling the bandwidth and data storage of all this. Bot net?
To me, recursion "clicks" more in a proper functional language. Haskell is one example. The language is designed with recursion in mind, so you worry less about performance (though your program can still get stuck in infinite recursion), and recursion really promotes readability because you can separate the edge condition (when not to make another recursive call and instead return the result) from the function body. In my experience, recursion in JavaScript is not always obvious or elegant. One of the classic Haskell examples is quick sort, which demonstrates the elegance of recursion. ``` quicksort :: (Ord a) =&gt; [a] -&gt; [a] quicksort [] = [] quicksort (x:xs) = let smallerSorted = quicksort [a | a &lt;- xs, a &lt;= x] biggerSorted = quicksort [a | a &lt;- xs, a &gt; x] in smallerSorted ++ [x] ++ biggerSorted ``` The elegance here is basically the classic Haskell idea of writing "what it is" instead of "how to do it" as you often do in an imperative language like JavaScript. Quick sort takes a list and sorts that list from least to greatest. So "what it is" here is a list sorted from least to greatest. And the Haskell implementation is almost a literal transcription of that definition: `smallerSorted ++ [x] ++ biggerSorted`, where `smallerSorted` and `biggerSorted` are recursive calls to `quicksort`. Using an imperative approach, you'd have nested loops that are comparing each item to all the other items. That's the "how to do it" approach, because it reads like a list of instructions you'd give to someone over the phone who was trying to sort something. Again, neither is better than the other, except maybe as a matter of personal preference. You can get the job done with both. Although not in Haskell. Recursion is your only option.
Node
ok
Thanks for checking us out! It's still has some bugs with some R16 features. If you can make your application trigger a set state (possibly typing in a text box?) when opening the tool, it *should* be able to detect the root node. 
I usually filter out my own props and collect all other to allow users to extend in any way they like (for instance classnames, styles, click events, etc) export default class extends Component { render() { const { someProp, another, style, ...props } = this.props return ( &lt;div style={{ margin: 10, padding: 10, ...style }} {...props}&gt; ... &lt;/div&gt; ) } }
Thanks! That's an epic answer. 
It did help!
Ransomware often leaves the data in place in your original server, it just encrypts it using a key known only to the attacker so it's unusable. All the attacker has to store is which key belongs to which victim (assuming they actually even intend to honor the ransom).
Since I wrote that comment, I've been digging into some reading and consulting the repo to try and figure out exactly how the priority system works: still working on it... As a side note, I think your article is a bit out of date (through no fault of your own) [since they removed the Animation priority](https://github.com/facebook/react/pull/9968) 
It isn‚Äôt bad nor good. If you can use a loop, then you usually should. However there are cases where recursion makes more sense.
Well, for starters, the entire code base fits right here: var html = require("yo-yo") exports.app = function(state, view, reduce, element) { return (element = (function render(state) { return view(state, function(action, state) { return html.update(element, render(reduce(state, action))) }) })(state)) } exports.html = html It's also based on the elm architecture (model -&gt; view -&gt; update) and Choo isn't. 
That is what I thought. But this article kind of indicates it deleted the data opposed to encrypt it.
This is why our pipeline runs closure and uglify back to back. Closure misses some random things as well, usually because absurdly obscure edge cases say it's unsafe, but we've never run into one that uglify has triggered since they almost all come from hacky code
For these situations I use a customStyle prop that you can pass to a component that will override the default styles. This is how it would work with a JSS solution (with CSS you would just apply another class): First add a style prop: &lt;SomeSortOfInput style={style.extraPadding} /&gt; Then inside the component: ({ style: customStyle = {}, ...rest }) =&gt; ( &lt;View style={[style.defaultStyles, customStyle]}&gt; // ... &lt;/ View&gt; ) This gives you the added benefit of having no extra elements, opening up the entire style object to be configurable without sacrificing anything or having to refactor anywhere the component is used.
That is quickly becoming a myth. Understanding that unsupported browsers are a massive security risk, most major companies and state governments have moved away from old IE browsers.
That is what I thought. But this article kind of indicates it deleted the data opposed to encrypt it. It also says no one has been sent their data after paying. So my guess is they deleted the data with no intentions of giving it back.
I originally had the same opinion, but after using them for a few weeks, i found i actually really like the format. I always use parentheses, brackets, and a return statement... `(x) =&gt; { return x + 1; }` ... IMO the shorthand format is a little less readable, kind of like an `if` statement without brackets.
Valid use cases and no reason to change if it's working well for you, but for animations, I would recommend [gsap](https://www.npmjs.com/package/gsap) and [velocity](https://www.npmjs.com/package/velocity-animate), they handle only animations and are more performant and robust. For ajax, I would recommend looking at [axios](https://www.npmjs.com/package/axios) (promise based) or [superagent](https://www.npmjs.com/package/superagent). (I would also recommend avoiding fetch and derivatives unless you're 100% sure your app _never_ needs cancellations or upload progress)
Sure, it's perfectly Ok. It's compact and understandable, and using a variable to store it is just taking up memory for something that's unnecessary. Also, lines beginning w/ four spaces are treated as code, so you can format code nicely. 
When possibly I go for css animation via classname, but yea. I also use axios. 
When possibly I go for css animation via classname, but yea. I also use axios. 
You could make it even better with ES6 syntax: const binaryAgent = str =&gt; str.split(' ') .map(num =&gt; String.fromCharCode(parseInt(num,2)) .join('')
Pretty cool! A lot of these are supposedly handled by http://prepack.io, but that's not production-ready yet.
Not a huge fan of arrow functions to be honest. I like the syntax, but the fact that they don't work like regular functions is just awkward. Like, &gt; Hey, now you can write functions in a very short manner! &gt; ...Also, *this* works different here! is a very weird design choice. An unnecessary compromise between neater syntax and a slightly different workflow for certain cases.
Is this a complete re-write or are you adding new modules?
It needs to be a complete nuke and rewrite. We're putting patches on top of patches at this point.
 this.setState((nextState) =&gt; console.log(nextState) || ({ repos: repos })); Don't do this.
Unless you never assigned it to a variable...
Well considering you narrowed it to frameworks created by Facebook and Google and then said you prefer angular, I‚Äôm going to go with angular. 
Looks great. I've been looking for something like this.
I think Angular sounds like your best bet, especially because you want to use TypeScript and want it backed by Google. You say you have an AngularJS dev, so they may be less daunted by Angular (even though it's pretty different). I wouldn't worry about that too much though, I think any decent developer should be able to learn new frameworks.
If you happen to use Material UI (beta/1.x): SomeSortOfInput.jsx: import withStyles from 'material-ui/styles/withStyles'; const styles = { root: { maxWidth: '100%' // or whatever style rules you need } }; const SomeSortOfInput = ({ classes }) =&gt; ( &lt;div className={classes.root}&gt; { /* your component JSX */ } &lt;/div&gt; ); export default withStyles(styles)(SomeSortOfInput); ParentComponent.jsx: import withStyles from 'material-ui/styles/withStyles'; const styles = { root: {}, someInput: { paddingRight: '10px' } }; const ParentComponent = ({ classes }) =&gt; ( &lt;div className={classes.root}&gt; &lt;SomeSortOfInput classes={{ root: classes.someInput }} /&gt; &lt;/div&gt; ); export default withStyles(styles)(ParentComponent); This has the benefit of using `&lt;style&gt;` tags which are more performant than inline styles. You can override any styles that you use in any component that uses the `withStyles` HOC. And in this example, `SomeSortOfInput` will get classes for both it's own `root` style and for `ParentComponent`'s `someInput` style. 
Also: this.setState((nextState) =&gt; ({ repos: repos })); Can be simplified to: this.setState(nextState =&gt; ({ repos }));
No problem. I should have worded my question a little clearer to make it more obvious what I was trying to ask. I guess that makes sense that if ::obj.func() could be interpretted as (obj.func.bind(obj))(arg), it would be more performant and functionally the same just to write it as obj.func.call(obj, arg).
super cool looking site, definitely would like to see more tools that help devs solve this problem
well, it's just a quick hack right? beats having to put parens around it like `o =&gt; (console.log(o), o)`
I always do `const foo = some =&gt; thing(some)` and Babel or whatever knows the function is called `foo`.
It's also really nice for configuration, for example if you want to use some plugins in Webpack conditionally, you can do ```js plugins: [ isDev &amp;&amp; new SuperDevPlugin(), new AlwaysPlugin(), ].filter(Boolean) ```
Arrow functions are great. I avoid writing `function` and as a bonus I never have to wonder about `this`. Only if I need to write a handler detached from its class will I use `function`. It takes some cognitive load off js programming.
It's a bit weird - maybe it works here because the `json` is bound to the response, but it takes little effort to write `.then(res =&gt; res.json())` and is a lot more clear at a glance‚Ä¶
And if you do somefunc().then(result =&gt; something(result, b)) ?
You can use the new `module` attribute on script tags to load a bundle meant for modern browsers, and you can make a separate bundle for older browsers.
ah yes, then it's anonymous but it will be easy to glean from the line numbers and the call stack where that is.
Nice. I like your form better. What would be an example of how that's used as a parameter to another function like `array.filter`?
Not doing stuff like this is the whole point of using linters.
Isn't that an implementation detail of the browser, and thus could be different for every JavaScript engine?
Hmm, yep! I guess so :)
+1 for positive attitude OP
If you are looking for framework that can be run without building system (but can if you want to) - IMHO Vue is the only real option here. 
I doubt `json` has an explicit binding to `response`, because why should it? Anyway, the suggestion of using `res =&gt; res.json()` definitely looks more appealing to me
or function BooleanCompare(item) { return item.bool === true; } array.filter(BooleanCompare); 
One-off variables are great as descriptive implementation (better than comments), but aren't always necessary. In this case, I would say the function name isn't great as I had to check implementation to discern what was going on. Starting with a verb can often help, clearing up what the function "does". And when in doubt, breaking up a step or two with variables can making reading the implementation faster. For more on this, check out the book Clean Coding.
So it's putting the template literal `#cpy-${app.name}` into the clipboard, instead of the output of the template literal?
Well, transpilers definitely do this, they don't have any choice. Although, babel detects whether you're actually referencing `this` and skips it when it's unnecessary.
&gt; let myfunc = function myfunc(a,b) {}; This is actually an anonymous function whose value has been assigned to the variable `myfunc`. This would accomplish the same thing: &gt; let myfunc = (a,b) =&gt; {};
Awesome thanks for the response! I always figured that was sort of the case but I guess I‚Äôve just never really encountered chrome being that taxing on my system. Although Atom lags hard for me sometimes. Strange.
I'd avoid taking the parameter this.setState(() =&gt; ({ repos })) 
I second Vue. I don't do this often but it sounds as if bringing in a framework like React or Angular with an entire build system and more of a component based/JS-everything approach is going to cause too much friction. Maybe try vue + typescript, or perhaps give Flow a change, it's easy to incorporate gradually. To be honest it sounds as if there are just too many things at this point that you need to work out. You want backing of a major corporation, typescript support, compatibility with current projects,.. initially that sounds like you just want Angular but then you'd have to forget about a templating first approach.
Have you tried setting a higher z-index to the window pop up? https://www.w3schools.com/cssref/pr_pos_z-index.asp
If you are that concerned about it: ``` somefuncResolver = result =&gt; something(result, b); somefunc().then(somefuncResolver); ```
As far as impact on GC goes, sure, but the behavior of lambdas is prescribed.
People are too focused on the syntax part of lambdas. That is not why they exist.
/me reads link domain, sees "sitepoint.com" -- yep, sounds about right. Garbage site.
S O U R C E M A P S
 S O U R C E M A P S / O / O S O U R C E M A P S U / O R / O R / U C / U C S O U R C E M A P S R E O C M O C M U E A U E A R M P R M P C A S O U R C E M A P S E P / E P / M S O U R C E M A P S A / A / P / P / S O U R C E M A P S 
thanks it worked
Really cool stuff. Gonna bookmark this for later. 
That closure is created whether it is an arrow function or not. If that closure is inaccessible though, in both cases it can (in theory at least) be garbage collected.
nononono.gif
good bot
Thank you Intie for voting on aryanchaurasia. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
And also what to use instead of iframe? Cheers
If coalescing has been removed, I guess I'm no longer right up there.
it doesn't really make sense to say so-and-so is faster than so-and-so in javascript because there are so many implementations of javascript. it might be faster in v8, but it's misleading to make broad statements like this..
basic github search turned up with this : https://github.com/ant-design/ant-design &gt; An enterprise-class UI design language and React-based implementation.
Think of the function scope as a JS object. It starts empty. You add the parameter names and give them any values provided. You add a hidden property to the parent closure. You look in any parent closures for the value of `this` (if it wasn't explicitly passed with something like `.call()`) and add it (it becomes the global in non-strict code if no value is found). You add a pseudo-array called `arguments` and put all your provided arguments inside. Now you start looking at the function itself. Any variable names declared with `var`, `let`, or `const` (outer scope only for let/const) are added to the scope object as `undefined`. Finally, any function declarations are parsed and the result added as the value of the key (before execution). Finally you start executing. The only important difference with arrow functions is that the `arguments` and `this` variables are not given any value. If you access them, you have to go up the closure chain. In theory, arrow functions can be a tiny bit faster than normal functions in cases where `this` isn't used. In addition, arrow functions don't have the cesspool that is `arguments` which means that they will never deoptimize because someone did something stupid.
Unless someone has specifically coded that, they will have to Google and use something from stack overflow or whatever. Why should someone know what type of object window.getSelection gives them? When I tried to do something similar years ago, it was tricky to get something that would work cross platform. Leave them alone while they code it.. don't breath down their neck. Don't expect them to remember details of little used APIs. Don't expect them to code while you are watching them. Specify one browser it is supposed to work on. If it takes a while for them to figure out the main trick, give them a hint like window.getSelection.
Not a frontend engineer myself, but it seems, that writing backend part puts them off. Would it be enough to persist state in a browser LocalStorage (http://diveintohtml5.info/storage.html) ? This will make it a purely frontend assignment.
True. I don't know the APIs myself. The question was relevant because he was using 'sel' as an Integer later on to get a substring. I've corrected my post. Sorry, missed this detail. I'm pretty chilled out during the interview. They can do whatever they want as long as they have a good reason for it and they understand their own code. Selecting the text, they can just choose to click a word and automatically select it. Whatever makes the point. 
One guy today created a local object with two methods get and set and that was considered his server API. He could write whatever he wanted over there. To mock a reload from server he manually changed the variables from the object and restarted the app. Unfortunately that was the only working piece of code. Get/Set.
judging by the tone of original post, I think "I don't know what exactly window.getSelection() returns, let me check in console and see" would be a sufficient answer. 
What does your implementation look like?
I used to screen coding applicants. In the hiring process you get a lot of duds, fake it until you make its, or people who can do the job but does it poorly. Tests like this help weed them out. Without them you are liable to hire them. Even if you hired them they may or may not work out. You might have already hired some. So I would have all your employed devs take the test. If they have the same issues but you are otherwise happy having them on the team then I would modify your tests to cater to these devs. Then you can use this test against applicants to try and discover those that will be a good fit.
Without all the context from the rest of the post, I would not have a clue what you actually wanted. I find task 1 particularly incomprehensible. Are you there to answer questions when you hand them this project? After rereading your post 3 times I think I know what you're actually looking for. I suspect that the average senior JS dev would take somewhere around 4-8 hours to complete the prototype this without bugs. How long are you giving them?
For reference I'm a deep NodeJS guy who knows enough about browser side vanilla js that I can understand the problems the big frameworks are trying to solve and and what challenges they bring. I have no hands-on experience building a big SPA, but I do jump in at work and fix our SPA for those times when you simply need someone very comfortable with JavaScript and not framework XYZ. I'd honestly say one hour is pushing it VERY fine. Throwing together a NodeJS project from scratch that includes an express server (and all the plugins to make it work) plus a socket-io library along with a build pipeline for a webpack bundle and all the boilerplate that comes with it... Add on top the time for all that to npm-install... I could probably spend an hour just getting setup. I'd consider dropping the hints about frameworks - it sets an expectation on the examinee that they need to use one. If I were to take your test and see it through within the hour, I'd ditch the framework and dump a script tag onto the page. It'd work, but it'd probably not be testing the skills you're looking for. If the solution met the spec, within the time limit would it pass? My employer ditched the idea of coding test a long time back, favouring instead to pit them alongside someone of comparable skill level and have them pair up. We find the rich dialogue and interactions you get with the candidates are way more valuable than a rushed coding test. ¬£600/hour is a LOT of money!!
&gt; Are you there to answer questions when you hand them this project? I'm with them at the beginning of the test for about 10-15 minutes to answer questions. I also ask them to tell me what they think the task is. They generally pick up on the functionality they need to provide for MouseDown events. I address this by providing some examples or telling them a simple click on a word would suffice. 
I've given a ton of tests to FE devs over the years, and I can see a few mistakes that I made early on. I do think that a senior level dev (5+ years) should be able to knock this out easily, but I think there might be a few things you can do to get to talking about the useful things you are trying to look for (also, the test screams fullstack, but *shrug*) 1. If you are sitting in the same room with them during this, stop. Check in twice to see if they have any questions but leave them alone while they work on it. 2. Get rid of everything that has to do with the token rules. People are probably spending too much time hung up on these. You're asking for a lot already, simplify it to "they can make any number of selections, they are persisted, can be deleted, and repopulate". If they can get this done you can always ask afterwards how they might implement some of the more complicated token parsing rules. 3. Drop the tags stuff. 4. You need to give them *something* to start with. A repo to clone with absolute barebones. They shouldn't have to go find sample text on wikipedia, if you want a node backend, they shouldn't have to start with an empty directory and then go google how to serve static files. I'd create a boilerplate that includes: - index.js for a node backend that: - serves a static folder - has an express route defined for /save (doesnt do anything, just so they know they have and can use express) - inside that static folder - an index.html with your instructions and the sample text from wikipedia - includes jquery on the page - an app.js with an IIFE and a console.log('make me work') You don't want a test where the only person to complete it wins the golden ticket. You want a test where 75% of candidates can complete a majority of it, and you get to sit down and have a meaningful discussion about the choices they made and how they would improve upon it - the kind of interactions you would have day-to-day. There are a lot of devs with a couple years experience who think they are qualified for "senior" frontend positions. It just isn't the case, and it sounds like the majority of candidates you've seen are like that. But I think you're also setting them up to fail. Dumb it down to where you think a junior level dev. should be able to complete the task.
`let myfunc = function myfunc(a,b) {};` is not an anonymous function. That's a named function expression, which is by definition not an anonymous function.
Absolutely. Easy-to-learn API and vast community adoption warrant at least looking into it. React is still a better option for larger projects with more complex needs, but I think Vue more than not does the job you need with a smaller, more approachable footprint.
Looks useful! Does this work with webpack? I am trying it out on our project with 15.5 and cannot get it to find the imported React library. 
Thanks. It's a good advice. This developer will be our first front-end dev in the team and we want him/her to lead the front-end effort. He should be the master of his ship.
Thanks a lot. It's really useful and it all makes sense. Points taken onboard. 
The entire statement is a named function expression, you are correct. The function declaration itself is an anonymous function.
By my reading of the official documentation for using yarn offline, that is exactly what one should be able to do...clean the cache and have it use the offline cache (which doesn‚Äôt get cleaned) to complete the installation. It says for example, in the documentation: &gt; How can you test to make sure it is offline? &gt; Clear your global cache with ‚Äúyarn cache clean‚Äù &gt; Turn off wifi &gt; Run ‚Äúyarn install ‚Äìoffline‚Äù. The offline flag will make sure yarn does not reach out to the network You are supposed to be able to take the offline cache, package.json, and .yarnrc file anywhere, including a machine with no internet access, and still be able to complete a successful install. As best as I can determine, there is a bug in yarn that is preventing this documented feature from working. 
You're asking for a front-end dev with a full-stack skillset. Modify your job posting and you'll get better applicants.
Your challenge itself is fair, but I'd say the one hour time limit puts people into a state of panic. The setup of the back end may he what is exacerbating this. As mentioned in another post, give them something to start off with. You're testing whether or not they can develop front-end applications, not how they perform in a stressful time constrained environment. This may be applicable for a position such as site reliability engineer, but front-end is relatively more relaxed. Just my thoughts.
are you using actual ides or text editors? cus I'm not aware of any that don't have this feature. cmd-shift-r does it in NetBeans, I know eclipse and android studio have this too but idk the keys..
What would I give for Javascript to support it.json()...
Good feedback. Thanks for the suggestions. I tell them to come with a laptop ready to code in their favourite framework. For the NodeJS backend part all I wanted to see is that they can allow the server to do get/set. The job shouldn't involve almost any backend but they do need to be able to jump in should there be an emergency and have a constructive conversation with the back-end engineers and agree what functionality stays on the server and what functionality goes in the front-end. 
Does work with webpack. Make sure you're using the chrome extension and not the npm module and have react-devtools and React-Sight enabled 
&gt; 1 hour is insane. Interesting... Time estimation varies greatly from between replies. On the assignment description, maybe I misunderstood it, but it looks quite clear. &gt; Allow the selection of a single token, at once. Display the selected token in a visually distinctive way. == whatever is selected, must be highlighted &gt; The page can only contain a single selected token. == once you start new selection, previous selection drops &gt; A token cannot contain ' ' (space), ','(comma) or '.'(dot). Everything else is eligible for being selected. quite clear. &gt; &gt; The user cannot select "There will be" in the same operation. This attempt will result in having only the word "there" selected. The user will have to select each individual word separately; == single selection/highlght can not span separators &gt; A selection that starts inside the content of the token will consider the entire token. "The|re will be" will select the token 'There', where | can be read as the starting position of the cursor. &gt; &gt; When a token gets selected, any other token that is selected on the page becomes unselected. A page can have zero or 1 token at a time. The currently active selected token should be visible on the page in a distinctive way/highlighted/ bold/colored differently. &gt; summarizes all previous requirements &gt; The selected token is persisted to server and displayed on the page when the page is reloaded, loaded in a different browser. &gt; quite clear.
Lads, it's Ben Nadel.
Ah, if that is the case then I agree. Don't settle for less.
are front-end guys are so narrow-skilled that can't through together some basic http backend in a language of choice? 
in NetBeans for example you can set formatting standards in the settings e.g. linebreaks before curlies. then hitting a hotkey formats the code. it works pretty well. problem is if you have a super short conditional or function you want to keep on one line NetBeans is going to spread it out anyway. code is maintained by people not machines so the way I see it, it needs that human touch. adapting and sticking to a code style is the only way to go imo. plus, that's like your signature. I work on a team of a few different devs and even with version control it's really nice to be able to look at a piece of code and instantly know who wrote it just by the style. plus, it literally takes like an hour to enter all the formatting settings into an use. you never realize how much of it is instinctual until you have to tell a machine how to do it.
Reckon i can get this going with react native?
Be upfront is what they're saying, no need for snark. 
If you need an interior designer are you going to interview architects?
Thanks for the feedback. Very valid points indeed.
I haven't opened it yet but THIS IS WHAT I"VE ALWAYS WANTED FOR CHRISTMAS!!!!!!! If this works how I hope it does, I will give you a buffalo nickel. For those of us who are visual "understanders" graphical representations of hierarchical systems are the bees knees
I didn't mean to be negative. Given the landscape of JS, there are just too many frameworks to take anything shiny seriously these days. went through the info, and it seems like this does have a redux++ feel to it. 
There is a problem solving component involved here. How do you decide what needs to be done on server and what needs to be done on client? Most of the guys had 2years+ NodeJS experience. If I rephrase the problem so they start from a server that gets them on GET /gettext an array of words with id, the problem of selecting a word in the client becomes trivial because this approach already frames the solution. What I don't get is why they wouldn't be able write two methods on the backend. 
But it's true in literally every implementation that's actually used...
gosh Napoleon like anyone can even know that
You need this. It's a godsend: https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync 
But it does show a certain intention of being aesthetically pleasing, what with the `args =&gt; this_is_returned` syntax.
Thank you for `@ts-ignore`. It's been painful to work around bad definition files from packages. It could be as simple as a forgotten property in a definition file. Now I don't have to jump through hopes for something beyond my control.
&gt; You need to give them something to start with Above anything else, this is the most important thing. Asking someone to start clean-slate is totally unrealistic.
It's just awkward that it *both* offers better syntax (at least depending on who you ask) and treats `this` differently. The difference being subtle is even worse, since people will just gloss over it, including tons of articles about the feature. If I were in the ES commitee, I'd just make arrow syntax work just like regular functions and make different syntax for the different scope behavior. Like what they did with generators and adding an extra `*`.
good analogy! If I interview interior designer, I'd be checking among other things, if he knows what load bearing wall is and how pipe and electrical works affect his options (and other way around too). He needs to have basic architectural knowledge to see which of his ideas can be implemented at all.
This is a joke, right? This has to be a joke. &gt; The following is a short extract from our new book, JavaScript: Novice to Ninja, 2nd Edition, written by Darren Jones. **It‚Äôs the ultimate beginner‚Äôs guide to JavaScript.** This has to be a joke.
Are you familiar with CesiumJS?
If one applies to a senior position, he better show knowledge of some related subjects. Same as for non junior backend engineers it is almost mandatory to be able to create SQL schema and understand how indexes and joins affect performance or show understanding of any other subjects outside of their main area of expertise. When gaining experience, it is almost inevitable to be exposed to a tech you are interacting with, there simply can't be distinctive depth of knowledge without at least some breadth too. 
Prototypes, closures, `this`, and hoisting!
Promises, async, await. Maybe I'm a moron, but it's just not 100% clicking in my head.
Does this mean you‚Äôre hired?
Not really, no
It's an open source Google Earth replacement / advanced geospatial platform written in JavaScript and using WebGL. It's a bit hard to get started with due to the way dependencies are handled, so this Webpack version takes care of bundling all the dependencies for you into a single file.
Thanks.
I‚Äôd suggest breaking the problem down into stages. This way it‚Äôs not as overwhelming (you‚Äôd give them the next step after they completed their current step). It‚Äôs a good exercise in reading their own code since they‚Äôd have to do so to progress. Also, as others have suggested, if you stick with this problem, try giving the boilerplate code. It‚Äôs similar to how hackerrank gives you some basic framework to put your code in. With this stages method, it‚Äôs not a matter of ‚Äúwho finished‚Äù but ‚Äúwho got the furthest and why‚Äù. You can sneak in some good/complicated stuff later on, like testability (how would you test this/unit test this?) reliability (network issues, etc), troubleshooting (live app is giving this error, what‚Äôs broken?) etc
Why is #4 a complete failure? I'm not aware of another way of visually distinguishing between characters within a text node other than extracting a range into a separate node. Like others have mentioned, it seems that your assignment is somewhat tough, even for a senior FE developer. I have two issues with this test: 1) I'm not sure that this task warrants the use of a framework. Most of the solution involves the use of DOM interfaces, e.g. selections and ranges, which most frameworks wouldn't help with outside of third-party plugins/components. If I were an interviewee, I would be concerned why you wanted me to attempt to fit this somewhat isolated problem into the context of Angular or React. 2) Although I think your instructions are clear (except I would need more clarification for Task 3), the time limit is too low. I would extend it to two or more hours.
Agree on prototypes - haven‚Äôt seen a need for them unless you are writing a framework or library. I‚Äôm good with hoisting I think because I learned K&amp;R C back in the mid 80‚Äôs as one my first languages and hoisting is just effectively the only way to do things - all declarations at the top of the function. JavaScript just does that for you if you don‚Äôt, if I understand it correctly.
Integration Testing is killing me. 
In my opinion, 1 hour is completely unrealistic. The Selection API is horribly finicky and full of corner cases. I‚Äôve worked extensively with Draft.js and you need only look at the number of issues surrounding selections in that repo to know that even the smartest FE devs on earth often struggle with selections. 
I have about 5 years of experience on both ends and can definitely ship something like this, the work itself is not an issue for me. I am however a perfectionist, and fret about the quality of the code I write as I write it. 1 hour for this task is unrealistic for someone like me. You did say you give extra time, but applicants in interviews are nervous and might gloss over the "extra time" and worry their butts off about the time frame having only mentally noted the time limit. It is also not fair to discount those who take longer than an hour as not being able to push code within reasonable time - we all know meeting deadlines is a coveted trait in a software developer, but not being able to finish a full-stack task in 1 hour while under pressure is not a good way to measure this trait. I've never been on the opposite end of the interview table, but I'm certain that a better indicator of dedication and ability to handle workload would be giving the applicant an afternoon to do the task, and then checking how often they committed/pushed to the repository, as well as how atomic those commits were.
If you haven't done this yourself, go do it. You'll learn way more about which bits are hard, and what a good solution might look like. 
For sure, but you shouldn't be asking the designer to build those walls, electrical systems, etc.
It's 60-80% slower than the fully-optimized iterative example, but roughly the same speed as the iterative example that calls a function each iteration. Don't know why you're being so rude when you didn't even read my post... Oh and the benchmark holds on Chrome on Ubuntu, Firefox on Ubuntu, Edge on Windows, Chrome on Windows, Firefox on Windows, and Chrome on Android. All have test cases 4 and 5 within around 10% of each other.
You‚Äôre not a moron, they‚Äôre definitely weird compared to most other JS. This helped me quite a bit for promises: https://qntm.org/promise Once you‚Äôve got that figured out, async/await is a little easier because you can transform it into a promise in your head. 
I wouldn't fret too much about the Vue developer availability. I learned enough about Vue in one afternoon to make one of the most highly-depended on plugins in the Vue ecosystem (although I'd prefer not to say which as I am on hiatus from open source work due to extreme injury). That being said, it is remarkably easy to learn. In fact, since it balances ideas from Angular and React, either an Angular developer or a React developer would have no issue learning Vue in about 3 hours. It's API surface area is extremely tiny compared to those frameworks. And don't think for a minute that it not being backed by a company is a valid reason not to use it - because it is backed by a company. the largest e-commerce company in the Asiatic region (which accounts for more than half of the world's population), Alibaba, are huge investors in Vue.js. Also, Evan You is a humble, friendly genius that is happy to answer questions and provide support for small issues during the learning curve, has worked on previous high profile projects like Gulp / Angular and is literally being sponsored by many companies to continue working on Vue. 
[removed]
Do they?
Thanks for the warning. If a site does that to me I instant close. 
idk what was rude so I deleted all of it. Im just disagreeing with a subjective comment you made, nothing more. didn't mean to hurt your feelings or whatever. it's not unlikely they would vary more than 10% even in the same browser at different times. 
Honestly, this task should have nothing to do with the backend. You can store this data in localstorage or whatever. 
I think the most confusing thing about hoisting is the difference between these: function a() {...} // hoisted var a = function() {...} // name hoisted, body undefined. ex: console.log(a()); // Uncaught ReferenceError: a is not defined var a = function() { return 42; }; versus console.log(a()); // Prints 42. function a() { return 42; };
I think one of the more confusing concepts was .__proto__ vs. .prototype. Promises is definitely up there, event loop, and strange type coercion. 
I tell you what, these new ways of doing async development confused the hell out of me at first, but damn if they're are so much cleaner and easier once you get used to them!
I have to say I just find the instructions for this task confusing. I am just skimming over it now but I only have vague guesses as to what you want. I feel sorry for anyone who had to take this interview with you, you remind me of someone I used to work with who I gave interviews with. He would be a smug asshole most of the time and yeah some people really struggled but at least in his case it was ordinary whiteboarding questions (of the type you would find on leetcode). THIS interview question to me just seems sadistic -- and mostly because it's confusing as hell. I guess I am not winning the pissing contest but seriously this is fucked up. 
&gt; You don't want a test where the only person to complete it wins the golden ticket. You want a test where 75% of candidates can complete a majority of it, and you get to sit down and have a meaningful discussion about the choices they made... Great insight.
Working on creating a tool to allow you to track webpack's output over time. Use the plugin in your production config to take snapshot of a build. Launch analyzer to check out build history. Let me know what you think!
Raj is similar to Redux. "Why Raj" explains: &gt; The Elm Architecture transcends any particular language. It plays to Elm‚Äôs strengths certainly but has found a home in JavaScript through Redux. Redux too loosely follows the architecture, inventing for itself much more complexity which Raj serves to undercut with a stricter adaption. Raj is a lot more limiting than Redux (in what I feel are good ways) and the program model from Elm takes center stage. Looking at it on a spectrum, Raj is in between Redux and Elm, so yeah a Redux++ is a good way to put it.
I found the wording of some the tasks somewhat confusing. Even though I managed to correctly pick up on what the requirements were, and if you told me my understanding was correct, personally the initial confusion would put me off balance. That added with regular interview nervousness, and a 1 hour time frame wouldn't put me performing at my best. I don't think the task is unreasonable, even with that time frame. Heck if instead we spent the first 10 to 20 minutes just casually discussing the problem / solution on a whiteboard. Then you told me to work on the problem for an hour to see how far I could get, I'd likely have it finished before the hour. If I knew you well, I'd be fine if you gave me a strict deadline, and a task list. There's an added pressure when you don't know someone, because you don't know how they will react. Thoughts like "will they be super critical if I don't comment my code?" can take up a lot of mental space. Whiteboarding may not be the right approach for every interview, but I'd recommend asking them how they'd like to get started. You can suggest something if they aren't sure, but the important part is to make sure they are comfortable. Options for the problem discussion: - Whiteboard discussion - Read outline document, then discuss - Review mockups, then discuss Options for working on the solution might be: - Pair programming - Work alone, then review - You work beside them, they can bounce ideas off you, and ask for help In general I think you should be helping them succeed any way you can. Even if that means pointing out a mistake and offering them a solution. We all get stuck sometimes, especially if we're stressed, sometimes it's not even a bug in our code, but just a mental block. Avoid making it seem like a test, and instead make it seem like something you're both invested in. For example if they're rusty at Node, tell them you can build that part, walk them through it, and silently take note of how much they are understanding/contributing. Conducting the interview this way will also give you a better sense of how things would be when officially working with them. All that being said I find some of the comments you recieved equally concerning. I've conducted some interviews in the past, and luckily didn't get any BS like that. So it's possible you are just getting a bunch of bad apples, but also could be stress factors making people say/think stupid shit.
Are you interviewing retards mate? I'm jr jr Dev and these excuses stink of laziness. Keep on searching.
This is a killer update! That @ts-ignore is üî•üî•üî• but I hope it doesn‚Äôt lead to fewer contributions to DefinitelyTyped.
Promises are IOUs. A function gives you an IOU (`Promise`) instead of the money. When the function can pay you back, it gives you the money (`resolve(money)`). If it's an asshole and can't pay you back, it tells you to get bent (`reject()`). `await` is a strike. A function gave you an IOU, and you said "I'm not doing a goddamn thing until you either give me my money or tell me to get bent (`const money = await giveMeMyMoney()`)." But most everyone else in your app isn't in the union, so they all keep working while you're sitting there doing nothing. `async` is like a sign on the front door of the factory that says "we're on strike, so you'll have to `await` a while (`async function weTryingToGetPaid()`)."
Maybe a comma after the atv2= variable declaration?
Closures, this and hoisting were all a problem for me, until I came across this Udemy course: https://www.udemy.com/understand-javascript/ This guy is an innate teacher and breaks down things in a way that, when he asks after a large and detailed explanation of a seemingly complex thing: makes sense? He makes you go: well... yeah!
5+ years experience. I would have noped the fuck out of there. 
100% this. If this is how you present your work environment to potential employees, it's setting a horrifying example. I wouldn't want the job even if I did crush the task. 
Arrow functions, destructing and the spread syntax are my holy trinity of es2015+ niceties. 
Generators and the tools/libraries built on top of them (for example, async generators, for...of, co, and redux-saga). Being able to pass values back and forth and throw to and from them was all initially difficult to wrap my head around. I also think that not enough of a big deal has been made that `await` is an expression that can be used anywhere. `if (await foo() + 1 === 2)` for example. And over the years, other things that have taken a while are Promises, the prototype chain, and Array.prototype.reduce. 
Agreed. If I were given a test written by a supposed developer that was this long winded and yet still poorly defined, I'd just leave. Developers who write English poorly also tend to write code poorly, and there are too many good shops to waste your time working alongside them.
https://github.com/Stuk/jszip
I don't know why, but to me it always feels wrong using `await` in a context like that. It works, but it doesn't seem right.
Tool works great! Easy to use and very intuitive! Would be great if we can have some filter options to ignore certain modules. 
As someone graduating from a CS program this spring, seeing these ‚Äúsenior‚Äù developers fuck this up gives me some hope I‚Äôll find a decent job. 
I do phone screens before folk come in using http://collabedit.com/ I ask 3 questions of slowly incrementing complexity and it never ceases to amaze how bad people are. Your example is pretty complex. Trust me, try asking my first two 'simple' questions and you will filter out a large number of candidates: Q1. Write a function that takes a string as an argument, the string is a sentence containing space separated words. The function returns a string with the words in the sentence reversed (not the string reversed but the words). Q2. Write a function that takes an argument of int that is the index into the Fibinacci sequence and returns the number in that location. Reminder, Fibinacci sequence starts with 0, 1 and the next number in the sequence is the sum of the previous 2 numbers. 
Any of the online code tutorial sites: codecademy, Udemy, codeschool, etc. I find that the other really nice resource is MDN.com for JavaScript. As for a tip, always see if the thing you are trying to write has already been implemented in the language API itself or written by someone else as a library / package / plugin etc. More than likely it has been iterated on and optimized. Use that, but also see what it is doing internally and learn from it.
hey thanks for coming to the interview, i figured since being a developer requires problem solving skills, you could bake an apple pie from scratch. i know it's not front-end but you should be able to do the research since you're senior.
wow, if you haven't done the challenge yourself... seems like you REALLY need to read this: http://www.lihaoyi.com/post/HowtoconductagoodProgrammingInterview.html
For a task of this size, make it a "homework" assignment, with no time limit. This will greatly reduce the amount of people who are not really serious. Out of 50 invites to take a homework assignment for our test, maybe 7 to 12 will do it. Then evaluate to see the quality of the code. You will probably end up with maybe 1 or 2 applicants worthwhile to go forward at this point. Do an on-site or video interview and pair with the candidate and ask them to extend and change their assignment to see how much of the work they did they actually understood as well as how they deal with changes in requirements. This has been a very successful formula for hiring great developers for us.
Now try to implement it in an hour. Count how many things suddenly become unclear. 
&gt; only show actual presenting components What would this be? Any component that rendered a DOM element?
Hi /u/lochmore, For javascript help, please visit /r/LearnJavascript. Thank you!
Great idea! Will check that out for sure! 
It's not uncommon to have a rut of bad candidates, and what you are asking for is honestly rather basic. Keep looking, imo.
- What a pathetically written piece of requirement: Vague, ambiguous and full of phrases / situations that require further clarification. - The language clearly demonstrates that this has been written by someone without significant experience. Too many giveaways. - Badly scoped, time allocated is very questionable. &gt;I give them about 1h alone in the room. Please, hire an interviewing agency / professional if you need to, but remove yourself from the panel as soon as possible.
What back end developers fail to realize is that an assignment like this constitutes less than 10% of a front end devs day to day experiences. I've been doing front end for... 7+ years, do you know how often I've coded something for text selection? Once. Generally speaking, front end devs are taking libraries that implement known and desired functionality and stringing them together, tracking down redndering issues (CSS), and hunting down edge case errors caused by loose typing. If this is the type of person you're looking for, put more emphasis on the engineer role and drop the "frontend" descriptor in favor of "full stack", because true engineers will have greater experience with all the technologies whereas front end coders will more traditionally be trained to look for existing solutions since so many problems in the js world already have a solution floating around in the library ecosystem. Also, is this a contract position or full time and are you still looking for devs? Just curious =P
Or maybe you're so dense that you don't understand the breadth of skills necessary to put together an elegant and functional frontend that plays nice with the multitude of APIs and rendering idiosyncrasies of the various browsers and browser versions spread across the web, including mobile browsers, responsive sites, and any number of solutions for reducing file/image size to provide a speedy user experience when limited by bandwidth. For everything you see happening on the front end, there's 8 other things you don't see that had to be taken in to consideration.
Prototypes. Types of things.
Here is why JavaScript uses this syntax: http://tc39wiki.calculist.org/es6/arrow-functions/ See "Rationale."
You have one hour... Sorry, make that 42 minutes. I've been rambling for a while.
Wow! Thanks for sharing this. This is a great post that benefits everybody. If it were me, I probably wouldn't have written a single line of code in an hour. I have terrible anxiety and tech interview stories always leave me feeling like I'll never get a better job. Thank you for sharing your process. It's insanely valuable to me. 
No offense, but your interview sucks. What you want is to collect _signals_, not review whether someone can finish an arbitrary assignment to your satisfaction. Asking the candidate to complete a large assignment puts them in a stressful position, which means you're going to get shitty signal (e.g. they might skip testing or refactoring to make up for a false start or time wasted on a silly syntax error, for example). Streamline. You can't get signal if the candidate is so busy w/ assignments that they don't have time to think calmly and talk to you. Make the assignment simple (15 mins) so you get time to talk about it for the rest of the hour. Communicate. Open-ended discussion is a great way to see how a candidate thinks, whether they can discuss technical topics with depth, what kind of experience they have, etc. Don't waste an hour leaving the candidate alone and doing something else. Hiring is impactful work so make sure you're there where it counts. Be humble. Think about it, 20+ people who have been employed and productive for years, and they all failed miserably? Very good chance that it's the screening process that is bad. Hiring skills are different from programming skills. Learning what signals exist and their spectrums requires experience. Calibrating your expectations to match reality requires experience. Structuring interviews in a way that enables candidates to perform their best requires experience. Be aware of your shortcomings as an interviewer and strive to improve with each new interview.
Yeah, the concurrency issue jumped out at me as well. I was thinking what am I missing here - it‚Äôs a multiple user system, but one where I specifically can‚Äôt have a login and I specifically can‚Äôt rely on a browser being used exclusively by the same person. Sitting here an hour later, I‚Äôm still stumped for how to satisfy that core requirement. 
Coming from other languages, JS can be tough. I remember during my degree a lot of students had trouble understanding what a "lambda" was. JS has them in spades; it's basically built around them. Closures and first class functions make JS *incredible*, as long as you understand what they're all about. Explaining to people why their outer function didn't return the value returned inside their inner function is ... difficult. For me, the thing I struggled with the most was understanding what happened "under the hood". For example, when I create a new solution in Visual Studio - what's actually happening? *HOW* does choosing "Console Application" make the program first open a command prompt? How is this different from a "Forms Application" or a service? Is it just configuration values in the .sln or .proj files? To be honest, I think I still don't _really_ understand lol
oAuth 2.0 and JWT's. I don't think I've spent even remotely so much time on making something work while still not quite understanding it.
Remember, _in an hour, from scratch_.
In addition to what‚Äôs already been said, I think it‚Äôs important to set an expectation as to quality - would you be happy with a hack job that won‚Äôt scale or is not efficient, or do you want a nicely architectured bit of optimised code? At a job interview, people are trying to show their skill, so it‚Äôs important to say, ‚Äúgiven the time limit, a hack one-off bit of code is fine - don‚Äôt worry about finding the best algorithm or optimising - just do whatever pops into your head and afterward we can talk about the pros and cons of other approaches.‚Äù
Just a quick note, don't be afraid to use fully written out variable names. It will make your code more understandable to outsiders, and more maintainable. ( So long as they are descriptive)
I mean, you can at least understand why you're getting down voted right? Honestly I would have literally laughed at you and left. It seems you've taken the criticism well at least. Asking them to whiteboard a solution would be OK, but I prefer to give code tests overnight. It's a better representation of how they will perform in real life. That's unless you like to peer over people's shoulder during the day and constantly tell them how they're doing it wrong. 
I think your test is bad because it doesn't test hardly anything that a frontend developer is supposed to be good at. Even if you find a developer that passes it, you probably haven't food the best frontend developer in your list of applicants. Here is what I see our frontend developers do: - User interface design, discuss requirements with an (internal) customer, show them different iterations of wireframes - Visual design in something like Sketch - Create well-defined components from the design assets - Implement them in HTML, CSS - Combine them into React components (or other framework) - Work with the backend guys to get the API to deliver the necessary data - Design the application's state and state transitions - Connect them all (this step and the previous one sound far easier than they are) - Implement specific logic of some interface parts A few of those steps involve heavy coding, others don't. Your task is mostly in the last step. You don't test for any of the others.
As for projects, once you have a good grasp of the basics I would attempt to build a well-defined application, brick by brick, and learn by doing. My first suggestion would be [TodoMVC](http://todomvc.com/) and then [HNPWA](https://hnpwa.com/). Why? Because the spec is well defined for both, you can start with little and add a lot over time, make them actual mobile apps, and also you can check the dozens of examples of how other people implemented them.
This was my sentiment. If the candidate happens to know this API then they have a huge advantage. I tend to make my FE questions really generic, like "In your favorite framework, how do you wire up a button? Great, you know how to use ng-click, how do you think it works under the hood?" Commence hour long discussion and hopefully hire of a candidate who actually knows how things work.
I just think, at a very basic level, you should be giving a high-level task that allows a developer to finish and shine via ideas and code quality, rather than a really detailed/wordy task for exhausted developers to crawl over the line with. No offense, but the near-ridiculous details about tokens in that question is indicative, to me, of a person that just can't really keep it simple. 
I was skeptical at first, but now I think the last time I used `var` was months ago. `const` in particular is what I use the most, knowing I can't ever overwrite that reference gives some sense of security. Except when trying snippets in the console, using `const` forces me to reload the page when retrying to run a piece of code that uses it :)
I've been using Puppeteer recently - it's really nice to use but still in development so a few things are still missing.
Because normal developers don't have someone judging them as they're writing code. &gt; never ceases to amaze how bad people are. Maybe because your interview method is absolutely horrible.
I'm a novice dev, what's wrong with adding span tags on click?
&gt; but what if someone else was selecting different words? There will be a race condition, given that there is only a single shared state to be kept by design, races are even desirable from a perspective of a test. Imagine posts were open for editing by anybody, last edit wins, simple as that, there is nothing wrong about it. Remember /r/place experiment where users were racing to update single pixel board? If I were in a position of topic starter, I'd give extra scores for candidates asking those questions though :) And if somebody catered for unreliable network and mentioned exponential backoff strategy, it would be insta-hire on the spot :)
It took me 2 hours and 22 minutes to do Task 1. Thanks, OP, for stealing my evening :-)
This has been discussed in detail [here](https://www.reddit.com/r/javascript/comments/75x99b/is_recursion_good_or_bad/)
For sharing code: Github's Gist is quite nice for sharing some quick snippets of code: https://gist.github.com/ Especially for HTML/CSS/JS, Codepen is great because it allows users to actually run the code, and interact with it: https://codepen.io/ 
This was almost literally the coding challenge I did when interviewing with a startup almost 10 years ago, except it was for a technical co-founder role instead of a front-end developer. They actually shipped my code (even though I declined the role), and I got some compliments on it (and eventually a job offer, which I also turned down) from one of their YC batchmates. Anyway, it's not a bad interview question, but an hour is a ridiculous time limit for it. It took me 4 days to deliver working code, including both front-end and back-end. It's a little unclear from your description exactly what you're asking, but if you have to deal with selections crossing multiple DOM nodes (if, for example, they'd hyperlinked or italicized only *part* of a token), the selection API becomes ridiculously difficult to deal with. Add in backend complexity and it becomes a huge time-suck that I wouldn't expect anyone to manage in an hour, unless you're just looking for a high-level overview of how you *might* solve the problem.
Hello! A little background on me, I was the VP of Software for a startup that grew from 3 engineers to over 200 during my time there. I have some suggestions: 1. Make this a take home test and give them a week. This is not something that can or should be done in an hour. 2. Clarify the instructions. I had to read task 1 three times to understand what you're asking for and I'm still not sure I know what you're looking for. Visual examples would help. 3. Either change the job description to Full-stack or remove all back-end portions of this project. 4. Consider distributing this project with a pre-built backend or boilerplate. Since this appears to be your first time doing this I would also suggest you look for a mentor who has done this before. Hiring is not easy and I know I couldn't have hired 100+ engineers had I not had people to teach me how to do it
/u/Dr3dbeard I'd like to double down on this comment because it really is a lot more important than you might think. there's really no need to save characters with today's autocompletions and huge memories, and in the few cases it really is necessary, there's minifiers (don't worry about that now), but it helps a lot to understand code when variable names are expressive and tell exactly what they are all about. And not just variable names, also html class names and ids. Just write it all out, be descriptive. Always think about what somebody else would or wouldn't understand at a moment's glance, not just yourself. Looking at the code, I can ofc say what it basically does (very simple input validation), but I have no idea of it's greater purpose or what the individual inputs are supposed to be. more descriptive names would have told the story, acronyms don't. It might not be as important for your course right now, as most of your code right now is of the "fire and forget" type I suppose, but it's a good practise to start early anyway. later on when you are actually have to work in the field, you will oftentimes have to revisit old code you wrote, and when a few months have passed since you last saw it, it might as well have been written by someone else, you won't remember "mtnnm" was supposed to mean, and the less time you have to spend to figure out what you did back then, the better. don't be afraid to call the input box's id "inputPersonName" or something like that, for example. In the same vein, at some point you will try to be clever with your code and save lines somehow by combining stuff in one line in creative ways, and it will feel really great. don't, because it'll feel a lot less clever if you go back a few months later and have to figure out what that creative line was supposed to do. it's a lot more important to keep your code readable and instantly understandable than to save a line or two.
as for your actual issue: &gt; once the alert box is cleared if I understand you right, you want to react to the alert box being closed. well, basically, everything you put after the alert() call is happening after it is closed, as alert pauses the script until you click it away. Put everything you want to happen as the box opens up before alert(), and everything you want to happen after it closes after alert(), and you should be good.
Do you have an experienced front end dev friend or former colleague who could write a new challenge for you or potentially even consult in the hiring process? It sounds like you could really use a good hire, and I think that path might save you the most time / resources.
This would be a great feature for your IDE. Having to trace through imports takes quite a lot of time. Nice work!
the samples are only showing generated type definitions. Is the " query builder, resolvers, ORM code," part in roadmap or are there just no samples?
You have a vernacular and way of speaking that's sort of hard to parse, just by going through some of your explanations... I don't know if you made your post in a hurry but I'd most likely be confused. Also... why is there a need for Node.js here?
I would just lookup a videos on [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)) object oriented design. If you can master these concepts and put them into practice then you already understand the fundamentals.
your indentation is so weird...
I've hired many good developers without having to put them through a gauntlet such as this. These questions only tells me you are a poor spec writer. And all those who didn't get hired are the lucky ones.
Thanks! I remember trying it before but not getting this to work, but I just checked again and had better luck this time :) Thanks again!
:p Was so tempted to do that myself! I actually google recursion to see if was spelling it correctly and got pranked my google :-(!
lmfao
&gt; I believe there is a problem solving component involved here that should concerns a front-end developer lead. How do you decide what needs to be done on server and what needs to be done on client? Na man. This is a question you can ask the applicant outright without them having to wire up the solution themselves. Said another way: do you think it's possible that a senior FE developer can answer this question with flying colors, but also not be totally experienced actually crafting the backend solution theirselves? Because I can tell you I'm responsible for making this call FOR some of our projects for our back end guys, and I can't do the backend. So take from that what you will.
This one actually solves the problem in my webpack.config, I actually had to do a few hacks because of this damn thing. I wish webpack would just ignore undefined plugins in the first place instead of throwing errors which are impossible to understand.
There's nothing specifically wrong with being narrow skilled. Moreover, front end itself isn't a narrow skill in of itself. Is knowing Javascript (and a couple of js frameworks like React, Vue, Redux, Angular) CSS (and methodologies and libraries like BEM, ITCSS, Bootstrap), and HTML (SEO ramifications, semantics), Accessibility... is being knowledgeable in all of these things considered narrow-skilled? This is a very simple concept. We benefit as a society when people specialize. You don't hire someone who can do accounting that also knows a bit of web development, and you certainly don't call someone who JUST does accounting narrow-skilled. Within a given skill are thousands of minor skills. It's absolutely pointless to look down on someone for the skills they don't have. I don't ever mess with backend because the idea is, I work with people on my team who I trust to handle that portion for me, the same way a school relies on their janitors to make sure their school is clean and sanitary. If I absolutely need to learn the backend, sure I'll learn it. But I work hard every week learning something new about the front end, because that's my domain, and I don't feel the need to learn how to throw together some basic http backend end together just so I have the ability to say that I'm well rounded. It's simple. If you want backend and front end skills, you say it from the jump. You can ultimately do whatever you want but that throws up red flags from me... it says you're the type of employer that expects someone to do everything. It says that you might want me to hop into Photoshop to create some graphic. "What, you don't have basic design knowledge? Are you that narrow-skilled"? "What, you don't have basic SQL knowledge? Are you that narrow-skilled?" "What, you don't have basic Project Manager knowledge? Are you that narrow-skilled"? We can do this all day and I can find the tangentially related field you don't have basic knowledge in and skewer you based on that.
That is not a front-end test. This is a full-stack test. Either be more realistic as to what you are looking for and specify that in your job spec or if you really do want a front-end developer them simplify the test to only involve the view layer.
Allowing race conditions is probably there to simplify test and not to shift focus on a backend work even further. Saying that, multiple user agents updating same state on the server, there is a time and place for them too. 
Absolutely without question. Even if I passed, I'd just be proud of myself but I'd feel disgusted with what was asked of me. Interviewers forget sometimes... the WAY you interview, is being interviewed. I've seen a lot of great candidates turn down job offers because the interview process was off putting.
Okay cool, I learned something :)
Why is there an assumption that a senior FE dev knows Node at all? I just don't get this assumption. Senor FE dev's have a LOT to concentrate on. Onboarding new developers, doing code reviews, making architectural decisions, being the main force behind creating new features. I don't get why this necessarily means they should be able to throw together some backend stuff. Also... a bunch of backend people chimed in and they've even said that asking for 1 hour is cutting it a bit close.
I do but I probably wouldn't pass any interview questions which specifically have me do any in-depth OO in terms of "ok create 3 constructors, create 3 instances, do different logic". I'm more concerned about the implementation than the philosophy at this point, but I'd like to learn from someone who uses the implementation to solve actual problems, hence this course. By the way the course costs nothing for me, I have an account already. And money isn't an object. I'd just like a good resource to learn from.
Here's how I think about it: practically, named functions are hosted, nothing else is. This rule, especially when using const/let, makes it a no brainer.
I understand the concept and can use them, but my problem is error handling promises / async / await (error handling in general really. How is it handled / how is it supposed to be structured in production?) ... Mainly the specific syntax is what trips me; so many times I'll look up how to handle a promise, or an AJAX request or whatever, and that specific solutions syntax is deprecated or somehow just won't work... Especially with anything jQuery! Same things starting to happen with React. Stuff that was the standard 2-3 years ago and appears in most tutorials throws up depreciation warnings. JS is tough when you only have to learn current syntax of it and any library, let alone trying to filter through the evolution of them.
I didn't fully understand promises until I went to the Promise/A+ spec and implemented my own very simple promise. Then you realize a promise is just an immediately returned object on which a calling function can register successful/failure callback methods. The callee can continue execution and because it still has a reference to the returned promise, it can simply say that the promise is fulfilled or rejected and pass values. I hope that makes some sense. [Here](https://gist.github.com/RobbyDmz/2cb71939ad657b6cf2ed144d65c5e66a) is the most simple implementation I wrote. Because the setTimeout in AsyncFunction will schedule something at a later time, the _promise is returned before the function has completely executed. Later on when resolve is executed it can signal success or failure and the promise calls the registered callbacks. All that's really missing in this example is an example call to the AsyncFunction. Something like AsyncFuction(5).then(successCallback, failedCallback).
Thanks for the feedback. Valid points and questions. It's been noted down. I considered #4 a complete failure because he was injecting html tags inside the text. The altered text was sent back and forth between the server and the client. In my opinion, this approach pushes all the problem downstream with increased difficulty. His client code has to bang on to not introduce errors for the backend engineer to do be able to cope with the text.
I had the same issue using React 16, but as soon as I performed the first state update, it attached just fine.
I like JWT's and use them instead of normal session tokens because they can securely hold some values. But Oauth2 is indeed a mess, the complexity (which inevitably leads to security issues) is one of the reasons the [lead author at the time left the working group.](https://hueniverse.com/oauth-2-0-and-the-road-to-hell-8eec45921529)
I have done the test myself. Who said tinkering around the selection API is the only way to do it ? That's definitely one way to do it. Feels the obvious way but not the only way.
Some people just get coding on a deeper level than I do.
Good article. Thanks for sharing!
This is awesome! Nice work. Any idea on how difficult it would be to port this for use with React Native using [React Native remote debugger](https://github.com/jhen0409/react-native-debugger) ?
Likewise. 7+ years doing JS / Node development and if I walked into this interview and got asked to complete this in an hour, the interview would have ended right there. 
Yes, the language was written by a developer. Can you give some examples of poor suggestions and loose enforcements ? I'd benefit from seeing these from your shoes. As mentioned, there are opportunities to ask loads of questions and further the specifications. There are some loose constraints because I don't want to take away from them the opportunity to rig/hack the solution. Like in life, everything should be fair game!
Real devs don't need a minifier, they just code like that.
This is a contract role for a lead front-end engineer that will drive the client framework. He will have to work with the backend team to split problems into backend - frontend so they solve the problems efficiently. I came to pretty much the same realisation. The engineering creativity and problem-solving on the front-end engineering is missing because the everyday job involves dealing with problems mentioned by you. Based on this post's feedback I'll tailor a new test. I might post the outcome on a new thread once I get some feedback from the field. 
I'd like to thank you for your thoughtful and elaborate response, even though I don't agree with most it :) I am not denying specialization is a good thing, "narrow-skilled" comment was very closely related to expected seniority. What I am saying that I never seen and can't imagine situation where truly Senior Engineer (not those fake titles from hip startups) was never exposed to a related tech and got at least some experience with it. Yes, I'd expect Senior Accountant (and future head of accounting department) be able to comfortably discuss basics (remember, we are talking about &lt;50 lines of backend nodejs code here) of Tax implications, Legal matters and Investment schemes. Ability to do so does not necessary come from the fact that it is a day job, it comes because during his career, he was part of some bigger project where multiple experts were pulled into a working group, or he had to review and provide second opinion on some third-party financial advisers recommendations, or he happen to be court expert ,etc. Do you see what I meant? If one has been around long enough , didn't hide in a corner screaming "go away, it is not my job", wider skills are gained inevitably. I believe you can't get senior without at least occasionally get your hands dirty and do work are not supposed to do on paper. If one managed to spend 5-7-10+ years in industry and stayed 100% of the time in the same domain, never jumping into adjacent ones either out of natural curiosity or necessity, then it is also a red flag. This kind of person is "throw over the fence" kind of person, these are hard to work and cooperate with. Lack of depth also affects decisions person makes. Being familiar with wide range of tools, approaches,patterns and paradigms to make more informed decision is a requirement for a Senior. &gt; What, you don't have basic Project Manager knowledge? 100%, why? I am pretty sure you cant be called senior if you can't organize team and work around you, do some timeline estimation and so on. Do I have different definition of "senior" from yours? Looks like you know your ways around frontend. What would you do if you started a new pet project? Where would you be making XMLHttpRequest (or whatever is current way of doing it) calls to? Mock all of them? You really say that you never had to code some basic nodejs server to prototype your ideas? If you say so, may I ask you to give more details how you do it otherwise? Do you have word "nodejs" on your CV at all? If yes, it is a fair assumption that you'd be asked to demonstrate some of it, right? 
I guess you could take the text, regex split it up, making sure to preserve the whitespace, and add a "marker" span before and after each of the words. This would at least help you when you click with the mouse, and get the offset, to work out the "word" you are inside (if you are in one). Surely though you would want to support cursors too and WCAG guidelines, so should allow some sort of visual feedback, and cursor placement. 
Can anyone offer a rough breakdown as to whats going on here? I'm properly mindblown
Very valuable feedback. Points taken. This is why I brought this here so I can learn and improve. This is the first time I'm hiring a FE. After we agree to stop the test, I do spend with them about 1h+ going through their code in a pair programming fashion. My goal is to understand how they've been thinking, where they hit the wall and how they plan to fix the issue. I do track their thinking process and how easy they may come up with two-three options for a particular problem. The upsetting thing for me is when I get back answers like: "Can I google? Someone must have built a library for this."/ "I don't know. I never had to do this.", "I cannot think right now. This takes days" (this was related to splitting by a comma in addition to splitting a text by space). So it's not the "not knowing" a solution that bugs me but the refusal to think on the spot on their own. 
Good points. All noted. Thanks for the feedback!
argh, famous leftpad case :)
Someone made a PR once in the devtools repo: https://github.com/facebook/react-devtools/pull/503 It was closed down due to philosophical doubts, but the reality is, my tree looks like this, all the time, in any app: https://i.imgur.com/ZyERNjH.png That makes the tool very hard to use. In 99% of all cases i don't care about HOC's, but only about components that output to the dom.
 let bar = await foo() if(bar +1 === 2) Please keep to doing it this way...
Do you think this can be done in an hour or have you actually done it in an hour? Well, you're already familiar with the requirements so you should be able to do it in half an hour. Good luck with that. 
Fantastic ideas. I feel you are right. I can see how the spirit of the interview felt to me like what you described but the candidates failed to relax and cringed around the tasks. I failed indeed at communicating clearly with the candidates the spirit of the interview. Got it. Thanks for sharing this here. Points well noted.
Good point about breaking the problem down into small progressive tasks with some seed project where can start coding. Duly noted! Thanks for the feedback.
[README](https://github.com/veu/mini-tetris#some-tricks-used) contains some info on tricks used.
Every program has an entry point called the main() method, thats where it all starts. In one template that main() method has some code that starts up a console window, the other a forms application. 
&gt; A few of those steps involve heavy coding, others don't. &gt; Your task is mostly in the last step. You don't test for any of the others. While valid, that other steps are essentials, how do you think, a candidate, who can't do something like "string".split(/[, .]/) on the spot, would perform in all those non coding steps? Can you trust decisions he'll be making? In other words, is it unreasonable to expect him showing some basics, before moving on to more ephemeral subjects?
Great and valid point about the quality of code. Thanks for pointing this out. Noted and I'll address this in the new assignment description. The candidates shared with me before the interview their github profiles or a sample project that is supposed to "demonstrates mastery" in any aspect related to their role (good unit testing, simplicity, code structuring, good component design, algorithms, state management, logging, anything is fair game). This project was one of the factors that got them invited to the interview. In the interview I'd love to see hacked solutions, rigged tasks, specifications or anything "unorthodox". I hoped that Task 1 read to them "use anything you know to highlight in a visibly distinctive way a word/token on the screen the user designates with the mouse". 
People linked me this SO answer for closures: https://stackoverflow.com/questions/111102/how-do-javascript-closures-work/111111#111111 But what really clicked (for me) was this: https://stackoverflow.com/questions/220658/what-is-the-difference-between-a-closure-and-a-lambda/36878651#36878651 Hope this helps you out.
Hat tip for giving it a shot. Sorry for this stolen time. How many lines are in the backend ? In the client side, did you do it via the selection API ?
Thanks for the advice. Points duly noted!
Hi, English is not my main language, and not sure if I understood the task correctly. Is what you want is that the user could select a word from a "random" text, filter out space, comma, dot, etc, highlight it, add a tag or something to it, then save it to a server for later to be able to reload? Task 2 is the same, but multiple of these, and in Task 3, add Baky as tag to words that start with a vowel, and Kola to everything else?
probably first think to learn is to grow some skin and stop worrying what random people think of you :)
Very valuable insights and feedback. Points duly noted. Thanks for giving an example and rewriting a fragment where my English fails to make a clear point. I got it. I'm indeed a non native English speaker therefore the sentences I wrote may be off-beat and failing to bring the clarity needed. Thanks!
Good points. Thanks for sharing!
It's a lot clearer here: https://github.com/veu/mini-tetris/blob/master/src/tetris.js
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [veu/mini-tetris/.../**tetris.js** (master ‚Üí 1bb3b57)](https://github.com/veu/mini-tetris/blob/1bb3b57efaccc8a1a71c0974202d57f5a05e978b/src/tetris.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
Forget WCAG guidelines and cursors because they are not part of the spec. That would do great. How many lines of code would this take? Are you a full stack ? 
&gt; If one managed to spend 5-7-10+ years in industry and stayed 100% of the time in the same domain, never jumping into adjacent ones either out of natural curiosity or necessity, then it is also a red flag. Conversely: if you hire a senior front end developer, and they have backend experience, design experience, PM experience, sys admin experience, app development experience, then it's also a red flag. They're a generalist, not a specialist. They've never buckled down and focused on one area and can't possibly be expected to have mastered that area. What you're not understanding is that it's easy to spoof what you're asking for. It'll take me 2 weeks to gain general knowledge in any category. If you gave me two weeks, I could buckle down and learn enough Node to be dangerous. 2 more weeks and I can be zipping around making SQL queries. 2 more weeks and I can make some simple iOS apps. This barometer that you're basing seniority on can be spoofed in a matter of weeks. That's an extremely weak barometer. The issue is that you think these 2 weeks (or just being incrementally exposed over the course of years, which I'm asserting you can't assess with 100% certainty) are a lack of disinterest, or not solving big enough problems to lack the necessity, and both are just untrue. Let me paint this for you in a different way. I'm very confident that in very little time, I could overcome the hypothetical hurdles you're presenting. The problem, is I believe those hurdles aren't indicative of anything, and in fact are red flags themselves. I'd rather spend 2 weeks concerning myself with a limitless amount of concerns I have on the front end, rather than passing some litmus test which could be indicative of an employer with the wrong frame of mind, or an employer that has less resources to hire specialists that truly will solve their problems effectively in that area. Now. If my company wants me to learn Node.js (or I interview with a prospective company that expects me to have a baseline of knowledge from the getgo, includes it in the application), then ok. Plenty of times companies do this. A company recently listed Clojurescript on their application. I thought it was interesting, I bought a book, and spent some days going through youtube videos and going through the book. At the end of the day I get where you're coming from but I just have to disagree. I don't think being able to whip up a CRUD is indicative of anything and doesn't necessarily give a FE engineer more insight just because they can make one. Moreover as to your pet project comment, it's very easy to make mock ajax calls, and things like redux essentially are an abstraction over the details from a database, you just hydrate it with ajax calls. I can either put data in the reducer directly, or have mock calls, and unless you looked at the network tab you literally wouldn't be able to tell the difference as I can simulate the amount of time it takes for the mock call to return.
If you aren't compressing the files, zipping should be fast
It's a good idea. I'll dig into it. I guess the dude I've consulted is an on par idiot with me because he gave me the green light and said it should be doable. 
Yes. Exactly that.
&gt; error handling in general really. How is it handled / how is it supposed to be structured in production? Handling errors using promises themselves is done via `Promise.prototype.catch()`: giveMeMyMoney() .then(money =&gt; { makeItRain(money); }) .catch(error =&gt; { console.log('That cheap bastard!', error); }); Handling them using `async`/`await` syntax is done with standard `try`/`catch`: // somewhere inside an async function... try { const money = await giveMeMyMoney(); makeItRain(money); } catch (error) { console.log('That cheap bastard!', error); } &gt; Mainly the specific syntax is what trips me; so many times I'll look up how to handle a promise, or an AJAX request or whatever, and that specific solutions syntax is deprecated or somehow just won't work... Especially with anything jQuery! It's definitely an area of the language/ecosystem that has been in constant flux for many years as the community tried to work out better ways to write asynchronous code. Luckily, we've converged on something pretty decent, and it's all relatively stable now.
Thanks for the link! Certainly easier to read but damn... that's some pretty awesome code and I still can't get my head round it entirely!
Well then I think that really is a trivial task. Maybe not for an hour, but 2-3 hours should get it done. Maybe also not strictly a front-end task, but really, with Angular or React or somesuch, you will probably need to have some experience with communicating with backend services. The backend part then is pretty much a textbook example and can be easily found with Google. I'd say for 600GBP a day, this is really not a hard interview. (I'm currently working in AngularJS, on a relatively large project, that's the insight I have)
When you say blob of text do you mean as in var blobOfText = new Blob() or just a chunk of text like in a string? Also by 'label' do you mean 'annotation'? "Tag" = annotation too? Also should the annotations pop up or otherwise display about the token? As a front end developer do we need to worry about multiple users trying to change the same annotation at the same time? (one guy selecting and one guy deselecting) Aside from those three or four things, I think 1 hour is certainly enough time to read this and begin to contemplate a solution. 
So when I was learning programming, it was stressed to make variable and function names clear. Variable names should clearly show what they contain, and function names should clearly show what they do. So is this guy wrong to code like this? If you were hiring, would you hire someone who had single letter variables and functions? If he's not wrong, then was I taught wrong?
You should be fine with Vue.js. However, these are some funny constraints? Not very common to not be able to use nodejs in development...
But what happens when you try to revoke JWTs? All the different explanations I've seen for that basically seem to boil down to "use JWTs and sessions in tandem", at which point what's the benefit of a JWT? I've seen them be somewhat useful in applications with a lot of microservices, because they mean that each layer of the microservice doesn't need to constantly check a single central source of truth all the time, but the tradeoff always seems to be that it becomes increasingly difficult to handle changing a user's permissions or revoking their access, and I've yet to be convinced that the efficiency is always that necessary.
TL DR Array.prototype.includes() can be used instead of indexOf(). Exponential operator (**) can be used like Math.pow().
How to shoot yourself in the foot. Multiple times.
This is all just my opinion, but it's not that either of you is wrong, it's that you're doing different things. Most of the time when you're writing code you want to write it in the most clear, expressive way possible. So that means have longer, descriptive variable names, include comments, and use advanced language features (like es6 maybe) to make your code easier to understand and prettier. Then, frequently, you use automated tools to shrink down the code into something minified and obfuscated. For js those tools are things like webpack and Babel. This guy was trying to write the smallest program by hand, to show what is possible and learn about the language. So what he created isn't really good code so much as a good end result. You would never actually write code like that, but you can learn a lot from looking at it that can maybe help simplify your own code. I've never hired anybody, but I wouldn't want to work with someone who coded like that all the time. On the other hand, sometimes you can try this sort of thing and really push what's possible.
This is all just my opinion, but it's not that either of you is wrong, it's that you're doing different things. Most of the time when you're writing code you want to write it in the most clear, expressive way possible. So that means have longer, descriptive variable names, include comments, and use advanced language features (like es6 maybe) to make your code easier to understand and prettier. Then, frequently, you use automated tools to shrink down the code into something minified and obfuscated. For js those tools are things like webpack and Babel. This guy was trying to write the smallest program by hand, to show what is possible and learn about the language. So what he created isn't really good code so much as a good end result. You would never actually write code like that, but you can learn a lot from looking at it that can maybe help simplify your own code. I've never hired anybody, but if all of their code was like that then I wouldn't want to work with them. But as a one of project he made something really cool.
My beginner-focused book https://github.com/bpesquet/thejsway lets you create a social news app using JavaScript and Node: https://thejsway-publink.herokuapp.com. Another great resource for small projects is https://github.com/wesbos/JavaScript30. Happy learning!
You're absolutely right. Revoking JWT's still means checking it against a blacklist. But the difference is that the auth layer can do only that. If it's valid and not revoked it still holds useful information (username, auth roles, anything you like, ..) that does not have to be derived from the database on every call.
This is not how this guy codes all the time. Look up code golf üèåÔ∏è 
But you need to make a database call of some description, probably to the same database, unless you cache the blacklist in a closer, faster database layer, in which case you've got to worry about keeping the new blacklist up-to-date.
nice !
Good that you're taking feedback. I consider myself pretty ok as a js dev and frontend (html/css) dev but if you'd drop this assignment on me at an interview I would probably perform horribly. Mainly because of how vague and confusing the task is. My current employer has a pretty good test, you get 3 hours and it consists of two parts. First part is coding up a simple layout from design, there are some tricky things like how to handle css sprites, responsive behaviour, some tricky positioning of some menu element... but all pretty standard and solvable. Second part consists of a time tracking app, basically a form and a table below it, the html and css is already done. The task is to create the basic CRUD behaviour of the app. They've had success doing this test for years. 95% of devs still wash out though but it's a proven concept since it's still doable and showcases the skills a frontend dev needs.
The point of code golf is to minimize the amount of characters used.
Don't let the unreadable code fool you. This program evolved from a mostly readable version with often simple steps. I also couldn't have done it myself. Some of the best improvements came from others. Definitely check out the commit history. That should make it clearer. https://github.com/veu/mini-tetris/commits/master
Yes, that's what I'm saying. But you're at least free of the worry to query for all the other info you might need on every call. Just a quick check against the blacklist.
he is probably tasked with writing that kind of function himself though.
Boom! Tetris for Jeff. 
I can think of a few reasons. Many popular tools used in front-end development are built on Node. NPM is the most popular package manager for front-end projects. Node is commonly used to set up dummy APIs in POC apps. You don't have to work or think very hard to set up a simple API with Express. The application would only need two endpoints to complete the OP's assignment. Nothing is mentioned about persistence through server restarts, so a simple in-memory collection of tokens would suffice. If you're familiar with HTTP from one end of the stack, it should be fairly simple to implement a basic solution on the other. You're right that a purely front-end developer shouldn't concentrate on their NodeJS skills, but I think you are severely gimping yourself in today's world if you don't learn the basics.
I think this is pretty amazing and I do not want to diminish this feat but I wish that there would be a counter-trend to this where people celebrate code that is so perfectly laid out and commented that it looks like too simple to actually do anything. Not really sure how to better express this idea. Somehow I want to call stuff like this the ‚ÄúThanks Cpt. Obvious Challenge‚Äù. Every time I see code like this I search for a write-up of the actual thought process and it amazes me that much more seeing all the parts neatly separated from each other.
Ah, makes sense. That is a strange solution. :P
If you‚Äôre doing OO with a language that isn‚Äôt strictly designed for it, I wouldn‚Äôt worry too much about glossing over the prototype stuff by using classes. You‚Äôll understand that stuff in time, and also classes, while they have overhead, once instantiated are just function objects (technically they‚Äôre always functions). So if you know how ‚Äòfunction‚Äô works, you‚Äôll be able to figure out ‚Äòclass‚Äô.
How about this. Build this with someone watching and judging you and time yourself. Then post it on Github and come back to this comment to let us know how it went. 
I mean, there's not many database engines where selecting more fields from a database is a major cost when optimising the query, right? Usually most of the time spent making the query will be in network calls and in scanning the table. I agree that there's a benefit to having a stateless backend, but usually by the time you've hit the backend, the security provisions of jwt become unnecessary, because everything back there is only accessible from your systems.
people have already chipped in to tell you about the task you have given them, so I'm gonna skip them and just talk about the environment of your test: an interview is a high stress situation for the applicant. yes, even for experienced seniors. keep in mind that not only are you looking for a good developer, the developer is also looking for a good job, one they will spend a large part of their week in for hopefully a long time - they are judging you as much as you judge them in this interview, so it's in your interest to make it a somewhat comfortable, relaxed experience, because it's gonna be stressful enough anyway. one hour is to short. not just for this task, but in general. even if you think they should absolutely be able to solve it in that time: give them time, not a time limit. let them sit for a few hours if they feel they need to. maybe let them estimate how long it might take beforehand. pressuring them to finish within 1 hour when they are likely already nervous about the interview anyway is a way to set them up for failure and doesn't really say anything about how they will really perform in stress situations later because it's a hardly comparable situation. keep in mind that giving them more time doesn't mean they will take more time. but they will be more relaxed about the time they have to finish the task. Give them space. don't put them in an enclosed meeting room, let them sit with your existing coders and tell the applicants to ask them if they have any issues - it might be more comfortable to ask a potential colleague rather than a potential boss. maybe tell whoever sits next to the applicant to casually fling a short question at them somewhere in between (not some interview-style question, but something natural - "...hey, do you know what that css attribute was called that does XY? I always forget..") and note how he reacts to it. if they have a few hours, they can work more calmly. if they are really good, they might finish within an hour anyway. if they are taking really long, you can then discuss why. And you can see how much/often they interacted with other developers - keep in mind that this interaction can be a good thing and not just a sign of the applicant not knowing what they are doing, depending on what they are asking. and you might also be also see if they fit in with the existing team personality-wise. 
Spam - links to a dodgy site that uses Udemi logo's without being affiliated. Course it's not free and the link is dead anyway
Pretty sorry that people downvote you for actually asking something valid. Somewhere on the Internet is a quote that goes something like this: ‚ÄúWrite your code like the next guy that has to fix something in it has homicidal tendencies and knows where you live.‚Äù If you now feel your way into this mans head and look at the code I think you can answer the question your self. :)
Yes it‚Äôs fine, I usually put a function or expression at the end of a function, and that‚Äôll be the main operation of the function and often correspond to the function name, so it doesn‚Äôt matter that it isn‚Äôt declared using a variable. In the code preceding the return statement I will use a functional/SSA style, progressively assigning values to variables: const isPalinedrome = ({ array }) =&gt; { const chars = array.split(‚Äò‚Äô) const reversed = [...chars].reverse() return compareElements({ val: chars, other: reversed }) // returns true if array elements match }
Why not just return ````chars === reversed```` ???
I'm using the [Airbnb Eslint preset](https://github.com/airbnb/javascript) and I have `var` blocked by default. Also explicit returns when an implicit can be used. It really makes your code much cleaner.
I realise I haven‚Äôt given very constructive feedback. If I were in your shoes, I‚Äôd make this take home, and I‚Äôd break each sub task into standalone tasks. I‚Äôd give them a repo with stubs at each step, and I‚Äôd assign weights to each. This way a developer might get stuck or not know how to solve one step in the complete solution, but still be able to demonstrate competence. This interview could have been a dozen separate steps, from finding subsets, filtering, finding selections and manipulation them, etc. Just because a candidate fails at 1 of the 12 doesn‚Äôt mean they‚Äôre not worthy ‚Äî it just means they struggled at one niche. That‚Äôs not a big deal in a team and in an actual working environment. Food for thought I Guess.
Because that wouldn‚Äôt work. [1] === [1] // false
&gt; 20 interviews later I cannot believe everyone failed so badly I couldn't scrape one. This is common. Most front-end devs suck. There are also many people, for whatever reason, view front-end skills as beginner or an entry point to technology. I interviewed with my current employer as part of a hiring blitz this summer. Out of 73 interviews they picked 9 candidates.
So yeah, I'd spend that hour setting up stuff and fixing the 95 weird errors I'd get from setting up Node+Angular. I think that goes for anyone.. Provide a minimal repository yourself with the weird, time consuming stuff already set up. After all, that's not what you're looking for anyway in terms of problem solving. 
I think you should really be looking into just using the default fetch API at this point. We've transitioned completely to it with the help of [GitHub's polyfill](https://github.com/github/fetch), and it's been a pleasure to work with.
Interviewing is hard; it takes a long time to get a good process going (as somebody that has interviewed at large tech companies before for FE roles and also as somebody that has interviewed/hired others). Keep us posted on what happens
I would probably just write my own minimal framework. The biggest challenge here is absolutely the AAA accessibility. You need to put all your energy into writing and updating fantastic HTML and CSS. The rest of those requirements are completely trivial. Don't over think this.
We use knockout under similar constraints and it works well, although vue is more popular and would have better community support, these constraints were set while vue was still young, hence, ko was chosen.
I think you're just arguing for the sake of it by now. Most frontends tend to make a lot of requests, if you have to go to the database to get a user's name/id, roles, other configurations, .. on every request vs only doing a simple blacklist check of a JWT token, you're putting unnecessary strain on the part of an application that scales the worst. That is the database. No matter how we optimize our query, we're still created load on the database and the network which we could easily avoid. This is especially so in microservice architectures where we can simply pass that JWT along (i.e. in a http header) in a secure manner.
Oh. I see.
Well just use node locally, bundle, commit bubdled code That is assuming that ‚Äúno nodejs‚Äù constraint is on the server Anyway this constraint is indeed odd, can you explain what‚Äôs the reason for it?
"can I review your code?" "yes of course!"
First I'd ask why those harsh restrictions, cause I can't imagine one where Transpilation and the likes is completely impossible.
Awesome work, the bit shifts are a brilliant trick.
I dont know why you are catching downvotes. The reactions in this thread are almost enough to make a person hire BE devs to do FE work. (I guess thats what fullstack comes down to) The most common complaint here is that they only know how to do cookie cutter tasks, and cannot be asked to use the DOM.
Ive abandoned projects entirely because of oauth2 especially if im doing like a C backend
One main difference is that it allows you to return a value (a Promise object with a consistent shape) from a function rather than having you supply a callback as one of the parameters (which may vary from function to function.) This allows you to do nice things like flatten and simplify a callback pyramid: result = a(w).then(x =&gt; { return b(x) }).then(y =&gt; { return c(y) }).then(z =&gt; { return d(z) }) (which could actually be shortened to) result = a(w).then(b).then(c).then(d) Await the results of a bunch of async operations: finalResults = Promise.all([a(), b(), c(), ...]) In general, you can write functions like `y = f(x)` rather than `f(x, callback)` 
Didn't know Theon Grayjoy was a programmer, this is pretty cool. 
You're able to read the first commit? https://github.com/veu/mini-tetris/commit/e47b080a394e98ff22cd996d19709f6141a8f40d This is absolute gibberish to me. I'm impressed.
Only the newest version is [ECMAScript 2017](http://www.ecma-international.org/publications/standards/Ecma-262.htm)
I'll bite on the first question as it's rather trivial. However, you really need to explain the second question better.
I feel like I've gained a super power
&gt; That is assuming that ‚Äúno nodejs‚Äù constraint is on the server That is *precisely* the constraint, as is very **clearly** mentioned above, without any ambiguity whatsoever.
Ok, then who says you cannot rely on nodejs locally?
This is a cool talk explaining and demonstrating these kinds of things: https://www.youtube.com/watch?v=RTxtiLp1C8Y
This is a cool talk explaining and demonstrating these kinds of things: https://www.youtube.com/watch?v=RTxtiLp1C8Y
Good idea. But seems to not work? Just don't appears.
That was very well stated ... thank you.
If repo has a private package.json file then it won't display stats. Which repo(s) it hasn't appeared for you?
1. Haven't edited the original post, it remains as is. Did edit the comment, but without changing the implication. 2. All orgs have some restrictions or the other on what you can use locally, and what you can commit and so on: Some are rather draconian in that they'll dictate even the IDE to be used, others not as much, but will have reasonable constraints imposed (Framework / Libraries / ORMs etc.). This is one of those situations where it sure sounds off, but it is what it is. No Node.
The project I'm working on has multiple React roots on each page and the page is assembled with the sub-apps that it needs. Your extension doesn't seem to support the multiple roots. It looks nice based on what I can see but unfortunately I can't really browse everything I'd like.
well, then, use the UMD build of React (or of any other UI library for that matter), use [bem naming methodology](https://en.bem.info/) for css classnames, use es5. And... may be good luck switching a job soon to the one where there are no such unjustified restrictions.
&gt; but I think you are severely gimping yourself in today's world if you don't learn the basics. That's fair. It'll be on the list to learn eventually. Ultimately I'll learn it mostly for interviews though. It wouldn't immediately benefit me in my job. That's essentially what I'm trying to get across.
It doesn't work for me (no React import detected), but I think you'd better add this feature to the existing React Dev Tools, it would be quite easy because you already have all the data, and would make happy quite a lot of people.
No way, almost 2x the average pay (base) for my experience bracket, plus generous RSU's, free food and great perks, and incredible work-life balance (most folks work less than 6 hours a day). I'd wash dishes and support IE6 if management asked me to. Money matters a lot more than being able to choose a particular development workflow, so I'm keeping this job.
Burn the witch!
"I think I need more coffee"
pretty happy with axios, but i guess it's worth checking out!
Writing good tests. @mpj once mentioned in his videos that he had a small function, 100 lines or so, and it had over 200 tests. Beyond the bare basics like testing for the correct parameters and the correct out put, I'm not really sure how you get over 200 tests for that. Most testing tutorials I've seen online have only very obvious examples. The ones at work are mostly server side testing that the sql queries are returning properly and that the data is formatted properly before headed off to the rest APIs responses. We've switched to Typescript on the front end and there really isn't much to test.
No it wasn't. But yea, now appeared. Probably very strong caches :D
Thanks for this extension! :) Btw seems to not work for monorepos :) Probably good feature :)
Fair enough. At first I thought so as well, but it seemed ambiguous the way the request was stated, so I figured I'd mention it.
Thanks for the suggestion :) I've added it to the to-do list.
any thing with "bind", "call" etc..
What you are asking people to do, as a test, is extremely uncommon. I've been doing web dev for anout 10 years and I have never once needed to preserve a selection in browser. Indeed, I've only once or twice needed to operate on selections, and even then, it wasn't on in-page text, but on a textarea. Combine with the fact that, last time I checked, text selection was incredibly broken and inconsistent across browsers. The common advice was to merely avoid that type of problem entirely. I think the only reasonable set of people who would actually know this stuff are those who worked on WYSIWYG editors, of which there are very few. Certainly, this problem could be solved by a good front end guy, but it would take more than a day just to work through the mysteries of browser selection systems.