Sounds like too much magic... try explaining that to someone who doesn't quite know all the ins and outs of Javascript, and they'll still probably have trouble understanding where the locally scoped variables are coming from. 
Destructuring does empower a special kind of bad code :) 
I personally like Visual Studio code, but if you should try out a few and see what you like.
Agreed! I reject PRs at work that deconstruct more than one level deep. Been caught out way too often by it, trying to rewrite code that went two, three, even four levels deep, throw in some default values... and eventually you just give up trying to figure out what's going on. 
Any benefits vs other programs? 
I like it because of the JavaScript debugging and the mods you can add to it. I switched from dreamweaver (which we were forced to use in school) to sublime and found the wonders of mods. Sublime was great for my Ruby coding, but I switched the JavaScript and found I liked the mods on Visual Studio better. And the formatting for React is prettier in Visual Studio code, I think. But hell, you could use notepad if you wanted.
Handles large projects nicely and has a really great eco system when it comes to extensions
It looks like a lack of support in the libraries you're using. Can you show us the actual code of serviceworkers in use?
Mods affecting the users own client is okay, but if you allow their mods to run on other users machines, it affects them. If I could submit javascript mods that could be run on your other users machines, I could easily maliciously attack your other users. I could make a modal pop up on their screen using javascript telling them they have to log in again. Would look legit, being on your domain. Then when they submit form, I could have it submit data to my own server. That's one example of the risks of letting users distribute their scripts on your site. That's why XSS attacks are a thing. Hackers find a way to get their own javascript to run on other users machines, then they exploit it to steal data/user information. The mods you see on minecraft server don't actually run any code on the clients machines. The mods they make change how the server responds to the client machines. For example, I could make a mod that communicates that user is in a new location on the map when they issue a teleport command. It tells the client the correct position to show on the map. With a client side mod, you could make mods that can execute any code, that's how things like skin mods get distributed. They can't be done on server mods because their isn't a way for the server to affect the skins using the available APIs that they can use to interact with the client. Minecraft doesn't advertise those mods because they are unofficial. They could have hacks in the code that steal data or do other things. Users should know that any clients they install could have malicious content in them. If minecraft were distributing these 3rd party clients that they haven't reviewed the code for, they could be held responsible for any user data stolen by those clients. Possibly resulting in bad PR or legal issues.
Ahh thank you! :) I'm currently in the proess of building a series of posts on this exact thing. I'm hoping to cover a few major topics whilst doing so: * The frontend - fleshing out the react app, basic concepts + a nice html + css design * The backend - again fleshing this out and adding new events and things like chat rooms * Deployment - a full CI/CD pipeline that will deploy this up to AWS using Docker + Terraform. Currently contemplating whether to use AWS Cognito for user registrations as well just to go above and beyond! What do you think?
It couldn’t get any further away from being readable even if it tried. 
Huh. Well, you might just be right. [https://bugs.webkit.org/show\_bug.cgi?id=182444](https://bugs.webkit.org/show_bug.cgi?id=182444)
I think you didn't read the article at all. That's exactly what this does: It automatically checks the type(s) of your payload recursively at runtime for you.
My mind just melted from it being confusing and hard to read. 
I can see how it may not be considered readable, but it's definitely more reliable in the context of: Import { common_header} from 'constants/headers'; const importantData = { [ common_header ]: 'some val' } I'm just saying that in a large project and even across different shared repos this strategy works for our scenarios
Webstorm works really, really well. Great support for all kinds of frameworks (like Vue and React), all kinds of tooling, and great autocompletion.
I have enough trouble reading destructuring queries as it is. 
here is a more reasonable example: ``` const TYPE_NAME = 'model-type'; const data = { a: { ... }, 'model-type': { ... } }; const { [TYPE_NAME]: model } = data; ```
Awesome, thanks all!
Try nodenv
Awesome, thank you! I was looking all over for this.
let o = { ‘p’: ‘hello’ } FTFY
It might be cause I'm used to it, but I find it easy to read. Is there something objective about it being hard to read/maintain that I'm missing? 
JavaScript: The red light district of features you've never heard of but still use once or twice before forgetting about them completely.
Why is that fixed?
Symbols. const sym = Symbol("foo") const { [sym]: value } = ...
It's the only way I could think of to access symbol properties in destructuring. --- It may also come in handy when destructuring arguments sometime. You can write a pretty terse version of a dynamic getter function with for example: const get = p =&gt; ({[p]:v}) =&gt; v In general it may be usefull when accessing dynamic properties of objects. The key can even come from the same object: &gt; let {key:k, [k]:v} = {a:1, key:"a"} &gt; v 1 --- You could also try to build some kind of poor mans typesystem using this by exporting a bunch of constants for known properties of objects. Whenever you want to access properties of an object that was created by a function of a module or is consumed by it you then can use these constants for some *typesafety*. --- Interrestingly you can also access specific indices of arrays this way: &gt; let {[1]:x} = [1,2,3] &gt; x 2 I don't know if that's useful though.
I have a feeling that problems with readability just stem from unfamiliarity with new javascript features. "I don't use this because it's not what I'm used to and confuses me"
Yeah, sorry to bring back crappy old tech memories. I should never have jumped in to write a 'solution' in HTA/VBScript in the first place, but I hadn't known other tools for simple GUI and scripting at the time ...
Thanks, that makes sense.
It’s not that illegible... It can be helpful if you’re using the same strings/keys in a lot of places. Create a file that just exports constants. Import the constant you’re looking for and reference it like this. If the key needs to change later you only have to change it in one place. Etc etc.
I think that it is quite legible as well. In fact, destructuring is easily my favorite feature of ES6. However, there are a lot of developers, in my experience, who do not like complex uses of destructuring as it is 'hard to read' or 'hard to understand what is happening here', mostly because they are unfamiliar with it. Any time you have a radically new syntax, there is a contingent who reject it out of hand because they don't understand it.
For code formatting you need to indent 4 spaces. // given... const TYPE_NAME = 'model-type'; // say, we get this from a response payload or something const data = { a: { ... }, 'model-type': { ... } }; // then... const { [TYPE_NAME]: model } = data;
https://www.reddit.com/r/javascript/comments/8y0wey/wtf_wednesday_july_11_2018/
Oh my bad, I was searching by the flair. Thanks
Ive no idea what the fuck I'm looking at... 
More fun is to abuse this and rest props as a native `omit` const omit = (obj, ...unwanted) =&gt; unwanted.reduce((o, omitProp) =&gt; { const { [omitProp]: _, ...rest } = o; return rest; }, obj);
psh, noobs, this one doesn't even have any default prop assignments! /s
fwiw i agree with you but i think there's a real learning curve that puts people off if you're not used to seeing it. the problems seem to be: 1. computed properties look like array literal notation and array destructuring 2. the renamed key takes the value position in the destructured object and that's not even including default properties and rest props
Well, first of all, this syntax is very confusing. It looks like an inverse of JSON. Second thing is that it enables going very deep into data structure in an unfamiliar way and you have to think hard to decipher the path. It is a good idea to write code which is easy to reason about and is considered a good practice in any language. This syntax feature goes against this good practice and doesn't save coding time or improve code readability. Compare the two: ``` const { [propName]: value } = data; const value = data[propName]; ``` Destructuring variant here contains a lot more noise, has inverse logic, takes more space and is harder to reason about. And it doesn't have any benefits whatsoever.
**fs2.js -** [**https://sinaomrani.github.io/fs2/**](https://sinaomrani.github.io/fs2/) simple image gallery in half kB.
&gt;But OOP and FP are not mutually exclusive. Yeah, Scala from the start from designed to combine OOP and FP paradigms. See [quora explanation](http://qr.ae/TUpy8d). What's interesting is that Scala does something similar to Javascript. [Functions are objects in Scala](https://kwangyulseo.com/2014/03/03/functions-are-objects-in-scala/). This is due to the limitations of the Java Virtual Machine.
Sooo... anyone have a real-world use-case for this vs `const c = a.days[b];`? I usually defend JS, but really can't see this being terser or cleaner given the punctuation galore.
``` The back ticks also work, if you use the correct ones. ```
JavaScript is both the best and worst language ever
I appreciate the explanation - and I now understand writing code that is considered good practice in any language is the goal here. And in your example I would opt for the second, but what about cause when you want some static named properties from data: ``` const { [propName]: value, otherValue } = data; ``` or ``` const { otherValue } = data; const value = data[propName]; ``` or ``` const otherValue = data.otherValue; const value = data[propName]; ``` Which would you use then? I get your argument though - it's different from what people are used to. I guess my argument is that new things often are different from what people are used to. /shrug That said, if I was on a team that banned this, I'd adhere to that because it'd be the standard. I just need something more than "This is bad, don't do this". Thanks! 
I think I'd rather do const model = data\[TYPE\_NAME\] in that regard I still haven't seen a good use case for assigning through destructuring objects on the left side, on arrays tho, it's pretty useful and clear.
Yeah I get the learning curve - they'll just have to learn. When I joined a rails team, I had lots of PR feedback about about making my code more idiomatic for rails despite the fact I was still grappling with the language syntax but now the idiomatic stuff makes sense when, if I had avoided it, it wouldn't.
On arrays it's a bit more useful and clear IMHO, I've never found a legible use case with objects, it just confuses me way too much \`\`\` const \[a, b, ...rest\] = \[1,2, 3, 4\] const \[, ...rest\] = \[1,2, 3, 4\] const \[a,\] = \[1,2, 3, 4\] \`\`\`
wait but then how do you access it? i use restructuring all the time, and have even done it with computed property names. but this example and the op’s confuse me a bit 
oh me too. destructuring for the sake of destructuring can get annoying.
`model` is the new variable that you'd access the value of `data[TYPE_NAME]`
oh ok. that’s probably what was confusing. so `model` is the assignment variable name... word
what's the difference? https://imgur.com/a/x0QH5mg
yeah, doing assignment in destructures is pretty bad. lol
it’s weird because it’s on the right (assignment) side of what would normally be an assignment in json or whatever. 
Oh weird, it doesn't show as formatted for me. https://i.imgur.com/EXkAOYa.png
Why are you logging so much, what value are you getting from it? I find tracing to be much more valuable to understand how you app is working.
I would just use object and its properties directly without introducing new variables. I only use destructuring for data transformations where it makes sense. In most cases I will try not to use variables at all and will try to pass relevant data to the function ASAP. My ideology is the less code you write the better.
oh yeah. new reddit has markdown :)
I totally agree, although I can imagine cases where avoiding declaring variables can make things hard to read. I guess it boils down to the case of context and what's going to be the best approach given that context. I appreciate you engaging with me though; I can't have my mind changed if I can't understand the other point of view!
Okay, this is new to me, and I was actually thinking about wanting to do this earlier today.
you want to pull out other properties at the same time
&gt;But OOP and FP are not mutually exclusive. Yeah, Scala from the start from designed to combine OOP and FP paradigms. See [quora explanation, 2nd answer](https://www.quora.com/Isnt-Scala-unnecessarily-complicated). What's interesting is that Scala does something similar to Javascript. [Functions are objects in Scala](https://kwangyulseo.com/2014/03/03/functions-are-objects-in-scala/). This is due to the limitations of the Java Virtual Machine.
I recently had to do some work with web sockets at work, and had to connect them to a Java backend. I tried a prototype with SocketIO, but unfortunately its support outside the JS ecosystem is fairly lacking, and so there was no way to pair it with a Java counterpoint without writing a custom extension of an existing web socket library. All of that said, have you looked into using the native JS WebSocket implementation? I was able to write a wrapper for that that utilized RxJS observables to give me nice subscription-based data streams, and ever since I've been trying to spread the word about it.
&gt;The matter of fact is that the most used &amp; powerful languages are multi-paradigm. This is why I like Scala. I can either do things the OOP way I learned in Java, or I can do the things the functional way I learned in OCaml. I think functional programming is really powerful when it comes to big data though, but I think mutable state is also sometimes necessary. I suppose the thing I like about functional programming is that keeping track of shared state in your head is a pain. 
I kind of draw the line at declaring functionality directly enabled by the core language syntax "magic". It may be unreadable, but its not magical. It is doing explicitly what the syntax declares it to do. It's even statically determinable, so you can declare types at compile time and check it.
[https://i.imgur.com/pvkze3g.png](https://i.imgur.com/pvkze3g.png) I think I understand now, how Vue got more stars on GItHub. (look at authors)
I started with sublime text and it was alright. Then in 2016-2017 I used atom, every day, professionally. It had a rad Mocha plugin where you could just click on the name of the test in the file and it would run it. I loved atom while I used it, but it is built in JavaScript so sometimes it gets laggy if you’re working on large projects or have a lot of plugin. I switched to visual studio code a few months ago and haven’t looked back. It seems like it can handle plugins better. 
Same here! Found socket.io/engine.io to be too opinionated on how socket communications should work, so rolled my own. Never looking back, tbh. Socket.io is too hung up on chatroom examples and not nearly enough on (near-) realtime data streaming.
For example, if your key is an invalid variable name like “foo-key” you could use this to rename it. const key = “foo-key”; const foo = {[key]: “bar” }; const { [key]:fooKey } = foo; console.log (fooKey);
Was just reviewing code and came across another destructuring that's fairly useful! ``` const { foo: 'default', bar: 'default' } = someObject; ``` Setting default attributes when fetching object properties!, I'd still keep it at 1 level tho. Still looking for a case where this is useful tho. ``` const { foo: c } = { foo: 'bar' } ``` 
Piexif is already mentioned, and I'm 99% sure it's the only one available. There's also [OfficeProps.js](https://github.com/TorkelV/officeprops) if you're interested in document metadata.
Both are me, I just testing comment system :( This post allow everyone give a review. Thank for your response i hope you can leave a comment on reactjs and vuejs
You
I appreciate the effort made to compare frameworks but this feels a little... Off. The various react router versions is a mark against react? That jsx conditional is just a javascript short circuit. I like that in a sense it's just javascript. As opposed to vues new html attribute. To each their own I guess. Change the title though.
Well this is sort of what I am getting at. It's possible that everything looks like a nail to my logging hammer. So, rather than placing them around where I feel I need them at the time I was wondering if there were some suggested patterns to look for/read up on.
You don't need to log at all, or just sparingly. Piece of advice I wish I knew a decade ago: force yourself to use less logging and more breakpoint debugging. Most code editors make them simple to add remove.
Why is it difficult to justify? Is there some serious bugs or issues they're not addressing? If it's just a low level of commits, it might just mean the library is in a stable place bug, functionality, and API wise React on the other hand is still doing an entire rewrite of it's internals, so of course there's a ton of activity. 
yes but this is taking the piss
Read this as “Why you should leave React for Vue, and never use Vue again.”
x is a placeholder for any string (instead of specifying exactly x, y, z, ...)
Gotcha, thanks! This lines up with what u/snail_34 wrote as well. Always glad to take this kind of advice.
Why?
VSCode is JavaScript too. Atom _is_ super sluggish with large files/projects, but that's not because it's written in JavaScript.
Note that the idea of `&lt;script&gt;` is to simply evaluate some code, it was never designed to be a module system at all but people abused globals to turn it into a pseudo module system. There's no way that ES modules could know that scripts pseudo "export" things by attaching them to global so the best thing you can do is just force it to load the script from within the module e.g.: import loadScript from './loadScript.js' loadScript('/scripts/phaser-3.11.0.js') // global Phaser is now usable like normal And how does `loadScript` work, well basically if you want it sync the only option is to load it via synchronous `XMLHttpRequest` e.g.: export default function loadScript(classicScriptUrl) { const xhr = new XMLHttpRequest() xhr.open("GET", classicScriptUrl, false) xhr.send(null) if (xhr.status !== 200) { throw new Error(`Failed to load ${ classicScriptUrl }`) } // a classic &lt;script&gt; tag is basically just an indirect // eval call after fetching the contents const indirectEval = eval indirectEval(xhr.responseText) } Note that if the classic script you're wanting to use was written in strict mode then it's very likely that `import '/some/classic/script'` will just work. But if it doesn't the `importScript` method will work fine.
Wait, I'm confused. Can you post a jsfiddle showing what this does?
&gt; I like that in a sense it's just javascript. As opposed to vues new html attribute. Yeah, I don't get why people prefer that at all. Vue requires learning and then constantly thinking about an entirely new set of commands. With React, you just write JavaScript. Is it fair that I assume the Vue people skew more toward the "don't really like JavaScript but have to use it because JavaScript won the browser" crowd?
They're both very reasonable choices. By most metrics, React/Redux/etc. is winning the mindshare war, but alternatives like Vue and Angular are still quite healthy, too.
Sorry for not answering your exact question, but from some developers' perspectives, frameworks don't matter that much. While there are developers who have *really* strong opinions about frameworks or methodologies (borderline religious), for others like me as long as the stack is reasonably modern (Angular, React, Vue; ES6 or TypeScript) they can create a good product. So my personal advice for you is that if you like the guy and he is experienced in Angular then you should just go with it.
 u/elliotforbes Do you have a good tutorial on Sagas? I am building an APP right now in React using Redux and Sagas but I really have no idea what I am doing...
\&gt; Am I limiting capability by going with a framework (angular) rather than a library (react)? Actually you don't. On top of the view library (ie: react) the developers will have to choose various other libraries. Some of them might be not well used by the community but they will be chosen if the developers are familiar with it. Now move forward in time 2-3 years and you might 1) hire people that don't know those libraries 2) those libraries were discontinued etc. IMHO angular as a framework is a safer choice, business wise.
Im on mobile so ill just give an example const obj = { a:1, b: 2, c: 3, d: 4, e: 5 }; omit(obj, 'a', 'b', 'c'); // { d: 4, e: 5 } As for the original code, you can collect any properties that didn't match during destructuring into a "rest object", as in the rest of the keys. const { [omitProp]: _, ...rest } = o; grabs the key in `omitProp`, assigns it to the variable `_`, then shallow clones all unmatched props into a variable called `rest`. 
This is awesome man. Looking forward to part 2!
Good reddit has markdown too, just not fenced code blocks. 
GitHub was hit with a 1.3Tbps ddos so what’s the point of having ddos protection ^^/s
Nebulas is fast, cheap, and "ease of development". * Javascript * Multi-language SDK * various developer tools * Mobile support with App store Some developer reviews.... **Nebulas: Javascript meets smart contract** [https://medium.com/tooploox/nebulas-javascript-meets-smart-contracts-b3e318e3bd18](https://medium.com/tooploox/nebulas-javascript-meets-smart-contracts-b3e318e3bd18)
FYI, codepen is relatively usable on mobile. 
It's a cool idea, but like others have mentioned, it relies on `Function.prototype.toString`. String-base reflection is pretty much an instant no for me. Not only is it side-stepping the language, it's also relying on a feature that isn't actually guaranteed by the spec in general.
Use a bundler like webpack or parcel, and if you need to import non-js assets give it the right loaders. For legacy scripts you use shims and then import them like anything else. The official spec is still years from reaching parity, and it probably never will.
&gt; Repetition helps, maybe the Udemy course just is too complicated at that point, or explains something in a weird order or phrased ambiguously. Can't really say. Looking at the course outline and video descriptions, I definitely have to agree. Among other things, introducing template literals _before_ objects or arrays seems super questionable. Template literals are rad AF, but you could go your whole life writing JavaScript without ever needing to use one.
&gt; But I am having trouble making the connection with how the function should be written and connected in terms of the arguments and lets and all of that. Can you elaborate a bit on what you're struggling with? Is there an example exercise in specific that bent your mind? And when you refer to "lets," do you mean the `let` statement for variable assignment? 
From a quick glance, it seems [NestJS](https://nestjs.com/) is exactly what you are looking for. I've no experience with it, but from reading [the documentation](http://docs.nestjs.com/), it offers these features: * Written in TypeScript * Built around classical MVC architecture * Support for microservices * Offers a form of dependency-injection * Built on Express, but can write/download an adapter to use Koa/Fastify/etc instead * Built-in patterns for GraphQL/Websockets * Can optionally include your choice of ORM, I suppose you would be interested in [TypeORM](http://typeorm.io) In fact this framework is looking so appealing I might start using it. Sorry AdonisJS, you tried your best. :D 
You can use \`import '/node\_modules/some\_lib/dist/somelib.js';\` in your code to bring in any kind of file, even if it's not an ES module. You can then access the global below it. This won't work with all libs, but for well-written ones, something like: import '/node\_modules/lodash/lodash.js'; const { \_ } = window; console.log(\_); Should work to get you what you want. The dependency will load ahead of time and attach itself to the global context (window).
This falls to the category: "Things JavaScript can do but people prefer not to use"
This could be expressed as: const key = “foo-key”; const foo = {[key]: “bar” }; const fooKey = foo[key]; console.log (fooKey);
Thanks man! That's what I was looking for. Do you happen to know something that can write XMP Data as well?
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Yes. We have destructuring, which is very useful in some cases: const { state: { count }, props: { countTime } } = this Allowing dynamic keys is a natural extension of this and is useful in some cases, such as retrieving an object which is keyed by its id, or retrieving a symbol keyed value. This can be abused of course. But lets you avoid setting up temporary variables. It is basically a tree querying DSL.
Thank you very much for the notice. Just added
They can be combined (recursively) as well by the way: const [{ foo }] = [{ foo: 'bar' }] console.log(foo) // bar
Here's a few examples: const { default: library } = require('library') const { class: className } = foo const { className: otherClass } = bar
I can’t be the only person that likes this and uses this a lot. “Unreadable” and “unmaintainable” has a lot to do with language comprehension IMO
And add babel for all other es6 features you want
I would say: follow your interests and passion. If you are interested in a specific field or framework or whatever, just take some time do get some hands on experience with it. The way you develop yourself mostly comes naturally so just do what feels right and don’t succumb to hype. 
It is indeed very opinionated, however I have been able to build various tools such as monitoring agents that utilize the library. I've previously looked at raw websockets and RxJS but within an Angular context which turned out quite nicely for my purposes and I may revisit it in a future react article! - This was the previous tutorial here https://tutorialedge.net/typescript/angular/angular-websockets-tutorial/ 
Nah, we use vue in our latest project and mostly chose it because we were sick of jsx. It feels like a step backwards. We used react redux for 2 years and threw away the complete codebase. Redux also requires quite a bit of boilerplate. I can see it working for small applications but if you have a big project with a lot of people it turns into a shitfest real fast. Vue stays readable.
Both are good choices. My personal is react though (more lego-like). Ask the actual developers and actual people who will work on this project. It they dont know, set them task to investigate both choices.
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
no wonder i hate programming in general.
TIL t-shaped developer 
Summary: stop transpiling for IE11. Author is very disconnected from reality, our client for example plan to migrate from ie8 to ie9 in next year and stay there for at least 5 years. Microsoft really did kill the web with no autoupdate of their browsers and they even made that mistake with edge again (it should be windows store preinstalled app with forced updates).
Hey that's not a bad idea, I have the highlighter extension but I still miss them occasionally. What would be interesting is if I could get certain env builds to fail if there were still TODOs in the code. 
Thanks! I hadn't thought of that, I'll definitely look into it
[http://docs.clout.tech/](http://docs.clout.tech/) This has awesome dependency and object life-cycle management but lacks any definitions. 
I have a commit hook that fails if it finds TODO in the diff.
No enough third parties. Need moar.
`JavaScript` is not *really* an official name, but a trademark of Oracle that is widely used. Since the trademark is `JavaScript` that is *the* correct way to write it. By the way, another name is `ECMAScript`, which is the current (rather successful!) attempt to standardize it.
Is the code for that on Github?
fenced code blocks are the best. I use them everyone except old reddit. Also funny. "Good" reddit. (that said, I wish clicking a post didn't open a full screen modal. blegh)
Without third-parties? Awesome! You don't see many people working with Vanilla Javascript anymore :(
It only looks legible because the object literal is just right there. In a codebase where you're working with objects on functions where you can't see the structure of the object, it starts to show it's illegibility.
Thanks :) I really love working with Vanilla Javascript.
No, it was just something I hacked together horribly in a few minutes. I put it here more for an idea for others than anything.
Your mentor is being pretensious, you should not dismiss something simply because of capitalizations.
As long as ot's not AngularJS (the old version), both are nice tools. As a JS dev you should be able to pick up either with minimal effort. One issue I had when working with AngularJS that has been a non-issue with React is that user-selected components (stored as strings in a database) were much easier in React (choosing a template). How is that in Angular now?
Aren't TODO apps like the hello world of front end dev? Why is there a library made just to make hello world apps?
This blog post downloaded about a megabyte of random stuff according to the network thingy in Firefox, and also contains a giant image of hot air balloons for some reason.
Django AND React? Unusual combination, even with Angular or Vue. Django fames itself for it's server side rendering templates, very traditional. The REST framework is more of a headache. If you want a good, modern back end, look into Node.
https://developers.google.com/web/updates/2016/08/removing-document-write
Not just TODO.. TODO-like imagine something like Twitter.
To show with an example: const Component = components[page.component] return ( &lt;/Component {...someProps} /&gt; ) vs. &lt;render-page component="$ctrl.component"&gt; This was a PITA in AngularJS with $compile and $parse, etc. 
You right. Thanks for the feedback. 
CRUD app may be ?
The name is a little unfortunate (ramda js anyone?).
Apple is similar with Safari. Users have to update their entire OS to get the newer version of Safari. You could say Safari is becoming the new IE...
This is not just IE, millions of Android and iOS phones are stuck with webkit browsers that will never be updated and will never support ES2015. Only people who don't give a fuck about content accessibility, which is one of the cornerstone of front end development would ignore them. So it's funny all these developpers completely ignoring mobile space yet all this talk about diversity and inclusiveness, how about inclusiveness of the poorest among us? 
This is medium, it's some complete shit which once claimed revolutionizing readability on the web : 1 fixed header and a 3 nagging popups and a non-dismiss-able footer if you didn't subscribe later... readability my ass... More like this is the silicon valley, people full of shit.
I prefer reactjs
Yes, there are different cases, so a developer should always be aware of which effect will different practices have on the code base. It's never black and white (:
Since technically both frameworks are at a tie, if your team members already have experience in one of those, then that's mostly already a winning point. (leraning curve matters a lot)
Oh damn, the beta has fenced blocks? I hope they bring over denoting which language, like on GitHub and SO. 
It already became. They only announced support for basic things like service worked, yet everyone uses them. At least its not abandoned like IE. But really, controversial opinion, but because of shit like this, web is slowest moving platform of all.
An alternative to that are git pre-commit hooks. I have [one looking for `# XXX` comments](https://github.com/exhuma/dotfiles/blob/master/git-template/hooks/pre-commit) and combine it with [some snippets](https://github.com/exhuma/vimfiles/blob/master/UltiSnips/python.snippets#L2). This is super handy. If I want to drop a quick print-line in my code and want to make sure I don't forget removing it I execute the snippet by typing `dp&lt;TAB&gt;`and automatically get the `# XXX` comment added. This way git will not let me create a commit. It has safeguarded me from accidentally adding *many* random stuff in my repo. Also, by simply adding `# XXX` to code-lines I prevent them from being committed. This hook can also easily be extended to `TODO` items.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [exhuma/vimfiles/.../**python.snippets#L2** (master → e538e80)](https://github.com/exhuma/vimfiles/blob/e538e8022d487e6e8f1eb6ee58f745a30f213c19/UltiSnips/python.snippets#L2) * [exhuma/dotfiles/.../**pre-commit** (master → c0390f4)](https://github.com/exhuma/dotfiles/blob/c0390f4227d582c9e95426a8fc2d15dd9e239461/git-template/hooks/pre-commit) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e2h5m2x.)
VSCode uses typescript to provide hints: https://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types https://basarat.gitbooks.io/typescript/docs/types/index-signatures.html
React : PLUS: - easy to learn - lot of developers, way more than Angular, so easier and cheaper to recruit. - actually solves the composite components as view issue - allows to transition easily from html designer work to integration since no special template syntax thanks to JSX. - quite simple data binding model - great ecosystem, with a lot of components libraries - has React Native for developing mobile apps which use the exact same principles as React MINUS: - flux/redux/reflux/relay/mobi whatever mess. These are "datastores" you use to sync data in React project and there are a lot of competitive solutions. Angular: PLUS: - name recognition? - ecosystem? - native script similar to React Native MINUS: - bloated, steep learning curve, most AngularJS developers still work and maintain AngularJS (1.x)apps, not Angular (2.x&gt;) apps which are 2 completely different frameworks - over-engineered - needs to add RxJS on top of that which is a framework of its own, with a complex API - deemed the JEE of front-end. AngularJS became famous because it offered an easy migration path from jQuery based apps to more structured apps, providing 2 way databinding, great automated UI testing toolsuit. It offered a better alternative that Backbone at the time. Since then other frameworks have caught up and try to promote simplicity while Angular seems to wallow in its own complexity to justify its existence. Angular (2.x&gt;) adds absolutely nothing to the competition IMHO. React selling point is JSX, Vue is simplicity, Angular is just bloat IMHO.
Here is a small version I love to use: [.git\\hooks\\pre-commit] #!/bin/sh # VAR=$(git diff --cached | grep -w "var_dump") if [ ! -z "$VAR" ]; then echo "You've left a var_dump in one of your files! Aborting commit..." exit 1 fi VAR2=$(git diff --cached | grep -w "@remove") if [ ! -z "$VAR2" ]; then echo "You've left a @remove in one of your files! Aborting commit..." exit 1 fi As you can see it's undynamic and highly optimizable.. but it works! If either `var_dump` or `@remove` is in the code, it won't let me commit my code. There are so many other things you could do and I am sure there are some cool open source configurations that will help you a lot! 
I'm a professional server side Java developer looking to go full stack. I knew I was interested in this so I just started studying JavaScript and front end concepts. If that's how you want to go just pick something and run with it.
:D
That's really cool. I'll definitely use that, thanks! As this is in the .git directory, it will not get committed and pushed to Github, Gitlab, etc... This means that if you pull it from a repo, this file will be missing. Is there any way to avoid this so that the file is included in a commit?
Logging with a library like Winston is intended for deployed instances. After the application is up and running where it’s not a good idea to instrument the process for debugging. Even then the logging should be very sparse, like request time, url, response code, and error information if there was an error. If you are developing, it’s much better to use development tools to set breakpoints or even better write tests to inspect the functionality of your code. A breakpoint enables you to inspect the environment, while a log will just tell you what you logged.
this \^
[removed]
&gt; document.addEventListener('scroll', function() also consider [throttling](https://www.sitepoint.com/throttle-scroll-events/) your scroll events
For example see here: [https://microsoft.github.io/monaco-editor/playground.html](https://microsoft.github.io/monaco-editor/playground.html) What I need is for my code do what they do, if you paste code or text of 500 rows it will have a proper scroll bar, if you render all rows on screen to calculate offsets and the height of the scroll bar works but when the number is less than 100000. This approach costs too much for the performance with 150 k of rows takes about 33 seconds to display something. See for example the Ace Editor and activate the line break: [https://ace.c9.io/build/kitchen-sink.html](https://ace.c9.io/build/kitchen-sink.html) Paste a large text with more than 100 k of lines, you can see that even with Word wrap enabled it can display a scroll bar, what I need is to do this, but the problem is just with the dynamic height lines. If I don't break the lines can I calculate everything without rendering, but how can you break the lines have to check how to do this, and for an editor of this follow-up we need to offer the option to break the lines. What I am doing now is to check the width of a character of a mono spaced font and then scroll through all lines of text in an array to check which lines I need break and calculate how the scroll bar without rendering. Do you have another idea?
Yes finally we have another one! Sarcasm aside really dont want community to switch between package managers and hopefully this will be an example for performance solutions for more adopted node pack. managers
But webpack 5 probably releases yesterday or something, making all of this useless
With how many lines you did that? I need to calculate a large number of rows, and they can range
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
Amazing. This is a less readable, more horrific way to do lodash's _.set().
 I love the ui filepond was built with, but for the life of me I can’t get it to work correctly with S3. I’ve added custom logic to have the file upload to node and fire off to se, but it’s always a “corrupted” image. 
Thanks bot! I didn't realize I needed to add a license file on top of specifying the license on package.json.
Webpack 5? Latest released version is 4.16.1 and 5.x has no due date yet: https://github.com/webpack/webpack/milestone/18 Are you from 2019?
nah, just edgy Lol also if anyone doesn't like that things progress and change, then this field isn't for them
So, I worked hard on making this project appealing, but I'm new to such efforts, so any feedback is greatly appreciated. Another important note. When I first wrote this library, it was a year and a half ago for a project. Back then normalizr.js required a LOT of configuration. Since v3 it's significantly simpler to use. For the simplest case, my library requires zero config, so it's easier, but for cases requiring some configuration, normalizr.js is easier currently. Frankly, I like their approach better. THAT SAID, please still try my library and see what you like or dislike about it. I imagine some people could learn something from the concepts I've provided and from the code I've given. Further I could definitely learn from feedback. (One piece of feedback I don't want... no I well not use super strict linting. My linting is very relaxed, because programming is not an assembly line at a factory, it's an expression of creativity and problem solving.)
As a small one-person developer is there any advantage to continue using Webpack over parcel for entry level React apps?
Ahhh this makes a lot of sense. I shouldn’t read code late at night. I was sitting there trying to figure out where unwanted went
React is a safe bet, wins in terms of available components+community+length of running with non breaking changes Angular lost a lot of momentum when it switched to 2 and broke everyones 1.x code. It's still very viable with a strong community but I find that projects that are POC or just starting etc are harder to get off the ground after 2. Vue is my current favorite, I think it strikes the best balance of ease of use and enforced structure etc. However, it's not the most mature or most popular. Once you get something off the ground in React I dont think you'll regret the choice and that's what matters most... just move on to making cool shit and dont look back
Nice! Looks like you ended up not using the Vuex store?
Yeah I had it checked during the set up thru Vue CLI but didn't end up needing it
chut, go revert
&gt; Deterministic. Has a lockfile called shrinkwrap.yaml Why a separate lockfile format? If this used `package-lock.json` it'd be fully compatible with NPM, so devs could use whichever they prefer, right?
Progress and change can happen without constant breaking changes
Yes.
Skill sets that you don't need now may be skill sets that you do need later.
Nothing about the existence of 5 breaks 4.
Hi! Dev here, do open an issue on GitHub, happy to assist!
Not with JavaScript apparently.
Yeah, and don't even fucking think sticking with jQuery hahah
I am in the same boat as you. I an currently trying them all out on different brances of a simple project. The only downside to parcel seems to be that it doesnt accept ES6 imports/exports. And to be honest I’m not even sure if that is really a downside. 
Well, I found Webpack greatly helpful for integrating tools like sass and postcss, and configurating those tools to my likes and needs, yes, Parcel makes module bundlers look easy and time saving, but still nothing beats Webpack in the way you can configure in your workspace, I usually manage a common webpack.config.js for all my react projects.
If they're following semver then yes it does. But I'm not familiar with their versioning strategy so forgive me if that's incorrect
:(
With great power...
Thanks for the helpful advice!
Couple hundred thousand for my case, but it depends on how heavy the hidden renders are &amp; what else you’re asking the page to do at the time. I’ve done over a million with a really simple list item—the limiting factor for that one was the maximum height a browser can assign to the container, definitely slower to load. 
Also, why YAML?
[removed]
It contains less noise than JSON.
You mean it’s less clear? Also it’s an unnecessary barrier when everyone using it knows JSON.
Tried it before because I like the concept much more than npm's deduplication. Had to give it up, though, because so many packages broke (I think it were mostly webpack loaders).
No, the way it works is that when you commit something it will look for a file named "pre-commit" (and several other files). If it exists, it will be executed. In this Case like it says.. pre commit. This Script will throw and error if vardump or error is in the diff, which will prevent you from commiting at all. To prevent this you can either remove the vardump/error in the Code, you can exclude the file from beeing commited or just rename the pre-commit file and it wont get executed.. that should be the last case scenario since you obviously dont want to commit vardump. If you somehow commit and push something into the Repository, everyone else pulling will have the vardump too! I think there is a post-poll file too where you could use a similiar Script to prevent pulling Files containing vardump.. 
Sorry, I was referring to the pre-commit file itself getting committed to the git repo, not files containing var_dump. Is there a way to commit the pre-commit file itself to the git repo so that when a person clones the respository, the pre-commit file will work for them too?
&gt; needs to add RxJS on top of that which is a framework of its own, with a complex API `RxJS` is not a framework. That's similar to calling `lodash` a framework. 
&gt; RxJS is not a framework. That's similar to calling lodash a framework. Is absolutely a framework, it is not similar to lodash, at all.
You're right. There are issues. Mainly two: 1. some modules require packages that are not declared in their package.json. This one can be fixed by running `pnpm install --shamefully-flatten` 2. some toolings don't resolve dependencies the way node does (they preserve symlinks) These are not unsolvable issues and I hope they will be fixed in the ecosystem
Great idea! 
Thank you!
That’s total bs, Which libraries to use is simple, the community has already decided. React is the safer choice, because the API is stable and won’t change were as Angular regular rewrites are too be expected. Plus Angular has a greater risk of being abandoned if google does not find the consulting contacts worth the expense. React on the other hand is actually used by major companies in core products. To the OP: Pick React, it will be much easier finding developers, it’s a more mature stable framework used by FB, NetFlix, AirBnb, JIRA and essentially every major app these days. Picking Angular will cost more, require longer development time, and will probably be abandoned in 2 years. Angular was made for sole purpose of consulting contacts. React on the other hand is an actual framework that’s actually used by major companies, picking Angular would be crazy 
&gt; JS breaks too easily &gt; Another little issue we have with polyfills and transpiled code is that a tiny little issue might compromise a whole site. Differently from HTML and CSS, we all know JS is not fault tolerant... * { background: white !important; color: white !important; }
`grep -r "// TODO" *.js -i`
Oh sorry I missunderstood you. I am not sure but according to following post it seems that you cant do that: https://stackoverflow.com/questions/3703159/git-remote-shared-pre-commit-hook A friend made something called "Captain Hook", maybe it's capable of doing it, but I dont know. It also seems like that you also "shouldnt" do/force it that way :P
It's not less clear, and it's pretty straightforward to learn for anyone who knows JSON. { "key": { "asdf": [ "some value", 1 ] } "key": { "another_key": "blah" } } v.s.: key: asdf: # Here's a comment; can't do that in JSON - some value - 1 key: another_key: blah Basically the Python of data interchange languages. That said, I'm not really sure why they decided to use it for a lockfile; those files aren't typically edited by humans; they're generated by machine. Not to mention `package.json` already uses JSON, so it seems better for consistency to stick with JSON for the lockfile.
And/or use passive modifier
Ah, because any object will match the type as long as it has *at least x, y and z*, right? Still confusing that it will not ignore that possibility.
Hah, this is great stuff. I hope you don't mind me forking and fiddling with this!
[removed]
Ah cheers, I'll check it out! Thanks for the advice
a lockfile should be committed to the repo and may be reviewed on code reviews, so it should be human-readable
Anyone said? # TODOS? *GAERON INTENSIFIES*
anyone said... # TODOS? *GAERON INTENSIFIES*
Web dev here. I work with all three popular frameworks (React, Vue, Angular), but my current project is in Angular 6 right now. Angular has an exhausting boilerplate. Explaining your work in Angular to your colleagues is an absolute nightmare. RxJS, Angular's way of managing states and observables, is useful but terribly complex. It's also VERY unstable. The RxJS team have been introducing breaking changes after breaking changes every update. IMO React/Redux is much more stable and mature. As a bonus point, Vue is simple and powerful, but probably not the best choice for large projects. You should wait for Typescript Vue to mature before consider using it.
https://symfony.com/doc/current/frontend.html Makes Webpack config a breeze :) But always good to have nice and understandable tutorials like this!
Cool. Also no codepen/JSFiddle? The only thing that bothers me about this is why? Cool you can do this but why not just used a position: fixed. why make javascript waste time and cycles trying to figure out where this element should be placed when the browser can do it on its own in a much more optimized fashion. Also as u/tobozo said debounce/throttle your events based on your use case. If this is just for learning awesome keep it up. Scroll progress is awesome and building it into a bar like some sites are doing is awesome. 
Cool, thanks. I'll probably give it another shot in that case. Seriously annoyed by npm's constant package-lock bugs.
&gt;This contrasted with the tc39 proposal, which is a specialized imperative syntax. Why is the syntax imperative? I don't understand which definition of imperative you're using here? Imperative programming is programming with statements that have side-effects (\[Wikipedia\]([https://en.wikipedia.org/wiki/Imperative\_programming](https://en.wikipedia.org/wiki/Imperative_programming))). Nothing in the tc39 proposal has side-effects so it's not imperative. &gt;The different "when" statements aren't normal functions, I can't write a function to produce "when" statements. That in itself does not make the syntax imperative. Purely functional languages, which by definition are not imperative, also has syntax that aren't normal functions. For instance you cannot write a function that produces \`if\` expressions in Haskell. That does not make the \`if\` statement imperative.
&gt; React on the other hand is an actual framework Except that it isn't
&gt; some modules require packages that are not declared in their package.json. It irks me that this kind of thing happens in something as commonplace as a webpack setup.
PaperJs is awesome for that. Check out P5.js as well
Iirc, pnpm and ied predate package-lock.json by years. I'm sure it's just a case of not having updated to the latest "standard" yet. 
It was all the rage back when pnpm was first authored. 
The fact it's the Python of DIFs tells you it's probably the wrong choice no?
How does that tell you that it's the wrong choice? 
Well JavaScript has a DIF.
GitHub is down again. If someone would still love to read about pnpm, here's docs website: https://pnpm.js.org/
That's exactly it, and personally, I find that code commented with a brief hint at what an unusual line does is great to learn-as-you-read (and Google deeper later).
You should probably read that sentence again. It's the Python *of* Data Interchange Formats. 
Actually, ied never implemented the lockfile. We did have plans to use the same lockfile format and everyone agreed to use yaml but the author of ied stopped maintaining it shortly after.
Oh you mean there's two active versions and the first one is maintained 12 years after the successor was released and 5 years after it was originally deprecated?
You can do it, no problem.
Is there an ELI5 on how to transfer to pnpm from npm? I'm dying for diskspace on my raspberry workstation. I was sorta hoping the node_module folder in all my projects could stay intact independant on my choice of manager.
`grep -i -r "//.*TODO" .` FTFY
Well... kind of. JSON5 is a thing.
I don't know much about Parcel but using webpack and playing with its configuration so that it fits our needs( big app with several layers of old stuff) helped me learn a lot about how package bundling works, specifities of ES6 modules and plenty of little things we take for granted when developing inside a well configured CLI generated react app. 
Also Sean Larkin is on Twitch and you can ask him plenty of stuff while he's live coding. 
I mean, if you're going to approach the conversation in bad faith then I have better things to do with my time
Holy cow...What's this syntax?? html` &lt;span&gt;Hello ${myVar}&lt;/span&gt; ` The `html\`something\`` thing.
Your node_modules won't stay intact because pnpm creates a non-flat node_modules. You may use the `--shamefully-flatten` flag that will simulate a flat node_modules but that is not needed in most cases. The good news is that the disk space savings are huge.
to migrate, you just have to remove your old node_modules and run `pnpm install`. if you commit your lockfiles, you'll have to commit `shrinkwrap.yaml` instead of `package-lock.json`
What do you mean finally another one? pnpm is nearly 3 years old?
Check out Google Caja for secure sandboxing.
No, you are missing the point. We must npm all the things! 
# ES2015
Why do I need a 'course' for a build tool?
On your first examples you can do \`\`\` const library = require('library').default const className = foo.class const className: otherClass = bar.className \`\`\` And IMHO it's way clearer, theres something about having to reason with both assignation on the left side, and, having to retain a right side property on the left side (default is from the require, not from the assignation itself) causes too much noise to me. Of course this is just my personal preference :).
Parcel is still very new, I looked into it and found a number of use cases it fails to address, and bugs with others. Why bother with learning one tool for "entry level" work and another for "production" work? Using multiple tools actually becomes more complex than just mastering the one you can rely on and use for everything. Yes, webpack is harder, but it's more robust, and the leading solution for modern frontend.
Is the semantics of the word "imperative" really that important here? I kept the word choice used by the grandparent comment in my explanation, and maybe that word choice wasn't optimal. But the concept that the grandparent was talking about seemed to be composability, and I think my comment addressed the differences between the two. 
Searched for something similar recently. svg.js and two.js are both modern, rich libs for this. Considering your example I'd say svg.js would be a good fit.
Contrary to what [opposing opinions](http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/) have to say about JWTs, JWTs are a secure, stateless, and elegant solution to authentication. The fact of the matter is that both session and JWT authentication have seen plenty of production usage and both implementations are secure and robust when it comes to handling user authentication. If statelessness is a practice you value in your system architecture, then I highly recommend checking out this article and learning more about JWTs.
&gt; Why bother with learning one tool for "entry level" work and another for "production" work? I feel like this line embodies what many see as a flaw outside of modern Javascript web development not just my situation. 
That was mostly joking. I do see your point, but I think when you have JSON you have to have better reasons than "it's a bit easier to read". For me the continual redesign of identically functional data storage formats to the point where they can't even think of a non-joke is just the prime example needless bike-shedding. Every time a new format is invented every language needs a new parser written, new bugs are generated and for what? Perceived 'pretty' based on less tabs or more words or less words or less punctuation or more punctuation. It solves no new real world problem, nor does it contribute academically and is everything I dislike about the culture of software development.
This is just an opinion, but I've had hours and hours of issues with YAML in the past where I've had approximately 0 issues with JSON, despite using YAML for only a couple of jobs and JSON consistently throughout my career. [Here's a synopsis of some of YAML's issues](https://docs.saltstack.com/en/2017.7/topics/troubleshooting/yaml_idiosyncrasies.html). I find that the novelty of "it's easier to read and there's less noise" wears off extremely quickly, and that significant whitespace has never shown itself to me to be "more readable" in any way as many people love to claim. IMO, JSON is the extremely clear, unambiguous way to represent data. The only improvements I would make are: - Not requiring quotes around keys - Allowing comments as one might expect
&gt;For instance, I know there is a canvas element. But that only seems suited for static drawings. I'm trying to do something a little bit more complex, such as: &gt; &gt;"Draw a red circle, yellow square, green triangle at positions (x1,y1), (x2,y2), etc. etc. with radius/side length "z", move red circle/yellow square/green triangle left by 300 pixels at a rate of 10 pixels per second. You can do exactly that in vanilla JS all on the canvas. If you don't have the time then definitely go with a library that abstracts away the complexities however I would highly recommend getting your hands dirty drawing primitive objects on the Canvas.
So I just did this and while I confirm it works beautifully, it seems like my current Gatsby setup takes offence to pnpm somehow. It's complaining about missing a bunch of packages, but the gatsby one is actually installed. Almost there at least.
The trick is to put the listener on the "#submit" button you have then fire a fbq('track' ... call. There is a fully working example below where a Lead event is fired when you submit button is clicked. [https://pastebin.com/4kMiX0dX](https://pastebin.com/4kMiX0dX) Depending on you form's behaviour, it may be best to attach it to when the form is submitted (e.g. after form validation passes - so for example, if someone does not enter their e-mail and hits submit it will still fire the event even if the form is not sent off). That is outside the scope of the question, but have a look at the working example above to do what you want.
You can try to create a `.npmrc` in the root of your project with this content: `shamefully-flatten`. Then remove node_modules and run `pnpm install` again. This hack should solve most of the issues I believe. glitch.com uses pnpm on the backend with this option.
You should take a look at Rollup. I use it now as I am writing Polymer code which works exclusively as you are describing, and it makes it very easy for me to use modules that weren't published as ES modules. It was also pretty straightforward to use
It looks extremely similar to lit-html. What are the differences and advantages?
I'm pretty confused about what this is. At first I thought it might be a validator like SimpleSchema or something, but... I'm not seeing how that would work. You say in the title that it's a "normalizer". I just don't really know what that means. Do you think you can clarify?
&gt; Is there any reason why I wouldn't go with Angular? 1. It's a relative pain in the ass to extract reusable libraries (see `ng-packagr`) from an Angular project. 2. Angular's AOT compiler often produces useless error messages. 3. JSX is both simpler and more powerful than Angular's template language. 4. Angular introduces a bunch of domain-specific concepts (e.g. pipes and resolvers) that (at best) provide no benefit over the simple functions you'd replace them with in a React app. I could go on.
True that. The best use case is probably when you need to extract multiple pieces of data. const { state, props } = this const { observable, computed, action } = require('mobx) But then again. For the second example I would generally use import.
I find Webpack confusing as fuck. Of course I'm an old-timer who's used to a .js, .html, .css file. (I think the docs on the Webpack site are pretty good though.) 
You don't, necessarily. But the bot doesn't read your package.json, it just looks for a license file.
The Typeahead &amp; Bloodhound combo is not for the faint of heart, but is super nice once mastered. I've forked your JSfiddle (and had to relink the typeahead lib) with a working configuration : your source is unchanged, the suggestion is shown if you type a keyword in any language, most of the suggestion data is shown but you have a function to change that. As a bonus I added the emptyText and suggestion click code I had. https://jsfiddle.net/2x6vd8w9/ 
Mo.js! It's lovely. Real easy to use, and there are a few decent tutorials out there. Let me know if you want a link and I'll DM you a link to the one I wrote!
It's called data binding.
Learning Webpack makes learning makefile a breeze.
You gotta learn Cmake now to make your Makefiles. 
&gt; Is the semantics of the word "imperative" really that important here? I think so because u/thisguyfightsyourmom asked specifically for the difference between imperative and declarative. But, I realize that you just kept the original word choice and I agree with your comments regarding the difference between the library and the tc39 proposal. I just want to emphasize that both the library and the tc39 proposal are equality declarative as none of them are imperative.
Fair enough, I'll edit my original post.
Another one: * Allowing Trailing Comma
Interesting that I had just watched this video last week: https://www.youtube.com/watch?v=GdJ0wFi1Jyo. What do you think about the point in the article you linked to? &gt; You cannot invalidate individual JWT tokens &gt;And there are more security problems. Unlike sessions - which can be invalidated by the server whenever it feels like it - individual stateless JWT tokens cannot be invalidated. By design, they will be valid until they expire, no matter what happens. This means that you cannot, for example, invalidate the session of an attacker after detecting a compromise. You also cannot invalidate old sessions when a user changes their password. &gt; You are essentially powerless, and cannot 'kill' a session without building complex (and stateful!) infrastructure to explicitly detect and reject them, defeating the entire point of using stateless JWT tokens to begin with.
Lol, this article can be shorten to ‘Object.defineProperty()’ :) I hopped for some rendering insights.
I took the exact same course, and loved it as a beginner, but it's missing most of the history and theory that makes things truly click. I recommend the Alicea, JavaScript understanding the problem weird parts, course next. It's excellent in explaining the how and why that makes javascript work.
This! If a developer is too dogmatic about choice of technologies I actually see that as a warning sign. Like they’ll never think like an owner and might have issues just getting stuff done ...
Thanks so much for this - spent hours trying to figure this out but as you said, typeahead isn't easy as a JS beginner 
It's believe what you have here is commonly known as [JSFuck](http://www.jsfuck.com/).
Agreed. It contains a significant amount of over explanation even for a novice user to come across it.
Thnx, you're right... now i just need to find a way to decode it in python.
Yeah good point. I'd probably also add hex/octal/binary as valid literal representations, and maybe a few more things basically just borrowed from JS. Generally, I'd prefer it if JSON configurations usually allowed you to run the JS engine on it and then JSON.stringify the output. This would allow for things like variables, environment variables, etc. The unfortunate reality is that this would be abused, so I understand why some of these features are not allowed in most scenarios, but a lot of tools allow you to just provide a `.js` file instead of `.json`.
All you need to know: !!\[\] is true true + true is 2 and so on !!\[\] + \[\] is "true" "true" + true is "2" and so on "2" + 1 is "21" \+("21") is 21, which is unnecessary because division would also work with two numbers represented as strings
That's why I linked the 2 documentation : you really need to read both and understand what each libraries does to link them together. Your code almost had it, apart from the 2 options arguments to the typeahead function which is something jQuery doesn't do often so people tend to be confused. Don't hesitate to fork my jsfiddle if you want me to check some other options &amp; usages !
i use JWT, and your right, there pretty fun to use.
Out of curiosity, how old do you think YAML is? *What* do you even think YAML is? 
It's JavaScript. You do not decode code of one language in another language. You can execute a node programm that runs this code from within you python code though. Also the syntax (and how JavaScript works) is very special and not really translatable into other language. 
Firstly, we should be doing every in our power to not let JWTs get stolen in the first place. This means using HTTPS, storing JWTs in the cookie, and dissuading users from self-xssing. We should also have measures in place to mitigate damages if a token is stolen. This means making the tokens expire after a set amount of time and requiring re-authentication before important actions are taken such as a purchase or a password change. The argument being made is that if a JWT is compromised, we should be able to invalidate it. With JWTs we can never truly invalidate a session without coming to a stateful solution. Instead, what we have to do is to make the contents of the JWT's payload worthless. If we know the *id* of the user who's session has been compromised, and if our JWT payload takes the form of `{ user_id, expiration }`, we can change the user's id, and now that JWT is essentially worthless because its user\_id references a non-existent user. 
Obligitory [beware](https://www.reddit.com/r/javascript/comments/6q2lk0/why_composition_is_harder_with_classes/dku34cl/)^1 [referencing](https://www.reddit.com/r/javascript/comments/5c5lkq/what_eric_elliot_wants_to_say_can_somebody/d9u6tv3/)^2 or [learning](https://www.reddit.com/r/javascript/comments/837t82/who_are_some_of_your_favorite_speakers_educators/dvh0br6/)^3 from Eric Elliott.
Cookies are secure against XSS attacks? Can't the attacker just get 'document.cookie' the same way they could access local storage?
Interesting, just out of curiosity my use case for JWTs/sessions approaches it from a mobile perspective. In which case cookies and XSS don't come into play. Does that change anything? Not with your last point, but with the first points? 
Yep, but those three specifically need to be numbers
&gt; !+[] Any ideas why this evaluates to true?
true, but it could save lines in function args ({ foo, bar, ["foo-key]:fooKey }) =&gt; { ... } obj =&gt; { let { foo, bar } = obj; let {["foo-key"]: fooKey = obj; };
[] is false, + turns false into 0, ! negates 0, which is false, to true
Thnx that’s what I ended up doing anyway
That is so useful 
Isn’t it just !(1)?
I figured that it would be possible to do stop motion style animations on the canvas with some for loops and whatnot, but I have to finish this very soon, so I'm looking for a library to speed up the process.
[PixiJS](http://www.pixijs.com/) is a good library if you are dealing with image sprites.
Lodash would be good for you.
Great point! This is something that I should have addressed in the article. It turns out that if we add an `httpOnly` flag to our cookie, then that will tell the browser to not allow the client to access our cookie. 
Are you saying this because you could pretty much do something like this: Object.defineProperty(foo, 'bar', { set: function(value) { _bar = value; someFunctionToRunWhenBarChanges(); } }); ?
I feel like the articles gives a _why_ to how reactivity works instead of simply giving the answer right away. I liked the fact that it explained the different problems before giving the solution (`Object.defineProperty()`).
The author explains the use of `defineProperty` in reactivity in the last part of the article.
Uhh... this is from the introduction of the RxJS docs.. \[literally\]([https://rxjs-dev.firebaseapp.com/guide/overview](https://rxjs-dev.firebaseapp.com/guide/overview)). \&gt; RxJS is a library for composing asynchronous and event-based programs.. \&gt; Think of RxJS as Lodash for events.
totally agree. There's also weirdness in yaml where you can link keys to other key / value pairs... it's just super weird for no good reason. It's the whole coffeescript thing all over again... there's a belief that it's making things easier, but it's just more hassle than it's worth. The comments thing is a good point but that's about it (this may not work for others, but you can always create a javascript file with your JSON like object, add comments, and then export that data, if you're in an architecture that allows you to import javascript files to get that data)
I use atom. I love it. If I didn't love it so much, I would use VS Code. Both are free.
Most of JSON's issues are addressed in [**JSON5**](https://json5.org). Would be nice if NPM would implement it since a lot have people have [**issues**](https://github.com/npm/npm/issues/3336) with the original JSON spec.
This "comparison" table is absolutely useless. They're both free, $0, use the MIT License and in active development. Okay then. Every Javascript framework has its positives and negatives. Use what you know, or what you need to learn for your job/project. If you don't know what you want to learn, pick one and proceed. With a solid understanding of javascript in general, picking up another "ramework won't be that difficult.
Oh I get that. I just thought it was too verbose. 🤷‍♀️
This is the dumbest thing I think I've ever seen on this sub.
The defacto normalizer, is "normalizr.js" It takes hierarchical data and flattens it. This means you have a single source of truth. I'll explain it with data, because it's easier. The function I have that "normalizes data" is called "flatten()". Now imagine you have two people, each one works for the same company and each own the same car. In JSON that may be represented by the company: const pepsiCo = { id: 1, name: "PepsiCo", employees: [ { id: 11, name: "Benji", car: { id: 111, name: "Honda Civic" } }, { id: 22, name: "jaman4dbz" car: { id: 111, name: "Honda Civic" } } ] }; Because that data is hierarchical, it doesn't have a single-source of truth, which means, if i changed the name of the car with id 111 to "Honda Accord", I'd have to change it in two places, or one of them would be incorrect. So we flatten the data, so there is only one reference to the car and all peices of data: flatten('companies', pepsiCo); //Result: { companies: { 1: { id: 1, name: "PepsiCo", employees: [{ id: 11 }, { id: 22 }] } } employees: { 11: { id: 11, name: "Benji", car: { id: 111 } }, 22: { id: 22, name: "jaman4dbz" car: { id: 111 } } } cars: { 111: { id: 111, name: "Honda Civic" } } } So now if you edit the name of car 111, you only need to do it in one place. This is a simple example, but most data people work with is highly relational, and tends to come from APIs that return data that is hierarchical. People who don't use normalization, essentially have to deal with updating all sources of a piece of data, or risk inconsistent data and bugs from it.
It was easy to add anyways
Hey everyone! After nearly a year in stealth mode we are finally opening up our new Serverless Platform to beta testers. We hope to support other languages in the future, but are focusing on javascript for now. The platform is all about simplifying the serverless experience so you don't have to deal with AWS CloudFormation or CloudWatch or Lambda, etc. We will take care of all of the backend details, so you can focus on building your app. Think of us sort of like Heroku, but for serverless apps. We would love feedback from the community, and if you need help getting started, definitely let us know.
Got it. Thanks for the information! I was under the impression that this would more accurately be described as "denormalization", in that you're associating relational data with the data it's associated with. So turning normalized (i.e. Properly relationed) data into denormalized (i.e. pre-associated) data.
Aha, makes sense. Ty
##r/learnJavascript --------------------------------------------- ^(For mobile and non-RES users) ^| [^(More info)](https://np.reddit.com/r/botwatch/comments/6xrrvh/clickablelinkbot_info/) ^| ^(-1 to Remove) ^| [^(Ignore Sub)](https://np.reddit.com/r/ClickableLinkBot/comments/853qg2/ignore_list/)
I guess this is still not a case for me where I think the lack of legibility is worth doing this.
You are doing this in the console. The `this` doesn't refer to the object. I don't this is the good way to test.
I fail to see why you can't simply do this: ``` let action; const copySearchQuery = (val) =&gt; { document.getElementById("searchQuery").value = val; }; const debounce = (callback, timeout, val) =&gt; { clearTimeout(action); action = setTimeout(callback(val), timeout); }; const keyup = (event) =&gt; { return debounce(copySearchQuery, 1000, event.target.value); }; document.getElementById("searchBox") .addEventListener('keyup', keyup);
Ah nice, good to know
Yes, upgrading from 4 to 5 will break code for 4. The same can be said for upgrading from IE6 to IE7 for websites made to support IE6. Progress and change cannot happen without breaking support for older, inferior products.
Might as well compare Angular to a potato.
Ya, it's a little weird, because with databases we're talking about the schema, but in my case we're talking about data. The name is because it's related to normal form, but it is certainly not the same as database normalization.
I wonder what would be the difference with [vuepress](https://vuepress.vuejs.org/) that seems to do something similar with some small customizations on the theme.
Try to write your own functions the way lodash functions work don't read it's source code it is way too complicated 
Yeah, but it doesn’t explain how reactivity works just how to observe properties :/ 
Holy shit. Multiline json strings! Pretty much the biggest reason I couldn't stand json for certain config usage. That and single quotes and trailing comma - the future is bright.
Wow - why have I never seen Object.defineProperty() anywhere before? It's so incredibly useful! I wonder how Vue figures out in the DOM where things like **&lt;div&gt;Price: ${{thePrice}}&lt;/div&gt;** are? Would the function $() just use "this.parent" to get the DOM DIV it's in? Then use search/replace the ${{}} text in div.textContent, and replace it with the result?
Cool ! But i think limiting the number of deploys would really piss me off at some point, esp if i were to set up a dev env with you 
You’re thinking about it in a more traditional DOM manipulation way, like jQuery or vanilla DOM API. Vue uses what’s called a virtual DOM to create and update the DOM using a function that creates elements using objects that represent the elements. I would definitely read up on it. For your second question, I’m not 100% what Vue is doing for the variable interpolation, but since you can do other valid JavaScript expressions besides just strings, like ternaries, function calls, etc. I would say it’s doing more than string replacement.
Thanks for the feedback! We do understand the concern and we are open to exploring other pricing models. We are not currently enforcing this limit while we collect data from our beta users.
Following. 
Aaaaah i see, fair enough! Is this noted on the site anywhere ? Might be worth making a point of 
Uhh ... so what? It literally fits the definition of a framework.
What features do you need? You could use just HTML canvas, depending on the level of abstraction you want. If you want a library, try Easel, Fabric or Paper. Want something with really fast performance? Try Pixi. How about SVG, for 2D designs that scale beautifully? SVG on its own is mature and usable. If you want a library, try SVGjs, SnapSVG or Paper. 2D on the web has many years of great support, and some fantastic libraries around it. Your decision on which to use, or if to build it yourself, will come down to the features you need.
Drastically smaller footprint.
It's also suited for chronological posts. 
The concept of software testing is same but the implementation of the work with the help of advanced tools like selenium, JS, etc, are different. I will recommend to do some online course and also there are lot of tutorials are available for [software testing](http://www.hitekschool.com/)(mainly for Js).
Looks like this [http://www.jsfuck.com/](http://www.jsfuck.com/) or this [http://jscrew.it/](http://jscrew.it/)
It’s quite complex process tbh thus there is such a perf penalty for it. General idea about vdom is to create dom (vdom) in memory, compare with previous one, “figure out” differences and patch. Patching is different depends on a change but it will go down to el.setAttribute rather then el.innerHTML = ... 
Wow, tough crowd. I found it helpful. 
Yeah it is helpful - title is just misleading a bit
yes,it's called serving a javascript file.
&gt; To get started, if you haven't already, create a free Azure trial account. Then go to the portal: preview.portal.azure.com. i thought there was no server? isn't it called "serverless"? /s
This is it. This is exactly what I was looking for. Thanks mv303.
sitio
I think we are all hoping (for your sake) that you're doing this for a personal or academic challenge, rather than it being a function in a legacy system you're converting 😀
I really hate seeing things like this - and no offence intended to OP as we don't know their motives for posting and this "which is best" thing happens outside of this post and this sub. You're developers, and developers should be pragmatic. We've done framework comparisons at work before and what we always find is that they're all good in their own ways and your choice of which to use depends on what you're trying to do - simple as. There are really interesting debates to be had about the varying approaches: opinionated vs unopinionated, fully featured vs lightweight, learning new tech vs going with tech you already know... have those conversations and the framework will choose itself!
Not going to defend webpacks complexity here but knowing your build tools has always been beneficial, in any language i've ever dealt with. I mean what's the alternative? Manual script tags &amp; managing scripts in a /scripts folder instead of npm, IIFE's instead of modules, globals instead of exports, cutting out parts of a lib you want to use instead of tree-shaking, gluing the distro together in a very specific order or else globals don't recognize one another. My hair stands up thinking of how much of a chore that was, back then i *wished* the web had a build tool instead of dumb concatenation tools. And i mean, go ahead and use script tags if you like to. But webpack, parcel and rollup do so many things right - must've saved a couple of months for me already that i would've spent doing manual chores otherwise.
It's possible to access the github API's from the client side. For example, their contents endpoint allows you to create a file; https://developer.github.com/v3/repos/contents/#create-a-file I don't know if it'll be a problem, but you might experience CORS issues if you're trying to access it from localhost. This can be solved by adding an entry to the HOSTS file on windows to map e.g. mydevbench.me to 127.0.0.1 - this won't be needed if you deploy to a server as the github API can be accessed on many endpoints from external servers without any specific needs. Generally speaking, you'll run into a lot more issues if you're just trying to load the local file in the browser - it's a sandbox environment and there's a lot of restrictions in place. There is a concern of the architecture though. Are you wanting to build a desktop client or something similar? In almost every situation, installing node is going to open a lot more doors for you. It's not just a server-side project but an entire environment for tooling, managing packages and yes, being able to host your own projects locally. You don't have to write server-side code to be able to launch a server - there's a package called `http-server` that launches a server on your machine for you without any coding needed. It's super-handy for testing and formed the basis of a lot of projects I used to build (nowadays I've moved onto react and the transpiling workflows which generally include a much better server package built around development, but it's a lot more management and totally unnecessary for small simple projects). If you find you need a server, I can honestly recommend digitalocean. Preinstall one of the latest node-ubuntu images they provide when setting up the server (it's about 3-clicks to install) and you'll be good to go.
You could try phaser.js or p5.js
what about TOML?
The lockfile is not manually edited, ever. It is nicer in code reviews because it has no commas and there are less diffs as a result. JSON5 with trailing commas would work as well. We may change the format in the future if the majority of pnpm users will ask for a something else
Vue turns everything you write into a so-called _render function_ - it evaluates your markup and variables and then returns whatever should be in DOM right now. Vue takes whatever is returned from the function and updates the DOM to match that. [On the Vue docs](https://vuejs.org/v2/guide/render-function.html#slots-vs-children) they show you the render functions that your templates are converted into. You can play around with it there, but it's basically just concatenating strings and the expressions inside the ```{{ }}``` moustaches inside a call to createElement. So this ```&lt;p&gt;Hello {{ showReddit ? 'Reddit' : 'World' }}&lt;/p&gt;``` turns into this ```_c('p', [_v('Hello ' + _s(showReddit ? 'Reddit' : 'World'))])``` where ```_c``` is the function that creates an element. If ```showReddit``` is ```true```, a &lt;p&gt; Tag containing _Hello Reddit_ is returned from ```_c``` and Vue writes that into the DOM. Now you change ```showReddit```, Vue is notified through the reactivity system, runs ```_c``` again, this time _Hello World_ is returned, Vue writes that into the DOM instead and your site is updated. There's a loooot more going on under the hood, but that's one of the basic principles (_describing what the DOM should look like and then updating it automatically, instead of manipulating it directly_) – go read up on render functions and virtual DOM if you're interested, it's quite cool! :)
There is no servers, it's in the "cloud"! 
What would be the scenario in which you would use the custom elements and shadow dom api over a framework like polymer? 
fair enough :)
Add to the above that it's also got really great integration with git. If you're anything like us, you have multiple branches open at any point, and they tend to have descriptive (read: long) branch names. Why remember any of them when I have a GUI to tell me what's available? If you're not using version management yet, that's fine too, but it's there for a time if you do decide to step into it. On top of that, they recently added an improved split-pane mode, meaning that while it was already possible to have files side-by-side (and multiple files in each pane through the use of tabs), it's now also possible to stack them vertically, or have a mix (e.g. left side can have 1 file group below the other, right side can have the same, and you can create just about whatever layout you need). Built in terminal with the option to have multiple open terminals in a single tab is fantastic too. We run several projects that require several tasks running before we can start to test or use them. Not having to have a third-party program for it has saved me countless hours. One of the big features though, is previewing web-projects inside VSCode. I don't use it often (primarily because it's not very clear on how to access it compared to the rest of the UI where features are super easy to find, and because a lot of my projects are react-native or backend node API's), but it allows you to view your end-product in a chrome instance that runs within VSCode, saving you the need to run another instance. This also ties in with debugging I believe. VSCode is a god send for development. The fact that it's free and open-source is another part of it. I used to use Notepad++ as I used to write code and push it to my own personal site via SFTP - it was quick turnaround but could have caused havoc if I pushed something that didn't work. This was before I used version control and didn't worry about things breaking (simple projects and a website that was very rarely visited). I did initially struggle to move to VSCode because it didn't have an SFTP module that was worth using at that time, but after some time refining my development methods, VSCode plays in perfectly with how I'm meant to develop projects. I'll be honest and say that I didn't think anyone was still using Dreamweaver these days.
2.1x larger (2536x2538) version of linked image: https://upload.wikimedia.org/wikipedia/commons/1/1a/Fra_Angelico_027.jpg ***** ^[source&amp;nbsp;code](https://github.com/qsniyg/maxurl)&amp;nbsp;|&amp;nbsp;[website](https://qsniyg.github.io/maxurl/)&amp;nbsp;/&amp;nbsp;[userscript](https://greasyfork.org/en/scripts/36662-image-max-url)&amp;nbsp;(finds&amp;nbsp;larger&amp;nbsp;images)&amp;nbsp;|&amp;nbsp;[remove](https://www.reddit.com/message/compose/?to=MaxImageBot&amp;subject=delete:+e2j7lco&amp;message=delete)
The good way to do this would be having regular authentication and then having a connection to Patreon via OAuth. That way, you are always aware of who is a premium member from Patreon, and it's a good exercise in writing a proper auth system
Recently, Apple broke input fields inside elements with their position property set to fixed, and this was done in a major release none the less, prompting a lot of users to upgrade to it. The fix was only released 3 minor versions later. Due to the classic fragmentation of users across differing versions of iOS, we had to provide solutions that didn't rely on position: fixed, and things like what OP is suggesting could be a way of solving that.
not quite – [] is truthy. +[] works out at 0, which is falsey, so !+[] evaluates as true I have no idea why +[] is 0 tho.
https://github.com/galvez/nuxpress -- like VuePress, but with Nuxt underneath, a tiny Markdown enhancement and chronological posts :)
I find this really interesting - I've always liked the idea of serverless but always found the admin too fiddly. I'll definitely try this out!
You probably still use `'use strict'` implicitly very often. For instance, any js script that's used as a module, will automatically force strict mode for that module. So if you use a transpiler to transpile those modules into usable scripts for the browser, that's how you get so many of those `'use strict'` in your webpack output. [Strict Mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) does a whole bunch of things for you. An excerpt from the above link: - Eliminates some JavaScript silent errors by changing them to throw errors. - Fixes mistakes that make it difficult for JavaScript engines to perform optimizations: strict mode code can sometimes be made to run faster than identical code that's not strict mode. - Prohibits some syntax likely to be defined in future versions of ECMAScript. As for your suggestion, I don't see how this would be useful. That's not to say that strict typing wouldn't be useful, but implementing it like this seems like it'd be very much an incomplete feature. There's a lot more to strong typing systems than simply never allowing type coercion, and altogether I think these changes would be too drastic to put in the ECMA standards. Code will look fundamentally different to the point that you'll see dozens of questions every day of people new to JS asking 'is this JS?' or 'what is this JS syntax?', and pointing to a simple variable type definition. If you're looking for strict typing, a much better approach is to use a tool like TypeScript or Flow. Not only is it clear that you're using something other than vanilla JS (such as through TypeScript's .ts files), but they also act like precompilers. This means that you can program in a strictly typed language as defined by the tool used (usually as close to JS as possible, but with added syntax for all the strictly typed features), and still receive vanilla JS output after transpilation.
Just having a slight issue trying to get remote working with JSON files and would appreciate any help. Basically, my JSON file has the following format [ { "name": "Hello", "alias1": "Hello", "alias2": "Bonjour", "alias3": "Hallo" }, { "name": "Goodbye", "alias1": "Goodbye", "alias2": "Au revoir", "alias3": "Tschuss" } ] However, when I search "Hello" or some variation of it, it returns both obj.name for the match and highlights it correctly, but also obj.name for the other objects. So it will show "Hello" first, but then below it, it shows "Goodbye". Is there any way to get around this? I'm assuming it's something to do with display: function(obj) { return obj.name; },
wait - so my service code lives in your github org?
What are you expecting constructs like `{@Position}` to be doing? That's not valid JS, so unless you run this code through a compiler or such, this will just cause syntax errors.
@Position sends through the hotel number. So 1, 2, 3 etc. So it becomes marker1. All works find on second time clicking it after map is loaded. My problem is marker1 is undefined when the user clicks on it first. So I need to get the value of marker1 variable once the map is loaded. All I have managed to do is send through the string 'marker1' .
&gt; Something like this would eliminate a very huge category of bugs from JS, and would improve the developer experience of JS by a lot too. This is something frequently claimed by strong typing fanboys, but to my knowledge there's no proof of it whatsoever, and many people who prefer weak typing may violently disagree. Personally I'm finding myself more and more drawn to strong(er) typing these days (especially in expressive languages like Ruby - Java was the worst possible advert for strong typing, and is many people's first experience of it), but that doesn't mean it's objectively better, despite what fanboys will claim.
**Lambda Mailer** \- GitHub: [https://github.com/adnanrahic/lambda-mailer](https://github.com/adnanrahic/lambda-mailer) \- NPM: [https://www.npmjs.com/package/lambda-mailer](https://www.npmjs.com/package/lambda-mailer) I wanted to add a contact form to my website, but didn't want to pay for, or manage, servers. So I built it with AWS Lambda and Serverless. I had so much fun building it, that I also published an npm module so other people can use it for their projects as well. :)
But what is it that's 'sending through the hotel number'? Is there some tool that parses this code and knows where to insert the correct values, or something else? I'm asking in this direction because it seems most likely that your problem is not JS related at all, but rather related to properly setting up whatever tool it is that can parse those `{@Position}` tags for you. So there's no use trying to come up with a JS workaround, you should just identify the problem in that tool and fix it there.
"use sttong" was already a thing https://groups.google.com/d/msg/strengthen-js/ojj3TDxbHpQ/5ENNAiUzEgAJ
The @Position is taken from the xml location here &lt;Hotel REF="1" Position="1" &gt; I'm using xsl. 
I always find golfing challenges interesting (I never participate, but I like looking at the answers). However, am I the only one that finds the golfing languages... pointless? Maybe pointless isn't the right word, but I feel like they aren't in the spirit of the challenges some how.
One book I can really recommend on algorithms is Introduction to Algorithms. Though it is not really a small book, it really grasps the entire spectrum you might need to know about. You can quickly read through the chapters for your interview and then learn the concepts thoroughly while having the job. 
Link?
Shouldn't you be using `this.state.Code` instead of `this.props.match.params.Code`? It is hard to read your code here, consider using triple "`" to format code. Also, you should remember that there are client side and server side routing.
https://github.com/zhenyulin/ultimate-hot-boilerplate
I wouldn't consider algorithms the same as problem solving per se. Some solutions can be trivial once you know how to solve them. If you haven't already, I'd suggest looking up tricky interview questions. Not language or es6/typescript related, rather logical ones, like this problem a friend once told me he was asked to solve in an interview: https://gpuzzles.com/mind-teasers/interview-marble-logic-puzzle/
Honestly my best interviews I spent less time talking and more time listening. Questions might arise but I shared my passion for what I did as well as my confidence with full eye contact. I have never not gotten a job after an interview unless I was offered a better position. Wish you the best... 
Thanks for sharing this. Very informative.
Ok I'm writing this on mobile so I can't properly format a code example. But let's imagine you open a piece of code you didn't write. There's a function in it that takes parameters. How do you know what types those parameters are? How do you use them properly? How do you avoid making a mistake because you're not aware of the proper API of those parameters? Strong typing being superior isn't just a fanboy thing, it is a fact. With strong typing code becomes infinitely more readable, and type based compilers like what typescript offers can catch type mismatch errors. Now this doesn't mean all bugs go away, far from it. But it does eliminate one type of bug and helps make developer lives easier.
`+` converts the value to a number. Since `[]` is false, false gets converted to 0. `+false` is 0, `+true` is 1.
I'm sure I can speak for many others when I say I don't have any experience with XSL. So I also don't have much knowledge about it either. My best guess for the cause of your problem, is that @Position is not being properly filled for you, or there's some other aspect in the connection between this XSL and the JS code that isn't working as you expected. As such, knowledge about XSL, how it works, and what you're expecting it to do for you are some of the important things to know here, in order for others to try and help you solve your problems.
I update the code to capture, can you see above please.
I love JWTs. I agree with some criticisms, and I guess if you're doing a standard web server where authentication and your application live side by side, it can be Overkill. But as access tokens to separate web services, JWTs are great. Just give them a short lifespan and require them to be refreshed, and you're good.
I agree that it is pointless. It can be a fun exercise, but it directly opposes what modern code should be-readable, maintainable, and easily modified.
You're coming back mate. Also, you can't expect to learn or grow if you try to destroy your mistakes. Food for thought. Opinions are cheap. 
The xsl portion of the code is working fine. My problem is the variable not defined at that point. What I want to be able to do is call it in the javascript when it is defined. I just noticed I forgot to add my getMarker function. This gives me the number of the hotel selected. So how at this point can I get marker = to the value in marker1 
Don't worry about TypeScript. It's very similar to ES6. The change will not be hard for you. Don't worry about algorithms. No one is going to ask you to find the shortest distance between two points during an interview. You may be asked to solve some sort of basic math or for loop problem, just to demonstrate that you know ES6. If you are as confident in it as your post suggests, you will have no problem with this, and it may even be fun. The most important thing is to show that you are _passionate_ about coding (not "this is just a job" mentality) and that you are _self-motivating_. What do you do when you don't know the answer to something? Learn the answer. What do you do when you have nothing to work on? Learn _something_. During your free time, they want an employee who is learning and increasing their value to the company; not someone playing on Facebook. Bob spends his free time texting his friends. Jill spends her free time learning TypeScript compilation optimizations, _just because she likes TypeScript and not because the job requires it of her_. Jill is the one who gets hired.
&gt; The most important thing is to show that you are passionate about coding (not "this is just a job" mentality) I don't think these things are mutually exclusive. Not to mention that you can go into something feeling like 'this is just a job' and find great passion for it. &gt;During your free time, they want an employee who is learning and increasing their value to the company; not someone playing on Facebook. OP, don't buy into this dogma. Do what you want with your free time. &gt;Bob spends his free time texting his friends. Jill spends her free time learning TypeScript compilation optimizations, just because she likes TypeScript and not because the job requires it of her. Jill is the one who gets hired. Really? Cuz it seems to me like Bob is someone who knows how to talk to people and finds value in building those relationships, which seems to me like a very valuable skill in this profession especially at an enterprise level. 
JavaScript simply is not strongly typed. The closest thing is TypeScript. Also, having developed in multiple languages over a long career, I frankly do not buy the whole argument that strong typing saves you from a whole world of bugs. It sounds like it should in theory, but in real life, it just doesn't, because I am used to weak typing, and I instantly get the problem in the rare case it does cause a bug.
*beep beep* Hi, I'm JobsHelperBot, your friendly neighborhood jobs helper bot! My job in life is to help you with your job search but I'm just 302.6 days old and I'm still learning, so please tell me if I screw up. *boop* It looks like you're asking about interview advice. I'm ~35% sure of this; let me know if I'm wrong! Have you checked out CollegeGrad, HuffPo, LiveCareer, etc.? They've got some great resources: * https://collegegrad.com/jobsearch/mastering-the-interview/the-eight-types-of-interview-questions * http://www.huffingtonpost.com/rana-campbell/10-ways-to-rock-your-next_b_5698793.html * https://www.livecareer.com/quintessential/job-interview-tips * http://people.com/celebrity/worst-job-interview-answers-askreddit-answers/ * https://www.thebalance.com/questions-to-ask-in-a-job-interview-2061205
Yeah I think yaml makes some sense for this for the reasons you're saying. I'm just criticizing its use more generally, in response to the comment I'm replying to. As far as I'm concerned, I never actually review the lock file (though I do commit it), so it might as well be binary
I didn’t appreciate the trickery
The profile lookup challenge uses very basic methods and is relatively simple, but depending on where you are in terms of learning it might prove difficult to understand where to start when reading about a problem. Are you sure you're at the stage of taking on challenges that are not guided yet? As the very basics of JavaScript, I would expect you to understand the \*basics\* of objects, arrays, strings and numbers, simple for-loops and if-else structures. This might seem like a lot, but you're not ready to build any sort of functionality without at least those tools in your mental toolbox.
Im just guessing since there is some information missing but but assuming you're using react router is your component the route component? If it's not you have to pass match to it or use withRouter. Also does the react route have the /:Code on it's path? 
1) show up on time. If you are running late, call. 2) wear nice clothes. 3) bring a copt of you resume. Have dates on it. 4) have some code samples. If you have a github full of practice examples , or tutorials, its not as good as ant single personal project seen through to completion. I could care less if you have a github at all, as long as ypu can show me *something*. 5) ask questions. Be personable. If i have to work with you for 40hrs+ a week, then i'd rather a teachable person whoe works well with the team than a genious hotshot who makes everyone uncomfortable.
Thank a lot :)
That's a great tip thanks 
Great advices thank you. Especially the last one. The interviewer told me they are looking for somebody good at teamwork.
&gt;This is the route : `{ path: '/clients/viewclient/:Code', name: 'ViewClient', component: ViewClient}` &gt; &gt;When, I put `Code: this.props.match.params.Code` , on the constructor : constructor(props) { super(props); this.state = { clients: \[\], Code: this.props.match.params.Code }; &gt; And : componentDidMount() { axios.get('[http://localhost:4000/app/viewclient/](http://localhost:4000/app/viewclient/)' + this.state.Code) .then(response =&gt; { if (response &amp;&amp; [response.data](https://response.data)) { this.setState({ clients: [response.data](https://response.data) }); } }) .catch(error =&gt; console.log(error)); } I get `TypeError: Cannot read property 'Code' of undefined`
no, [] is not false, nor is it falsey. try running: [] ? 'I am truthy' : 'I am falsey' the unary plus operator only knows how to convert strings, true, false and null. when it encounters something that isn't one of those, eg an array, it first converts that thing to a string, and then tries to convert that string to a number. so when it sees +[] it interprets it as +([].toString()) = +('') = 0 
That solves type mismatches but doesn’t necessarily help you use the function since you still have to know what the parameters mean and how they relate to each other. That requires that you read the documentation or the code.
I'm not a lawyer, but has customer 1 been paying you to develop that code? Does that mean they own the code? Ignoring that - At this point, you'll probably want to not change what customer 1 has. Copy-paste the app into a new repo and start modifying it to match what customer 2 needs. But here is the thing, EVERYTHING you change should be written in a way that can be changed by setting a variable/config. Then you do the same thing for customer 3. By the time you have integrated customer 1 into your new 'White Label' app, it should be pretty solid.
There are a lot of good points here that translate well into great general rules, like *Never expose implementation details in your API design* and *It's easier to add fields than to remove them*. Although lengthy, there is a valuable wealth of information derived from in-the-trenches experience.
You’re right, my bad. That does make the whole thing more magical seeming 
&gt;Minty town-down shooter game link is dead.
Thanks for the response and for the callback args bit too! Is there a way to not have action pollute the global namespace? 
You're totally right. Edited.
Unless you're good enough to write self-documenting code ;)
These are good. A cautionary tale about #2. Yes, don't come as a slob, but also don't dress up too much. Dress for the job. Know what' you're getting into and what people that work there are like and dress a bit above and beyond that, but not too much. We had a guy come in with a full suit and tie for a developer position and one of our interviewers vetoed him because how he dressed. We work in a very casual atmosphere and his attire gave off the wrong vibe (especially to this guy) so it ended up counting against the poor kid getting interviewed. I thought he ok, but nothing stood out to me that I could use as enough fuel to counter the dress complaint. To the credit of my colleague, he didn't just look at the kid and right away say no. He gave him a chance, but I specifically remember that as a point against when we discussed his performance in the interviews. 
I'd rather implement a schema in postgres and then point [postgraphile](https://www.graphile.org/postgraphile/) at that. This seems like such meta programming it makes my head hurt thinking about it.
Shout-out to /r/CodeGolf! It needs some love.
Exactly, and that's why I love it. From 9-5, I can't be clever. I shouldn't abuse the language. I need to make the code easy to read and debug. I'm writing the code for the sake of others, not just myself. It's like being a painter but constrained to a simple offering of brushes and a very limited color palette. Code golf is what I do for fun. It's being able to use any instrument and color available to paint with. I don't have to worry about if anyone else can understand it (not even myself). I just have to make the output congruent.
So where you say: showInfoWindow(map, marker{@Position}, hotelDetails{@Position}); You're calling the JS `showInfoWindow` function with 3 arguments. The second and third argument contain XSL variables which are resolved upon compilation, resulting in actual code like this: showInfoWindow(map, marker1, hotelDetails1); Now, this `marker1` is actually supposed to be a variable name? And this variable is not defined when you first click the link, but is defined the second time? So then my question is; why are you passing it the first time? Could you not use a different event handler for the first click, and then replace it with this one for the second and further clicks? With two distinctly different things happening on 1st click vs other clicks, two separate functions for this seems logical to me. --- That aside, there's a couple other things I can point out that may help point you in the right direction. For example, the way I understand it you'll have variables like `marker1`, `marker2`, etc. That clearly smells like an array-like structure, so could you not define `marker` as an array, and then access elements like `marker[1]` etc? Tieing into that, what varies in the variable name upon calling is the number you get from XSL. If the variable is not defined at this moment, you could also pass just this number `1` as an argument, instead of the actual resolved variable `marker1`. Then the function you're calling will be responsible for converting that into the actual value you want. The above array suggestion helps here, as the function can just do `marker[markerID]` with `markerID` holding that number `1` from the function argument. This will put the function in control, so it can delay this lookup until it knows the value is defined or something like that. I hope this gives you some clues on what you want to do. If none of this helps though, then you really gotta add more details here. I'm still missing a large part of the picture here so it's pretty hard guessing what the hell you're even trying to do. More code samples = better, just make sure they're formatted via reddit markdown or some external code sharing site or such.
I wrote this as a guide to help anyone understand all of the how to setup Webpack and Babel configuration files as well as an explanation for each of the various Babel dependencies newcomers are bombarded with: babel-core, babel-cli, babel-register, babel-preset-env, babel-preset-es2015, babel-preset-es2016, and babel-preset-es2017, babel-preset-latest, babel-loader, and babel-preset-react. If you would like to make a suggestion or modification, feel free to let me know and I can make the change/modification accordingly.
I guess I see that. That same spirit is why I like messing around with brainf*ck in my free time 😂
Ok
&lt;joke&gt;Talk to sales people why cash flow isn't great ;), after all you are in this spot now because of their ideas &lt;joke/&gt; But taking this seriously, have You consider to do profiling of existing app, doing benchmarking, trying to refactor existing codebase without changing all tooling around it? What is bootleneck in Your App? Frontend/Browser? Backend/Database Queries? Without those information wild guess about changing framework cannot predict outcome of Your rewrite. Small incremental refactors make a lot more sense in Your position rather doing big rewrite. Try to plan refactor including your profiling findings and making sure that refactor is achieving Your goals by measuring per sprint Your performance gains.
I love seeing what different people are passionate about.
I'm glad large companies are stepping up. I hate the recent trend to have individual developers financially support OSS.
We are hoping to nail down some of the specifics during the Beta and communicate those guidelines. For now, we are trying to help our Beta users ship their products, and are not trying to impose overly burdensome restrictions.
Phaser.
You should really re-format your comment to use “``` ```” around the code, it makes it much easier to read. It ends up looking something like this instead: ``` import React from React; class Thing extends React.Component { render() { return ‘Much easier to read!’ } } ```
Cool. Is this an "instant" style transfer variant? How well does it work with large images?
Yep, that's a big deal for me too.
Something happened to your formatting.
I mean, to each their own, but what you’re describing is not really relevant to the article. 
I spend a great deal of my days manipulating data arrays into a form suitable for data visualisation, my favourite method is therefore map() https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map Rather than looping over arrays map makes transforming arrays into new structures much easier!
yeah could I get some uuuuuuuuuuuuuuuuuuuuuuh code formatting?
Array modification functions like [].filter, select, find and so on. 
&gt; Never expose implementation details in your API design and It's easier to add fields than to remove them. Like linking your API directly to your database schema?
Please share your project in a way where we can see all the relevant code. From your other posts, it seems like you hit server route /app/listeclients and render a list of eclients. From that ui, you can go to a route /clients/viewClient/:Code (where :Code has been substituted with the Code from the list item, but you haven't shown us this part, which is the most likely part where it is not being passed properly) Side notes: - RESTful APIs would have GET /eclients (list eclients), POST /eclients (add eclients), PUT /eclients/:clientId (edit client), DELETE /eclients/:clientId - similarly for client side routes - You might prefer BrowserRouter to HashRouter
Yeah, I've seen this one used a lot but haven't played around with it. Definitely need to look into it...
Oh, nice, thanks! I haven't played around with a lot of those yet.
Once you understand them you reduce the amount of for loops you write by 50%
To address your question "how to pass req.params to frontend", normally you would use the result of a backend call as input to your frontend, not the the input to the backend as input to your frontend
That's a great way to get an API that works and lets you quickly get at the whole model. If you're designing an API for serious use though, this isn't a great way to get a clear or intuitive API that's going to be nice to use. As an API consumer, you often want to think about the data in a different way to how you'd think about it when designing a DB schema, and autogenerating the API from the DB tends to tie them together. The article touches on this in [Step 2](https://gist.github.com/swalkinshaw/3a33e2d292b60e68fcebe12b62bbb3e2#step-two-a-clean-slate): &gt; Our implementation defines the existence of manual and automatic collections, as well as the use of a collector join table. Our naive API design was clearly structured around our implementation, but this was a mistake. &gt; &gt; The root problem with this approach is that an API operates for a different purpose than an implementation, and frequently at a different level of abstraction.
This is one of the reason rest APIs “fail”. They just expose the database schema. Your clients don’t want to make half a dozen calls to construct your data model every time they want to do something. 
I find myself often using the call() and bind() methods to avoid to write "var that = this". My favourite methods are the Array methods though. I especially like forEach() because it's much cleaner than the classic oldschool loop that becomes even more ugly when nested.
Well so, the people that have been writing it and working on it for many, many years disagree with you on both points above (similarity to lodash / framework vs library). I must have a different definition of framework than you. I use rxjs like a library all the time.. just sprinkle it where its convenient.
sorry, fixed it
The information and enunciation are good. Your voice itself has a slowly slow and downward ton towards the end of words or sentences. This makes you sound tired or bored. Try to smile and think energetically when speaking.
&gt;OP, don't buy into this dogma. Do what you want with your free time. Dogma is right. You can be knowledgeable and self motivated without spending every waking minute balls-on-screen. The company that EXPECTS you to live and love the job is the company you don't want to work for. You'll go in, day one, with expectations beyond the job jhat you interviewed for. And saying "I can't make it on Sunday, I have a family thing" will result in a ding and be the excuse for lack of promotion "you don't seem dedicated".
Good bot.
99% in my case
go through technical interviews
I don't think there are any methods that are 100% accurate, but I generally find that people with low skill in Javascript are those that are still learning the basics of the language as well as commonly used objects and their methods. Medium skill as those that know the basics of the langauge and are starting to get into more fringe features of javascript as well as understanding the more confusing parts of the language like `this`, prototypes and implicit conversions as well as starting to learn popular frameworks/less common objects and their methods. High skill is when you start to worry less about technically solving a problem and start to think more about optimal ways of writing code for both technical performance, but as well as logical understanding and ease of use for future devs.
Awesome, I'll take a look into these as well. Thanks!
Arrow functions have almost eliminated the need for .bind() in my code. Especially in react (native) with babel-transform-class-properties
I'd add to that high skill: - being able to talk about why you did something a certain way over some other way - structuring actual application (&gt; 50 routes or something with remote data access (REST, JSON:API, and GraphQL, the tradeoffs for each) - understanding why js on the backend can suck, and ways in which it might not in certain scenarios - good quality tests - not brittle. - quality of style implementation with respect to component design I know some of this goes beyond javascript, but it's still all very important.
Why not console.log(A)||A
My comment certainly over simplifies it. I think overall my intent was to indicate that low skill is still learning, medium skill is knowing a solution to the problem and high skill is knowing the solution to which of many solutions to solve the problem with.
I'm hoping you can help explain something to me. When you say Arrow functions, you mean you have code like this correct:? class MyClass extends React.Component{ click=()=&gt;{ //this runs without any bind } render(){ return (&lt;div onClick={this.click}&gt;my div&lt;/div&gt;) } } My question is.... I for some reason thought we weren't suppose to do it like that... like... it wasn't ready to be used yet or supported in React. Is it now safe to always do this? I hope this isn't confusing what I'm getting at. The reason I ask is because you said especially in RN, is that because there are support problems with React or have I imagined this limitation from my own context. 
You can see here the complete code : [https://github.com/IchrakMansour/Brillo.git](https://github.com/IchrakMansour/Brillo.git) but we interest just a `Brillo/src/views/Clients` 
http://sijinjoseph.com/programmer-competency-matrix/
&gt;I don't think these things are mutually exclusive. Not to mention that you can go into something feeling like 'this is just a job' and find great passion for it. When people use the phrase "this-is-just-a-job mentality," They *mean* *precisely* that they don't find passion and enjoyment in it, but they do it because it pays the bills despite their lack of passion. At least, that's the meaning implied by Charles\_Stover. So those mindsets are mutually exclusive. &gt;OP, don't buy into this dogma. Do what you want with your free time. Again, you're missing the point here. Of course people should do what they want with their free time. But a person who *wants* to code in their free time, at least with some of it, is going to be a more desirable candidate. We're not talking about people who are pretending to want to code in their free time, which is how you seemed to have interpreted that. &gt;Really? Cuz it seems to me like Bob is someone who knows how to talk to people and finds value in building those relationships, which seems to me like a very valuable skill in this profession especially at an enterprise level. Now I think you've become the one who is making a mutually exclusive statement. People who enjoy coding for the sake of coding and even might do it in their free time is unable to have friends or social skills? Everyone should have balance in life, and that should include time with friends. But that has nothing to do with the difference between person who would rather do anything else other than coding, except when she has to at work, and never has a desire to learn new things, compared to the person who enjoys coding and learning and getting better, and even enjoys working on some side projects on the side in her free time. Either could be balanced or unbalanced in their social lives. What they do in their free time has nothing to do with that. No one said that a person who enjoys learning and improving and coding even if they aren't getting paid for it is unable to balance that with a healthy social life. 
How to use the result of backend call as input to my frontend please ?
I think when you stop worrying about how good you are then you are probably pretty competent.
Are there any benchmarks or ways of testing competency, out of curiosity? I'm self-taught but also do it recreationally so I'm not going to be applying for interviews or anything as a way to gauge skill. I'd like to think I'm following a good model of building extensions inside Adobe programs from scratch, but also wouldn't mind course-correcting if I can find out I'm approaching things from a lazy, sloppy, or inefficient way.
Proposals to the ecmascript standard have to go through 4 stages to be officially included in the next release. ES2015, ES2016 and ES2017 are examples of releases. They contain multiple accepted proposals. As soon as a proposal hits stage 4 it's 100% safe to use. Stage 3 is considered pretty safe as well. What we're doing in the earlier comments is covered by the class fields proposals. [This one](https://github.com/tc39/proposal-class-public-fields) was merged into a [more complete proposal that also includes private class fields](https://github.com/tc39/proposal-class-fields). It's currently at stage 3. I consider it completely safe to use but some may not.
Yup. Learning to problem solve is not the same as algorithm. For example, finding out your code runs more efficiently by following the DRY principle is not an algorithm. Problem solving is usually more the employers ask for, and for algorithm it could come up during the interview, such as writing a pseudocode for sorting. Generally, they’ll present you with a piece of code and you go through with them on how to refactor it or resolve it. Don’t worry about not knowing the syntax or keywords, the key thing is how you approach the problem and what you’ll do to improve it. Speak your mind, and guide them through your solution. This way they can interact with you. Never be afraid fo ask them questions. An open minded developer is much easier to team with.
Can’t you minimize that in postgraphile by using functions/stored procedures to do that work? Those get exposed as queries/mutations quite nicely.
wow thats a mouthful answer! Thank you for taking the time. Hmmm I was under the impression that arrow functions and etc get polyfilled with babel. I'm still very new to React and trying to understand it better. i'm using the create-react-app. Is this not the case? So this isn't necessarily an issue with React but Javascript correct? 
It's been done before. Definitely get an understanding of es6 first but it is learnable. Depending on the project you can also learn on the job. React fundamentally won't make much sense without es6.
If they ask you to do a whiteboard coding question, ask them some questions before you start coding to make sure you understand the scope of what they want you to do. Then, as you start working through it, talk through your thoughts out-loud instead of coding in silence. Also, if you enjoy coding and learning about it, then things will work out for you. If not this job, another one. You'll be fine.
I'm not sure of any surefire way to test competency, especially in adobe extension development. You'll only know for sure that you're on the right track when you're either writing the best practice for the industry, or are following those that do. I'm not sure about who the big players are in the adobe extension world, but it would be beneficial to look over their work and see if there is anything they do that you dont understand or aren't sure how to do and then fixing that. 
There are pros and cons to this. There is no wrong answer. Do whatever gets you further in life. Sometimes the pros outweigh the cons, sometimes they don't.
In my experience, the domain model hardly maps directly to the physical (database) model in non-trivial applications.
Arrow functions are an example of language features that are already included in the ecmascript standard, but some older browsers doesn't support it. They were included in ES2015. In order to make code written with arrow functions run on older browsers, a transpiler like babel is used to convert modern code to older code. Class properties on the other hand, is an example of a language feature that is not yet included in the official language. In order to use it we HAVE to use a transpiler like babel, because no browser supports it. And in most cases we have to use special plugins for the transpilers, like [babel-plugin-transform-class-properties](https://babeljs.io/docs/en/babel-plugin-transform-class-properties/)
So I'm not able to indent so I hope you can easily read what is going on
I highly recommend to learn JavaScript foundation first and make some small app. If you feel you are comfortable with JavaScript, especially with ES6, then jump into React őr other framework. I do the opposite, when I worked in a small company during my university. I had to work in Angular and before that I don't write a single line of JavaScript, after a hard time I learned, but it could have been a lot simpler.
String.charCodeAt() is called on the string you want to examine, with one param: The character index in the string. So what you want to do is document.write("Pos[0] = " + strSplit.charCodeAt(0) + "&lt;br&gt;"); document.write("Pos[1] = " + strSplit.charCodeAt(1) + "&lt;br&gt;");
By the way, start a line with 4 spaces to write code like this
Thanks for taking time to explain this, I understand better now. 
JavaScript is not a language that imposes much structure on you or your code. You can do things many different ways, and, if you are not careful, you can be very sloppy. So, one of the hallmarks of being a great JS programmer is discipline. Discipline for not being sloppy. Discipline for knowing which parts of the language you should use, and which you should not. Take some examples. You should have your go-to ways of dealing with many different common scenarios. You should be able to immediately tell how to deal with them. Examples include: * How to deal with event callbacks * How to break out of callback hell when you don't control the API * How to create a module (out of the many ways of doing so). Why did you choose that method? * How to create a class (out of the many ways of doing so). Why do you do it your way? * How to structure the public interface of your class. What aspects make up the public interface of your class? * Do you write functions whose inputs are taken directly from the output of some other function or process? (Bad!) * Do you write APIs with poorly specified input arguments? Output values? Professional JS is CHOCK FULL of these examples and they are universally bad. * Do you make sure to use EVERY variable you pass into your functions or methods? (God objects are the BANE of JS) This is just a small list of things to watch out for. JS is full of these landmines. It is very, very easy to write code that works in JS, but is very difficult to maintain or build on.
&gt;const test1 = strSplit.charCodeAt(0) - 97 That is giving me an error right off the bat. I'm using an Online Editor ([js.do](https://js.do)) but it is telling me, " **JavaScript error:** Uncaught TypeError: strSplit.charCodeAt is not a function"
I’ve found React and Vue much easier to grasp now that I have a better understanding of programming and JS.
student here... what do you mean by "never expose implementation details in api design"?
thank-you so much I got it
are you ready for your guide to be outdated in a week? (sorry, spent the past weak dealing with package crap across multiple projects instead of writing code)
"Ultimate" is a strong word, and there are a lot of small things missing like the differences between production and development code, for starters. 
Sure you could, but my point was people don’t. They do like the OP suggested and just do the minimum without thinking about real world usability of the API. 
I don't have much more to say than that this looks just amazing😍
&gt;ease of use for future devs I like this - it's when you realise you can do clever shit, but don't, 'cos it's a pain in the arse for other people. In my experience it's usually anything anyone on stack overflow describes as 'succinct'.
&gt; Do you write functions whose inputs are taken directly from the output of some other function or process? (Bad!) What's an example of this? Like if I want to calculate a function with the date string input, is passing myDate.toISOstring() as an argument bad form? What's the correct way to do it?
I do think I understand the basics now, and I feel like with what FCC has given me up to that point was a little more difficult than most people's ablilites at that time in the course. Now looking back on it, I think it's just growing pains that comes with learning how to program in your first language. From what I've read, for a lot of people, it's easy to understand basic topics on a surface level, however when it comes to applying them for the first time, it's really difficult. I really appreciate the response though! 
You should consider moving to ES6
O_o What a bizarre question It's like asking "what's your favourite key on the keyboard"
Well, now I want to know what your favorite key on the keyboard is...
LOL by the time you have finished rebuilding it GraphQL / React etc are not going to be "safe" anymore.. Seriously though, I don't understand how you have time to rebuild everything but yet you don't have time to refactor what you've got? Although not my stack of choice there's nothing wrong with Meteor. Unless you have specific problems that cannot be solved with Meteor (you didn't mention any, so I guess the answer is "no"), I would start moving towards a microservice architecture and bit by bit shift bits away to a new system, but keeping the main core there.
What coming out in a week? Haha I like to call that dependency hell
Go for it. The best part about React is that it's mostly just JS. So you'll be writing a lot of normal ol' JS, just within a React context.
Yeah, applying knowledge is typically the hardest if you've primarily read about it. Remember that programming is equal parts science as it is craft, and you need to practice the craft part equally along with the science, or you'll end up with a ton of theory without any idea of how to apply it. Good luck in the future!
OH NOT THIS FUCKING LAME JOKE _AGAIN_
no
`Proxy.revocable` Because I think it's funny.
or ease of use for yourself one year later. "omg. what did I do"
or have an over-inflated sense of purpose and skill
Where does this.props.match.params.Code come from? Is the props passed from another class?
&gt; two.js &gt; modern You mean the two.js which is based on underscore and backbone? :thinking_face:
[obligatory stack overflow](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454)
In fact, I am newbie on ReactJS and I try to use the result of backend call as input to my frontend on putting this.props.match.params.Code , I just want when I click on button view, it redirects me to get more information on the row, you can see the complete code here : [https://github.com/IchrakMansour/Brillo.git](https://github.com/IchrakMansour/Brillo.git) just we interest a `Brillo/src/views/Clients` and I don't know exactly how to use the result of backend call as input to my frontend.
ESC, without a doubt
Looks like your in a nice mood ♪(┌・。・)┌ 
Mention some things you want to learn about and improve on, that you know you'd learn about there
The real joke here is this fucking lame "serverless" buzzword.
I knew I would find it there as the very first comment.
You either aren't talking about postgraphile, a graphql database server, or you have no idea how it works.
Yeah i know but you can use RegEx to select single tags (open, close, empty) when combined with JS, PHP or whatever, you can achieve what you can't with RegEx alone. I was tinkering around with this for a while and thought this might be useful for someone.
Sorry but the name really puts me off
Depends on what direction you want to go with it, but I'd suggest wrapping your head around callback functions sooner rather than later If I'm being honest though, if you've got a 'basic understanding' of functions and loops your next best step is probably to get a 'strong understanding' of functions and loops. Just keep writing code, I guarantee you'll learn something from it.
I quickly got a much better understanding of JS by learning React. I’m not sure how I would have learned JS all on its own without involving any libraries like React.
I'm glad you brought this up, because it is a great example. It is so simple, yet we can learn so much from it! So, first off, we have a function that takes a date string as input. You want to pass it toISOString. OK. But why an ISO formatted string? There are a large number of ways to format a date. Who says it should be in ISO format? What if the function wants it in MM-DD-YY or YY-MM-DD or MM-DD-YY or MM-DD-YYYY? So many ways to format a date. If this is a user-facing rendering function, it is best to let the locale decide. Also, why is this function taking a date STRING as input? What if you pass it a junk string? What will it do? If the function wants a date as input, it should be a real Date object, not a string. That way, it can interpret the date any way it sees fit, including letting locale specific behavior influence rendering if that's its ultimate goal. The fact that the function takes a string date though is code smell. It is almost certainly a sloppy API. It could mean it expects to get a date from a user-input form, or a JSON return value from an external source, or somewhere else. In this way, it is an example of an API designed with the output of another function in mind when this function's definition was created.
Be self confident and show that you love to code! Don't be nervous, if it doesn't work out, the next one will :-)
Postgraphile let's you add computed columns, custom queries, special types and the whole shebang. It's basically just modelling the data inside postgres as opposed to doing it in a separate layer. The biggest benefit? A agnostic backed with all the special queries you need already built, regardless of how you move to production. I think people just aren't aware of what features it's implemented.
I’ve never heard of a graphql database. Please explain. 
lolno Solving stupid code golf questions don’t make you a knowledgeable or skilled programmer.
Server, not a database.
Much of an interview will be judging you as a team player. Both on a social level (don't be negative about past experience, find a balance between presenting yourself in a good light and sounding arrogant) and on a practical team interaction level and project development level. Have you worked with source control? Git? Github? Have you tested your code? Do you write a good and readable code?
Touché. I meant by this that this is a more recent lib than classical ones such as Raphael. But well, this is subjective. What's important is if they seem maintained and fit to the OP need, isn't it?
Babel X, things weren't modular enough so now they're making each function a separate dependency.
Thanks for the great response. I appreciate it. I think you nailed it with that last paragraph. 
Is it easy to horizontally-scale a postgraphile service?
You mean by adding servers? I got a setup in nginx that just targets dockerized containers. I'll admit I have no idea on it's performance at scale, but if you can cluster a postgres server, you can pack the postgraphile server with it.
I was in that exact position last year. I say go for it outisde of JSX react is pretty much just regular ES6 JavaScript. 
If you had read the post, you'd know this is exactly the main problem the article is trying to solve
Thank you for the advice. Programming on a daily basis is the way to go then. I should just work on mastering and fully understanding the fundamentals and that will guide me the through the rest. Incase this helps, I am looking to develop for ecommerce. 
It's probably a tie between End and Home.
You'd think that the really big players like FB, Google and many others etc would step up and sponsor a critical project like this - it is literally less than a drop in the ocean for them and they have tons of devs using this daily (and likely contributing to it).
I agree but I would still call it a loop, it's only downside is performance and early termination. 
Same question, where do you expect `this.props.match.params.Code` to come from? I assume you're trying to get `Code` from a RESTful call, but what is the name of that? FYI, from a OO point of view, this `this.match.params.Code` is not declared anywhere within the class. You're trying to access match object but it doesn't exist.
How to get `Code` from a backend ? how to resolve that ?
the problem of having your schema together with your database and not reinvent your schema? sounds like a made up problem only solvable by left-pad
You can use axios, if it's a RESTful call.
 axios.get('[http://localhost:4000/app/viewclient/](http://localhost:4000/app/viewclient/)') ? 
This is from node but util.promisify. Turns any callback signature to promise signature.
It's a bit like c#'s (and I imagine other languages) .Select() linq method. Super useful if your companies data structures are crap and you need a UI friendly data model
The money is nice but the developers contributing to the project is arguably better than a donation. That’s a contribution that goes directly to the software.
Actually, Microsoft probably uses more React than Angular. They are using React for the next version of Outlook Web App. Also the component library for Office 365 (Office UI Fabric) is based on React. 
Trial and error
You are thinking about this all wrong. 
I have a Postgres database server, it’s a program that enables me to connect to a Postgres database. Are you saying your “graphql database server” is different?
i'm confusing the matter. Whatever you're talking about it's not [postgraphile](https://www.graphile.org/).
JavaScript then TypeScript. Skip CoffeeScript altogether imho.
Why do you think I should skip CoffeeScript, it seems to me that it makes development time faster no?
Size of job market for JS and TS are larger. TypeScript’s type-checking speeds up development more than a little syntactic super will, especially when working with large codebases. Fewer errors, less reworking.
What’s a popper?
Not entirely sure why I got a downvote, but thanks for the answer. Do you know what static type checking means? I've seen that mentioned quite a bit with TypeScript.
Sure, but your server is already running and you can just state the path instead. get('/news')
Types are known at compile time opposed to runtime.
Learn python
&gt;is it worth it to start learning these instead or just vanilla javascript No. Learn Javascript or TypeScript instead of CoffeeScript. CoffeeScript is a preprocessor, and until you can explain in one or two sentences what that means to someone who doesn't program, you shouldn't be using it.
I just looked it up. Seems pretty good. Mind sending me your tutorial?
JavaScript. Since you're young and have the time before you enter the job market, look in to Elm as well. 
CoffeeScript was a child of its time. It's now obsolete. The good features were rolled up into JS itself and TS, and the bad features... as you were told, it's best to skip that. 
While I think I can use python for front-end development similar to JavaScript(I'm sure a framework like that exists), why would I use that over something more universally used than JavaScript?
weekly vue jerk article
JavaScript is the language of the web. If code is running in the browser (not accounting for help from plugins like used with the Java programming language), its basically always going to be JavaScript. Most web development uses JavaScript, but there are variations including supersets of JavaScript which are languages that are JavaScript plus other things added in. This is what TypeScript is. It is JavaScript with typing information - extra code added to scripts to identify what kinds of values variables and the like hold - and a few new language features like decorators which are not yet officially part of JavaScript. TypeScript is no more closer to C++ than JavaScript is, though C++ also has types. C++ types, however, use a different syntax. TypeScript is closer to ActionScript, the language used for Flash. ActionScript was very much like JavaScript but had types - the same typing style that TypeScript uses. // JavaScript var num = 1; // TypeScript var num:number = 1; // ActionScript (Flash) var num:Number = 1; Even though TypeScript is very much like JavaScript, it still can't run in the browser. It has extra things that JavaScript does not support and browsers only know how to run JavaScript. So before you take your TypeScript code and give it to the browser, it needs to be compiled, or "transpiled" to go from TypeScript to JavaScript. This is an extra step you need to do before code can work in the browser. But there are apps and command line tools that make this process pretty easy. It's not as easy as straight JavaScript, but it's not horrible once you get the hang of it. And for just testing things out, there's scripts you can add to the browser to do this automatically for you in the browser itself (it just runs a little slower so you wouldn't want to publish anything out publicly that does this). CoffeeScript is a little different. It's a language like JavaScript but is different enough that it's its own, separate language. People who know how to use JavaScript can pick it up pretty easily though. And it was designed specifically to tackle the problems that people have with JavaScript, though maybe slightly biased in it's approach in doing so. // JavaScript var num = 2; function square (n) { return n * n; } square(num); // 4 # CoffeeScript num = 2; square = (n) -&gt; n * n square num # 4 Like TypeScript, it has to be compiled into JavaScript before it can be run on the web. So there's still an extra step there. But like TypeScript, it can also be compiled automatically in the browser just for messing around with it (again, with the same caveat that you wouldn't want to use it in production). CoffeeScript had a lot of momentum when JavaScript was starting to feel stagnant in terms of improving as a language, especially given how ES4 was abandoned. After ES6, some of CoffeeScript's features - and competitive advantages - were starting to show in JavaScript itself. This made JavaScript a little more appealing and CoffeeScript no longer seeming as necessary. Though version 2.0 of CoffeeScript was released as recently as last year, most developers now a days are content to ignore it. While CoffeeScript looked to make working with the (err, "a") language easier, TypeScript's goal has been to make working JavaScript safer. Since it is a superset, it _is_ JavaScript, but JavaScript with additional features that helps prevent errors and ensures that developers are writing code correctly, something that is more and more important as web apps get larger and more complicated. In fact, writing TypeScript means writing _more_ code to do the same thing in JavaScript alone, but it's code that provides better information on how it should be used and better error checking that is performed before you run it. --- For simple projects, TypeScript can be overkill. But it doesn't mean you can't use it. As far as learning goes, JavaScript is the best place to start. It's already what TypeScript is based off of so by writing JavaScript you're pretty much already writing TypeScript. Once you want to step up your game from JavaScript, you can start getting into the things added by TypeScript. If you're interested in CoffeeScript, you can learn that too, but I wouldn't suggest it as a place to start. And it really does help to know JavaScript first since it has to be compiled into JavaScript when it runs. This sometimes adds an extra layer of complexity to understanding the language. Plus, its probably not something that you'll see much when you're out looking for a job (whenever you might decide to do that some day, but who knows what things will look like then!)
This is not a sub in which you should care about karma. You'll find a lot of disappointment here ;)
Haha. Yes! This a thousand times. The only time I heavily comment code is if i feel that adding some notes about WHY I chose to write what I did is important. Code that is self documenting doesn't need heavy documentation, and that's why types are so valuable. Without types you need to work even harder to document what you write.
You should skip coffeescript. No company will expect you to know it, and it is becoming increasingly rare in usage. Also it is difficult to debug problems if you don't understand the javascript that it eventually compiles to. Typescript is becoming increasingly popular but it is also far and away not as common as javascript. Also, it is a superset of javascript (javascript + extra features), so if you are learning javascript, then you are well on your way to learning typescript and can explore it in greater depth later. Focus on javascript. It will have the most learning resources (blogs, books, etc...), the most tooling / support, and the most job opportunities. You can play around with it at any time just by opening the inspector, so the setup barrier is extremely low. I recommend going on Frontend Masters or [Egghead.io](https://Egghead.io) and watching videos on javascript fundamentals. Then pick a framework and start learning it. Vue.js is probably a good one if you are a big fan of html templates. It's also pretty opinionated about project structure so you can get pretty far without having to make a lot of decisions about every little bit of the project. 
Yeah I love Vue but this was a little bit circle jerky
Python is a good language to use to learn programming fundamentals for a variety of reasons. It's very explicit and terse, and there is usually only one way to accomplish any given goal which helps to reduce confusion. However, I don't think you should learn it first if your goal is to be a frontend developer. Learn Javascript.
Don't. I'm not a python Dev, but I know it has a lot of value, especially when it comes to data science-y stuff. But it's not a replacement for JS in front end developer.
I'll also echo that you should use JavaScript first. Everything else is built on top of JS, so understanding that will give you a better understanding of how things work under the hood. Don't just focus on ES6 stuff either, some of the older ES3 and ES5 is more imperative. While I like writing declarative code more, understanding the old imperative way gives you a nice look under the hood of how things work. For example, don't just learn ES6 classes, learn how constructor functions and prototypes work too, and the syntax for working with them manually.
Every time I've read about Vue since 2016 I _really_ want to write a project in it. I'm so entrenched in React development however that it feels more worthwhile to continue building mastery within it. Maybe that's the wrong perspective however and I should start branching out more to identify common patterns and best practices and use them anywhere ¯\_(ツ)_/¯
You dropped this \ *** ^^&amp;#32;To&amp;#32;prevent&amp;#32;anymore&amp;#32;lost&amp;#32;limbs&amp;#32;throughout&amp;#32;Reddit,&amp;#32;correctly&amp;#32;escape&amp;#32;the&amp;#32;arms&amp;#32;and&amp;#32;shoulders&amp;#32;by&amp;#32;typing&amp;#32;the&amp;#32;shrug&amp;#32;as&amp;#32;`¯\\\_(ツ)_/¯`&amp;#32;or&amp;#32;`¯\\\_(ツ)\_/¯` [^^Click&amp;#32;here&amp;#32;to&amp;#32;see&amp;#32;why&amp;#32;this&amp;#32;is&amp;#32;necessary](https://np.reddit.com/r/OutOfTheLoop/comments/3fbrg3/is_there_a_reason_why_the_arm_is_always_missing/ctn5gbf/)
I dropped this \\ ¯\_(ツ)_/¯ 
You dropped this \ *** ^^&amp;#32;To&amp;#32;prevent&amp;#32;anymore&amp;#32;lost&amp;#32;limbs&amp;#32;throughout&amp;#32;Reddit,&amp;#32;correctly&amp;#32;escape&amp;#32;the&amp;#32;arms&amp;#32;and&amp;#32;shoulders&amp;#32;by&amp;#32;typing&amp;#32;the&amp;#32;shrug&amp;#32;as&amp;#32;`¯\\\_(ツ)_/¯`&amp;#32;or&amp;#32;`¯\\\_(ツ)\_/¯` [^^Click&amp;#32;here&amp;#32;to&amp;#32;see&amp;#32;why&amp;#32;this&amp;#32;is&amp;#32;necessary](https://np.reddit.com/r/OutOfTheLoop/comments/3fbrg3/is_there_a_reason_why_the_arm_is_always_missing/ctn5gbf/)
Do you mean this didn't get called? Or is the function throwing errors? If it's the former, it'd help if the calling code is also present.
It doesn't matter what programming language you're learning: always, always, \*always\* start with the fundamentals. This is especially with JavaScript – since popular libraries and tools are constantly swapping in and out (as per the famous illustration: [https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f](https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f) ). So go all-in vanilla JavaScript, then feel free to learn all the other stuff that's out there that depends upon it. (Full disclosure: I'm the coordinator of the web dev program at a local college. We need more students who understand the fundamentals – and that's what employers want, too.)
the function is called. but nothing happens. there are no errors that I see.
wheelDelta is depricated. Firefox doesn't support it. https://developer.mozilla.org/en-US/docs/Web/API/MouseWheelEvent#Properties
Yes, do it. You'll probably learn more about JS on the way. The React docs are pretty good. Go through the tutorial once, and then read the docs pages, especially the "Thinking in React" page.
1. Asynchronous behaviour: What does it mean that a particular function is async in JS? Also leads into the event loop 2. Function binding. If you alias a function to a variable, pass it to another function, call that variable, what are the implications? For example: ```javascript const myVar = someClass.someFunction; function anotherFunction(input) { input(); // and input.call, input.apply variants } anotherFunction(myVar); ``` Not that you'll need to write that kind of code all the time, but helps in understanding the binding semantics in JS (and similar things can be done in other languages too, so it helps there too). 3. ES6, especially centred around `const`, `let`, `var` distinctions.
Nobel Prize worthy
Good bot
Promises api methods, Array functions: `reduce`, `filter`, `map`, `find`.
Forget about CoffeScript. Start by learning vanilla JavaScript.
I hate when people downvote to disagree. It’s a legit question. IMO, always start with the base and then move to libraries and other adjuncts. Learn HTML/CSS before Bootstrap, etc. The reason is, when these adjuncts fail, it will be necessary to go to the base language (or close to it) in order to fix it. This is more true in other parts of web development than your question but I feel like it’s a good general rule. 
Wow, alright then. Thank you for your very detailed response. I probably will not need to know this way later but what exactly are C++ types and how does this relate to TypeScript? Another question or "concern" I have I guess is because it has to be compiled before the browser can read it is it actually *slower* than just vanilla JavaScript or am I wrong? &gt;*In fact, writing TypeScript means writing more code to do the same thing in JavaScript alone, but it's code that provides better information on how it should be used and better error checking that is performed before you run it.* If I read this correctly, this just kind of confirms my belief that JavaScript is faster than TypeScript and CoffeeScript is much faster than TypeScript, just with more information and more readable code which is always nice. Luckily, I won't have to worry about speed for a long time but it's still something to note I guess. You also mention that TypeScript has better error checking than JavaScript, how can a programming language have better error checking than another one? Will the compiler fix errors it can find in the build? I'm really new to programming, sorry haha. From your post, there seems to be no reason to actually learn CoffeeScript, so I'll probably ignore if for awhile. Either way, all I'm making is static HTML pages and TypeScript seems to be a very heavy superset of JavaScript if that makes sense, so I probably will not be learning that first thing either as suggested. I thank you for your comment, it was very insightful.
You're not wrong, Walter, you're just an asshole.
I’ll never like anything as much as Sindre Sorhus likes programming in JavaScript 
\`\`\` function expandArray(){ let myArray = \[1, 1, 1\]; return function(){ myArray.push(1); return myArray; }; } \`\`\`
Wha...?
I'll check out those two websites, thank you for the resources! I've heard about vue.js but I have no idea what it does. Once I learn JavaScript enough to be competent at it, I'll check out that framework. I suspected that JavaScript would easily have the most resources for me to use in order to learn it.
I've tried using Bootstrap, controversial opinion, i'm really not a fan. It's not a customizable as I would like it to be, and websites made by Bootstrap look kind of the same imho. I agree with what your saying though, I should learn the fundamentals before branching off into all these different libraries, frameworks etc.
In Javascript, you can write something like ```js function daysOld(age) { return age*365.25; } ``` Makes sense. But maybe you integrate it into a site as `const ageInDays = daysOld(userinput)` Then someone types in "Thirty". Turns out that in Javascript, `daysOld("Thirty")` is `NaN`. Stands for 'not a number', kind of makes sense, but probably isn't the way you want to handle this. If we do a whole bunch of stuff that uses daysOld, this behaviour might wind up causing a bug that is only apparent further down the line. You'd be able to track down the issue... but you'd have to spend time doing that. Dynamic Type Checking lets you say ```function daysOld(age:number) { return age*365.25 }``` And then have the system tell you, the moment `daysOld('Thirty')` runs, that there's going to be an issue caused by doing that, rather than having the issue pop up wherever it breaks something. *Static* Type checking means that the check is done by just reading the code, with no need to run it, which means that the issue with `daysOld(userinput)` can be found before anyone even thinks to type "Thirty". You can set your text-editor up so that you're told about this issue the moment you type it in, even. Instead of having to track things down later on, you catch the bug before you even save the file. 
&gt; ¯_(ツ)_/¯ ¯_(ツ)_/¯
&gt;You're not wrong, Walter, you're just an asshole. When it's appropriate.
Yeah bootstrap has its place but it’s certainly not an end all. It’s for quick sites and makes them fully responsive. But I was just using it as an example of something similar to typescript/JavaScript. Bootstrap goes on top of HTML/CSS like TS does for JS. 
Skill in anything is a spectrum. Atleast in programming it falls along this line - Has heard of a feature/framework/technique/language/tool Has used it occasionally Has used it in everyday work, knows the various configuration and features, can navigate through documentation and examples very quickly Has come across edge cases, perf issues, or gotchas Is able to reason about diff techniques/frameworks etc in terms of tradeoffs, perf implications, speed of dev, etc Is able to contribute unique/very impactful code that exposes right levels of abstractions and configuration for other devs 
Webpack-dev-server has been deprecated in favor of webpack-serve. 
Are there Elm jobs? I've never thought to look.
I’m still at the nuxt Ssr with vue point, cool to know about this too
More every day. Many startups. If you needed a job this year or next then JavaScript will give you more options. But, I've been recruited for a couple Elm jobs in past couple months. A little bit of wishful thinking and a little bit of the trends lead me to believe it will get big soon. 
I think a lot of Vue adopters came from AngularJS 1.X. It's hard not to write a love letter after dealing with AngularJS and the 1.X to 2+ nightmare a lot of teams went through. 
Learn javascript then react. You will be making over 100k in a few years. 
&gt; If I read this correctly, this just kind of confirms my belief that JavaScript is faster than TypeScript and CoffeeScript is much faster than TypeScript. Actually no. Let's use the example of /u/systoll above: This is JavaScript: function daysOld(ageInYear) { return ageInYear * 365.25; } // This will cause an error when you run the program daysOld('thirty'); This is TypeScript: function daysOld(ageInYear: number): number { return ageInYear * 365.25; } // This will cause your editor to show red squishy line below 'thirty' // to indicate that you have an error even before your program is run. daysOld('thirty'); The TypeScript compiler will strip out the `: number` part above and create a JavaScript file with identical content to the first example. So the runtime speed of two program should be completely the same.
Nuxt makes it super easy by making it "just work" out of the box, but you'll run into some oddities here and there with things like plugins, but it's super helpful and removes a lot of boilerplate you'd normally be writing. I know some people like to see the capabilities and limitations of a framework before they get started with it, so hopefully this will help put some confidence in the minds of people looking at Nuxt / Vue.
Noob here, would splitting up mutations (update, addProduct, removeProduct) work well for RESTful APIs too? Or does that go against best practices ?
Welp, I'm stupid. Thank you for clarifying this concept, I'm not sure why it was hard for me to understand.
Since they're all JavaScript in the end, they all have basically the same performance. Looking back at the simple variable assignment examples I posted earlier, when they're compiled, they all become the same thing: // JavaScript (no compiling needed) var num = 1; // TypeScript var num:number = 1; // compiles to: var num = 1; // JavaScript version # CoffeeScript num = 1 // compiles to: var num = 1; // JavaScript version The compiling happens before you give your code to the browser. For example if you're writing TypeScript, you'll have a source code file named something like `MyCode.ts`. When compiled, it will generate a file like `MyCode.js` and it's that file you give to the browser to run. That file is a JavaScript file that gets generated from (compiled from) the original TypeScript code. The same applies to CoffeeScript. I mentioned that you can also compile in the browser itself though it's slow and not something you'd want to share. This slowness is because it needs to perform that compile step in the browser to convert your code into JavaScript first before the browser can read it. This compiling is handled by _other_ JavaScript that has to load first, read your non-JavaScript code (i.e. TypeScript) before the browser can read it, compile it, then give it back to the browser to run it as normal JavaScript. It's this part of the process in this case in particular which makes it slower. But if you do the transpiling beforehand, it's not something you have to worry about. An in-browser compiling of TypeScript can be seen at: http://www.typescriptlang.org/play/ Note that when I say "compile" here, this isn't the same as the "compiling" the browser does - something it does with your code to be able to run it. This is compiling that happens before the code is run. I mentioned "transpiling" before which is a term used for this kind of compiling which is translating code from one source code format to another source code format. Both of these formats would be human-readable code formats that you could look at and visually see what's going on in the code. The more common "compiling" that happens takes human-readable source code and compiles it to machine code that can only be read by computers and not so much you or me. C++ is different in a couple of ways. For one, the syntax is different, especially when it comes to types. Using the simply number example: // TypeScript var num:number = 1; // C++ int num = 1; These are all simplified examples, but you can see the type for C++ comes before the variable name `num` (here "int" stands for "integer" which is a specific kind of number) and there's no mention of `var` in the declaration. The `var` is implicit in the use of `int`. (And even now, with JavaScript you'll often see `let` or `const` used instead of `var`, but I'm using `var` to keep things simple.) Another thing with C++ is that type information stays with the variables, even when the code is run. As you saw with TypeScript, when it gets compiled to JavaScript, the ":number" part of the TypeScript code - that which indicates that the `num` variable contains a number value - is stripped. This is because JavaScript doesn't know or care about what kinds of values get assigned to variables so doesn't need to track types like that (nor can it understand what the type meant if it stayed in the code). TypeScript only does type checking when it's compiled, but it's this type checking that adds the additional layer of safety to your code because it helps ensure you're using numbers where you're supposed to use numbers and not, for example, where maybe strings are expected. C++ does this when you compile, _and_ is able to check types when you run your code (though if you have type problems then, you're gonna have a bad time). When you're first learning programming, TypeScript can seem like a waste. It's ok to ignore it for now. The benefits are hard to see right away. It's not until later, when you've buried yourself in a shitload of code in a massive project that those additional TypeScript type annotations (e.g. `:number`) start showing their worth. In fact I had one project I had written that I felt pretty good about - this was in ActionScript, mind you, but the same concepts apply - that I had started writing without types. When I was done, I went back to add type annotations to help make it "nicer" code. Turns out, by adding those types, the compiler pointed out multiple errors that I had not realized I had before! The addition of types helped fix my code. Also, by starting with JavaScript first (ignoring TypeScript for now) it's one less thing to worry about. TypeScript types can get very complex. They're quite powerful, and the TypeScript team is constantly adding features and expanding it's typing capabilities. There's a lot to learn (I certainly don't know it all), so starting with JavaScript alone will make learning things a lot easier. I don't think I would suggest anyone learn TypeScript first unless they're already familiar with another typed programming language.
&gt;Incase this helps, I am looking to develop for ecommerce.How often are algorithms used for ecommerce? Algorithm scares me as math is not at my strongest at the moment.ReplyshareSaveedit &gt; &gt;kgrz1 point · 1 hour agoAsynchronous behaviour: What does it mean that a particular function is async in JS? Also leads into the event loopFunction binding. If you alias a function to a variable, pass it to another function, call that variable, what are the implications? For example: Thank you for the detailed answer. I have added those topics to my to learn list. Very much appreciated!
It's called *Love letter to Vue*. What did you expect?
This has already been said, but focus on learning vanilla JS. Everything you will need to do (in the browser) can be accomplished with vanilla JS, and the knowledge you'll glean from building things in vanilla JS is worth more than any convenience built into the tool, framework, or library that's being recommended to you. Once you're building things on a schedule the convenience is nice, but not understanding JS when you're building critical features with (insert framework or library here) is a recipe for disaster.
CoffeeScript is a preprocessor? Huh, that kind of changes a few things then. I probably won't need it for awhile then. Thank you for the information
What the fuck is the point of this
GitHub: [https://github.com/ElemeFE/page-skeleton-webpack-plugin](https://github.com/ElemeFE/page-skeleton-webpack-plugin) Page Skeleton is a webpack plugin.The purpose of the plugin is to generate the corresponding skeleton screen page according to different route pages in your project, and to pack the skeleton screen page into the corresponding static route page through webpack. * Support multiple loading animations * Preview on mobile * Support multiple routes * Can be customized, and also directly modify the skeleton page source code in the preview page * Almost zero configuration available
: nods : thanks.
&gt; It's not a customizable as I would like it to be Devil's advocate, as I'm not a big Bootstrap fan (for other reasons) – you can customize literally any part of it. It's just LESS/Sass. Sites that are identifiably Bootstrapy look that way because of lazy designers.
Ohhhhh, thanks!
I see - this has been lots of help! Thank you.
The interactive UI is pretty neat. 
Can we please not try to steer a young kid down the path of using random languages and libraries no one has heard of simply because you find it interesting? Keep that for sharing with peers.
The answer is vanilla JS and to get as comfortable as possible with the fundamentals. Try to learn and use as much ES6 as you can - many companies are now using it in production code. As tempting as it will be, DON’T use jQuery if you can help it. A lot of devs who are just getting into basic JS will start to use jQuery for convenience but you will become over-reliant on it. If you find yourself loving JavaScript and want to dive deeper, the next step would be a framework or library such as React, Angular, or Vue. 
I would say 'reduce' is my favorite method, it is like a swiss army knife 
By the time you are in the workforce, Typescript will be pretty much synonymous with Javascript or it wont exist. Don't drive yourself crazy following the flavor of the year. Learn Javascript. If you are looking for something to learn, don't learn languages, learn API's. Can you integrate the Google Maps/Bing/Openstreetmap API, or the IEX stock market API, or the Accuweather API, Lyft API, or any of the other thousand interesting API's out there into a web app? That can all be done with vanilla Javascript. The moment you need another language to get something done, you will know it.
If I understand this correctly, you want to make a request to all the urls: ``` https://example.com/page-1 https://example.com/page-2 https://example.com/page-3 https://example.com/page-4 ``` but only return when all of them are complete? If so, you could achieve that using `Promise.all`: ```javascript Promise.all( [ 'https://example.com/page1.json', 'https://example.com/page2.json', 'https://example.com/page3.json', 'https://example.com/page4.json' ].map(url =&gt; fetch(url)) ); ``` `Promise.all` resolves once all the requests are done. If there's an error in one of those requests, though, the entire promise gets rejected. Now for some shameless self-promotion. I just posted this today morning, and coincidence may be, but I think [this](https://kgrz.io/composing-promises-like-theres-no-tomorrow.html) might help you further. The solution that you want might be slightly different, but it goes through basic building blocks for problems like this. (if I understood it correctly). 
I kind of disagree that it’s only for quick sites. Bootstrap provides a whole framework, you only use what you need. We build custom web apps using Bootstrap as the base and completely customise the look and feel to the point it looks nothing like vanilla Bootstrap. The responsive grid is great.
Yeah Frontend Masters has this cool "pathway" section that lays out a whole curriculum [https://frontendmasters.com/learn/beginner/](https://frontendmasters.com/learn/beginner/) Brian Holt does the first course in that class. He's a good instructor, I did his computer science workshop in person. You can probably skip the first 2/3rds of his course and get started with the javascript section though. 
Can confirm, have no expectation that I'll ever use coffeescript.
Ok that’s fine. I’m not bagging on bootstrap. I was only using it to make an analogy. It is what it is. A library. There’s amazing things about bootstrap. There’s some really restrictive things about Bootstrap. I use it all the time. But it’s just a tool, not a language. 
I would strongly encourage you to start with Typescript for two reasons. 1. Typescript gives you almost immediate feedback when you make mistakes. If you use the VSCode IDE, you find out very quickly if you're making mistakes in your code. This will help you learn things much, much more quickly. It also helps prevent frustrating, silly errors. 2. If you know Typescript, then you already know Javascript. However, if you know Javascript, you don't know Typescript. Either way, get ready to never stop learning. The field changes rapidly.
The last statement is so true. This is something I have not heard from the thread before, you think I should start with TypeScript? I know about the immediate feedback, but those seem like solid reasons to learn TypeScript. That being said, I still know only the bare basics when it comes to the fundamentals of programming so I'm really not sure if starting with TypeScript is the best. Besides, doesn't TypeScript have C/C++ like syntax? would it not be just as hard to go to JavaScript from TypeScript and vice versa? 
Yeah totally agree with that. Full Bootstrap can be a bit heavy sometimes unless you build your own version also
I hate to use this phrase, but the answer is "it depends". I have experience in working at an e-commerce company. There are lots of backend systems that power the UI, built in a kind of loose service-based architecture. Most of these systems use a thin layer of common functionality that's abstracted out into a library. Depending on the system you might see a difference in the prevalence of algorithms. For instance, the search team uses open source search systems to power the search in UI, but they need to understand what makes search fast. They probably don't muck around the tools themselves, but might have to write application layer code which might need to be fast. Same goes for UI. Most of the main UI components are not too algorithm-heavy, but it does help to understand how React works at the library layer even though we might not modify any of it. And React uses a lot of non-native data-structures and fancy algorithms. But there occasionally are some user-level elements that end up using some kind of a fancy datastructure. My point is, learning algorithms can make you a better program designer, and so is an essential skill. But don't let that discourage you. You'll have ample time to learn them. If working in a team, most of the time you spend writing code is to make it readable for your teammates. So sticking to fundamentals and knowing them in depth helps.
Pure JS for sure. I'm a software developer, and while I work mostly on backend, I have done frontend work. I also work with a lot of UI/frontend devs. 1. You will likely need to use multiple frameworks through your career. Angular, React, etc. are all slightly different but if you know JavaScript, you'll be able to jump into those with relative ease. 2. Node.js is a beast but eventually you'll be able to delve into that. Node is used almost primarily for backend development (also Ajax). Being able to code both front- and back-end can prove to be very lucrative. If you're really motivated pick up some SQL in a couple years and you'll have enough to develop the full stack. 3. Lastly, JavaScript is a fully-featured programming language, so if in a few years your ambitions/interests change (and they are likely to with your age), you'll have learned one of the most versatile and in-demand languages out there. You'll also have a solid knowledge of programming logic, which I can assure you is infinitely more valuable than knowing any one language. You can do a lot more with JS than just frontend. You can make games, desktop apps, build AI, create neural nets for ML... The possibilities are endless. Happy coding! 
As someone who does the same, my argument is that if you're going out of your way to make it so different from regular boostrap, aka overriding bootstrap, and only keeping the bones (grid, utils, etc) then... maybe a more modular approach perhaps just a grid in postcss or something like that. 
All valid Typescript is also valid JavaScript, so you can write a JavaScript file, slap a .ts extension on it, and it will compile just like any other Typescript. If you go this route, you have the advantage of learning the build tools as well - something you'll run into very very quickly with vanilla JavaScript anyway, since it's needed for modern features and required for popular frontend frameworks such as React. If you do, you'll be able to add in the Typescript features as you learn them (they have C like syntax but don't really make Typescript read like C - more like JS with some weird stuff here and there). Typescript is a standard way of using JS in production, so it's a very marketable skill, and if you ever want to do a big project the type checking will save you a LOT of headaches. Mostly, though, just start. It's very easy to spend too much time deciding what to learn rather than jump right in - and you'll find at a certain point that languages aren't really that different and the core concepts are basically universal (some exceptions, ofc)
It takes like a day or two to learn Vue enough to write a project in it if you already know react. That said if you enjoy react development Vue might not have much to offer. 
Switching from TypeScript to Javascript would be very easy -- I write exclusively in TypeScript but whenever I need to do a quick test in a browser I can just write in Javascript. It is very easy for people to articulate why Javascript is "easier" than Typescript (you don't need to compile/transpile Javascript &amp; it takes work to write types explicitly in Typescript). However, Typescript will save you an immense amount of time once you get over that small initial learning curve. In truth, in the early days of programming you should pick a project that you want to do and make sure that you enjoy it. Try not to worry too much about details like languages and stuff -- the most powerful skill you can develop is learning to love programming. So, if you try Typescript and get annoyed by doing types or transpiling -- switch over to Javascript. If you try Javascript and get annoyed by frustrating errors that are hard to debug, try Typescript. Try things, make sire you enjoy them.
Coffeescript is just a different syntax. It doesn't add much benefit, and comes with a bunch of overhead. Typescript adds type checking, and a lot of other nice features. u/zingzingtv 
Not stupid.. just learning. There’s no shame in not knowing everything.
That 'How it feels to learn javascript' was good, thanks. 
React Native. And no, not for the web app, for the desktop app. Completly different thing. They are only using it for the view,no logic attached. And no, Microsofts knowledge DB website is completly written in Angular (which is bigger than the ones you mentioned). + mixer.
If I understand the problem correctly, for this request: POST /user You want something like this to happen: const user = User.generateNew(); const key = Key.generateNew(); user.keys.push(key); user.save(); Correct?
I use Scatter for several project [https://github.com/mariocasciaro/scatter](https://github.com/mariocasciaro/scatter) Easy to use and well documented.
If you are learning vanilla javascript, spend the extra effort to learn es6.
Which part of customization of Bootstrap are you having trouble with?
Focus on the basics. The fundamentals, and learn some framework so that you can start creating some interesting projects. Remember, languages are merely tools. Use them to build interesting applications and websites. That's the goal. 
&gt; And then have the system tell you, the moment `daysOld('Thirty')` runs, that there's going to be an issue caused by doing that, rather than having the issue pop up wherever it breaks something. The big benefit is that it tells you *before you even run it* that you have a problem, that your code would allow `daysOld('Thirty')` to run. By checking the types, the compiler can tell that `userinput` is a `String` while the argument to `daysOld` must be a `Number`, and so your program is not valid. The compiler forces you to fix your code preemptively by somehow converting `userinput :: String` into `age :: Number`. Which forces you to think about it, because how do you safely convert an arbitrary string to a number? You can't! You have to handle the case of non-numeric input somehow, and only use the parsed string once you've proven it really is a valid number. Which is *great* because that means the compiler just helped you eliminate a whole category of bugs before they even existed.
You don't even have to think about them next couple of months.
Learn C first. Then, go to JavaScript if you care so much about the feature of TypeScript. Learning C doesn't take you long at all, like a few weeks. 
Yeah I agree with that too. I guess it depends totally on what is being built, picking the right tool for the job. Bootstrap can be quite large if you only want a few things like a grid
You don't appreciate the features of TypeScript unless you know things about memory allocation. So, learning Python doesn't make sense because Python is as high language as JavaScript. Learning C++ is good but every tutorial focuses on the object oriented programming design which can be learned later. If you were to learn C, all the tutorials and lessons try to teach you (dynamic) memory allocation, pointer very well because that's what C does. Also, because JavaScript, Python, TypeScript are written in C, when you learn these languages, you will instantaneously see how and why their syntax works as they do. When you need to google-search a coding question for JavaScript for example, you would search "what is the design in C for JavaScript's \*\*\* syntax?" instead of "How do you do this in JavaScript?".
You can learn TypeScript in a day if you know JavaScript. Forget about learning TypeScript.
`reduce` is the NAND gate of collection methods. Basically every other collection method (`map`, `filter`, etc) can be made out of `reduce`.
Would you try to be a sushi chef without knowing how to cook rice?
&gt; websites made by Bootstrap look kind of the same imho. There's probably confirmation bias here. If a bootstrap website is properly customized, you wouldn't ID it as a bootstrap website.
It's probably because you don't fully understand how HTTP protocol works. The material often gets overlooked because it sounds like you've already known because you use internet every day. For example, can you explain what how "redirect" works?
Tooltip.
No one will notice this comment because it’s not 9 miles long.. But you should try the three you mentioned you’re already interested in and the one that gets you making things you’re happier with the quickest should be the main focus. Everything else blooms from there.
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), “nobody” starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
&gt; You also mention that TypeScript has better error checking than JavaScript, how can a programming language have better error checking than another one? TypeScript is not a programming language. It's closer to a linter. It defines hints that the linter can use to warn you of potential problems with your code. You can also achieve similar results with Flow, or jsDoc etc. But the code that makes it to the browser does not contain any of those checks. For example, if you define a function with TypeScript and say that it should have a number as argument, then call it with a string, during development you will get an error in your IDE/build process telling you what you did wrong and refusing to go forward unless you fix it. But if you write all the calls correctly correctly and then at runtime, in the browser, (in the console for example) you call that function with the wrong type of parameter, you won't get any warning, and the code will run using JavaScript implicit type conversion rules. This is not just a hypotethical scenario; if you are getting data from outside your app, from an API for example, there's no guarantee that the stuff that comes in is the right type. This is why you should learn JavaScript first and foremost, because no matter what linting or syntactic sugar you apply on top, when it runs in the browser it's still plain old JavaScript.
Pure Javascript. Don't mess around with anything else. 
You've basically got it right. Scopes are created by functions, and each scope has access to variables in the outer scope, but variables within an inner scope are private to that scope. So something like this wouldn't work: ``` var x = 23 function add(a) { var z = x + a } add(1) console.log(z) // z is not defined ``` You _could_ do something like this, but you shouldn't. ``` var x = 23 var z = 0 function add(a) { z = x + a } add(1) console.log(z) // 24 ``` Changing `z` from within the `add()` function like this can make it harder to reason about your code, and can also lead to bugs that are harder to track down. It's better to return the value and assign it as needed. ``` var x = 23 function add(a) { var z = x + a } var z = add(1) console.log(z) // z is not defined ``` This actually applies to pulling in `z` from the outer scope as well, since that value might change outside of your `add()` function when you're not expecting it to, which can lead to unexpected results. It's better to make `add()` a "pure" function, which is a function that only takes outside input through its parameters and will thus always return the same output for a given set of inputs. So instead of this: ``` var x = 23 function add(a) { return x + a } add(1) // 24 ``` Do something like this: ``` var x = 23 function add(a, b) { return a + b } add(x, 1) // 24 ``` Or even better, use partial application to make this more reusable: ``` var x = 23 function add(a) { return function (b) { return a + b } } var addX = add(x) addX(1) // 24 // or, the add() function with ES6 syntax const add = a =&gt; b =&gt; a + b ``` 
The correct answer.
i've been a front end dev for 10 years and just set up my first web server from scratch using nuxt and pm2. with this stack, i found the process accessible and it's really pushing me toward full stack development, which is in high demand. jump iinnnn.
I’m confused how a static type checker would help in this scenario when you don’t know what the user can put in. Seems like it’d make more sense to catch it earlier by forcing the input to be a number in the first place.
&gt; All valid Typescript is also valid JavaScript I think you got that backwards.
I did.
In addition to what other replies have said, CoffeeScript also has weird corner cases around syntax, where it is very easy to accidentally write something different than what you intended due to whitespace and indentation. (Not that whitespace significant syntax is inherently bad. After all, Python is fine.)
[removed]
I find that despite all the libraries and everything vanilla JS is wayyyy easier to learn. most of the time it works just fine too (specially if you can use es6) - no need for any libraries or their fancy features. 
1. I don't know what the value is of this fork over the original repo, but here's the [original repo](https://github.com/wesbos/JavaScript30) for anyone interested. 2. I opened a random challenge, the [type ahead](https://github.com/wesbos/JavaScript30/blob/master/06%20-%20Type%20Ahead/index-FINISHED.html), looked at the solution, and spotted a race condition. The cities array is populated asynchronously but used synchronously. That means you could interact with the search widget before the cities data has loaded. For a learning exercise, _maaaybe_ that's OK, but in real life production code, we should never let that pass code review. Race conditions are one of the worst kinds of bugs because your app will appear to work most of the time yet fail randomly and intermittently.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [wesbos/JavaScript30/.../**index-FINISHED.html** (master → be63f4d)](https://github.com/wesbos/JavaScript30/blob/be63f4ddd72916d3e2d5fadd4bb91f94b5c211e3/06%20-%20Type%20Ahead/index-FINISHED.html) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e2l8pbu.)
just do stuff you are interessted in. what tech you are exactly using is totally irrelevant imho.
Start with JavaScript. There are two excellent books, "JavaScript: The Good Parts" by Douglas Crockford, and "JavaScript: The Definitive Guide" by David Flanagan, which will teach you JavaScript up to the so-called ES5 level. Next is ES6, which is very well summed up on es6-features.org. For online language reference, use the Mozilla Developer Network. The easiest way to do that is to add the word "mdn" to any google search about language specifics, for example "mdn split string". Avoid w3schools, it pops up a lot in google results but the information is old and sometimes wrong or misleading. You will need to learn about promises. *After* you do, read [We Have A Problem With Promises](https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html). Also you'll need to learn async/await. It's not necessary to learn in-depth about promises and generators to use async/await, but I would advise you to do it at some point, because otherwise you're just groping around in the dark whenever you use it. You can learn TypeScript at any point after you understand the basics of the language. The thing to keep in mind about TypeScript and some ES6 syntactic sugar like "class" is that they don't change the fundamental nature of JavaScript. You can use them and pretend that JavaScript has type checking or class-based OOP, but it doesn't. People who do this lock themselves into a narrow, false view of the language. People usually do this because they're veteran programmers who come to JavaScript from class OOP languages like Java or PHP and they're unwilling or unable to shift their mindset and learn prototype-based OOP. It's unfortunately extremely common and you'll find it everywhere, even in very advanced programmers. As a newcomer, you have the advantage of not having this mental baggage; don't let it warp your understanding of the language.
Coffescript is dead. Don't bother with it. It's always best to know your basics so start with vanilla JS
Just wanted to point tha same thing out. It highlights the point about learning the underlying tech the framework / library is built on top of. Just learning Bootstrap will only take you so far, but knowing CSS and LESS/SASS will allow you to bend it to your needs and understand what and why it does when things go wrong.
Done! Check your inbox 
yep, the only reason to use CoffeeScript today is if you join a project that was built with it: it still has some virtues, I still like the syntax for instance, but it's not worth all the tooling your missing out on imho
Doing what you want - serial requests, can be done easily with async-await. Need to combine serial and parallel? Promise.all for parallel and async-await for serial.
This. Vanilla (ES6+) then Typescript.
Our backend handles the authentication transparently.. ie creds are not passed with the API calls. We also transform on the backend.. so the details that make the call complete are handled in the backend. Never use third party API calls in your front end. 
On #21, why split out almost all of the fields except ID into their own object, rather than allowing ID to be nullable? I understand that the name would need to be different to capture the functionality, but it would reduce the specification in much the same manner. Not arguing for A or B, just trying to understand why the choice was made. 
There's always going to be an issue with the buckets of knowledge you've explored. In many areas I'd fall into the third category put forward by the comment to which you are replying, but I've had little opportunity to use ES6 yet or many of the larger client server frameworks. The more you know the quicker and better you can pick them up, but a naiive test won't reveal that. The Dunning Kruger effect is very real, with the more you learn in programming comes a greater understanding of the breadth and depth of the field. If you are teaching junior / intermediate staff within a certain domain and can discuss matters with true subject matter experts that's what I'd suggest communicating when asked, but be clear about the scope of your work history. Many programmers can write basic logic and copy stack overflow, being able to show expertise in even a narrow area or write pseudo code for theoretical problems well is less common. I like the idea that being able to consider several possibilities, then make a decision based on performance and future maintainability is what distinguishes it if you want to evaluate based on code seen in the workplace. 
Learn JavaScript. It’s very vast in itself. Learn the nuances of the language and the move to TS. Skip CoffeeScript. Not at all worth the effort in 2018. 
API level 0 "Needs to look up the documentation frequently" Uuuh, I think that's me for most things, but I'm usually checking what's available as options I've forgotten before I try something overly complex to deal with a solved problem. Even with tools I've used for ages the field progresses and options are added. 
CoffeeScript is dead.
Not sure why you have down voted me...Outlook Web is a web application. Microsoft UI Fabric is a web component library intended for Office 365 and Sharepoint. Visual Studio Team Services also uses React web (not native). All of them are pretty important products for Microsoft. Moreover, isn't React Native still React? 
The only good thing about Coffee script is it reduces the competition for web dev jobs. "Here is my code sample, it is in Coffee script" "My eyes!!!"
As it's a startup, take very seriously that interviews are a two way affair. You need to be sure that they will suit where you want to go and should probably do some due diligence about the company so that you don't end up not being paid or worse. If you can't find them independently, ask for some details of people they've worked with previously in a similar role so that you can ask what you are likely to experience. 
I remember when I first started programming (Java or C#, don't remember), I hated the fact that you always had to specify the type of your members, because it seemed like a lot of extra work, whereas in Javascript or Python you let the compiler/interpreter do the work for you. It was only later down the line that I realized that it is a huge help once your code gets a little complicated. If you have a semi-decent IDE, it will tell you straight away when you're doing something wrong. No more hard-to-find bugs because you used an integer where you should have used a string.
After posting this only i realized it is the forked repo, thanks for sharing the original repo
`Number#toString(radix)` lets you turn any number to a base of your choosing. It's has niche use cases but it comes in handy once and a while. 
You could do something like this, which doesn't use any external libraries and should return all your data once it's ready AND merge it into a single output array; const fetchAllUrls = async () =&gt;{ const remoteData = await Promise.all([ fetch('https://example.com/url1'), fetch('https://example.com/url2'), fetch('https://example.com/url3') ]); return [].concat(remoteData); }; It's untested, but it should give you some idea on what way to go if it's not quite correct. It does rely on modern features like async-await and semi-modern features like promises and fetch, but support for these is pretty good at this point. Just as a side note, code that's running at this level (i.e not tightly integrated with a specific node project which might have HTTPS-specific handling or libraries) will be treat HTTP the same as HTTPS. You can't request HTTP resources via HTTPS - it's not a problem for your use case, but just be aware that you can only reliably request HTTPS resources vis HTTPS (and not via HTTP).
Small nitpick, the JS example does not throw an error, just a garbage result. Actually, a fine result which is indeed not a number :)
Might wanna read up on Strangler pattern. But yeah decomposing your app bit by bit might be the way to go.
Quoting from Wikipedia: &gt;For the cooking process of this name, see [Curry](https://en.wikipedia.org/wiki/Curry).
This was the error (Chrome, OSX) when pressing = ; main.js:298 Uncaught TypeError: Cannot read property 'unload' of undefined at HTMLDocument.playAudioOnKeyDown (main.js:298) And the source: https://imgur.com/OLctK30 One side-note - many macs don't have some of the keys you mention such as pg-up, pg-dn, and prt-scr. I'm using an external keyboard since I'm a Windows native so (so those keys are available, and I've remapped my Mac around the keyboard), but use a Mac while away from my main machine.
AHH. This error I was ignoring and forgot to try and catch. It still continues to play sounds right? Thanks ms a lot for your feedback! Basically this function is to remove sounds in the array but there are no sounds loaded at that moment so it finds an error. 
AHH. This error I was ignoring and forgot to try and catch. It still continues to play sounds right? Thanks ms a lot for your feedback! Basically this function is to remove sounds in the array but there are no sounds loaded at that moment so it finds an error. 
Good luck, I've been trying to get into a junior/intermediate dev position for months with no luck. I ended up settling for an unpaid internship at a small business to try and make myself useful in the meantime. They don't have any developers at all, and the only other IT person is filling 4-5 different roles, from help desk to database admin. Its technically illegal but nobody would hire me, so I wish you luck.
Sounds a little more in line for something like r/alphaandbetausers
More specifically: Coffeescript was an alternative language for Javascript that essentially "transpiled" to Javascript for execution. The thing is, most of the problems that Coffeescript solved were addressed in later versions of Javascript, so learning Coffeescript won't really make things simpler. The big advantages of Coffeescript were the arrow-syntax for function returns, for/of, for/in, string interpolation -- all of which are in vanilla ES6+ javascript (and can compile to older browsers using a library like Babel.) My thoughts on learning typescript: Typescript isn't just a language/transpiler, it's also an ecosystem. Using the free Visual Studio Code IDE, you can have the IDE alert you to a lot of potential problems you need to address. It really shines when you use TSLint and ESLint, to make sure your code is a consistent style.
Agree. `async` `await` is a useful tool. I was trying to explain the same: that it's easy to do with Promises once we know the abstractions. Will add the `async-await` example too, thank you for pointing that out.
Enjoyed reading that because empathy. Haven’t used vue (yet), still doing angularjs but probably where I’m investing time next.
This is a really unhelpful site. This is the [second time I've noticed it](https://www.reddit.com/r/javascript/comments/8ofp6l/promises_in_javascript/) come up here and it is the second time it's been basically wrong. Or if it's not wrong, then what it's saying is less useful than what it's leaving out. In this latest post, it says: &gt; Function currying is creating a new function with preset value of parameters This explanation is a pretty mangled, but based on the examples he gives, what this correctly describes is [partial application](https://en.wikipedia.org/wiki/Partial_application). If you are feeling extremely generous, then currying can be thought of partial application taken to its logical extreme (where every parameter except the last is set via its own, dedicated function). But currying really belongs in its own category as it solves a distinctly different problem, which incidentally comes up extremely rarely in JS (compared to, say, Haskell or Erlang). Also... partial application using only `bind`? In 2018? That's... sucky. 
&gt; is it worth it to start learning these instead or just vanilla javascript?V No, both node and browser runtime's require vanilla JS. No point in learning any kind of compiled lang before you learn what it compiles into otherwise you're gonna have problems debugging. &gt; Apparently, and correct me if I'm wrong, TypeScript has C++ like syntax and static type checking(?) Yes and no. &gt; coffee-script adds syntactic sugar to the code to do more things behind the scenes. Coffee-script is dead, native ES6 is just as good or better.
What kind of modules? I've just been reading this on ES6 modules and from this point of view - nothing you've said looks right ;-) https://hacks.mozilla.org/2015/08/es6-in-depth-modules/
Youtube, books and practicing 
&gt;sort of a basic form of batching If you look at a series of promises being chained together via `reduce` as a batch operation of maximum 1 item per batch, then sure, I guess it counts as "batching". That being said, *real* batching is rather trivial to implement. Let's start with a utility for reducing promises: Promise.reduce = async (values, reducer, initialValue) =&gt; { return (await Promise.all(values)).reduce(async (accumulator, value) =&gt; { return reducer(await accumulator, value); }, initialValue); }; With this utility, we get rid of a lot of the boilerplate around repeated promise reduction. Example without the utility: const sumPromise = Promise.all([1, 2, Promise.resolve(3), 4]) .then(nums =&gt; nums.reduce((accumulatorPromise, num) =&gt; { return accumulatorPromise.then(accumulator =&gt; accumulator + num); }, Promise.resolve(0))); Example with the utility: const sumPromise = Promise.reduce([1, 2, Promise.resolve(3), 4], (accumulator, value) =&gt; { return accumulator + value; // can also be Promise.resolve(accumulator + value); }, 0); This doesn't solve the problem of batching on its own. In order to solve the issue, we need to understand that `Promise.all` does not actually execute the promises that are passed to it. Promises are eager, meaning they are executed at the very moment they are created. By the time they are passed to `Promise.all`, they are already deciding whether to resolve or reject. `Promise.all` is simply a tool for collecting their results declaratively. We cannot control the concurrency of eager values without delaying their execution. Fortunately, we can use functions to encase the creation of a promise and execute that function when we decide we want it to be executed. Hopefully this code snippet helps illustrate the idea: // this promise is eager. it has already executed. const eagerPromise = new Promise(resolve =&gt; resolve(100)); // this action is lazy. it creates a promise. const delayedAction = () =&gt; new Promise(resolve =&gt; resolve(100)); // we can execute the promise when we think it's time for the promise to execute. delayedAction().then(/*...*/); What I'm suggesting is that we need a way to map the values to delayed actions that create promises. So, let's write another utility: Promise.map = async (values, transform) =&gt; { return Promise.reduce(values, (accumulator, value) =&gt; { return accumulator.concat(transform(value)); }, []); }; This utility will lazily execute a chain of promise-returning functions in sequence. For example, here's what reading a directory of files would look like: const files = ['foo.txt', 'bar.txt', 'baz.txt']; const filesContents = Promise.map(files, (filename) =&gt; { return fs.readFileAsync(filename); // assume this returns a promise }); Note that the `transform` function is not executed for `bar.txt` until after the `transform` function for `foo.txt` has executed and resolved. This is *not quite* batching, but we're headed in the right direction. We are effectively batching 1 action at a time. What if we were to take the `files` array, and split it into chunks - then execute an action for *each* chunk, then combine the results back together? Let's create a utility for splitting an array into a chunks of a given size. The code for this is pretty simple. Array.chunk = (array, size) =&gt; { const chunks = []; const length = array.length; let i; while (i &lt; length) { chunks.push(array.slice(i, i += size)); } return chunks; }; Now, we can ask for an array split into chunks of 2 (the last chunk might be of a smaller size): Array.chunk([1, 2, 3, 4, 5], 2); // [[1, 2], [3, 4], [5]] We can now modify our `Promise.map` utility to accept a batch size (which defaults to the length of the provided values), and use `Promise.all` to declaratively stitch the results together. Promise.map = async (values, transform, size = values.length) =&gt; { const chunks = Array.chunk(await Promise.all(values), size); return Promise.reduce(chunks, async (accumulator, chunks) =&gt; { return accumulator.concat(await Promise.all(chunks.map(transform))); }, []); }; Lets look at our `files` example again: const files = ['foo.txt', 'bar.txt', 'baz.txt']; const filesContents = Promise.map(files, (filename) =&gt; { return fs.readFileAsync(filename); // assume this returns a promise }); The code is the same as before, but there's a big difference in behaviour compared to the previous iteration. The above code will execute all of these file reads in parallel, whereas the previous version executed them sequentially. This is because we're defaulting to a batch size equal to the length of the input - `files` is 3 entities long, so we guard for a concurrency of 3 actions at a time. What if we want to limit it to 2 actions at a time? Easy: const files = ['foo.txt', 'bar.txt', 'baz.txt']; const filesContents = Promise.map(files, (filename) =&gt; { return fs.readFileAsync(filename); // assume this returns a promise }, 2); What about 1 action at a time? Again, easy: const files = ['foo.txt', 'bar.txt', 'baz.txt']; const filesContents = Promise.map(files, (filename) =&gt; { return fs.readFileAsync(filename); // assume this returns a promise }, 1); As you can see, batching is very simple to accomplish, and it uses the same idea as your sequential `reduce`. Also, before anyone complains about modifying built-in types, I just did that for brevity. I don't normally extend/augment built-in constructors.
Exports with return are either AMD or UMD modules. Don't use that old crap these days.. 
Udemy courses
ES7
Ahh in the book series you don’t know JS
What is the point of having an api identical to your database? If you want that you might as well give clients direct access, and use postgres roles for security. Graphql is tailor made for the problem of having multiple databases, and an api that abstracts over the internal complexity. If you do not have that problem, then there are better solutions than graphql.
Hey. Thank you. I wish good luck to you too !! 
Try freecodecamp!
What do you need help for? Are you expecting to show a number instead of a boolean?
I’m learning JS and I’m aware that thing are done differently (or at least heard it). But, it is important that I still know how it works because if I for example how to go trough some code for a company that’s outdated , I need to understand the code 
Yes, I understand. I'm just saying don't go producing more of that outdated stuff today.
Thank you so much for this reply. I kept focusing on getting the marker1, marker2 etc that I forgot I really needed to get the value from the array. After 2 days spent going mad I got it working in a few minutes after reading your reply! I blame sleep deprivation caused by a teething toddler for my confusion on this! Thanks again! Really appreciate it! :)
I learned TypeScipt before JavaScript, but I came with Java background, so it was the easier path for me. You can skip CoffeeScript.
What I'm doing 1. Taking both of Steven Hancock's JavaScript courses that are on Udemy 2. Taking a Udemy course on data structures and algorithms in JavaScript followed by a a book that goes more in-depth with the theory 3. Doing the JavaScript30.com exercises 4. Practicing via Coderbyte.com 5. Learn Vue.js
How did coming from a Java background help you in that regard?
Ha, me too! Only it took learning some Rust for me to finally appreciate it.
Do you mean yes and no as in TypeScript has C++ like syntax and does not have static type checking?
Id go with this answer also. I use Typescript with Angular 2+ and it’s very powerful. But if you aim at being a versatile frontend developper your first and ongoing focus should always be Javascript. 
`addEventListener()` is available only if there's DOM - which is available either in a web browser, or a WebKit node.js. That function doesn't have anything to do with the command prompt of either the node.js prompt, or the Command Prompt application.
Oh. I used w3schools a lot when I was learning a few more advance CSS techniques (flexbox, css grids, animations) I thought it would be reliable since w3c sets the standard of the web, and it was created by the creator of HTML, but I digress. I'll check out those two books, I've heard of the first one *Javascript: The Good Parts.* As for the last point, I do not think it will apply to me, but I will make sure to watch out for veteran programmers who only program a certain way. What is the difference between prototype-based and class-based OOP? Is one more beneficial than the other?
[https://javascript30.com](https://javascript30.com)
That gave me an idea, I think I will port my first app from angular 1.x to Vue. The logic is messy but it's only a few files long.
[https://github.com/getify/You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS)
Nice! Super explanation! Really appreciate the effort you put into this. Pretty sure this will help someone or the other. No complaints, but not sure why you emphasised "real". I did mention towards the end that using similar sequence of steps, adding a proper batching solution of `Promise.all` and the one mentioned in the post could be a small-ish next step. One of the major goals of writing that post was to make sure the evolution of reduce + Promises flow feels "natural". And the concentration was more on Promises, rather than just getting a batching functionality working, and mixing and matching patterns. And the focus was also on looking at how error handling can be added without going into callback hell.
String `includes()` method is has the same functionality as below function. function stringIncludes(str, pattern) { return str.indexOf(pattern) &gt;= 0; }
I should probably try that to be honest. It would give me a feel for all of the languages before I decide but it will require me to invest a lot more time, but I think it is more beneficial to do this in the long run.
I could write TS code like my Java code, I had classes, interfaces, types, so it was more familiar to me. Of course after some time and learning my TS code became less and less Java-like as I became familiar with JS concepts.
the V
Thank you for all your replies! Very helpful!
make a website, either find some who looks for web developers who is okay with the fact that you are a novice or make your own it may be your portfolio, some random game like Pac-man, Tetris, custom game, whatever, but the best way to learn something is to actually do it, so the best way to learn JS is to code in JS, if you have some issue you may use some advice but you'll know what you need help with
Thank you dude for all those tips.
Starting an online business from scratch by developing top notch eCommerce website with JS &amp; nodeJS which will result in highly scalable &amp; speed platform. Also developer would be happy to code hassle-free.
You can do all sorts of fancy animations, smooth scroll and stuff like that, which will catch the eye of non-IT people. But it comes with a price, more javascript === worse performance. Your pages will take longer to load and become responsive, so keep it under limit. I personally avoid js as much as possible. Google something like this "javascript animation effects". Also I have heard React is good for Designing user interface, but I never got the chance to use it so can't say much about it.
VanillaJS. Learn the basic and fundamentals before picking up a framework.
Browserify or Webpack. Webpack has a higher learning curve but lets you do more.
When we were testing people in interviews we let ppl have google and as much time as they wanted, but they had to solve simple problems in vanilla js. If you need libraries, then you'll eventually get stuck and be useless until you properly learn fundamentals. The test could be done in 20 seconds, but most ppl would spend 20 minutes before giving up.
i’ll check them out thanks 
It's not identical beyond initial startup. On postgres, you can 1. add smart comments which modify crud utitlies, (limit insert, update, create, etc) 2. Disable tables 3. Create computed columns 4. Add synthetic functions to return specific searches The point being, things in the database like table relationships, search functions and documentation don't need to be duplicated. It also comes with graphics which allows your developers to see all the links, connections and test the queries. Why wouldn't you want to start with everything, then trim what you don't want and add functions you do? My whole issue when doing full stack as a hobby is having to leap frog from database design to api design to front end design. Sticking to two concerns with postgraphile gluing em together creates far more value. Of course, postgraphile also promises row level security and jwt, which I can't discuss as I've not yet been there.
Reusable encapsulated components is always impressive when you let them know the financial savings. The one thing that impresses everyone more than anything is money and how you can make someone more of it.
who the fuck hired you?...
Older browsers (IE) don't support Promises so you'd need to include a Promise polyfill in that case.
thanks for reply @jcunews1
so? do we need 300 articles saying the same dumb shit over and over again?
Learn typescript and then use that knowledge to learn languages such as Java and c++.
Bootstrap certainly has it's place and it's not really in building marketing or brochure based websites. When a designer hands me a template of a client's website to convert into html and css, I'm not using bootstrap. But if I'm building an administrative web-app or a dashboard where the design isn't the focus and the functionality is, then I'm sure as hell using a bootstrap-based theme package - a library that comes with a customized bootstrap framework with styles for forms, widgets, modals, graphs, navigation, icons, fonts, animations, etc. etc. It just makes life so much easier and makes great commercial sense.
^ This is it. Explicitly.
What's an example of a problem?
Err.. Except your example makes it sound like type checking is done at runtime, whereas it's actually done at lint/compile time. 
Didn't mean to start an entire discussion about this, but admittedly I've only used it for a week before I stopped.
Almost all my personal projects use vanilla js. I tend to like vanilla more than frameworks, but for larger applications, nothing beats a framework.
I will consider this for the next vid, thanks!
You are correct Javascript is the way to go with frontend. Javascript is ubiquitous, and has gotten much better with recent updates. However, you are young and have not technically learned programming yet, so learning python which is more accessible to beginners will accelerate your learning. I have seen javascript programmers write horrendous code in other languages but python programmers typically write beautiful js. This is because in python you don’t have to fret over syntax, you can just make stuff work. My point is... you will find it more useful in the long run to learn python; subsequent languages will be easier to learn and you will be able to do more. That said, you can always learn both. Happy coding!
Coffeescript was cool 5 years ago because Javascript still sucked. Now a lot of what is possible in CS is possible in JS. So Coffeescript is redundant. Typescript brings static typing and static type analysis to Javascript so it's not a different language with different runtime semantics.
Oh, I see. Your saying to learn python for learning the fundamentals of programming, alright then. Thank you for this information.
Ouch. JS =/= DOM . So VanillaJS doesn't mean shit unless you are not using a third party language. But nobody can't tell apparently. 
1 - learn the DOM 2 - learn the DOM 3 - learn the DOM
https://expo.getbootstrap.com These sites don’t all look the same... Also, I suspect lots of bootstrap sites look the same because they are front ends slung together by back end devs and it looks a lot nicer than it otherwise would. Ps. Not invested in bootstrap at all, I just like checking out what you can do with stuff.
Given 20 lines of simple JSON data of people, sort by id, filter by haircolour and return a new array with the full names (concatenation first and last name) So the simple solution was filtered, sort, and map, but we were fine if ppl didn't use those functions. They just needed to solve the problem in a reasonable way.
I’d skip the coffee script entirely. It’s been mostly obsoleted at this point and has been trending downwards rapidly for a few years. JavaScript is the most important to learn. Not only are interactive parts of pages written or transpiled/compiled to JavaScript, but more complicated pages get written entirely in JavaScript using a framework like angular or a view library like React. I’d get a base of ES2016(ES6) JavaScript then move to typescript. Typescript will give you a much stronger understanding of the language, especially when working with classes and objects built into the browser. The types of all built in things are named the same as they are in public browser docs like MDN. Typescript will protect you from making silly mistakes and force you to understand the code you are writing to satisfy its compiler. If you start adding type annotations to everything you write, you will quickly discover misconceptions you had about how you were using certain objects and functions.
Under no circumstances should you entertain the idea of using CoffeeScript. The ecosystem is long dead. Source: Maintain 5 year old coffeescript application responsible for $xxMM in revenue and my life is miserable. :)
Even in most OOP languages, if someone wants to grab your private members, they can do it by Reflection or via memory reading
You have 13 &lt;div&gt; tags and 11 &lt;/div&gt; tags. You need to fix your formatting and learn to close your tags. Also, I'm not sure what you're trying to accomplish. Are you saying that when you click on the image, the image itself should change? Or you want another image to show below it? I can't see any of your styles, so I'm not sure how this is supposed to look.
Try getting into JavaScript with NodeJS and use ElectronJS for GUI’s. That way you’ll be learning webdev and be able to make native apps. A lot of great apps are made with ElectronJS; Slack, VSCode, Postman. C/C++ are excellent languages that force you to learn what’s really going on. But the learning curve to get over so you’re actually happy with what you’re producing is a lot higher. Best advice IMHO: Start with JavaScript, get VSCode and add an extension to it called Quokka and you’ll be making stuff in no time. 
Hey guys! We're using vue.js daily. Now it's time to share some of our experience. Enjoy reading!
I went through their docs the hard way. Important thing to note: React doesn't provide much in the way of boilerplate or patterns. Every project is going to be a little bit different, and that's OK ( guess). This doesn't answer your question, but you should check out [https://vuejs.org/](VueJS). You'll feel a lot more comfortable learning that than learning React. It kinda takes all the best parts about AngularJS and all the best parts about React. r/vuejs
Skip Coffeescript. Trust me
Could you share a little bit more information on the kind of application you maintain? It sounds pretty cool to be able to maintain something for that long that is clearly generating revenue for you and/or your team, especially with the language that not a lot of people seem to like.
Could you try a hard refresh / deleting all resources in dev tools? 
I maintain a websocket server that the entire business uses for message delivery, without getting into too much specifics, it has low latency requirements. It's unmaintable garbage that wakes me up at all hours of the night with issues that cost the company lots of money in downtime. So it's pretty stressful. The code was written by a bunch of smart people in CoffeeScript who just want to ship code and did not care about maintability, so it has a lot of warts, and lots of scaling issues. It's from a era where CoffeeScript looked like it had a future. My dream is to rewrite it in Erlang/Elixir or Go, but the business has no appetite for any language that isn't Java or JavaScript.
Sorry for the formatting it is a copy-paste mistake, my apology.. As I said, the div "switching" is already accomplished. Now I wan't to make the image to change completely on click so I can achieve some kind of "active" button look for the related div. If you think you can help me, and I'm still not clear maybe I can PM you for more details?
I won’t! Thanks for the heads up 
Ok. So you click the image, and it changes. Then you click another image, and it changes. Do you want the first image to stay changed or revert back to what it was previously? Also, do you have to use jQuery?
&gt; I used w3schools a lot when I was learning I just threw up in my mouth a little. Here are two better resources: * [https://css-tricks.com/](https://css-tricks.com/) * [https://developer.mozilla.org/](https://developer.mozilla.org/en-US/)
Nice! I'd add some accessibility stuff to it, but this would turn into a much lengthier blog post. 
Thanks. 
Makes sense, thanks. 
That looks like a lot of work. 
Your function isn’t using any data from its environment. Consider this simple example: let foo = 0; function whatIsFoo() { return foo; } `whatIsFoo` is a closure. It is capturing `foo` from its lexical environment. While your `transform` function is a closure, it’s not using anything from its environment and so could be written in a language which does not support closures. You often see closures in functions that return other functions because having a closure that only accesses global state isn’t that interesting. Defining a function that returns a closure over a set of local variables allows you to create multiple instances with different behavior. For example: function makeCounter() { let current = 0; function next() { return counter++; } return next; } With this you can call `makeCounter` multiple times to generate multiple counting objects, each of which remembers its own place while counting.
Thanks! Yep, we decided to leave accessibility stuff outside to make the post easier :)
Same, personal little projects, Vanilla.js best choice 
Oh, I was under the impression that you were the creator of this system making big bucks, but that sucks. I can't really say for you to just convince them to change the codebase, but even if you could it seems like a monumental task to change the entire codebase. At least your irreplaceable in your job, I'll stay away from CoffeeScript.
Speaking of CSS: * https://caniuse.com/
Technically, every function is a closure in JS. Every function could possibly close over the parent scope. The actual question is: Over how many variables does my function close? `transform` for example closes over 0 variables: It could have closed over `sent` and `arr`. This means, you can safely move `transform` out of ` newCamel` because it does not dependend on any of the values of `newCamel` (or remove it entirely, it's redundant). const newCamel = (sent) =&gt; transform(sent.toLowerCase().split(' ')); const transform = (arr) =&gt; { /* ... */ }; You see why `newCamel` and `transform` should be simply merged to one function? Btw, you should validate your inputs: `array[i + 1].substr(1)` throws if array has an odd amount of elements. 
This. But learn es5 first. You still may need it, since es6 syntax isn’t fully supported in all browsers, and especially isn’t available in legacy applications. 
Here's the default way of uploading an attachment (I forget which MS site it was taken from): function uploadFileAttachment(itemId, listname, fileName, bufferData) { $.ajax({ url: _spPageContextInfo.webAbsoluteUrl + "/_api/web/lists/GetByTitle('" + listname + "')/items(" + itemId + ")/AttachmentFiles/add(FileName='" + fileName + "')", method: 'POST', data: bufferData, processData: false, headers: { "accept": "application/json;odata=verbose", "X-RequestDigest": document.getElementById("__REQUESTDIGEST").value, "Content-Type": undefined }, success: function(result) { console.log(fileName + ' uploaded successfully' + result); }, error: function(err) { console.log(JSON.stringify(err)); } }); } You'll need to iterate over all of your files and add a timeout. I'm not familiar with a batch image upload.
It just means that because the types of the variables don’t change after compilation (static), you can ask the compiler to do the work of **checking** they all match for you. Because this happens at compile time, you’re guaranteed to eliminate a lot of runtime issues you might otherwise run into. For example, you write a function expecting a string as an input, and it changes it to an int under your feet. You’ll most *likely* get an exception there. So *you* end up having to do a lot of thinking about which types are allowed to go to which functions. The idea behind static checking is that you just *tell the compiler* what types of variables a function can accept. By doing that, the compiler goes, “hah. This doesn’t match. Try again”. This means that you as a developer only have to think about types while first writing code, instead of throughout the lifetime of that piece of code. You get nice documentation about how those functions work (since you’re naming all your types). And it’s easier for you to work with other people’s codes, because if someone writes a function, you can only look at the type to know how to use it. You don’t need to look at that function’s implementation to figure out details about how things work. 
Hi /u/kiarash-irandoust, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Hi /u/bbmario, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/stranglingisfun, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/Lookeeee, For javascript help, please visit /r/LearnJavascript. Thank you!
Technically TypeScript is "transpiled" rather than "compiled" into JavaScript. But otherwise I totally concur with this write-up. After moving from JavaScript to TypeScript I would never want to go back. Learning TypeScript might be a valid path to learning JavaScript because there are lots of tools that will display side-by-side comparisons of the JavaScript that your TypeScript code is going to transpile down to.
Hi /u/foofex2187, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/thegroove226, For javascript help, please visit /r/LearnJavascript. Thank you!
I'm of the opinion that if you write proper ES6 following object oriented design, utilizing pure functions, there is no need for the additional overhead Typescript introduces.
Hi /u/Doommestodesu, For javascript help, please visit /r/LearnJavascript. Thank you!
As I said I'm very much noob at JS... So yeah, when I click on another images, it changes and the previous one reverts back to the first image set.
I don't agree? The strong typing features of TypeScript, when combined with the right IDE tooling, is enough to transform the developer experience.
Js already supports multi threading... https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers
JavaScript started out life with a direction that used features heavily influenced by Lisp/Scheme: (http://2ality.com/2011/03/javascript-how-it-all-began.html) &gt; A company called Netscape was founded in 1994 and created one of the first web browsers. They recruited Eich in 1995, because they wanted him to create a programming language for that web browser. The lure for him was that he would be able to base the language on Scheme (a Lisp dialect). Scheme’s influence led to JavaScript having closures. Another influence was the prototype-based programming language Self which is responsible for JavaScript’s prototypal inheritance (some of the elegance of this approach is hidden by JavaScript’s muddled adoption of it). I don't know how much that means to you, but JS has always been sort of an ugly stepchild of Java-like syntax and Scheme tendencies. It's what gives it the ability to do multi-paradigm programming styles. (In the UI you can get really powerful functionality with little code using Functional concepts.) When I was in school, people are not really taught functional programming formally (AFAIK) and are usually taught Java or some other statically typed inheritance based languages because "that's what businesses use". So for some, this can look like cryptic incantations (and some really can be...) I actually branched out on my own free time and started learning Lisp, then Haskell to try to further my knowledge of functional development. I found it rather enlightening and it's made me think about development (in general and especially JavaScript) in different ways. While I'm not a fan of Typescript (I prefer to have more of a Haskell [Hindley–Milner] type system... see [Elm](http://elm-lang.org/) if truly interested), it sort of grounds JavaScript for some to a more familiar model that they are used to.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](http://elm-lang.org/) - Previous text "Elm" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
If we are talking about byte code, we can do anything. This is a void point. If we are talking about reflection, we can do per what each language allows, and if the language allows access to a private variable, without some sort of trust mechanism in place, it is a fault of the language and a void point. With type script, you are transpiling to another language, a script language, one where you can not really tell what code will enter the code space at run time. There is simply no comparison between having to write 'O._privateVariable', like in type script's case, and having to hack your way through byte code using assembly and similar, to get access to the private variable. Interested reader might want to try CrxOop, my own javascript library for OOP, and it should give you "runtime privacy".
Because you are not a beginner...
That's fair, actually that's significantly simpler than I expected. I'd agree then if they struggle with a problem like this unless they seem like a quick learner they'll struggle in a JS job.
Webpack it's the best choice, I personally recommend the version 4, there is a lot of documentation in the webpack page, good luck! If you have any doubt i can help you.
Thank you a lot for the comment! In the last example, that is also nice when it comes to one preset value (example 10, 100, 1000) so var addTen = add(10) var addHundred = add(100) etc.. Regarding the ES6, I’m really looking forward to learn ES6, but at the moment I’m learning the old school just in case I need to update some old code etc.
Gotcha. Give me a couple minutes, and I can write something up to help you out. You didn't answer my other two questions about id's though.
What is the outcome from adding a [] + {} ? And What is the outcome from adding a {} + [] ? 😂
I would argue that 99% of visitors to a website don’t even know what Twitter bootstrap is. IMHO it’s not used so much bc the designer was lazy, but perhaps more because it’s a quick and easy way of getting a project live. As mentioned you can customize bootstrap as little (make a few changes to the style sheets) or as much (purchase premium bootstrap themes from wrapbootstrap.com) as you want.
I don't see any need to use jQuery for this when you can just use an `onclick` function on the element itself and `querySelector` so [this plnkr](http://plnkr.co/edit/Lf5ReZFQx4WDjiezwxd8?p=preview) shows you how it's possible.
Erm, isn't a modal dialog that blocks nothing called an amodal dialog?
I had read that fighter pilots could perceive 1000fps events, but it looks like they were actually only perceiving 220fps events. However, you still would want a higher FPS than that to avoid flicker and motion blur at these limits. Sorry for that mistake. When I make these kinds of “extreme” requirements, people assume I mean for normal TV viewing, where they would often be overkill. However, that assumption is wrong. VR and other newer visual technologies require vastly more graphical power just to operate normally. 8K per eye would not be overkill for VR.
how to know if string is a palindrome?
Plus, even as a designer, I would say that is often a good thing. No reason to make users learn your interface because you wanted to be special, unless you truly are offering something special that is. But run of the mill webshop... yeah just be bootstrappy predictable.
 ¯\\\_(ツ)\_/¯
I have collected some questions and collated in my app. You can try it [https://play.google.com/store/apps/details?id=gamesmint.com.jsone](https://play.google.com/store/apps/details?id=gamesmint.com.jsone)
Download! One star for too much yellow. Jkjk I'll give a legit rating later. 
Such as? I see this phrase alot. Do you mean decoupled componets such as endpoints/microservices or literally the idea of all these frameworks like express, vue, etc that break up MVC componets.
No, this is excusing bad design, improper documentation and overall laziness. If you use explicit naming, if you have good documentation and care about learning the tools you use, i.e: APIs, you are going to have to spend time on them learning how they work. Stop excusing bad developers!
https://github.com/GoogleChrome/puppeteer
I've seen Elm mentioned more than once, but I don't know if I can handle using a functional programming language let alone an OOP-Orientated one haha.
Still bad. The rule of thumb for gzip is that repeated patterns can be compressed to the original length for the data plus two bytes to reference the data each time it is used. Since literally every character will be a repeated sequence, instead of just single letter variables (one byte), gzip simply cannot make it smaller than like twice the size of a non encoded compressed version. For example, my very simple, tiny library, onfontready has these stats: * minified: 901 bytes * minified+gzip: 390 bytes * encoded minified: 689,359 bytes * encoded minified+gzip: 12,481 bytes So, even after gzipping, this encoding scheme is well over an order of magnitude larger in byte size than even the uncompressed minified version.
I'm not excusing bad developers. You're excusing a bad programming paradigm.
Beginners get vanilla. Coffee is for CLOSERS.
It’s dying fast
&gt; : thanks for the feedback, saying the function needs to close over a variable makes the idea of closure click better. So the inner function has to have some sort of dependency on the outer function correct? 
Why would you start with JavaScript? I have junior developers start straight with TypeScript, you don't need to worry about many of the JS quircks and you will still learn Javascript as the API is the same as TS.
&gt;!(noob alert)!&lt; Isn't there an already existing method that does that? `str === str.split().reverse().join()`?
and ({}) + [] 
Yes, but coding interviews are generally set up in unrealistic environments where: A) Libraries don't exist B) Stackoverflow who now? C) "Well, yeah, that's one way, but we really wanted to test you on big O and you're kind of fucking that up for us right now."
Thats not a language feature, its a browser API.
i had to make my own function
Serious question. How come you don't just read through volumes of their code. Then have them code and bug hunt a few projects for you?
&gt;Well, yeah, that's one way, but we really wanted to test you on big O and you're kind of fucking that up for us right now." That's kind of lame. Were you able to use a for-loop and slice? That's the only way I can think of doing it without join and reverse.
For the same reason I would start with assembly in a comp-sci course. You got to understand what is going on under the hood to make informed decisions at a high level.
I'm a bit confused. What are you talking about?
Puppeteer is one option if you only care about Chrome. I use Burnside, which will work across all browsers as its pure JS. [https://github.com/Nike-Inc/burnside](https://github.com/Nike-Inc/burnside) 
I sometimes do https://projecteuler.net It's more mathematical puzzles though.
In my experience the most hirable engineers are not the ones who know everything about a single framework or ecosystem, but the ones who understand fundamentals, concepts and patterns. I recently went through an intense interview process with big tech companies and none of them cared about the React / Vue thing for senior roles, just that you had experience with at least one of them. All tech screens were core JavaScript problems, sometimes even language agnostic. I got 3 React-specific questions the entire time, and was able to answer them even though I have more experience with Vue than React. Point being, many companies prefer that you have experience with lots of different things, rather than mastery of one.
i did via for-loop which took the first and last character and compared them then second and last but one etc. it was more of a test for the way i solve problems generally than test for solving the problem itself, i mean in the end it was basically the same then the split-reserve-join way but i had to explain what's going on
A bit late,but I agree. The only time I use var now,is to test some array function in browser console,like var getAdmins=ele=&gt; ele.role==="admin"; users.filter(getAdmins) For more complex methods,I need several tries,and let/const will break the declaration rule in console.
I disagree with the whole point, but not with this particular case. Functions should remain as small as possible and have a single responsibility utopically. If I need to process an object and then create something else with that processed object it's actually *good* practice to separate that in two functions and wrap them both in another.
Yes, that's correct. Take u\/meefims's example: `next` depends on `counter` (which is declared and defined in `makeCounter`). Non-closure functions (although not present in JS) can only ever refer to either local or global variables, not parent locals. Internally, a closure instances stores a list of references to the variables it closes over.
codewars.com
Oh yeah definitely, I understand the importance of language fundamentals over frameworks. I spent a LOT of time working in JS, ES6, before spending a lot of time in React. I just need to get into something new soon. I've honestly been thinking about trying out Ruby, Ruby/Rails for something new to do. 
TIL
You need to know JavaScript first before you start learning TypeScript and CoffeeScript.
` const isPalindrome = (input) =&gt; { let pointer = input.length - 1; for (const char of input) { if (char !== input[pointer]) return false; pointer -= 1; } return true; } ` this doesn't necessarily cover edge cases but worked on racecar haha
O.o
Webpack is the standard. You could also give Parcel a try, I think it fits your requirements.
[This is my repo.](https://github.com/BLBaylis/react-calculator) Previously, I've only made projects with a HTML, A CSS and a JS file. This is the first time that I've added tools like Babel, Webpack and Sass, so any advice on my file structure would be very helpful. In future I'm just gonna use create-react-app though, it seems a lot easier. This is also my first react project, so I'm sure there's a lot to improve on there too! Thanks
The replies I read were single line questions revolving around some deeper edge case knowledge that would rarely be run across in typical real-world development afaik. Hence comments about the acting like you couldn't just look it up on the job. I'm just wondering why the emphasis on these questions over real code and real-world bug hunting. 
"closure" mostly just means that functions can be used as state containers. One of the implications is that functions can do jobs similar as classes as state containers
Yes, supports, but Web Workers are not threads. This, most likely, can be called separate processes. And here's why: A web worker does not have direct access to the variables of the main process. To transfer data to the main process, special methods are called. Quote from Mosilla API: &gt;Data is sent between workers and the main thread via a system of messages — both sides send their messages using the postMessage() method, and respond to messages via the onmessage event handler (the message is contained within the Message event's data attribute.) The data is copied rather than shared. What is a thread? This is a function that can be executed simultaneously with another function. In this case, this function has full access to variables in its scope. To pass some value, you do not need to create a special message and pass it by the postMessage() method. You just need to assign the value of the desired variable. For example: // the variable var c = 1000; // the thread var t = thread() { while(true) { // thread can access the variable c--; } }; // starting: t.run(); // wait until the value of the variable becomes 0 while (c != 0) { // nothing to do, just wait, the value of the variable is changed in the thread } // stop the thread t.stop(); 
it looks amazing, that's exactly what i was looking for
Totally... but its so so darn handy lol
Learn the basics first... by the time you are done with that people will probably move on to the "next big thing". JavaScript is great in some ways, but there is volatility there that you have to accept to remain sane.
I'd add a powerful type system and pattern matching.
and the answer? 
Is Nuxt basically a port of next.js for Vue?
Basically, yes. (It's not a direct "port", but same idea)
&gt; IMHO it’s not used so much bc the designer was lazy, but perhaps more because it’s a quick and easy way of getting a project live I think you missed my point – I wasn't lambasting Bootstrap, but rather sites that don't change Bootstrap a lot.
I’m glad I’m not a student of yours, haha.
Key thing to observe from this article is that SSE are not yet implemented in IE.
Nice article. I've cross-posted this to /r/learnreactjs! You may also prefer /r/reactjs to here for a more relevant subreddit.
- Explain hoisting - difference between arrow function and regular ones, - difference between let and var, - is a const variable immutable? - if you look good ans wrote in your resume you worked on a framework, I'll probably asked questions on rendering cycle &amp; strategies - if you said you had experience with node's, what's common JS and how is it different from es6 modules - functional programming is popular, could you give me a definition and an example of it (whatever piece of code that shows some currying or function composition would be fine) - usually we show them a PR and ask them to do a review on it 
&gt; doesn’t make you a knowledgeable or skilled programmer. the question was "Whats the best way to tell your level of skill?" &gt; Solving stupid code golf questions in no interview have i ever been asked a code golf question. are you trying to say white-board?
Could you please write an example of the syntax of pattern matching? It may be a good thought but I have not ideas about syntax.
Something as simple as the diy version of the components here: https://www.webcomponents.org/ the point is that they're reusable and drop-in ready. 
https://reasonml.github.io/docs/en/pattern-matching.html
Best to try it out in a browser console 😂 one is [object object] and the other is 0
Is there a notable performance difference between running something with a web worker vs your multithreading implementation? Other than syntactically, I'm struggling to understand what the difference is. 
Ah I get you. Thanks.
I'm new on this :(, I'll do it for the next one. Thanks!!!!!
Typescript. JavaScript is being turned into canvas for other languages like Ocaml.
Nope, the solution for performance is more js, aka SPA.
Learn vanilla JS first IMO
You haven't done anything wrong! I thought you might want to know where to post in the future for more targeted exposure. :)
Hi /u/ONCEisONCE, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/HuckleberryC, For javascript help, please visit /r/LearnJavascript. Thank you!
If you want to look at a simpler modern build tool check out https://rollupjs.org/guide/en
If you know react you can build a decent Vue project in an afternoon. 
in other news-water is still wet
Marko here, from the CxJS development team. We worked very hard on CxJS for the past two years and now the framework is ready for general use. You'll find CxJS very useful if you're developing applications which heavily rely on data tables, forms and charts as these are included in the package. Anyone who register on our webiste can get a license for free. If you like the product and your company decides to use it for a team of three or more people then a license should be purchased for additional developers. 
I looked at Elm and it actually looks pretty awesome, but I'm unsure of what exactly it does. It can make HTML and JavaScript code from what I've seen, and it looks more clean, but what is it supposed to be..?
Yes, but you’d be surprised at how many people don’t know it. I always ask that as the first whiteboard question and only 1 person of the last 15 or so did it that way instead of using a for loop. 
The key difference is the data exchange between the two threads. In the case of web workers, threads exchange messages, and you must declare special functions to process them (myWorker.onmessage = function(e) { ... }). In the case of threads, the exchange of data is very simplified. You do not need to write any handlers, you can simply access the necessary variables at any time because both threads have the same scope.
Very interesting. Thanks a lot. I'll try to implement.
I would find it hard to believe that any comp sci course would start with assembly and not something like c# or java.
Great article thanks man! 
heres the chunk of code I have, pls dont laugh im not good at coding int numArray\[\] = new int\[10\]; int random = (int) (Math.random()\*10); numArray\[1\]= random; numArray\[2\] = random; numArray\[3\]= random; numArray\[4\] = random; numArray\[5\] = random; numArray\[6\] = random; numArray\[7\] = random; numArray\[8\] = random; numArray \[9\] = random; numArray \[10\] = random; for (int i = 0; i &lt; 10; i++) { } int i = 0; System.out.println(i + random);
This is your home page: [https://imgur.com/a/q8kpMkE](https://imgur.com/a/q8kpMkE) on Firefox, with a common configuration.
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/qTcloYT.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20e2mi5fw) 
I think you've landed in the wrong subreddit. What you need is /r/java or more appropriately /r/learnjava ;)
Thanks for reporting. It's very strange. I just tested and it works fine. Did anyone else experience the same issue?
My first question is always; `You've got a container with 1000 &lt;div&gt;'s inserted on load, we want to observe when a &lt;div&gt; is clicked and console.log the element. How would you approach this? ` I use this to see if they suggest event delegation, if not I then ask; `An additional 1000 &lt;div&gt;'s are going to be added every 5 seconds, how would you ensure those are also being observed?` If they still don't suggest event delegation, i'll explain it ask if they know what it is and then go to some simpler questions. Usually those that know the above are competent enough developers that have actually built something worthwhile and not just thrown together some jQuery scripts.
The review on a PR is great idea.
I'm not entirely sure what Elm does, nor have I ever heard of it. It looks really interesting though, what does it do?
(I'm so sorry for the length of this...) I don't know how to answer the question you're asking (maybe I'm thinking too deeply about it?) but: Just like many of the tools and languages that sprung up around JavaScript (CoffeeScript, TypeScript, ClojureScript... the list is maddeningly long), it's someone's attempt to make a language that compiles to JavaScript that follows the functional language concepts of Haskell (and others). It abstracts the DOM (Document Object Model - how browsers deal with the HTML) making it easier to work with and in the process faster (Virtual DOM - Popularized by React, used by many now including Vue and Angular). It introduces state management techniques and features from functional languages. Functional languages attempt to look at development from a higher level. Instead of telling the computer how you want it to do something, you tell it what you want it to do. The most popular examples of this revolve around processing all the items of an array/collection. In JavaScript you have to be very explicit in what you want to do with each item (there are shortcuts now, but historically you would use a for loop like this): for (var i = 0; i &lt; array.length; ++i) { newArray[i] = array[i] * 2; } You would need to create an index variable, initialize it to 0, on each loop make sure it's under the length and increment the value by 1. You'd have to do this for every instance of every loop. Functional programmers think that doing the same operation multiple times is not the smart way to program. Every developer knows a for loop because every one of us has written them thousands of times over. Why do we do that to ourselves? (yes, it's faster in most cases, but that's a deeper conversation) Now you can do: newArray = array.map(item =&gt; item * 2); Because of ES6 shorthand and JavaScript accepting more of the functional form which Elm fully embraced. In Elm, you tell it to just go over the collection and perform (map) some function (`(* 2)` - 2 times ?) on each item: newArray = map (* 2) array Now, that looks like JavaScript has caught up, right? It's not so simple. I've already shown one technique that functional development easily allows (currying). That "`(* 2)` - 2 times ?" strange looking thing I used? That's actually calling the multiplication operator (*) with a single parameter (2). Conventionally, the function comes first. What you want to do followed by what you are doing. Since you need two numbers to multiply (x * y) I'm missing one of the values! (* 2 4) -- 8 2 x 4 = 8. But I just used `(* 2)`. So you'd expect an error since I never told it what to multiply 2 by. With currying it returns a new function that's waiting for that value. That new function is passed into `map` along with the array. `map` handles iterating over that array, performing the operation and returning the new object. Now, remember when I said that you tell the computer what to do instead of how to do it? If your program calls for multiplying a lot of arrays by 2, you can do this: multiplyAllBy2 = map (*2) I now have a function called multiplyArrayBy2 that will multiply whatever array I give it by 2. newArray = multiplyAllBy2 array anotherArray = multiplyAllBy2 thatArray So if you find yourself doing the same thing over and over again, it makes sense to give that process a name. You could go through and create all the methods needed to do this in native JavaScript but the format is unusual for functional developers in the same way that functional development is unusual for 'conventional' developers. That, in essence, is what Elm is trying to do. It's creating a language that compiles to JavaScript that allows people to develop in a functional form. Does that make sense?
So the benefit is in short but numerous processes rather than offloading a larger process? If so that makes a lot more sense to me. It sounds interesting, I'm still very much in the "I can use it, but don't understand everything about it" phase of my career. Can I ask why not just run node on your hardware though? Or would this be used instead of a language like C?
Sort of makes sense. When you used the ( * 2 4 ) example, I'm still lost as to what is going on behind the scenes to make the output 8, you said something about it returning a new function to a map? How exactly does this map work if you could explain it to me? Other than that though, when you showed me the Array * 2 example it actually looks really convenient. Imho functional programming looks very hard to master but it also looks a lot faster than any OOP-Language I've seen. I do not think this will be the first thing I delve into, especially when it is not that popular yet, but its something to note. A bit off topic, but can I implement Elm in markup and styling as well? I see myself using this instead of JavaScript in the future, as it still compiles into JavaScript it is just faster.
Also found that #2 a good little one, first rough stab https://jsfiddle.net/Phunky/s8zLdx1k/ Reminds me that for our last round of hires we started giving people a little task pre-interview to hopefull put of those that are not up to the task. https://bitbucket.org/snippets/mobilleo/zeanbb/lets-play-snap
&gt; Just like many of the tools and languages that sprung up around JavaScript (CoffeeScript, TypeScript, ClojureScript... the list is maddeningly long), it's someone's attempt to make a language that compiles to JavaScript that follows the functional language concepts of Haskell (and others). It abstracts the DOM (Document Object Model - how browsers deal with the HTML) making it easier to work with and in the process faster (Virtual DOM - Popularized by React, used by many now including Vue and Angular). It introduces state management techniques and features from functional languages. Functional languages attempt to look at development from a higher level. Oh, you also mention that the Document Object Model is abstracted and made faster. What do you mean when you say that the DOM is faster? Faster to develop sites with? Faster for the browser to see? Sorry, I'm asking a lot of really basic questions but your help thus far has been really helpful. Thank you. 
Maybe I am showing my age :) None of these existed when I was sharpening my tools.
It's not necessarily faster. Maybe faster to develop later when you get used to it, but fundamentally you are constrained to the JavaScript VM. There are techniques used in native functional languages that make memory management blazing fast that are not readily available, but for this conversation we are stuck in the JavaScript VM. I mentioned that in functional form the function comes first. Multiplication (*) is just a function. It takes two values and returns a value. This is denoted by the following definition: * : (a -&gt; b) -&gt; c multiply takes `a` and `b` and returns `c`. It will also take just `a` and return a function expecting `b` which will return `c`. &gt; A bit off topic, but can I implement Elm in markup and styling as well? Short answer? You don't need to. ;) . Long answer? With the virtual DOM you don't need to put code in the HTML. The CSS is a bit more complicated. Let's just say no for now. Stylesheets should be static items for the most part. 
[object Object] 0
+1 for CRA. I don't care if you're using React or jQuery. It is a good choice.
It's not my intention to be an asshole and these are low priority things, but A) consider using spaces instead of tabs and B) Indent the constructor body. These things make it unnecessarily hard to read the code. For point A, at least on GitHub. For point B, fix it. It is hard to read.
 const displayAnswer = eval(this.state.internalQuestion).toString(); If you actually need eval, use new Function(code)(). Right now all surrounding variables will be available to the eval string.
If you weren't already aware: https://github.com/tc39/proposal-pattern-matching
[Zz1995aJ](https://www.reddit.com/user/Zz1995aJ) should adopt [prettier](https://github.com/prettier/prettier) (or eslint) to their project to address a lot of obvious inconsistencies in code formatting. 
I'm with you guys. I learned c# and Java in school and I actually liked it a good deal, but when I found python and started using it, I loved the fact that I didn't have to worry about 'silly' typing. Now, as I am developing more and more complex applications, I'm finding that I generally miss typing and the errors it prevents. I just recently discovered type annotations for python and have been using them wherever I can so that helps to curb some of that. I'm also learning a good deal of javascript too, and glad that they implemented annotations in the same fashion. Going to be giving TypeScript a whirl as soon as I get my head fully wrapped around ES6
Alright then. One more question, difference between Virtual DOM and regular DOM? I promise this is the last one. Thanks for all you help. 
I just finished doing this 50% of the way there. If you want to hop on a call on me. We turned meteor headless and are using it as an API only. We have a plan to fully phase it out. We did this with a very small team. It’s not something I’d be into explaining over PM
I am just amazed that this framework / library still exists (this is basically the old JavascriptMVC IIRC), and that anyone uses it. Not that I am remotely interested, but if nothing else, top marks for persistence
&gt;I suspect lots of bootstrap sites look the same because they are front ends slung together by back end devs and it looks a lot nicer than it otherwise would. Yup, that's what I've used bootstrap for. I know a fair share of html, css and learning js, but my background is backend or native app development. I recently started building a string of web apps for my company and since I have deadlines and am pretty much building them all by myself, frameworks like bootstrap help me come up with a decent looking interface relatively quickly. Does it look fantastic? Not particularly, but it certainly does like nice and it works so that's where I leave it. If it were customer facing, I'd probably be working with marketing to customize a lot of the look
Whatever you decide, forget CoffeeScript, it's as good as dead.
Thank you for the insight. Very helpful!
 const displayAnswer = new Function("return this.state.internalQuestion")().toString(); Is this correct? Also thanks for your feedback.
Is this for your job?
Think of the Virtual DOM like a library for handling the document updates. Historically, DOM updates can be the slowest part of website performance because every time you update the DOM (the HTML) the browser has to re-render parts of the page and apply all the styles and content shifting required to do that. The Virtual DOM is a software implementation of the DOM in memory and whenever you make an update, it will momentarily pause to find out if you have any more updates and consolidate any changes into a single step. This helps keep the browser from refreshing the content every time you update a value.
I'm not familiar with anonymous async function declarations. Using a named declaration as follows works: const express = require('express') const bodyParser = require('body-parser') const low = require('lowdb') const FileAsync = require('lowdb/adapters/FileAsync') const app = express(); app.use(bodyParser.json()); const start = async function() { const adapter = new FileAsync('db.json'); const db = await low(adapter); app.get('/posts/:id', (req, res) =&gt; { const post = db.get('posts') .find({ id: req.params.id }) .value(); res.send(post) }); app.listen(3000, () =&gt; console.log('Listening on port 3000!')) }; start(); 
Thats pretty fricking sweet, alright then. Thanks for this information, this reason alone gives me a pretty good reason as to why to learn Elm after I've learned Vanilla JavaScript.
Hi /u/shehryark4, For javascript help, please visit /r/LearnJavascript. Thank you!
If you are OK with first learning all of ES5 and then what’s new in ES6, you can take a look at my books (free to read online): http://exploringjs.com
Thanks for making the list.
* https://stripe.com * https://github.com/stripe/react-stripe-elements
Why not just use Vue Portals and place your modal component at the root level then just use Vuex mutations to toggle. 
why do you need webpack to create an iframe? 
People say angular is popular... but there are like 10 vue and react libs in the list, 0 angular.
Very nice, I just recently read through one of your posts on the spread operator - great content.
Or just `"use strict";` at the top of your file and `eval` is evaluated in strict mode too.
Where is this line gone db.defaults({ posts: [] }).write() ? Also, just as a general notice, it's bad practice to not handle exceptions. Node already deprecates uncaught Promise rejections. Just `(async(fn))().catch(console.error)` should do the trick 
In technical writing, you should never assume the reader understands a domain-specific acronym. It would help the reader to have, in the first paragraph: In the world of web application development, Progress Web Applications (PWA) are blah blah blah The only way I was able to understand that's what the acronym was in this context, was by inferring it in the second paragraph after your problem statement.
&gt;This organization structure, combined with the global-ish nature of JavaScript in the browser, has made us build the desktop client UI out of many small, self-contained web apps called Spotlets. They all run inside Chromium Embedded Framework, each app living within their own little iframe, which gives squads the ability to work with whatever frameworks they need, without the need to coordinate tooling and dependencies with other squads. While this approach has the disadvantage that we have many duplicate instances of different versions of libraries, increasing the size of the app, but it offers the massive advantage that introducing a library is a discussion between a few people instead of decision that involves ~100 people and their various needs. Not only would such a big discussion extremely time-consuming and hard, it would also force us to use a least-common-denominator approach to picking libraries, instead of picking the ones specifically tailored to the problem domain of each squad. This frame model is also corroborated in Spotify's [Spotify Squad framework — Part I](https://medium.com/project-management-learnings/spotify-squad-framework-part-i-8f74bcfcd761) under "Decoupled Releases" I imagine that the natural inclination of a company towards scaling is to _standardize everything_ I'd be very curious to hear what discussions brought about this seemingly insane solution. Does anyone else do this? Does Spotify still do this and do they regret this?
I don't need webpack to create an iframe. I know there are lots of opinions around webpack, as well as the use of iframes and using react to create an app. I wanted to know if anybody decided to compile those opinions into something like react-create-app to help those learning how to build a widget
Looks normal to me.
I don't know if you'll find anything like that. One of the main points of react is to break your app into separate, reusable components, which could basically be construed as a widget. I think the iframe approach might be counter-intuitive, but I could be missing the whole idea of what you are trying to do.
Really helpful to scan through this and tuck the knowledge away - never know when I might need one of those!
Is CanJS no long built with jQuery in mind?
I’m very much a beginner in JS, but really found https://eloquentjavascript.net to be the best for my learning style. It’s worth a look. I started with YDKJS and purchased physical copies of the first three books but still prefer eloquentjs.
Yeah I was wondering why no Angular. Kinda annoyed if not a good reason for that. Dunno why someone(s) downvoted u
What do you mean by adding a time out? Sorry im still new to Javascript. 
Ahh well hmm, I was kind of making fun of angular. But your post made me realize that this is a curated list rather than an objective "trending" list. Hmm.
What are the itemId, fileName and bufferData variables?
Ahhhh, curated. Kinda guessed and makes sense now. Ng purdy kewl 2 me. 2.x so much better and simpler so i didnt mind the new version. Cheers
then why are you talking about iframes? iframes have nothing to do with react.
Awesome article! I used to have so much headache managing dependencies between karma, mocha, chai, and getting it to work with a webpack config. Even learning about web testing environment is kinda daunting. This approach seems much simpler and easier to maintain.
You can also use jasmine-style describes and its instead of test. This allows you to use beforeEach and afterEach for better build up and tear down of variables between each test. I also prefer Jasmine's spyOn function rather than just.fn because Jasmine automatically cleans up spies, while jest requires extra code.
thanks, i've been wanting a guide/examples on unit test. im a junior level developer and haven't yet learned UNIT testing yet.
Check out PayPal’s zoid: https://medium.com/@bluepnume/creating-a-cross-domain-react-component-with-xcomponent-fbcccc4778fd
First of all they used stars to measure popularity, which is a bad metric. Maybe they could've used issues, comments, PRs, commits, etc? Would be more interesting. I can click star on a project and forget about for the rest of my life. Second this is popular in open source... on github, it does not mean angular is not popular in general. Overall very stupid article, and angular sucks.
\[Eloquent JavaScript\]([https://eloquentjavascript.net/](https://eloquentjavascript.net/))
This is cool!
Vuex is popular but still - there are many people who doesn't use it
If you’re using angular I feel bad for you son I got 99 problems and a digest loop ain’t one 
So many release candidates with breaking changes. It's what made me finally jump to React. 
Probably in June 2018 no new cool angular library has popped out or bumped in a way that created hype or interest among the community. I can see that those libraries had been recently bumped with new big features or sponsored on different channels (Twitter, mailing list, etc)
Which had like 16 mqjor versions in a year. Human being is a mystery. One can jump on a pre-release product and be so frustrated it os still in development.
Lucky us we have a stackoverflow with 99 answers
I don't get the hate for angular. It feels like it's just the cool thing to do, like hating php or in other circles hating javascript... Sure, upgrading from angularJS to angular was between a pain and impossible. But that's 4 versions ago, and every upgrade since has been a breeze. Angular is what introduced most people to some good patterns like dependency injection and some proper mv* work. Now I've only done some exploring in react, and I did like it, but I didn't find a compelling reason to change my preferred framework from angular to react. Both work fine, and one I know. 
Maybe to do with the all-in-one nature of Angular making it less necessary to use extra libraries.
Popularity among jobs and github is different. In Italy there's way more Angular than React jobs and Vue is close to non existent e.g. It's not just here like that. Angular is still very popular.
You got downvoted for how you explained it, and your last line too, but I agree, measuring popularity by github stars is beyond pointless.
React is a library, not a framework tho.
Do you have a repo for the project?
No, sorry. But the basic structure is a server rendered react app where the service worker is included on the client and I'm trying to cache all responses from the server.
&gt;If you weren't already aware Really, I didn't know! Thank you so much for your help!
1. A static type system that automatically creates a runtime type schema which can be used for runtime validation 2. A built-in type that encases the possibility of both `null` and `undefined` 3. Instead of operator overloading, a macro system. 4. Operators are functions, not symbols. Function calls can be prefix (`f(x, y)` === `f x y`) or infix (`f(x, y) === x f y`) 5. Functions support weird names - .e.g. I can create a function called `&lt;--` if I want. 6. Pattern matching 7. Tail-Call optimisation 8. Guard operator for null references e.g. `let x = some?.object?.that?.might?.not?.exist || null` 9. A built-in primitive for coordination of concurrency (CSP channels, Saga pattern or the Actor model) 10. A pipeline operator 11. Built-in currying (with support for placeholders) 12. A cascade operator for getting/setting properties of variable neatly in a chain 13. `try` / `catch` is valid inside an expression
I kind of just comment and forget unless someone replies, if a comment "fails" thankfully doesn't affect me. In this case I had to comment because of how low effort this "article" is. Let me save everyone here some time, check this out: https://github.com/trending/javascript?since=weekly
I didn't think about it as whole blog is kinda related to web applications, but it's good point, thanks.
It went from 0.x straight to 15 with class syntax instead of createClass (which is still forward compatible) and then 16 with a couple of minor refinements and additions (which can be made backwards compatible). See: https://twitter.com/dan_abramov/status/1017409804308905986
Yes, the benefits of threads are precisely this. Threads (or as they are also called "light processes") exist in all modern operating systems and are supported by most programming languages. Threads require much fewer resources than processes because the operating system does not need to switch the context of the task. However, they allow you to perform several tasks simultaneously. Consider a function known as setTimeout (). It will call a callback after the time has elapsed. But this is not exactly its description. In fact, it will not call a callback before the time runs out, but because at the moment when it's time to call a callback, a single-threaded JavaScript can perform some other task. And your timer can actually triggered much later than you want. Try to call setTimeout () with a time interval of 1 millisecond. Yes, it will work, but only after Javascript is "freed" to process your callback (most likely it is more than 1 millisecond) since it "does not know" how to perform functions simultaneously. Now imagine that you have multithreading. The timer will trigger and launch the callback in a separate thread. It does not have to wait for the main thread to finish executing. The main thread can do something "heavy", but the programmer should not care, because the timer will trigger exactly through the declared interval. As an added benefit of the above example, I can measure time intervals of less than 1 millisecond. How about 250 microseconds? In my implementation, it now works. I can not start Node on my hardware. This requires, at a minimum, an operating system and somewhere around 100 megabytes of RAM. I have neither one nor the other. Of course, now I'm testing under Windows and Linux, because it's easier. But the final product will run on very small systems. It is quite enough and 16-32 MB of memory for small programs. Why not C/C ++? Because I love Javascript)) I need a prototype inheritance, garbage collector, associative objects ... My tests show an acceptable performance reduction when using the interpreter. I can completely control the stepping motors, servos in my milling machines, get data from sensors, etc. It just becomes much more convenient than in C/C++.
[removed]
I've never heard them called that. I could understand 'popout', but popper (besides what it's typically associated with) sounds like it's something to do with arrays, or even animations.
I really liked the repo with algorithms. Very well written - perfect for refreshing memory before future interviews
I have experience in both Angular and React. The thing I realized was that even though React is a great UI library, it can't come close to the organization and modularity that Angular possesses by using Typescript.
[removed]
Sorry for replying this late, but if you checked the example that I'm stuck at, you'll notice that it is very much similar to this..
Nice article. The `setup()` function got me thinking. I never thought of it like that before and I appreciate the article. But in your `typeEmail(value)` function the `email.value = email` should be corrected as `email.value = value` right?
Thanks for your remark. It's a good point. I hope you enjoyed the article anyway
I think the "w3" in w3schools is just a gimmick. They're not affiliated with the W3C. Class and prototype OOP are not necessarily better or worse, but they're different. With class OOP you define the blueprints for the objects beforehand. You can't change then at runtime. Your only choice is whether to make an object use this blueprint or that one, but you can't make objects deviate from the blueprint. With prototype OOP the blueprints and the objects are fluid. You can modify any live object and change it however you want. You can modify a blueprint at runtime and all objects that were based on it will change on the fly. You can pretend to do class OOP in JavaScript, pretend the blueprints don't change, pretend that access modifiers like private/protected/public still make sense and so on, but you're missing out on what the language had to offer and run into some frustrations when the analogies don't hold. Not to mention going down a completely wrong path, conceptually. I still wish they would have picked a different keyword instead of "class" in ES6, because it just reinforces this fallacy.
That’s nice to hear, thanks!
I haven't worked on a Vue project at all yet, nobody seems to use it in my circles. Plenty of Angular and React about (UK)