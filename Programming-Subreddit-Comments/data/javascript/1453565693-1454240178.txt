If you're building a web app like Facebook or Twitter where you are constantly loading in new content then SPAs are great. If you're building something like Wikipedia where most of the content is static then a traditional MVC framework is probably better. 
It's on their website...
http://gr1d.org/home
It depends on what you want to do. For example, you can use it for initialization: function initRest(baseUrl) { return function(restMethod, parameter) { var fullUrl = baseUrl + restMethod + "/" + parameter; http.get(fullUrl); }; } var restUtility = initRest("example.com/restapi/"); restUtility("test", "hello"); //will call 'example.com/restapi/test/hello' restUtility("version", ""); //will call 'example.com/restapi/version/' This ties in with your original question about closures because that *baseUrl* you passed to *initRest()* is captured (stored) by the inner function and does not need to be specified for every call thereafter. 
Cool, thanks. Doesn't look like production-grade project though.
Ah yes good point. Still not good practice to be willy nilly with types like that. 
Well as far as I know there is also the difference that in the ES6 shorthand, the resulting function is not anonymous. While in /u/pkkid's example the function is anonymous which means stacktraces etc will be a little harder to read.
But the result of the inner function is to console log 'dude', which it does.
It looks like they also added a flag to allow it for insecure contexts, so developing on localhost shouldn't be impossible. 
I changed the `console` line to `return console...` and I get the same result in the console. That is the result that I would expect, but...?
I wasn't sure about that, so I looked into it a bit. As far as I can work out, the shorthand *does* produce anonymous functions. Chrome DevTools will infer the function name from the property name anyway. Try running this code. let obj = { method() { console.log(method); } } obj.method(); You'll see that `method` is not defined within the function, which it would be if that were the its name. Still, I'm glad you brought it up because that's not something I knew before.
This would work and I appreciate the response, but idk if this is fullcalendars default way to do it. In the documentation it discusses recurring events being added after version 2. Weekly recurring events use the dow property. But there is no mention of how to implement daily recurring events. For my situation I can't use a function because the events are being read in through a json feed and I don't think I can perform a function after reading the json in. 
Learn 5.1 first, 6 isn't yet widely adopted by browsers and developers. 
The issue here is that you have asynchronous code inside the for loop. So what happens is the for loop is executed very quickly (before the async code can finish). So your variable pictureCounter is now the number 5 (because it incremented, and did the check &lt; 5 which failed, and popped out of the loop). Once your async code comes back and executes, that variable is still 5, and that is why you are seeing the behavior like that. Gimme a sec to rewrite the code how you want it (I'm on mobile) EDIT: I'm so sorry for formatting, again, I'm on mobile...) 
ES6 is current JavaScript. ES5 is old JavaScript. And I highly recommend you learning ES6, since it has a lot of new, really useful things. This is a really good book to get you started with up-to-date JS: https://leanpub.com/javascriptallongesix/read
Thank you for your detailed response. Blocked-scoped declarations not supported outside of strict mode is the response I get to this :(
You should be using a transpiler anyways, so there is no point in worrying about browser support (unless you are a poor soul that has to support IE8 and below). As for developer support, who cares? I don't think it hasn't been widely adopted, but I can't see there being any downsides to being ahead of the curve. ES6 WILL be widely adopted, it is only a matter of time.
Put `"use strict";` at the top of your function.
Not at all, you've been a terrific help and I've understood everything you've said! Thank you.
Meteor is a strong choice.
Thanks guys, I really, really appreciate the responses. To elaborate further, I'm coming from a lack of experience standpoint and don't know squat about JavaScript. I guess my question is how close does version 5.1 parallel version 6? Like, would reading the book I got serve as a good pathway to learning version 6 or are the changes between versions so significant that I should just start out with a book on version 6?
How about they fix flexbox broken in 48 first?
Hi /u/the_legend_of_dave, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `davidvgalbraith.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [davidvgalbraith.com](/search?q=%28and+site%3A%27davidvgalbraith.com%27+author%3A%27the_legend_of_dave%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|9|90%
Oh, good. I thought there should be some localhost exception, but that's cool.
1. bind the onclick for the radio to the same fn as the checkbox. long answer: if checkbox and radio are used together to calculate the total, extract the logic to a single calculate function, run that same function when either one is clicked/checked. easier to debug too. so it looks like your missing the radio.onclick handler. 2. tTotal.value is not liking number values/digits i think (you cant add 1.23 to "$0.00" because of the "$" is a string... so no $ until the calulations are done. if you still have problems: i would use a local variable to store a temporary total. and i would change the `if(chk1)` to `if(chk1 &amp;&amp; number(dtotal) != 0)`. 3. use the var total above then `if shippingChecked total += 10` and print the output again 4. same as #2 example code for #2: var total = 0.00 if (chkShelf.checked &amp;&amp; Number(sTotal.value) != 0) total += Number(sTotal.value) if (chkDrawer.checked &amp;&amp; Number(dTotal.value) != 0) total += Number(dTotal.value) if (chkDesk.checked &amp;&amp; Number(deTotal.value) != 0) total += Number(deTotal.value) if (chkShip.checked) total += 10 tTotal.value = '$'+total.toFixed(0) // or whatever, note this is now a string for sure, input boxes might always be a string randomly if they check a radio button its nice to check the checkbox for them. (if its the same click handler its like 1 line of code, `if (e.target == shelf2) checkbox.checked = "checked"`) random #2: idk i heard people are using 'input' or 'oninput' instead of onclick now for these, (so they can support keyboard selection), not sure about it tho. the other response is rly good too, like a lesson in JS, would read that also. :) gl!
would be nice
Learn JavaScript first instead of learning a framework, that'll help in the long run. 
You'd rather layout took priority over security?
&gt; True, the endpoint could just pipe it to the NSA. But assuming the service isn't malicious [...] If the servers are in the US (e.g. if you use AWS or whatever), the NSA has access to it.
localhost will most likely work without https
They can work on both simultaneously, you know.
what about this? document.getElementById("action").addEventListener("click", function(){ var myArray = []; var html = ""; while(myArray != 'a') { for(i=0;i&gt;=myArray.length;i++){ myArray[i] = prompt("Enter an item to add to the Name list (enter \'a\' to quit",""); html = "&lt;ol&gt;"; html += "&lt;li&gt;" + myArray[i] + "&lt;/li&gt;"; html += "&lt;/ol&gt;"; var x = document.getElementById("todo-list"); x.innerHTML = html; } } }); maybe Just needed to create another loop so it doesn't keep erasing the previous value?... or something. Also don't have "a" working yet.
Hi, I made something like this once. http://newsmapp.nl Source is here https://github.com/romeobravo/newsmapp Hope it can help you. It is an implemtation of jvectormap, you should look that up.
Does it work for wildcard domains? Then you could write a DNS server (or use an existing service, if there is one) that transparently translates domains to IP addresses. 10.0.0.32.example.com --&gt; A 10.0.0.32 Then you could just instruct Chrome to allow it for all *.example.com. That is, if Chrome allows for wildcards.
edit: can use the .entity method i described in other post yea if you want you can use two variables so you dont have to create all those Image()'s.. but even with this code they are still created, gonna have to factor it out to two classes probably top of the file so the animate() function can get it: var sprite = new Image() sprite.src = "pokeball.png" var pokeball = ...... old code then in animate: function animate() { context.clearRect(0,0,canvasWidth,canvasHeight); var pokeballsLength = pokeballs.length; for (var i = 0; i &lt; pokeballsLength; i++) { var tmpPokeball = pokeballs[i]; tmpPokeball.x += tmpPokeball.vX; context.drawImage(sprite, tmpPokeball.x, tmpPokeball.y) }; if (playPokeballs) { setTimeout(animate,33); }; };
I think most users became acquainted with MEAN as a bundled stack. True, MEAN doesn’t “need” to come bundled but it sure makes things a lot easier when getting started (especially if you’re very new to the stack). Having basic authentication, authorization and user administration out of the box can be a big hand up. As far as the use of Express.js is concerned, there seemed/seems to be no reason for an immediate change. The whole point of PEAN was to replace the “M” in MEAN (MongoDB) with a “P” (PostgreSQL) - which was a fair bit of work in and of itself. Seeing something similar using KOA would be cool though :) We’re with you on the use of PostgreSQL within a Node stack. PostgreSQL’s new NoSQL capabilities in combination with a relational DB makes PostgreSQL very appealing. Why choose when you can have the best of both worlds? 
I honestly expected this to be [1, 2] due to how Immutable does Map.toArray(), as it makes the most sense to me. An array from a map should be an array from values as a default implementation, with explicit calls for keys and entries. (I can see the argument for all 3 being explicit too). Alternatively I was expecting an error, as everyone else here seemed to be. I was not expecting what the actual answer was. That's terrible.
i added an example to my last post, idk if that helps. gl!
[Imgur](http://i.imgur.com/CcefOO6.png)
But they have enough resources to work on both.
Interesting! I use babel to transpile es6 to es5 and I think babel does name the functions...
Check out: http://frzr.js.org http://freezer.js.org/minimum-viable-view-library ..and: http://github.com/pakastin/worker-example ;)
Look into Promises (ES6) and async/await (ES7). The ES5 solution to this are nested callbacks which are pretty annoying to use. Assuming "takePicture" and "turn" are async functions which take a callback: takePicture(function(picture) { console.log('got a picture'); ... turn(function() { console.log('done with turning'); ... }); }); If those functions return Promises and if you can use async/await: let picture = await takePicture(); console.log('got a picture'); await turn(); console.log('got a picture');
Yes, seriously, they are pushing for https everywhere and it's a good thing.
afaik React is a replacement to EJS. They vary quite a bit in scope, but with React there would be no need to use EJS.
Yeah, that's kind of what I was thinking.
Okay... cool. Did you see what I created? In the `powers` array (the list of all the powers), you'd just follow the pattern I used and take out or add in any powers you want. I don't really understand the stats part... So if you want more help with that, you're going to have to explain it to me more.
I took the title from [here](https://twitter.com/metromoxie/status/690238475946311681) From his profile he works on Chrome.
[**@metromoxie**](https://twitter.com/metromoxie/) &gt; [2016-01-21 18:24 UTC](https://twitter.com/metromoxie/status/690238475946311681) &gt; Starting in Chrome 50, geolocation will not be available in insecure contexts (i.e. only HTTPS embedded in HTTPS): https://codereview.chromium.org/1530403002/ ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
I've been working on a run time type checking library for a while. Mainly as a vehicle to learn functional programming principles, not because I expect it to be a thing. It supports pattern matching, typed functions and generics. I thinks its nifty, but I also realise it's pretty useless. https://github.com/Gwash3189/stronganator While I'm proud of the outcome, some of the tests and code need some serious refactoring. 
Theming just landed today! Enjoy!
when the user enters 'a' I need the list to write to the html in a numbered list.
lol ;)
For example if the user enters get groceries, wash dishes, cook dinner then hits 'a' it writes the following. 1. get groceries 2. wash dishes 3. cook dinner
It basically seems like they're using feature removal as a blunt instrument to get people to use HTTPS. I like the result but I'm not sure I agree with the methods. Has the potential to break a lot of old code.
That's not even remotely true. 
Pressure is meant to be less opinionated than that. You could set it up to do that if you wanted. For example in the "unsupported" callback, you could active an animation or something like that.
In my opinion it doesn't really matter what you do or where you start. Just start developing on a regular basis. You should also try to find a "mentor" someone who takes a look at your code and shows you where it can be improved. 
It's really cool what you made :-) the stats are the same as in a rpg game. how much dmg can your stand deal, which it's its range of action, it's resistance... For example, a fire stand with power e and range a all it would do is to act like a lighter 100m away from the user. How could I change that image to this one? http://vignette4.wikia.nocookie.net/jjba/images/4/41/Arrow.png/revision/latest?cb=20150523191621 I think it fits better because in the series, unless you're born with your stand power, the "arrow" is necesary to get 1
"Ah every language with anonymous functions and classes" FTFY. 
stats could be displayed in a table under the text Stat | Rank | ---------|---------- power | a | range | b | durability|e| precision|c| learning|d| something like this Edit: it's late in my country, gonna sleep, i'll answer as soon as I wake up
Obviously, not in any general terms, but in the context of trying to thwart/challenge people to trouble shoot with JS vs just copying scripts.
 document.getElementById("action").addEventListener("click", function(){ var myArray=[]; var v= ""; while(v != 'a') { v = prompt("Enter List Item", ""); if(v != 'a') { myArray.push(v); } } var s = "&lt;ol&gt;"; for(var i = 0; i &lt; myArray[i]; i++) { s += "&lt;li&gt;" + myArray[i] + "&lt;/li&gt;"; } s += "&lt;ol&gt;"; document.getElementById("todo-list").innerHTML = s; }); This works but it only outputs numbers not words. How do I make it output words also. Like when I enter 1,2,3, 'q'. it outputs 1. 1 2. 2 3. 3 However if I type any words it breaks and no output. 
actually I figured out if I change for(var i = 0; i &lt; myArray[i]; i++) to for(var i = 0; i &lt; myArray.length; i++) it now outputs words as well but then show an option 4 as undefined when I type 'a' . lol I know I'm close though.
&gt; Who cares if sites like that aren't https. People who wants to watch/monitor/track what you're doing online. Why is insecure by default a good thing?
I wanted to use JSPM and was hoping to standardize on it at my job after reading about SystemJS + builder, but I had a really hard time adding it to an existing workflow. SystemJS would not stop trying to transpile my code, even though it was already transpiled from ES6 to ES5 by way of TypeScript. Something in a code comment was triggering transpilation, and I couldn't seem to shut it off. I still have a TODO to reproduce and file an issue. Also, it is (or was) opinionated about which loader you should use (System). It would be nice to be able to use with Require or something else, similar to how JSPM can pull from NPM or GitHub...let me handle my loading and transpilation concerns. Do one thing (manage packages) do it well. I just want sane package management! 
But you, presumably, know much more about the site you are looking at then the average viewer and know how to keep to safe sites or determine when a site is sketchy. HTTPS also helps prevent other problems that are cropping up such as ISP or adware code injections. I've put together a JavaScript error monitoring solution for a decent sized retailer (and monitor it daily) -- you would, hopefully, be disgusted at the number of errors generated by such injections. Just imagine how many there must be out there without poorly written code.
~~https://jsfiddle.net/m2Lydc1w/~~ https://jsfiddle.net/62oh5qx6/ *https://www.reddit.com/r/javascript/comments/42dev7/rotation_not_working_on_first_iteration/
Ok, that's a good point. I concede. You're right, it's probably for the best. 
That's fine, there's too much coddling of old code as it is.
\+ `transform: rotate(0);` (line 22) https://jsfiddle.net/m2Lydc1w/2/
I too am swayed by this point
You're right, however as a JavaScript beginner you should probably stick to 5.1 because a JavaScript developer is most likely going to deal with 5.1. After the developers has gotten comfortable with 5.1 they should move to 6. If a beginner start learn 6 he will be bound to a transpiler for many year to come. He or she may have difficulties when using 5.1 because of the syntax differences that the beginner wouldn't be aware of. Also many great JavaScript books don't use 6, potentially making it more difficult to understand for the beginner.
Thank you for the detailed reply. I appreciate it. Do you have any comments about how running in a Node environment would possibly affect all this?
I thought this was going to be exploring angular 2.x, but nope, this is 1.x. If you're the author, you're a bit behind to be talking about the last major version. If you're going to keep writing about and using 1.x though, I'd recommend avoiding `$scope` as much as possible and use ["controller as"](https://toddmotto.com/digging-into-angulars-controller-as-syntax/) instead. I'd also recommend proof-reading your code samples, since there's a lot of inconsistencies in style and formatting, which made it somewhat distracting to read. 
What is the real flag? 
Nobody said insecure by default is a good thing all that has been said is insecure should be an option people should be able to chose. I can still run telnet even though I have SSH and it's fine in some cases and I need it in others. For my personal stance on this issue I think the future should move towards HTTPS (not forced to use but move towards) but there is no need to break things that used to work in an effort to try to force a change. Changes of this nature should have been restricted to future features added, not ones already out in the field.
Yeah, because in 1996 web sites were just collections of static HTML files. Few modern web apps work properly on archive.org. If a site is doing geolocation it's probably going to need to call a web service to look up some information based on that location, which isn't going to work on the WayBack version.
Ha-ha, you must be a product manager.
Enlighten me, then.
I use this in one of our client's apps, it works really well.
good parts is a terrible beginner book
You misunderstand what this encryption does and how it works. If your assumptions were true it would actually *hurt* Google to force encryption in this case. Here is an example: Unencrypted (current): A user with Google Fiber goes to Yahoo maps using HTTP and searches directions to a pet store, Yahoo uses the geolocation data to see they are at a shoe store in a fancy mall currently. Google Fiber could theoretically read this as it forwarded the data to Yahoo's servers and use the information to sell pushed ads for both shoes and pet products (I doubt they would, they have more cash efficient ways of selling ads but for the sake of argument) Encrypted (this announcement, worst case for user) A user with Google Fiber goes to Yahoo maps and searches directions to a pet store, Yahoo cannot get geolocation Data because Chrome denied it for not being done over HTTPS. The user manually puts in that they want to get from the mall to the pet store. Google Fiber could theoretically read this as it forwarded the data to Yahoo's servers and use the information to sell pushed ads for pet stores but the mall data is vague and harder to sell. Encrypted (this announcement, what Chrome is trying to achieve) A user with Google Fiber goes to Yahoo maps and searches directions to a pet store, Yahoo updated the server connection to use HTTPS with the security certificate Yahoo owns. Google Fiber cannot read any of this information and simply routes it to yahoo. They have nothing to sell to push ads. You are *very* rarely targeted by ads because of interception, it's costly, hard to do, and ever less fruitful as data switches to HTTPS. Your ad profile is made when you type things into a search or use a service. Googe, Yahoo, Facebook, Joe Schmoe's hotel booking site - all take your data (usually in a secure connection already nowadays) and either process it themselves (like facebook) or sell it to 3rd party ad companies (Joe Schmoe might use Google). The other way ad's work (well, used to thanks to security policies in browsers changing) is they'd read the page they were on and send the info back to home base. Iframes, better ad companies, and sandboxing have made this method obsolete. Anyways, this isn't forcing people to use Google's encryption only so they can see it - in fact that's not how HTTPS works and if Google tried that on a site it didn't legally own every browser would refuse to load the page. Things like this are a huge step forward in user data privacy.
Personally I always like to challenge myself with a project. In the past my biggest successes were making a minesweeper game, and an app that used a scraper on IMDB to download data about movies, to help track where you are in what show. These sort of projects forced me out of my comfort zone a little and helped me discover new cool technologies/skills/paradigms. I'm now looking into rewriting minesweeper to learn about various new tools/libraries I should be using.
Thank you! appreciate that. I solved it myself but this with comments is very useful for future reference. I figured out I had the closing &lt;ol&gt; tag inside of the for loop, and I defined the wrong innerhtml element originally. I am definitely new to this only starting learning about it 5 weeks ago. Just now learning about loops. 
I totally don't understand programmer conferences. Everything is on the web. Now if it was like BYOC week long hack-a-thon like a programmers version of QuakeCon, then I might be interested.
 Solved
Any chance you could combine the curves that share a width and draw those together?
The curves are procedurally generated, and the widths aren't integers - One might have a width of 17.432, while the next closest has a width of 17.393...
Regardless of the utility, you did a good job on the readme. You might consider a TOC since it's kind of lengthy, but other than that, it looks like a fun project. 
[This](http://draemm.li/various/plants/) is what I'm working on.
These are pot-shots from some past experience with canvas. They may or may not be total bullshit. YMMV/benchmark/grain of salt/flame me if I'm wrong. - You could do all of the drawing operations in a loop instead of one function call per line. The function execution comes with a cost and 10,000 function calls per frame could be avoided. You should still do each frame in a requestAnimationFrame function, but you don't need one per line. - You could clear smaller rectangles if you can calculate the bounding box of all lines ahead of time. - Avoid transparency on the canvas itself. Alpha within the canvas is fine, but if you're using it like a transparent background image layer, it could be eating performance to have to calculate and compose the image data of the canvas with the underlying window. - Are you separating the line calculation steps and the drawing steps or interleaving them? Trying batching the line calculations together and the draws together, or the opposite. I couldn't tell you which is quicker.
For any one diving into functional programming or wanting to learn more, I am starting a series of posts explaining the fundamental types. Today I wrote a post explaining Functors in Javascript. https://medium.com/@kaw2k/a-map-to-success-functors-in-javascript-6eb6638ce966#.oopom19fg
I know nothing about this version, but it might be what you want. https://github.com/tbprojects/siege_load_test
Yum
JS Lint http://www.jslint.com/ Warning: It will make you cry.
Cool, so is AdSense going to be fully HTTPS now? Because I'd hate to take a 90% drop in ad revenue to get access to these features.
I find it extremely difficult to learn as an academic pursuit - learning for the sake of learning. I learn what I need to do to get the job done. For example, I tried to learn React for ages and just couldn't pick it up. Then we started a new project at work that React was a good fit for, and it all just came to me and now we've built a big site using it and modern practices.
It's one of those things that you learn about, but you have to keep learning about how to use them. Some of these are easy to learn, like scope, where closures might take a little bit more time understand why and where to use them. Constructors, you must know how classes works and why they are important. Inheritance goes with classes also. http://www.w3schools.com/js/js_scope.asp http://www.w3schools.com/js/js_objects.asp http://www.w3schools.com/js/js_object_definition.asp http://phrogz.net/JS/Classes/OOPinJS.html http://www.sitepoint.com/simple-inheritance-javascript/ 
It turns back on when you release the space because you have 'keyup' being bound to start. If you want to toggle the stopwatch try something more along the lines of: window.addEventListener('keydown', function(event) { if (event.which === 32) { event.preventDefault(); if(watch.isOn) watch.stop(); else watch.start(); } });
Use "keydown" instead of "keypress". "keypress" is triggered when you type a character. "keydown" is triggered when you press a key. So, if you hold a key, "keypress" will be triggered repeatedly. 
Sure but there's also some networking 
As I said, I know why this is happening, but like I said in my second sentence I want it to stop as soon as you just press down on the spacebar button, I don't want it to wait until the key goes up.
Thanks for the tip, I'll keep that in mind. It doesn't really help with the problem though :/
It means, you can't drop an https iframe inside of an http page and get geolocation. The iframe and all of it's parent contexts must be https
But I only want that to happen for the Stop part. I don't want the stopwatch to start until the space bar is released.
Yeah, that's what I originally tried. The thing is, when the keydown is pressed, `watch.stop` will run which will make `isOn` equal to `false`, so once the key is released the `watch.start()` function will run anyway. Don't know if there is a way around this.
Ah, I see your problem now; what you could do is add a delay-inducing variable, such as below: var delay = false; window.addEventListener('keyup', function(event) { if (event.which === 32) { event.preventDefault(); if(!watch.isOn){ if(delay) delay=false; else watch.start(); } } }); window.addEventListener('keydown', function(event) { if (event.which === 32) { event.preventDefault(); if(watch.isOn){ watch.stop(); delay=true; } } }); This allows the keyup function not to start the watch on the same keyup as the keydown which stopped the watch
The things I look at whenever I conduct front-end web developer interviews are: 1) How well you do on my interview testing/questions 2) Personality 3) Github / Code samples 4) Experience you gained at your last position I rarely read past the top quarter of an applicants resume. There simply isn't time, and it's so easy to just jump on skype to get a first impression.
localhost is considered a secure origin. So, you're all good. No flag needed.
You already have the answer to your own question. If there was a certification that meant anything to a person reading your resume, you'd already know about it. The best way to target what you should improve about your candidate attractiveness is to get opinions on your resume/portfolio. See what others see as your weak spots and tackle them.
I don't think it's fixed unless you bundle in dev mode as well. But that sort of defeats the purpose. 
Comparing the two are a little like comparing apples and oranges. Webpack is not even close to perfect but it handles my build needs in ways no other build tools can currently. JSPM deals with JS whereas Webpack deals with all of my frontend assets and not just JS.
Have you done a test to see if looking up your points in an array is slowing you down. Are you creating new arrays for every curve? Reusing the same global arrays might help. I read somewhere that you should avoid using a point object {x:1,y:2} because simply looking up the properties was slow. Should use posX and posY rather than pos.x and pos.y. Not sure if the same applies to arrays. 
Hey, because you recursively call render, are you not creating new instances of all the functions you declare within render. I guess it's just calculate forces. I'm on my iPad on the couch otherwise I would play around with it.. Beautiful project. I would learn a thing or two :)
2 things seem to be not obvious to some of developers: 1. You can handle the same action in several reducers, mutating what's relevant. For example, "add comment" action might alter "posts", "comments" and "users" reducers simultaneously 2. Your components still see the whole state, unless you limit it with selectors. And selectors are fully independent from reducers I try to treat redux as DB and each of reducers holds normalized set of data
Everything can know about all of your state. You choose which actions they're permitted to fire and which state they're permitted to see. So don't worry about splitting the state. 
Great, Google Chrome is becoming less compatible with the HTTP and HTML standards every day :/
It's been answered that functions are objects but it's pretty easy to see this is the case. After all, functions have properties such as length, caller and arguments as well as methods such as call, bind and apply. You can add your own properties and methods to any function or even the global Function object, just like any other object.
Slides: http://www.slideshare.net/byrichardpowell/backbone-to-react-what-it-says-about-awesome-ui-code Video: https://frontendne.wistia.com/medias/j8w2tq1l17
I don't believe DI is something needed in node, as it's very easy to mock out the require statement with something like proxyquire.
I think I like this the best.
As an employer I'd probably laugh
but why?
One thing you might try is to remvoe/re-add events based upon the current state of the watch. Initially, you can add a keydown handler that prepares things, key up that removes that handler and attaches another one to stop the timer.... once that one fires, you initialize everything again to state 0.
yea, and it could cuz the game to restart each time, but ez to spot bug if it does? another reason having it in a seperate class would be helpful
When will this plague end.
javascript Tutorials #02 (for loop in javascript for activities )
Worse. He's a redditor.
I use this in a websocket chat to show unread messages. Good stuff.
Async? Is that some lib? 
&gt;What makes them so good? The networking, which in 2016 is the *only* reason to go to a conference. Go to ones where there are people you want to meet. Even if The Greatest Talk That Ever Happened occurs when you're there, it's a single talk out of dozens, and it'll be online in a couple of days. You go to conferences to meet people and talk shop.
Thanks! Edit2: I've found a solution but I don't know if this is the right way to do it and please read my additional question at the bottom if you don't mind! :D However, my solution is to use height: 100% !important; on the blue div. --------------- It seems like I have another stupid question :D. I am trying to build a basic flex box layout and I want the red flexbox to be as high as a typical navigation. I set the container to flex:wrap; and gave the red div a min-width of 100vw; (you taught me that! :D) so that the other two would slip into the second row. But when I now give the red div a min-height or any height (px; viewport,%) in general nothing happens. :/ I wanted it like this: http://i.imgur.com/tAYWjyt.png Here is the code: http://codepen.io/vancum/pen/dGdqQo Additional question: The parent is 100vh and 100vw (I am going for a fullscreen thingy) and I want this three boxes to be my base. The pink div is going to have a nice background image, the blue one is for content and the red one, like I said, for the nav. I am planning to put some flex divs INSIDE the red nav box for the navi (one for Home, one for Contact and so on). Does this make sense or am I running into problems? Love, vancum Edit: Oh wow, I thought this was a private message, I was confused. However, love for everyone! :D
Here's something I don't get with the Redux philosophy: how do you build large complex applications with many nested components? Since you can only pass props into the component from the parent, you get a recursive unpacking of props from the root to the leaves. It's demuxing the props from a complex object down to simple values as you navigate down the graph of view components. So as the complexity of your page grows you need to increase the complexity of the props object fed into the root component. But for this object to be complex you need a complex function to build the props object from the state, right? It needs to know exactly how the view is structured to be able to build an object that can correctly trickle down the component structure and be demuxed correctly. So either you end up with a God function that knows exactly how the view looks and is able to take the state and convert it into a props object, or (more likely) you create the mirror image of the view of a stateToProps object, that can recursively create the complex props object for the root component. So now you have two structures that need to be maintained in sync; the view and the StateToProps function. Make a change to only one of these (without a similar correct change to the other) and things fall apart. To me this sounds like it breaks the encapsulation principle. And so far we have only considered a single such structure, what if you have multiple pages? Wouldn't you need many such complex muxers-demuxers? Wouldn't it be better to have some components be self controlling and be able to get the state themselves (like in Flux)? Am I over thinking this? 
It's unfortunately unpopular right now to point this stuff out. React takes certain ideas from video game programming and Redux brings in an academic approach to creating single point of entry functional state. The web is experimenting with a lot of ideas right now (and reinventing many of them) -- but if you check out the more evolved systems for developing software, such as InterfaceBuilder for mobile or Unity3d/Unreal SDK for video games, you'll find that is _massively_ easier to do much, much more complex interactions. The thing is, all of these systems incorporate programming as an extension to rich interfaces. In game dev, roughly half your programming team is building tools, not direct game code. There seems to be an extreme puritanical love affair with the command line among web devs. As someone who's been coding professionally for 20 years (and longer as a kid), I don't see it staying it that way. Things move towards being easier -- such that cognitive overhead is reduced and we can work on ever harder problems. React, and Redux, and virtually all of the existing 'solutions' are not in the same league as tools for the desktop, mobile, games or even industrial PLC systems from 20 years ago. If you think it's finally settling on something, and you can learn React and move forward, get ready for the next phase of obsolescence...
You have no problem them, because no certification would be valued. 
First of all, I made a mistake when writing this. MAP_EDIT_MODE was state, not an action. It shouldn't have been ALL_CAPS. Thanks for noticing this and moving forward anyway. I think the main case for keeping my state un-sliced is that I might want it to make decisions on state mutation. For example, NEW_USER action is dispatched. My users reducer handles it but needs to know a few things to make the proper state change: * map_edit mode = false * if new_user not in scoreboard, add it to the scoreboard state * show_help_bubbles = true So if those three are managed in different slices of state by different reducers, I can't easily update those when NEW_USER is dispatched. You suggested two ways of handling this. 1) An action creator dispatches multiple events: NEW_USER, RESET_HELP_BUBBLES, DISABLE_MAP_EDIT. My concerns of this approach are: * Effectively pushing state mutation logic up into the action creators as that's now where I have to decide when to dispatch the other events. it just feels dangerous when I think about how that logic could become more complex or require more and more effects to occur when NEW_USER is dispatched. * I have to wander around my code to reason about how state changes. 2) Multiple reducers listen for NEW_USER. My concerns of this approach are: * This means that to understand what NEW_USER does to my app, I have to look everywhere to find all the reducers that listen for it. * more boilerplate, more switch statements Say I use an alternative: reducers are split up into multiple switch statements so that I can split it up logically into many thematic reducer groups. But unlike doing this with combineReducers, they all receive and affect the same state rather than slices of it. Is there anything that stands out as problematic with this? Why might this break down? I'll have to try it to be sure if there's no immediate obvious reason. This would allow me to break my huge reducer into multiple files but allow any single case to mutate any of the state based on one action. So I can then reason about actions more simply: we don't dispatch a bunch of them to do something, we dispatch one, because that was literally the "action" that was invoked. We have one place to look at entirely how the app's state mutates when an action is dispatched. Thanks!
Back when I did it, reddit called me drunk :D [github](https://github.com/jbebe/all-my-projects/blob/master/priv/web/javascriptLibrary/minJS.dev.js)
Nice explanation. Thanks!
Funny you talk about Interface Builder. There are people now trying to get Redux to work in Swift. I mean I admire their efforts , but I have developed for the web and iOS and nothing beats UIKit + Xcode for sheer development speed. Interface builder is really good but it also does have limitations. You can't do everything in IB though apple is changing that , you can now make your own custom views configurable in IB by adding annotations to your code. On the other hand you have FB trying to obsolete native dev through their related React native project. It'll be interesting to see where all of these end up a few years from now. My personal opinion is that for something to take off , it must be simple and easy for ordinary programmers to grok and use. Interface builder is simple. Angular.js was simple in a way (to get started) . Redux and friends are just adding way too much upfront complexity just to build a boring CRUD app.
Sorry about the formatting, I'm on a tiny screen.
&gt; Wouldn't it be better to have some components be self controlling and be able to get the state themselves Yes, and totally doable with `react-redux` and the `connect` function. In fact if you watch the [egghead.io redux tutorials](https://egghead.io/series/getting-started-with-redux) thats what Dan Abramov suggests you do.
&gt; Angular.js was simple in a way (to get started) . Redux and friends are just adding way too much upfront complexity just to build a boring CRUD app. Redux literally has an [API surface](http://rackt.org/redux/docs/api/) an order of magnitude less in size than [Angular](https://docs.angularjs.org/api). You can learn the entirety of its principle and application in an afternoon. How can you simultaneously defend Angular and critique "Redux and friends" on the grounds of complexity?
Answered part of my own question, got my code working but declaring request_obj = new XMLHttpRequest(); in the script file outside any function, that's messy though isn't it? the MDN says "Note that there are no parentheses after the function name and no parameters passed, because you're simply assigning a reference to the function, rather than actually calling it." So you can't declare the xmlhttprequest object inside the request function and pass it to the response? Feel like I'm being thick.
I'm not even saying one is "better", I'm saying the argument was poorly made.
having TLS as an option is great, but imposing this cost on everyone is a step backwards away from openness if your ISP is injecting ads, then switch to TLS or switch ISPs, but forcing TLS on everyone punishes the good ISPs (and their customers) by removing their competitive advantage (bandwidth is expensive in my area)
Super simple and straightforward, I like.
It's not just ISPs though, it's all sorts of malware. Google is doing the right thing for its users by helping to protect them against obscure threats that most are in no position to understand much less diagnose or prevent. Browsers have a long history of stagnating to protect this API or that protocol, I'm glad they are bucking the trend.
It's just a very disingenuous comparison to me to ignore all of the complex parts of angular to make a point about how angular simple is. Yes of course, if you ignore 95% of angular, then it's simple, but no one can realistically afford to do that. You will almost immediately need to learn about providers to configure e.g routers. Pete Hunt even [recommends to not over complicate it](https://github.com/petehunt/react-howto) and just stick with react until you need flux. All of these articles are for building applications with some complexity to them, if you just want to "start out" all you need is react. 
Could you expand on this a bit? I'm genuinely interested. It sounds like you're saying these graphical tools do a great deal more than an IDE or a library or framework. Am I interpreting that correctly? If so, would you mind explaining a high level overview of what all of the various pieces that make up the final game/app? Do you write code in well-defined places, that the tool performs code generation around? Or am I getting off track? What kinds of tools does half of the team usually produce? How easy is it to reason about the resulting game/app as a whole? Or are these tools useful for programs that are simply too large or complex to be reasoned about as a whole?
Title should be: "9 things React.js beginners don't need to worry about just yet."
Thanks for the reply, appreciate it. I'm just starting out, I've deliberately not looked at any libraries or frameworks yet. Sticking to vanilla js until I get more comfortable. I had to google the colon notation, I've only created simple variables so far, back from work and slowly working my way through understanding this. It definitely does help. :) 
the video is fantastic. So thank you for that. Just to &lt;pre&gt; up your example: var sites =[ 'site1', 'site2', 'site3'] var returnedData = []; function readData(data) { returnedData.push( { title: data.title, text: data.text} ); } function readError() { console.log(error); } for( site in sites ) { when(get(site)).then(readData).error(readError); } so a few questions about this example: 1) are there any limits on the number of sites you could be doing? 2) what other limitations exist for this sort of solution? Thank you
Either of the approaches suggested above are perfectly good and I've used them in large apps. The 2nd (multiple reducers responding to the same action) is probably the simplest and most expressive, but it really depends on the specifics. &gt;This means that to understand what NEW_USER does to my app, I have to look everywhere to find all the reducers that listen for it. Well, in the Backbone days we would've had a user model that contained all the state and behavior for the user in one spot, and meanwhile there are lots of other models floating around that can hold and change state as well, and that didn't make things very easy to reason about. Now all the logic governing application state for each area of concern is held in one place. Most of your actions probably won't have app-wide effects -- they'll generally only be handled in one place. And I'm not sure why it would create more boilerplate -- wouldn't you have to have a reducer for all of those areas of app state anyway? I don't think I follow your alternative proposal. It sounds like you're talking about mounting multiple reducers at the same point in the state tree, which I don't think will work. Maybe you could post a gist or something, but I think your best bet is to pursue the approach recommended above.
..nope, it's like trying to juggle 5th dimensional mobius strips whilst riding a unicycle after eating a cocktail of psychedelic drugs.
Make sense. B.R.
Personally I'm not a huge angular fan. I'm a fan of meteor, but I would not recommend going all out and learning both meteor and angular at the same time. I've developed several apps with blaze. The view layer meteor has used up until very recently. Due to this there are a ton of packages that will make your life a lot easier if you stick to blaze. I'm currently in the process of developing a Meteor react app and although I enjoy it, I have to do a lot of things from scratch that would take 5 min with a package and blaze. Consider buying the ebook called discover meteor. Best book for beginners. But uses blaze. Meteor is a great tool, but it is currently shifting massively. So don't marry a single view layer. Their main focus has been blaze and is the best supported one. If you're new to meteor, I'd try a few projects with blaze first. Unless you're building a huge or very complex app, blaze will get the job done just as good as angular, if not better.
I have the same view as you. With desktop applications, its very easy to do the program if you stick to the defaults, custom things on the other hand is a different story, you might need to redo the whole component just to do small changes. Web development on the other hand, lacks good default elements, but its much easier to do custom things.
I think this article, even though it's on the older side, explains the async patterns very well: http://www.aeflash.com/2013-06/async-and-functional-javascript.html Same here: http://www.sebastianseilund.com/nodejs-async-in-practice This one's good for an intro to promises: https://spring.io/understanding/javascript-promises And here's some additional reading on promises: https://gist.github.com/joepie91/791640557e3e5fd80861 The main you need to know, is that you're trying to handle data that won't be available immediately. Async and Promises are two ways to handle this. Async does this by passing the next function to run so that it can get called after the data resolves. Promises allow you to chain these events a bit easier, and provides more structure. With promises you can check states, and you can have better (imo, in terms on consistency and structure) error handling and chaining of events. The main thing to understand about promises. You create a function that returns a promise. Inside the function you declare the promise, and it's initial state is unresolved. The function returns the promise with an unresolved state (generally) and later updates the state to either resolved or rejected. You can then use .then() on the returned promise to specify the next function to get called when the function eventually updates the status to either resolved or rejected (or canceled in some implementations). The then function takes two parameters .then(nextFunctionIfResolved, errorHandler). I most implementations you will only pass in the nextFunctionIfResolved, and you will follow the chain with a .catch(errorHandler). ex: (assuming $http.get is a function that returns a promise) The following w promise chains are the same: $http.get("/path/to/endpoint") .then(function (response) { console.log(response.data); }) .catch(function (err) { console.error("Error: " + err.message); }); $http.get("/path/to/endpoint") .then(function (response) { console.log(response.data); }, function (err) { console.error("Error: " + err.message); }); The good thing about the first method is that you can chain multiple functions together, and a single catch at the end of the chain will handle any errors. Also, here's an example of mixing callback and promises for when you're using libraries that use callbacks. ex: assuming $q is the promise library, and fs.readFile is an asynchronous callback function that reads a file. $http.get("/path/to/endpoint") .then(function (response) { var def = $q.defer(); fs.readFile(response.data.filename, function (err, data) { if (err) { def.reject(err); } def.resolve(data); }); return def.promise; }) .then(function (data) { var fileData = JSON.parse(data); console.log(fileData.something.interesting); }) .catch(function (err) { console.error("Error: " + err.message); }); 
* Keep your components small...if you intend to compose them in another component somewhere. If the component is used just once, it may make more sense to include the relevant parts in the same component so I can immediately see what is rendered rather than sifting through 10 different files * use redux.js...where appropriate - which is when state is shared amongst disconnected components and has muiltiple ways of being changed. In many cases it is much more simple and maintanable to just use component state. * always use proptypes....for shared components - not necessarily for components used just once overall, write the most readable/maintainable code that makes sense for your case
Hey Buddy, want to say thank you very much for the input. This helped me quite a bit. I really appreciate it. 
I can't speak for angular but I've used meteor successfully in multiple projects recently. Why wouldn't you want to recommend meteor? 
Yeah, I'm currently rewriting the animate function! Thanks for the input. :)
&gt; but that shows the point Does it actually *show* anything? Take this line of Dart code: print(0x20.toRadixString(8)); Looks pretty much the same, doesn't it? However, Dart doesn't have primitives. That integer there is an immutable object. There is no observable difference between those two. The JS version and the Dart equivalent look both like regular method calls. This is why beginners often believe that everything in JS is an object.
fantastic! great info, thank you kindly :)
&gt; An action creator dispatches multiple events: NEW_USER, RESET_HELP_BUBBLES, DISABLE_MAP_EDIT. You're quite right; the drawbacks of this approach are that your action creators start to get "heavy" and tightly coupled, and it may not be clear in a reducer where/why actions might be dispatched. However, this method will work and is commonly used. &gt; Multiple reducers listen for NEW_USER. You're right here too; this means that it may not be clear in an action creator all the bits of state that may change in response to an action. However, this method will also work and is also commonly used. It should be clear on reflection that what'd really being asked his "how closely should my action creators be coupled with my reducers"; in the first case your actions creators need to know exactly how your state is structured, whereas in the second case your action creators have no idea. My preference is for the second, in general, as I don't think you gain anything with the coupling. &gt; reducers are split up into multiple switch statements so that I can split it up logically into many thematic reducer groups. But unlike doing this with combineReducers, they all receive and affect the same state rather than slices of it. Is there anything that stands out as problematic with this I'm not seeing the advantages. You'd end up with a *ton* of duplicated switch statements, plus now you'd lose a key advantage of Redux, which is that you can always work back from your state to figure out why is looks that way. Now if your help bubbles are disabled, you don't even know which reducer to start looking at. (This also opens you up to a whole new class of bugs; if you have two reducers listening to the same action but mutating the same state in different ways, then you end up with a race condition depending on which one executes first. Or if you have two reducers listening to different actions but mutating the same state, it'll depend on which one you dispatch first.) In a sense, you're just pushing the uncertainty around. Option 1 above means you don't know everything that might happen in response to an action; Option 2 means you don't know everything that might trigger a reducer. And now your option 3 means you don't know all the reducers which might mutate a item in your state. :)
It's a black box that doesn't conform to the rest of the javascript ecosystem.[ It's also highly in flux currently](https://www.discovermeteor.com/blog/the-state-of-meteor-part-1-what-went-wrong/). A simple koa/express server with a react/redux front end is going to be infinitely more easy to reason about, and subsequently iterate and extend. Also there's a lot more mindshare for these technologies, as they are much more popular than meteor. 
For those interested, I've opened a support issue for Nodejs to support the feature under a harmony flag. https://github.com/nodejs/node/issues/4847
Nothing wrong with vanilla JS/jquery. In fact if you follow design patterns your code won't turn into spaghetti. In most cases you would end up taking what they have and optimising and cleaning up as part of maintenance. For my apps I chose vanilla over frame works because I feel big frameworks are just to cumbersome. 
agreed - good stuff
I didn’t miss the point. It’s a document store meaning that you would store all the data of said post in the same document. What you’re trying to do is a perfect case for something like mysql. And I got the gist from the last bit and a skim. 
The point was why is this feature overlooked given this common use case and support for the same operation in the forward direction, not for a recommendation on which technology to use to model the domain data. So yes, you missed the point. I'm not trying to do anything and your suggestion to store everything in the same document doesn't hold water. 
&gt; Problem is, the project that I would need to maintain is basically written in vanilla JS and seems to be a bit old. Ouch. Not a prepossessing start. &gt; Is it even possible to write proper SPA web app in vanila JS/jquery? Absolutely! I mean, all those fancy frameworks like React or Angular 1.x were written in vanilla JS. For all you know, you might open up this legacy webapp and see clean seperation of concerns, full unit test coverage, all functionality broken down into sensible module, maybe a classic MVC-type breakdown into presentation and data with all network functionality carefully seperated into its own mockable module, maybe even with it all being driven by some well-documented internal framework. ...I mean, it's not going to happen, but it *could*. &gt; For me It seems like 99% of the job would be writing SPA-ghetti boilerplate, especially in comparision to things like Angular.js. Or maybe I am just pessimistic? No, that's probably accurate. If it's old and still around it's probably because nobody can figure out how to update it. Don't be surprised if you find that some of the JS is being constructed on the fly by `echo` statements in some ancient PHP script. (And yes, there's an ancient corner of the app I'm working on right now that was done that way. When you open a php file and see SQL and JS mixed together in the same code block, you know that madness cannot be far behind. Luckily, my job is to rip it all out, burn it with fire, and replace it; the decision was made that it's too far gone to even try maintaining it.) Or, maybe it's still around because it doesn't need updating because it was written right the first time. It's like finding a brown cardboard box in an alleyway with a note scribbled on the side that reads "awesome shit". You have no idea what's inside it, and it might indeed be awesome but (spoiler!) it's probably just shit.
It's because, like /u/zachrip said, you are wanting a relational db. MongoDB is just a document store. If you want to use Mongo, then you *would* store everything in the same document. You can build yourself a workaround, but MongoDB wasn't meant to work like that. I'd suggest using a different db for storing your data. Not every one is right for the job.
You question is a bit hard to understand, but I think you're looking for [this](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/translate)? You'll essentially translate to wherever your object is, draw it, and then restore the canvas to before the translation. If that's not what you're looking for, you'll need to reword your question. EDIT: And don't forget to provide a [codepen](http://codepen.io) as an example
[Link to the GitHub Repo](https://github.com/nhnent/tui.grid)
I'm thinking you need to: * Check your map again. This is /r/javascript not /r/java * Recheck your formatting * Seriously recheck your directions. Maybe you need a new GPS?
You are not calling the callback function in your .toBuffer's else clause.
There are a few bugs in your library. At the time I was looking, I found the following: 1) Dangerous use of "this" in the animate function. What do you intend "this" to represent? If I'm not mistaken "this" will be window. 2) The variable k in the obj.size function is global 3) The local variable async in the ajax function is unused. If data.async is not defined you are passing undefined to req.open() 4) The function hasClass will return true for elements that do not have a class of match i.e. lib.hasClass(&lt;div class="amyclasses"/&gt;, "myclass") Having corrected all that, your library can be further minimalised. Not counting comments, yours comes to 91 lines, I can shave 21 of those lines away for a 70 lines solution as follows. lib = { create : document.createElement, hasClass : function(el, match){ return (new RegExp("(^| )" + match.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&amp;") + "( |$)")).test(el.getAttribute("class")) }, css : function(el, css){ for(var i = 0; i &lt; el.length; i++){ for (var prop in css) { el[i].style.setProperty(prop, css[prop]) } } }, s : function(el, parent){ //select return (parent || document).querySelector(el) }, sa : function(el, parent){ //select all return (parent || document).querySelectorAll(el) }, sn : function(el, n, parent){ //select nth-element, is btw faster than css3's selector nth-child(n) return (parent || document).querySelectorAll(el)[n] }, animate : function(el, change, duration, timing, end){ duration = duration || 200 timing = timing || "linear" var transition = "" for (var prop in change) { transition += prop + " " + duration + "ms " + timing + ", " } el.style.webkitTransition = transition.substr(0, transition.length - 2) if (end) el.addEventListener("webkitTransitionEnd", end()) lib.css([el], change) }, obj : { size : function(o){ var k = 0 for (var prop in o) k++ return k }, select : function(o){ var arr = [] for (var prop in o) arr.push([prop, o[prop]]) return arr } }, ready : function(exec) { document.addEventListener('DOMContentLoaded', exec) }, ajax : function(data){ var req = new XMLHttpRequest(), params req.open(data.method, data.url, data.async || true) req.onload = data.onload || function() {} if (data.params){ params = new FormData() for(var prop in data.params){ params.append(prop, data.params[prop]) } } req.send(params) } }
&gt;Edit: It'd be great to see some feedback on my comment and why people think it's minsinformed rather than blindly hitting the downvote button. I didn't downvote you, but I didn't find your comment to be adding anything to the discussion, so I could see why someone would. You said you use a lot of middleware (which you don't like) and end up calling it a mess ... but that isn't at all related to the topic of angular vs react+redux and the size and simplicity of their respective APIs. Furthermore, making a mess out of redux by using too much middleware is imo a self-inflicted wound. Then going on to involve Dan doesn't really reflect well, or again, add anything valuable to the conversation. 
What would you say is intermediate?
&gt; When should I start learning Node? Now. &gt; How much of vanilla javascript should I have down before turning towards backend? Backend can run on *vanilla* javascript, Node is just a JS runtime, as V8 is in Chrome. References to *not vanilla* javascript, tend to refer to framework style conventions; like jQuery for *everything* or the *Angular way*. Dive in, have fun. Code is poetry.
Do not underestimate the power of vanilla JS. It doesn't consume extra cycles to by different framework files to breakdown the functions. It is the lightest and probably most efficient code for the Computer to handle. Remember frameworks are only helpful to people by reducing the amount of work we need to build components.
I found http://markojs.com/ ; sometimes you just want/need to do server-side templating. I was trying to find the state-of-the-art there and the last I had heard of was ejs and jade. Nice comparison at: https://github.com/marko-js/templating-benchmarks Marko supports both async and streaming, the only other one that does that is Dust, but Marko has an HTML syntax and seems to be the most advanced one out there.
As long as you can learn from those frameworks and the general guidelines to best practices, you should be good. Source: my single page app with jquery and samny js, http://offprint.in
To answer your original question / name of the post - [yes](https://github.com/lukehoban/es6features#enhanced-object-literals). Check your [compatibility](https://kangax.github.io/compat-table/es6/#test-object_literal_extensions), though.
You're right. I misremembered what I had read and I was on mobile, so I didn't double check. You're also right about the complexity/verbosity issue. I've found it fairly simple to work with, but damn is it verbose. So far, the trade off has been worth it, but I'm not sure how I'll feel after I've written a few hundred action creators and reducers.
I'm getting JavaScript Fatigue fatigue.
It's good to learn now, However I would suggest finding a need to use it, then learn as you go.
[removed]
Node is just vanilla JS that doesn't run in the browser. That's basically all it is. You should learn Node if and when you want to write JS that doesn't run in the browser. The real difficulty with Node isn't with Node itself but with what you want to do with it. If you're using Node to write the server-side code for a web app, then you need to know how the server side works in general, how to design good back ends, that sort of thing. The language itself is a fairly trivial component of this, and the design principles generally apply whether you're using JS or some other language. If you're still learning JS in general, you can certainly use Node right now to write simple command-line scripts. I do that sometimes when I have some math problem I want to do quickly; I write some simple JS code and run it with Node because it's simpler than setting up a webpage and doing it in the browser.
As /u/clarle already mentioned, you can use computed properties with ES6. In ES3/5 land, you have to write something like this: var stringArray = ["key"]; var object = {}; object[stringArray[0]] = "value";
It helps to understand some common patterns as well as how scope and async works. Really that's all you need to be able to dive into Node. You'll learn modules along the way, so just have fun!
Have a look at http://12factor.net/
Benachrichtigung(‘It\'s pretty simple; universities should be teaching Javascript to fulfill foreign language requirements’);
I would also like to know. Few issues I have. &gt; ...powerful enough to build the World Wide Web, make robots move, and convince publishers to print entire books about it I feel like this is a stretch, javascript is standing on-top of many shoulders here and every language has publishers. &gt; JavaScript versions do not matter to the user or developer because it is not server-side, so that one less headache makes it a better option for teaching. I disagree with this entirely, developers more than anyone need to know the version of javascript. Further, being used on the client side or server side should not give value to a language. Is programming client side really necessary for teaching anyway? Wouldn't developing servers, embedded systems be relevant too? &gt; Actually, H.T.M.L. does need another language to work, and it is JavaScript. If you want to render on the client, you need to use Javascript of course, but this can easily rendered on the server. &gt; Simple, pure, vanilla, untouched, beautiful JavaScript I'll leave this here: http://cube-drone.com/comics/c/relentless-persistence 
I didn't know about this proposal until now. It looks pretty neat.
Here is a website where you can request a free code review from experienced devs https://anadea.info/freecodereview
This is probably not the tech answer you're looking for, but maybe a good perspective for you to consider: You're getting into a 'business endeavor', so your main quantifiable metric is how successful your business is. If you get clients, and they are paying you for your service, then you are doing a good job. The level of sophistication, security and/or scalability of a software product is entirely dependent on the client base. For example, I wouldn't invest to much time in learning and implementing security for a non profit puppy shelter organisation, but would probably hire a security expert to help out with the security of the app if I were to store passport data into my databases. 
Jenn Schiffer writes a ton of satire. That's definitely a joke.
Well, that makes sense. Although there's a lot of raised eyebrows in the article, or are those paragraphs satire as well?
It doesn't appear on the agenda for the TC39 meeting this week. https://github.com/tc39/agendas/blob/master/2016/01.md 
Express documentation has good tips: http://expressjs.com/en/advanced/best-practice-security.html http://expressjs.com/en/advanced/best-practice-performance.html
true, would probably get better answers via IRC #mongodb or /r/mongodb or /r/node if you dont get the answer you need try irc, those guys are really smart. irc.freenode.net or [webchat.freenode.net](http://webchat.freenode.net/)
&gt; It is also a functional programming language which, like Latin, is considered “dead” and referenced only in historical texts. Is she joking or just ignorant? 
better to state what you are drawing, the first is curves, the second is penstrokes... im not sure. for an image you use drawimage for penstrokes/outline (path) you use beginpath/move/lineTo/fill for rectangles you use fillrect, etc once you know what it is you google "draw canvas foo" where foo is rectangle, image, pen, etc! sry i would help but im not a canvas expert
Check out: https://frzr.js.org https://freezer.js.org/minimum-viable-view-library And for example: https://github.com/pakastin/worker-example I'm currently creating two big SPA web apps with those techniques.
Y'all need your joke detectors calibrated
Yeah I just needed to go back to standard `render: function (){}` to make it work
Sure so you now have the choice of using a really big black box that is in flux. Or a few tiny black boxes that are in flux. I'll always go with the tiny scenario.
Just within the function since they are declared as function arguments.
:) . thanks
Well, TBH there are two kinds of JavaScript-programmers. There's jQuery-programmers (who usually have no actual clue about what they are doing and just copypaste lines of jquery from StackOverflow) and actual JavaScript-programmers. So if you ask me, it's a fair division.
Super excited for this. It's clear, extremely practical, and solves an annoying pain point that I see surprisingly frequently. Sad to see that we'll have to wait quite a while to see it land for real though. If you're really impatient, it looks like it's been in Babel since 5.4 (May 2015): http://babeljs.io/blog/2015/05/14/function-bind/
* `addTodo` is an action creator * `ADD_TODO` is an aciton type * `{type: types.ADD_TODO, text}` is an action
Yes, it’s the only way to use a symbol as a property key in object literals and classes (needed e.g. for iterability via `Symbol.iterator`).
My first instinct was exactly this especially as the top of the article quoted the author lol. If so, well played! 
Reddit, the new stackoverflow.
In case you're interested, this is a more complete explanation of scope in Javascript: [What is the scope of variables in Javascript?](http://stackoverflow.com/a/500459/1038034) Learning how to Google information like this very important. I found this article using: "object scope site:stackoverflow.com" Hope that helps.
&gt; Is it even possible to write proper SPA web app in vanila JS/jquery? Yes. You can write absolutely anything in vanilla JS, but.... you really need to have a solid plan for code organization and architecture before you start writing any code at all. If you are confident with planning and organization you can end up with a smaller, faster, and easier to maintain application in vanilla JS. Most developers are really not up to this and will end up with a bunch of ad hoc spaghetti bullshit. In the end when writing in vanilla JS the quality of the result is entirely reflective upon how strong of a developer you are. JQuery is not vanilla JS, by the way. &gt; For me It seems like 99% of the job would be writing SPA-ghetti boilerplate People who are afraid going the vanilla route will always bitch about three things in advance (the three points of vanilla doom): * reinventing the wheel * unmaintainable code * you will end up with a framework anyways Those three conditions are highly probable, because most developers have never learned to plan like a product manager. When your code is a bunch of ad hoc garbage then you will probably end up full-filling all three bullet points. When you completely lack confidence to accomplish the mission then you are writing your own self-fulling prophecy and are doomed anyways. If you are confident (successful experience is required) that you can produce an large app in vanilla code then you will likely be successful. You bypass the three points of vanilla doom when the code is well organized so as to be always maintainable at scale. Organized code does not automatically mean you are writing a home grown framework. A lot of what frameworks do is minor vanity and convenience effects that you probably don't need anyways. If the parts of your app that are repetitious and framework-like take less than 2% of your total effort then nobody gives a shit that you are reinventing the wheel because you will end up writing this code anyways (either originally or conforming the framework's api).
There will always be more to do :P
I would unsub if there were such a rule.
That makes sense, thanks!
`dist` is ignored in `.gitignore`, but not in [`.npmignore`](https://github.com/jquery/jquery/blob/master/.npmignore), which determine what is published to npm.
Many libraries specify a "postinstall" hook to build their source code when you install them. This could be what is going on. https://docs.npmjs.com/misc/scripts
Just follow the same pattern I used for all the other ones... Here, I added a 'Death' power right at the beginning of the array of powers: https://jsfiddle.net/spntmbad/ Make sense?
I don't know what blogger is, but if your blog is letting you add html, then you can add in all the code in your blog's html area.
The answer is likely the .npmignore thing, but regardless, they could include grunt as a dependency and use it without you having it installed
There would be several issues with trying to roll your own 100%: 1. Maintenance - You're doing everything by yourself you need to maintain it. If you hire additional developers they'd have to learn your code base and there would be 0 help on stack overvlow for them. You'd have to write extensive documentation if you want others to be able to help maintain your 1 off app. 1. Cross Browser Compatibility - You'd have to re-write all sorts of helper functions to maintain cross browser compatibility, especially if you need to support lower versions of IE. 1. You'd be wasting a lot of time reinventing the wheel - When working on a project the first thing you should be doing is seeing what out of the box solutions are available and if they meet the criteria for your project. While there's some initial time dump in researching the solutions and familiarizing yourself with them, in the long run you'll be in a better spot where you can be much more productive and focus on implementing the business needs instead of re-inventing a framework so you can do anything. I agree with what your statement about writing a lot of boilerplate, or basically re-inventing the wheel, and it would be a large waste of effort to keep it up. Things like Angular didn't get written over night and they had large amounts of people helping. A 1 off isn't going to have that many eyes on it, and it will be difficult to know that you filled all the gaps properly.
I don't fully understand the objection to the term "mixin" for this. * The first google result for "jquery mixin" is the `extend` method. * The lodash `mixin` function behaves much like the jQuery `extend`, even allowing you to add to the lodash prototype if you omit target. * The typescript documentation mentions [mixins by name with a whole section to them](http://www.typescriptlang.org/Handbook#mixins), as does the [livescript documentation with its `implements` keyword](http://livescript.net/#oop). * "javascript mixin" is used **two** orders of magnitude more than "javascript concatenative inheritance" based on google search results. * "javascript mixin" also leads to plenty of good articles like [this](http://raganwald.com/2014/04/10/mixins-forwarding-delegation.html). Meanwhile, "javascript concatenative inheritance" just leads to more eric elliot articles. * Mixin is a commonly-used term in css preprocessors to mean something very similar, though the syntax is closer to e.g livescript's `implements` due to mixins being a language construct in those. * Mixin is used by [several](https://github.com/brigand/react-mixin) [smaller libraries](https://github.com/onsi/cocktail) to describe the same concept Even if the term was totally different outside of web dev, it seems to be fairly established to mean this specific concept in web dev. Much more so than "concatenative inheritance" is, anyway.
&gt; It's not inheritance, it is composition It most definitely is *not* composition. Elliott literally invented his own definition of composition, and he's ignored the definitions given in the GoF book and the UML manual, for example.
This is ridiculous! How much google spend on this marketing crap? This is nothing compare to the price of software engineers. The "resources" argument doesn't apply to Google, Apple, Microsoft or any other corporation as all of them have too much meaningless spendings.
You're absolutely right, and this is a trend with Elliott. He ignores established terminology, invents his own, then acts like he discovered something new.
I think you should have an "Other" field for education level too, considering there are a lot of different education systems in the world that don't really match 1:1 with the American one.
Care to clarify this? I feel like a mixin falls neatly into the GoF definition of composition.
Hi /u/chilaluna, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Phaser is great. I went to a hackathon, learned phaser, and built a game where a cat has to collect money bags along the audio wave form of the song playing all in ***4 hours***. (Results may vary)
Looks interesting. Whenever I use Selenium Webdriver I have to almost always add a framework over it (usually handrolled) to deal with the boilerplate and make tests sufficiently clean and abstract. The "stale element" is quite a bother to deal with as well, usually resulting in ugly retry checks. Do you happen to know if webdriver.io is doing those retry checks, or if it's doing something all together more intelligent? I also happened to notice the delay is `200` for the tests which are said to fail, yet `500` for the ones which are said to work. It's usually such a faff to get the right figure I tend to just send javascript down with `executeScript` to ensure everything has loaded first.
I've got 4 multi select dropdowns for 4 different entities and I'm not using any third party component for the dropdowns. I'm defining an action for each user interaction like, opening the dropdown, closing the dropdown, selecting the item in the dropdown. So, it looks like I have to repeat these actions for all the dropdowns. For example: For entity 1, I should define the action and the corresponding reducer, for entity 2, the same as above. Is it the correct way to do it? Or Am I missing something here?
Composition is "objects acquiring references to other objects." The GoF book even explicitly defines "mixin" separately as a type designed to be combined with other types through inheritance. The biggest hallmark of inheritance is that it makes an IS-A relationship. That is, the derived incorporates the entire public interface of the base as its own, such that the derived can behave as if it "is a" base. class Stack { push() {} pop() {} } class Derived extends Stack {} // Derived incorporates the structure and behavior of Stack // Instances of Derived will behave as if it "is a" stack let d = new Derived(); d.push(); d.pop(); And Object.assign does the same thing. It incorporates the entire public interface of its sources, such that the target object will behave as if it "is a" source object. let stack = { push() {}, pop() {} } let derived = Object.assign({}, stack); // Derived incorporates the structure and behavior of stack // "Instances" of derived will behave as if it "is a" stack let d = Object.create(derived); d.push(); d.pop(); Object.assign makes an IS-A relationship, not the HAS-A relationship that we call composition. To make a HAS-A relationship, we would hold a *reference* to an object from within another. class Stack { push() {} pop() {} } class UsesComposition { constructor() { this._stack = new Stack(); } } // UsesComposition *does not* incorporate the structure and behavior of Stack // Instances of UsesComposition will *not* behave as if it "is a" stack // Rather, instances of UsesComposition "has a" stack and "uses a" stack to accomplish its tasks let d = new UsesComposition(); d.push(); // nope, is *not* a stack So to bring this back to Elliott's examples, this is a mixin/inheritance: const GuitarAmp = (options) =&gt; { return Object.assign({}, distortion, volume, cabinet, options); }; This is composition (holding references to other objects): const GuitarAmp = (options) =&gt; { return { _myDistortion: distortion, _myVolume: volume, _myCabinet: cabinet, _myOptions: options }; }; 
Here is an article about this: http://support.screeps.com/hc/en-us/articles/205960931-Server-side-architecture-overview
I hope you're getting paid well, or you're on a team, because that's a lot of hats to be wearing at once.
If your code works as intended and is easy to read and test, I don't see why you need to apply any of these concepts. I wouldn't stress about not using them. Just keep writing code. Whatever you do, don't try to shim them into your code just for the sake of using them. In my opinion, closures and inheritance can do just as much harm as good if you're not careful with them.
I don't know, you'd have to ask her. She seems to weave a lot of sincerity with sarcasm, so... ¯\_(ツ)_/¯
You can't always just throw money at things. Engineering hiring is more limited by candidate availability. They are *constantly* trying to find new people.
You still seem to be thinking that we have to involve the prototype chain to be inheritance. We don't. Object.assign copies "own" properties, so of course it ignores the prototype chain. And if the prototype chain isn't involved... let stack = { push() {}, pop() {} } let derived = Object.assign({}, stack); // Derived incorporates the structure and behavior of stack // "Instances" of derived will behave as if it "is a" stack let d = Object.create(derived); d.push(); d.pop(); And you haven't addressed that even Elliott calls this inheritance. In fact, to fuzz matters even more, Elliott refers to the use of Object.assign as *both* inheritance *and* composition. Are we to believe now that inheritance and composition are the same thing? They're not, of course. Elliott is right to call Object.assign inheritance, but wrong to call it object composition.
This video here underscores exactly the point. You'll notice he uses Object.assign as the example of *composition*. https://www.youtube.com/watch?v=wfMtDGfHWpA
Cool! I'm not sure the best way to go about it, but you can use `setInterval()` and `setTimeout()` to time events in javascript. 
How many have used Python classes or Ruby classes before and didn't realize how strikingly similar they were to JavaScript classes? Did it make any difference if you didn't know that? Does it make any difference now that you do?
Yeah, we've progressively replaced our uses of Backbone.Model and Backbone.Epoxy.Model with Ampersand-State. I had to write a bunch of shim code to make Amp.State and BB.Collection play nice together, but Amp.State is a fantastic upgrade. Not sure I can just throw the edits out there, but looking over the code, my shims include: * Overriding `BB.Collection._isModel()` to determine if it's a model by calling `getType()` * Adding `serialize()` to BB.Model/Collection * Adding `BB.Model.getId()` * Adding several missing Underscore methods to Amp.State, as well as `has()` * Overriding `Amp.State.toJSON()` to behave like Epoxy does and optionally return computed/derived attributes * Adding another Amp.State custom datatype for BB collections, allowing it to propagate events when using a Collection as a field Marionette's views are great for lifecycle handling, though. We've been using a custom mixed-in version of Marionette.ItemView (for lifecycle events) and Epoxy.View (for declarative data-binding). I'm prototyping my first React/Redux app, and definitely like what I see there. But, if you're still working with Backbone right now, a combo of Ampersand-State, Marionette, and Epoxy is still pretty good.
The point is Python, Ruby and Smalltalk behave the same way. For example, in Python, if a requested attribute is not found on the instance, then the search proceeds to look in the class object, and if it's not found in the class, the search proceeds to the base class object, and so on recursively. Python doesn't use the words "prototype chain," but the process is the same.
The point is Python, Ruby and Smalltalk behave the same way. For example, in Python, if a requested attribute is not found on the instance, then the search proceeds to look in the class object, and if it's not found in the class, the search proceeds to the base class object, and so on recursively. Python doesn't use the words "prototype chain," but the process is the same.
Exactly. Who cares, it's just syntax.
Actually with ES6 you could have views as subclasses of Array, and then be able to access children using `view[0]`, which is nice.
Why not just have a release branch and feed Bower release files from there? Anyway this is a circle jerk, developers protesting on live code what the fuck.
Think about what you know about classes. Now turn it upside down. All the relationships go the other way. Things bubble up rather than being inherited down. But, it pretty much works the same. . .
This is a great article, I have had the privilege of rolling out an automated testing solution and turning it over to a team of QA (with minimal engineering experience) and junior devs to write tests. This forced me to abstract away much of the asynchronous checking as well as the StaleElement issues The growing pains were real. I chose protractor even though we don't use angular and couldn't be happier. Once protractor added [ExpectedConditions](https://angular.github.io/protractor/#/api?view=ExpectedConditions) life got so much easier. One thing I would point out is, I don't think the use of pause is a very viable solution. When your testing library becomes large these have the potential to slow things down *a lot.* Also, it's not guaranteed that 500 ms is long enough, so it comes down to you trying to find a duration that is long enough to always work but short enough to maximize test run speed. The main two ways I combat these type of errors are: 1) wait-for-browser-ready-state.js - A dirty method to make sure the browser is ready, it requires executeScript to check readystate (is there a better way? If so, please let me know!). Every test uses this to automatically wait until the browser is, indeed ready. 2) performActionAndWait(actionToPerform, functionThatReturnsDifferentValuesWhenReady): so something like: performActionAndWait(element(by.css('#action-menu &gt; button')).click, element(by.css('#action-menu &gt; .menu')).isDisplayed) performActionAndWait can be given a timeout, in which case you then handle unexpected issues. Hopefully the name is self documenting enough, but essentially it runs the comparison function, saves the result, then performs your action and reruns the comparison action at a set interval until the results are different.
We've just started experimenting using WebdriverIO where I work (having previously sat on Robot Framework and before that Selenium with Python). So far it's been a really pleasant experience, for similar reasons to the ones noted in the article. Mainly though, that API is so much better than what we've used before.
Doesn't throw a wrench in the works at all, thanks for the link. I've just started reading it. I've not bothered with tutorials yet, just working on my own stuff and googling when I get stuck. However I think a bit of an overview is a good idea as I go along, ta!
I ended up getting what I wanted to work wrapping my ajaxRequest() and ajaxResponse() functions inanother function and declared the XMLHttpRequest() object there. Thanks for all the suggestions, slowly understanding bits and bobs but a lot still goes over my head, I've got the impression there's often 100's of ways of doing the same thing. The greater your knowledge / toolset is the more ways are open to you, but that's not to say you can't achieve what you're after with some of the basic stuff. 
Going to your site on firefox or chrome, I get untrusted connection error
ya try `this.readystate` in the response func!, my post was way too long. gl!
Thanks for that link. I tried the tool but I think it might be beyond my capabilities. I wouldn't know where to start! My page is: http://www.access-programmers.co.uk/forums/showthread.php?t=99673 If any kind soul knows how to do a quick look...? :) I put my websites url and looked in the tool, but not sure if I was meant to put the rouge link in instead. Edit: Ignore the request. I have removed the link now. 
Thanks for the reference. I was curious about the same question, since this was the first time I read about a standardized stream API. But now after I read through the spec and also the linked FAQ I'm positivly impressed and it might be one of the best efforts to create a backpressure-respecting stream API. Rxjs is not that focused on backpressure scenarios. The current node.js stream API cares about backpressure and IO and does a quite decent job for it, but understanding it is complicated due to all the legacy support (two different reading modes which are implicitly switched). The linked streaming API seams more straightforward. But I think this is also mainly a gain of using promise based APIs for reading/writing, which were not available (or not yet standardized) when the older streaming APIs were developed.
Is a scroll down button a `&lt;select&gt;` ? Or something else? Regardless probably just pagination of the resource and limiting how many are actually in the Dom at any given time 
Thanks for the info, I'll take a looksie. 
Let's put it simply then: 'inheritance' as a concept is the fact of acquiring behavior and structure from another object's implementation. It doesn't require a formal inheritance tree, it doesn't require prototypes, it doesn't require classes, it doesn't require going several levels deep, it doesn't require to be enforced by formal typing. That's all implementation details. As long as an object takes part of its implementation directly from another and exposes it with the same structure, by copy, by delegation, by a class or by whatever mechanism you can imagine, it's inheritance. As /u/MoTTs_ stated, composition for an object is the fact of getting references to other objects having the desired behavior, and then use those objects when required. Note that this is not optional, it is the strict definition of composition in OOP. The object must have, as own attribute, a reference to another object and use it. This avoids structural conflicts which are the trademark of inheritance patterns. Problem is, some inheritance implementations are so popular that they are used as if they were the concept, and the whole web is bloated with those. /u/MoTTs_'s examples are perfect illustrations. (and he did show you the definition you're asking for: &gt; Inheritance is (from the UML manual) incorporating structure and behavior http://msdl.cs.mcgill.ca/people/tfeng/docs/The%20Unified%20Modeling%20Language%20Reference%20Manual.pdf search for inheritance in the glossary) When you use Object.assign, your new derived object exposes directly part of the interface of the 'source' object. Yes, it doesn't get the prototype, so it doesn't exposes the whole thing, but still it exposes what is the 'own' interface of the 'source', and it directly gets the same implementation for this interface. Behavior + structure are taken =&gt; it is inheritance, even if partial. When composing, the composed object doesn't automatically get any interface. It gets an instance, and uses it when exposing its own interface. &gt; Object.assign is "has a" relationship, though. There is no is-a relationship to the original object; if the source object was a new Car(), the assign target would not become a Car The assign target will get part of the Car interface (the own properties) and expose directly those properties, so you can say it is still at least part of the previous car. But you can't say at all that it has a Car: you have no way to call target.car or target._car or any full instance of Car. And, as already stated, owning a reference to a full instance is the canonical definition of composition from the GoF book.
&gt;JavaScript does not need a JavaScript framework to run. Because it is JavaScript already. Smart money is on joking.
Citation needed for "real classes must not be reliant upon resolution via prototype chain".
They are _mostly_ syntactic sugar at this point, but not entirely. Also, going forward they will not remain syntactic sugar as they will be growing new declarative capabilities like private/protected slots, decorators, class property declarations, and the corresponding reflective capabilities.
That's true. The purpose of my comment was to illustrate how wildly different Javascript's concepts are from other languages through an example. Maybe I didn't pick the right example.
Define what you mean by "class", and then we can discuss whether what JS has meets your definition. (And argue about whether your definition is even vaguely useful, but that's neither here nor there.) &gt; So, does JavaScript have real classes? If we consider Smalltalk's classes, Python's classes, and Ruby's classes to be real classes, then so too must we consider JavaScript's classes to be real classes. That does not logically follow. It's like saying "if watermelons are green, and limes are green, then cats must be green". Python and JS differ in many ways; if you want to make the argument that those ways are not important, you need to make that argument, not handwave it away because "well, it's all runtime objects and all runtime objects are the same, right?". Edit: I think one of the points you're trying to make is that inheritance and OOP is a big and complicated field, and most of it doesn't look like Java. This is quite right, and there *are* strong practical similarities between the classical inheritance implemented by Python and the prototypal inheritance implemented by JS. However, they're still not the same thing, and the phrase "real classes" has no commonly agreed meaning.
The Symbol.iterator value isn't meant to be included in the iteration, it's meant to provide the means for doing the iteration using for-of loops: http://www.2ality.com/2015/02/es6-iteration.html There are other use cases for computed keys as well, usually if you're constructing an object dynamically and the keys themselves are also dynamic. Obviously not something to make a habit of, but it does happen.
&gt; Javascript objects have no blueprint. That's...not really true. A common definition of the prototypal pattern would be "creating an object that can be used as a blueprint for other objects through prototypal inheritance." (see, eg, [here](https://carldanley.com/js-prototype-pattern/) although it's a common definition). Now we might say that the blueprint being an actual object (with no real distinction between "blueprint objects" and "real objects") makes this pattern wildly different than the classical inheritance models where, even in Python, we have class objects and instances objects, and strong dividing lines between them. Or we might say that's really just an implementation detail, and the two patterns are very similar. But saying there are no blueprints...when I set the prototype of `myObj` to `someParentObj` I am inheriting behaviour from the blueprint provided by `someParentObj`. No? What is `someParentObj` in this case if not a blueprint?
Instead I will phrase it differently and then provide the requested citations. In JavaScript the prototype chain is a secondary scope chain after the primary lexical scope chain. As a result this effectually means scope and inheritance are separate and unrelated qualities. This is absolutely not the case with classical inheritance. Definition and examples of classes in a classical language: https://msdn.microsoft.com/en-us/library/x9afc042.aspx In the classical inheritance model a class is a blueprint from which an instance object is modeled. In JavaScript this is completely not the case. In JavaScript an instance is created from a constructor function. Once created the instance carries the methods and properties defined on the base's prototype, which are applied automatically as the instance's creation. The instance object's reference does not resolve to the base object or its prototype. Instead it resolves against the lexical scope chain. Only the inherited properties and methods resolve to the base object's prototype. In classical inheritance an instance resolves directly to the class from which it inherits. In this model is there is no separation of scope and inheritance. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain Since JavaScript classes resolve to prototypes, which resolve against a prototype chain, they are fundamentally not real classes. The first link to the C# class reference proves this: &gt; This code creates two object references that both refer to the same object. Therefore, any changes to the object made through object3 will be reflected in subsequent uses of object4. Because objects that are based on classes are referred to by reference, classes are known as reference types. In C#, a classical language with real classes, an instance resolves back to the class that is referenced when in the new object instance is declared. 
It is definitely solvable-reload just changed modules on every change. See https://github.com/capaj/systemjs-hot-reloader And in production, it is very nicely cacheable, unlike webpack single monolithic build.
This is all interesting information but none of it suggests why C# classes are "real" and JS classes are not (or why classical inheritance as implemented in C# is a defining characteristic of classes). Class has been used across myriad programming languages for decades with widely varying semantics so I find it surprising that so many people think there is one notion of what "class" means.
Enabling caching sure speeds everything up. I still don't know why is full babel5 loaded to use non es6 dependencies
It uses the the localStorage api, so it can pass whatever strings you want across tabs. If your image data can be represented as a string (like base64 or a URI), then yeah I think it can handle that. But hey idk I'm on a mobile device so experiment and let us know! :)
Thanks, I've fixed it up :)
I use JSPM and bundle (even in dev) and never had a problem with load speed. I don't really agree with having different artifacts for development vs production. But then I've never had a process that depended on instant feedback in the browser either. (Good to know about systemjs-hot-reloader though.) I am eager to see the next version of jspm which has rollup optimizations integrated, apparently. 
Nice job, good to see a project that actually does something. Couple questions - Does Immutable.js really help with anything in anything in this project or was it a learning exercise? - What is the use case of `function delayedDispatch(dispatch, action)` that waits for 700 ms, did you have a race condition or is it for an animation?
Wow, I've never thought it that way. You just turned my mind upside down but in all seriousness I'm going to steal this (if I may) when I'm explaining prototypal inheritance to someone. 
I can't wait to try this, I've been thinking I want something like this for a while!
I feel like there is a misconception here about what objects can be vs. specific examples of them in the wild. Here is my lazy copy-and-paste from a google search on "what is a class in programming": &gt; In object-oriented programming , a class is a template definition of the methods and variables in a particular kind of object . Thus, an object is a specific instance of a class; it contains real values instead of variables. JavaScript fits this description to me as much as anything else out there. It just accomplishes it differently
You could write a script that would search Facebook for names and pick the top one. Then it'd click the add friend button. Just use jQuery and inject it somehow.
Still too much book keeping for my taste. Just use React or some other vdom based library.
I'm not going to overtly help anyone to be a spammer :/
&gt; I think C# classes are generally considered more real This seems like an assertion begging for a citation. Has anyone actually conducted a study on the question of "which language has classes that seem more real to you"? (Also, I'm pretty skeptical of the idea that the popularity of languages is the correct metric for deciding whose implementation is canonical. PHP is phenomenally popular, but I'm pretty sure that doesn't mean its bizarre left-associative ternary operators are "more real" than the ternary operators of less popular languages. If you're popular and wrong, you're still wrong.)
Then Python doesn't have real classes either. You can do something like: aFoo.__class__ = Bar And suddenly your object is recognized as a Bar, even though it never touched Bar's constructor. Of course, if you then tried to use Bar's methods, you'll probably run into issues (because of the lack of proper initialization done in Bar's ctor), unless you understood the internals of the class and initialized it manually.
Wasn't looking to spam anyone. Was just curious. Thanks anyway.
V8 does use hidden classes whenever it can and it also avoids following prototype chains wherever it can. Being specified in a certain way does not mean that it's actually implemented like that. These hidden classes are very similar to what you find in VMs of class-based languages. These classes are just as real as integer math, Asm.js, or deoptimization triggers. The spec is only about the observable behavior. It doesn't dictate how things are actually implemented. E.g. it won't tell you how much memory an object will use or that `delete` and `arguments` are supposed to be able to cripple the performance. Anyhow, if I use the `class` keyword (or if I do what it does via prototypes), V8 will create an actual class and use that as the blueprint. It does this because it's faster. So, for all practical purposes, JavaScript does have classes just like it does have integers. But even if you pretend that implementations don't matter, ES6's classes still tick all the checkboxes. They do qualify as classes just as much as Python's or Ruby's classes do.
Wasn't talking about `Object.observe()`, but rather the (FRP-like) `Observable` object from [Rx](http://reactivex.io/documentation/observable.html) (it has implementations in nearly every language now, and provides a nicer library of combinators over "Streamlike" things)
Okay thank you I will use this and see what I come up with.
Apart from streams being pretty cool by themselves, this was a very clear and extensive article. Nice!
Thank you for showing me this jekrb! Just downloaded from the git hub page. trying to get the example to work for me on my machine. not working yet but hopefully ill figure it out. :)
Thank you to everyone that has replied. I am currently going through all of the solutions and will get back to anyone soon if I am still stuck!
Try aurelia... It's is better than angular
There's a discussion in the meteor's forum that's interesting to choose a frontend framework for Meteor. I think Meteor is going to choose React as a default. So you should go with that. [Why doesn’t MDG just adopt Vue.js and forget about React vs Blaze?](https://forums.meteor.com/t/why-doesnt-mdg-just-adopt-vue-js-and-forget-about-react-vs-blaze/13926)
X-Post referenced from /r/node by /u/keithwhor [Nodal 0.6: Tests as First-Class Citizens, Deep Joins and More](https://www.reddit.com/r/node/comments/42qp9n/nodal_06_tests_as_firstclass_citizens_deep_joins/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
This was also answered in the link of /u/jaffathecake. Basically these kind of streams are designed for especially for the point-to-streaming with backpressure over the complete connection scenario, which is not the biggest strength of Rx. Although some parts of Rx support backpressure, it is not used throughout all observables and combinators, and the default multicast and synchronous push semantics make it more complicated. This was also a reason why reactive streams where designed for the JVM, where RxJava existed before.
Ah! Perfect, just found it: https://github.com/whatwg/streams/blob/master/FAQ.md#how-do-readable-streams-relate-to-observables-or-eventtarget Thanks so much for helping clear that up for me, that was incredibly helpful! :)
For the reading part: It should basically work. But in order to support backpressure between both streams you should not switch the node stream to flowing mode but instead listen on the 'readable' event and read and enque data in the pull callback or if the readable callback was called and the watermark is not yet reached. Have not thought all details out, but I think both APIs contain sufficient information for full briding.
Well, I wouldn't worry too much about that. Yes, there are tons of libraries but you should start your search by first defining your use case, and then finding the library that fits best (and not the other way around.)
Most of these examples use arrays and ignore objects. That causes the post to overlook quite a few advantages of underscore and lodash. For example, `_.each()` can take an object instead of an array. The first arg passed to the function is the value. The second is the key. Also, in lodash, returning `false` will end iteration early. It's like `break` in loops. These may seem like minor differences, but they allow for more flexible, powerful, and straightforward code. And that's just one function. There are lots of similar nice-to-haves that make lodash and underscore worthwhile. Heck, I even use lodash for server-side stuff. Edit: Fixed grammar.
Lodash performs better than Native for a lot of it's implementations. The primary reason is for consistency though, especially if you're using a more functional style with a lot of currying and composing.
OP obviously never used them.
~~[why the fuck is nobody backing his claims here?](http://jsperf.com/jquery-foreach-vs-for/8)~~
If you're using lots of lodash functions in addition to the native ones, it's cleaner to read and write code running everything through there, rather than special-casing the ones that are worth shimming. Internally lodash is pretty good at falling back to native functions where available if it's sensible, remaining extremely compatible with them (so you could migrate very easily if you wanted), and ensuring great performance. Personally I use lots and lots of lodash functions, and while the ones listed here are useful to have natively, they're not the majority of the methods I use. Lodash is *really* good, native has a long way to include everything Lodash has (and I'm not sure it would be sensible to do so), and if you're going to include Lodash anyway you might as well use it for everything.
Thanks bud. On mobile/lazy.
Exactly. Take object example in any of it's implementation and see code failing badly. This us stupid argument against uderscore/lodash
4 files in total. So cute.
are you sure it's react? or is it buildtools + react + a framework?
rollup won't help much today. Most libs aren't written in es6 unfortunatelly.
As has been said numerous times, Lodash provides more consistency (between methods and across browsers) and improves support for objects and convenience calls when dealing with collections (arrays of objects). Why use a shim when you can use a fairly lightweight library that does the same thing better?
Hi, I've changed some word to make it less aggressive...
Absolutely made my day. Although I am not a Meteor developer, it definitiely has the coolest cat ;)
Interesting. I'll have to look into it. Thanks! 
See, I don't really see performances as a valid reason to use these functions. I have yet to see an application where `Array#forEach` was the real bottleneck, and if you're writing a library, I'd very much prefer the library author to avoid dependencies, even if it means they have to implement a basic forEach that solves their particular use case, than requiring me to use Underscore or Lodash or whatever. I love taking libraries for a date, but I hate it when they require me to bring their friends along. As for the consistency, it might make sense when making use of the functional style (since Lodash brings new features in this regard), but not quite as much when writing imperative code - one might argue that using the standard library is the actual best way to achieve consistency.
Yup, D3.js is awesome! But do you think maybe this is slightly off topic?
As I said, the primary reason isn't really about performance. Getting more consistency from using the standard library is arguable. Consistency comes down to programming style and the overall composition of your program. It's not consistent if in your code you are using some of the native array methods but then have to constantly break out to write some for loop to do something those methods won't do. Or if you have to operate on objects similarly.
Not really, the thread is about comparing charting libraries and he is expressing a preference. "I prefer this F/OSS option" isn't really a *useful* response as it says nothing about why it is preferred (just because it is free, because it is F/OSS, because it is particularly good for a given project type, because of specific good experiences, etc), but I wouldn't call it off topic. (edit type: threat-&gt;thread)
Oh bummer... Is this just a repackaging of this series? https://medium.com/front-end-developers/wordpress-with-node-react-and-graphql-part-1-introduction-ee0fc491730e#.87bnrzifw
That's pretty huge, and yet it's already fast enough for me, so I'll keep it. 
In practice, you're absolutely right. I was just refuting a claim that has since been [removed](https://github.com/cht8687/You-Dont-Need-Lodash-Underscore/commit/7d7147369096fec2e2ab273e21210c38454725b4). Overall, I agree with this write up, just not that specific claim. I was very curious as to why that is when I found it out, [this SO answer](http://stackoverflow.com/questions/18881487/why-is-lodash-each-faster-than-native-foreach) sums it up nicely. 
Are you using npm2 or npm3? I find npm3 to be very slow.
Massive is a stretch, as the tweet replies suggest. And its definitely proportional to the depth of your dependency tree. I'm leaving it on, personally. 
Chaining. 'nuff said.
[Looks like a fix is underway](https://github.com/iarna/gauge/issues/7#issuecomment-171474156). Anyone who's written low-level progress bar code will recognize this problem. Updating the progress bar every tiny cycle is slow -- because I/O is suprisingly slow.
a "definitve" guide about javascript charts should speak about all javascript chart libraries (chartjs, etc.) and at least about D3js which is by far the most advanced solution.
And let me guess, most of those updates don't actually visually update the bar because they fall within the existing tick's representative width?
abysmally slow...
Thank you!
Thanks!
I think sinon is pretty popular. It's what we use at the office.
http://sinonjs.org
The Definitive Guide - written by head of marketing at FusionCharts. Not saying it isn't useful or well written, but you should be aware of the bias.
Same here. Virtually know noticeable difference. 
There's a balance to strike between the number of download requests and the cache-ability of those requests. Webpack lets you put the balance where you want it to be and where it makes sense for your application.
I've seen symbols used as flags that you don't want to be visible, and I've seen them used to simulate "private" members. 
I've seen code before that updates a progress bar inside a tight loop. It was common to update the progress bar every 10th or 100th spin around the loop for this reason. After all, the test `if ((i % 100) == 0)` executes pretty much instantly in most languages.
If you need deeply frozen objects and ability to turn off freezing in prod to skip the perf penalty, check seamless-immutable. For more stability and code clarity, forget about `var` and use primarily `const` and `let`, if absolutely necessary. You'd need an ES6 compiler for that.
It's almost twice faster with progress off. Massive is not a stretch.
Tell me about it... `npm link/unlink` used to be instant, now it takes 20s.
The comparison charts included D3 I thought?
No problemo! And I am glad you like it :) I agree with your point, but there is a [free licence for personal use (without watermark)](http://www.fusioncharts.com/download/free/) if you are interested in trying! 
asdf7890, are you talking about this [comparison table](http://www.fusioncharts.com/javascript-charting-comparison/)? If yes, then it does include D3.js.
What's the version of npm that this trick works with. I'm still using 2.7 and it's not working there.
Node needs requestAnimationFrame
Here's (really simple) jsperf: http://jsperf.com/object-assign-vs-for-in
This isn't even necessarily possible, nor does it actually effect "drawing" to a terminal.
That is not a bug. You saved a reference to the div. Just because you cleaned up the dom structure there does not mean the div is garbage collected. Basically you just removed the div from its parent, but didn't destroy the div.
&gt; The entries are always enumerated deterministically, in the same order in which they were added to the map. [in the case of trees, too] ah. Funny it's kind of buried, but this is a nifty thing to know about iterables. I've been doing js for so long now in real life applications, it's good to catch up on all the ES6 features like iteration, that fill in gaps that other languages supported all along. Good blog. reading about ES7...
haha, yeah didn't notice that.... Looks like setting innerHTML clears out all the text nodes... EDIT: FWIW, you shouldn't be using innerHTML anyway :)
woosh
&gt; What OS are you both using? Linux. I posted the output of `uname -a` above. The terminal I use is called Terminator.
The syntax was changed to `require(lodash/fp')` without an invocation.
One example is that class methods have a [[HomeObject]] which statically links a method to the class it was defined on. So even when you extract a method from the class (eg. call it with a different this value, put it on another prototype, etc.), super() will still know where to look for the original super method. Now certainly you could accomplish something like this with closure capturing and binding, but it's not a simple desugaring in any sense.
Your link gives: 404 Not Found
Why is this a bug? If the node is still in memory, why do you expect its attributes to have changed?
But it's all async, so it's faster!
I've just been trying it, and it works pretty well. The api is really sparse though.you have to write your own push, splice, etc.
would be useful to use with nodejs -&gt; graph database perhaps. such as neo4j
Fixed. Thanks!
Awesome! Totally wasn't expecting an answer, let alone one so detailed. Much thanks, and great work!
Robert Martin (Uncle Bob) had a good bit about how code is documentation. You wouldn't see blue prints to a house documented like this. Blueprints should be able to be understood otherwise they are useless. Anyone can write code that a computer can understand. You should be writing code that a human can understand. I think I saw it here: https://cleancoders.com/category/clean-code 
sceptical at first but shaved off 40 sec of our build. win. thank you kindly 
Addendum: We still have to prefix all fields/properties w/ `this.`. =( Java/C# classes are much cleaner than JS's just b/c their compiler can figure out what is a field against a local/parameter variable. Btw, JSweet is a très cool Java-to-TS/JS transpiler: :D http://www.JSweet.org/jsweet-live-sandbox/
I don't but I also don't expect it's contents to have changed
Regardless of the outcome one might expect, the "bug" is that it behaves differently between browsers. IE removes the innerText/HTML but leaves the node attributes, Chrome leaves everything alone, and FireFox adds the following attribute value pair: xmlns="http://www.w3.org/1999/xhtml" to the div. I personally would have expected them all to wipe out everything but the tagName: "&lt;div/&gt;", or leave the node untouched, so IE wins the bug trophy because it does more things wrong :D
This is great to hear! Never understood the benefit of JSPM over Webpack myself, as Webpack takes care of not only everything JS but also scss, image optimizations, etc. Not to mention it will have the same tree shaking functionality that rollup provides: http://www.2ality.com/2015/12/webpack-tree-shaking.html
Awesome! This is extremely exciting, Service Workers are going to be *amazing*. For those that don't know what this is: service workers essentially let you do things on your website outside the context of the page. You can intercept requests directly (and thereby really easily make your page work totally offline), do background data syncs, and push notifications to users, even when your page isn't open. This is the point where the web really starts to compete with apps on mobile, and give you the same experience on desktop too, all on open tech without walled gardens. More detailed intro: http://www.html5rocks.com/en/tutorials/service-worker/introduction/ Current compatibility status: https://jakearchibald.github.io/isserviceworkerready/ (Edge and Safari are still the big holdouts, but there's starting to be good progress)
a good video explanation [https://www.youtube.com/watch?v=d10k3iiZ_xk&amp;ab_channel=TomScott](https://www.youtube.com/watch?v=d10k3iiZ_xk&amp;ab_channel=TomScott)
Fanboys exist for javascript build tools now? Glad I don't have to work with you.
The naming of the original MEAN.JS project on github is rather unfortunate. On one hand it is confusing because the MEAN stack and the MEAN.JS should not be treated synonymously: MEAN is a general stack, while MEAN.JS is an opinionated implementation. Adding to the confusion is how MEAN.JS and MEAN.IO have a history where one split off from the other. Code organization and taking care of common tasks are part of the goodness of the MEAN.JS project. http://meanjs.org/ "MEAN.JS will help you getting started and avoid useless grunt work and common pitfalls, while keeping your application organized. Our goal is to create and maintain a simple and readable open-source solution that you can use and trust in your projects." PEAN.JS looks interesting because it as allowing you to talk to a relational db like PostgreSQL.
Start with: http://expressjs.com That's the basis of everything node.js related.
- https://medium.com/javascript-scene/10-interview-questions-every-javascript-developer-should-know-6fa6bdf5ad95 - http://www.sitepoint.com/10-typical-html-interview-exercises/?utm_content=buffer95738&amp;utm_medium=social&amp;utm_source=twitter.com&amp;utm_campaign=buffer - http://www.sitepoint.com/5-typical-javascript-interview-exercises/ - https://www.reddit.com/r/webdev/comments/3f7q3q/been_interviewing_with_a_lot_of_tech_startups_as/ - https://www.reddit.com/r/javascript/comments/3rb88w/ten_questions_ive_been_asked_most_more_than_once/ - https://www.reddit.com/r/webdev/comments/41k1yy/a_collection_of_about_200_what_are_the_best_dev/
Interesting, what does the following mean practically? &gt; It retains a large amount of compatibility with React, but only the stateless functional components and ES6 Classes interface.
npm2 didn't have a progress bar, did it? I thought that was an addition in npm3.
&gt; Only how it was called, to be exact. The caller doesn't matter. Well... function getName() { return this.name; } var john = { 'name': 'John', 'getName': getName }; var jane = { 'name': 'Jane', 'getName': getName }; john.getName(); // John jane.getName(); // Jane 
I think you are making the classical mistake of mixing up ES2015 with the class syntactic sugar. Given the new syntax for (de)structuring objects, defining properties and the spread operator, I would argue that "classes" are still inferior to the power of plain objects in JS. Please consider adding a preact.createClass() function. Other than this personal preference of mine, your project is great!
You can use window.location to redirect users to another page.
&gt; I really don't understand why I'm being downvoted because when you compare with `!=` `know` is coerced to `no`
npm2 doesn't have a progress bar does it?
https://egghead.io/playlists/the-this-key-word-250c37d9
This is awesome.
That's a good point. I do agree. Thanks! 
&gt; My idea is to make each name an object and store each file as its own array of objects and then do a final comparison/ordering and display that to the end user. Thoughts? I think you should just try it.
But an array doesn't offer me to store both the name and value in 1 field like an object or map does? Also the issue might be due to the async method of Firebase
If you say fast you need to prove it. Looks neat otherwise!
not sure 100% but i think prompt() returns null if they push cancel &gt;.tolowercase() is a string method (String.toLowerCase) and wont work on null usually when you get an error like that its because you did `a().b()`, error "b() is not defined"... thats because a returned something not expected, like null or object! 
Different problems. This is about terminal IO speed whereas Dahl was trying to improve network responsiveness in web servers.
I'm not following benchmarks too closely but I think http://mathieuancelin.github.io/js-repaint-perfs/ is more used now, the other libraries in that repo are from 2 years ago, so not representative of today
DBMon in Preact (just a straight port of the React one): http://jsfiddle.net/developit/3vLa1Lac/
&gt; From an agency perspective, clients love the WordPress admin panel. That means when they put out an RFP, clients that are already familiar with WordPress will list it as a requirement. ...and they'll be pissed when you tell them they can't install some plugin. Especially the Super Hyper Amazing SEO Mega Pack 3.0 Special Edition Pro plugin that the SEO consultant they hired claims is utterly critical for the operation of their site.
&gt; Ahh... I'm on npm 2.14.9 for this project, no wonder. No progress bar :) Yeah, that is a regression on npm3.
Hmm, you could also say that there have been and always will be bugs in browsers, so it feels like you are making a segue point about semantics (or futility?) Perhaps "defect" instead of "bug" more accurately reflects your perspective. Regardless, it's a deviation amongst the browsers, and in all likelihood the specification too. Even if (for hypothetical sake because I'm not looking it up ;) the spec explicitly left this behavior up to the vendor, the consequences of this behavior has enough real-world significance to be deemed a defect in the spec. Knowing that there will always be differences in behavior, or that vendors try hard, doesn't mean inconsistencies should be overlooked or that the spec shouldn't be altered under these circumstances.
Personal opinion, if you're serious about learning to code you need to learn how to solve these class assignments on your own utilizing references and search. Those are skills you're going to need as long as you code.
I'm trying to imagine the scenario wherein I'd find it useful to not know when a date was invalid and instead only get the current date. 
Quick explanation of transducers: https://pbs.twimg.com/tweet_video/CZrvXIAWQAA-7EM.mp4
&gt; I don't really agree with having different artifacts for development vs production. What do you mean by this? Are you saying you don't minify in production if you don't do it in dev?
i've tried but nothing from google seems to be helping me out. there's a lot of forums but nothing that helps guide me for some of these problems.
&gt; sit down, shut up, and don't release software you're not willing to support. News flash, shitbird. Just because you open source software and someone uses it, does not mean you are required to provide support for them. Most open sourced software is under the MIT license, which specifically states: &gt; The work is provided "as is". You may not hold the author liable. So if you use something I open sourced under MIT and it somehow causes your whole office to burn to the ground, it's not my problem. That's your problem.
Unfortunately, good authoritative sources are hard to find, but both the wikipedia article (even if it is a bit confused) and the UML manual put an emphasis on one point which is a good key: inheritance creates a conceptual relationship between the parent and the child, not necessarily a runtime relationship. &gt; The full descriptor is the union of the contents of the segment declarations in an element and all its ancestors. That is inheritance. It is the incremental definition of an element. Other details, such as method lookup algorithms, vtables, and so on, are merely implementation mechanisms to make it work in a particular language, not part of the essential definition. Although this description may seem strange at first, it is free of the implementation entailments found in most other definitions. Generalization is a taxonomic relationship among elements. It describes what an element is. Inheritance is a mechanism for combining shared incremental descriptions to form a full description of an element. They are not the same thing, although they are closely related. If you use object.assign several times with different elements, you give to the resulting child all the implementations of the public interfaces of those elements. You can chain and you can branch. And if you change a parent and reload, you change the childs. (as you must do e.g in a static class-based language where you can't modify classes and hierarchies at runtime but must compile). Therefore, you're conceptually building an inheritance tree. That's why object.assign is a mechanism to generate a form of inheritance. As for how it differs from composition, I may propose an alternative view. Main difference between inheritance and composition lies within the answer to this question: who gets the control over the shape of the final element? (which I will call the 'client' rather than the child to be clearer). Imagine that my goal is to build a supper-dupper-robot out of tank wheels, plane reactors and head of a big animated samuraï statue. I'm given those three things as instances (e.g. by an external library), and as I follow OOP, the encapsulation rule states that internal implementation of those object is unknown to me, all I have is the interface. I can't directly pick wheels, reactors and head, because maybe the way they work requires that they're tied to private parts of the instances. e.g. tank.start() may involves the tank's fuel reservoir to feed the engine. I don't want to have to deal with implementing that in my upper-dupper-robot, I want to have the tank behavior for mobility. [I will lighten the syntax of my examples for clarity] Let's assume those objects have those interfaces: let tank = { startEngine(), stopEngine(), moveTo(), rotateCannon(), fireCannon() }; let plane = { start(), fly(), stop(), rotate() }; let giantSamuraï = { rotateHead(), hitWithSaber(), kick(), battleCry() } I want my upper-dupper robot to be able to start and moveTo like a tank, to chain start/fly/stop from the plane in order to use reactors for boost, and to rotateHead and battleCry while doing so, because it's fun. Now, I have two ways to build my robot from those objects: inheritance and composition. Let's object.assign: let upperDupperRobot = Object.assign({}, giantSamuraï, plane, tank); upperDupperRobot.start = function(){this.startEngine()}; upperDupperRobot.boost = function(){this.start(); this.fly();this.stop()}; upperDupperRobot.rage = function(){this.rotateHead();this.battleCry();this.rotateHead()}; What can be said about this? First thing, my client robot got a lot of unwanted stuff directly exposed for its own client code to use. I may need to delete those things (if I'm sure they're not required for the functionality I want). That means my robot doesn't have control of its own shape: it can't select what to pick, what to leave. And if the maintainers of the libraries I used to get my parts add stuff, that stuff will pop on my robot. That's a typical inheritance characteristic. Second thing, I'm lucky that the maintainers of the libraries didn't give the same name to their methods, or I'd have been in trouble because of conflicts. That's a typical issue of multiple inheritance. Other than that, it has the benefit of being concise (direct calls to methods through this, no need for redefining inherited methods if I want them as-is) and easy to understand. Let's go compositional: let upperDupperRobot = { _tank: tank, _plane: plane, _giantSamuraï: giantSamuraï, start(){ this._tank.startEngine(); }, moveTo(){ this._tank.moveTo(); }, boost(){ this._plane.start(); this._plane.fly(); this._plane.stop(); }, rage(){ this._giantSamuraï.rotateHead() this._giantSamuraï.battleCry() this._giantSamuraï.rotateHead() } } So, what are the main differences? My robot is fully responsible for its interface. It doesn't expose any unwanted own method. Even if the pieces get later more or less methods, the composition prevents structural changes of my robot. It means that as the developper, I'm in control of my own code. (of course I still use library parts, so I can still get bugs ;) ) I don't care anymore about conflicts in method names. The code is a bit more verbose. The benefits this technique gives in term of distribution of responsibilities, decoupling (more visible if I inject an interface through a constructor though), and conflict avoidance are the reasons of the 'favor composition over inheritance'. Any technique not giving you those is, by definition, not composition. Usually, people showing examples using object.assign or similar techniques tend to base their demonstrations on code they fully own, so it's easy to craft mixins so that they haven't any conflict, and only contain desired functionality. And that creates the illusion that mixins are a form of composition, by hiding at first glance the inheritance characteristics and making the shortcut of 'I make a full object from others, so I'm composing'. But in a real OO codebase, especially a large one, you're rarely in control of everything, and true composition can save you a lot of headaches. That's not saying mixins/traits/decorators aren't useful in a lot of cases though. But they should be treated as what they are, a form of inheritance, and used with the related pitfalls in mind. Sorry, lengthy answer, it may be hard to digest ^^' I don't know if it's enough to convince you, but it the clearest way I've found to expose my view on the topic. edit: formatting, damn markdown habit ^^'
Assuming you're doing something like let scores = obtain(); from init() you need to be returning the scores from obtain(), which I'm assuming you tried to do with the return in the forEach but it is in the wrong place. Instead move the return statement so instead of return scores; }); you have }); return scores; Then obtain() will be returning the scores and you should be able to access them from init().
If you have deep recursive calls you can blow through your stack. Tail-call optimization can suppress a new stack frame from being generated for certain types of recursions, effectively removing the stack size limit.
Only relevant on npm@3 
&gt; Given the new syntax for (de)structuring objects, defining properties and the spread operator, I would argue that "classes" are still inferior to the power of plain objects in JS. Can you give an example of something you'd like to do with (p)react that you can do with the `createClass()` syntax, but not with the `class` sugar? My experience has been that the two forms are essentially identical once you get past the lack of mixins and autobinding, so I'm curious what drawback you're running into?
I agree that circumventing the uni-directional flow of state is easy to do with Backbone models. It would be amazing to enforce that flow during development, like you said. Since Marionette.State is a proxy to a model, the API could be updated to make setting properties a little tougher, but at the very least with this approach the views aren't dealing directly with the global app state, as you observed.
This is a great suggestion. You may not know what codepen is. You can put your code there, and then share the link with us, and we can see/run/edit the code. 
Yeah jQuery had its purpose in the past for cross browser support, but it is time for it to die a slow death. Native javacript has much better support in modern browsers and it is the future.
Well written, matches my experience exactly
You're way off-base. I've never asked for support from an open source project maintainer and then gotten angry when I didn't receive it. I'm making a point for developers to take responsibility for the things they do in the world.
It's not a requirement for developers to support there open source software if they don't want to and if released under the MIT license. I agree with what the author has said and agree with him that not everyone can complain like he did in his post. If I released software that parses data and a company uses, then all of a sudden the parser doesn't work then it's not my responsibility to fix it for them because they didn't pay me to make it or pay for support period, none of CoC bulshit or that the company is losing money because they used it. That's on them for choosing software without checking if they will get support.
Ah right, db.on is asynchronous. I can see you've already implemented Promises so now if you want to use the return value you need to use .then because as you have it now you are trying to log the this.scores out before the Promise has actually resolved so it won't have the value you are expecting. Instead you could do something like: this.obtain().then(scores =&gt; { this.scores = scores; console.log(this.scores); }); Or if you want to still write your code like it is currently and you are willing to use Babel you could use async-await syntax: async init(finalScore) { this.finalScore = finalScore; this.input = $('.user-input'); this.scores = await this.obtain(); // Halts function execution until this.obtain() has resolved console.log(this.scores); // Should now be correct }
&gt; There sure are a lot of languages. &gt; Jenn Schiffer Pretty clear it was a joke from the start.
That's what I thought. It has only a spinner.
None of these things are jQuery faults. In its heyday you could have read these tips in new posts from 2008 and basically every single day of 2009, 2010, ... [No, really, go look](http://www.editgym.com/reddit-time-machine/?query=javascript&amp;useregex=false&amp;sfw=true&amp;nsfw=false&amp;sortedby=top&amp;searchtype=title&amp;search=jquery&amp;interval=months&amp;amount=20&amp;page=home). John Resig blogged about all of this stuff as he they were developing jQuery. I'm not saying the points are invalid, I'm just saying the community around jQuery has been addressing it *all along* and *begging developers not to abuse jQuery*. It's a developer problem. JavaScript has matured a lot and the API has grown to support the stuff you *needed* jQuery to do back then. But I'm still not inspired by the examples on http://youmightnotneedjquery.com/. If anything it serves as an advertisement of what web development is like when you don't lose yourself in minutia and focus on *building things* instead. I can't even possibly describe the unfathomable depths of relief I felt when jQuery raised the water line of effort involved in working with the limited, XML-inspired APIs available to us before ES5. I could spend my time working on much more interesting concerns and get things done a lot quicker. It's the same way I feel when I can use libraries like `moment.js` or Python's `arrow` to deal with dates or Python's `requests` instead of `urllib2` for HTTP requests. `$.ajax` is a hell of a lot cleaner than the equivalent code in plain-old JS and I'm astronomically more likely to screw it up than the guys running automated tests on dozens of browsers. If I'm trying to write a small library, I will fight tooth and nail to avoid dependencies, including jQuery. If my employer or my colleagues insisted, I'd set aside jQuery and we would do just fine. Otherwise, there are bigger concerns than dodging a capable tool just to fulfill some ideological itch or chase an optimization phantom way out into the weeds. Learn the best practices around your tools and you'll know how to judge for yourself if the problem is in the tool or your understanding. Take a long hard look at the priorities of your project, its audience, and its stakeholders, and you'll realize whether shaving off a few milliseconds or kilobytes is really worth their time and solves a real problem actual people that depend on you have. Learn to identify when those concerns are real and when your abilities are needed elsewhere. At a time when everybody is happy to shop out huge swaths of their project to 3rd party dependencies on NPM - we're seriously going to isolate jQuery and point to it as a scape goat for developer laziness? That's what we're doing? Really?
I highly encourage you to read You Don't Know JS. 'This' depends on the call site and the binding. Learn about the differences between explicit, implicit, hard, and default binding. 
But what is the difference between your this.getExampleInt = function() and the prototype way mentioned above? 
oh snap i didn't know about this. that's amazing! would anyone be willing to help me out with a few small assignments if i post my code on there?
i'll def. use this soon and see if anyone can help me out. sounds amazing.
Thanks! 
If anyone has teamviewer or something like that and would be willing to help me it would be greatly appreciated! I might look into buying a codepen membership if that would work out better. 
oh okay. do you get the live feed and stuff with just a free account? i thought you had to pay for it. 
yeah it looks like it is. is it worth it to pay for codepen or am i better off with one of the other free sites?
If you're just looking for the collaboration feature, I would use one of the other sites. jsfiddle is just as popular as codepen. I like codepen better for daily stuff because it reloads your code automatically, but otherwise they're pretty much the same.
&gt; I don't hold that position anymore. That's inconsequential; to get to the point: are you still employed by, or otherwise have a vested interest in, FusionCharts in any capacity? I find it very interesting that you chose to say, "I don't hold that position anymore", when most people would have just said, "I don't work there anymore" or simply, "I quit that job." And not only are you still doing work for a prior employer (4 months later, at that), but they published it on their website. edit: someone reported my comment as "This is personally damaging to OP." Whoever that was, I'm curious what your rationale is?
I started writing up a substantial explanation about how the stack works, however you'll probably get better information from google. Fib refers the the [recursive algorithm used to solve a Fibonacci number](https://en.wikipedia.org/wiki/Fibonacci_number) 
Have you looked at http://isomorphic.net/ ?
I ended up using JSPM and AmpersandJS for pretty much the same reasons you mentioned. JSPM handles installing the browser packages, ES6 transpilation, and bundling. Also, the registry leverages NPM and github so chances are you wont have trouble finding what you need. AmpersandJS is spun off of BackboneJS but each piece, (view, model, and collections, etc), are their own standalone modules in NPM. Of course, this is all IMHU, YMMV, and all that other disclaimer junk. Edit: since ampersand is spun off of backbone some of the documentation is the same but there's a lot that's different. You have be careful there. However, I think the documentation for ampersand is decent. The gitter is pretty active as well. 
How long until it shows up in chrome?
Hello kenman! thanks for the little post-mortem there ;) I didn't mean to be cryptic there. Or in JS terms, you can see my statement as: "I don't hold that position anymore" === "I don't work there anymore" === "I quit that job" I know they are technically not equal, but I hope it's clear now. Also, I could have posted this under some other name, but did it under my real name because I am not benefiting from it. All I wanted was a little feedback on my post, but got THIS. ¯\\\_(ツ)_/¯
###Thank YOU, [/u/patrickpdk](https://www.reddit.com/u/patrickpdk)! ####I am glad to hear that :)
Yep, just tested it myself. Has anyone found it *doesn't* improve install speed?
All in favor of renaming hapi.js to grumpi.js...
Just glancing through the code, it looks nice. I'm not sure how useful it will be for me as I prefer to render my elements using HTML, rather than as defined spiffies from a lib, but I give you props for putting this out there. Scary thing to have other people look at your code. ps. I love that multiple Berry instances are Berries.
Sounds like he needed to let off some steam. He doesn't attack anyone personally so I think it's absolutely fine. The message itself is solid. Especially in the JS community people have weird entitlement ideas with open source software. It's code someone wrote and chose to publish. It could be riddled with bugs, it could perform badly and it might not have the features you want. The next version might be something else entirely. You are free to use it, even as part of commercial projects, but *you* are the one responsible for that decision. If you encounter problems, they aren't on the guy who gave you free code. For some reason many developers assume every github project and npm package comes with some sort of guarantee and free support service. No, it's a bunch of free code. Anything more is pure goodwill and you should think carefully before whining it doesn't meet your exact requirements. I can't share majority of the code I write, but even if I could, I'd be terrified to do it because of the sheer amount of demands, criticism and complaining I've seen in github comments.
Exactly. There's no difference on the way `getName()` was called in both of these: john.getName(); // John jane.getName(); // Jane It would be different if it was called like this: getName(); // &lt;value of name property if current object is the global object&gt; //i.e. by default, this refers to the current object ...or: getName.call(jane); // Jane jane.getName.call(john); // John //i.e. temporarily bound function call ...and: var getName2 = getName.bind(John); getName2(); // John jane.getName = getName2; jane.getName(); // John jane.getName.call(jane); // John //i.e. bound function
If you were talking about the example --- in the first block the call was recursively made and each iteration received the output of the next call. When the edge function is hit - the answer has to bubble back through the whole stack. In the second example - which is more like a reduce - the current value is carried through all the iterations - so that as soon as the answer is met - the var b contains it. But in either case JS builds a stack and you have to return through the stack. Their addition of tail call optimization will allow them to jump from the answer to the bottom of the stack and discard the stack when it is done without having to traverse the returns of each function (at least thats the way it works in other contexts). For basic ELI5 of stack - look below. Basically a stack is just like blocks. Each call ads another block which is the edge of the calculation. If the stack of blocks gets too tall for you to add another you have a stack overflow ( in js you just crash ). So you do fibonacci here and it adds a bunch of blocks for each step in - then to get the answer is has to return block by block - back down the chain to the floor. This is time consuming and inefficient but it is what most JS engines do now. Tail Call optimization turns a stack like this into a loop. So instead of having to add a block each time - you just have that bottom block that you swap out with another block until the return comes. This keeps you from having to stack and you get the answer as soon as you get to the block with the return. The loop ends and you are done. There is gobs more information about stacks that is more detailed than the 10,000 foot view I am giving you. Hopefully this made sense. 
[removed]
There is actually a post on github about it now: https://github.com/npm/npm/issues/11283 And it has been a known problem for a while that simply did not gain any popularity / priority to be fixed: https://github.com/npm/npm/issues/11283#issuecomment-175324560 "TBH I'm a bit embarrassed that I didn't push out a quick gauge patch earlier. I've been aware of this as an issue for a while and the fix was literally 10 minutes or so of effort, but it hadn't bubbled up in priority as I hadn't realized how big an impact it was having. I'd been waiting as it's addressed by the improved architecture of the rewrite (prints at a set interval, no debounce needed), but clearly it was worth doing sooner than later."
the irony is that you say jQuery should die a slow death, and that "native" JS is the future, yet a new JS framework is released hourly. I'm not calling jQuery a "framework" but I'm also not sure what your argument is here. jQuery is a toolkit that makes some things easier for some people, just like many other libraries you and other jQuery pitchforkers probably use. in other words - what makes jQuery so egregious and everything else new and shiny not as much?
Meh, I agree with him. Being nice is OK, most of the time. But I think showing anger is not always a bad thing. Sometimes you have to draw a line and shout "I'm mad as hell and I'm not going to take it anymore". Where's the good in suffering silently from what you consider abuse? No good is coming from that either.
i'd love that to be honest! pm me?
Firefox seems to have a shorter list than other platforms. I will still use can I use to get a good idea if I can use an API or not.
react+redux(flux) is the hottest trend right now, pretty easy to pick up. and both look like they aren't gonna become a fad anytime soon
Can't see the code on mobile :(
This is a common problem when code calls for progress display updates very regularly and the UI layer doesn't debounce/bunch those updates. The effect can be surprising, sometimes worse than being seen here. It is usually a problem that the devs of both layers have in the back of their minds but it usually isn't a priority to be optimised until a bunch of users notice and start being vocal about it (nothing is broken or missing afterall, so bugs and planned enhancements come first). It can be fixed in both places: the UI layer by: * queueing and chunking updates together (I played with the display 0.001s ago, lets queue this update until the next tick the user will actually notice) * merging update requests (and dropping those from the queue that are superseded by subsequent updates) * dropping things that are effectively no-ops (updating a 25 character progress bar from 12% to 13%? there is no need for me to redraw that) and in the other layers by simply not calling for UI updates as often. Sometimes people leave the "every step" updates in the main code but push them through a small layer that bunches/merges them before passing to the UI code (this can be much less work than implementing "should I update yet?" logic in every process that might not be instantaneous).
How does it compare to [react-lite](https://github.com/Lucifier129/react-lite) ?
you should add [react-lite](https://github.com/Lucifier129/react-lite) that claims react compat too.
All libraries except Deku should run all test cases in less than a minute on a modern computer, if you are running on a mobile, just check "mobile mode". When it finishes, it sends results to the parent window, and they are displayed at the bottom section "Results". It runs slow, because it is important to let the browser flush dom changes before each update.
I feel like maybe this blog post needs a clearer thesis statement. What is it trying to communicate? Because what I'm basically getting out of it is "Yeah, you could use React and write a really solid app that would be suitable for production, but you could *also* hack together your own toy framework that wouldn't be remotely suitable for production!" This seems...trivially true. But why would I want to do that? Why would I even want to spend 5 minutes reading a post about it? On the other hand I've seen a few "React from scratch" posts floating around that try and duplicate what React does *in order to better understand React*. (E.g. [this one](http://ryanfunduk.com/articles/react-from-scratch/) or [this one](https://gcanti.github.io/2014/10/29/understanding-react-and-reimplementing-it-from-scratch-part-1.html).) This seems eminently sensible to me. If that's what OP is aiming for, then maybe a better intro and some sort of conclusion would make that clearer. In short: Is this a personal exercise to understand React, or meant to help the *reader* understand React, or is it (as it appears at first glance) actually an argument that you should just hack together your own "framework" rather than use an existing, tested, documented solution?
Maybe you should add an issue to his repo ?
I think the hottest thing right now, architecture wise, is the MVC with front-end abstracted out of it. Take a look at REST and RESTful API writing. It's a stateless paradigm very easy to understand once you get into it. As for frameworks, they're like assholes and opinions: everyone has one. I favor Angular and the upcoming Angular2 because they benchmark very fucking well, and I've grown used to it. I don't like JSX so I don't like react. As for javascript itself, ECMA6 is becoming the standard, and you should ; if you don't already, write only ES6, transpiled into ES5 by babel, while we wait for native support everywhere. Libs you might want to know: moccha, moment, express (if you don't already), bluebird, lodash, knex+objection or sequelize, and your good ole transpiler babel with a linter such as ESlint and a tool such as gulp or grunt. Socket.io is a good thing to know, if you've never done real time it can be pretty challenging. Otherwise, I'ld suggest that you don't jump in a framework such as SailsJS or Meteor which will, in the end, lock you in a tech that might not move fast enough forward compared to the javascript environment.
It seems that it is incompatible with React in many ways, this one is huge: https://github.com/Lucifier129/react-lite#react-lite-vs-react "the rule about setting props if propName in dom is true then dom[propName]=propValue else: dom.setAttribute(propName, propValue)" Even in dbmonster it doesn't have good results, and by looking at the source code I don't see any of the optimizations that can be found in modern vdom diff implementations, nothing interesting in this library.
Riot is great, was using both v1 (the "backbone killer") and v2 (the "react killer") for a time. I yearned for a more standardized pipeline and did not like the ".tag" files idea, but otherwise its pretty sweet. I guess the biggest difference between riot and preact is that preact does not require precompilation as part of the intended use-case (though like anything it benefits from having a transpiler). Might be worth you looking at https://git.io/preact-markup though, which is an implementation of HTML5 Custom Elements using preact components. Similar to how riot hooks into custom Elements. 
Yup, and I have found mixins and decorators harder to mock during testing. Currently I only use decorators for syntax sugar like @bind, everything else is high order components. 
It's 1/5 the size and does basically the same thing. Neat project though!
Thanks for the feedback. I agree it's definitely not something that is always needed or is right for everyone. But in the right situations its been really helpful, especially iterating on quick prototypes, form heavy applications or when working with people that don't understand forms. Yeah it is a bit scary, I am sure I will get used to it just like I got used to code reviews, biggest difference is people hold back when they are sitting next to you. Haha thanks, there are a few puns like that in there.
I don't precompile my riot in most projects. The performance impact is minimal. 
(author here) I can understand that. My position is that it is okay for simple transformations, and gives you a very high speed. For more complex transformation that cannot be expressed as a chain of simple transformations (map/reduce/filter/....), I would not go into strings either. Actually transfun also supports function parameters (sorry, not documented yet!) so you can write map( &lt;function&gt; ) as well. Of course then Problem 1 is back (one function call per element), but Problem 2 is solved (merged loops). It is a tradeoff. Thanks very much for your feedback. I'll have to add a section about this!
In my opinion, implicit recycling technique is almost always useless in real projects, except for getting better results in benchmarks. In kivi, recycling is only working on Components and it should be explicitly set with the amount of Components that should be retained in pool. For this benchmark, kivi implementation is built without recycling, because it breaks "render" times, and with recycling it is slightly faster.
I spent too many time on this game in the past. Thank you for this!
Wonderful work. Is this recreated or auto-ported with something like emscripten?
Not needing to build and later tare down all the stack frames can have a considerable performance impact in tight recursive loops too.
Maybe. However, when I read this: &gt;You are not entitled to good (or any) documentation. If you don’t have the time to read the code, the tests, and the examples, shut up or fuck off. I don’t have the time to explain shit to you. I document my work for my own needs. I publish a lot of code without any documentation. Don’t ask me to add some. The only right thing to do is to ask if I am willing to take a pull request adding or improving the documentation. That’s it. The only interpretation I have is that asking for documentation *at all* makes you entitled, which I have to disagree with. They're not just saying people who *demand* documentation are entitled - you're entitled if you do *anything* other than submit a pull request with the documentation you want. The way I see the FOSS lifecycle is someone solves a problem with code - usually a very specific problem that no one else has tackled yet with an FOSS project. Then, out of generosity, that code is released to the wild. Now anyone can iterate on it and improve it in case they run into a similar problem and need it do something more. It's all "as-is", but hey, it was useful to me, might be useful to you. This is all fine and dandy. From the author's post, I have the feeling this is the kind of FOSS process they want and nothing further. But there's another side, too. Not everyone has the capability, the time, or the desire to take up a FOSS project and modify it to do what it needs to do. Sometimes, there's a huge barrier in doing so, such as working on a compilier. Sometimes the source code is impenetrable and not documented at all. Sometimes the maintainer is hostile, and discourages people from submitting PRs. There's a lot of reasons someone could have. At this point, you can open an issue on sites like github. A way of signaling to everyone who *can* work on it, "hey I found this useful, but it'd be even *more* useful if it did x, y, and z". There is no entitlement here; the request may come from a self-serving place, but the end goal is improving the project as a whole and making it more useful for everyone. So I disagree with the premise that just asking for documentation makes you an "entitled asshole". I see these requests as much of FOSS as PRs are, and as healthy for a project. Now, of course. Someone *can* **demand** documentation or a feature. Someone can be mean, abusive, or indeed, entitled, when talking about things the project doesn't do. Someone can come into a conversation without reading it and demand answers. This is not healthy and makes everyone feel worse, so it needs to stop. I don't get the feeling this is entirely what the author is talking about, though, particularly when they say the only correct way to fix the problems are PRs. 
Also, depending on the input image, you might want to preserve more detail than a simple "workout lightness/other and apply a threshold" approach will, in which case you'll need to look into dithering techniques. https://en.wikipedia.org/wiki/Dither#Algorithms is a good list of commonly used techniques for that.
Great news. The chakra merge is probably going to take a while, so it's good to have this support built into v8. Hopefully the node team will bump up v8 to match.
Please put it into JSFiddle or plunkr
Looks like it is recreated from reading the post-mortem, though the game assets are probably ported over.
It means grandparent node of a node in the tree.
Thanks you very much for the feedback. Since this starter should be for a library that can be compiled both for Node and for the Web, there are two different builds: 1. For Node - just compile the files to ES5 (without bundling) and output to `lib`. This is done in Gulp 2. For Web - compile the files **with** all their dependencies, and create a single standalone file in `dist`. This is done with Webpack. I will try to research if it's possible to bundle the files for the Node in webpack as well, but *without* bundling the node modules dependencies. Again, thanks for your feedback.
Yeah, you mostly just reiterated what the article said- which I started off by saying I agreed with. ;) I just dislike seeing all of the OSS / JS fatigue / CoC flame wars that I've been noticing lately. It works people up to anger and encourages a mentality of "us" and "them". And you can rarely if ever change someone's mind by yelling or cursing at them, so in the end it just reinforces existing beliefs. But that's just my opinion. Fortunately none of my libraries have had a CoC submitted or anything like that so maybe I should just be quiet and count my blessings. :)
&gt; We encourage developers in general to upgrade to strict mode for new code. Can't stress this enough.
So, am I correct in understanding that the second example uses tail-recursion, but not the first? How does JS know to use tail recursion on the second example? I don't really see any special syntax (such as * for generators). Is it just inherent that if tail recursion can be used it will be used?
Manual port... I wrote a little about it in my blog article.. http://www.adityaravishankar.com/2016/01/commandos-bel-html5-recreating-the-classic-2-5d-real-time-tactics-game-in-the-browser/ 
Ton of time spent on recording videos of the original game, comparing, taking screen shots, adjusting stuff pixel by pixel... It's still not perfect, just as close as I could get it to the original...
Enemy pathing stored? 1. Patrols are either 2 (ping-pong) or multiple points (loop) stored in a "patrol" array, so the guard knows what to do when he isn't chasing commandos... Anytime he kills a commando, he goes back to walking along the points in the array... 2. Moving to the next point on the array (or any destination), is done by using A* on a mesh of polygons (nav-mesh), tojoin the starting polygon and ending polygon.... 3. Once I have the list of polygons he has to walk over to reach the destination, I smooth the path to reduce unnecessary turns, then the guard starts walking on it..... There are a couple of screenshots in the article I wrote, which might help explain it a little more easily... :) 
Thanks a ton dude.
Do you intend on using this in an upcoming book? Open sourcing the code? In general, it'd be great fun to see the implementation specifics. Were there any major browser-specific problems you ran into? It certainly feels like you're adding to the already-strong case that browser-based gaming is really feasible. 
Wow! Thank you for invoking awesome childhood memories!
Cool.. Happy to help.. Are you a game programmer as well??
My previous game - Command &amp; Conquer (with multiplayer) www.adityaravishankar.com/projects/games/command-and-conquer/ led to a book - Pro HTML5 Games www.adityaravishankar.com/pro-html5-games/ where I build a complete RTS game with multiplayer from scratch... I thought I had already made the case that browsers were ready for cool games :D I haven't thought about making this a book yet... Writing a book is a thankless, and very painful task, and a technical book, especially in the days of torrents, doesn't really pay enough.... Thanks to sticking to canvas, and based on my experience with previous games like C&amp;C, I didn't really run into any significant browser specific problems.... Some problems though.. Firefox, for some weird reason is very, very slow without any reason that I can trace... Code that runs fast on IE/Edge and Chrome just seems to die on Firefox... I still need to try and debug it.... And Opera, by not supporting CSS3 stuff like cursor:none is just preparing to be the IE of the current decade..
There's a huge difference between asking nicely to adopt a CoC, and public shaming &amp; boycott. Open source doesn't mean everyone owns the project, it means everyone has access to it. You have all sorts of rights to overhear someone else's public conversations, but you don't really have much right to insist that your idea of how they should have those conversations are correct - and you have zero, absolutely zero, right to harass people for not accepting what you insist on.
I love it. This is my favorite paragraph: "If you don’t pay me for my services or contribute meaningful value to me personally, I don’t owe you shit. You are not my customer and you are rarely right. Open source is not an invitation for harassment and making demands. If you choose to interact with me about my open source work, remember it was your decision and you can stop interacting with me at any time. No one is forcing you to use my code. I am giving you a lot of free modules to do with as you wish. That license does not extend to my time or my attention." You are so correct on this, joshmanders.
To be fair, ES6 is the result of years of work, implementing it is bound to take a lot of time. One of the main benefits of the sped-up specification releases is that since there will be fewer things to implement at a time, it will happen faster.
Hogwash. Anger is just as bad or good as any other emotion. It matters where and when you show it and how. Not every discussion is between lifeless automatons that remain calm throughout. Humans have emotions and they should be able to show them when appropriate. Anger is no exception.
You missed the word "HOW" in &gt; don't really have much right to insist that your idea of how they should have those conversations are correct And no one's saying you can't have a boycott. We're saying, you may be an entitled pratt to think you should. 
Again, the "don't come from this in anger" does not mean "come at this like a lifeless robot". You're allowed to be angry about something without calling people entitled assholes or saying they're more often wrong than not.
Thank you ... appreciate the props... I still haven't decided what I am going to do with it... Until two days ago, I was struggling to just get this game finished... Will give it some time and then take a call... Maybe a book or mini tutorial discussing the salient design features... The last time I OSd my C&amp;C, one company stuck it into an android app and sold it on the store...... another chinese company took the game and put it into their own site....they didn't even change the google analytics code, so I still get chinese traffic reports :( Overall very skittish about sharing my work.. While there are good people out there, there are also tons of complete idiots who spoil it for everyone else.... :/ 
This sounds so annoying and awesome.
That sounds like it'd would be a great library.
that's fine. Eran is not responsible for anyone else's feelings of entitlement. Eran is responsible for his reaction to ...(this is important) *his perception of their feelings*. And his reaction is over the top. "I'm sorry, I didn't bother to write good documentation." is a perfectly acceptable reply to people who want docs. (it's also honest and accurate). This is true whether the people in question have unjustified feelings of entitlement or not. "Shut the fuck up" is completely unacceptable in civilized discourse, regardless whether the other party expresses feelings of entitlement. 
This is such an appropriate analogy because it demonstrates how fucking entitled people who complain about OSS are. Learn to bake your own cookies or at least contribute the ingredients and kitchen.
This is not even a js-specific problem, but a community/github problem. GH issues are so often used by non-contributors (such as reddit and tumblr users) to rile up political opinions on things like CoC, licenses, and renaming variables to be politically correct.
That, and the actual test is just a few processor cycles of simple arithmetic.
Unsure if you're the owner of the Twitch channel, but I'm really excited to watch this later and hope there's more in the future!
Walmart's JS &amp; Node team is top noch. They've written Hapi, which they use to serve hundreds of millions of requests during Black Friday and such onlines sales.
Hm, you are right, I have not considered this aspect of this at all.
Sure, it looks close enough so I just referred to createElement as hyperscript so there was a frame of reference. Apparently that backfired. Pairing template strings with React is nothing new... http://www.2ality.com/2014/07/jsx-template-strings.html
Look up Server Side Events: https://developer.mozilla.org/en-US/docs/Web/API/EventSource
It is not about bridges. It is about the expectation put on those who give away part of their time and resources for free. Be part of improving it or be grateful when somebody else does it for you.
Actually, my last project Command &amp; Conquer is full fledged multi-player with upto 4 players per game... My book pro html5 games (http://www.adityaravishankar.com/pro-html5-games/) covers the entire design and builds a full multi-player rts game from scratch (with original artwork since I didn't want to misuse C&amp;C for commercial stuff)... I use a very similar design to the one discussed in the book ... I have a game object with a rendering loop, and an update loop... I have commandos, guards, vehicles objects that act as factories and composite the individual game entities, and I have mouse and sidebar objects to handle those components separately... very easy to maintain, minimal code reuse... I can't say I've officially followed a specific pattern though... I've had years of Java/oops and programming practice, but now I just write what feels easy to maintain :) 
AFIK*
The tools you've brought up (Grunt, Gulp, Webpack, and npm run-scripts) are all widely used. The change you may be seeing is in what's "hot." I think its a good idea to be aware of all the options out there. However, this doesnt mean you should drop a tool because it's not shiny anymore.
I've looked at this book a couple of times and have thought about picking it up. I'll probably grab it this weekend. Do you use any libraries outside of Box2D? The reason I ask is I don't want to be tied into learning a game library right off the bat, I'd rather see how it's done with vanilla JS.
Funny we were just talking about this at lunch. Never used Grunt, Gulp seemed better middle of last year when we decided on it. Using Browserify w/ Angular written in ES5. Now we're about to switch from ES5 to ES6 and try to move to a Babel/webpack approach. I'm not sure if we will still need Gulp at that point. I am going to try to get away with just npm scripts. (e.g. start, stop, test, etc) 
This is pretty cool. Source code is very easy to follow. I am curious where do the rendering performance improvements over react come from?
I use a lil jQuery for some menu related stuff ... But the entire game code for both games is entirely canvas, written from scratch.... I wanted to teach people to build games vanillaJS since it is the most satisfying and the best way to learn.... The only reason I even used jQuery was so beginners weren't distracted by crappy DOM manipulation needed for the initial menu stuff.... In fact, if you are my intended audience - people who want to understand how each of the bits works, and slowly build the game by typing bits, watching it affect the game, then add more code, you will get a lot of value from the game... That was how I intended the book to be used... As a complete journey building the game with me by your side telling you why something works a particular way...
I found something close: https://github.com/mchelh/mcScrollTabs I added a enhancement request.
[Tabs](http://lea.verou.me/2012/01/why-tabs-are-clearly-superior/)
For a deep dive on exactly why non-native methods could be faster, and why this post is ignoring these kinds of cases: [John-David Dalton - Unorthodox Performance -ThunderPlains 2015 ](https://www.youtube.com/watch?v=OP8jdbcDfaA) See for yourself. This is almost a case-by-case literal and code-centric explanation as to why noone should take this repo at face value.
&gt; Sure, it looks close enough so I just referred to createElement as hyperscript so there was a frame of reference Yeah... I still don't know what you're trying to say... &gt; Pairing template strings with React is nothing new... http://www.2ality.com/2014/07/jsx-template-strings.html I know, and IMO, doing that when you're using babel to transpile your ES2015 code anyway is dumb. It's like you're just adding complexity for literally no reason. A lot has changed since 2014.
Language feature support is very slow all across the board for important languages. Even in C# where MS can take unilateral decisions.
Fantastic, that's what I was hoping to hear. I'll be picking up a copy on Amazon tonight. Thanks!
Are there any es2015 features that are supported by all the browsers now? Is it time to start disabling some babel transforms or do I still need them all? 
At what point, if ever, is it a good idea to target different browsers with different builds, using different Babel transforms?
Although there is very little in common between the two presentations, here is the discussion of the original "JavaScript Combinators" talk: https://www.reddit.com/r/javascript/comments/27glvu/javascript_combinators_video/?
The users in my project tend be one of two things: * blunt and to the point * incredibly thankful and reverent about the effort I have put into the code which they are consuming for free. For this I feel incredibly blessed. Every once in a while there is an asshole who might post an issue to a dependent project about how crappy my own project is. Since this is rare its easy to ignore. Since I have wonderful users that occasionally give me praise it is easy to ignore the far fewer assholes. I am so amazingly blessed to get the kind of feedback that I get that sometimes its that final straw that keeps me going when I feel like letting the project go. **My users should demand things** I need my project to be free and open because I am absolutely dependent upon the user feedback to make my application better. My users are absolutely entitled to demand things from me and my application, but that does not mean I am entitled to give it to them. I would rather they ask for something impossible than to remain ignorant because impossible requests still provide direction, insight, and trajectory. **I owe my users better documentation** I feel obligated to provide my users with ever improving documentation. Documentation takes time to write, review, and maintain. This is time I could be spending with my kids instead of blowing it on a free side project that costs me money to maintain. Better documentation means I get more users using my application. It also means I get users more of the advanced and esoteric features they might not have considered otherwise. The return on this investment is better user feedback, higher quality defect submissions, increased consumption by other larger applications, and some sense of ownership. **Demands !== entitlement** I want my users to demand better things from my application. My time is limited as I have two jobs (one of which is management). When my users demand things from me it means less time and effort I have to spend on product management and planning for the future. When I have a bunch of demands awaiting my attention I just have to prioritize and then work them in the order of priority like a normal developer. **The best way to management entitlement is...** I never attach timelines to any issues in my application except major defects. On my major defects I am willing to lose sleep to get a patch published, but that also means the submitting user has the responsibility to provide me with the information I need to squash the bug. Since I have great users this is a non-issue. Everything else gets worked as quickly as I can get it done. I will provide feedback on my progress of larger enhancements so that any user can test things out, but I don't promise a time line. This is never a problem so long as I am frequently engaged. Set reasonable expectations with the users immediately. Don't raise people's hopes with an ambitious effort if you are not willing to see it through. Be up front with your users the moment you make a large decision about an issue they submitted. The users are taking their time and effort to provide important information to me through their issues and requests. I own them my opinion quickly and honestly. **Entitled users only embarrass themselves** Entitlement only really comes into play after a user makes a demand and I don't rearrange my priorities just for them. When, in the rare moment, this produces an emotional event I am not afraid to tell the entitled user to stop using my application. The application is free. I owe them feedback for their demand and that is all. For shiggles (shits and giggles) tell an entitled user that if they can do better then they should write their own application. There are many people in open source who would see that as a worthy challenge to embrace for the benefit of all. Entitled assholes don't share that line of thinking though, which makes their responses funny.
I'm on mobile and don't have time to make a snippet but [this](https://developer.mozilla.org/en-US/docs/Web/API/Event/stopPropagation) should be what you are looking for
I would personally also add the number of StackOverflow questions to the comparison. That really helps with general support.
It can be misleading though. There is more to ask about in Angular. React is pretty bare bones in comparison. In that regards, you could interpret fewer questions to mean 'simpler' rather than 'less community support'.
Simpler single-pass diffing, instance recycling, diffing the actual DOM to VDOM instead of between VDOM trees, and just being small (less memory overhead). So far the drawback is that preact targets the DOM, react is far more abstract and can support any type of tree structure. I'd say just pick whichever you need for your use-case.
ya, commenting so i can watch this later, im a noob :). maybe make it a highlight if u can so it doesnt fall into twitch's hole of nothing after 2 weeks.
Little known fact: npm scripts have a special PATH that includes `node_modules/.bin` (it's mentioned in passing [here](https://docs.npmjs.com/misc/scripts), and when you install a tool like webpack it symlinks its binary into that folder. So you can omit the entire `node_modules/webpack/bin/` part of the command; just running `webpack` from an npm script command will work even if it's not installed globally. (However, note that the mangled PATH isn't inherited, so if you're trying to use a tool to run *another* tool, you can only omit the `node_modules` prefix the first time. I can run `babel-node` without providing the full path, and I can run `isparta` without calling the full path, but if I want `babel-node` to *run* `isparta` it has to be `babel-node node_modules/.bin/isparta --args` because screw you, that's why. npm is useful, but it's not the most...elegant tool.)
"long-polling" was previously used before web sockets, instead of AJAX. It's related to ajax, but gives better response time than hitting an endpoint every few seconds with ajax.
And even Modules is of little comfort without Module Loader becoming a real spec and getting implemented.
Awww, I actually thought I was gonna go to bed early tonight.. :(
Install along with clippy.js for maximum usability!
I think this is a pretty superficial view. Each one of these tools has a core concept: Grunt - take a set of files, transform them into other files on disk Gulp - take a set of files, transform them into other files *in memory* (i.e. Grunt tended to get very slow/hard to maintain because disks are slow and it's one big shared mutable state blob managed by a bunch of plugins) Webpack - take a set of n *modules*, run transforms, package them into a set of m *bundles*. This idea is wildly different than the other two. I gave a talk on this here: https://www.youtube.com/watch?v=VkTCL6Nqm6Y
Let's say I didn't want to transpile a javscript file containing JSX or use the clunky DOM-like API. Is there a way to compile a JSX string for React?
I used to use Angular heavily, but have somewhat recently switched to React. I've found it a lot easier to use. That being said, I'm reserving judgment of Angular 2 until there is a stable release. Angular 2 is usable but there are a lot of best practices still to be established, it's still very bulky (React + Redux + React Router + Fetch polyfill + Immutable JS is smaller than Angular 2 on its own), and a lot of documentation is still incomplete, and for these reasons I don't like using Angular 2 at the moment, but these are all things the Angular 2 team has said they hope to improve before the stable release.
And async/await ^which ^is ^mostly ^candy
Even though it's stage 3? So, only some of the stage 3 proposals will make it? I didn't expect that async/await was that far away. How about SIMD?
The npm package seamless-immutable uses object.freeze with an optional parameter to apply it to nested values to have a truly immutable object. It's been useful for maintaining an immutable state within apps. It goes well with redux.js
Native web pack... Man the dreams I've had about this .. 
Beating a dead horse...
Oh sorry, to answer the SIMD question, it will also not be in 2016.
To display the data you had submitted you have to print all the values that the _POST array holds. Check the Yii documentation about that.
For perf, probably not, because micro-optimizations vary from browser to browser and your code may actually require nested for loops, how would it know? For features, yes, eslint has rules for just about all of them, fully configurable. You can make your on rules pretty simply too, or so I have heard.
Is it just my use cases never align with this, or is server-side rendering less and less necessary these days?
You guys are the best, thanks for explaining!! I completely missed the fact that returning the function would put it into a loop.
Someone explain to me why facebook with its infinite resources can't make react as blazing fast as an identical framework developed by a single dev for free?
8 months of development just to get the first level out? Wow, that's commitment. This is pretty motivating. Really nice work, I loved this game and the hard work put into this really shows.
I think it'd be very difficult to find even one person with equal enough experience across all frameworks to make this meaningful.
If you care about SEO, you still need to worry about server side rendering There are a lot of people building a new generation of unindexable "flash sites"
Pretty shallow comparison. But having said that, this only proves that React is the clear winner. Look at the size of Angular 2 which is 764k compared to React at 151k. Yes, Angular is a fully-featured framework and React is technically just the view aspect. But having said that 99% of all of the things Angular 2 can do, React can do (if you throw in React Router which is a few more kb's) the overall size is still way smaller. Size matters when you're building a site for mobile users or for demographics with slower speeds like Africa. React + React Router + (some Flux implementation) + Fetch polyfill will come in way smaller than 764k. And that is even assuming your app needs a router, Flux library or Fetch polyfill. You don't need a monolithic framework for everything. Most people do not assess their needs and pick the right frameworks/libraries and tools before starting a project. I love front-end development, but I think sometimes people pick whatever is the hot choice right now without asking, "Do I even need a framework?" As for server side rendering, React can do both. And I feel as though isomorphism isn't as beneficial to development as some people make it out to be. For years we got by fine without it, but all of a sudden Node increases in popularity and we decided that a shared codebase is a good idea and essential. There is rarely a scenario (except the aforementioned speed concerns) when isomorphism is a benefit to an application. In-fact, I have found it can just add unnecessary complexity to an application with negligible benefit.
I hear you on the NDA business, but it's a real concern for me at the moment. The work I'm doing (while not "novel") is extremely proprietary. What can I tell about you to help clarify my question? Edit: Grammar
Why?
I'm very okay not supporting IE and Safari. But I will leave the transforms on for some time, just not with any reasoning related to those browsers.
Google executes JS so it can index JS apps (assuming they use proper URLs). Server side rendering aims to improve the first pageview render time.
Very interesting:)
Because you can find mistakes easily by having a clear, early error while you develop, rather that a weird behavior and bugs hard to pinpoint.
If you care about time to first render as well.
This sounds like react to me... In react, you give every component some props and it returns Html, if you want to render it takes the dom, react does a diff of the old and the new dom and creates a patch. That way you can build your component in a functional way: take several input params and return a node 
Thanks for clarifying. Maybe it's just me, but, when I see: map('.p').filter('!=null').reduce('+') ...my impression is that the probability of making a mistake while writing that line of code is going to be damn close to zero, as well as the probability of misunderstanding that line of code while reading it. Moreover, even if using code strings can at first be seen as a weakness (no parsing, no syntax highlighting), on the other hand the very use of code strings makes very explicit that we are *generating* code. In my opinion, no amount of tooling is going to compensate for these two points, precisely because tooling only provides *weak* safety in a dynamically-typed context like JavaScript. In a more type-centered context like TypeScript, Haxe or OCaml, I would definitely see it otherwise. By the way, when refactoring code in OCaml - especially when changing types - the guidance provided by the type system is truely amazing. 
http://www.infoworld.com/article/3024271/javascript/nodejs-welcomes-microsoft-chakra-javascript-engine.html
There is no XML in Ajax. Ajax is not an acronym.
Great, it seems the perf are almost 4 times worst than react.
Probably Redux. https://github.com/rackt/redux
Why are people so hung up on library size? With features like tree-shaking just around the corner most of this won't matter any more.
I feel this post is a little bit empty. You didn't even specify what you did try to make it work. :( &gt; We tried all kinds of methods listed on JSPM github discussions like bundling all dependencies during dev, but it was still really, really slow. &gt; &gt; We feel this is just an inherent problem with JSPM's architecture and simply cannot be solved unless JSPM becomes more like Webpack. On the contrary, we us JSPM in a RoR project and it works great. I don't have to trouble myself with running a second server. The speed is fine – we bundle the dependencies in a separate file and transpile our own code on each reload. And for deploying the code, we just have a simple npm script set up on the server which is ran after each deploy: `jspm install &amp;&amp; jspm bundle main app/assets/javascripts/bundle.js --minify` No need for Gulp for us.
If you need routing, resolving urls requires that server or placing your assets behind nginx or something similar. Unless I'm missing a way to resolve https:// urls between S3 and Cloudfront
In addition to what /u/erwan said, strict mode also offers significant compiler optimizations. 
You can use $(npm bin) on non windows machines to get around this if your company only develops on a mac. Fairly certain you can fake this in windows too. Whether going through all that work is worth it though? No clue
Angular2 is that size partly because it is still in beta, and comes with a bunch of tests/debug code etc which won't be there on release
Well, the good news is that V8's SIMD implementation has been making steady progress for quite a while. https://bugs.chromium.org/p/v8/issues/detail?id=4124 You can enable it if you start Chrome with: --js-flags="--harmony-simd"
Noted. Adding this to my list of things to learn. Thanks! 
Hey adityars, Just wanted to say such an amazing amazing job. I will purchase your book tonight. What are your thoughts of frameworks like pixi, phaser, etc? Control vs speed to market, etc
Do you mean a native app? If so, then check out Cordova, ionic, react native, and phone gap. Do you mean a mobile web app? You can check out MDN and Google for some blog articles!
You sound like you know nothing about CSS. The client should probably give the project to somebody who is not transitioning to javascript from Cobol.
It sounded like you were describing the perfect situation for a react app. Maybe take a look into it?
Yet Redux is not MVC.
Yeah it is, it means Asynchronous JavaScript and XML.
http://shiflett.org/blog/2007/apr/ajax-is-not-an-acronym
 event.preventDefault(); event.stopPropagation(); and you'll be able to restore the initial down-arrow key without having the page to scroll :-)
Definitely a good addition to the comparison but this is the hardest metric to analyze. Lack of questions is either a good and a bad thing. Maybe something like activity stream of asked questions is better metric because it will be easier to compare the community support.
&gt; This is exactly what Redux allows you to circumvent. What you're describing sounds like React without Redux. Just to make sure I'm following, you circumvent that by having direct access to the stores from the components. Is that it?
why not create a y in x tutorial for es6?
Yes, it's very similar to AWS Lambda, but without any of the setup or configuration hassle. We're still working on the messaging :)
Classic closure in a loop problem. http://stackoverflow.com/questions/750486/javascript-closure-inside-loops-simple-practical-example
This is actually great but does anyone know of any ES6 video tutorials? I'm more of a visual learner and have been struggling to understand ES6/Babel
I don't have anything against them.... Just like I don't have anything against ready made cooking/baking mixes.... They have their time and place, especially when making specific recipes... However learning to build from scratch combined with using frameworks for specific projects is my ideal middle ground... Impact js for example was great for creating a quick side scrolled or single screen multi element game with its level editor.... Pixi gets a lot of cool stuff right for people wanting to avoid primitives and deal directly with entities with the webgl + canvas combined model... As do derivatives such as phaserjs and panda.... However some of the implementation details can become restrictive when you want to do anything beyond what the developers envisioned.... I've done enough client games using frameworks.... However every game that has ever got me famous, I did vanillajs .... Bottom line... It depends on you and your needs ... :)
I had to check because of you. I was like, no way it can't be. 
What about [axios](https://github.com/mzabriskie/axios), I used in couple of projects and was very satisfied, mostly because it has same interceptor API as original angulars `$http`.
Pluralsight.com has a few of them, and they are excellent.
Yup.
Hey! If you don't mind, I'm somewhat new to programming... Why "foo" and "bar?" To me, they always remind me of "FUBAR" from when my friends and I would get drunk in high school. "Fucked Up Beyond All Recognition." Ha! So... why "foo" and "bar?"
Nice! I've been going through some of the new arrow function syntax and I put this together yesterday (**really basic**): http://codepen.io/anon/pen/zrjBWN?editors=0010 Discussion here: https://www.reddit.com/r/learnjavascript/comments/42yj6y/es5_es6_demo/
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment is kind of implicitly explained in the modules example but deserves an own explanation in my opinion.
That kinda attitude kinda puts you in the kitchen sink category. Let other people be great at specific things for you, otherwise you'll be running a stack of mediocre self built tools. This isn't a catchall of course, but there is absolutely nothing wrong with using other peoples tools.
i always liked doing it without toggle $('#nav1,#nav2,#nav3,#nav4').fadeOut('slow') $(this).fadeIn('slow') or maybe $('#nav1,#nav2,#nav3,#nav4').not($(this)).fadeOut('slow') $(this).fadeIn('slow') if you cant do them all at once you have to get tricky, one way you can do this is using a data tag: function navFadeOutOpenMenus (e) { $('#nav1[data-expanded=1],#nav2[data-expanded=1],#nav3[data-expanded=1],#nav4[data-expanded=1]') .fadeToggle('slow') .data('expanded', 0) } $('#nav1').click(function(e){ navFadeOutOpenMenus() $(this).data('expanded',1) $(this).fadeToggle('slow') }) // etc 
Your custom components will still rely on the structure of out-of-the-box html elements, you can't avoid that. You can use CSS or stylized CSS framework like Bootstrap or Foundation to help guide the structure of your custom components. All these components will have customization, hence the existence of CSS. Render speed and animation will only be concern once you figure out the aforementioned. When you encounter your issues with flickering or choppiness, google the solution "avoid flickering animation html css" or variation thereof. Please review HTML/CSS princples at these tutorials: https://dash.generalassemb.ly/ https://www.codeschool.com/paths/html-css When you finished those, move onto more dynamic things like JavaScript and React: https://www.codeschool.com/paths/javascript https://scotch.io/tutorials/learning-react-getting-started-and-concepts https://www.codementor.io/learn-reactjs https://www.quora.com/What-are-some-good-ways-to-learn-ReactJS
Totally agree, I can't understand examples with foo/bar, my brain doesn't understand the relationship.
That sounds interesting. How do I join?
Good question. I can't say anything about Coffee- vor LiveScript as I've never used them. I prefer TypeScript instead of ES6 because of interfaces, static typing and accessor modifiers (private, public...). But thats just developer candy :) Most importantly (imho) is the fact that your TypeScript (I think coffee too) gets conpiled so that (some) JS errors occur in compilation and can be fixed before you'd deploy in prod systems. In the end it's about you and the language that's most comfy too you as it all becomes ES5
I don't know what that is, sorry.
I haven't looked deeply at your code, as it's too much work to get an example working - as someone else said, a Codepen would be useful. But the screenshot image you are placing on the canvas - is it being loaded from a different domain than the one which is serving the app? If so, you will be subject to cross-domain rules and you won't be able to read from the 'tainted' canvas after placing a cross-domain image on it. You can make it work by [sending CORS headers and setting the `crossOrigin` property on the image](http://blog.codepen.io/2013/10/08/cross-domain-images-tainted-canvas/).
Decorators are great.
For the time being, until ES6 support is widespread and Uglify supports it, your best bet is to compress your JS *after* putting it through a transpiler (e.g. Babel).
I figured out the problem. That's exactly what it was.
If you are looking for something more relaxed and not so opinionated, Backbone is a great choice, especially if your apps are backed by a REST API.
AngularJs! Since you're already using the M$ stack, AngularJs is backed by M$ and Google, it already ships in Visual Studio. This is the framework that everyone is adopting. AngularJs + MVC Web API are a match made in heaven. :) 
Right. The deadline is March 1, and there are no more TC39 meetings between now and March 1, and therefore no currently stage 3 proposals will advance before the deadline (with the exception of those that advance today, ie. exponentiation operator).
SIMD is making progress across all implementations (Chakra has it, so does Spidermonkey). It isn't too bad if it reaches standardization next year :)
&gt;We use c# MVC with Telerik's Kendo MVVM framework for the client side. We have had great success with this however the license cost per developer seem a little steep. * What are you paying (ballpark) for your Kendo licenses? Keep in mind this is for having "great success", which most likely provides ROI in future work. * What do you think you will end up spending in ramp-up time for switching to a new JS framework? What are you *prepared* to spend (which is most likely grossly underestimated)? * Is the desire to switch solely based on $? Being a small dev shop do you think you could raise your rates ever so slightly to offset any Kendo licensing? &gt;We are in the early stages of looking into a javascript framework to help us move away from Kendo as well as create more fluid applications What does "create more fluid apps" mean? Knockout is basically just two-way data binding, it isn't a framework. It has a low learning curve, but I'd guess it's not what you're looking to do...
Of those languages, only TypeScript is a superset. Valid ES6 code is also valid TS code. CoffeeScript and LiveScript are pretty pointless from my point of view since they only offer different (more ambiguous) syntax and lots of sugar without improving the tooling. Dart is a separate language which is much simpler than ES6 even though it offers things like optional types, mixins, metadata annotations, async/await, and operator overloading.
Could you elaborate please, I guess I don't know the difference between superset and preprocessor. Also, how does Dart compare to Typescript?
angular and backbone have a nice collection class (like its own array class with find/delete/set1/setall), so if you are doing lots of list stuff it might be a really good choice ive found react to be the sanest, because of not mixing JS and XML (html) * unless you are going to use css 3 animation * unless you are doing a lot of nested data components (and not using a datastore or flux) one example of nested data i would avoid react for: components: `multiwindowapp&gt;component&gt;rightbar&gt;split50vertical&gt;list&gt;listitem` , its just klunky passing the properties from component all the way to list, when it could be 4 or 5 components deep. (a lot of boilerplate that you get to tweak constantly when your API changes, if the API is already firm its probably fine)
Oh.. There is a simple entry form on the right of the game so you can register.... Just pick the updates you actually want... Just to give you an idea I sent 3 beta updates and one release email for commandos in all of January
Gotcha! I saw that but I wasn't sure if that was the same thing that you were referring to above. Thanks!
es6 has await and async functions, classes, promises, and some other goodies typescript has types like `int bool float` etc and a lot of es6 goodies (and classes, inheritance, and more probably) coffeescript has a nice compact syntax and half or more of es6 features dart is its own language, and probably the most feature rich language of the 4 
A newbie might not be aware of the different context that this is being used in.
Sure, but with that argument, many other things will look similar to a newbie as well. I don't see how this is particularly bad for newbies.
Thank you for your reply. I understand what you mean, i could not find any active forums for LL. If I may ask, would you know how I can write that I don't want two objects in that fll array? Can I do that after I wrote getLength ?
Appreciate the feedback ... Thanks...Glad you enjoyed it ... :)
For some reason I expected something more than a Slate port to NodeJS. Slate is too much overload for me, I get lost in three columns and for me there are far too many background/foreground colors. I'd be great to see a minimalist version of Slate that is more than just a theme.
why don’t people simply use [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) instead of rolling their own?
&gt; es6 has await and async functions Async/await won't even make it into ES7. https://www.reddit.com/r/javascript/comments/42wulr/v8_js_engine_to_support_91_of_es2015_in_chrome/czegzh0 &gt; typescript has types like int [...] float Dart has ints and doubles, but TypeScript has only `number` (double).
This app doesn't have a server side. It's purely client side. How does react do with animations? Are there any remarkable performance gains in that area, or is it about as performant as something like greensock? I've done some research, but would rather hear from someone who's used it.
And it's down :(
Yeah, that is how I am doing it as of now. I wish we get a ES6 compressor soon.
I just started reading about ReactJS and have heard lots of good things about it, including it being fairly easy to understand. I assume using FLUX would be easy to integrate with .net. Honestly if we use Web API I feel all of the solutions would be fairly easy. 
I have heard a lot of good things about backbone. Perhaps Backbone and ReactJS combined is the way to go. 
I guess my worry here is Angular 2.0 is just now in beta correct. If we make a switch now I'd like to only have incremental learning curves. Do we learn 1.x first and then re-learn 2.x?
WhatFont says [it's Lato](http://i.imgur.com/RIRQpK0.jpg). Same font used for all the CodePen panel titles.
All good questions. * We just spent over $5,000 on license. Now to be honest that cost will go down significantly at renewal, which will come into my decision of course. * I am not to sure what we will spend for ramp-up. I am the lead developer and we are shop of 4 right now. I plan on testing out a few frameworks and then making a basic test application that will help the other developers ramp up quicker. I am sure it will cost more than I think in time. * The desire isn't only based on money. Up until recently I have been very happy with the Kendo Library. I have a few issues though. Part of what we pay for is support and I feel the support hasn't been as good lately, if I can find a better solution with a large enough community to answer questions then that would be better. Also, Kendo sometimes doesn't play as nice with Bootstrap as I'd like. Another issue is we develop a lot of applications for other businesses that eventually want to take over their own code. We have had complaints from clients when we use a paid library. 
I just looked it up. Other than the name doesn't seem bad. 
They do exist as of today. It's not like it's been around forever and everyone is using it. In fact, no one heard of it until today cause it's only now been introduced. I never said Tonic was a simple tool.
If you have GPU support you can write a shader which will do this to all the pixels at once.
With es6 syntax (and a little regex for the second operation), you can get a really succinct and loopless version of it [jsFiddle](https://jsfiddle.net/lexicalnoscope/t5em476g/)
interceptors. request and response transforms. 
Cool, with the open sourcing of [ChakraCore](https://github.com/Microsoft/ChakraCore) also done I can see some competition spurring things along. Nothing's got close to matching the 97% compatibility level of the [XS6](http://kinoma.com/develop/documentation/js6/) JS engine though!
I recommend this. Use React for your view and Backbone for your models. I use this and it is very powerful. I find that I don't even need Flux at all. Someone even went as far as to strip out the view from backbone: https://github.com/green-mesa/backbone-model
If you were looking for Obfuscator (making the code harder to read), then a transpiler would actually help. (But it looks like you just want a compressor)
what do you need them for?
You'll want to .split('-') the string into an array and then change each element in the array to make it uppercase (use the map function). Then if you want it back into a string, you can .join(' ') the result with a space or whatever character you want. let newStr = str.split('-').map((s) =&gt; s.substr(0,1).toUpperCase()+s.substr(1)).join(' '); http://www.es6fiddle.net/ijyqsb5l/
I don't use TypeScript for anything, but I know its syntax and features. Its analyzer does a great job and its compiler is fairly fast. If you're looking for some kind of ES6++, TypeScript is probably your best bet. Personally, I prefer Dart, but if I had to interact with a lot of JS or if I had a large existing JS codebase, I'd use TypeScript.
&gt; yeah, as soon as you duplicate your second path with more than one slash in it, it’s time to ditch npm scripts and at least switch to You're not wrong, but we're still waiting to find an alternative that's better. &gt; makefiles Yeah, problem is, makefiles in an office full of web developers are basically the definition of "crazy unmtaintable technical debt". A random coder where I work has a fighting chance of figuring out that npm script; I'm not even the only one who could have written it. Nobody here understands makefiles. If makefiles are a better choice for you, then that's awesome. I also know some places who use rake with great success. But for *us*...no.
Nooooo. Stop this non sense Typescript already...
Hey Daniel, amazing release and awesome work from you and the rest of the TypeScript team! With regards to backwards compatibility/breaking changes, I know it's huge concern for language designers, and for good reason. Are there any strategies that TypeScript uses or would consider adopting to help determine if a feature is worth adding, or worth breaking compatibility for? As an example, this behavior could be tied to the JSX flag, and the flag could be off by default, but later changed to on by default. Users who require the old behavior because they haven't or can't migrate old code could still use newer version but would need to configure the flag settings. Is something like this an acceptable solution or does it depend heavily on the scope of the issue?
Thanks. I tried your suggestion. It makes a large difference for the "select row" benchmark with 53 msecs instead of 164 msecs. The update 1000 rows was a bit quicker with 550 msecs instead of 590 msecs, but the rest was pretty much unchanged. I'll update the code.
{1, 3} is a subset of {1, 2, 3}. {1, 2, 3, pink elephant} is a superset of {1, 2, 3}. A subset omits things and a superset adds some. https://en.wikipedia.org/wiki/Subset TypeScript is a superset of ES6 which adds things like type annotations, interfaces, and enums. [Strong mode](https://developers.google.com/v8/experiments#strong-mode) is a subset of ES6 which removes things like `var`, `delete`, and things like the ability to step outside of an array's bounds or the ability to modify classes. Dart is neither a subset nor a superset of ES6. It's a new language with simpler semantics. Like TypeScript, it's optionally typed, but it doesn't share TypeScript's JS-ancestry. Here is a small example which shows some of the differences: class Vector { num x, y; Vector(this.x, this.y); Vector operator +(Vector v) =&gt; new Vector(x + v.x, y + v.y); String toString() =&gt; '($x, $y)'; } main() { print(new Vector(2, 3) + new Vector(4, 5)); // (6, 8) } https://dartpad.dartlang.org/a2e583845ed6a3cdbcd3 `num x, y;` creates two instance fields. ES2017 (or so) might support that, too: https://github.com/jeffmo/es-class-fields-and-static-properties `Vector(this.x, this.y);` is like: constructor(x, y) { this.x = x; this.y = y; } `Vector operator +...` defines the '+' operator for this type. Operator overloading is really neat for games. It makes dealing with vector math a lot easier. `'($x, $y)'` is like: `(${x}, ${y})` Also note how the operator and the toString method use arrow functions, which is also something you can't do in ES6. Dart code is pretty terse. The tooling you get with Dart is very similar to the one you get with TypeScript. In both cases you need very few type annotations to make it fully typed since most types can be inferred. For example, this demo only contains a single type cast and yet it's fully typed: https://dartpad.dartlang.org/e23e4d137570c652591e
Those custom events are only on Mac, 3D touch has a different API and does not have events that fire like that. I built a javascript library that is a wrapper around both methods in JS: http://pressurejs.com/
If you want to go with that data model, you can achieve it with a very small amount of code. As long as your content blocks are all inside of the same element, chaining `.siblings().fadeOut()` after your fade in command takes care of hiding all other content HTML: &lt;nav&gt;&lt;button data-content="1"&gt;1&lt;/button&gt;&lt;button data-content="2"&gt;2&lt;/button&gt;&lt;button data-content="3"&gt;3&lt;/button&gt;&lt;button data-content="4"&gt;4&lt;/button&gt;&lt;/nav&gt; &lt;div&gt; &lt;div id="c-1"&gt;I'm content&lt;/div&gt; &lt;div id="c-4"&gt;I'm more content&lt;/div&gt; &lt;/div&gt; Javascript: $('[data-content]').click(function(){ var selector = "#c-"+$(this).data('content'); $(selector).fadeIn().siblings().fadeOut(); });
For what it's worth, this kind of mistake wouldn't have happened with TypeScript or Dart. They both know that "indexOf" expects a number/integer and not a boolean: http://i.imgur.com/i3JiwI3.png Since "indexOf" is a built-in method, this particular bug would have been caught either way by [VS Code](https://code.visualstudio.com/): http://i.imgur.com/cfETSvF.png (green squiggly in JS mode) WebStorm would probably have caught it, too.
A bit of explanation. I spent the last two months building an application which had the following requirements: - Universally rendered - Good development experience (hot reloading) - Doesn't use Bower or Gulp - Supports Cordova iOS and Android - Written with ES6 I chose to go with React and Redux because I wanted to learn them. I'm still not an expert at it, but I'm getting better. While working on it, I referenced [RRUHE](https://github.com/erikras/react-redux-universal-hot-example) a lot, but found it to be a bit complex and I didn't like the directory structure. So I decided to rip out what I did and put it up with some examples, an opinionated directory structure, and these features: - Universal rendering with `react` and `react-router` - Hot reloading with `WebpackDevServer` and `react-transform-hmr` - The new `react-router-redux` for react-router -&gt; redux bindings - Babel 6 for ES2015 - Cordova support with hot reloading, a build tool, and a distribution tool that uploads your binaries to [Fabric/Crashlytics](https://fabric.io) - Webpack configurations for production, development, and cordova - ...and I think there's more, but that's the gist Suggestions, improvements, and strong opinions are welcome! 
Knockout isn't the hottest 'framework of the now', but I wouldn't say it's _dying_. It's still being worked on, still getting new features, though the changes are quite iterative and evolutionary. It is a knowingly modest framework, though, and doesn't provide much more than data binding and componentization. I have built several applications with KO with great success, but you do need to have a clear idea how you'd like to write your domain code. Then again, no framework will ever help you write business logic. Angular is a little problematic right now - 2.0 is on the horizon but remains quite far from production-ready. Its API is still unstable and - as far as I know - Google haven't yet endorsed it for any more than experimental use. You may struggle to find documentation - its current user-base is enthusiasts and evangelists. React is just a view technology. It is often embedded into a Flux architecture which essentially uses events to drive changes in domain objects in turn rendered by React. There are several Flux implementations - the community seem to have coalesced around Reflux. There are also non-Flux React architectures, mostly plugging React views into some kind of functional-reactive paradigm. I have seen some promising projects combining React with RX.js EmberJS is old, but has a loyal user base and a fairly well-defined roadmap. It is very opinionated and may be a good option if you want the framework to lay the rails of your architecture. Its age means you'll probably have lots of choices when it comes to off-the-shelf UI components.
my point is: if you would benefit from variables, you’ve grown past npm scripts. if you use solely the variables+targets+dependencies+lines of code, then makefiles are better than npm scripts. surely, going more complex isn’t… e.g. redux’ npm scripts: "clean": "rimraf lib dist coverage", "lint": "eslint src test examples", "test": "mocha --compilers js:babel/register --recursive", "test:watch": "npm test -- --watch", "test:cov": "babel-node $(npm bin)/isparta cover $(npm bin)/_mocha -- --recursive", "test:examples": "babel-node examples/testAll.js", "check": "npm run lint &amp;&amp; npm run test", "build:lib": "babel src --out-dir lib", "build:umd": "webpack src/index.js dist/redux.js --config webpack.config.development.js", "build:umd:min": "webpack src/index.js dist/redux.min.js --config webpack.config.production.js", "build:examples": "babel-node examples/buildAll.js", "build": "npm run build:lib &amp;&amp; npm run build:umd &amp;&amp; npm run build:umd:min", "preversion": "npm run clean &amp;&amp; npm run check", "version": "npm run build", "postversion": "git push &amp;&amp; git push --tags &amp;&amp; npm run clean &amp;&amp; npm run docs:publish", "prepublish": "npm run clean &amp;&amp; npm run build", "docs:clean": "rimraf _book", "docs:prepare": "gitbook install", "docs:build": "npm run docs:prepare &amp;&amp; gitbook build -g rackt/redux", "docs:watch": "npm run docs:prepare &amp;&amp; gitbook serve", "docs:publish": "npm run docs:clean &amp;&amp; npm run docs:build &amp;&amp; cp CNAME _book &amp;&amp; cd _book &amp;&amp; git init &amp;&amp; git commit --allow-empty -m 'update book' &amp;&amp; git checkout -b gh-pages &amp;&amp; touch .nojekyll &amp;&amp; git add . &amp;&amp; git commit -am 'update book' &amp;&amp; git push git@github.com:rackt/redux gh-pages --force" and as makefile (still without variables): clean: rimraf lib dist coverage lint: eslint src test examples test: mocha --compilers js:babel/register --recursive test-watch: npm test -- --watch test-cov: babel-node $(npm bin)/isparta cover $(npm bin)/_mocha -- --recursive test-examples: babel-node examples/testAll.js check: lint test build-lib: babel src --out-dir lib build-umd: webpack src/index.js dist/redux.js --config webpack.config.development.js build-umd-min: webpack src/index.js dist/redux.min.js --config webpack.config.production.js build-examples: babel-node examples/buildAll.js build: build-lib build-umd build-umd-min push-tags: git push &amp;&amp; git push --tags version: clean check build push-tags docs-publish prepublish: clean build docs-clean: rimraf _book docs-prepare: gitbook install docs-build: docs-prepare gitbook build -g rackt/redux docs-watch: docs-prepare gitbook serve docs-publish: export GIT_DIR = _book docs-publish: docs-clean docs-build cp CNAME _book git init git commit --allow-empty -m 'update book' git checkout -b gh-pages touch _book/.nojekyll git add _book git commit -am 'update book' git push git@github.com:rackt/redux gh-pages --force
Mostly I have been using existing files and cherry-picking what I need until I get the errors and warnings down.. MediaStream.d.ts seems pretty clean and complete, though.
The Web audio typings are in lib.d.ts already so should already work. You're right that getUserMedia throws an error though, I wonder if that has been added in the latest update. Note though if you get stuck from things like that in the future you can cast it as 'any' like this: `(&lt;any&gt;navigator).getUserMedia`
Array of promisesQueue keeps recent user activity (letters from input are converted to XHR request and stored as promises in this array). Keeing them in array gives you access to the most latest (finall) request based on that activity. In short: I need just the latest XHR reposne.
Why? Have you used it? And if so, do you know any OO based languages?
Vue.js is the easiest MVVM framework out there (I think).
Holy shit, this looks awesome! If only I worked with TypeScript at the moment :) Two questions: [this-based type guards](https://github.com/Microsoft/TypeScript/wiki/What%27s-new-in-TypeScript#this-based-type-guards) [this-typing](https://github.com/Microsoft/TypeScript/wiki/What%27s-new-in-TypeScript#this-typing) Where exactly are these from and what about soundness? It raises covariance/contravariance related concerns for me. Is the second just a special case of/shorthand for "implicit f-bounded polymorphism as seen in the curiously recurring template pattern"? What exactly is the motivation behind the first one? Since I appear to be able to put any boolean expressions, I can use this to make "promises" to the type system? I.e. I can shoot myself into the foot really easily?
Most of this guys posts are him wailing on Typescript. Very odd.
I've been meaning to get into ES6 using Babel/Traceur/whatever (is there a big difference? Preference?), but I just haven't... mostly because TypeScript is so heavily implemented in our applications at my workplace, that it makes no sense to ditch it at this point. But I'd like to get into it sometime soon. I honestly don't know of the advantages of TS vs ES6/Babel. I've only been into OO for a year or two and only lightly, so I don't have much input on that. But the ability to create and extend classes in JS is AMAZING! Using .d.ts definition files is really cool too... I love being able to start typing a function and seeing the expected parameters and types. That saves a lot of time.
Then you don't want `all`. `all` is for when you want them _all_ and you just want the last one. In that case you need to handle the `ajaxCall` promises individually and only care about responses from the newest one. You can still use your queue for this, but it should be checked in the `then` to see if the result from the respective `ajaxCall` (which you can capture as a local variable before pushing it onto the queue) is the last one. If not, ignore it.
If you use www.ag-grid.com for your datagrid, you can still choose from the common frameworks, as ag-grid supports React, AngularJS, Angular2, Web Components and Plain Old Javascript. So choosing a framework doesn't bind you to choosing a grid.
This is the best answer because it uses regex, and doesnt use split or a loop to iterate every character in the string.
2.0 still has ~1000 issues on GitHub, it was projected for release late 2015, its now a month into 2016 and its still in beta. I personally wouldn't hold my breath, 1.0 is not a steep learning curve, you will benefit greatly from it as well. There will be ways to port 1.0 to 2.0, they can also be running in the same app, so you can start new functionality in 2.0, while doing the easy port for the existing code base. More info here: http://angularjs.blogspot.com/2015/08/angular-1-and-angular-2-coexistence.html
I'm not quite sure what you mean, he mocks some data up in the `model` method for the purposes of the tutorial, you would usually have something like `this.store.findAll('someModel')` in the model hook which would load all your models from the store/API. I personally have never used firebase but I imagine there is an adapter which would let you quickly connect and pull data 
Alright thanks a ton!
What extra syntax are you talking about? The `async` and `await` keywords? If that's what you're referring to, the alternative is to use a lot more code to produce the same results. A couple of keywords (which do serve the necessary purpose of indicate asynchronous behavior) go a long way to code reduction, even with their additions to the code itself.
Type guards in general are there to make promises to the type system, and yes you can shoot yourself in the foot with them so make sure you have test coverage on the implementation of them if you use them. As far as this-typing, yes.
First of all, this can't be the code triggering your error - you say it happens when you *get* something from localStorage, but the code you pasted is for *setting* something in localStorage. As for the "unexpected token u", this occurs when you try to `JSON.parse()` a string which contains undefined - this because, while undefined is valid in JS, it's *not* valid in JSON. For example, run this on the console to see what I mean: JSON.parse('{"a": undefined}') So in your `getItem` code, try console.logging the string you retrieve before JSON.parsing it. You almost certainly have an undefined in there somewhere. Incidentally, it's weird that you managed to make this happen in the first place, since `JSON.stringify` will correctly strip undefined. I believe there are certain JSON libraries (python maybe) that don't handle this correctly and return JSON with undefined, so maybe it came from something like that.
Hi! Thank you for answering. How would I go about console.logging it, and identifying which one is undefined? Also, this is my load() function, is there something wrong with it? function load() { localStorage.getItem("save", JSON.parse(save)); if(typeof savegame.hp !== "undefined") hp = savegame.hp; if(typeof savegame.maxhp !== "undefined") maxhp = savegame.maxhp; if(typeof savegame.combatLevel !== "undefined") combatLevel = savegame.combatLevel; if(typeof savegame.nextMiningLevel !== "undefined") nextMiningLevel = savegame.nextMiningLevel; if(typeof savegame.miningLevel !== "undefined") miningLevel = savegame.miningLevel; if(typeof savegame.miningExp !== "undefined") miningExp = savegame.miningExp; if(typeof savegame.points !== "undefined") points = savegame.mipoints; if(typeof savegame.totalmexp !== "undefined") totalmexp = savegame.totalmexp; if(typeof savegame.ironOres !== "undefined") ironores = savegame.ironOres; } And here is the place where it says there are errors: http://puu.sh/mNx0I/46feee7202.png allthough if I remove the upper, it just moves the error down too.
Oh my god. I can't believe I didn't notice this. I'm a newbie coder, so my syntaxes are so bad, but that are one of the things that I'm working on bettering.
Hey all - I was pretty fed up with some of the bloated examples out there when I was trying to show or teach my friends how to play with React and Redux. So I made my own... While there are some great, great examples out there with super-advanced features, they aren't conducive for the beginner to see how the pieces fit together in a realistic setup, this means: having Webpack, being able to write in ES6, enabling DevTools (but splitting that up) and allowing for easy extensibility into any which direction. I tried my best to keep it as un-opinionated as possible - and to leave great comments, hoping that people learning can follow the code by reading... I hope you enjoy it and be sure to star/fork! :)
A few things. First off, where are the variables `save` and `savegame` coming from? `save` is likely undefined, so `JSON.parse(save)` is equivalent to `JSON.parse(undefined)` which will obviously fail. Secondly, why are you even passing a second argument to `localStorage.getItem`? [getItem takes a single argument - the key to retrieve](https://developer.mozilla.org/en-US/docs/Web/API/Storage/getItem). And finally, you're not doing anything with the thing that's returned from getItem. You may want to brush up a bit on the localStorage API or you'll keep banging your head against the wall. I think you are going for something like this: function load() { var saveGameString = localStorage.getItem("save"); var saveGame = JSON.parse(saveGameString); if(typeof saveGame.points !== "undefined") points = saveGame.points; //...etc... } This assumes you have already declared the `points` and other variables in the containing scope.
Seems like they are pretty successful. And doesn't Facebook own them? Anybody know why they are shutting down?
 if (day = "Monday" is setting day to equal "Monday", you need to use == to do a comparison. 
&gt; What's the advantage? Static typing. &gt; Isn't writing ES6 using something like Babel preferable? No. TypeScript aims for 1:1 feature parity with ES6 + the benefits of a type system. &gt; I find it hard to believe Microsoft has done something well and truly right. Microsoft is one of the largest and most successful multi-national companies in existence; this statement defies logic. That aside, look at what Microsoft has been doing lately; you might be surprised.
While totally valid there is no reason to do === vs == in that case
cool thanks!
Great thanks for the input. Just curious, regarding the book, it says on your site it was published in 2012. This will be tricky to answer without being bias, but does it still apply to todays world? Considering how quickly things change in JS land?
Something to consider to clean up those if blocks: var savegame = JSON.parse(localStorage.getItem("save")) || {}; // save game defaults to an empty object var hp = savegame.hp || 0; // 0 here can be any default you'd like This avoids any undefined errors and makes the code a little terser, less typing means less chance for typos.
It's a bit of an extreme example, but it seems to be Sindre's style. It was brought up in a [Github thread here](https://github.com/sindresorhus/ama/issues/10#issuecomment-117766328). Here's what Sindre had to say (and read the whole thread for more, it's a long post on the topic). &gt; Some years ago. Before Node.js and npm. I had a large database of code snippets I used to copy-paste into projects when I needed it. They were small utilities that sometimes came in handy. npm is now my snippet database. Why copy-paste when you can require it and with the benefit of having a clear intent. Fixing a bug in a snippet means updating one module instead of manually fixing all the instances where the snippet is used.
Any idea when async/await are going to be added? I think I was using async await with Mongorito promises that do not work well with them. I guess I'll wait for async/await mongodb wrapper. The extra code I was talking about was when it was callbacks/promises. I just hate all that extra syntax, i'm wondering if this is where lisp macros come in.
small chance theres a lib on unheap.com else i would check npmjs.com once u figure out some keywords 
yea xml req functions cant access text files. only file inputter can (`&lt;input type=file&gt;`) i dont think i really understand why u need xml req to read a local text file. (you cant) maybe edit your question with your goal of xml req, its not clear. xmlreq is the ajax function maybe: just put the two together `lines = lines + line` `doxmlreq(lines)` `doxmlreq = (lines) =&gt; new xmlhttprequest(...)` i guess you can add an intermediate step if ur making some sort of remote js file uploader longpoll_request_server().on('url', function(data) { file.src = data.url // set html file input src here, not sure if u can via js! var str = readlinebyline(data); xmlreqlines(str) }) 
There is still a reason; if they pass in something which is not a string, how will this behave? All of a sudden, we have all these extra type conversions happening. It's not something big to worry about when beginning, but using === should always be the default, except where type conversion is explicitly wanted. And if you're relying on that, it might be helpful to document that you're expecting type conversion may/will take place.
As a further to this, it may even be helpful to put a type check at the top of the function first, eg. `if (typeof day !== 'string') { return 'Not a day'; }`
&gt; allow comments in tsconfig.json At least they're sane, unlike json) 
1 stylish chrome plugin and greasemonkey do this (and you dont have to use any onload stuff) if your doing it yourself do `window.onload = function() { foo(); }` if doing yourself and using jquery `$(function(){ foo(); })` 2 // jquery var coords = $('#mydiv').find('.myclass').find('div').html() // shorter version var coords = $('#mydiv .myclass div').html() //vanillajs: var coords = document.querySelectorAll('#mydiv')[0].innerHTML
maybe one is for the first page load from server (original html) and the page:load ready is for turbolinks pages (2-end) ------------ it looks like page:load is an event and ready is the argument in the second one. maybe its a hack to make the page-load ready event fire on the original jquery page load (first block) idk https://github.com/rails/turbolinks --------- edit docs say $(document).on('ready page:load', function(event) { // apply non-idempotent transformations to the body }); the non idempotent implies its only going to be called one time ever. (first page load probably)
Yeah I it makes a little more sense now with his explanation, thanks for the input!
Hmm. Can you mix `--allowJs` and `--declarations`, to produce some flavor of .d.ts files from .js source automatically? Because that'd be swell. 
So what are you really trying to accomplish here? Or is this just messing around with JS? You seem to use the word "sorted" in your question, which really doesn't have a lot of relation to the question you're asking. Here's some code: ["foo", "foo-bar", "baz-bar"].map(function(s){return s.split("-").map(function(w){return w[0].toUpperCase() + w.substr(1);}).join(" ");}).sort(); which produces: ```[ "Baz Bar", "Foo", "Foo Bar" ]``` unless you want something like this: "foo-bar-alpha-baz".split("-").map(function(w){return w[0].toUpperCase() + w.substr(1);}).sort().join(" "); which produces: ```"Alpha Bar Baz Foo"``` 
Also, this expression actually has a result. It's "Monday". To Javascript, all non-empty strings are "truthy", which mean you may as well have put `true` instead of `day = "Monday"`. Then because you're or'ing that expression and it came out true, there's no reason to even evaluate the rest of the condition.
Nice work! Funny because I just posted something similar too, though mine might be a bit more opinionated. https://github.com/combine/react-redux-starter The thing is, and I could be wrong about this, but I think people working with react and redux start to form their own opinions about the best way to do it. I noticed that every boilerplate out there differs a bit. Do you think that's the nature of this stack versus something like Angular, or even Rails?
It's funny when people who shit on microsoft all their lives suddenly start using Typescript because it's currently a tech buzzword. 
Thank you so much!
I'd argue that tools that lower the overall complexity in the development system can help the programmer focus.
I'm not exactly sure what you're saying, though the tone of "currently a tech buzzword" seems to indicate you think lowly of Microsoft and TypeScript. Primarily, "TypeScript" is not a buzzword. It's the name of a technology product that Microsoft has created; it's not jargon or a technical term or meaningless. Second, while TypeScript may be new to you and many others, it has been around for a few years and has seen great success on a number of projects, small to large. As it so happens, Microsoft's Azure portal is written in TypeScript, which is a huge and successful product for Microsoft. It's not going anywhere any time soon, a leading language developer is behind the product, an enormous software company is primarily responsible for it, and it continues to improve every day. I really don't understand where the distaste for TypeScript comes when people have happily been using CoffeeScript, Babel, and other to-JavaScript compilers.
How was this not the headline feature? It's my biggest annoyance when trying to annotate real APIs.
This will blow your mind: you can enter ES6 code on your .ts files
Nice work. I was looking for something simple to help me learn Redux. :)
If IBM really has no interest in maintaining Express, they should hand it over to a trusted contributor who wants to take over as maintainer... I have no idea why the Node.js Foundation would accept this proposal...
Doug Wilson is already burned, I don't think he'll ever go back to express by reading his comments in this thread - [is express dying?](https://github.com/strongloop/express/issues/2844). IBM and StrongLoop has kept Doug 100% out of the loop when it comes to decisions for express, even though he is one of the few contributors. At a corporate level, IBM believes they have included him, but in reality they just keep informing him of their decisions after the fact. It is easy to understand Doug's frustration, considering he's been working on IBM/StrongLoop's property for free for quite some time and has been shown the ass in return. Doug rejected *a* proposal from StrongLoop, which might be the Node.js Foundation transfer proposal. edit: IBM is painted as the big bad overlord in the "express is dying" thread, but in reality they are a strong contributor to many open source projects. Kudos to IBM for giving away ownership of Express. They certainly didn't have to.
You can combine [some of these micro libraries](http://microjs.com/#dom)
There are a lot of lazy and incompetent guys out there. That's the market. 
Thanks for helping me. I tried what you suggested in the second example and when I entered it into the console I got a syntax error about a missing ) online line 6. I'm sure if that's the problem or if it before that line. Here's what it looks like now: function multiply(n) { var equal = 0 for(var i = 1; i &lt;= 10; i++) { equal = i * n; console.log(i + "*" + n "=" + equal); } } Does the type of quotation " or ' make a difference?
For Android apps, you may interest in https://crosswalk-project.org
Yeah you can certainly have most of your site be server-rendered HTML, and hten just have a few components (like a complicated form for instance) be a react component. You can even pre-render the form on the server as well, so the user doesn't see any "flickering". It's a bit different in how it works though. It doesn't do MVVM, or any view-model binding at all; it's focused on the view. I can't really fit a description on why that is good in this format; just try a couple of videos on youtube and then try to write a few components, and you'll see if it fits you
next level: a bash installer that checks if npmjs is down before doing $ npm install --global is-github-down
Oh shit my bad. Thanks. I hate to ask more of you but if could help with the final part of my project here that would be tremendous. So now I need to connect this function to a web page that allows the user to enter a positive integer. When they click a button, that number multiplied by integers 1 through 10 will be displayed on the web page. What I struggle with is getting input from the text box and displaying the output on the page. Here's what both files look like: The Javascript function multiply(n) { var equal = 0 for(var i = 1; i &lt;= 10; i++) { equal = i * n; console.log(i + "*" + n + "=" + equal); } } function call() { var outputDiv = document.getElementById("output") outputDiv.innerHTML = (multiply()) var button = document.getElementById("inputButton"); button.addEventListener("click") } I was reading elsewhere that it would be simpler to have another function call to *multiply* And the HTML &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Multiplication&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Multiplication Game&lt;/h1&gt; &lt;p&gt;Enter any number!&lt;/p&gt; &lt;form&gt; &lt;input type="text" id="input"&gt;&lt;/input&gt; &lt;input type="button" id="inputButton" value="Click to see what happens!"&gt;&lt;/input&gt; &lt;/form&gt; &lt;div id="output"&gt;The output div&lt;/div&gt; &lt;script type="text/javascript" src="multiplication.js"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Again any help is appreciated.
https://jsfiddle.net/ox7o40z5/ Your "multiply" function needs to return a string.
It is just Angular done right.
Is there a good overview/collection of JS patterns?
Tools don't have to solve *all* issues to be useful. TS' analyzer doesn't help with faulty algorithms, but it does make sure that you're using the right types and that there aren't any syntax errors. E.g. it does spot the type error caused by the misplaced paren: http://i.imgur.com/i3JiwI3.png And it also spots the forgotten '+': console.log(i + "*" + n "=" + equal); Both bugs are real-world issues which were produced by fellow redditors.
Static typing will save good and bad programmers alike from runtime errors, which is a lot. No matter how good of a programmer you are, we people make mistakes a lot more often than compilers.
Because he's that bad at regexes ?
Bang on! this works exactly how I needed it too, nice clean code. Will be adding this to my Gist for future use.
Yes (and unless you dig MS way of doing stuff I didn't like its architecture) and yes big big time. Even if I am turning away from OO at the moment towards FP.
No it is not when you have constant bashing for Typescript. Yes it is not right for everyone and it can lead to fragmentation. I would have welcomed MS to get behind Babel instead and ditch Typescript.
theres a web audio api, which you can use to create a oscilliator/visualizer, basically to get the raw data. its only like 10 or 15 lines of code too so its nice. the video generator is gonna take some planning, it could be done like 4 or 5 ways. it entirely depends on what movie format ur using. you could see how crumbles does it: https://www.crumbles.co/ maybe here has some good data: https://developer.mozilla.org/en-US/docs/Web/Demos_of_open_web_technologies (scroll to Video and audio api). theres 4 audio visualizer examples/src on that url, heres one of them: http://mdn.github.io/audio-buffer/ theres also might be some helpful data if you google 'animated fullscreen background html5', towards compression/framerate ideas. 
This book contains some good examples : https://addyosmani.com/resources/essentialjsdesignpatterns/book/ 
&gt; It's the name of a technology product that Microsoft has created; AFaIK, TypeScript was acquired by MS, not created inside MS!
I don't think it's possible to compare them, as they solve different problems. Using `Sinon` with `Mocktail` would be a great approach, and something I use in my own projects.
So what are the up and coming alternatives to Express? This is good news I guess, but it feels slow. I'm not heavily invested though.
Node desperately needs a de facto framework. Ruby has rails, Python has django, C# has .NET MVC/WebAPI, Java has SpringMVC. I'm fully in support of having options and using the best tool for the job but it would be nice to be able to choose a framework and be sure that it has a future. 
Reading through the comments I fully agree with the notion that it should not become part of the NodeJS Foundation till express has the manpower behind it to keep it supported. As it currently stands it's a liability with the way IBM treated the project after buying StrongLoop. Which you would think is weird considering strongloop fully depends on express to run. I also do not have much hope that many people will be eager to take it over with the way IBM has treated the previous maintainer. 
There is nothing Windows oriented about TypeScript itself though. It perhaps used to be back when Visual Studio was the only decent development environment for it, but nowadays I'd say it's one of the worst. I've since moved away from it and dabble with Atom/Sublime/VSC.
I don't think you can put this on IBM. The project was languishing under StrongLoop first, IBM probably didn't even know what they had. Even if they did it was still on StrongLoop to deal with it. Who really expects IBM to be quick on doing anything? The speed in which they are dealing with this whole "Express is dying?" stuff is actually amazing for them.
That's prefectly good advise! I event drop the promisesQueue. Just comparing last query from input with resolved promise result from ajax call. It's so simply and clever :-)
Here is a pretty good intro video to NativeScript: https://www.youtube.com/watch?v=N8zsFIVdLwY
You only need the setTimeout fallback if you care about IE9. The prefixed versions aren't needed anymore and the "ms" one never existed in the first place. http://caniuse.com/requestanimationframe If you don't care about IE9, just use rAF directly. By the way, the setTimeout fallback should use a delay of 16 ms, not 1000.
You're technically correct. But if that was all that mattered we'd still be writing assembler or something even lower level - because "Bad logic is never going to be fixed by abstraction or better tooling".
You can't compare Express to Rails or Django. Those are full blown MVC frameworks, Express is just a routing based framework. It doesn't do anything else. That being said, I have been working on what I nicknamed Rails for Node, or Node on Nails, but really named [Kratos](https://git.io/kratos).
The _.isNaN section seems the other way around to me. Why is isNaN("blabla") returning true a surprise? isNaN tests if the argument is NOT a number. "blabla" doesn't look like a number to me. And trying to coerce "blabla" to a number gives NaN. Number("blabla"); // NaN To me the "surprise" is actually lodash returning false, meaning that it considers "blabla" a number.
http.createServer() has a definite future in Node. For routing I just [patterns](https://www.npmjs.com/package/patterns). 
I'm going to check out koa, but I just have to say oh my god what is going on with that home page. Has the pendulum swing completely the other way as far as usability and responsiveness go? When I open the page on my desktop browser I just see a giant "koa.js" in the middle of a white screen. It took me a minute or so of looking until I saw the tiny hamburger menu in the top right and I realized I could scroll down. There's no indication of either of those two things. Not having a menu expand out on a top bar when on a large browser or giving the user some indication that there's more content as you scroll down are both really lazy design decisions and it bothers the hell out of me. 
&gt; you would think is weird considering strongloop fully depends on express to run. I think they're looking to move onto other projects. In particular, it seems like they're intending to drop Express in favor of Loopback.
First I wanted to say thank you to all of you who helped with this. So far we have decided to research the following options: * Lower our license plan with Telerik which should save us around half of our licensing cost. * VueJs * reactjs + Redux (or possibly reactjs + backbone) * Aurelia We originally thought we would look at Angular 2.0 couples with ASP.Net 5/MVC 6. However 2.0 isn't really production ready. Last night I ran through a few tutorials on VueJs and Aurelia. I also saw that reactjs.net is supposed to make react easier for .net developers so I'll research that as well. I never really felt behind on technology until I started working through these tutorials and realized how nice some of these client side frameworks/libraries are. 
Most type errors I've seen are caused by external factors like an endpoint returning the wrong data type, which typescript won't catch for you.
Hah, found it. http://dinahmoelabs.com/#plink Here, for all the interested :)
I understand now. Thanks!
Microsoft is not the only one providing typing through javascript, there's also facebook's flow. Moreover, they also mentioned ES6, which obviously microsoft doesn't control. They're getting downvoted because they've brought up something pretty much entirely irrelevant to the new release of typescript to get on their soap box and complain uselessly about "bad programmers", as though typescript and ES6 is designed specifically to counter them or something.
Just a nitpick: `Number.isNaN` is very much *not* experimental, it's [part of the ES2015](http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan) (current) spec and [is supported](http://kangax.github.io/compat-table/es6/#test-Number_properties_Number.isNaN) by all latest versions of desktop and mobile browsers, and had been in Node for some time now.
&gt; What kind of endpoints and APIs any and all, what kind of answer do you want here?? Back-end coders frequently don't have a clue what the front-end needs, and many coders are not great communicators. The endpoint can return any inconsistent result if the back-end programmer isn't doing their job well. Static typing isn't going to save you in every situation, and god forbid you work at a company where the back-end programmers can't even tell you how to interact with the endpoint. I think a lot of people commenting on reddit programming subs live in a tiny little bubble they created themselves, and not in the real world where things get messy.
&gt; I have worked with IDEs for half of my professional life. I didn’t know any better, until I started working without an IDE — what a relieve and productivity boost this was. I can't disagree more. I've worked for years without an IDE, then I switched to Webstorm, and I'm so much more productive! It is crazy, that people are trying to fix bugs for hours in their brainless editor, that could be found by some good IDE immediately.
Even Python (in 3.5) embraces optional types, I feel like the time is right for javascript as well.
Sounds cool, but does it actually run for you? I'm getting one of these errors :( `XMLHttpRequest cannot load http://95.85.37.129:4444/socket.io/1/?t=1454084347791. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://dinahmoelabs.com' is therefore not allowed access. The response had HTTP status code 504.`
You probably work on small code bases.
Actually, it was created specifically for the Azure portal, which became too unwieldy to maintain with just JavaScript. This talk briefly mentions it. https://channel9.msdn.com/Events/Build/2014/3-576
I'm no big fan of angular1 or 2, but this seems more of a rant against JS than a rant against Angular 2. If we're talking about coffeescript vs JS, then I'm firmly in the JS/curly-brace camp. Coffeescript has a lot of syntax ambiguities and makes it far easier to write unreadable code. I have a hard enough time getting devs to use good standards. I don't want to use a language that makes this problem even worse. 
You could argue that one shouldn't need to do transformations to get some basic functionality such as being able to add a comment.
Try Meteor. Get the benefits of Node with a more complete stack!
This looks like an ideal boilerplate for my needs. Most boilerplates I've come across are either too comprehensive (like you mentioned), or are simple but lack some key elements from the core stack. I also like that you're planning on adding SASS in the mix, that's something most boilerplates don't include. Now if only I had time to play around with this.. :D Maybe I can squeeze in an evening here and there.
First off all you can still write your ng2 apps in ES5/6. Furthermore no one forces you to use an IDE. What does that have to do with Angular2? What I'm missing here is actual criticism besides: I don't like decorators.
There's a difference between small and monolithic. Huge codebases have been written in lots of untyped languages without issue. The key is knowledgeable devs and architects. Large codebases that are well-architected to break things apart into separate modules with well-defined (and documented) APIS don't tend to suffer from type issues like tightly-coupled codebases do. Lots of type errors when trying to compile indicates a poorly designed system and/or a less skilled developer. JS doesn't suffer from a multitude of types which will break when interchanged. Very few Java bug are caused by passing a string instead of an integer or an object instead of a regex. Most of them are caused by passing an unsigned int rather than a signed int. A second argument is that C or Java-style types are fundamentally bad. They don't exist to protect the programmer. They exist to tell the compiler how to optimize, but do so at a level that is actively bad for the programmer by adding a lot of code noise and cognitive overhead. The Hinley-Milner system was first written about in 1969. We've know it works well since ML was created in the early 70's. It gives far more safety with less boilerplate (and resulting cognitive overhead) while still giving the compiler the safety it needs. Finally, if you unit test, then having type issues is pretty much guaranteed to not happen.
Finally a decent answer. Thanks for sharing.
Yeah. A JSFiddle. No description. Absolute link from your computer. I won't even bother reading the code if you don't at least provide some level of effort.
Thanks much for the reply and links. Crumbles looks very interesting and closest to what I am looking for. I should be more clearer however. I think I misused the term 'generator' here. I do not necessarily want to 'generate' any visuals. I already have video1.mp4,video2.mp4,video3.mp4....videon.mp4 footage uploaded. What I want to generate is, an instance of a video player where I want to play fragments of these clips (video1,video2,....) according to the BPM of music I have detected. The pace at which one video jumps to another or duration of playback should match with tempo of the music. I am not sure if you would be aware of Adobe's Premiere Pro but there is a third party script for it which has a similar feature I am looking for. http://aescripts.com/beatedit-for-premiere-pro/ Here's another (a bit more advanced) example: https://www.magisto.com/ I hope this is more clearer now. 
Ouch, that's a little high and mighty don't you think? I don't think you've done a survey on "most programmers" in order to uncover this. Would love to hear more about the job.
Luckily, we as programmers can put abstraction between ourselves and systems that we deem "messy". It's part of the trade. I have to question your tact of making such widely general assumptions about both the readers of /r/programming as well as the programmer community. What's up with that?
There's a difference between small and monolithic. Huge codebases have been written in **assembly** without issue. The key is knowledgeable devs and architects. Large codebases that are well-architected to break things apart into separate modules with well-defined (and documented) APIS don't tend to suffer from type issues like tightly-coupled codebases do. Lots of type errors when trying to compile indicates a poorly designed system and/or a less skilled developer. **Assembly** doesn't suffer from a multitude of types which will break when interchanged. Very few Java bug are caused by passing string data instead of integer or an object instead of a regex. Most of them are caused by passing an unsigned int rather than a signed int. A second argument is that C or Java-style types are fundamentally bad. They don't exist to protect the programmer. They exist to tell the compiler how to optimize, but do so at a level that is actively bad for the programmer by adding a lot of code noise and cognitive overhead. The Hinley-Milner system was first written about in 1969. We've know it works well since ML was created in the early 70's. It gives far more safety with less boilerplate (and resulting cognitive overhead) while still giving the compiler the safety it needs. Finally, if you unit test, then having type issues is pretty much guaranteed to not happen. **disclaimer:** I'm not comparing JS to Assembly. I'm just saying your points are stupid.
try to find the keyboard shortcut for dev tools and see what error messages print, maybe `ctrl ~` possibly paths to jquery or something got messed up also
Congrats Microsoft, another piece in your world domination puzzle. I am sure some proprietary change in this 'language' of yours will one day break every browser except Internet Explorer. Keep them upvote robots running full speed. 
Sails is all but dead and currently runs on unsupported Express v3. I wouldn't put that in production if I had a gun held to my head. Edit:// not to mention it's supporting legacy node.
DV certs, may as well be self-signed. 
Huge programs are seldom written in assembly (also keep in mind that huge is relative. Windows 95 was only around 50MB). Having done my share of assembly, I guarantee you that a 50MB asm program is basically unheard of. That said, asm suffers from a load of problems that languages like C do not (zero portability, lots of overhead from tracking low-level things like carry flags, etc). Additionally, asm specifically *does* suffer from a multitude of types that will completely break your code if interchanged. Arguing that architecture is of supreme importance is not absurd. Learning and practicing good architecture is hard (thus, it shouldn't be surprising that skilled devs are necessary for this). This importance is the whole reason so many textbooks and articles spend so much time on the subject. My point wasn't even that types are bad or should be avoided. It was only that they aren't particularly necessary in JS and that if typing is used that Hinley-Milner is vastly superior to C-style typing. Reductio ad absurdum doesn't answer any of these points.
I wouldn't assume it to be default, but some kind of setting you pass to the compiler so it wouldn't break existing code. About the --allowJS flag, will you be able to add type annotations for those files or will it be strictly js? 
I mean, point taken, but we _do_ have an obesity crisis....
But, the solution would not be to get rid of braces but to remap a key on your keyboard to allow you to type braces more easily. Plus your IDE should be helping you out by inserting the braces automatically.
Nope. I think using reduce for the summation over the loop was a good change but much of the rest is not helpful. IMO stuff like changing this: const sides = (box) =&gt; [box[0]*box[1], box[1]*box[2], box[2]*box[0]]; into this: const sides = ([a, b, c], acc = []) =&gt; (acc.length == 3) ? acc : sides([b, c, a], acc.concat([a * b])) Makes the code both longer and harder to read. Edit: Formatting
Wonderful arguments pro #vanillajs! 👍
"Have you ever wondered how blind developers are able to write clean code and also operate a computer? The aim of this code talk is to give people an overview about accessibility tools and coding environment (IDE, OS, pc setup) blind developers use to write and debug code." https://www.livecoding.tv/video/how-do-blind-engineers-write-and-debug-code/ (part 1, start from minute 18) https://www.livecoding.tv/video/how-do-blind-engineers-write-and-debug-code-2/ (part 2)
Can you explain?
So HTTPSEverywhere won't be useful in the HTTPocolypse? Now there are more fees for registering a domain (effectively)?
Sure, and you can put type annotations in JavaScript as long as you strip them out before you evaluate it, but then what you have is TypeScript not JavaScript ;) It may seem like nitpicking but it's not. Adding a mandatory preprocessing step means that your input language is no longer standardized and no longer interoperable with the large collection of libraries that support JSON. That's a burden on both developers and any poor user who gets stuck with a not-json .json file.
HTTPSEverywhere is useful if everyone has a DV cert in that it protects you from MitM. That's about it though, there is 0 guarantee about who is on the other end, only that whoever has authority to make DNS changes to that name is answering.
We typically don't take requests here, you need to have demonstrated that you've at least attempted to solve the problem, and then point out where you're struggling. We will gladly help you learn, but we're not just going to do people's work for them. However, I do realize that this is an atypical request, one that some might find... dare I say, fun? I'm not sure about that, but regardless, if you could share what you have so far, it might be helpful. Also, if it doesn't pan out here, you might try /r/perl.
I don't see how this matters. So what if you are exactly who you say you are: a corporation that sells my personal information for profit or with negligible security? Ooo boy, the certificate guarantees that I am at the real [Target](http://krebsonsecurity.com/tag/target-data-breach/), [Home Depot](http://krebsonsecurity.com/tag/home-depot-breach/), or Facebook site. Big, fat, hairy, deal. Until there is some certificate the guarantees that they will keep our information safe, it doesn't make any difference. At least with encryption I know that everyone else at Starbucks can't sniff my passwords.
Right, well, we're in /r/javascript, most people just think the lock means they're secure if they even bother checking for it.
In over 30 years of programming, I've seen *a lot* of shit code.
I agree. I think his objection to "ugly" JS code is more a damnation of the devs he's working with/after than it is of the language itself. JS can look elegant indeed, if the dev cares to write it that way.
I am not sure how I feel about stewardship passing to the node foundation, but I will say that this bit of "drama" has spurred me to get more involved. And hopefully in a similar manner to the io.js/nodejs situation, it will result in more than just a few people (aka, Doug Wilson) helping with support and new feature development.
JSON is "a lightweight data-interchange format" that is officially implemented in no less than 63 programming languages. Despite its JavaScript inspiration/heritage, it is interoperability that makes it valuable, not `JSON.parse`, which wasn't implemented until people had been using JSON for years. From that definition, it follows that functions are out of scope, because they define behavior, not data. Complex data structures are omitted to keep the language interoperable and simple. Comments have none of those problems: they are simple, every language has them, and they (may) deal solely with data. And let's not forget that comments were originally included, then were removed, not for any reason you're saying but because "people were using them as processing directives". Which is just about the most ridiculous reason you could give, because such people obviously were not using standard-compliant parsers and thus were not affected.
You should work on your pronunciation. Seriously, - treeeees - 0:42 probems - 0:48 operashos - 1:42 binary shree - 1:45 prant (I had to listen three times to find out it's to mean parent) this goes on and on and makes it extremely annoying to listen to. Sounds like you just recovered from a hard night drinking or something. It's rather typical for the low quality of Packt to let that go through. Every serious publisher would have told you to hire a professional voice actor to do the speaking or something on that line. You go far too fast through the code samples. Could as well leave them out if you do not even try to really explain them. At about 4:20 you totally lost me. First talking about implementing the balancing function, then babbling something about 'find' already being implemented and then showing code that copies an array into the tree structure. Sorry, but there are tons of free videos (and other material) available online that are far better. If that's all I get for a rather expensive set of videos (assuming the other chapters are of similar quality) I would think Packt is stealing money from me.
I've been using static typing with Javascript for 15 years, you don't have to explain any of this to me. I actually prefer the dynamic typing of Javascript.
You already write them dozens of them in JS (or most other programming languages) anyway, why should the few more in a templates matter? Besides that, I'm on a german keyboard and still don't have issues with them. You get used to pressing AltGr and shift.
This is why I put the "too much detail" as a sub-heading. This approach is obviously overkill, but it is about the journey not the goal :) 
The parentheses are indeed required, but in fact you can't override the reserved words in this way: with ({this: '', null: '', true: '', undefined: ''}) { console.log(typeof this + ' | ' + typeof null + ' | ' + typeof true + ' | ' + typeof undefined); } // object | object | boolean | string Note that `undefined` is not a reserved word, so it actually can be overridden (outside of strict mode); the other ones are allowed (ES5+) as unquoted object properties, but by themselves they are still reserved words. Below, here's an example with a reserved word that wouldn't normally work where a variable name would work: with ({this: '', null: '', true: '', undefined: '', for: ''}) { console.log(typeof this + ' | ' + typeof null + ' | ' + typeof true + ' | ' + typeof undefined + ' | ' + typeof for); } // Uncaught SyntaxError: Unexpected token for
Yes, use process.exit(); https://nodejs.org/dist/latest-v5.x/docs/api/process.html#process_process_exit_code * 0 - means clean exit * 1 - means exit with failure I am not sure of other process codes.
Thanks for the English advice
Michel, I just wanted to say that I had a look at mobservable a couple of days ago and I absolutely LOVE it. I didn't realise when you made your comment that you were the author! I've been swapping out redux + immutablejs in my side project and my code has become so much simpler and easier to read.
[Some info on the ranges of numbers used, and that you can use](http://tldp.org/LDP/abs/html/exitcodes.html) 
FINE IT'S MINE I CLAIM IT, GUYS. Node on Nails^^TM
&gt; This approach is obviously overkill, but it is about the journey not the goal Yeah, but if the goal stinks, then people are going to wonder why they should bother to make the journey. Ultimately you need to show why a functional style solves a problem better than other styles. Surely there are situations where it will. Unfortunately, I think this article achieved the opposite.
Decided to implement it from the start as if i didn't read the article. I got a little bit different [solution](https://babeljs.io/repl/#?experimental=true&amp;evaluate=true&amp;loose=false&amp;spec=false&amp;code=const%20getSides%20%3D%20\(box\)%20%3D%3E%20box.reduce\(\(acc%2C%20d%2C%20i%2C%20arr\)%20%3D%3E%20\(%0A%20%20acc.concat\(%0A%20%20%20%202%20*%20d%20*%20arr%5Bi%20%3F%20\(i%20-%201\)%20%3A%20\(arr.length%20-%201\)%5D%0A%20%20\)%0A\)%2C%20%5B%5D\)%3B%0Aconst%20getSmallestSide%20%3D%20\(sides\)%20%3D%3E%20Math.min\(...sides\)%20%2F%202%3B%0Aconst%20getSquareFeet%20%3D%20\(sides\)%20%3D%3E%20sides.reduce\(\(sum%2C%20side\)%20%3D%3E%20sum%20%2B%20side%2C%200\)%20%2B%20getSmallestSide\(sides\)%3B%0A%0Aconsole.log\(%0A%20%20getSquareFeet\(%0A%20%20%20%20getSides\(%5B2%2C%203%2C%204%5D\)%0A%20%20\)%0A\)%3B). 
static typing does not improve things when the data coming from the back-end is an unexpected type. I'm not sure what kind of crack you're smoking. The static typing in typescript is compile-time, not run-time. Once the code is transpiled, typescript isn't going to help you when the back-end sends you unexpected data types.
Forking a language that's been entrenched for 20 years is a risky business. The truth is, typescript won't really help you write better code if you're not a good programmer. If you're a good javascript programmer you would know that you didn't need typescript, even in the largest of teams or the largest of projects. If you do risky things with types then you'll still get errors from typescript and you'll still be fighting an uphill battle with your code. If you know how to write code with dynamic typing then you won't have to worry about types at all. It's really not that difficult to figure this out.
I ended up doing it two ways: The first finds getUserMedia() at the old traditional places: navigator.[webkit/moz/ms]?getUserMedia, and calling it with the success/failure callbacks. The second uses the newer navigator.mediaDevices.getUserMedia(), which uses Promises (yaay) for success and failure. According to MDN, this is the future home of the API. 
"comment1": "You can add as many as you want", "comment2": "and still not break json" 
&gt; DV cert still sounds like a huge jump in trust than self signed though, no? The problem with self signed, is what happens when the cert changes? Are you being MITM's by someone able to manipulate the DNS results getting to your computer, or did they simply update their cert? 
With the current CA system. There is no reason to not just go with Let's Encrypt, startssl, or whatever is cheap. The people visiting your website, won't know the difference, unless you happen to be a security company. 
Just because you can stick function expressions on a single line doesn't mean you should. Please, please add some newlines and whitespace to your function helpers, it will really help with readability. As it is right now, the original function is far more *readable* than the functional equivalent, due purely to whitespace organization.
Not really. It is completely free. Not free, then charge you a lot, if you ever need to revoke a cert. It is partly sponsored by the EFF. It is a non-profit organization. 
Right. Now comment out a line or a block or add a comment to the end of a line. Just use YAML for configs.
&gt; If you know how to write code with dynamic typing then you won't have to worry about types at all. &gt; Oh man. You're hilarious. &gt; Just a few hours ago you complained that the real world is messy and that things will fall apart if the endpoint isn't consistent with its types And this is caused by programmers who don't have a clue about how to use types. I see it every fucking day. See my other comments about programmers who don't know when to use a Bool or an Integer, or arrays or hashes too. I'm currently fixing code someone wrote who assumed that a length of 0 on an array means no data was loaded, when the data coming from the server could be an empty array. That could never work as intended, but whoever coded it thought it was good enough. derp.
That's idealistic. In the real world a 20-something brogrammer will program endpoints that return various inconsistent results. Good luck getting them to fix it if your company lacks back-end resources. 
This is my solution: var result1 = _(input).map(row =&gt; { var [a,b,c] = row.split('x').sort((a,b) =&gt; a-b); return 2*(a*b + a*c + b*c) + a*b; }).sum(); 
 x = 'foo'; isNaN(x) &amp;&amp; typeof x === 'number' &gt; false x = 0; isNaN(x) &amp;&amp; typeof x === 'number' &gt; false x = NaN; isNaN(x) &amp;&amp; typeof x === 'number' &gt; true Problem solved. Leave it to JavaScript language developers to add a new method to check the specific case where you need to test for NaN and not whether something is a number.
&gt; ... yes some of the methods could be replaced by native methods. This is not the case when things get a bit more complex. Nonsense. Lodash and Underscore are not some magical entities that provide non-native functionality. They both use native APIs to provide new API methods.
You're calling the summary report, not the summary report filtered by the parent record. You effectively have to recreate all the filters of the report and add an additional filter for related patent. It's a limitation of the current exact forms implementation. Just curious, when do you need to have your project done? 
What is the deal with using GitHub as a document store, a wiki?
This is only for the developer version and there are no plans for general public release of the feature.
Sorry, so essentially my problem is that that would be a screenshot, I then have (as the code reads) 13 others that it is supposed to transition the image by changing the opacity. If you were to add any image to the jsfiddle it would transition. However if I do that from my computer it does absolutely nothing. Sorry for the vagueness on that by the way.
Meteor is not ready for prime time, and is years away from offering the sort of full-featured framework functionality that Rails brings to the table. Never mind the really bad decision to tightly couple Meteor to MongoDB. That's a non-starter.
Pretty nice work, and I don't mean to demean it, but the name name leaves something to be desired. Maybe it's just me, but it made me think of pedophile. And then there's your [reddit username...](http://static1.squarespace.com/static/53422302e4b02233d7451d48/t/56610d5be4b06522c744e5aa/1449200991926/)
I'd like to have it finished by Friday of next week. 
And how much good code?
You can gain a lot of efficiency by knowing that it's very likely that the projectile closest to a given tile right now is the same projectile from the previous check (this is called temporal cohesion). Broadphase collision detection could help you out without much memory demand, particularly a grid approach or Sweep And Prune.
The projectile to tile distance is a main component of the game. What do you mean circle to circle check? Can you link me to a visual representation?
This is perfect, Thanks! 
I worked for a bigger CA for a while, can confirm. The verification process was basically checking the state records to see if your business is registered with them. If not we'd check Delaware. There might also be checks to make sure you had access to the actual web server by having you upload a garbage .txt or something. There was more involved with issuing software certs but I didn't get a lot of that in my training. I was going into support, I only spent a few days in verification so I'd be familiar with the process. But like you say, we just want to make sure you are who you say you are. I can't speak for what the company would have done about FaecBook if something like that came up, I wasn't there long enough to hear it come up.
Then I'd recommend putting in a support case with Quickbase if you need help. They've got a good team there. 
You said you only wanted to figure out which one is the closest one: &gt; I need a way to find the closest projectile to a given tile And for that you can keep them squared. A squared distance of 100 (10²) is smaller than a squared distance of 144 (12²). And the same is true for collision checks (as I've shown in that demo). You only need to figure out if the squared distance is smaller than the sum of the radii squared. You don't need the actual distance for that.
Thanks for this! Solving issues with other browsers is a real headache!!!
Good. Chrome should too.
Thanks for the suggestion. I have added an "Other" field for education level.
I actually know some of the dudes that work on sails (they run the Node meet ups in Austin) so I'll ask them about that next time I see them 
Not everyone needs "the green bar". Secure communication should be accessible to all.
I think you're better off finding out what exactly you need to do and start from scratch. This is not a huge amount of logic and I'm doubtful that any direct translations would be anything other than pseudo code. 
It's the default and their best practice. It's not required but it's way harder than it needs to be to change to something like pg. 
" I used CoffeeScript, to get rid of all the distracting curly braces and semicolons of javascript..." I couldn't take the post too seriously after I read this.
https://github.com/strongloop/express/issues/2869#issuecomment-177043509 Doug Wilson is donating all of his express modules under the expressjs organisation, to be a part of the Node.js foundation along with the express core.
It's bound to happen, probably over the next 5 years new browsers will becoming increasingly hostile towards sites that don't have SSL. But simultaneously you'll see many hosts provide SSL with hosting for cheap, preconfigured and ready to go. Hosting without SSL will become like purchasing a new car that has not tires - unheard of.
Is there some reason I see no code at all?
[removed]
Consider React, as you'll be able to more easily make the transition to React Native. 
@hahaNodeJS Are you on GitHub? What projects do you dig/contribute to?
The articles point 1 is fair enough. Point 2 seems to be "look, you can do weird things with JS's type coercion. True, but if your code breaks because `[] + []` didn't evaluate to what you thought it should, you have massive problems to deal with that have nothing to do with the language you're using. Also: &gt; ECMA should remove “==” and force everyone to use “===”. Having both is damn confusing. They do different things and both are useful. And I can't recall ***EVER*** being confused by the difference. It feels like the sort of thing someone would write after they incorrectly used `==` instead of `===`; maybe don't make so many assumptions about a language you clearly don't know yet? Point 3 is absurd; the biggest issue with ASI is the stupid arguments over whether to always include/omit optional semicolons. $5 bucks says the author has never, ever run into a "sublte bug" or "unexpected behaviour" caused by ASI. (Although if he routinely tries to add empty arrays, who knows?) But also, like every other point in this terrible blog post, there's no actual explanation of what exactly he doesn't like, or how he'd change it, but it's hard to see a way of interpreting it that doesn't end up being a proposal to break 90% of all existing JS code. JS may need saving, but I'm not sure OP is the hero it needs... Point 4 I can't evaluate; apparently the author is upset that other people don't try and add arrays. Or something. Point 5 and 6 are...basically factually incorrect? Point 7 is worth quoting in full: &gt; Prototype objects do not scale well to large applications; it’s a rather primitive and sloppy way to do object-oriented programming (but it’s flexible!). Further, there are multiple ways to handle object inheritance, making it difficult to decide which way to go. JavaScript is the only popular OOP language that uses prototype objects. The preference for class-based OOP is clear, such that ES6 and TypeScript employ classes. Nevertheless, their classes are not as completely fleshed out as you would find in Smalltalk and C++, for example. And because the use of prototype objects is so poorly understood by most JavaScript developers, they abuse the language and write horrible code as a result. I don't even know where to start with this; every assertion is wrong. True, JS is not C++. There are probably people out there who think that's a problem with JS, but then I also met a lady who thought the moon landings were faked. Both types are best avoided. If you have an actual specific issue with prototypes...well, you probably don't understand what you're talking about, but sure, spit it out and we can talk about it. But "prototype objects do not scale well to large applications"? It's the programming language equivalent of saying red cars go faster. What were you doing with the objects that caused them not to scale, and what do you even think scale means in this context? Did you construct a deep inheritance hierarchy? You did? Right, don't do that. Point 8 might be a badly stated attempt at stating a valid complaint, but the author lost all credibility with me when he tried and failed to discuss prototypes. As stated, it's basically "promises aren't perfect!". And? I'm not overly fond of python's ternary syntax, but I'm not writing lists about how python sucks because it's not perfect. Point 9 is "I listened to Douglas Crockford and now my brain hurts". Hopefully OP will learn a valuable lesson from this. Point 10...well. "The main draw of JavaScript is actually in frameworks like Node.js and AngularJS." One of these things is not like the other. And then: &gt; JavaScript apologists frequently tout using JSLint as a universal solution to JavaScript’s problems. 1. No they don't. 2. You're thinking of ESLint, not JSLint; JSLint has been a punchline for years. See point 9 about listening to Crockford. &gt; Is it too much to ask for a programming language that doesn’t have such horrendous problems that I need a tool to help me avoid them? No. A good linter is helpful in every language, stop being lazy. This reads like a rant written by someone who read another, better rant, and then tried to parrot it back and didn't do a very good job because they didn't really understand it.
The game source is provided in the tutorial: https://create.goocreate.com/edit/bb3eea5c7dfe4b3b85fbcd9d7e6eddb5.scene Duplicate the scene and start hacking :)
When the certificate owner changes his certificate willingly, he can self-sign the new certificate. I think this is even implemented in the current DNS protocols and automatically checked by the browsers.
I made a statement at the end of the publication to explain the context: &gt; To be clear, this is not production code nor “best practice”. This is about solving a simple exercise with the most (to absurdity) functional idioms: only pure expressions and no duplications. Of course, the readability is worst, but the idea was to show the thought process and the techniques involved.
Nice work. Looking for more advance version of this. Add more things to it like custom page creation, drag &amp; drop. It will be very useful and easy to do.
By experimental, I mean it is marked as such on MDN and is fairly new to browsers (such that not everyone has it yet).
I recommend mithriljs + meteor. 
I have used Bootstrap. My experience says that if you create your webpage layout according to Bootstrap guideline. You will never have to worry about responsiveness. Tip to consider: Start by considering mobile layout first. It will be very helpful.
Experimented with putting Leveldb *in* a webworker. https://github.com/jekrb/example-leveldb-webworker Note: There are bugs in IE, Edge, and Safari (the new IE) that causes this to not work in those browsers. Chrome and Firefox works great.
Wat? XP is unsupported and riddled with security issues. If you have XP browsing the internet, may the Lord have mercy on your browser. 
There was a time where Facebook did care about it as a potential revenue source as well as an opportunity for easy integration with it's own services. Keep in mind, when Facebook purchased Parse, they were not quite the mobile advertising magnate that they are today, and services such as Google cloud, Microsoft azure, and big pieces of the AWS sphere either did not yet exist, or were not yet so robust. I believe that Parse would likely not be getting shut down had Facebook never purchased it, as the option to evolve and iterate at every turn would have been something that would be done without question. When daddy has to pay for you to stay up to par, you better hope daddy still cares.
We've heard
StrongLoop should have just hired him to run the project in the first place.
There is no lawsuit involved..
How is this better than an inline style attribute? 
Looks cool, and good job submitting this, it's never easy to put personal code out for review. One piece of feedback I'd give is to include your `.editorconfig`, `.babelrc`, `.eslintconfig`, etc files when you generate your new site so you don't have to copy them over later. I'd also suggest running a strict linter on your code, it'll catch bugs like: https://github.com/simonknittel/static-site-generator/blob/master/_gulpfile/images.js#L20. You're missing a dot `.` at the beginning of the `pipe` call, so it's returning after that `pipe` call and line 22 is never evaluated. A linter will complain about this kind of thing. If you were on my team and this was a code review, I'd tell you to indent these lines to the left: https://github.com/simonknittel/static-site-generator/blob/master/_gulpfile/copy.js#L15. You want your chained method calls to all be lined up. With them indented over like that it, they look like properties. All in all it looks good so far. Getting things like linting and tests running a lot (maybe a pre-push hook?) will help enforce some self discipline and help you catch the only issues you're really having.
the password manager that take hours to recompile fully and weights 28MB ! yeah !
Hey - I've started a similar project still in a proof of concept phase. [Angular frontend](https://gitlab.com/burke-software/passit-frontend) and [python backend](https://gitlab.com/burke-software/passit-backend). We're looking at releasing desktop clients with electron. A large difference is we want to support secure sharing with a model of a potentially untrusted server - similar to the defunct mitro project. PM me if you think there is room to collaborate - I'd love to chat. [Taiga backlog](https://tree.taiga.io/project/bufke-password/backlog) shows our plans too.
No. Just no
To whom talking about recent browser standardization. Did you ever really worked on a production website with a good load of frontend users? Just because I still get complains about how my modern websites doesn't work on IE8. And a lot of times I just need to create a polyfill/workaround to make it work in old crappy browsers cause not every time you can tell the customers to upgrade. I still use 1.* jQuery for that single simple reason.
Thank you!
&gt; I’ve been given a task at work which involves mouse wheel/trackpad scrolling. I’d have to capture that event, **change it’s speed and velocity** please god stop doing this
I’m not a fan of scroll-jacking either. And the thing I was doing at work has nothing to do with a website that you might use someday. Javascript can be used elsewhere you know :)
Do any of the developers have backgrounds in encryption and security? This is a very, very hard/complex problem to solve properly.
I'm really surprised to not see more about Adonisjs. It follows a lot of the same design patters as laravel and spring with pretty clean syntax. http://adonisjs.com
Documenting react components using runtime type introspection. https://github.com/gcanti/tcomb-react#extract-documentation-from-your-components
Yes, because that built-in marketing crap takes engineering resources to support. Look at any opensource project, it's usually maintained by a single guy or two while a commercial development usually takes five times more people for the project of the same size. That's because they're making software for sell, not for use. Commercial developers do not have that luxury to skip that user-fuck features, ads and spyware, and have to do what big guy said easier to sell. Having that in mind, if you want to get an impression how much resources required for this specific project, you have to find similar opensource project (even poorer in "features") and see how much developers are constantly contributing in it. 
Granted, setting breakpoints and watching variables when hunting bugs is much easier with an IDE. But I would argue, that having to use breakpoints and the like a lot is simply a sign of bad coding style (not meaning to offend you). If you have a solid test suite, you don't have to touch a debugger in years!
I would suggest a different publishing platform. Links from the Packt website are banned on this subreddit on account of them spamming the hell out of us.
&gt; This prints what I want. And it's 3 lines of code less than the non-working code...what are you complaining about?!?! /s Edit: the bug is probably in the functionality of Buffer(HexArrayMAC).toString('ascii'); Since that's the only major difference in code. Or an error in the definition of the string constants, they have funky looking ASCII numbers in them that I'd want to be double-checking. That part of code could well do with a comment to describe the strings.
Can't test it as there's no windows version yet, a couple questions: What features are in this early version? Is there a roadmap? Will cross platform include android? Will syncing use a special server or will it work over something like ownCloud (my current setup is ownCloud sync with KeePass 2 and Keepass2Android)?
You’re right, braces can help. And even the mostly braces-free language of Ruby profits from using braces to make code easier to read in certain places. However, having to use braces all over is more like highlighting 90% of text in a book you read – it doesn’t improve comprehensibility.
Indeed ...but less complicated.
Thanks but ultimately I think I need to control my backend going forward. The migration will pose some challenges, but at least Parse cloud clode is all Javascript anyways so I should be able to reuse pieces of it.
http://perldoc.perl.org/functions/pack.html
The post is not meant to be taken too seriously ;). CoffeeScript is far from a perfect solution – it merely illustrates where JS has problems.
I agree. After showing pedit to a friend, he told to make a reddit post. I made the account just for this. Imagine my level of creativity at that point.
If you want a replacement for Parse, check out Firebase. Plays nicely with Angular
It should be .replace(/-/g) to replace all occurrences rather than just the first. I prefer the split version for readability: const cap = (s) =&gt; s[0].toUpperCase() + s.substring(1); const f = (s) =&gt; s.split(/-/g).map(cap).join(" ");
It's the web. Scrolling down isn't assumed?
Thanks! Right now its all local on the system, we will have cloud support soon. About team/remote features, we'll have to think more about it but its definitely something we'd consider. 
Right now we only support adding groups and entries. Soon we will add cloud support too and you'll be able to import directly from keepass. Owncloud has been partly implemented too :)
If you're wondering why tutorials are pretty old, it's because nothing has really changed in two years. Which is a good thing! Try these: - https://github.com/koajs/workshop - https://github.com/koajs/kick-off-koa After that, I would personally look at code in the official repo then ask questions. 
Those are plans for the near future. The first few features I plan to work on are: * Rich text formatting * Images * adding/removing items from a list And then work on it from there. I'm also hoping to get others interested in helping out with the project.
I'm assuming you're not interested in the [ParseServer](http://blog.parse.com/announcements/introducing-parse-server-and-the-database-migration-tool/) then?
awesome thanks! If nothing's really changed, is there worry that it's unmaintained or obsolete? I know there's always so many other libraries, standards, compilers, etc. popping up and even though this framework may still work great, maybe it's not the most optimal framework it could be? I'll definitely dig some more and look into these though :D
My issue comes when I try to concatenate the String.fromCharCode and the Buffer. 
I think it's ridiculously cool of them to have built this for the community, but if I'm going to host my own app I don't want it to be a black box, I want to know how it works so I can fix it if it breaks. So I'm going to migrate it to Express.
It's basically "complete", save for keeping up with (new) standards.
Thanks! I have an upcoming project that may require training several developers on Marionette. This will help!
Are you saying to develop a React web app first, use something like Bootstrap for the responsiveness, then the transition to native will be easier? Or does React come with a web browser first approach that does not need Bootstrap but it still looks great in the web browser (unlike Ionic - how it targets mobile UI first with browser as an afterthought).
Good to know, thanks :) I'll absolutely follow the project. &gt; though Buttercup's purpose is to beat that combination. Thought so from the syncing and consistency remarks vs competition ;)
It's great to use proven technology, but you need to know enough to implement it. For example - PBKDF2 iterations. This is set to 1,000 in the code for buttercup. PBKDF2 was recommended with 1000 iterations in the year 2000. Since then, the recommendation has gone significantly up - LastPass uses 100,000, and as time goes on it gets way easier. OWSAP's recommendation of 64,000 in 2012 doubling every 2 years puts us at a recommended 256,000 iterations for password security.
A default of 1,000 iterations of PBKDF2 is 16 years out of date. Current recommendations are over 100,000.
Have you heard of Yeoman?
Yeah, I know of that, but what do you want to say me with it?
Did you verify that the browser is actually making the connection?
You could start of by making a mobile web application in react using http://reapp.io for mobile components like fixed headers and pages that slides in from the side. I would have recommended Ionic framework for Angular just a few months ago, but react + reapp seems to run much faster in the browser thanks to the shadow dom technique.
[JavaScript: The Good Parts](http://shop.oreilly.com/product/9780596517748.do) by Douglas Crockford is widely acclaimed -- I learned more from it than any other JavaScript book, and I have read many. [Exploring JS](http://exploringjs.com/) by Axel Rauschmayer is good, too.
Keep in mind react is much more popular overall, so it'll be easier to find react developers than vue developers. A good javascript developer should be able to pick up either in fairly short order, though. But really, I'd recommend learning and becoming familiar with both. Vue is like a much more simple angular, and react offers a lot of good concepts for making maintainable applications.
Angular is a front end framework, it has nothing to do with Parse, which is a backend. Angular or React, you still need a backend. BTW, Angular 1 is mature and stable and adopting best practices from other frameworks. You can use anything from React's ecosystem with Angular either now or soon. Unless you have other serious reasons to change, I wouldn't do it. Parse definitely can't be a real reason, it didn't even have any Angular integration like Firebase or Backand. Your correct question is what to use instead of Parse. Which you partially answer with your Express app. However, you'll still need to find a cloud provider for it. Which is the most important decision I would say.
What does your index.html / index.js file look like?
My index.js: &gt; var express = require('express'); var app = express(); var http = require('http').Server(app); var io = require('socket.io')(http); &gt; app.use(express.static(__dirname + '/www.csgolobby.com')); &gt; app.get('/', function(req, res){ res.sendFile(__dirname + '/index.html'); }); &gt; io.on('connection', function(socket){ console.log('a user connected'); }); &gt; http.listen(3000, function(){ console.log('listening on *:3000'); }); **** Index.html secret ;3 The only thing I will include of the html is: &gt; &lt;script src="socket.io/socket.io.js"&gt;&lt;/script&gt; &lt;script&gt; var socket = io('http://localhost'); &lt;/script&gt;
Apart from books, here are a few hints that you might like: * Always be sure to separate your concerns. For example, keep all the message strings separately, maybe in a particular file or section of your javascript. This way, when you need to modify texts, you won't be messing around with complicated parts of your code. Another example: the functions for handling your data should be separate from your DOM-manipulation stuff. It's easier to call CallMyDatabaseURLToSaveCustomerInfo(x) than doing embedded ajax everywhere and then having to change every single file whenever there's a change in the API. * Try to avoid nested functions. Those are a hell of maintenance. In ajax code, I've found it best to declare a callback separately, i.e. function mycallback(data) { ... } instead of ajaxSomething(url, function(data) { ... } * DON'T REPEAT YOURSELF. Avoid copypaste and use common functions in a separate script or library. Same with common parts of HTML. Try to see if you can use an include-file approach (it's doable and there are functions/libraries for that). 
Could you provide a reference to back up that remark? I'm not doubting you, but having research as to why that amount of iterations would be necessary would be very handy.
I moved &gt; &lt;script&gt; var socket = io(); &lt;/script&gt; from the head to the bottom of the body and it worked! had it like that before but it wouldnt work. thanks for all the help!
Restify for a pure API back-end
If I had something constructive to say, it would be that (not being much of a developer), the idea of a totally self contained (if redundant) package that I can distribute to my friends and family is totally awesome. To nerds running linux, carry on.
What are the differences between this and [SpiderOak Encryptr](https://github.com/SpiderOak/Encryptr)?
Ah ok, thank you. Sorry for the dumb question. :)
as you do not point out eyactly what you dont like about this data format let me give you some ideas why this data format is very good indeed. **Its used for charts.** That means we want to display n dimensional data in different types of visualisations. The data type of each of the dimension is not fixed, nor is the dimension itself. with the chosen data format you can easily and performant iterate over all elements. Its dynamic, extensible and readable. what you can not do with a naive key, value object pair is: * iterate over all elements in a strict order. Even if your js implementation always outputs the elements in the same order, a object is not quaranteed to have any order, see it as a hash table. * use special characters in the label (whitespace, dashes, quotes..) {work-yesterday: '8h'} * use numbers. {1999: 'bad year', 2000: 'good year'} // invalid * use multiple times the same label. You cannot work or eat twice, casue it whould overwrite the previos data {'work': '1pm', 'eat':'2pm', 'work':'3pm'} * not possible to represent multi dimensional data. try to put a xyz point into this represenatation. Not possible you are limited to exactly 1key and 1 value {'home-location', 123, 345, 567} // cannot easily be translated to an object so the purpose of charts require to define multiple values, that might vary in datatype and count. It is not foreseable to predetermine this format or even set it to something fixed.
Just as a side note, this is exactly how you instantiate Maps in Javascript. new Map([ ["someKey", "someValue"], [["keys can be any Javascript object"], 1234] ])
Use [Math.random](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random) to get the random cell + colour. You'll want to use random integers which aren't provided directly from this function but there are examples about how to does this on the page. To get a random cell you could use either [document.querySelectorAll](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll) or [element.querySelectorAll](https://developer.mozilla.org/en/docs/Web/API/Element/querySelectorAll) and then index the returned array-like object with a random integer. function int() { // Code to generate a random integer } var cells = document.querySelectorAll(".grid-cell"); var index = int(); // Generate a random integer which is constrained to the length of cells var randomCell = cells[index]; And then to apply a random colour you need to generate it, possibly doing something akin to var randomColour = `rgb(${int()}, ${int()}, ${int()})`; randomCell.style.backgroundColor = randomColour; Then to make it repeat every 250ms you can use [setInterval](https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval).
http://youmightnotneedjquery.com/
[removed]
This has been available for a while with [node-inspector](https://github.com/node-inspector/node-inspector). Missed this, author is aware. https://github.com/Jam3/devtool#node-inspector Definitely a different experience, I could see some downsides to running in electron rather than hooking up to node's debug functions, but barring weird incompatibilities it could be a nicer debugging experience. I've noticed hiccups while using node-inspector, and there are some quirks.
I'm thinking of going from GCM to CBC+HMAC on [Turtl](https://turtl.it) because of the same reasons. Safari is like the new IE when it comes to supporting newer features.
Yea, pretty much agree with the comments over there. It's a shame that async/await didn't make the cut and that it's "includes" instead of "contains" is really annoying. Well, at least we do now have a prime example for why it's bad to modify any of the built-ins. Don't be like MooTools. Don't ruin it for everyone. The other features I would have liked to see were of course SIMD and, perhaps more surprisingly, [class property declarations](https://github.com/jeffmo/es-class-fields-and-static-properties). The latter is handy if you treat class declarations as immutable bindings (strong mode). Plus, it's kinda needed to mirror the behavior of other languages. Aside: If you want to toy around with SIMD, you can enable it in Chrome by starting it with `--js-flags="--harmony-simd"`.
Yeah as good as this is, it's not new at all
Ah! So in short, I'm an idiot. I was so convinced my js was the issue that I didn't even think about checking my HTML. Thanks for the help! The spaces are to imitate a pause between the two words and I thought it would create a pause after they were over prior to the text moving to the bottom. If you look in the "printLetterByLetter" function you'll see a commented out portion in which I attempted to make this happen.
http://codepen.io/anon/pen/JGZvYr
Transpiling has costs. 
There's a actually one that I use a lot. For example, we want an interface to manipulate the state of things. Let's start with an object which contains a node: var $input = { node : document.querySelector('#myId') }; Then we augment this object with methods to provide a clean interface. for (var k in input.method) { if (input.method.hasOwnProperty(k)) { $input[k] = function (k) { return function () { var x = input.method[k].apply(null, [$input].concat([].slice.call(arguments))); return x ? x : $input; } }(k); // execute immediately } } Okay, so let's say we have a method: input.method.value = function ($input, value) { $input.node.value = value; }; This is just a simple example of this pattern. What's nice is that you can call the method on `$input` like this: $input.value('myValue'); I like it. I use this pattern a ton.
http://read.humanjavascript.com/
I already use JavaScript in places and Typescrpt in others. I prefer to have types and es6 features though. My only question here was debugging node from the the browser with ts
 function changeColor(){ // the total number of squares var numSquares = 16; // gives a number from 0-15 // Math.random gives a decimal number between 0 and 1, inclusive. var square = Math.floor(Math.random() * numSquares); // colors are numbered from 0-255 or 00-ff in hexadecimal // we use the number 256 so that we get 0-255 // Math.floor will give the lower decimal number, where Math.ceil gives the higher decimal. var r = Math.floor(Math.random() * 256); var g = Math.floor(Math.random() * 256); var b = Math.floor(Math.random() * 256); // we create a string to use for the CSS var color = 'rgb('+r+', '+g+', '+b+')'; // we select all elements with the .cell class and set the background to the color string above. document.querySelectorAll(".cell")[square].style.backgroundColor = color; } // now we execute the function above every 250ms. setInterval(changeColor, 250); http://codepen.io/anon/pen/rxKvWj
You'll have to assemble a typescript interpreter. AFAIK, TypeScript only ships a compiler.
https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map
It's still in stage 3. Only proposals that reached stage 4 were included in the finalized draft. Check proposal statuses [here](https://github.com/tc39/ecma262/blob/master/README.md).
They extended built-ins and used "contains". When Firefox started to support String.prototype.contains, websites which used MooTools broke. That's why "contains" was renamed to "includes". Personally, I would have preferred breaking those crappy sites which use that crappy lib.
Seems pretty obvious. It's 4 rows of 2 columns. Exactly like a table. 
I can attest to this. The time spent learning Vue and its ecosystem was a fraction of the time spent learning Angular. React is not so difficult either but I thought Vue was quite easy to learn, with few gotchas along the way.
oh, ok you have your scripts in your html. cool. I'd take out the argument from the io function, since your server is serving up that page, you don't need it. 
The transpiled/compiled JS, yes. I've only ever used TypeScript compiled into JS, so I don't know if the TS itself could be debugged. Edit: Basically, thought you were asking about debugging TypeScript pre-compilation.
You are correct that in general Javascript is inferior for backend programming. Backend systems require mature and stable code, Javascript simply is not a good choice for this. The only thing I use node for is for compiling and building my frontend code. I could see how it could be useful for writing simple asynchronous micro services, but I would not choose it as the backend for a large MVC web app.
Lots of good reasons given all over the web. But I'm still convinced the main one is that front end developers can now do more without learning another language. Now you can rig up something simple without whipping out Java or Ruby or Python. And isomorphic code and all that nice sounding stuff.
* having same language across your whole stack is nice (sharing code and knowledge) * huge community and ecosystem * writing javascript is fun (maybe not for everyone, but for a lot of people it is) * eventloop is easy to grasp model, easy&amp;simple &gt; sophisticated&amp;complex * race for performance from all the big players (google, microsoft, apple, mozilla) why would you not use it beyond client-side? are there any very good reasons to not use js on the server? i know lots of people still say that js is just a "toy-language".
In case you haven't figured it out, $(document).ready fires when every DOM element has loaded **besides images.** It works on JSFiddle because of something that I don't know that I'd assume has to do with jsFiddle executing the javascript in the iframe and all the weirdness with that. And so since the images aren't loading there is nothing for jQuery to attach its event handlers. Anyway, as to a fix read: http://tech-blog.maddyzone.com/javascript/document-ready-vs-window-load-vs-window-onload 
I'm a little surprised that your JS changes when switching out the persistence layer in Angular would be enough to say the whole thing is scrapped. Maybe it is because I'm fairly seasoned with Angular, but I build my front-end prototypes with only fake backends, and then integrate when I'm comfortable with it. My point isn't do things like I do, but that it might not be as bad as you think. In terms of what frameworks, I think Angular 2 will have a lot more overhead than Angular / React because it is new (there are not as many libraries or developers for it). In terms of focusing on product, I would personally bet on Angular because you'll be coming into it with a more opinionated framework rather than just a view library. Also, going from angular to the flux mindset will be a bit of a change. It just doesn't seem worth it, when the end goal is to get a product in front of users.
It has been tried many times before: Netscape with its LiveWire server (released shortly after JS itself, but never gained traction and died out), Microsoft with JScript.NET in ASP.NET (that of which Modern Javascripters™ dare not speak), and Aptana with Jaxer (see LiveWire). I think the main difference is that V8 was a fast enough engine (compared to Fx2-era SpiderMonkey, [which Jaxer was based on](http://ejohn.org/blog/server-side-javascript-with-jaxer/)), and after a couple years when it had been tried and tested in Chrome, the idea to use it to realize the long-held dream of JS on the server came easily. --- **EDIT** From the article I just linked to, and its search-result snippet, I know that ItsNat was also developed for this purpose, and I was reminded of Mozilla Rhino, another JS engine for Java, which like JScript (in ASP or WSH) is meant to load and run directly from the local machine and therefore can run server-side JS; also, although Java bundled Rhino for versions 6 and 7, Java 8 ditched it for Oracle's faster JS engine, Nashorn, which is thus yet another server-side JS engine.
Absolutely - Safari lacks a lot of basic support that other browsers provide. CBC in my opinion is still ample in terms of security, but perhaps we'll use GCM a bit later.
It only made it to Stage 3, and I guess it was harder to implement than first thought; I'm sure it will make it into ES2017 though.
This is a good point. As this is an alpha, we're not encouraging complete migrations to our format just yet. Upping the iterations is easy and will be added as a task for this milestone. Unfortunately it breaks backwards compatibility so I'd prefer to make these changes in bulk :)
You have to look at it from a business perspective. There's a huge advantage to limiting the skill sets required to develop and maintain a product, and JS is not negotiable.
Um, of course they provide non-native functionality. That's what *all* libraries do. It's not magical, it's the whole point of writing libraries. (Arguably with the exception of polyfills.)
What is this instability you speak of?
This is just blind speculation based off your misguided opinion.
One of the main reasons I would never use JavaScript for more than some light front end stuff (REST calls, UI stuff) is the lack of structure in the language. Writing good quality JS code (maintainable code) is very very difficult, mainly due to the lack of static typing and a very poor module system that encourages the whole code base to be exposed to itself. I would never choose to use it for a large web project for the full stack, when other languages are quicker to develop with and easier to maintain.
Whoa.... of all the synonyms they had to go for the one that sounds confusing. I mean, "has" and "encloses" would have been better.
not only huge, but the biggest repository of code ever created.
But couldn't that be done with other language-specific package managers, like pip?
I'm a little confused here. Do you own this website? Do you want to just translate the whole site into German for everybody? Where does selenium come into this? When you say "recognized by the website", what do you mean? 
I don't understand why one would use this. It might save a few keystrokes up front (but a decent editor will guess `font-size`, at `fo` so even that's debatable. As for maintenance and readability, it's an abomination. It's pretty much inline styles. It becomes difficult to make site wide changes, when every paragraph looks like `mt20 fs18 fw400`. It has no meaning for developers, and it's much harder to understand. I want to understand the rationale around this more, but I can't. It would actually take me longer to use this in the prototyping stage than it would to use SASS/LESS. But, I'll try and keep an open mind, enlighten me!
First off, have you tried using Google Translate (or Chrome's built-in translation tools) instead of rolling your own? Second, you might be better off with a snippet of JavaScript that is copied into the console, or something like GreaseMonkey, rather than going through Selenium. It takes a rather paranoid developer to write code which realizes that the page has been tampered with locally, and do something about it - at least when the changes are superficial. But there is a chance that functionality on the page relies on the text shown in elements. I'm not saying that that's common, or good practice, just that it could be the case - especially if the site is a hobby project maintained by one self-taught person, although it seems to be a bit too large for that. ETA: So the most likely outcome is that the page keeps working and no-one is the wiser. It's unlikely, but possible, that the page would break in a significant way. It's very unlikely that the page would be meaningfully aware of the change, but if someone has been paranoid enough to check that, they would almost certainly go far enough to know precisely what has changed. You can detect and work around these checks since they must be done at least partially with client-side JavaScript which is visible to you, but I honestly wouldn't worry.
This is interesting because there's also [decaffeinate](https://github.com/decaffeinate/decaffeinate), which very recently switched to the upstream CoffeeScript parser. And decaffeinate is much more mature in some areas than decaf. (The decaffeinate-parser branch just needs some serious commitment to fix failing tests and it'll be awesome) I contributed to both projects in the last days 😀
This name will stay forever. I doubt they'll add an alias.
I can't seem to reproduce the memory leak example #1 It also seems not logical to me, that previousObj should be leaked, because after the replace() is done, there is no reference left to previous obj? Update: I can reproduce it, but it only works if the thing has another property as a function O.o Update 2: I finally got it :D I think the example could be explained better: var theThing = null; function replaceThing() { var priorThing = theThing; function unused() { if (priorThing) { console.log("hi"); } }; theThing = { longStr: new Array(1000000).join('*'), test: function() { console.log('test'); } }; }; setInterval(replaceThing, 10); Given this piece of code, each theThing has a reference to the previous thing. This is because it contains a function (test) defined in the same scope as the function with reference to previousThing. 
And the NaN stuff: sorry for following the IEEE spec that defines floating point numbers in js, java, c, python, c++, ... That's how NaN is supposed to work.
Start with ES5. First, it is the foundation of ES6 and very little becomes obsolete due to the new version. Second, you’ll need to know it for legacy code.
Sure, but it does not seem curated by any mean and there's a lot of junk in it.
"there's nothing that can can handle this except JavaScript" This is true of every language - there is never a case where only one language will work (OK, maybe a few minor exceptions such as the language a specific program such as Matlab uses). 
yes it matters when you have a lot of small modules. for example you can use underscore on the front- and back-end. also it is about knowledge, there doesnt have to be a dev for backend and a dev for frontend who each know their language well.
I would love to see how you think it can be curated. I think download stats are good enough indication of how good those libs are. It would be out of scope of what NPM is to try to curate it. "sorting through the junk" problem is better solved with blogs, articles and sites like reddit.