So just overall better, nothing particular to FE development.
Do naive people like you still exist?
This is ES6 notation for shorthand function properties
Thanks so much for sharing our work! We're constantly improving and adding new bits to Fabric and its sub-projects since it's what we use in our own products across Office 365. And yes, PLEASE let us know if you have any feedback--we want to make Fabric as great as it can be, both for Microsoft developers and developers building on top of Office 365 (or who just want to make their apps look and feel like Office).
See at the end, it is doing e=setTimeout(o), which in the code is fontName = setTimeout(tryFinish); I guess you are re-using the fontName variable for maximum golfing... but as you never call cancelTimeout... you don't need to assign the return of setTimeout? That saves another couple of bytes? Darn it, read the comments... you'll clearing the fontName value to free up handles to iframe.
In my opinion: No point learning jQuery nowadays; and if you're familiar with vanilla JS it will be extremely easy to pick up anyway. My current preferred setup from editor to code is Sublime Text 3 (performance over Atom is the reason), Node, Webpack, Pug, ES2015/16, Stylus, Vue. I'll let others answer the other stuff.
&gt;better overall functioning of common tools like NPM, gulp, git Can you elaborate on these? I used npm and git extensively on both OSX and Windows and haven't found any differences apart from the `node-gyp` package from npm which has some issues on windows.
Basically this. If Photoshop came to Linux, Apple would be in real trouble.
https://github.com/salsita/jq-clipthru
1) Once you feel like you're "good enough" with css/html/js i'd recommend you to learn [Express](http://expressjs.com/) it's a really popular framework to use on the server-side. Just to make one thing clear: JavaScript was always a OOP language. The difference is that Java's objects, for example, are class-based, while JavaScript's are prototype-based. ES6's classes are just syntactical sugar on top of those prototypes. 2) Basically Angular 1 was a popular (but outdated) framework, and Angular 2 was so different and much more complicated thand Angular 1 that a lot of people moved to React or Vue. But you shouldn't worry about these frameworks for now. 3) VS Code as a text editor, webpack as a module bundler, Babel, Flow as a type checker and MongoDB as a DataBase. 4) Node is extremelly popular. Walmart, Netflix and LinkedIn are using it to name a few. But yeah, it's single threaded. The speed is also slower than C# and Java but it's a really small difference. Anyways even if you need to use other language on the backend, if you're a good JavaScript dev, Java/C# will not be hard to learn.
&gt; zeplin It's not Adobe. I use a number of different tools for web design and I always come back to Photoshop for something. I come back to Illustrator to fix shapes the designer made for a custom icon font. I use Photoshop or Illustrator to edit design a logo for a site. Zeplin seems like a great tool for a portion of the site design/development, but I would still go back to Illustrator and Photoshop when I need them. I spent nine of the last ten years with a Windows machine as my primary work computer. I frequently reached for my personal Mac when I needed to debug an iPad, when I worked on a Bash script for our Linux server, when I wanted to run a couple of command-line tools for testing, etc. Now I'm on a Mac. When I want IE 11, I launch a VM, though I think I'm going to have BrowserStack account, soon. Most of my Windows considerations come in the form of, "I'll see if I can find something like that for Windows for you."
Blogger appears to be the common pattern: https://duckduckgo.com/?q=priority_psa_not_processed&amp;t=ht&amp;ia=web
The speed is not slower than Java and C#, look it up.
v3 ! Also try Jitouch. Best thing I've ever used on a computer.
&gt; What's the best modern way to learn JS today without wasting time with old frameworks or "old ways" who are obsolete today? JavaScript is a very simple and very small language with a lot of quirks. If you are into books, grab [Douglas Crockford's JavaScript: The Good Parts](http://shop.oreilly.com/product/9780596517748.do). If you are into online courses I'm sure there are plenty to choose from. The whole point of frameworks and libraries is to abstract away the language so there's no point learning any of them if your goal is to learn the language. &gt; For example once you're solid in Html5,Css3 and pure javascript what you learn? You will get solid in HTML/CSS/JS after years of actual experience; not days or weeks of tutorials. At that point, "what to learn" will be dictated by your project/business needs, which can't be known right now. &gt; is Jquery still worth learning? Most of what people "needed" jQuery for when it was created, DOM traversal, is a lot easier now so that makes it a lot less useful than it used to be. Also, see my point above about frameworks and libraries. &gt; I ask this because it seem to me that JS is transforming slowly in a OO programming language like C++,C# or Java etc (I mean you can program it like that if you want) and not everyone seem excited with ECMAScript 2016 in the community People have been wanting to use JS as a classical OO language for a long time. Right now, the trend is moving toward functional programming. About ES2016… we will see when browsers actually implement all of that and manage to adhere strictly to the spec. &gt; Why there is a lot of hatred toward Angular2 or typescript and some of the new stuffs is React as all the momentum now over the others big framework like Angular 2 ? Angular, React… are solutions to specific problems that only a handful of companies have. They are pretty much useless for most of the web but those companies are very good at marketing and grabbing mindshares. As for Typescript and all the other compile-to-JS languages, some of them are very nice and come with very good tooling but… do they fix an actual problem you have or are they solutions waiting for problems? &gt; What you use as your development environment ? * Editor: Vim * Package manager: npm, currently trying yarn on a couple of projects * Task runner: npm at work, make at home * Bundler: browserify * Linting: jshint * Testing: tape, currently considering tap * Frameworks: none * Libraries: depends on my needs &gt; How big and popular is Node.js ? Very big and very popular. &gt; Is it possible to have a solid career and try to become a full stack developer with just the open source stack (Html,Css,Js,Node+the rest etc) and not use C#.net or Java as your backend technology? Yes but wait for a few years before anyone could take you seriously. &gt; Some .Net and Java programmers told me Node can't do everything or "as well" as their tech (C#,Java) because it doesn't "scale well" and its "single threaded" and Bad concurrency primitives. Is that true ? Only Node developers will answer "no" to that question. &gt; Is this why some big website switched back in the days like Twitter ? Yes. To be fair, Node and the V8 engine changed quite a bit in the mean time so the concerns of 5 years ago may not hold true anymore.
Express and koa. Express is *de facto* the standard in the industry. Koa is way more modern as it is and it is actually going forward. There is too much drama with express right now to be confident in the future. It's pretty big but for any pure-CRUD API I'ld recommend Loopback, which is very good, even though its documentation sucks balls.
\#preventDefault() cancels the event, so there is no way to resume it later, you'd have to invoke it again. But the easiest way would probably be to just a have a boolean check somewhere like so: var spellingChecked = false; then you could add a listener to the "Check Spelling..." item: app.menuActions.itemByName("Check Spelling...").addEventListener("beforeInvoke", function() { spellingChecked = true; }); and in the `checkSpelling` function you'd just have an if block function checkSpelling(myEvent){ if(!spellingChecked) { // spelling was not checked, cancel event myEvent.preventDefault(); // prevents default action alert('Check Spelling...'); app.menuActions.itemByName("Check Spelling...").invoke(); } // else just continue with the event }
&gt;Runs OSX and can run windows flawlessly while Hackintosh sucks balls hard. Not necessarily. My Hackintosh runs the latest OSX on the metal and it's a laptop. I've even developed native iOS apps on it. At one point I had W7/OSX/Arch Linux running on one SSD. I know this is not the typical case, but not all Hackintosh builds suck.
mac + homebrew + iterm2 ftw!
Let's just say *most* suck ; I know I'm pulling this out of my ass though. In my own experience, every hackintosh I ever done wash le shite.
What i have found after years of client side app development is this: Most of the libs/frameworks goal is simply to have stuff drawn on the screen, now there are many ways to accomplish this. Some mutate the dom and others use virtual dom. There is no reason why you cant modify the dom, and at the same time why you would not want to use a virtual dom. Heres the kicker: state management. This problem is always going to be there. No matter what framework you choose or do not choose. The best/easiest/most robust/sane/maintanable way of handling state is to go the functional way. It may seem an overkill for some, but as your app grows this approach will yield some great results. Having said that, the option of framework is not important, some have a more oop way of doing this, some a more functional. The praise React gets is because of this. The view is simply a function that renders the state as it is. The state is (should be) immutable and easy to reason about. React is also just a view. Nothing more. There is no ajax, router etc. It can be beutifully simple, or as complex as it needs to be. Finally, i have built large multi thousand line apps with older frameworks, like knockoutjs. And i have no problem with mutating the dom, because my state is secured, by beeing immutable. I never use loops or mutate variables, everything is a result of some function based on inputs. Dont learn frameworks! Learn patterns, and best practices, they will outlive any framework out there! Ps. Also never, ever keep your state in the DOM. 
I think it's the combination of a unix environment with a highly polished, well integrated interface on top of it. By controlling everything from the hardware on up, Apple is able to create a highly optimized OS, which means things tend to be faster, more stable, etc. Combine that with a unix environment that doesn't require you to jump through hoops, plus a little marketing shine, and you've got an answer. People tend to under estimate how important that polish and integration is, and it's why Linux, whether it gets `insert favorite tool here` or not, won't ever overcome Apple in terms of market share. Most devs have to solve enough weird problems in their own software; they don't want to worry about solving problems in their OS, or having to tweak things to get it all to behave just so.
Thank you and all who answered, I'll look into Koa!
Windows is most definitely used outside of desktops. Perhaps you should Google "windows server".
Interesting, I'll give it a look!
I've always been worried that a future company will *force* me to use a mac. I wont always be lucky enough to work out of a Linux VM 
It definitely takes some time to smooth things over. For me it was worth the time because I wasn't making enough money to buy a new Mac. I ended up turning my &lt;$500 dollar laptop into a 3k work machine. [I don't know where I'd be without her](https://imgur.com/N1wFt).
jQuery (and its plugins) may still have their uses, but I do wish people would learn plain JS and the DOM API first. I've found that people who lean too heavily on jQuery have a hard time moving on to other kinds of libraries and frameworks, and also don't have a good understanding of how to optimize their app performance.
On top of the many reasons that others have provided, I've found that at the company I work for it's easier to get software and tools installed on OS X. Once you've got the Xcode Command Line Tools, you can pretty much get most things installed via homebrew. Also, you've got git working at that point, too. On our Windows machines there is a laborious approval process for whatever version of the Visual Studio runtime, whatever version of Python, etc. to get some packages to cooperate (node-sass comes to mind as a prime example we've had issues with). We work in a highly regulated environment, so anything that makes any part of the process of getting your dev environment set up slightly simpler is coveted. It also comes with an integrated iPhone and iPad simulator once you install Xcode which is great for quick tests of local code if your company's release policies and procedures make it difficult to test on devices. Pretty much all the available Pro models have a high DPI screen and can support 3 monitors in addition to the laptop LCD without any kind of external docking station, too. Also, this is completely anecdotal to our company, but we can't get any Node version management software on PC approved, but we can install nvm via homebrew. We have to support a few different internal applications, one of which only runs in the old 0.x.x Node so nvm is pretty important. For our team it basically boils down to a bunch of quality of life improvements that make us prefer the MacBook over the HP and Dell PCs that the rest of the company uses. A lot of it at big companies might just be that Macs are newer to the company and they haven't spent as many years locking things down and making it difficult to do your job. Also, the PC laptops at our company are at least 3-4 times as thick and at least twice as heavy. It's another quality of life thing that could be avoided in most situations, but a lot of companies don't make hardware choices with comfort in mind. Honestly, the shift to Front End devs seeming to prefer Macs has been great because it helped us shift our whole team over. EDIT: Fixed some typos and auto-correct mistakes.
You never reboot your machine? I mean I only do it ~ every 3 months, but NEVER?!?!
If Affinity releases Linux versions of their software it will be revolutionary.
It's easier to ignore IE
Thanks for a good laugh
I liked this approach: https://medium.freecodecamp.com/a-study-plan-to-cure-javascript-fatigue-8ad3a54f2eb1#.99hoffawa
I see two major reasons: 1. Unix Shell (bash). This made it easier to get up and running with compilers and tools you need. It also makes it easier to run a local apache server, which will more closely match production. Yes their are windows servers, but they are the minority and tend to cost more. I'm genuinely curious if we'll see some people switch back now that windows has bash powered by Ubuntu. 2. IT departments do the buying. They often look at price/feature comparisons when deciding what to buy. This means if you request a windows laptop you are likely to get a big clunky dell machine. It will have the specs you need, but it will be heavy and ugly. If you request a macbook you will get a sleek good looking macbook. There are only high-end macs, but there are plenty of average to garbage windows machines. Requesting a mac guarantees you get a high-end laptop. 
A lot? The only important one is sketch AFAIK. Adobe works on Windows and Affinity is just releasing betas for Windows.
But can you configure it to say "Yes Master Wayne" in Michael Caine's voice every time you use it?
What kind of masochist wants to develop on windows? 
Nope. Source: have had Win10 complain about node paths.
Miller columns in Finder.
I'm pretty sure he means having to reboot to fix problems or being forced to reboot to install updates.
He's actually 16 years old and had a 2 page assignment due the next day.
Or .Net.
You're referring to Ubuntu desktop correct?
Had to actually make my browser window small so I could read the text, that huge font
I'd never run Apache natively, unless it was a SUPER simple site. Docker or Vagrant to run a VM which could be *much* closer to the production environment.
I haven't seen anyone mention that many macs come with a beautiful retina display. It's just _easier to read_ on a mac than on Windows.
Macs have good battery life, really? Mine gets about 2 hours before I have to plug it in.
It would allow you to do the effect you're after, as long as you would attach the masking element to your mouse cursor.
[Seems like Windows 10 is fixed](https://www.reddit.com/r/technology/comments/4lkoe4/microsoft_removes_260character_path_length_limit/) but it requires a registry setting.
The designers usually do it, and then we optimise them and tidy them using third-party tools. I'd love to get to grips with Photoshop and Sketch, but I've yet to work in a setting in which developers use them directly.
Direct link https://soundcloud.com/blockchannelshow/making-bitcoin-great-with-javascript-brave
So, like, what's his point? That the web is pure as just HTML? That he misses the idea that HTML is a semantic structuring language (Markup)?
Excellent summary. Points for vim, points for npm as a build system. &gt; Only node devs will answer no Lol, yeah.
Because web devs like the worst font-rendering (not visible on Retina) available.
Have they said anything about that at all? I know they are on beta for both products on Windows.
TBH projects nowadays tends to use rather simple layout that can be build with CSS and pack of icons - there is no need to export assets.
I wouldn't say I've never touched PS but as the js needed gets more and more complex I see front end devs splitting themselves into those that really know how to do a pixel perfect design from .psd to the browser and those that can set up babel webpack and can grok angular 2, react etc.
Yeah, seriously. I don't even do design work, and I want one. It's just so damned pretty, and it's got specs to back it up.
I think it's a culture thing, Mac's seem to be used in Western Europe and the USA a lot but in other parts of the world where firms have to start up with smaller sums everyone gets PC's and you use Linux a lot.
Because node and other tools were shit on windows for a number of years. But this has been fixed in Windows 10 with unlimited file path lengths and the bash shell.
Hi /u/dzstormers, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
It's getting better. Windows 10 with bash basically fixes the main issues.
*Exasperating
I've never had to reboot windows 8.1-10 to fix a problem. The updates can be configured for automatic, scheduled, or when you choose.
I agree, Docker or Vagrant is the way to go, but you would be surprised how many programmers don't know about them or choose not to use them.
&gt; exacerbating Oh, sorry I hard-translated from Spanish 'exacerbante', I really thought that was a word &gt;.&lt;
Based on your title, can you define "prefer"? If by "prefer", you mean you hear a lot about it and the people you know use macs for front end, then that's basically a small circle of people where everybody has one. If by "prefer" you mean "use it in dev" or you're talking statistics, then the reality is that it's not a preference. There's plenty of google results out there on the topic. This question comes up a lot in various ways. Of the people that I know that do dev for banks and governmental organizations, and corporate service contractors -- places that have tons of in-house apps and front ends, and large dev teams -- they may hand out iphones, but they have zero macs. And while "prefer" is impossible to quantify ("i'd prefer using a mac but I have to use windows on this Thinkpad"), if "front end devs" truly preferred it, it's concrete usage stats would be higher. Having worked in this kind of environment, if you can get a team together on a topic to say "we need a better editing suite" or "these Dell KB/M's suck" or "we need more screen space", then you can get things done. But then there's 2 guys out of 13 on a web dev team that want macs, where 5 people don't care and the other 6 don't want to have to learn all new tools. 
dude, do you even frontend?
I think my work macbook has more reboots due to updates than my home windows PC. Our IT dept pushes out tons of OSX security updates., maybe those aren't trickling down to end users as much?
I said that wrong. I usually say it this way: "Outside the desktop, Windows is a minor player".
Its not 'bad' but pointless IMHO
I have similar experiences to many of those listed here. I used linux for a long time in college. When I started making more money doing development I upgraded to a Mac since I kept a very similar shell / dev setup, but I could now plug in my projector without having to go hand edit some config files. After college I got a job working at Microsoft and for obvious reasons started developing on Windows. The mindset is just very different. Many of the tools are GUI based instead of CLI based, although Power Shell is allowing for this to change. Although there are still some bad legacy decisions that make interactions clunky (I'm looking at you tab complete!). I've also seen many people suggesting that IT departments don't like Mac's and while that used to be true that is changing. IBM recently announced they're pushing to use more Mac's because it is cheaper long term: http://finance.yahoo.com/news/macs-cost-one-third-much-223047938.html I think the GUI focus on Windows made clunky CLI interactions (cmd, why you so hard to resize!?) less of a focus. With many open source projects, especially those meant to be used by developers or run as servers developing a UI was very low on the list of priorities and so developers tended to favor environments where they could get something running quickly and easily. This means using environments where CLI is a priority. And for the linux vs mac debate... As your time becomes more valuable I've seen many people make the same decision I made, you want the power of Linux without all the extra work and a nice looking UI to boot.
Nothing wrong with that. But its usually easier to do it in the constructor so you don't have to do it manually for each instance you create. If you have a lot of different methods to do this with, helpers like lodash's [_.bindAll](https://lodash.com/docs/#bindAll) can help.
Talk of using .NET for the web brings even more chuckles than Windows does! Thanks for bring that up.
progressively animated. like maybe a 100ms in between each check. The end result is all red. But i want them to change 1 by 1 x=red o=original color ooooo ooxoo oxxxo xxxxx ooooo oooxo ooxxx oxxxx xxxxx The first example, i clicked the middle letter. Second example i clicked the 4th letter. Its so hard to properly explain this lol.
It is definitely a word! But in English it means to make something, like a problem, worse. Whereas exasperating = infuriating. Cheers mate!
Anyone wanting to join for https://github.com/tunnckoCore/ideas/issues/43 - Nodejs Continuous Integration Service - only for and built on Nodejs?
Ah, nice. I was wondering if there was a bind all function. Thanks!
What's the point? Calling those methods will result in the instance being bound to the context already, without the need for bind. 
Why do front-end DEVELOPERS need photoshop? That is the job of designers and what not. Unless you are at a very small shop or a full-stack type guy. FYI, i'm a Linux guy.
You guys don't have something to test all browsers with? BrowserStack is easy enough for that. Kind of irresponsible to not be able to check your code on all browsers before shipping. 
You realize it's one of the most popular web technologies, right? Just because startups don't use it doesn't mean no one uses it.
hmmm, where do you see the library name? Im looking through his code and i dont see any mention of that library
Then I'd have a _machine_ and not a _book_! In all seriousness, I'd love to have a windows machine that was effectively in my macbook without having to parallels or virtualize. My CPU fans would be grateful.
&gt; Aside from the fact you're using googles minification instead of an automated build process... I'm still in the experimental phase here. It's unlikely any of my projects will grow to a scale for an automated build process to make sense. &gt; It is bad practice to pollute the global namespace (root object). In general, I get this. Much like it'd be ridiculous to just make everything a "global" variable in any other language. However, for things that *should* be used globally (such as object definitions, truly global functions such as this "$namespace" one, etc.) how strictly does this "don't pollute global" still apply? 
npm 3+ also installs your deps as a flat tree where possible
Hi /u/riteshkadam12, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Unless you use jsonp, don't. 
Not when you pass methods into callbacks like OP mentioned. Callbacks accept a function reference which is given without context.
I'd still recommend Mint over Ubuntu. I've been using for three years exclusively almost. I installed Ubuntu 16.04 when it came out, and went straight back Mint. 
ahh ok thanks man!
&gt; I'm genuinely curious if we'll see some people switch back now that windows has bash powered by Ubuntu. Unfortunately servers are precisely what's not supported by Ubuntu Bash (at least not yet). I've been developing on Ubuntu, but my main machine runs Windows, so I was excited about Ubuntu Bash. Alas...
I think basically there's generally just a culture of treating devs extremely well. Macs have a reputation for being top tier machines. They're trendy/hip/cool whatever. So devs want them. And enough devs want them that having them as standard is a selling point to potential employees. Personally I think the development environment on the Mac is also extremely nice to work in, so there's that and probably other factors too. But yes I think generally this is a status thing more than anything else. That's the way I see it. 
The usual worry is name collision with other scripts that may be used on the page.
In my experience Macs cause problems in Git when they share the environment with other OSes because Macs don't respect casing. For instance, if a Linux dev checks in a foo.js and a Foo.js, the Mac dev has issues when they go to pull. If you get the non-Mac people to understand the issue and be cognizant of it when naming their files it should help avoid problems.
The #preventDefault() is working like a charm and cancelling the event. I like the idea to use a boolean check, but it doesn't look like indesign has a boolean allocated for spell checking and I don't think I can create one.
my windows computer at work needs to be restarted once or twice a week. i don't remember the last time i had to restart my mbp.
If the code is ever going to be deployed in your own infra it's not the worst thing in the world. But be aware you're adding risk to the project, so ensure the payoff is worth it. Is there a reason you want this namespace functionality over using importing / require syntax?
&gt; Is there a reason you want this namespace functionality over using importing / require syntax? Mostly because I'm completely unfamiliar with that syntax. :) (Like I said somewhere else, I'm fairly new to JS). Correct me if I'm wrong, but is that syntax not part of another 3rd party library?
ex-desktop Linux user here. Macs are awesome if you're a keyboard junkie because every text field has emacs keyboard shortcuts for navigation. Also, on Linux you have more than one popular GUI toolkit and keyboard shortcuts are not consistent across them all. Not even close. Sure you can stick to GTK or QT but that's awfully limiting. macOS lets you define custom keyboard shortcuts for any menu item in any app. I think the UI is far more polished but that's subjective. There is absolutely more polished desktop software available for the Mac than Windows or Linux. macOS is more tuned for desktop use as well, and the UI generally remains responsive when faced with CPU intensive tasks. You can still make the SPOD appear or get the UI to freeze (especially on the 12" MacBook), but it's pretty good overall. Of course if you care more about software freedom than utility, overall experience, polish, etc. than none of this matters. If you just want to get shit done and have a consistent experience across apps nothing rivals macOS to this day.
I did backend work on my mac as well. I remember trying to get an Java-based web-service running in Windows, but the CLASSPATH env var used to start the service was too large for Windows. I had no problems getting it working on a used mac they had laying around. This was at a large company, so you had to use a corporate approved OS and image for your corporate-issued laptop. Linux wasn't an option at the time, but it would've worked fine.
Now that I've looked at this code, it appears to have compiled fine, it just minifies the variable name `root` to `r`, and so on. (Maybe that was just what a *different* minifier gave you.)
Windows 10 has Ubuntu on Windows
No, that minification is my own. I wrote my own javascript minifier that just removes whitespace and renames variables. The google closure service wouldn't minify it.
backed by unix so you can actually do stuff in CLI node-gyp absolutely SUCKS on windows.
Hi /u/jonathanmh, it looks like you're new to /r/javascript, welcome! This post was removed because it really doesn't have anything to do with javascript. Also, thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `jonathanmh.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [jonathanmh.com](/search?q=%28and+site%3A%27jonathanmh.com%27+author%3A%27jonathanmh%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|70|64% [clacks.jonathanmh.com](/search?q=%28and+site%3A%27clacks.jonathanmh.com%27+author%3A%27jonathanmh%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|1|1% [projects.jonathanmh.com](/search?q=%28and+site%3A%27projects.jonathanmh.com%27+author%3A%27jonathanmh%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|1|1%
Don't re-invent the wheel unless you have to. With *any* programming language (or *any* programming library or framework) you can always write your own version of what other people have already written. And it will probably seem like a good idea at the time: your version will be simpler, do everything you need, and you'll understand it completely. Why bother learning someone else's way of doing things? Why? Because maintenance is a bitch. Let's fast forward 6 months or a year: now you need some new functionality. Or maybe you want to use some new tool. Or maybe a user does something you didn't expect and you get a non-trivial bug. *You* have to go fix/augment the code. It's been months since you wrote it and now it doesn't make as much sense as it used to, plus you architect-ed the whole thing based on the assumptions you made at the time, and now that those assumptions are no longer true you need to do a ton of refactoring just to be able to start adding the new feature/bug fix. ... and then in six months it will happen again. Unless you go to a new job, at which point all that code you wrote will be gone, and you'll either have to re-write it for your new place OR ... just learn the standard. Experienced programmers learn that writing code is the easy part: maintaining it is the hard part. If you use a JS module system (any of AMD, CommonJS, or ES6, although personally I'd recommend Babel+ES6) 3rd party tools will work with it, your co-workers will already understand, you'll have transferable skills you can take elsewhere, and most importantly someone else gets to maintain the underlying import system for you.
https://jsfiddle.net/sch1m0wj/3/ Using Rx.js simply because I'm curious about that library. You could wire up a group of setTimeouts based of the number of .letter classes. [using randomColor instead of changeColor](https://jsfiddle.net/sch1m0wj/4/) I only implemented the first changeColor event. But the same sort of logic can be applied to mouseout instead.
Agreed on the good parts. IMO, Kyle Simpson's YDKJS has supplanted it. Heavy focus on how JS works, why it works that way, and why it's (usually) a good thing.
we found your sacrifice. *^devilishly ^grins*
Lie. Lie. Lie. Lie. My mac crashes every couple of weeks and requires a force reboot. This is a mac fan boy myth.
This is also untrue. updates have required reboots as well as installs for some applications.
JS:TGP is certainly very opinionated but it's also the most concise and to the point introduction to JS I've read on dead trees. Though the fact that I read it after ~10 years of practice may alter my judgement a bit. But yeah, you raised a good point. &gt; (not even the one I wrote) Link?
Angular 2 and React both require extensive tool chains and configuration to be most effective. Your application has to be built around them instead of the other way around. They both have their own ecosystems that aren't always compatible with the rest of the JS world. This makes things very frustrating for devs who feel they have no choice but to learn these systems, because it seems like all the jobs out there are requiring those skills. Especially when those devs go looking for solutions to problems in their legacy codebases and get told to "just use react", as if it were so easy.
Thanks so much!! I'm not a java guy, you saved me a lot of time!
You can handle namespaces and variables better in any other *real* language I've seen. But yeah, that compiler is a jerk.
Some companies have no idea what a front end developer is. 
I agree with all of the above. This is the same in any language, and is not unique to Javascript. However, there is the occasion that a Global makes sense to use. My question was whether there was some core reason with Javascript that I was unaware of that makes it different from other languages in this regard.
Koa + es7 / typescript decorators = literally flask
It's a half truth. I have had macs that crashed regularly, but they were work machines that were loaded up with IT required software like superfluous virus scanners.
Not to divert the question/conversation, but I think I'd qualify as an "experienced programmer". 20+ years doing it professionally in most language out there (Java, VB.NET, C#, Delphi, etc.) Please don't think that being new to JS means "new to programming". This said, one COULD debate the merits of using a 3rd party tool vs. "reinventing the wheel". On my current contract, they tied themselves tightly to Silverlight. Guess where that's going? On my previous contract, it was Angular.js version 1. Yet another previous contract, there were some (paid for) 3rd party 3D graphic/audio/input libraries that were adopted, then abandoned by the developers after a year (requiring a full rewrite of the entire tool - this time opting to do it with a lower level graphics library (DirectX)). And on even another previous contract, two separate 3rd party libraries that were tightly coupled ceased to be compatible with each other (a decision made by one of the library developers) requiring significant rework and the selection of a new library. 3rd party libraries require your developers to get boned up on the ins/outs/quirks of that library, and at any point it can be yanked out from under you. If you're working on a code base that has to stand the test of time (15+ years), needs a great deal of customization, or has to run highly optimized, 3rd party tools may, in fact, not be the answer. Experienced programmers learn that you have to use the correct tool for the job, and that not every problem is a nail looking for a hammer. Also, one of my favorite quotes from a developer blog I read years ago: "If we never reinvented the wheel we'd still be rolling around on round rocks." 
Aha! This could've been where the problem was. I did change the syntax since the error, and the syntax was somewhere in that neighborhood. Thanks!
&gt; Affinity Tell me more ? Can this be used as replacement. I'm still looking for my hope to drop windows. Adobe products are the last string holding windows at work. 
I actually haven't tried it yet as I have been ok with regular Command Prompt for now.
When the method gets called without context, you've already lost the expected value of `this` inside that prototype method. Assigning `self=this` then is assigning it the wrong value of this. Using a closure variable like `self` is _a_ solution, its not the only solution. Using `bind()` is a different approach of effectively doing the same thing. For OP's particular example, this would work by using `instance` instead of `this`. That would be equivalent to a `self`, especially since only one instance of `ModalViewModel` is ever created. A `self` in the method works when the method is already called with the correct context, but that method creates another function (closure) within it that may be called with a different context but still needs to retain access to the current context. This is also something arrow functions address when targeting ES6+.
&gt;why with Javascript specifically, developers seem to think the rule is "never." A good chunk of it is historical. Back in the 00's people didn't just throw a variable or two in to the global namespace, they threw *a lot* of variables in to it. Then, 3rd-party libraries did the same thing, and threw lots of stuff in the global namespace. Even worse, some libraries (I'm looking at you Prototype) took it a step further and modified native global objects. It all seemed like such a good idea until ... &gt;variable name collisions (which would be as rare as how often you'd drop something global) wound up not being all that rare. And they were, potentially at least, extremely painful to deal with when they occurred. As a result, almost anyone who did web development back then got burned by the pain of mis-used globals, and our community collectively now has a reflex reaction to hate on globals. Globals aren't inherently evil, and in fact you have to use some if you're not using any sort of module system. But they can cause a lot of pain, which is why most devs both use modules and avoid globals. 
&gt; macOS is more tuned for desktop use as well Yeah I dont like that they shoehorned a touchscreen UI into Windows, because it's comically bad. Windows 7 was a pleasure to use compared to 8+. Thank god Apple hasn't lazily slapped a touchscreen on a macbook and MacOS is still keyboard/mouse only.
&gt; took it a step further and modified native global objects. **shudder** Thank you for the history! This makes sense, and sounds a lot like the growing pains of most languages. In all other languages, we avoid this with robust namespacing (and obviously, not using globals unless absolutely necessary). I found that namespacing is less than simple in Javascript, thus the little function I made. For my own personal development, I'd prefer to use something that "mimics" the standards used in other "mature" languages. (I also have a script loading function that mimics the "includes" of C++, but I'm afraid if I shared that some folks would have an aneurysm.) I do understand the push-back that many here (in this subreddit) have against making javascript "act" like other languages (it would be no different from the pushback one would receive from trying to make C# "act" like javascript), but I do feel that adopting a few of the standards used elsewhere would go far in helping with the Javascript learning curve. Thank you for the insight!
But it says 15 seconds, not 3... Nvm.
I've had much the same experience - specifically I quite enjoy the KDE flavour of Mint. It feels like it has the solidity of debian, but the 'up-to-dateness' of Ubuntu.
So, if C++-style namespacing is really important to you, by all means implement your own module system! But just understand that, as with anything in programming, there is a price to building your own tool instead of using one someone else built: * no one else will know how to use your system (but every good JS hire *will* know the CommonJS and probably ES7 system also) * you don't get any of the extra features/stability that scores of other programmers have added to the major systems * you have to maintain it, fix all bugs in it, etc. &gt;I found that namespacing is less than simple in Javascript Because you're not using a module system :) It's sort of like complaining about the C++ tooling in the 90's because you're using an 80's version of the C compiler. If you want to build a C++ system because it's better, go for it, but I truly believe you'd be better served at least learning how everyone else in the JS world does it first (and that means learning a module system).
I didn't pay for it myself and when price isn't an issue plus we're talking laptops Macs are pretty darn good
Wow, I'm surprised to hear that. Douglas Crockford was core to my evolution in JS development.
This is precisely why I was creating this simple little "namespace" script. Basically, other than the "$namespace" function itself, what gets dropped on the "global" is just the root of your namespace. So if you're following namespace standards, that would usually be "com" (or "net" or "org" etc.) since my namespace for example would be: com.peculiarhabit.my.namespaced.stuff Thus "com" would be the only thing sitting on the global. All definitions for my classes (such as in the example, the "MyClass" class) look like this: com.peculiarhabit.controls.MyClass(); So while the class definition is *accessible* globally (and will purposely not be garbage collected) the only "dirtying" of the global space is the root "com" namespace. 
&gt; Because unless im reading wrong the only way you could make such a statement is if you do not understand prototypal inheritence. It's completely possible there's something I'm missing. Could you please explain it to me?
Because most of the time I just get handed the design in PSD files. 
Heh, sorry your original post came across very "I'm new" sounding, and it can be hard to distinguish "new to programming" from "new to Javascript". And yes, absolutely programmers can't always use 3rd-party tools, and yes there are absolutely great reasons to write your own version of X. The question isn't "is it wrong to write your own X?", it's "for X, would I be better served leveraging the efforts of others, or starting from scratch myself?" Obviously a lot of factors go in to that equation, but I think one important (cross-language) one should be "the closer X is to the core of the language, the less likely you should be to want to re-invent it". So I'm not saying that a fourth, C++-inspired module system is a bad idea, I'm just saying there's a pretty good chance you can get 80-100% of what you're looking for by using code that is already there waiting for you, is fully documented, tested, etc. and which any new co-workers you have will already be familiar with. In other words, using any of three existing (I'd recommend ES7) module systems.
the ESC key appears in the touch bar when contextually necessary.
There was only one reason I switched to Macs over Windows (I toyed with Ubuntu but the lack of Adobe software was a dealbreaker) was the lack of a case-sensitive filesystem in Windows. I do backend and fronted work in equal amounts, and when deploying to a linux production server, I've lost more hours than I care to admit hunting down that one file that was being requested in different case from what it actually was on disk. I have tried running Linux VMs on top of windows, but since the project dir is on a NTFS drive (mounted over sambe in the Linux filesystem) the file operations get handled by NTFS and are case-insensitive. After switching, I discovered the joys of the command line, and frankly how OSX has mostly sane defaults. I'd spend a good day tweaking Windows XP and 7 to suit my needs, it seems I don't have to worry nearly as much on OSX. The only thing I actually miss from Windows is the Windows Explorer's tree panel. Why the designers at apple thought it was not necessary, and poured work instead on that senseless cover flow, is beyond me. Also, Hackintoshes are great, if you can get them running.
Our development environment is React, Redux, Webpack, D3, Immutable. We iterated over a number of alternative components before settling on each piece. Briefly, here's why we settled with each piece React &amp; Redux: We played with Knockout, etc. before realizing that our application logic naturally demanded a bunch of pub-subs. React's vdom diffing made it far more performant than Knockout etc. We first used Reflux to handle state but ended up hating it since it lacked any form of best practice and left the developer in the dark about best practices. We then migrated to Redux and have loved it ever since. It's got a somewhat large learning curve but best practice is pretty obvious once you're past the hump. The ecosystem is also very well developed with lots of developer discussion about 3rd party modules, etc. D3: Truth be told, we mostly use it for calculating shapes &amp; forces and let React take care of DOM manipulation. D3 is kinda the only man in town with respect to visualizations, so this wasn't a massive debate for us. Webpack: We chose webpack after using Gulp-- the workflow is much nicer, even though the configuration can be daunting. We typically only review our build process every once in a while. In the intervening time, webpack is usually pretty happy to handle most situations without problems. Also, the community is great. Immutable: Okay, we're not an *immutable all the things* shop. We like immutable since it provides a consistent API for all it's collections. I don't need to remember the API differences between a Map &amp; a Set. 
Completely fair. :) On that note, the reason we're boning up on Javascript *is* specifically because Silverlight is no longer an option. We all have backgrounds with much more "traditionally" structured languages, so the prototype design of JS is throwing us for a loop, and I've yet to find a tutorial that doesn't muddy the waters further. Any good recommendations on where to "start" when coming from a strong background in other languages? 
I've replaced Photoshop/Illustrator with Affinity Photo and Affinity Designer. I don't have any regrets, it takes me some time to figure out how to do things on occasion, but I think that's more from switching off a decade of Adobe usage than Affinity lacking anything. Affinity has a nice competent svg export system for web now too as of 1.5.*. Now blacks actually export without a fill value, so you can target them with CSS. That was one thing that was really standing in my way of moving off Adobe completely, and now I feel very comfortable saying Affinity is my go-to toolset for graphics.
On my phone now so this will be terse, but the imported file looks like: export var Bar = 1 export var Baz = [2, 3] export default 'foo123' // imported as Foo in importing file
yeah and php is fast. Again that's not enough (and React is already fast so FASTER doesn't mean anything to me). Talk to me in METRICS that actually matter (is it twice as fast? Is it faster than an optimized react application?) Licensed better? What does that even mean... tons of companies are using React in their software and they're not paying Facebook. As far as syntax, I'm pretty sure I saw for loops and a lot of people complained about the syntax so far. Again, sure you make your arguments by my point stands... make them quick, make them effectively, don't make people hunt them down, give the other side of the coin WITH the supposed positive benefits so that people don't have to go hunt this down... this is what I'm looking for when people are pushing new technology, new software (same thing redux did when it pushed itself over flux).
I'll try to keep it to yes/no questions then. :D Are these exports essentially... Like "static" properties/functions? 
This has never let me down ModalViewModel.prototype.show = function() { var self=this; setTimeout(function(){ self.isVisible = true; },200); // other stuff }; In general you should refactor anyways so that this isn't a concern. ModalViewModel.prototype.delayedshow = function(which) { setTimeout(function(){ which.isVisible = true; },200); // other stuff }; ModalViewModel.prototype.show = function() { this.delayedshow(); // other stuff }; In my experience 'this' confusion only happens when you aren't writing 'clean code'. I always offload my this's and have never had this problem. Generally my opinion is you should fix coding problems where they happen. There might be an instance that you want to override the this... or use bind as the first argument in the settimeout
&gt; At the same time the OSX advantage will evaporate in the near future Windows offers Ubuntu tools, powershell, and .Net from the command line and combinations thereof. Ubuntu tools on windows are vastly overrated. It basically feels like cygwin but with apt package management, still not truly integrated in any form. I may as well be working over SSH on a remote server or a vm for all the real convenience it provides. Also, until Windows drops the case-insensitive file-system there will always be issues.
&gt; Bundler: browserify Why not webpack though? It has a lot more feature than browserify and the learning process isn't that complicated (no, the config is simple - you can be up and running with like a 10 lines of webpack.config.js).
I'm not familiar enough with `static` in a C++ context, but you can export a class with static functions ... // Foo.js export var doSomething = function() { return 'something';} export default class Something { static do() { return 'something';} } // Bar.js import Something, {doSomething} from 'Foo.js'; doSomething(); // 'something' Something.do(); // 'something' However, you can't import the static properties of a default exported class, ie. you can't do: import {do} from 'Foo.js'; If you Google "es7 modules" you should find a lot of good resources on them (they're new so people have written a lot). However, I should note that to use ES7 modules you'll need to use Babel (since browsers don't *yet* support them). Babel is essentially the same as gcc (although technically it's a "transpiler" not a "compiler"): you give it JS with "import whatever" and it will convert it it in to JS your browser can understand.
Welcome to linux, where everything can use a desktop environment (or not!) like XFCE. The difference is just a GUI. If you've got a computer that runs well, I would recommend experimenting using a virtual machine instead of on hardware at first. Much easier to rollback your mistakes / start over should stuff go wrong.
Sorry for the late reply but thanks for your help. I'm going to read over YDNJS to help myself more
&gt; Angular, React… are solutions to specific problems that only a handful of companies have. No. They are solutions to building web applications that have a non-trivial amount of code (say LoC in the thousands). They are not needed for your typical web pages. &gt;do they fix an actual problem you have or are they solutions waiting for problems? They fix the issue of organizing and maintaining large JavaScript codebases over a significant span of time (years).
It works! Thank you so much for your help!! I had to made one other small adjustment because the boolean would have remained set to true if a user were to open a new document without completely restarting indesign. I added app.addEventListener("beforeClose", function() {spellingChecked = false;}); to the main function so that when a user closes the document, the boolean sets back to false. 
1. I care about my user's time. Each ms matters. [Ref 1](https://www.facebook.com/notes/facebook-engineering/every-millisecond-counts/122869103919/), [Ref 2](http://www.gerrymcgovern.com/new-thinking/google-marketing-every-millisecond-counts), [Ref 3](http://www.carbon60.com/blog/milliseconds-are-money-how-much-performance-matters-in-the-cloud) and everyone is aware of Amazon and how an increase of 100ms decreases their sales by 1%. 2. The React license has an addendum. This is a highly and hotly debated issue. Vue has a pure GIT license, so there's no controversy. Many companies legal departments are telling them to move away from React. Some people are willing to take the risk, and other aren't. Personally, I don't see this being an issue for me, but if I can avoid unnecessary risk, why wouldn't I? [Ref 1](http://react-etc.net/entry/your-license-to-use-react-js-can-be-revoked-if-you-compete-with-facebook), [Ref 2](https://discuss.reactjs.org/t/legal-department-did-not-allow-use-of-react/3309), [Ref 3](https://github.com/facebook/react/issues/7293) 3. Sure people are going to complain about syntax.. everyone prefers something different. I can complain, along with an army of other people, about React's syntax all I want but that doesn't make it bad. 4. If you want to keep using React, there's nothing wrong with that. The React team actually helped write the [official Vue comparison documentation here](http://vuejs.org/v2/guide/comparison.html#React). &gt; The React community has been instrumental in helping us achieve this balance, with special thanks to Dan Abramov from the React team. He was extremely generous with his time and considerable expertise to help us refine this document until **we were both happy with the final result**. The comparison to React in the documentation is about as clear as be. Not sure what more you could want. 
Of course it does.
The PC operating system has nothing to do with what runs the internet and, as I said, Windows does not run the internet and, therefore, is a minor player.
So the un-sugared version of this is: fetch(url).then(response =&gt; { console.log(response.headers); // Headers are available here, but not the actual content yet response.json().then(json =&gt; { console.log(json); }) }) As you can see from the comments, the headers come in first, which might be useful in some situation. Then you have to wait some time more until the entire body arrives. You can write a wrapper around fetch that ignores the headers and resolves when the json has arrived, but if this was fetch's default behaviour, then you couldn't do the reverse. I agree that it's a bit silly that you have to do this because I have never needed only the headers, so this creates some unnecessary boilerplate. I wish they had some secondary API that allows you to just fetch some json. 
Since protypal inheritance is hard to wrap your head around, and since I've seen it explained poorly very often, here's my quick attempt. 1) Every object in Javascript has a secret property called `__proto__`. I say "secret" because you can only see it in the debugger; you can't reference it in code. Whenever you try to access a property/method on an object, and it doesn't have that property/method, the brrowser tries to use find it on the `__proto__`. If it can't, it tries the `__proto__.__proto__`, and then `__proto__.__proto__.__proto__` and so on: var foo = {}; foo.__proto__.bar = 1; // you can't actually do this foo.bar; // 1 2) Every function in Javascript has a `prototype` property This one isn't secret: function Foo() {} Foo.prototype = {bar: 1}; 3) Where does the secret `__proto__` come from? When you create an object from a function using `new`, the `prototype` of the function becomes the `__proto__` of the new object: function Foo() {} Foo.prototype = {bar: 1}; var foo = new Foo(); foo.bar; // 1 (it's using foo._proto__.bar) 4) By exploiting this you can achieve classical OOP-like inheritance, even though it works differently "under the hood": var SuperClass = function() {}; SuperClass.prototype = {bar: 1, baz: 2}; var SubClass = function() {}; SubClass.prototype = new SuperClass(); // SubClass "extends" SuperClass SubClass.prototype.baz = 3; new SuperClass().bar; // 1 new SubClass().bar; // 1 new SuperClass().baz // 2 new SubClass().baz // 3 Hope that helps you understand prototypal inheritance better :)
I have Photoshop open nearly all day. The designers give me the photoshop file and I export the jpg and psd files that I need from it. I find it easier than telling them the exact sizes I need.
Because it returns a promise object. 
You're adding promises for no reason at all. Are you doing anything asynchronously? No. You're just reading keys from an object. You're storing state on what comes down to the global object. I see a lot of problems with this. It's impossible to have 2 instances of your state next to one another. It's always best to make modules in a way that they can be instantiated multiple times. Just initiate the state once and put it on react's context. Edit: I suggest you read the redux docs. It'll explain some great concepts.
same here.
It's not implemented in any (major) browser yet. While the standard was approved by the W3C, the implementation of it is something the browsers have to work out, and they're still working on it. Thankfully Babel exists though, allowing web developers everywhere to use the ES7 module system today as long as they "transpile" their code through Babel first.
But `JSON.parse` is synchronous.
Unless you're used to windows, and everything windows has to offer. I had to use a Mac for work recently and it was like pulling teeth to do the things I wanted. 
Avoiding using globals can be useful if you want to protect your code/data against a malicious third-party script. It won't give you any guarantee though. For example a malicious script could still modify the prototype of `window.XMLHttpRequest`.
You can still one-line it as `let response = await fetch(MY_URL).then(res =&gt; res.json())` The reason is because the headers arrive first, and the Response body comes in as a stream, so you have to wait for the stream to complete before you can access the body.
Awesome, exactly the explanation I was looking for. TIL. Interesting that other languages (e.g. Python) don't support the same "two-step" response loading afaik (probably because you need slick concurrency primitives to do it). Thanks!
I'd second this. If you're just getting in to the bundling game now don't pick Browserify: it's yesterday's news. I'd recommend a bundler from the "modern" generation, ie. either JSPM or Webpack (and having far more experience with Webpack I'd recommend it over JSPM, though both are viable).
Please do me a favor change it to bcrypt by default
as someone that's used Windows, OSX, and Linux (ubuntu). windows was awful to do design work on if you needed to use more than one program at a time, like indesign and illustrator or photoshop. it would be slow and freeze up on me, and this was with a computer (desktop) i built and spec'd out for design work to be more powerful than my mac i had at work at the time. not to mention how annoyingly slow the registry makes booting up and running programs, i haven't used win10 but it was still an issue on my wife's win8 machine (laptop), it was mine before she got inherited it after i got my macbook pro. also when i was trying to learn sass, i ran into the issue that Ruby isn't really supported for windows. so it never really worked, so i tried linux and it worked for the CLI tools i needed to learn, but Gimp and Inkscape are jokes compared to Adobe's software. and there is no color standards between the distros, so you can't have color that are consistent from one machine to the next. which for front end stuff isn't that big of a deal since they are all "close enough" for web, but I deal with print design and photography so i need something better than "close enough." OSX just works better. i don't have to shoehorn anything into it. all adobe programs work well, without constantly running into crashes. there's no registry so slow down the computer. the "Adobe RGB (1998)" color profile is reliable and is embedded in cameras and monitor and printers, making the gamuts consistent as possible between machines. the fact that it's "unix like" means that most CLI tools can be ported over to OSX if they aren't usable directly. 
That's why it's necessary for Mac developers to create a case sensitive partition to put your source code. Don't make the / partition case sensitive because it breaks many applications. If you don't do that already, sooner or later you'll learn it the hard way.
Great! I'm glad I could help :) 
Front end developer is a pretty broad set of skills and every job / market has varying involvement between those skills. I've done front end for advertising and marketing clients where I have PS open all day every day and every task is a new complex design. I've also worked on front end for applications where tasks are functionality focused with a simplistic and modular theme already set up where I don't even edit a stylesheet for months.
You can also one-line it as: const json = await (await fetch(MY_URL)).json(); I might like yours better though.
&gt; No. They are solutions to building web applications that have a non-trivial amount of code (say LoC in the thousands). Thousands of lines of code is unfortunately pretty trivial in this day and age, even for typical web pages. What I'm getting at is that Angular, React and friends, while being perfectly legitimate solutions for perfectly legitimate problems are not worth the hassle for most of what makes the web. &gt; They fix the issue of organizing and maintaining large JavaScript codebases over a significant span of time (years). … and thus make sense if that's a problem you face. If you don't have the problem, the solution is useless. Angular, React, $BUZZWORD and Co. are great for your Resumé, though. And biffing-up one's resumé *is* a legitimate problem in needs of a solution ;-)
Or the slightly shorter let response = await fetch(MY_URL).then(res.json)
I like yours better. I don't like mixing the promise/.then() syntax with async/await personally.
It does. 
The basic reason is that the Response object you get from the 'then' block or awaited response of the 'fetch' call is represented by headers AND a stream object. The simple answer is that you cannot parse a Stream synchronously (or you really shouldn't! it could take a while to be readable and hang your app). If you're legitimately handling errors, you want to throw as soon as you know the response is non-200. Then you have to wait for the response to finish and you can deal with its content. The underlying format of the objects is the short answer. I wrote this to illustrate a bit. const path = '/path/to/resource'; const data = await fetch(path).then(response =&gt; // as soon as we have headers, but before the body needs to be complete we can check for 2xx/3xx/4xx/5xx response.ok ? response.json() : // in the simple case, we're able to just return the json we expected handleErrorResponse(path, response.status, response) ).catch(fatalError =&gt; // happens with no network or dns failure handleRequestError(fatalError) ); const handleErrorResponse = (path, status, response) =&gt; { console.error(`Request to ${path} failed to load with ${status} status`); if (status &gt;= 400 &amp;&amp; status &lt; 500) { // handle that error here const clone = await response.clone(); // try to parse the error as json, then text if it fails // we clone because we can only read a stream once! const error = await response.json().catch(fail =&gt; clone.text()); console.debug(error); // now that we have error content, maybe you want to log it throw error; // maybe you want to wrap this as an innerError but you get the idea } // etc for other error classes like 400 or 500, maybe you even want to re-issue the request } code presented with no sanity check :) might be an error in there
Dude, you need to learn programming, the rest is just tools. The following video might help you to clear your mind. [Staying relevant as a programmer](https://www.youtube.com/watch?v=ZZUY37RQS-k). Javascript is almost "must know" language for any developer and it can be a good entry point to the programming world. But without knowing javascript what is the point of discussing all those js frameworks. Truly answering all those questions requires an effort fit to a book, so I will skip.. Here is a decent guide on how to learn javascript. [http://jstherightway.org](http://jstherightway.org)
&gt; async/await in Python 3 exposes that behavior in a nice way Nice is relative. I'm not a huge fan of async/await style concurrency. In many ways it's a clutch for not having proper threading.
...and mobile safari.
&gt;sometimes at the bottom By "at the bottom", probably you mean when it is fed as a parameter to a IIFE or a module.
Not sure how or works on JS, but in Scala it's common to get the headers firsts then getting the content by chunks. That way you can do streaming, either to save time by starting to work on the content before it's fully arrived or to work with an infinite stream.
I use Vim, which means every 10th keystroke or so is escape, which functionally makes the new Mac a no-go for me. I could rebind, but I'm not going to work on developing all new muscle memory just so that I can continue to use a Mac.
Windows has a 256 character path+filename limit that runs into the deep directory structures you get with nodejs, libraries and other js dev setups. Macs don't. Simple as that. There are shitty workarounds, but it's simpler to just buy a Mac and if you need Windows sometimes, run dualboot or in a VM or such. Can't run a MacOS on a Win box. 
This can be achieved with a series of the native function 'str.replace()' wholeString.replace("PERBMP", "207").replace("otherString","replacementString").replace(...,...); This wasn't tested as I'm on my phone but should be a good start!
That's not valid. `res` is undefined. You could do const getJSON = res =&gt; res.json() const response = await fetch(MY_URL).then(getJSON) 
If you find hatred of one library over another, you're likely better off distancing yourself from the source of such hatred. My other advice is to just start doing things. The cost of doing things wrongly many times is much less than the cost of paralysis trying to get it right the first time. Poop out a few awful applications and eventually it starts to *click* and you suddenly grok the pros and cons of web dev libraries (and how little it truly matters in the end)
Done https://github.com/cosmicjs/user-management
Interesting. That could work, though I think it would be somewhat cumbersome to update. I will play around with it thanks.
elementaryos is worst distro, just stay with ubuntu or xubuntu better
Thank you for taking time to look at it and provide critical comments on my implementation. I'm looking over the Redux async docs now. I now see this is a poor example for what I'm doing ... I'm working with it in a small app now. On first access of a key in the state, the data won't be present and It'll return a Promise that resolves to the requested data while caching it in the state. So a Promise is returned for a reason - on every call you'll get a promise that has what you want - either fetched or cached. I'm sure they're room for improvement and that's how we learn.
This looks promising. So would I replace var test = with {finishingoperation.description} as that is pulled directly from the database?
Looks like you're missing some dependencies: * Jquery Mapael - Dynamic maps jQuery plugin (based on raphael.js) * Requires jQuery, raphael.js and jquery.mousewheel
If you are building the initial string before trying to make the replacements, then you can actually skip a step and just populate the replace array with those finishingoperation.description values. It's hard to tell exactly without seeing any of your code.
Yeah the input is not a delimited sting. It is a single value pulled from a database, but that value could be one of many. This works when the returned value is PURPB, but of course if only for one possible value.t Replace({finishingoperation.description}, "PURPB", "207") 
So, using my code example, this should translate the string (after you've built the replace object): var translated = replace[{finishingoperation.description}]; I'm not familiar with i-net designer, so the context of that variable might differ from what I'm assuming.
Can't we simply init a response now from our string, so the parsing can be done outside the event loop? (new Response('{"a": 123}')).json().then(console.log); console.log('First!'); Will run properly in async, so we'll see: &gt; "First!" &gt; Object {a: 123}
Check this one out: https://cosmicjs.com/apps/voting-app Built using React, MobX and Cosmic JS for easy data storage and management.
[String.prototype.replace()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace) takes a function as the second argument which you can use to map the replace value. Then for the first argument, use a regular expression which you can create by grabbing the keys of your map and `join()`them together with the pipe operator `|`. The 'g' of the second argument in `RegExp()` makes the search global for the entire string. var input = 'PERPB,ABC123,WERWE,WERTHK,UBBSDO'; var replace = { 'PERPB': '207', 'ABC123': '45097', 'WERWE': '908', 'WERTHK': '7035', 'UBBSDO': '987' }; // combine the search keys into a regular expression. 'g' makes the regex search global var search = new RegExp(Object.keys(replace).join('|'), 'g'); var output = input.replace(search, function(matched) { return replace[matched]; }) console.log(output); Here's a JSFiddle: https://jsfiddle.net/2dbbkafr/
I'm a big fan of affinity designer, but haven't tried photo yet. Also they just published a book on design recently, have you looked at that?
Like others have said, the unix utils mostly, but what puts it over Linux for me is the trackpad and its gestures on OSX.
You haven't tried Windows 10 then. There's absolutely 0 requirement to use a touch device with windows 10. Just works like plain old windows, except it works well with a touchscreen too. I have both by the way. Considering leaving macOS for windows once the linux subsystem works well enough. Because macOS is boring and is just iOS's little desktop buddy. Every new feature is to improve its compatibility with iOS. That's it. That's all. Expect nothing more in the future as well. The only reason I still use mac is cmd+h to hide app windows, alfred, iTerm3 which is so amazing and homebrew. cmd+h and alfred are replaceable on windows. iTerm 3 is tough ... it's such a badass terminal. It'll be hard to get used to anything less. And homebrew will be replaceable with the unix subsystem. It's either that or Docker.
One reason I see having this two-step process being beneficial is because `fetch` throws an error **only** if there was an error getting a response from the server, not if there is a 204 or some weird _no content give_ response. So we can say "Hey, check the headers and make sure that we need to parse the content/do something else". `fetch` is a low-level API and I find that most of the 'man, this is weird/sucks' things about `fetch` are because I expect it to be a high-level abstraction of the contract between client/server.
Sketch, that's the reason. After that, with today's tools (Vagrant, Docker, ... ) you're no longer stuck on one OS. And please, let's just stop the "Mac OS is more beautiful"... No, it's just different styles. You may prefer one, OK, but please, be a little more opened minded...
This is my first time hearing about Affinity. I've been using photoshop and indesign in parallels. $50 one time fee and looks pretty similar to photoshop! Looks like they are releasing publisher in 2017
The link you provided still doesn't have them.
I am literally typing this from my iMac at work as a web developer. I literally have no clue what you are talking about. Why would I want to have a Macbook Pro or iMac just for Development when my Windows machine that I've built and upgraded since 2005 can do everything I do at work perfectly fine plus more. That probably makes me a better developer since I can happily use both environments and be perfectly fine with it. I'm actually impressed narrow minded mac users like you call themselves developers just because they can open a console inside Chrome and hack javascript together.
sorry i just syncronyzed local with remote should have them up now 
Probably missing a closing bracket or parenthesis. You would need to post all the code to be sure.
Thanks, I'm working on a better example :) 
I think front-end devs tend to not come from a hardcore computer science background and are generally less comfortable with all the compile-it-yourself &amp; 'tinkering' that the heavy cs folks have been doing since they were 15 on a commodore 64, or whatever you call them. They choose Mac because Mac promises not to make them do that. - a front-end dev
Simply for cohesion and scalability. JavaScript development has become a practice of compiling many libraries together. What if another library overrode your method? In theory, you can avoid this by faking namespaces, but in practice JS is incredibly strange, and manipulating its native interaction is dangerous.
Erlang is the gold standard for concurrency, IMHO, but it does things *very* differently. Go is probably a "better" answer, because it has great support for concurrency while still feeling like a C-style language.
With Swift, you compile against a well known standard library API. This won't change as your code gets run, so any changes you make to a type there will either work, or not if there's a problem (i.e. trying to add a member that already exists). With JavaScript, the standard library comes from the runtime which is running your code, and this runtime changes from client to client. You never know what version of a runtime you might be getting, including a future version which may have added the API you added yourself. If that were to happen, there would be a collision and the entire internet would break! Then everyone would blame you and there'd be a thousand memes with your face on them. In fact this almost happened with includes() which originally was contains() https://esdiscuss.org/topic/having-a-non-enumerable-array-prototype-contains-may-not-be-web-compatible
I don't use Adobe anything, Ubuntu all the way
Hi man, good that you're getting started with JavaScript. It's a lot of fun. First of all, you can never shorten JavaScript to Java. Java is a completely different language. Java and JavaScript are like Ham and Hamster. Don't confuse the two! Second of all, it's really difficult to look at code in a Google Doc. What you're missing is a `}` at the end of your code. You're not closing your `for` loop. Hence the "Unexpected end of input"
Create a separate partition with a case sensitive file system. A have this setup working for years without an issue
&gt; Are you trying to make an argument against frameworks in general? No. Against legitimate solutions to legitimate problems misused by people who don't face even slightly comparable problems. Or who don't even problems to fix at all. If you only have a picture to hang above your couch, use a hammer. Even if those brand new FX-2000-PRO sledgehammers are fucking sexy. If you have a skyscraper to build, you'll need sledgehammers. Maybe those brand new FX-2000-PRO ones; they are fucking sexy. If you run a skyscraper building business and you want to attract the brightest engineers, let them work on the next line of sledgehammers. The FX-2000-PRO line is so 2016!
Glad to be of service :-D
Ok, I've refactored the module and provided a sample loader - same URL as above. I'm invoking it like this getStateKey('config').then(data =&gt; { this.setState({loading: false}); }).catch(err =&gt; { console.warn('Error loading configuration', err); this.setState({loading: false, isError: true}); }); Simple map object on line 30 links up the state key with the fetch function. getStateKey, line 41, checks to see if the key is present in the state, if so that is returned. If not, it looks in the map and will use the Promise for the key from the map. In this case, it's the function on line 16. In my large app, these fetch functions are in another module and are imported.
I would say the over-all UX standard for apps developed from Mac in general is higher as well. 
If you want to do it all in one line (and don't mind mixing styles a little) you can use something like this: const json = await fetch(MY_URL).then(r =&gt; r.json());
Your coworker is doing it wrong then.
The thing is, OP can build their computer for gaming and it can do everything they could possibly want to do as a developer on that very machine. There's no need to sacrifice any development capabilities for gaming. You do sacrifice gaming, and more money, if you buy a mac though.
Because you could instead do fetch(...).then(r =&gt; r.text()).then(t =&gt; JSON.parse(t)) `.json()` is just convenience
That doesn't answer my question, and more to the point, why would `r.text()` be asynchronous as well??
Laptop hardware drivers.... Nope. 
Sucks to be him
More importantly, `response.json()` **waits** for the request body to finish arriving, then parses it.
Oh please.
Vanilla / plain js is such a loaded term. You either use a popular open source framework or you build your own. *Everything* is vanilla js.
Yeah, if you want to have different contexts, enforcing a bind at time of instantiation could mess you up. If you're using prototypal inheritance, though, your original function is still available through the prototype. What is happening with something like: this.method = this.method.bind(this); in the constructor is that you're creating a new instance member thats overriding the would-be inherited version of that method. The original is still in `constructor.prototype.method` which could be rebound as needed. You just need to go through the prototype to get to it which is a bit uglier than going through the instance.
Nice one!
Stop trying to make fetch() happen. 
Linux?
&gt; What I'm getting at is that Angular, React and friends, while being perfectly legitimate solutions for perfectly legitimate problems are not worth the hassle for most of what makes the web. Is what "most of what makes the web" today the same as "most of what makes the web" tomorrow, ie, will SPA become the common type of 'web page' in the future? I mean if we're only going to use tools or languages that are worth the hassle for what makes the web, then why aren't we all doing `PHP`?
I'm wondering if this might be less of an issue with Node.js, since you have far more control over the environment in which the code executes than you would if you were writing code for the browser.
[details regarding the implementation](https://github.com/thysultan/dio.js#diocomponentprototypestylesheet)
task runner, script launch, ect. However you want to put it. you can use NPM's scripts in really comprehensive ways and generally with a lot less code than grunt or gulp builds.
Something I wrong with your computer. I run Linux (Arch), OSX, and Windows across multiple separate machines, none of them, regardless of OS ever have to reboot for anything other than an install or update. Modern computers don't crash with normal use of software except in exceptional circumstances.
WLS has made it a lot easier to dev on Windows, but it's still not native and leaves me asking the question why even bother when you could just have the real thing. I 100% believe it will get there eventually, but for now, eh, not sure. 
Don't disagree with Erlang but channels in go aren't as glamorous as people make them out to be. Under the hood they are pretty yucky.
&gt; JavaScript development has become a practice of compiling many libraries together. What if another library overrode your method? Well, why would I import a module that overrides capitalizeFirstLetter, if I already do that myself? I think libraries get much more modular these days. I seldom use a library that have real side effects like this if I would import the module.
The consideration is that you have no idea if a library is going to override your function or not. I'm not disagreeing with you, though. At a low level, it should be pretty obvious to the developer what he is implementing when done correctly. There are just nuances with JS that might require standards compliance in order to guarantee compatibility. If you're not too concerned with edge-cases or obscure third-party libraries, you probably won't have any problems extending native objects. At least, not immediately :)
If you are running JavaScript in a browser, the browser could have its own implantation of capitalizeFirstLetter which happens either before or after you define it, so you can't rely on it. Just make it a pure function instead.
This is not true. It's one thing to have a streaming JSON parser that operates on an incoming stream, but if you already have the full string representation in memory, parsing it into an object *is* a synchronous operation. There would be absolutely zero justification for making the API asynchronous. Such a library exists, by the way, checkout `JSONStream` on npm.
I love that they did it this way. Versus all-in-one response
Your id is button, but you are searching for id buttons.
Right, this is what I noticed we were constantly having to call .bind in click handlers.
&gt; I literally have no clue what you are talking about. I totally agree with that statement. &gt;my Windows machine that I've built and upgraded since 2005 can do everything I do at work First you say you use a Mac and now you say you use Windows. I already know you are a liar but you now make it obvious you ONLY use Windows and you prove you are the disgrace I said you are. More proof is you don't know the difference between dev on a Mac and Windows cause you think the tools work the same and are the same. You can't fool anyone with that lie either. Here's a surprise for you. I own no Mac products save an original iPad given to me for Christmas, years ago, and I don't know why. I build my own machines and I run FreeBSD.
Hey all! I work on this. Thanks for linking. If you're curious and want to hack around, I've made a few codepens here that are hooked up with React 15, TypeScript, and a CDNified version of fabric-react exported under the Fabric global, try it out: * [DetailsList, hooked up to reddit](http://codepen.io/dzearing/pen/EgqMZq) * [ContextualMenu](http://codepen.io/dzearing/pen/WovrbX) * [CommandBar](http://codepen.io/dzearing/pen/ENjKPy) * [Using FocusZone, keyboard arrowing (instead of tabbing) through focusable content](http://codepen.io/dzearing/pen/YpqXJZ) Feel free to peruse [my other pens](http://codepen.io/dzearing/pens/popular/?grid_type=list), although I make a lot of them for reproing issues. If you want to deploy (and livereload) the samples locally: git clone https://github.com/OfficeDev/office-ui-fabric-react npm install gulp serve 
Professionals use professional tools kid. I don't own any Apple products but a dusty iPad given to me years ago for Christmas but never use.
Your functions are currently just declarations, to invoke them you need select(); or buttons(); in your &lt;script&gt; tag Your onclick handler is defined in the variable Select, which currently is just a variable. It doesn't exist in the DOM so you can't click it to trigger select(); Maybe try something like this? &lt;script&gt; function select() { document.getElementById("list").innerHTML ="fruits"; //variable fruits is undefined, //so for this example I used a string } &lt;/script&gt; &lt;p id="button"&gt; &lt;button type="button" onclick="select()"&gt;Sort&lt;/button&gt; &lt;/p&gt; &lt;p id="list"&gt;&lt;/p&gt; or, more similar to your current code: &lt;p id="buttons"&gt;&lt;/p&gt; &lt;p id="list"&gt;&lt;/p&gt; &lt;script&gt; function select() { document.getElementById("list").innerHTML ="fruits"; //variable fruits is undefined, // so for this example I used a string } function buttons() { var select = "&lt;button type='button' onclick='select()'&gt;Sort&lt;/button&gt;"; document.getElementById("buttons").innerHTML = select; } buttons(); &lt;/script&gt; 
&gt; document.addEventListener('click', obj.click.bind(obj)); Yeah that's what I was getting at, here's an example: https://jsfiddle.net/vyqnh41L/6/ I didn't even think about the .removeEventListener case, but even so, if you're going to pass it to more than one click handler, or you want to guarantee you're able to call other methods of the instance, and don't care about the 'this' that called it, then it seems like binding it to itself by default makes sense.
&gt;knowledge of plain JS is essential Then why are you asking the question when you already know the answer? If you don't know plain javascript, YOU are the one who is dead.
Vanilla JS? Eh, about as dead as Angular, so I'm not sure it matters too much. (Which is to say: There's a ton of jobs for both, but the future is obviously elsewhere.) Ninja edit: And come to that, I'm not sure I agree that "vanilla JS developer" or "Angular developer" are actually things. There's just "JS developers", and they all work on different projects in terms of scope, scale, age, libraries being used, frameworks, etc. When people say "vanilla JS" they seem to usually actually mean "our own Frankenstein's monster of a jQuery based framework the last developer wrote", which is obviously terrible, but is in every sense of the word less "vanilla" than a job maintaining a standard backbone app. Really, you should focus on the project and the team, not the tech. A good team will probably use good tools, but plenty of bad teams are happily churning out Vue or whatever it hot today. I'd rather be on a great team using mediocre tools than on a bad team using great tools. Especially since the skills are incredibly transferable.
Well shit. I just turned this guy's interview offer down... then I read this. Next time I guess.
I agree with this endorsement. That said, I think it's a tough book. I'm okay at JS and can get it to do what I need for my work, but I'll admit I am still learning. I've probably made an attempt to go through Eloquent JavaScript about three times and each time have made it further into the chapters before discouragingly getting distracted by something else. Nonetheless, I learn something each attempt so certainly a worthwhile book. 
React does not. I'm not familiar enough with Angular to say.
Erlang feels incredibly wonky at first but it really helped me get into concurrency, so +1 for that.
Spot on Angular 1 vs 2!
You'd better not suck at fundamentals if you want to keep that job.
If I was using Affinity Photo, would I have any trouble sharing (both sending and receiving) files with coworkers using Photoshop? I assume it's a drop in replacement?
Have an 8gb Ram and running a VM and some background processes puts it on heavy load and opening a pull request on github with anything more than 50 files WILL lead to a crash. I don't know why they sell these with such miniscule ram and are continuing this trend.
I'd echo that experience about Macs and add one big issue with icloud is it saturates your internet connection when it syncs. But ... I find it ridiculous my Mac Mini isn't supported with Sierra, but Windows 10 and Ubuntu will run just fine. What the heck? 
Asynchronous !== Concurrent Those are two completely different things. Nodejs does all the processing in a single thread, so there are no tasks in it that work in parallel. Goroutines aren't real system threads. Nevertheless they ARE threads, scheduled on the level of the Go runtime.
Oh yeah, true. 
Not sure how that is relevant to my comment.
Not really. Regardless of how you do it, the resulting object must be serialized and then deserialized again whenever it crosses the thread boundary. So you have to go through that expensive process, which turns out to be worse than just waiting for it to parse in the first thread. A way around this it to pass the text into another thread and have that worker `JSON.parse` and then retrieve any relevant data you need from it, and return only that data back to you. But even this is only really necessary for very large JSON strings.
What's wrong with it? Seems like a very nice and simple API. Much better than normal ajax.
Maybe, maybe not. Node still needs to abide by the standards set by TC39.
Why, if I may ask?
Flip a coin.
For ANY navigation. Either code, IDE, software everything.
Yay!
It's not much different from opening a memory editor and changing values in a game, which is definitely cheating.
Head: React, Tails: React
React
Maybe a little OT, but this is a *brutal* way to accomplish what you seem to be trying to accomplish (dynamically generating a button with behavior)
I'm not surprised - there is a severe lack of respect for Crockford in the industry. I think this is because most js developers now were in diapers when he burst on the scene and helped change JavaScript from the wild west to a respectable profession. 
Definitely not. You're taking a big step down a very wrong path - should `String.prototype.replace` be async? `+`? "Async everywhere" may seem like an OK idea when you're working at absurdly high levels of abstraction and everything has half a second to complete, but if you pull that idea into low-level code then you'll very quickly realize: **async has overhead**. Besides, the comment that started us down this path is wrong. We're not `await`ing the parser, we're `await`ing the completion of the HTTP response, then parsing JSON synchronously.
In Go functions are synchronous and you can run things in parallel using the "go" keyword.
The MooTools framework does/did a lot of monkey-patching. It was a big problem when ES 6 wanted to add additional features to Array, like Array.prototype.contains = function (item) {} MooTools had already extended the Array type with lots of additional functions. So it was impossible for ES 6 to add a .contains() method without breaking all legacy sites that used MooTools. The ES 6 method was renamed to "array.includes(item)" instead. Scala and Swift lets you add additional methods to objects, but it doesn't implement it the same way as JavaScript does; you don't really add new methods to a class, it's just syntactic sugar for using a wrapper class. And Swift has static type checking, as opposed to JavaScript, which is dynamic. You could say it's "safer" to monkey-patch in Swift and Scala than it is in JavaScript, so that's maybe why people do it?
&gt; which happens either before or after you define it, A built-in being defined after code is run? Not even JS is that absurd.
Because other languages are sexier than PHP.
What does it add that https://github.com/Polymer/ShadowDOM doesn't?
Both Both for knowledge. Your own to understand it React for real world use 
 document.getElementById("buttons").firstElementChild.click();
hmm, my idea is actually longer… const getJSON = Response.prototype.json.call
I've pushed my old project to [GitHub](https://github.com/Krizzu/Universe) and made it with live preview. One of my first projects, created with JQuerry and velocity.js. Pretty cool, I must say!
more specifically: * `await fetch(…)` returns a `Response` once the headers have arrived, but before the body has * `await someResponse.text()` returns, as you said, once the body has arrived * `await someResponse.json()` is a convenience function that not only waits for the body arriving, but also parses it before returning. BUT for optimization, `.json()` *can* be implemented by doing both waiting and parsing in native code, which means that less time is spent in synchronous JS code: const r = await fetch(…) const obj = await r.json() can be thought of as const r = await fetch(…) const body = await r.text() const obj = JSON.parse(body) // this pauses JS execution for the parse duration. or const r = await fetch(…)(…) const body = await r.text() const obj = await JSON.fictionalAsyncParse(body)
[you’re right](https://www.reddit.com/r/javascript/comments/5cg27o/why_does_fetch_with_es7_syntax_require_two_await/d9x2bsd/?context=3)
Fair enough. I like to avoid having to nest callbacks, so async/await suits my preference.
React
I've made a [star map](http://www.hoopcola.pl/przeslij-gwiazdke/?free) using React where you can share your wishesh with other users. The map is infinite nad uses a seed-based Math.rand() to generate placement, color, size and rotation of the star. By default you will only see 9 "sectors", but you can scroll left/right up/down as long as you want, and will always be able to find a free star for you ;) The original idea was to use real-world data to load the star position etc. but all the REST API I could find were super slow, so we decided to go with random. I made it using React in about 3-4 days. There are a lot of things I would want to fix before going live, but sadly the deadline was quite short so I had to hack around some parts (mostly when it comes to mobile support). By default all the stars you see/seen (when scrolling to another sector) are kept in memory, but there is a config.js flag that changes it so that those would be removed (intended for working with low end devices, but it turns out it's quite performant even on prev-gen mobiles).
 String.prototype.capitalizeFirstLetter = function () { return this.charAt(0).toUpperCase() + this.slice(1); }; for(var k in 'foo') { console.log(k); } Outputs: 0 1 2 capitalizeFirstLetter Oops. What if some library you're using adds a method with the same name, but slightly different behavior? What if that method gets added to the standard library in the future, but... with slightly different behavior? To make matters worse, this stuff can also break heuristics and make your code run much slower in some environments. https://www.nczonline.net/blog/2010/03/02/maintainable-javascript-dont-modify-objects-you-down-own/
For companies, someone with experience in the used framework(s) is preferable, but someone with in-depth knowledge of the language and experience with some similar framework(s) is almost as good. Pro-tip: Don't refer to yourself as a &lt;framework&gt; developer. You're a JS developer who's built some fancy stuff with &lt;framework&gt;. Frameworks come and go. This is just one you happened to use for those projects.
Is there any way to suppress the nosy redundant ``` constructor(props){ super(props); } ``` ?
`jQuery` syntax can still look cleaner, shorter, and work for older browser's.
It feels nostalgic to see the ol' Angular 1 code as it was 2 yrs ago, you may look into using components these days with Angular 1.5.
Is that spec'd behaviour, or just implementation? `JSON.parse` always needs to stay synchronous, but it seems like Body.json() is something that could run on another thread.
So far it has been more fun than No Man Sky.
[Lloyd's Vornoi algorithm produces even 'enough distributions](https://en.wikipedia.org/wiki/Lloyd%27s_algorithm)
it's an option, it was clearly meant to be changeable.
It's also a good way to encourage the very fragmentation we all complain about.
How so?
Learn the 101 of each. Make a simple app in each. Then, and only then, decide on what feels *best* for you and follows your natural dev patterns more. I, personally, feel right at home with React. It just makes sense in my mind and I love the approach. Angular was a tough snippet to swallow. My colleague, the opposite. He couldn't align with the React pattern, but felt right at home in Angular. So I think you owe it to yourself to try both, and choose which one you like best. There is plenty of industry for each.
I know it wasn't in the question but why not Vue?
I think what you're after is the "Revealing Module Pattern" - It's very useful for creating modules (classes), etc. https://addyosmani.com/resources/essentialjsdesignpatterns/book/#revealingmodulepatternjavascript Also if you're able to use ES6 (Babel) you can use the new class keyword http://exploringjs.com/es6/ch_classes.html Read up on scopes and closures - esp. closures! Other information regarding name spacing patters including automating it https://addyosmani.com/blog/essential-js-namespacing/
They have some unusual API choices like panicing if you try to close a closed channel. They are just a mess of mutexes and queues under the hood. Typically you need to use more then just channels - example wrapping logic in mutexes. They are also quite slow.
Is there any native API that is loaded after script tags are excecuted? That sounds super strange to me. Because you would have to add some wait function before you could use this native function.
It's not fragmentation, it's choice. It's better to have 2 tools that do the "same thing" in different ways with different priorities than have one tool with multiple flags, settings, and options that tries to support both use cases. Just like how owning both a bicycle and a truck is not "fragmenting your transportation", it's having 2 options you can use at different times.
Modifying built-in prototypes is bad but enumeration doesn't matter because properties can be defined as non-enumerable now.
Angular provides a whole framework where as React provides a template engine with awesome Dom manipulation!
Very good point about bug fixing as an onboarding method. A bug report (a good one anyway) consists of "This code should do X when given input Y, but it's doing Z", so every bug you fix increases your knowledge of the codebase.
It *is* fragmentation, by definition. It's also choice. The problem is his project isn't just a learning exercise, it's an attempt at solving a solved problem. It doesn't seem to do anything better. &gt;Just like how owning both a bicycle and a truck is not "fragmenting your transportation" No, this is a terrible analogy because bikes and trucks serve two completely different purposes. It's more like owning a Camry, a Corolla, an Accord, a Jetta, a Civic, a Sentra, a Focus, a Maxima, and an Altima.
&gt; I get you are not considering the maximum string size, to assume that a json to be parsed would always be trivial enough to do on a blocking operation in the main thread is a bit naive. Personally I think storing so much data in a JSON string in RAM, that parsing that string would cause your application to lock up... is a bit naive. If you have that much data you should probably be using a fast key:value database like Redis to store it and then only retrieving the data that you need when you need it. Javascript is a very forgiving language, it lets developers make poor decisions. That's why it gets a bad rep. There's probably someone trying to parse 10gb JSON string with JSON.parse(), but that's kind of an edge case and, if discovered by anyone compitent, would be on /r/programminghorror.
Asynchronous operations are intended for instances where you are waiting for I/O. Not instances where where you would have to compute things. Computing things asynchronously hasn't been possible at all in Javascript until Webworkers recently came about. Also if something takes a significant amount of time to compute, its not really a bad thing, so long as you only do it once and then [save the result](https://www.sitepoint.com/implementing-memoization-in-javascript/) so that you can just read it instead of computing it over and over again. Also you can use a database like Redis to store your data instead of using a giant string of JSON.
A Ferrari and a Lambourghini :p
Just because you didn't look long enough to figure out the differences doesn't mean they don't exist. And even if they didn't exist now, having multiple implementations is always a good thing. It keeps bugs/issues in one from becoming "standard". And while my analogy was extreme, it was correct. Do you really think that most of those car companies should just close up shop because there's no point in having any choice?
If you aren't using a framework you are writing your own. People complain about too many tools, you are creating a new one without documentation. That said some people will always prefer it. 
Yes. An app I worked on had jQuery + jQuery plugins. A client we worked with claimed the app was not working. When we debugged via desktop remote, we found the jQuery plugin we had in our app no longer existed in runtime. What was happening was the client had a chrome extension that overwrote jQuery with it's own version of jQuery after the app had loaded.
&gt; Just because you didn't look long enough to figure out the differences doesn't mean they don't exist. I never said his project wasn't different. It's clearly different, but it's not *better*. Furthermore, even if it is different, OP does a pretty poor job of describing how his project differs from what's already out there. What exactly makes this better? It would be a waste of time for me to create another ssh implementation. There are tools out there and they work. It would *not* be a waste of time for me to create another ssh implementation that solves a new problem, or is faster, more stable, easier to use, etc. Obviously, all of this goes out the window if I'm doing it as a learning exercise. &gt; And while my analogy was extreme, it was correct. Do you really think that most of those car companies should just close up shop because there's no point in having any choice? No. I believe the market will absolutely destroy anyone who tries to enter the already saturated economy sedan market without differentiating themselves. And just like when a developer abandons a project, those who are already users or customers will no longer have any support. It's a net loss.
tagging /u/impressflow so I don't need to copy-paste
Because I work in this industry, and I have for a while. It's like saying: jQuery is way less prominent now in the web industry. Yes, I'm pulling it out of my ass and don't give you neither source or numbers. It still is true because if you work with JS devs this is the kind of things you should know.
Cool. Are you the only one who works in the industry ?
I was primarily backend until maybe six months ago. This was the opinion I had going in but very much disagree now. While the JS ecosystem is moving quickly, churn seems like it's cut down and clear winners are emerging. Just don't bother trying to keep up with shiny new JS trends and instead, focus on battle-tested, less sexy libraries.
Definitely good advice on the ask questions but not the same one multiple times. It's a good way to collect glares. Source: I got glared at ;) 
I think you meant "another script could have its own implementation that is defined either before or after yours". A similar issue for native implementations (if you, say, put in an existence check) is that yours may not conform to the new native implementation. (This is exactly what happened with `.getElementsByClassName` in Prototype, and it is also why prollyfills are risky.)
Can we please throw the term "single page app" in the bin with "web 2.0" and "rich interactive application".
[Movie reference](https://www.youtube.com/watch?v=Pubd-spHN-0)
The point is that such a "MooTools like library" is impossible in Swift, because you can't add new methods to a class in Swift like you can in JS. As for breaking MooTools, it is possible that the authors of the library made sure to check whether `Array.prototype` already had a method called `contains`, expecting that any future native method would work the same way as theirs; alternatively, if they didn't, then that would break any other script loaded later that expects the native method instead of the MooTools method.
This is a pretty interesting approach. I can't really tell very easily, but how would you handle multiple components all binding to the same key? Or component that contains another component binding to the same key? This approach does break the whole component approach, since you're interacting with state outside of the component. If this could be written so you're not binding to the Document object, I believe the approach would be a lot cleaner - however that would also make it less useful since you won't always receive the key events. This probably mostly just highlights the importance of keeping global event dispatching within your controller/action dispatcher.
Thanks. Don't know why its related to JS though.. 
Good read. But Trello is an interesting choice for note-taking. Not sure I'd recommend that approach to notes (I don't think you explicitly made that recommendation, but it stuck out). There are lots of other better tools suited for note-taking (evernote, onenote, or even just Vim and a text file). Totally understand that Trello works for you, but possibly worth mentioning other common approaches so beginners don't feel like that's the best/only way to do it.
Again, just because you don't see the benefits, doesn't mean they aren't there. If it didn't differ in any way, then it'd just be a byte-for-byte copy of the first, and nobody thinks that would be useful. Even if it doesn't "add any features" the fact that it's different is still really useful. What if some massive bug is found in Polymer's implementation that causes issues in a large number of apps, or it's found that the way that OP architected this one makes it easier to apply some optimizations. Hell just having an implementation built by someone other than Google is a plus sometimes. Nobody is holding a gun to your head making you use this, it doesn't harm you in any way. You can argue that by this existing the current implementations are getting "less help", but that's not the way things work. It's like saying you shouldn't watch TV because that's taking away from time spent saving dying children. It could be true, but it's not in most cases. Just sit back, relax, and be happy that someone is making something that might make your life better in the future, and they are doing it for free.
It might even do streaming parsing and bail on parse errors before the whole body is downloaded.
You'd break any script that is loaded later and expects the standard method.
This is not the right file: https://uoft-medicine.000webhostapp.com/jquery.mousewheel.min.js It looks like you saved the github page instead of the file itself.
FYI: The JavaScript engines internals are threaded native code; it is just the JS event loop that runs like a single thread. So they could offload the parsing to a native thread that *does* run parallel to the JS engine and later callback into JS with the result. 
As /u/eirslett said: &gt; Scala and Swift lets you add additional methods to objects, but it doesn't implement it the same way as JavaScript does; you don't really add new methods to a class, it's just syntactic sugar for using a wrapper class.
I'll admit that my investigation was purely on the side and not full time so someone who does do front end work full time probably does know who the clear winners are or is better able to predict who they will be in the future. But if you google "what is better X or Y" for a Javascript framework, transcompiler, task runner, CSS preprocessors, etc... I don't think you will find clear winners very easily.
It's worth noting that these problems didn't come from JUST extending the prototype, but doing so _conditionally_ if there was no native implementation... naively expecting that future native implementations would match. If you JUST override the prototype in client code, you're not risking such a clash, and it's a lot less dangerous. Your code will be built to use your methods, and even the native language uses them in the future, your code will still use your overrides. That said, libraries should probably shy away from this practice, as they are often meant to work even with each other, and if one overrides some method one way, and another another way... ZALGO
Thank you both of you that helps a lot :)
Additionally, you're assigning `boards` as the function `getBoards`, rather than as the return value, `getBoards()`.
Because async i/o isn't the same as concurrency. Having one thread which does the processing and doing cooperative multitasking on that one thread has many benefits over actual multithreading and letting the kernel manage which is doing what. For starters, the async i/o method is almost always more memory efficient, and avoids all the issues with shared memory.
Again, none of this is relevant to my comment.
&gt; I'm not a huge fan of async/await style concurrency. In many ways it's a clutch for not having proper threading. It's all relevant to your comment. async/await isn't concurrency, it's not the same as "proper threading" and "proper threading" isn't what anyone here is talking about.
Out of curiosity, does your development stack heavily involve remote servers? I did formally work at a place where it was 90% VIM users, but that's because our stack was so fucking complicated that it was impossible to run on our local machines. You choice was either work in a terminal, or work over ftp/nfs/rsync. Everywhere else I've worked people preferred desktop editors like Sublime, Atom, WebStorm, Coda, etc.
No, our backend stack runs just fine (if slowly) on our local environments. Hell, I've got it set up on two of my personal machines. Come to think of it, though, I have a friend who's a backend dev in an environment like you describe, and she had to learn vim in her first weeks on the job. And for what it's worth, *I* am the oddball who uses Sublime in vintage mode. :)
Well one of your problems is that you have a loop that is incrementing i, but you never use i anywhere that I can see. Try replacing 0 with i in this line ...SelectRoom()'&gt;" + roomArray[roomIndex].choices[0].text + "&lt;/but...
Oh crud lol, It's because I keep changing things to see what happens when I do lol. I've tried adding a switch statement now, so that it changes as the room index changes. I'll try putting 'i' into it, thanks!
- Acorn - TouchDraw (for SVG editing) - OmniGraffle - ImageOptim - Sequel Pro - Robomongo - Kaleidoscope - Tower - Cornerstone - Transmit - Hostbuddy - LittleIpsum - Dash - iTerm - Movist These are all Mac only applications that I use regularly in my day job. This doesn't even include things like Docker for Mac or 1Password which are subjectively better experiences on the Mac than on Windows. Yes, you can find tools to do the same thing on both Linux and Windows, but they're no where near as well built or as easy to work with. Then there's stability concerns. On my personal Macs where I control how the software is loaded, I have _zero_ stability problems. I use it as both a laptop and a desktop, via a Thunderbolt 2 dock that lets me plug in one cable when I get to my desk. I restart the computer maybe once a month for security updates, but beyond that it's rock solid. A major contributing factor to that is because I always upgrade my OS via a clean install, so one day a year I'll have a day of downtime while I backup everything, wipe the drive, load the new OS, and restore from backup. Contrast this to my last work provided Mac which came loaded with IT policies and Virus software that I could not disable, and which I had to do an OS Upgrade on instead of a clean install when macOS 10.11 came out. That mac crashed constantly, it would never wake properly from sleep, login took forever, and some parts of the OS reset themselves every time it rebooted. When I left the job I wiped out the drive and loaded a new OS on to it before turning it back in. Unsurprising, all those problems vanished.
That willYouSucceed function at the top is ridiculous in every possible way.
My guess (having not bothered reading the spec…) is that the first `await` is waiting for the server to respond &amp; is triggered by the receiving of the headers. The second `await` is to allow for all of the body of the response to be received.
Not really up to the industry, it's up to the clients, and right now, enterprise clients are leaning angular. Which certainly doesn't mean that you should not spend time learning react. By all means, learn everything you can, what you do in one framework may benefit from things you've learned in another. Just don't surrender to industry preference - devs like react better, but that doesn't mean clients do.
Please read the readme ;-) e.g.: &gt; Note: All country profiles use the "official" two-letter GEC (formerly FIPS) codes and NOT the ISO codes (you &gt; might be used to) e.g. `au` for Austria (and not `at`), `gm` for Germany (and not `de`), and so on. factbook.json uses the same country codes as the CIA. In a nutshell - 1) the world factbook is older than the ISO 3166 (why break/change things ;-) and 2) covers many more countries (and territories) e.g. 267. For more insight see [Cross-Reference List of Country Data Codes](https://www.cia.gov/library/publications/the-world-factbook/appendix/appendix-d.html). Cheers.
Hi /u/dfghghfhfh, please show us what you have so far. Here are a few, but not all, of the ways you can post your code: * [Github Gist](https://gist.github.com/) for simple JS/text dumps * [Pastebin](http://pastebin.com/) for simple JS/text dumps * [Codepen](http://codepen.io/pen/) for JS+HTML+CSS * [JSFiddle](http://jsfiddle.net/) for JS+HTML+CSS Please reply to this comment once you have done that and I will make the post public. Thanks!
But async/await doesn't give you concurrency at all. You can only ever do one thing at a time, never more than one at a time. You seem to fundamentally misunderstand how async/await works. Async/await in JS allows you to do i/o "in the background", it ONLY deals with i/o. You cannot await a CPU bound process (well you can, but it won't do anything). Also, JS does have true concurrency. It's called WebWorkers, and it can happen right now in most browsers. There is no shared memory yet, but that's in the pipeline, and it will come to JS first before WASM gets access to it, so webassembly won't help/hurt any of this. If you want preemptive multithreading, then JS is not the language for you, but you can still do it using multi-processing. And saying that JS is "worse" for people because it doesn't support concurrency in the way you want concurrency to work just makes you sound uninformed. you are complaining that cooperative multitasking isn't preemptive mutitasking. It's like complaining that your red car isn't blue.
The code works: https://jsfiddle.net/uz0cgkkm/ All I did was change the image `src` to point to a valid image (random one I found on reddit).
Ok, so show us what that looks like. We need to see broken code before we can fix it, we can't just guess what you may have done wrong.
All you have to do is put this somewhere in the `&lt;head&gt;`: &lt;script src="http://path.to.your/file.js"&gt;&lt;/script&gt; If this is all local, you should be able to use that path as well: &lt;script src="C:\path\to\file.js"&gt;&lt;/script&gt; You shouldn't need to touch any of the rest of it. You might try opening up [Chrome's devtools](https://developer.chrome.com/devtools) and see if you get any errors.
But after you've written your "large elegant application" with "vanilla js" what have got? Services? Templates? Routing? Authentication? Chances are you've written a custom framework. That's my whole point.
Nope. Are you sure the file is getting loaded? Add this somewhere in your JS file: alert('File loaded'); Do you get an alert pop-up when the page loads? If not, then your file isn't getting loaded.
I don't have anywhere to easily post it. Is the image showing up? Did you change the image `src`?
Hi r/javascript. Had an itch and scratched it here. I see lots of ways to improve, but I thought this was a good place to start open-sourcing the idea. Idea is that sometimes people who start filling out an online form, and something happens (real life, tech issues, whatever)... what happens to the info that was being added? Poof. It disappears. That's why I made FormSync. Example: https://jsfiddle.net/acoyfellow/2se2rLq2/
I think he's joking. The teams I worked on would always give browser compatibility issues to the dev lowest on the totem pole.
It's the small, but important things for me. Even though I'm a software engineer, if I'm going to be looking at a screen for 8+ hours a day, I want what I'm looking at to be beautiful. And macs don't just run macOS. I run it, Windows, and Linux in one box. My windows machine is little more than a super expensive gaming console/porn server. My macbook is my virginal madonna. Actually, I just don't want to jerk it using my work machine.
The biggest thing for me was business domain language (i.e. jargon) that was never explained to me. Also, jargon peculiar to the monolith that no one bothered explaining too.
Given all the talk about template vs. JSX, your last point puzzles me: why is Vue "not nice about JSX"? Do you know that in Vue 2.0 you can write: const Foo = { render (h, { props: { color, userName: name }}) { return h('section', { class: 'foo' }, [ h('h1', { style: { color }}, `Hello ${name}!`) ]) } } Seems this is what you prefer, and this is exactly what you can do in Vue. Doesn't this check the "flexibility" box for you?
Ember :)
I swear by nvALT, it's a good way to organize small notes and code snippets by keyword.
I don't understand how juniors survive these days in this world of transpilation. It's impossible to gain a deep understanding of code without getting in there and stepping through it.
Browsers before IE9, sure. After IE9 there's no point as anything essential (e.g. classList) can be polyfilled so that you're sticking to the native APIs. And I don't think adding a layer of abstraction over the top is cleaner, but that's just me. It obscures what you're doing and presumes you know something extra on top of the language for little benefit, if any, with many drawbacks.
&gt; on my first day at Xeneta I got a MacBook Pro and was told to setup my system according to the README.md file ... So I had to ask for help. Again and again. Else I would have wasted weeks on this setup. *This trend has continued*, though with less intensity as time has passed. Oh, so you're that guy that asks for help on every little thing even if the solution is easy to google. When I see someone like this I immediately think that they just do the bare minimum to get by and are going to require consistent hand holding. &gt; First of all: you have a lot of holes in your knowledge and there is no reason to hide this, so swallow your pride and ask for help when you need it. The blogger is right you shouldn't hide holes in your knowledge, but you shouldn't run for help at the first sign of trouble. People should be striving to build a reputation as an independent learner and problem solver, or you'll be *that guy* that doesn't know how to use git.
&gt; step 1: learn to type. I KNEW I WAS DOING SOMETHING WRONG
I created a modest [Simon Game](http://codepen.io/nankeuriseu/full/dpQBgP) while completing my Front-End Development Certificate through FreeCodeCamp. **Explanation.** Re/Start starts or restarts a game. Strict means you lose when you miss one. Win is 20 in a row. (Those in the program already know these rules, so I didn't make effort to make them more self-explanatory.) **Feedback.** I've already received some feedback on the design aspect, but if anyone would pop in a few words about the JS I'd love it. Also, I know there are some issues with the Audio in Safari. They seem to come and go.
What are your thoughts on electron thus far? I've been itching to play with it.
Don't do it. This will come back to haunt you. Try: http://passportjs.org/ They have authentification boilerplates for nearly everything. And more importantly it's open source. 
This resonates very well with the JavaScript community, we have all these frameworks to solve a problem that if we understood the fundamentals of software development we would probably not need to have them.
Correct! 
Or arguably better, use promises. function loadBoards() { return new Promise(function(resolve, reject){ Trello.get("/members/me/boards/", { fields: "id, name" }, function(boards, attempt) { console.log(attempt); console.log(boards); resolve(boards); }) }); } function newCard() { loadBoards.then(function(boards){ for (var i = 0; i &lt; boards.length; i++) { console.log(boards[i].id); } }) }
Seriously, if you're validating every API you consume in this way you're going to have a bad time. I'd much rather have code that isn't polluted with 1000s of not needed conditionals. 
Exactly this. I work in Windows and rarely have any issues. Not sure after everyone's coworker/friend in here is doing but it's definitely wrong, lol.
Sure! Im in
I DMed you, so check your inbox.
Here's a solution It's a little verbose so you can so see how it works. Cheers! http://codepen.io/daniel_demarco/pen/oYxwOd?editors=1111
Awesome thank you for the report! Looking into it now
Nadella is doing a bang up job imo.
Ok so I've googled around a bit now but I can't seem to find anything that shows me how to do this? Could you help me out?
Which would return derp (if blah and bleh are truthy), which may or may not be a boolean value, which may or may not be what you wanted in the first place.
Something like this (untested): class PolyClip { constructor(src, voices = 1) { this.cursor = 0; this.clips = []; for(let i = 0; i &lt; voices; i++) { this.clips.push(new Audio(src)); } } play() { let clip = this.clips[this.cursor]; clip.pause(); clip.currentTime = 0; clip.play(); this.cursor++; this.cursor %= this.clips.length; } } let clip = new PolyClip('foo.ogg', 5); **Edit:** Not really sure why this was downvoted. The code does work fine. Just call clip.play() in response to a key press.
This is what I did but I think you could use mod arithmetic here to make your code clearer ``` // Style each letter a different color of the rainbow in order var el = document.getElementsByClassName('title')[0]; var colors = ["red", "orange", "yellow", "green", "blue", "indigo", "violet"] const string = el.innerHTML.split(""); el.innerHTML = ""; string.forEach( (letter, index) =&gt; { const span = document.createElement("span"); span.innerHTML = letter; span.style.color = colors[index % colors.length]; el.appendChild(span); }); ``` 
I can understand why you would prefer React for various reasons, but "less flexible" and "restrictive" would the last applicable ones. It's the complete opposite.
I think the idea is to ensure that certain scripts aren't even loaded until later, if ever: Having any value for the `type` attribute of a `script` element, other than `"text/javascript"`, will keep the script from loading.
I would use the WebAudio API instead. There are lots of intro to WebAudio articles out there that will explain how to do something very similar to what you want -- [I would start here](http://blog.chrislowis.co.uk/2013/06/05/playing-notes-web-audio-api.html).
Never heard of it. But, I probably wouldn't switch into something that has had no major releases since 2010. There are more than enough widgets out there that have React or Angular in mind - no matter how esoteric an interface you are building. Keep doing what you are doing. Your boss probably got talked up by some salesperson. Tell your boss they are wrong.
``` return Boolean(blah &amp;&amp; bleh &amp;&amp; derp); ```
Pull the room title and the room text out of the for loop. Thats causing you a bunch of problems.
I've used it. It's really targeted for people who only deliver to a client base comfortable with "enterprise" desktop programs in the 2000's. I would not use it now, as it doesn't provide the same level of development support that modern frameworks will. It's mostly a UI kit, and a very dated one at that.
Thanks for this, I will share it with my students :)
Pro tip: Don't ever show ExtJS to anyone in management at an "enterprise" company, because they will get addicted to how "enterprise" (read: shitty) it looks, and then want it everywhere. Fight this tooth and nail, do not let them go anywhere near ExtJS. Like others have said, literally ANYTHING but ExtJS. [EDIT] /u/psayre23 pointed out that I didn't include why -- let me try an include the why in order to be more helpful: This is a bit hindsight-y (in that I'm going to put ExtJS in terms of some things that came after/grew alongside it), but ExtJS has all the worst parts of Ember, React, Angular, and jQuery. It is like the worst of ember in that it has large ramp up time, poor documentation (this is no longer true, ember has excellent documentation now, but pre 1.10 things weren't so clear), and a lot of parts that SEEM like they would fit together well, except when you try to put them together, things go off the rails very quickly. It is like the worst of React, because it embraces what I like to now call the "component life", except does it by creating tens (hundreds? I've never tried to count) of one-off objects with obtuse and often frustrating interfaces and ergonomics, and tries to get you to live in the ExtJS object world that is as far removed from HTML and CSS and possible. This, obviously, has disastrous consequences (looking at their site now, I don't see the object reference I dealt with during ExtJS 3/4, however, so maybe this has changed). It's the worst of Angular, because it takes the complexity that angular brought in (I feel that angular was the first big framework for a lot of people coming out of jquery land and other smaller micro-frameworks), and adds an even greater amount of complexity for no benefit. The move to angular made developers start thinking in terms of views/controllers/routes/etc on the frontend, and basically introduced developers to trying to jam what they thought should happen into a framework. If you thought trying to track the watch/digest cycle in angular1 was hard, it was harder trying to find how to modify the ExtJS "widget" that was ALMOST what you needed, that was doing stuff ALMOST at the right time you needed it to happen. It's the worst part of jQuery, because it was spaghetti. Except even worse, it was a flavor of cold, hard spaghetti, not warm malleable flexible spaghetti. If you got yourself into a mess, you HAD to read tons of ExtJS documentation to get yourself out of it, and that's if you ever managed to get yourself out of it. jQuery at least has some feeling of primitives that you can combine/reuse to get your achieved result (and yes, make patchwork fixes), but ExtJS was spaghetti without the flexibility. All that said, ExtJS has changed. They seem to have some new versions of the software, it seems. Maybe things are better? One of the reasons I stick with EmberJS so often is that they generally keep an eye on the landscape and incorporate things, and I appreciate that. I wouldn't dare ExtJS another chance, but maybe they've changed. Maybe it's more modern now, maybe they've stopped trying to have every object on the screen be represented by some sort of ExtJS under object. I don't know, and I don't care to find out. I think that if your frontend framework needs professional support, something is wrong. It's one of the things that worry me about Ember too. I am comfortable with Ember's choices, and I have invested the time in getting to understand why the decisions get made and I have a decent grasp on how the system works internally, but I think the more consultancies/professional support services that are built up around a frontend javascript framework, the less likely that you should use it. Good frameworks are simple, obvious, and powerful. When you need to break from them, you'll find that a good framework gets completely out of your way, and leaves you breadcrumbs (in the form of APIs with good developer ergonomics) to find your way back in to the system. ExtJS did not do those things when I last used it. I do not mean to offend the developers that I'm sure have poured heart and soul into it, but I just don't like it very much.
My experience with ext is one of spending a week trying to get it to do something that I wanted that was slightly different from how it wanted to do things. I think I gave up after that and convinced my company to move to something else. Did angular for a while before migrating to react. Still using react.
That was something I mentioned leaving my last gig - they had a weak omboarding process and plenty of bugs… so instead of making new devs create features and "figure out" the code base, they could fix bugs and understand the code base. 
Released major rewrite of onfontready, but it is fully backward compatible, so I gave it version 1.1.0 instead of 2.0. https://github.com/dwighthouse/onfontready Released it at 1am on the election day, so I don't think many took notice of it.
My mind tripped on 20 years of web dev experience.. and then I realized that's possible. Holy fuck the web is old now. 
Thanks! I will do. 
Pretty cool! thanks a lot for posting, I have been trying really hard to learn React, so this will help a lot =)
If you're in the UK and have access to a Nationwide account you can download their mobile banking app. It's written entirely in ExtJS (well... Sencha Touch to be more accurate). It's one of the more complicated examples what can be done with Sencha. Nationwide have a similar outlook on using ExtJS everywhere in their enterprise. Although the difference being that they started with it back when the alternatives didn't exist. As an enterprise option is not that bad. If what you're after is a known quantity and enterprise levels of movement in the code base (not often and over long long periods) then it's good for that. That's why architects love it. No constant churn. The downside is that doing things the Sencha way limits what you can do massively. That's the trade off. Try using accessibility mode with ExtJS. Try inspecting the deep DOM of death. Try and use modern build tools with it. You'll have your work cut out for you. Tl;Dr: Decision makers and architects love it (make the choice once, forget about it). Devs hate it (why the fuck would you do it like that? OMG look at this horribleness).
Use this as example: https://jsfiddle.net/qwsejd0r/1/
&gt; return !!(blah &amp;&amp; bleh &amp;&amp; derp); 
Not sure it was necessary to post this into at least three separate subreddits! I am tempted to ask, what makes this bloggers approach to survival so good as to be evangelised? It all sounds a little trite and arrogant to me. The only tip which I believe it's half right is the last one. Bug fixing is a good way to learn a code base. However, I think it's important to get to know a code base before you go on a rampant big fixing spree. This is where honing an ability to read and analyze code comes in. Additionally, there no mention of good programming practices like pairing, which can negate the need to harass colleagues with loss of questions. Nor TDD/RGR. A suite of appropriately named tests can easily be peer reviewed to check you're understanding. Maybe the author should approach the subject matter more objectively and at least interview a number of relevant people before spamming multiple subreddits with his take on how to do things.
Hey everybody, I post this question on Hacker News as well and things went crazy, so I made a slack group for those interested. I was able to find a mentor as well to help us navigate through react. If you wanna join the group you can messaged me your email address and I will send an invite. Best
Here's my take on it, you can iterate through the individual letters by turning them to an array using the split() method, then you can itterate using map() and form a new span with the custom color from the list, in the end just join all the created spans and put them inside the title element, I'm using the ES6 syntax to make it a bit more concise: var el = document.getElementsByClassName('title')[0]; var colors = ["red", "orange", "yellow", "green", "blue", "indigo", "violet"] el.innerHTML = el.innerText.split('') .map((l, i) =&gt; `&lt;span style="color: ${colors[i % colors.length]}"&gt;${l}&lt;/span&gt;`) .join('');
It's much more than an implementation detail. Swift and Scala are compiled languages with static typing, JavaScript is an interpreted, dynamic language. In the compiled languages, resolving function calls is done at compile-time. You will get a compiler error if "hello".foo is not defined in Scala (I'm not a Swift programmer, but my understanding is that they are similar in this regard). You will also get a compiler error if FooString (a wrapper that implements foo) is defined in another file, but not imported directly/referenced as a dependency into the class where it is used. So even if you use syntactic sugar, it's not overwriting a global String method, like JavaScript. In JavaScript, everything happens in runtime, and god knows what function you may have attached to some global object... That's why proper scoping is so important in JavaScript code (for any sizable code base at least). Another issue is that with JavaScript in the browser, you have no idea which JavaScript engine is going to run your code. With Scala, you can explicitly choose which version of the standard library to run, on a per-application basis. I'm not sure how Swift works, but it's similar there? In which case backwards/forwards compatibility is not such a big concern.
Involves yet another framework but I think this is a good introduction and is the easiest way to get started https://zeit.co/blog/next
Me? **You** are so.. red! Just what you deserve. People downvoted **you** into oblivion for a reason.
In a nutshell, a universal (or isomorphic) js app is one that shares code between the client and the server. The main advantage is that you deploy one language/app on client and server. This reduces code maintenance footprint and prevents client/server deviation. It also supports seo out of the box. see: http://isomorphic.net/javascript it might help to reframe the question. What sort of application are you trying to make? You may not need this sort of architecture. Have you been asked by your employer to write one? Is it just a desire to learn? Your question is quite vague, and so the answer will be too. 
I want to offer a big grain of salt here. I've been doing web development since I was a teenager in the late 1990's. Its a generic grain, but basically take opinions from &lt; 2yr devs very generally. Its not that they don't have value, but that they lack perspective and experience.
&gt; &gt; I hated working with ExtJS more than anything I've ever worked on. Can confirm this, I worked 6 months in an ExtJS project in ~2012. Never again. I go so far as to say it in interviews: "I will never work in ExtJS projects again". For me it was several things: - Seemingly complete lock in into ExtJS way of things - Documentation was very incomplete or just plain wrong in some cases (I believe this was largely fixed since then, but don't know for sure) - Documentation was by default only online and down quite a lot. You could get an offline version but that lacked all the comments which quite often (like php.net) contained the most important information (see point above). The downtimes actually cost me quite a few hours work. - Codebase was enormous. I don't have the exact numbers anymore but it was something like 400k lines of code. I looked through a couple thousand of those and there was so much stuff in there that was completely unnecessary for probably 99.9% of use cases and a lot of really badly written code. - Code was buggy, weirdly so. Some components base functionality as described in the docs just did not work. - Bugfix response was horrendous. I submitted 2 bug reports, with my recommended code for fixing them. Nothing happened in the 6 months I had to work on that project, except an automated response that the ticket was put in triage. Asking what was happening got no response either. After that I didn't even bother reporting anything else. - The direction things were going in was very opaque and it seemed like if you weren't ready to get some Sencha certified ExtJS consultant, it's basically your own fault.
Angular 2 vs Ext JS is an apples to oranges type of comparison. I don't see how Angular 2 is supposed to compete with a component framework such as Ext JS. If you work with a lot of templates, then I guess it might be OK. If not, then I'm afraid, you will end up building applications which are hard to maintain since different components will need to come from multiple vendors with different coding standards. Basically, you will nee to build a framework on top on Angular 2. https://www.sencha.com/blog/top-8-reasons-why-enterprises-prefer-sencha-ext-js-over-angular/ https://www.youtube.com/watch?v=Umd8XpCRzvI
Thank you, very appreciated.
TypeScript provides me with some significant benefits: I have to keep less in my head. This might seem really stupid since a big part of writing code is knowing the standard library and keeping track of the available methods/functions/keys/array contents/etc of any object, but when the IDE knows more about your objects, it helps you stay focused on a given problem. This comes up again and again: "is this an array of Strings or an array of objects?" "Is this key going to give me a String or a Number?" If you're dealing with complex objects, this can be huge and save time that, at the end of the day, really matters. Refactoring is much easier. I can change an argument or a data type and the compiler will tell me where I have to make corrections. This isn't too different from what you experience with good unit tests but it saves you the extra step of writing and maintaining them. Type errors were extremely rare in my code prior to TS, so I wouldn't say that my code is any more stable. The big benefits have been in the area of rapid development: things are built faster and are more stable out of the gate. Of course, if someone is building relatively simple views with limited business logic or simple data, it's probably overkill. But for someone whose project is more app than website, it's awesome.
I'm in. 
&gt; scrollbars Isn't this supposed to be handled by the browser?
well, but that's like your opinion. for me, that way of teaching is boring and slow. you might as well tell the guy to take an online course. they'll have it well structured for you, with examples that are relevant to what they think you need to learn. have ur guy follow the chapters and save your breath and time. i always teach in the context of solving or building something. if u start by giving the beginner a hammer he's gonna see nails everywhere.
I'm in also.
I think I heard about this in one of the chrome dev summit talks.
Awesome work! How long did it take to build that?
But it's not "hiding" if it actually solves the problem. I use react because it lets us build UIs in a fraction of the time that we could before, and those applications are more maintainable than before, and more developers can work on the project with less training than before. If I want to compress my images in my application, i'm not going to write my own compression algorithm, i'm going to use a standard one. And it just so happens that someone has created that, tested it, given it a great API, and documented the hell out of it. You'd be stupid not to use it, regardless of how much you know about the fundamentals of image compression. Nobody is saying that using a framework/library removes all problems, but that it reduces the amount of work needed. You might need to learn x/y/z to use framework "W", but framework "W" needs to learn a/b/c/d/e/f/g/h/i in order to work, and 'i" needs to know about j/k/l just to do it's job. So rather than learn and use the whole damn alphabet every time I make anything, i'm going to just learn and use x/y/z and let the framework deal with the rest. Sometimes you'll still need to "punch through" the abstraction and manually mess with "i", but that doesn't mean that the framework is useless.
&gt; Facebook doesn't offer any such thing for some reason. why would it? Dan Abramov responds to any react related question on twitter even without anyone paying him directly. Offering paid option would be pointless.
Our opinnion might differe - anyone that is familiar with Array.from/Array.keys usage of making an indexed array will recognise it right away, and if you want to make an array containing 137 items I would never do it by hand ;) Also, the performance hit - I don't really think you can measure it, that's how small it would be. But yes, it will still be there, and in case where you are sure you will never ever need more than 10 items, you can stick with hard-coded array.
Things like semicolon removal can be refactored by using the `--fix` flag. I'd also look into Facebook's [Codemod](https://github.com/facebook/codemod) for advanced refactoring. Personally, I introduced a modified standard style at my work.
Your homepage doesn't even work on mobile. You're not selling Ext JS very hard when your site says this: "For best results, use a desktop computer with the Google Chrome browser as my site uses XML,HTML,CSS, JavaScript, browser workers, and websockets - so you will need more than a phone to use it. Please Download Chrome or open the site again using Chrome's icon () on your computer."
I am not trying to sell anything. They don't pay me and it was an expensive license but it’s still great to work with.
Thanks for your comment. I was able to make improvements to the article. I saw memory problems as part of the _performance reasons_ I described but I now see it was unclear! I added a section on how to _simulate_—don't really like that word here, seems misleading— TCO, one of the three solutions I describe uses trampolining.
 let choices = [...'123456789'];
You're right, you're talking about Patrick Kettner's talk : https://www.youtube.com/watch?v=ARkPBm6AcNA I added the same king of feature to topheman/rxjs-experiments a few months ago (in august - https://github.com/topheman/rxjs-experiments/commits/master ), with all the automation part in bonus. When I watched the talk two days ago, I decided to write a post about the webpack part. Also tweeted it to Patrick: https://twitter.com/topheman/status/797632807480664064 Edit: Just added a mention/link to Patrick's talk in the conclusion of my post, before the resources.
OOooohh fancy. Thanks!
I assumed you meant to make it a functional stateless component. That would be even nicer. let Square = props =&gt; &lt;button style={props.style} className={props.className} onClick={props.onClick}&gt; {props.value} &lt;/button&gt; and because you're passing along "known" props like style and className you can probably just skip that alltogether and pass it all down let Square = ({ value, ...props }) =&gt; &lt;button {...props}&gt;{value}&lt;/button&gt; 
If you're interested in a commercial framework with similar features to Ext JS, you should take a look at [Cx](https://cx.codaxy.com). Cx offers powerful data-binding options, view controllers, history based routing paired with a rich set of widgets and charts. It combines the best parts of Ext JS, Angular and React in a single, highly integrated, package. There are a couple of application templates which can be used as a starting point for new applications: - https://github.com/codaxy/cx-starter-kit - https://github.com/codaxy/employee-directory-demo - https://github.com/mstijak/tdo - https://github.com/codaxy/state-of-js-2016-explorer The framework and the documentation are also available at [GitHub](https://github.com/codaxy/cx) The framework is free for non-commercial use and we offer bug-fixing support on GitHub + offer support for paid customers. 
I love it, so simple and creative! And a perfect demonstration of what Node is good at/for. Great work.
&gt; I assumed you meant to make it a functional stateless component Yes, just a mental-shortcut, but that's exactly what I ment. &gt; and because you're passing along "known" props like style and className you can probably just skip that alltogether and pass it all down Yup, but I'm not a big fan of those because I got burned with redux-form abusing that and resulting in warnings with 0.15 IIRC
I know my opinion won't carry too much weight and there are many good ones already in the thread but I thought I would share anyways. I have been developing for six years now and early on I experimented with ExtJS. Mind you, IE9 was new at the time. ExtJS was made at a time when we didn't have all the nice things we do now like flexbox, and also it was a time when you couldn't rely heavily on native browser APIs like querySelectorAll and so forth. Things are so much better now, and if you only need to support IE9 and up (or even better, IE10 or better, IE11) it will be so much more efficient to stick with native browser APIs and CSS features. As a matter of fact, I am a strong proponent of using vanilla JS over frameworks now, adding polyfills as required.
Actually: - First example: no error - Second example: error - Third example: depends on your web browser
Finally, the button is added.
Was the part about **For best results** kinda tricky for ya? :-) Supporting multiple browsers for all the stuff I mentioned is too much for just me. It's just my home site and I wanted to do local file IO and play around with ThreeJS. Desktops and tablets work best for this so I put up that message. Happy you found it enjoyable.
I like it, simple and fun. One problem though - whoever wins the FIRST game, wins the whole thing, regardless of who wins the rest of the games.
What the hell happened last month? Why is there such a massive sudden increase of repos for all languages?
There's a bug where it seems like the event handler you attach for the spacebar (for the "press space 10x" round) isn't unattached afterwards, so on your second attempt at the game, you only need to press it 5x since the handler fires twice each time you press it.
The claim that references are impossible in JavaScript is glib. If you have closures in a language, you can make effective references of variables. Concrete example: let x = 42; const deref = () =&gt; x; const set = (v) =&gt; { x = v; }; The pair of the deref and set functions act as a reference to the variable x. They can be passed around, like any other value. I'm not sure this article is very helpful. 1. It conflates the concept of variable assignment with the concept of structure mutation. They are different concepts. 2. It makes assertions that just aren't true. Compound objects can be made immutable. We can use const when defining the constructor of a class, for example, as well as Object.freeze(). https://facebook.github.io/immutable-js/ is a library of immutable, compound data structures. 3. The use of the unfamiliar terms "assign by value" and "assign by reference" are meaningless in the article. The author could have just stuck with the concepts of immutability or mutability. I get the distinct sense that the terms are being adapted or borrowed from superficially similar terms in C++. But in C++, the terms used are "pass by reference" and "pass by value", and they have to do about how parameters are passed from one function to another, which the article here isn't even talking about. In summary: there's some information the article, but it's mixed up enough that I got more confused reading it than not. Overall, -1.
It's vulnerable to XSS. For instance, if I make my name: "&gt;&lt;script&gt;alert("hello, world")&lt;/script&gt; Then "hello, world" will pop up as an alert once the round starts. This is a massive vulnerability and should be fixed immediately. Start by looking in to how to sanitise input.
you definitely should shuffle the order of games
this is part of https://github.com/surikov/webaudiofont
They should really change the criteria to 10+ stars or something, this is a totally pointless data otherwise.
I've used both extensively on commerical projects, so I guess we can agree to disagree. React is low level, lots of manual work, while Angular is high level with lots of opinionated abstractions. I'm finding the Angular abstractions working for me, being a perfect fit for a HTML UI.
You need a reverse proxy like nginx for that
JQuery
Maybe it has to do with how they report? Maybe they are including private repos now, for instance.
&gt; But it's not "hiding" if it actually solves the problem. It is hiding if you bring a huge pile of stuff you don't need to fix something that you don't know how. &gt; I use react because it lets us build UIs in a fraction of the time that we could before, and those applications are more maintainable than before, and more developers can work on the project with less training than before. It's ok to use a framework to do things faster if you could write the framework yourself if you wanted to (because you understand how it works). It's not ok to do that in order to build more maintainable applications, using a [forcing function](https://en.wikipedia.org/wiki/Behavior-shaping_constraint) to do that is an evidence that the programmer lack fundamental principles. It's **not ok** to think that developer won't need training, they will need training because they will have to learn all the idiosyncracies of a new framework, that's pretty obvious. They **won't need training** if you were not using a framework or if you built your architecture to make it possible to plug functionalities the framework is supposed to be solving (instead of depending on it). A framework is not part of your domain, it's just an irrelevant detail. &gt; If I want to compress my images in my application, i'm not going to write my own compression algorithm, i'm going to use a standard one. We are talking about two things that are completely different again (another Straw Man). A compression algorithm is not a framework, it's just an abstraction. &gt; You might need to learn x/y/z to use framework "W", but framework "W" needs to learn a/b/c/d/e/f/g/h/i in order to work, and 'i" needs to know about j/k/l just to do it's job. I have no idea what you meant by that. &gt; So rather than learn and use the whole damn alphabet every time I make anything, i'm going to just learn and use x/y/z and let the framework deal with the rest. Ignorance is not an excuse. When abstractions leak then how are you going to solve the problem? Learning frameworks without understanding the fundamentals is the recipe to create crap software and tie yourself to a framework that will change in a couple of years. That's the worst business decision one can make. &gt; Sometimes you'll still need to "punch through" the abstraction and manually mess with "i", but that doesn't mean that the framework is useless. I never said frameworks are useless, they are just not fundamental to do your job and you should not learn them first. You should learn the actual platform before thinking about using frameworks. I use frameworks but at least I can write any of them from scratch if I want to and I never let my application depend on them. Also, I treat them as if they were pluggable to my domain, not a fundamental part of it.
Babel-polyfill works the same way, it's ES5 that polyfills stuff in global scope. It's best practice to use NPM to manage it as a dependency, and pull it in as an ES6 import at the top of your app JS, but I'm pretty sure you could paste it in manually as a seperate script like your example and have no transpiration/bundling step.
I use node as my backend so for the most part, everything is JS.
2 stars and that's it is what I think. You can star (and fork) your own projects 
Not by choice...
I'm in
JS is obviously growing, but could this be a case where web dev languages are over-represented on GitHub as people may use it as a form of cheap hosting, while backend or compiled languages tend to be privately hosted?
Same reason someone would use Linux over windows for development. A functional bash terminal, make, a package manager, and it looks better. FE developers also don't require a powerful PC or anything specific like that, so it's just the general appeal 
Yes, the spread syntax is also much better than mine.
I find it funny hearing JavaScript programmers talk about how abstractions are harmful... While working in JavaScript, a language built on the backs of at least 4 or 5 languages, several layers, and hundreds of abstractions just to get to hello world. And do you really think that you need no training if you don't use a framework? You sound like you are suffering from a bad case of "not invented here". Your code isn't magically better than others, and if you try to solve everything yourself you're gonna find that the people who stuck to (and mastered) one domain are always going to be several steps ahead of you.
It is quite definitive, covering ES5.1, common elements of the DOM in HTML5, and the API used by jQuery 1; also, this book is widely talked about, although not as much as before ES6 was released in 2015. I have seen that a 7th edition of the Guide is in the works: http://support.oreilly.com/oreilly/topics/javascript-definitive-guide-7th-edition It will most likely be released early next year.
A great book but also a long and dry read. I think most people prefer the shorter, easier to read in quick burst books.
/r/javascriptmasterrace
I was thinking about implementing offline support using [offline-plugin](https://github.com/NekR/offline-plugin), can anyone tell me the pros/cons?
Is there a better book theses days something similar who cover everything and is a bit more modern then ? I guess once you master JS and the basics the rest is quick to pick up or understand overtime at 15hrs a day of study
Webpack is not suitable for server, use nodemon.
Nodemon only restarts the server when it detects a file change. And webpack is what's going to make the file change. How could he run both at the same time?
I think that you have to write to webpack configuration, one for the server and one for your client For your client you could use webpack-dev-server it's useful 
And then web assembly will change everything. 
Ever heard of ClojureScript? Or TypeScript?
http://eloquentjavascript.net It's a good book, but I don't know relative to learning JavaScript from scratch.
/r/aww
&gt; I find it funny hearing JavaScript programmers talk about how abstractions are harmful I never said abstractions are harmful, neither the OP. Please, if you are going to argue, at least argue against something someone said. &gt; And do you really think that you need no training if you don't use a framework? Neither I or the OP ever said that you will never need training if you don't use a framework. If you don't know what you're doing, then definitely you need to learn the platform and software engineering, but at least that will be a long-term investment. If you know the platform and fundamentals, THEN you don't need any training when not using a framework. &gt; You sound like you are suffering from a bad case of "not invented here". Your code isn't magically better than others, The OP also never said that their code is better than others, again you are making up arguments. &gt; and if you try to solve everything yourself you're gonna find that the people who stuck to (and mastered) one domain are always going to be several steps ahead of you. Which domain? React or Angular aren't domains. Your business is a domain and it should not be tied to a library or framework. I know and work with many frameworks and I can ensure you that understanding the fundamentals of JavaScript and software engineering allows anyone to use any of those frameworks without big friction. Nobody is arguing arguing against using frameworks, the argument is against learning them instead of the things that really matters to you as a professional (unless you don't want to be one).
This is not PHP application, it is Node.js server ;) Also, no SQL here
But life happens™ you know. Shitty network, worm infected router, a company firewall, Starbucks Wifi Login credential page... you name it!
I much prefer this library: https://github.com/paulmillr/es6-shim Also, I notice that your library even polyfills some very old ES APIs; I'm not aware of an engine that lacks `Array#push` and `Array#pop`, for example. It is still instructive to try to re-implement these methods, and also (my favorite) to implement `Function#call` by using `Function#apply` (even though IIRC all engines that have one method have the other).
Yeah, so React being lower level allows it to be way more flexible 
I'm curious, though - would TypeScript, Dart, CoffeeScript etc count towards this data? They all compile to JS, but the files hosted on Github are in different languages.
Leave me your email address please and I will send you an invite 
I used to swear by Ember. Tried Vue a month ago and Ember just feels terrible now in comparison. 
 I agree with you. But just a funny fact: I'm working on a project in Unity, where the backend is javascript (node,) the front-end is c#. Who would have thought? 
Yes that seems to work in this case. But will it be the same if it was an ajax request?
Probably. With npm you can use github as a module repository, but (as far as I know) languages like python and Java requires a repository server (pip or maven). So it necessarily doesn't mean the language is more popular, but it is easier to work with github directly. 
You can't fork your own project into your own account
 JavaScript is everywhere ♥ !!!
I bet a majority of those projects surveyed have embedded SQL strings. But SQL doesn't even make the list. If they had a way to measure embedded SQL strings too I'm sure SQL would be in the top 10 languages. That's probably a conservative figure. I wouldn't be surprise if it place higher. Almost all projects use SQL whenever something needs to be stored. But these kind of surveys doesn't detect that properly. 
https://github.com/getify/You-Dont-Know-JS Try this one
I tried it. It works well but it didn't play well with the constraint that I explain in my post which is to be able to have a fallback for the html file. Moreover, I wanted to do something more with the service-workers (like add to home screen or push notifications), you can't overload so much the provided SW, so I felt it was a little too much shipped code for what I needed.
You could say the same thing about HTML and CSS, but like SQL, neither of those is really a programming language.
With all the mini JavaScript libs this result is not a big surprise. One more useless statistic. 
But unlike HTML &amp; CSS pretty much all SQL implementations (MySQL, PostgreSQL, Oracle...) have procedural extensions that turn it into a full programming language.
Excellent job. 
&gt; Do you use Ext JS 6? What about developer experience, do you have something like Cucumber/Webpack there? 
Except the browsers console written in C (which is itself an abstraction over Assembly, compiled with a compiler written in C, etc...), using a cross-platform GUI widget framework to paint on the screen across multiple OS's which each have their own GUI Widget framework which is used by the GUI widget framework of your browser, and each OS has it's own memory management, disk format, SYSCALLS, kernel, etc... It's using html and CSS to render the console in most browsers. A JIT is used to compile the JS into bytecode which is run through a VM written in C (in chrome's case), which is run through the CPU to execute, again using SYSCALLS which are different on each platform, dealing with the memory management, disk management, and CPU execution for you. The `console` object is a library provided by your browser to allow you to log things, and it has a LOT of API surface that you probably don't know about, like how you can style that logging, and that styling works in a hybrid of CSS and sprintf which is from the C language and isn't really a standard in any meaningful way, but is just another abstraction over various ways to print in various languages, etc... You are deluded if you think that there aren't any abstractions with a hello world in JavaScript.
well, that's exactly my opinion :) &gt; i always teach in the context of solving or building something. if u start by giving the beginner a hammer he's gonna see nails everywhere. here is why I'm always hands-on. every curriculum is custom per person. online courses are failing short of it (for valid reasons, of course). but, I do agree "building something" is the best way to go, only the problem is, people usually don't know what they want to build :/
Potential race condition? Give the new window a new name (i.e., wName1 then wName2) as a test. 
&gt; If you want to arbitrability name things, then React isn't a framework, it's a library, so is it immune to your criticism of frameworks? Definitely. A library is pluggable, a framework is not. Your domain shouldn't even depend on the web, the web should be pluggable. &gt;That's so laughably false it's not even funny. When you are using something like react (simply for the sake of conversation), your program will be pushed toward a given architecture. That means when a new developer comes on your team, they will have some idea on how the program renders, what library calls to make, and how it's most likely functional in nature without having to dig into the code much at all. That's leaps and bounds above knowing "literally nothing" about your code. This is one of the main "selling points" of using a framework, and it's not false, it's very well understood and is the main reason why so many of them exist and why they get so big. Using a behavior-shaping constraint to force a good architecture is a problem right there and it is all the OP argues against. The famous "Magic". An architecture is supposed to be developed, not abstracted in a library or framework. A good example is redux, instead of using it it will be much better if you implement the event sourcing architecture in your own domain because a library ties you to the decisions of the author. &gt; Take something like a simple testing framework. It writes the API, it tests the code, it improves the API based on feedback from hundreds or thousands of developers, it has tools written for it, it has optimizations and compatibility that you could only dream of hitting because it's used by thousands of developers who all submit bugreports and code changes because it didn't work on their esoteric hardware or software. That testing framework put 100% of their effort into writing a testing framework. And unless you think you are going to do better, you'd be dumb to not use it, because unless you are writing a testing framework as your application, you aren't going to put in even 1% as much effort, time, testing, focus, and detail into your testing framework that you come up with yourself. We are not talking about a test framework or library, that's a whole other conversation. Tests are not part of your domain, they have different purpose. &gt; Your domain is to make an application Domain is, formally speaking, "A sphere of knowledge, influence, or activity. The subject area to which the user applies a program is the domain of the software". "Your domain is to make an application" makes no sense. &gt; So when you sit down to write your application, why would you then re-create and write your own rendering framework? No, you wouldn't. There are plenty of rendering libraries out there and you can even use a framework as the rendering if you must. That doesn't mean the domain should depend on it. Nobody said you should re-create your rendering concern. &gt; By using a pre existing one you get a LOT of things, and while it can increase the amount of work you need to do in the short term, it can decrease it over the long term. Again, I am not arguing against frameworks. I am arguing against learning them instead of learning the platform. &gt; Which again is my point. So why would you argue against using them? Again, I am not arguing against frameworks. I am arguing against learning them instead of learning the platform. &gt; But you have very clearly stated that you shouldn't use frameworks, you shouldn't rely on frameworks, and that things will be better if you don't use a framework. And i'm arguing that it simply isn't true. There's enough evidence to conclude you probably didn't understand anything I said, sorry for the ad-hominem. Not relying on frameworks architecturally is totally different than not using it ever. I never said you should never use a framework or that things will be better if you don't use a framework. &gt; But you have very clearly stated that you shouldn't use frameworks Probably not in the context that you are thinking, but in the cases where it doesn't make sense.
There's a huge different between a platform that should maintain most of its backwards compatibility than a framework that can rewrite and change everything out of the blue (Angular 2). The line is not blurry at all. &gt; Even the console api changed significantly in the last few years! It never broke the web. &gt; They aren't different, they are pretty much the same. They are not. Not even closer, as stated above.
&gt; I seriously can't fathom someone that thinks that they can write applications where literally everything is "pluggable" including the platform it's written on... You can't plug the platform, that's why you shouldn't rely in frameworks as the platform because they are to unstable to serve as such ;) Take a look here: https://8thlight.com/blog/uncle-bob/2012/05/15/NODB.html: &gt; Here’s what an application should look like. The use cases should be the highest level and most visible architectural entities. The use cases are at the center. Always! Databases and frameworks are details! You don’t have to decide upon them up front. You can push them off until later, once you’ve got all the use cases and business rules figured out, written, and tested. Again: &gt; Databases and frameworks are details! If you can't write the core of your application without a framework, then something is seriously wrong with the architecture.
(Full disclosure: I’m the author.)
I'd love to see your magical application where you can plug the web in and get an application, then unplug that and plug in wxwidgets and have it work just fine, then unplug that and plug in MFC and have it work there as well. I'll literally shout from the tops of mountains if you can show me a system that lets you do that. You would be the savior to all of software development if you came up with that one. Anyway, i'm gonna block you now, I don't need the stress that comes with knowing you are the person I might accidentally hire next...
Which compile to JavaScript
It's opt-in for users to reveal private repos (activity, not content). So awareness probably spiked
Satan?
Thanks!
I was going to suggest that the figures are fake, but they totally add up! They most likely wrote a frontend application that queries Facebook's graph [API for the post's reactions](https://developers.facebook.com/docs/graph-api/reference/post/reactions). Said frontend was then streamed as a video using some capture software and/or hardware. Pretty cool!
If you want to avoid the mutable approach, you could use [`String.prototype.search`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/search), checking that the returned index is greater than `-1`.
Great resource. Learned a few new things I didn't know before. Bookmarked
&gt; JavaScript-&gt;wasm Lol. It's like using a microwave to start a fire and using that fire to heat your dinner.
There are bad ways to do virtually any good thing. I once saw a person use jQuery. :shudder:
Or: using ultra-optimized bytecode to conduct CPU-intensive tasks more efficiently, while writing in a high level idiomatic C-like language.
Thank you so much!!! Works perfectly!
Thank you for doing this, we appreciate it.
For us it was. For the past year we tried to redesign our portal to be more "web 2.0" and the amount of time that was needed to do only about 25% (we have at least 100 aspx forms) was so much that we decided that if we were going to spend that much time we might as well just change frameworks to something new and easier to use, so we changed to React. This change enabled us to hire more engineers, is almost impossible to find an engineer that has worked with EXTJS while finding an engineer with React experience was very easy. 
I really like ThreadItJS.com It's only about 100 loc to implement but it's very close to a realistic app (it's basically a trimmed down reddit/HN-like app) and it covers a lot of ground: parameterized routing, xhr (including loading and error states), recursive components, dynamic state structure and performance The ThreadItJS API artificially makes some requests slow or errored on purpose so you are forced to implement loading and error states, just like in a real life production app. It also periodically regenerates its data and it always has a really really big thread (1000+ comments), so you can easily compare how different frameworks perform under stress.
I'm aware of ES2015+. I like that sugar, except the fact that you have to live with bad performance and low compatibility(not transpiled) or implement complex infrastructure which results in more vectors of failure(transpiled). Not even mentioning the main problem - high amount of run-time errors and hard refactoring due to lack of types leading to read-only codebase. TypeScript might help, but if you are going to go TypeScript &gt; JavaScript &gt; wasm, why not cut one step and do C# &gt; wasm instead.
You could keep a Constants.js file that exports an object that contains data about CSS class names you expect to use in your site/app. For example: // Constants.js const BlogConstants = { contentContainer: '.content', blogPost: '.blog-post' }; export default BlogConstants then in another file // Some front-end file.js import BlogConstants from './Constants.js'; const contentContainer = $(`${BlogConstants.contentContainer}`); Alternatively you could create functions that take elements as parameters so you only need to pass a selector name once when calling the function.
Did they release an update within a year or two? Yes. But the vast majority of the framework is outdated and was created for an Internet that doesn't exist any more. Avoid it like the plague unless you like wasting lots of time to end up with an app that's insanely slow. 
[JS the Good Parts](http://shop.oreilly.com/product/9780596517748.do)[store] [JS the Good Parts](http://bdcampbell.net/javascript/book/javascript_the_good_parts.pdf)[PDF] is a great start.
Man. I ended up writing a custom version of this functionality a month ago it would have been nice to have this :) 
This is a bit silly. You really shouldn't be using Angular 2 without Typescript. Plus, while Vue2 and Angular2 are comparable, React is not comparable to either. A lot of people make that last mistake so w/e I guess. /opinions
As a guy who has read/perused too many JS books (and I _still_ am nowhere close to mastering it), the ONLY book I keep coming back to is "Speaking JavaScript." HUGE hat-tip to /u/rauschma for writing something that is both readable and thorough! 
JavaScript may well be the most popular language, but it's definitely over-reported in Github. A lot of the bulk is millions of copies of jQuery + jQuery.min checked in with a small amount of original code. Visual Studio (for example) includes a ton of JavaScript in its initial scaffold for ASP.net MVC projects. The last project I worked on in that stack was still 40% JavaScript after a year of largely C# coding. 
I used sencha touch 2.x for about a year writing a mobile version of an cms. I enjoyed having a lot of built in functionality and a consistent UI but I can vouch for the support issues. I ran into a nasty reorder bug and support did nothing to fix it. It also had a extremely high learning curve. There were a few times I had to dive into source because I couldn't find an answer in their docs or online. I couldn't recommend it to anyone now a days. Especially since there are better options now. Ionic framework didn't exist at the time and jquery mobile wasn't good enough for a large mobile app. 
Bad performance? Low compatibility? robinwilliamswhatyearisit.jpg
[Here is a good place to start.](https://www.ultraedit.com/support/tutorials_power_tips/ultraedit/scripting_engine_tutorial.html)
Sublime text 3 build 3083
For real, though. That font's sexy AF.
I’ll ask the graphic designer who did the cover.
Really? How do you access such an app? Surely they aren't serving http requests from their database. Edit: Thanks for the downvote, but that wasn't a rhetorical question.
I try to keep a habit of having js-* class on anything I need to target with my js. For example: &lt;ul&gt; &lt;li class="js-list-item"&gt;Some list item I need to target&lt;/li&gt; &lt;/ul&gt; &lt;button class="js-some-trigger"&gt;Some button&lt;/button&gt; Of course, you never assign any css to those classes, so that you can easily attach them to some other DOM elements (for example you could easily swap &lt;button&gt; for &lt;a&gt; and you wouldn't have to change a thing in your JS). In the end, you can't write a 100% flexible code without writing a relatively bad code, at least that's my opinion.
this is purely anecdotal.
PHP Storm here. 
How about YDKJS
[Nuclide](https://nuclide.io/)
I'm using Sublime Text 3, I've tried Atom and VSCode and they both seemed very slow to me, I love the responsiveness of Sublime Text and I don't need the extra features available in other editors, so I don't see why I'd change.
I end up using vim for JS, HTML and CSS and PHPStorm for PHP. As far as I know vim has nothing similar to the "Ctrl+click" thing which is (for me) a critical feature
VS Code or Webstorm/PHPStorm
Interesting. Looks similar to Atom. 
gvim or the cli version? 
TL;DR Sublime Text 3 Sublime Text is perfect, extremely fast, awesome package control Atom is good for everyday use VS Code is quite good but worse customization than atom / sublime WebStorm / Netbeans / Eclipse are really good but large and slow VIM never used, looks extremly efficient... I can recommend Sublime Text 3 because the workflow feels right, it's really fast and there is a large community behind it. You can achieve the same with it as with other full IDEs. Can highly recommend sublimetextbook.com and every post from @wesbos
I use both, but I use the terminal version probably 90% of the time.
VS code. It's phenomenal. Tried atom recently because they have an elm extension I'd heard good things about but ended up switching back the same day.
Lets address the elephant in the room... Atom
You may need to wait until the page loads before showing the second alert.
I've tried that--same result. Did a 5 second wait at one point
I laughed loud at this one! :D
I used BBEdit for the longest time (mid-90s to mid-2000s) because it had excellent HTML and scripting support with integration for all sorts of developer tools like CVS, Subversion, make, plus hooks for developing your own shortcuts and scripts. Excellent multi-file search, excellent diff/file comparison tool. Just a great editing environment all around.. Then I got sucked into the TextMate vortex, which has its own strengths and peculiarities. Nowadays, I'm almost entirely in a command line prompt or vim/MacVim. I feel like I have more control and command over my programming environment than ever, am more efficient than ever. My general advice: stick with something you like and learn it inside and out, but also take time to learn other tools. Been programming since the '80s.
JS before ECMAScript 5 will always be around for a long time; JS built to be backwards compatible pretty much ensures this. 
I don't understand how this would work. If you navigate away from your page, how will your JS execute? If the website you are trying to access is the same domain as your script, you can use an iframe, but otherwise the browser will prevent the XSS. Alternatively, your JS could build the request that the form would be submitting so you never actually need to navigate to that page.
Eclipse Neon FTW
it kind of does, but it's not worth mentioning, because compiling the whole thing can take up to a minute or more, and a moderate size application in Extjs in obscenely large, in the range of 6-7 megabytes before minification, and over 2 megs after it. you don't always have to compile to a single js file, you can edit file-by-file if you want, and load files on the fly, but again, with a moderate size application , it starts get really slow, since it'll be hundreds of request before you get to the start main screen. Just stay away from, you'll hate it.
That's a good point, I guess it wouldn't. I'm new to javascript and the limited experience I do have is with node, not html. I will actually need to submit data to multiple firms as part of this process, so I'm not sure your suggestion would work. It sounds like html probably isn't going to work for this
luke wagner (one of the wasm leads) said back in June that js -&gt; wasm isn't possible because wasm lacks a garbage collector. [here's the full talk](https://www.youtube.com/watch?v=RByPdCN1RQ4) if you wanna check it out.
Good read! Thank you. Unfortunately Github always said that they were working on performance but it hasn't really improved at all. At least not noticeably in my experience.. 
Thats true! The lack of performance is a no-go for an IDE I want to use every day...
Does anyone know where to find the response article to this?
It only gets wilder from here on out ;). Buckle up.
I'd encourage one to read more current books first before reading a book like "Speaking Javascript", which covers many techniques you simply no longer need with ES6. In particular, "Secrets of a Javascript Ninja", 2nd edition - coauthored by John Resig, has been a fantastic and up to date text I've thoroughly enjoyed. It's very similar to YDKJS. Some topics are covered more eloquently in the former than the latter, and vice versa. Read both and you're set. Remember, JS has changed a LOT in the last few years. Read current texts and learn techniques to make your life easier.
Kyle Simpson and John Resig have written excellent JS books which I consider superior.
&gt; https://kangax.github.io/compat-table/es6/ Chrome 97%, Edge 93%, Firefox 92%. How about &lt;=IE11 ? Safari ? Mobile browsers ? None of all browsers support es6 modules or tail call optimization. I guess you are fine to use es2015+ to build desktop applications on electron or node-webkit, but not the web. 
VSCode. I used to use Atom, but stopped because of performance issues—mainly crashing when opening a large text file. They’ve most likely fixed the issues, but I haven’t needed to switch back.
Why it doesn't: Community size.
Yup, I almost forgot how to do basic `git` commands thanks to VS Code :)
Yes, what /u/jirocket said: ECMAScript 5 is fixed and remains the foundation of current JavaScript. ES6+ is covered by separate books.
I like Sublime Text 3 when making small projects and WebStorm for big and complex projects.
Hmm I was kind of underimpressed with its git intregration, compared to for example Webstorm or even something free like Netbeans. But maybe it has gotten better lately.
Nice ASCII art in the page's source code. The tool locked up when I attempted to minify this code: https://github.com/prettydiff/biddle/blob/master/biddle.js
I just updated to the most recent version and the syntax highlighting issue from a few months ago seems to have been resolved. Ignore the build number now.
I've never really used those IDEs, but I can imagine they handle it nicely. My git needs are relatively simple since i'm the sole dev on most projects (so mostly just need a quick/easy way to commit changes with a message and sync with the remote origin). I was mostly comparing VS Code to other simple editors like Brackets and Atom, which I felt had confusing/annoying Git plugins.
New update, see first post.
JetBrains IntelliJ based IDEs are awesome. My only gripe is the artificial limitation on language support. Sometimes I have to read PHP in a Python project, they won't even highlight it. IntelliJ ultimate can do any language.
How is the performance of JetBrains IDEs compared to those mentioned in OP? 
I like [Eloquent Javascript](http://eloquentjavascript.net/). Mostly you should decide on a project and attempt to complete it.
Best I can come up with is that: var x = 1; ...**is not** an expression, while: x = 1; ...**is** an expression.
How long will it be free online for? 
Recently moved from Jetbrains IDEa (Webstorm, Rubymine, IntelliJ, they're all the same in this case) to VS Code because of its TypeScript integration and overall performance. The Jetbrains IDEs are so slow with TS that they are essentially worthless, while VS Code is just fantastic. This combined with the vim plugin is great.
Hopefully this helps: http://codepen.io/anon/pen/mOEmXr?editors=1010
Tip: Create a link on your website to the actual git repo. My guess is people aren't bothered looking for it manually (I barely did). For the lazy: https://github.com/cfv1984/html-require/ And put in an example too, I had to inspect your HTML code to look for the actual usage of this tool. For the lazy: ``` &lt;link data-import="./views/contents.html"&gt; ``` It requires [this file](https://cfv1984.github.io/html-require/views/contents.html) and replaces itself with the content of the request and sub requests. Cool idea, feels kinda native.
I like to make an image searching thingy: * make an input box * search some subreddit for images * display thumbnails * click on thumbnail to see full image in modal
Time to incorporate Babel into your toolchain. I've been using ES6 in production since before it was called ES2015.
Yes, [var introduces a statement](https://tc39.github.io/ecma262/#sec-variable-statement) so it's no longer an expression. 
Vim, terminal version. 
After trying Atom and Brackets, at home I use Sublime (worth every penny I paid). I'm using PHPStorm at work and love it.
Recruiters requesting explicit N years in X lang is the recruiter's failure. Polyglots are able to learn workflows faster because of the continuous learning.
Gah! Must have copied over it when I added the toggle method, and didn't notice (nor did the hundreds of people reading...hmmm) I'll fix that right now EDIT: fixed &amp; hopefully made that part read a little clearer with intermediary step. Thanks for catching that!
Whatcha got so far, homie?
here is what I have: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;title&gt;Username&lt;/title&gt; &lt;/head&gt; &lt;body&gt; First Name:&lt;br&gt; &lt;input type="text" name="firstname" id="firstname"&gt;&lt;br&gt; middle name:&lt;br&gt; &lt;input type="text" name="middlename" id="middlename"&gt;&lt;br&gt; last name: &lt;br&gt; &lt;input type="text" name="ln" id="ln"&gt;&lt;br&gt; grad year: &lt;br&gt; &lt;input type="text" name="gradyear" id="gradyear"&gt;&lt;br&gt; &lt;input type="submit" value="Submit" onClick="getUN()"&gt; &lt;script&gt; function getUN () { var lastname = document.getElementById("lastname").value; var username = ln.substring(0, 4); var firstname =document.getElementById("firstname").value; var gradyear = document.getElementById("gradyear").value; 
I've had friends try aswell, I've come to a solution that I'll layer 3 different coloured menus and cycle them with the buttons, hopefully I can that working! 
libraries &gt; frameworks
As a writer, how was your experience publishing with O'Reilly?
SQL is most definitely a programming language. It's even [Turing Complete](http://stackoverflow.com/questions/900055/is-sql-or-even-tsql-turing-complete).
Hehe.
Thank you. 
Looks like you're on the right track. Where's the rest of the javascript?
Nice! So... here's how I put it together: http://codepen.io/anon/pen/YpWxVR?editors=1010 I put comments in there, but please let me know your questions! And don't just copy. You won't learn that way! :)
A big +1 from me. Was gonna suggest the same.
NP, I will look at it some more. I maintain a little minifier/beautifier of my own at http://prettydiff.com/ If you ever have a question about beautifiers just drop me a line.
I was 100% Atom for a while but switched across to VSCode for the debugging and flowtype support. When you've got the right plugins installed, it's a brilliant editor. I've got a list of my favourite plugins here http://madole.xyz/my-favourite-vscode-plugins/ 
Atom in Vim mode. Great features with (for my purposes) mostly complete Vim keybindings. No macros, though.
I just fixed it, it is now minifying in ~2 sec. 
PostScript is Turing complete too. That is a necessary but insufficient condition for a programming language. In any case, this is a boring matter of semantics. The point is that it's perfectly reasonable for SQL not to be included in these stats, especially because in the kind of case u/reallyserious was talking about, it's far from the primary language.
msys2 / mintty / vim
Excellent. I had read other developer's experiences, and it seemed they felt either ripped off, or the publishing of their book was a mess. Wish I could recall where I read these stories.
Evil mode subsumes you!! Emacs + Vim &gt; Vim. It's unholy, but I wouldn't have it any other way!
I'd be interested to read that, too, but I like this. The JS community seems to have a strong preference for just hacking together libraries until you have something that works, so I really appreciate articles to highlight why an experienced team might go the other way. When a team has to ship quickly, I think that convention-over-configuration offers many benefits.
iOS 10, sure. But not every iPhone user is going to be getting the new phone every year, and quite a few can't or simply won't update the OS to the latest supported version for their phone, and are thus locked in to older versions of Safari. I'd say mobile Safari is worse than oldie because even in locked down corporate environments, you can still install chrome with limited privileges - no such love trying to install a modern browser on an iPhone from a few generations back.
Hey there! Made a couple adjustments to the site/demo. Is this better?
This is my setup, except I pipe the ts-node through to nodemon for automatic restarts and it works very well.
You're missing out on a lot of TypeScript definitions tho, which is what OP was most likely suggesting.
In vim that's `ctrl-]`, but you need to have a [tagsfile](https://andrew.stwrt.ca/posts/vim-ctags/) generated.
I just started learning javascript/jquery a few months back (html and css as well). Here's one of my projects.. www.ponymaxspeed.com If you're looking through your phone I recommend turning your phone sideways (portrait mode) and zooming out.
Thank you sooo much! I am taking a Computer Science course and I was struggling with JavaScript in particular, this is so much clearer than my instructor showed us. I can't thank you enough!
Did you evaluate Electrode?
Especially when 2016 is almost over and soon this article will look antiquated. 2016? That's so last year. 
X-Post referenced from [/r/reactjs](http://np.reddit.com/r/reactjs) by /u/sabakumoff [react.js based Projects that Welcome contributors!](http://np.reddit.com/r/reactjs/comments/5cvq4y/reactjs_based_projects_that_welcome_contributors/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
I usually use Atom but have been trying VSCode lately and am impressed with it. The performance is great, the ability to cmd+click to jump to definition is awesome. Themes are not great. Git integration is good (but I still use CLI and Tower out of habit). I'd give it another try.
No problem! Thanks again for the helpful read
 import math num = 600851475143 i = 2 limit = math.sqrt(num) largest_so_far = 1 while i &lt;= limit: while True: if num % i != 0: break largest_so_far = i num = num / i i += 1 if num &gt; largest_so_far: print num else: print largest_so_far Here it is in Python.
Thanks doc
I'm still a student, but I use Sublime Text 3 most of the time. Some classes have us using Visual Studio (more last semester than this one) As I was reading this thread I installed PHP tools in Eclipse. 
Perhaps, but they have to be manually generated unless your codebase is written in TypeScript. Since these files are generally not committed to npm, you'll be curating them in your application and ensuring they are compatible otherwise there's little point in using them. At least this is my perspective having never authored a project in TypeScript. I'd be interested in perspectives from devs authoring applications using React and TypeScript and what sacrifices in tooling, or otherwise, they've hit.
I switched from sublime to Cloud 9 (c9.io) but I do a lot of debugging.
It is built on top of Atom
Amazing stuff!
I don't know anyone that uses it but most databases can serve their stuff over http these days. Here's something random I just googled and know nothing about: http://postgrest.com/ 
The ui is very pretty but $19 for each additional user sounds very expensive to me. It would be great to have free plan for open source projects.
Thank you, doctor. Much appreciated!
I used to the Pixi Normal map plugin. But as you say I think it was made for 3.1 (I'm still using this one lol). But this code isn't tagged as "deprecated" should be compatible, maybe with more work: http://sinkingship.ca/springroll/components/pixi.js/docs/files/src_pixi_filters_NormalMapFilter.js.html What I know is that you need: - shader loading diffuse texture and normale texture - a light source to make it work I made last year a Ludum Dare game using lights just for testing purpose and it was pretty tricky to have something great. Also, everything without a normal map was displayed "normal". Hope this help. PS: also checkout issues on the github, branch dev.
You are blinding loving it without understanding my complaints
As someone relatively unfamiliar with either, why is that?
I love little dev tools like this! Nice work. I would move the processing client-side though, for a perf boost especially on large files, and to reduce server load/increase server capacity. Also, little style bug in Chrome, the footer moves up and down as you select Minify/Beautify.
OOP doesn't make much sense to me when writing UIs. Sure, it can be useful for business logic, but in my experience, just straightforwardly applying functions to a piece of data I need to transform works better. There's really no need to be creating class hierarchies for those functions and putting them as methods. Reusability of code is much easier when you just require/import it and call directly than through extension of a class. I would probably use OOP if I was trying to write a game in JS. But for my daywork-corporate web apps OOP is too complicated to get right.
Atom with the vim-mode package.
backgroundImage doesnt have a src property, you will just use var image = document.body.style.backgroundImage; if (image === "url('WiP-Blue.png')")
Thanks for the feedback, the selection process is fully automated by the way :)
Thanks! I have been doing JS for a little bit now, and recently started to pick up VueJs. I am wanting to expand into ES6. With your Exploring ES6 book, how much prior knowledge of JS do you recommend?
I had to allocate a lot of memory on a MacBook Air but now it runs fast for me.
I dont understand why you got downvoted. You're spot-on.
Use freecodecamp, they give great examples and you get to do challenges without much help. But it takes a while until you get to the harder stuff..
Most of them just seem to be there because they've left in the CONTRIBUTING.md from the boilerplate they used.
That's cool, but how is it hilarious? Edit: Oh ok, I kept scrolling.
Bkieshedding, a developers finest task.
No problem!
Libraries === a hand rolled framework. Hand rolled framework &gt; community tested framework? eh no
Vim is wonderful for editing text, but has a lot of frustration if you want to mod it to be more IDE-like -- autocomplete, syntax highlighting, go-to definition, etc. It's totally possible, and people do it, but it's a pain. Emacs is closer to an operating system than an editor and is HIGHLY extensible because it's written in a fully complete Lisp. There are plugins for Emacs that would be basically impossible in Vim. The consequence is that I get the best parts of Vim while running what is functionally an IDE in my terminal! 
I like [this one](https://raw.githubusercontent.com/dcodeIO/WebAssembly/master/WebAssembly.png) the best, because it has a clearly defined shape that is clear at any size. However, I'm not sure what it's meant to represent or how it relates to the project. And then there's [this](https://cloud.githubusercontent.com/assets/298127/7970659/70880d2e-09f4-11e5-9c7b-c2134ee7f483.png). Messy at any scale and completely meaningless. Also has that vague "swastika" aura to it somehow.
[This one](https://cloud.githubusercontent.com/assets/1779502/19870492/06f72e60-9f6e-11e6-8ce8-a17305a8b6c2.png) all the way!
OMG, I just highlighted A SINGLE PART from whole paragraph: An active repository should meet this requirements: * created or updated during the evaluated period, * at least one star, * at least one fork, * a size larger than 10 Kb.
Ember appears to have a very large, regularly updated (as-needed, I'd bet) typings file. I would be shocked if it wasn't extremely accurate. My experience so far is that 99% of the libraries I use have existing type definitions. For those that did not, it was simple enough to write my own. Benefits of TS greatly outweigh this issue, especially now that type defs are installable using npm.
TextMate2. Long time on the market, macOS native app &amp; works super fast. Supports all types of languages you can imagine. Maybe it's missing some 'latest solutions' from VSCode &amp; Atom but when you get used to workflow - you wouldn't want to change. https://github.com/textmate/textmate
I'm sorry if I should I understand what you mean but I don't. Is there any tutorial online on how to do this?
I liked the first one you mentioned but am not super keen on it for the same reasons. I think [this one](https://cloud.githubusercontent.com/assets/5701323/10919181/80b7e85c-8250-11e5-9f9e-f1c14e7f7f4f.jpg) is more apt but I am also a huge fan of [this one](https://cloud.githubusercontent.com/assets/1270425/20037158/9e0ad45c-a412-11e6-8e8b-157e9f387957.png) and love that it fits with the JS logo.
Eclipse Neon FML
 function keyDownHandler(e) { if (e.keyCode == 81) { var audio = new Audio('sound.ogg'); audio.play(); $("#button").css("background", "url(ButtonActive.png)"); $("#button").css("background-size", "10px"); return false; } } function onoff() { currentvalue = document.getElementById('onoff').value; if (currentvalue == "Off") { document.getElementById("onoff").value = "On"; $(document).keydown(keyDownHandler); } else { document.getElementById("onoff").value = "Off"; $(document).off("keydown", keyDownHandler); } } 
Wow! I can't thank you enough! That explained it extremely well and worked perfectly! I've certainly learned something new today aswell so thanks a lot!!!
Personally I like it because it's consistent, easy to vectorize (so SVG), and I like the color orange. I always thought it looked more like a shield. Which makes me think a sword and shield design where the handles form the W on the top, the edge of the swords form the bottom of the A, and the shield part visually fills in the blanks for both the W and the A. Something like this [http://www.freepik.com/free-icon/shield-with-two-swords-in-cross_717126.htm#term=shield with two swords in cross&amp;page=1&amp;position=0](http://www.freepik.com/free-icon/shield-with-two-swords-in-cross_717126.htm#term=shield with two swords in cross&amp;page=1&amp;position=0) But more fleshed out. Just a silly idea but I think it would look cool. 
Yea that is what I thought. It just feels dirty not writing OOP, but that is a weird trait I have here. Your argument sounds reasonable, thanks.
So, what's the deal with keystone? It looks like pretty interesting project. 
You can try to always read/review any library before you add it as a dependency to your project. This is also very useful for more experienced developers. For many reasons.
That's interesting, what don't you like about the HTML5 badge? I've never had a problem with it.
Actually lost it at [this one](https://cloud.githubusercontent.com/assets/416585/20234921/7f4bcba4-a839-11e6-919a-45858002cf3a.png) 
I lost it at [this one](https://cloud.githubusercontent.com/assets/3106496/19885875/b86c7e46-a029-11e6-9e26-eb4565e69f80.jpg).
While true, I was thinking more about SASS and CoffeeScript, the former of which is still wildly popular, while the latter heavily influenced ES6.
Pretty much all proposals use WA.
Not the same person. My problem with the logo is not the HTML one, but the cheap knockoffs for CSS and JS. Seriously, every time I see a CSS3 shield logo, the 3 has a different shape.
A lot of these logs have an uneasy fascist-regime feel edit: *logos*
These are brilliant 😂
&gt; It just feels dirty not writing OOP I know the feeling. It's really hard to write vanilla javascript in a clean fashion. Where do I put this piece of logic? Where to put this other piece of logic? Constant questions. I am mostly writing react these days and it's much easier there- just chop your frontend design into little reusable bits and make them components. Then sprinkle your business logic into them as needed. Alternatively if you're a Redux person, sprinkle it in your reducers. Sure even here you can make a mistake, but it's much more flexible than OOP inheritance hierarchies.
Yes, we know.
&gt; When did we decide that methods are complicated? They're not. I actually write most of my code as class methods. It's the inheritance chains that are complicated and totally not flexible. That's what OP meant when he asked right? because I don't see how anyone can be confused about the thing you're talking about.
I really don't understand why an API needs a logo.
It always reminds me of [Moses on South Park](http://southpark.wikia.com/wiki/Moses). 
I love [this](https://cloud.githubusercontent.com/assets/11630829/17126966/30a92d20-5302-11e6-8990-abbcac1a8234.png) 3D one. 
I could, I just chose not to. It has nothing to do with being sfw or being at work or school or whatever, I just prefer to self censor when possible.
They do have hot module replacement and time traveling debug (if you use redux as your store). https://vimeo.com/187938033
&gt; I don't see how anyone can be confused about the thing you're talking about. You'd be surprised. There's a trend lately in the JavaScript community where people don't distinguish between classes and inheritance, who regard *any* use of class the same as if you had abused inheritance in the worst way. And people who don't realize that "this" and input arguments are the same thing, who regard "this" as stateful and evil but other input arguments as pure silver functional bullets.
Hits home. Using methods and "this" should be more encouraged these days. 
Some pointers that work for me: - Program a lot! After 8 hours of work(also programming) i usually get in 2/3 hours of practice in the evening and am still able to be a loving father of 2. In a good weekend i spend my evenings coding, but i also take weekends off if i do not feel like it, find a balance. - Read books whenever you feel like it. I mostly read books about project management, scrum, lean, agile. Some recommendations are: clean code, the clean coder, the pragmatic programmer, The mythical man-month. They will teach you past mistakes so you can benefit from them in the future. - Get enough rest, 7 hours of sleep, minimum. Focus is very important and burning the midnight oil might be awesome when playing with new tech, it will bite you in the morning! - keep a journal and read it back once in a while, you will be amazed at how fast you will progress yourself. Make sure though you are your worst critic. - Do small exercises, called "katas" like so: http://codekata.com/ - Find peers to converse with about programming. - Allow peers to review your code and pair up when you get the chance. I put a lot of effort in staying relevant, but also follow my own commonSense (tm). I do not consider myself a rockstar programmer, cause the more you will learn about programming, the more you will realize how more much there is to learn
[Please.](https://cloud.githubusercontent.com/assets/416585/20234921/7f4bcba4-a839-11e6-919a-45858002cf3a.png)
Haha incredible
I made this on the back of rewriting my [Universe](https://bitbucket.org/cgraamans/universe) application.. which needed a complete overhaul, considering I wasn't using any standard frameworks at all (very disgusting, I know). For this I needed a quick Threejs AngularJS framework I could plug into my [sockey websocket service](https://github.com/cgraamans/sockey) to retrieve data for my little solar system simulation. I thought you guys could use something like this as well :) This bootstrap contains... - Ready-to-use Socket.io implementation of the [btford-socket-io](https://github.com/btford/angular-socket-io) provider. - A THREEjs renderbox - Automatic Raycasting - Use of rootScope object for storage of three objects and socket functions - Phonegap-ready by bootstrapping angular I'll include a better example and a downloadable .apk as well if there's interest for it. Edit: I welcome constructive criticism as well :)
You're right, and I thought about that shortly after posting... 😝
The four arrows just seem to scream at me saying `YOU! DO IT NOW!`
For me OOP comes in handy when I need to maintain separate instances of variables inside a function. With OOP I can use the "new" operator to easily do that.
After reading the whole conversations, I've tried spacemacs, but man, I can't stand it. I follow the SUCKLESS and unix principles always, and emacs is not an editor but a complete operative system. I want an editor which just is great at editing text, anything else. So I use a terminal emulator which is st from suckless, inside st I run [abduco](https://github.com/martanne/abduco) for session management, and inside abduco, I run [dvtm](https://github.com/martanne/dvtm) for terminal multiplexer, I use to have 1 main window which is in the left of the screen running [ranger](https://github.com/ranger/ranger) to navigate in an agile way through directories and files, and for text editing I use [vis](https://github.com/martanne/vis), which is a vim written from scratch, having native support for multiple cursors, the sam regex language, and other cool stuff. I has the 80% of the vims functionality but in around 1% of the vims code, it is amazing. In the rigth side I have 3 splits. In one I keep track of the Git repo, in other one I have the running server, compiler, or an extra terminal to connect to the database, and in the last one, I have a live linter. If I need extra terminals I can change to a new tag in dvtm where I can configure a complete new working environment with other layout, or I cann minimize other windows inside the multiplexer and restore them when I need. Here you have a link where you can checkout the layout http://imgur.com/a/YcJZh With that stack I have very little tools which do a single task very well and combine all them together in perfect harmony.
There are 1485 results for 'scroll' searching on NPM (https://www.npmjs.com/search?q=scroll). Was there no existing library to abstract this task?
Here's one way: http://codepen.io/lemmin/pen/mOrJLP
You mean [Master Control Program](http://tron.wikia.com/wiki/MCP) from Tron (1982)?
And now you know
I want to avoid iterating through the whole array to change the length property of each array. Is this durable?
Thanks for the feedback. I'll be adding that information to the README asap. The default Node.js image is very simple, you give it an entrypoint and it runs it. This is fine for very simple/small scripts but for larger projects you'll probably want something a bit more robust. The goal of NoDock is to provide a complete environment for your node project: Node.js service(s), databases, web servers, queues, etc. without requiring you to do all the "wiring" between the different services. You can still use NoDock for simple projects by using one of the examples or you can build upon them. I hope this clears things up :) EDIT: The README has been updated to include the above explanation.
That totally works, thanks very much for the help! 
It's a whole new language, having its own logo seems reasonable.
In JavaScript, if something is not a primitive, it is passed by reference. So if we want an array of arrays and then modify the inner arrays and have those values show, we can do the following: var arr1 = [1,2,3] var arr2 = [arr1] console.log(arr1.length) // 3 console.log(arr2[0].length) // 3 arr1.push(4) console.log(arr1.length) // 4 console.log(arr2[0].length) // 4 If you are wanting to affect all of them at once, I am not sure the best way to go about doing this. However, when dealing with pointers/reference/values, it gets really confusing and the words get jumbled up in the JS community ( at least in my experience ). Just know that if it is a data structure (array/object), it is a reference to that data structure, not the values of it.
someone hire this talent, quick
The examples given read the same length either way and are less clear with a new syntax. The pipe syntax is immediately understandable and fills a need, I just don't see the niche for ::.
Yeah, I am not sure it is actually possible without some sort of loop because arr.length is a value, not a reference, as /u/lemminman says below
&gt; The examples given read the same length either way and are less clear with a new syntax. The pipe syntax is immediately understandable and fills a need, I just don't see the niche for ::. Thank you for your feedback. Are you referring to the usage examples? (https://github.com/gajus/babel-plugin-transform-function-composition#usage-examples) It is not all about the syntax. * In the Bluebird example you are saving adding 31kb library to your bundle. In addition, you get to use native Promises without needing to write a custom implementation or needing to pollute the Promise prototype. * In the Ramda example, well, this just illustrates that you can compose any curried functions. Furthermore, inverts the order – first the input, then the operations (which is more natural than: list of operations followed by an input). It is very hard to write concise examples. I'd really appreciate if you could raise an issue on GitHub with your suggestions for improvement.
"By reference" in JavaScript is synonymous with "by pointer" in C++. So every JS object behaves like a pointer. var behavesLikePointerToObject = { n: 42 }; var length1 = behavesLikePointerToObject; var length2 = behavesLikePointerToObject; console.log(length1.n); // 42 behavesLikePointerToObject.n = 7; console.log(length1.n); // 7 length2.n = 3; console.log(behavesLikePointerToObject.n); // 3 That being said, you can't just assign one of these objects to an array length, because Array is expecting the length to be a plain number, not an object containing a number. Just like in C++ if something expects an int, you can't just pass an int* and expect it to work. To achieve what you're looking for, you'll probably have to implement your own method, called maybe "setSubarrayLengths(n)", in which you iterate through each array and set the length appropriately.
These are neat. On the same lines, I'd love to see an existential operator implemented by the same methods, eg `foo?.bar?.baz` instead of `foo &amp;&amp; foo.bar &amp;&amp; foo.bar.baz` Might be a good side project.
MDN [guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide) and [reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference). The [Rauschmayer](https://www.reddit.com/r/javascript/comments/5cvqia/javascript_books_by_dr_axel_rauschmayer_free/) books.
Thank you for taking time to look into this. I have considered writing an existential operator in the past. However, I have decided against, because I have learned that using types (e.g. Flow type) and abstracting getters/ setters drastically reduces the need for it. The only exception is working with external inputs (e.g. global variables). In such case, I recommend using utility functions dedicated for that purpose, e.g. https://lodash.com/docs/4.17.1#get
Interesting about the parameters, but I would think that the first parameter must be used, not the last, for example const {pow} = Math; const eight = 2::pow(3); // now nine
Analysis.
Jesus christ. Only one that should have a chance here, and even then, it's not brilliant. https://cloud.githubusercontent.com/assets/1270425/20037158/9e0ad45c-a412-11e6-8e8b-157e9f387957.png
This feels very XY problem: you're describing what you're trying to do in terms of your intended solution (using pointers) instead of just describing the problem you're trying to solve. What exactly are you trying to do here?
This induced much of the giggles. 
I think you have misunderstood the `|&gt;` proposal. It is more restrictive than `::` implementation – it forces you to use an arrow function every time you have parameters. In fact, you are using an arrow function in all examples above (you can use it with `::` too).
Gotchya. I'll take it to our website guru then. Thanks for your help. 
Every time you have *multiple* parameters, but yes that's right. My point was I like that approach better because then you can put the parameter anywhere† -- first, last, middle... doesn't matter. EDIT: Though... `|&gt; _ =&gt;` is some crazy punctuation. Terse is good, but this is approaching Perl-level terse. ---- † giggity
thanks for the link before my phone decided to go into autocorrect hell i found this http://www.midijs.net/ and was trying to figure out how to make it work without needed the file to be hosted on another server because i am hosting the webpage via github.io + my current code im trying to implement the file playing api with is here https://github.com/jfmherokiller/midi2spu it uses typescript but thats mainly so i can catch alot of my developing issues.
There are a lot of scrolling libraries that do different things, not all of which provide the utility to just determine how much the user has scrolled the page. Besides, I appreciate an article that zeros in on a specific task and how to accomplish it with just vanilla JavaScript.
Nice! Enjoy!
How would such a device work? Every person would need a scent producing device as part of their computer. Since scents are created by releasing vaporized products into the air this device would need a cartridge of scent producing products that would need to be refilled periodically. People hate refilling ink, they would certainly also hate refilling this cartridge. This technology doesn't exist because it creates more work than the problems it solves.
That's definitely the best one, but I wish he used the same typeface as the JS logo ([Neutraface](https://houseind.com/hi/neutraface)). [The binary one](https://cloud.githubusercontent.com/assets/5701323/10919208/a617cf7c-8250-11e5-9437-03077ec3318a.jpg) is great and has a lot of love in it, but the logo itself is a bit too thin and the concept, while really awesome, is too obscure and not as "useful" and immediate as the puzzle piece (or the badge one for that matter).
There has been research into smell simulation. It currently fails in a number of areas. 1. Unlike the RGB color scheme for images, or frequency encoding for audio, there is no set of "base smells" that can be combined to make a spectrum of all smells. A smell simulation device would need to have, on hand, thousands of chemicals in readily vaporized forms. This is impractical in the extreme. Imagine buying smell cartridges like printer toner, and then realize you need to buy hundreds of cartridges at once. 2. Real world devices that get over the first hurtle hit the next one: over time, the smell emitter starts to smell like a combination of every smell it has ever emitted. There isn't a known good way to keep smells from impregnating the device and surrounding area permanently. All those smells combined smell awful. 3. People psychologically expect certain smells to come from certain things. When you force all smells to come from one source that is clearly not natural, the person tends of react negatively, as if they are being sprayed with a chemical (which they are). I've experienced this on a Disney attraction with "real smells!" It was disturbing and gross. 4. All this and then you realize that most smells are subtle anyway. Only the really strong smells will be noticeable by most people. And what smells are the most strong? Blood, death, decay, harsh chemicals, smoke, biological waste products, skunk spray, and pure cooking extracts like vanilla. Most of these are simply unpleasant. Even if we could build the technology in a practical way, it might just be a solution in search of a problem. 
VueJS. I started using it recently (quasar framework specifically) and it's awesome! I got tired of people drooling over it and decided to see what all the fuss was about. Definitely my favorite thus far out of 8 years of web dev experience (I've built apps of every size with angular and backbone, tinkered with react). I recommend Rekord for the model library. I might be biased on that one.
My vote is for a cute cat.
Pretty unfortunate that the JS community can't decide on (fn, collection) or (collection fn). Seems like the arrow function is an advantage here.
Those WebAsses... 
&gt; running over a deer with your car, effortless. More like the the body comes crashing through the windshield and kills you.
Thank you!
Eric Elliot is a couple of years late to the "Intro to Node &amp; Express" party isn't he?
https://vuejs.org/2015/10/28/why-no-template-url/
I see, thank you for the pointers!
The best part is that you're probably right.
I think your logo is good. Actually, this would be a neat logo for some corporation. But not for a programming language. In my opinion, a programming language needs no logo at all. *This post has been heavily edited. Execuse my harshness in the beginning, i'm prone to that*
“[Speaking JavaScript](http://speakingjs.com/)” – if you already know how to program.
Why any language would need to have a logo? I mean what's the frigging point, are you trying to sell it? The Assembly does not have a logo, nor does C, but it's used everywhere. Ruby is a good programming language not because it has a fancy logo, but because it's a just a good language.
MOAR
Wow, that's hot. I think I got a [boner](https://cloud.githubusercontent.com/assets/14282874/14588957/1611592a-04d7-11e6-887a-6a8f003f5a96.PNG)
Sorry bro, I fooled you. It wasn't that simple. I actually deserved them downvotes. It's just that I overreacted in the beginning, and realised that that was too much, and decided to edit the comment. Thanks for cheering, though!
This. I've learned more from programming my stupid Tic-Tac-Toe game and a Javascript calculator than I have from solving algorithms and other stuff. Granted the algorithms helped me come up with efficient solutions, but experience &gt; theory.
So much awesome mathematical magic going on there. Thanks for sharing!! 
&gt; I don't get why people code their code. It seems to me like writing a &gt; script which writes the script.. I don't get you at that point. I mean, I don't understand the relation between people coding their code and the editors. If you mean that you don't understand why do people work very hard doing scripts for customize their editors, I must say that I don't understand either. Well, actually I can understand because I used to be that guy. But you start to read about editors, and start to try them, so you end choosing one of the most popular ones. In my case the interface was critical, and the vim modal system conquered my heart. But suddenly you see that for edit files you need to open them, and for that a file manager is a great option, so you start to search for that functionality that you want, and you suddenly land in the world of plugins, so at the end you are transforming an editor into an IDE, and to achieve it, you are messing lots of modules and things that don't belong to a editor!. Finally I asked my self... Man what the fuck are you doing. You have a .vimrc file with a grazzilion lines, most of them I don't understand why the fuck they are there (your vimrc won't never be yours, it will be a Frankenstein from dozens of others vimrcs). So I decided to stop and to find an editor which keeps the vims user interface and editing features, but without the whole non essential capabilities vim offers. I tried sandy (which is really amazing, but lacks in editing features, for instance, it hasn't the f - character command which is like 'go to the first occurrence of character in the current line from the current cursor position- and other ones which I use frequently). Then I tried kakoune, which key features are async edit and multiple cursors, but It is very verbose. And finally I fall in love with vis which I combine with small tools for file browsering, lint and so on. 
Linux is better compared to either mac or windows for coding, but keep in mind you wont get adobe support so for design you'll either have to get a new toolset that's compatible (gimpshop + krita + inkscape) or you may still want to dual boot windows. If you're still set on 1 OS only and/or you can't live without adobe make sure you install cygwin + bash on windows.
Nice!
I have recently tried developing on Windows, and I feel like if you want to take the time to learn a new system, by all means, do it. However, I think going to Linux for web design may not be the best move overall. People use Mac and Windows to make things easier for a reason; however, take this opinion with a grain of salt because I have very limited exposure to a Linux system.
The design is terrible. Just use a normal layout, the buttons around the face is just bad UX. You may want to use "Reset" or "Clear" instead of "AC" and "C." You should add keyboard support.
&gt; the second parameter is also often optional, which makes it even weirder to put it upfront This is a bigger problem. Using functions with optional parameters makes any kind of function composition extremely hard. &gt; also lodash map for example: Lodash was designed to appeal to the JavaScript developers. There was no consideration for FP at the time. The lodash-fp came into the game a lot later. I therefore encourage to distract yourself from Lodash and focus on http://ramdajs.com/docs/ and https://github.com/lodash/lodash/wiki/FP-Guide when evaluating a proposal thats primarily aimed at FP and function composition.
This got a lot of retweets for something as rudimentary.
Seems like I can understand the majority of whats going on there, maybe not full use case for it all. But I know what its doing. Do you books include mini projects when something is built using what you have said, or challenges?
React, Angular2 or VueJS
If you are on linux, use your package manager to install it, else go one this page (https://nodejs.org/en/download/) to download it and follow the steps It's pretty easy :) 
Scented spam is going to be so bad.
Maybe you don't want to look at the "better", but the most popular in what you want to do. For instance where I live, most startups uses React, while bigger companies are more angular oriented (most of them started with Angular 1 and continued with the second version). So take a look at your market and see what it wants / do. Personnaly i really like Vue, but there is no job in Vue anywhere so i only use it for pet projects and freelance work.
Is there any need to be so blunt? I was just giving an example. Drawing from my own personal experience, I've written [one game using composition](https://github.com/jamesseanwright/glitch-hunt), although it cuts a few corners as it couldn't exceed 13 KB when built; I found that using [ECS](http://www.richardlord.net/blog/what-is-an-entity-framework) allowed me to share logic trivially between unrelated entities, keeping my code very DRY.
I used this to learn Verlet integration. The guy is awesome
&gt; Is there any need to be so blunt? I was just giving an example. Sorry, I didn't mean to come out as blunt. I do think purely functional is absolutely a valid path, even for writing a game. I merely wanted to rebute your claim that using inheritance is one of the worst things you could do.
Too late.
I loved VS Express (I still do!) but it is not appropiate for coding Javascript, CSS and HTML - a massive amount of memory allocated, so many stuff loaded you don´t really need.... VS Code was a waste of time. I loved Brackets, a bit slow maybe but it was cool enough for my daily routine, but after an update, a couple of shortcuts I used all the time, changed and I simply could not recover from that :( I tried Atom too, but its avant-garde layout design became a massive mess for me. Also when trying to install packages was a "never-ending / behind a corporate proxy" nightmare! I go for Sublime Text 3. I´ve been using for several years so far so good.... small, faster and with a predictive behavior.
It's never too late with the [help of hackerman](https://kungfury.vhx.tv/updates/hackermans-time-hacking-tutorial)
Care to explain what you missed in VSCode? Or better what you disliked about it?
Combine that with [Hacker Typer](http://hackertyper.net/), and you have a full-fledged hacker on our hands. Hold on to your private keys boys, he's going to come at us full force.
What size does it reduce to when you bundle with `NODE_ENV = "Production"` ?
Big thanks for that link, now I can pretend I'm a real professional
Learn JS2015/16 and it's differences with JavaScript. Compare code written in one language with similar code written in another. Look at the process the author has taken and the design decisions they've reached to arrive at their solution. Stuff like "Favor composition over inheritance" is amenable to google - but in the context of JavaScript as it's used today, it's not worth bothering about unless you plan to work on other languages/tools.
WAT
what is your OS ? You don't need sublime for node.js, you can write code with what you want For the moment you just have to install it on your system If you are on Windows, the installer is a GUI so, just follow the step And if you are on linux or mac, you can use your package manager to install it To test if the installation is ok, open a terminal and write the command: &gt; node - v And if you have an output with a version number it's ok, else the system tell to you that he don't know this command 
Does it depend on jQuery?
take a look on this https://www.smashingmagazine.com/2016/08/a-beginners-guide-to-progressive-web-apps/ 
X-Post referenced from [/r/frontend](http://np.reddit.com/r/frontend) by /u/wayspurrchen [Gist of React/Redux links I've gathered over time](http://np.reddit.com/r/Frontend/comments/5dabtj/gist_of_reactredux_links_ive_gathered_over_time/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
* We hit so many bugs with the tooling. * So much stuff was undocumented. * We found many decisions questionable... "easy-webpack", aurelia-cli not going in a direction where it feels like it'll ever be able to create decent production bundles. * On one *very* important issue Aurelia devs claimed there was no problem, we later found out what the problem was on an angular 2 mailing list. * When we contributed a fix to one of aurelia's libraries it had to be added in four places due to cut and paste coding... it wasn't pretty. * In the year we used it, Aurelia wasn't able to synchronise an array content with the view properly. At first it was dreadful one of our patches made it happen much less frequently. A second patch came a few months later that improved things further still. But there are still many situations where the view can desync with the array. Our Aurelia website is about showing posts in order of score, the whole time the posts have been out of order (but at least now there aren't duplicates!!).
"This is actually really good", I said to myself while reading this. How often does that happen?
It depends on the tool set really. I've only done 'real' development on Windows. I've worked with Mac before for very basic web dev. In my experience the things I reach for are available. Node, task runners, VS Code (Or Atom/Sublime), etc. You might have a need for something odd, but I've never had any issues in the entire time I've been developing anything. 
Vraiment clean, I love it 
This is great. Thanks for sharing. I really like getting back to vanilla Javascript and utilizing its powers.
I don't get the hand-wringing. I find that first example perfectly normal. My team and I wouldn't bat an eyelash at it and nobody would think it deserves a comment. Also his example of the "hard to read" reducer is hard to read because of shitty formatting, not "fancy" code. This syntax is definitely tricky when you first start using it, but it's been around for how long now? 2 years?
His second example is better to make his point. However, the [first example](https://mobile.twitter.com/WickyNilliams/status/798497274653503488/photo/1?ref_src=twsrc%5Etfw) serves a clear point that he completely misses. There are many times where we would like to assign the value of child properties to a variable but a property in the chain doesn't exist. In es5 we have to wrap the assignment with a try/catch or an error will be thrown. Destructuring solves this problem, which is what's happening here. Edit much later: I are dumb. Yeah I forgot about needing to use default values. I don't think I the creation of the temporary object is a big deal in most situations. It will be garbage collected fairly quickly. 
Vue jobs exist. There's a website devoted to it. https://vuejsjob.com/
Great write up. A few more points: Naming your variables a,b,c,d is not clear. Pick descriptive names. If the variable is holding a boolean I like to name the variable something like 'isEqualOperator' or 'isAllClear'. A name that suggests what the boolean represents. Another recommendation would be to name your event handlers in the normal camelCase that you have all your other variables in. OnButtonDown would be onButtonDown. One last thing... Your event listeners could be rewritten from: button[i].addEventListener("mousedown", function() { OnButtonDown(this) }, false); to: button[i].addEventListener("mousedown", onButtonDown); and the event handler would be: function onButtonDown() { this.style.fill = "rgba(74,144,226,1)"; numberToArray(this.id); }
"Jāas makes learning the fundamentals of things seem like the Grunt of 2016." I laughed.
Try writing easily readable, highly maintainable, well decoupled, short code. Some of my function libraries on complicated projects can grow to like 1-2 thousand lines. 
I think the term you're looking for is "expression parser". Math.js supports this with math.eval()
For instance: [lambda abuse in Python](https://github.com/csvoss/onelinerizer)
&gt; when all the newest features are combined ... just for (some definition of) fun.
Do you guys know any other cool YouTube programming channel?
Seems to be working for me. What's broken for you?
really cool! thanks!
This is so broad...
Maybe you could initiate trackLength to zero so you don't end up with an undefined track percent 
A new tool or library in Javascript? I don't think I can handle another one.
Yeah I was wondering if it would be a huge hassle to Reactify this.
Useful https://github.com/benoitvallon/computer-science-in-javascript
I use it and love it. It's probably the best UI library for Vue - very good code quality, look and very active (my issue was solved in hours). Great job! 
Since you have Angular experience maybe check out vue. You already know directives. Especially learn the component stuff (try not to avoid it). Then you can check out Angular 2 if you want to. It is all becoming very closely related. I wouldn't be surprised if we have a clear best in class winner in a few years. 
Huge downvote for this. Don't post garbage like this on this subreddit, please.
This is an amazing idea. In fact, I've been working on a concept for this exact feature. It allows developers to specify scents that the users experiences when they visit their website, using a simple API that looks like this: new WebScent({ 'sandalwood': 0.35, 'lavender': 0.65 }) Its really a spectacular piece of technology and I think it could change the world. If people are interested in more information, I'd be happy to provide a link to my blog where I talk about building it.
I can't tell if you are joking.
Why is that better than just let inputClass = manager.options.inputClass;
When it comes to software, something is only "bad" if the person paying you thinks its bad. If they think its good or they don't care, then it doesn't matter! One of the things I love about working in software is that no one gives a shit. Makes slacking off on the job very easy
Why? It's not going to make the code any clearer or work better.
When you complex do you mean graphics intensive or lots of business logic? If you don't need graphics, check out Ionic which uses Angular under the hood.
&gt; We’re pretty sure this is the first real object database for Node What's the difference between document and object in this sense?
How did you go from soren to sqren?
Hi /u/TechnicianApp, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). Thanks for your consideration!
In that example, it's not a huge gain. But it can be helpful when you're destructuring more than one property, e.g. ``` const { inputClass, outputClass } = manager.options; ``` which in ES5 is an extra line var inputClass = manager.options.inputClass; var outputClass = manager.options.outputClass;
It's not really for that case. You see the advantages more when you want to pull multiple variables out of an object without redeclaring them over a bunch of lines. I use it all the time with React state and props.
You don't have to repeat the option’s name. IMO this makes it easier to immediately see the intention: you just take it out, you don't create an alias that could or could not be banned differently.
 const { inputClass } = manager.options || {} If we reasonably assume that `manager` can be assured to be an object beforehand, while `options` can only be `null`, `undefined`, or an object, and the first two cases mean the same as an empty object.
What's a "while number"? [edit] oh you probably mean "**whole** numbers". That works right up until you need to do division.
This is really awesome.
What does your code look like? It's tons easier to help when we know what you've already tried.
Rather than filling onbuttondown, use css and :active, unless there's some limitation I don't know of
Interesting post
&gt;I’ve never actually sat down and read the docs. And people wonder why they struggle so.
Say waaaaat. This looks amazing. Good job.
Kind of amazed that [Leaflet](http://leafletjs.com/) isn't in this list..
Order doesn't matter. If "foo" is somewhere in there AND "bar" is somewhere in there, it should match! &amp;nbsp; **So yes:** "foo bar" should match "foo xyz bar"! **And yes:** "foo bar" should match "bar xyz foo"!
In that case I'd probably do as you said, and test each string with `indexOf`, e.g. function matches(text, search) { return search.split(/\s+/).every(word =&gt; text.indexOf(word) != -1); } You'd probably want to lowercase both string first (or ideally do actual case folding, though I don't know if JS supports that properly.)
Thank you. Element looks cool. I'll try it. 😇 // I want to learn Chinese but It isn't easy haha 😂 
Okay, will try! While waiting I tried a few things and made a working code. Sadly, I feel like this is completely wrong and there is a much easier way. How would I check the key for multiple conditions, if I dont know how many keywords the user entered? I can't just use: if(key.indexOf(searchArray[0]) != -1 &amp;&amp; key.indexOf(searchArray[1]) != -1 &amp;&amp; key.indexOf(searchArray[2]) != -1) {} This would fail, if there are only two keywords entered. &amp;nbsp; **Her is my super sketchy workaround:** searchArray = "julia hunt".split(" "); var people = { "maria julia hunt" : 25, "katy lee brown" : 36, "peter steve olsen" : 45, "yvonne julia hunt" : 12, "peter griffin" : 40, "penelope june west" : 8, "julia sarah roberts" : 38 } for (var key in people) { var match = 0; for(i = 0; i &lt; searchArray.length; i++) { if(key.indexOf(searchArray[i]) != -1) { match++ } if(match == searchArray.length) { console.log("Match: " + key); } } } &amp;nbsp; How should I go over the conditions if I don't know how many there are? --- Edit: --- Well ... your code seems to do exactly this. Even tho I don't understand how it works. Full code: searchArray = "julia hunt"; function matches(text, search) { return search.split(/\s+/).every(word =&gt; text.indexOf(word) != -1); } var people = { "maria julia hunt" : 25, "katy lee brown" : 36, "peter steve olsen" : 45, "yvonne julia hunt" : 12, "peter griffin" : 40, "penelope june west" : 8, "julia sarah roberts" : 38 } for (var key in people) { if(matches(key, searchArray)) { console.log(key); } }
A document store is like a key-value store where the values are the equivalent of JSON documents. While the documents can contain elements that you in principle can deserialize into objects, that is not the main purpose, and it limits relations only being within the document, and even there to only parent-child relations (so all relations shape a single hierarchy). An object database stores objects that can have arbitrary relations with each other, so in this sense it is closer to relational and graph databases. But the main defining feature is that the objects are *live*. You can get any object from the database, and follow its relations to other objects, watch it for changes, update it, and in general work with it as a regular object, even though it is simultaneously persisted and may be shared with other apps or processes. 
You *know* the JS ecosystem is in bad shape when the joke has gone over most of these commenter's heads.
My example uses [`Array.prototype.every`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every) which takes a callback which it invokes on every element of the array, and returns true if all of the results were true, otherwise false. If you want to do it with an explicit loop, the easiest way to do that might look like: function matches(text, search) { let terms = search.split(/\s+/); for(let i = 0; i &lt; terms.length; i++) { if(text.indexOf(terms[i]) == -1) { return false; } } return true; } In other words, you can bail out the first time you find a non-matching term, because there's no point in checking the rest since a match requires all terms to match. This is commonly referred to as short-circuiting. If you reach the end of the loop, then you know every term had to have matched, without having to keep track of the number of matches. The nice thing about `Array.prototype.every` is that it also implements this short-circuiting behavior for you — it won't do extra unnecessary work. 
Ah. This makes perfect sense! Thanks a lot for the explanation. Will google a bit about this. Will find more usage for this, I guess! &amp;nbsp; The last code I posted above works fine for me! Thanks for the help, the code and the good explanation on everything!
- Solving problems you don't have is useful only when you're very sure they will appear in the future. Here it appears you haven't even considered it. - You're mixing the old and the new way of doing things. Why solve a problem in two ways, when the first can take you all the way? - It's still less readable. Not as a matter of familiarity, but of fact: more syntax noise, information is out of order, the latter even more so due to mixing paradigms.
I was 100% sure, before reading the comments, that the top comment would provide some "support" then reach the conclusion: &gt; This is nothing to do with ES6 and just about writing clear code. Well, what you've done is mix the old and the new way of doing things, blunting the cons of each but not reaching anything optimal. How is it "clear code" when a three-part lookup is written in the order "3, 1, 2"? How is replacing a single character of syntax noise with two, plus two more spaces, clean code?
How is this not OO? Just because you're not using the "new" keyword, custom prototype chains, or ES2015 classes, you're still returning an object that has methods and private data. I find this question silly because you can't not "do OO" in JavaScript. DOM elements are objects, strings are objects, objects created with object literal syntax are objects... 
You wouldn't be able to do this in C++ either. As you said, "length" is a property - not a field or a straight up piece of data. When you set the length of an array, the setter gets invoked, which is a method on the array object itself. You _have_ to loop though each array to tell each array to change its length, because to change the arrays' length, each array has to internally allocate more memory to support that new size. To put it simply, setting the "length" to a new value does nothing in and of itself, each array also has to allocate new memory. Which is why "length" is a property with a setter, instead of a simple field. So having pointers would make no difference to anything. Just do this: arrays.forEach(a =&gt; a.length = newLength); And you're done.
*learned*
this is amazing
Thanks for that, I appreciate it greatly. I came across this, however I didn't investigate much further from their landing page. 
Unsure if this is the type of thing you are looking for, but I've enjoyed using it: https://github.com/cssinjs/jss
Thanks that seems like a good explanation
Except in this case I question the reassignment in the first place, rather than just direct usage of manager.options.
Mixing paradigms is NECESSARY if you want clean code. Doing everything as pure OO or pure functional makes you go out of your way to set up a lot of boilerplate that 10 lines of procedural code might be able to handle just fine. I am always mixing and matching procedural, OO, and functional (and sometimes reactive) code depending on which will produce the best combination of readability, understandability, performance, and maintainability for the problem at hand. Don't be a hammer coder. It's not healthy.
I'm not.
[Yandex.Maps API](https://tech.yandex.com/maps/) is missing.
Sorry, but no. Unless performance criteria is absolutely paramount and you literally cannot achieve the effect any other way, then code readability and understandability are the two most important considerations of any piece of code (where security is not a consideration). Code cannot be maintained or easily debugged if it's not readable and understandable. I deliberately "de-optimize" code when I find it's unclear as it was written. Clarity is king.
Exactly - came here to say this about the reducer example. This article was incredibly biased to make a point by bad example. Everything in code was incredibly exaggerated and could have been perfectly fine if approached similarly as his "better version". Use ES6 to make your life easier. Not harder. ES6 on its own doesn't make your life easier or harder - it's you as a developer who decides what direction it will take. 
I'm quite interested in using this for a few projects. When I installed it from npm, I noticed that the total size is about 35MB. Of that 35MB, it looks like about 20M is Android-related. For React Native, I guess? Seems like a lot of stuff that isn't strictly necessary for a conventional Node app.
Leaflet and OpenLayers require OpenStreetMap and an online connection which kind of sets them in their own category. A service is somewhat different from a library. I believe the author was aiming for JavaScript libraries where you provide your own map data, or it's embedded in the code.
JS trying to be more like PHP
That right..I just tried to point it out that the original reducer's code produces larger output and works slower than the modified code after transpiling both of them to ES5. And reformatting of the original code does not solve perf/size issues. 
The last line is great. I want that. In the meantime, if you use lodash, `_.get(manager, 'options.inputClass')` is great.
it's style. It shouldn't matter. The only thing that should matter is the logic.
What are their best courses iyo?
Considering this is new, they may have not considered turning it into a tiny self contained package. Maybe someone should notify the author.
I was trying to be sarcastic in that sentence, but apparently this attempt failed :)
I agree that one can write confusing/poor code in just about any language out there. Absolutely. BThe main point of the article was in that using new JS features blindly may cause the significant problems, not with readability, but with the script size and the running time of the code after it’s transplied to ES5. And it has to be transplied because it’s using ES7 features which even not in the specification.
The first example is just the prelude to the article..the reference to the source that inspired my to write a blog post..But again, I now understand how poorly the article was shaped, so I understand your point. 
That's no broad, she's a service.. and she's class-y!
&gt; this is a great **non-existent** solution to a non-existent problem FTFY
burn
 (lambda __builtin__: (lambda __print, __y, d: [[__print(d.x&lt;d.y&lt;5) for d.y in [(4)]][0] for d.x in [(3)]][0])(__builtin__.__dict__['print'],(lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))),type('StateDict',(),__builtin__.__dict__)()))(__import__('__builtin__')) What the fuck? 
Idk I feel it's easier to learn java than JavaScript 
The description is nice and I agree that Meteor has good enough features to gain more traction and become an ideal Javascript development platform for many.
I can now see the source of confusion..it’s in the name of the article. I figured it out that it has strongly negative connotation. Native English Speakers explain it to me : http://english.stackexchange.com/questions/358771/its-good-until-its-not-expression But I don’t think that ES6 is horrible, believe me. I love it in fact. But I can see that blindly using each and every new feature may cause significant problems and I tried to describe them.. The name of the article should have been something like “Repercussions that you may face after using too much of ES6 in your code”
Because `map` is meant for producing a new collection by transforming an original collection (every iteration it adds the return value into a new array that becomes returend at the end). Even though it iterates over an array and can be used as a for-each, it misrepresents the developer's intentions, and does things under the hood with a new mapped array that never gets used. Here he should just use `forEach`, or even better, restructure it as a pure function and use `reduce` https://github.com/davestewart/javascript-state-machine/blob/master/src/StateMachine.js#L94 var transitions = options.transitions .reduce((flat, tx) =&gt; flat.concat(this.transitions.parse(tx)), []) - `forEach` should be used for simple iterations - `map` should be used for transforming a collection of elements into another collection of elements. collectionA -&gt; collectionB - `reduce` should be used to transform a collection into a new value, or a new collection that cannot be achieved by `map` - `filter` should be used to create a subset of a collection based on a predicate Example: http://i.imgur.com/xjkcvPq.png
Yes, I do realize that it has nothing to do with ES6. I even renamed article to "ES6 is great, but use it cautiously" to better convey the main point of the article..
Can this integrate with realm for react native?
I mean, I wouldn't say I'm a javascript ninja, but I do write it for a living, and I've been using this syntax every day for the past 18 months now. It made me stop and furrow my brow for maybe the first month or two, like any new syntax or pattern, but after that it became second nature.
Wrong. Consistency matters. 
The [progress bar](http://codepen.io/Linuxdirk/pen/XNNJNK?editors=1010) is [supported in all relevent browsers](http://caniuse.com/#feat=progress). Styling is [a bit tricky but possible](https://css-tricks.com/html5-progress-element/).
I only browsed it casually. So the TL;DR is "don't overuse destructuring", right? Which is very good advice indeed.
Thank you! That's perfectly valid point for the bright future when everyone will use browsers that support ES6. We are not there yet unfortunately(f.e. In October 2016 the market share of IE9 is 6.36%).
I guess we all learned what it means to let browsers reflow &amp; repaint a 10k row table when Bootstrap is part of the equation. Though I think you're giving me too much credit, since this was already discovered by you guys [1] [1] https://github.com/mathieuancelin/js-repaint-perfs/pull/68
There's no backlash! No one is afraid of ES6. I don't understand the defensive responses to this article - it's not bashing ES6 or JS.
Yes, you can. Neither myself nor the article was implying that wasn't the case.
[Cesiumjs](http://cesiumjs.org/) is not on the list and should be. 
Your last suggestion sounds good for medium to larger-scale projects. At the moment I'm attempting to build a universal/isomorphic js app with create-react-app. The patterns I've seen for that architecture are single-repo apps, and for the code-sharing advantages of universal js to work, that's really the format to use. If anyone's interested, I got a lot from [Luciano Mammino's scotch.io tutorial](https://scotch.io/tutorials/react-on-the-server-for-beginners-build-a-universal-react-and-node-app) and [Tony Spiro's tute on Sitepoint - Part I](https://www.sitepoint.com/building-a-react-universal-blog-app-a-step-by-step-guide/) and [Part II](https://www.sitepoint.com/building-a-react-universal-blog-app-implementing-flux/)
Thats a domain of inexperienced programmers to make a code like this. Programmer path is quite weird, but well, so true for many of us: First you start declaring all variables in a list without overusing rvalues because it is too hard to follow for you as beginner: let type = req.query.type; let users = Users.allWithType( type ); let countOfUsersUpdated = 0; users.forEach( ( user ) =&gt; { if( user.needsUpdating || user.isFreshlyRegistered ) { countOfUsersUpdated = countOfUsersUpdated + 1; if ( user.updateCount === undefined ) { user.updateCount = 1; } else { user.updateCount = user.updateCount + 1; } } } ); return { countOfUsersUpdated: countOfUsersUpdated }; Then you start to feeling familiar and start to abuse "clever tricks" and write more shrinked code: return { countOfUsersUpdated: Users.allWithType( req.query.type ).reduce( (u,r) =&gt; { ['needsUpdating','isFreshlyRegistered'].filter( k =&gt; u[k] ).length ? u.updateCount = u.updateCount++ || 0; return u.needsUpdating ? r++ : r } , 0 ) }; Then you begin to write more complicated code, large enterprise projects. You actually stumble upon your "clever" you written six months ago and have no fucking idea what is going on here, spending time to just "decode" it, and then you edit your "dumb" friend code which is longer, less clever but hey, you need 5 seconds to realize what is going on here and why. So you are moving back to your roots, and start writing "dumb" code as you did before: let type = req.query.type; let users = Users.allWithType( type ); let countOfUsersUpdated = 0; users.forEach( ( user ) =&gt; { if( user.needsUpdating &amp;&amp; user.isFreshlyRegistered ) { countOfUsersUpdated = countOfUsersUpdated + 1; if ( user.updateCount === undefined ) { user.updateCount = 1; } else { user.updateCount = user.updateCount + 1; } } } ); return { countOfUsersUpdated: countOfUsersUpdated }; :)
Yep, we're not there yet. At least some of us. And probably the project where you took the code from since it is intended for a wider audience. But the project I am currently working has dropped support for IE9 and IE10 in january this year, at the same time that microsoft dropped support for them. But for a lot of projects out there the only problematic browser that still needs to be supported is IE11 that has only about 11% support for ES6 features. All the other browsers have over 90% ES6 support. The same is for server side (node is at 97%) and mobile. Once we drop support for IE11 you may even drop the transpilation step from your build.
Maybe you could pass the data as a prop from CompA to CompB.
I managed to solve the problem without having to change my components structure. The object that is loaded in CompA is passed to CompB as a prop and the default state has a property 'loading', when it finishes loading on CompA the property 'loading' changes to false. In CompB I added a componentWillReceiveProps and it checks if the property loading is false and if so I can retrieve the id from the props and load what is needed.
You mean like improve the language of our website?
Yes. It needs a tweak here and there. Always nice to get an edit. 
Most people are talking about smell simulation as a chemical thing - imo if it is ever implemented, it would be through brain manipulation rather than through thousands of refillable smell cartridges. 
One day I might be able to gauge what these benchmarks mean... One day. 
[http://www.raygun.com](http://www.raygun.com)
Can you not just copy the value and mutate the copy instead of all this?
Cool! One more question..the code snippet I shown in the article actively uses Object Spread Initializer(https://github.com/sebmarkbage/ecmascript-rest-spread/blob/master/Spread.md) which is not supported anywhere(http://kangax.github.io/compat-table/esnext/). Therefore if one uses this feature, the code has to be transpiled to ES5(or ES6). Do you leverage this syntax in the project you are working on?
Hi /u/sajjurajesh, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `codeschool.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [codeschool.com](/search?q=%28and+site%3A%27codeschool.com%27+author%3A%27sajjurajesh%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|9|75%
definitely an ads guy
Wow. Use Google first. There are SOOO many solutions out there. For the super lazy and if you don't care at all about javascript.... Replace: &lt;input type="button" value="Submit" class="btnSubmit"&gt; With: &lt;input type="button" value="Submit" class="btnSubmit" onclick="javascript:if(confirm('Are you sure you want to submit your request?') { alert('Your request is about to be submitted'); $('form').submit();}"&gt; Getting the verbage exactly write or having other alert appear after submission would require you to create a second html page or have an understanding of javascript. FYI, the above is javascript circa 1999 and will surely get you bad marks if this is for a test.
Really don't get what the point of all this is. 
I have no clue what that means. I'm pretty much a nub about webpages. My programming has always been back-end, c#, vb and the like. How can i figure out if i'm in an i-frame? 
Solved this by including [mapper.js](http://webscripts.softpedia.com/script/Image-Galleries/Image-Effects/mapper-js-44327.html) and assigning the image a "mapper" class.
 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Chapter 10 HW&lt;/title&gt; &lt;link href="css/jquery-ui.min.css" rel="stylesheet"&gt; &lt;link href="site.css" rel="stylesheet"&gt; &lt;script src="jquery-3.1.1.min.js"&gt;&lt;/script&gt; &lt;script src="jquery-ui.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(function(){ $('#name').focus(); $('#dob').datepicker({ changeMonth: true, changeYear: true, yearRange: '-100:+0', maxDate: 0, dateFormat: 'm-dd-yy' });//end datepicker $('#appDate').datepicker({ changeMonth: true, changeYear: true, yearRange: '0:+100', minDate: 7, dateFormat: 'm-dd-yy' });//end datepicker $("#confirm").dialog({ modal: true, autoOpen: false, buttons: { "Confirm" : function(){ $(this).dialog('close'); }, "Cancel" : function(){ $(this).dialog('close'); } }//end of buttons });//end dialog $('#btn1').click(function(){ $("#confirm").dialog('open'); });//end click });//end ready &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="content"&gt; &lt;div class="main"&gt; &lt;h1&gt;Request an Appointment&lt;/h1&gt; &lt;form&gt; &lt;div&gt; &lt;label for="fullname" class="fullname"&gt;What is your name?&lt;/label&gt; &lt;input type="text" id="name" name="name"&gt; &lt;p&gt; &lt;label for="ssn" class="ssn"&gt;Enter your SSN:&lt;/label&gt; &lt;input type="number" id="ssn" name="ssn"&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="insuranceCompany" class="insuranceCompany"&gt;Insurance Company:&lt;/label&gt; &lt;select name="insuranceCompany" id="insuranceCompany"&gt; &lt;option&gt;Blue Cross&lt;/option&gt; &lt;option&gt;Aetna&lt;/option&gt; &lt;option&gt;Humana&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="dob" class="dob"&gt;What is your birthdate?&lt;/label&gt; &lt;input type="text" id="dob" name="birthday"&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="doctor" class="doctor"&gt;Doctor:&lt;/label&gt; &lt;select name="doctor" id="doctor"&gt; &lt;option&gt;Dr. Miller&lt;/option&gt; &lt;option&gt;Dr. Jones&lt;/option&gt; &lt;option&gt;Dr. Adams&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="appDate" class="appDate"&gt;Appointment Date:&lt;/label&gt; &lt;input type="text" id="appDate" name="appointment"&gt; &lt;/p&gt; &lt;p&gt; &lt;span class="label"&gt;Gender: &lt;/span&gt; &lt;label for="paypal"&gt;Male&lt;/label&gt; &lt;input type="radio" name="gender" id="male" value="male"&gt; &lt;label for="visa"&gt;Female&lt;/label&gt; &lt;input type="radio" name="gender" id="female" value="female"&gt; &lt;/p&gt; &lt;p&gt; &lt;input type="button" value="Submit" id="btn1" class="btn1"&gt; &lt;div id="confirm" title="Confirm Appointment"&gt; &lt;p&gt;Do you want to schedule this appointment?&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;
To solve a whole lot of problems Javascript never had. IIRC lenses are a Haskell thing, now that functional Javascript is getting trendy people are trying to carry it over because they like the pattern even though it's entirely unnecessary. 
Not sure why you are downvoted, but this is spot on. The code-style part is debatable (although I wholeheartedly agree), but the important piece is understanding the [`Array.prototype` features](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype#Iteration_methods) and using them properly. Each has a very specific role.
$(this).dialog('close'); alert('ur stds will be cured by teh docta'); // better to forward them to a new page as keeping the user // on the same page after a form submit is an opening for // injection attacks.
Well, you want to be in an i-frame to isolate your elements from the main page's JavaScript and CSS. Otherwise a page could add event listeners or some CSS changes to all your elements preventing them from doing what they're suppose to without you or them knowing it.
You see similar things in other languages that add features for programmer happiness. You can do some extremely slick things in Ruby that look and feel brilliant until you have to refactor a few months later. I've come to realize that one of the qualities of a senior developer is knowing when _not_ to use a language's tricks.
Yup. Plus, map is about 6 times slower than forEach. https://jsperf.com/map-vs-foreach
Thank you!
&gt; Otherwise a page could add event listeners or some CSS changes to all your elements preventing them from doing what they're suppose to without you or them knowing it. Think of an &lt;iframe&gt;&lt;/iframe&gt; tag as a little sandbox for your elements. They can live happily inside their little bubble without worrying that the parent page will mess with them too much. 
It makes it difficult to look for a problem when you obfuscate the code you need help with.
Looks cool. I'll try it.
From the article: &gt; this write-up is intended as an introductory into the concept [of lenses] Maybe you won't use this in production JavaScript, but it's a good way to learn a new FP concept.
So the `\b` in regex indicates word barrier. Just remove those, if you still want to use the regex test: if ( /^(?=.*julia)(?=.*hunt).*$/.test(key) ) { ... }
I recommend if you really want some solid help make a working example of exactly what you have. Then provide an example of it not working.
Note that without word barrier, it would pick up a string like `abcfooxyz bar`.
JSX (presumably) syntax aside, I think it's going a bit overboard to say that only 5% of js developers can understand a simple map. I would expect this to be fairly trivial for anyone who has spent at least a year or so working on any modern code base in most any language.
[removed]
ImmutableJS Maps can't reference by key like that. You're looking for a Record if you're trying to treat it like an object. Keeping it to your map reference the solution is const exampleObj: Map&lt;string, string&gt; = Map({key: 'value'}); export default function exampleFunc (obj: Map&lt;string, string&gt; = exampleObj) { return obj.get('key'); }
You can link it.
i really can't as it's behind a login
Good info, but live coding always seems to end up distracting me from the content because I get lost in the weeds of seeing the code get written. Seems preferable to have a set of progressively more advanced examples that are already shown to work in order to avoid things like typos and to help with the overall flow of the presentation.
Thanks
Hi! :-) Now I know how it works... BTW, do you guys have any idea about how I can make js execute before loading body? I tried so many times...
Nice suggestion.
The vue file format is one of the things I love most about Vue. I wish the other frameworks would adopt that. When building components with other frameworks, there's a debate about whether bits of HTML should go in the .js files (which makes it hard to read, clutters up your JavaScript, and is complicated for HTML designers to deal with). Or if you should always use separate HTML/CSS templates instead, but then you end up with two or three separate files to keep track of for every component. The Vue format is a perfect solution where everything is kept together in one file, but nicely separated, and using standard tags so that existing editors already know how to syntax highlight it correctly. It's brilliant, and I really hope every other framework adopts a similar option.
I agree, in part, with the spirit of your comment, but I think your actual example is pretty poor. &gt; 95%+ of js developers will have to waste time figuring out what this code does and still won't understand whether it actually solves a problem that needed to be solved. 95% of JS developers (who understand React, JSX, and ES6 syntax) are going to look at it and go "oh, it's mapping over an array and rendering a bunch of comments in divs, the array is coming from running the user object through an `allTextToUpper` function, it must be intended to print out a list of comments in upper case". This just isn't magical; it's an extremely common React idiom to pass a list of something into a component, loop over it, and render each item in the list. All the actual questionably useful FP stuff is packed into the implementation of `allTextToUpper`. I'd probably write it like this instead (in fact, I've been writing code very much like this all week): const renderView = user =&gt; { const comments = user.comments.map(comment =&gt; ( &lt;div&gt;{comment.text.toUpperCase()}&lt;/div&gt; ); return &lt;div id="comments"&gt;{comments}&lt;/div&gt;; }; But the difference is really quite minor, and I think you should expect any JS dev actively working on a React/JSX/ES6+ codebase to not even have to pause to parse out what's going on in either example.
I'm wondering the same. This example shows us directly manipulating the DOM and using query selectors, which really me of a mix of Backbone/Angular and seems like a step backwards. Also string HTML templates? The entire benefit of React is that you avoid stuff like this and your view is a pure function of your state. My guess is that this is a really bad example.
&gt; That being said, all modern vdom frameworks are ridiculously fast [...] They are so close and minimal-overhead in real-world perf [...] the great general-case performance and ergonomics we have today. That's just not true. Every nontechnical user I've spoken to complains about new websites being slower than old ones, and it takes a lot for nontechnical users to complain about performance. I routinely see people interacting more slowly and deliberately with vdom-based web apps, because they know they can't keep up. I get that modern vdom frameworks have improved a lot on a naive implementation, but they haven't come close to making up the massive performance penalty that the virtual DOM introduces.
Then why force it on others? Format the incoming code as part of the build step.
It is not a good example at all, no offense to the author. They aren't leveraging vue's databinding. Also, instead of using query selectors, you could use [ref](https://vuejs.org/v2/api/#ref)'s. The official Vue guide serves as a fantastic introduction to Vue. Vue supports an Angular-inspired template DSL, template literals, render functions, and JSX (and probably more). You can use whatever makes sense for what you're trying to accomplish. &gt;your view is a pure function of your state This is the goal in Vue as well (in case anyone is wondering)
Despite what other people have said, I've never noticed any performance issues with it. I've added a few plugins, and it's just perfect: - "beautify" for pretty printing, - "ESLint" for direct linting integration - "Document This" for easy JSDoc style commenting - "npm Intellisense" and "Path Intellisense" for better import autocompletion. - "Visual Studio Code Settings Sync" for easily sharing settings across machines. Being able to create a ".vscode" folder in a project, and sharing launch configs and editor settings across the team is a really nice feature too. 
I have not seen this sort thing in Vue very often: sayHi: function() { var name = document.querySelector("#vue input"), button = document.querySelector("#vue button"), prompt = "What's your name?"; var style = name.style; if (!name.value || name.value === prompt) { name.value = prompt; name.focus(); } else { alert("Hello " + name.value + "!"); name.value = null; button.blur(); } Evan You talks a bit about dom manipulation here: https://devchat.tv/js-jabber/187-jsj-vue-js-with-evan-you
I'm not sure it was a very good introduction to lenses. I think [this article with immutable.js](https://medium.com/@drboolean/lenses-with-immutable-js-9bda85674780) is more clear (and more correct) and provides some better argument for places where lenses might be appropriate in javascript.
&gt; Every nontechnical user I've spoken to complains about new websites being slower than old ones, and it takes a lot for nontechnical users to complain about performance. I routinely see people interacting more slowly and deliberately with vdom-based web apps, because they know they can't keep up. That's because modern websites are 90% bloat...and it doesnt help that the "big" vdom frameworks are in fact really slow and heavy. But I can prove to you that this is not true of properly written code (which is a rare thing to behold, I know). Load up TechCrunch, New York Times, Gawker, whatever "heavy" website you can imagine and run this in devtools: `document.querySelectorAll("*").length`. That's how many dom elements a vdom framework would have to create to load the site. All the other junk (fonts, assets, images, third party srcipt shit) will load the same regardless of vdom or not. You will find that even heavy websites have fewer than 5000 dom nodes. Gmail for instance accumulates them as you load up different mailboxes or search results, so you can end up with 10k or 15k+, but gmail is shit for performance, this is not news Next, load up https://o-0.me/code/domvm2/demos/bench/dbmonster/ (i've put a copy of the domvm dbmonster bench [1] on my server). This page is 100% client-side rendered. You can load it on your phone and it will load fast. I can load it fast on my 5 year old HTC Evo. Do you know how many nodes it created and painted? 2935. In a fraction of a second (after dns resolution/https negotiation). If it didn't load, use Chrome (it's non-transpiled ES6). Granted, the benchmark was generated by js, so there was almost no network transfer overhead to pull the dom content, but this overhead (if it existed) would be the same for server-side rendered content. Yes, server-rendered html would "stream" so you get instant above-the-fold painting, but the point is that if you have a website that feels slow, it's because it is written like shit, bloated to the eyeballs and/or in a slow vdom framework. I'm not suggesting that Gawker type sites shoul be written in js. Far from it, i dont even like running js on the server. Static html is where it's at for most of the web. But SPAs absolutely don't need to be slow. People just got used to React and Angular, which is a shame. [1] https://github.com/leeoniya/domvm
I like how VimModePlus is rethinking some Vim basics, including cursor motion after an operator. https://github.com/t9md/atom-vim-mode-plus/wiki/YouDontKnowVimModePlus
Why are you wanting to do that? The simple answer is place the &lt;script src=".."&gt; tag in the head. A JavaScript parser will begin parsing at the point of first sight to the detriment of the rest of the XML parser's tasks. If you are loading JavaScript in the head, be advised the DOM may not be available for manipulation. This is why you tend to see a lot of JavaScript with onDocumentReady handlers. It's generally considered unwise to load JavaScript prior to DocumentReady simply because the User has no real indication the page is loading until the JavaScript parser completes it's task. You'll inevitably wind up with document handler spaghetti and a slower time-to-first-paint. It's also worth noting some web crawlers/spiders don't handle JavaScript. Google do to a degree for some purposes, although for the purposes of good SEO, I'd have a pure HTML document ready before JS manipulation. If you're loading code that has no real bearing on the DOM or uses ShadowDOM manipulation to form a DOM at a later date it may be worth looking into the 'async' attribute &lt;script src="..." async&gt;&lt;/script&gt; This will load the JavaScript at an arbitrary point in time, it'll also load more than one script at a time and queue them for parsing, ideal if you're getting scripts from a CDN. Although not great if it's making DOM changes. If I'm using async, I'll usually have a static script just checking that each script has been loaded before anything that relies on them is attempted. 
Agreed. I recall the list of of qualities I would like to see in developer who join my team: * **Ability to ignore new tools and technologies** * Taste for simplicity * Good code deletion skills * Humility
Yeah, Angular 1 offers everything Vue.js does. What the hell is going on here.
I was in the same boat for quite a while, but VS Code has a lot of packages these days (all the ones I need). And themes? All of [these](http://tmtheme-editor.herokuapp.com/) (and then some), or write your own!
This...is a really bad example. Edit: 99% of the time, if you're writing proper Vue code, you should never be manually querying or manipulating the DOM.
&gt; but then you end up with two or three separate files to keep track of for every component. This is not a bad thing. You will inevitably end up with components with rather long markup and styles. It's easier to reason about when HTML or CSS when they are in their own separate files. Otherwise to keep the length of your markup and styles manageable, it forces you to create many small components out of things that don't really need to be components. I would rather Vue support the ability to compose components out of separate styles, scripts, and markup files. Something like: **Foo.vue** export default { style: './some/styles/file.scss', script: './some/viewmodel.js' markup: './some/html/file.html' } That then is literally your whole component definition, allowing you to keep each file 100% focused on one language, making them easier to navigate and compose together as needed. In most cases those three files would live together in the same folder as the `.vue` component file, but they wouldn't have to - giving you massive flexibility as to how your application is organized.
I think that Google's explanation of what "critical rendering path" is can help a lot to figure it all out https://developers.google.com/web/fundamentals/performance/critical-rendering-path/adding-interactivity-with-javascript
&gt; But on the other hand I'm also pretty confident that not using anything constructs that, while unknown for a junior, are -or should be- familiar to a senior is not healthy either. Fair enough, but that's not really my issue here. Stuff like this is easily abused for the sake of self-indulgence. People, especially those who feel stagnant or bored with the status quo, have a tendency to do things for the simple sake of doing, not always because it makes the most sense. That can be a very bad thing when it involves unnecessarily increasing the complexity of your code base.
This is great, and you can then test your code with fuckit.js!
If it's to show off the benefits to Vue, it's a bad example, but if it's to teach a beginner how to use Vue, I'd say that can be a good thing. A lot of guides focus so much on immediate ideological purity and professional setup that it can be overwhelming for a beginner. It can be good to ease into things by only introducing one tiny thing at a time.
Vue already does. see the src imports section in http://vue-loader.vuejs.org/en/start/spec.html PS: This information should be in vuejs.org site but I am too lazy to make a PR.
Just only Atom ;)
Very nice tutorial! I might give this a shot during the holidays.... So marked for later!
I didn't really read your introduction (sorry) but I assumed that I might be able to input a sample json object and this service would generate random variations based on that prototype. Still cool though!
Here's the post for the server side in case you were interested: http://thereactionary.net/you-got-a-friend-in-me-building-a-net-core-backend-friend-for-a-react-app/
I was thinking the same thing, maybe trigger the nerve endings in the nose to push out the same signals to the brain as it does with out scents. but I think a direct to brain stimulation wouldn't be consistent due to the fact every brain is wired differently, but maybe if we could replicate the input signals then the brain may interpret it similarly. it's possible that in the near future sending fart signals to people online could be considered a form of harassment. 
Dude, are you aware of Angular 1's vastly improved performance over the years? 1.6 made it even faster. Of course I read the page, otherwise I wouldn't have said that. There is this principle that you should practice called "principle of charity". Thank you.
Because prebuild code should look consistent. A project's code base should follow internally consistent styles and structures and standards. It should appear to be the output of one person. 
The course is specially designed for front end developers and designers who have interest in javascript and who want to be ahead of their peers by learning the new features of this amazing language
Coupon Save 78%. This course is all about creating a fully functioning production ready, real time web application!
Ty =]
The adventures in "Error Driven Development" continue...
Simple CRUD Application In JavaScript
Emacs with [JS2-mode](https://github.com/mooz/js2-mode) and [web-mode](http://web-mode.org/)
yeah, that's it. Not only about functions, but with classes too, things like find parent class, other implementations, parent/overriden methods and so on. PHPStorm is obviously much heavier than any "text editor" but is also has a lot of features the others don't have.
I've used it in javascript, never tried in PHP
Do not worry, everything takes time. You'll pick up little bits eventually, and theyll all start coming together. Do not dive into a framework or library too early so you don't get discouraged.
For those willing more advanced stuff, there is a new course on Vue 2 at Udemy. The course is massive, I enrolled the other day and am more than happy from the content and the instructor. Here is a link: https://www.udemy.com/vuejs-2-the-complete-guide/
Oh My God- I haven't laughed so hard in months!
Working on nailing the languages from as many tutorials as I can find. Repeating steps so many times it feels like I've brute forced some concepts into my head that it feels like boredom. At least if ur so bored of repeating parts you already know, it's one way of confirming you actually got the stuff to stick for good. 
Coupon Save 56% . The course is specially designed for front end developers and designers who have interest in javascript and who want to be ahead of their peers by learning the new features of this amazing language
Not op, but: &gt; Ionic, as we know, changed. Completely. So did Angular. It is called Refactoring. It is called rewriting. Refactoring is something like changing the implementation without changing any public APIs. There are several definitions, but this captures the essence. ninja edit: &gt; Code refactoring is the process of restructuring existing computer code—changing the factoring—without changing its external behaviour. Refactoring improves nonfunctional attributes of the software. Advantages include improved code readability and reduced complexity; these can improve source-code maintainability and create a more expressive internal architecture or object model to improve extensibility -- [Wikipedia: Code refactoring](https://en.wikipedia.org/wiki/Code_refactoring)
This is fantastic, thanks for pointing this out!
Great, it has demos. Shit, readme file is written in Chinese.
Not really. Its purpose is to store your JSON object and provide a link for HTTP GET request, so you can easily use it as a web service for testing purposes.