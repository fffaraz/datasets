Just my impression. Even barebone configs without AOT had inexplicable stuff in them and would cause large, unoptimized builds. Normally it's either plain Webpack and no extra stuff at all or minor things like babels JSX or Vues SFC loader. Just as an example: module: { entry: './index.js', output: { filename: 'bundle.js', path: './dist' }, rules: [ { test: /\.js$/, use: { loader: 'babel-loader', options: { presets: ['env', 'react'] } } } ], } Few lines more to get an optimized distributable: plugins: [ new webpack.DefinePlugin({ 'process.env': { NODE_ENV: JSON.stringify('production') } }), new webpack.optimize.UglifyJsPlugin(), ] Not trying to bash Angular, but the article isn't entirely wrong claiming that building it can get a little confusing, at least once you're out of the cli.
I only came here to read comments and lmao
That's okay. Cheers
I would recommend react/redux, we use it for a similar scenario at my work at a large tech company and have seen no issues with scalability. Integrating Typescript into it or another type system like flow can help a lot of there are many developers working with it and you need it to scale better. Much lighter than Angular 2. And I would recommend using es6 with it. If licensing is that big of a concern for your company, I can only say I've worked with Angular 2 and not Vue. If a lot of the devs are C#/java people, Angular 2 and Typescript will probably be the easiest to get into of the big frameworks, and how to keep it scalable will be more evident. Hope that helps! Edit: since you're the only one working on the front end, I couldn't recommend react/redux enough, it may seem jarring at first seeing HTML (well JSX) in your JavaScript, but once you get used to it and see how intuitive the functional approaches it takes are, you won't want to write UIs any other way. You most likely don't need the monolith that is Angular 2. :P Also keep in mind Typescript is a Microsoft developed thing, so it shares a lot of similarities with C# if that appeals to you.
Thanks, as someone else stated, it may have been an ecmascript/async issue. I've had a similar async issue earlier in my project so i did an alternative. I may have to try using let instead of var for similar loops.
The programming community buried Perl for having too many magic punctuation marks yet modern languages are all moving in that same direction. If you're an expert, it's powerful and terse, but it's a huge barrier to entry for learners. I'm trying to teach my daughter JavaScript and there's no way I can show her ES6 and make it remotely intuitive.
Maybe not for this project, but check out Aurelia. Really just feels like writing typescript. No weird licensing 
You can also use one of the popular clones of React, like Preact. 
Not nearly as fast as /dev/null ! ...sorry, bad joke. 
See also: https://nearley.js.org/docs/tooling#nearley-unparse-the-unparser
This is how I've always felt when confronted with this question but since frontend dev is not my forte, I always concluded I must be missing some profound insight. So if, as you say, jquery + json + rest backend has worked well for large projects in your experience, when *should* I use Angular or React or X framework? I've dabbled in both and for me (not frontend dev but very comfy in js, jquery) learning something like Angular is a bit off putting. i.e. when do you say "ok, jquery will not cut it for this type of project, we need X framework here" ?
Last weekend I made an markdown based ebook editor / creator using electron. https://atnpgo.github.io/NeoGutenberg/
There is a front end dev community that has ~10k subscribers with several JavaScript focused channels. http://frontenddevelopers.org
&gt;(there are still many interesting not-so-popular projects on Github). Mind sharing some? Would love to take a look
Hear hear! &gt; "Mainframes are an idea from a bygone era. We now have the ability to put that computing power on the desktop." Um... isn't "the cloud" just today's nomenclature for "mainframe"? &gt; "Visual Basic 6 is limited by its variant/loose data typing, allowing programmers to do too many stupid things or silly mistakes if they're not watching carefully." Then we get [`var` in C# 3.0 and `dynamic` in C# 4.0](https://www.codeproject.com/Tips/460614/Difference-between-var-and-dynamic-in-Csharp) which are progressively the same thing! Oh... and Javascript is loosely typed and look how popular it is! Programming goes in swings and roundabouts... The reason one language/platform/approach is "old" or "antiquated" or downright "bad" becomes the next hottest feature with a different name in a later version of what is The Next Big Thing ^TM everyone moved to.
I have been using Vue for the last few major projects at work and I can confidently say it has reduced development time and definitely been a joy to work with. React is great but I feel that Vue is much more rapidly understood by unfamiliar devs, and the time savings of being able to quickly integrate HTML without having to react-ify it is quite nice. Just my opinion though! I'd absolutely say to try both Vue and react and see which sits better with you. If you're doing a SPA either of those choices will be great. 
I released a new version of my next gen transparent reactivity library: https://github.com/nx-js/observer-util. It uses ES6 Proxies under the hood.
You can do [plenty](https://threejs.org/examples/#webgl_buffergeometry_instancing) of particles/shapes with three.js. In general, particles should not be done as individual sprites/meshes.
Made some Vue bindings for Redux. Pretty similar to the React Redux API! [Here](https://github.com/mini-eggs/Vue2-Redux).
Still wish we had a better solution than `.mjs` :(
&gt; An orginization thats latest political affiliation (george soros etc..) fake news.
People still uses jquery?? Wtf
You'd be amazed. In fact, for simple marketing websites and the like, it can even be a good solution! The nice thing about this article is it helps folks stuck in that world to see what more advanced frameworks might look like 
I created a noise library that lets you apply transformations. The docs page has a canvas visualizer, so you can test out your own transformations: https://scottyfillups.github.io/tumult/
In 3 scenarios (all in my opinion of course which probably means I forgot something! ): When developing systems that require low latency, shared states and are used by hundreds or thousands of users at the same time. Then frameworks with a virtual DOM would be a better bet. When developing very large projects with 10+ developers then a framework might be a strong option as a way to reduce code complexity and increase code clarity between team members. When developing projects where all (or most) developers have a detailed knowledge and experience of using the framework. Otherwise I would recommend keeping the development tools and cycle as simple as possible. 95% of all projects don't need a framework so why use them? Most frameworks have 3 massive flaws in my opinion which render them dangerous in many real world projects. There is usually a very steep learning curve. When you encounter problems you'll quite often notice that the depth of support isn't on par with what you see with JavaScript/jQuery. And lack of a deep knowledge base can easily eat months from your development time. They are rigid. Real world projects need to be adaptable due to changing user demands or scenarios that weren't anticipated. The framework might easily handle changes to underlying data sources but the problems start when you have to bring the small screwdriver into the project. Seeing half of the UI crash because you adjusted a single CSS class due to interactions inside the framework isn't particularly amusing. They are volatile. The new cool framework today will probably be forgotten tomorrow. The Java ecosystem is a cemetery of frameworks, tools, test suites, apis, etc. that were discarded or faded into oblivion. And now we are starting to see the same thing in the JavaScript world. Additionally there are thousands of projects that have been burned badly because the framework's developers suddenly decided to redesign a new version leaving the current version in a lurch. Use the tools that you know and focus on clarity. It will make everything so much easier to maintain and in the end save your sanity!
Not currently working and on a local server, but I am putting the HTML5 Gamepad API and threejs together to make a fps-like game with an XBOX 1 controller. 
Fyi: New version is out with improved iOS scrolling. I am glad that you informed me about it, thanks too :D!
Cool. Now a bit vague question: How does the integration with backend look like? If I were to use Vue.js with C# in the backend (talking to CRM) am I condemned to use that Razor and similar MS stuff as a layer between frontend and the backend (you can give me technology-agnostic answer, I used MS tech in the question as it concerns me right now, but the methodology in general is something I actually want to know)? It would be a bummer to have things like routing in Razor or whatever and use Vue as a glorified jQuery.
Reactiflux is centered around react but a lot of the topics are pure javascript ones.
Normally you can just entirely separate the frontend and run ajax requests via CORS if that is an option. Your C# backend would literally just be an API endpoint. I don't generally do any server side rendering at all when I use react/Vue. If you're using an app using a webpack boilerplate it'll just compile into a few static files you can toss up on a web server and all of the backend data just comes from making Ajax or websocket requests to your applications API. I'm not well versed in the Microsoft development stack so I'm not sure what razor is, but it's pretty much entirely backend agnostic so it doesn't matter a whole lot what tech you use for the server side. You can make your .net app basically serve the file generated by webpack and use one code base if you want as well. There are plenty of ways to do it :P Im just explaining how I'd do it for a SPA though, if you want to do a multi page application you can still use Vue and react on a per page basis, but it's just not going to leverage the true power of either solution.
Hi /u/samsolomonprabu, you already posted this. Please do not repost. Thanks.
I'm really sorry. I drafted the same both in my mac and PC. Without realizing it, I posted it now. After I realized it, I just removed the old post. I will not repost again. Thanks for the kind notification.
https://learn-programming.slack.com has a large JavaScript presence. 
Great work but that map projection is so ugly
I created a nice photo editing and labelling system combining fabrics vuejs and drop zone to allow dragging of some pictures on to the site and it creates a canvas for each one that can be marked using fabricjs. Works great.
https://code.visualstudio.com/images/1_16_ts-extract.gif
damn, this is a big improvement. VS code has always been a great editor and this shit is something else :)
Thanks for your reply :) That DEMO is awesome
Yoooo üëã I got the short end of the stick when it comes to jobs that stay on market trends and am trying to fix that.
Glad I switched from Atom
This is such a clear answer, thank you
Have they fixed that stupid blocky scroll bug that you fix by resizing the window?
First, are you _positive_ that you're getting passed over for those reasons? Most interviewers won't tell you why you weren't picked (which sucks), and so I'd like to throw it out there that there could be other factors at play -- maybe you're not a strong interviewee, or don't appear to communicate effectively in person, or you come across with some personality flaw (arrogant, pedantic, etc.). If I take your word for it that it's not your soft-skills, then how advanced are your github projects? We can critique them if you wish. When I interview, if all they've done is make a todo app or something else equally as trivial, then it's just slightly better than not having a github. However, one candidate that comes to mind had made a multiplayer game utilizing websockets; that was pretty impressive! And it was impressive because they had to do quite a bit outside the normal framework -- it's really not hard at all to take the latest framework, and make it do things that it was designed for (todo, blog, movie ratings, etc). Also, it's possible the code in your projects is lackluster; it doesn't matter if you make a multiplayer game w/websockets if it's a [Big Ball of Mud](https://en.wikipedia.org/wiki/Big_ball_of_mud). Again, a code review/critique might help here.
Yeah it's good for JavaScript beginners (I used it too) but you can achieve the same result with vanilla js... 
This is sick
I started using VSCode yesterday. Atom failed on me recently and brackets can't handle node_modules. This is great, and I'm glad that the prior editors borked up.
Vine is no longer around.
just press the 'F12' key, and keep focus on console, network panel, if you debug websit and ajax request
If you're only changing the first line, could you show us what it is when it works and when it doesn't? That might be a good start. I'm not totally sure I understand your code, probably at least partly because I don't know jQuery.
Might want to look into an actual search service like elasticsearch, since it‚Äôs made specifically for this use case.
&gt; Most interviewers won't tell you why you weren't picked. You can also ask for feedback on the interview you've just done. I think I tend to interview well but I recall one instance where I didn't think I came across as strong as I should of so I asked the interviewer for feedback. They were pretty open about it and I'm pretty sure me asking that question helped me go on to the next round.
&gt; should of Did you mean should have? -------------------------------------- This is a bot account.
It's either should **HAVE** or should**'VE**, but never should **OF**. See [Grammar Errors](http://www.grammarerrors.com/grammar/could-of-would-of-should-of/) for more information.
I used the new Chrome Puppeteer Node API to have headless Chrome poll Delta for flight cancellations to escape Hurricane Irma and text me with Twilio. After a couple hours I got the first text Thursday morning and booked lights for Friday. Watching Irma from out of state now.
Ok this is getting ridiculous, lol.
They're on discord but yea reactiflux rules.
Does it also know to create parameters from variables the extracted code needs?
I love this application. Game changer.
I added a few comments to my code above. Each name in the array is given a unique div. The jquery function animates an object and moves it to a new position. So what I'm doing is randomly generating a new position for each div/name and then the animation glides the name to the new position, over and over. It's a list of names floating around the screen until I hit the stop button. If instead of `var nameArray = {{ student_names | safe }}` I use the following: var nameArray = [ "Jimmy", "Sonny", "Sammy", "Henry", "Hank", "Susan", "Sebby", "Alyssa", "Pepper", "Ken", "Steve", "Kandi", "Wes" ]; the divs and names will randomly move around over and over in the loop. If I use `var nameArray = {{ student_names | safe }}` though, the divs and names only move once and stop. FWIW, `console.log(nameArray)` is printing the following: `Array [ "Jaffer", "Janice", "Jaclyn", "Jack", "Jerry", "Jim" ]` so it seems to me that the array is legitimate.
That's really interesting, thank you for sharing. It seems like AutoMod needs to be updated to gather the same data from text posts too. I can't think of why that feature isn't already available. Has this ever come up before?
... and requires jQuery.
Yup! It knows based on the scope whether it will capture variables as part of a closure or if it needs parameters. [See here](https://twitter.com/typescriptlang/status/903300458508255232) for another example. 
bootstrap requires jQuery too...
Automod can do that with additional configuration, but toolbox can't, thus my request :)
How does this compare to WebStorm? I like the refactoring JetBrains has in it's products.
Honestly why would anyone use Atom or hell, pay for Sublime over Vscode? 
Mongo has full text search, you create a text index on the fields you want to search on. See the mongo docs, it works great.
Still has a lot to catch up to.
vsc refactoring needs a lot to be considered "usable". Things like updating references when moving files in the file system are still missing.
Haven't used brackets. What do you mean by "brackets can't handle node_modules"? That sounds weak 
Uses a lot less ram. But this is still more of an editor with some ide features than an ide 
Probably means the code completion
If you are one who truly love open source community and love to build your own tools. Atom makes that easy when you know JS. VSCode is way ahead of tooling because of the backing of a huge company. Atom team just focuses on Atom. And its up to the community to provide the toolings. To say atom sucks is such a "my camp is better than yours" schoolyard mentality. 
Hey guys, do the JS features like this, autocomplete, etc work out of the box? Or do they still need a config file in the root of the project? I've been using Code for a year but I still never seem to get any of the quality-of-life JS features to work. My understanding was that if I start typing the name of a function that's in another file (but in a file within my current workspace) that it would attempt to autocomplete. I've seen gifs of it. But mine never has. Writing plain JS by the way, no typescript.
I didnt say Atom sucks, at all. Its a great tool and what you said is of course true. I'm saying as a developer who wishes to use the best code IDE, Vscode is a better option. The fact that it was made by MS (and has great community support) isn't a reason for me not to use it. Its the same thing e.g. for React or Bootstrap or MaterialUI or any other open source project made by a big comany. Both can happily coexist. I think you are being overly defensive.
You may want to study up on your fundamentals like data structures, common design patterns, and so on. Frontend is getting quite sophisticated. And play around with Angular, Ember, and Relay. Understand where the frameworks are converging/diverging and what their strengths and weaknesses are.
I've only made a Hello World extension with VS Code and poked around in a couple other extensions, but it doesn't seem very hard. Is Atom really that much easier? I had assumed they were pretty similar.
Everything about vscode is great except that they just cant ever get autocomplete and suggestions inside jsx to work right (or coherently)
what happens when you use a hardcoded array of length &lt;= `max` (12)? i *think* you're running into weird (probably closure) issues into your loop with `i` and `max` and calling a callback at the end of `animate`. i'm looking at this expression to determine the callback to play in the `animate` call specifically: i == max - 1 &amp;&amp; loopAllowed ? loop : undefined i'm thinking you're running in to an issue where `i` is being set to the value it gets on its last iteration of the loop and that is interacting with `max` and calling `loop` properly when the list of names &gt; `max`. In the case of the hardcoded array you're using, it has 13 names in it, which would set `i` to 13 on the last iteration (thanks to `i &lt; (numberStudents + 1)`) of the loop which satisfies the expression `i == max - 1` which calls `loop` rather than `undefined`
It would constantly freeze every few minutes and get progressively worse as I left it open. It would use 20% of my CPU - I have an i7 5820k...
Hey there internet stranger. If you're struggling with switching jobs, reading these two articles will help you a ton. http://www.kalzumeus.com/2011/10/28/dont-call-yourself-a-programmer/ http://www.kalzumeus.com/2012/01/23/salary-negotiation/ 
Lichess 
I was in the same boat as you until my most recent job. It sounds like you're already doing a good job selling yourself so just keep at it and don't get discouraged. No matter how good you are, getting No's after an interview is inevitable and no reflection on you or your abilities. Remember that the more you apply, the less likely it is that you won't get an offer. Don't slow down and don't give up. 
I still haven't found a reason to switch from Atom. I also find the new git diffing in Atom better than Code's. What am I missing here? 
VSCode is an IDE
That's awesome. Can't wait to try it on Monday.
Obligatory emacs/vim comment
That's why you transform your values in something like a computed property beforehand, which is both more performant because the computation is memoized and your code is easier to read. 
Horrendous title; trying to shame people into reading it?
Need a really quick edit? Using VSCode is an option. Some plugins are outstanding as well (it's small, but I love the DocThis plugin for JSdoc, it's much better than Jetbrains's). But WebStorm is a far more capable and outstanding IDE. VSCode is more editor than IDE, while all of Jetbrains's products are full IDEs. Quick addition: Sometimes VScode is great to use if you're at a job and can't use WebStorm due to licensing
The story behind getting full type analysis in vscode with regular javascript is a mess. I think it because they've said it so many different ways and it won't offer to give you a basic setup to get your started. Ideally, it should 'just work', but it doesn't and so you go looking for documentation and find a ton of outdated information. AFAIK: You need to make a jsconfig at the root of your project. Something like: { "compilerOptions": { "target": "ES6" }, "exclude": [ "node_modules" ] } then, vscode will be able to see your entire project and not just open files. Again, as I understand it. It will also automatically download the appropriate @types. You'll get a lot more analysis with this. You can add checkjs: true under compiler options to run the full ts type checker for full type analysis. This last bit I've been unable to get it to recognize my props in my react component and I still don't know why.
Yeah it sounds like it, but it's actually critiquing another medium article with a similar name.
"you could quickly fix this by changing your input value binding to value.bind="RG &amp; updateTrigger:'blur'" which tells the binding to update your model only when the input blurs (instead of on every change/input event." https://github.com/aurelia/binding/issues/536
This article is in response to [another article](https://medium.com/reverdev/why-we-moved-from-angular-2-to-vue-js-and-why-we-didnt-choose-react-ef807d9f4163?source=---------0----------------) that's been making waves across a bunch of other subreddits recently. Being a person who loves Vue, React, and Angular 2+, and believes that they all have good things about them and good reasons for wanting to use them, I feel like the original article came off a little short-sighted in its arguments. I feel as though this response article (though it could've chosen a less condescending title) addresses those points well, especially in regards to the use of TypeScript.
It's too easy to judge articles by their titles without even reading them, but they are definitely meant to be inflammatory in certain cases. Forgive my ignorance :|
[mp4 link](https://g.redditmedia.com/1WEYs6ST249Ws-S3p_KzLG45rLwGzp16S8E3QtNYpxI.gif?fm=mp4&amp;mp4-fragmented=false&amp;s=a2134fc7519cf1685c60748d71ac3137) --- This mp4 version is 20.59% smaller than the gif (856.15 KB vs 1.05 MB). --- *Beep, I'm a bot.* [FAQ](https://np.reddit.com/r/anti_gif_bot/wiki/index) | [author](https://np.reddit.com/message/compose?to=MrWasdennnoch) | [source](https://github.com/wasdennnoch/reddit-anti-gif-bot) | v1.1.2
I completely agree with the comment from u/kenman. I am going to take this a step further and just immediately blame you for a failure in soft skills. Here's the deal. Nobody really cares if you have practiced a couple minutes using *new* or *legacy* approaches. You would do yourself a huge service by simply forgetting this. Most of what you are talking about as far as *new* code is just build process and tooling. If you were to come into an interview and focus the majority of your energy on this I would think you are just spinning your wheels with bullshit. What is most important is whether or not your code sucks and how immediately you can address a given problem. If you want to be successful in an interview you will articulate this very clearly and calmly. No bullshit. No back-peddling stories. No tooling nonsense. Just provide a solution as directly as possible. Tooling and build processes aren't a solution to a code problem. They are conveniences and dependencies, which are nice ways of saying tech debt. A bad ass rock star developer will take the existing code bad, no matter how old and horrid, and work with it as necessary to get the job done while providing (in code) a superior approach on your own time.
Write code. Build an application. Solve for inefficiencies that slow you down.
CP and DI are simple means in order to glue a string to a model. There's nothing particular good or great about it. It's often already done in JSX (redux/reselect) or not necessary, but nothing would prevent you as it's unopinionated about it. I don't think splitting up the view simply because the underlying stack forces you to makes it more readable.
What "horribly opinionated server impact" are you referring to?
It's one thing to do a simple map or reduce on some items with JSX, but doing multiple, possibly complex transformations is painful to read and wastes my time as I can't quickly see what's going on at a glance. A big time smell imo. 
i have only ever used try/catch when writing validation code. we wrote a collection of validation functions to perform on input fields and they all used try/catch to report errors up to the wrapping parent invocations. do yall have other use cases i might consider?
Does resizing the window fix this? I would always just shut it down and start it up again. Will have to try this, thanks!
Yup, I just maximize then restore and it's all better.
Awesome. Having to wait while TS + all my plug-ins re-initialize every time was super annoying.
IMO this is a bad use for try catch. You should have returned an object with a property that says validation failed like { valid: false, error: new Error() } An appropriate use case for try catch is when calling JSON.parse since it's a synchronous action that can throw a hard error.
Network calls when using async/await syntax in ES7.
To add, try catch shouldn't be used as a lazy way to handle undefined errors. For example, I should never see let myThing; try { myThing = foo.bar.buzz; } catch (e) { myThing = defaultValue; } I would deny that PR and recommend: const myThing = foo.bar ? foo.bar.buzz : defaultValue; Or even better with lodash const myThing = _.get(foo, 'bar.buzz', defaultValue);
Can you show the code that causes that error?
Is it accessible?
I'm a bit further now.. I've wrote the update function like: update(req, res){ return LED .findById(req.params.LEDId) .then(LED =&gt; { if (!LED) { return res.status(404).send({ message: 'LED Not Found', }); } if(req.body.status){ changeStatus(req.params.LEDId,req.body.status); console.log('STATUS CHANGED'); } if(req.body.prog){ changeProg(req.params.LEDId,req.body.prog); console.log('PROG CHANGED'); } if(req.body.white){ changeWhite(req.params.LEDId,req.body.white); console.log('WHITE CHANGED'); } if(req.body.color){ changeColor(req.params.LEDId,req.body.color); console.log('COLOR CHANGED'); } if(req.body.brightness){ console.log('BEFORE BRIGHNTESS CHANGED') changeBrightness(req.params.LEDId,req.body.brightness) console.log('BRIGHNTESS CHANGED') } return LED .update(req.body, {fields: Object.keys(req.body)}) .then(() =&gt; res.status(200).send(LED)) .catch((error) =&gt; res.status(400).send(error)); }) .catch((error) =&gt; res.status(400).send(error)); }, I've tested it and it jumps to the changeBrightness function. There I want to work with noble. Code looks like this: changeBrightness(LEDId,updateBrightness){ console.log('BEGINN CHANGEBRIGHTNESS FUNCTION') var uuid = "4711"; var brightness = updateBrightness; console.log('BRIGHTNESS', brightness) console.log('UUID', uuid) console.log('AFTER CHANGEBRIGHTNESS VAR') // Connect to client, find Service, find Characteristic and write status noble.connect(uuid, function(error){ noble.discoverServices([lightningServiceUuid], function(error, service){ var tempLightningService = service[0]; writeFile("SUCCESS -- Discovered Service on UUID"); tempLightningService.discoverCharacteristics([brightnessCharacteristic], function(error, characteristics){ var tempBrightnessCharacteristic = characteristics[0]; writeFile("SUCCESS -- Discovered Characterisitc on UUID"); console.log('IN THE MIDDLE OF CHANGEBRIGHTNESS FUNCTION') tempBrightnessCharacteristic.write(new Buffer(brightness), true, function(error){ writeFile("SUCCESS -- Wrote brightness characteristic"); }); }); }); }); //Disconnect from client noble.disconnect(function(error){ writeFile("SUCCESS -- Disconnected from Client"); }); console.log('END CHANGEBRIGHTNESS FUNCTION') } I'm currently working with a fake uuid for testing purposes.. So my output looks like this when I start the server and execute a update request: [nodemon] restarting due to changes... [nodemon] starting `node ./bin/www` Executing (default): SELECT "id", "device_id", "name", "group", "status", "device_type", "prog", "white", "color", "brightness", "createdAt", "updatedAt" FROM "LEDs" AS "LED" WHERE "LED"."id" = '1'; BEFORE BRIGHNTESS CHANGED BEGINN CHANGEBRIGHTNESS FUNCTION BRIGHTNESS 5 UUID 4711 AFTER CHANGEBRIGHTNESS VAR PUT /api/led/1 400 357.728 ms - 2 Why does it stop before the noble function? What do I need to change?
It might come back with the usage of await/async since it's the only way to handle code rejection. That I am aware of. Weird that on a article dedicated to try/catch they don't talk about its usage in await/async code, it's the most up to date usage we can have with try/catch.
I want to bulid an application. But have no idea what to bulid.
 @connect(state =&gt; ({ items: getVisibleItems(state) })) // memoized pick ... const transformedItems = this.complexCalculation(this.props.items) .sort(this.sortItems) .filter(this.filterItems) ... .map(item =&gt; &lt;li&gt;{item}&lt;/li&gt;) return &lt;ul&gt;{transformedItems}&lt;/ul&gt; Again, JSX is unopinionated, use whatever style you like. DI and CP on the other hand are mandatory because of the templates implicit connection to the presentational layer. You might think that it's better to chop the view into pieces, but then you'd do the same to your JSX view naturally. Most people would probably prefer not to scatter the view if they have the option, and JSX allows that, too. 
&gt; nodejs all the things What does that even mean?
You're correct. Decreasing the number of names less than twelve stopped the loop. I first worked on this script over a year ago and I can't remember what the `max = 12` does. I actually had help with this animation over 2 years ago and remembered that [the code was suggested to me on Stackoverflow](https://stackoverflow.com/questions/31775101/javascript-how-to-exit-a-loop-by-clicking-a-button). It looks like the suggested code was to have `max = 2`. I'm not entirely clear on what the `i === max - 1` is doing, but I know that if I remove it the loop doesn't quit even when I click stop. **playing with it just now** I see that the `i === max - 1` maybe prevents filling up a queue of animations so that it stops soon after pressing the stop button. So the `max = 2` defines the 'overshoot'.
it's easy to use Modal : ``` bDialog.open({ url : 'http://some url' }); bDialog.open({ dom : $('#some element').html() }) ``` Alert : ``` bDialog.alert('your message'); bDialog.alert('your message',function(){//your callback}); ``` Mask : ``` bDialog.mask(); ``` 
But actually we use React in a J2EE app using the nashorn compiler with no issues.
How is this related to React? You said it yourself it's a client-side framework. No one is forcing you to use server-side rendering; actually a lot of people would advise you not to. I really don't understand your incoherent ramble and now I don't think I even care.
First, since these are just snippets, i don't know how they fit into the whole project. But i can explain what these functions are doing in isolation. Alright, let's get to the first function: const getDistance = (state, rotate) =&gt; ["x", "y"].reduce((object, axis) =&gt; { object[axis] = Math.abs(state[axis] + rotate[axis]); return object; }, {}); It's getting a bit fancy with its use of the reduce method. reduce() lets you iterate over an array, but unlike a forEach where the action on each index is independant, reduce lets you carry forward some result which you're successively modifying. A more common use for reduce would be if you want to sum up all the elements of an array, you might do this: let ten = [1, 2, 3, 4].reduce((sum, current) =&gt; { return sum + current; }, 0); // the 0 is the initial value In their case, they're using reduce to repeat the inner function once for x and once for y, inserting the results in an object which they're building up one axis at a time. You could write pretty much the same thing like this: function getDistance(state, rotate) { const object = {}; for (let axis of ['x', 'y']) { object[axis] = Math.abs(state[axis] + rotate[axis]); } return object; } Or since it's just two elements, you could unroll the loop: function getDistance(state, rotate) { return { x: Math.abs(state.x + rotate.x), y: Math.abs(state.y + rotate.y) } } In short, it's taking a state object and a rotation object and adding their pieces together. ---------------------------- Next up, we have this function: const getRotation = (state, size, rotate) =&gt; { const axis = rotate.x ? "Z" : "Y"; const direction = rotate.x &gt; 0 ? -1 : 1; return ` rotateX(${state.x + rotate.x}deg) rotate${axis}(${direction * (state.y + rotate.y)}deg) translateZ(${size / 2}px) `; }; This function's goal is to produce a string which, i assume, is then used as a css transform. The return statement is using an es6 template string. If you're not familiar with them, it does two things that are important for this code: 1) it lets you do a multiline string 2) It lets you embed expressions which will then get evaluated and incorporated into the resulting string. So for example, `translateZ(${size / 2}px)` is the same as: "translateZ(" + (size / 2) + "px)" The rest of the function is calculations to figure out what the right values are to put into the string. It figures out the axis of rotation, whether it's a positive or negative rotation, sums the x and y values, etc. Then it spits out a string that looks something like this (i'm making up the numbers): rotateX(50deg) rotateZ(20deg) translateZ(10px)
The only time I've ever used it is when validating XML.
Any use of await *
jsize tells you the size of any npm package - awesome!
¬Ø\\_(„ÉÑ)_/¬Ø I think that looks awful but to each their own I guess. Letting people do whatever they want with React/JSX is great in theory until you work on different React-based projects and everyone has their own little ways of doing everything, because of a non-cohesive environment. 
 Hi! This is just a friendly reminder letting you know that you should type the shrug emote with three backslashes to format it correctly: Enter this - ¬Ø\\\\\\\_(„ÉÑ)_/¬Ø And it appears like this - ¬Ø\\\_(„ÉÑ)_/¬Ø --- *^If ^the ^formatting ^is ^broke, ^or ^you ^think ^OP ^got ^the ^shrug ^correct, ^please ^see [^this ^thread](https://www.reddit.com/r/john_yukis_bots/comments/6tr5vq/u_you_dropped_this_a_shrug_fixing_bot/)^.* ***^Commands:*** *^!ignoreme, ^!explain* 
Could you also do const foo = foo.bar || default If you're only checking for defined/undefined?
So from looking here: https://developers.chrome.com/extensions/bookmarks I'm guessing you're developing a plugin which does the following: function something() { chrome.bookmarks.create({ ... }) } Since `chrome` is a global object, I don't think you can do the normal `jest.mock()` since I don't think you're importing the module. Correct me if I'm wrong. With that said, assuming you're just calling the global `chrome` object, you can do something like: // https://developers.chrome.com/extensions/bookmarks#method-create // Need to mock the return value from the callback as well. // Probably best to be done in a seperate file and just `require()` it here. class BookmarkTreeNode { constructor(bookmark) { this.bookmark = bookmark } // Other mocking stuff // ... } describe('chrome.bookmarks', () =&gt; { beforeAll(() =&gt; { // Remember that `chrome` is a global object // Creating a mock implementation here. // Probably best to be done in a seperate file and just `require()` it here. global.chrome = { bookmarks: { create(bookmark, callback) { process.nextTick(callback(null, new BookmarkTreeNode(bookmark))) } } } }) test('creates a new bookmark', async () =&gt; { chrome.bookmarks.create({name: 'example'}, (bookMarkTreeNode) =&gt; { expect(bookMarkTreeNode.name).toBe('example') }) }) })
So I literally just did this at work and I used something akin to Elixir's convention based tuples of `{:ok, val} | {:err, error}` vs my code `{ok: some value} | { err: new Error('message) }`. I then decided to just use a true Result type and picked up https://github.com/Threestup/monads, since it allows the convention to be enforced and comes with some handy functions for working with Results &amp; Options.
You could modify your code to be more testable. Here's two different approaches: 1. Use dependency injection. Instead of using the global `chrome` object, pass it as argument to functions that use it. So in the application, you can use the real `chrome` object and in tests a mock. 2. Move all code that handles `chrome` object to own file. In tests you can mock the whole file. This may seem like unnecessary over-engineering but instead of writing simple wrappers, you can create a custom API that makes sense to your use-case.
I just think he doesn‚Äôt really know what he‚Äôs talking about. At all. And we are all apparently idiots for not agreeing.
&gt; it's the only way to handle code rejection Async functions return promises so you can still use normal `catch()` promise syntax like `await someAsyncFn().catch(() =&gt; someDefaultValue)`.
[removed]
I've never used noble before, but if [this is the right library](https://github.com/sandeepmistry/noble), then it looks like .connect() takes just one parameter: the callback. You're passing two parameters: the uuid (which is presumably ignored for not being a function) and the callback (which is presumably ignored because it's not expecting more than one param)
you can but that would also work for any falsy values, and it implies you know foo is not undefined. So better would be foo &amp;&amp; foo.bar || default. prefer a ternary operator with a very specific condition imho.
We use react in a jvm app without even nashorn... React runs in the client just fine, this guy just doesn't even know what he's talking about.
React works great just in the browser without server-side rendering though...
&gt; it implies you know foo is not undefined Fair point, this isn't great to bet on
I think he believes you can only run React if you're using server-side rendering. 
I have to admit that I use it a lot more now with async / await
Really nice, I didn't know that. Thank you for the heads up, it always was a downside of async/await to me... Not anymore! 
We use webpack and babel to translate to an es5 version that will run in nashorn for SSR. We use that same component on the client side. The only time you run into an issue is when you need the window object in your component which you can simulate but it's not necessary. Also, React doesn't need to have node you only need it if you want to use jsx. You don't have to use jsx then you don't need node to transpile. Not looking at a framework because you didn't get over the node requirement is extremely close minded.
You have to be careful with the catch. It is the only natively supported block-scoped mechanism in JavaScript.
What is it ?
Thank you :)
&gt; especially in regards to the use of TypeScript. Thanks for this. It's actually kind of incredible to see the knee-jerk reactions front-end devs have against TypeScript. I don't get it, I've never seen anyone have an actual problem with it, and it's saved me and my company thousands of man-hours over the last 4 years. I don't get the hate. 
I was hardly using it at all before, but not I feel like more of my code is wrapped in a try/catch than not when all my network and DB calls are async/awaited.
 $ jsize react + react-dom angular vue react + react-dom = 44.2 kB (gzipped) angular = 61.5 kB (gzipped) vue = 20.9 kB (gzipped) 
 $ jsize react@16.0.0-rc.2 + react-dom@16.0.0-rc.2 react@16.0.0-rc.2 + react-dom@16.0.0-rc.2 = 36.7 kB (gzipped) 
I don't like that you cannot filter on Exception class, like in (for example) Python you can do things like this: try: a = getStuff() except NetworkError: retryStuff() except SecurityError as e: callPolice() log(e) except Exception as e: log(e) raise e else: useStuff(a) finally: cleanup() It also has an else clause, which only runs when try doesn't raise, to keep the try block as specific as possible and only contain code you expect could raise. Also you can raise from within an handler and it'll chain the exception message. I hope for JS they can add this stuff in a new ES version. I guess quite a lot of it could be compiled to ES5/6 with some generated boilerplate. edit: ooh.. lets downvote discussion.. classy.
Thanks!!!! I've overseen this, that was part of my problem... I still have a problem with the db callback.. The output looks like this: [nodemon] restarting due to changes... [nodemon] starting `node ./bin/www` Executing (default): SELECT "id", "device_id", "name", "group", "status", "device_type", "prog", "white", "color", "brightness", "createdAt", "updatedAt" FROM "LEDs" AS "LED" WHERE "LED"."id" = '1'; 1 BEFORE BRIGHNTESS CHANGED 2 BEGINN CHANGEBRIGHTNESS FUNCTION 3 LEDID 1 4 updateBrightness 3 5 BEFORE DB CONNECT - LEDID: 1 6 AFTER DB CONNECT BEFORE RETURN -- UUID: Promise { &lt;pending&gt; } 7 BRIGHTNESS 3 8 UUID [object Promise] 9 AFTER CHANGEBRIGHTNESS VAR 11 END CHANGEBRIGHTNESS FUNCTION 12 BRIGHNTESS CHANGED Executing (default): UPDATE "LEDs" SET "brightness"='3',"updatedAt"='2017-09-10 18:15:29.181 +00:00' WHERE "id" = 1 (node:9694) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): error: operator does not exist: integer ~~ unknown (node:9694) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code. PUT /api/led/1 200 603.293 ms - 216 Is there a possibility to wait until the db returns the uuid?
&gt; I'm saying as a developer who wishes to use the best code IDE, Vscode is a better option. You state this as fact, but it really isn't one. The "best code IDE" can very dependent on what a person is looking for in an editor. There are lots of factors to consider like tooling, customizability, size of package-developer community, etc. In some regards VSC is better, but Atom is better in others.
blog post with bit more info: http://szymonkaliski.com/blog/2017-09-08-building-das-ui/
even better..dependencies!
looks dope, can you add mouse support tho
But why use 2 different templating languages when React does it both on the server and client? You will always need build tools, any real enterprise app will have a build step. What's even better is that we can use JavaScript instead of gradle. Not really a hack when it's in production.
Pretty sure you can filter inside the catch block using `instanceof(err)` along with a switch/case statement or whatever syntax it is.
A function called `checkData` that validates some JSON and then also inexplicably sets innerHTML on some random DOM element. Stopped reading there, no thanks. 
I refreshed my personal site: https://pakastin.fi üòé
I don't think this will ever work this way because JS uses duck typing. You might as well just have a `switch`/`if`/`else` chain in the `catch` block and it will pretty much be the same but allow for the flexibility that nominal JS programming requires.
that's not really accurate if you use async/await for the main benefit of assigning: const data = await doSomething().catch(() =&gt; someDefaultValue); console.log(data); This does not work.
[‚ÄúEvery time you build a to-do list app, a puppy dies. Here are some better project ideas.‚Äù](https://medium.freecodecamp.org/every-time-you-build-a-to-do-list-app-a-puppy-dies-here-are-some-better-project-ideas-279d4055f77)
VSC is better in every way, and objectively so. Atom is dead.
Yea, but that boilerplate would be a pain to write and maintain in a real project so they should put this behind some syntax in the JS compilers like Babel and TypeScript.
 &gt; async function foo() { throw new Error() } &gt; async function bar() { const baz = await foo().catch(() =&gt; 'baz'); console.log(baz) } &gt; bar() // =&gt; 'baz' Works for me in node 8.1.2, what happens when you try it?
You can do this to some degree in JS already. function behavior (input) { try { validate(input); } catch (e) { switch (true) { case e instanceof TypeError: //.. do things break; case e instanceof ReferenceError: //.. do things break; case e instanceof EvalError: //.. do things break; case e instanceof RangeError: //.. do things break; case e instanceof SyntaxError: //.. do things break; case e instanceof URIError: //.. do things break; default: //.. do things break; } } } function validate (input) { throw (input ? new RangeError("Out of bounds") : new TypeError("Wrong type")); } 
Thanks for the demo. Typing that up you'll agree the boilerplate and indenting is a bit cancerous. We need this with better syntax, should be easy to implement.
I hear ya, but lodash ain't too bad and in some cases, better performing than it's es6 equivalents. I like it for the additional support around dealing with null/undefined. (I'm trying to convince myself, here...)
&gt; IMO this is a bad use for try catch. You should have returned an object with a property that says validation failed like { valid: false, error: new Error() } What's missing in your advice is the part where you say "you shouldn't do this, because...". If you have to dig for a real reason that is more substantive than cheap word-play like "exceptions must be exceptional" you might find out you don't have much of a platform to step on to recommend against exceptions in scenarios where the specified action can't continue due to bad input. Coding the "happy path" and throwing when you deviate from it is a perfectly valid approach to structuring your app. Yes, even when validation errors are expected. It creates a simple, clear code flow and ensures that if something fails to acknowledge and handle the "sad path", your app doesn't blissfully continue operating with invalid assumptions and state. How is returning an Error better than throwing it? All I see is failure to use existing facilities for error communication (i.e. throwing) and reinventing the wheel through custom return results and flags, that can easily be ignored or misunderstood.
What's the difference between the boilerplate? Honestly doesn't seem like much to me.
In Python, isn't is discouraged to use try statements? Is there anything from this that we can apply to good js design?
With ES6 and async/await its actually very nice so yes, I like it :)
I totally disagree. That is a perfect place to throw an exception. With your suggestion, you need to pipe the error object through your entire call tree up to the point where you are going to handle the error.
Someone typed it up ITT, it is a big old nasty multi level deep blocky exercise in JS features and syntax optimisation. Imagine this in a real project and having those craggy warts all over your codebase. It is already terrible without any actual business code.
In general ducktype sure, but this could specify to use the prototype chain and `instanceof` semantics. Someone wrote the switch ITT, it is cool but no way you (and everybody else) would want that all over their code. Imagine having that on every await.. or lets not. If there was a good spec with compact syntax more people would use it as convention/standard (like in Python). This would be super valuable now we have async/await in JS and throw/catch becomes a thing to do (instead of error callbacks or Promise rejections).
ES6 + any kind of static typing with VSCode is acutally enjoyable in daily work
Came here to say ES6. Classes, async/wait, and promises ... it's actually a joy to write JavaScript with ES 6 features these days. I actually DO love JavaScript where I absolutely used to loathe it. 
In the last code you showed, UUID was a hard coded string. Have you changed that to be a promise? And where is the UUID being used?
PHP can filter on the exception class and it uses a similarly loose typing system. 
It wouldn't be too much trouble to create a utility function to achieve the same functionality: function matchException(err, matchers) { for (const type in matchers) { if (err.constructor.name === type) { return matchers[type]() } } return matchers.default() } try { doSomething() } catch (err) { matchException(err, { TypeError: () =&gt; handleTypeError(), ReferenceError: () =&gt; handleReferenceError(), RangeError: () =&gt; handleReferenceError(), default: () =&gt; handleOtherError() }) } You'd want to clean it up and add some more checks in `matchException`, but functionality is there.
Flatte manages your database for you with a manifest which is created by you. Client-Side NOSql Firebase Realtime Database modeling and management system.
I think rc-dropdown is a good option, which renders the drop-down content in different react-router using rc-trigger.
I love coding in JavaScript. I find the syntax pleasing and easy to understand. I like how you can alter any object prototype and essentially extend the language yourself, especially with things like getters, setters and proxies. Also, JavaScript has native classes now, but even before that you could easily polyfill such a thing.
This is my update code now: update(req, res){ return LED .findById(req.params.LEDId) .then(LED =&gt; { if (!LED) { return res.status(404).send({ message: 'LED Not Found', }); } if(req.body.status){ changeStatus(req.params.LEDId,req.body.status); console.log('STATUS CHANGED'); } if(req.body.prog){ changeProg(req.params.LEDId,req.body.prog); console.log('PROG CHANGED'); } if(req.body.white){ changeWhite(req.params.LEDId,req.body.white); console.log('WHITE CHANGED'); } if(req.body.color){ changeColor(req.params.LEDId,req.body.color); console.log('COLOR CHANGED'); } if(req.body.brightness){ console.log(' 1 BEFORE BRIGHNTESS CHANGED') changeBrightness(req.params.LEDId,req.body.brightness) console.log('12 BRIGHNTESS CHANGED') } return LED .update(req.body, {fields: Object.keys(req.body)}) .then(() =&gt; res.status(200).send(LED)) .catch((error) =&gt; res.status(400).send(error)); }) .catch((error) =&gt; res.status(400).send(error)); }, The BLE code: changeBrightness(updatedLEDId,updateBrightness){ console.log('2 BEGINN CHANGEBRIGHTNESS FUNCTION') console.log('3 LEDID', updatedLEDId) console.log('4 updateBrightness', updateBrightness) var uuid = getDeviceId(updatedLEDId).toString() var brightness = updateBrightness console.log('7 BRIGHTNESS', brightness) console.log('8 UUID', uuid) console.log('9 AFTER CHANGEBRIGHTNESS VAR') // Connect to client, find Service, find Characteristic and write status noble.on('discover',function(uuid) { uuid.connect(function(error){ uuid.discoverServices([lightningServiceUuid], function(error, service){ var tempLightningService = service[0]; writeFile("SUCCESS -- Discovered Service on UUID"); tempLightningService.discoverCharacteristics([brightnessCharacteristic], function(error, characteristics){ var tempBrightnessCharacteristic = characteristics[0]; writeFile("SUCCESS -- Discovered Characterisitc on UUID"); console.log('10 IN THE MIDDLE OF CHANGEBRIGHTNESS FUNCTION') tempBrightnessCharacteristic.write(new Buffer(brightness), true, function(error){ writeFile("SUCCESS -- Wrote brightness characteristic"); }); }); }); }); }); //Disconnect from client noble.disconnect(function(error){ writeFile("SUCCESS -- Disconnected from Client"); }); console.log('11 END CHANGEBRIGHTNESS FUNCTION') } The database code: getDeviceId(LED_ID,brightness){ console.log('5 BEFORE DB CONNECT - LEDID:', LED_ID) var uuid = client.query('select device_id from "LEDs" where id like \'$2\' ', [LED_ID]) console.log('6 AFTER DB CONNECT BEFORE RETURN -- UUID:', uuid) return uuid }, The output now is: [nodemon] restarting due to changes... [nodemon] starting `node ./bin/www` Executing (default): SELECT "id", "device_id", "name", "group", "status", "device_type", "prog", "white", "color", "brightness", "createdAt", "updatedAt" FROM "LEDs" AS "LED" WHERE "LED"."id" = '1'; 1 BEFORE BRIGHNTESS CHANGED 2 BEGINN CHANGEBRIGHTNESS FUNCTION 3 LEDID 1 4 updateBrightness 3 5 BEFORE DB CONNECT - LEDID: 1 6 AFTER DB CONNECT BEFORE RETURN -- UUID: Promise { &lt;pending&gt; } 7 BRIGHTNESS 3 8 UUID [object Promise] 9 AFTER CHANGEBRIGHTNESS VAR 11 END CHANGEBRIGHTNESS FUNCTION 12 BRIGHNTESS CHANGED Executing (default): UPDATE "LEDs" SET "brightness"='3',"updatedAt"='2017-09-10 18:15:29.181 +00:00' WHERE "id" = 1 (node:9694) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): error: operator does not exist: integer ~~ unknown (node:9694) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code. PUT /api/led/1 200 603.293 ms - 216 
&gt; In Python, isn't is discouraged to use try statements? Nope: https://docs.python.org/3/glossary.html#term-eafp . The idea is to let functions tell you if they could do what you asked them or not instead of creating a second set of "checker" functions. This style is much more resistant to race conditions as well, whereas "asking permission first" opens you up to the state changing between when you asked permission and tried to do what you wanted to do.
You really like this "exercise in JS features and syntax optimisation" I mentioned eh? :) Cool attempt, points for effort. Syntax improved but still a bit kludgy; it doesn't catch subclasses and behaviour on name collisions is a new factor. And most of all if you use block functions as clauses instead of references you'd be at 3 indents for handling code. Could be worse but it would be a tax on readability (and development/code hisotry) to have to break out to other functions all the time (it'd be handy to be able to nest a little bit without block hell).
Benefits: - Flatte provides to create a NOSql database model. - MySQL like transaction for Firebase. (If all conditions are passed, flatte sends the whole data to firebase.) - Client side processing. - Flatte handles copy records and external effects for you. No need to write everything in your application. (Denormalization) - Flatte allows you to create field based functions. - You can create your constants with predefined templates. (also with functions) - You can apply filters to incoming values. (Such as uppercase, date format..) - With Flatte Manifesto Builder, you can easily create and visualize your manifest. please fork on github https://github.com/Flatte/Flatte-Web Flatte manifest builder: https://flatte.maxabab.com
what if you want to handle the error or reject the overlaying call?
&gt; it doesn't catch subclasses and behaviour on name collisions is a new factor. re: name collisions, yeah, I went with checking names because otherwise you'd need to do something like matchException(err, { [TypeError]: () =&gt; ... } which I thought wasn't as nice as using string keys. If you went with the above approach you'd be able to catch subclasses via `err instanceof matchers[type]`. 
getDeviceId is returning a promise, so if you want to wait for that to complete, you'll need to call .then() on it. So a start would be: changeBrightness(updateLedId, brightness) { getDeviceId(updatedLEDId) .then(function (deviceId) { noble.on('discover', function (peripheral) { peripheral.connect( // etc ); }); }); } I don't see anywhere in your code though that you actually use the device id, so there's probably some other modifications you'll need to do to use it.
What pisses you off or wastes your time when you program?
If you want to do something with the thrown error, you can do it within the `catch` function as usual: const data = await doSomething().catch(err =&gt; { if (err instanceof TypeError) return someDefaultValue if (err instanceof RangeError) return anotherDefaultValue }) Or if you want it to bubble up through the call stack, you can rethrow the error or throw a new one, again within the `catch` function: const data = await doSomething().catch(err =&gt; { if (err instanceof TypeError) throw err if (err instanceof RangeError) throw new Error('value out of range') return someDefaultValue })
I like ES6&gt;, the eco system, the build tools that we've got. I don't script, i write applications. On the server, for the web, mobile and the desktop. There isn't a language for these tasks that i'd prefer over JS nor one that i would think is better suited. I've grown up with C/C++/C#/Java and i've used them for the longest part of my job, but nowadays i'm quite certain that for certain tasks (for instance frontend), given the same amount of money, time and workforce they wouldn't be feasible.
tbh it's pretty low on my list of things that need to be added to the language. 
With a static type checker it's usable, otherwise no.
Ok, I will try it.. I use the device id to find the matching uuid to connect to.
Interesting. when I looked into this with 7.x and the harmony flag I was told this was not possible. I don't know if they were wrong or something has changed.
Maybe this [Stackoverflow answer](https://stackoverflow.com/questions/19672685/setting-binary-data-on-img) will help. Also check out the links in the answer to information about receiving binary data and the Blob data type.
ok
&gt; Or since it's just two elements, you could unroll the loop: function getDistance(state, rotate) { return { x: Math.abs(state.x + rotate.x), y: Math.abs(state.y + rotate.y) } } I wrote my own comment about this before I read yours. What drives people smart enough to write code like this to such obscure solutions?
&gt; Prototyping just makes so little sense once you've been exposed to class-based object-orientation This doesn't really make sense. What is it about Prototypes you don't like? how the syntax is? how inheritance works with them? Also, what's your language of choice?
I use it, it's not really that slow for me, but then again, I don't code on a potato... Yeah, it chugs a bit when I accidentally open up a minified file, but I haven't really used a text editor that doesn't. 
I don't like try catches. Is there an anti-trycatch club I can join?
Maybe, but I think JS needs this for professionalism. Error handling is a such a neglected part. It was picking up with the node-style callbacks and the promise rejections but we need to push further. I've been doing a lot of python last few years where you have the syntax I mentioned and I feel being able to cleanly handle specific (classes of) exceptions like that really helps building more robust applications (and keep it readable and maintainable without boilerplate).
I like to lurk into node_module libraries source code to see how people smarter than me work with and that covers most of architecture and code design decisions. The UX part gets kinda trivial from there, reading examples from blogs or UX libraries
Interesting, thanks for sharing.
If you had many more properties than just two, i could see it being useful to do something like what they did. And obviously if you didn't know the properties until run time, you would have to do something like that. But with just two predefined properties, i agree that it's needlessly complicated.
Have been using JavaScript since 2004, back when HTML5 wasn't a thing, and ES6 didn't exist. *gasp* i actually liked it back then, and it sucked back then, and now with ES6 and React, eslint, etc, I love it even more.
Again, it depends on what you're using as a criteria. There are far less packages for VSC compared to Atom and it is much less customizable. Atom has very high usage, and to call it "dead" is pretty ignorant imo.
It's never enough, reminding people they're using broken grammar. 
I use both WebStorm and Atom. WebStorm for applications, Atom for libraries/general coding. WebStorm is a fully-fledged enviroment, I can set it up to automate everything in that project. Need something compiling? File Watchers. Need to debug two processes? Debug configs. Need to publish? Connect. It has many features that would support you through a sometimes laborious development process, especially with scabalable applications with about up to hundreds of files. It's designed to cope, it just falls short when you wanna get on with things. There's lots of fiddling with lots of menus, and there's not much chance you'll use ever feature. Atom on the other hand, is kinda like the LEGO of IDEs. You're given freedom to add whatever you want. Want a console? Add one. Want icons? Sure. Want a live reloading localhost? Here ya go. You can add in peices to make it yours, but it will never be enough to support serious development workflows. On the other hand, it's beautiful for just plain writing code. I can write code for hours in that thing: it has beautiful syntax highlighting for anything JavaScript I need, or even things like SQL, Markup, HTML, CSS. You can be more productive because it doesn't complain if you've spelt a word wrong and doesn't care if you're referencing things that don't exist (this can be done later in WebStorm or something). TL;DR - WebStorm does pretty much everything. Atom does what you want it to do.
I switched from Atom to VSCode. I'm sure VSC is objectively the best code editor at the moment and it runs great on my horrific PC.
LocalStorage can be considered the cookie's replacement. Although it has more memory (cca 5 MB), it would be better to keep track of the number of the jobs. You can store the jobs in a json file then use an api (there are many, google it or wait for another user who knows some) to fetch the data. 
Great that you made the switch. This is the story of every Atom user switching to VSC / Subl / WebStorm, just that some don't like to admit that they were wrong. Denial is natural, but they were wrong nonetheless.
Don't forget that JS lets you throw *anything*. Love catching strings or other random nonsense.
Probably not exactly what you asked, but from an architecture of an entire system/devops perspective, I always try and adhere to principles outlined here: https://12factor.net/
No it's not. - It's still regularly updated - Healthy package ecosystem My Experience of Atom / VS Code: I switched from Atom to VS Code about 4-5 months ago. It's better in some ways, but worse in others. - Performance isn't bad in either - VS Code seems to create more file watchers than Atom - Atom does use more ram and cpu - Atom sucks at loading large files, there used to be a package that could do this really well. I always work with large files in the terminal anyway though. - Atoms UI/UX is better - VS Code often has issues when trying to rearrange tabs - Atom can split code windows into top / bottom panes _(edit) and left / right panes simultaneously_ - VS Code has horrible placement of the debug controls - Atoms font rendering is nicer - Atom is more customizable - VS code goes out of it's way to not allow custom styling of the UI - VS Code has great built in git support - Although by default constantly bombarding the user to allow access to their private key is f*ing annoying - Atom does have git packages, but some of them aren't that good - Atom has git status highlighting in the file view - VS Code still doesn't have this despite it being a [heavily requested feature going back 2 years](https://github.com/Microsoft/vscode/issues/178) - Atom can have multiple projects open at the same time - This is coming in VS Code - VS Code has a built in debugger (even if the placement of the controls suck) - Atom has packages for this but they aren't really comparable - VS Code has great built in typescript support - VS Code's task launcher is great At the end of the day they both have a lot to learn from each other, and from other editors. I'll probably be sticking with VS Code just because it's node/js debugging is so fantastic. I really wish though that MS would allow adding to the apps css (Without resorting to editing the minified css which adds a sketchy label to the window title, and gets overridden each update).
It would strictly speaking be possible. However, by the same logic one could argue that JS should have type pattern matching using the same methodology. The reason JS does not is because, like you said, there have been essentially no major standards regarding errors in the past, and there likely will never be. So standard language features like that being added now would add fragmentation to the community. TBH, I've been professionally developing JS for over 2 years and I've been studying JS for at least 3 or 4 years now, and I have never felt a need for this feature. I understand the value, coming from other imperative languages, but I think it's more of an anti-pattern than a pattern. I think we would be better served to look at languages like Rust, which does not have a true exception system and instead promotes the pattern of returning a value which may represent either a success or an error type, forcing you to acknowledge all possibilities. It reserves exceptions (which it calls panics) for unrecoverable cases that imply a bug in the program itself rather than just an exceptional case the program should handle. If we're going to pick a standard, I would much rather we do that than implement a pseudo-pattern matching system based on prototypes.
If you want to somehow interact with the content of a web page, you'll need to write a browser extension, or use something like greasemonkey. If you have access to the underlying data source where the queue is managed, your better off using that. Otherwise, a chrome extension is probably the best bet you can play sounds popup displays, even send text messages if you wanted to. I wrote a browser extension that lets you make phone calls and send sms using twilio. No reason it couldn't do that based on a page event.
[removed]
async/await are ES2017 (ES8) features, not ES6.
I never said it was impossible, just that I didn't think it would be that valuable or fit particularly well with good JS coding style. If your argument is that we should follow PHP's style, then I'll have to respectfully disagree. =)
meh all electron based editors at this point in time will suffer perf issues, so im staying with sublime/Vim thanks.
Oops. Either way though. Those additions to the language definitely make programming in it much more enjoyable than previously
&gt; If you are one who truly love open source community and love to build your own tools. Atom makes that easy when you know JS. VSCode is open source and is written in TypeScript, so I don't really see how that only applies to Atom.
The technology is just not there yet.
I really like this. Maybe it's because I'm a power vim user who does genuinely believe in both the concept of visual programming (though it's almost always implemented absolutely terribly) and functional architecture, but this feels really good. I would love to see some sort of I/O system implemented so we could see how it might actually be used to create anything besides a functional library. Super cool though. Inspirational.
Hi, /r/iamverysmart!
Agreed. Async/await is so much cleaner than just promises, not to mention just callbacks (shudder).
FUD: Fear, uncertainty, doubt.
Shows that you really haven't used much (Sublime / EmEditor / Ultra Edit, all handle significantly large files just fine). Are you a "Wordpress / Drupal Theme Developer" by any chance?
You are either grossly misinformed or trolling. React doesn't care at all what is on your client side. In fact it is just a rendering library, it doesn't even have any built in function to call an API on any server. We use Java Spring as our backend with rest interfaces. React could care less, we use axios to call apis and react renders it. We've never touched a nodes server (which I assume is what you are talking about??). We don't (currently) do any isomorphic rendering, it is all client side. 
Why don't you like them?
First off, this is a completely pointless post. Code editor is simply **personal** preference. Nothing more. My preference is Atom. It has the best UI/UX for me by far, and a super healthy package system and community. Throw on Nuclide and an integrated terminal and it's golden. I've never had issues with speed, unless I'm opening a 1mb+ file, which lets be real, if you code correctly this never happens. I do own sublime too for this reason, but I open it maybe once per year when some client sends me an insane JSON file of all their data. Personally I don't like VSCode, while it is very good, I find the UI messy compared to Atom. Sublime truly is dead, it never gets updated and the plugins are no where near the quality of Atoms (see the ESLint difference parsing speed). Webstorm, I've never needed all the features it provides, for day to day use for me it would be massively overkill. --- **Personal preference** Atom. VSCode is also excellent. Sublime is outdated, you can use it, but you'll be missing out. Webstorm is overkill for me, however it is very good too. Your preference is your preference, don't attack others for their choices. You clearly just have something against Atom, if you tried to criticise the other options nearly as hard, you'd find the many faults with them too.
&gt; unless I'm opening a 1mb+ file, which lets be real, if you code correctly this never happens The first sign of a charlatan with a major conflict of interest is that they will sound like an apologist, and resort to ad hominem attacks. Try not to get personal. If you read the original post, I jotted down a list of points without a single derogatory remark directed towards anyone. I criticized Atom, not the people who use it. If that offends Atom users, that's for them to deal with. I welcome and respect everything you've said regarding the different editors, since you are entitled to your opinion irrespective of how delusional it may seem to me, but the verbiage regarding attacking others and calling out a non-existent bias was uncalled for. 
Question is, how are you using it daily? Straight up in the browser and still writing ES5? Or writing ES6+ with babel, webpack, flowtype, and a solid tool chain? The latter is great, the former is terrible. Javascript changed a huge amount in 2015-2016.
Um what? Are you saying that i have uncertainty / doubt regarding electron based editors (VScode, atom)? Sorry but no, it's demonstrably true electron editors have worse perf, it's been benched : - https://medium.freecodecamp.org/why-i-still-use-vim-67afd76b4db6 - http://blog.xinhong.me/post/sublime-text-vs-vscode-vs-atom-performance-dec-2016/ - https://www.youtube.com/watch?v=zsn257SnapQ Oh yeah and my favorite issue (albeit now closed) where VScode chewed up all the battery in peoples laptops from cursor rendering xD - https://github.com/Microsoft/vscode/issues/22900
You criticised EVERYONE in the comments. That is where that remark came from. Also in no way am I a charlatan, you're clearly just a troll, here for laughs. The quote of 1mb+ files, when in Javascript is that common? If so I'd question your knowledge in the matter.
WSH?
Classy with the name calling. Why so triggered, when I'm more than willing to be civil with you? Does criticizing ATOM result in PTSD triggers for you? Show me a single instance where I insulted anyone? (Quote me please, not editing any comment except spelling / grammar corrections).
You barely notice the difference. It has some weird VB data types like Enumerators IIRC. It was a think 20 years ago. I really don't see why you would use it now. Even if you are interested in WSH, surely node / electron can do whatever you need.
ATOM is significantly slower than VSC, Brackets is somewhat slower. What I'm getting at is that not all electron based editors have the same performance. Monaco makes Atom look like a joke. No opinion on Brackets though, haven't used it in a while.
What is `finally ` actually good for? What can you do in a "finally" block that you can't simply do afterwards, after the try/catch code blocks?
I've been fine with tween.js for a while now, is shifty better?
All of the above. JavaScript is langua franca so it's not like I have a choice.
Hate on me all you like, but I actually like plain old ES5. In my experience, an arrow function here or there makes things a bit cleaner, but I don't have any huge gripes about it. It's very different to other languages (i.e. prototypes) but I use it all the time with not too many issues.
If Tween.js is working fine for you, I don't see a need to switch away from it. Shifty is intended to be a simpler, more modern alternative to libraries such as Tween.js and GSAP, but you'll be set with whatever you go with ‚Äì they're all pretty good!
Maybe [Cabin](https://medium.com/@nparsons08/cabin-a-fully-functional-react-redux-example-app-updated-acc6389eeee8)? I just heard of it myself and still looking into it, but it seems to be a pretty good model for a production-ready full-stack webapp.
So what language would you rather use?
Not yet, I haven't learned JavaScript yet; still trying to wrap my head around jQuery at the moment
It's just personal taste, I feel it disrupts the code's flow.
What are you asking me?
Implement it, and publish it. It's a great way to give your idea some traction: working code that devs can use in their actual line of work. 
Hi /u/eXtremeRR, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `youtube: CodeWorkr`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [youtu.be](/search?q=%28and+site%3A%27youtu.be%27+author%3A%27eXtremeRR%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|10|56% [youtube.com](/search?q=%28and+site%3A%27youtube.com%27+author%3A%27eXtremeRR%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|6|33%
It has extremely limited use, but there are a few cases where you might want to use it. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch#The_finally_clause might help you understand a bit.
Hi /u/interwebzpolice, please don't use racial slurs.
Hello kenman, Thanks for the heads up! I'm sorry for this, I'm not trying to be sneaky in any way. I'm the author of these videos, well not this one in particular - this was submitted by a subscriber of mine, but it's still on the channel I own. However, the reason why I kept posting them is because I believe they're useful to some people - I've been getting positive feedback overall and people seem to enjoy them. That said, I just went through the guidelines and yep, I'm a spammer. It's just sucks that it'd be harder for people to find my content in future if I don't post it here because I'm a small channel, but rules are rules and intend to follow them. Again, thanks for bringing that up, it's better to be wary of that guideline sooner than later.
why am i getting down voted for pointing out bad code?
You can still post in the weekly [Showoff Saturdays](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts if you want.
Thanks for suggestion!
Love the minimalism.
&gt; inexplicably sets innerHTML on some random DOM element The reason it does that is so the code can be run and feedback can be displayed on the monitor. Yeah it's side effecting. But it's just for the sake of a demonstration. Maybe if you hadn't stopped reading you would have realized that
Thanks! üòéüëç
I think the main emphasis was on community. Atom relies on the community more to deliver the plugins. Whereas Microsoft develops them (albeit where it benefits them in this case TS and dotnet). So my point was that only reason VScode is so good for those tech. 
I've never tried coding an ext for code. But I'm pretty sure both APIs are equally good. Wasn't saying it was easier. First statement wasn't a comparison. Just a reason why people love atom. Maybe it's just me but the community on atom seems to be more accessible. 
Yeah, most probably a knee-jerk reaction on all the posts on "seriously why bother with atom". To each their own, right? Support what you love and make them better. Sorry if i came out too harsh. 
C#
Ooh good call. I'm just using it 'cause it's a fast shorthand at generating an array with the numbers I want, but I bet I could just throw that into a function and be done with it... EDIT: Updated to remove Array.from! Hopefully that's all of the problems.
in that case why not just `console.log` ? 
You can teach them es6 while avoiding the whole transpilation topic. Just demo/test on a modern browser. They'll likely never have to set up a build/webpack anyways. Just start off with function, variable introduction. At the end of their lessons they won't be able to do anything solo, but they may be ready to contribute as long as you hold their hand. Just aim for them learning something and not making them hate programming.
Try [JavaScript 30](https://javascript30.com/) by Wes Bos. That will give you an idea for content. Short demos with quick "wins" for newbies are the best way to get them excited to learn more. Stay away from complicated examples for start. 
Their error handling is coarse, and they get everywhere.
How else do you handle errors?
your boss is a moron if he expects you to give a comprehensive JS lesson to people who don't already know it on site. if that *is* what he expects then the best way to go is stick them in front of a computer and walk them thru one of the many learn-to-code-online sites like treehouse or whatever. any good coder knows not to reinvent the wheel. lessons exists online already. use them. otherwise teach them specifically the javscript commands they need to do their job and leave it at that. unless they're planning on doubling your salary, teaching javascript is way above your paygrade as a programmer.
localstorage is **not** the cookie's replacement. they have two entirely seperate functions. cookies are sent to the server, localstorage is not.
**Disclaimer** I am the author of this post. I wanted to get eyes on this idea/concept and figured I'd post my medium article here. If this is poor form, let me know and I will delete it.
I like it. I find its lack of strong typing and function-oriented objects to be a breath of fresh air compared to the ProblemFactory style of programming that Java encourages.
Prototypal inheritance isn't that far off from inheritance in c# (you run into the same issues with inheritance trees in both instances). Fwiw, I haven't used prototypal inheritance in js in a long time (favoring composition over inheritance for re-use).
jQuery? lol.. You could do a google search and find an example of how to do this in a [single line](https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref_audio_play) of regular vanilla javascript (plus some HTML), but if you insist on dragging jQuery into it, it would look like this: function playSound(mp3File){ var $audio = $("&lt;audio&gt;"); var $source = $("&lt;source&gt;"); $source.attr("type", "audio/mpeg"); $source.attr("src", mp3File); $audio.append($source); $("body").append($audio); $audio.on("ended", function(){ $(this).remove(); }); $audio[0].play(); } Then call `playSound("myMP3File.mp3");`. For storing data in a queue, you could use an in-browser database like [jSQL](https://github.com/Pamblam/jSQL/) (invented by yours truly).
Agreed.. From my experience, without async await it would have been try catch hell within callback hell... Never used it before, but now I do all the time
So, objectively looking at it, what benefit do you feel you've gained over the supposedly inferior practice of throwing Errors on ...having an error and returning result on ...having a result?
Because maybe they didn't want the reader to have to open up their developer tools just to read a blog post? Seems pretty obvious.
This seems like the right place for it. Thanks for posting. I'm happy to see [Edward Kmett's work](https://github.com/ekmett/lens/blob/master/README.markdown) reaching broader, mainstream audiences. 
Maybe I read through it too quickly, but while this is a cool way to maintain your reducers (I use lenses in mines too, they're nice), I'm misunderstanding the part about decoupling set operations. Selectors decouple views from the shape of the state. But in the same way selectors are the "gets", the reducers themselves are the sets. The reducer's entire job is to maintain the shape of the state. So what exactly does adding one more layer of abstraction here adds? The actions are not coupled in any way to the state's shape. The only thing that is is the reducer, and it's, quite literally, it's only job. (again, I read the article somewhat quickly, so excuse me if I missed the explanation)
I probably did a piss-poor job of explaining it in the post, tbh. To me, a `reducer`'s job in the way that I have seen it used most often is to retain the shape *while updating a part*. What I wanted to do is to remove the part of *retaining shape* and instead let my "reducers" focus on just updating a value. So using `lenses` as "mini-reducers", each updating just one single piece of state. For instance, given a `FETCH_USERS_SUCCESSFUL` event, you might set `users` to some part of payload, `tab.loading` to false, and a few other things that get triggered when you flip a piece of state. Using a `reducer` method that has to remain the shape while updating means that setting `tab.loading` might need to be updated each time that the shape of the `tab` slice of state changes, even though we are just wanting to update the value of `loading`. &gt; The actions are not coupled in any way to the state's shape. I meant to say that the reducer is coupled to the state's shape and that I was wanting to find a way to remove the coupling of the shape from the reducer. I realize that that complexity has to live somewhere and it might be better for the reducer to know the state of shape instead of just having actions update single values of the store. That's why I wanted to get eyes on this approach and see if this shift of complexity is easier to grok. &gt; So what exactly does adding one more layer of abstraction here adds? To me, using `lenses` to say 'When the business domain says User, it is talking about these parts of state' helps to remove the need of having to mirror that in your state shape. This is the great use of `selectors`. I wanted to use the same idea of almost snipe updating a piece of state given an action. The benefit is that now instead of in my reducers me having to say 'Okay, I changed what this key was, which means I need to go in all of the reducers that go below this key and change how I access it', I can just say 'Update username to this value' and what `username` means is defined in a single file for all of my application to use. 
Wow, I have no idea why I am still using Atom/Sublime compared to VSCode at this point. 
anyone who says they hate javascript is simply a shitty programmer. the fact that js doesn't come with things like inheritance, etc people think it can't be done, but anyone who actually understands the language knows it can do *everything* any other language can do. i use lots of languages daily and js is my favorite. i even have an "ex igne vita" tattoo. last job interview i had the interviewer told me the quickest way to determine a programmer's competency is to ask them what they think about javascript.
it didn't suck. es6 didn't add anything but convenience functions. there is almost no new functionality since es5. they're just making it easier for people who don't wanna take the time to actually learn the language.
Well is it an actual exception that would want execution to totally halt or are you using it as a lazy way to return a validation error? If it's the latter, then yes bubble the event all the way up. It's more explicit and readable. Otherwise relying on random errors being thrown throughout your codebase and having a top level error handler is a good bit more confusing and difficult to maintain.
Spread operators, modules, destructuring, native promises, async/await (technically es7), template laterals are all brand new things that make js incredibly easy to code with and are way more than not wanting to learn the language.
I've never understood this argument. Some engineers are so adverse to building their software on top of other software. If we always avoided dependencies then we'd all be writing in binary. Software is built on other software so we can build faster and greater things. Adding library dependencies is totally fine! Especially if it'll make your code more readable and maintainable. Now don't just go adding random libraries in NPM that have no support around them. You could probably just look at their source code and copy it. But something like lodash is an excellent thing to add.
[userscripts](https://greasyfork.org/en) are fun and useful to write. plus it makes u feel like a super leet hackerman without actually having to have a lot of skill.
Could I just ask what you think Angular has that React does not? I spent about a week or two learning it, and I felt that every decision or feature of Angular that was different than React was either objectively worse than the corresponding decision or feature of React or subjectively bad enough I think it's fair to say pretty much no one would want that. I won't get too deep into why I think that, but I'd like to hear what you have to say in favor of Angular.
spread does not provide any new functionality, it simply makes the programmers life a little easier. you could always use `apply` instead of spreading params. destructuring is just another convenience thing. you can do that with a loop in es5. modules, promises are just more structures that can be replicated with es5. not saying they're not handy, but just because the syntax is new to the language doesn't mean the concepts are. things like localstorage are actual new functionality, but everything you just mentioned is for the programmer convenience. localstorage and other actually new functionalities are html5 products that es6 has apis for. nothing about es6 extended the functionality of the language itself.
Start with this free course. It does not require any setup (has interactive playgrounds in browser) and can be a very good starting point. Don't go into ES6 unless they are comfortable with JS. [Introduction to JavaScript: First Steps](https://www.educative.io/collection/5679346740101120/5720605454237696)
Alright, thanks
You mean "good JS coding style" is to disregard the types? Because I think there are plenty of people that would respectfully disagree with that - at least I would. That's like saying the `instanceof` operator has no place in Javascript. I don't see how type matching in `catch` blocks would make JS less flexible... We don't have to skip features [just because PHP did them too](https://yourlogicalfallacyis.com/genetic).
It's probably too much work, but in case you're interested, there is a process that allows you to [submit your own proposal to the ES standards body](https://github.com/tc39/proposals/blob/master/CONTRIBUTING.md).
It's always good to realise that it's just syntactic sugar for Promises, so you can do with them whatever you can do with Promises.
Your example: const myThing = foo.bar ? foo.bar.buzz : defaultValue; ...also does type casting on `foo.bar`, if that's what you meant by "works for any falsy values".
I feel like I'm missing something, but I feel the same. It's worse because I think my main gripe is the extra indentation and the disconnect between the error handling and the source of the error, which feels like petty syntax whining. Therefore I usually just use Promises that I can catch, together with a linter that disallows me from leaving dangling Promises. And I'm afraid I'm going to regret that later...
I've now wrote it like this: changeBrightness(updatedLEDId,updateBrightness){ console.log('2 BEGINN CHANGEBRIGHTNESS FUNCTION') console.log('3 LEDID', updatedLEDId) console.log('4 updateBrightness', updateBrightness) var uuid = getDeviceId(updatedLEDId) .then(function(uuid) { var brightness = updateBrightness console.log('7 BRIGHTNESS', brightness) console.log('8 UUID', uuid) console.log('9 AFTER CHANGEBRIGHTNESS VAR') // Connect to client, find Service, find Characteristic and write status .then(function(uuid,brightness) { console.log('10 IAT THE BEGINNING OF CHANGEBRIGHTNESS FUNCTION') noble.on('discover',function(uuid) { uuid.connect(function(error){ uuid.discoverServices([lightningServiceUuid], function(error, service){ var tempLightningService = service[0] writeFile("SUCCESS -- Discovered Service on UUID") console.log('11 AFTER DISCOVER IN THE CHANGEBRIGHTNESS FUNCTION') tempLightningService.discoverCharacteristics([brightnessCharacteristic], function(error, characteristics){ var tempBrightnessCharacteristic = characteristics[0] writeFile("SUCCESS -- Discovered Characterisitc on UUID") console.log('12 IN THE MIDDLE OF CHANGEBRIGHTNESS FUNCTION') tempBrightnessCharacteristic.write(new Buffer(brightness), true, function(error){ writeFile("SUCCESS -- Wrote brightness characteristic") }); }); }); }); }); console.log('13 BEFORE DISCONNET CHANGEBRIGHTNESS FUNCTION') //Disconnect from client noble.disconnect(function(error){ writeFile("SUCCESS -- Disconnected from Client"); }); }) console.log('14 END CHANGEBRIGHTNESS FUNCTION') }) } and the new output is this: [nodemon] restarting due to changes... [nodemon] starting `node ./bin/www` Executing (default): SELECT "id", "device_id", "name", "group", "status", "device_type", "prog", "white", "color", "brightness", "createdAt", "updatedAt" FROM "LEDs" AS "LED" WHERE "LED"."id" = '1'; 1 BEFORE BRIGHNTESS CHANGED 2 BEGINN CHANGEBRIGHTNESS FUNCTION 3 LEDID 1 4 updateBrightness 3 5 BEFORE DB CONNECT - LEDID: 1 6 AFTER DB CONNECT BEFORE RETURN -- UUID: Promise { &lt;pending&gt; } 15 BRIGHNTESS CHANGED Executing (default): UPDATE "LEDs" SET "brightness"='3',"updatedAt"='2017-09-11 05:47:02.518 +00:00' WHERE "id" = 1 (node:1436) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): error: operator does not exist: integer ~~ unknown (node:1436) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code. PUT /api/led/1 200 545.967 ms - 216 So the LED is changed but it still don't wait for db response. Or do i need here at getDeviceId() another promise object? getDeviceId(LED_ID,brightness){ console.log('5 BEFORE DB CONNECT - LEDID:', LED_ID) var uuid = client.query('select device_id from "LEDs" where id like \'$2\' ', [LED_ID]) console.log('6 AFTER DB CONNECT BEFORE RETURN -- UUID:', uuid) return uuid }, I've tried it with: getDeviceId(LED_ID,brightness){ console.log('5 BEFORE DB CONNECT - LEDID:', LED_ID) var uuid = client.query('select device_id from "LEDs" where id like \'$2\' ', [LED_ID]) .then( function(uuid){ console.log('6 AFTER DB CONNECT BEFORE RETURN -- UUID:', uuid) return uuid }) }, But with this it stops at point 5..
Who cares?
You already have great PWA so why did you decide to build native app anyway? In what area native app beats the PWA? If you had to judge is native app more important than the PWA for your business?
I would start by asking for a raise unless training other staff is explicitly in your contract.
&gt; Which by the way is not this-aware nor does it contain the capacity to refer this lexically. That's like... almost the whole reason arrow functions were introduced. They eliminated the need for `var self = this` and `bind(this)`. Besides, the vast majority of functions do not need 5 different ways to set `this` depending on how you call the function.
Disclaimer: I wrote the article OP posted. &gt; Could I just ask what you think Angular has that React does not? This might be an unpopular opinion, but I kinda like `NgModule`s. It allows me to group components, directives, services, as well as their corresponding logic into a way where I could keep a clean code structure + directory tree. As I have said in the article, Angular is a framework, React is a library. The former occasionally has to put itself in weird, often off-putting positions in order to service the "framework" as a whole, whereas the latter outsources all the hoop jumping to whatever weird, brew-it-yourself glue you end up using to stick things together.
You mean greasemonkey. I have written a couple of greasemonkeys. And you are right I do feel like a super leet hackerman. But when I make bot the scraps a site then I feel like I am a next level hacker. But the thing is I don't want to continue to make suff that I can make. I want to make something that I can't make. Something that will require me to go and learn something new.
true, which is why I finished by saying using a very specific condition :) 
I am only wondering, what exactly do you mean by react code being not reusable? Components are pretty well reusable and composable...
&gt; In what area native app beats the PWA? This is a basic introduction, watch the first couple of minutes: https://youtu.be/WEQx3wz8QeY?t=53s I'd pretty much rephrase the question. If javascript is free of the browser and can render on every target it wants, why cling to embedded browsers as content hosts and a chunk of hacks to make the experience somewhat bearable for a small portion of users while the rest gets served plain websites as a fallback?
I find simple games to be good exercise, they usually combine a unique domain model with it's business rules, state management and interactivity in both input and output with a splash of math. Plus there are tons of great gaming ideas with varying difficulties to implement. i.e. Implement Tetris in whatever framework you're interested in or Vanilla JS. Use whatever libraries you're interested in learning.
Thanks so much! I'm in the same boat - vim everywhere, but I want to be able to lay out high-level code in visual form. I mentioned this at the end of the blog post, my next steps would be to port this to electron, have blocks as files, and allow require() and IO calls and all the cool stuff :) not sure when I'll get around to it though, I have personal projects laid down till the end of the year...
For those wanting to read more, I highly recommend [the Browser Networking book](https://www.amazon.co.uk/High-Performance-Browser-Networking-performance/dp/1449344763/ref=sr_1_1?ie=UTF8&amp;qid=1505120886&amp;sr=8-1) that covers WebRTC, STUN, TURN, ICE, and more.
and the JSFiddle too: https://jsfiddle.net/9wwa06tu/
I almost fainted when I saw the build pipeline!
Thanks for general answer but I know the difference between them and what they are capable of. However I'm interested in their specific case and their user experience.
You could not tell them apart from Swift/Kotlin made mobile apps, or native desktop apps on OSX/Windows. You write them in JS and perhaps Node, but they run native, their animations, elements and controls are native, they have the same freedoms and permissions and behave like everything else in their environment. They're also easier to write than PWA's, styles are very powerful, there's a large eco system. 
Angular makes a lot of architectural decisions for you, which takes a lot of the thought of project structuring out of the equation, kind of like Ember. React sort of just leaves you in the dust in that regard, which can be a good thing or bad thing depending on your perspective. Having too much freedom makes it easier to make bad decisions. And, though it's not unique to Angular, I'm a big fan of the services and dependency injection pattern, and the way it's implemented. It's actually taught me a lot about how I could structure applications using other libraries, Vue and React in particular. For a while, I used to feel the same way as you, that Angular was just worse in every way compared to other options. The biggest thing I couldn't get over was the templating syntax. That aside, once I dipped into it a bit more and thought a lot about the decisions the Angular team made, it was easier to see how someone could enjoy working on a larger application with it.
I was thinking of makeing a rouge like. But that would be a long term project but I think it will be worth it.
I¬¥m currently developing with Typescript, and I like it, the problem is that devs tends to use TypeScript with OOP (with this all over the place and impure functions every where), and that¬¥s sad, because FP and TypeScript could do better in most situations.
Someone was wrong because this is a basic tenet of how promises work.
&gt; Thinks using Jekyll is _too complicated_ on Github Pages - &gt; Suggests instead setting up React and a custom component to render Markdown files Okay!
for one, `finally` runs even if `catch` throws an error.
What have you tried and what tools are you using? Eg are you doing this with vanilla JS? JQuery? Also check the console when you make the request.. you might be getting blocked with cross site scripting security measures.
I've followed a few tutorials online but they typically throw in different variables (using multiple &lt;li&gt; or adding functions for clicking a button). I'm a Javascript noobie. I don't understand much of any of it. I have no idea what language I was using. I just followed tutorials that were online. I assume basic Javascript though. 
i generally assume when JavaScript is the subject, we are discussing client side code. I think the discussion is different when adding dependicies which haveother effects, like computational/loading bloating, like adding a dependencie to a client and only using 5% of its capabilities.
Edited.
I've just been through a 3 weeks quick introduction to javascript (which I knew well before but this was to get my entire class up to speed). I don't know if this will be very useful for you, but our teacher did a fantastic job of mixing theory with exercises. I would recommend to be really nazi about indentation and break the theory into small bits and make sure that everyone types the stuff and try to run it and see the results. He did a good job of balancing helping people who were stuck with simply moving on. It seemed to work well. An I would recommend not going into es6-stuff or any advanced topics. These people might not know what functions, control-statements or variables is, so starting with this might be a good start. Once that is covered you can move on to Dom-interaction/manipulation. One thing that were really awesome about my teacher was not using powerpoint - he just showed us how stuff worked from an editor with a browser. I think that was fantastic!
I know the struggle you are facing. It's very intimidating for a beginner to start learning suck a complex topic. Bouncing from one tutorial to another and from one unknown term to another can easily get you overwhelmed and stuck. Proper hierarchical structure and a clear path saves a lot of time. I'm currently working on this: A complete JS Roadmap starting from the very basics to the most advanced topics: [here](https://weeklywebwisdom.com/2017/09/03/javascript-learning-path/) I try to update it daily. Maybe it will help 
There‚Äôs the big one of native apps being able to run at 60fps while WebView-based apps can only run at 30. Using React Native you can easily call on the native layer to run the animations for you, so you get the full 60fps.
Thanks for the post! I would like to have a good lens library for JavaScript - in particular one that includes a solid set of type definitions for Flow and/or Typescript. I wrote [`safety-lens`](https://github.com/hallettj/safety-lens), which is a direct port of portions of the Haskell `lens` library. Unfortunately I was not able to get composition of different lens subtypes working in a way that would allow Flow to compute the correct to for the result. I've been thinking about redesigning the library to work with Flow's strengths rather than Haskell's by using intersection types to track the capabilities of each lens.
I would decide on a few core skills you need to know to get where you want to be. Want to go full stack JS? Learn a Node framework like Hapi or Express, and make sure you‚Äôre up to scratch on the skills required to write a production-quality server. For front end, you should pick a view library/framework to get good at. If you feel your JS knowledge is hindering you, try writing as much native as you can and get the core concepts down. After that, I would just learn things as and when you need them. You don‚Äôt need to know every framework inside and out, you‚Äôd drive yourself insane by the time you got halfway there. Just learn core concepts and features to the point where picking up a new JS library or framework is just a case of browsing the docs and reading up on best practises.
Hi /u/szymon_k, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
Update: we figured out it's due to a bug in Polyfill.io: https://github.com/Financial-Times/polyfill-service/issues/1299
&gt; Look. Think more critically about the tools you are choosing to use and don't just use them because someone told you to. These tools are meant to help you. I am not using these tools because I am uncritical about the libraries I use. I am using them because my employer makes me, and if I do not I will be fired.
It seems to me that you may not be used to working with promises, so let's talk just about them for the moment. This will be pretty long, but i hope it will be useful. After describing promises, i'll come back to talk about your code in particular. ------------------------ In javascript, you often want to do things that take time. For example, you want to request some data from a server or a database. But since javascript runs in a single-threaded environment, we don't want the thread to block while this is happening. Instead, we want to make a nonblocking request, then execute some more code, and when the request is complete we want to continue where we left off. The simplest way to do this is with a *callback function*. You've probably noticed that noble uses callbacks, but the simplest example of a callback function is probably setTimeout: console.log('before set timeout'); setTimeout(function () { console.log('timer went off'); }, 1000); console.log('after set timeout'); If we run the above code, it will print out "before set timeout", then it sets up the timer, then it immediately prints "after set timeout". One second later the timer goes off and displays "timer went off" Callback functions work, but they have some problems if you use them a lot. It's common that you want to do one asynchronous thing, followed by another async thing, then another, and so on. So our code can start looking like this: doThing1(function (result1) { doThing2(result1, function (result2) { doThing3(result2, function (result3) { doThing4(result3, function(result4) { } } } }); It gets even worse if we need to have error handling, since we need to check for errors every step along the way and manually make sure that those errors stop the rest from executing. For example: doThing1(function (err1, result1) { if (!err1) { doThing2(result1, function (err2, result2) { if (!err2) { doThing3(result2, function (err3, result3) { if (!err3) { //etc } } } } } } This situation has several nicknames: "callback hell", "the pyramid of doom"... Basically, it makes code hard to write, hard to read, hard to maintain. --------------------------------- So promises are another way to do the same sort of thing, but in a more structured way. Let me make up an example. Let's pretend that i have a function called setPromiseTimeout which is similar to setTimeout, but instead of using a callback, it uses a promise. This function doesn't actually exist, but if you're curious i can show you how you could create it. console.log('before set timeout'); var promise = setPromiseTimeout(1000); promise.then(function () { console.log('timer went off'); }); console.log('after set timeout'); As before, this will log out "before set timeout", "after set timeout" and then a second later "timer went off". But the way it's doing it is a little different. setPromiseTimeout returns a promise object. This promise object represents an *eventual* value. Every promise has a `.then` function, and using .then, you can provide a callback function. The same sort of callback function we did in the earlier examples. Eventually, the timer goes off, and it "resolves" the promise. When the promise resolves, the callback function gets executed. So far, this is not much different than simply using callbacks. We still needed to have a callback function, it's just used in a slightly different place, so what do we gain by using promises? There are two main things 1) Chaining When you call `.then()` on a promise and tell it some work you want it to do, this creates *another* promise. So this allows you to write code like this: doThing1() .then(function (result1) { return doThing2(result1); }) .then(function (result2) { return doThing3(result2); }); .then(function (result3) { return doThing4(result3); }); Or for a simple case like this, where the results of the previous function lead directly into the next one, it could be even simpler: doThing1() .then(doThing2) .then(doThing3) .then(doThing4); Compared to the callback example, we don't get this problem of becoming more and more and more indented. The code becomes easier to understand. 2) Error handling When you call `.then`, you can actually provide *two* callbacks, one for success, and one for an error. So something like this: doThing1() .then(function (result1) { console.log('we got our result!', result1); }, function (error) { console.log('it didn\'t work', error); }); Or if you only want the error callback, instead of .then, you can use .catch. `.catch(someFunction)` is the same as `.then(undefined, someFunction)` doThing1() .catch(function (error) { console.log('it didn\'t work', error); }); And the error handling combines well with the chaining. If an error occurs anywhere, the error will be passed along, and we can write a single error handler at the end. For example: doThing1() .then(doThing2) .then(doThing3) .then(doThing4) .catch(function (error) { console.log('something went wrong in one of the 4 functions'); }); ---------------------- Ok, now back to your code. First, I think you need to change some of your variable names. You're using uuid many times and it means many different things, which can cause confusion or bugs. Let's look at getDeviceId: getDeviceId(LED_ID,brightness){ var deviceIdPromise = client.query('select device_id from "LEDs" where id like \'$2\' ', [LED_ID]) return deviceIdPromise; } client.query is returning a promise. It does not have the value yet, but it returns a promise that you can call .then on. You mentioned trying to do the following: getDeviceId(LED_ID,brightness){ var uuid = client.query('select device_id from "LEDs" where id like \'$2\' ', [LED_ID]) .then( function(uuid){ return uuid }) } That was the piece of code that prompted me to try to explain what promises are, because it doesn't do anything significant. It takes the promise and calls .then on it. In the .then handler, it's doing... nothing. It takes the resulting uuid and returns that exact same uuid. Since .then returns another promise, you now have a new promise which is pretty much identical to the promise that client.query returned. You save that promise to var uuid, and then you don't return it. Since you don't return it, there's no way for the code that calls getDeviceId to call .then on it and get the final value. There is no way to have the result of the database query synchronously. You will need to return a promise object. So i think you should leave getDeviceId as you had it, just change the variable name to `var deviceIdPromise` like i did, to make it clear that this is a promise, not the actual id. ------------------- In your changeBrightness function, i don't know what this line is trying to do: .then(function(uuid,brightness) { It's calling .then as though it's working with a promise, but the line right before it is console.log('9 AFTER CHANGEBRIGHTNESS VAR') Which returns undefined, not a promise. So i would expect an exception to be thrown here --------------------- I also looked up your database error `error: operator does not exist: integer ~~ unknown`. It seems that the problem is that your database query is using `LIKE` with an integer, which doesn't work. https://stackoverflow.com/questions/42449756/postgresql-error-operator-does-not-exist-date-unknown https://stackoverflow.com/questions/25528780/pg-query-query-failed-error-operator-does-not-exist-integer-unknown-n 
Where you go totally depends on the quality of people around you and the problems you are working on. Always remember those two things are controllable. If you don't have a problem to work on go and find one. It's easy - at your workplace talk to someone (preferably with experience) about a problem they want fixed but don't have time themselves. You will automatically discover the tools you need when you have that problem. 
Wire a methane CNG gas sensor to a raspberry pi. Fart to trigger.
With jQuery, you can just select an element and load data into it: $('#Eth').load('https://api.etherscan.io/api?module=account&amp;action=balance&amp;address=0xe4a0ca1eb1cc8e19952763d2609cfaac70655e0f&amp;tag=latest&amp;apikey=717A6SD94Z36JGI13G3V6MVTZUDPZ8RI2A'); But you probably want to have it formatted nicely. You could do something like: $.getJSON('https://api.etherscan.io/api?module=account&amp;action=balance&amp;address=0xe4a0ca1eb1cc8e19952763d2609cfaac70655e0f&amp;tag=latest&amp;apikey=717A6SD94Z36JGI13G3V6MVTZUDPZ8RI2A', function(data) { $('#Eth').text((+data.result).toLocaleString()); });
[removed]
I accumulate a lot of notes and materials regarding JS when I tried to learn it properly. I'm working on a complete [Javascript learning roadmap](https://weeklywebwisdom.com/2017/09/03/javascript-learning-path/) which I hope will help both beginners experience programmers to learn/re-learn JS more efficient. Let me know what do you think! :) 
Personally I go all in with TypeScript. I think it would be annoying to have some functions/classes defined with types while others are not. My tslint and tsconfig are almost as strict as possible. &gt; The way I see it I can go all the way and make sure every class and function has their data tied to an interface I'm not exactly sure what you meant by that. You don't have to tie every function or class to an interface.
I meant to say type checked. Sorry, still a little new to all the terminology! Thanks for your input 
 fetch(url) //your url goes here .then(response =&gt; response.text()) .then(text =&gt; { const paragraph = document.getElementById('Eth'); paragraph.textContent = text; }) 
It composes the results better much like map, reduce, filter, compose better than a for loop. It also seems to force you to handle your errors to a higher degree (pretty subjective). I'm using it within a middleware so I essentially have this: const response = validate(validateParams).match({ ok(newReq) { Object.assign(req, { originalHeaders: req.headers, originalQuery: req.query }, newReq); return await handler(req); }, err: (err) =&gt; ({ status: err.code, headers: {}, body: err.message }) }) return response; The alternative would look like try { const result = validate(validateParams); Object.assign(req, { originalHeaders: req.headers, originalQuery: req.query }, result); return await handler(req); } catch(err) { return { status: err.code, headers: {}, body: err.message }; } Additionally, it becomes debatable whether the error is exceptional. A lot of people frown upon using errors as a form of flow control. Until the most recent version of node &amp; v8, try/catch blocks resulted in preventing your code from getting optimized (not sure how other browsers handled it). In turn, this means my code will run faster in older browsers and versions of node, while performing similarly in new versions.
Codecombat.com
This is what [Ramda](http://ramdajs.com/) is for.
Updated fiddle: https://jsfiddle.net/nnfy2tcv/
Echoing my comment from HN: I experienced what Mikeal talks about here when needing to do URL parsing: node has it's own URL parser which has been around for ages, but there's now a WHATWG URL standard that's also implemented in node, and by using that my module can work everywhere without needing extra code in browsers, and be familiar to more developers. Oh and re the other point in the article: obviously `await` indeed changes everything. `util.promosify()` is great but having `omit callback and I'll return a promise` in stdlib would be even better.
I agree with this. There's no point in going in half-assed. If you're going to do it, do it right and go all-in. That being said, you don't need to add annotations everywhere. Let the implicit typing do most of the work. const doSomething = (x: number): number =&gt; { return x * 10; } const z = doSomething(5); // don't bother adding an annotation for "z", the compiler can already figure out it's a "number".
Awesome, works great! What about the second part? I need the dropdown to change based on if the checkbox is checked or not.
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/AT75WIV.gifv ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dmuwgdd) 
Not to say that they deserve the traffic if they just let that go, but for now I'm just looking for a workaround. When you disable JS you can *view* it fine, but you can't answer questions. Is there a name for this problem?
Note that it's not difficult to create a copyFile function yourself, the difference here is that this is using a new feature of libuv that performs file copying much faster than user-land functions could. function copy (source, target) { return new Promise((resolve, reject) =&gt; { const rstream = fs.createReadStream(source) const wstream = fs.createWriteStream(target) rstream.on('error', reject) wstream.on('error', reject) wstream.on('close', resolve) rstream.pipe(wstream) }) }
I love the concept of your lib! I might have to check it out to see how useful it would be as a stand-alone helper for the paradigm I am using. I (almost) always use `ramda`so I get their `lenses` for "free" but for the `set` and `createReducer` library/helper functions it might be a better idea to use a lib like yours! If you decide to re-do it, I'd love to offer a helping hand. Not sure how helpful I can be but ping me!
I don't necessarily believe that it has *no* place in JS, but I don't think encouraging its use is beneficial either. Outside of the context of React (where classes are all but mandatory in some cases, and when they're not mandatory I skip them), I tend to use JS data structures similarly to how one might use lisp data structures. Factory functions returning anonymous objects. When I make result objects that may contain results or may contain errors, they're not constructed using `new` or `Object.create`. They're just POJOs. Adding type matching would enforce that I use one of these methods, even though they're not necessary in most cases. Further, if the error needs to be serialized, you would need to re-attach the prototype in order to have it follow the convention that such a feature would encourage. And if you're encouraged to use error types and encouraged to not put redundant data in the error type, that means the consumer will, in some cases, *have* to use `instanceof`, which is a pattern I disagree with. I do think if JS were redesigned today with backwards compatibility out of the equation, `instanceof` would not exist in the form that it is now. A form of pattern matching that checks content makes more sense if you ask me (and I believe it should be put in the language at some point). So rather than try { // ... } catch (ExceptionA as e) { // ... } catch (ExceptionB as e) { // ... } catch (e) { // ... } It would be more like try { // ... } catch ({ type: 'A', ...e }) { // ... } catch ({ type: 'B', ...e }) { // ... } catch (e) { // ... } This adds flexibility because my method of object creation works, but so does yours. `ExceptionA` could have a prototype field of `type` that is defined as `'A'`. I do agree that it would break exception inheritance (in that subclasses may not be caught as superclasses), but I believe that is less important than allowing POJOs to conform to the style. --- I would like to add that, if JS were explicitly/strongly typed, I would agree with you that `instanceof` or something like it might make more sense, but JS is not explicitly/strongly typed, and most of the libraries I use and create use that to their advantage by just doing duck type checking and not yelling if the input isn't the proper class.
https://jsfiddle.net/cwue7uoc/ - That should do it.
What is a "PWA"?
Hmm. `NgModule`s are actually among the worst part of Angular to me. It seems that they looked at npm's module system combined with webpack and said "how can we do this at runtime instead of build time?". I understand that it's attempting to do dependency injection, which is nice for testing, but it definitely feels redundant to import at the top and also in a decorator. It feels like a regression. Jest also handles turning npm modules into dependency injected code, but it's a bit harder to learn than other testing frameworks. I hear the "framework" vs. "library" comparison a lot, and I'm not totally sure I understand. I worked professionally in Angular 1 and this bothered the hell out of me, but I don't think that's even a controversial opinion. The fact that I couldn't just import `axios` to do my request handling really bothered me because it meant that any bugs the "official" AngularJS libraries had, I was stuck with. Do you think you could elaborate on the advantages of the Angular 2 method? I do understand that it plays nicer with external modules, but what does it provide that React or other very popular libraries do not? I understand, for example, that Angular and Redux is common, and that's usually what people mean when they say "weird, brew-it-yourself glue" (I do agree that learning Redux is usually harder than learning React itself). Again, I'm not trying to challenge, but only to understand. I understand if you're busy though, and I don't want to take too much of your time.
Your try... catch example is not using throwables to their real potential. As I do throw on validation errors and so I have practice with it, let me show you what your example could look like: validate(validateParams); Object.assign(req, { originalHeaders: req.headers, originalQuery: req.query }, newReq); return await handler(req); Where did the error handling go? It's not needed. The handler in your example is redundantly playing middleman between the validator and handler caller, but since exceptions automatically bubble up, we can just let the validator act as a *delegate* of the handler, and throw the same Error object that the handler would throw. The caller can that understand that Error and produce the appropriate error response for you. This is suitable not only for validation, but any auth checks or other invariants you must ensure in your handlers, i.e.: requireVerifiedUser(auth); // Throws if not verified. requireAdminUser(auth); // Throws if not admin. ... handler logic runs ... And this is very composable and reusable, without writing "try...catch" even once: // Elsewhere in your reusable code. function requireVerifiedAdminUser(auth) { requireVerifiedUser(auth); requireAdminUser(auth); } // In your handler: requireVerifiedAdminUser(auth); ... handler logic runs ... I'm itching to comment about how we can eliminate that Object.assign() too, but... another topic. 
Cool. I'm starting a new, very intensive job fairly soon, or I'd offer to help, but would you be open to collaborators in the future when you're more available? I see a lot of promise in--perhaps not this but--something like this.
Thank you so much, this is working pretty great. The only other issue is that when the checkbox goes from checked to unchecked, the "Delivery" option needs to be selected
Nevermind, I got it! Thanks again!
I see. I've heard that people like the services aspect, though I'm not sure why. I understand DI to really only be beneficial from a testing perspective (because it's hard to swap out modules without something like Jest), but are there other practical advantages that npm modules don't offer? One thing that I respect about this methodology is the idea that services/modules can actually be factories, which enables more flexibility. An example of this is when you do something like database work, the module can either create a connection by default, or it can be a function that initializes everything and essentially returns what would otherwise be a module. I'm not talking about the database library itself but rather something like a "model" module. Could you point to an example of a service that makes more sense as an Angular service than it would as an npm module?
Progressive Web Application, using service workers for caching assets locally, SQLite, local storage, push notifications, offline mode, etc.. 
&gt; I understand DI to really only be beneficial from a testing perspective (because it's hard to swap out modules without something like Jest), but are there other practical advantages that npm modules don't offer? In general, the easier it is to test a bit of functionality, the better. You end up with something more reusable and more flexible, even if you don't really care about unit tests. For example, you could have an AJAX function which accepts a `fetch` implementation to use to actually perform the fetch. By doing this, it makes mocking a `fetch` easier for testing purposes, but you could also, for example, pass in an implementation of it that performs differently depending on the scenario, from pretty much anywhere. Decoupling the code from its dependencies is probably the biggest advantage to making it more testable. &gt; Could you point to an example of a service that makes more sense as an Angular service than it would as an npm module? You could very well just have a node module that contains whatever functionality you want, then simply import that wherever it's needed and use it from there. However, doing this creates a hard link between your code and its dependencies, removing potential flexibility from the equation. And note that Angular's services aren't unique to Angular, it's just what they decided to call them. Redux and MobX employ the same kind of pattern of DI in React components, just that Angular services are meant for more than just managing state. In short, testability is probably the main goal of the services and DI pattern, but you get a lot of other benefits out of making code more testable. You end up with more flexible, maintainable code. I'll also add that there's no real benefit to how Angular in particular does DI compared to other frameworks and libraries. That's just preference. Angular probably opted to go full-in on DI solely for the rationale I've listed above, which I'm not even a fan of myself, but it's still a reasonable perspective. It might seem like extra work and boilerplate from the outset, but I'm sure the benefits are clear in larger apps.
Tl;dr the author prefers MVC and points out that object mutations are sometimes okay (with no examples of when or why). Not sure who the target audience is here or how this is a real problem in JavaScript.
The author's potential preference for MVC is not explicit and not relevant. I think you're missing the point of the article, which is pretty explicit in this paragraph: But the real issue is that the benefits of either static typing and functional programming lose their value if the programmers ignore principles like separation of concerns, encapsulation, the single responsibility principle, code reusing, putting things in the right place and naming things accordingly. Ultimately, being well organized.
Do you know why it defaults to "Delivery" instead of "Please Select"?
both are the same, though there is no point using `bind` if you aren't using `this` keyword: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
yeah sure! ping me at hi@szymonkaliski.com sometime in the future :)
Super cool! I wrote a package [vitrarius](https://www.npmjs.com/package/vitrarius), which is sort of the opposite of yours, I guess. It focusses on using lenses dynamically and, consequently, a bit dangerously. Would you mind if I reference yours from the readme as an alternative?
where can i find an online demo?
&gt; className isn't a JSX limitation though True &gt; Current React (16) also finally does False. `class` instead of `className` is not allowed with React 16. Same for `htmlFor` vs `for`.
here the official demo: https://demo.keplerjs.io/
I would do const redirect = (url, user) =&gt; { window.location.href = url + user.id; }; const login = (url) =&gt; { Auth.login().then(() =&gt; redirect(url)) } As the other commenter said, bind will let you modify the "this" and arguments, which isn't needed int his case. Unless all your functions return functions, having one random one do so would be pretty confusing, just for weird syntax promise. By switching to the anonymous function,you get the simpler function. In the first case, redirect doesn't redirect, it returns a function that eventually redirects. *keeps rambling*
&gt; if people can‚Äôt write sane programs in simple Javascript with mutations, are you convinced that they are able to do it with functional programming Totally agree with the sentiment here, functional programming is not some sort of magic bullet that removes complexity.
Hmm, I think you have a good point. The main issue is probably that it relies on nominal typing, which is indeed not often used in Javascript - and I agree that that's a good thing. Your post somewhat got me thinking that such a feature _would_ be nice if it was implemented in TypeScript, i.e. you could do a `catch(&lt;type&gt; e)` in there, which it would transform to a runtime structural type match (i.e. a switch statement in a single `catch` clause that would check for object properties). But that probably goes against the TypeScript principles and/or introduces too much runtime overhead.
I can't think of any project that wouldn't benefit from static typing. Even the smallest programs are easier to modify with autocomplete, compile time checks etc. Obviously bad code is bad regardless, but nobody is aspiring to that.
Someone had a bad day at the office...
Just tried, too bad, you're right. Dan Abramov one time said they're probably going to do it and the RC readme had something about class throwing a warning, i took it as a positive. Do you know if it will come or have they abandoned the idea again? Not such a big deal but i never understood why class had to be className, when style could be style.
With ES6 I think `bind` should only really be used when you need to set a context to the function (`this` context). Currying is useful if you need to call a function which either gets the rest of its values later on, or you're calling it repeatedly with the same base arguments. You can get a little more functional with this and use/write a `partial` function which allows you to do this easily (lodash has the same function as does ramda etc). Here's an example const partial = (func, ...preloadArgs) =&gt; (...nextArgs) =&gt; func(...preloadArgs, ...nextArgs); const redirect = (url, userId) =&gt; window.location.href = url + userId; const partialRedirect = partial(redirect, 'http://foobar.com/?id='); // sometime later partialRedirect(123) // --&gt; http://foobar.com/?id=123 `partial` has a lot of uses, you can partial partial's and keep stacking. It's one of the fundamentals of functional programming. I would definitely advise reading [functional light programming](https://github.com/getify/Functional-Light-JS) which does a deep dive into this and you'll learn a lot about currying, partial application and composability.
Interesting. Certainly performance would be much better on a maybe application, but I'm not sure there's much to gain using React.
Haha, yeah the legacy codebase I talked about in the OP was like a big ball of mud in many places. In a way, it's a good learning experience getting to work with obfuscated code as a way to push your limits, but I don't see why that usually gets spun as bad. I would spin it as, "if I can put up with ball of mud code, imagine how fast I would fly working with very clean, organized code". But anyways I do have a public portfolio of code projects. It's not all JavaScript but there's some there. [Github link here.](https://github.com/ccajas?tab=repositories) Some projects are less trivial than others.
THANK YOU SO MUCH!!! You've brought me a fair bit further! My code is now: changeBrightness(updatedLEDId,updateBrightness){ console.log('2 BEGINN CHANGEBRIGHTNESS FUNCTION') console.log('3 LEDID', updatedLEDId) console.log('4 updateBrightness', updateBrightness) var uuidPromise = getDeviceId(updatedLEDId) .then(function(uuidPromise) { var realUuid = uuidPromise.rows[0].device_id var brightness = updateBrightness console.log('7 BRIGHTNESS', brightness) console.log('8 UUID', uuidPromise) console.log('8,5 REAL UUID', realUuid) console.log('9 BOTH VAL:', realUuid, brightness) // Connect to client, find Service, find Characteristic and write status console.log('10 AT THE BEGINNING OF CHANGEBRIGHTNESS FUNCTION') noble.on('discover',function(realUuid) { realUuid.connect(function(error){ realUuid.discoverServices([lightningServiceUuid], function(error, service){ var tempLightningService = service[0] // writeFile("SUCCESS -- Discovered Service on UUID") console.log('11 AFTER DISCOVER IN THE CHANGEBRIGHTNESS FUNCTION') tempLightningService.discoverCharacteristics([brightnessCharacteristic], function(error, characteristics){ var tempBrightnessCharacteristic = characteristics[0] // writeFile("SUCCESS -- Discovered Characterisitc on UUID") console.log('12 IN THE MIDDLE OF CHANGEBRIGHTNESS FUNCTION') tempBrightnessCharacteristic.write(new Buffer(brightness), true, function(error){ // writeFile("SUCCESS -- Wrote brightness characteristic") }); }); }); }); }); console.log('13 BEFORE DISCONNET CHANGEBRIGHTNESS FUNCTION') //Disconnect from client noble.disconnect(function(error){ // writeFile("SUCCESS -- Disconnected from Client"); }); }) console.log('14 END CHANGEBRIGHTNESS FUNCTION') } and for the db connection getDeviceId(LED_ID){ //var intLED_ID = parseInt(LED_ID) console.log('5 BEFORE DB CONNECT - LEDID as int:', LED_ID) var uuidPromise = client.query('select device_id from "LEDs" where cast(id as text) like $1', [LED_ID]) console.log('6 AFTER DB CONNECT BEFORE RETURN -- UUID:', uuidPromise) return uuidPromise; }, My output is now: [nodemon] restarting due to changes... [nodemon] starting `node ./bin/www` Executing (default): SELECT "id", "device_id", "name", "group", "status", "device_type", "prog", "white", "color", "brightness", "createdAt", "updatedAt" FROM "LEDs" AS "LED" WHERE "LED"."id" = '1'; 1 BEFORE BRIGHNTESS CHANGED 2 BEGINN CHANGEBRIGHTNESS FUNCTION 3 LEDID 1 4 updateBrightness 3 5 BEFORE DB CONNECT - LEDID as int: 1 6 AFTER DB CONNECT BEFORE RETURN -- UUID: Promise { &lt;pending&gt; } 14 END CHANGEBRIGHTNESS FUNCTION 15 BRIGHNTESS CHANGED Executing (default): UPDATE "LEDs" SET "brightness"='3',"updatedAt"='2017-09-11 17:35:28.279 +00:00' WHERE "id" = 1 7 BRIGHTNESS 3 8 UUID Result { command: 'SELECT', rowCount: 1, oid: NaN, rows: [ anonymous { device_id: '4711' } ], fields: [ Field { name: 'device_id', tableID: 32833, columnID: 14, dataTypeID: 1043, dataTypeSize: -1, dataTypeModifier: 259, format: 'text' } ], _parsers: [ [Function: noParse] ], RowCtor: [Function: anonymous], rowAsArray: false, _getTypeParser: [Function: bound ] } 8,5 REAL UUID 4711 9 BOTH VAL: 4711 3 10 AT THE BEGINNING OF CHANGEBRIGHTNESS FUNCTION 13 BEFORE DISCONNET CHANGEBRIGHTNESS FUNCTION PUT /api/led/1 200 629.055 ms - 216 So this works fine, except the noble bit. But I have to read a bit more about how to connect to a specific device. And then there is my writeFile(), do I need to make it promise ready too? Code for this is: writeFile(fileInput) { var formattedTime = moment().format('YYYY-MM-DD HH:mm:ss:SSS'); if(!exists("../logfiles/status.log")) { open("../logfiles/status.log", 'w'); }; appendFile("../logfiles/status.log", formattedTime + ' ' + fileInput + '\r\n', function(err) { if(err) { return console.log(err); } }); }, When I include a writeFile("test") before the console.log("9...") I get the following error: (node:4578) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): TypeError: "callback" argument must be a function (node:4578) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code. and log 9 is not written Or do you know a better way to write a logfile?
What makes it faster ? 
Hi, I am the developer of this project. Please let me know what you think of it. It's a great example project to demonstrate React &amp; GraphQL since everybody knows and loves hacker news.
Your example probably doesn't fit well into the framework I use. The way it works is a bidirectional flow of code. handler 1 calls handler 2 calls handler 3, returns result to handler 2 returns result to handler 1. Your lowest handler returning something that could be a response to a request. If you throw down in handler 3 you now need to try/catch in handler 2, moving control of the error handling outside of the code that causes errors or build a top level error converting handler. Eventually someone has to handle the error and moving who handles the error to the farthest edge of your code is to me the worse place to handle known errors. There's a reason why many languages have adopted things like Option types and Result types, as throwing isn't composing code together. Lastly, your code doesn't support the ability to run validation across each piece of data prior to throwing or running your validation in parallel. My current implementation can be easily switched to become a list of errors rather than a single error, while throwing provides no opportunity to do so, which is something you'd want to do on something like user account creation. You can use an object spread rather than Object.assign, but there isn't much to be really gained from that. Even someone like Martin Fowler argues against exceptions and uses this particular case https://martinfowler.com/articles/replaceThrowWithNotification.html
Out of those projects, which single one do you think is the best example of your skills?
Yes, that is something that's been tossed around a lot in the TypeScript/Flow world, but as you said they're avoiding adding runtime features that aren't part of an ECMAScript specification (TS messed up by adding decorators too early, but other than that) on principle. A lot of functional languages that have JS as a backend do something like this, though, I think. Elm almost certainly does.
Flash didn't die because it was a closed platform. It died because it was bloated and insecure.
I don't mind at all! I look forward to taking a look at your library.
" you‚Äôre probably already using Babel to transpile from TypeScript anyway." if you had said tsc, I would agree with this statement. babel needs flow to do typescript proper and I'm not really sure it does have better penetration than tsc. "It‚Äôs a hodgepodge between a particular style of programming that helps squeeze more performance out of your code and elitism tendencies that follow after successful execution of the former!" I don't think I've ever seen an "immutable" version out perform a normal program. Usually the copies of copies means the immutable version is horribly slow with no hope of ever catching up. 
I think the error is because you don't have a callback when you call `open`. Perhaps do this: writeFile(fileInput) { function callback(err) { if (err) { return console.log(err); } var formattedTime = moment().format('YYYY-MM-DD HH:mm:ss:SSS'); appendFile("../logfiles/status.log", formattedTime + ' ' + fileInput + '\r\n', function(err) { if(err) { return console.log(err); } }); } if(!exists("../logfiles/status.log")) { open("../logfiles/status.log", 'w', callback); } else { callback(); } } So i'm creating a function called `callback` which does the appending. If the file exists, this callback function is called right away. If the file doesn't exist, we call `open()`, and pass the callback in to be executed when it finishes opening.
Thanks for the offer to help! I'll keep you in the loop.
Interesting! 
The libuv function does all the file copying in C instead of having to pass a bunch of bits to JS land just to have those same bits come back from JS land to libuv to be written to a different file. So those bits that needed to be copied somewhere else no longer have to cross the C/JS boundary.
Who's saying complexity should be removed? A feature-complete solution is necessarily of a certain amount of complexity regardless of how you do it. The value of languages with some feature is that the use of that feature makes it easier to think about your code and come up with easy-to-understand solutions. The complexity is still there, but, like a great piece of explanatory writing, you understand it more quickly. Even though this doesn't impact the complexity of the solution, it does impact the quality of the code. Aside from that, the tone of the stuff I read (and I've been following this subreddit for years, as well as other programming-related communities) about functional programming and static typing in javascript and derivatives is that they are techniques which can lead to better code, and they're useful to have in your mental toolbox. Responding to this with "But it's no magic bullet!" is missing the point entirely.
Neither of those worked for me :|
The article is, in general, tautological in nature. The author claims that if people don't write good code, the code will be bad. "You can't write bad code [when the programming language has this feature.]" is not a line of argument worth defending, and not one I see espoused except rarely, by people who are blowing smoke. The worthwhile conversation is about what kinds of solutions programming paradigms and language features lead you to use to solve various problems, and if these are more or less effective than one another along various dimensions.
Exactly! 
Yeah, we also tested TestCafe and Nightwatch first. But then we started to write our own solution so it could be used with ease even by non-developers
Hi guys, this a rendering subengine I did for ExpressJS trying to mimic PHP behavior. Feedback is welcome.
Honestly - never heard about it.. Thanks for info, we'll need to check their approach!
If it was an open platform, chances are, the security issues would have been caught earlier.
Filter network requests by XHR, all data should be there. However, you would probably need to chain requests, as the parameters are returned in previous requests. Will be fun, the end goal here is to make a function that returns the information that you want, using the endpoints that you get from the XHR requests. Example JSON data: https://i.imgur.com/cqH7Za4.png
Oh it might even be easier, I'm too lazy to check but check if all data you need is here: vfl3.betradar.com/vfl/feeds/?/favoritbetvfl/en/Europe:Paris/gismo/vfl_tournament_livetablebyseasonandround/SEASONID/ROUNDID replace SEASONID and ROUNDID, e.g.: https://vfl3.betradar.com/vfl/feeds/?/favoritbetvfl/en/Europe:Paris/gismo/vfl_tournament_livetablebyseasonandround/1214028/19
The 'great piece of explanatory writing` should include hiding the complexity, because, otherwise, if it's in your face all the time, you can't concentrate very well. Hiding it is, in a sense, removing it.
You seem to reduce the article to one word extracted from it. There are more ideas/questions in it. For instance, whether it's possible to write good programs with static typing and functional programming while it's impossible without them (this is different from what you wrote). Whether there is too much debugging being done. And, most importantly, whether there is enough awareness about the mentioned principles.
Really digging the name!
I don't use a linter on most of my small projects, never had unwanted behaviour as a result of omitting semicolons. The effort in semicolons is the need to break the cursor out of an object or array literal and when reading back they're visual noise to me. 
I've seen plenty of stuff within the last year that claims functional / immutable programming as a magic bullet, or to be objectively better than imperative / mutable programming. &gt; The complexity is still there, but, like a great piece of explanatory writing, you understand it more quickly That's the point the complexity is still there, and to me hiding the complexity actually makes code harder to understand. Your essentially bundling operations into an abstract name, that may or may not be descriptive. Even in the optimal case if you want to actually understand what's going to run, you have to jump around a lot more to figure it out. There is also a small performance hit you take by adopting a fully functional style.
But then what's the use?
One could say the code ship has sailed. 
It can be useful when you're prototyping or just starting with a solution and you don't want to define your types -- because you're not sure what the final implementation will be.
&gt; TS messed up by adding decorators too early, but other than that Agreed, but then again there was quite a lot of pressure on that from Angular, so there was little choice. But yeah, it's probably best if it's baked into the language.
Underscore is deprecated since forever.
This is only one small part of localization, namely: message localization. That's been a solved problem for years, however. Try localizing postal codes in 10 lines of code, then come back here.
&gt; Eventually someone has to handle the error and moving who handles the error to the farthest edge of your code is to me the worse place to handle known errors. You say that, yet in your example you literally mapped code to status and message to message 1:1. For many errors in an HTTP app you don't need such a narrow context. A 404 is a 404 is a 404. If it isn't you can **still** catch and change that at every level. But in **most cases you don't have to** and that represents a giant reduction of noise and boilerplate you need to write, read and maintain. &gt; There's a reason why many languages have adopted things like Option types and Result types, as throwing isn't composing code together. Not many, actually. All the mainstream languages prefer exceptions. Also let's not mix-in optionals with this. Errors and optionals are two different use-cases with two different solutions. The fact they both *could be represented with a union* doesn't mean that a union is the optimal representation. For example Swift, an example of a very new (and increasingly popular) language uses optionals for "has a value or doesn't have a value", but its errors are thrown, and they're showing no signs of moving towards "result" objects. &gt; Lastly, your code doesn't support the ability to run validation across each piece of data prior to throwing or running your validation in parallel. My current implementation can be easily switched to become a list of errors rather than a single error, while throwing provides no opportunity to do so, which is something you'd want to do on something like user account creation. You're not right about that - of course it can be a list of errors. This has nothing to do with whether you throw in the end or you don't. As I said, I have some experience working this way - when an Error gets thrown it contains an aggregate list of all errors in the input. That's not hard to implement, and once it's implemented and encapsulated as an API it's just as easy to use as I demonstrated. &gt; You can use an object spread rather than Object.assign, but there isn't much to be really gained from that. There isn't much gained from trying to make your request immutable as well. There are parts of it that can't possibly be immutable (i.e. any stream of size that you can't fit in RAM or sometimes even on disk). I've learned this the hard way, so you can believe me about it ;-) I understand what you're doing, I'm intimately familiar with the functional techniques you're using. But with all the boilerplate you write, all the pointless object duplication and ceremonies, be ready one day for people to finally see the Emperor is naked. Functional programming has many strong ideas and techniques, but it's heavily abused right now beyond its point of utility.
well svg is a start.
I'm just getting &gt;InstallError &gt;Installing the packaged failed. for everything I try
/u/has-ams Thanks man. All the data that I need is right there. Can you please tell me how you figured it out? I already have logic in my head how I will do things, I just want to know how you got to the url :) Thanks **EDIT:** Ah, I found that URL in the Network tab in developer tools. Thanks a lot man, really appreciate your help :)
&gt; Try localizing postal codes in 10 lines of code I wrote that to title to show how easy Express.js middleware system when creating simple localization.
Sometimes works, sometimes throws (as with vue-markdown) BuildError Failed to build this package
Again, this is only one small part of localization. I really don't think you have enough context to understand just exactly how small a part this is--especially since you haven't figured out how to handle placeholders or singular/plural translations.
That "copy of a copy" you are describing would bloat data storage, in exchange for the benefit of increased performance. It is the very logic behind classic caching algorithms, and this is why immutability a thing in the first place. Have you looked at WebAssembly? It is advised by Chrome programmers to apply static types to JavaScript to increase performance because JavaScript compiles to machine code that will physically branch execution based on predictability of data types.
Suggests that *Facebook* use React.
No problemo. For live data always check for xhr requests to find out the endpoint.
Design/development is much easier with Mongo/etc. if you know JS and don't know anything about relational databases. Further, there are many extremely ambitious applications that are a perfect fit for a document store, so this isn't a one is always better than the other situation. Therefore, I suggest 1) lots of research into the relative merits of document stores vs. relational databases (there is much material available on this topic), or perhaps 2) just use the document store because it's so easy to get started with and already makes sense to you.
Be careful about introducing "new skills" into your interview. If done wrong it can come across as "I dabble in this and that..." Nobody wants to hire a dabbler. They want someone to dive deep and solve their current problems now. So, that leads to two scenarios: 1) A traditional PHP/plain-JavaScript shop interviews you because you have those buzzwords on your resume or 2) A "modern" shop interviews you because you said you knew Node.js (for instance). At #1, (perhaps) you are coming across bored with the "old stack" and are talking up the new stuff. This simultaneously makes them feel outdated and that you won't roll up your sleeves and help them with the current environment. At #2, you come across as wanna-be "dabbler" in the new stuff, so (again) won't be able to contribute to their current problems. So, tailor your approach to the job you want. If you really don't want the old PHP/JavaScript type of job, leave that off your resume or create a functional resume that emphasizes the new stuff. Make sure your "personal" projects aren't toys (as others have said). The easiest way to do that is to contribute to substantial GitHub projects using the new stuff you want to work with. Worse case: You might still have to go after jobs that use "old stack" technologies but are potentially ripe for modernizing at some point where you could play a key role in that.
background : I'm a self taught developer that started with JS. I submitted my first PR on github 4.5 years ago and am now happily employed as an embedded firmware engineer (long way from JS, but I still dabble for fun). I don't have a degree and don't see myself needing one, though of course that may change. What follows is what Worked For Me (tm) Don't think about what technology you want to learn. Think about what you think should exist in the world, and then work backward from that and learn the technologies necessary to build it. Find open source projects that are inline with your interests and file stupid PRs for small bug fixes. Join the gitter chatrooms and niche subreddits and slack channels and weekly hangouts. Along the way you will find the people who speak your language, who care about what you care about, and who will point you in the direction of things you didn't know you didn't know. And they'll offer you jobs... because anyone can make a ToDo MVC demo in 6 different frameworks and stick it in their github account, but it's really rare to run into a person that's spent the last 6 months working independently on exactly the sort of problem that keeps you up at night. /endrant
Is npm case sensitive? I thought it wasn't, but this seems to be
It depends. You can think about mongo as a weak-typed language, and relational databases as a strongly-typed language. Relational dbs will have schema specified which cannot be violated (foreign key, ...) while in document dbs, you have to manage this logic in code. Sometimes, its better to bring strongly-typed language, sometimes javascript is great too. It depends on problem being solved, people, experience and preferences.
I was just listening to a podcast today about the kinds of tools developers can use/should be using. Essentially, go with what fits your needs and feels comfortable *and* what your client needs (if there's a client in the picture). So much stuff is coming out all the time it's impossible to learn everything that you're better off specializing in a couple of things. Plus, if you're working for a client, you have to consider what their needs are. Are they going to take on the technical skills to learn how to maintain their site once you're out of the picture? Or find a developer who can? Or do they want something more low-maintenance and more squarespace-y? Just go with what feels good to you and what you feel like you have the best results with. A good product will shine independently of the tools used to build it.
Seems to be case-sensitive https://www.npmjs.com/package/REACT
It's a 2013 video.
It's not very rare that packages are published and the author misses adding dependencies it requires in it's package.json. There is already an open issue about this on their repo - https://github.com/miaolz123/vue-markdown/issues/18 In such cases we chose to throw rather than continue, because without accounting for those dependencies, we would be reporting the incorrect bundle sizes. 
Strange. Could you try now, or give me an example of what you're trying to search?
I agree, unless their code base before wasn't performant, and they wanted to deploy to multi platform with a single base.
I didn't mention because, as I said, for last the last time again, SIMPLE localization. Thanks for interest.
They're referring to issues of horizontal scale (i.e. when your service grows so big you need to distribute it to multiple servers). You need to study CAP and ACID theorem if you want to understand this. Mongo is CP, RDB's are AC in CAP. Where you can use mongo, write heavy complex data structure (difficult to map with schema) workloads. Where RDB's rule is when operations need to be transactional (all-or-nothing, ACID). You should also look into polyglot persistence (coined by martin fowler) which involves using the right storage tech for the right reason (stack design).
This is not correct. MongoDB supports very different use cases from relational databases but those cases are valid cases. The kernel of truth is that NoSQL databases are often used for cases that relational databases are designed to support. As a rule of thumb: if you have relationships amongst your data there's a good chance you want a relational database.
I had tried ajv, pixi, knex, and a few others before. All working now!
That's not the point 
Forgot the (2013), sorry about that...
PIP is the other dependency manager I use. It's terrible in comparison to npm.
plus Steve Jobs
&gt; I don't think I've ever seen an "immutable" version out perform a normal program. Usually the copies of copies means the immutable version is horribly slow with no hope of ever catching up. Two things: 1) assuming you're talking about a full copy, that's really not how well-implemented immutable data structures work. They're typically built to leverage structural sharing such that most updates will only require actually copying a minimal, localized portion of the data structure 2) though there usually are some minor performance tradeoffs for updating, there are also performance advantages elsewhere. As an example, comparison for equality is essentially instantaneous. React uses this to avoid a lot of extra work during reconciliation.
http://mac.softpedia.com/get/Graphics/Drawscript.shtml But it looks like it is written in SWF, not Javascript.
Id argue that Composer is relatively easier/more put together than NPM, but I also don't usually have any issues to complain about with NPM.
Composer I think *is* better. But maybe it has an easier job. Have you ever developed a npm package?
I have, neither is necessarily fun to get right. I wasnt arguing on creating a package. Composers job is definitely easier - it autoloads everything and unlike NPM you don't have the chance that people will be using the modules on both back and frontend. 
Can you please make a more practical example when to use currying? It's really hard to find a good example. 
PostgreSQL has extremely good support for JSON (and BSON, etc), so there's really no point in using MongoDB.
I dunno, if it had been open maybe more of it would have been absorbed into the browser. Even so, it was a good trial-run for a lot of features we have now.
Well there was a moment there where the Flash looked like a viable (albeit closed) cross-platform ecosystem. If they had let Flash get their foot in the door, they may have lost out on having absolute control over iOS. People were not nearly so demanding that their tools be OS back in the 2000s. I'm sure Apple was aware of this and decided no way were they going to let Adobe have that opportunity, however slim it may have been.
You mean Mongo is AP and RDB is CP right?
No? Why do you think mongo is AP? https://www.quora.com/Why-doesnt-MongoDB-have-availability-in-the-CAP-theorem Furthermore why do you think RDB is CP? ... The whole reason 'No SQL' solutions were created in the first place is because RDB's are not scaled horizontally (partitioned) very easily. 
Because it only supports async replication and RDB supports synchronous. Async replication means that the data might not be consistent at all times this different nodes may return different copies of the data. Edit: Okay, Thanks for the link. I was reasoning about it on a lower level. Can you explain why RDB is AP?
Omg znode is what I've been looking for
I'm curious--to which podcast were you listening?
I think you might need to revisit what CAP theorem is :)
&gt; Edit: Okay, Thanks for the link. I reasoning about it on a lower level. Can you explain why RDB is AP? It's not, it's AC.
Then this is a waste of time. If you aren't even handling singular vs. plural, you're just mapping strings.
The Web Ahead. I think it was episode 79? It was under the category 'Education'. Jen Simmons has *awesome* podcasts, some of the best I've listened to.
It's not really a matter of seriousness but about the use case. If your data is related, then it's usually better to use a relational DB than a document based one. Relational DBs are good for related data. Here is a great article explaining why: http://www.sarahmei.com/blog/2013/11/11/why-you-should-never-use-mongodb/ Many people started using Mongo because of the MEAN stack, and also because being schemaless makes it easier to get started. With Postgres you can have a relational model using Jsonb types and still have schemaless fields that can be queried against. It's the best of both worlds IMO.
As far as manipulating the DOM, you can replace jQuery with Vue on a file per file basis, progressively. Vue is not only for SPAs and it will bring data binding to your workflow which will make your code much cleaner.
Relational database design creates and enforces a rigid structure for the data, and has constraints so that data can't get screwed up (e.g. deleting a library patron account when borrowed books are outstanding). MongoDB et. al. simply persist a JSON object "document" which is very convenient, but you have to manage the data integrity at the application level. So, it depends on the complexity and importance of the data. Banks don't use MongoDB, but it's probably ideal for saving reddit comments. There is a hybrid approach where SQL Server and Postgres (maybe others too) allow saving of JSON object "documents" into a relational database field, so you get that flexibility but within a relational structure. 
Great idea! It seems to be parsing `package.json` incorrectly though - it's complaining of missing Redux `peerDependencies` for https://bundlephobia.com/result?p=redux-persist@5.0.0-beta.13 (the non beta version loaded fine), but `redux` is clearly marked as a peer dependency - $ yarn info redux-persist@5.0.0-beta.13 | grep peerDependencies peerDependencies: { redux: '&gt;3.0.0' }, Edit: After retrying for a few times it suddenly worked. Weird. 
We are currently in the [Trough of Disillusionment](https://en.wikipedia.org/wiki/Hype_cycle) for NoSQL databases. They were hyped beyond belief in recent years, but people have now come to understand their limitations. Some people are therefore completely disregarding them. But there are use-cases that NoSQL databases are better suited for than relational databases (see other replies), even though they by no means replace relational databases like people thought they would.
/u/stupidblackbear yo dude
Yeah it looks very... promising. Also, as a shameless plug, here is a simple RPC library I whipped up a couple years ago to enable simple prototyping on similar principles: https://www.npmjs.com/package/remote-control
There are no points in using MongoDB. In most cases, your data will have relations between them, so you should use a relational database. In rare cases where your data are unrelated documents, you could use PostgreSQL to store them, since PostgreSQL has rather good support for JSON.
realize that everyone is more or less in the same boat. be a man and make ur own decisions.
I use angularjs not jquery. I did a little research about Vue and I really like it. Vue compontents are pretty similar to angularjs components so this will make the switch moderately easy for me. 
Learn both. It'll only take several small size projects to get fully acquainted with either. After you're familiar with one, those skills will provide context for learning the other. Once you understand both, you'll also understand the advantages both have and know when an application would benefit from a relational/non-relational design. That understanding is something you can't from a few paragraphs on Reddit. Also, enjoy it! Programming is about learning new paradigms, not about being right.
i use lenses in all my reducers that can't be done with just a assocPath call from ramda. we don't move them out into another file or really use them anywhere but the reducer (we have selectors for getting data) so usually they are just used for R.over operations
Looks interesting. But what's purpose of functions like R.F();? It is absurd for me.
Have you actually finished the first version (without automatic refresh)? I would finish that first before essentially rearchitecting everything. Answers to your questions: 1. No clue. Run load tests based on the SLAs you define and expected number of simultaneous users. 2. No idea. What is preventing you from implementing WebSockets in PHP? 3. MySQL. Why change the database if you don't need to do so? 4. What does Sails offer that you can't get with Express? 5. Sure, but what are your requirements around authentication? Do you understand the tradeoffs of JWT compared to OAuth 2.0 bearer tokens?
If you use VS Code, the [Import Cost](https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost) extension does something similar. It mostly just makes me feel bad every time I `import`.
[removed]
It's based on your use case. If you have several entities (users, clients, tasks, etc) and they maintain the same data structure, I'd go with relational, and vice-versa for NOSql. At my job we use mongoDB, and it works, but we're finding that relational would have a lot of advantages. Best thing you can do is learn both 
I have worked as a MySQL/MariaDB DBA for years - so I should be biased towards either of the two camps (MySQL, MariaDB) I am also a Node user and have a couple applications, one that does hundreds of thousands of requests a day, so like my peers, I should be strongly biased towards MongoDB I'm also a Ruby fan, and we all swear by Postgres and Couch. I've got a friend who loves Erlang, his community seems to enjoy Cassandra and Riak. The truth is, any extremely mature database tech will get you far enough to the point where you have can have a business and hire someone like me to fix it. A very very badly designed MySQL database can be well indexed and read-replicas can be used and you can scale out (albeit expensively) to enough customers to get venture funding and hire me. Same goes for Mongo, Cassandra, Dynamo... The things an `i3.16xlarge` can do, oh baby... Personally, I prefer Redis and MariaDB 10.2 - Both are in use every day powering some of the most trafficked sites on earth. I know how to scale, tune, replicate, back up, etc etc etc both of them - and so do a hundred thousand other linux nerds. TLDR: You can't choose wrong if you _just want to build a product_, but I recommend picking something extremely mature and popular if the goal is for it to _not be a time sink_. When I think of simple+mature+popular I think of Mysql, Postgres, MongoDB - you can't go wrong.
This is true. MongoDB should only be used the the silliest of applications.
Ironically, relational databases are quite bad at relations. JOINs are some of the most expensive operations. For relational data I'd go with a graph database (e.g. neo4j). Relational databases provide a wide range of solutions to tackle common needs (geoqueries, json, normalised data, ...) and are therefore good candidates for most project, unless they have specific requirements.
Great post, I like how you enumerated each library that you used and why you picked them. Do you have any plans in adding a comments section? If so what are you planning to use? 
Very Interesting tool pastelski! Just start working on a cli to get your metrics from the commandline: *bundle-phobia-cli*: [npm](https://www.npmjs.com/package/bundle-phobia-cli) [github](https://github.com/AdrieanKhisbe/bundle-phobia-cli)
I think schemaless is a misnomer - even if you don't have a schema in your database, your code will need to identify a dependable structure at some point. There are many ways to work with this - you can migrate data structures on read or use backend batch migration or even deal with the variations with code. But schemaless always implies for new people that there is no cost when making major schema changes. The big difference is that you can deploy new code without a database migration... but that doesn't mean the new code will necessarily work with older structures unless you've thought out your approach. Also this coming from someone who's used both, appreciates they both have value for the right use case as you mentioned. Also not an app developer any more but still have a hell of a lot of nostalgia for it.... if only not for the wide swathe of middle management which always seems to appear who are never technical.
If you find out what content it's actually pulling in you could intercept the network request using background workers or add it to your block list (ublock or adblock etc). That way the network request would fail but the rest of the site should work fine.
The article may be misleading and not a solution to the whole idea of localization, but you could be a bit nicer when giving feedback.
I'm not sure what you mean by "serious application" - do you mean `serious [web] application` like a line of business web app? Yea, relational probably beats out a document db in most cases.... if you have a schema that isn't likely to change and relations between schemas -- sql for the win. Or do you mean "serious application" like something that needs to be applied, seriously. In which case, mongodb has it's uses, certainly. Imagine you have completely random data. Well, not "random" but certainly with enough tentacles that you can't realistically create a schema that matches it all. An example: you've built a fancy web app (using a relational db, surely) and now you have some logs for it. You go all out and are doing request and response logging with transaction ids spread throughout various microservices. Ok, this data is in JSON... and you wanna get a picture of how a single user interacts with the myriad of systems you have. Now where in the heck are you going to put all this log data so you can get the "big picture"? You've got POST bodies, request headers, strings and context from application logging, errors, etc, etc. all sorts of junk in there... where does it go? The answer: document database. There are tons of different types of databases and they all have their niche. If you wanna be .. ehm... employable... you're going to need to learn at least SQL -- the bread &amp; butter of web applications is toasted with SQL. If you wanna be *gainfully* employed, learn many many types of databases, what their niches are and why they exist. No one in their right mind spends countless hours building a database engine because it's trash and/or useless... each has it's use.
What does good mean here? Extra performance on X?
You can build a non-relational database within a relational database server. Having the data human editable may seem a great thing in development, but rarely has any useful application outside of that. Data is Data. The database you use and the way you store the data should be informed by the project, not a preference. However, if all your devshave MSSQL knowledge, leveraging that, but using a key-value structure may be better than retraining on a new platform, and supporting it. 
No-one talked about Cassandra a Amazon Dynamo. Thoses db are one of the best in the world in terms of scalability and availability. Also very good in performance. And they are NoSql as far as I know. They are the 2dbs used in a majority of world-scaling projects. I think ppl should avoid talking performance without testing themselve :/ its often wrong tbh. So, if you mind about perf, I would suggest you to quickly setup different db with a few "docker run thebdyouwant" and do your tests. If you have trouble with a document based db, its neitheir you didn't created a good schema in the first place (most cases), or your useCase is VERY relationnal. 
I don't know if you can say that. Flash being an open platform would have changed its trajectory so much.
If you are going to work with technology you will be seeing new languages, frameworks, ... Some you will love. Some you will have. Some will be totally over hyped. Some will never reach the credits they would deserve. Too many things to learn ? Yes, sure. Don't be scared. Keep a flexible mind and enjoy it
If there may have been a good use case for document databases (note I'm not including all NoSQL here but addressing OP's question), it has died with the advent of technologies such as postgres' BSON. Document databases give a false sense of comfort to developers who don't want to think about the real problems of serialisation, and gives a temporary pass. Mongo's 1 advantage was proper use of mmap, it lied about it's consistency guarantees and its only scaling, horizontal, didn't actually scale. Once you discover the problems of consistency and scaling you have a nearly unsolvable problem, and probably financial interests too at that point. edit: thank you to sickcodebruh420 for pointing out I should have written JSONB and not BSON
Well... I prefer mongo and I use mongoose to achieve some relationships between collections and one of the best selling point of mongo is the JavaScript interface and horizontal scaling... if u want that go for it. I did use rdbms but sometimes scaling can be a hassle there.
We started using MongoDB in end of 2009. The reason we went for it over mysql or postgres is because of its much easier replication system. We needed small bits of data that almost never change at very high speeds. Now we just use compose.com for not so important smaller chucks of data and for all bigger projects mongolabs with our own servers. It really depends what data you have and on what scale. On reddit in general you won‚Äôt find much support for MongoDB and SQL databases are pushed hard especially the standards like postgres and mysql. Nobody mentions services like compose.com that now run your sql services for you or MariaDB etc. there are also nicer alternatives from the last few years like Crate but it seems to be all ignored in favor of the two known free databases.
can't wait to learn vue!
Don't wait!
Talk about jumping in the deep end... I'd have a go at improving the UI first as that's easier - to get used to syntax etc. Then look at auth options like oauth using ajax or a fetch, then for api calls. 
Relational databases are great if your data is relational. Document databases are great if your data is non-relational. If you're looking for a primary datastore (the central source of truth that drives your app), then your data is *almost* certainly relational. There are a few exceptions, but they're rare. If you're looking for a cache, maybe somewhere to stick some denormalized data...a non-relational database is a great idea. And in some cases, a document store would be a good idea, and maybe even MongoDB; it started out as a truly execrable disaster, but over the last few years they've redesigned, rebuilt, and duct taped it into something quite decent. In other words: 1. I'd like to have a single database to drive this project, what should it be? Postgres (or MariaDB, whatever). 2. I've already *got* Postgres, but I've got tons of non-relational, denormalized data I need to shove into a glorified key value store and access quickly, should I use MongoDB? ...sure, if you like. Concrete personal example: A while back I was young and dumb and tried using MongoDB as a primary data store for a fairly basic CRUD app (basically a glorified address book). This was a *horrible* mistake. Conversely, right now I'm working on a mature application that has a ton of very relational data, which it needs to crunch through in an expensive operation to generate extremely complicated denormalized JSON blobs, which then get served to clients. I'm currently shoving them in Redis, but MongoDB might actually be a better choice. It's all about using the right tool for the right job, and MongoDB is a bad tool for the generic "I want to store a bunch of data, then query it later"; just use Postgres. Also, I know it's already been linked, but: http://www.sarahmei.com/blog/2013/11/11/why-you-should-never-use-mongodb/ Seriously, read it.
Don't write off all document stores because of MongoDB. MarkLogic is a document store (in fact, multi-model with documents and RDF triples) and provides full ACID transactions (across multiple documents, unlike Mongo) and it scales *very* well. It also views security as a major requirement and provides high availability and disaster relief -- it's a serious database for serious applications. I disagree about the false sense of comfort. It's much more flexible to not require a complete schema up front, but we understand that doesn't mean you don't need to understand your data. The approach allows a development team to be agile with data in a way that is painful with relational data. Disclaimer: yes, I work for MarkLogic. I've been there almost 8 years, largely because the technology has impressed me. --- edit: s/series/serious/;
&gt; Banks don't use MongoDB, but it's probably ideal for saving reddit comments. This isn't because of MongoDB being a document store; it's because of other limitations. There are document stores that provide the enterprisey features that a bank expects. (And yes, there are major banks building critical applications on document stores.) 
I'd recommend React, it's dead simple
https://github.com/babel/babel-preset-env
There was a blog post about a year ago called [When to Avoid JSONB In a PostgreSQL Schema](https://blog.heapanalytics.com/when-to-avoid-jsonb-in-a-postgresql-schema/). The problems he points out are easily managed in a dedicated document store. 
I do not. I see fantastic value in BSON, graph DBs be they RDF or not, as well as time db-s, rrds, memcache-types and redis for its specific algorithms. I just disagree with the premise you can scale by throwing money at a problem, and I have a rather active hate towards MongoDB because it took them so long to do just IO right, while they lied about it, not to mention the rest of its technical defects. I just want to emphasise that there is a rich and diverse ecosystem for handling data persistence and retrieval, not because it's fun for us all to learn every algorithm, but because they are needed. And document dbs insinuate to beginners that there is no need to continue the work of an IT professional into "dba" territory. I believe your index structure should be a strong deciding factor in designing UI, and believing otherwise is a disservice to users =) edit: thank you to sickcodebruh420 for pointing out I should have written JSONB and not BSON 
&gt; Where RDB's rule is when operations need to be transactional (all-or-nothing, ACID). Disagree -- there are NoSQL databases that support true ACID transactions. &gt; You should also look into polyglot persistence (coined by martin fowler) which involves using the right storage tech for the right reason (stack design). Even better, look into multi-model databases. The benefits of polyglot without the operational complexity. 
Don't worry is only a hobby/learning project so it's okay if I restructure some things 2. Is better do PHP with WebSockets than use them in NodeJS?
&gt; Should I use vanilla JS for that or JS framework? Which framework would should I use? "Vanilla js" for UI related tasks that are dynamic is a waste of time. I would also recommend React. It is very easy to learn, there are few foreign concepts and it is close to javascript. [It has the biggest userbase/component eco system as well](https://npmcharts.com/compare/react,angular,@angular/core,ember-cli,vue), so most of what you need has been done/implemented already by others. I liked eggheads introduction because it also guides you through build systems, which are equally important: https://egghead.io/courses/react-fundamentals
The document-based NoSQL idea is actually about performance. Why run a query for every page load, when you can just grab a doc that has already been rendered with all the values for your view? The biggest problem here is that managing all those docs is a huge task. If you add a field to a view, you have to generate all those docs again. If your DB is old and convoluted, using MongoDB as a View cache Will definitely speed up your site. (However, you should really think about refactoring your data instead.) 
I think that ruby gem is the prime example of how a dependency manager should work. It is not perfect by any means but it does its job very well.
&gt; you can deploy new code without a database migration... but that doesn't mean the new code will necessarily work with older structures unless you've thought out your approach. We've always been able to deploy code without a database migration, especially if we don't care if the code works with the data!
"Better" is relative. If you have experience with PHP, go that route. If you want to learn more about both Node and WebSockets, go that route. 
Care to offer some constructive criticism?
That's a somewhat short sighted view of it.
That link is all you need. Configure preset to target your browser's you want to support and you're good to go. 
On Mozilla's own site, obviously. Nothing's more complete than in its innovator's site.
The site seems out of date and is full of warnings. Was looking to see if there are any other resources. The development community is great at creating additional content. Don't post it you're going to be so condescending.
I use npm, pip (Python), and occasionally Maven (Java). Can't say I like any of them really. I will say that npm is a more complete tool than pip at least, because with pip you need to use other tools as well (virtualenv, virtualenvwrapper) to get a similar experience. 
I'm not sure what you mean, I only use the word in "a good chance" which means "likely".
Can there be separate apps in 2 folders nearby that have different dependencies? I mean isn't gem like pip? Without virtualenv basically globals everywhere? Also how versions are stored?
I actually like crystal language shards. .yml file based dependencies list, easy adding new, easy developing new package (crystal language cli even has command for new library which will generate folders, shards.yml and even folder for tests!)
Yeah, you can have "Global" and "Local" dependencies something like NPM and you also have Gemfile and Gemfile.locks where you handle versions. 
that was... quick
Hi /u/JustBesideTheWindow, please keep it civil.
Yeah, I'm at work.. stuck on a problem with Ruby.. browsing reddit.. you know the drill..
No. Started using yarn, never looked back. There's still limitations to semver, but I get along with it so far.
On a side note to this, relational databases have issues when you get to large scale. Although if you are asking a question about MongoDB on reddit you probably aren't dealing with this level of scaling. Doing joins on a hundred million records is hard when you need performance. At that level you really want to be designing your system so that you only have relationships when you absolutely need them, and store everything else in some sort of hashmap style database with super fast query times.
Can you give a source for relational database being bad at JOINs ?
https://www.npmjs.com/package/@paybase/csp
&gt; such as postgres' BSON Do you mean JSONB?
Don't think so. BSON is a postgress binary base json format (I thought) Edit: a word and added uncertainty
Many people think about Mongo as a lightweight alternative for relational dbs. Easy to start, no schemas, no migrations, no transactions etc. Mongo has its own advantage for quick prototyping, rad and startups (you just drop entire layer of schema definition). But you will quickly understand why you need relational databases when a) you will need transactions (this is already solely a reason for banking) b) you will save some junk data (or strings instead of numbers) to db c) when you will migrate data for the first time
That's interesting; I had assumed there was something intrinsic to document stores that prohibited proper transactions and subsequently avoided them for anything where I needed them.
It's true if you have to hit the disk often JOINs will be expensive, but most of the time with proper indexes and filters JOINs are quite efficient. JOINs are one of those things that sound scary when the process is described, but when you set things up properly and let the database do its thing the vast majority of us will be just fine. There are exceptions, but most of the time you'll be painfully aware if you are an exception and you will have data to back up your claims.
What are examples of applications that use non-related data?
Quicker to pickup compared to others
This is my favorite framework I've never tried. edit: I should very much try it, been on node only for the last year or so and build our first prototypes with a poorly understood express.js structure. Tried feather.js for a little while but was not that happy with how it all happened. Most likely because of my poor understanding of nodes or express but still. I guess what i should do is actually learn a decent express structure and i'd be fine. Our front-end is more and more rxJs and i like how rxJs becomes this universal theory of asyncronicity. Of of the joys of javascript/node is the same code client/server, having the same api within that code takes this one step further. 
I'm nitpicking about the identification of it as "_postgres'_ BSON." As far as I'm aware, BSON was created primarily for/by MongoDB and JSONB was Postgres's answer to it.
It seems to me that if your goal here is to learn JavaScript then vanilla JS would be the way to go. React obscures DOM operations, event handlers, etc. and I suspect you'd be better of learning those beforehand.
Thanks :)
You definitely can go wrong... if you choose MongoDB for an application where referential integrity is important, or even if you just do a lot of joins, you chose wrong.
Can you name any free document stores with such features?
So it lies somewhere between a dev console and something like Codepen? Seems like it will be handy if it can be embedded in tutorial sites.
Nodejs will convert the path using path module, so it will work as expected.
&gt; Do you know if it will come or have they abandoned the idea My guess is that it will never happen. &gt; never understood why class had to be className See https://twitter.com/dan_abramov/status/890191815567175680 `const { class: className, active, children } = this.props` vs `const { className, active, children } = this.props`. Edit: Preact supports `class`, see https://github.com/developit/preact/issues/103
None that I'm aware of (others may know of one), but choosing a database that requires more developer work isn't free either. For instance, let's take consistency. If you choose an eventually consistent database for a use case that requires true consistency (in the ACID sense), then the developer team will have to account for that in the application layer. Those developers will be paid for that time, and for the future time spent maintaining an implementation that has to handle what should be managed in the database. I like free too, but sometimes you get what you pay for. 
A popular misconception, probably because most either don't support full ACID or limit support to single-document updates. If you're curious: [How MarkLogic Supports ACID Transactions](https://developer.marklogic.com/blog/how-marklogic-supports-acid-transactions)
&gt;i like how rxJs becomes this universal theory of asyncronicity. ... what?
Never saw it that way, perhaps it wasn't such a bad call.
I think you're trying to say that commercial databases are superior to free and open source counterparts. I think Goldman Sachs, Morgan Stanley, Yandex and millions of others who migrated from Oracle to Postgres would disagree with you.
&gt; use lenses in all my reducers that can't be done with just a assocPath call from ramda this is what happened on the project I was working on previously that led me to this idea. Glad to see that others are seeing the same patterns emerging! &gt; usually they are just used for R.over operations This is how we were using our `lenses` as well. We just chose `set` or `over` depending on the situation. That is how we came up with the `set` abstraction and its syntax: trying to get `lenses`, `setters` and the `method` together. Do you have any public code I could look at to gleam some inspiration?
Nope, I'm trying to say that sometimes paying for licensed software is worth it. Citi, BNP Paribas, Deutsche Bank, Morgan Stanley, and [quite a few others](http://www.marklogic.com/customers/) have found that to be so. For the record, I'm not saying the free guys have no value or that they have no place; I am saying that you should choose a database that delivers the features you need. 
I think they mean how you can lift pretty much anything into an `Observable`. I hate to say it, but `monads`?
Sorry relevant to an article I have read last week, about how rx js is becoming the theory of everything. Basically rxJs toolset to handle async programming, i said everything because more and more you see it handle user inputs, observable based client architecture, rxJs based websocket wrappers, rxJs database. Maybe everything was too strong of a word but its surprisingly everywhere and once you get the hang of stream operations, using similar patterns and same API from user inputs to database query is quite nice. that being said, rxJs was not instinctive to me at all, so there this step to get above before seeing any benefits. 
Thank you very much for the reply! It is a hobby project to learn and develop. It's not for a business or a job hehe 1. In principle, my web app is nothing like a chat. I just want that when I add something in the database, for example a new category, the server notifies all devices with the web app open that something new has been added. So I think it would be best to use SSE (Server Sent Events), and make a solution like long-polling for IE (Please correct me if I'm wrong) or do a Rest API on NodeJS and implement socket.io. 2. Do you know if a Rest API made in PHP is faster or has better performance against multiple user connections than one made in NodeJS + nginx proxy? Apart from everything, I have never done anything in NodeJS and I do not know why, but there is something that calls me to try NodeJS. PD: Arrrg too many technologies! Haha
There was a [really good article](http://www.sarahmei.com/blog/2013/11/11/why-you-should-never-use-mongodb/) a few years back (from 2013 even) about the pros and cons of MongoDB. Most of the current issues with Mongo have been known for quite a long time but nothing stopped the hype train of new developers looking for new technologies as a panacea to quickly bootstrap new projects. Frameworks like MEAN sprung up and fed into the hype as a way to reduce "developer fatigue". In general, most developers will look for ways to streamline their workflow. However, what we are seeing now, is that many developers who had originally bought into the hype have run into many of the issues surrounding NoSQL databases, have had to rethink or refactor code bases, and have had to deal with the development headaches of using the wrong database tool for the specific project. In general, smart developers always research which tool they should be using for the project based on current and possible future goals for that project and potential changes in scope during the lifetime of the product. NoSQL databases are really good for a limited set of project constraints. If a project outgrows those requirements, as many do, those benefits disappear and the cost of trying to build around NoSQL limitations or refactoring a code-base is non-trivial. I recommend reading the link above as it provides a much deeper dive into the limitations of NoSQL and its proper use-cases.
1. It depends on how deep you want to go. WebSockets could work. You could also just write a timed event in JS that refreshes the data (which is what GitHub does). 2. Almost anything can be made performant. I have never run loadtests comparing those two configurations, so I have no clue if one is better than the other. However, if you're just doing this for fun, does performance really matter (assuming both respond in under 500ms, or some threshold you decide)? I completely understand the desire to work with newer technology. I got my first taste of Node.js (and serverless) last month (https://engineering.edx.org/serverless-984cee7797e1). Jump down the rabbit hole and see where you end up. I find that inexperienced developers focus too much on identifying the "best" way of doing something too early. The journey of getting there is actually more important for your development.
I wrote a blog about my frustrations dealing with the decision to use mongo early on, when we should have used a relational database. It doesn't just bash it, but talks about why you should spend time early on figuring out the right database. Usually people just do what's easiest, and that's bad. https://runnable.com/blog/think-before-you-mongo
&gt; I would also like to add database search which I expect to be much harder. When users are logged in, they can add certain products and I would like to build it to look like Google search so when users starts typing the name of the product, let's say "ac" it would show "acme product" from the database. This feature (to do properly) is going to require both backend and frontend code, ie, you're not going to be able to do it all with js framework X.
 import { assocAll } from '../common/util'; export default createReducer({ [actions.selectUser]: (state, payload) =&gt; R.over(R.lensProp(payload), R.not, state), // toggling a user [actions.deselectAll]: R.map(R.F), // setting all users false [actions.selectIds]: (state, payload) =&gt; assocAll(true, payload, state), // setting a list of users to true [actions.deselectIds]: (state, payload) =&gt; assocAll(false, payload, state), // setting a list of users to false }, {}); selectors end up like this (not reusing any lenses generally) export const filteredCountSelector = R.path(['meta', 'filtered_item_count']); export const selectedUsersSelector = R.path(['selected']); export const selectedCountSelector = createSelector( selectedUsersSelector, userCount(R.identity) // helper func ); export const allSelectedSelector = createSelector( filteredCountSelector, selectedCountSelector, R.equals ); 
I'm surprised that `new Array(3)` creates a sparse array. I assumed setting the size ahead of time would be better than simply pushing to an empty one since that's how it works with typed arrays and things like that. Well, I guess that somehow makes sense since `new Array(3)` creates an array with 3 "slots", which is different from one which contains 3 things (null/undefined included). Maybe this is something where the dev tools could help.
Sure, but I hate having to completely re-teach my fellow developers when they see something like this and think "that's localization?". I've spent countless hours having to carefully explain that no, it's not this simple, and no, you can't just blanket replace strings with other strings and no, you really do have to account for cultural differences like addresses, name ordering, number/date formats, time zones, and a whole host of other tiny details otherwise you just look like a rank amateur. _That_ is why I hate articles like this.
Lists of stuff with self contained data. For example some logging application or some cache DB that is not the source of truth and is not queried against.
20 years ago, I was a C programmer. Every day, week after week, year after year, C was just C. Every few months, someone would maybe write a book. I'd drive to the next town over to buy it. That was a language you could keep your head around. Now, it's constant Buyer's Remorse. Or Framework Remorse? Maybe I shouldn't be sticking to Backbone for so long. But, rewrites are expensive, so I'll sit over here and tinker away. 
I do feel Framework Remorse, its hard to ever settle and when we do, there are many ways it can go wrong. I guess at one point you learn to learn frameworks and its not such a heavy burden to try some around t'il you find a good fit. Love to embrace your older ones and maintain while still moving forward to your place of confort. Sometimes confort's not ahead but where you are at. If you've wen through the whole learning curve of a library, it'll take a whole lot of new and worthy tech to outweigh your current expertise. Its worth changing from time to time but sticking to that change works best for me. I must say, there are reasons for theses new things to come out, they bring many new and interesting concept to the table, much productivity sometimes. I like to wait a few rounds, see what tech/pattern actually sticks( i really suck at predicting it apparently ) and then use one, once adoption is wide and large enough that you get it all, community, ressources and docs. Like 3 months ago only we switched to React on the front side, very happy with the result, very happy with mobX as well. In a weird state of denial and love with horizon.js reactive queries and auto database builder and indexes. 
Yeah. I rebuilt the main webpage in Vue, as well as some unfinished side projects. I like that quite a bit, but it's just a static SPA. Maybe in one of my side projects, i'll do some backend stuff.
oh look another person glued some npm packages together into a skeleton starter app, wrapped some functions in their own abstractions and decided to call it a framework. these people are delusional.
I read an article about monads just today. It sure is easier to work with data if it's on the same "level" throughout the entire codebase. But I'm just at the beginning of my journey with RxJS. Edit/plus: "Everything is an observable. Even your dog is an observable of barks." :D
I'd think so. Tutorial sites could benefit from integrating it. And it's much lighter than a codepen. The backend leaning on the github pages (js.org) just need to send a few static resources...
Is there a migration guide from version 3.x.x to 4? I get that "move fast and break things" is very common in JS community, but there should be a migration guide if you want your framework to be taken seriously. it also seems that there are many unfinished pieces of the docs, just like in v3 docs. I really like the idea behind this framework, but the lack of complete documentation really makes me question my own judgement when I've decided to start a new project with it.
Man, this keeps looking better and better. I wish I was still doing node development, but will definitely use this for my next project.
It's probably mainly the realisation that there's _so much_ in a typical application that is asynchronous, and that RxJS just provides a very elegant way to deal with it :)
Ack, crap Should be using just "gatsby" (which has a lot more downloads) than "gatsby-cli" Here's the updated link: https://npmcharts.com/compare/metalsmith,wintersmith,assemble,harp,brunch,nuxt,gatsby,hexo-fs,spike ------------ addendum - if you're interested in this kind of thing, here's a comparison of the UI component libraries for react: [Carbon, Material-UI, Ant Design, Blueprint, Office UI Fabric, Rebass, Grommet, and React Onsen UI](https://npmcharts.com/compare/carbon-react,material-ui,antd,@blueprintjs/core,office-ui-fabric-react,reactstrap,semantic-ui-react,rebass,grommet,react-onsenui) And table component libraries for React [react-bootstrap-table vs react-table vs rc-table vs fixed-data-table vs @blueprintjs/table](https://npmcharts.com/compare/react-bootstrap-table,react-table,rc-table,fixed-data-table,@blueprintjs/table) (did I miss anything?) --- edit: btw, having this be expandable on reddit was a total surprise, but was apparently made possible by [embed.ly](http://embed.ly/) 
Reminds me of joi, which is Johnathan Blow's subset of c++
Can anyone confirm or deny that this is a realistic (even though humorous) representation of the JS ecosystem? I'm just beginning to learn.
/r/learnjavascript
There's certainly truth to it, but nobody is making anybody use the latest stack. If you're just learning Javascript, like from ground zero, you can just code in a dang script tag for a while. If you want to toe the waters of more modern stuff, Express and React both have generators that can get you up and running relatively painlessly. People mostly only run into this transpiler/build process hell when they set up their own stack from scratch, which is unnecessary a vast amount of the time. 
Nativescript is so underrated.
Vue is good. It's fun to learn too!
Thanks! This seems to be fairly close to the previous art. Have you ran into any issues with connection to your `actions`? Does that paradigm of `[actions.selectUser]` lead to hard-to-find state updates/changes?
what is difficult about angulars syntax?
not that i've noticed. actions are all clearly defined in our actions.js file in the reducer folder. so if a developer wants to see what actions are already defined they can go look there. otherwise it's standard redux and that action constants show up as usual in redux-logger for example. very clearly indicating what kind of business logic has happened. We use redux dev tools to look at the state diff to figure out all the places an action touches. also any grep would show you all state mutations for an action easily
Good catch. Thanks
Just a hack, but you can simulate a click on the border like this document.addEventListener('DOMContentLoaded', function() { document.getElementById('myBorder').click(); }); This won't solve the problem where the user clicks somewhere else manually - but it sounds like you should probably add a click listener to the 'part of the iFrame in which my game is rendering' too
I'm a noob, but this is my understanding: the border isn't a separate element. The iFrame is the element, and I am rendering in one part of it but not another. What I am finding is clicking in the rendering part doesn't work, but clicking on the part I'm not rendering on does.Edit: I added this code to the .html within the iFrame: document.addEventListener('keydown', function(event) { if (event.keyCode == 37) { alert('Left was pressed'); } else if (event.keyCode == 39) { alert('Right was pressed'); } }, true); as I expected, it only alerted when I had clicked on the non-rendering area, it's as if the pixiJS render has blocked my click
Like /u/kotborealis said, your require paths will be fine, but if you are doing things like fs.readfile('./myFolder/myfile.txt'); Those will break - look at Node's [path.normalize](https://nodejs.org/docs/latest/api/path.html#path_path_resolve_paths)
Since all code is pre-bundled your scripts will load faster in that there's no delay to fetch it from the network. But Electron is basically a bundled chrome+node so no, the runtime execution won't be any faster.
i did that while learning, went fromplain js to jquery, angular, ionic, quasarframework and finally stopped at vuejs. vuejs either got lucky or it just suits how i think about the project.
I think we already have one of these
Full disclosure: self-submission.
What is the purpose of this changeName function? Your getting the value of the input field and then get the newInput property of the newName element (which is undefined), and set the textContent on undefined to ''? 
I'm not a TypeScript user, so I don't want to add any TS-specific anything to my package.json. This is the point, which others have seemingly missed.
Not sure what you mean? Edit: In case it isn't clear, `Atom-IDE` is a package that you install on top of Atom that gives you a lot of IDE functionality like Outline view, Diagnostics, Autocomplete, etc.
Really interesting. I was thinking about this idea too. But I was hoping for something more functional or less class-based, tbh.
A lot of interesting stuff, but really the only thing I'm super excited about is being able to use a `.babelrc.js`. Everything else in all my projects (webpack, postcss, eslint, stylelint) all use JS configuration, where I can drop quotes around keys and test `proces.env.*` for things, even \**gasp*\* add comments, so I'm very excited to drop the only JSON config (besides package.json) I have left.
&gt; Nowadays, the performance of both for-of and forEach is on par with the old-fashioned for loop. this is only true if you're calling a function at each iteration as they are: `doSomething(item);`. otherwise, for-loops (and maybe for-of) are significantly faster than interation constructs that *require* callbacks, like `map` and `forEach`. https://jsperf.com/native-map-versus-array-looping
It's not difficult, can just be weird at times. Don't forget the weirdness of angular 1!
&gt; joi JAI?
Damn, this looks like something I'd be into
&gt; that require callbacks Those might get inlined.
doesnt work in windows: (node:15912) ExperimentalWarning: The ESM module loader is experimental. { AssertionError [ERR_ASSERTION]: An invalid error message key was used: ERR_INVALID_PROTOCOL. at message (internal/errors.js:70:3) at NodeError (internal/errors.js:29:13) at resolveRequestUrl (internal/loader/resolveRequestUrl.js:84:11) at Loader.import (internal/loader/Loader.js:61:27) at Function.Module._load (module.js:462:27) at Function.Module.runMain (module.js:665:10) at startup (bootstrap_node.js:201:16) at bootstrap_node.js:626:3 generatedMessage: false, name: 'AssertionError [ERR_ASSERTION]', code: 'ERR_ASSERTION', actual: undefined, expected: true, operator: '==' } 
An entirely different file extension. Can't use __dirname. ~~-`import * as fs from` instead of just `import fs from`-~~ (edit: nm. it works) I didn't even like the fact that even in babel you couldn't do `module.exports = {named}` (exporting default) and then `import {named} from ..` (importing named), it had to be same in both for some reason. All this for static analysis? JS is a beautiful DYNAMIC language, stop changing it!
what module were you trying to import (the full string)?
yes thanks
from the jsperf link, `for` is 20-25% faster. in Chromium 63.0.3207.0 (Official Build) (64-bit)
I followed the example in the article exactly, so: node --experimental-modules main.mjs main.mjs: import {add} from './lib.mjs'; console.log('Result: '+add(2, 3)); lib.mjs: export function add(x, y) { return x + y; } 
can you load `main.mjs` without it loading `./lib.mjs`? also, are you running this on a network shared drive working directory?
I'd add the advantage of having a current version of the Chrome browser, which adds performance in comparison with older browsers. 
I am running PowerShell on a local drive. I changed main.mjs to: console.log('Result: '); and get the same error
Ok, last ditch run with `NODE_DEBUG=module,esm` environment variable set. We can't get a local repro.
I do wonder if powershell is somehow involved in this, we are using cmd
I tired cmd.exe as well, setting the NODE_DEBUG environment variable. Same issue. I have not yet figured out how to set the environment variable in PowerShell yet.
What map does is quite convoluted. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Polyfill Secondly, I can't tell what's actually measured here. "h" is never read. A sufficiently smart compiler could discard everything and you'd be none the wiser.
Ah, got it. I needed to do: $env:NODE_DEBUG="module,esm" but I still got the same error.
If it matters, I am on: Windows 10 Pro Insider Preview Version 1703 OS Build 16278.1000 and: 64-bit operating system, x64 based processor
Yeah, that's the one! Don't know if it's even close to be finished, though
You're using Backbone as a server framework? Bold choice
On second look, there was a little more info in the error this time: MODULE 15160: looking for "C:\\Users\\mark\\dev\\esm-demo\\main.mjs" in ["C:\\Users\\mark\\.node_modules","C:\\Users\\ma rk\\.node_libraries","C:\\Program Files\\nodejs\\lib\\node"] (node:15160) ExperimentalWarning: The ESM module loader is experimental. { AssertionError [ERR_ASSERTION]: An invalid error message key was used: ERR_INVALID_PROTOCOL. at message (internal/errors.js:70:3) at NodeError (internal/errors.js:29:13) at resolveRequestUrl (internal/loader/resolveRequestUrl.js:84:11) at Loader.import (internal/loader/Loader.js:61:27) at Function.Module._load (module.js:462:27) at Function.Module.runMain (module.js:665:10) at startup (bootstrap_node.js:201:16) at bootstrap_node.js:626:3 generatedMessage: false, name: 'AssertionError [ERR_ASSERTION]', code: 'ERR_ASSERTION', actual: undefined, expected: true, operator: '==' }
Fun fact, I googled "joi blow" to figure out what you were referring to, yeah, don't do that at work like I did.
That is strange. Bluebird uses new Array(n) a lot, e.g. In INLINE_SLICE to copy arguments into a pre-sized array.
Looks like it's gonna take a while to smooth all the bumps out.
not a fan of .mjs extensions especially when considering isomorphic code :/
what is weird about it? it's typescript and component decorators... also, Nest is written like Angular not AngularJS, not sure why that's relevant... 
Sweet article, man (: Ninja edit: comma for direct address
He still uploads videos (recordings of Twitch livestreams) about the development of Jai to his YT channel. The videos about Jai showcase new features he implemented or are compiler bugfix sessions. I might be wrong, but I remember that he said like 2 months ago that he will publish the compiler for very early testing in one year. YT Channel: https://www.youtube.com/user/jblow888 Twitch Channel: https://twitch.tv/naysayer88/profile edit: wording
Angular 1 is what I am referring to not angular 2/4. Also I got that takes written like angular not angular js. My point was if they were referring to angular one that is horrible. If angular 2/4 then it's better. Lol
Well shit. I thought this was a way to integrate with my Nest thermostat. lol That being said, this looks pretty awesome.
Thanks folks!
When will we not need babel anymore?
Hi /u/Kinetic_Query, I would suggest that you try posting in /r/LearnJavascript. Sorry!
Looks common sense to me, is there no library out there that already does this?
When javascript stops receiving new features, or browser vendors make browser updates somewhat mandatory. The real answer is before this ever happens, babel will have become so accepted that the default for javascript will be to use compilers, and then people will transition more readily to clojurescript and better compiled languages instead of tacking on shit like Typescript to javascript
Too complicated. Vanilla js++
Vanilla will always be there. But once you start dealing with more complicated concepts in Javascript (Immutability, FP, all the little Javascript coercion quirks) then you realize that using raw Javascript to build modern applications is the real complication. Take something like .map(). That's been super super fucking useful, and only in the past couple of years has landed in Javascript world... but more functional languages have had shit like that for a long time. Sure it's complicated but as compilers start to get smarter, the idea of Javascript working both on the server and on the client, and our need for language to do more, the requirements (especially for companies) will get to the point like I said where these languages actually are a panacea. I'm getting to that point in my career and a lot of others are as well.
&gt; The ‚Äúenv‚Äù configuration option (not to be confused with babel-preset-env) has been a source of confusion for our users as seen by the numerous issues reported. &gt; The current behavior is to merge the config values into the top level values which isn‚Äôt always intuitive such that developers end up putting nothing in the top level and just duplicating all the presets/plugins under separate envs. They know me too well üòÖ Yeah `.babelrc.js` is gonna be a welcome addition for sure.
you have tried debugging that sourcemapped shit right? its rare that you can even hit your breakpoint.
Not really. Conceptually my point still stands though. Babel has to use the same sourcemap solution as well. Maybe it ends up working better because it's more similar to vanilla JS but I'd want to do some research and see if those sentiments are echo'd by others. But the point still stands. As it is right now, we take Javascript and super impose all these new features (async, types, immutability). All their doing at the end of the day is copying features from another language anyway. Why not just use the other language that is designed with these concepts in mind from the ground up if we live in the "compiled javascript" world. Don't get me confused... I'm very very grateful for Babel, I think they will push the needle more than anyone could have EVER imagined. Insanely grateful to their efforts. I'm hoping people use that effort to justify using different languages that compile TO javascript.
&gt; Not really. enough said. you don't even use the debugger...try it then let me know what you think :P
lol. like I said, the concept is the same regardless of that one point.
the concept is useless if the tech is unusable. you should have learned that by now.
dude. these are "concepts". You do realize javascript compiled by babel HAS to use sourcemaps, correct? So what is it that you're actually saying? Clojurescript is just one dialect. The concept of a language being built from the bottom up to support features, rather than them being tacked on, has absolutely nothing directly to do with some bug you're dealing with in clojurescript. You've missed my entire point by fixating on this one issue. So I'll say it again, and I'll say it slowly. Most people are using Javascript in a way that wouldn't work if you just stuck it on a page. They are compiling it. You compile JSX. You compile ES6 to ES5. As applications get more complex, instead of using tacked on features, it may suit us more to use a better language which holistically has these features integrated and built in. And we already know that this will work because we do it today in Javascript. Maybe some other language will do sourcemaps better, or maybe debugging in clojurescript or the like gets better. That has nothing to do with my main point. In the future, try not to get sidetracked needlessly. &gt; the concept is useless if the tech is unusable. This is factually incorrect. Concepts lead to tech breakthroughs. Everything begins as a concept.
Mac: (function (exports, require, module, __filename, __dirname) { import { Wrapper } from './wrapper'; SyntaxError: Unexpected token import at createScript (vm.js:74:10) at Object.runInThisContext (vm.js:116:10) at Module._compile (module.js:588:28) at Object.Module._extensions..js (module.js:635:10) at Module.load (module.js:545:32) at tryModuleLoad (module.js:508:12) at Function.Module._load (module.js:500:3) at Function.Module.runMain (module.js:665:10) at startup (bootstrap_node.js:201:16) at bootstrap_node.js:626:3
[removed]
Try it. Attempt a MEAN stack and time box yourself to half an hour just to be safe. Did it work? Did you create a simple list on the server and update it on the browser? No? Then yes. It's all true. 
There is the very popular [JedWatson/classnames](https://github.com/JedWatson/classnames). I credited it on the README [here](https://github.com/jbucaran/classwrap#credits).
Didn't mean to put the library down. Looks like an easy to use and useful library.
Seriously though. I am a consultant and I am sure that someone will ask me "what the hell is .mjs, why not just .js" and I will only be able to respond with a shrug. Maybe "the community broke the ecosystem by trying really freaking hard not to break the ecosystem"?
It would be better to invest some time into learning modern JavaScript. You are going to do to it at some point, and it's better to start as soon as possible. Otherwise you will be forced to maintain jQuery projects for ever. You don't need to make an SPA. React and Vue allow you to use components without going into a full blown SPA. I don't know about Angular. It's perfectly valid to handle routes, auth, etc, in your backend. In some cases this is even desirable. You don't need jQuery. There are many libs that use Bootstrap's CSS but use React or Vue for the JS. For example: https://react-bootstrap.github.io/ https://bootstrap-vue.js.org/ Also you might feel comfortable with it, but trust me, once you start doing data binding you can never go back to micro managing the DOM with jQuery. ES6 is not slowly taking over. It's been here for a couple of years.
Hi /u/shad0proxy, please no copypasta. Thanks.
it had to be done.
`eddEventListener`? Check for errors in your browser's console...
Sure no worries. The title can be confusing, but I didn't mean alternative to class names, but `classnames`, the name of the other library out there that does this. üòÇ
Demo link: https://apoorv.pro/lozad.js/demo/
The various clis being produced by frameworks are godsends. Angular, ember, Vuelta, react, and probably more all have one now. Setting that stuff up manually is somewhere between annoying and impossible (depending on the framework) but the clis that I have used have all removed the pain points of actually getting a basic app up and running.
&gt; Even better, look into multi-model databases. The benefits of polyglot without the operational complexity. Interesting concept, which one would you recommend? OrientDB?
With @std/esm you can override that and just use .js
For anyone experiencing issues who just wants to get es modules working you might want to consider npm.im/@std/esm I've been using it and it works pretty well. Please still work with Bradley to fix your issues but if you're in a bit or can't control node versions of your consumers then this is probably your safest bet.
C and C++ have variadic functions without needing to use a vector... int printf(const char* format, ...) { va_list args; // ... 
Yup, at least one other person [had the same thought](https://github.com/Jeff-Mott-OR/javascript-cpp-rosetta-stone/issues/2). So far the reason I haven't done that is because the goal of this write-up is to gain insights into JavaScript's inner workings, and a `vector&lt;any&gt;` parameter named `arguments` reflects how JavaScript behaves.
Hi myyuh42, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi xREZxShockz, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi robottest, For javascript help, please visit /r/LearnJavascript. Thank you!
He means visual studio code
 $ node --experimental-modules test.mjs (node:19825) ExperimentalWarning: The ESM module loader is experimental. Result: 5 Make sure you're using v8.5
I see a lot of your articles posted here, I'm really impressed with how on point you are with JS. Thanks for the helpful read. 
will webpack and react die already?
I would argue, that even this is limited beyond reasonable. You should be able to override what are the extensions that support modules. Why not? For example, we have our React code in .jsx files and they are the prime candidate for upgrade to ES modules, but not like this.
Thanks for the article and your work Dr. Rauschmayer!
One advantage of shipping the runtime + the code is that the code can be stored and loaded in an engine-specific format to reduce parsing time. 
Why?
is it based on express or not? one main thing I like about hapi is that it's not based on express ah nevermind, it is &gt; Under the hood, Nest makes use of Express, allowing for easy use of the myriad third-party plugins which are available
Likely someone who can't be bothered to learn new things and expects knowledge they learned a decade ago to carry them well into their golden years. At least those are the types of people I have encountered that share this sentiment.
First of all, you do not have to switch. Use what works for you. Write tests, measure performance, decide on what you need. High-level languages allow quick development and iteration and this can cause paradigm shifts. Currently we are seeing the functional (Elm, React, Redux) and reactive (RxJS) paradigms getting traction as the original event-based style did not suffice. It is good to know the backgrounds of those paradigms, strengths and weaknesses, so you can more easily make the switch. C is reliable, but way less flexible. 
Thanks the edit, Did'nt realise what you were posting about and had forgotten Atom was already a thing, my bad, derp...
Oh man that DLL plugin plus Happypack is no joke. Works for hot reloading too. Hot reloads in my project went from 5-8s to about 1.5s. Production builds cut in half from ~50s to 25s with only Happypack. Can I go back in time and learn this a year ago?
Whut? I tried happypack but I could not make it work at all -_- any tutorials you could point me to? Or a config example?
What was the reason again for `.mjs`? Something about semantic difference between `module.exports` and `export` requiring too much static analysis?
&gt; &amp; updateTrigger:'blur' THANK YOU!
My most recent use case is a little abstract I guess. I built a bulk resolver for promises that others could add functions for resolve/reject. There was no limit to the amount of functions that could be registered to this handler. If a promise resolve or rejected I'd need to call all the resolves, or all the reject functions - they all accepted the same arguments. In order to do this I used currying to store the array of functions and then call them all later. Here's a dumbed down version as the functions etc would get passed around. const curryFuncs = (funcArray) =&gt; (...args) =&gt; funcArray.forEach(func =&gt; func(...args)); // These would get added to at a certain point in time const resolveFuncs = [() =&gt; {}, () =&gt; {}, () =&gt; {}]; const rejectFuncs = [() =&gt; {}, () =&gt; {}, () =&gt; {}]; // Store them for later use, curry them for simpler call down the line const promiseHandlers = { resolve: curryFuncs(resolveFuncs), reject: curryFuncs(rejectFuncs) }; // Some time later in another part of the application Promise.then((result) =&gt; { promiseHandlers.resolve(result, 'foo', 'bar'); }).catch((err) =&gt; { promiseHandlers.reject(err, 'foo', 'bar'); }); 
You can also use v8 snapshots for faster startup in electron
I like how this was given non commercial license. I'm sure people would otherwise rush to steal these snippets for their companies. Real money maker right there. No but seriously, this is interesting project.
Hi. There's only 1 breaking change - the NestFactory returns Promise, so it has to be awaited. I mentioned about this in the CHANGELOG, but I think you're right - I should create a 'Migration guide' chapter, just to briefly clarify this. Will do it asap. About docs missing parts - the only missing articles are the 'examples'. I'll fill this section as soon as I can, but I don't think it's 'blocking'. Thanks
&gt; babel-loader: Don‚Äôt forget to exclude node_modules from the loader! But wouldn't that effectively eliminate 3rd party module tree shaking and scope hoisting? Haven't had the exclude in there since Webpack 2, i thought that's encouraged?
booooooooring. things this time could have been put towards instead: * a tutorial on writing good, lasting, tutorials * a good tutorial
Does it work with webpack 3?
Whoever wrote this doesn't understand Vue: "Unlike more complete frameworks such as Angular or Vue, React deals only with the view layer."
https://github.com/amireh/happypack/issues/172
Awesome! Thank you! Gonna drop it in our project before the end of the week!
because everything being re-invented in the js ecosystem has a lifespan of 2 years at most, probably.
I have to agree that express as a base is weird to me too, should have a look at hapi. Heard it can get confusing at first but pretty powerfull in the long run. 
well, I think there is also the "reddit effect" here too, lotsa hype over certain things, that change constantly.
I've created a very simple app as an example of Gruu usage. [https://github.com/MarekLabuz/mareklabuz.github.io](https://github.com/MarekLabuz/mareklabuz.github.io) 
babel is not responsible for tree-shaking
babel-loader isn't responsible for tree-shaking or scope-hoisting. Webpack 2 added those features in core. 
I was under the impression that webpack would either pull common js (which doesn't tree-shake/hoist) or choke on es6 semantics and crash uglify (since babel isn't allowed to transform it). I ran some tests and it didn't seem to work until the exclude is removed. If you keep it, how do you manage to make it work, for instance with uglify?
ESM has different scoping, parsing, and timing than CJS or Script. There also exists ambiguities in source texts that parse in all 3 but produce different results at runtime.
.mjs is isomorphic! .mjs is in the updated MIME for JS as an internet Draft: https://datatracker.ietf.org/doc/draft-bfarias-javascript-mjs/ WHATWG has it in the examples (although they don't care about file extensions): https://html.spec.whatwg.org/multipage/webappapis.html#resolve-a-module-specifier For serving all you need to do is ensure you serve *.mjs with a JS MIME type. I have been sending out PRs to the major MIME libraries, and some of them are waiting on the Internet Draft to be adopted. Let me know if you get stuck!
See https://www.reddit.com/r/javascript/comments/6zpp0r/using_es_modules_natively_in_nodejs/dmy15tl/
found it I think, but not sure why it works on CI/my laptop : https://github.com/nodejs/node/pull/15389
A week has passed and the game is now ready :) If you're still interested you can play at http://js13kgames.com/entries/a-moment-lost-in-time. Initially innerself made me very productive and I was quickly able to add all the views and put the logic in the reducer. In the later stages of development we focused on UI polish and I set out to add transitions between views. As you can imagine, CSS didn't appreciate the fact that innerself would re-render entire DOM trees when the state changed. I'm not very happy with the result: I ended up using setTimeout timed precisely with the animation events to work around those re-renders. I guess this counts yet another example of a use-case which innerself isn't well suited for. Any time the DOM is stateful (forms, animations, transitions, video, audio), re-rendering by assigning to innerHTML is a bad idea.
Awesome! Thanks for the quick work! As you can tell, I am pretty excited about modules!
That pixel tracking URL can be whitelisted by your IT department without making Facebook accessible to everyone. I would just contact them and request that they whitelist it.
Interesting library, but "localize" is a *horrible* name for it. Say the word "localisation" or "localise" to a hundred devs, 99 of them will assume it has something to do with i18n and not one will assume you're talking about converting data objects between languages or transferring server-side data to client-side code. Also, my knowledge of Go syntax is almost non-existent, but isn't this just a library that mashes together "converting Go data objects into JSON" and "outputting that string to client-side JS by assigning it to a named JS variable"? Those are two completely different tasks that would be more flexibly handled by creating separate (more reusable) code for each Why not just write a straight Go-to-JSON library (which is useful and reusable), and then (separately!) dump out the JSON string as the contents of a `&lt;script type="application/json"&gt;` tag that you can pick up in your client-side JS (which is such a trivial job it's not worth a library just to do it)? **Edit**: Also, I don't see any checks there for circular references in data structures. Unless I've missed something you can easily cause an infinite loop just by having an object that contains a reference to itself, or two objects that mutually refer to each other.
Webpack transforms the ES6 module syntax (and transforms unused imports in such a way that Uglify's dead code elimination can remove them), so your dependencies' `module` builds need to be ES5 with ES6 modules only until Uglify can deal with ES6.
What are peoples' thoughts about using the DLL plugin with Git LFS? Would be in version control, but not show up in diffs
Hard source web pack was a copy paste setting that sped things up by a lot by caching all node modules. Other ways to set it up but, out of the box this got my long builds down to a couple secs 
Cool, glad to hear that. About docs again - I've noticed v3 docs had unfinished "API reference" section, which in v4 does not even exist. Does it mean there won't be this section at all? I would recommend bringing it back (and obviously, finishing it), as it provides easily accessible list of all the little pieces of your framework.
curious what your tools of choice are (promise I won't shit on it üòÑ)
Just to add onto this, you can use babili and get all the benefits of uglify + some, and it can handle any es release you throw at it for the most part. 
Are you loading a `.mjs` file or a `.js` file? ESM and CJS had to be disambiguated and only `.mjs` files load as ESM.
&gt; Vuelta What is this? A quick google shows me a bicycle race in Spain. I'm assuming it's something like vue-cli?
But wouldn't that mean the exclude has to go or else 3rd party es6 modules fall out? We deploy all our modules in es5-cjs and es6-modules for instance. I'm not sure how many developers would release es5-modules just because uglify is lagging behind.
I used happypack before but had lots of problems due to caching. Then it broke with a new webpack version and I stopped using it. DLL does help a lot though.
The DLL files are kinda dependent on exactly what you have installed, so if everybody has slightly differing package versions, it breaks.
yes, but it only works per-file, not across the final bundle or AFAIK scope-hoisted modules. That does make a big difference‚Ä¶
The es-main entry of modules should point to ES5-syntax JS files that have import/export statements. ES5 means no babel needed, and import/export meant Webpack can do the tree shaking.
I sincerely do appreciate this work, and I cannot imagine the amount of effort that it has been. As you have explained all over the place, there is a technical explanation for why this change to .mjs is viable. The problem with that technical explanation is that I cannot explain in 1 sentence **why** .mjs makes sense and satisfy the question fully. And yes while I can say that there is an enormous effort to make a smooth transition, I still have to explain why JSON cannot be loaded with require in a .mjs file. My job is to explain these things to people and in my experience it is a measure of how intuitive the feature is that proves how popular it will be and how easy it will be to use. I hope that this will be kept in mind when the discussion continues in node-eps/pull/60, and I would say also that I am disappointed that this has been publicized as an experimental feature before discussion has concluded for a combination of other options.
My Sublime Text 2 license used for upgrade only costs $11. That's an awesome price.
Sorry it took a while to get back to this. I'll try to answer as much as I could. I'll admit that I haven't dove deep into the internals of Angular, my attempts to understand the framework so far have been through trial and error. Though I at least appreciate thee way it tries to shrink the initial app load size by lazy-loading modules through the router, therefore splitting every feature into its own file. I do agree that the decorator syntax could be less confusing and redundant, though. &gt; I understand, for example, that Angular and Redux is common, and that's usually what people mean when they say "weird, brew-it-yourself glue" (I do agree that learning Redux is usually harder than learning React itself). For Angular, I recommend using [ngrx](https://github.com/ngrx/platform) instead of Redux. It provides the same functionality as Redux, but utilising Angular's reactive programming patterns.
üòÇüòÇüòÇ Ignorance can be a bitch sometimes too
If you want a 1 sentence answer: While .js can refer to older Scripts, the standard for .mjs ensures that it is the most Modern parse goal for JavaScript across all environments; the Module parse goal. See the usage restriction on the internet draft.
As for discussion, they have been in talked about since mid 2015; no solution was without problems, and the choices of: * Original plan in 2015 was unambiguous parsing * `.mjs` was voted in early 2016 * Unambiguous parsing was brought back in mid 2016 * `.mjs` returned when unable to remove ambiguities in parsing at TC39 in second half of 2016 These have been talked at great length and decisions were made. That said, people can continue to talk as they wish. `package.json` has a variety of issues stemming from tooling disagreeing on how it should word, requiring a file that is not related in any way with Web plans, and experience in both learning and maintainance. Those things are acceptable to a variety of use cases, but .mjs was seen as more beneficial in those areas.
I tried [this](https://github.com/amireh/happypack#using-multiple-instances) method for my Webpack 3 config, and got it working. Note that their example is incomplete, however. Wherever you are defining your loader string (e.g. `babel-loader`) replace it with `happypack/loader?id=someUniqId` and then add an equivalent instance of the Happyplugin for it: new HappyPlugin({ id: 'someUniqId', loaders: ['babel-loader'], verbose: false }),
Does it still prompt for upgrade?
I've tidied a little bit up. Your code is fine (for a beginner), your issue is simply that it's sloppy. Your ID's doesn't match what you're trying to get, you write `eddEventListener` instead of `addEventListener`and stuff like that. http://jsbin.com/xufuzizuxe/edit?html,js,console,output
On the 3 beta on linux did for me.
I'll stick to vs code, thanks. 
This is a very ambitious project but, alas, in this era of tons of framework, mini-framework, transpilers and friends... unlikely to succeed 
webpack and vue but webpack is shit.
This survey is conducted by Sqreen and NodeSource. Our goal is to better understand the security best practices in the Node community and share the results with you. The survey should take around 3 minutes to complete. We really appreciate your support!
I work for MarkLogic, so my preference should be predictable: MarkLogic. Documents (XML and JSON) plus RDF triples. Supports document queries, plus SPARQL (for triples) and SQL. Also ACID, HA/DR, government-grade security. That's my preference, but I'd lean toward any multi-model database that has the features your use case needs over polyglot. 
Here's some constructive criticism: It is really hard to understand what your product is offering or doing. The website you've built seems targeted towards corporate individuals without a development background; the words are very vague and don't transfer a clear message on what your product intends to do. I believe that developers will be interested to know what problems your product will solve for them and the way they will be able to do that is to see more specific code samples rather than pretty icons and sentences like "this will speed up your development process for real time apps". The question is how exactly will it speed up the development time, as in "show me examples". Take a look at the way TJ hollowaychuck presented his new "UP" framework. I think that can give you inspiration. This is just my honest 2 cents on this :)
Why should I use this instead of VS Code? 
Lighter weight, less buggy, not an Electron app. Was using Sublime, then Atom for a long time, then switched to VSCode for a few months, but now I'm back on Sublime. VSCode was really good but had a few really annoying bugs that were dealbreakers and the UI just felt a bit too in the way for me. 
Although it would be worth ensuring that the site doesn't depend on the Facebook Pixel being accessible to finish loading. From the way the OP is worded it seems that the site doesn't completely load if the client can't connect to Facebook, which would cause the site to not work properly at many other businesses, or potential customers with privacy software.
So does this mean it is actively being developed again?
&gt;Express and React both have generators that can get you up and running relatively painlessly. Or with Vue, just include a CDN (or local) copy of the pre-compiled Vue library and you can go crazy.
Would really like to know what bugs you encountered.
I'm not too well versed on algebraic structures, but from what I understand Observables implement (or at least closely shadow) Monads, which according to the [fantasy-land spec](https://github.com/fantasyland/fantasy-land#monad) implement the Applicative and Chain specifications. So, I think it's accurate to say that there are similarities. 
Not sure what real problem this library solves because "how to implement classes in JS?" is not a problem in JS ecosystem anymore (ES6 classes, TypeScript etc.).
If you're willing to sacrifice some functionality (i.e. IntelliSense, integrated debugger, refactoring) for faster performance (especially start up time) then sublime is for you. 
I can only assume he meant outside of the main business logic.
I don't think it ever stopped, it's just that it's a single guy doing the work. Edit: 2 guys
$0 for VSCode or Atom is even more awesome. 
&gt; not an Electron app You already said "lighter weight", what else bugs you about Electron from the user perspective?
Good call. 
Dogma
Development was slowed for a long time, but like a year ago he added someone else to the team and there have been a ton of updates since then.
I personally like to use VS Code with a single workspace for each of my projects and then in Sublime Text I have just about every important folder on my computer in one workspace and use it for small edits, quickly looking or searching through projects, and for notes.
$0 and $11 are basically the same thing on most programmers' salaries.
It's not letting me save my preferences. Anyone else?
Take a look at CrxOop Structures, and then take a look at CrxOop Classes. Even if do not plan to use CrxOop, it will be a learning experience for you, and will answer your question. CrxOop Structures are comparable to the ES6 classes.
[removed]
And Brackets
Thank you. Let me draw the attention of the reader that this is a plain javascript library. No transpiling, or external tools.
Wrong. $0 and $11 are probably the same thing than $0 and $0.01. It's not how expensive or how cheap it is It's the difference between free and paid software. And programmers like things free.
good luck 
You can get a job making 6 figures eventually. (More than just JS knowledge, but JS can be a big part of it.)
Anytime one of my language servers errored, it would pop the console up, which was insanely annoying. That in itself was enough to make me leave.
Electron apps are just known to be massive memory hogs. Nothing particular against them other than their abysmal resource consumption. 
It removed many default color schemes. Just 4 I see now.
VS Code is better editor, i really feel great
Ah I didn't know there were other devs on it. Haven't been paying too close of attention to the project. I've used VS Code as my text editor since April, but I whip out Sublime for massive files. 
Same as any other programming language, you either get a job writing it at a company or you build something useful with it and charge money for it. 
I cannot tell you how to start making income *right away* but I can tell you what you can do to maximize your chances for a real gig when the time comes, especially if you don't have background or degree. Don't be afraid to show the world what you're learning, create a profile on github and put it out there. When you've become more confident in your skills, create a profile on stack overflow and start helping other people. Stuff like this will be an asset to your resume, even if it's not top quality it shows that you enjoy doing this. There are companies out there who prefer to hire not according to what you already know, but what they can get you to learn.
I'd pay $11 to not have to use either of those. 
FYI Our corporate Symantec Endpoint Protection flagged this as a virus. http://securityresponse.symantec.com/avcenter/cgi-bin/virauto.cgi?vid=4294924068
I just _knew_ the very obscure closure leak would be listed as part of these "common" memory leaks.
Vim is better, more robust, free-er and more customisable. Fight me casuals.
I've the same problem a plugin for syntax highlight will sometimes go hiwire and hog one processor to 100%. And once the plugin goes that way you have to restart vscode. Most of the times you do not realize immeditely, only after a while when the notebook is starting to get hot.
First off, if you indent a line with four spaces on Reddit it will appear as code. Using this would make reading your post a lot easier. &gt; innerHTML = f; &gt;I am using JavaScript with both jQuery and Angular Second, none of those three forms of DOM manipulation (direct via `innerHTML`, via jQuery, and via Angular template rendering) go together: if you're using Angular you generally should not be using `innerHTML` or jQuery, for instance. And while you could use `innerHTML` and jQuery together, there'd be no reason to since jQuery has `$(...).html()`. On top of all that, it's also not clear what you're even asking (eg. it's not clear what you mean by "the right things to input").
Yeah because you can edit text at lighting speed once you've spent years learning all the commands. Getting characters into the file is really the bottleneck with programming, since my advanced vim using brain instantly knows how all the code should be for the whole project.
Woot!
TL;DR: they're recommending Typescript as it seems to catch more errors and has better error messages (and better tooling, e.g. VSCode integration) than Flow. --- And, yeah, it really seems like TS is winning out over Flow, to me. Flow was a bit ahead of TS when it first came out, but TS has covered a *ton* of ground in the last year since 2.0 hit. 
I am sorry. I am new to all this. to simply put it we will soon be working with angular but this is a formula we had devised to allow us to add a max buy feature if we were to add an upgrade feature to the game we are doing this as a part of an IT project even though we are reasonably new to all this but yeah. &lt;!DOCTYPE html&gt; &amp;nbsp; &lt;html&gt; &amp;nbsp; &lt;body&gt; &amp;nbsp; &lt;p&gt;A typical arithmetic operation takes two numbers and produces a new number.&lt;/p&gt; &amp;nbsp; &lt;p id="demo"&gt;&lt;/p&gt; &amp;nbsp; &lt;script&gt; &amp;nbsp; var a = 100000 ; &amp;nbsp; var b = 1000 ; &amp;nbsp; var c = 50 ; &amp;nbsp; var z = 100; &amp;nbsp; var d = a / b; &amp;nbsp; var e = d * c; &amp;nbsp; var f = a - e; &amp;nbsp; var g = f / b; &amp;nbsp; var y = z * g; &amp;nbsp; document.getElementById("demo").innerHTML = d; &amp;nbsp; document.getElementById("demo").innerHTML = e; &amp;nbsp; document.getElementById("demo").innerHTML = f; &amp;nbsp; document.getElementById("demo").innerHTML = g; &amp;nbsp; &lt;/script&gt; &amp;nbsp; &lt;/body&gt; &amp;nbsp; &lt;/html&gt; &amp;nbsp; 
Software which deserved to be paid for the efforts of one programmer dedicated to improve the coding habbit of rest of millions of programmers VS Software promoted by big corporate VS software developed by community.
Because Javascript "scripts" are different from Javascript "modules". This can have real implications on how certain code executes. Modules have 'use strict' enabled by default, for example, while classic scripts do not. When the JS engine goes to load some code, it needs to know whether to activate module mode or not. In the browser, this happens with a special &lt;script&gt; tag plus only letting modules import other modules. There have been many proposals for how to do this in node.js. Detecting based on file contents seemed like a good idea, but nobody could make it work in practice. Adding a special field to package.json would be similar to how browsers do it, but that proposal wasn't acceptable to the node team. Ultimately, node.js just did what it already does - use another file extension (they already special-case '.json'). I personally would have preferred '.es' as the file extension, since these are ES modules, but I guess it's too late now.
Hi rorytha, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi _aloy, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi RenjithVR4, For javascript help, please visit /r/LearnJavascript. Thank you!
+1 this. Anyone can learn to dev, but you can't teach curiosity and enthusiasm.
You can teach it. But you can't *fake* the real work you've done. I've heard many stories of people making a great impression on a technical interview but being shit in actual work.
VS Code has actually been one of the few electron apps that has *not* hogged my memory or grew into dozens of processes. Does it actually have high memory usage for you? 
He was obviously kidding. You can use vim just like a normal editor after about a week. Just go into insert mode, and save to disk before you quit with `ZZ`. I think it took me about a month of solid use before I felt like I wasn't being slowed down any more though, to be absolutely fair. 
Isn't that because it makes an outside data conneciton?
&gt; Because our websites tries to access Facebook over and over again, so the site never loads fully. https://www.stevesouders.com/blog/2010/06/01/frontend-spof/
Yeah, I'm kidding around too dude. I used to like vim for like the first 2 years of college and got really tired of it when I realized editing text isn't what slows me down at all. Now I haven't used it much for years and it's annoying trying to remember how to do basic stuff.
It doesn't even mention that Chrome's DevTools were originally WebKit's DevTools.
Vscode is pretty damn good with JavaScript and c#. It has by far the best intelligence for JS of all text editors. Hell, it is even better than webstorm a lot of the times. 
You are right, I haven't gone too deep into the history of DevTools. I made whole research on web dev tooling, and there is just too much to talk about - I wanted to focus more on the future. Maybe I'll write another article focusing solely on the history. Anyway, yes, you are completely right. Chrome inherited Web Inspector when they forked WebKit. 9 years later Chrome DevTools code is still very similar to Web Inspector's (even though UI isn't).
&gt; If you're willing to give up using an IDE to use a text editor, for faster performance FTFY
Pretty much. If you want a lightweight text editor experience use Sublime. if you want a more integrated developing experience use VS Code. 
A lot of people are saying {Atom, VS Code, etc.} is better IDE than Sublime, etc. First of all, Sublime is a text editor, not an IDE. Second, whats the reason someone would prefer {insert your IDE} vs Sublime? 1. Sublime is **fast**. You cannot really comprehend the difference if you have been using IDEs all the time. I am on a latest generation macbook and simply typing text in Atom editor feels slow. The feedback time is at least 10-25ms longer than Sublime. This can get annoying really fast. The same applies for opening files, jumping to lines, etc. 2. Sublime can open large files. Like, did you ever need to edit 20MB file? Your IDE is not going to even open the file. Sublime will feel like using vim. Sure, it is rare that you need to edit 20MB file. But it feels even on 2k-3k files. 3. And the most important reason ‚Äì **battery life**. I can code all day using Sublime and it will hardly impact my batter life. Meanwhile, Atom IDE (and every other Electron app) is always top of the list memory/ CPU/ battery hog. I have been using Sublime for 3 years. The only reason I have started to use Atom editor is because it has a lot better Flow type integration. As soon as something comparable appears in Sublime land, bye bye Atom.
My `subl` terminal command stopped working on updating to 3.0 on macOS. For those in a similar position, the following command will set it up correctly: ln -s "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl" ~/bin/subl [Source](https://www.sublimetext.com/docs/3/osx_command_line.html)
The fiddle is not linked correctly, and there's multiple ways and caveats. ``` let elem = document.querySelector('.shipping'); elem.parentElement.removeChild('elem'); ``` That's one way, but the selector may not work the way you need, and you will need to store the parent element if you want to add it back. Alternatively you may wish to 'hide' the element. ``` document.querySelector('.shipping').setAttribute('visible', false); ```
The most interesting thing in there to me was the bit about who would support the project when the developers got tired of it - that is a bad omen that they mention it.
Emacs is more customizable, has Evil mode built in (best vim emulation there is).
Just from a quick glance, you are only adding two numbers. Shouldn't you be adding all four numbers?
Vue that for some reason my phone autocorrects to Vuelta. I have no idea what that even is.
That was just an example, not the actual being used.
What is Flow type?
Didn't Sublime text 3 come out years ago or have I gone crazy?
Still no ligature support :(
It would be more useful if you could console.log() more than once.
I'm not sure exactly why, but the virus definition is the plugin manager is Trojan. So that makes sense. Sublime 2 never had an issue.
I thought this too, but I have a feeling it's been in beta a while 
Battery life is a valid concern, but it's worth mentioning that Atom occupies its own category of slowness, all things considered. VSC is _many_ degrees faster on startup time and feedback latency, and it can handle large files a lot better as well.
Obscure and common are not mutually exclusive. Quitcher bitchin'
Hi /u/couchjitsu, please don't troll. Thank you.
Hi NbAlIvEr100, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi Ktorti, For javascript help, please visit /r/LearnJavascript. Thank you!
[It is Facebooks's version of Typescript.](https://flow.org/) (basically)
It has been in beta for what seems like 30 years.
Flow is type annotations for (the otherwise typeless) Javascript. Originally by Facebook. 
&gt; What are some game changing facts on choosing react over angular that I should tell my manager, without sounding like I am a hard headed guy who is trying to take over the whole team? I'm a big fan of Angular (version 2+ *not* angularJS), but it does have it's pain points. 1) Observables... you don't have to use rxjs, but if you do and no one on the team has experience with them, then you're pretty much asking for a steep multiple month learning curve. 2) typescript, I love it. I think it's straightforward. Many people do not like it and think it's cumbersome or complicated. 3) verbosity, this is a little bit of a stretch, but if you're writing a __simple__ display component then it's pretty much guaranteed to be twice the length of the same component in react. Don't lead with this one -- it's kind of weak imo. So, as an angular fanboy those are what I would lead with. However, I think you should consider if you're being a hard head. I don't get to work with Angular at work, and I wouldn't really try to make them change -- especially if I was just starting. It might not be the best idea to make waves as soon as you arrive.
Tell them why you like React. I don't think you could tel them why to pick React over Angular without having worked with both.
&gt; I don't get to work with Angular at work, and I wouldn't really try to make them change -- especially if I was just starting. It might not be the best idea to make waves as soon as you arrive. This. It will not be just a tool *you* will be using, it will affect the whole project and the entire team or anyone who will maintain it in the future. Besides, you're being given an opportunity to learn something new *and* get paid while doing it. Seize it.
Being fair though, it's not actually common. Not rare s hens teeth, bit not common either.
Does anyone use IntelliJ/Webstorm?. I finally caved and pay monthly and since then I've not looked back. It's been fantastic for it's speed, refactoring, click into modules, debugging, flow type, real time linting based on project config. I probably use 1% of it's capabilities but that 1% I've not been able to reproduce in any other editor / IDE. I tried using the last release of sublime for two weeks, thinking that would give me enough time to acclimatise and rate my productivity. It fell through the floor. 
I find MongoDB is easier to set up in a web app than PostgreSQL. Yes, Postgres can do a lot of stuff. But that's also a bit scary isn't it? I don't want to bring in an entire OS just to save some JSON that is sent from my front-end application. With proper boundaries between contexts of your backend services, each should own their own data and in many cases MongoDB is perfect for that.
Sorry about that, here you go: https://jsfiddle.net/hcwwfv6e/
I personally think React is better. There's too much surface api and custom angular specific knowledge, for not much benefits, vs dealing with react, where in most cases 99% of the time you're writing straight javascript. Also, the community is stronger on the React side. If this is your first job as a web developer, you can't really be picky. To be honest, there isn't a whole LOT to react. You get lifecycles down, you get all the React dsl (className vs class, camel cased css, component life cycle methods, passing and working with props, this.setState), then you're good. Everyone can "know" React nowadays. Companies that do hire FE developers to work on React wouldn't look over a good candidate who just knows Angular. So just work with whatever your manager picks. If you really want to broach the topic, just ask: "Hey I'm curious, what made you decide to choose Angular". And he'll either give you the "Angular is good for companies" or maybe he'll be a little bit open to ideas, or whatever. But just ask innocently, probably your best vector.
It did take them 3-5 years to release v3.
https://jsfiddle.net/mm0s665d/ You should have at least tried to write something. There's still no context as to when or why you'd want to remove or what other selectors might clash with that one.. But the crowd at /r/LearnJavascript is more accustomed to these problems and could point you to a stack overflow link. You should also have no trouble with google. GLHF.
**Here's a sneak peek of /r/learnjavascript using the [top posts](https://np.reddit.com/r/learnjavascript/top/?sort=top&amp;t=year) of the year!** \#1: [The Entire JavaScript Language in a Single Image](https://fossbytes.com/wp-content/uploads/2015/09/infographic-the-entire-javascript-language-in-one-single-image-491250-2.jpg) | [29 comments](https://np.reddit.com/r/learnjavascript/comments/675fk4/the_entire_javascript_language_in_a_single_image/) \#2: [This pretty accurately describes my feelings on my JS learning journey so far.](http://imgur.com/zKJt5rb) | [6 comments](https://np.reddit.com/r/learnjavascript/comments/5k71cn/this_pretty_accurately_describes_my_feelings_on/) \#3: [Github Repo with 100+ Free resources to learn Full Stack Web Development.](https://np.reddit.com/r/learnjavascript/comments/5zse5u/github_repo_with_100_free_resources_to_learn_full/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
It does manage to use more memory than atom though.
Massive yes. It works better if you just use it for code. But logs, scripts, data and other text files can be large.
I like sublime for small projects and large files, use IntelliJ products otherwise generally. I miss the performance of file switching and such from sublime, but I like some of the niceties of the IDE too much.
I'm a big React fanboy, and I freagin despise Angular, including Angular 2+ With that said, any of the big name frameworks right now will get the job done. Unlike the days of Backbone/Angular 1 and all of the smaller spaghetti generating frameworks of old, most of the modern ones are good enough to get stuff done without shooting yourself in the foot too much. Having a new dev just come in and push hard on a framework is freagin annoying. There's context to consider, what the people currently on the team know (not just framework wise, but the background, skillsets, etc), and a ton of other factors to consider that may not be obvious to a newcomer. Or maybe the manager is biased, and it's cool to put some points forward, but its unlikely going to be stuff they haven't heard before. Case in point every time we onboard someone who tries to convince us to ditch Redux. I've read the millions of articles and all the arguments from all sides. A newcomer adding to the bikeshedding isn't going to generate any productive conversation we didn't have a thousand times already.
Sorry but I wouldn't use this. D3 is pretty amazing and has my vote but I've seen some smaller/light-weight charting libs which seem much more... forgive me, but... professional. This looks like a decade-old-in-house-project that was dumped on github which is pretty much what you said. We've all written ugly internal code we wish no one ever sees, and this feels like it wasn't meant to ever be anything but internal. My best guess is that if someone chose this over D3 it's because they wrote it. For starters you said its open-source and I see a license file but the js file itself contradicts that. You can't do that. I wouldn't use it because the copyright says 2006 and that seems about right for the code that follows. A lot of this code is extremely dated, and I recognize some of these hacks, but even for 2006 there's a lot wrong. I wouldn't use it I don't think any author takes this project seriously, they're missing incredibly simple and trivial details like that. There's barely a commit history, no real stars/forks/issues/PRs, no users I can find, so I don't think anyone else takes it seriosly either. If you're serious about building a charting library, (which I doubt because what's wrong with D3?) then you need to understand how things have changed in the last decade. - Your code should be modular. I can't believe this is one 20k-line file. - Ever heard of "not-invented-here" syndrom? You have a hundred lines of code for things like formatting numbers and dates. I guarantee there are packages you could rely on like momentjs. - Stop supporting IE6. I recognize some of these tricks/hacks and they're honestly not needed anymore. - Look at modern libs and see how they name things and how they organize things. I don't want to review the code but you'll notice that no modern, popular lib looks anything like this. - I've seen better APIs. Same as above, look at other libs. - Is this the first time in version control? I see no legit commits and there are "name - date - fix" comments all over. - I've never heard of the author and this is his ONLY github project. That's kind of surprising to me these days, even students who apply for jobs where I work have more repos and interaction with other projects. I won't rag on him for that but it is something people consider when looking to use a project. If he had some PRs approved for a large, well-known project, I'd be confident that he knows how to use git, how to make PRs, how to work in the community, etc. A few quick-glance comments about the code: - This is written like minification doesn't exist. It did in 2006, so why `d = s1 - e1;` huh? This is really hard to read. - There are way too many underscores. You don't even need ES6 to start using more privately scoped variables. - I also see a lot of "do" words in function names. I don't know if I've ever seen that to be honest. - Linters and format checks would really help clean it up for reading. IMO it's not worth it. You can do some powerful stuff with D3 and it has a legit community. Doing your own thing just doesn't seem to make any sense. **EDIT**: I just noticed the website. This was originally a paid application? Wow. Just wow. And boy was I right on IE6... LOL. The website says "powerful and clean" and I think it all honest opinions, the source code does NOT reflect that. 
See https://medium.freecodecamp.org/why-i-still-use-vim-67afd76b4db6, initial testing also shows Sublime and Vim using somewhere around 80% less power than Atom and VS Code (need to do more iterations on the battery/cpu benchmarks however)
I'm a HUGE fan of WebStorm. I was just interviewing for a new job the past couple of weeks, and I would ask what IDE they used. If they didn't use WebStorm I wasn't interested. EDIT: It seems people think I was the hiring person. I wasn't. I was the candidate. I was the one looking for the job, but I wasn't interested in the job, if they didn't use WebStorm.
Its shit. https://medium.freecodecamp.org/why-i-still-use-vim-67afd76b4db6
Happy to see it finally out of beta, it signals stability, moving forward etc.
Benchmarks https://medium.freecodecamp.org/why-i-still-use-vim-67afd76b4db6, my bias is towards Vim but Sublime 3 comes out really well. Not included but my benchmarks show 80% longer battery with Sublime/Vim compared to Atom/Code.
Does it? Not for me
There is a tradeoff here: If you choose to process `node_modules` with Webpack, you may gain optimizations on modules which were not already optimized. For example, a module that was unminified could be minified by your build. However you can inadvertently lose optimizations that a module may get from a more performance-oriented compiler (Buble, Clojure Compiler, Rollup). Only a thorough benchmark will be able to tell you which way is best.
After about a days worth of research, my initial conclusions: OrientDB = no go, as of june 2016 it was a bit unstable in scaling, more tests needed to confirm. arangoDB = general purpose use case with integrated analytics (graph / geo-indexing), looks to be the new MySQL (in terms of abundance of use). couchbase = when you want to abstract your analytics to something 3rd party (e.g. elastic) for redundancy / granularity. MarkLogic = choice when moving from existing RDB system, enterprise solution with integrated security layer. Cosmos DB = MS Frankenstein API.
Not going to speculate about the main question, but in regards to &gt; if they can pop up a notice telling you to turn off your popup blocker, why not just put their ads on that? They could, but the ads would still be hosted on the same sites/hostnames, and would still match the rules in the block list, so the ad would just be blocked in the popup instead of being blocked in the main body of the page, changing nothing. In other words the underlying issue is ads coming from origins that are easy to differentiate from content, not the location on the page where the ad appears. Publishers usually don't have control over the sites hosting the ads (i.e. they are run and managed by the ad networks) so they can't really do anything about that fact. If you really wanted to make ads unblockable, you could put the images on the same hostname as the content, and give both of them URL paths that are indistinguishable (e.g. arbitrary hex digits) such that a block list cannot list one without listing the other. But that's not very feasible because it would require the publisher to also host the ad media files themselves, and that would mean they would not be served through the ad network, and the ad networks would never allow that, because they also want all the juicy analytics that come with hosting the ads. Maybe it would be possible if you could reach out to clients directly and convince them to let you host their ad media in house, but that's not really how the ad industry works. You have to go through one of the larger ad clearinghouses in order to be linked up with a large enough number of clients to make it worth all the bother.
I might have cared like 3 years ago...
That is very little information. 
If you truly have an argument for choosing react over angular (I personally like them both, for different use cases) for this particular project, make that case to your manager. "I have more experience with react" might in some situation be enough of a case since they hired you for a reason. Usually it won't. "React is better because I say so/ I just like it" is not going to make anybody respect your position. On top of that, if you are a new hire and don't respect the manager enough to trust their (or the rest of the team's) judgement, you may not be in for a great experience. If they have a legit argument, then consider a chance to work with another toolset that you may like or hate - either way you most likely will benefit from the experience. If you know your tool is the right one for the job, explain why. The requirements of the project - the client, the resources (including the skills &amp; strengths of the entire team), the problems you need to solve, etc - are (or at least should be) more important than what you personally prefer to play with. OTOH if they really do not understand why they are choosing angular but won't hear any reason it might not be the best choice, you might not want to stick around. 
I agree with everything you said completely. I've used vim and then sublime at work for the last 5 years for almost all my web dev. But I will also say that I spend a lot of free time working in Unity with Visual Studio on my PC and that IDE feels just as fast to me as sublime. It is a pretty powerful PC though. Also, multi-line editing in sublime is better than any other editor I have tried.
I was going to mention battery life as well. Some days I just have to do some small scripting tasks (in NodeJS), and my MBP can easily last the almost-mythical 10 hours of battery when I'm just using VSCode and the usual (safari with a bunch of tabs, airmail, messages, but not Slack, that app sucks battery faster than [explicit]).
Question, what type of stuff are you doing that don't need an integrated JS debugger? (if you are working on JS that is).
Was this the angular TS plugin? Drove me up a wall. I just leave the console opened but minimized as small as it will go. Terrible fix. Best fix I've found though other than just using React cause it's better...too bad we use angular at work :'(
It's really great. You can even use it without adding a single type annotation. Only complaint is that it can get a little verbose, but that's attributable to any type system built on JS. (but really, try adding a full 1:1 annotation for function params that is an object with default values :|)
The browser's User-Agent is the most reliable way to check for this. You can use a variety of RegEx filters to check for specific platforms and then change behavior based on that.
Thank you for introducing me to some of my battery suckers, I had no idea
Which is not to say you can't install some packages that bring certain IDE-like functionality in Sublime, if you so desire. But the quality of those packages varies a bit.
 Webstrom is great but you can not decide a candidate based on his IDE. 
Nope, it was the PHP language server. Agree though, insanely annoying. 
I spend my days writing React code, and my evenings/weekends are PHP and Vue.js. I do all my debugging in Chrome devtools. 
You CAN, but you probably don't deserve to be making hiring decisions if you do. 
That's really a short sighted reasoning. 
Hi TargetNeutralized, For javascript help, please visit /r/LearnJavascript. Thank you!
https://github.com/jhallen/joes-sandbox/blob/master/editor-perf/readme.md I find vscode to be generally snappier than atom for sure.
Have you tried Color Sublime? It‚Äôs amazing. 
I use VS code all day every day for JS development but I've always used Visual Studio for c#, does vs code have any advantages over studio?
I'm glad they've got a good looking logo now, it's about time.. I'm not sure what they were thinking with the old one. Good update as well. Nice to see subl still moving forward, even though it's slow progress. I really think it'd benefit from being an open source project, both to advance functionality and speed up development.
Do you have a source on the commonality of various JavaScript gotchas in the wild?
What?
Microsoft FrontPage v11
Sublime is ok but costs money and I'm cheap :) Atom stutters noticeably for anyone coming from any decent editor. Notepad++ was really awesome when I was on windows. No frills, just me and the code, and it's super snappy. Emacs was good too, but the shortcuts are weird and I never really got into power user territory. I think what little VSCode lacks in perf, it more than makes up with its autocompletion system and plugin ecosystem. Things like version auto-completion in package.json, side-by-side markdown preview, prettier formatting on save etc, save sooo much time. Big files honestly haven't been an issue for any editor I've listed other than Atom. I've been able to crash it several times with 200kb+ files, but all other editors here handle those just fine.
I use PhpStorm (same company as Webstorm, etc). and I also use SublimeText. IDE for most dev work. Sublime Text, I use as a "clipboard", editing CSVs, txts, etc. So they are two totally different products IMO.
I paid $79 for Sublime. A good tool you use often is worth spending on. 
You seem upset about something.
2 guys, 1 app?
Thank you! Check this out now... https://codepen.io/SarahC/pen/rzQrJX?editors=1010
Running Kubuntu on a Lenovo Carbon from a couple years ago, and Sublime felt slower to me except on very large files.
Very funny :)
I see very little mention of linux (i.e. ubuntu), only windows and mac, safe to say I should avoid this since I use ubuntu for pretty much everything?
javascript, no I mean ecmascript! no I mean babel! good old babel, doing all the stuff 
Dreamweaver 
Sublime is nice, but its bus factor is way too high.
Do you hate yourself that much?
Why? I was asking a question, nothing more. It would be good to know what kinds of JavaScript-specific problems developers commonly experience. People seem to have a problem with me asking, or pointing out the difference between obscure and common.
It's a great product and use it for most projects (PHPstorm in my case). I tend to prefer VSCode for lighter projects though. 
Having spent the last two weeks building a mobile menu at work - I can't say I'd recommend this as a first project. However, getting in over your head is sometimes fun. For swiping, check out the hammer.js library. You can use it to have swipe events call transitions between the menu divs. Also, for now I'd avoid a menu design that involves any stacked layers, because animating css can mess up z-indexing in complicated ways.
If it's easy when youre designing IT structure, it's probably not telling you the truth.
sorry i mean progress bar bro. effect like progress bar. if you run above code will echoing to browser in normal way.
How does any text editor have a bus factor? Every engineer at my shop uses a something different. 
Ah okay, thanks i'll check that out
In connection with the previous post maybe, but that post is still a valid question. I wonder if it is possible to pick up on some of these and other gotchas via static code analysis, and scan github repos that are active now and have been around for a while to see how common some faults are and how long it generally takes for them to be fixed.
I don't really understand this one. Doesn't the issue stem from having a global variable accessible to the insides of that function thereby causing whatever is inside to be unable to GC?
Well, since since you want a web desktop app electron is a very good idea. Also, electron is just a container ( think chrome and node ) so the hi / presentation layer can be done in any spa or even node runtime . So, you can use react or angular or vue or any other, just please take into consideration that a electron app vs a spa may not be always connected to the backend... so offline support should be taken serious... Well good luck :)
Wow. Good luck.
Sublime is developed by 1 person.
Have you considered https://npmjs.org/package/rdb ? Docs at [https://github.com/alfateam/rdb/blob/master/docs/docs.md](https://github.com/alfateam/rdb/blob/master/docs/docs.md) It is used in critical enterprise software. It is stable with few bugs. I am the maintainer - so I am biased of course..
In our codebase for instance we use classes, async/await, spread, perhaps the full range of es6 and up. The transpiling effort isn't small and for things like async/await it's downright ugly (asyncgenerator). We publish source as is to allow customers to optimize against it (if they don't exclude node_modules). Then a browser-monolith, es5/cjs, and i think es5/esm would also make sense from reading through the replies here. Thanks for all the hints!
I don't see why it wouldn't work, [Electron supports linux](https://electron.atom.io/docs/tutorial/supported-platforms/). You can try typing these three commands: git clone https://github.com/electron/electron-quick-start cd electron-quick-start npm install &amp;&amp; npm start
Still by Facebook AFAIK
Side note, you can actually run node debugging in the Chrome tools too (with a little bit of cli-fu), which is awesome! 
Short answer, no. Long answer, if you like setting up your entire build process by hand, including package management instead of having a tool built to do just that, then VS Code is a lightweight alternative to visual studio. 
Maybe it's not the most common, but whenever I've been asked to help on tricky memory leaks the cause has normally been repeated async callback registration (e.g. requestAnimationFrame, setTimeout) combining with accidental closure capture, e.g. capturing context-allocated bindings not strictly required by the callback. I *wish* rAF accepted a scope/thisArg parameter (e.g. like setTimeout takes) to permit pure/top-level callback functions to be used. Until then, bind() is a workaround to create a callback that only extends the lifetime of explicitly nominated objects. If your leak is just down to some ever-growing object graph, the memory profiling tools allow you to inspect the heap's retaining links. 
So I have to pay $80 for ST to throw my $200 Operator Mono font down the drain?
Did you mean very sad? Because it is.
oh, well the article completely ignored linux for the most part, as if it didn't even exist or was just a subset of Mac.
Text editors are harder than AAA games apparently.
OP is going to really need it.
Your tone of voice in context with your original reply makes it sound that way. You can find out the common / uncommon JS issues with a quick search, there are a lot of places that post about it.
Yep. 'I still do, but I used to, too'.
With @std/esm you can unlock unambiguous mode that will treat any file (non .json/.node) as ESM as long as it has at least an import, export, or "use module".
Worth noting is that these benchmarks are for base configuration, ie. without plugins. Add couple of plugins to Atom and you can 100x those stats for Atom.
Very interesting read. Another redditor recently made me aware of the module/nomodule option in script tag and the argument was that now with native es6 modules in chrome we don't need sourcemaps anymore in development. While that's very nice, the more compelling argument in this article is performance. I was not aware of the huge impact. Less than half the time to parse compared to an es5 bundle is impressive.
That was sarcasm, so basically, yes :)
Speaking from experience, rather than from a dataset. It's possible that my experience is unrepresentative, but I imagine it's not. I've worked on a broad range of JS things for a long time. So yeah, caveat that it might be the most common memory leak, but also expectation that it's not. Do you think it's common?
Ok so I found this: https://github.com/xpl/string.ify . Formatting seems to be ok - not a big fan of the lispy looking output, but it works. would be nice to find something with a little better output
the points criticised in this article seem like features that few platforms have good solutions too. they are general difficult parts for any platform to get right
I can't really agree with that blogpost. The only argument against that makes any sense is the time investment. Yes that's true whether youre going to invest in Flow or Typescript. But &gt;A false sense of security from the misconception that this will have any effect at runtime The blame for that false sense cannot be pushed onto Flow. If you're using a tool without knowing what it's uses are then you should blame yourself. &gt;More damn errors to fix before your pull request gets merged in What kind of argument is this even? That's like saying you don't like unit tests because now you have to make sure they all run green. Well.. duuuh
I use Ublock Origin which does this. It's offered on the Chrome web store. If Google doesn't have a problem with it, I don't either.
Tell them why you like it, but don't say "the community is so lively". This is a place of business, and they will use whatever fits their needs. They don't care which online community you have more fun in. Sell them on the strengths of the product functionality, and why that makes it better over the other.
I don't know whether it is or not; my experience is the same as yours. This is not really what I'm getting at, however. Perhaps the author included an uncommon error in his list of common errors, but that doesn't make it obscure.
Care to enlighten me?
thank you for the feedback thomash. I agree, and the goal was not really to criticize. I have a lot of respect for the work that went into the electron framework. My personal hope is that the electron community is strong and large enough to address these big, general, outstanding issues so that we can find (better) solutions together. Right now, it feels that everyone has to find their own solution. The first step is to be aware of this which is why I started the list 
Is high memory usage a problem? I've seen this as an argument all over he place. I mean if you have memory then it should be used right?
&gt; What kind of argument is this even? That's like saying you don't like unit tests because now you have to make sure they all run green Yeah, this is basically complaining that you don't code everything 100% correctly on the first run. One of the biggest gripes (but again, one to be expected) I have is that types and some ES6 features can make for some very verbose expressions and can end up making the annotated structures difficult to parse through for someone unfamiliar or new to Flow/typing.
I didn't say it did.
You are correct; OP did.
Because it's too much to learn or?
is it still important if we have VS Code now ? ;) 
A simple example would be if I had a person in my web app and it sent Json with the name, email, adress, age to the backend that handles person creation. With MongoDB I would just need to do a save on the document.
For javascript objects This is built in to all modern browsers: http://devdocs.io/javascript/global_objects/json/stringify `JSON.stringify(object, undefined, " ");` The last argument is the key. I've used four spaces. You could use a `"\t"` for tabs. This determines the indenting As for supporting functions, you can use a replacer function to convert the functions to strings. **edit** Re-read the question, made answer more relevant
It's assuming you know stuff about electron in the first place.
Set a goal to complete [one of these challenges](http://edabit.com/explore) every day until you start your new job. 
Does it now? Docs seem to suggest, that this option only applies to .js files. Even so, this behaviour is not compatible with the current version of ESM, which would only delay problems.
It's so easy no one should pay for your "expertise". If you're too young or inexperienced to understand difficult things are difficult, I hope you'll heed my warning.
VS Code and Atom are both built on top of Electron. Both run fine on Linux. I use VS Code on Windows and Linux (Xubuntu).
Expertise in a technology is just a means to an end for me. I want to solve people problems. If a technology helps me with that, I'll learn it. I sure hope I don't get paid to know a specific technology but instead for my ability to solve difficult people problems in an effective way. I don't know what's difficult about saving JSON from a front end app though. Naturally, there are other services in my backend that probably deal with more complex logic. And I don't build for scale first. I want to move fast and solve the people problem first. The same way Discord didn't start with Cassandra but with MongoDB. 
[removed]
And read lots of code! GitHub is your best friend 
Before solving comes understanding hard. If you don't see what's hard, don't assume it shouldn't be. Discord didn't do very well, take a real success like Whatsapp, and elixir's difficulty makes sense.
Sure, http://lmgtfy.com/?q=common+javascript+mistakes
Discord didn't do really well? It's like the only app gamers use for communication. It has even expanded its original use case and other audiences are using it. Please enlighten me what's hard about storing a simple JSON or you're just gonna keep saying I don't understand? 
Yeah I have to keep saying that if you think storing json is easy, furthermore, I hope to never be one of your clients. Here are some tips if you want to google your way into better knowledge: database column, B-tree, indexing, schemaless, deduplifying
Basically you know nothing about how a database works and what it does, begin with that.
Just when flow 0.54, Atom IDE with both Flow and TS support are released and Babel 7.0 with TS support is coming so soon. Battle is ramping on.
Well, you still didn't explain what's hard about my problem. Thanks! 
You can't afford my training time
Good discussion! Assume a person doesn't know something and keep repeating that to make yourself look smarter. 
You'd have a vague point, if you didn't say obviously simplistic things and disregarded my suggestions for keywords of study. I hope you're like 15 because otherwise, you are cancer in IT. Oblivious to complexity, underestimating scale, dismissive of difficulty, you are an insult to expertise, and by not looking into anything, you have made yourself yet worse.
VS is better for that, but if we are talking text editors and not IDEs then it would be excluded. I just mentioned webstorm, because the JS functionality in VS code is almost as good if not better in certain scenarios. However I have a 2gb windows 10 tablet and VS can struggle on it. I have been using vscode (and for unity development on my Mac) and with the c# plugin it works great. If you are developing in core, then it is great since you can use so many command line features. 
I wonder if they ever find a good way to slim down on the runtime.
&gt; Why would you eject from create-react-app? &gt; Until you eject you are unable to configure webpack or babel presets. Well sort of... you can use [react-app-rewired](https://github.com/timarney/react-app-rewired).
FiraCode is free ;) 
I've already studied those topics but thanks. I'm dismissive of difficulty when I ask you to explain it to me? Ok.
You should use [Array.prototype.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) and pass in your own `compareFunction`. Let us know how you get on with that and we can provide additional pointers. 
Also, try to imagine some types of quick projects, maybe to make your life easier at some point, and start doing it from scratch. It's really good for facing real-world problems.
If you don't know how to setup your environment, don't setup your environment. https://www.webpackbin.com/ https://codesandbox.io/ https://repl.it/ https://snack.expo.io/ Less posts complaining, more solutions.
First of all I would ask: What is your starting point? Are you already familiar with another language or have some basic js experience? What scale will you be working on? Is it agency work or are you working on an enterprise application? What technology are they using, are they hot on unit testing, do they use ES6 with webpack and babel, do you need to learn react.js or some other framework? Will you be involved in maintaining and writing build tools in node and the associated technologies? Given the short timespan I would consider all of these things and focus your efforts in one direction or another. 