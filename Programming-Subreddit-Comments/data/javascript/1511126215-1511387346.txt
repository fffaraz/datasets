You should check http://brunch.io/ out. It is easy to set up and use but a bit limited when compared to gulp.js and such.
I think it looks pretty. It would be awesome to have the same scientific support in JS world as Python does... I know there is https://deeplearnjs.org/index.html - but we need more :)...
Install uBlock Origin. Go to uBlock -&gt; Dashboard -&gt; My Filters Add the following line: ||a.thumbs.redditmedia.com/QXHHza4iNC-VAEJwCCBUTLisp8-wbzft_1txQwHMxc0.png$image 
Fizz Buzz.
Are you sure you hate jQuery? Because I hate people who use it just for AJAX and nothing else (252kb+ file for what can be done with like 5 lines of code), and yeah, people like that DO exist. Though it is pretty goddamn useless nowadays, it was good back then when clientside code was completely different between browsers, now it's at least somewhat close to a standard.
He said developer, not user.
You can use fetch and polyfill so that when browsers support it you can just remove the polyfill 
Use factory functions instead. Write less code and it’s testable without extra code https://medium.com/@pyrolistical/factory-functions-pattern-in-depth-356d14801c91
ELI5?
I feel we need to be giving our build chains less moving parts, not more.
You are disagreeing about the colour of shit. Who cares, it still looks like shit.
I find it to be a modern expression of the level of shit and piss that JS has become. I'd downvote me - lol.
Any sort algorithm with a supplied comparator function
That is a false-positive. To get even near to what the most simplistic 5 line webpack config gives you will have you jump through severe hoops with Gulp. It was a great tool for what it did, but [the web has moved on](http://www.npmtrends.com/grunt-vs-gulp-vs-webpack) from concatenations, loading iife's in correct order and the manual labour of managing dependencies. Webpack knows your project by AST analysis, like a real build tool. You import and use code freely without having to adapt the config. It handles minification, your images, gives you a dev server. If i had to do all of this manually with gulp plugins and regular expressions right now, i'd freak.
I feel like with the advent of static typing systems, intelligent bundling systems with code splitting / dead code elimination, and the addition of desperately needed features to the ES core like block-scoped variables, lambdas, iterators, promises/await, etc have made the language much more tolerable and powerful in the past few years. I'd love to hear why you think it has come to a greater level of shit and piss than before, though.
Hmm, so I looked and... bootstrap allows scrolling of the body of the website behind the modal! So, even behind the gray overlay you can still scroll. My thought is that I'm going to have to manually intercept the scroll event and keep resetting the window scrollY to be some saved value. Need to try.....
Is this better than code splitting? If so, how?
Transpiling is the act of making one language into another. In this case it could be Typescript into Javascript, or Coffeescript into Javascript. Many times you would use a transpiler like Babel to perform this process at build time, or when you're making the code ready for production. It usually transpiles the files, then merges them together into a single Javascript file, using a minification step. Dynamic transpiling is the process of dynamically detecting changes in the source and running the transpiler on that individual change, then including that newly transpiled code in the webpage without reloading the page. Typically changes would require a full page refresh.
Still not there. I tried disabling Adblock but no luck. Maybe it's a browser thing? I'm on Chrome 62.0, Win 10. Or maybe it show differently for users depending on how old their account is? 
Commented on the article, but you never know where people read comments... This is a good quick review of default parameters. There is an warning about destructuring and defaults that you might consider. function foo({name = "default"}) { console.log(name); // This can cause a TypeError } To correct this, you need to have a default object as well as a default destructured parameter. function foo({name = "default"} = {}) { console.log(name); // This does not cause a TypeError } It might seem like you could avoid this risk by combining the default object and the default value, but that only works in some situations. function foo({name} = {name: "default"}) { console.log(name); // Only gets default if no object was passed } Whenever you use destructuring and default arguments, it’s important to understand where and how to apply the defaults for the result you want.
Agreed. In some projects, the builds are more complicated than the code they're building.
I write my webpack config files in typescript and use gulp to transpire that before webpack kicks in. Fortunately I can avoid writing my gulp files in ES5 by having a globally installed util that will precompile my typescript written files to a dist folder which is where I run all my commands from. Luckily it was easy enough to wrap this all up in an npm that others can enjoy. 
It is more like a PaaS but with online coding support. We don’t want to categorize it as PaaS or IaaS, as we wish to provide a more integrated development + testing + hosting experience.
I guess "has always been" would have been a better way to phrase it. It was a joke - but thanks anyway for taking it seriously a wasting your time replying.
I think jQuery really shone a few years back before better standards, like you say. But the part I mostly hate about it is that it tends to be misused as a crutch these days, and doesn’t really encourage the right way of thinking about the DOM, if that makes sense. Like, I see some front end devs (who don’t really understand JS) writing some crazy jQuery one-liner to manipulate the DOM when you could do it far more sensibly using an OO approach. I just think it doesn’t really have much of a place these days, and those who still use it haven’t taken the time to learn JS, so jQuery leads to them writing weird code they don’t really understand. So I guess it’s a bit harsh of me to call jQuery names, because it really was revolutionary for its time.
Yeah JavaScript can be very tough on the eyes. 
This is precisely about eliminating the build chain altogether
This looks exactly like how you would set up DI in Angular(2+)
Some hypocrisy given your wall of unformatted text
Apples and oranges. I just fixed things with an extra paragraph break. Trying easily modifying the header image.
Depends on exactly what you want to test, but here are some ideas. * Fizz Buzz. Not terribly wild, but it'll separate the wheat from the chaff. For bonus points/cruelty, ask them to do it some way other than the usual if/else chain, or to include "Ding" for numbers divisible by 7. * Fibonacci, iterative and recursive, and possibly also memoized. * This requires basic DOM manipulation as well as knowledge of closures; given an arbitrarily large number *N*, generate a set of buttons labeled from 1 to *N* such that when I hit the button labeled with the number *i*, it pops up an alert containing *i*. * Likewise, AJAX and callbacks; ask them to place a GET request to some API that you the professor set up beforehand, and do something with the results.
This is much better: code splitting adds cognitive and technical overhead. A developer has to specify the bundles, which will inevitably result in some over/underfetching. By just authoring the individual resources, this automatically dedupes resources on the client, reuses what it has, requests what it doesn't, pushes dependencies for resources alongside the request. For example, let's say you have a component for which you add a new dependency - lodash.filter. There's nothing else you need to do. Nothing to build. You don't even need to restart the server. No bundles to worry about: it may be for example another component next to that component already loaded lodash.filter in which case it would be reused. Or the user may have visited a page where that resource was loaded already. Or it may be they haven't. Either way, it results in the optimal solution.
Jesus Christ, why would you let subreddits use their own style anyway?
&gt; I know there's a subjective component to it
Quick reminder. Check for template injection to. Sometimes can get reported as XSS. 
Why not benchmark [marko](https://github.com/marko-js/marko)? I thought this was supposed to be its strong point.
How do you reliably test this. Normally you test against the transpiled code. You then have reasonable certainty it works. With runtime transpiled code you can only test against what you get sent.
And replacing it with a runtime chain
* Angular main announcement - I'd guess if you use Angular you'd have seen this a million times. * React Vue - Unholy stupidity, not least because you'll have to ship both * Arbitrary incomplete list * PWAs - "Please start using a worse version of a native app" 
document.body.style.overflow = 'hidden'
Huh. I’m pretty skeptical to be honest. Doesn’t seem feasible to do dynamic transpiration in production. Any non-trivial application is going to involve some sort of kernel that would take way too long to transpire in every new page load.
not sure if troll or...
Hey guys, as /u/Reashu is trying to say is that that checkbox is not there by default, you need to install the Reddit Enhancement Suite addon. You can find it here: https://redditenhancementsuite.com/
Wow, the performance of React SSR is horrible =O
This checkbox is "gold" option. Use RES instead or disable all styles in all subs through setting.
What about currying. Make a function that returns a function
When you have a partial performance stack like this then yeah it is, but the page requests should be cached so the hits to the server are minimal (only dynamic content and user specific stuff, likely through an API over SSR anyways).
Transpilations are backed by an LRU cache, meaning the top N (default 25) browser-version combos are cached, it's only transpiled the first time it's requested, not on every request. As explained in the notes, you can also preheat the caches. 
Native Date()? Everything, lol
It's not a simple moving build-to-runtime, this changes a lot of things. Interested to hear how you think the failure case worse is worse though?
If it fails to compile the transpiled version right now, it's a build failure. If it fails to dynamically generate the minimum version in this system it's a runtime failure.
&gt; reliably test this. &gt; Normally you test against the transpiled code. You then have reasonable certainty it works. &gt; With runtime transpiled code you can only test against wh Puppeteer: https://github.com/rijs/sync/blob/master/end.test.js#L278-L328
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [rijs/sync/.../**end.test.js#L278-L328** (master → c5d6049)](https://github.com/rijs/sync/blob/c5d60499954e7cab2f07c4bb78ced28b4aa99126/end.test.js#L278-L328) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dq2f7vr.)^.
If it fails to dynamically generate the minimum version, it falls back to whatever you specify (whether you want that to be apply all transforms or no transforms).
You can't read the URL and have a switch/if statement if it's localhost. It's not the most elegant way and if you ever have a dev server it would leak the URL for that, but it's simple and it works. 
How “wild” are you thinking? I find that a useful exercise for learners is to implement some of the basic higher order functions like map and forEach themselves, and then play with them.
So... Class - is an object... a collection of properties and methods/functions Classes can be used to make more objects class Person { constructor(name, age) { this.name = name; this.age = age; } sayHi() { console.log(this.name + ' says Hi!'); } } object - in a broad sense, everything in JS is an object (collection of properties and methods). Here's a literal object: const billy = { name: 'Billy', age: 32, doStuff() { console.log('stuff'); } } Here's an object created from the Person class: const bob = new Person('Bob', 32); method - a method is just a function that belongs to an object. The `sayHi` and `doStuff` ones above are methods. parameters - are variables that are inherent to functions/methods. Functions don't have to have parameters (that's why the `()` is blank sometimes). You never have to have parameters, but if a function does have parameters, then it has those parameters as variables that take on values when calling the function. You assign values to the parameters by passing *arguments*: function func(param) { console.log(param); } func('hi') // 'hi' is an argument that gets passed to func the small program above will print 'hi' to the console because `'hi'` was passed as an argument through the `param` parameter and thus became available in `func`. Make sense?
Those tools are useful, but not all developers are familiar with FP. You may have a hard time finding code bases that have a strong FP orientation. Sadly it is easier to find OO orientation in JavaScript. There is a new trend of annotations too.
I see. I’ll read up on this more before worrying about potential problems ;)
Yes. Developer. And a basic skill.for a junior developer would be knowing how to implement third party APIs like react, or bootstrap. Someone here disagrees?
Not forgetting the abysmal performance on android... :(
Hacker hank has the classic problems.
There are at least 2 major problems with these numbers. While the raw/static benchmark is interesting, it does not belong here. If you have static content, you would simply cache it and serve it via Nginx (without ever hitting Node) and you would get another 10x perf increase. Which brings us to the next point: the content is *not* static and cannot easily be cached. Part of it not being static is having to pull it from a DB, which is where your bottleneck will almost certainly be. So, a realistic benchmark for rendering 100 rows of dynamic content should include the i/o needed to get the data, as well as only using non-cached templates what can render 200 or 1000 rows, too. I think you will find the perf numbers not differ by 10x, but more like 2-4x.
Sure, but come prepared with what you've tried and a specific question - at least that's how I see it - coming to reddit and asking people do solve all your homework is a waste of your time - why bother taking the class?
No, you can use Functors and Monads without understanding them because they are just (very broad) generalizations of patterns that people have found. i.e. you know how to use an Array, and a HashMap, you don't need to know how those generalize or how to prove something is a Functor. Some people will insist that more functional code is better, however we really don't have good ways to quantify what makes one style of programming better than any other. Pursuing functional programming is at least a fun academic pursuit though, so learn on your own time and find ways to make it useful for you.
Really I only had this question: A basic step is an operation that is executed in _____ _____ [two words] I am pretty much lost. I put byte code but im very unsure
You could get them doing things with Church encodings: https://en.m.wikipedia.org/wiki/Church_encoding
You are definitely on the right track. Your code is pretty high quality considering you're a "huge beginner". Keep it up. I second using a view framework (my vote is Vue) if you start adding more complexity to the game.
use phaser.io and build a pokeyman game clone
As nice as this is, and as annoying moment is to work with, this really should abide the temporal spec for future compatibility. It would be a win win. https://github.com/tc39/proposal-temporal
says the guy wasting his time writing a comment being a prick
Being "a JS developer" isn't really a thing. I mean.. of course it is, but for the most part you're developing an application and JS happens to be the thing you're writing it in, along with html, css etc. No matter what seems important from a technical point of view, there's a job to be done and focus on doing that job well. That being said, learn stuff. Lots of stuff. Try new things and experiment with concepts. *Gain Experience*. Overtime you might find you're really applying stuff you have learned, or are starting to notice that certain knowledge isn't as useful as it seemed before. What I'm really trying to say is, don't worry about whether a concept is "important" to know. Go forth and learn that concept and ask questions along the way. You'll either finally get it and apply it sometimes, or you won't but will have discovered many things along the way and be better off.
i meant it more as a, using github pages, not as in "rly?"
Functor is just an object that holds your data as a private and also implements a "map" function to transform the private data. You can think of javascript array as a functor. Monad is like a functor but after it transforms a value, it wraps your value again. So even if the transforming function throws error, you will be able to continue with applying multiple transform functions. Javascript promise is a monad and a functor.
No, ask in /r/learnjavascript instead. Also, always show what you've tried yourself before asking for help and read the sidebar before posting.
"basic step" doesn't have any particular meaning in JavaScript or programming more broadly that I'm aware of. I suspect that this is asking for something that was being taught as a high level concept. Because of this, anything offered here would be more of a best guess at what the professor/teacher is looking for than a confident answer. I'd look through your reading materials and lecture notes, if any, as I suspect that the answer is lifted directly from the lecture or reading. 
Okay makes sense. Will definitely be giving it a try soon. :)
Me in 2002: Ajax everywhere! Separate the UI from the data! Static UI assets can run anywhere! No SSR is good! Me in 2018: SSR IS GOOD IF NODE DOES IT AND NOT JAVA. WTF Javascript community. You make no sense. 
Wow, isn't this like cool as hell? Doesn't this have the potential to enable live selective rendering (hot-er reload) in development mode?
I've been experimenting with fast server side rendering, and so far ivi appears to be the fastest server side library. Sadly, it's pretty unknown and doesn't support jsx. 
Ty sir
In 2002, we try to optimize by doing more Ajax and avoid whole page re-rendering. SSR is still needed to be done today because of search engine crawler (which is annoying and not ideal) but SSR today and SSR at 2002 (whole new page all the time) is very different.
ivi is the fastest [1]. as for jsx, not sure how in-step this is with the latest ivi, but https://www.npmjs.com/package/babel-plugin-ivi-jsx [1] https://medium.com/@localvoid/virtual-dom-ssr-performance-5c292d4961a0
Anything that teaches them about functions being first-class and closures should do the trick. While I don't have anything you can show your students, I can perhaps inspire you with this tail-recursive implementation of the `fibonacci` function that *does not use a single variable or while loop - it's all just functions* - perhaps you can show it to them as inspiration as well: console.log((n =&gt; (f =&gt; (g =&gt; (...args) =&gt; f(g(g))(...args)) (g =&gt; (...args) =&gt; f(g(g))(...args)) )(fib =&gt; (n, current, next) =&gt; n &lt; 1 ? current : fib(n - 1, next, current + next) )(n, 0, 1))(7)); // logs "13" This works because of the [Y-Combinator](https://www.wikiwand.com/en/Fixed-point_combinator#/Fixed_point_combinators_in_lambda_calculus). Broken down into separate steps, the code would look like this: const A = f =&gt; f(f); const Y = f =&gt; A(g =&gt; (...args) =&gt; f(A(g))(...args)); const fib = n =&gt; Y(fib =&gt; (n, current, next) =&gt; n &lt; 1 ? current : fib(n - 1, next, current + next) )(n, 0, 1); console.log(fib(7));
If I understood it correctly, this looks cool as hell. Going to give it a try soon
Currying is only a subset of higher order functions, no?
The idea behind SSR is to allow partial static rendering on initial request (for faster client access, for SEO, and for clients without JS) _without requiring two different codebases_ but still allowing for the client to be a dynamic application with thin requests made to an api. The reason "its good if node does it" is not because node, it is because you can use one code-base for both the server and the client.
Yours is fine. Here I refactored what you were doing. Dunno if its better, was bored. I just split things up a little :p https://codepen.io/anon/pen/KyQPpY?editors=1111
Downvoting because this is very unethical.
Is it unethical if the user is warned and is participating willingly in order to earn in game rewards or an ad free experience? 
Not sure why you’re being downvoted, but yeah I agree with you. There is tremendous value in learning for the sake of learning. 
No, but something tells me that no one doing this would warn their users. When have you every been asked if a site can mine crypto on your machine?
I agree not warning users is unethical but if implemented correctly and ethically mining via Javascript/web browser has some real use cases. There are sites out there that have done it correctly.
Not trying to be a dick, but do you have any examples? I've literally never once been asked if it's ok to mine on my machine, but have caught a few sites trying.
Here's an example of a site using the power of mining within a browser for upgrades on the site. https://windscribe.com/miner/yt57xwbr&amp;pcpid=miner_email1
We aren't using one code base these days. It just doesn't happen in any company. I was just as much a believer in the savings that a one language codebase would make things cheaper for the business and faster for development. What I find in practice is Javascript itself isn't even one code base, it gets transpiled from ES6, and then the dev's are stepping through so called compiled code they didn't write to figure out problems. SSR can be done in any language so I don't see why the front end community decided after a long fight to get their code base away from back end teams has now become them.
The only difference between now and 2002 is Javascript is doing SSR instead of Java, Ruby, or Python. What is the difference other than the language?
What do you mean it doesn't happen in any company? The only people using React et al on the server are those *who are using one codebase*.
You can stick with what you’re comfortable with. 
Yes and no. The only time I use the terms "Monads" or "Functors" is when I'm chatting with other FP nerds, but in JavaScript, we're usually too busy using them to understand them. If you're using the `map` function of an array to create a new array, or using the `then` function of a promise to create a new promise, you might already be using them just fine. I recommend watching [this funfunfunction video on monads](https://www.youtube.com/watch?v=9QveBbn7t_c) (as well as [this one on functors](https://www.youtube.com/watch?v=DisD9ftUyCk)).
huh? you render your client-side app on the server. i wasn't aware java, ruby, or python could run on the browser. 
Oh god the significance of it. I was wondering why “this” didn’t work, for hours, before I discovered the arrow function. 
I'm not confused at all. I'm specifically talking about rendering HTML/CSS/JS on a server. The code the server runs can be any code as long as its output is one that a browser can render.
Fuck java
Sure. Now how do you get React to understand exactly what, if anything, needs to be updated on that page to sync with client-side state?
It actually took me way longer to understand this concept that i want to admit. The reason it took so long was because every time someone tried to explain, then they started to use hard words and then i just closed off. What you really need to do is to go back to the beginning and learn one thing as a time. var greeting = 'hello'; This line seems simple, but in fact it's not. There are so many questions you can ask about this, like is it an object, method or parameter? What can i use it for? Why did he write greeting, is it because he wrote hello? Why did he write 'hello' instead of 'hello world'? You can see I'm already confusing you more than i am helping. It's because i probably can't tell you how to learn it, but you have to experiment. ----------- I'll try to use an analogy, but it probably won't work. Imagine you are standing Infront if two slot machines, one is free and one costs 50 cent to play. Just think () means that the gap is too narrow, we can't put money in. And (coin) there is a gap to put money in. In real life it would be like this ( ) var twenty = 20; var fifty = 50; //Free machine - no parameter function free(){ return true; } //Paying machine - 1 parameter function pay(coin){ if(coin === 50){ return true; }else{ return false; } } Calling free will always allow us to play, because it doesn't require any parameters/coins But calling pay forces us to use a coin, and we have 2 kind of coins, namely fifty and twenty. So if we say pay(fifty); Then we are allowed to play, because we put 50 cent in the open gap ( )
Well, Web pack can actually use a Type Scripture configuration if you have ts-node installed as a devDependency. There's a suppressingly large amount of typing for the common plugins. You can also add // @ts-ignore to skip the one that doesn't.
What I'm loving is how people are reinventing problems that were solved 15-20 years ago by PHP, JSP and so on.
What are you trying to open? A code file?
I don't think I said anything controversial. Reddit as a strange place sometimes.
HTML and CSS are not programming languages though. Almost every front-end application solution has things like separate language for application appearance. Take Android and their XML for example, Android Java programmer is still Android Java programmer even if they use XML.
Sure. Not sure what your point is?
Awesome! It works! The only thing missing is a message for when you *win* - right now there's only a "you died!" message.
&gt;then the dev's are stepping through so called compiled code they didn't write to figure out problems Source maps have been a thing for a while now with js. You might want to look into them.
Just referring to the first sentence. 
disregarding that your reply literally has nothing to do with my comment, let me tell you everything that's wrong with your statement. none of the server-side languages you mentioned allow you to have a single toolchain and write in a single language for both frontend and backend. in fact, there was never such a language (unless you consider GWT, which had god awful, huge and slow JS output). react is not MVC, it's MVVM. virtual-dom was not invented before react existed. and the "problem" of updating the DOM was very real and resulted in shitloads of unmaintainable, fragile, impossible-to-test spaghetti code. the fact that V8 and other JS engines have had tens of millions of dollars worth of engineering put into them to make them fast has given us the option of writing the same thing everywhere. the problem we did not have before that we *do* have now is performance, but it's a much easier problem to solve than all the shit that is now *solved*.
I got lazy haha so instead of doing that I doubled the opponents attack so he would pretty much always win xD
Interesting to see what you did, thnx for sharing! 
wow lol it *really* sounds like you have no clue what you're talking about
I know about source maps. Thanks.
Staying on one programming language at a company is unrealistic.
What is your point? React, JSP, ASP...all doing SSR. 
That guy explains. 
I use vanilla javascript and canvas mainly, and it feels like I am just using a lot higher level openGL, and I see no problem with it... Then again, I'm not really interested in web development, I just noticed that it's so easy use browser page as part of presentation when you can program, and so I did in college, I don't really know how much web developers learn about actual programming. And what you said reminds me of people trying to use regex as html parser, and everything else. Another crutch when there's far more sensible approach.
Our company builds the front end using Node and our back end is Node. Our desktop POS is an Electron application. Our mobile application is a Cordova application. Aside from needing HTML and CSS on the front end it isn't unrealistic to just use JavaScript primarily. Just because you don't know of a company using one language doesn't mean companies are not doing it.
You guys got really triggered off the word 'any'. So I'll edit and say 'most'. Good for your company. I didn't say it wasn't possible, it is just unrealistic.
Actually basic skill would be to understand the language they are working in, and be able to develop in it. Adding a shitton of dependencies even if you don't need them isn't skill.
But it isn't unrealistic. We are literally using JavaScript everywhere. None of our coders touch any other language.
You really need to do more research into what SSR means with React. Like u/spacejack2114 said, it's not the same as when we were writing multi-page apps.
DI in JS like that shows a misunderstanding of the dynamic nature of the language.
Very interesting! Will you at some point integrate with Visual Studio Code through an extension so that code is sync'ed between my local environment and the online one? That would be sick!
-sees Angular, closes browser-
This is the goto answer for JS devs. But what I keep missing and what OO programmers really want is a DI container. In the post you've linked, the developer still has to do the bindings manually for every factory function's dependency. It's not that there is any magic to this, but they use a framework that usually handles this perfectly without ever specifying implementation other than in a container file. With factory functions you either end up coupling all over the place, or pushing down dependencies manually throughout layers.
Can you include a benchmark for non-VDOM approaches like HyperHTML? I see you did include es6 template literals, but then I don't understand why pug's precompilation is faster. Literals also compile at the load stage, so should be the same speed at run time.
&gt; SSR can be done in any language so I don't see why the front end community decided after a long fight to get their code base away from back end teams has now become them. This has nothing to do with backend/frontend. This is to do with rendering the frontend on the server in a pre-cooked way. Your API/etc would be exactly the same either way. 
&gt; We aren't using one code base these days. It just doesn't happen in most companies. Agreed, SSR specifically talks about rendering the template on the server though, it has nothing to do with your backend or API. &gt; What I find in practice is Javascript itself isn't even one code base, it gets transpiled from ES6, and then the dev's are stepping through so called compiled code they didn't write to figure out problems. Compilation targets have nothing to do with this discussion &gt; SSR can be done in any language so I don't see why the front end community decided after a long fight to get their code base away from back end teams has now become them. Again, it can be done in any language, but the goal here is to keep your _template rendering_ on a universal codebase so you do not duplicate any templating.
That's just ONE page.
What I loved with PHP/Java/Python is how people were reinventing problems that were solved 15-20 years earlier with COBOL, Fortran, Perl and so on.
How long do you spend on the top of the page on reddit? Most people literally immediately scroll down.
you are very right :) we initially ported the `Injector` API of Angular2 in a package called `diyai` first: https://github.com/fahad19/diyai only difference is, you don't need TypeScript for using this. that package later found its way into `frint` as a fork.
you are very right :) we initially ported the Injector API of Angular2 in a package called diyai first: https://github.com/fahad19/diyai only difference is, you don't need TypeScript for using this. that package later found its way into frint as a fork.
I've recently been working at a company ranking in the french top-10 on Alexa, and they are using SSR in production.
Same.
Thanks for the comment! Looks like the sync functionality is in hot demond :) We will surely look into this.
Superb! 
...but it was about making a rich text editor, code is just a raw text (and style format is another case, but there exists great tools like CodeMirror:)
Use case: you've been using yarn.lock to lock the dependencies of your repositories and now want to move to package-lock.json (introduced in npm 5) which does something similar. (or of course, the other way around!) With this, you won't need to update all your dependencies and go through lots of testing to make sure you didn't break anything. I hope you find this useful. Would love to hear your thoughts.
Hi /u/dexygen, we're very open to changes in the theme for the subreddit. As you correctly noted, the background is merely an image, and so, if turning down the saturation seems to alleviate it a bit for you and other redditors, I'd be on board with that. We had a stickied thread already on the design, but the majority of the comments were that we should revert the theme entirely, which we didn't feel like was the intention of the thread.
awesome! "Functions don't have to have parameters (that's why the () is blank sometimes)" this gave me a light bulb. Thanks so much. 
Amazing , I set up my own bot there , packages [ modules ] are already there , just have to write tour code at the index.js part and you are ready to deploy it . Had a few enquiries with the bot as i was afraid that my password might get stolen , went to the help desk and Ang replied me , he said he was willing to check the database to really make sure that the files that I deleted are not there anymore. Cheers , Fan of Postverta now PS. Ang , I was the guy that asked you about the bot earlier today :) 
Best explanation of monads / functors I've read in a long time!
Other platforms don't seem to have architecture problems with keeping the view in sync with app state. In iOS, MVC is used - enforced by the platform even. It works beautifully. I think the reason JS devs complain so much about how things were before is because there was no convention around event dispatching, which led to it being a mess. Also, the solutions such as Backbone (and early angular) were really quite poor compared to other platform's frameworks. React came along and imposed a philosophy on the community, which makes things a lot cleaner. That is a step in the right direction. My personal opinion though, is that React is needlessly complicated for a problem that only exists because of how bad the other frameworks are. I think you could probably get the same amount done with half the work if you had an even better framework. State management really doesn't need all the effort that is being put in currently.
Pulling it from a DB need not be slow if you use something like a key value store.
After some research it looks like using the browser cache is proving to be impossible as a replacement for localstorage in stale-cache. It comes down to one problem: it looks to be impossible to hit the browser cache through a XHR call without making a network call. The only hope I found was request cache-control: only-if-cached, but that's broken on all browsers. stale-cache's claim to fame is that it makes a very fast call to local resources, then later verifies freshness. This is made impossible if a network call always happens on the first call. response = staleCache({url}) // fast, no network display(response) // instant response = staleCache.fresh() // eventual, over network 
This is known is it not? I feel this is a comparison of an incorrect implementation of react SSR and the conclusion is incomplete. React render to string is synchronous...you have to account for that, you can't just push every request through renderToString or static content. After optimising your application you can get response times of ~5 - 16ms. We've had no issue of using and optimised implementation of SSR for a site that serves millions weekly. At no cost increase.
It sounds like I now I have twice as many code paths to worry about - and that's before I've even written my project code.
The best di system I've found in the front end world so far is Angular's. It can be hard to explain *why* a real dependency injection system is so useful though when everyone just counters with stuff like "just pass a factory around!". No, it's really not a substitute.
Being a "JS developer" basically means being a developer with JS as a language/ecosystem of primary focus. Just as being a .NET/JAVA/C++ developer is a thing.
&gt; While the raw/static benchmark is interesting, it does not belong here Yeah it was interesting. So why not show it? The author wasn't making an argument that anybody would swap between static or dynamic. Because, like you said, your site is either one or the other. It was there to show the baseline / hard limit for comparison. That's all it was there for. Seeing how far or close something is to the hard limit (when not using any system at all) gives you a better understanding of how important the differences between each templating system are. It helps you weigh up whether or not you should spend the effort in swapping between templating systems. Comparing systems that appear closer to the static/hard limit = probably not worth spending any more time on.
You mean [hacker rank](hackerrank.com) ...?
I assume you're not talking AngularJS' DI system :P but no sane person would. So is it possible to use Angular's DI in other projects? I guess we could sort of implement decent DI with Factory function for our Factory functions that takes a container object in it's constructor. Totally doable, but I guess then we've just built a DI framework.
Imagine you have webpage with 3 sections, TopBar, SideBar and MainPage. Everytime people click new menu on Side bar, the main page load the new layout. Things we did at 2002, is we need to reload *all html and all javascript* from the server again. Which have same TopBar, SideBar and new main page. Things we did now, is we need to load only new data and maybe new javascript/html (up to design) that need to be display in main page section. The difference between fully reload the whole page and partial load (only main page part) play a significant difference to user experience. And when we talk about SSR today, we still mean that SSR that you do not have to do full-page reload when you click anything. Really different from 2002 normal MVC workflow (Spring, Django, Ruby on Rails) which controller return full-page html with some pre-defined data.
True. And before them, they were solved (quite thoroughly) for desktop applications. And the data concepts go even further back, to the 60s-70s. JavaScript has been reinventing a LOT of wheels. It's not the first platform to do this and it won't be the last.
Downvoting because there is absolutely nothing unethical in using JavaScript to mining. Unethical thing is doing so without user's permission, which is in no way encouraged by the link.
On IOS you download a binary blob once from the store, install and run it. The web browser doesn't have that luxury. It has to download, initiate and still make content appear more or less instantly. It doesn't have much to do with this or that framework. React on IOS as in React-native doesn't need SSR.
Hi thanks for reaching out. I still didn't entirely like the image when the saturation got turned down. I actually created my own new yet similar image with code against a background color that is a "tint" of the big JS logo, which, using http://imagecolorpicker.com/en, I learned is #FFB500, which I then entered into http://www.color-hex.com/color/ffb500 to find the tints, and I chose #ffda7f to come up with the following image: https://i.imgur.com/l4a0anR.png I was going to create my own subreddit just to test out the entire theme with this image, but maybe you can make something work with the tints on that page? I really do think it should be a similar color to, but not exactly the same as the big JS logo, which as I mentioned, is something I learned in the excellent book "Design for Non-designers". If you think that "tint" is too light, maybe the next darkest one, #ffd266? Hope you don't mind I'm just trying to help. BTW I'm used the minified code from jQuery, which might be funny if someone noticed, because so many people disparage jQuery these days (but I'm actually building my own framework with jQuery *as the foundation* -- why throw out the baby with the bathwater).
It seems like the only people who invent and/or upvote this type of stuff are academics. People who dont have to answer to project managers. People who dont have to implement new features into an aging codebase... but, the people who *do* have to implement new features *and* must answer to project managers are ultimately the ones who suffer because eventually these things trickle down... all the way down to recruiters who eventually ask if you have experience with *dynamic transipilation* and if you dont.. well, goodbye resume.
Theres already THe Coding Den and the one from/r/programming 
It seems like the only people who invent and/or upvote this type of stuff are academics. People who dont have to answer to project managers. People who dont have to implement new features into an aging codebase... but, the people who do have to implement new features and must answer to project managers are ultimately the ones who suffer because eventually these things trickle down... all the way down to recruiters who eventually ask if you have experience with dynamic transpilation and if you dont.. well, goodbye resume.
It seems like the only people who invent and/or upvote this type of stuff are academics. People who dont have to answer to project managers. People who dont have to implement new features into an aging codebase... but, the people who *do* have to implement new features *and* must answer to project managers are ultimately the ones who suffer because eventually these things trickle down... all the way down to recruiters who eventually ask if you have experience with *dynamic transpilation* and if you dont.. well, goodbye resume.
[What yellow banner?](https://i.imgfly.me/fz3Kf.png "You can disable all custom subreddits CSS/styles in your /prefs")
Here it is two tints darker: https://i.imgur.com/cae2all.png
So I should turn that off for all subs, or constantly change back and forth? What a PITA
Yes. It has some nice problems
I don't even bother to read it as well.
I keep it off for all subs. Getting used to each sub having their own styles is PITA for me.
yeaah, is good to know and understand. Make life simple sometimes or can be a pain, like most patterns out there. But if you never heard this things, no problem at all, just keep coding and learning...
SSR isn't for the user, it's for SEO. So we quickly realized that we didn't need any dynamic content from the sever. We don't use SSR for areas that require a user logged in session. Everything else is behind a varnish cache.
&gt; It just doesn't happen in most companies. This is going to be all anecdotal here, as I doubt there is a stat to show, but in our organization we do exactly that. One codebase, runs on both the server and client. We don't use React, but vueJS and DoneJS. I would recommend checking out DoneJS if you want to see the most complete isomorphic framework I've seen. 
Applications have code to run and they also talk to remote services. Really not that different from single page applications. If apps are really decreasing in size notably when adding redux, then I would say it was written badly in the first place. There's nothing special about functional programming and the way it dispatches events that would lead to such a reduction.
Note: This is not what dynamic transpilation refers to in this case. The "dynamic" part is transpiling resources specific to a particular browser-version the first time they are requested (and caching for future requests by the same browser-version). It means you can just author your code according the standards and not have to transpile according the the lowest common denominator, penalising all browsers. The "hot" reload part is a completely orthogonal feature to this (i.e. if you deploy a new version of a component all clients will be updated, whatever degree of transpilation they need)
I'm not sure how reusable Angular's di system would be. I know that it relies on typescript meta data unless you want to mess with bare strings for denoting types. I assume it's pretty tied to angular since angular is also instantiating the components as well as the services you inject into components and each other. But it's open source so you can always take a peak for yourself.
Cool demos. Best of luck with the job hunt
Glad to help.
I suppose that, semantically, all of those are "server side rendered". But whatever that term used to mean in 2002, it doesn't mean the same as it does in 2017. At least not when its used in the context of frameworks that allow you to build "single page apps" like React, Vue, etc.
React: running the same code on the client to attach event handlers to the SSR'd content to make it interactive and/or upgrade it to an SPA experience, allowing static and dynamic parts of the app to be defined in the same components.
The code that mobile applications run is locally stored. The app boots up instantly, then perhaps fetches some backend stuff. &gt; And if we are talking about load and execution speed (I wasn't in my first post), doesn't react/redux make that worse from vanilla JS/HTML? Vanilla js is a meaningless term. If that means that you don't manage your state, then no, there can be nothing worse than that. 
&gt; There is a reason everyone for the last 20 years has been talling about small, isolated, reusable components - and I bet you there will be plenty of articles in a couple of years about splitting your huge monolithic redux codebase up. In my experience redux logic is pretty easy to split up and reuse. I've been migrating a legacy backbone app to redux primarily by moving whole "modules" (meaning actions/reducers/selectors grouped together for things like products, user, payment info, etc.) from an RN app into a third shared business logic codebase. Each app uses the shared code alongside any specific logic it needs. That's been far easier than I thought it would be. In fact, the big issue with the transition has consistently been tracking down implicit behavior in our MVC spaghetti code. Granted, you can write spaghetti code with any library, but in my experience the constraints redux imposes help keep inter-concern communication clear, explicit, and detached, which makes writing "small, isolated, reusable components" a hell of a lot easier.
iOS developers usually complain about how MVC does not really works for them and become Massive-view-controller. They come up with a lot of way to do things differently such as VIPER, MVVM, RxSwift and etc. Your statement about other platform does not have any problem is basically not true. At this point I wonder if you actually did any frontend development before? I have experienced in React, Angular (web) Swift, Objective-C (mobile), Silverlight and WPF (desktop). I would say development experienced from React is the most pleasurable one for me.
You could use a JS or JSON file for each environment that has these mappings, then have a build process that includes the correct file.
Codewars is great too
I would spend some time determining what your users’ needs are, and decide if you actually need a framework right now. 
r/LearnJavascript
As Vue.js fanboy I reccommend it. But seriously - this framework does not force you to use biuld step. You can just drop it to page like jQuery. Also there are multiple other frameworks that does that but it seems to have largest community. So if no build step I recommend it.
Check out hyperapp, it’s an incredibly lightweight framework based on Elm architecture. May not be enough depending on your needs tho. https://github.com/hyperapp/hyperapp
Why yes there is! But that really depends on what are you actually looking for. You can build user-friendly stuff with jQuery, you just need to know how to use it. Most of front-end frameworks are ment for: * dom manipulation (so you don't have to put html tags into strings and append them with jquery) * where your API is separeted from your fron-end * large team's * large projects * a lot of logic I don't think that front end framework is something you look for. Maybe something UI related? Semantic UI or UIkit maybe?
React is probably the simplest. [You don't specifically need build tools](https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html), but if that shocks you, pretty much everything is better of with them and if you want to learn JS, skipping tools is probably the worst you could do. You'll rub your eyes later on because virtually nothing will make sense, from tutorials to examples using code you can't execute to 3rd party controls you can't use. When you're over the big shock, javascript needs build tools and all, then you can learn React in a manner of minutes since it's basically javascript. That means no parserer, no extra syntax, no weird code in html.
Really interesting. I might add this to my projects as an optional ‘donate’ button.
Seems like it could be very useful for new JS developers who just want to get some dynamic HTML on a page. I did something [very similar](https://github.com/ericmcdaniel/backbone-component-renderer) for Backbone render functions.
You mean class methods? I'm a little confused by the use of arrow functions in the example, aren't class methods already bound to the class instance?
&gt; it looks to be impossible to hit the browser cache through a XHR call without making a network call. [It most certainly isn't](https://i.imgur.com/e1iPaLa.png) (from Google's homepage). You're doing something wrong with your research/testing. The browser request flow goes like this in every browser: 1. HTTP request is initiated (user types URL, user clicks link, JS, etc.) 2. Browser checks if the URL has been cached locally a. If it **has** been cached locally, browser checks if the cached version is stale (according to `max-age`, `Expires`, etc.) 1. If it is **stale**, browser issues a new network request for the same URL (using `If-Modified-Since`, `If-None-Match`, etc.) a. Server checks if the asset currently cached on the client is still valid 1. If the asset is **valid**, server replies with 304 not modified. 2. If the asset is **not valid**, server replies with the new version, a 2xx response, and appropriate cache headers a. Browser caches the asset locally according to the cache headers 2. If it is **not stale**, browser serves up the cached local asset with no network request b. If it **hasn't** been cached locally, browser issues a new network request for the URL 1. Server replies with the asset, a 2xx response, and appropriate cache headers 2. Browser caches the asset locally according to the cache headers The red requests in the screenshot above followed `2.b.1`, while the green followed `2.a.2`. Note the sub-15ms response times on the cached responses, which is virtually impossible over a WAN (in contrast, the uncached response takes 120ms exactly because it's a network request).
Just surfing the web must be a real PITA for you then
What is this line ? // create template function that produce HtmlTemplate "&lt;div&gt;Hello xxx &lt;/div&gt;" let hello = (param) =&gt; html`&lt;div&gt;Hello ${name}&lt;/div&gt;`; Is name expected to be within param ? There is some implied destructuration in there ? I'm uneasy around magic vars
For SEO you can just do prerendering. 
I think I already know your answer but what do you prefer? Phaser or the React, MobX combo?
When ['&lt;div&gt;',CONTENT,'&lt;/div&gt;'].join() is not enough ....
What IDE is he using in these courses?
[Aurelia](http://aurelia.io/) is designed to closely align with standards such as WebComponents and ES2017+. Writing Aurelia code is basically preparing for emerging standards and best practices.
How about just Twitter bootstrap?
That also works. Using Varnish allowed us to bypass the need to create a publishing step integrated with our backend so that when pricing or stock changes happened, there would only be a 5 minute delay. Works well.
Good grief, the very first example demonstrates JS injection, while the rest of the Readme focuses on performance. Certainly the fastest way to get owned.
How is this different than lit-html
Very similar indeed, however yalla offers better performance
How do you achieve that? Is it by not implementing your own parser?
That is called Template Literal https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals 
Awesome ! in the end, i believe yalla will be disappear. We want the browser to have native Templating Engine, since we dont have it right now (yet) yalla offers ES6 Templating Engine, best in performance and most simple API.
Looks like atom. These two, visual studio code and atom and pretty good editors in case you are still searching for one. 
JavaScript and HTML are refreshed with pages. Depending on what you are actually trying to do, you either want to store that date client side (locally or in a cookie) or server side. I don't know what sort of server you are using, but if you store it server side, you should be able to send it back to the client by injecting relevant data into the HTML page.
No i know what template literal are, i meant the source of the expression. The function accept "param" but the template has ${name} in it. Is Name expected to be in the param objects ?
'&lt;div&gt;',CONTENT,'&lt;/div&gt;' is similar like `&lt;div&gt;${content}&lt;/div&gt;`. That is template literal, but it doesn't do well if we want to do something like this var text=""; function updateText(event){ text = event.target.value; update(); } function update(){ document.body.innerHTML = `&lt;input type="text" onkeyup="updateText"&gt; } update(); ----- The input node will always be rebuild, and we will lost focus in whenever we typesomething. Not so efficient, hence if we use Template Literal we can do similary function update(){ render(html`&lt;input type="text" onkeyup="${e =&gt; updateText(e)}"&gt;`,document.body). } With this we will not rebuild input type everytime update function called, and we will not loose the focus on input, we will just update the delta. Sweeet :)
Thank ya
I'm looking for simpler way to build and reuse interactive page components (for example dropdown menu)
I think he is referring to that ‘name’ is not being passed as an arg into the function expression explicitly. Intuitively the signature should be ‘...params’.
I'm looking for a UI library that assists in drawing graph nodes and their relationships.
My bad, it was a typo. I just commit the fixes :) thanks for spotting it :)
Performance in yallajs is still in early stages, but looking at the technique used in other library definately theres plenty of room for performance improvement. 
ping /u/ellisgl why?
Per that [installation page in the React docs](https://reactjs.org/docs/installation.html), you can absolutely use React without a build system. [All you need is two script tags in an HTML file](https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html), and a third if you want to use the JSX syntax directly in your code. However, like all modern JS frameworks, React is commonly used with a build system that handles many aspects needed for proper deployment. For example, the [Create-React-App](https://github.com/facebookincubator/create-react-app) tool includes: - A compiler - A bundler/linker - An optimizing minifier - A linter - A development server with live reloading - A test runner All of those are isolated and scoped to that one project, and they are all build-time dependencies only. That way, you can use the latest Javascript syntax and organize your code however you want, but build an optimized JS bundle for deployment. So, there's a distinction between what's actually _required_ to use something like React, and how it's _commonly_ used.
&gt; While the raw/static benchmark is interesting, it does not belong here. I'm not the author of this benchmark, but showing the results for a static page gives us a baseline for performance that is very helpful for comparing all strategies for rendering and serving up HTML. It is also helpful to remove the cost of HTML rendering to see how much of the overhead comes from the server, network, etc. &gt; So, a realistic benchmark for rendering 100 rows of dynamic content should include the i/o needed to get the data, as well as only using non-cached templates that can render 200 or 1000 rows, too. I think you will find the RPS numbers do not differ by 10x, but more like 2-4x. Why include the time of i/o if the goal was to benchmark HTML rendering? If you have a server that is saturated with incoming requests then the CPU cost associated with HTML rendering can quickly become a bottleneck. FWIW, when we created benchmarks for [marko](https://markojs.com/) we also found that React was 10x slower than other HTML rendering solutions: https://github.com/marko-js/isomorphic-ui-benchmarks Based on my investigations into performance, the biggest reason that React suffers on the server is that rendering to HTML with React requires one pass to render the entire VDOM tree and then another pass is required to serialize the VDOM nodes to HTML and there is no way around that since the VDOM integral to React. In contrast, on the server, Marko renders directly to an HTML stream (no VDOM nodes are created) while Marko renders to a VDOM in the browser.
Then what's your point? People have been rendering html on the server in Node on Day 1.
Poll the API every so often. 
Calm down. You posted this same link before, then you deleted it. The HN link I linked was just for other people to get another source of comment.
The static benchmark is a control. It's how you can perceive render overhead. Not sure how I/O factors into this. You wouldn't even want to bench the filesystem I/O of each templating engine because you aren't incurring that in production.
Just a rough idea : Yallajs development is using ES6, we are not using typescript like lit-html. Hence our code can be optimized in terms of LoC, since our code is not strictly to follow "typescript" way. lit-html still struggling with iterator performance, lit need to refactor some of the fundamental such as how to walk the tree and cache them in iterator, but if lit need to go this way, it may break the api that they already announced to public. yalla, only have 3 api, html, htmlCollection and render. Yes we can do Async and Plug (directive) like lit. But the rest, we believe we dont need them. Such as Plug or Directive api, i dont think its needed (maybe yalla will drop it too). We already have custom element, we can leverage custom element to build more complex and sophisticated front end. Why introduce something similar ?? We can use custom element to listen when an element is connected or disconnected. Why we need to create the samething. To summary : yalla goal is to make webapp go back with plain vanillajs. No bloated framework, no Babel, no Transpiler. Just javascript and browser. Thats it 
Yes, it was my mistake :) thanks
I'm glad that you're working on Yalla and the simplicity goal makes sense. That being said, I'm not sure why Typescript would impact performance at all. Also are you using custom elements internally?
&gt; Other platforms don't seem to have architecture problems with keeping the view in sync with app state. Wow, yes they absolutely do. Any time you don't have unified state model, you have to reason about desyncs. In iOS any time you have two Core Data instances (one constructed by the app, one for syncing with network requests), you have to reconcile differences. Also, these ecosystem impose a framework on you which is a lot different than being in an ecosystem where you can choose your own. At which point you can look for ways to improve the model. You aren't going to land a pull request into Cocoa. But you use a tool that compiles into Cocoa for example (or webview). So there's plenty of "reinvention" in those ecosystems as well. You just have a limp understanding of the state of client development.
Yah, you right. Thanks
Dependency Injection is good to know for creating testable code, if a function doesn't employ DI it makes it more difficult to make a unit test for it.
Performance not in script computation but in terms of line of code (LoC). No, we don't have custom element. However yalla can play nicely with custom element. :)
Tired of manually traversing lots of repos (CLI guy :P), I built this quick shell script to do all the work for me! https://bitbucket.org/killerspaz/repo-status Nothing super fancy, but it works great for me - figured I'd share.
Ah ok, I can see how you would have a smaller bundle size.
Hmm.. Ok that makes sense. Since I'm sending a date range through the POST anyway, I'm setting the variables I need, server-side, anyway. So I can access them when defining my js vars by echoing the variables in an open/close PHP tag set. It feels grimey, but it may be what I have to do. I could have this in the PHP: if (isset($_POST['$startValue'] &amp;&amp; isset($_POST['$endValue']) { //Set vars after formatting to what Moment.js expects } else { //Set vars to my default range } And in the js: var start = &lt;?php echo $formattedStartVar; ?&gt;; var end = &lt;?php echo $formattedEndVar; ?&gt;; That look right? Will something explode?
Not necessarily. It depends on whether the `html` function correctly escapes the value when building the output. 
I don't want to assume too much about your code, but it seems to me that unless you are comfortable sending that date range to the server with every post that goes to it, it might make more sense to store it. If you are, then that should work, otherwise, could you make a small MySQL database to store it in or something like that?
I don't want to assume too much about your code, but it seems to me that unless you are comfortable sending that date range to the server with every post that goes to it, it might make more sense to store it. If you are, then that should work, otherwise, could you make a small MySQL database to store it in or something like that?
Thanks for the reply! &gt; You posted this same link before, then you deleted it. It wasn't me. I posted to /r/ruby and /r/frontend but not JS until this post. Here's what I see when viewing that page while logged in: https://www.dropbox.com/s/ab3upnf5t8fy4yc/Screenshot%202017-11-20%2010.42.28.png?dl=0 If I had posted it, then I wouldn't see [deleted] under username Message the mods if you want. &gt; The HN link I linked was just for other people to get another source of comment. Ahh. Thought it was related to the previous sentence in some way. This sentiment didn't come across. &gt; calm down I didn't hear a response from you, so I'm following up. How would you have followed up in a more "calm" manner? 
&gt;The rise of ES6 vanillajs webapp. Last time I checked, to use it, which I am actually always using, all I need is a notepad and a browser.
That would be the first step, next to achieve high score in benchmark is we need to ensure that we minimize node movement, avoid reflow, tackle focus lost and only updates the delta.
You don't need to know Dependency Injection just like you don't need need to know Monad -- Unless you do hardcore OOP, you don't need to know DI. Unless you hardcore FP, you don't need to know Monad. That said, if you want to be an experienced programmer, you probably should try out both. Also there are other types of IoC not mentioned * IoC Container (e.g. InversifyJS) * Service locator pattern 
I'm comfortable sending the range each post, as the only time there would ever be a post is when the date ranges matter, and they'd potentially be custom rather than any given range template, so I'd need to make sure I'm passing those values through the post. Thanks for your help. It got me in the right direction!
That's true, but without template engine it would be hell to build and maintain vanillajs webapp with ES6.
https://learn.jquery.com/plugins/basic-plugin-creation/
It's pretty easy to dynamically create documents though.
you're right, i suppose it depends on the size of the total template (in the case of this bench it's very small). if the template is huge and dynamic, it can become much more of a bottleneck than the db i/o. &gt; FWIW, when we created benchmarks for marko we also found that React was 10x slower than other HTML rendering solutions i'm familiar with all of this [1]. your benchmarks use React 15, which was indeed very very slow (as Vue still is today). React 16 got literally 10x faster [2]. /u/localvoid pretty much disproved [3] that vdom for SSR has to be slow (as you guys like to advertise). [1] https://github.com/leeoniya/domvm/tree/3.x-dev/demos/bench/ssr [2] https://github.com/leeoniya/domvm/commit/bdff6e7af158a97297ff850934a746ff36e45bb2 [3] https://medium.com/@localvoid/virtual-dom-ssr-performance-5c292d4961a0
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [leeoniya/domvm/.../**ssr** (3.x-dev → b15563c)](https://github.com/leeoniya/domvm/tree/b15563c894a3fcc4aa81eb9f71c21060c879bd65/demos/bench/ssr) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dq3j2d6.)^.
Just some remarks: * for quick-and-dirty code, storing the state of a recursive function in global or module-global variables is a bad idea. * always use `===`, never use `==` by principle. In your specific code, nothing will functionally change when you refactor, but it's probably a bad idea to fall back to the quirky behavior of `==` just for the sake of saving a single keystroke, and having to think all the time whether o whether not a `===` might be necessary each time you write an equality test. * `characters.length` and `characters[ i ]` are not reliable in JavaScript as they index Unicode code*units*, not code*points* (read Mathias Bynens on that one). The best way to quickly circumnavigate that problem is probably the new-ish `var d = Array.from( text )` idiom which gives you a list of strings of codepoints (characters). * are you sure you want to use a bitmask for the task at hand? Sure, if you know your input is only up to 7 characters, that'll work. Otherwise, it will break in interesting ways.
You are mistaken. DI is an architectural pattern. It is akin to "unidirectional flow" or "service-oriented architecture". You can design your app entirely without it. People who came from non-SOA OOP shops tend to use it because that's how they architected their apps. DI is responsible for wiring components together either manually or automatically depending on framework. In unidirectional flow, that responsibility is done manually in `app.jsx` or `root.jsx`. In SOA, it is done in service discovery. 
These performance metrics aren't trustworthy. You should submit a PR to https://github.com/krausest/js-framework-benchmark to see how performance stacks up against other frameworks.
I ran be coupled with my own mess than one that is created by a third party. It’s often easier to figure out and introduce a custom DI for organize’s needs instead of using a generic one you need to fight
I suggest the community should look to http://theworldsworstwebsiteever.com/ for inspiration what this forum should look like. 
I would recommend to see the story behind it :) https://codeburst.io/how-it-feels-to-learn-javascript-in-2018-6b2cf7abb6aa
Masking is a bullshit idea that breaks more things than it helps. Don't do it. *Validate* but don't block the user from inputting wrong things. Same goes for maximum field lengths. Validate maximum lengths but allow the user to paste more. With masking you interupt the normal user flow, violating the [principle of least surprise](https://de.wikipedia.org/wiki/Principle_of_Least_Surprise). You prevent the user from using copy and paste how they like etc. Don't mask.
I would love too, however it was to early to submit pull request to krausest git. We already have performance tuning in our pipeline. We are using the same fork from krausest, you ware most welcome to validate them. Once we are feel comfortable with the result definitely we will send pull request. :) 
Awesome! I should have checked your benchmark before posting :p
I've previously looked at `ivi` and https://medium.com/@localvoid/virtual-dom-ssr-performance-5c292d4961a0 and I have looked at the associated GitHub repo that was used to benchmark marko and I don't see any `.marko` files and `marko` is not even a dependency in the `package.json`. [Where's the marko code](https://github.com/ivijs/ssr-benchmark/tree/master/src/marko/color)? Maybe /u/localvoid forgot to push the code or maybe I am missing something obvious? While I am sure React 16 is faster and we should update the benchmarks, I feel that Inferno and Preact better demonstrate how fast VDOM rendering could be on the server, but in our benchmarks they were still significantly slower than Marko on the server. I expect that React 16 would be closer to Inferno and Preact. While I am sure `ivi` has some nice optimizations, it sounds like it might rely heavily on caching, `shouldComponentUpdate` and Redux (immutable data?). From [the post about blueprints](https://medium.com/@localvoid/improving-ssr-performance-in-virtual-dom-libraries-57232e2ead21): &gt; In practice, we will need to generate many blueprints for different route paths, so we can skip rendering for as much content as possible. Caching has limitations (invalidation and balancing memory usage) so I am not convinced that it can automatically be applied to everything and feel that it is something that the developer would need to opt into in specific areas. With that said, I really like that `ivi` is trying to innovate in the area of SSR and it's great that developers are sharing their findings. I'm glad all libraries are getting faster (and hopefully smaller).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ivijs/ssr-benchmark/.../**color** (master → 6367ec1)](https://github.com/ivijs/ssr-benchmark/tree/6367ec1aedcd1b86c0297bdcd1bc272d0eccf014/src/marko/color) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dq3kp3n.)^.
Soooo... React?
It looks similar, but we have different technique to achieve them : 1. React use virtual-dom, which increase script computation, and memory footprint that is why in the benchmark result, yalla wins over react in all points. 2. React use JSX which makes us depend on transpiler. If you could spend time to see our example on how ES6 singlepage app running in browser without babel or bloated framework. It will give you clear idea how it looks like. Just to make it clear, the comparison is not React vs YallaJS, it should be React vs ES6 (platform). Yalla is just a small library acting as a glue or i would say the missing part of ES6 single page app. https://codeburst.io/how-it-feels-to-learn-javascript-in-2018-6b2cf7abb6aa
I think the concern was more about security. For example given a template like `&lt;script type="application/json"&gt;${foo}&lt;/script&gt;` (which is something one might do in a SSR hydration scenario), and a template `&lt;html ${attrs}&gt;&lt;/html&gt;` (which one might do to support i18n), there's no good way to avoid injection of unmatched quotes in the latter without breaking the former, unless you have a parser that is aware of where the interpolation is happening. Also, you briefly talked in some other comments about optimizing for LoC vs runtime performance. As far as I'm aware, vdoms like hyperapp can go as low as 7kb unminified (vs 35kb for yalla). I think the perf gains from outlets look promising but I'm also curious if it can do well in tree reshaping scenarios (e.g. remove an element from a list), which is sorta what vdom is all about. I'd even say that is more important than creation perf, since that is an aspect for which SSR is becoming a popular solution. One other question I had was with regards to the mention of ES6 in the context of being a vanilla framework. Obviously template tags are a big part of the API, but for better or for worse, ES6 is still not fully viable if one needs to support, say, IE11. On the same vein, support for module syntax is even more spotty. How would you envision yalla being used in a real project?
Have you had a look at mxGraph[1]? Used to be a quality commercial library that the creators open sourced. https://www.jgraph.com 
Interesting
To achieve high performance in tree reshaping : For node deletion : is to utilize existing node (update the value) instead of getting the child node based on index, and call ChildNode.remove() directly instead parentNode.removeChild(childNode). For node creation : is to utilize the template and ensure to call cloneNode(true) instead of recreating node on every request. For node update &amp; reading: is to utilize outlet and the key, by using outlet we can exactly find the location of dynamic part, hence we are fully optimize in update. We are working hard to reduce the weight, we have plenty of room for optimization. I'm not sure if you called them parser, but yes we are aware where the interpolation is happening. That is why we treat the dynamic part differently for attribute, event, node, and style. Having said that you cant perform above injection in yallajs. For non ES6 browser , unfortunately we still depend on babel to transpile them to ES5. Please take a look on yallajs todomvc, which is compiled down to ES5. http://yallajs.io/todomvc.html Yes its compatible with IE 
This should be implemented in npm honestly (.prodIgnore or something)
One option a coworker and I discussed was potentially creating a dynamic container file which would return an object with references to the required container all of those views could import &amp; use. But I can't shake the feeling we're creating new systems to work around a deeper, potentially avoidable problem. export default { HeadContainer: window.is_manager ? ManagerHeadContainer : UserHeadContainer, EditableGuestsContainer: window.is_manager ? ManagerEditableGuestsContainer : UserEditableGuestsContainer, EditableDateContainer: window.is_manager? ManagerEditableDateContainer : UserEditableDateContainer, ItemsContainer: window.is_manager ? ManagerItemsContainer : UserItemsContainer, EditableItemContainer: window.is_manager ? ManagerEditableItemContainer : UserEditableItemContainer, EditablePriceContainer: window.is_manager ? ManagerEditablePriceContainer : UserEditablePriceContainer, TotalsContainer: window.is_manager ? ManagerTotalsContainer : UserTotalsContainer };
i ran the bench locally. still behind React, but not very far.
If I had to build this game again I'd go with React + MobX because I'm more comfortable with them and I can use CSS with them (which makes life a whole lot easier). If I was to build a game with lots of effects and movement, I'd probably go with Phaser, or even migrate to Unit or another engine. Unit has tools to manage assets, do map editing, compile and lots of other things to make your life easier. One thing to consider is the performance bottleneck that constant DOM updates can cause. The more elements in the screen updating at the same time, the harder it'll be to keep up 60 FPS.
D3 if you’re feeling confident or want lower level control or Chart.js if you want something more high level :)
You could look at Polymer and more generally https://www.webcomponenets.org. I've found it very easy to use. Polymer is nice because it's basically just a wrapper around the existing web components spec: https://www.w3.org/standards/techs/components#w3c_all 
You are correct; honestly, I had forgotten about `new Function()` because it is so uncommon. Of course, you can do the same in Python: &gt;&gt;&gt; function_type = type(lambda: None) &gt;&gt;&gt; function_type &lt;type 'function'&gt; &gt;&gt;&gt; function_type(foo.__code__, globals(), 'bar') &lt;function bar at 0x106d906e0&gt; (Stolen from https://stackoverflow.com/a/25292325/4379329) I avoided the class / method / generators because that was clearly not what the OP was asking.
&gt;Make a new API [request?] every so often. Alright so I could use`setTimeout` and check for new changes a couple times per day, right? Didn't think about that. The API updates values once or two times per day. Thanks!
&gt; none of the server-side languages you mentioned allow you to have a single toolchain and write in a single language for both frontend and backend. How is isomorphism in any way related to the topic at hand? If anything, it hampers performance because you have to optimize the same code for completely different environments. &gt; react is not MVC, it's MVVM MVC/MVVM/MVP are all particular cases of the same problem. A problem which is as old as UIs (ie. goes back to the 60s). &gt; 15-20 years ago the most advanced (and only) SPA was Gmail Are SPAs now some sort of standard against which all web apps are to be measured? Is it impossible or inconcievable or ill-advised to make a web app which is not an SPA? If your answer to any of these is 'yes', it's a rather sad thing.
It is If your library's `package.json` has a [`files`](https://docs.npmjs.com/files/package.json#files) field, only those files will be included. Alternatively, `.npmignore`will also ignore files But most module authors don't bother to do that. I wouldn't say it's really the module authors' fault either. Any system that relies on its participants to act responsibly is broken
I would use a cron job, or something different, with something that infrequent. Using setTimeout for something hours in the future doesn’t seem like the best way.
Done this. We opted for just removing redux from the shared components and having everything coming in at the top level when you import them. We even split them off from the main code base, so nobody could come along and unknowingly connect them up to something again. We toyed with some of the techniques you can use while testing connected components, like exporting them connected and unconnected, or some kind of mock store injections. But that all just felt absolutely filthy and unsafe. I'd be interested if anyone has found a better solution.
But this also removes it for Dev, no? TS typing files are only useful in development for example
I don't like the source code, it's all one big file with very tight spacing and hard to read. Basically no comments.
Thanks for checking out, we will fix this very soon. Please bear with us
I'm glad the first bar chart was updated to not be like the one in the linked article, the one in the article was kind of dumb to be honest. Good luck on the project though OP!
Thanks for the feed back, will fix it very soon. :)
Vue.js
Honestly, even tho the performance of react SSR is pretty awful (assuming you have almost any traffic at all, I fail to see where the "performance" gain is for the end-user when your API is down hard) - the worst part of React SSR is the additional complexity that comes with having your API respond with more than one content type. APIs that speak JSON and _only_ JSON are so easy to reason about. With React/HTML outputs from APIs you now have a world of complexity to deal with in terms of caching (Vary headers anyone?) and concurrency (Particularly in node, you dont want to be shipping MBs of content to people). Caching is the answer to SSR? What about if I just continuously bust the cache with query params? Another source of DoS / Complexity. Totally static SPAs and JSON-only APIs make for _such a simple_ experience, I personally could not care at all if the time-to-interactive takes an additional 25ms. At least I can serve 100,000x as many customers! I won't even get into the monster that typical React-SSR-style build systems get into... And then trying to implement a native client becomes a weird step-child, rather than "just another client".
Real programmers use a magnetized needle and a steady hand. 
https://unpkg.com/
If you're looking for something simple I would recommend Bootstrap. It has an easy to grasp grid system for laying out your page. It has many useful components like the drop down and the documentation for all of them is super easy to apply into your code. It natively uses Jquery to work these components but you can change that yourself if you wanted. Bootstrap is great for a quick and stylish front-end!
We've hit this in the past. What we ended up doing was splitting the component into two - the first is a non-connected element that may require certain props to function properly the second is a connected component that wraps the first and provides the required props via `mapStateToProps`. We'll create one of these for each different part of the store as needed.
The Alabama Shakes image is not being displayed in the artist view.
I'm not sure I understand what makes your approach different. We too have dumb (non-connected elements) components &amp; smart components (connected). Do you keep them separated so that your non-connected elements are not allowed to import your connected components?
This is complete nonsense. *Broken* masking is a bullshit, and it's easy to break or forget somthing, but plenty of sites do it properly. The same applies to almost every single progressive UI idea.
Masking is broken input. &gt; do it properly. Define properly, define the advantage.
I still don't get what you're talking about, as long as you're not transpiling features that are above your tsconfig's target, typescript won't generate extra code. Typescript doesn't add runtime checks, it's all statically analyzed and verified, then it strips out all the typing in the bundle. Typescript shouldn't affect the LoC in the bundle. 
Bootstrap and Twitter bootstrap is same thing?
&gt; Masking is broken input. No, it's not. Phone numbers should be masked. Social Security numbers, credit card numbers, pretty much anything that has a defined format in which you *always* see it. The advantage of that should be clear. You see: 4111 1111 1111 1111 vs 4111111111111111 &gt; Define properly don't break user input. Allow backspace, pasting, editing mid-input, number formatting in different locales, etc. There's a long list of things to consider here but my point is that a *proper* mask is useful.
Yes it was made by Twitter. Bootstrap 4 is the newest version.
 &gt; No, it's not. Phone numbers should be masked. Says who? and why? &gt; Social Security numbers, credit card numbers, pretty much anything that has a defined format in which you always see it. You don't muck around with user input, you validate and then maybe normalize once the user leaves the input field. No need to break the normal input. 
Because it's good UI. If you want to have a discussion stick to the credit card example as it's the clearest case. Other cases are more arguable. 16 numbers are easier to visually validate when they're space-separated than when they're a long string of numbers. &gt; No need to break the normal input. I'm not suggesting breaking the input at all. That's not what masking is.
Apologies, I think I misunderstood your architecture. With my approach you still have the same problem -- the nested containers still need a way to choose which of the connected components to pull in. This is really dirty and probably wouldn't memoize properly but you could add a prop as something like `storeBase` and prepend all of your store queries with this. If the store looks identical in both areas it should continue to work.
So... It's not vanilla js, but a template engine. Misleading title.
 var input = 'abc'; var bitmask = 0; var characters = input.split(''); var running = characters.map(character =&gt; [character]); function permutations() { for(var i=0; i&lt;characters.length - 1; i++) { running = running .map(permutation =&gt; characters .map(nextCharacter =&gt; permutation.includes(nextCharacter) ? null : permutation.concat(nextCharacter)) .filter(charArray =&gt; !!charArray) ).reduce((arr1, arr2) =&gt; arr1.concat(arr2), []) } var result = running.map(permutation =&gt; permutation.join('')).join(' ') console.log(result) }; permutations();
Why don't you implement a credit card and a decimal number field and then we go and see how perfect that is and how many obscure browsers and screen readers are fucked up by it?
&gt; and then we go and see how perfect that is and how many obscure browsers and screen readers are fucked up by it? You're making my exact point -- *BROKEN* masking sucks. You're arguing against the entire concept.
How is React vs ES6 a comparison. React and ES6 isn't an either or thing.
SmartyJS.
I am arguing against the entire concept because user input is a complex issue and all masking solutions tend to be broken one way or the other. Moreover the advantage of masking is shaky at best and can easily be replaced by better mechanisms. 
&gt; all masking solutions tend to be broken one way or the other. No, they're not. Plenty of payment providers mask credit cards properly. TurboTax masks all sorts of input properly. Leave the browser and almost every payment app masks properly. Most of the open source solutions suck, I'll give you that. &gt; Moreover the advantage of masking is shaky at best and can easily be replaced by better mechanisms. You're just being flippant if you claim to not see the value in spacing credit card numbers.
&gt; You're just being flippant if you don't see the value in spacing credit card numbers. As I said: formatting is not the same as masking. Do it as you leave the field. If you absolutely need live-as-you-type display, mirror the input to a static text field. Don't muck around with selections and cursor positions, and field undo and screen readers and screen update notifications for blind people etc etc if you can avoid it.
They are, but binding a function in JSX isn't, so it's about hooking those two together.
&gt; Don't muck around with selections and cursor positions, and field undo and screen readers and screen update notifications for blind people etc etc if you can avoid it. I repeat: *BROKEN* masking sucks. Every single one of these is an example of *BROKEN* masking. &gt; Do it as you leave the field Why? Seriously stop with the "it's hard to do properly" argument. Assume it's done properly. What possible advantage is there to: 411111111| vs 4111 1111 1| The 2nd one allows you to actually see separations the same way they are on your card and validate *as you type*. Requiring the user to leave the field means people have to look at a jumble of numbers.
Just assuming it is perfect on a unknown number of devices and technologies does not seem like a good strategy. 
Okay, fine. Your only argument is "it's hard to do properly" and you won't even discuss the rest. Bye.
&gt; At this point I wonder if you actually did any frontend development before? Is there any need to be so personally insulting? I wasn't insulting OP, just a framework. Don't get your knickers in a twist, love. Massive view controller is a bad problem, and I agree that MVVM and Rx help. However, I don't think that the reason for these changes was primarily a problem with syncing state. That's what I'm saying - this whole changing everything about development to solve a problem that isn't really a problem in other platforms.
This library: I paste "1.1.2020" into date, BROKEN. I type 1.1.2020 into the field without looking: BROKEN. edit: Usability is not making the user jump through hoops.
For the 5th time or something: BROKEN MASKING SUCKS I don't care about this library!!! You're arguing against the entire concept!!! PayPal does it right. Google does it right. Square does it right. Turbotax does it right.
You are inventing imaginary magically cross-compatible code.
LOL, so let's get this straight: - If masking can be done properly you don't have a problem with it - You continue to insist that it can't be done properly - You ignore examples where it is done properly ... yeah. I'm done with this conversation.
Hi, there's a chart in the story [This one](https://cdn-images-1.medium.com/max/1412/1*uKNDIzPRGf_u82IaB6J6Jw.png) which uses a dubious scale to make the difference appear huge. If you use a scale starting at 0 the difference appears [much smaller](https://imgur.com/a/SjCOU) When you create a chart, you need to draw it in your head without the numbers on it and see if it still represents the relationship between the values. In this case it would appear that React was 50 times slow than yalla which is clearly not the case. It's a statistics thing which we use to assess how honest a report is. I'm sure you're not trying to mislead people, but it's worth fixing :)
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/1JNgLop.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dq3xq2r) 
Frankly, I'm not very impressed by Core Data either. The running state of an object is often different than the stored state (and remote state), and the syncing and threading problems that it causes can be a serious pain in the arse. It also prevents people from [separating layers](https://en.wikipedia.org/wiki/Multitier_architecture) inside their app - remote, business logic and db. It's a bad wrapper around a SQLite DB. &gt;You just have a limp understanding of the state of client development. Come on. Does the JS community have to be so mean? How old are you?
&gt; If masking can be done properly you don't have a problem with it I still wonder if the meager advantages are worth all the complications, man power and trouble. As I said: Go and implement a credit card number and a decimal input (let's say grouped with 3 fractional digits) and we'll see in how many ways it is broken. &gt; You ignore examples where it is done properly You haven't provided on-topic examples that work. Javascript, no-stupid-ass nodejs binding please.
&gt; no-stupid ass-nodejs *** ^(Bleep-bloop, I'm a bot. This comment was inspired by )^[xkcd#37](https://xkcd.com/37)
&gt; How is isomorphism in any way related to the topic at hand? the topic at hand is your assertion that we're re-solving already solved problems. isomorphism solves an unsolved problem: 1 language everywhere - this is the context in which i brought it up. &gt; MVC/MVVM/MVP are all particular cases of the same problem. i want to make sure we're both coming from a place of understanding exactly what virtual-dom libs provide. &gt; Are SPAs now some sort of standard against which all web apps are to be measured? Is it impossible or inconcievable or ill-advised to make a web app which is not an SPA? If your answer to any of these is 'yes', it's a rather sad thing. there are certain classes of apps where, yes, avoiding AJAX and reloading the page on every single change is not acceptable. just like you dont technically need Javascript for anything, or anything more than table layouts. there's nothing wrong with not making an SPA. but if you've decided to make an SPA, then using the same language/framework on both front and back is often much more valuable than optimal use of CPU/mem resources. there's basically nothing that runs on general-purpose hardware that operates at peak efficiency, save maybe ASICs.
&gt; and we'll see in how many ways it is broken. Again, BROKEN MASKING IS NOT THE DISCUSSION. Why can't you get past that?!?!?!?!?!?!?!! It'd take me like 3 months to make one that works everywhere in every use case. I don't have time to do that. Most people don't have time to do that. I FULLY ACKNOWLEDGE THAT. Turbotax, for instance, apparently did, kudos to them! &gt; You haven't provided on-topic examples that work TURBOTAX, PAYPAL, GOOGLE, SQUARE My god. &gt; no-stupid-ass nodejs binding please .... .... .... .... .... node is server side. You have no idea what you're talking about, this is pointless.
I agree with you, this is the advantage of react/redux. I just wish a different standard had taken its place :-) Having worked on the backend too and seen the craze for splitting monolithic codebases into "microservices", it does make me smile seeing the frontend going the opposite way.
Popper.js provide different distributed format, my guess is that you don't load the right file for your build process. If you target ES5 you should include dist/umd/popper.js
No mods need. My initial thought was "Why would you post it, delete and re-post it?" I've never had some really request for a reply from me. Also (sorry for the excuse) was having to deal with some work related stuff.
Pull out the function and call it separately. function putQuotes() { $("#textslide").html(quotes[i]); if (i == quotes.length) i=0; else i++; } setInterval(putQuotes, 3500); putQuotes();
Research Regular Expressions
I've replaced everything beginning at "setInterval" with your code, but nothing changes. What do you mean by "pull out the function"? 
https://webdesign.tutsplus.com/tutorials/html5-form-validation-with-the-pattern-attribute--cms-25145
React isn't going to help him create a friendly user interface. It does not concern itself with design.
Got it, thanks for explaining
HyperHTML
We usually start by normalizing state into collections and keyed lists. Then distribute concerns among components that deal with a clear task. I dislike passing state down, which sometimes can get hairy and creates implicit dependencies that are harder to refactor. Each view can listen to its own slice of state and change if necessary, thereby it can later be ripped out, placed here, placed there, without interrupting the application at all. @connect((state, key) =&gt; ({ guest: state.guests[props.key] }) export default class Guest extends React.PureComponent { render() { return &lt;li&gt;{this.props.guest.name}&lt;/li&gt; } } @connect(state =&gt; ({ guests: state.guestIds }) export default class Guests extends React.PureComponent { render() { return ( &lt;ul&gt; {this.props.guests.map(key =&gt; &lt;Guest key={key} /&gt;)} &lt;/ul&gt; ) } } Some other components should be kept pure and wrapped into store-connects on demand. Those that can be re-used in varying contexts.
Try reading books on js. I got this book called Secretes of the JavaScript Ninja that is really good. The ebook is free online. 
I know this feeling, I used to build websites in PHP with some JS to ease UX. Now I work on kinda SPA and learning front-end frameworks with the appropriate tooling is incredibely time-consuming. If you don't plan to go the SPA way, don't bother with frameworks. Especially if you do server-side rendering and only need to handle few user interaction. Stick to vanilla js. At some point if you need some special feature add a lib that do this job but with the state of javascript and browser support the only thing lacking is a templating engine wich can be easily fixed by a third-party lib.
Check out this example: https://jsfiddle.net/t8jyfszs/1/ You're passing an anonymous function to setInterval. By 'pull out the function' I mean to say, that you should give that function a name so that you can still use it in setInterval, but at the same time, call it independently of the interval too
thanks, but i need to do it with function by Regular Expressions, but i did not succeed yet unfortunately. 
Funny how it flew over your head.
Why? Reacts components eco system has more design related content than any other. There are dozens of UI libs to choose from, like [antd](https://ant.design/docs/react/getting-started), [semantic](https://react.semantic-ui.com/), [bootstrap](https://react-bootstrap.github.io/), [material](http://www.material-ui.com/#/), etc. Not to mention thousands of individual components for every UI concern under the sun. They're easier to deal with than their css/jquery counterparts, also smaller because you only fetch components you need. Creating self-made components is fine as well, given how easy it is to create re-usable components.
I've read Eloquent JS, You Don't Know JS, and Head First JavaScript. It's not a matter of if I can understand it. I can't. I'm wondering if it's possible to advance without that understanding.
Yes I notice I will fix it
Play in a js fiddle or empty js file until you understand it. No it’s not ok to not understand it, it’s everywhere. Even a click event usually. That explains it best. $(‘.title’).click(function(e) { // runs later // ‘this’ refers to something different than outside of this function scope // variables declared here may behave differently outside of here // variables declared outside of here may behave differently inside here }); Those are the things you need to understand about closures and one of the most common occurrences of them. Think of it like this— a closure closes over its environment. And things behave differently inside. It’s ok to debug and do console logs to see what’s going on when you are writing code, don’t let it be a mystery. Lastly, it doesn’t have to be anonymous function. 
I don't think you get it, I've been doing this for probably 50 hours over the last couple months. Take this for example, from You Don't Know JS for (var i=1; i&lt;=5; i++) { setTimeout( function timer() { console.log(i); }, i*1000); } This results in the printing of 6, 5 times. I understand where 6 comes from, I understand that the scope of timer() isn't closing over i, so it prints the 6. What I don't understand is what happens if I change a few things here, and how it doesn't have the same outcome. for (var i=1; i&lt;=5; i++) { foo( function timer() { console.log(i); }); } function foo(action) { action(); } This works just fine, it prints the 1,2,3,4,5, but it's not coded any differently than the example with setTimeout. I do not understand at all why the top one doesn't work and the bottom one does, because they're the same thing!
Best answer IMO. The browser will take care of everything. Works in IE10+ and all other major browsers.
Note though that Bootstrap is a CSS framework , not JS. It does come with a couple of jQuery plugins, but IMHO these are the least useful parts... maybe worth a shot if you have absolutely no time though.
It's already been pointed out that npm does support this. But it's also somewhat niche that you actually care about these extra files. In this case, they want to keep their Lambda slug as small as possible.
[removed]
Well no, they aren't the same thing - setTimeout specifically runs after the amount of ms of the second argument, and doesn't control the scope of i in the callback, so the loop executes before the callback executes, then i has a value of 6 every time. In the second example, it doesn't control the scope of the variable, but it happens synchronously, so the value of i can't advance until foo() resolves it's action.
&gt; It does not concern itself with design. If all he needs is design, and everything else is working fine for him why inject React? None of those "frameworks" you listed has anything to do with React itself. 
Not every web application needs to support obscure browsers and screen readers. We use (limited) input masking at my job for specific types of inputs (numeric only for example, the default number input is terrible, or inputs that must be a specific length). We test thoroughly for a reasonable range of browsers and after working out the kinks we never had any problems with simple masking. I'm not saying that it couldn't break some obscure deprecated version of Opera Mini or IE7, but not everybody supports those browsers, and not everybody needs to.
Because he literally asked for framework suggestions. Other than that it's never "just design." The interface eventually has to do something. And that is where it usually gets complex without a proper components model and a way to react on changes and state. No benefit at all from loading up a gigantic pile of bootstrap, 1% of which is actually used, then a jquery monolith on top of it, then slinging state into dom nodes and class names.
Check out [yarn autoclean](https://yarnpkg.com/en/docs/cli/autoclean)!
The 2nd snippet just works because there's no timeout but it logs `i` right away -- as far as closures are concerned, there's no difference indeed. Just try changing `action()` to `setTimeout(action)` and you'll see that it doesn't yield the desired result any more either.
https://cdnjs.com/ They have a nifty importer: https://github.com/cdnjs/cdnjs-importer 
[](https://i.imgur.com/NlHr81y.gif)
...There are literally three comments. The first is the license (that isn't even at the very top of the file???) The second is: /** * Deep clone node is broken in IE, following for the fix */ And the third: /* Function to take the path of a node up in documentFragment */
Tweak the first example a bit. Instead of calling `setTimeout()`, just push the function onto an array. After the loop, you'll have an array with five functions. Then loop over each of the functions, invoking them one-by-one. In this case, they will all print out 6, just as with `setTimeout`, but the flow is easier to understand. This is because `i` has iterated to 6, and that's the current value for each function _when you invoke it_ from the array. In your second case, you're executing the function while `i` currently has each loop value. In both cases, you're referring to the actual loop variable (through closure) rather than the variable _value_, which is what catches most people. Really, closure is just capturing _references_ (not values) of variables at each function runtime scope. That's the other other thing that usually causes confusion. Most other high-level languages treat scope as a lexical construct (that is, you can figure it out while reading the code), while JavaScript treats scope as a runtime construct (which is why `this` is so slippery, and why you have to reason about the _runtime_ behavior to understand scope).
Maybe you dont understand it now but as you grow and progress as a developer maybe one day it will click in the future so dont stress about it. 
Stop screwing with scroll, you bastards. 
1. React's use of the virtual-dom is intentionally for increased performance. 2. React doesn't require JSX.
Is there a point where that approach has proven difficult? Like a dynamic collection where each item can be an editable-inline form?
You're failing to see what he is asking for. &gt; i need to create user-friendly interface Nothing about React will help him in this regard. Is it a nice framework? Sure. I love it. But it isn't going to help him create a user-friendly interface. You can create a very user unfriendly interface in React very easily. For what he asked he needs a CSS framework like bootstrap, material, foundation, etc.
Answer: no. Learn closures. If you have programmed for only 50 hrs of jscript and you cant do closures than watch youtube videos. Take a udemy course. And watch more. After you hear a dozen or so ways of it being explained.. and you open up... it will make sense. 
That's not necessarily true. Even if I/O latency is high, it can certainly matter if rendering has a 10x impact on throughput, because the two can't be parallelized.
Not so much, no. We use inline editables as well somewhere. Each item is linked via connect, gets its id by prop, like so: import ContentEditable from 'react-edit-inplace' @connect((state, props) =&gt; ({ plugin: state.plugins[props.id] }), pluginActions) export default class Plugin extends PureComponent { setName = ({ name }) =&gt; this.props.setName(this.props.id, name) render() { return ( ... &lt;ContentEditable text={this.props.plugin.name} change={this.handleChange} paramName="name" stopPropagation /&gt; The component has lots of other elements, each linked to its respective state as well. Everything's displayed in a list later on by a higher order component that groups and filters them.
Ah cool, sounds like a good approach. What would you do if you wanted to use that Plugin component against a different store with a different plugins location in the store and fire different actions? 
I think this is turning a little awkward now, no offence. Read the topic description again. And if he meant something else, it's all fine, it won't hurt.
50 hours on closures, probably 150 extra on javascript itself, that's why I'm worried I'm never going to get this.
Well you could. Sounds like an unusual thing to do but `connect` is implicit. The `&lt;Provider store={...} /&gt;` HOC serves a store by context, `connect` merely reads and subscribes there. Use the same component in another provider and it'll reflect state there. You might want to keep components mostly pure. Props in, view out. If it's too versatile, like varying actions and so on, maybe better split it into pure functions and re-use them in connected HOC's that fulfil specific demands. Why do you want more than one store anyway?
The second example isn't the same as others have said - it hides the same bug because it runs immediately. If you were to change the first to `setTimeout(function () {}, 0)` you would see it "works" This specific example is more about asynchronous programming than it is about closures. Closures are just functions creating a new scope - each scope has access to all the variables in parent ("enclosing") scopes. On the note of async programming - you have to realize that `i` here changes over time. By the time the `setTimeout` callback fires, the loop has already iterated and `i` is set to 6. If you wanted to fix that, you need to create another scope and pass `i` into it.... Something like this: for (var i=1; i&lt;=5; i++) { function newScope (z) { setTimeout(function () { console.log(z, i)} }, z * 1000 ) } newScope(i) } Outputs: 1, 6 2, 6 3, 6 4, 6 5, 6 Here the variable `z` is created as a copy of `i` with each iteration of the for-loop. `z` doesn't change, so when you log it - it shows the copy, not the value of `i` which by the time it runs is set to 6.... both are logged to show the difference.
How to tank FPS and ruin web for mobile 
&gt; virtual-dom increases performance Over the traditional jQuery style querying of the don't, yes. Newer techniques than vdom (see: lit-html) can improve even more on per-node updates to the DOM. &gt; React doesn't require jsx You're correct... with a technicality. In the real world, you won't see applications being written in React without jsx to accompany it. No company in their right mind would put themselves through that.
&gt; Browser checks if the URL has been cached locally &gt; If it has been cached locally, browser checks if the cached version is stale (according to max-age, Expires, etc.) &gt; If it is stale, browser issues a new network request for the same URL (using If-Modified-Since, If-None-Match, etc.) ^^^^ Here it is. There's a network request happening, even if the server says the data isn't stale. In stale-cache, we just check if there's data, display it (without any network hickups), and then ask if its stale, there's no network request. Why else would there be an (unimplemented) cache-control directive called only-if-cached?
Even using something like react-redux's connect() to inject state, because of react's tree like structure, your components are always going to be tied to all the components deeper down the tree If you want to a uncouple this, and reduce the component's responsibility, you can use this.props.children, or render props, to delegate that responsibility back to the parent/caller. Using this approach, you should be able to compose your containers within a single parent container component. When you wish to reuse your components for a different use case, they should hopefully be decoupled enough to compose them in a different arrangement.
Right, the Provider provides the store context which is simple enough but if you did have separate stores and separate actions you would need to make things more general as you said. &amp;nbsp; The reason we have more than one store is because we have more than one app. We provide a public users app and a managers app because our clients have clients. Until now they've been decidedly separate and now we're trying to share some meatier components between the two apps and found ourselves in some trouble when we realized how many deeply nested views are importing store container-connected components. &amp;nbsp; I'm trying to find out what others like yourself are doing to avoid running into that problem &amp; what specifically we did to wind up here.
whooooosh
Using SSR doesn't require a change to the data API layer at all... It kind of sounds like you don't have a complete picture of how SSR works. As far as typical SSR builds being monsters... totally agree. Next.js does the best job I've found to simplify it, otherwise, screw SSR and just do a prerender.
'the rise' to ~100 github stars lol
Just go with vue. Very easy to learn. Tutorials over at vuecasts.com
We have a very similar constraint. We deploy a lib based on redux due to cross platform concerns. Customers can hook into its store and reflect data. Some customers do use redux already and are now confronted with two stores, which could be bad. So we just expose our reducers. Customer can link them into their own store at the creating stage, then we allow them to pass their store into our lib: this.store = options.store || createStore(reducer) The redux store also has a function called `replaceReducer`, where one could theoretically combine and extend reducers. 
react or vue :D angular sucks :p 
Remember what I said before: &gt; make your JSON API respond with a far-future Expires header (effectively forcing the browser to cache the response "forever"). When you do this, your browser will never determine the asset to be stale, and never get to that point (*note: you can also use `cache-control: max-age` to accomplish the same thing*).
The web journal site looks pretty cool. Do you know what publication framework are they using?
I'm quite aware of how SSR works, but I have yet to see SSR happen out-of-bound of the normal API process. Not used Next.js - rather I tend to inherit older Node.js codebases where the line between client and server has become incredibly blurred. I wouldn't have any issue with SSR if it was done _outside the API codebase_ :)
I'm pretty sure the point of this framework is to improve those things.
It's just a function with some data. Imagine you have a function Add, which takes two parameters A, B and returns A+B. Now a closure could be a wrapper around add which only takes one parameter, C, and calls add(5,C) You have just made a closure around the add function and the data 5. A function and some data, that's all it is.
I am pretty sure that it is about syncing state between model and view. I mean, the whole point of Rx in Swift is to make the model become observable instead of object, and then make view automatically react to those observable as it changes. MVVM is to make another model call "ViewModel" which easier to sync with view (instead of using business model which relationship between view may be more complicated and not in 1-1 manner). For WPF (desktop development), Microsoft comes up with data binding framework, which again to help sync between C# object and WPF view. I agree that there is no point of me become too personal. But you are not insulting just a framework here, in my view, you just claim that main problem of frontend development and frontend architecture does not really exist. If you claim that Vue, Rx, VIPER or Microsoft Data-Binding libraries solve this problem of syncing between model and view better than React and make frontend development become easier to reason about, then that would be insult to the framework. But you claim that React solve problem that does not really exist, which I get on my nerve because as my experienced on various frontend platform tell otherwise. To me, this sound like insult to frontend architect. 
&gt; scrollytelling Stop
Gotcha. Yeah, normally (ideally? maybe not normally) it is done separately from the data API. I've never had to touch the data layer to get SSR working. Usually, for me, it's just a nightmare of failed babel configurations, giving up, waiting a few weeks for new versions of babel plugins, give up, decide to refactor the entire app, give up on that, and repeat that cycle until it works (either from new babel plugins or just by chance).
It seems like you're getting hung up on Javascript's [event loop](https://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/).
Or implement `reduce` and use it to implement `map`, `filter`, `some`, and `every`.
&gt;Using IntersectionObserver abstracts element-in-view detection and removes the need to monitor scroll events, which contribute towards a sluggish experience.
Eh, the article says that this is a desktop implementation. He links another article to see for responsive mobile scrollytelling. https://pudding.cool/process/responsive-scrollytelling/
That depends on what your definition of "do well" is. You certainly can't be an expert in JavaScript without understanding closures. But you don't need to understand closures in order to write JavaScript, even professionally, and 150 hours of learning is nothing in the grand scheme of a career in coding. Not even a month of work. The longer your career in JavaScript , the bigger and more complex your applications, the more important understanding closures will be, and the more closure-related bugs you'll run into. One day, when you've hit the same bug where for some reason 'this' points to 'window' instead of what you expect for the dozenth time, you'll gain a little insight into what closures are, but mostly they'll be an annoyance and you may not even realize you're dealing with a "closure bug" at all. If all you're doing is adding jQuery behaviors to webpages, maybe learning to save a reference to `this` outside of an inline function is all of the closure knowledge you "need". If not, another day, maybe a few months later, when you're trying to figure out why all of the things in your loop are coming out with the same value -- the last one -- and change it to a mapping function to fix the problem you'll gain a little more insight, and you'll begin building a mental library of patterns for dealing with closures even if you don't quite understand why they work. If you're doing a little bit of data manipulation, or building small apps with short lifespans in Angular or React, maybe your closure journey ends here. But maybe years later, when you're defining a higher-order function and you carefully define a counter variable outside of the returned function, and then bind the function you're wrapping to the object you're calling from, you'll achieve enlightenment. You'll see that the common thread to all the patterns in that mental library is closures. You won't be able to pinpoint the moment when you understood what a closure was, but you'll know that it was a long time ago. You'll reread the materials that are giving you such a hard time now, and some of them will be embarrassingly obvious. Some of them will teach you names for things you've been doing intuitively for as long as you can remember and you'll eagerly reread the entire book leveling up additional skills along the way with your newfound understanding. In the meantime, just keep programming. The bugs in your applications will teach you what you need to know about closures as your skill in JavaScript grows. If you want to try to nudge yourself along, reread the 'Functional Programming' chapter in Eloquent JS, and try reading "Functional JavaScript " by Michael Fogus if you haven't. Both books have sections on closures, but it seems like for you learning directly about closures on an intellectual level is not working. Functional Programming is a "next-level" programming skill and it may not be easy to learn, but understanding closures is necessary to understanding functional programming. Read and then try to replicate the examples from memory. If they don't work try to fix them before looking back at the books. If yours don't look like the examples once you've got it working, then try to understand why theirs works too, and why it might be better than yours. 
What is happening in your first example is not an effect of closures, it's more about of how the JS event loop works. setTimeout basically says 'call this function in i * 1000 milliseconds', and *not* 'wait 1000 milliseconds and then call this function'. So the function is essentially 'queued up', and the loop continues. By the time the first 1000 milliseconds has passed, the loop has already executed 5 times, so `i` is already 6. 
 Without only-if-cached working the knobs and levers to make what I want are not there. Lets see if I can make something close: how it works now: response = staleCache({url}) // nothing or old data in local storage display(response) response = response.fresh() // network call display(response) // update display and localstorage with browser cache and current cache control // nothing in cache? makes network request ( we cant control that ) // or something in cache with max-age infinity? response = staleCache({url}) display(response) // at this point something always in cache now with max-age infinity // need to force fresh, use 'no-cache' in request, // then response has max age infinity response = response.fresh() // network call display(response) // update display and localstorage If there is nothing in cache, the above will make two network requests. As far as I know, there's no way to ask the cache if the data in the cache with a far-off expiration is actually just delivered. And there's the weird behavior of no-cache which makes me think it doesn't force fresh but forces a revalidation of of existing data (which we happen to give a max age infinity ) https://www.mnot.net/blog/2017/03/16/browser-caching &gt; no-cache means something slightly different than you might think; it allows use of the cache, but forces the request to go to the origin server to validate any stored response. All tested browser caches support it. If only-if-cached was available it would work perfectly for me and solve all my problems, but it seems to be just a concept in some spec writers mind. 
I'm all for constructive criticism, but your post reads like a fifth grader who discovered the internet. Just because you read a book on design and found it interesting, it doesn't make you a designer. The yellow isn't bad. It's actually a nice shade of darkened yellow, as it should be considering the rest of the website is mainly white or light greys. I know it comes from the Js's logo, but it works nicely. The banner gets a nice contrast from the brown bar underneath, providing a clear separation from the rest of the content. There's also the fact that reddit is meant to be scrolled. You're not reading that much content close to the header to justify any changes, as you'll be scrolling within the first few seconds of opening a page on any sub. Then there's the code in the background. It's barely there, it's more of a pattern to break the huge yellow rectangle - if it wasn't there then I'd support your argument of the yellow being overwhelming. It's not supposed to be readable, or else people instinctively will try to read it ( and this is the same reason why "Lorem Ipsum" is used to mock text - Write any readable language there and people will, without a doubt, read it ), thus wasting their time. _If_ someone really wants to know what's in there, then it's just readable enough for that, but as it sits, it serves it's purpose perfectly - being a subtle pattern, some visual "noise", just interesting enough to soften the yellow rectangle and make it more "digestible". Improving that code's readability is completely wrong. &amp;nbsp; So please, next time you read a book on any subject, use that knowledge to start a discussion, to pursue more information, or to try to solve a real problem. Try to figure out where the concepts you learned could be applied and remember that just because you learnt a couple of thing, your opinions are just that and don't hold any more value.
&gt; my only dependency in my JS projects is user not trying to open my page in a goddamn IE6 Heh. I wish I could outright eliminate IE altogether. But I am aiming my advice to this fellow as someone who I suspect is wanting to be **employed** as a Junior Developer. I am a developer, and my primary non-browser language is C#. But I do not use ANY server controls. I am strictly pure HTML/CSS/Javascript, and C# is used only for server-side work, and only via ajax calls to Generic Handlers. And if I could get the time to do it, I would get rid of that and replace it with Node. But I'm getting conflicting feedback on the viability of Node. But if I could squeeze in a Node project into my workload, I could eliminate MS altogether (except for the database backend). And, as I am the lead developer at my company, I will likely get a chance to do that some day. 
You can put the code in a Gist, and then use [RawGit](https://rawgit.com/). 
Yes, but lets say the page that is rendered has dynamic data, but not user specific data then when ever the data is updated you can Render Via react and then put the generated HTML into a cache and only render once per update. 
With React you can render something like a welcome page on the server and then use normal data fetches once on the client. 
Look into PDF.js (by Mozilla, I think). It's the most sophisticated PDF -&gt; HTML project out there, and I think it has some DRM stuff, and in any case certainly prevents download of the PDF (you're in control of what buttons the PDF viewer presents to the user, and the manner in which it's viewed). ... however, it's not for the faint of heart, as documentation is basically non-existent.
Thanks! No framework, every story is a custom build, using a [starter](https://github.com/polygraph-cool/starter) scaffolding with a bunch of build tasks. 
I think it is an important concept, that helps you understand higher order functions/classes, decorators and more. Let me try: Variables in JS can be seen as pointers in C. When a variable is used that is defined outside the function, then the same pointer is used, which means the same value also: var i; // variable i is a pointer that points to undefined for (i=1; i&lt;=5; i++) { // we change the pointer i so that it points to a value equal to 1 (first pass) setTimeout(function timer() { // here a couple things happen // first a new function "timer" is created // then the body of the function is parsed // the parser detects that a variable "i" is used // the parser detects that "i" is defined outside but not here // the parser decides to use that "i" that is outside // it is the same "i", here and above // there is only single "i" in play here (not 5) console.log(i); }, i*1000); } // the value that i points too is 5 // the first "timer()" function is executed // console.log(i); now displays the value that i points too --&gt; 5 // and again ... We can say that all the timer functions closes over i that is outside, (close over = closure) We can say that all the timer functions are keeping a shortCut to the i above, a pointer to a pointer if you want. Your second example is kind of counter intuitive because the functions are executed immediately, with console log freezing the value and displaying it immediately. Now an example where we can create more variables (or pointers) : var closeOver = function (anything, anyFunction) { // returns a function // the closuredFunction gets anything from here, // when this runs the value anything is already frozen and COPIED var closuredFunction = function () { anyFunction(anything); }; return closuredFunction; }; var i; // variable i is a pointer that points to undefined for (i=1; i&lt;=5; i++) { // we change the pointer i so that it points to a value equal to 1 (first pass) setTimeout(closeOver(i, function timer(x) { // here a couple things happen // we pass i to a function, // when a function receives a parameter it is copied // the parser detects that a variable "x" is used // the parser detects that "x is defined INSIDE the parameter list // and resolve its pointer when called, not now console.log(x); }) /*closeOver returns a function*/, i*1000); // i++ does change the pointer i but not the pointer anything that is elsewhere in memory } // in this example more variables were created
Thanks?
 Here's my unusual way of understanding closures. I'm probably going to get a lot of crap from functional hipsters but I'll tell it anyway. A computer language doesn't have to let a function see outside itself for variables. I'm not sure if allowing that is "purely functional", but we'll get lots of arguments about that. I think c/c++ doesn't let you see outside except if they are global variables, which gives you a nice warm feeling, but you can't really pass functions themselves around anyway, just pointers. But you know that c functions entire world is either globals or what was passed in. Maybe perl too? I forget. But in javascript you can see outside the scope of a function. Ok fine, whoever came up with that idea probably thought he was brilliant, but I really don't like it myself, it makes reasoning more difficult, and you can't do something like cut-and-paste a function somewhere else, it always has to deal with the stuff around it, like baggage, or your family on thankgiving. Now here's the deal with closures. The genius who came up with the idea of a functions scope being bigger than the function decided to pass a function to another function, and had an oh-shit moment. He realized if you pass a function that needs knowledge about whats around it, it has to drag all that outside baggage around with it. But instead of calling it outside baggage, its called a closure. Functional hipsters think they are some great truth in the universe, but I think they are just a kludge to allow function passing in a language that allows outer scope visibility. You can do some crazy stuff with closures, mostly for the purpose of making you feel smarter than your coworkers. Here's something I think the hipsters call a kestrel, but I think of it as a two-stage function, it uses a closure to store a variable for the second step. function f(x){ return function(y){ return x + y } } f2 = f(1) // stage one f2(2) //=&gt; // stage two, returns 3 You can write the above like this for the bonus of 10 hipster points f = (x) =&gt; (y) =&gt; x + y 
I'm surprised the Purescript offerings (pux and halogen) are basically the worst, especially when its competitor Elm is far up there above react.
Cool! I like these types of posts. Learn something new!
I think this is a concept that would make implementing the framework a little easier and more practical for most people. https://github.com/russellgoldenberg/scrollama/issues/19
I usually just use `el.click()` so that it populates all the event props and bubbles as expected. https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click
closures are really simple to understand people just like making them complicated : think of a parent function which inside of it has a nested function and we will call this function child...it looks something like this function parent(a){ var a = 2 function child(b){ return a * b } } so think of it as a child asking its parent for information.....however the parent function cannot ask the child for any information..and because it is not accessible form outside in it is a good way for privatizing things 
 try { throw new Error('Whoops!'); } catch (e) { console.log(e.name + ': ' + e.message); }
Looks great, are you (one of) the FE devs on the project? Would love to hear more abt the stack
Dunno if you checked MDN, but this is clearly [documented](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event). It's a good resource, if you didn't already know about it.
Keep at it, it'll click eventually. To be honest, 50 hours is not that much. That's barely over a week of full time work. You think a week is enough time to learn anything hard? Check out some of the exercises here: https://nodeschool.io/ Particularly the "Functional Javascript" workshop. I had a really intense A HA moment when doing that one that changed how I coded forever after. 
None taken. You're right our bickering wasn't adding anything of value. I apologize. 
&gt; I'm all for constructive criticism, but your post reads like a fifth grader who discovered the internet. Ad hominem. Stopped reading.
But you bother to comment....that makes sense
It doesn’t require JSX, but are you aware of any production React sites that don’t use JSX? 
I'd say move when you need it. I started learning back-end stuff when I noticed I was trying to find all sorts of front-end workarounds for things that could have easily been solved with back-end code. I tend to find it hard to learn anything in a way that sticks unless I have a clear use case for it.
I'm not entirely sure that closures are that hard of a concept...
This example deals with asynchronous code which might be what you're hung up on. The example is supposed to show how the *closure* of each "instance" of the function timer has a reference to the same instance of i. The setTimeout is key to showing this because the for loop completes its iteration of i 0 == -&gt; i == 5 and the setTimeout executes each instance of "timer" at some point after that. Again, it will execute a function passed into it after the delay in ms passed in as the second parameter. This is the part you're hung up on: **setTimeout executes all 5 calls to "timer" *after* the for loop has finished** All 5 instances have a reference to the same "i" in their closure. Closure is just the bucket representing a function's scope. Since all 5 instances of timer execute after the for loop completes and all 5 have a reference to the same i in their closure, you get five console.log of the current value of i, which is 6. Your second example runs synchronously within the for loop. Each instance of the timer there does share a reference to the same variable, but you're causing the console.log(i) to occur during each iteration of the for loop. Each instance spits out the current value of i, same as in your first snippet, but the difference is your "small modification" is causing each function to be called within each iteration of the for loop in sequence, where as the original waits until the for loop completes before calling the functions. It's a bit of a complex example because of the asynchronousness in setTimeout. Closure is literally just the scope that a function has access to when it's created. If you have code that dynamically creates functions, like a function declaration in a for loop, you can create the same function logically that behaves differently based on its own scope of variables. That's the benefit of closure. Same logic with different data in a small package that you can then pass to other functions or something.
Fallacies don't apply there, you're just trying to sound smart. You can say you stopped reading because you felt insulted, that's your choice, but ad hominem is an argumentative fallacy. I'm not trying to present an argument, I'm simply stating my honest opinion about your post. &amp;nbsp; PS to my previous post, which I forgot to mention. I'm an actual designer. So feel free to read it and take a lesson, or just disregard everything I said and use your book as a support for every argument you present ( tip: that's also a fallacy ).
Additionally: RTMFspec
Everyone's mind works differently. You learn different things at different times. When this clicks for OP, a door will unlock in his mental universe and he will never be the same. 
Have a poor man's auth key (a long randomly generated string in a cookie or localStorage) and check for it.
Your question is weirdly worded: "vanilla JS" and "back end programming" are not mutually exclusive concepts that you can "move from" or "move to", they are not even in the same category. Are you asking "when to move from writing JS for the front-end to writing JS for the back-end?" If yes, then the answer is "it depends". It depends on what is your current state of skills and what you are trying to achieve by this action. You have mastered all of the [front-end web development skills](https://medium.com/@TuckerConnelly/javascript-competency-matrix-6831817885d9) but there are no good jobs for front-end devs in your area? Well, it might be time to switch sides and learn some node. You have finished a couple of online courses on JavaScript but are not getting job offers? Well, not knowing node is probably not the problem here...
[removed]
Most web servers—Apache, nginx—support basic authentication. 
[removed]
Is this something I'd just specify in the nginx.conf?
Yeah. Read the nginx docs. 
Thanks!
Right. I've never used `new Event()` in my life. Anyone have use cases for using new Event()?
I've only ever used it for click proxying, and even then, I'd never proxy clicks in an ideal world
Y'know, I'd love to see you write up a few articles on some of the advanced architectural stuff your team has done with Redux... :)
Mask and other constrains can be useful for many regular cases. It could be really helpful and not to violate POLA at the same time. I agree that we should not use it everywhere, but sometimes. Validation is also always required, usually on backend.
You probably want to try it in IE. If I recall, new event does not work there...
Since the mobile app, I can't stand entering reddit desktop. Feels like 10 years ago.
Guys, I have doubt of my own for(let i = 0; i &lt; 5; i++){ setTimeout(()=&gt;console.log(i), 1000); } This code works because let is block scoped right ?
`React.createElement` might be verbose, but there are plenty of compile-to-js languages that use function calls to build DOM. 
I haven't tried webstorm but android studio feels like a square wheelchair. I find IDEs extremely slow and heavy, and for most tools there is an equivalent extension in VSCode.
You can eliminate MS, use python/elixir with a Django or whatever is used nowadays. And it's not as horrible as node. Also I did eliminate IE, I just simply don't give a fuck about it, mainly because I don't think that anyone who is still working on a private company machine that has only IE6, will really care about my procedural terrain generation, simple games or whatever else. And if that ever becomes a problem, I can just make a proper webpage that supports even a [fucking tamagotchi](http://motherfuckingwebsite.com/). Also no, I don't really care about web development, I just wanted to learn what I can actually do with just a browser and plain javascript, and well, I can do a lot.
I’ve used it for playback of user events before, firing mouse/keyboard down/up/move events.
Including some for React. Although there isn't much more you can shed after const r = React.createElement Which results in code like const { onClick, children } = this.props return r(MyComponent, { onClick }, r('small', null, children), )
Not helpful at all.
&gt; React 16 is really an improvement. It pushes react in front of preact and vue.js. Fiber is showing its magic
The server side can be vanilla too, if you choose to write code without a framework—just like the client side can. Neither one is easier than the other, it all just depends what kind of problems you are trying to solve. There are three layers to think about here. 1. Language The language is the same in the browser and on the server, concepts here are readily transferable between environments (functions, objects, promises, loops etc). 2. Platform The browser has native libraries for interacting with HTML whereas the server's native libraries focus on networking, file systems etc. These APIs are usually low level, but powerful. Examples of platform code would be `http.createServer` and `document.createElement`. 3. Libraries These are the abstractions that other people build to make it easier to work with the native platform libraries. Frameworks would fall into this layer. Examples would be React (in the browser) and Express (at the server). It is important to learn the Language as you'll be using it regardless of which platform you're writing code for. Then it's your decision to write applications using either the low level platform APIs (less productivity and better understanding) or using frameworks (high productivity and less understanding). 
Membership is open for those that want it.
What all of us want to try is to remove IE from this world. And also cure cancer, and most STD's.
I’ve done it properly, was just at a company that wouldn’t let me open source it :( Same with all the working solutions I’ve seen. It *is* possible to write your own code without using a library ;)
&gt; because they're the same thing Nope! In the top, you are calling setTimeout, which is going to call what's inside it at the time it is allowed, and at that point in time, the reference to `i` holds the value `6`. What's actually happening behind the scenes is the loop is run immediately and they're all waiting to log `(i)` . At the bottom, there is no setTimeout at all, and you're passing a function to another function which is going to immediately execute with whatever argument it is given. It is evaluated immediately and the reference to `i` is whatever it is at the current point in the loop. 
But mostly remote IE
If you're just venting, I get it. I was there once too, I only got it once I actually sat down and started reading about them properly. You're right, most examples overcomplicate shit and then go "Tada!". If you actually want some insight though, I'll show you some code that might help you get it. If it's still confusing let me know so I don't contribute to the "tada!". Example 1 // A short lesson in closures // All you have to know about a closure is they return a function, and whatever is returned // knows about everything in the current scope before the return statement function makeCounter(){ let counter = 0 return function(){ console.log(counter) // notice how we are looking at variable 'counter' in the main scope of the function counter++; } } // Since we're returning a function, we can call it var a = makeCounter() // Remember the function that was returned contains a reference to the variable in the outer scope a() // 0 a() // 1 a() // 2 // That lets us do this var b = makeCounter() b() // 0 a() // 3 b() // 1 a() // 4 // They're both counting with their own interval, because they have their own reference, they're not sharing a counter Now this thing on its own is not really powerful, but imagine making a whole bunch of functions when building UI functionality, in this example we want to enable/disable form elements // Closures are powerful because they hold their own state and you can solve interesting problems with them function toggleElement(element){ var disabled = false return function(){ disabled = !disabled element.disabled = disabled } } // Now we can pass this function an element, and get a function back that enable/disables it. // Because we're using a closure which takes an element as a reference, // you can pick and choose which element to have the functionality // Imagine some form like &lt;button id="#main-button"&gt;Click me&lt;/button&gt; &lt;input id="name-input" type="text" /&gt; var main_toggle = toggleElement(document.getElementById('main-button')) main_toggle() // now it is disabled main_toggle() // now it is enabled var name_toggle = toggleElement(document.getElementById('name-input')) name_toggle() // disable name_toggle() // enable 
I'm a PM away if you need help, just send a message. 
Yeah well then you must be a shitty designer
It is stupid simple. There is a complex formal definition. In practice though it is merely the crossing of a scope boundary to resolve a reference. Imagine nesting functions. You declare a reference in the outer function and use it in the inner function. That is a closure. It allows leaking data into a higher scope so that other lower scopes have shared access to references.
This is a great idea. Graveyard sounds a bit scary though...
I recommend not using `for in` loops. If you want clean always use `while` or `do/while` loops. In the case of your example `let` simple declares a reference `item`. Since let is block scoped the reference is bound to the forthcoming block created by the loop.
When looping over arrays: If you need indices, use 'in' for(let item in names){ console.log(item) } // output : 0,1,2,3 If you need values use 'of' for(let item of names){ console.log(item) } // output : 'a' , 'b' , 'c', 'd' forEach will let you do something on the items of the array function. You can't break out of a forEach loop like you can with a normal one (unless you throw an exception) `names.forEach((item,index) =&gt; console.log(item, index))` You just use this for when you want shorter code 
You've got a couple of concepts wrong. If you look to e.g. MDN, you'll see that for ... in is syntax only valid for enumerable properties on **objects**, not arrays. I'm not sure where you've read for ... for syntax, but it doesn't exist. .forEach exists so that you can call it on an array, like array.forEach(item =&gt; { }) and what you are probably looking for, which is the newest syntax, is for ... of, which lets you iterate over any iterable (Array, Map, Set, String, TypedArray etc.). [Go read more here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)
Some loops you use for objects ( the thing which looks like that { property: value} ) and in javascript is build on objects, and aslo some object may inherit properties of another objects but will not have it by it self. The part was very VERY basic explanetion of objects you better check some good article. So when you want to loop trough the object you must use hasOwnProperty() to make sure that you are looping only trough properties of this particular object not the one which it can inherit. For object looping you can use for( key in Object){...} loop and inside you will need to check if property is right. Also you can use this loop for arrays too but you will not need to check if it has property. Basic loop is for(iterator; condition; iterator++/--){...} usually used for arrays. There new loop which came in to make it easier to loop and make it more functional forEach, but i am not really fun of it.
Yeah it does 😱 . My main concern is that I'd like it to be a more openly governed thing, instead of it being an org with owners. Like a more democratic way to donate orphaned modules back to people who want them. However I don't really see a way to implement that within githubs model.
Amazing work! Never heard of surplus before. Looks very interesting...
I had to use it for a really complicated scenario at one point, but I'm pretty sure we eventually replaced all that code with a completely different system that didn't require faking a click at all. Which is my general advice when someone wants to fake a click anyhow, now.
I evaluated the solution as a way of getting to market on multiple platforms quickly, but ultimately decided that it was not of interest, as the community around it seems very closed and too small to have solutions for all of the issues I'd be running into. It also seemed like I was going to need to write a good deal of platform specific code for some of the features I wanted. I ended up with React Native instead, and have had the feeling that it was the right choice all the way, partly due to the platform, but mainly due to the community. I digress, but speaking to your job prospects, if you feel like it could be exciting, go for it, but it already sounds a little bit like you're on the fence about the job, and the main thing drawing you to it is the pay, which will turn out to not matter in the long run if you don't enjoy developing the product.
In what way are while loops cleaner than for...in loops? That's a very unpopular opinion.
More detail plz
forEach can also be chained along with other Array functions although I find myself using it a lot less than map/filter/reduce. [1,2,3,4,5,6,7,8,9,10] .filter(i =&gt; !(i%2)) .forEach(i =&gt; console.log(i));
Also, I'd like to add to TheNumberOneCulprit's points (speaking of misunderstood concepts): 'webpack' is not a next-level of javascript or anything, that could _introduce_ any new ways of iterating. Webpack is a packaging tool. I think clearing up your vocab in what-is-what regarding javascript is just as useful as knowing how to iterate over values of an array. Otherwise you'll be the next guy who says that jQuery is a better language than Javascript.
That's cool man, how long did this and your other Github projects, each take you to build? 
it's 2017 and people still browse reddit with css enabled
About what?
Historically `for in` loops were for iterating through the keys of object literals before the Object.keys method came out in ES5. If you need to find a given item from an array you need to do any looping at all. `[].indexOf("whatever")` The code formatting is accomplished with the grave accent character. On most QWERTY keyboards it is on the same key as the tilde.
Short and to the point answer: Build applications with the stack you want, as your projects expand, you will most likely have to use some open source libraries, when you do encounter those libraries, try to see if you can help them out a little bit. By doing it this way, you're showing a practical record of being able to take an idea and execute it with the tech stack you want, while at the same time showing that when you do encounter issues, you're not afraid to tackle them head-on. The open-source work is a nice benefit, as you'll then have a track record of how you communicate to others technically, how you solve problems etc.
Thanks for all responses, i'll use bootstrap for this project and maybe in future other frameworks.
&gt; The only annoying thing is that forEach returns undefined. I really wish it would've returned the array itself. That's what [map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) is for :) // create an array var numbers = [1, 4, 9, 16]; // call map(), passing a function var mapped = numbers.map(function(x) { return x * 2 }); // log the result console.log(mapped); // expected output: 2,8,18,32
oh good, more dumb crap from node that isn't about making the software better. &gt;making a venn diagram of shared values will hopefully represent the true core values of the Node.js community, from its ecosystem of communities. no. this is the core values of the people doing the exercise, not the community. stop speaking for other people. many businesses depend on nodejs. they don't give a shit about node's social mission or its great core values. they don't give a shit about *fun* or *romantic* or how *welcoming* the community is. they give a shit about software quality, bugs, communication and having a plan they can base their business off of. other than stability and performance, everything in here is about how the clique that did this exercise interacts with each other. it's really really great that a small group of people got together and published these and that they're more empowered and capable people. but this kind of post dramatically lowers my confidence that the people developing node have their heads anywhere other than the clouds or up each others asses.
Depends on the employer and position. For our hires, when I've been involved in the hiring process for our team, my primary interest in an applicant's GitHub is to check out their coding style. Is it clean, are there comments, how are things structured, etc. An active GitHub can also help fill the gap for someone with weaker work experience on their resume. People who have contributed to other projects can effectively count as work experience to an extent (less so for personal projects though they still carry weight). Bonus goes to the use of technologies we use here, but not required as they can always be learned on the job - assuming there's already a base understanding of core concepts which ultimately gets flushed out in the interviews. 
I can see that you're making a good point. Reacting immediately in the view to actions can be tricky in the old way of doing things. You do need to listen to events. My question is, is it really that important to fundamentally change the way we program? In my experience, unless you are writing something like a word processor, the amount of events you need to react to on screen are quite few and can be encapsulated nicely inside the view controller (or even inside the component controller). If the view is not in memory, it doesn't react to it. Simple as that. Reactions to onDataChanged should *never* be in a central place. I can imagine the mess you talk about with all of the combinatorial mutations if you did have that sort of stuff in a central place. isUserCanAccessFunctionalityX is generally a method of a user model. In most cases it would be "accountType" or something. I can't even imagine writing this locally to a view. Likewise, remote operations return to act on the relevant model (of which there is only one instance of inside the app). There is no need for some sort of syncing or merging. I really don't understand how people can be having problems with this stuff?
Thanks, thats a really helpful reply. Any advice on how I should allocate my time for the next couple months? Between developing apps, adding to my portfolio site and studying/learning. 
Thanks for the reply. In your opinion is clean dry code more important than the app itself? I was kind of embarrassed to upload some side projects because they seem too simple. To-do apps and things I made just for fun.
Don't really know germany but in Paris, there are more and more companies that ask for a quick exercise to evaluate your skills before any interview. When you successfully pass that part, during the interview, there is a code review asking why you made your choices and trying to figure out the tradeoff of your design. At the end, some companies add an exercise where you have to add a new feature in the exercise. For that kind of exercises, usually I'm looking for tests first. Then I checks commits to see if your history shows a consistent story (often there is only one commit though :(). Then I'm looking at your "production" code and I try to find the flaws of your design (questions that I should ask during the interviews) Finally, I check if you respected good programming design (for example in OO, if you have setter/getter in every class, that's a fail) if your files, functions are well named etc... That's of course when we ask for an exercise, I don't really know if that respond to your question :)
\`type this\` = `type this`
No, what I was saying is that it would be nice to tap into a chain of array functions without affecting the array. Sure you can do this with map by giving it an identity function that causes some side effect but that's a hacky work-around.
Yes, you are right, I meant for of, not for -- for! As for webpack, yes indeed, what I meant is that with webpack I can use es6 which introduces new concepts.. Again, thanks a lot for clarifying. I'm new to this! :D 
&gt; hasOwnProperty If I use for item of items (when items is an object) do I still need to use hasOwnProperty ??
Fuck IE
&gt; for Also, using `forEach(item =&gt; {})` do I need to use `hasOwnProperty`?
The condition should be `i &lt; items.length`, not `&lt;=`, or you'll get an error, in most languages. In JavaScript, if you try to access element from array and index is out of bounds, it returns undefined.
What about using factory functions? https://www.youtube.com/watch?v=ImwrezYhw4w + You don't have to deal with shitty "this" + You have real private methods and attributes - You don't have classes' inheritance (but really who cares?)
It's up to the design. Let's take Facebook for instance. They have notification center. When people click on notification center it should render list of notifications. They have chat as sidebar and as a chat popup which need to display all chat messages, paginated nicely. They have news feed. They have advertisement. All in one single view. So this view have as least 7 models that need to be combine together in this view. Imagine combinatorial mutation of these 7 models together. It will be mess for even single non-centralized view already. Business logics such as "isUserOnline" need to share to another view that have ability to display chat popup as well. So how can we solve this problem in the past? Answer is we use to do simpler frontend in the past. You cannot chat while browsing webboard. Notification center is just another a mailbox page that trigger a whole new view instead of small popup. For these type of design we can actually follow Ruby on Rails tutorial and make it work. Model fit nicely with the view with natural 1-1 relationship (instead of 10-1 relationship). I still develop this kind of apps as side project from times to times and I always go for simple MVC for this type of apps. But in my main work, I do project management software and majority of view needs combination of 3-4 models before it have all the data it needs. You may argue that old design is better from UI/UX perspective. Sometimes I feel like app design these day getting unnecessary complicated as well. My point is, given trend of modern app design, these new frontend frameworks (React, Viper, Angular) is solving a problem of complicated frontend. It enable us to have enough power to build and maintain these kind of frontend.
I appreciate the sentiment, but I thought I'd try and solve the Class issue, rather than avoid it.
I simply get {"code":5,"desc":"Referer was denied access."} When trying to fetch data of my own ig account. 
at a mid-stage fintech company here. we care that you have one, and you have some projects on it, and that's it. been here for two years now, and started helping with the interview process. noone actually looks at the projects or code you have on there. it's a worthless measure because stuff that is online can be curated and is under no time constraints. we really only care how you do on the coding portion of our interview. this might ruffle some feathers but we actually care more if we can work with you on a daily basis than if you are some god coder. youll see in the interview process people actually rooting for a candidate they like to do well in the coding portion. 
I like the idea :) How would one submit an npm package to you?
Personally, I'm more impressed with the speed improvement of Angular 5.
By Kestral you mean partially applied function, and it's useful as a similar mechanism to dependency injection in OOP, reusing functions in different contexts and composition amonst other things. I didn't really get currying or partial application until I just _used_ it a few times and then I saw the power. You can make modules of useful functions and partially apply them for the current context and reuse the same module in another context. I particularly like to use them to pass API environments around while still keeping the underlying fetches the same
Have a look at [lit-html](https://github.com/PolymerLabs/lit-html) it used a very similar concept
&gt;So this view have as least 7 models that need to be combine together in this view. Or we could have 7 isolated components, each with their own controller. &gt;So this view have as least 7 models that need to be combine together in this view. Imagine combinatorial mutation of these 7 models together. There should be one model that each component subscribes to. No need for 7 models, that would be silly. Then there are no combinatorial problems. Model - is for objects (users, posts, photos) Controllers - Are the logic for "screens" Views - Purely for layout and presentation. The controllers are what subscribe to events and update the views. The models deal with all the actual data. &gt;My point is, given trend of modern app design, these new frontend frameworks (React, Viper, Angular) is solving a problem of complicated frontend. And my point is yes, they are solving it, but they are far too complicated. I could write half the code to do the same work without them. 
You can just transfer it. If you want I can make you admin of the org, so you can decide what happens to your package.
That's interesting, as I've never had a technical interview before. I don't really know what to expect, or what they will ask me to do (why i'm so nervous ahah). Would you mind giving me a couple pointers on how to best prepare? What types of problems they could ask me to solve and how I could practice them before hand? - Also, I'm planning to apply and interview remotely, not in person. So the interview will be over skype (I assume). Any idea how the coding portion of the interview would be conducted. As someone in the type of position I'm aiming for, I really appreciate your advice.
Nope. Personally I almost never use for loops and use array methods like map, forEach, filter, and reduce instead
No, that is really helpful thanks. The technical exercises are what I'm most nervous about, I still consider myself quite novice. Do you have any recommendations on how I could prepare for and practice those types of exercises? Any online platform or learning resource that you recommend? Thanks again
Yup, though there aren't any strict roles, we all do everything (data analysis, writing, design, dev). The build is just a bunch of tasks to make our workflow more efficient (gulp, webpack, stylus, etc.). Also a bunch of smaller things I've picked up along the way like a poor man's CMS via piping in google docs copy -&gt; archieml -&gt; handlebars, or async font loading strategy with FOUT.
Ditto, what I got from this is that I wanna learn more about Surplus.
You could also use symbols as keys, which wouldn’t make them private but it would make accessing them more inconvenient
Yes from what I've understood now they seem much better and more concise 
Either that or have console.log return its arguments. I'm not sure what's worse though, having forEach in the middle of a chain or introducing side effects in a map
Cool. I was just curious about the process, and if was that simple just to change ownership through GitHub. You probably also want to inherit the ownership of the npm package itself through `npm owner add &lt;user&gt;`?
Subscribing to the model is exactly what React want to do. Imagine Facebook photo for each user. When any of your friend change his profile picture, the Chat, Notifications and news feed item related to that friend should change the profile photo accordingly in real time manner. So, news feed component need at least two combination of model (user and news feed itself). I would say it get more complicated when you also consider the fact that comments content and likes need to be shared between notification center and news feed as well. New posts from your friends may be displayed on both notification center and in your feeds. When you share a post in facebook and the source post is deleted you need to deleted the shared content immediately in real-time as well, including one you shared in your private chat roomz It is impossible to design model exactly for each view. You have users, posts, comments, chat messages and all of them can be display in nearly every component. At least you need some additional transformation layer that combine every model from the backend and transform it to view-model (MVVM) which become out of scope of simple mvc. I would be happy if you design something even better than React-Redux to solve this problem in non ad-hoc or case-by-case basis.
 const sfx = f =&gt; x =&gt; f(x), x; const inspect = sfx(console.log); // Or your preferred option, maybe different for different environments. ...and then do a `map(inspect)`. I don't feel that's _hacky_ anymore than having `forEach` return the original array. Of course, performance is going to be worse, but then again, if that was a concern, I wouldn't go around chaining transformations and would compose them before -which incidentally would take me back to the above `sfx` and `inspect` functions anyway.
Some quick ones, Write an exponentiation function. You should be able to produce a solution almost immediately. We want you to be able to figure out the O(log(n)) solution with minimal prodding. A recursion problem, sometimes as trivial as fibonacci, again shouldn't be too many hiccups here. You should be teaching us about memoization and implementing it as you're finishing up. There's also an intentionally difficult problem given. A big determining factor is how someone handles themselves when they hit a wall. Being vocal, clear, and concise about your thought process is key here. Some people melt down. Listen to some podcasts about the stack you use. Be able to have a conversation about current technologies and why you would use one over another. Know about the major coding patterns, for example if you're doing javascript, you should know about redux patterns, observables, es6/es7..
Generally, yes. What the app does has little significance... with the exception of projects that are learning projects such as to-do apps. Those may likely get ignored (I'd ignore these, and anything else you could look up online and create with step by step instructions). The goal is to determine what you're capable of on your own. Simple apps are fine, as long as they're made by you.
Hi /u/ungaks, this post was removed. Please see our rules, and do know that 'Java' !== 'JavaScript'.
This is irrelevant to the statement when comparing non JSX react to Yalla as the two have an implied requirement to not use transpilation. The whole point of JSX was to create a simplified mental model instead of converting html to a datastructure, which is why people use it. Additionally, Elm (the language) and Reagent (clojurescript) use techniques similiar to react.createElement which have production apps in their respective languages.
Thanks so much for your help.
No actually I'd prefer if you keep that. It's just a place to dump the module while you're waiting for another maintainer. You'll still be the one who transfers npm ownership to the person who wants to adopt it. I'll also add you to the org so that you'll still own your own repo.
Bottom line up front. Show projects that you are passionate about working on. Write code in your preferred personal style. Write fabulous, clear, and direct documentation. I have one github repo that is nothing but personal opinions in markdown format and it has nearly 400 github stars.
Thanks for the advice
`forEach` operates on arrays, and what you get are the individual items of the array. With this, the `hasOwnProperty` is not needed, since you're not getting keys, that you'd have to check against the object, but you actually get the elements themselves. Example: ["potato", 1, 3, {key: 'value'}].forEach(x=&gt;console.log(x)); // you'll see: "potato", 1, 3, {key: 'value'} logged in separate lines, because you console.log for each item
I have actually built the code for changing a profile photo in several different places on the app. You just need to subscribe to the event in the view controller. You don't design models for each view. Models are for objects, like users. A model (generally) only has one instance in the entire app, and multiple view controllers can refer to them. Views have no relation to models directly. Think of the model as the data layer for the application. If you delete a post, the delete action flows directly to the controller, then the controller calls the model and deletes the data. The model can then call the remote api if it wants to. Then, all of the view controllers that are subscribed to the model will then update their view based on dataChanged event from the model. This is the MVC pattern. As you can see, it is quite similar to redux, but each "store" is linked to an object, and is not in some sort of central place. This is more flexible. I should write a framework, but I have some other projects that make me more money :-p
Angular is plenty fast, it is on same level as React 16. Actually all major frameworks React, Angular and Vue are plenty fast. What we should be focusing on how to get better at code splitting, lazy loading and reduce the bundle sizes.
If you wish to solve classes' problems, you have to solve "this" too :D More seriously I understand your attempt but why trying to fix language flaws with code when there is a better way already provided by the language ? If that's for challenge, no problem :)
And these are only the meetups, conferences will be another post. Not sure if it's interesting for the js sub though, so I won't post it here, only on the react sub. 
What do you mean? &gt; Does looking at this page hurt anybody else's eyes? No, but looking at your wall of text with in-line edit is. Hence the hypocrisy.
Hi /u/amdg1927, For javascript help, please visit /r/LearnJavascript. Thank you!
Wow, upvoted. This guy thinks so exactly like me, it's uncanny. It's telepathy or something!
The closest things in web development to what your described is Angular. I still wonder about subscribing to the event itself. I would rather have my "adminButton.hidden" subscribe directly to the model "user.isAdmin", instead of just changes. Get back to the root, in web development field we do not have a way to make view subscribe to web-controller, given that traditional web MVC framework the controller is object in the server-side that have method that return html. There is no way for that HTML in the client browser to subscribe to the controller object in the server again. I would understand if you talk about subscribing to viewController in iOS environment. Now, I want to state 2 things 1. Event binding and model subscribing very powerful and convenient architecture. Based on your comment recently I think you see the point. 2. MVC for web development is different from iOS, since when web developer say controller 90% of the times the controller exists on server-side. There is no way for client html to connect to controller without intermediate tech stack such as Ajax or Websocket. There is no way for web developer to use traditional "Web MVC" (different from iOS mvc) to do what you did. 3. Angular try to solve this by make a "client-side controller", which is really close to what you did in your comment. 4. React solve this problem in another way. Now, get to the root argument 1. I insist that problem of binding and syncing model with view is a real valid problem in frontend development. 2. You can use iOS MVC to solve that problem to some degree, but when it get more complicated there is a lot of needs to solve this problem in standardise way hence we got RxSwift, MVVM, VIPER, etc. 3. Web MVC cannot do any of these stuffs. So it is really different from iOS MVC. 4. Angular try to solve this syncing problem in the really close way to what you did. 5. React proposed a completely new way to solve syncing problem. 6. I enjoy the React way more.
Gotcha. Why not something like this? $(el).on('myCustomEvent', function(e) { // do stuff }); ... $(el).trigger('myCustomEvent');
That is jQuery code and not Vanilla like the rest of the examples in this thread. https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events
Why involve the DOM at all? If you've got a good reason for it, then sure. But I'm betting you could rewrite it to avoid the dom and end up with cleaner code and better performance.
You're getting the hang of ad hominem. But think of it what you want. If you only want everyone to praise you for your revolutionary ideas, go ahead, bask in the upvotes. Otherwise, learn to take some constructive criticism. Or don't. Maybe that was a really awesome book and you "picked up" so much that someone who does this for a living is now jobless.
Ah. Good point...
Shh, you can only upvote OP and bask in the glory of the things he "picked up" in a book he read once. He is now a full blown designer and we, mere mortals, need to praise his superior knowledge. He doesn't like criticism, it hurts his feelings.
You need to [pass expect a function](https://facebook.github.io/jest/docs/en/expect.html#tothrowerror) that runs your expected-to-throw code. expect(() =&gt; CheckFunctionExistenceByStr( 'any string', 'FunctionThatDoesNotExistsInString' )).toThrow();
I'd say each took me about 3 days of on and off work. Took a few re-writes as I got more comfortable with React. I'm hoping to get a little faster with each project.
All in all, I don't really see what, if anything, does this provide over... class MyClass{ constructor(baz) { this.baz = baz; } foo(x) { privateBar.call(this,x); } } function privateBar(val) { this.baz += val; } And don't misunderstand. I don't present this as _better_ in any way. Just that I don't see that your code really solves anything over this in any particular aspect.
Same goes for our hiring process as well. Also if you don't already, I'd recommend that you use good, descriptive comments in your git commits. (Not a novel, just bullet points.) We're curious how potential hires perform in a team setting, and you'd be surprised how many candidates leave their commit messages empty. And /u/senocular, if you're who I think you are, thank you for creating the TransformTool, it was a godsend at my last job several years ago.
Hi /u/dnonsense, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
That's a pretty good point. I might have lost sight of the forest, here.
Shit I️ thought .click was jquery. Looks like I️ need to go back and convert to this. .click is supported by all browsers too, unlike new Event. 
&gt; When looping over arrays: &gt; If you need indices, use 'in' Danger! That is not the idiomatic way to iterate _arrays_, for good reason: the `in` operator iterates all **keys in an object**. This 'works' in your example because it just so happens that arrays are simply objects with numeric keys. But what if your array has additional properties? A demo of what can go wrong: let names = ['a','b','c','d']; names.NOT_AN_ARRAY_INDEX = 'ok'; for (let item in names) { console.log(item) } // output : 0,1,2,3,NOT_AN_ARRAY_INDEX Additionally, as [MDN points out](for...in should not be used to iterate over an Array where the index order is important.): &gt; `for...in` should not be used to iterate over an `Array` where the index order is important. This is why the idiomatic way to iterate an array is via `Array.prototype.forEach` (or ye olde `for(;;)` loop), because only numeric keys are iterated. I have fixed way too many bugs in my day due to this problem -- so please don't iterate arrays with `in`. 
Haha yeah `.click()` throws me off too for looking way too jQuery-ish. You should also upgrade to iOS 10.11.1-2 to get rid of that “I” autocorrect bug 🤪
I have found the solution, please see similar thread in /r/LearnJavascript.
They’re on version four...
I have no idea if this is enough information, hit me up if you need more!
Just noticed that. Jeez, don’t have time to keep up with all of this! Thanks!
Well. If you're on localhost and don't intend to push this to anything except your local machine, you can use a script tag and point the source to that file, attach an ID to it and.. ``` var json = JSON.parse(document.getElementById("yourID")) ``` If you intend to do this online, you'll have to host the file. In that case, your server will usually have a static file capabilities, so you wouldn't have to do anything complicated with it.
🔥Inferno🔥 Still faster than React 16. Too bad maintenance of the projects seems to be falling off. 
Looks really nice. I like the animations, but I feel like the animation on hovering an item is unnecessary, and actually detrimental, since the animation + the pointer cursor make the items look clickable. So you're creating an expectation based on a common UI behavior and acting against that expectation, something to avoid. I'd remove that animation and keep the standard cursor, especially since people would probably want to select the commands in order to copy them. If you really want some sort of highlighting animation, maybe subtly changing the background color of the hovered item instead?
Awesome idea! What about npm orphanage though?
Thanks for the answer, So for localhost I use the line you wrote, and change "yourID" to the name of the json file? Would it be easier for me to just upload the json file to a website, does github work?, and just insert the URL in my code? 
Cool idea! GitHub is currently previewing the new [repo transfer API](https://developer.github.com/changes/2017-11-09-repository-transfer-api-preview/), might be cool to use this to make transfer as easy as possible.
Hi /u/JavaScriptWorks, we don't condone people stealing other peoples content, thus this was removed.
I didn't mean to be rude, I am just really enthusiastic about specs. (WHATWG DOM, W3 HTML, etc.)
Anyone got a link to bubbles documentation? 
I purposefully refuse to program for IE. IE can go suck a fuck.
Are you using node or a browser? If you're using node, const fs = require('fs'); fs.readFile('myJson.json', (err, data) =&gt; { if (err) throw err; var myData = JSON.parse(data); }); From a browser, use fetch: fetch('/myJson.json').then(function(response) { var contentType = response.headers.get("content-type"); if(contentType &amp;&amp; contentType.includes("application/json")) { return response.json(); } throw new TypeError("Invalid JSON"); }) .then(function(json) { let myData = JSON.parse(json) }) .catch(function(error) { console.log(error); });
If all developers refuse to support IE... maybe... just maybe.
Glad to see the major frameworks pulling into a tight group towards the front. And Aurelia seriously has pulled forward too! 
Thanks for the answer, I'll be honest here, when I said I was a beginner, I meant it. I'm only like 3hours into coding(= Im afraid I didnt understand your comment :)). I've mostly used copy and paste and try to make it work. I believe I am on the right track. I am having problems with reading the json file. The code looks like this: $.getJSON('https://www.highcharts.com/samples/data/jsonp.php?filename=aapl-c.json&amp;callback=?', function (data) { In the sample json the format looks like this: [ [1290470400000,44.10], [1290556800000,44.97], [1290729600000,45.00], [1290988800000,45.27], etc etc.. But when I create a json the format looks like this: [ { "Date": "Nov 20, 2017", "Index": "12,55734305" }, { "Date": "Nov 19, 2017", "Index": "12,33132751" }, etc etc... This results in nothing showing up on my chart. So I guess I need help with recreating a file using the sample date format. 
Atm the "website" i'm creating is purely a HTML file with some lines of codes in it.
Because you're toggling the #link div
Now there is no contrast between the subreddit title and the background.
$.getJSON is a jQuery api call. Docs are here: http://api.jquery.com/jquery.getjson/ You should read up on the JSON format (https://www.json.org/). Your first example is an array. Storing arrays (or arrays of arrays) will result in your first example. You can try it yourself, open the console on your browser (from the dev tools menu option or ctrl+shift+i (or whatever it is on a mac)), type JSON.stringify([1,2,3]). You'll see "[1,2,3]". Now try JSON.stringify({firstProperty: "foo", secondProperty: 3}); you'll get "{"firstProperty":"foo","secondProperty":3}". In our second example here we're passing an object to be Json-ified and you're seeing the property and values. That'd account for your second example, you're jsonifying an object.
Correct - When you use 'var' there the variable lives in the parent's scope, whether it is a function or the window. So every time through the loop i gets over-written. With let - even though the 'let i' isn't really inside the block, it is creating a new block scoped i every time through the loop.
They're not, but the books you read and the new programmers that you talk to you make it seem like a big deal - for me, once I finally decided to 'learn closures' I was a little disappointed. It was like 'I already knew that, but now I have a name for it I guess'. Maybe if you learned a different language first than it is more of a weird concept?
Flashbacks: https://en.wikipedia.org/wiki/Gopher_(protocol)
If you put a link to your github I'll check whether you have any noteworthy open source projects. That's about it. I don't look at boot camp/job interview exercises and I don't do any code review. I use this criteria for a few reasons. I find that merely owning an OSS project says a lot about the candidate's level of experience and commitment to good craftsmanship. I don't look closely at exercise code because a) I don't want my judgment to be influenced by superficial things like ASI style b) if you at all bothered to have a github with things in it, your code is typically good enough and c) looking at exercises doesn't tell me anything about the things I actually want to know. Things that I really care about are whether you have a grasp on current developments in niches I care about (for my team, that's tooling stuff; for product teams, I look for product oriented libraries), whether you have a dogfooder's mindset, and how you work in teams. As I said at the beginning, I get signal for those things by looking at OSS project scope and discussions on issues, if any. For good candidates, I get very strong positive signal with this criteria. I also occasionally see good candidates that don't have strong github presence, but the vast majority in that bracket is either average or junior and I need to prod deeper in an interview. Hope that helps.
 document.getElementById("enemy-name").innerText = enemy.name should be document.getElementById("enemy-name").innerText = opponent.name It's always the little things.
Just had a play around and the simplest way I could find was to wrap the whole toggle function in a click handler on the `&lt;a&gt;` tag and making sure that you call toggle on the `drawer` div rather than the `link` a tag. jQuery('#drawer').hide(); jQuery('a#link').click(function () { jQuery('#drawer').toggle(function() { jQuery('#drawer').show(600); var destination = jquery("#v1").offset().top; jQuery("html,body").animate({ scrollTop: destination},"easeInQuad"); }, function(){ jQuery('#drawer').hide(600); }); }); 
I [forked your pen](https://codepen.io/anon/pen/PORjqX) with fixes. a few things: - it needs to be `opponent.name`. `enemy` is a class - which is like a template used to create enemies (enemies have a name, health and power) but doesn't actually hold that information itself. when you _instantiate_ a class with the `new` operator it returns a new _instance_ which you can store in a variable, instead of modifying the`enemy` class itself. and in your original code those instances are being stored as the `dragon` and `rat` variables. - your `enemy_encounter` function wasn't being run because it wasn't being called. - you don't need to include a script tag for `randomenemy.js` because codepen runs your javascript for you without needing a script tag. 
It all depends on what you want to achieve. From what you described with building web apps for business Python / JavaScript would work very nicely together. JS for front end and Python for backend. If you were to choose only one - go with JS for web development as it has better support for backend with node.js and express.js where Python does not have the best support for frontend web apps. JS on the backend can cause a lot of frustration because the ecosystem is changing so rapidly. This is why I would suggest Python w/ flask or Django for backend if you have the time to learn both : ) 
But they are not at all performance, so take care if you are doing heavy lifting.
I think there are two options 1) a functional 3-tier web application that you have deployed. This is a big ask and will take tons of time. Shows you're adapt at multiple layers and understand (in general) what it takes to put together a web app. 2) small and useful modules that plugin to third party architectures. Express middleware, jQuery plugin, react components... etc shows an understanding of modular code.
If you're building modern websites, you'll need Javascript at the very least. And that probably won't change for quite a while. Someone might eventually create something that compiles Python to Web Assembly and make it possible, but it'll be quite confusing at first and not very stable. So my advice is to learn Javascript if you want to build web apps.
There's nothing stopping you from learning both. But if you had to pick just one, Javascript.
Check this discussion https://github.com/whizzzkid/instagram-proxy-api/issues/14
&gt; Actually all major frameworks (...) are plenty fast Agreed. At this point this benchmark only really shows who micro-optimizes more and we're well past the point of diminishing returns. &gt; code splitting, lazy loading and reduce the bundle sizes. Yeah, lots of interesting problems there. SSR and async rendering are other two major areas where I'd love to see more work being done.
i'll add that how we got to this point is *thanks to* the many micro-optimizations done by the libs. also, implementation micro-optimizations are distinct from lib micro-optimizations and unfortunately theis bench does not distinguish between the two.
Ahhh I keep forgetting to run the functions. Great elaborate explanation of opponent.name. Thnx for a lot for your help! Huge motivation boost :D
Appreciate the help very much, thank you.
Isn't this what bundled dependencies are for? You can use your sub-package as a local dependency, then included it bundled into the main one when publishing.
Thanks for the feedback, The thing is that I have shipped an unfinished feature which is copying the command when user clicks it. This is a work in progress, will be available soon :) That said, I totally agree with you about the hover animation, I will test the background color change instead. I will keep you posted 
Thanks
Thanks! I played around with formating the json string, and somehow I managed to make it right. I believe the problem was with spaces and such. The data is just inverted atm, so it looks like a steady downhill, but it should be a somewhat easy fix. Thanks for bearing with me!
There's still hope that new [tests](https://github.com/krausest/js-framework-benchmark/issues/305) would help improve on other areas that where previously ignored.
Makes sense. However, with graveyard carrying that negative and dark undertone, finding adopters may be tricky. Perhaps we can borrow from the adoption terminology. How about npm-rescue-shelter or just npm-shelter?
No worries, enjoy your coding adventure. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse
This is what you would have to do. src becomes wherever the file is, being on github, your machine, or out on a server somewhere. ``` &lt;script id="MyFile" type="application/json" src="c://all/myfile.json"&gt;&lt;/script&gt; &lt;script&gt; var json = JSON.parse(document.getElementById("MyFile")) // json is now your file. &lt;/script&gt; ``` Github might make sense to upload the file into. If your project is already under source control why not throw it in and access it via the raw file. It's definitely not recommended to this on something that will be making that request to github every second, and it could even be against some ToS with github too. But since you're making the raw changes to the json file, it might be beneficial to put it into source control so you can mark your changes and rollback if need too.
Thanks for the input
Makes sense!
I see what you mean. Changing the name is fine by me, you're not the only one who's mentioned this. However, maybe it's best to wait for npm's reply in this issue: https://github.com/npm/npm/issues/19052, and once there's a bit more clarity, move to a more definitive name?
How do you get the two languages to work together? I thought if you picked one language (python for example) you had to do everything through Python? You mean there is a way to design the website and such with JavaScript, and have all the backend coding be Python? How would that work in the files though? 
Thanks very much, that did help. One quick question - Is a LinkedIn account important for you? On my resume I am planning to link Github, Twitter and my portfolio site. Should I add anything else? 
You are correct. dist/umd/popper.js worked perfectly. Thanks
Do you know whether aurelia supports keyed updates? If not I'd not bother with it.
I love date-fns, but the one thing it can't do (yet) is timezones 
Oh don't get me wrong, progress is progress. I'm just saying the impact of inching forward nowadays isn't nearly as impactful as the progress we saw in, say, Ember over the course of Glimmer development, or the huge improvements we saw in Angular 2 over 1.5. I'm very happy to see that all the work put into React 16 is paying off, but I also agree with Tom Dale that from now on, people are gonna need to start putting on their compiler hats to really make a dent on perf going forward. Compared to that, I think the things I enumerated in my previous post seem like lower hanging fruits.
&gt; By Kestral you mean partially applied function, and it's useful as a similar mechanism to dependency injection in OOP, reusing functions in different contexts and composition amonst other things. Kestrel, also known as k-combinator. I think its a specific form of partially applied function. &gt; I didn't really get currying or partial application until I just used it a few times and then I saw the power. You can make modules of useful functions and partially apply them for the current context and reuse the same module in another context. &gt; I particularly like to use them to pass API environments around while still keeping the underlying fetches the same I know, right? Its funny how a common pattern in functional programming is almost objected oriented, its 'state' that has a 'method' 
the easiest way which currently comes to mind would be to create a restful API using Django and make queries / requests from the backend with JS. So basically every time your program needs to request data it would send a request with the required parameters to the restful API And then return the necessary data to your app.
Uhh, doesn't win8/10 whatever already have no support for IE and microsoft edge is a thing? And other platforms mostly use chromium/safari.
So... you created the modern version of the Apache Foundation, where projects go into "maintenance" mode and die a slow, horrible death?
As a Python fan, I’m excited too see what will happen in the future 
Microbenchmarks, though. None of this has real world implications at this point. Infernos creator has had a [talk about it](https://www.youtube.com/watch?v=djOc1EK07Tk), measuring even regressions in real world apps when optimizing for benchmarks. The thing that makes Fiber stand out is that it runs on a scheduled reconciler, it is entirely new ground for performance with implications that likely could be dramatic. You can see how fast it really can be in the [Sierpinsky demo](https://claudiopro.github.io/react-fiber-vs-stack-demo/).
&gt; people are gonna need to start putting on their compiler hats to really make a dent on perf going forward yeah, i think svelte is definitely on the right track and the way things should be. however, i do have a problem with learning more and more special template syntax which must keep expanding rather than just sticking to POJS. the need for extreme SSR speed [that's not already solved by caching] may be solved by js-executing indexing engines used by SERPs in the future. we'll see :)
My personal approach: *context* I approach interviews as if I am looking for a colleague or a team mate. Thus I tend to give more weight to attitude, maturity, discipline than "clever hacks" or matching technology styles/choices. I always assume that the code is for learning or show casing abilities, so I'm ok with not paying attention to production quality or optimizations. That being said, on to the answer. I always start with the commit history. That is my filtering criteria. If there are just few commits, then I cannot be sure if they did it on their own or had help. It doesn't make sense for me to invest more time. Especially if there is just one commit which uploads the entire project. Secondly, I look at the messages. Are they describing the changes appropriately or just generic messages (fixed things). I work in a distributed team and in any codebase having meaningful messages makes our lives so much easier. This is a test of maturity. Then I look for refactoring or rewrites in the project. I use this to judge decision making and also potential interview questions. I am more interested in why and how it was approached than what was done. Next steps depends on the seniority of the position I am looking for. For seniors, I tend to look for design decisions, technology choices for interview question. For others I look for basic disciplinary stuff like is the code readable and understandable, are there comments in the complicated sections of code. Are there any tests at all? If yes, what are they trying to test. I've also developed a habit to look for some signs in their chosen tools. Just to see if they take time to learn the basics. For example, is there a maintained gitignore file or not. The end. I take this pain because I want to give the interviewee a realistic and fair chance. I do not believe in white board programming. What is your take on my process as a potential interviewee? I would love to hear feedback. 
I mean it certainly sounds like even though Python is becoming more popular, it's still in the early stages of becoming a more powerful web framework, which could take years and many contributions from individuals around the world. Whereas that time and commitment has already occured in JS. 
Ok that makes sense. Thank you for your answer.
Dude, it’s understandable that after 50 hours of trying to learn something it doesn’t make much sense, but it sounds like you’ve given up on it which isn’t the answer. Not in web development, not in life. Saying you’ll never get it is more harmful than you think. Don’t you see? It’s a self-fulfilling prophecy. If a person tells themselves something over and over, they begin to believe it. Whether that thing is negative or positive, it still implies. You need to start with telling yourself that you’ll figure this out, and you need to *believe it.* By doing that, you open the door which previously you were holding shut while telling people it wouldn’t open. Also, keep in mind that this language was created by man. Therefore, it is meant to be *understood* by man. You are no exception. Have more faith in yourself. 
Last year it was 2016.
Ok, I understand that now, but why doesn't this work the same way? for (var i=1; i&lt;=5; i++) { setTimeout(console.log( i ), i*1000 ); } Obviously the difference here is that there is no function wrapper around the console.log, but I do not understand why that does not create the same effect. It doesn't delay at all for some reason, and I can't figure out why even after reading the API from Mozilla on setTimeout, AND it prints the 1,2,3,4,5.
These things can overlap easily. You can learn while building things, Infact that is an awesome way to learn. For example, if you want to learn full stack development, say with react, with rest services in spring backed by a noSql offering, you can build it in stages and as independent modules. Start with react front end by mocking your rest API (json-server is awesome for that) play with it till it gives you value, learn a concept and implement it. Once happy work on replacing the mock layer with spring boot and so on. Only bit of advice I can give is to achieve focus. Do not start 100 things at once. It is tiring and confusing! Do what helps you improve AND is fun for you! If you need more concrete ideas pm me your current skills and what you plan to learn and I can share my experience with you. 
Definitely worth waiting! And thanks for bringing this to theirs and communities attention! 
Differently employers and hiring managers will be looking for different things, also depends on the job you’re looking for. I have my pinned repositories as 50% work-related stuff (full stack, so currently have a small API, a React Native project, and a library I made) and 50% stuff that is more general and computer sciencey and in a few languages; C++ OpenCV motion tracking app I made when I worked as a research assistant, C# Kinect app that dresses users up in costumes, and my final dissertation project. Just started a new job and my new boss specifically mentioned a few projects so it definitely helps. Hope this helps 
LinkedIn, usually not, since I get their work history from the resume anyways and it's often difficult to find the right person on LinkedIn if for whatever reason I didn't receive a copy of the resume (you'd be surprised how common it is for different people to have the same names). With that said, I do use it on the few occasions where I need to and I'm able to find the person. Twitter, Facebook and blogs I also don't look at. They're usually too noisy or inactive, and I'm certainly not going to be reaching out to the candidate through those platforms since I already have their email and phone number at that point. I do look at portfolio if the resume lacks detail in the work experience section, but it's only a cursory look to see if it's more of a web design type of portfolio (i.e. focused more on html/css) or more geared towards engineering (i.e. web apps, which are more relevant if the position is a full stack one) and I usually ask about work experience as a first question in an interview. I'll look at personal sites, but only out of curiosity, because linking to one immediately tells me the candidate is at junior level, and I'm generally never looking for junior level candidates.
Email from author: Sure no problem. Thanks for the kind words. On Nov 20, 2017 4:47 PM, "Eliott Enos" &lt;mail@rogercollier.com&gt; wrote: Hey Roger, I just read your article - https://medium.freecodecamp.org/every-javascript-framework-tutorial-written-more-than-5-minutes-ago-f96642d4f05 - and found it hilarious! Would it be at all possible to publish on our platform and give you credit/link to original source? Very funny reading! Many Thanks, Eliott Enos https://javascript.works-hub.com/blog 
A lot of companies do this lately. - Most pay no attention to anything you already have in your site, resume, github, gitlab, wherever. You may already have similar content, but they do not want to looks at that. - Instead they'll ask for an exercise estimated at about 6-8 hours of work. The exercise is usually very similar, but _themed_ around the company's business. - Depending on the company, you at least get a review and some feedback. If they are nice people, they may even do the code review during the interview, so that you're present and can discuss or explain your decisions. On the other hand, some are... not so nice. They may have you waiting for more than three weeks and then give you two generic sentences of feedback that will make you doubt they even looked at it. (Sorry for the rant but a certain low-cost airline based in Dublin just did this to me and well, I'm frankly dismayed they would be such assholes.)
This is my favourite tech test, way better way of demonstrating what you can actually do and giving you the leeway to do it how you want over a 30 minute useless examination of how well you can solve code puzzles.
You should definitely create a pinned repository with details on how to transfer the module. In addition to that, you should have some relatively strict requirements for transfer, like having at least x amount of npm and github repos. Otherwise, this could easily be abused for distributing malware. Imagine express decides they don't want to maintain it anymore and transfer it. Someone could easily claim it, so it should only be given to accounts that have something to lose.
Feel free to help them out. Most of their stuff is completely open source and welcoming to pull requests.
Ahh, thanks! I found a json host, which I just put the text into and they gave me a link. I got one last question, then I'm all set. Can you (or anyone else) explain how I turn a regular date (such as 2017-01-01) into 1290470400000? (1290470400000 is just an example, I dont think it reflects 2017-01-01, but I think the chart I am using wants this date format, and I have no idea how to convert dates into that numberstring)
I really like Maximilian Schwarzmüller, I've taken a couple courses from him. However, this Medium article is literally just copy pasted from the Udemy course overview...not really thought provoking content is it?
Thanks for the informative reply. I have taken notes, and will be putting them to good use. I am relieved that your approach and a lot of others, aim to highlight the personality of the applicant, not just the ability. I know personality is usually a key aspect to a job interview, but as this is my first technical interview I guess I was just hung up on it. Scared all the questions and problems would be above my head haha. My opinion is that your approach seems very pragmatic. I hadn't thought about consistent commit history, that makes sense. I like how you look for basic disciplines in comments and rewrites too, and then base some interview questions off what you find. As an interviewee, it would make me feel like you put a bit of time into researching me, instead of asking the same generic questions you ask everyone else. So, do you value the quality and readability of the code over the application itself? I was a little embarrassed to upload small side projects. But I can't really think of what to work on. 
I think it's _reasonable_. But I think there are better ways. In particular there is one downside a lot of companies do not consider. The exercise they give you is nothing special, but still requires a fair amount of work (in hours). The candidates do have to put an effort into it which a lot of companies do not quite appreciate. Lately I've settled on _thinking_, on walking through solving an exercise together. We sit down together, I present you with a problem and some goals but don't ask you _to solve it_. Instead I ask you _how_ you would solve it. I ask for ideas and approaches, and I get an impression on how you think and how you approach the problem. If you already have some code that I can see and we can _also_ review it a bit and talk about it, then great. Bonus points. But as for giving you an exercise, I prefer _seeing_ how you approach it than just evaluating the final solution.
Some cool changes. I especially like them moving the packages to @babel and the optional chaining. I hope that lands in the standard.
But then, you repeat yourself.
Thanks so much for your reply. I love learning and building at the same time, but I was a little weary about uploading those projects as a lot of them are based off tutorials and I got told that's not a good idea? That would be amazing, I will PM you tomorrow :)
It doesn't, I don't believe. Or rather that it doesn't support setting a "key" for a row. But it also observes array mutations and does another bunch of fairly intelligent things around diffing and catching even in immutable cases that make it pretty damn fast though. I'm sure they Aurelia team could speak more to this though.
Definitely **always** take the time to write a good README.md. It's 50% of what they'll look at to evaluate if your project does something useful.
I think it depends on the exercise, some of them are far better than others, I think the best/evil one I've gotten so far was pretty vague about goals but I ended up putting quite a bit of work into it as they were like, be creative! Of course I got that one so, maybe I'm biased. I'm not so big on the walking through an exercise together, only because pair programming is something I can do awesomely with the right person, but I hate it to bits when I'm with the wrong person. Now amplify that by an interview environment and the wrong interviewer, and it'd go off the rails. But maybe you mean something less intense anyways... Either way, the best part of doing an exercise for me is that I can do it outside of the confines of the high stress interview environment and just get on with it. I'd argue they'd be able to show you all of that with you give them the right exercise and a solid git history. Ask them to commit fast and often so you can track their progress. You're still letting them do their job in their own environment and then afterwards you can go through the whole thing talking about why they made that choice over x choice, why x approach didn't work. 
Really? Would they be looking for how useful the project is its self or the quality of the code?
Heh. I'd never seen txti before. That's dang useful. If you just want to throw up a page with some info on it, and give people a link.... It's perfect and super handy. I wonder if google indexes those pages?
&gt; walking through an exercise together, only because **pair programming** is (emphasis mine) Oh, I didn't express myself correctly. In the interview I _don't_ have them programming at all. It's all about the approach. It's a conversation. I don't really believe in having a coding exercise during the interview for the same reasons you pointed out. But what I meant is having a conversation around the problem. Discussing how they _would_ solve it, not showing me how they _are_ solving it.
Definitely value those things over the actual purpose of the app. They are more relevant for a developer position. The idea of the app would be more relevant for a product owner or a business functional role. There is a catch though, some people may get hung up on the idea to look beyond it. To prevent against that you can try two things 1. you can straight out try to clone an existing application, especially the one you use. Building a StackOverflow clone for example. 2. You can make it absolutely nonsensical or just vanilla boring. Whatever makes the person looking at your code focus on your code. I would prefer the 1st as it is less mentally taxing! 
That's very interesting actually. So each author submits all the static files (Images, CSS, her own .JS, JSON for data, and HTML)?
Yeah, I had one of those recently actually. It's a bit tricky but it ended up turning into a general discussion about programming, which is obviously fantastic – I'd say again my only problem with it would be nervous interviewees. It think it's a good approach for seniors, who should be able to think of a dozen solutions off the top of their head along with the upsides/downsides which opens up a conversation. I don't think there's anything like a perfect solution, if anything it'd be nice to get multiple options to suit what kind of time you have available. Though I've gotten a lot more picky with what jobs I let myself get put forward for these days, so less overwhelmed with 20 tech test's to be done by this Sunday shite. (Incidentally, I have worked previously with a PO from a low-cost Dublin airline, I would avoid them like the plague after that...)
Thanks for the reply. I was thinking of doing your 1st example and doing a twitter clone or a reddit clone but I got discouraged as I thought they might assume I followed a tutorial or something. Would that matter? 
Yes if you are looping though properties of the object the you have to check if this object has the property ex: for( var item in items) { If (items.hasOwnProperty(item)){...} } 
Hi /u/Joymarty, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Medium's become a spam cesspool.
No doubt, but it's still impressive how close to native JS it is in these benchmarks. We use React at work and I wouldn't even consider suggesting we move based on these. I'm sure there are edge cases that React handles better as well. I guess my original post made it seem like Inferno &gt; React because of this, and I did not intend to imply that.
Yeah, there never is a perfect solution. Whatever works for you. The approach I use has taken me quite some time to make work. I once tried to have someone else try it and they told me they didn't like it, they couldn't make it work, so I guess it does depend a lot on the person interviewing. I _do_ make a lot of effort during the whole interview to make people comfortable so that when we get to the trickier parts it generally goes quite well. I've been on both sides and I sure as hell try to avoid the things I myself hate as a candidate. (Good to know. Thanks :) )
npm-orphanage ^^/s 
Surprised no one has asked this yet. What's the concern with having nested containers? I find react my components can be made far more performant due to nesting containers and they have fixed issues with nesting long ago.
Depends on a webhost, often times it does, when it finds it... And yeah, it's useful, for simple canvas projects.
Not sure this is the issue, but could you try: const pollTimer = window.setInterval(function() { if (this.newWindow.document.URL.indexOf('afterlaunch') !== -1) { window.clearInterval(pollTimer); this.newWindow.close(); } }, 1000); } } 
Nope. Most of us start with tutorials and books, importance is the journey of where you go from there. After all, everyone has to start some where, why not a tutorial? Don't try to just lift and shift though. 
In our case we want to reuse those top-level views that had containers for them but now we cannot, at least not without extra work. It seemed like the value of separating smart containers from dumb views is that it would allow the dumb views to be reusable with any container connected component. &amp;nbsp; But since our dumb views also import smart containers we can't really reuse them with another container or store. Instead we have to make extra containers that switch between the two containers. I would rather we had more strongly followed [drcmda](/u/drcmda)'s method of creating smart containers for parents that combine dumb children allowing for greater reusability. &amp;nbsp; In our case we're writing extra code to work around the constraints of a tool we may have used incorrectly.
I have been trying many ways to get the url through variables, document.url, and location.href, and nothing seems to work. Thanks for trying to help though. Much appreciated
Your _cookie code_, the functions you got from S.O. work fine. Your problem is here: if (currentCookie === 1) { Cookies store _strings_. They know nothing about other types. So, when you read the cookie you get either `"1"` or `"2"`, as strings, not as numbers. That comparison you have there, will never be `true`.
I did just the same thing at work a while ago (also calling it graveyard) for internal projects. It seems like a nice way to "over-deprecate" a lib :)
Didn't realize that only Python fans are excited to see what happens in the future. 
Sorry, I thought we could be mature in a subreddit about computer programming. 
ahah nice. Thanks man
Thank you so much both of you. I will look into GSAP, but for the time being, I went with a variation on Zaphoidx's advice with the following: (function () { jQuery('#drawer').hide(); jQuery('a#link').click(function () { jQuery('#drawer').toggle(function() { jQuery('a#link').hide(600); jQuery('#drawer').show(600); } ); }); } )();
I'll make it easy for you, learn both. At some point you will need both unless you want to only focus on either front-end or back-end. I've use Django and javascript together successfully in several projects. This is my favorite learning resource for python: https://learncodethehardway.org It's free and awesome. If you love it please show appreciation to the author by buying the product. 
They're probably not even going to open the files for your code to look at it. They'll notice the readme file because it loads on the project page.
They would, but if your Readme sucks they (and potential contributors/users will just leave.
Yeah definitely, I made similar points in the issue I opened in the npm repo. Of course the rules will still just be conventions and I’d prefer something less subjective eventually, but it’s a good start. Would you care to help with creating this? I could give you rights if you have a GitHub account.
Sorry, but I don't really have time right now. I'm a full-time student and work basically full-time remotely.
&gt; i do have a problem with learning more and more special template syntax Personally I also don't like the trend of custom/weird/clever syntax, but Angular does it (`&lt;div [foo]="bar"&gt;`), React does it (`&lt;&gt;&lt;/&gt;`, `...`), Vue does it (`&lt;a v-on:click.stop="foo"&gt;`)... I don't think any framework really cares about HTML purity anymore :(
[removed]
Thanks! I'll check 'em out :)
Ok, thanks! That give me something to chew on.
Getting an error: const main = async argv =&gt; { ^^^^ SyntaxError: Unexpected identifier
Another great article from a medium.com...
I like the name. Nice idea
when it's to help the compiler (as in svelte's case), it's yucky but i get it, not really other options there. when it's just to make it look like HTML but is really sugar to neutered JS, blah.
Oh shit, TypeScript with Babel sounds hella cool somehow!
Oi, I never did fully finish work on that thing, but I'm glad you were able to make use of it ;)
This statistic is a joke. It's definition of 'vulnerable' is very questionable.
Oh, it's a reusability concern, gotcha. In my opinion, this has nothing to do with nesting containers. Even if these components were commonalized, you would still likely be wrapping them in containers. I know React started out as the idea of all data flows from the top, but from a performance perspective it's far more performant to have multiple "tops". (Why re-calculate 3 parents when only a child needs re-rendered). It also doesn't really complicate the idea of "where did the data come from" either, so I really don't see a reason not to do this personallty. Typical rule we follow is to only commonalize components (unless we plan to commonalize an enture structure of reducer/component/saga/actions), and then the implementing application wraps them with a container. So for example, we may need a general "Chart" component, but how data gets fed to it could differ from app to app, or even use case to use case, so that "Chart" component might becomes 2 or 3 different components based on what's wrapping it. If refactoring your code-base to do the above isn't feasible, then I guess you could write a wrapper to convert data into an expected format and just wrap your components with that, but I really don't see why you couldn't just break apart your component and container one at a time. It's something you can easily break out into multiple phases over a period of time. I am not a fan of writing hacks to fix a problem, and I could consider fixing this any other way to be a hack. I also am not a fan of pre-emptive commonalization. I recommend you only seperate components and containers when something is expllicitly commonalized in some fashion. Having to bounce back and forth between files to get scope of what a Container's Component does is just a waste of time for no reason otherwise. I am also confused on what your use-case is for having more than 1 store or 1 app. That statement doesn't really make sense. If the context is having a component being re-used in multple applications, I don't really see how the changes anything. tl;dr: Break apart the components that need commonalized. Put the components in a common library and have the implementing application wrap them. 
Out of curiousity, hasn't node@10.0.0 pretty much covered all of the things that babel was used for? How long until babel is obsolete -- is it already?
I would like this too !
Browsers.
Elm would be in 1st for sure
All GeoJSONs are available as npm package. See the list is here: https://npmjs.com/org/geo-maps
duh, thanks.
Me three
It's still a bit bumpy, it doesn't seem to like import transforms like @babel/plugin-transform-runtime, but once it's stable, this will be so good to have!
You can’t use the official api to scrape Instagram without implementing a login flow to obtain a user access token. A couple weeks ago someone posted an unofficial api for node to make the requests you want. Shouldn’t be hard to find on github.
Glad I was able to help
Nesting containers by way of props\composition makes sense. I'm not favoring the top-down approach either and believe most of our issues could be solved through composition by passing container components down as children or props. The problem is that our dumb view .jsx files import smart containers themselves in their file definition which is the source of frustration not being able to reuse our intended-to-be-reusable view components. Nested containers are probably fine in top level views as well as those are naturally tied to a particular store context and it makes sense that their job is to import the required containers to compose the UI together in some fashion. Thus you still have your performance gains of siblings\children connected to a store but all of the dumb views can now be used independently of the store. &amp;nbsp; In the example in my original post we can't display the HeadView.jsx in a new app because it's importing EditableGuestsContainer.js instead of taking store-connected children or using EditableGuestsView.jsx. So what was meant to be a dumb view is importing another store connected component which is expecting data to be at a very specific location in the store. We avoided pre-emptive commonalization and now we can't reuse our top-level views because somewhere they import child views that import container connected views that import dumb views that import more store container connected views. &amp;nbsp; The reason we have multiple stores is not as important as the fact that the data structure these components are now meant to be used in has changed because originally they were implemented in a page where managers build one document at a time and the store had all its attributes as root props. Now we want to reuse these components for their clients in our app who will be looking at several documents at a time. In which case the store data paths those containers were originally pointing to no longer apply. Like from `store.getState().guests` to `store.getState().docs[xxx].guests`. &amp;nbsp; I am trying to build a case for refactoring those components in the codebase by demonstrating that this is a problem we have created for ourselves that the community at large has avoided (or learned to avoid) by using a better architectural approach. &amp;nbsp; Does that help clarify my issue? I think we're in agreement on not pre-factoring for possible reusability and not using a full top-down approach. I appreciate your insight and am enjoying discussing these concerns and seeing how others like yourself think of and approach store organization. 
React is really intuitive with its special syntax, and you don’t have to use it. It’s just a convenience. Angular is ridiculously bad with its special syntax.
A lot of the big js framework/library tutorials on udemy cover these. One I can recall of the top of my head is the react course from Andrew Mead. It talks about es6, react, Babel, webpack, redux and firebase (I may be missing some stuff). The way it’s put together helps make it easier to understand. Basically he gets you to a point where you sort of hit a dead end and then shows you a new tool to help you get through the obstacle. Udemy courses as I’m sure you know go on sale to $10 all the time. Definitely worth it. 
It’s done to prevent version conflicts across multiple projects. You can have one project with SweetJSLib v1.0.0 and another with the completely incompatible SweetJSLib v2.0.0. The python community often uses virtual environments to isolate dependencies.
&gt; interview The exercice asked where I'm working is that one : https://github.com/sandromancuso/Bank-kata There is no real solution but the one implemented in that repo is relatively good (even though it's java and not javascript ^^) You can try to do it on your own. If you want a code review, don't hesitate to ask, I think there is a subreddit for it and a stackexchange too :) If I find a candidate that has other projects on its github (which is not very common) I take a look at the most recent ones to see how the guy works outside an exercise :) btw if you want exercises, that website can help : http://codingdojo.org/kata/
OP wants to know how to structure their code, not how to work with some &lt;framework/library name here&gt;. Frameworks can give you an idea about the final outcome, but they abstract way too much and hide the gritty details so you won't have to deal with them. 
Blame it on the mindset that "you should blog about anything, all the time! Even if you're just learning something, write a post about it!" So now we have tons of low effort articles that don't matter.
But you learn exactly this in a lot of those courses. 
Hi, thanks for the reply! I've done a lot of searching for this "unofficial node api" you speak of, but I can't find it. Can you please post or DM a link. 
 Oh yea, this is problem a problem in the cpan and other worlds, but not a problem with ruby because bundler can monkey with the inc paths before the scripts import anything.
Agreed, programming during in interview is not the best environment. You often look for something dumb you forgot on google when you are alone but during an interview you can't do that :) Our job is mainly communication. Majority of people you encounter can talk to a computer. But very few can also talk to real people (that's really hard for me too) When your working in a team that the main thing you are looking for, so for me the interview is mainly a conversation. We can use the exercise to start the conversation or something else if the candidate want to talk about something else. For the exercise, no need to ask for something convoluted : the first week of the [FooBarQix](https://github.com/arolla/Craft_Your_Skills/tree/master/FooBarQix) is more than what I need to evaluate someone and initiate a conversation
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [arolla/Craft_Your_Skills/.../**FooBarQix** (master → fa96542)](https://github.com/arolla/Craft_Your_Skills/tree/fa96542a68e2b82ef6332cd74b85f68d16eec9d4/FooBarQix) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
Framework/library-specific courses teach you what you need to know about that framework or library. Sure, they add state management (which adds another library) but the combination of the two is destructive in the long run, especially to young/inexperienced developers. Soon enough, you get people who call themselves 'Angular developers', 'React developers', forgetting about the fact that they are first and foremost *JavaScript* developers, and not restricted to only one of its who-knows-how-many libraries. 
Honestly, those don't bother me that much. They can be annoying, but the author is usually earnestly trying, and learning. In time, they should improve. My beef with Medium is that they allow blatant blogspam (like this post), which uses a url-shortener to link to the product so as to hide it from any sort of automated detection. On top of that, they've started allowing blind redirects -- e.g. you click on `not-a-spam-site.medium.com` and it instantly redirects you to `spam-site.com`.
"Intuitive" is subjective. I think Vue syntax is intuitive, but it's still weirdly magical as far as regular HTML goes.
That’s fair enough but how do you learn more advanced topics without a project to learn them with? There’s also a ‘build your own react’ course. Maybe that would have been a more appropriate suggestion. 
If you're running into issues with the beta, please make sure to let us know! I'm not aware of any outstanding import-related issues.
Just a general reminder here, if you're using the beta, be 100% sure you've got a lock file and you're using matching versions of the various Babel plugins/presets, since we're not guaranteeing compatibility between the betas. If you're using Babel through integrations with other tools, there's still some hoops to jump through to get it all to fit together, since you can't have a `.babelrc` that works on _both_ Babel 6 and Babel 7. If you run into any obvious bugs, please do let us know.
I'm fairly certain that OP is asking for a vanilla solution on purpose. I agree that some concepts are more easily learned through using high-level APIs and tools, but OP clearly says that that's not what they're looking for.
https://www.reddit.com/r/javascript/comments/7cxz0u/a_proxy_api_for_instagrams_public_data_works
The readability is not the best. You have to understand quite well how "this" works in javascript to understand that piece of code. And I don't think that piece of code solves the problem that you still can access to MyClass.baz which is public. When you make private scope, it is to protect your internal data model and avoid exposing it to other classes. So when you want to change your internal representation, you don't have to change code elsewhere.
&gt; JS on the backend can cause a lot of frustration because the ecosystem is changing so rapidly. Express is pretty stable. I'm not sure i'd agree with this as a reason to choose python. Then again i wouldnt use python for anything, so im biased.
I'd say it is a method that takes state as a parameter, (if you uncurry the function) rather than state with a method. I guess this is just splitting semantic hairs though as the end result is the same just from different perspectives. I prefer the functional approach as it's easier to plug in different values, but the same can be achieved with interfaces and dependency injection (which is cool but a bit too magical for my tastes usually...). There's a happy medium between functional and oop imperative and I think JS is positioned in the best place for it tbh!
Based on other comments in the thread, a few points that are kinda confusing for new developers. There is JSON and then there are JavaScript objects. The two can (usually) be converted from one to the other, but they are *very* different thing. JSON is a string -- it's a value that comes from somewhere. Sometimes a call to a web server, sometimes loaded from a file. JavaScript objects are *in* the code themselves. (The reason JSON and JavaScript objects look so similar is because JSON is *based* off JavaScript syntax. JSON stands for *J*ava*S*cript*O*bject*N*otation.) 
&gt; At some point you will need both unless you want to only focus on either front-end or back-end. Why is that?
Django is 5 years older than Express, so you have it backwards. 
* scope * dom * events * asynchronous vs synchronous Know those concepts with confidence and you will probably be fine.
Should make a repo for posting issues/requests/etc
Finally a comment! Thank you. I feel like I have a basic grasp on those topics, hopefully it shouldn't be anything too crazy. Will definitely be reviewing these. Thanks again
Who woulda thought jQuery, the most popular JS _dom_ library is used on a lot of sites.
Ok, thanks for this reference, I'll check it out. Here's the thing: I'm not trying to be library-free just to say so. The issue is that that each library or is it's own challenging learning curve, and I've only got so many hours/brain cells. Think of this like how you would recommend books for an average Middle-school student. I know how to read, but I need practice. I'm ready for the Harry Potter of Javascript, not the Shakespeare.
Do you have sort of a narrowed in idea of what it is you are trying to learn? Even if it’s concept wise. I think I could maybe help a little more from there. 
nom-adopt
oh, npm-orphanage then.
Sure: modules. Say, an app which uses "the module pattern." (No Node, No Webpack...) Or maybe it's more relevant to your question to mention that I'm working with the WebAudio API... Thanks!
I don't see how JSX is confusing if you're familiar with HTML. It's not doing weird black magic like Angular, where you have to know a huge API and tons of your logic is encapsulated horribly in HTML.
Check out spi http://www.spi-inc.org/
yes thank you!
Thanks so much for your help
Get at least a basic understanding of Big O notation. They won't expect you to code a binary search algorithm from memory for an entry level position, but they may give you an algorithm challenge that's easy to solve with nested loops (O(N^2)) when it'd be more efficient to use two separate loops (O(N)) or something else entirely. Big O, algorithms and data structures are intimidating, but just practice, practice, practice. They're hard for everyone, even your interviewers. If you can get comfortable with at least a few, they'll be impressed. Also, brush up on event bubbling/event delegation, and the basic DOM API methods. The MDN is a great guide. Don't worry about not knowing the trendy frameworks. They'll be satisfied if you can demonstrate strong knowledge of JavaScript alone. If you can code an app with plain JavaScript, they know you'll have no trouble learning any framework. React, Vue, Angular and the rest just offer patterns and a paradigm for different styles of building SPA's. They're still JavaScript applications. Lastly, just show your enthusiasm and willingness to learn and take on any challenge. They'll be rooting for your success, even if they don't show it. Even if you think you're bombing a technical challenge, just give it your very best shot and stay positive. They care a lot more about how you approach hard problems and working with others then your ability to complete an on-the-spot coding challenge perfectly. 
Hi, the tool support node &gt; 7.6 now. Could you upgrade your node in your machine?
I have just published a new version, added the click to copy feature. I m still working on improving styles though :)
This article is great. Any project not following all of these need to seriously stop what they’re doing and get on board.
Im looking for something like this also. I have an app in production that uses elixir as backend and vanilla js for the frontend. I have never been a js developer, but Im trying to understand what are the architectures that best fit frontend development, everywhere I look is always some js framework with lots of dependencies and libraries and each with many many many ways of doing things, that can be really confusing.. As my architecture right now, I created a View -&gt; component -&gt; connection kind of arch.... Which Im not happy right now because I linked the component directly with the data source and now its a little bit more work if I want to change where I get the data from that component. So maybe something like: -&gt; Data View -&gt; -&gt; Component ?? 
This is perfect advice, thanks a million. My knowledge of Big O notation is just my memory from my algorithms class a few years back, but I got an A in that class and it all seemed to make sense to me. I feel like I have a very good fundamental knowledge of data structures and algorithms, I think I'm more worried about Javascript specific problems. I mean, in my work experience I was basically using the same snippets of Javascript over and over and I didn't have to go too deep into it. I'm now beginning to learn I've just scratched the surface with it and having a little paranoia I'm a little over my head applying for a "real" Javascript developer job. I am a very quick learner and have no doubt I can catch on and get caught up really quick, I just kinda hope they'll give me a chance with only my basic Javascript knowledge. 
Using babel ts preset gives speed advantage? Like, with happypack to static check ts in a thread and then babel in another?
I am still new to node but I think you can install packages globally with the -g flag?
&gt; I don't see how JSX is confusing Sure, that's because we know how JSX works. I'm talking about people who primarily do Go or Java or some other language. JSX is confusing in the same way it would be confusing if you're used to `fetch` and someone suddenly tells you that `[select * from foo f join bar b on f.id = b.id].map(doStuff)` is how you're supposed to do data fetching now, oh-and-btw-you-need-to-install-flooberstalsky-but-its-easier-to-just-use-create-jql-app, oh-and-btw-theres-an-api-to-optimize-the-query-that-you-may-want-to-learn.
Babel's `ts` preset is just for parsing TS and removing the types so that you get normal JS code. It doesn't do typechecking. The intention is that you can use Typescript for type checking, but then still use Babel to do whatever cool transformations you want to do.
I think you've got a catch-22 on your hands, which is why you're having trouble finding an intermediate vanillajs app. You don't want to learn frameworks because of time and braincells, but you're trying to build an intermediate level app with vanillajs... The problem is that if you're trying to save time, but your app is sophisticated enough that it requires intermediate architecture, you're going to burn a lot more time and energy using vanillajs than a framework. It's not like the backend where you can use the most basic server and build out a sophisticated app. The frontend is just way more dependent on these technologies. No one building an intermediate front-end application is using vanillajs, and if they are, they'll have build enough custom code to pass off as their own framework. That being said, you might what to try looking through my website, https://menternship.org where experienced developers enlist volunteer interns to work on their projects. You night find someone with a vanillajs app there that you could collaborate with.
There are always going to be new things on the horizon, so babel will always be relevant as long the language continues to evolve
Promises 
Yeah, I learned React and JS after only doing C# and Java. It made complete sense to me, and it's not hard at all if you understand XML and HTML. JSX is really easy. Your counter-example is not really relevant.
Like promising to show up every day on time, and stuff like that? Jk, thanks for the suggestion, I hadnt really thought of that topic, or know too much about it. I'll review it tonight
What kind of stuff do you want to make? You mentioned games, but game architecture is totally different from something like a single page web app although there is some overlap of course.
 I haven't watched this yet, so apologies if it isn't what you are looking for: https://frontendmasters.com/courses/organizing-javascript/
Again, it's not about you or I think is easy. I think functors are easy, and I'm sure you do too, but it's also true that there are people that struggle with them. I'm telling you that when I say people get confused by JSX, that's actual feedback I heard directly from these people.
Honestly, if people are getting confused by JSX, then that's the least of their problems.
So you need an event handler, which one is on you. You can use onblur which will trigger when the user switches focus off the element, you can use onsubmit on the form and get all the inputs by name and validate from there. I’d recommend checking out mdn to see what you have available. So now that you’re listening for the event, you need to do something with it. The event handler will take two things, the name of the event and a callback, which gets passed to it an event object. There’s a property on the object called target. Target holds the amongst other things the value of the input. As you might of guessed, value is a property on target, which means in the call back, you can get access to the value of the input via event.target.value. From there you run a Regex test on that value and then what you do from there is up to you. Some options are display some error message, add a class to the input so the border is red, the world is your oyster. Hope that helps. Happy hacking.
I don’t know if this helps but I’d recommend checking out [clean code](https://github.com/ryanmcdermott/clean-code-javascript/blob/master/README.md#variables) 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ryanmcdermott/clean-code-javascript/.../**README.md#variables** (master → 6741e85)](https://github.com/ryanmcdermott/clean-code-javascript/blob/6741e85ebf1b6d23a95ff88e4919d905674a12a3/README.md#variables) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
I would not add that feature. Most people know how to copy paste I think.
Not a magic bullet but these helped me: * Study the structure of big popular open source projects like lodash or JQuery that have been around for awhile, learn how they structure and organize their code and borrow from it. * A book like [Clean Architecture](https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164) might help too. * Understand how JavaScript works under the hood and computers in general so you have a better understanding of the whole system, this involves learning low level documentation. * Get really good with OOP. * Code-&gt;Refactor-&gt;Code-&gt;Refactor, apply and reiterate all the stuff you've learned and see if it works. 
My own projects are using the WebAudio API to for in-browser music apps.
Sounds like Ruby does essentially the same thing as [WinSxS](https://en.wikipedia.org/wiki/Side-by-side_assembly) where it stores multiple versions of the same libraries globally. This might seem like it saves space, but consider how often you stop using a Ruby program, or update it, or update the dependencies of your code. Each time you do this some of the libraries you have installed might become orphaned (i.e. they're still installed but no programs depend on them). Over time you'll accumulate tons of orphaned libraries but you don't know which are orphaned, so it's hard to clean up. You'd have to delete your gems and re-install every Ruby program on your machine. The way NPM does it might seem like it wastes space, but you'll never have space taken up by libraries that aren't needed. I'd rather have a little more space taken up by libraries I need than a lot of space taken up by libraries I don't need. Also you're free to install packages globally with NPM using the `-g` flag. If lots of projects on your machine use the same packages this might make sense.
Tests. Too many times we look at a candidate with 10 projects with no tests. Instant pass for me. It’s a sign they don’t know how to manage a large codebase or work with a team. 
[removed]
This is some scare tactics sales bullshit.
Thanks, that's helpful. 
I'm not an experienced hiring manager or anything but one dev to another I skim for passion and improvement when I'm interviewing someone. If I know a language you have I'll look to see that you know some best practices (ie not every repo looks like the software gore sub). Mainly I just like to see that interviewees do stuff. Take on a project and improve it. Pick something up for fun and tinker. Hopefully that helps, though I'm not the ideal person to answer you. :) 
I know exactly what OP is looking for - it's not a catch 22 at all. I've worked in a number of places where they used jQuery on the backend, and other small libraries to fulfill specific needs. What he wants is something that describes breaking code into modules and organizing a midsized js project. I honestly think this is really important to know outside of a framework - too many people follow the boilerplate of react/Angular projects and never really understand how things are working at a more detailed level...which is exactly the problem OP is trying to solve.
Thanks for the input man 
There is a talk from Nicholas Zakas, now a bit old but still good, on architecture that you might like. This one https://youtu.be/vXjVFPosQHw It's a general talk on scalable architecture from the days when he was working at Yahoo. It presents a general approach and structure, not tied to any library. Note that it *is* a bit old, but I think it's still interesting. He has a couple more on maintainable code that may also be interesting. Besides that, you might want to look for references *outside* JavaScript. Ideas on application organization are, in part, not that dependent on the language, and you mau find more and better help.out there. ---- In a very different way, there's a quite excellent series of minivideos at egghead.io from the author of Cycle.js... Wait, wait, more than focusing on using Cycle, he shows how one person could _“arrive at Cycle”_. That is, he shows how you would sort of _build your Cycle-like structure_. It is still particular to the approach chosen by Cycle, but it's still fun to watch. ---- None of these will strictly answer your question, I'm afraid. But at least they should give you some ideas. 
[removed]
That makes sense, thank you for the explanation.
check out this code (my portfolio website) - https://github.com/asapzacy/zac.codes - nothing crazy, but definitely in that intermediate js range. it's a static single-page app, built 100% in vanilla js, handlebars, scss, gulp, etc + hosted on a digitalocean droplet running ubuntu/nginx/node. I love react/webpack/babel/css modules/etc., but this project really taught me the basics on DOM manipulation and vanilla javascript.
I certainly hope they weren't using jQuery on the backend ;). 
D'oh
https://www.amazon.com/JavaScript-Patterns-Better-Applications-Coding/dp/0596806752/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1511332535&amp;sr=1-1&amp;keywords=javascript+design+patterns
I've used it for some small personal projects along with TypeORM and so far so good, it works very nicely.
 Bean.prototype = Legume.prototype; &amp;nbsp; That line assigns a pointer to `Bean.prototype` which points to `Legume.prototype`. Essentially you are creating an alias to `Legume.prototype` so that now whenever you reference `Bean.prototype`, you're actually working on `Legume.prototype`. Like a shortcut or a link. In this case, you're actually modifying `Legume.prototype` via writing `Bean.prototype` and that's why you see the change when you `console.log()` `Legume.prototype`. &amp;nbsp; Bean.prototype = new Legume(); &amp;nbsp; `new Legume()` creates a new *instance* of a Legume. Think of `function Legume()` as a description of what a `Legume` is, and an *instance* of a `Legume` as being an actual unique copy of `Legume` created whenever you write `new Legume()`. Now when you reference `Bean.prototype` you'll be working on this *instance* of `Legume` that you just created. In this case, you're modifying the *instance* of a `Legume` that you created by writing `new Legume()`. This does not modify `Legume.prototype` at all, which is why you don't see any change when you `console.log` `Legume.prototype`.
No, it doesn't yet. There is still draft spec changes... of note: - async generators (behind flag in 9/10), - class properties - pipeline syntax - observables - Promise.try - optional chaining That's not a definitive list by any means. Take a look at http://node.green - at the bottom of the page. In short, as long as people put forward proposals to the node TC, and these proposals get approval &amp; move forward, there's always going to be new syntax / methods that engines haven't implemented yet.
What happens when the module comes back? Resurrection ? 
An issue exists: https://github.com/babel/babel/issues/6093#issuecomment-322944634 but it seems to be a little obscure this time, been waiting for it since the beta program started. Otherwise the beta ran very smooth. :-)
https://pnpm.js.org/ pnpm installs globally and creates symlinks locally. Although the symlink format doesn't follow npm's flat layout, so a few packages break when installed with pnpm.
Doesn't the name graveyard suggest nobody will be taking over? If you want people to take over maintenance, I think you should name it differently. If it is where you expect NPM modules to die, than its fine.
The concepts, structure used are so far from idiomatic Javascript. Tends to make the whole code a lot more complex than it could be.
2 recommendations. Avoid Clean Architecture at all cost. Get really good with functional concepts. Function in Javascript is first class citizen. It is what gives it his power. There are bad parts to Javascript but functions are its main good part.
I have written in this part which is uncorrect; myMusic[1] =[ {"artist": "Micheal Jackson", "title": "Bad", "release_year": 1987, "formats": [ "CS", "8T", "LP" ], "gold": true } ];
If your using an auto checker like a web training app, and position zero (Billy Joel) is indeed acceptable, then it is likely being thrown off by Michael Jackson’s name, because the code appears identical. It’s currently put in as “Micheal,” when the correct spelling is “Michael”
Smart! I'll definitely bookmark the site, and check for interesting projects. And also, if any projects of my own gets the boot, I'll be sure to use the graveyard :)
I love this video series, my coding improved immediately and I was able to design my own components from vanilla JS that felt polished and testable: https://www.pluralsight.com/courses/javascript-practical-design-patterns
Way I learned how is by writing my code, and rewrite it in better ways often. Sadly that leads to a lot of dead projects.
IMHO Second approach is more appealing because you will have two separate project and in any timne you can replace backend or frontend without touching counterpart. IMHO this is big win.
Print doesn't print the whole sheet
Complexity isn't inherently bad. Sometimes complexity up front on the easy stuff makes the harder stuff itself easier. I haven't used this library so I'm not talking about it specifically. Just saying that just because something might have up front complexity doesn't mean it doesn't have benefits down the road. Redux is a good example of this. Easy things get a bit harder. Hard things get a lot easier.
It's not useful to me, but I'm happy that you ask newbies to learn *JavaScript* before anything else, like Node.js, jQuery and etc, as in, how *language* works, not how to use *libraries*.
A rule of thumb is to start and use simple easy to read and maintain codebase. Abstractions add inherently complexity and increase the surface of code to maintain. Keep things simple is good programming practice because it always esay to create complexity in particular as time goes. I consider Redux simple. Its flow actually makes sense to me. However I would not use Redux unless I need global state management. Following a template like MVC, Flux for all our code doesn't make our code better in any way. It does show however that we blindly follow a recipe without considering the value of why we are doing it.
Yeah definitely, I think the consensus for now is that npm-orphanage is a better name. &gt; If it is where you expect NPM modules to die, than its fine. Oh no, the opposite. The idea is to aid with discoverability of unmaintained npm modules.
Yup
Yeah definitely. I can add you as a member if you want!
100% correct. This is not implemented yet 
`=REGEXEXTRACT(concatenate(IMPORTDATA(E1)),"biography: ""(.*)""full_name")` Did you even read the accepted answer?
&gt; myMusic[1] should be an object You are making myMusic[1] another array by including the single brackets again( [] ) Try replacing with &gt;myMusic[1] ={"artist": "Micheal Jackson", "title": "Bad", "release_year": 1987, "formats": [ "CS", "8T", "LP" ], "gold": true };
I agree with a lot of what you said but I don't agree that you should always start simple. If you design beforehand and have done similar stuff before you often know where upfront complexity is going to pay off in the long run. And often it's easier to accept added complexity upfront and design with it in mind than it is to have to refactor later because your initial design didn't cover what the design encompassed. And redux isn't that complicated once you understand it but it is certainly way more complex up front than just handling state locally and mutating it as needed. It scales better but it definitely adds complexity.
So, now the problem is that the whole item seems clickable, when only the command is clickable.
Perfect! thank you! 
Then you have to ask yourself why it's not correct. Your first problem is that you're using recursion when it complicates the problem, instead of making it easier. So what I get from the problem, is that you need to "slide down" through a sum of numbers with highest possible result. So, algorithm: * We have to go through each array only once, so we iterate over the structure. * The path must be the longest, therefore we should pick highest number from a row. * The path must also be a *slide*, not just random jumps, therefore second point is narrowed down to *highest number in a lower level between current element index and two neighbours*; * Once you find biggest number that matches second and third points, you simply add it to the sum. I don't know whether I should do this, but this is solution in JS: function longestSlideDown(pyramid) { var pathLength = pyramid[0][0]; // will always be first element var prev = 0; // index of element in previous row for(let i = 1; i &lt; pyramid.length; i++) { var max = prev; if(pyramid[i][prev-1]) { // check left if possible if(pyramid[i][max] &lt; pyramid[i][prev-1]) { max = prev-1; // we go to left if possible } } if(pyramid[i][prev+1]) { // check right if possible if(pyramid[i][max] &lt; pyramid[i][prev+1]) { max = prev+1; // we go to right if middle/left is less than right } } pathLength += pyramid[i][max]; // add the number to the path prev = max; // previous index } return pathLength; }
Chrome debugging tools is probably your best bet. Check out their memory profiler, running that for an hour might be overkill, but it should give you an indication of where you might be leaking something (which this sounds like the issue is).
Hi /u/neggir, I'm removing this post as this is not related to JavaScript, and should be something that the game provider should handle for you.
Given that under the hood nest.js uses express as web application framework, I would say that one could always go and do things outside of nest scope and simply use express. But that just simply beats the purpose of using this framework at all. I found that nest.js doesn't neccesaraly have to be used from the very beggining, instead if you outgrow your express application and find difficulties maintaining it, you could switch and migrate your code quite easily to nest.js However, for me there are some things that looks to require too much of a boilerplate code, but I'm not worried about it, I actually like the clear application structure that nest.js provides and even in a small application that's not a big problem. Also nest.js doesn't break if you decide to use your service as a default import rather than creating a service which should be injected and so on.. so there are many places where you can use basics of nest but skip other parts until you feel need for them..
ELI5 why I would use TypeScript with Babel? Does the TS compiler not do the same things? 
I agree with it, mostly. Linting is useless and annoying though. In JS, at runtime you get errors that are very descriptive about common problems regardless. If you can't figure out where you misspelled a function name in your code from an error message then you should consider getting your shit together or simply doing something simpler.
Demo: https://denisraslov.github.io/grid/
Another good way to improve your JavaScript is by joining my Front-End Slack community (currently 500+ members). Drop your problems here and create a discussion with Developers from all different levels--&gt; www.frontenddudes.com
I’ve searched and can’t find anything. Thought somebody here could tell me what the problem might be, so i can solve it myself instead of going through the hassle of contacting whoever made the game. I believe it is related to JavaScript though, so if you could tell me why you think it isn’t, that would be helpful. You literally just shut me down without explaining anything.
Where do I sign up for that? ;D
I'm sorry if you feel shutdown, but you are having an error with a product that happens to be using JavaScript, but it might have been a completely different language it was using. Since it's a game you're playing and not developing, you can't modify the source code, or at least I presume not, and thus, even if we could help you in here, you would anyway have to go to the game provider to get this bug fixed. Looking at your error, it would seem that for some reason Bugsnag, a bug reporting library for developers, is not loaded. This could possibly be due to you having some kind of blocking extension in your browser, or what do I know. But we're not a "throw some error out and get everything fixed for you"-community, which was why I shut you down.
Thanks, now I get it :) you're a real hero for making this API, I've been needing something like this for a long time. I had an app I made that made calls to instagrams API but after instagram changed their API and implemented a bunch of restrictions the app I made got useless.
[coroutines.js](https://github.com/divs1210/coroutines.js) Heavily inspired by core.async - allows creation of coroutines and channel-based communication b/w them.
&gt; Avoid Clean Architecture at all cost Why? 
I don't think I can help you much but... The first error is _normal_. You don't have anything defined to be served at `/` so, if you try to load that, it should throw that error. For the second error, which is the actual problem, you may try: I assume `192.168.1.123` is the IP address of the camera, right? And the URL is correct. I mean, can you actually access `http://***:***@192.168.1.123:8080/stream/video/mjpeg` and get something in your browser? Or try to open it with VLC and see if it can play it or if it returns any errors. Is your password Base64 encoded or plain text? If all that is indeed working, you can try and use a lower resolution from the camera. This sometimes helps. If all else is ok and it still fails, I'm afraid you'd have to debug through the MjpegProxy to actually see what is going wrong.
It sounds like you're probably adding an infinite amount of content to the page, perhaps invisibly as new script or style tags, or just other dom elements may be hidden afterwards. It's also possible that you're creating an array and filling it forever, taking up huge amounts of memory... And then iterating over that array would take longer and longer, making the page get slower over time. As /r/TheNumberOneCulprit said, chrome debugging can help with figuring out what's actually happening, but those are some suggestions for possible problems.
This changes things, and I wish you would have contacted us in the mod team with this info before posting, as we're otherwise operating in the dark when it comes to determining whether something is content stealing or has permissions from the original author. I'm sorry your post was unfairly removed in this case. 
Thank you very much
I haven't read the book but it may be that object oriented clean best practices done adapt super well to traditional is? Not sure. Es6 is bringing in object oriented js in a big way but for now you'll need transpilers to use it in production.
https://plainjs.com/javascript/ajax/send-ajax-get-and-post-requests-47/
&gt; like Node.js, jQuery and etc Node is a runtime, not a library.
On each create ajax call, 44 empty divs are added to the body. May this create a serious performance penalty? I tested locally and with 10 000 empty divs the website was working ok, but with 100 000 it was very slow.
It's javascript + it's own things, I don't care.
Well did you report an issue then?
I'm not sure if this is relevant to your question, but one great way to achieve more 'well-organised code' in JavaScript would be to make use of [standard JavaScript modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import). They will eventually be implemented in all browsers, but in the meantime a build tool is needed, like Webpack or TypeScript. In my experience, it's worth taking the plunge into such tools to start using this fantastic new standard. Also, again I'm not sure if this is relevant to your question, but if you are put off by the scale or opinionated nature of many JavaScript frontend frameworks, I recommend checking out [Svelte](https://svelte.technology/guide). It's pretty minimalist and largely unopinionated. You might like it.
The point of linting is to catch small problems before runtime. In the long run, this saves time. Using a tool to speed up your workflow does not make someone unqualified to be a programmer.
Hard to find a problem when I don't really know what algorithm the author used to test it. Also it's just my interpretation of what I am supposed to do as it isn't really clear (as if it's ever clear, nobody fucking wants what the fuck they know for fuck sake). So no.
the browser is javascript + its own things. they're both implementations of ECMAScript with their own APIs. The only reason I mention it is that it's equally valid and arguably better to learn JS in node working with the filesystem than it is to learn JS in the browser.
Yes it does, if you bothered to read what I actually typed. There's nothing wrong with speeding things up, without hurting the project.
That's exactly your problem, yeah. Do you really need them? Can you avoid them, or delete them afterwards?
Except it's not. Because to work with the filesystem I'd use a proper language.
Awesome! I have some future plans that will need something just like this. Starred for later.
Won't even load for me. I get multiple unresponsive script warnings. FF 53 on Linux. 
Node is a runtime, but... Because Node has built-in modules like the file system, http, stream, and url modules, for example, you can refer to learning its library just as much as any other library.
I don't think that you need transpilers at all*. Although I agree that JavaScript is good for functional programming, I think it is a mistake to hate on either OOP or functional programming. Also, Martin's books are usually really, really good. Therefore, I think it's not good advice to "[a]void [it] at all cost". (*Although OOP is much more enjoyable with TypeScript, if you ask me :) )
If the point was the learn working with the filesystem I'd agree, but the point was to learn JS so your argument doesn't apply to the topic of discussion. Working with the filesystem in node is functionally no different than doing it in Python or C. Regarding typing, I'd recommend you'll read the spec. In 10 years of working in JS, I've never once had a bug that occurred as a result of me trying to increment an array. If you want a language that will scream at you for doing incredibly stupid things, JS is not for you. Try /r/cpp.
Here's a sneak peek of /r/cpp using the [top posts](https://np.reddit.com/r/cpp/top/?sort=top&amp;t=year) of the year! \#1: [I just found a use for the poop emoji in C++](https://np.reddit.com/r/cpp/comments/75gohf/i_just_found_a_use_for_the_poop_emoji_in_c/) \#2: [C++17 is formally approved](https://herbsutter.com/2017/09/06/c17-is-formally-approved/) | [97 comments](https://np.reddit.com/r/cpp/comments/6yjerb/c17_is_formally_approved/) \#3: [Bjarne Stroustrup awarded 2017 Faraday Medal](https://www.cs.columbia.edu/2017/bjarne-stroustrup-awarded-2017-faraday-medal/) | [23 comments](https://np.reddit.com/r/cpp/comments/72gxkw/bjarne_stroustrup_awarded_2017_faraday_medal/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
Oh okay, I get it, you think that JS can be used everywhere. Also, you use JS in browsers *clientside*, on server you use *proper languages*, there's no reason to learn using node.js, when you won't even ever (in your right mind) try to use JS for anything that isn't clientside on the fucking browser. For example, Discord team wrote client using Javascript (Electron), but even they weren't stupid enough to use it on their servers.
The browser has built-in modules like window, document, location, XMLHttpRequest, etc. It just sticks them all on the global object rather than putting them in modules...because it doesn't have modules. Hence my point, if you're going to learn JS. Maybe learn it in an environment that is designed with developers in mind instead of one that's a Frankenstein's monster of backwards compatibility concerns and failed or failing specs/conventions that are no longer relevant to modern JS development.
I'm wondering if this is the same guy I watched a plutalsight class on regarding clean coding. It was really helpful when taken as language agnostic.
I get that your feelings are hurt because I corrected you, but now you're just going off the rails. I didn't even suggest people should "learn node.js". I suggested they learn javascript in the node runtime. Just as an FYI: Plenty of companies use JS on the server. Netflix, Uber, Paypal, Medium, etc. etc. I'm sure you can explain to me why the solutions architects at those companies are totally wrong and should be using x, but might as well save yourself the keystrokes; you've done enough here to demonstrate your unquestionable authority on the subject.
React orphanage could work. All the projects are up for adoption and need some love and care.
Good, so you agree that linters are valuable tools.
It's fine. Don't overcomplicate things. &gt; Moving them all to a separate helper module wouldn't really change anything (the module will become the god object in this case). I would still do this for the sake of maintainability even if the resulting architecture is not better.
You can use [fetch](https://github.github.io/fetch/) to do the POST request to a fake API like [reqres](https://reqres.in/). It has a login endpoint.
Unless they develop node for backend, JS will only help if you're doing frontend stuff. Django and Flask are more widely used for backend.
Express is good, but it's EcmaScript and all of the compilation/tooling that can get confusing
The development-style is the only thing I hate about angular2.
their library is very slow. they should be using virtual tables, if they aren't. Either way it's dog slow on scrolling.
You don't have to use a framework to study a framework. Frameworks are exactly what you are looking for. Structure for applications. Now if you want to be framework free, you could have plenty of reasons but know that in the end, you build your own framework. You are never frameworkless. Now building your own will launch you in many pitfalls and its ok if you want to learn the real reasons for your actions. I don't have a clean application to show you but i can tell you what mine are build, i use Mobx I think the way to think about bigger applications is 2 things : Separation of concerns and Standards. In my applications i have : * **Views** : Display informations, no logic beside maybe conditionnal display but no request, no data transformation at all. very important. Views only read data * **Actions** : Logic of a command, this has no actual implementation but only overview of what is happening, it calls functions in a understandable flow. * **Services** : Actual code implementations, called by Actions, this is where you do big data processing, ajax requests, * **Stores** : Data resulting from actions and services, all domain data should be in stores, nowhere else, single source of truth at all time. * **Utils** : Your weird code that does re-usable manipulations but are not attached to a domain like services (ie debounce) Some concept that will help you along is **Pure Function**, Try to have has many pure functions as you can, that is a function that operate on NOTHING else than its parameters. This will help you create understandable flow for you won't have to keep the entire state of your app in mind, you'll know some part will forever react the same way. Now go ahead and do your thing !
You are misinformed.
This was true 2-3 years ago, but there are really only a few viable options these days. gulp/webpack paired with babel/typescript. Python is just too damn slow to be taken seriously as a backend for anything more than hobby projects. Once you are paying for servers and bandwidth you simply cant accept your backend framework performing so poorly.
192.168.1.123 is the Camera. and Using the Base64 encoded password I am able to access the webstream at that address. Unfortunately the camera is a "dumb" ip camera. There's no way to change the stream settings. How can I debug through the mjpeg proxy?
yes
If you're finding a lot of PHP on SO you should probably look for XHR / XML Http Request instead. This is the total vanilla way of doing Ajax requests in JS. However, as /u/vonpapen mentioned you can use a library like [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) or [axios](https://www.npmjs.com/package/axios) to reduce your syntax significantly (and show that you're into staying up to date - but don't skip over the basics just because these are an easy way out). Heck, if you were going to use jQuery anyway for the site (for dom manipulations and whatnot), that also has a pretty easy-to-use [.ajax](http://api.jquery.com/jquery.ajax/) command. Remember not to miss the keyword **post** in the description you gave us. Technically you could do a user login with a HTTP GET-request, but this can have major security implications (i know, not in this excercise, but it shows that you are aware), so make sure you use the HTTP POST-method instead.
thanks fixed the link
I just went through the same process as you! Never really interviewed - was always hired based on reccomendations and network, but I just moved to the US (I'm from Denmark) and had to start from scratch here, and claw my way into the market without any network. Fast forward, I just got a job offer a few weeks ago. GitHub came up in my interview by their lead developer, who liked to see passion from my activity and what kind of projects I liked working on in my spare time (sure, they won't go through every line, but descriptive titles and readme's will go a long way). Since this was for a React-position they probably looked for some projects that were made with this, so make sure you make the stuff that you apply for easy to find (through pinning, good descriptions/titles, and so on). I really just built stuff that I liked myself. You don't have to reinvent the wheel, you will always learn something new or at least improve your project structure / syntax memory from building things while you have fun. I love video games for example, so I built a new twitch-website in React - not really a lot of new functionality other than what their site already has, but this project made sure that I finally nailed using Redux! Best of luck in your search. I'm sure you'll pull through!
It seems React and Angular and all that more and more need helpers to make them work, organize it, help keep your sanity, etc. I'm not sure one should be using helpers like React and Angular that themselves need helpers.
Sure just code your own browser in assembly while you're at it! 
How about more generically looking into things like IIFEs for segmenting/structuring code, or perhaps patterns like MVC (maybe just searching for js design patterns will find a useful starting point)?
thanks, I went ahead and used the .ajax command as I used jQuery for this. Lets see how it goes. It wasn't perfect but I made sure I showed that I understand WHY a POST request is used, not only how.
First understand basics. You have to choices from the code: * organize by scope (closures) * organize by objects (prototypes, inheritance) Secondly, understand your environments: * Legacy browsers (scripts included via script tags) * Tooling for the browser (scripts are combined into files via a build process, can use a Node style module system) * Modern browsers (ES6 modules are now a thing in most modern browsers) * Dynamic code inclusion in the browser, ASI (require.js) * Node (node style synchronous require) For me contending with the various environmental concerns is by the hardest decision to make in code architecture. Third, know your business requirements before you write any code. This will help you organize technical aspects of your application into the various separations of concerns. Fourth, code strictly to the requirements. Produce a minimally viable product (MVP) first and then make it awesome later. Fifth, divide your code into files respective of the separation of concerns. Personally, I don't care how big or intimidating a file gets. I only divide code as necessary to achieve separation of output as dictated by the business concerns. --- My current personal preference is to organize by object in the global scope. I do this to provide the minimum commonality for all environments. Node supplies a reference named *global*, so I organize all my code under a single property for the given application and attach it as a property of *global*. For the browser I then run a build process to take the fully composed application and dump it into a single file and rename all the *global* references to *window*. That object organization allows me to put code from various files together in a way that is environment agnostic and stupid simple. It is a poor man's modules without any conventions or unnecessary code. For all other considerations I prefer to organize my code by scope. There are two benefits to this approach: 1. You never need the *this* keyword. Code gets smaller and easier to read. 2. Never needing *this* means there is only lexical scope. Things only flow one way, which makes the code more predictable and **far** easier to maintain. 3. You only declare references where they are needed. If you need wider access or reuse to a reference then declare it in a higher scope. Otherwise declare the reference in the lower scope possible. This avoids a lot of confusion in what things are and where they are used. 4. Create various nested scopes and use this to create logical structures that dictate the flow of instructions from broad to specific. Being able to decipher the flow control of code by simply reading the code takes longer to write but it **magic** for maintainability.
Yeah. Not using React and Angular means using assembly. Makes "reddit sense" to me.
TS is not as good a transpiler as Babel is, plain and simple. I wouldn't let a type checking tool take over the build system, then wait years until newer drafts can be used or tested. Babel has always been very close to the TC39 and now they're directly involved in the meet-ups. They reflect most drafts, also track their staging status. Feedback flows directly back to the committees, so it's actively shaping the future of javascript. The community is very active. And Babel is more than a Es-next transpiler. Without it things like JSX wouldn't have been possible. There countless of useful plugins in its eco system.
Yes I think that , not learning will get you stuck on the "undefined is not a function" very quickly anyway
Thanks for your input man, and congrats on the job offer. Would you mind linking your github? You can pm it to me if you like, i'd just like a reference from someone that just went thorough the process. 
It's like asking me why people still use jQuery for basic DOM manipulation which could have been done with few lines of plain JS and not making user load additional 252KB file just cause. Don't. Ask them instead.
I've been looking for a resource to practice making API calls forever. Thank you!
btw, `fetch` is [built-in](https://caniuse.com/#search=fetch) into most browsers as well, it's not really a library. I just linked to the documentation of GitHub's polyfill.
May I PM you a question?
TL;DR Depends. When you're a beginner? Definitely. Anyone else? Well, debugging is just a part of development, you won't avoid it either way, having two things complain is worse than just one, imo, especially when linter doesn't catch everything. Though when you run it and shit fucks up, you know that there's a real problem that you do have to fix. And that will happen occasionally whether you use that or not.
Sure.
Also instead of running `Bean.prototype = new Legume();` You can instead create a new object with the Legume prototype without invoking the constructor. Invoking the constructor can result in unwanted instance properties on the prototype or other side effects, so you can use Object.create instead: `Bean.prototype = Object.create(Legume.prototype);
But [`undefined` isn't a function](https://i.imgur.com/dyR76GX.png)!!1!!!one!!!! There's not much to argue, it's like saying that you should learn C++ before using libraries for C++, it's just common sense to most. But what do you actually mean by &gt;stuck on the "undefined is not a function" ? 
Thank you for the feedback! I will explore this problem and react-virtual-list library, and will try to solve the problem in the nearest release!
I learned JS that I wanted to *use in a fucking browser goddamnit*, not on a fucking joke called "server that runs Node.js" that most of you seem to love nowadays. Try again.
And you aren't wrong, these fanboys are a fucking joke, it's `Node.js` for a reason.
I deleted them. Now I'm waiting for the feedback from QA. Thanks for helping.
Hi! have checked you proxy api, great job by the way. However is there a way for the proxy to get the specific comments in a certain post? Right now am checking the return and it seems the counts are the only ones getting returned Any ideas? thanks!
Look on Github - I don't know of any repos that are geared specifically to your needs, but there are any number of projects you could look at the should meet your needs. I have an automated Bitcoin trading platform that I wrote several years ago (and eventually sold a later version of the code). There is some good stuff, some bad stuff, and a lot of stuff in between. It is a single page app, so lots of JavaScript. [link](https://github.com/cclites/ModoCoreV1) 
I didn't see that point being made anywhere in your 7 word comment... I was just pointing out that in terms of a learning path there's nothing wrong with referring to Node.js as a library to be learned as there are built-in methods that you won't find in the browser and I wouldn't consider to be native to the language of JS. Since you brought it up, in your perfect world what is the perfect environment to learn JS?
every language has bad and good stuff. If you more errors when trying to increment Arrays, then try something like TypeScript
It's not true. Node.js/Express are far better than Django/Flask. Both in terms of speed and (imo) syntax.
Yes, this did not work for me, did it work for you? 
If you turned d into [d] you could map over it and insert a tap function at any point where needed Where tap is simply an identity function with a side effect Tap = d =&gt; { console.log(d); return d } You'd then have to just get the value out at the end. E.g. Mu = ([d].map(tap).map(d =&gt; [foo(d), bar(d)]).map(tap)[0] or any other way to get the item out Basically make d a functor and map it Sorry if formatting is jank, on mobile and sorry if logic is jank because I'm pretty fresh to functional
Couldn't you just create more than one helper module? I mean, your first and second methods could go into a Port helper module, the third and fourth methods could go into an Element helper module Then you import all of them in your RootStore
The problem isn't lack of message itself, the problem is that the fucking intrepreter and whoever wrote it thinks that it's fucking okay to just simply try and increment a goddamn array. To be honest, if I had a choice, I'd swap JS with anything else out here the moment I could, and I do that, when I am not trying to make something that runs in the browser even on my grandma's tamogatchi. Saying "bad and good stuff" isn't an excuse to be beyond retarded and `[]++` to `0` in no time. I can't even fucking comprehend, how ++ operator has ability to replace ARRAY with INTEGER. JS is interpreted language, there's no types, let's say there's a function that accepts some number and it uses it as a counter. Well well well, what fucking happens when a newbie stupidly inputs array into it and can't even figure out the problem once it occurs because even he wouldn't think of being so fucking retarded and replacing a goddamn array with a 0. Now think about what would python interpreter say about it. That's right, it would do what every proper language would do, COMPLAIN ABOUT IT. You think that errors happen just because machines like complaining? No skiddie, they are errors for a reason, just like with exceptions, if you leave them exist without doing anything about them, the latter behaviour of a program is undefined. Just use leftovers of the braincell ball you call "brain" for a second and tell me to use TypeScript or something else again. I dare you.
"stealing"?!? The author is given credit right there on the site. 
I would wait until webpack becomes an option. Concatenation and loading dependencies in order are artefacts of the pre module era, as well as chasing behind dependencies manually. You could theoretically force browserify in there and hope all is well, i'd rather enjoy a working system as it is and go webpack once the issues that prevent it are cleared. 
We all saw this error, right ? I mean just look at a search [result on stackOverflow for "undefined is not a function"](https://stackoverflow.com/search?q=%22undefined+is+not+a+function%22) 3,209 results. And this is just the questions with that exact phrase inside the question. I used it as example. You would be surprised by the number of people who start JS with a Java background, without learning it properly, I once heard: "I am smart enough for this scripting thing called JS I don't need to learn it" haha
"This doesn't work for me" isn't an answer. Explain to everyone what you tried, why it didn't work, how you want it to work, don't just blindly copy code, etc, etc, then ask a proper question and people will be able to help you.
If the first thing you do is pick jQuery up you aren't smart enough to even exist, it's not funny, just sad.
then use it in a browser, no one's stopping you.
But no, to learn JS truly, I need to use Node.js even though I won't need anything it provides and javascript there is exactly the same!
≥ I didn't see that point being made anywhere in your 7 word comment... Sorry, got you mixed up with the angry guy. That point was illustrated elsewhere in the thread. &gt; I wouldn't consider to be native to the language of JS. I wouldn't consider browser APIs to be native to JS either, neither would the committee writing the ECMAScript spec, that's why those browser APIs aren't in the spec. The perfect environment to learn JS would just be a REPL that implements the ECMAScript spec but not any Node or Browser specific modules. Regardless of what I think, or what you think. Node isn't a library, it's a runtime...those are just the facts. 
In Google Sheets I placed the an instagram URL A1 I then put the following code in section B1 =REGEXEXTRACT(concatenate(IMPORTDATA(A1)),"biography: ""(.*)""full_name") Doing this shows #N/A in B1 and text goes over the left hand side of my screen. When I click #N/A it shows a long error starting with the following: Function REGEXEXTRACT parameter 2 value "biography: "(.*)"full_name" does not match text of Function REGEXEXTRACT parameter 1 value "&lt;!DOCTYPE html&gt;&lt;!--[if lt IE 7]&gt; &lt;html lang="en" class="no-js lt-ie9 lt-ie8 lt-ie7 not-logged-in client-root"&gt; &lt;![endif]--&gt;&lt;!--[if IE 7]&gt; &lt;html lang="en" class="no-js lt-ie9 lt-ie8 not-logged-in client-root"&gt; 
&gt; It's like asking me why people still use jQuery for basic DOM manipulation which could have been done with few lines of plain JS and not making user load additional 252KB file just cause. I'm not advocating for using libraries. I'm pointing out the fact that libraries and runtimes aren't equivalent things. Writing vanillajs is great, if you look through my comment history you'll find me advocating against unnecessarily using libs when vanillajs will do. I've been saying this for years. &gt; Don't. Ask them instead. Just as an FYI: popular =/= best. Remember that majority is stupid. Sometimes the majority is stupid, sometimes it isn't. Evaluate on a case by case basis. &gt; Also you still try to capitalize on "LUL you don't even know what Node is!" except I do You still seem to think it's a library. So sorry, you don't know what node is. If you don't know the difference between a runtime and a library, maybe this thread would help? https://softwareengineering.stackexchange.com/questions/136860/what-is-the-difference-between-apis-libraries-runtime-systems-and-frameworks
The initial removal and assumption of stealing was based off that I did not originally see a link back to the original post. Whether it was there, and I missed it, or it was not there at all, it lead me to believe that it was stolen. Furthermore, the way that it has the original authors name with a new date, although this is more of a repost of the original blog post, indicated to me that this was an attempt at masking that the blog post wasn't something that was posted on that blog originally. This lead to the removal. Seeing it in its current state, it's a little better, but preferably you'd credit people in the top of the post, not the bottom, if you wanted to credit in a transparent way. Again, I apologised to OP for the assumption of them stealing the content, but we get a mixed bag of posts on /r/javascript, and this initially fit as being very low-effort to promote the javascript works platform by rehosting content.
I am so hyped for this, already tried it out last weekend and it worked great!
You don't need node to learn javascript, its just a better environment to learn it IMO. You can learn it in either. I learned it in the browser before node existed. If someone came to me asking for advice, I'd tell them to install node rather than teaching them how to get an http server up on their machine, create an HTML document, create a CSS file, and create a javascript file, add the script tag to your html document, then open your browser to localhost:8080 and then open the dev tools console to see `"hello world"`. Instead I could just tell them "run this in your terminal" `brew install node &amp;&amp; echo 'console.log("hello world")' &gt;&gt; hello.js &amp;&amp; node hello`
I'm not sure I completely understand the problem, why can't you just replace the text immediately after creating the new elements all in the same function?
&gt; having two things complain is worse than just one The advantage is if your linter/compiler catches the error before you run the code then you won't see the second complaint since you already fixed it.
Thanks for the feedback! I will take a look at this problem and will try to fix it.
I probably could, but (regarding your first example) I cannot really decide if they are related to Ports or Connections more. Most of the time they are used when rendering Connections, but this may change when I start creating special styles for connected Ports. It's like a case where tags would make more sense than categories, if you know what I mean.
Your explanation seems a bit vague to me, so please correct me if I'm wrong; an event fires in the DOM, a function (that you don't want to edit) is called in response to that event, and then you want your function to be called aftwards? `event -&gt; other function -&gt; your function` In that case, you can simply attach your function as a listener to the same event on the same DOM node. If your listener is applied last, it'll also be called last when the event is dispatched.
Thank you! Hope this component will be helpful for you! If you have any problems with it or with the documentation, please, write an issue and feel free to contribute :)
&gt; Avoid Clean Architecture at all cost. Nonsense. Clean Architecture is a fantastic book. I will read it again. 8-9/10
Doh. You are so right, I actually put axios in there first and then snuck in fetch without accounting for the differences. 
You can just take him literally and miss the point or you can try to understand what he meant: every level of abstraction has effects: Something gets easier to use ("powerful programming language") or you can achieve some goal with less code but at the same time you lose the ability to access low-level stuff. Frameworks like react or angular make different decisions on what to include into the library behind an abstraction or what can be build in "user land". "helpers" like you called them use the building blocks provided by those libraries and add another abstraction. This is not at all a reason to avoid them. 
https://github.com/leboncoin/morphlingjs
I hope you're just assuming that I'm fucking stupid, sadly I'm not. It's far simpler to just write your own page with script tag in it and run it in browser than it is to download node and remember to do everything you just said. Also it's far simpler in browser, press ctrl+shift+i, type `console.log("hello world")`, done. Also not everyone uses brew, nor needs it, just like node, what do you do then, tell them to install brew? You don't even need a http server to learn JavaScript itself.
&gt; Frameworks like react or angular make different decisions Thus **MY** point which is what this portion of the thread is about.
If you want to validate your `1112`, then do store which element you select, look at what path you actually found and just manually verify if it is a correct solution. I haven't really reviewed your code, but `1074` is indeed the correct solution, so you'll find that in some way the path you've found is not valid.
&gt;&gt;What he wants is something that describes breaking code into modules and organizing a midsized js project.&lt;&lt; Yes! Thanks for "getting it." 
It is much easier to find a solution if you start from the the bottom and then proceed to the top, than going from top to bottom. 
If you're looking for a complete solution you might take a look at CxJS.
Try **not** to read the following solution, but if you really can't solve it... [there's a solution here](https://gist.github.com/gezeta-id/7998cb636b3147b3323b8f82f0dc6ecd).
That issue is a showstopper for me too. It breaks if import statements are touched.
I already have a complete solution. It's called JavaScript.
After two years of using Babel I'm still amazed what Babel offer. You get to use new language features you like or write your own extensions and do crazy things. I love it.
I already told you that I walked through it manually. I get exactly the same numbers by writing on paper by hand, as does my algorithm, and the sum in both cases is `1112`, and I am supposed to find a longest path. How do you even get 1074?
All these Excel grid components are huge and slow. What is the import cost of this component?
That is the stupidest thing I've read today.
It depends on what you're trying to build. JavaScript is used for all kinds of things these days. It's much easier to work if you have the right tools and libraries available.
I have only looked at Angularjs, React, Vue, and now doing an enterprise Angular 5 project. If I could get my company to buy in I would've gone with Vue. Takes a lot good from Angular and React. Look at using Vue CLI. I don't know enough about Ember but a lot of people are using Vue. It's solidly third after Angular and React. I would go with it.
[This is the expected maximum path](https://imgur.com/sHy0KAH) which gives you a total of `1074`. Can you draw your path to compare?
You should probably chill out on the $hilling for CxJS.
Hi /u/paulrennie, For javascript help, please visit /r/LearnJavascript. Thank you!
Thanks for the ping on this one. PR posted: https://github.com/babel/babel/issues/6093
Hi /u/toyoagz, For javascript help, please visit /r/LearnJavascript. Thank you!
react-redux is a helper for two insanely useful and popular libraries that marries React's props injection process + life cycle events and redux's global state management. Arguably one of the most useful "helper of helper" libraries and a great example of why your generalized statements are being down voted. That being said, this component library in particular is nothing I would personally ever use.
[Maximum path using my algorithm](https://i.imgur.com/2149TFR.png) I mean, the creator of this could expect me to either care about indexes (in next row, the number can be either prevIndex-1, prevIndex or prevIndex+1), or about how it looks graphically... In both cases, I don't know why you went into `64` in second row, even though `95` is clearly way more than that.
&gt; I literally feel like I have no foundation to do this assignment. I think you should get the foundation first. Forget the assignment. Take your losses and move on. 
Well, the problem is not terribly well explained but and the small ASCII art provided isn't really that clear. But if you go to the original [Euler 18](https://projecteuler.net/problem=18) images provide a much clear explanation of the situation. As for the question of choosing `64` in the second row... The thing is you simply cannot solve this problem going from the top to the bottom. It doesn't work. Imagine a pyramid such as this one: 10 80 30 20 01 99 10 01 10 99 10 01 10 10 99 If you try to go from the top, each row a step, you will choose `80` in the second row and then be forever stuck into sliding to the left, missing the opportunity or reaching the `99`s. Because going from the top, you cannot predict what will later be in distant areas.
Thanks! Checking it out now... :) 
I'm interested in seeing these instructions.
Hey bud, sounds like you're in a tough spot! Sorry to hear it. But if you want to get help, just post the problem and ask questions about it.
It doesn't line up correctly on the columns that are read only. Also dear god is it slow. 
I've been doing Ember for the past 2 years, but haven't done anything on Vue (or React/Angular for that matter), so take this with a grain of salt.... :) Convention over configuration, every project have the same structure, which is very useful when you switch projects, every things goes in the same place. You've seen an ember project, you seen them all I love ember-cli... scaffolding, build, livereload, minifying, sourcemaps, etc... everything just by installing ember-cli. Ember community is very friendly (there's a slack channel for Ember), there are lot of addons for many situations (see emberobserver.com). The community is smaller than Vue/React, but there's usually always an addon for what you want to. Stability, I've been upgrading my app from Ember 2.0 to Ember 2.16, without much of a fuss. But also, I've been getting sweet stuff like the new Glimmer rendering engine (much faster rendering than the previous one) just by upgrading my package.json Just my two cents, I'm sure Vue/React are great as well.
Downvotes here are the maniacal screams of reddit. They mean less than nothing.
And profound statements like &gt;JavaScript is used for all kinds of things these days.
On the other hand it shows how flexible/extendable the library is. Some more fully featured libraries are a bitch to extend
ooh those harry potter ones are lit
&gt; The main motto here is to have a "reactive" app that can be synchronized in real time with your data sources and update accordingly (as I understand it). Yeah, I think the `reactive` term is overloaded. This is essentially the goal behind any user interface. In some ways I feel like `reactive` is a buzzword. Reactive programming in and of itself is nothing new. https://en.wikipedia.org/wiki/Reactive_programming#Object-oriented
Okay, I see, and I mentioned it, kind of, in previous comment. The only way then is to find all paths, and get the longest one. And to do that you can use a graph and find it's critical path. Graph would look something like this: 10 /\ 80 30 /\ /\ 20 01 99 /\ /\ /\ 10 01 10 99 /\ /\ /\ /\ 10 01 10 10 99 You'd end up figuring out that the maximum path is sliding all the way down to the right, as you checked all of them and you know. So, what I wrote was just stupid bruteforce afterall as I didn't account for this.
Evening, Best way you can request help is to post a bit more in detail about the assignment itself rather than just saying we need to make a battleship game? Get yourself to a point where you have some code written, then when you hit issues post a question based on that specific error.. then continue to work that way. 
VSCode has vim plugins
I might be misunderstanding your error here, but it sounds like your REGEXEXTRACT is not finding a match within the Instagram page. But that HTML has `class="not-logged-in"` so maybe you just need to log in to Instagram?
Are you willing to share your repo? Or is this closed source?
I don't understand what you mean with those `//`, but anyway... There's a solution that doesn't require calculating all paths through brute force. In fact, the number of paths grows exponentially with height (`2^H`) so brute force is not a terribly good idea.
Thank you for your reply. I was logged in when I did it. I just tried it again to make sure. I also tried using the following code: =REGEXEXTRACT(concatenate(IMPORTDATA(A1)),"biography: ""(.*)""full_name The code above gave me the same error so I changed the IMPORTDATA to IMPORTXML =REGEXEXTRACT(concatenate(IMPORTXML(A1)),"biography: ""(.*)""full_name That one gave me the following error: "Wrong number of arguments to IMPORTXML. Expected 2 arguments, but got 1 arguments"
It's just a tree that follows the rules of how you can traverse through the pyramid numbers from one another.
Aurelia does
Aurelia does
&gt; more modern, with native javascript and a way less crazy approach to doing stuff Well, that would literally be react. Whatever you think of Vue, and many do love it, it does take the opposite approach of what you're describing. It bases on an older philosophy leaning in Angulars direction. Instead of native javascript you have javascript-like string evaluation and mark up extensions in moustache templates. Kind of a disregard for javascript and modern language features. You do need build tools for self-contained components.
Uhm... Ok. What I don't understand is what is different between `/` and `//`. I mean... from `80` you can go to either `20` or `01`, and from `30` you can go to either `01` or `99`. It's the same type of traversing from `80 -&gt; 20` and `30 -&gt; 01`.
I edited the reply. From 30 you can go either to the left, downwards, or to the right, which is index-1, index, index+1 on last row, which is `30 -&gt; 20/01/99`.
Depends on where your events are located in your "database." What column? Supposing it's column E, we can mostly use the example on the sheetrock page to build a query: sheetrock({ url: "https://docs.google.com/spreadsheets/some_sheet", query: `select A,B,C,D,E,L where E &gt;= '${new Date}'`, callback: myCallback }); No idea if that works, but it's a start.
Post the instructions, maybe people can give you some direction. No one's gonna do your homework for you though.
I added them in, thank you for trying to help
I added the instructions in the description, thank you for trying to help
I added the instructions in the description, thank you for trying to help
I added the instructions in the description, thank you for trying to help
just figure of speech. those two would literally be the only way of me turning this in is what im saying.
Aaah, ok, so that's what you understood and implemented! I see. As I said, the original image in the Euler Project is much clearer than the explanation at codewars.
All right, I got it working using this slightly modified regex: =REGEXEXTRACT(concatenate(IMPORTDATA("https://www.instagram.com/reddit/")),"biography"": ""(.*)""blocked") Not sure why, but for me, "full_name" doesn't come after the bio; instead, the next parameter is "blocked_by_user", so I used that as the end point for this regex and it works.
Try a data structure called a matrix, a "2 dimensional array" or array of arrays. var ocean = [ [0,1,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,1,0,0,0], [0,0,1,0,0,0,0,0,0,0], [0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,0,0], ]; 1's are subs, 0's ocean. You'll have to randomly populate this with subs, then use this data structure to create your DOM elements (the viewable, clickable grid). 
When we have a real product to show one day i would love to. :-)
Wow this is great! Thank you @thequargy guy. It worked for me! Is there any way that instead of using the URL we can use a spread sheet coordinate like "A1". I tried it with A1 and it didn't work, this would be super convenient because then one could just drag down the code to cover multiple usernames. I just shot you over some Reddit gold 😎
&gt; if you can't understand a technology from spending less than 5 minutes on the hello world and introduction part of the docs then (again, for me) this technology is flawed in its design This is a good strategy if you're only building "hello world" apps, but if you are building anything for the real world you should adjust your metrics. Unfortunately, the only real way to evaluate a technology is build something non-trivial with it.
Classes exist to classify something, so if you can't separate two things, they probably belong in the same class. As there's no "default" way to get private methods in objects and etc, it doesn't really matter what you do, technically everything is a god object, especially functions (they are objects too) that are in `window` scope in the browser, as they can access any variable from any other object in the same scope.
Yeah, just put in a cell reference instead: =REGEXEXTRACT(concatenate(IMPORTDATA(A1)),"biography"": ""(.*)""blocked") And then in cell A1, put your url
Omg, I had forgot a parenthesis haha. Thanks again for all your help! 
&gt; I'd say it is a method that takes state as a parameter That's good, I'm going to remember that.
Write the posts anyway! :) The project that got me started on React+Redux in the first place still isn't done yet, but I took what I learned working on it initially and turned it into [my "Practical Redux" tutorial series](http://blog.isquaredsoftware.com/series/practical-redux). Seriously, it sounds like your team has been doing some pretty advanced stuff architecturally. I'd love to see some long in-depth writeups on that, and I'm sure it would be useful for other people too.
It's not that newbies need to learn Javascript, or learn the language, before frameworks etc they need to learn the fundamentals of programming before trying to build something substantial. "Learn the language" is annoying trope repeated ad nauseam that is in itself the language of newbies.
Does this need a GUI? Or can it be ran in the console?
As a guy with a lot of side projects, the uniform project organization with Ember is a big boon when you're jumping back and forth between projects. When you start with something that's just a view library and have to add on a bunch of custom configuration to build out your custom framework stack, it's tougher to remember how everything is set up. If you're not super diligent about documenting, it's something to really consider.
OP you might want to add ```demo.gif``` to ```.npmignore``` there's no reason users should download and keep in their ```node_modules``` a 5.45MB gif. Host it somewhere else.
Typescript's compiler is single-use - it just compiles TS to JS - while Babel has an entire plugin ecosystem which can be used for a lot more. For example, I use `babel-plugin-lodash` to break monolithic lodash imports into imports for just the functions that I need, to reduce our frontend bundle size. Currently, that's just not possible to do with Typescript, AFAIK.
 var launchRocket = function(sequence) { if (sequence === 321) { document.body.getElementsByClassName("animation-window")[0].className = "animation-window animate"; var e = "ri"; var x = "s3f"; var n = "orward"; That is your code. As you can see, you **can't** use it because it's incomplete. It's just a broken fragment. It doesn't do anything.
It doesn’t work properly on my iPad.
The guy who wrote this is an idiot.
[removed]
Thank you for reinstating. We both write our own content and republish content that looks lilke it would be interesting to community. We always ask permission from the author and include a link to original source. Thanks for looking into it :)
&gt;React is plain javascript without new or foreign constructs. That couldn't be further from the truth (when comparing to Angular, Vue, Ember etc.)...
I can't honestly compare Vue vs Ember as I've zero Vue experience. OTOH I have been working on a production Ember app for 3 years and can speak to why I like Ember and continue to use it. The Ember team is continually releasing features and updates with a mindset of making upgrades painless. Being an opinionated framework means that everyones' Ember app shares a lot of commonality. That means tooling built for one app can easily be adapted to work for the entire community. EmberCLI is probably the best example of this. EmberCLI is your central tool for boilerplate code generation, building your application, running cli or in-browser tests, linting, live recompile of your app during development. Pretty much ever other framework has a *cli tool based on what ember has, but they seem to only partially work in one way or another because other frameworks lack the strong conventions of ember. A second value of ember's opinionated style are the patterns that have developed by a community all have the same way of doing things to solve common patterns. Need authorization? see https://ember-simple-auth.com/ Need to deployment pipeline? see http://ember-cli-deploy.com/ Need server-side rendering? https://ember-fastboot.com/ Need a drop-in solution for pretty much anything else? See https://emberobserver.com/ . All of the above are just addons and again Ember's structure says that all addons must interact with your app and embercli a certain way. So understanding Ember addons means you can fork / extend an addon to make it work your way if for some reason its out-of-the-box implementation isn't right for your use. As for your concerns about Ember: speed and weight. I can't speak to your intended app's use. I suspect Ember is fast enough; Its fast enough for Linked in, Its fast enough for Netflix, Its fast enough for Twitch. Then again maybe its too slow for you? As for weight maybe its too big? I have no sense of the size of actual vue apps vs an ember app.
Hi! I've been writing JS for a living for like 7ish years, learned it on my own. Thoughts: You should look into the 'pubsub' and 'finite state machine' patterns. Those terms are super googleable and are used to solve the exact problems you're running into. This will get you a lot further than thinking about modules / inheritance, IMO. I know, you wanted examples. I have none, but a quick google search turned up this blog post that goes into concrete detail on both patterns: http://codeincomplete.com/posts/javascript-game-foundations-state-management/ Do you have anything on github that you'd like feedback on? I'm happy to take a look. Somebody else linked to the old but still relevant architecture talk that Nicholas Zakas did years ago. There's a lot of evergreen stuff in there, *but* that talk is more about very large scale JS architecture; it's a lot more than you probably need. Like, if an app is so big that different pieces belong to teams in different time zones, each team has to commit to maintaining a stable API, so the other teams can get work done. For a personal project that's getting complicated, you don't need that level of separation. Happy to answer questions. Good luck :-)
Sounds like you'd like to *spy* on a function. Basically, you wrap the original function with your own, so while something else thinks its calling the original, your wrapper is actually used instead. Check this out: ``` function Spy(obj, method, callback) { // We can track what spy data, such as arguments were used to call the function. const spyInfo = { args: [] }; // Hold onto the original function we are spying on. const original = obj[method]; // Update the function with our own which saves the arguments used, // calls the original function, and then fires our callback. obj[method] = function() { const args = Array.prototype.slice.apply(arguments); spyInfo.args = args; const returnVal = original.apply(obj, args); callback(); return returnVal; }; // `freeze` the object so it becomes read-only data. return Object.freeze(spyInfo); } // Usage Spy(console, 'warn', ()=&gt;{ console.log('A warning was printed just above this!'); }); console.warn('Uh oh!'); // Prints: // &gt; *Uh oh!* // &gt; A warning was printed just above this! ```
LMGTFY https://www.google.com/search?q=make+a+battleship+game+in+javascript&amp;oq=make+a+battleship+game+in+javascript&amp;aqs=chrome..69i57j0.33015j0j8&amp;sourceid=chrome&amp;ie=UTF-8
"I can't write 'classes' without using .prototype"........
Thank you all for the replies. I ended up using MutationObserver anyway which resolved the issue and I only use one other so the cycles are not too bad. Sorry for any previous vagueness. To clarify, I am stuck using a 3rd party widget gallery solution that I don’t want to edit directly as is not appropriate for stable release support and they wouldn’t support it. The vendor hard coded some text in their function that creates divs on a page for the drag and drop feature and I needed to change the text. That is easy with promises in ES6, but good ol’ IE... Anyway, I decided to just attach a mutationobserver to a parent div and look for a subtree mutation to catch any child. So now any time their function is triggered for the drag and drop, my function fires and overrides it. End result; I’m happy. Better end result; MS releases an update to the IE11 engine for ES6 support.
A view in React consists of nested function calls, nothing more. You don’t invent something to realize a loop, you use for-of or map(). You don’t extend markup syntax with special constructs to get conditionals, you use if-else or ternaries. You don’t inject externals into a config, you use regular JavaScript scope. You don’t register components so they can be found back in a string template, you refer to them as you refer to anything. React is pure JavaScript however you want to interpret it.
Oh this could be super easy. I would build an object {0: 0, 1: 0, 2: 0.....} Then i would use math.random to pick 10 random numbers from 0-99 (referencing the items in the object) Then loop the object and each iteration in the loop create an element. The ones that ended up being randomed are the subs and the rest are ocean. Thisbuilds your board. Then you just need a clickevent bound to each element that checked to see if it is water or sub.
Sounds like gui, but a super basic one. Just a grid of elements.
Give this page a look: [HTML Templates](https://developers.google.com/apps-script/guides/html/templates ). You should find the example listed under the 'Pushing Variables to Templates' particularly interesting. I've done something similar to what you're tying to do and I found it much easier to write the entire e-mail as a scripted HTML template and pass in variables with the data you want to send to people.
&gt; Instead of native javascript you have javascript-like string evaluation and mark up extensions. Templates compile down to JS. Templates are also optional. &gt; A disregard for javascript and modern language features You can use all ES6+ features with Vue perfectly fine? &gt; Build tools are needed for self-contained components. I've never met a single person who didn't use a build tool for React, or for any modern frontend project for that matter. Though, knowing your past posting history, you seem to ride the React evangelism train pretty aggressively, so it's probably pointless arguing any of this with someone like you. I just thought it was fair to let you know where the downvotes were coming from.
&gt; Classes exist to classify something, so if you can't separate two things, they probably belong in the same class. I'm just not sure if I don't see a good separation, or if it really doesn't make much sense to separate those methods. As for your latter point, I use TypeScript, so I have plenty of `private` and `protected` methods. And I don't think that `window` or its functions can be called "god objects". This anti-pattern usually means *poorly maintainable* objects that do too much work by themselves (without delegating it to other functions or classes), which is clearly not the case. Fortunately, am not a maintainer of `window`, and the functions available on it are simply builtin functions of the language, the same way as `string`, `number` and others are builtin primitive types. They don't have issues with too much responsibility.