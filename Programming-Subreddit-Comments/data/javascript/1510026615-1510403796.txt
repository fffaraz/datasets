&gt; Express is just plain outdated Can I ask why you think this? It seems to do what the majority of people want.
There's no secure way to do this without a server and a database of sorts. The obfuscation tool you linked is just that, a obfuscator - nothing more. It just turns your code into unreadable, incomprehensible mush; that when executed, all pieces back together at run time to execute normally. It doesn't provide any sort of encryption and doesn't stop a hacker either - it just slows them down as they have to now reverse engineer your app. It's really a false sense of security and the only reason why such things exist is to be implemented as part of a broader multi-layered defence strategy, i.e defence in depth. 
I think he means this: const fn = () =&gt; {} console.log(fn.name) //=&gt; "fn"
Maybe he is referring to what Babel transpilation does. See [this code](https://babeljs.io/repl/#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;code_lz=G4QwTgBCELwQZgVwHYGMAuBLA9sgFAJQQDeAUBBGAKbqJjIQCMA3KQL6mmq4DO2ANlQB0_bAHM8IQgVakgA&amp;debug=false&amp;circleciRepo=&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015&amp;targets=&amp;version=6.26.0) When you have ``` var a = function() { return 1; } ``` and you check 'es2015', the transpiled version will be ``` var a = function a() { return 1; }; ``` Of course this is only half of the problem, as it only works when you assign a function to a named variable. For truly anonymous functions that you pass as callbacks, there's nothing different.
what about something like this?
You need a server to handle login
SVG can't do parabolas, but it can do Bezier curves. Check out https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths#Bezier_Curves. But you'll need a way to mathematically "translate it" - to approximate a Bezier curve given your parabola.
I created [an issue](https://github.com/gikmx/npm/issues/6) for this, so hopefully we can find a better suited name for the project.
Not sure how *efficient* this is, but you could loop through the letters of the word and see if its position is the *first* position of that letter. function isogram(word) { word = word.toLowerCase() for (var i = 0; i &lt; word.length; i++) { if (word.indexOf(word[i]) !== i) { return false } } return true }
Lambda is not necessarily node. I don't know what gave you that misconception. But please go on..
I spent a week or so recently trying to figure out how to use realm's mobile database for a react native app and found the whole thing to be a huge headache. I'm sure the fault is largely mine but using it on Windows just sucked. So hard to see what was in the database and some of the solutions were unexpected dead ends. For instance, on Android people recommended using stetho and another library to integrate the database with Chrome dev tools. Ok. The docs explaining that process left out some parts so it took a while to get around that. Then, once I had it hooked up I discovered that it actually doesn't work for react native at all anyway. Super awesome fun. I tried using the Linux subsystem for windows but Microsoft hasn't implemented some key features of Linux that it needs in order to run the object server. Then I get Realm Studio and it gives the option to connect to a local database but that doesn't do me any good without having a way to keep pulling my realm file off my testing device and onto my hard drive. Again, I get that this is certainly my lack of understanding but I don't see what the studio even offers. The whole experience was just deeply unpleasant and all I got from it was a wasted week. Does anyone have any helpful advice on how to use realm on windows efficiently? 
even with using .htaccess/.htpasswd? I can't just upload those files and get it to work?
I mean, if you want a fixed number of usernames and passwords that don't change, I suppose you could use this
I just want one password for me, and only me, to have access to the website. Except I am not able to get it working using a couple of free sites
I think you may be misunderstanding the use of the word component, here (although admittedly, it's not a great word choice). It doesn't have anything to do with react components, or emulating them at all. Nothing says you can't use MVC with this structure. I'd argue it's still recommended. This pattern just says put the models / views / controllers that interact with each other in the same spot, and try to keep things together within a context. The whole point of the pattern _is_ to scale well, in the fact that when (or if) it comes to it, it's much easier to break into separate services -- because the code is already structured that way.
are you using apache.. ? I'm pretty sure this only applies to apache
I guess my code sucks then because I disagree with most of these. They're "best" practices after all.
:) well, I also don‚Äôt know, probably it‚Äôs just marketing)
Express is old, I'm not sure that I would go as far to say outdated. Used express in the past, but now I find Koa fits much better with the addition of async and await.
&gt; and typing (TypeScript) or [Flow](https://flow.org/). 
Hey, thanks. I had a plan to add Webstorm plugin (or maybe for Atom), but will see then, depends how much time it can take.
Thanks, do you mind to file an issue on GitHub for ‚Äúfor..of‚Äù loop? Just simpler to track that.
&gt; AWS Lambda often holds state between executions This seems a bit nitpicky, as it's not at all an intended functionality of the platform and nothing you could every rely on in a production environment. 
The middleware interface is supposed to be compatible with all the Connect-based frameworks, isn't it?
You can do some of the things you mention, but it's a guidelines list ie. sticking to them will probably be better than otherwise. Also, it would help if you could explain your statements, because there's none that I wouldn't take with a grain of salt.
I have used a lot of prototyping software, but I found that knowing a good portion of HTML, CSS and JS enabled me to create better (read more fine-tuned) prototypes. But, other comments in this post made me think. There is a difference between UI and UX. UI is what the users sees, UX is what the user experiences. So for UI for example Photoshop would do, but for UX you need to model interactions of the user with the system, and I think JS is well suited for this.
Let's see some numbers.
Whenever you ask a question somewhere, ask that question **there**, instead of making people go to some other site to read the question. Thank you. That said, you'll need to provide more information. There seems to be a Php server involved, and a node server too... One is on port 8888, which one? What is being server from where?
Because sync fs is evil. It doesn't matter much in this particular case but it just hurts to see both combined like this.
Agree with most of them, but this one "1.5 Use environment aware, secure and hierarchical config" just goes against the Twelve-factor app principles https://12factor.net/config
So as i understand, Axure wasn't enough? Basically if you look in this way, UI is UX or is a part of UX and vice versa. Are your team of developers using React to? 
What about this https://github.com/krasimir/react-in-patterns
It's [actually in ES6](http://2ality.com/2015/09/function-names-es6.html), and it's pretty cool for stack traces. Try this in Chrome: const foo = () =&gt; {}; const x = foo; console.log(x.name); // "foo"
&gt; It probably won't be a big pleasure to maintain hundreds of lines of code in a single file I inherited a code base with node js files over 4,000 lines long. Reading that only reminds me of just how fucked I am.
http://docs.aws.amazon.com/lambda/latest/dg/programming-model.html
I said 'node is a lambda runtime'. That doesn't mean it's the only runtime...
On the topic of "component architecture", Bob gave a good talk about how to architect your codebase https://youtu.be/Nsjsiz2A9mg. 
Which ones though? I only dislike the "use semicolons" one. My code just looks much nicer since I stopped using them and if you ensure that you're doing the "braces in same line" line thing you automatically wont fall for the new line pittfall. 
To say it another way, you should have files that work together on a feature in the same folder. Or regroup code by feature.
Never did a javascript server app, but you uses webpack for that? I thought that webpack was for frontend?
Honestly, it's not that they're bad, they're just very situational. What I dislike about the term "best practice" is that it doesn't leave room for critical thinking. I'd happily break all of these if it benefited the project.
You can check some numbers at the The Computer Language Benchmarks Game. If you want to try yourself just do some decent image processing using jimp against a C++ library (or a Node package using C++ under the hood) or ImageJ. Or FILTER.js vs OpenCV vs BoofCV for CV. BTW those were real comparisons we did for some requirements at hand. We decided to go with Java (ImageJ) for image processing and OpenCV (C++) for CV. We were NOT surprised with the results we got but we wanted to keep it simple by using a pure JS solution...
There‚Äôs a video course on codementor.com It‚Äôs 70 or so bucks and goes into node step by step. Or you can go to freecodecamp.com. I tried a few udemy courses but they‚Äôre not as great as codementor‚Äôs. 
Also, Koa supports HTTP2. The author of Express said a while back that it will never have HTTP2 support. I'm also pretty sure he said Express should be considered deprecated but I guess it's taken on new life since then.
You keep on throwing out these snarky remarks like they do anything other than make you look brutish and immature. I just eliminated the need for node our our backend utilizing lambda, and microservices. I'm sorry that triggers you.
&gt; https://github.com/trainyard/pico-lambda/blob/2e232f2306fd2a4fcad70e966fc97075f5deecb2/src/index.js#L31 ew
Your while asks 2 questions, but not the 2 you think it asks. You're basically doing while( ( annoy!=="yes") &amp;&amp; ("yeah")) You need to do each test separately.
I'm confused, the conclusion that was drawn is one that one would naturally come to you while using TypeScript.. I'm not sure what the extra libraries are adding in this story..
You mean, like normal people, who are competent and don't need a library to add two numbers together?
Hmmm, I would rather use es6 Set class. Not so many features but still. 
Yes, Sets are good for simple case of comparing elements by values. But many "what if" are exist that Sets simply cannot address: what if you want 1 and '1' to be treated equal, what if you want to compare by objects content, what if you want to compare only by part of the object properties, all noted above at once... and so on. It is handy to have a flexible library for such cases.
Does it use JSDOM to emulate DOM in node.js?
thanks for that link. I kinda half knew about it but reading that made it really clear. 
thanks, Axel is awesome.
Hi /u/casper-2004, For javascript help, please visit /r/LearnJavascript. Thank you!
This looks like a great too for JS testing, but I don't think this is the same use case as selenium, nightwatch, etc. Selenium, etc. can check your app end to end. The JS app, the API endpoints, the DB, etc. working together. They catch a category of bugs that are missed if you mock API endpoints.
As someone learning the language, this looks awesome. Just wish there was a cleaner PDF version I could print off...
&gt; JavaScript is pretty easy ... &gt; I found it all confusing Lol. Anyway, as someone has already said if you want a proper way to register and login users that isn‚Äôt a hack and is even remotely useful then you need a backend. I saw in another comment thread you were saying you only want to be able to access it yourself, so how about ditching the notion of logging in and just ‚Äúsecure‚Äù it by running it locally. You hold the copy, the code isn‚Äôt available online, so only you can use it.
This please 
.htaccess is an Apache thing and Apache is a web server. There‚Äôs no getting around the fact that if you want authentication you need a backend. When a client loads a web page it gets all the JavaScript needed to make the front end run, that code is viewable by anybody. You need to store user data away from that code or else any authentication you have is pointless.
All of Rico's cheat sheets are good. You can see the rest here. https://devhints.io/
For plotting anything onto SVGs via JavaScript I would check out D3.js. If it doesn‚Äôt have what you‚Äôre after out of the box there‚Äôll be a plug-in out there or you could more easily write your own functions.
With tools like Invision I don‚Äôt think it‚Äôs worth it. You‚Äôd be hacking away to get what you want done, even if it went perfectly it would be way slower than using a tool made for rapid prototyping, and it won‚Äôt help your designs skills. You‚Äôll have a better understanding of the limits of JS but you‚Äôd probably want to double check anything like that with developers anyway.
&gt;thanks, Axel is awesome. wait, who?
Axel Rauschmeyer - the blog he linked to. 
In the example I give in the readme it does via enzyme, and I think you should use something like that-- but the library doesn't do it itself. It just makes it easy to make asynchronous expectations in your tests, which in turn makes it easy to write these sorts of behavioral tests. You could also use this to test any other asnyc code.
Got bored at work so i created this 3D painter mini app, in my web game engine, not bad for a 15m break, http://nunustudio.org/examples/demo.html?isp=files/paint.nsp
I wouldn't know where to start because it's really a lengthy subject but I absolutely love this article: https://auth0.com/blog/a-brief-history-of-javascript/ It should be able to answer your question at its entirety, plus it's very, very interesting if you're studying anything web-related.
Yes, that's right and something I haven't highlighted clearly enough. This is not for e2e testing of your frontend in concert with whatever services it talks to-- this is for comprehensively testing the behavior of your frontend with mocked collaborators. In practice, I've seen a bunch of teams use tools like nightwatch to assert on any UI behavior that can't really be tested at the unit level. This leads to super slow CI pipelines, flaky tests, etc. I wanted to highlight in the readme that it is possible to assert on this sort of behavior with tests that look (and run) more like regular unit/integration tests.
That's pretty nifty. Although isn't one of the perks of anonymous functions the fact that you can keep your code super clean? `const filteredResults = [1, 2, 3, 4, 5, 6].filter(x =&gt; x &gt; 3)` Here, I'd need to create a filter function for that comparison?
Plus it‚Äôs much better to have 100 functions that operate on one data type than 10 functions on 10 different data types. Especially when using Redux and the likes where data tends to be the primitive arrays and objects you could easily apply this into a reducer or chaining array methods.
If you only need to have one login, you can take all of the secure aspects of the site (e.g. API keys), and put them into an object. Serialize and encrypt that object using a public key. Add a form that accepts a private key and decrypts the object and uses the keys. If it's too hard to separate the secure aspects, you could encrypt the actual javascript of the site as text and then eval it once it's decrypted. 
So I've done something like this in ava with essentially this https://github.com/avajs/ava/blob/master/docs/recipes/browser-testing.md Is there a reason why you would need an entire framework around this rather than using async/await? The same should be achievable by Jest. I can see why you made it, but not sure why one would use it in lieu of simply doing 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [avajs/ava/.../**browser-testing.md** (master ‚Üí c41b2af)](https://github.com/avajs/ava/blob/c41b2afc201118bfdc4d2039180ae2ddd0f697c9/docs/recipes/browser-testing.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
What do you await in your tests? When you‚Äôre testing app behavior at a high level across multiple components you generally don‚Äôt have access to the promise instances themselves. This library actually doesn‚Äôt set up jsdom rendering like in your example. It just makes it easy to make assertions when you don‚Äôt know (or don‚Äôt want to know) if the code is sync or async, or how many promises are involved.
just link to the full table, mmkay? https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html
Hey, y'all - I just published this package to NPM the other day and would love to get feedback! Also, big shout out to [jonom](https://github.com/jonom) for creating the original [jquery-focuspoint](https://github.com/jonom/jquery-focuspoint) that this was adapted from.
The code I wrote had 0 vdom components, so control was quite flexible, but because of that required jsdom. I don't recall using async for any of the code. You can use async/await with non-promises as far as I can tell, so should never need to know if promises are involved. ``` function t() { return 1; } async function main() { const a = await t(); console.log(a); } main() ```
Or a dual screen desktop wallpaper 
It sounds like your use case is a little different from what I‚Äôm trying to solve‚Äî this library is for writing assertions similar to functional tests, e.g: ‚Äúwhen I click the button, then I see a message‚Äù when that behavior relies on talking to one or more web services. Generally, this presents a big problem because you don‚Äôt know when your mock web service has responded: all your assertions run before the actual code has finished executing. As an aside, async/await is essentially syntactic sugar on top of promises‚Äî async functions always return promises. It‚Äôs just a different way of expressing them.
This is pretty nice. I only wish we could see what some of these statements return. 
You might wanna reword/rebrand this as most of the things you mention aren't what they seem... &gt;run thousands of times faster than nightwatch.js or selenium This makes it sound like you're actually offering something that has all the features of nightwatch/selenium, but really you're just using JSDOM or not even using a browser env. And.. &gt;Hereafter defers evaluation of each line in your tests until the promises and callbacks triggered by previous lines have completed. But as you answered to a comment below, this is trivially solves by async/await &gt;If asnyc/await is working for you, then you‚Äôre right, you don‚Äôt need this :) 
whoa, I catch myself coding files over 1,000 lines every once in a while but 4,000?!! good luck!
Node and React work really well together, so I suggest learning both. Right now, the "in" thing seems to be to use Node to create a minimal Express server that renders a simple HTML page, and then the heavy lifting / routing is done by React. There are numerous boilerplates to do this. I would start with create-react-app. It has enough documentation and should make sense to you since you know JS well. https://github.com/facebookincubator/create-react-app
Thanks for Mention the main URL.
Yeah, But you can do this by yourself. So you can learn things more better by practicing.
You can use something like web page to PDF editor for that.
I'll post my standard advice for learning React: The article "A Study Plan to Cure Javascript Fatigue" ( https://medium.freecodecamp.com/a-study-plan-to-cure-javascript-fatigue-8ad3a54f2eb1 ) is a great place to start. It gives an excellent series of steps for tackling modern Javascript concepts one piece at a time: Javascript, React, ES6, and state management. There's also a "Front-End Study Guide" based on that article that's very good, at https://github.com/grab/front-end-guide . On that note, definitely don't over-complicate the learning process by trying to learn many different things at once. Some people will say you should use a "boilerplate" to learn React, and they're wrong - boilerplate projects almost always come with too many pieces configured, and are confusing for beginners. Instead, the best advice is to focus on learning React itself first. Once you have a good understanding of how React works, you will better appreciate why a state management library like Redux can be useful, and you can learn about other tools later. You should start out by reading through the official React docs and tutorial at https://reactjs.org/, and I'd encourage you to use the official Create-React-App tool ( https://github.com/facebookincubator/create-react-app ) for setting up projects. It creates a project with a solid build setup, with no configuration needed on your part. There's an excellent post called "Simple React Development in 2017" ( https://hackernoon.com/simple-react-development-in-2017-113bd563691f ) that gives some more specific instructions on the actual steps to follow. For an even simpler setup, CodeSandbox ( https://codesandbox.io ) is an online editor that lets you build entire React projects right away. Past that, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. It includes links for learning core Javascript (ES5), modern Javascript (ES6+), React, Redux, and much more. I also published an "Intro to React (and Redux)" presentation at http://blog.isquaredsoftware.com/2017/02/presentation-react-redux-intro/ , which is a good overview of the basic concepts for both React and Redux. Finally, the Reactiflux chat channels on Discord are a great place to hang out, ask questions, and learn. The invite link is at https://www.reactiflux.com .
Pretty solid list for the beginners!
Seconded. If you know JS, you can get up and running with React in a solid weekend iand fill in the rest as you go. Express is similarly trivial for basic routing. I'd add that the OP will need a bit more than a minimal Express server to handle the DB queries and login credential stuff. For the latter, check out Passport: http://www.passportjs.org/
How about npm-GIK
The idea here is nice, somewhat similar in spirit to date-fns, but for native Array/String/etc methods, but there are some issues. For example, `map` remains non-unary like its `Array.prototype` counterpart, meaning that you still get composition problems when using point-free style, e.g. `map(parseInt)`. Implementation-wise, it's a shame that it doesn't use ES6 modules; this lib could potentially be a good candidate for tree-shakeability like date-fns
Apply anyway, JavaScript recruitment is a joke!!!
Could you pleas post whole request response screenshot. From here it looks like you are using etag or some other cache for api calls, thus it return 304. Try adding If-none-match: [some random number] to your request header. Once you get responce 200 take screenshot of that...
Yeah, IÔ∏è don‚Äôt get how these employers expect a JUNIOR DEV to have 3+ years in js, front end frameworks, and numerous other random shit thrown in.
&gt; I have a PHP/MYSQL app that I have developed over the years and want to level up my skills and recreate it with server-side JS. &gt;I am considering doing this with Node or React. Any thoughts on the best choice here? Node is server side js. React is client side js. 
how to write javascript like it was 2007.
pin this shit immediately
Great info here! Thx much. Dumb question can react be used with node? Or apples and oranges? I am generally trying to become a better js programmer and break out of small biz websites and use a personal project that is rather complete as a real world example. There is no need for real-time updating of content on the page, my app spits out static HTML right now. Again, lots of MySQL and js / jquery integration. Is react the best choice?
Awesome. This sounds like a great path!
C# is fairly popular for backend/server-side, and it's actually fairly nice as far as languages go. I'd definitely recommend looking into it if you have time to invest.
Hi /u/riteshkind, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I wrote assertions as well. Basically, create a fake browser environment, operate on fake dom, which is pretty much what enzyme is going for the vdom world. All the functionality of my components are fairly functional and I can pass in the data I need. test('getExpanders', t =&gt; { const emailChain = email.getChain(chain.element); const possibleExpanders = emailChain.querySelectorAll('div[aria-hidden="true"]+div'); t.is(email.getExpanders(possibleExpanders).length, 3); });
In an apples to oranges comparison; React is an apple, Node is an apple tree . You don‚Äôt have to know a lot about node to use React, but you do have to know enough to climb the tree to grab an apple . 
There's no need to create a new element ‚Äî simply change the `src` attribute of the existing element.
The key thing is that promises (and by extension async/await) in your tests don‚Äôt really solve the problem when you‚Äôre attempting to assert on a real-world application. To wait for a promise resolution in your tests requires having access to it‚Äî that‚Äôs generally not possible or desirable when describing the behavior of your app at a functional level. It‚Äôs fine for lower-level tests or simpler/different use cases. I agree, though‚Äî i think I could definitely illustrate what it solves better in the readme.
You don't have to use either feature. :) Personally, I use "true" anonymous functions where it's obvious and self-contained (e.g. map() or filter()), and named methods or functions for bigger things.
Somebody at big company X has come out with a new way of doing the same something, everybody aboard the hype train. I'm honestly waiting for Facebook to come out with a new keyboard layout for React developers, and you must have at least 2 years experience with it to get a React job. 
https://github.com/alvarcarto/url-to-pdf-api
Nice find! I love how simple these cheatsheet are.
Actually, Prettier is really nice. It solves a lot of pain points around code formatting. Have you tried it? 
It's still worth noting how to switch.
I use flow with react every day and find the combination works really well, and worked well even before the [major improvements in flow 0.53.0](https://medium.com/flow-type/even-better-support-for-react-in-flow-25b0a3485627). That said, I haven't tried typescript - perhaps that is even better. In any case I actively like using flow with react. Another thing I like about using flow is that you can use [flow-runtime](https://medium.com/@gajus/ode-to-flow-runtime-ed78b2e10ec8) to transpile the static type annotations into runtime assertions, which is pretty cool! 
Jquery doesnt play so nice with react because of its DOM changes... However Node / Express is incredibly simple to set up and get going. If you have a standalone machine like a linode box etc, i just did nginx reverse proxy to node / express, and hardened the whole machine, just for the fuck of it. hell you can even do an nginx to node / express to react too. I let nginx handle the SSL certs. react is also the new hot chick in the room, so theres that.
what's better Prettier or Beautify?
I would have said flow because typescript taking over the build system was and is a terrible idea. But now that babel 7 has finally taken that away from them it can behave like any other modular tool now and has more support for 3rd party types. I still think flow is more elegant, and once it learns to read TS types, i will discard TS.
Thanks for this little comment, I am just learning JS and most of the training and books include a section on JQuery. So reading articles like the one OP posted make this process more frustrating. Thanks for saying JQuery isn't bad and giving the reason. (also this is my first Reddit comment after lurking for years, so have an upvote for making me comment)
I'd note that object spread isn't even stage 4 yet (though I'd say it's undoubtedly going to make either the 2018 or 2019 spec). Similarly, object getters/setters -- though largely forgotten -- are ES5 constructs. Some useful stuff is also missing * Class get/set syntax * Symbols (and well-known symbols) * new properties and functions for math, number, array, string, etc * Proxies * Proper tail calls
I mean the instructions and test cases seem quite clear. Also, my friend, use the google. This is the day-to-day of a developer. You get thrown into shit you don't know and you have to figure it out. 
lol thanks
A junior dev shouldn't need much experience, but they should be semi-knowledgeable in JS. Confidence is key in this situation. Those job requirements lists mean little in the end, and since you have equivalent experience in another programming language I'm sure it'd be fine. Apply to anything you're interested in and ignore the requirements.
Looks like they just gutted that src/emitter.js file. The blueprints for what they want are in the specifications file. Karma will probably alert you if your shit is lacking. You're gonna wanna have some experience with Node.js and webpack / babel. Doesn't look like their package.json file is utilizing babel at all how it stands.
I'm sorry I'm a novice and I guess I may just not be familiar with Heroku, but where do you store dependencies when deployed to Heroku?
I prefer Flow. I believe it has better React support according to [this](https://medium.com/@calebmer/flow-has-better-support-for-react-42a8768163ef) which states that TypeScript doesn't have support for default props or strictly typed children. However, TypeScript has the advantage in tooling and the amount of library definitions available. Just keep that in mind when deciding.
it's 2.9 3 is on PR already
C# is still quite big, especially on the backend, but it shares lunch with nodejs and go now. On the frontend it is shrinking fast. Xamarin hasn't gotten traction. Even Microsoft, after investing and then buying Xamarin, use javascript for their own cross platform apps, and react-native as their new strategy for universal apps. From what i observe in our company and industry partners, C# is declining everywhere. We went from 100% C# on both frontend and backend in maybe 5 years to 10% on the frontend (most apps converted to either web-apps, electron or react-native), to 50% on the server. 
Probably because you live near LA. Due to JavaScript's prevalence, there have been a lot of people doing JavaScript work coming from all background in last few years. So there are probably a lot of designers and creative types entering JS development in LA. 
My issue is that I don't know what the tests are expecting. I've never dealt with tests before and I don't know if I'm supposed to keep the original functions in the emitter.js file or not. The task also says that I can use my preferred JavaScript specification which in my case would be Angular 4 / TypeScript but I'm not allowed to use third party Node Modules according to the specs.
Yes I've tried it, its nothing but a js beautifier without options. Some choices they made are so bad I had to abandon it. They disallow padded code blocks, which is just a disgusting choice for code readability, which has been best practice for decades, and refuse to change it. https://eslint.org/docs/rules/padded-blocks
I think you're going to just want to write the thing in vanilla JS or ES2015+ to ES5. You want to keep those 4 functions that are in https://github.com/Frosmo/emitter_task/blob/master/src/emitter.js Look at this file: https://github.com/Frosmo/emitter_task/blob/master/test/emitterSpec.js That's what karma is going to run when you shoot off a test with 'npm test'. When you run karma, it's going to run your functions and make sure they return the right shit given various parameters. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [Frosmo/emitter_task/.../**emitter.js** (master ‚Üí db0e6d0)](https://github.com/Frosmo/emitter_task/blob/db0e6d0ae4966dd8ea852904134d9584965e0932/src/emitter.js) * [Frosmo/emitter_task/.../**emitterSpec.js** (master ‚Üí db0e6d0)](https://github.com/Frosmo/emitter_task/blob/db0e6d0ae4966dd8ea852904134d9584965e0932/test/emitterSpec.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
I work on TS so I'm biased. I &lt;3 static types, and think they bring a lot of benefit either in either system, so I'm glad you're looking at either. There's definitely a big community around React &amp; TypeScript. For instance, customers like [Slack](https://slack.engineering/typescript-at-slack-a81307fa288d), [Lyft](https://eng.lyft.com/typescript-at-lyft-64f0702346ea), [GitHub](https://githubengineering.com/how-four-native-developers-wrote-an-electron-app/), [Tumblr](https://twitter.com/tumblreng/status/907619955180482560), [Asana](https://blog.asana.com/2014/11/asana-switching-typescript/), Reddit, and several teams in Microsoft. Basically the way our team thinks about it is that TypeScript is a type system that should work for all JavaScript users, and that includes giving an amazing experience for React users too. Feel free to check out [our Gitter channel](https://gitter.im/Microsoft/TypeScript) if you have any questions.
good bot
I did not know that! That is great info. Thanks,
I really like typescript. The fact that it has a compiler makes it very solid in my opinion. It allows for things like abstracts and other stuff that goes beyond a type system. And the @types packages are easy to use and cover basicly all that you need for declaring package definitions. And I feel like the typescript service is faster at reporting errors in my ide than flows.
Thanks for your input! Doesn‚Äôt really help since I still don‚Äôt know what it expects. I mean I do know but still dont. Should I have a function outside those four functions which I pass to each of those functions as a parameter and make a callback to it or what. I really didn‚Äôt imagine I would have such a hard time dealing with this task since I already know how to build quite large apps with Angular, Node, MySql. Just one of those moments when you realize how little skill one actually has.
The thing about padded blocks, is most of the time they're used to space out significant chunks of code. Most of the time, it isn't that helpful in terms of being used across the board, and then you get back into the issue where you're having to deliberate over spacing. IMO it's fine once you get used to it. That being said, it's a tool you can choose to use, but it's nowhere necessary. It's good in my company because we all agree we spend way too much time worry about the formatting of our code, and Prettier just handles this for us automatically. Further than that, we just have to accept at the end of the day, that web development, especially front end, especially at the current moment, is going to be in a state of constant flux, while people realize newer, better ways of doing things.
I'm thinking you're just building a 'module'. This means you're only responsible for functions of this Emitter object. Hypothetically someone would be able to import * as Emitter from '../src/emitter'; and then hit your functions. (This is what that karma test file is actually doing.) All that you're responsible for is making that test runner happy. Scroll down in that test file, you'll see some stuff like this: expect(Emitter.off(EVENT_NAME_ONE)).toBe(0); expect(Emitter.off(EVENT_NAME_ONE_UPPERCASE)).toBe(0); expect(Emitter.off(EVENT_NAME_TWO)).toBe(0); expect(Emitter.off(EVENT_NAME_THREE)).toBe(0); It's sending that emitter.js file some bullshit constants and seeing if your functions return the right shit. I know what you mean man. I'm just learning as I go too. I have no clue about how angular works. 
For learning, they about the same. Both has roughly the same language features. The syntax differences are pretty self-explanatory if you know how they work. For usage with other libraries/frameworks, Typescript is better, due to the fact that the community driven [DefinitelyTyped repository](http://definitelytyped.org/) has been around for longer. Flow has similar thing with [flowtype](https://github.com/flowtype/flow-typed) but it is smaller. For React support, Flow is probably better, since it is first-party support by Facebook.
Are you looking for a pre-built module you can load in, or are you looking to make it yourself? A quick Google search brings lots of results for the former: - jQuery (https://jqueryui.com/datepicker/) - AngularJS (https://720kb.github.io/angular-datepicker/) - so many more (https://www.google.com/search?q=datepicker+javascript) If you want to make it yourself, you'll probably rely on `new Date()` quite a bit (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date).
That made some sense now! I‚Äôll try again tomorrow since its midnight here in Finland now. Thanks bud!
We previously used js-beautify and we moved to Prettier. To us, it felt like js-beautify was having some issue with some of the newer ES2015 syntax, and it was becoming an agitation point for us. Prettier felt much more consistent with what we expected. Simple things like having 3 options for trailing commas ("none", "es5", or "all") and having configurable parsers (for flow, typescript, etc) just really helps with the transition. That being said, we have since moved back to using ESlint with --fix to handle most of the same things. Prettier was very convenient but in order to keep things simple across our organization, we kept the number of different technologies down. 
They could have handled padded blocks much better, it just makes me think they don't have much experience, believe it or not. Prettier preserves single newlines, but murders padded blocks, are you kidding me? From this { chunk one chunk two chunk three } To this? Are you kidding me? { chunk one chunk two chunk three } 
Np dood. Good luck :)
We gave up on Flow recently on a project at work and ripped it iut. I love strong typing and I'm the one who originally championed it but eventually we decided the pain wasn't worth the benefit. The main problem was that Flow's error messages are absolutely terrible. They can be completely indecipherable and point you towards the wrong line of code After using Elm on side projects for a while and seeing how well it's type errors can really help drive development in a TDD style feedback loop it makes me sad that Flow doesn't live up to that potential at all :(. 
Honestly I'm a fan of theirs. I don't think a brace that already is on it's own line with no other characters, needs another empty line of padding. TheS space between lines that have 5+ alphanumeric characters... I think it's fair game and a lot more useful. It's tough because we can both agree that more padding isn't always better... there is a certain benefit to seeing more of a file onscreen at a time that tons of padding impedes on. Where that line is drawn.... is going to be subjective but I like their current stuff. I think it's a great fits most sizes approach. They can always add options for what you're asking for... they do allow customization for some of their stuff so it's not out of the question.
Believe me, I tried to get them to change it, they shot me down sayings prettier 'is opinionated'. For decades developers have been doing something called 'chunking' (at least in the perl world it was called chunking). Its to make your code more readable by putting things together. It seems to me since they don't squash all newlines they might agree, but not incorporating that into a block structure makes no sense, looks more like an oversight, or they decided it was too difficult to make work. 'allow newline after { if block has chunks, otherwise remove', they just opted for nuke all /{\s*/s 
The code could be made significantly more legible if you created a constant dictionary of the argument counts of each of the plucked functions. In which case, you can also use `switch` statement instead of cascading ternary. 
Wow, yeah it must just be the area I live in. There are plenty of JS postings... just with ridiculous requirements even for junior.
Right now I would say I am proficient in Javascript/Node.js. I really prefer back-end but there are not as many job postings within 50 miles of me. I messed with react a bit but backed off once I got into redux (I jumped straight from learning react into redux and I think it made things a bit more complicated than they really are). I also did a digital interview and passed 2/3 questions easily... haven't heard back from them. The one I missed involved heavy use of regex and honestly I would have been exhausted/annoyed by the end of it. It was the first question...
Currently fairly deep into Node.js so I am debating if it is worth putting that aside for C# at the moment.
There are very few people who are good at regex. The sad part is you might not hear back from 99% of the places you apply for. My advice is to update your LinkedIn profile to add all of your experience. Any update will send you to the top of the recruiters' lists (it's based on last updated timestamp). A more complete profile will get you more attention. Don't be afraid to contract for a while. If you can't find a permanent position, maybe a 6 month contract will suffice, and it'll give you the experience. In Seattle where I work that's pretty much the only way you can find a programming job nowadays. There are only a few companies hiring full time developers. Can I ask where you're located?
I‚Äôll definitely do this. I‚Äôm currently located in Irvine, CA but plan to move around Denver in about a year.
I agree, I don't understand what's better than eslint with --fix Actually I get it - it's for people who don't want to think
TLDR: YES. Start now and don't look back. your powers will be compounded. ---- Apologies in advance for the long post. I'm a designer who spent the past year and a half learning JavaScript and other web technologies. In my opinion, the answer is an emphatic yes! I've found studying computer science and programming - via JS - to be incredibly beneficial, empowering, and satisfying. I appreciate technology much more now that it's demystified. My design horizons have expanded considerably - a major benefit. The learning curve is steep and requires time (this may be explained by the fact that I taught myself, your experience may differ). I paraphrase Douglas Crockford, a notable JS developer, who said something like, 'programming is difficult business and should never be undertaken in ignorance.' Haha, well... I found there's really no way of getting around the ignorance part unless you just dive in and get your hands dirty. I'm still horribly ignorant but I manage, day by day. Patience and dedication are key - I've spent months repeatedly reading, highlighting, and annotating bits of JavaScript to decode it's syntax, features, and flows. Each time I thought I understood it, but in reality I learn something new. It's humbling. Code is dense, just like design - lots of hidden structures account for the richness of deceptive simplicity. On the point of compromising design for the sake of engineering: I think there's a bit of truth to this, but I'd personally be suspicious of anyone who tells me design and software engineering are at odds. it's not like adopting an engineering-oriented mindset will do any permanent damage to you as a designer, haha. While learning programming, out of necessity, I spent less time dedicated to what most people may call 'designing,' but in my view, the paradigms, structures, and architectures of logic and computation constitute design systems in and of themselves. Just my own hypothesis, but I think the dualistic concern stems primarily from tribalism and who's paying the cost for one to gain design and development experience. I try to stay vigilant about my strengths and weaknesses, and remind myself of what I'm ultimately striving to do. During my initial period of learning, I would say my aesthetic sensibilities regressed somewhat because I was so stuck in the weeds of debugging code that I made compromised aesthetic decisions under the influence of what I'll call "developer aesthetics" and what's easier to implement. To this extent, I can empathize with why developers want to take a simpler, safer path, which to be perfectly clear, is truly the best decision at times for any number of reasons, not least the avoidance of pain, but I also don't believe the developers' credo that 'simpler' or more 'elegant' is necessarily the better path. Once I accrued some experience and gained a degree of confidence in JS, I started to make bolder design decisions again, which I could now implement in code! Another benefit to knowing programming is having a sense of literacy about technology, which is empowering. Sometimes people are just lazy and take advantage of your ignorance. Now you can ignore developers who throw a wet blanket on your ideas! üòâ It all comes down to how much time you're willing to put in to achieve good results - like with anything. Good luck!üçÄ 
Prettier isn‚Äôt a FB project. It‚Äôs a project by an FB engineer. It was pitched within FB the same day it was launched to the public.
You've got a few options here; You can use partials for each button that are only rendered if the user has access permissions. At the very least, I'd use a partial for the buttons area/holder. You can also use a server-side rendering, and this would be my recommended choice. Within your template, you would render the button only if the user has access to that 'service'. For example, if you were using EJS with Express, you might do something like this; In your route handler; ` getUserPermissions(function(userErr, userData){ res.render(__dirname+"/template", {user : userData}, function(renderErr, html){ res.send(html); }); }); ` And in your template; ` &lt;% if (user.Services.Orders == true){ %&gt; &lt;button onclick="javascript:location.href = '//mydomain.com/orders'"&gt;Orders&lt;/button&gt; &lt;% } %&gt; ` 'getUserPermissions' would be a function which would query your access/permissions system or database to find out what services the user has access to. This would, in this example, return an object that contains a services object which contains booleans for the services they can access (in this example, 'Orders' is 'true'). EJS isn't used much these days compared to react or similar, but the overall practice is similar if using most server-side rendering engines.
Lol, you said 'poop'. Thanks for the explanation!
That's exactly what I said. I can guarantee you that if I had written prettier nobody would have noticed. There probably have been a hundred different Prettiers before this came out, and nobody noticed.
Have you tried using Prettier as a plug in for eslint, works great.
No, it‚Äôs not. You implied that it was a FB project. My point is that its success has *nothing* to do with FB. That may have gotten people to look at it, but it‚Äôs successful because it‚Äôs damn useful. Yes, there have been similar things before, but did you ever try any of them? I did and they all caused more problems than they solved.
What does "fairly deep" mean? Can you lead a Node.js full stack project? If so, you should have little trouble picking up C#. If not, get a few more projects under your belt first.
Thanks for sharing! This is what I used up till now, with lacklustre result I‚Äôm afraid (-: Guess I have to start hoarding older tablets / smartphones. . . 
I haven't actually, though I heard there were 3 different ways for configuring prettier with ESLint? pretter-eslint, eslint-config-prettier, and eslint-plugin-prettier? Are you actually referring to this last one? I'd be interested in investigating it but given the options, maybe you could save me time in talking about any considerations you had for the others if you chose the plugin over it.
That unary operator is beguiling AF. it's so random it's paradoxically unforgettable.
&gt; Somebody at big company X has come out with a new way of doing the same something Not &gt; Big company X has come out with a new way of doing the same something
... yeah, whatever
I go the plugin + config route. Basically, Prettier just becomes part of the fixing process, you don‚Äôt have to think about it at all. It‚Äôs the same experience as using just ESLint, but you get consistent-looking code. The config just helps by disabling parts of ESLint that Prettier will handle instead. 
Many features of many languages are "sugar". Unless you're writing machine code, you are taking advantage of abstractions that are there to make your life easier.
So salty. Prettier is just a tool. It works for some workflows, not so great for some other, YMMV, etc. Chill out :)
Obviously I am tying the two together but don't seem to see why I'm doing it. Whether its a FB project or somebody at Facebook it doesn't matter, you clearly know it has something to do with facebook, so it gets added to the hype cycle, whether its a great achievement or just a bad rehash of the same old stuff.
I was working at FB when it was launched, so the odds that I know it has something to do with FB are a bit skewed ;) But even if I‚Äôm biased, you‚Äôre biased against it. You‚Äôre dismissing it as having no value *because* it comes from someone at FB. It‚Äôs by far the best code formatted I‚Äôve ever used. I‚Äôm not claiming to have compared every one in existence, but prettier saves me a *lot* of time
https://gist.github.com/96bdce87aaf486d49968f34b42434eca This is my gist note on it. 
sorry?
"where" converts the eager load to an inner join, unless you explicitly set the "required" flag to false. include: [ { model: B, where: { col: val }, required: false, } ] 
I'm not biased against it, I think it sucks. I used it for week and got sick of the mess it was making, tried to get it fixed, was rebuffed because its 'opinionated', went back to js-beautify, which works well.
Thanks, I added the required: false but the query still quite isn't what I want it to be yet. Adding in the required gives me: SELECT * FROM table_a a LEFT OUTER JOIN table_b b ON a.id = b.id AND b.col = val; Is there a way to move the b.col = val away from the join condition, and inside a subquery, like: SELECT * FROM table_a a LEFT OUTER JOIN (SELECT * FROM table_b b WHERE col = VAL) ON a.id = b.id; 
Hi, what about editor support (IntelliSense and real-time error checking)? I've used both flow and TypeScript as well but find that flow's VSCode support is very very bad compared to TypeScript - it's very slow to show code completion, sometimes inaccurate when showing which line has error, and has much less type definitions for libraries out there If anyone has any tips for optimizing flow, I'm open to suggestions..
I used to work at an accounting firm that had quite a few clients. They needed someone to come up with an app that would allow them to login from anywhere and view client data such as payment plans and such. I couldn't do it back then so recently, I decided to create the app. It employs Node.js/MongoDB/Express for keeping track of client data and the website itself was designed with just html/css/javascript and SemanticUI (no front-end framework). I used ejs for rendering the pages.
Thanks! We might do that if it doesnt add too much to the byte size, or if we decide the byte size isn't that important. 
Very good point regarding the unary issue. Might be able to figure something out
Yes. Architecturally, a React client-side app is generally just compiled into static HTML/JS files. If there's an application server with an API, it doesn't matter what language that app server is written in, as long as the API is available - could be written in Node, Python, Ruby, Java, whatever. However, almost all Javascript build tools (like Webpack, Babel, ESLint, etc) are themselves written in Javascript. That means they need Node installed on the build system so they can run, in the same way that a Python app needs Python installed, a Java app needs the JRE, a C# app needs the .NET Framework, etc. So, you may not need to learn how to write a Node-based server to use React, but you will probably need to have Node installed to run the build tools that are normally used by React apps. That said, it would also be an interesting project to recreate an existing PHP server app using Node-based tools/libraries like the Express web server and an ORM like Sequelize.
Ah, I'm honestly not too sure. But "attributes" may help here to change what is returned from "B" This example is untested. include: [ { model: B, attributes: [[sequelize.where(col, val)]], required: false, } ] 
Yes, let's get upset about people releasing awesome tools for free.
How would git know what hooks are defined in a `package.json`?
Hi /u/Old___Dude, For javascript help, please visit /r/LearnJavascript. Thank you!
Thank you, I will do that. Sorry for posting in the wrong place 
Ok. I'd recommend doing some more projects using SQL first. At least one with close-to-the-metal SQL, and one with a ORM. Ideally, also another with restify/swagger. And I mean work projects, not toy ones. That will probably be at least a year of investing in the Node stack and solidifying fundamentals. Alternatively you can take the plunge and learn .NET now. Obviously there's the extra learning curve of the new language, but the tooling is more or less similar with different names. In .NET, pretty much everyone uses MSSQL, and usually Entity (an ORM), although there are many options with varying degrees of lightweightness, Dapper being one of the closest to the metal ones. MVC5 is sort of the Express of .NET. It has a templating language called Razor that is fairly straightforward. IIS is basically how you run the HTTP server. Main difference is that it's a Windows service, rather than a script. Language-wise, you'll find that C# is basically a more modern and safer C++, and there might also be some learning on the tooling side, basically getting up to speed with visual studio. 
Awesome, I‚Äôll look into this. IÔ∏è do have a few apps that I‚Äôve built out in both mongodb and another version using SQL. I‚Äôll just continue with Node for now but need to keep looking for dev jobs as my current job just does not interest me at all (Currently a shipping manager for a small company).
&gt; this Err? That statement is just wrong. Default Props can be set on stateless / stateful components just fine. Here is a link to the definitely Typed file: [Link](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts#L325) Strictly typed children are defined as a React Node.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [DefinitelyTyped/DefinitelyTyped/.../**index.d.ts#L325** (master ‚Üí e562021)](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/e5620215b5b38f76a1eecb294bb3cce2cc948b0f/types/react/index.d.ts#L325) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dpi4r3r.)^.
Hmm, a work project is, well, a project that you do as part of your job as a developer. If you're not already employed as a developer, it's a bit of a chicken and egg problem :) You can still get your foot in the door in various ways. If you know the "lingo" and have at least the basics in your toolbelt, you can talk your way into some larger corporatey companies fairly easily. Other options include freelance, and joining a company that is actually looking for a junior (rather than the junior-that-is-really-a-senior BS that many have been trying to pull off lately)
Good point. Just updated the post. You also need to pull in the lint-staged npm module. 
Ah alright, thanks for the info.
Yes it is. i'm glad if my find helps you :) 
Hhahahaah!
Hey, If you have any query or something like then you can simply contact with them. So it may helps other developer to learn everything!
Well it doesn‚Äôt suck, it does exactly what it was designed to and it does it better than any competing software I‚Äôve ever seen. You don‚Äôt like the formatting rules they chose, cool, that‚Äôs a perfectly valid opinion. But FB‚Äôs name around it still has *absolutely nothing* to do with why people like it. I like how it formats code (mostly, I have a minor gripe or two) and it has far fewer issues than js-beautify
Will prettier use the settings I have for it from my package.json or do I need to specify the cli flags?
Flow. They‚Äôre both great but flow‚Äôs automatic type inferences are amazing, and the way it handles possible null values (well, it handles them) is far better than TS. Someone can correct me if either of these have changed recently, I haven‚Äôt tried TS in a little while
Well I disagree, I think it's reinventing the wheel, I think it would have been mostly ignored if it wasn't associated with FB. I remember the second I heard about it I knew it was somehow related to FB, must have just been a coincidence?. 
As I said, FB's name may have gotten more people to look at it. But FB, Google, et al have released plenty of open source things that nobody cared about, usually because they weren't generally useful but useful only in the companies' context. It's popular because it's useful. I honestly don't see how you can argue with that. You can say that you don't like it because you don't like the admittedly opinionated choices that it makes, but it fills a gap.
Why do you not use javascript to implement javascript interfaces?
Typescript. 
Its popular because its *usable* and associated with FB. That's all you need. Code formatters have been around for decades. 
Show me one that works with ES7, and react, and literally *anything* that babel can support, and that can split lines of code and correct things like missing semi-colons or trailing commas. This has *nothing* to do with FB. John Doe could have written this and it would be popular, it would have just taken longer.
Flow. TS doesn't catch errors on nullable types which makes it a complete no-go for me. Simple example: function foo(bar?: string): string { return bar; } TS is happy with this, flow isn't. Flow complains that you could be returning null/undefined from a function that expects you to return a string.
Thank you for posting this, I just finished a course on es2015 and will no doubt use this as a reference.
Best Practices NodeJS https://github.com/i0natan/nodebestpractices
The perfect Front-End Checklist for modern websites and meticulous developers http://frontendchecklist.com https://github.com/thedaviddias/Front-End-Checklist
Learn ES6 by doing it. Fix failing tests. Keep all learnings. http://es6katas.org/
links down for me..
 Learn ES6 by doing it. Fix failing tests. Keep all learnings. http://es6katas.org/
It will be format and prettify javascript before commiting to git See here How to run ESLint using pre-commit hook https://medium.com/@shettyrahul8june/how-to-run-eslint-using-pre-commit-hook-25984fbce17e
Having used both (Flow for one very large project and TypeScript for a few less large projects) I am very much in the TypeScript camp now. Firstly, DefinitelyTyped has vastly more library defs available than flow-typed, which matters a whole lot more than you might realize. It's pretty rare that `npm install @types/name-of-package` comes up empty. Secondly, Flow feels slower and buggier; I use VS Code full-time and have found that TS reacts to code changes far more quickly and accurately than Flow (almost instantaneously across an entire project), and provides much more useful error messages (I lost count of the number of times I saw `merge_strict_job exception: Utils_js.Key_not_found("LeaderHeap")`, which I believe usually indicates a bug in Flow itself but is also completely useless and extremely difficult to debug). Of course I realize that TS and Code are both Microsoft products so it's not surprising that TS works better, but even in Atom with Nuclide I found that Flow was a bit slow to catch up to things, and still sometimes threw very cryptic errors. Finally, TS has a pretty solid built-in compiler which tracks the official spec, and natively supports features like `async`/`await`. To your original question, I'm currently working on a React-heavy project with TS and have found it to have excellent support. Flow works very well with React as well, which is to be expected since both come from Facebook. I think either would be a fine decision, but definitely feel TS has the edge in stability and speed.
Please provide more information and attach some example
Same place you do for every node project: the package.json file
@andynaguyen You need to add association in model A, its like a A.associate(B) See here example how to use include https://gist.github.com/zcaceres/83b554ee08726a734088d90d455bc566 Association need to add in A.model.js And see here how to add association http://docs.sequelizejs.com/class/lib/associations/base.js~Association.html
So, I'm still learning, but mostly am messing with node and electron. What exactly is ES2015?
Lambda only supports 4 languages. Node, Python, Java and C#. Not using Node just means you‚Äôre using one of the others. 
TypeScript is faster, has better tooling, less bugs, and a bigger community. 
Wrote a blog post on how promises work in JavaScript. Still a WIP but take a look: https://medium.com/p/dd6908092138/
I don‚Äôt really see this as ‚Äòinterfaces‚Äô, rather, it is a runtime check of an object properties. For that reason it is more of an assertion library. The main advantage of interfaces (in languages like TypeScript) is that they provide compile-time type checking.
Came here to say this.
Never saw code completion as something important. Typescript kept me from writing async, or use spread, and these days it would have kept me from things like this `a?.b?.c ?? d` instead of `a &amp;&amp; a.b &amp;&amp; a.b.c != undefined ? a.b.c : d`, i just didn't want it to transpile or cripple javascript. Now that babel has solved it for them, i'll look at typescript again. 
You're not really storing it there though are you? In a node project it's listed in the package.json but stored in the node_modules directory.
Hey mate, thank you for this long post. Knowing that you are designer in front and code in the back made this post interesting to me :). As i understand, you use JS as a design tool, you do not see yourself as programmer, but rather understand how all this works? Because if i look it my way, i can make any prototype very dynamic in minute with Axure (do you use it?) so i was thinking, why program? But than again what you say makes sense. Do you code JS, HTML, CSS and than pass that code to developers to continue or to edit that to make product? 
&gt; Finally, TS has a pretty solid built-in compiler which tracks the official spec, and natively supports features like async/await. That always used to be my biggest gripe, because this is not what they're doing. They arbitrarily pick a draft here and there. Async/await came 2 years after babel had it, spread came years after half the web used it (everything that had redux in it). And these days you miss out on other things like `a?.b?.c ?? d` instead of `a &amp;&amp; a.b &amp;&amp; a.b.c != undefined ? a.b.c : d`, pipes and many more. Even if you just want to test and give your input back to the standards bodies. Babel is directly involved in the tc39, they track each and every proposal and follow it through the draft stages to completion. The `env` preset tracks completed specs, the `stage` presets track everything below. But as i said below, babel 7 can read typescript, so typescript can now be used for what it's been made without interfering.
Why make a blog post, when the github repo covers everything and is always up to date? 
Always faster than I can summon you ;D
good code is all about writing error less and strict code in that case typescript is far superior than flow. As a JavaScript coder shifting to TypeScript is painfull but good things doesn't happen easily. Sometimes TypeScript strict type checking can make you think of jumping back to JavaScript but beleive me its worth coding in TypeScript :)
As of the last few releases, typescript has async and spread even before that. This all predates any Babel Typescript support, btw. My companies build hasn‚Äôt migrated to Babel. I‚Äôve experimented with it, but there isn‚Äôt really a benefit, yet. (Not that I‚Äôm against Babel, prior to my current stack it was a staple of what I was working with.)
u/albedoa is right. You also need a conditional check so that your code isn't executed outside those dates. You may also want to preload the holiday image. [See this fiddle](https://jsfiddle.net/dfrxz0w4/).
If you only need 2 images you can make an if else statement to switch between the images
Yes, they added it only recently in 2017. Babel had this 2014 i believe. &gt; I‚Äôve experimented with it, but there isn‚Äôt really a benefit, yet. Um, yet? Babel is the better transpiler, TS doesn't hold a candle to it. As i said it is directly involved in the tc39, they have a gigantic community, they track all proposals, have them years earlier with less bugs and problems down the line. With TS taking over transpilation all you do is limit your code. Not to mention you're cut off an entire eco system of meta plugins. 
[Here ya go! Not the prettiest but it gets the job done.](https://codepen.io/Olliebaba/pen/ooYzMb?editors=1010) Also, be sure say 'javascript'. Java is a different language, different community, different eco system entirely.
You can pass a reference to the image directly through the onClick event instead of using a name attribute. 'name' is typically used for form submissions and element manipulation is done directly as below, or with classes or IDs. onClick="rollover(this)" then function rollover (image) { if (image.src === "http://graphics8.nytimes.com/images/misc/nytlogo152x23.gif") { image.src = "http://graphics8.nytimes.com//images/2010/04/09/bucks.gif"; } else { image.src = "http://graphics8.nytimes.com/images/misc/nytlogo152x23.gif" } }
Will there be videos added to youtubes? I'd rathe catch up on the discussions on my own time.
Wow! You're awesome thanks so much. So to make sure I understand this, you're essentially using a if else statement to check that the displayed picture matches the hyperlink? It looks like src1 and src2 are checking against the document.picture.src? 
Java***script***
TIL
This is more a topic for /r/learnjavascript, but I'll answer nevertheless. Here's a simple solution that, apart from the DOM Level 2 Events (onclick attribute instead of using addEventListener) might even occur in real life: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;JavaScript Assignment 4 Part 3.&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;Welcome to Switching Images!&lt;/h3&gt; &lt;p&gt; &lt;img src="http://graphics8.nytimes.com/images/misc/nytlogo152x23.gif" data-alt-src="http://graphics8.nytimes.com//images/2010/04/09/bucks.gif" name="picture" border="0" onclick="rollover(this)"&gt; &lt;/p&gt; &lt;script&gt; function rollover(img) { var altSrc = img.getAttribute('data-alt-src'); // make sure there is an alternative source if (!altSrc) { return; } img.setAttribute('data-alt-src', img.src); img.src = altSrc; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; By using "this" in the event, we make the browser give the image reference to the event handler, to be used inside the rollover function. If you wanted to use addEventListener instead, you'd remove the onclick attribute and use the following script: &lt;script&gt; document.addEventListener('click', function(ev) { var img = ev.target; // only execute the event on images if (!img || !img.src) { return; } var altSrc = img.getAttribute('data-alt-src'); // make sure there is an alternative source if (!altSrc) { return; } img.setAttribute('data-alt-src', img.src); img.src = altSrc; }); &lt;/script&gt; This makes use of event bubbling (events 'bubble up' from document, html, body, up to the target and can be caught with such an event listener) so if you added more images with data-alt-src-attributes, it would still work for all of them.
Thanks! I used your advice and /u/nemohearttaco to accomplish this. I knew it would be easy. 
yup, just checking 'are you already picture one? if so be picture two, otherwise be picture 1.
You‚Äôre getting oddly antagonistic. I was citing anecdotal evidence that I personally couldn‚Äôt consider moving to Babel until recently because our build was Typescript based. And the yet was because moving a products build system had ancillary costs. I get that they had bleeding edge support 2-3 years ago, you don‚Äôt pull the trigger on production systems the instant support lands in a single release. Especially in a product that knows it‚Äôs chasing standards and prone to API change.
Surprised nobody mentioned unsound type system of typescript. Note: If you're unfamiliar, type "soundness" means that the type checker will always complain when your program is invalid. You can't write an invalid program with a sound type system. Why would anybody need ‚ÄúType‚Äùscript if it‚Äôs type system isn‚Äôt working as one would expect?
Well implement.js is javascript
These are the flow features he was taking about. https://medium.com/flow-type/even-better-support-for-react-in-flow-25b0a3485627 Children can be anything, not just a React.Node.
TypeScript will support proposals that are stage 3 or higher in the TC39 process. Pipeline isn't even stage 2 yet (hopefully at the next meeting it will be). Once there's a concrete spec for optional chaining semantics it will be implemented as well. As the guy whose job it is to be tightly involved with both TC39 and TypeScript, I am happy to report we're directly involved :-D
And hints in the IDE, which is actually a huge part of it. When I say that an object implements an interface I want the IDE to light up if I don't implement a method, if I implement it wrong, and ideally offer a way to autogenerate stubs for all missing methods.
I don't think that is fully correct. TS had decorators for instance, as well as javascript foreign constructs. Some specs, like spread, became living standards long before the standards body made it official. In that time you'd import any source code or example or tutorial that uses redux, and TS wouldn't run.
Comparison: &gt; Type Systems for JavaScript: Elm, Flow, and TypeScript http://djcordhose.github.io/flow-vs-typescript/elm-flow-typescript.html#/
Same thing in TS. Drafts that they had would change over time. Privates for instance will change in TS with the upcoming class fields proposal. I understand what you're saying otherwise. 
Our experience shipping decorators is in part why we have a stricter stage 3 policy now. Object rest/spread has been in for some time (once it got stage 3!)
But can use babel after tsc. Can make setting compilor option not process many thing babel come and process everything can be config. I not use babel 7 TS before. What is good for move from tsc?
Yes, but that would involve two chained transpilers. Babel 7 is still beta, i would wait until everything's flattened out. But then it wouldn't be like moving, you would use TS on no-emit. 
&gt; chained transpilers Is use them chained is bad? I use now like this
Hey quick message to say thanks to you and the team ! I started using typescript 6 months ago, I never used a type checker before and didn't see the appeal, now I can't imagine my life without one ! Some things are still enigmas to me so I might pop in the gitter chan to annoy people with my stupid questions :)
First I would use an &lt;ul&gt;, since this is the very definition of a list. Beyond that you could simple prepend the new message to the start of the ul and then check the amount of children and delete the last one, till you meet your aloted amount. See https://jsfiddle.net/Sorcy/54mru0cs/1/
I imagine it would take longer or could cause some edge cases. If you're already chaining, wouldn't hurt to try it, maybe you can make your build faster: "presets": [ "@babel/preset-env", "@babel/preset-stage-0", "@babel/preset-typescript" ]
No I use create react app I cannot change babel preset. I am sorry
&gt; Privates for instance will change in TS with the upcoming class fields proposal TypeScript private is syntactically orthogonal so I wouldn't expect anything about `private` to change significantly. 
nice idea
So why would one need implement.js to implement javascript?
Reading between the lines of your request, I'd recommend simply using "appendChild" if you have a container div. So: document.getElementById('logsContainer').appendChild(document.createTextNode(msg)) See: https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement
It's not to implement javascript it's to implement interfaces
Which brings us full circle to my first question.
Parent appendchild. If children length is greater than 10, delete last. 
And the answer is they are
Don't do something based on of it's "in fashion" or not. Base it on its merit. If it's simple enough, jQuery and plain js will do fine. If it's more complicated, then use a suitable framework.
It is very important if you work in a team.. if you're responsible for everything in the project maybe not, but if you need to work with other modules someone else wrote, the extra information can help take a lot of mental load off, otherwise you'd have to read the inner workings of the other components/modules before you can actually use them
I work in a bigger team, i just never really had any problems with it. VSC and Atom both autocomplete, even without types. It gets way better with types of course. IMO this is for the editor or ide to figure out and they're all getting better at it. 
Have you heard about for? function msgLogs(newMsg){ // if your elements are named by id var ids = 10, tmp = null; for(var i = 1; i &lt; ids; i++){ document.getElementById(‚Äúlog‚Äù + (i + 1)).innerHTML = document.getElementById(‚Äúlog‚Äù + i).innerHTML; } document.getElementById(‚Äúlog1‚Äù).innerHTML = newMsg; return; // if your elements are named by class var logEntries = document.getElementsByClassName(‚Äúlog-entry‚Äù); var len = logEntries.length; logEntries.forEach(function(el, ind, arr){ if(ind !== len - 1){ // descending, or you could have called Array.from(logEntries).reverse().forEach for a less annoyingly looking way arr[len-ind-1].innerHTML = arr[len-ind-2].innerHTML; } else { arr[0].innerHTML = newMsg; } }); return; } EDIT: typos. Comment posted using an iphone
Although I wouldn‚Äôt compare the two directly, they do have a bit of an overlap, but are still quite different tools. Both offer enhanced type safety, but TypeScript takes it the whole 9 yards whereas Implement.js focuses on objects with some additional features for manipulating them. Benefits of TypeScript: * Compile-time safety * Less verbose syntax * Whole host of other features you would expect from statically-typed languages Benefits of Implement.js: * No need to learn new syntax * Purely JavaScript - no transform step * Reshaping objects * Renaming properties * No compile step
why not just do associations? hasOne, hasMany, belongsTo? You also can associate through another table with a through property
You might be projecting a bit here. I like Prettier but had no idea it was made by a Facebook developer before this comment chain.
Really cool
Here are some points that speak for using vanillaJS/JQuery vs Full blown Framework with state management etc.: Are you planning on maintaining these apps for a very long time? Framework Will these apps consist of high complexity? (Many buttons that alter the same variables in different ways) Framework Would you like to finish as soon as possible? vanilla Do you care about performance (this will only show when using TONS of ressources) Framework Will someone else ever have to work with your code? Framework Would you rather not invest a great amount of time in to learning a framework? vanilla Would you like beautiful already done components that work seemlessly with each other? Framework Will you ever want to showcase these apps when applying to a job? Framework (unless you're super awesome with vanillajs) Think about these points and decide then. If you chose a Framework you stack should be: * ReactJS or Vue * Webpack * ES6 (Write modules for calculation stuff and use those in your framework. Webpack will allow you to do this easily by bundling everything into one .js file) * JSDoc * VSCode (or any other editor that supports type checking JS via JSDoc) If you choose vanillaJS/JQuery your stack should be: * A good editor 
Yeah, that's right, I don't want to think about my formatting. I don't want my team to worry about it either.
[removed]
 const bump_new_msg = msg =&gt; { let Logs = document.querySelectorAll('[id^="log"]') , last_Log = Logs[ logs.length - 1 ] , first_Log = Logs[ 0 ] , Logs_Parent = last_Log.parentNode last_Log.innerHTML = msg Logs_Parent.insertBefore( last_Log, first_Log ) } 
&gt; Parse error: syntax error, unexpected '&lt;', expecting end of file in /tmp/theme_temp_setupf86ddj on line 2
When a heroku dyno (think server for now) starts up, the first thing it does is npm install. Everything specified will get downloaded. You really ought to just try it to see how it works. https://devcenter.heroku.com/articles/getting-started-with-nodejs#introduction
I'm looking for a pre-existing module. I don't think I have either the skills nor the time to build one out myself. I have tried some of these pre-existing one's already but I am not too sure of the implementation of them. I tried one, which I will link when I get back to my computer, but the calendar would not pop up on clicking into the text bar. It could be a bootstrap conflict or something similar.
Awesome shorthands for Javascript!
I would use plain JS for a calculator app. At most I'd use some lodash utilities if I find I need them.
Number 1 will be super helpful 
You missed the disadvantage of having to include a type assertion library in production. Sorry to burst your bubble... It's a neat concept, but the benefits of this library pale in comparison to Typescript
Training one with Trump, Bill Murray and William Shatner would be pretty entertaining.
I think you triggered the anti-framework squad! They are right, calculator app does not need one. I guess the question is.. would you like to learn one ? Say you'd like to learn react because you have other plans that could get more complexe and like the idea of mounting and unmounting things. You'd like to get a job in the web app departments, like to practice with architectures using mobx or redux. Then its interesting to have a very tiny project using it because the low complexity of the project will make the learning digestible. If not, yeah jquery can really do it! ps : pick [semantic-ui](https://semantic-ui.com/kitchen-sink.html) for your UI, so your calculator is sexy by default :)
The first example on number 8 should probably be '==' instead of '==='. Otherwise, thanks for the tips.
If you're looking for editor support checkout nuclide. It's a package on top of atom that transforms it into a good React/Flow editor. If you look at where each came from I guess it's logical that VSCode + TypeScript (both MS) work best together and Nuclide + Flow work best together (both FB). Personally after using Flow extensively I agree with one of the other commenters that adding a type system on top of a language without native types always feels like a hindrance. I'm convinced Flow is inherently the better type system though I know TS has better IDE and community support.
Personally, I‚Äôd take this as an opportunity to learn and practice with a framework, it may be overkill for this specific project but I like to keep up to date on that sort of thing. Frameworks exist for a reason after all. I might go with a relatively lightweight framework like Vue. It‚Äôs not the most popular out there but it‚Äôs growing, and it has a simple API that you can learn in an afternoon. It‚Äôs basically just a templating engine that knows when to re-render automagically. Components get data as input and produce rendered HTML as output, no manual dom manipulation and you can choose how much control to give the framework. 
Glad to assist! Q1- this is remedied by a combination of source-maps and advanced logging features. Source-maps will be handled by webpack (currently the standard bundler). They will allow errors to be reported at the proper places in your source code. As for break points... I know in C#/Java dev breakpoints are cool and logging is seen as lame, but in JS logging tools are amazing and breakpoints are too ephemeral to be helpful due to these transpilation cases. Abandon the break points. Console log is variadic and supports object browsing in the browser- just do that. Q2- imports are an illusion for you, the programmer. Nothing more. Even in Java, Go, Haskell, C#, etc compilers take all the files of a program and eventually create one big executable. JS is no different. Your resulting monolithic index file is the result of transpilation. It is one file to make shipping it to the browser fast and easy. That bundling process will also handle making imports work without affecting any global variables. Import works like import in any other language semantically. Under the hood, es6 modules are objects, which is very cool and useful as soon as it stops being confusing. Node requires are a (slightly) different animal. Q3- Go you, this is great! I recommend webpack. It's not super easy, but none of them are and webpack is the standard. I also recommend not learning webpack while making a website. Learning webpack is way simpler on node projects (and yes, still useful despite the name). I guess you can PM me if you want specific pointers for that? Mostly I just got on github and looked at other projects' webpack configs to get a feel for what I liked. Q4- Not quite. So, dependencies can be thought of as a tree, which then gets transformed into a list. The list is guaranteed to define things in the correct order. Then, bundlers walk the list performing either A1 or A2 as needed, followed by C. Often, there will also be linting and/or typechecking steps in there too. The output of this is appended to the target bundle. After walking the whole list, it puts some finishing touches on the bundle and calls it a day. So... simple, but also not at all. Hope this helps! These are good questions- you're on the right path!
The newest versions of prettier can use a `.prettierrc` or keys in the package.json file. 
Holy..... that is so much more comprehensive than i could ever hope for
I think that was the most concise explanation of Markov chains I've ever read. Very informative.
It's not because the code is short that it's good...
You‚Äôre comparing apples to oranges
A?.b? That‚Äôs nifty. But I just use lodash.get() and it does that. 
You just compared them in the post I replied to? They both do similar things. Typescript does it much better
This is pretty cool: {items?.map(item =&gt; &lt;span&gt;{item.members?.name ?? "noname" } 
You might also like tcomb, which removes some checking from production builds. Since typescript was mentioned elsewhere, there are some things you can only do with a runtime type system: Refinements of primitives (think PositiveNumber) Pattern matching (in JS at least) Dynamic type generation Dynamic data validation Dynamic form generation (see tcomb forms and tcomb native forms) If you add both typescript and tcomb together, you have very predicable, strong types in your code.
Yea. Thank you too.,
Aha~&gt;?
Thanks for your compliment.
Excellent article.
You are most welcome dude :) 
It's just a version of Javascript
any online demo?
Throw Gordon Ramsey in there for the odd curveball.
Keep seeing people repeat this as if it's a bug in TypeScript. This is an intentional trade-off which improves usability.
Right, that's why I was confused by the cli flags being included. 
Old habits die hard. Haha. 
The post links to blog posts with in-depth explanations, not to ECMAScript proposals.
Thanks! Should be fixed for now. 
No need, just throw some "fuck" and "bollocks" in the mix.
I'm not sure. I'm not hosting the event. I just wanted to share it, because I'm super excited about doing it.
If you post your code, the good people of reddit can help you find the problem!
It's wrong though. Try with zero or an empty string.
The 9, 11 and 12 are hardly readable. Otherwise, the others are good.
instead of ''
Don't forget "donkey"
If you reread my reply you‚Äôll see the first thing I said was that I would not directly compare the two because they are very different tools with different purposes. I made the comparison in order to show how they are different, and have different use cases. You yourself say this is an assertion library, which is true, yet you then go on to say how TS is simply better, but TS is not an assertion library. Either you are mistaken in thinking TS is an assertion library or you are confused about something else. It‚Äôs flattering to have my library mentioned in the same breath as TypeScript, but they are not designed for the same purpose at all. TS and this both take a crack at interfaces, but that‚Äôs where the similarities end.
I mean when variable1 = 0, it's obviously not null or undefined, but in that case variable2 !== variable1
Great links!
I'd use typescript since type checking seems particularly helpful for a calculator app. Or Elm since it's good with runtime errors. Or next.js and build in SSR to each equation via routes and see if you can get ranked on Google for random math equations.
No I think, I am a front-end developer, and in my interview I haven't got any question about react or some. I got question clearly in algorithms and data structures, with javascript interpretation. And so far so good, you know, those skills are the cornerstone of a good front end engineer, nowadays browsers allow us to do hell of a things. So brace yourself mate, catch up on algorithms and stuff.You will be good!!! Hope it helped!
&gt; those skills are the cornerstone of a good front end engineer not sure if trolling or serious :/ "Let me just implement this merge sort manually" -- No Frontend Engineer, Ever
They don't always do and when they do, they often haven't really thought about why they do it, other than it sounds like a reasonable proxy for coding ability, or they heard google does it. A good interviewer isn't looking for textbook pedantic answers to obscure trivia, they look for signals, e.g. whether they candidate can logically deduce a solution from basic principles, what are focus areas when iterating on a solution, whether the candidate puts thought into a question before banging out code, etc Of course there are also bad interviewer. Often times people approach hiring as they did school (memorize a bunch of stuff and hope something sticks to the wall), but I can't say that's a great strategy, considering that the result is they get to work in a place with gameable hiring
&gt; Why do companies test on computer science for front end positions? I find this baffling, too. When I hire devs, I ask exactly 0 questions that are irrelevant for the day-to-day job they'll be expected to perform. Knowing when to use what algorithms (and Big-O) may be important in some cases as knowing a high-level description of how they work/what they do. Asking details about the intricacies of data structures is pretty useless for a frontend dev in 99% of cases. check out https://github.com/poteto/hiring-without-whiteboards
Well... I'm a front end engineer and I just wrote some pretty specific merge and sort code for comparing two very large objects. Not everything is about making sign up and contact forms.
why would you manually write a merge sort? &gt; two very large objects it sounds like you wrote a comparator function to be plugged into a standard merge sort algo.
yup, i feel like the people who undervalue cs type skills only have experience working with small applications. when you're dealing w big data and large traffic, performance becomes more important.
again, you need to know when to use a merge sort, not how to implement one. it is very rare that you need deep CS knowledge to select the correct algorithm. very few frontend engineers actually develop novel algorithms - merge sort is not one of them.
The details of my anecdote don't really matter here. The point is a good CS foundation is absolutely critical to any front-end engineer on my team.
&gt; The details of my anecdote don't really matter here. they absolutely do. because you're replying to a comment that argues that a manual implementation of a merge sort is a necessary requirement for a frontend dev. writing a comparator function is hugely different that actually implementing the merge sort. in real life, an frontend engineer will never need to do the latter.
I think the apt parable here is the story of the engineer that went to a client site to fix a big machine, did so by tightening a single screw and charged $5000. Upon being asked why a small tweak cost so much, he replied "I didn't charge for tightening the screw, I charged for knowing _which_ screw to tighten". Perhaps, implementing merge sort from scratch isn't useful in most cases, but knowing _what_ is the best tool of a given task - be it an algorithm, a data structure, whatever is valuable. As an interviewer I do derive value in algorithmic questions, but not about the candidate's proficiency in any given algo, but about whether they approach a solution via dynamic programming vs large state machines, whether they think about testing, etc.
I mean, c'mon mate, thats not like and engineer attitude, it like using jQuery all the time because it has a method called doWhateverIWantHoweverYouWantAndLeaveMeAlone(). I's not like that mate IMHO.
It's a very specific case for why good CS isn't a cornerstone for a front-end engineer. You're speaking in absolutes "No Frontend Engineer, Ever" ... "a frontend engineer will never need to do the latter". The data scientists sitting right next to me would argue against your statement.
&gt; knowing what is the best tool for a given task yes, this is the point. a candidate should be able to explain why they used a merge sort, for example. or broadly what resource tradeoffs it makes vs other viable solutions. these are general qualities that are of course necessary for any engineer.
and the graphic designer sitting next to the data scientist will say that of course the data scientist needs to know the difference between color spaces - that's like 101.
good moin'. that article sucks by any means
Cool reply dude
You know, I have cs master's and the theoretical knowledge I've obtained is always in the back of my mind and definitely helps me write better code, reason better etc... But these typical algorithmic questions also do nothing to really test that knowledge appropriately.
so testing in algorithms in the standard ? because throughout my whole career (10 years) no company ever made me do algorithms in a test . companies like Atos , Safran morpho etc . So i'm wondering if algorithms are becoming hyped up , especialy with the apparition of testing platforms online like hackerrank , maybe companies are trying to immitate google and microsoft.
This example doesn't seem to use onclick https://codepen.io/ckm100/pen/dPLyjZ
https://news.ycombinator.com/item?id=11753459 https://danluu.com/programmer-moneyball/
Just use the onmousedown event ;)
I tried to use flow-runtime on two projects so far last year, but it always became very very slow to run the app. They were both apps around 70k-100k LOC so not small apps. How long have you been using flow-runtime?
Is EventListner allowed?
how do traffic levels affect frontend performance? how does "big data" factor into the client. this whole topic if about frontend, yes?
I have built a few components with it at work. It is nice but visual studio is a big pain point. I also find my lack of knowledge of builds/ dependencies a bit of a blocker. If you have any tips on resources to learn about that stuff I would be very grateful.
To expand on this, vue-router has hooks you can use to determine permissions on routes based on user data. Between that and using v-if directives in your components, you should be able to implement permissions pretty easily.
I don't think it's about you being able to specifically implement a merge sort. However it shows that you're able to solve a problem that's a bit more involved than writing down `myArray.sort()`; and a somewhat larger react application can actually pose quite difficult sorts of problems when it comes to efficient updates (say).
i guess you're right if we're speaking solely on front end, my mistake.
Because assessing programmer quality is a really hard problem, so many companies settle by measuring a (very poor) proxy instead. Personally the moment a company pulls out this sort of nonsense with me I just cancel the whole interview right there (this almost always happens during phone screens; I've almost never walked out of a physical interview). If you're desperate for a job that might not work, but if you can afford to wait a little longer you'll likely be much happier off with a company that is smart when it comes to recruiting, because they'll likely be smart in other ways too. Conversely, when a company is stupid enough to ask you about CS 101 nonsense for a front-end position, you can pretty safely assume the stupidity doesn't stop there ...
You could do something like a for loop if you really want to keep it concise, extendable, and understandable to even beginner devs; for (var i = 1; i&lt;10; i++){ document.getElementById('log'+i.toString()).innerHTML = function(){ (i == 1) ? return msg : return document.getElementById('log'+(i-1).toString()).innerHTML; } } It's not a particularly elegant solution (and it's untested), but it would allow you to log using similar style of coding to what you're doing now. Alternatively, and a better option, would be to use an append function. jQuery offers one, and I'm sure vanilla JS also does but I can't recall what it is at this time.
Yeah, clever but as author sums up - do not use it in real code unless you have a good reason. Always KISS your code
Obscure is not clever.
Count me in yo
Nice one. thank you. I'm on it. Will be updating the mailing list next week. https://reactfirebase.carrd.co/
make it text based, ie listen to keydown etc.
Bleh... if you want to avoid making new functions often then just store the function earlier: const trim = srt =&gt; str.trim(); /* ... */ const trimmedParts = addressParts.map(trim);
https://rawgit.com/krausest/js-framework-benchmark/1922d6b922816b5b7f5c81fecf7a950df7bc005e/webdriver-ts-results/table.html
Could you just do addressParts.map(String.prototype.trim.call) ?
Tools come and go, but strong computer science fundamentals will always be relevant. It's also a lot easier to train a new hire on your specific stack than on modes of thinking. Front-end engineering is still engineering. A good developer needs to know about runtime complexity, datastructures, design patters, etc... regardless of whether they work in javascript, Java, or C++. A bootcamp-trained novice may be able to bang out a working design in React, but that doesn't mean it will be well built. 
Because companies don't want to hire someone who becomes useless when they encounter a situation that doesn't involve just gluing two APIs together.
&gt; Conversely, when a company is stupid enough to ask you about CS 101 nonsense for a front-end position, you can pretty safely assume the stupidity doesn't stop there ... You'd be surprised how many people can't reverse a linked list. Yes, I understand that your job won't involve reversing linked lists. However, if you can't handle the simplest datastructure, how can you be expected to work with trees or graphs? As [Steve Yegge said](https://steve-yegge.blogspot.ca/2008/03/get-that-job-at-google.html), "Graphs are, like, really really important. More than you think. Even if you already think they're important, it's probably more than you think."
I'd go as far to say that the focus on algorithms is actually hurting hiring better candidates who understand designing systems and implementing good code to support those designs. Focusing on frameworks is silly, knowing the depth of knowledge in JS isn't if you need them working productively immediately or if they claim to be experts. Most companies rather take the trivial amount of time to see if someone remembers an algorithm rather than talk through software design, architecture, etc. and seeing if you could have them implement a large scale system and not just a spaghetti coded system with optimal algorithms.
Most backend devs aren't going to implement a merge sort either... They are 99% of the time going to use the standard library implementation in whatever language they use. Understanding algorithms and computational complexity is important skills for any developer. It doesn't mean you're going to be reimplementing the basic algorithms you learned in school. It means you can demonstrate problem solving skills for things beyond the most basic of tasks.
No, because then you're just calling `call` with an undefined `this`
I think it's unavoidable that if you're type checking absolutely everything at runtime then it will be slow. In any decent sized codebase I would only use it where it would add the most value ([controlled e.g. by using pragmas](https://codemix.github.io/flow-runtime/#/docs/pragmas)) i.e. near boundaries, rather than type checking everything. A majority of code probably doesn't really benefit from runtime type checking when you take into account the cost of increased bundle size/performance hit.
`String.prototype.trim.call.bind(String.prototype.trim)` or `Function.prototype.call.bind(String.prototype.trim)`
map will pass in string as 'this'
I KISS my code goodnight every night‚ò∫Ô∏è
By using the publicly defined methods that operate on the object, like any productive programmer would. I don't need to know how to construct a lock to lock a door, and if I ever needed to reverse a linked list manually (god forbid), I'd google it before building my own algorithm. 
No, it won't, and even if it did, `trim` must be the `this` for `call` if you're calling `call`, not the string.
For total novices.
An understanding of basic algorithms is a must for any "software engineer" just as learning math properly without the use of a calculator. More often than not, those type of questions are a filter before you get position specific questions.
Um.... elem[i].addEventListener("click",function() {
Use keyboard keys? E.g. +, -, /, * &amp; =
I browse Reddit on my ipad. As far as I can tell, this demo doesn't actually do anything. Dragging moves the page. Taping on the image moves the dot thing to that location and updates the text. No cropping happens.
It depends on what the interviewer is looking for in the answer really. Yes I can‚Äôt remember *the* way to reverse a linked list, and yes I would normally look up an answer. But sitting down with the problem, I just wrote a dirty solution in 5 minuets, could point out a weakness in my solution and suggest two ways to fix it. If your interviewer is looking for *the* textbook solution that‚Äôs been refined over years, then yeah it‚Äôs a bit stupid. But if it‚Äôs framed in the way of: *Heres a simple problem, based on a context you should be familiar with (knowing what a linked list is), can you show how you would solve it*. Then it‚Äôs really worth while. We ask questions like this. Really we are looking for them not to remember, so we can work through the solution with them. When they just know the answer it‚Äôs a bit of a failure and we usually extend the problem to put them out of their depth. 
Even more generic but still easy to grok: const methodCaller = (method, ...args) =&gt; (object) =&gt; object[method](...args); array.map(methodCaller('trim'))
Specifically, I thought they were talking about not being able to use onclick in HTML.
I wish this made with &lt;3 thing would die.
Sorry...
EXACTLY 
[removed]
I hope people are going to be equally outraged when they find out that major sites such as facebook and google have been secretly using javascript to offload page rendering to the client, rather than server rendering like in the past. Imagine the horror of using users cpu's for corporate profit!
Isn't that what most of programming is?
I've been in the web dev game for over a decade, led two teams, worked for a genetic screening company, a storage device company, a consulting company hired by Apple, etc. I've never once had to work with trees or graphs on the front-end (unless you count GraphQL).
Thanks so much for taking the time to explain all of this. I will start working through this.
thx!
Yeah - I figured I would need to move to vanilla JS. I know it pretty well, hope to get better, Hot chick - like that. Some of these terms are foreign to me, if you had links as to how nginx relates - I want to up my skills, but for this project rebuild a PHP/MYSQL app using more modern tech.
It all comes down to signaling competence. While there are many things that could be done. Computer science is a widely accepted context for people who have gone to school for programming will be able to discuss. Most job owners are looking for people who went to school for programming, and it shouldn't be surprising that they use a topic from that schooling in interviews.
`gofmt` for Go changed the game. `prettier` does the same for Javascript. I just wish there was an official configuration from the node team. There should be an official way to format React in create-react-app. I'm sure there will people who balk but big projects should enforce code formatting. It's better for the community that everyone formats code the same way. Hardly anybody complains about formatting n Go. I disagree with some of the formatting, I just accept it and it doesn't bother me anymore.
quite good example, thanks a lot 
They are very different libraries that have the same goal: assertion of types. Typescript is much better at achieving that goal. The data member translation feature doesn't seem useful enough to warrant a runtime type assertion library.
Format your code by putting 4 spaces before each line
&gt; Front-end engineering is still engineering. Umm, no it‚Äôs not. Stick to Photoshop.
Thank you! I have [an issue to add touch support](https://github.com/third774/image-focus/issues/1) if you're interested in updates.
Yes, but you still need to be able to invent your own stuff when somebody hasn‚Äôt done it for you.
It's a little unclear without seeing your code, but let's assume your search pages look something like this: http://www.awesomewebsite.com/search?query=local+hackathons If that's the case, then when a user is redirected to the log-in page, they're redirected *from* this url. That means you can capture that information before sending them to the log-in, and you could use a similar querystring for the login page: http://www.awesomewebsite.com/login?redirect=http://www.awesomewebsite.com/search?q=local+hackathons Then, when they hit that log-in submit button, the request would come *from* this url. Which means once again that querystring is available to you, and you can send them there next.
Im currently using the yelp fusion api. Thank you for this
[removed]
That's actually really clever. May not be the most readable but yeah, you are only using functions that already exist and you don't need to rely on ES6. 
This might not work as the api works a bit different than f IÔ∏è was searching local info
There will be no reference to trim...you are only passing the call function this way, there will be no reference for String.prototype.trim as the context. String.prototype.trim.call === Function.prototype.call
We all agree that this is 100% more readable, but it isn't as smart. You are still creating a new function this way, you're allocating a new object, which doesn't happen in the mentioned code. But yeah of course you shouldn't use shit like that lol, I lost around 2 minutes to fully grasp it, and I'm kinda used to Function.prototype.call shenanigans.
Oh, I see. Your users are searching via AJAX instead of page reload. Nonetheless, you could build something on the front-end that updates the `location.hash` without reloading the page, which would still be accessible to your `req` objects.
Because "real world problems" are difficult to bundle up neatly into a 1-2 hour interview, they are good at showing how candidates approach problem solving, and candidates who are successful in the interview tend to be successful in the job.
Hi /u/myrrtle, For javascript help, please visit /r/LearnJavascript. Thank you!
&gt; Everyone pads their resumes these days and say they are senior engineers after just a few projects. Probably in response to companies padding their job descriptions... You're going to get what you pay for if you're advertising for "senior engineer" role with a junior level salary.
I don't really see the difference. Companies used to render their websites on the server which cost them money. Now they use your cpu to do it which uses your hardware directly and uses your electricity to make them money. It's literally just javascript running in the browser.
Sweet!
Bitbucket pipelines are so good
I'll definitely give it a shot soon. Thanks for explaining!
CSS - Chris Coyier JS - Probably Paul Irish but I really enjoy the mindset of sindre sorhus
Codewars and a lot of practice
The following were extremely helpful for me: This is super as a beginner. https://www.udemy.com/understand-javascript/ He really breaks down concepts in an easy to understand way. Once you've got the basics down, try to understand everything in Eloquent Javascript (free): https://eloquentjavascript.net/ Most important though, is to be actively building things. It doesn't matter what it is, just build and fail, and get stuck, and work your way through. In the end this is where you'll learn the most. 
I do attempt projects. This is how they usually go down: I start the html and css and finish with no problem. I start with JS and seem to hit a dead end rather quickly. I believe it‚Äôs because I don‚Äôt have the concepts down yet of how to make things operational , but also definitely because I haven‚Äôt seen a lot of practical JS. Every time I watch a tutorial I go ‚Äúoh damn; didn‚Äôt know I could do that/call that css selector. Or it‚Äôs like ‚Äúdamn, i have no idea how to calculate that, or determine all the components of the app. And then I think I might just not be smart enough for a dev job. No shame in admitting that, if it was the case. But maybe it‚Äôs too early to tell, so until then I will look at your resources and thank you a lot ! 
https://www.learnhowtoprogram.com/intro-to-programming And then on to the actual JavaScript course. You can probably skip a week or so of Intro as it's mostly HTML/CSS.
I am working through this right now https://javascript.info , I am finding it to be quite good. 
https://i.imgur.com/h6HseM7.png
This reminds me of a programmer who used the following utilities in their code. ``` var bind = Function.bind; var call = Function.call; var bindable = bind.bind(bind); var callable = bindable(call); ``` Still takes me a while to work through the steps of `bind.bind(bind)`... 
Check out JavaScript30 by Wes Bos. I think you'd really appreciate this free resource.
What the hell is that used for
 var trim = callable(String.prototype.trim); addressParts.map(trim);
I've written a couple of MIDI libraries for javascript which can be used for creating/playing audio visualizations in the browser. They may be useful for your project: MidiWriterJS: https://github.com/grimmdude/MidiWriterJS MidiPlayerJS: https://github.com/grimmdude/MidiPlayerJS -Garrett
developer.mozilla.org and google
[removed]
Yep, the only stuff I ever used.
some stuff to play with: this is a copy pasta from a little mini tutorial i did for people in my bootcamp cohort...so please dont be offended by the beginner devops stuff: Currently I've got a full web server running in the cloud on ubuntu linux. nginx is the webserver handling the traffic on http (port 80) and https (port 443). It hands all traffic off to port 8080 which is where Node/Express will live. This is called a `reverse proxy` It's pretty easy to set up nginx as a reverse proxy to node/express with a little google-Fu: http://blog.danyll.com/setting-up-express-with-nginx-and-pm2/ Once you get that running you can get a FREE ssl cert (these used to cost money!) from The EFF. Certbot will even configure your nginx for you to forward port 80 to port 443. https://certbot.eff.org/ So now express is still LISTENING on port 8080 (or whatever port you're using) and you need to keep that locked down - especially if you have stuff you want kept away from the probing bots. So Uncomplicated Firewall jumps in... https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-with-ufw-on-ubuntu-14-04 basically with very little effort you close off all traffic except port 80, port 443, and port 22 (ssh) to the outside world. Mysql still runs on 3306 but its only accessible from itself (localhost).
EloquentJS for practical usage. YDKJS for a more serious study of the language. But before YDK I learned C using The C Book and Harvard's CS50. Really helped understand JS on a deeper level. All free resources.
In my opinion the two most important transferable skills for engineers are: 1. Being able to think in an abstract way 2. Being able to approach problems iteratively Watching a candidate work through an algorithm as part of an interview _is_ a good way to get a measure of these skills. You want to know that they can think outside of the browser, and that they know how to break problems down into approachable chunks. If you are hiring new front end developers, you'll be looking for a blend of productivity and adaptability. You want developers who can adapt when the project/team/company/industry inevitably shifts in the future. If a candidate has these transferable skills, they're far more likely to be adaptable. Productivity comes down to domain knowledge (React/JavaScript/DOM etc) and work ethic.
MDN and Reddit.
watchandcode.com goes into debugging, testing and reading code early on while every other resource mentioned here skips these things entirely . It doesn't just talk about es6 functions, it has you actually writing the functions . It also gives practical examples of all of the things it teaches and is the most efficient path to prepare for a framework or to contribute to FOSS .
Does your city have code clubs or JS beginners‚Äô meetups? Pair programming (for a specific challenge) is one of the best ways to learn. Since you asked us about a personal, most helpful resource to learn JavaScript, mine is Fun Fun Function on youtube: https://youtu.be/riDVvXZ_Kb4
I personally think reading the You Don't know JavaScript books by Kyle Simpson are excellent. They provide you with a solid understanding of the fundamentals of the language. Plus the entire series of books is free on github.com as it was an open source project. 
For me it was actually building apps. You can read and watch all you like, but you're really only going to learn by doing. Just think of a simple app and then build it - you'll learn along the way.
For me its Anthony Alicea's Udemy JavaScript course (learn &amp; understand JavaScript) Then CodeWars Then Frontend Masters courses on Advanced JavaScript (of Kyle Simpson) For jQuery, I liked Tutsplus's 30 days to learn jQuery course And for React, Stephen Grider's courses on Udemy And Full Stack React Book
Well I don't agree with that! Because some people just have to start with these concepts in order to dive into the current state of JavaScript. But I you think it's written like it was 2007, maybe you this article is just not for you üòâ
https://edabit.com - You do little challenges starting at easy and progress to harder ones over time. It‚Äôs a great way to learn js.
I think those two are relevant when you start doing real-time applications
that wat I was going to replay
&gt; Being able to approach problems iteratively Or functionally :p Jokes aside, I think JS community these days encourage people to write more functionally than before especially with React dev and even Angular with Rx
MDN and Udacity. The documentation on MDN is just awesome. It's very helpful to have such detailed docs with examples. Udacity courses like object oriented JS, design patterns in JS helped me learn more subtle things about programming and JS in general. The beginner courses are also amazing though. Google web developers website is also quite helpful. 
It is strictly equivalent. It only matters if the call to map us being made while iterating on something.
I was actually just reflecting on this a few minutes ago. Today I was offered a positon at a startup as lead ui/ux developer, in the bay area. I started from the ground up 15 months ago. I was working in a call center and I hated my life. I really didn't know anything about coding at the time and had no concept of the different brands of software engineering. All I knew was that I thought I would be good at it. I decided to go with JavaScript because of a friend's recommendation. There are tons of resources out there and it doesn't really matter which ones you use, so long as you learn the full stack in the right order, so that new concepts always have a firm foundation to continually build off of. I don't know where you're at in the process, but here is what worked for me. I hear of people talking about imposter syndrome. Proficient people don't have that. This is how you become proficient; the order to learn and understand full stack(and the time it took me): -google: learn how to phrase search queries phase 1: (3 - 6 weeks) -html: make sure to write clean code with proper indentation (a day) -basic css: mockup simple webpage views with rectangles and try to create them. Everything is a box. Everything is essentially a div. Add background colors to your boxes to visualize them. (the same day) -chrome dev tools: console and elements tabs. -basic JavaScript: native types, variables, strings, arrays, conditionals, loops, functions, objects (a few days) -more basic JavaScript: all array methods, all string methods, what methods actually are, constructor functions (a few more days) -es6: arrow functions, template literals, ternaries, classes (started using immediately after discovering, was weird at first) -optional Javascript: prototypal inheritance, call/bind/apply, callbacks, closures -practice basic algorithms: level 8s on codewars or the basic algorithms on freeCodeCamp. Do 50-100. This part is crucial and extremely painful. I think its the barrier for beginner coders. You will know you are ready to move on when you feel you've masters all the basic JavaScript concepts (2 - 3 weeks) phase 2: (2 weeks) the dom: event listeners, event handlers, console.log(event) on an event handler and explore the object thoroughly. (a day) to-do list app part 1: make a read-only to-do list where you can render an object or array, or whatever data structure you'd like, to the dom. Use a table or an unordered list.( 1 day) to-do-list app part 2: add an input and add button so you can add a new todo and a delete button and an edit button(1 - 2 days) jQuery: don't learn this, stick with vanilla JavaScript for now documentation: learn how to read it responsive web design: master css and know when not to use pixels for sizing (a few days) API app part 1: do a fetch/ajax request to any API and console.log the response JSON (1 day) API app part 2: render the response to an unordered list and add pagination(1 day) phase 3: (4 - 8 weeks) build simple apps: calculator, tic-tac-toe with ai, battleship, simon, anything phase 4: ( 5 - 10 weeks) react: learn react. There are tons of resources out there. The new facebook docs are great in and of themselves. Never use vanilla javascript again(for now). (1 week) react to-do list: same as last, but with react (a couple days) build something complicated that utilizes all of react's functionality: build a real game or something equally complicated, but not a web app, yet. (4 - 8 weeks) phase 5 (3 - 4 weeks) -backend: nodeJS, callbacks, es6 promises, npm, http, mongoDB with mongoose, rest, crud, postman/httpie (1 week) -learn git -build a single resource restful api: (2 weeks) phase 6 (3 - 4 weeks) -full stack to-do list part 1: build the font end with react (couple days) -full stack to-do list part 2: build the back end with express and mongoDB (couple days) -full stack to-do list part 3: bundle it with webpack and deploy to heroku (couple more days) -now do it with redux (a week) phase 7 (many months) -network: make a linkdin, go to meetups -build more full stack apps: you should always be working on something -freelance: place very low bids on upwork, Accept any work for any amount of money. It's getting paid to continue your training, which you still need. 
+1 for google, that site has everything
Is there any chance that you are thinking of "imperative" rather than "iterative"? I'd agree that the community is _generally_ encouraging functional programming these days, which I think is a good thing, because it often forces you to understand the problem domain better, before you can model it correctly.
Great book to understand the language, but the parts where he advocates about not using classes is silly with so many libraries already embracing it
If it's for challenge why not try use one of the famous reactive libraries like Bacon.js, Rx, xs? I think it's a good practice for functional reactive programming. Also it's kind of in between a framework and plain js, you'd use a lot of plain JS and the streaming library will help guide the flow of the calculator program
What really made JavaScript click for me was "You Don't Know JavaScript" by Kyle Simpson. https://github.com/getify/You-Dont-Know-JS The caveat I would say is that there's a lot of the JS ecosystem the book doesn't touch on. Things like the DOM API, Node API, and trending libraries/tools aren't really in the book's scope. So, it might not be the best resource if you're looking to just quickly get started building functional, interactive webpages using JavaScrip. But if you want to understand the language itself better, this is the right book to read. It's hands-down one of the most important books I have read in my career.
I started JavaScript after attending a meetup for my local FreeCodeCamp group. I went through the exercises there for the most part. I come from a programming background already, so I wasn't learning how to program, just how to do stuff the JS way. I have experience in Java from school but learning how to do things the functional way with `map` and `reduce` and such really made me grow to like the language a lot. I now consider it my most proficient language after several months, even after spending 2+ years with Java in uni. 
I‚Äôve been trying to teach myself javascript for years and it never clicked, so I bit the bullet and signed up for a part time onsite javascript course. I shelled out about 4K and I‚Äôd do it again. It was general assembly javascript development course. Afterwards I did Gordon‚Äôs watchandcode.com javascript course (free) and I‚Äôm building my own apps now. If you have the money I strongly advise taking an on-site course
 function removeDuplicates(str1) { var str=str1; ' var uniql = ""; var alpha = ""; var num = str.toLowerCase().split("").sort().join("").match(/(.)\1+/g).length; for (var x=0;x &lt; str.length;x++) { if(uniql.indexOf(str.charAt(x))==-1) { uniql += str[x]; uniql = uniql.replace(/[a-z\d\s]+/gi, ""); var arr =uniql.split(''), alpha = arr.sort().join('').replace(/\s+/g, ''); } } return "uniques: " + alpha + ", " + "duplicates: "+ num; } console.log( removeDuplicates("th#elex_%ash?") );
 function removeDuplicates(str1) { var str=str1; ' var uniql = ""; var alpha = ""; var num = str.toLowerCase().split("").sort().join("").match(/(.)\1+/g).length; for(var x=0;x &lt; str.length;x++) { if(uniql.indexOf(str.charAt(x))==-1) { uniql += str[x]; uniql = uniql.replace(/[a-z\d\s]+/gi, ""); var arr =uniql.split(''), alpha = arr.sort().join('').replace(/\s+/g, ''); } } return "uniques: " + alpha + ", " + "duplicates: "+ num; } console.log( removeDuplicates("th#elex_%ash?") );
It isn't as much about being able to implement standard algorithms (or even exotic ones) from first principals, it is about having an understanding of complexity analysis. This can be vitally important for scalability, and while you will hit this sort of thing more server side it can be a help client-side too. Complexity analysis can be applied to things like DOM manipulations and network accesses just as much as it can to sorting and pure number-crunching and those are very relevant if you are implemetning a large or otherwise complex application interface that needs to behave efficiently and/or responsively (the two are usually but not always the same thing) especially if it may need to do so on low-power devices on slow/laggy/unreliable networks. For a more senior front-end role where you might be in a position to take part in the descision making process for architectural choices then such experience can be useful for assessing the quality and applicability of competing libraries, frameworks, 3rd party services, and so on.
That's more of a psychological problem than one of intelligence. You need to stop measuring yourself against people who have already done the work of learning. They learned from someone else, as you are learning from them. It's turtles all the way down. Second, break big problems down into little problems. Build FaceBook2 is a big problem that's hard to reason about. Display FaceBook2 logo on web page is something you could answer with an internet search and some trial and error. All big problems are lots of little problems glued together. Third, see little victories as victories not as one tiny step on a thousand mile journey. If you're feeling relief instead of joy when you achieve something then you need to read up on the perfectionist mentality. This is about holding yourself to an impossible standard rather than acknowledging what you can and do achieve. Your last sentence is a common symptom of that "I think I might not be smart enough for a dev job". You're already preparing yourself to abort the mission.
I learnt Javascript at W3Schools. That is where I also learn HTML, CSS. They have lots of useful tutorials there.
For me, at first it was https://www.codeschool.com and after that, MDN and CodePen. 
I took a course on udemy by Jonas Schmedtman Then the only way to learn anything really is to do lot of projects, take up a complex project and complete it. So many beautiful tools are free now. You can dive into nodejs too. I started learning nodejs, ui design, reactjs. All the codes goes in github.com Data is persisted in mongodb, free available at mlab App is deployed on heroku, free for basic use cases 
It's not testing knowledge, it is testing ability. Ability to think, to solve problems, and most importantly, to communicate.
Looks like it doesn't scale across machines yet, which is the real killer feature of such a thing.
Clever is not smart.
Well that would be a goal for a good interview. However, asking people for sorting algorithms off the top of their heads doesn't achieve that really.
Mdn
Yeah I see where you're coming from but all he is really saying is that that stuff is "syntactic sugar" because under the covers JavaScript uses prototypical inheritance rather than a class based system, so using classes just abstracts that complexity so you don't really have to fully understand the prototype model that JavaScript uses. End of the day it's up to the developer to educate themselves and make a decision based on their own knowledge and experiences. 
Very nice explanation of Markov chains. Thanks.
I've been using Code School for a while now. It's good fun, however I make the mistake of not practising outside of it and tend to forget everything. My dev job doesn't require much JS knowhow at the moment.
Funfunfunction channel on YouTube. Specifically the functional programming series. https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q?app=desktop
Second this with little stars. I was having trouble really grokking promises and discovered this guy's video on the subject...for the first time everything really clicked. The musical interludes can be a bit annoying, but he's really good at explaining functional programming concepts in a way that makes everything super easy to digest.
[JavaScript30](https://javascript30.com/) from Wes Bos. It introduced me to so many things that you can do with JS!
Setting out to build something that made outbound requests to an API or database and not stopping until it was done. By the time I finished I learned enough to start refactoring it and realize where improvements were needed the most 
Why is the [code white on white background](https://i.imgur.com/48LKOet.png)? Why is the [header font size 118px](https://i.imgur.com/NVTnfLB.jpg) on my screen?
This may be a controversial opinion, but if you're strong in HTML and CSS, maybe consider jumping right into a framework directly. For example, [Vue](https://vuejs.org). (I suggested Vue because it has HTML and CSS right in the same .vue file, which you may find helpful) The examples usually give you enough stuff to get going quickly, so you see results of your frustrated labor quicker than you would with vanilla JS. Frameworks are extremely popular, so it's a required skill anyways, and you may not NEED to know a lot of the foundational nuts'n'bolts of JS. ** By no means am I saying "don't learn plain JS", but a framework can help you bridge your mental models from HTML to JS, quicker.
You are about to learn a full blown programming language. You can write pretty much anything with it, frontends, backends, commandline tools, and what not. HTML is just a markup language, you can learn the *basics* of it without any background in programming in a day. CSS is a little more complicated than HTML, but it's just a tool to format elements on the screen, and that's it. You can learn it's *basic* in a couple of days as well, without a background in programming. If you start JS you start a journey into the world of programming and computer science. Be prepared, it will take you some years to master your domain and become productive on an industry level. I was in the same situation as you are now. I started as a frontend designer, became Photoshop/HTML/CSS ninja... It was a *gigantic pain* to get into programming from there. I got depressions and lost connection to some friends, due to the sheer amount of stuff I had to learn. Eventually I became a full-stack dev... but it was a tough ride. &gt; Is there a single resource that helped you making JS click in your head? My first big click moment was when I started writing something that was NOT meant to be executed in the browser. I think writing software for the browser is a bad and *very confusing* way to get into programming. It would be 100 times better if you pick a beginners book/course/video-series that explains how to write a command-line tool with nodejs. This gives you a much better idea about how programming works in general and it would show you plain JS without the DOM, the frameworks, the transpilers etc. Don't start with the current frontend stack right away, it's unnecessary complex and complicated. Learn the very basics of JS and programming first. Write some toy commandline-tools and scripts for nodejs, after that pick some frontend-framework like React (or whatever is en vogue that day in the future) and get into it (if you decide to do frontends). The second big click was when I switched to a Unix like OS (in my case Linux) and started using the command line heavily. Don't beat yourself up, programming is nothing you can pick up on the fly! 
I might have misunderstood your words, but iterative sounds like thinking in terms of loops and routines.. it's probably me reading too much into it By any chance, were you talking about agile iterations..?
They have very different goals, one single feature of TypeScript - interfaces - has a similar goal. You use this library when you want to check an object‚Äôs shape or refactor it slightly. You would use TypeScript if you want a statically typed version of JavaScript, and a statically typed language is much, much, much more than asserting types.
Ah, it all makes sense now. Yeah, I meant iteration at high level, much more like agile. Approaching problems one step at a time, rather than trying to do everything in one go.
My job.
I hate the amount of regex codewars katas give you. Least in the c# I spent more time trying to get regex to work then my code. 
Any answer to a what X helped you learn Y is to just build something. When you hit a road block any Google resource will do. Even if you have a resource (e.g. You Don't Know JS by Getify) you still need to build something along side of it. All of Wes Bos' material is great (es6.io, 30 Days of JS) but the point is that you learn by doing, always.
If it relies on addEventListener, it's broken
Not sure where you're getting that undefined from. Also, I'm not a big fan of using food for promise analogies since food can be fully consumed leaving nothing behind whereas promises will continue to always offer a value after being resolved. A better example might be having your wing man fetch a phone number from a woman at the bar. When he comes back with that number, you can ask him to show it to you as many times as you want and it won't go away. That's information that he either always has, or doesn't have (if rejected). It's also quite possible he left the bar with the woman himself leaving you hanging waiting for a promise that never resolves, which is something you might need to consider as well. How long do you sit there and wait until you realize your bud abandoned you and you may never hear from him again?
I second this, I only discovered this channel two weeks ago - as soon as I watched the first i went ahead and made it my aim to run through all his videos. His delivery is x10 more interesting and entertaining than most other youtubers out there.
IMO there is little point in just 'learning JS'. Just start to make a website you want to make and google anything you need along the way. JS itself is very simple: there are variables, functions, few operators and that's it. It's not complicated. Yeah there are some advanced built-in things like Array.prototype.map for example but you will learn all that stuff once you need it because at some point you will google 'how to apply function to each element of array' and there will be link to stackoverflow question where dude in the top answer will link to MDN docs regarding Array.prototype.map. Complicated stuff starts when you don't use JS itself, but use tools that use JS. Like if you wanna make a website you will probably use some framework like React or if you wanna make a server with JS you will need to use something like Express. And to learn those you start with the docs and then just google if anything isn't clear. Sure it requires understanding of basic js syntax but there are a lot of abstractions that has nothing to do with js. TL;DR Don't worry about 'learning JS', just start doing something and google along the way. The hardest part of JS development isn't JS itself anyway.
Once you've run through a basics course whether it's on Udemy, Codeacademy or whatever... Go straight to your text editor and start building as much as you can. I find following tutorials doesn't unlock your mind and help you think for yourself when solving problems since most things are already thought out for you with a lot of tutorials. If you encounter a problem, MDN and Google are your friends. I've also asked plenty of dumb questions on Twitter as well. If there is a topic you find confusing it's best to focus in on it and learn it through youtube videos or blog posts. More generalised videos I find don't quite sink in or help me all that much. All things aside though, everyone works differently - don't get disheartened if something isn't quite working for you. Keep plugging away until you find something that fits for you.
I find it funny that with JSHint people were crying out for a way to configure _everything_ - and now that we got that with ESlint, a brilliant tool, the hipster have decided what they really want is something that doesn't let them configure _anything_. Sheeple.
what did you use to create that animated gifs ? i want that in my docs !
Yeah, loose use of scalable here. But it cluster on a single machine
&gt; Is there a single resource that helped you making JS click in your head? Nope. The only way to make a programming language 'click' is to write several projects in it, keep coming up with better solutions, and keep seeking feedback from others. There's really no substitute (though authors of online coding courses would like you to believe otherwise).
It's remarkable that junior developers want to learn via books and videos rather than doing and building. I mean, if you're not interested in building software what are you doing in this industry?!
From what you say it sounds to me like your challenge is less the language itself (Javascript) and more thinking like a programmer, or even a web developer. In which case, I would indeed spend some time learning the language with the resources you got here, but that would only be step 1. Step two would be to find some resources for a step by step building some web application or web service from scratch so you can start wrapping your head around how these things work. It's like you're asking for a manual for a saw because you want to build a wooden table. You of course need to know the tools but you also need to know how to put the table together with them.
I'd put an emphasis on first selecting Stack Overflow links via Google, also.
Just want to say don‚Äôt worry about not being smart enough. Coding in general just requires a large knowledge base and it‚Äôs very easy to mistake knowledge for brains when you see more experienced developers solving problems 5x faster
I think if you have everything noted down, and try to make something, anything with it, it will help you way more than just reading, it's like math, you practice to do some operation until you get a result, and there's always google from where you can get quick tips or even the entire code on how to do what you wanted to do; but if you find the code of the thing you wanted to do, try to understand it, get the logic part of it, so you learn the lenguaje. 
[https://i.imgur.com/0mw1I8e.gif](https://i.imgur.com/0mw1I8e.gif)
"Javascript: The Good Parts" by Douglas Crockford. Concise, well-written, and just opinionated enough to teach a minimal set of sane best practices.
Head First Javascript Programming Book earlier this year. Right now I'm a React Native developer for a multi national company so yeah... It's good for learning the basics, ES6+ stuff I learned with google but it clicked easily.
codeschool.com was great for me to understand basics
On the school page opening the text feels weird when another text above was opened and is automatically closed. The text that you wanted to open opens to the top. About Me does nit fit the box on iPhone SE.
Stackoverflow..lol
Care to elaborate?
It‚Äôs not the resource, but for me it was the way of learning. 80% of programming is recognizing patterns (and anti patterns) I‚Äôd say. I use cue cards and test myself on the daily to keep me up to date. 
Ya, I‚Äôd agree. You should always invest in yourself 
I have used both extensively, with MDN being my favorite in precision of information. Not always easy to apply though if one doesn't have the background knowledge yet. Stackoverflow is also very good IMO, but I DON'T want to ask every single little thing on there because it seems like my learning will get diluted if i don't find it out on my own via research, trial and error etc.
I started it a few weeks ago and consult it here and there. Yesterday I did for example which triggered this post. He does a great job actually building things, but the explanation are insufficient at times to understand the "why" behind things
I will be doing research into the perfectionist mentality you mentioned. Thank you !
Thanks for the feedback. I‚Äôll have a look at the issues :)
Came here to shout out Stephen Grider. He does great work on Udemy, and I lean on his courses for new info on React and used his ES6 course as well. Great pace, great structure, love the practice problems. 
You could say 9 features, as object desctructuring is in stage 3 for the Ecmascript specification and array destructuring is already in the ES2015 spec.
Thanks for sharing this. Looks real good so far
Nice. I've got moistdads.com for the right offer.
You took moistdads.com?! Damn, had to settle with soppinpops.com :(
You should definitely have a look at [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise), and in particular [axios](https://github.com/axios/axios) for HTTP requests
For me IÔ∏è just had to take a step back and identify why we need JavaScript. Then start learning the parts IÔ∏è needed and applying the concepts. On your html/css page, what does it currently not do that you‚Äôd like it to do? If it‚Äôs simple animations, you‚Äôd be surprised how much you can accomplish with CSS. JavaScript adds behavior and functionality to the page, but that is a broad stroke definition of why we need it and how to use it. I‚Äôm still learning as well, but if you have any questions feel free to PM me.
Short answer: your if/else statements should go inside of the callback in the ajax call, because otherwise the response data (usually) will not be available. Longer answer: if you can imagine yourself as the JS interpreter for a moment, you would read through your code like this: 1. create a var called myData, create a function called getData 2. run getData() 2.5. send a GET request, then hold it in your memory temporarily because you know it's not done yet. 3. run the if/else checks, and all the code inside them 4. at some point after 2.5, (you don't really know when) set the variable myData to some value from the backend Since computers are really fast at running code, chances are step 4 will be run after step 3, where you actually need the data. The quick solution is to move your if/else into the callback function. Also, I don't believe you can check for array emptiness like that. Try if(myData.length &gt; 0).
Yep it's the most useful site. 
You‚Äôll need to move your if statements in the `done` callback. The callback is executed at some point later and so the reason your if statement isn‚Äôt working is because they executed before the callback.
Came here to say this. His stuff is actually over my head, (really wish he'd do a series of JS Basics) but I enjoy listening to his videos when I am stuck in the car for long drives. I dunno if its learning through osmosis or whatever, but I've found that just by listening to him talk about JS, I've gotten more comfortable with talking about the language and it's concepts, even though I can't actual write that much code. I really only needed to learn enough to write a few user scripts. I accomplished that, but someday I want to come back and learn JS more thoroughly. Until I find the time to do that though, I just keep watching JP and his wildly entertaining videos and hope to pick up on a few things here and there. Best of luck to you, thanks for asking this question, lots of helpful comments so far with great resources for us noobs.
Browser &gt; View Source. (Doesn't really work so much nowadays.)
A Chrome extension that delivers the best development articles to your New Tab https://www.producthunt.com/posts/daily-7 
https://tech.slashdot.org/story/17/11/08/1135240/how-chrome-broke-the-web
&gt; #10 Method extensions You can already do this? Just tack onto the object's `Prototype`
This is completely unfair, but when I'm looking at a new language for the first time, I often base my initial opinion of the language on the answers to two questions: * Does it have pattern matching? * Does it have list comprehensions? Of course I love JavaScript and it has neither, so that's not hard and fast, but I'd love to see list comprehensions added in place of destructuring (which we already have). Also, extension methods are completely unnecessary, as we've been able to do that forever except with more power and more flexibility. It just doesn't look like it does in a class-based language, but of course JavaScript has bent over backwards to try to look like a class-based language, so it's not unreasonable to assume that the author just didn't realize what he's missing.
I‚Äôd just like to thank OP for posting this, as well as all the great people giving awesome responses and linking great material. I‚Äôve been feeling the same with JS lately, but I‚Äôm starting to feel that I need to just keep at it, and the more I do things, the more I will understand them! Hell, if I have to watch a video 6 times until I understand why we‚Äôre using a loop in this situation then so be it!
Eloquent JavaScript taught me everything I needed to know at the start. Highly recommend that one.
There is JSON5 which is designed to address precisely your concerns about ergonomics. From what I understand, JSON‚Äôs goal is to be easy for machines to read and write, and easy for humans to read. Where it is strict, it is to engender performance and resist misuse. For instance, comments existed in the early spec, but were removed on the concern that users could abuse it to extend the format or store non-comment data. 
People love JSON - it's used everywhere, it's easy to parse, it's easy to read as a human being, it's easy to understand what's going on. So it's a very common data structure that can be used to store lots and lots of things. If there weren't strict definitions for how things had to be structured... would it even be the same data format? What if my JSON blob used strings as keys, but yours used variable names? What if tried to assign a function to a key? If you pulled down JSON from an API, you'd need to ask all kinds of questions, like, "What data-type are the keys? Do I index with a string, or...?" The fact that these things are standardized is why they're useful.
react native is easy if you are creating your own app, you decide on how it looks, its features, and so on. however, if you work for a client where THEY decide how the app looks, how it functions, etc... then you will fucking hate react native.. seriously. 
I've played music for two decades and teach it to kids on the side. I've noticed people with competence of a skill often have the mindset you do and it's easy to forget what it's like to start learning a new skill. This is true for music, coding, anything. They don't know where to start so they're looking for guidance. "It's remarkable that people new to music want to learn via books and videos rather than making their own compositions. I mean, if you're not interested in making music, why pick up an instrument?" This isn't a particularly helpful sentiment and it just makes it look like your masturbating your ego. I think doing and creating is the best way to learn too but it's understandable that people new want to immerse themselves in the basics - especially considering another extremely common complaint about juniors is that they don't know the fundamentals!
JSON is strict about these things because the ‚Äúdiscoverer‚Äù of JSON, Douglas Crockford, is a proponent of the idea that there should be one, and only one, way to do something in a language and that the rules should be clear. Since it was going to be an interchange spec, he wanted clear rules, like requiring all keys to be quoted, rather than only quoting strings with non-word characters. He didn‚Äôt want comments because he saw it as a way to make JSON overly complex, preventing parsers from adding special instructions in comments. 
I use those if statements to determine how many points to add to my chart. I then add the points to an array and render the chart. This is in a loop so it makes a new request for data every minutes and adds new points. Does the whole chart thing need to go inside the callback too?
&gt; This isn't a particularly helpful sentiment and it just makes it look like your masturbating your ego. Yes, if you mutilated my argument I suppose it would do. A better rendition would be: "If you're not willing to pick up an instrument, why are you so set on being a musician?". Programmers program. That's how they learn and develop. At some point there will no longer be tutorials and video courses, because the nature of the job is that you're always doing something new (else you could just buy / package existing software). It's a research-oriented job and learning to experiment and prototype effectively is amongst the most valuable skills a programmer can develop.
Actually doing the work on your own, looking up the things that you know you should be able to do when you get stuck on MDN/StakOverflow, knowing how to ask the right question, seeing how other people approached the same problem and incorporating those idea into your refactors and future work. Repeat, over and over again. Doing it using a modular, TDD workflow using the terminal/command line like a real development process even though it's a bit trickier at first getting set-up. Numerous good exercises here: [exercism](http://exercism.io/languages/javascript/about) and I think freecodecamp had a similar structure to their javascript track that's a bit easier to get going on.
As a beginner, I often find MDN a bit over my head. Sometimes w3schools has the right amount of basic information to allow you to understand MDN. SO is fantastic for obscure or specific cases, but they're not friendly to beginners there. 
Touch support should work now! Please let me know if you still have any issues.
Omg. Soppinpops!
Stephen Grider's React classes on Udemy
Eloquent JavaScript. One read through made me go from knowing nothing about JS to it becoming my go to language.
&gt; ...because under the covers JavaScript uses prototypical inheritance rather than a class based system So does python (iirc). Just because the class implementation isn't straight from C++ doesn't make it any less valid. 
Project generators for me. Learned the basics of node/scss/commonJs/es6 &amp; build tools (grunt/gulp at the time) all with one single generator (angular fullstack, search google for daft monk). It took some real time and patience going through how it‚Äôs wired together, but when the generator is so popular (as this was, at the time of learning 2-3 years ago) you tend to be able to pickup best practices and techniques implicitly. From there on I‚Äôve been able to go into other frameworks (such as a project using react/redux) a little easier. Though, that said, I‚Äôd liken the switch of angular -&gt; react/redux to trying to work with angular when you‚Äôre familiar with JQuery. It takes time, patience, and plenty of effort in spare time but just keep banging your head against the keyboard till it makes sense
Here was my path for vanilla JS. Down the road I would learn [node](https://www.udemy.com/the-complete-nodejs-developer-course-2/) and some [framework](https://medium.freecodecamp.org/a-study-plan-to-cure-javascript-fatigue-8ad3a54f2eb1) if you want a development job, but focus on vanilla JS for now. 1. [Eloquent JS](http://eloquentjavascript.net/) (at least the first 6 chapters) 2. [Codecademy JS](https://www.codecademy.com/learn/introduction-to-javascript) (a good intro that includes some ES6) 3. [You Don't Know JS](https://github.com/getify/You-Dont-Know-JS#you-dont-know-js-book-series) (mode in depth reading) 4. [JavaScript 30](https://javascript30.com/) (build some projects) 5. [Codewars](https://www.codewars.com/dashboard) (always keep practicing) Use [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript) for reference, [StackOverflow](https://stackoverflow.com/questions/tagged/javascript) when you get stuck, and join a local [JavaScript meetup](https://www.meetup.com/) group and do some pair programming.
&gt; Just tack onto the object's Prototype That would be monkey patching. Extensions don't actually modify (patch) the class. They also aren't global. You have to import them wherever you want to use them. See also: https://kotlinlang.org/docs/reference/extensions.html
Pipeline operators are in strawman of TC39 proposals, destructuring will be fully implemented in ES8 and extensions could always be done via prototype. I believe a lot can be done with libraries like RxJS so there is no need to pollute the language itself (I live reactive programming, don't get me wrong). If expressions can be done with ternary operators though it looks ugly. What I like is cascade operator. I think it would be a great feature.
Photoshop and like 100 images :)
Without really knowing how the rest of your code looks, I would say only add the lines that rely on the response data to the callback, e.g. adding the data points to your myData array and rendering the chart. The chart probably should not go inside the callback because (i'm assuming) it is an object that should always persist, even when the response doesn't come back.
This particular feature is still under develipment. But it will be sooner or later :)
Treehouse.
When you make an HTTP request synchronously, you are blocking everything in the application, it doesn't allow anything to be added to the callback queue. In other words, until that request fulfills, your entire page is dead, nothing will be interactive, and if the request takes a long time, the browser may give an ugly pop up asking if you want to kill the page. As others have said, make use of callbacks or Promises. More recently in ES8 there has been the introduction of async/await which allows you to write your code in a manner which makes it easier to write asynchronous code. (Read more here) [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function].
MDN and dmitry soshnikov's the core
Oh snap nevermind! 
Yes, this is a great answer. A good developer will be persistent and will handle frustration. And there will be frustration, a lot, along the way. But when you face those seemingly unsolvable problems, and you think, and you try, and you eventually solve it; you "learn" that you can do it. That in the end, with sufficient effort, you'll solve it. Repeat that process over and over and eventually you'll be pretty confident you can solve whatever they throw at you. Perhaps you'll need to study new concepts, perhaps you'll ask for help, perhaps your solution is not ideal; but you'll win. On the other hand, if when faced with frustration you stop, then you'll "learn" that you can't do it, that perhaps you're not that smart, that perhaps you're not "a real developer". But all it takes is to keep trying, to keep studying, to keep learning from other people much smarter than you. We're gonna make it brah.
Number seven exists - it‚Äôs called ‚Äòdo expressions‚Äô and I believe it‚Äôs in stage 1 or 2 of its proposal. Babel has full support for it.
I don‚Äôt understand why keys are different from strings. This is just syntax. Ie, { a: 1 } == { ‚Äúa‚Äù: 1 } Same for double vs single quotes. I can‚Äôt believe that performance is the answer. If you‚Äôre that concerned about performance you probably should be using JSON anyway.
It's easy to write as well, most editors help you avoid mistakes
What does list comprehension add that stuff like map and filter can't do with similar readibility? I'm not very familiar with list comprehensions so forgive me if that's a dumb question.
Yes it was hard to do but did not take much time. Xd
People love JavaScript too. It‚Äôs used everywhere, but the standard evolves.
Actually i was thinking to take over this task soon.
Having a more senior developer leave to another job and dumping a huge project on my lap. Baptism by fire if you will. I did a lot of things wrong and god help the poor soul who is still at that place of employment that has to maintain my code base. But I learned so much by *doing* that I would never have learned from any single resource. 
&gt; ES8 ES6/ES2015, ES2016 (~~ES7~~), ES2017 (~~ES8~~), ES2018. The next one would be "ES9".
I think this could help you https://www.udemy.com/understand-javascript/
Unfortunately not. It's a University city with many like-minded people I'm sure, but unfortunately the freeCodeCamp club isn't taking off here 
Double-quoted keys is one of the better design aspects of JSON. It ensures easy parsing plus it has no opinion about the particular language. For example, lisp allows characters that most C-like languages forbid (due to them being operators). Likewise, it avoided keyword debates. More importantly, it gets rid of ambiguity issues like when your keyword starts with (or contains) a comma, quote, space, bracket, etc. Crockford made some mistakes when he designed the spec. The first mistake was the lack of trailing commas. This is fine when sending over the wire, but annoying to human writers. Of all his mistakes, this is probably the most understandable as the then current ES3 spec did not allow them. Another flaw (also based in ES3) is the lack of good multi-line strings. They are not so necessary for computers, but humans would greatly benefit from the ability to represent newlines natively rather than by putting `\n` into some insanely long line (and trailing `\` characters are known to generally cause problems). The third mistake was the removal of `NaN` and `Infinity` values. The numbers are more or less universally understood to be doubles (64-bit floats). Crockford (from what I can tell) doesn't understand the hardware limitations that are responsible for the IEEE 754 specification. Instead, he seems to think that these numbers should not exist and therefore he arbitrarily forced his "pure" vision onto the rest of us despite the bad implications. The biggest flaw of all (IMO) was the removal of comments in later versions of the spec. He believed people might include informal pre-processor directives inside comments, so he (once again) decided to enforce his vision of purity by completely removing them. In practice, he didn't solve the issue (turns out that people who need this use complex magic strings instead) AND he made sure that users cannot add comments to an inherently human-readable format. Add trailing commas, add `NaN` and `Infinity`, add backticks for multiline, and add comments. Those together would make for a much better standard, but even JSON as it is has single-handedly saved the rest of the world from the likes of XML which counts for a lot in my book.
You should be doing something like function getData() { $.get('http://127.0.0.1:5000/').done(function(Data) { myData = Data['stuff']; if (myData == []) { // do something } else { // do something else } }) } getData() 
I like this one at first sight ! Thank you 
The problem is apples and oranges. There is a fundamental difference between most extension method-equipped languages and JavaScript, so it makes sense that the way to solve certain problems is also different. Monkey patching (in JS) *also* doesn't modify the class, because JS doesn't have classes and therefore there is no class to modify. It adds a function to an object, which can then be used as a prototype for new objects. Therefore monkey patching is also not global, as it only acts on the single object that you've added a function property to. Unfortunately, that doesn't work so well with built-in objects because built-in objects are in fact global. So monkey-patching them is also effectively global, which is why we've all been encouraged not to monkey-patch built-ins. But now there are proxies, which have pretty much the same attributes as extension classes: they don't modify the object in question, they have to be "imported", etc. Thing is, I think we should be careful what we wish for here. Having coded in both Scala and C# (the latter not by choice, it's part of my job) for some years, I can say that there is little that I like less than extension methods. They make it really hard to figure out where the code that is being run actually lives when an extension method is called. IDEs help out with this of course, but when you live in an ecosystem where IDEs have a hard time helping (like JS, where any code could have been run in a prior `&lt;script&gt;` tag, including proxies/monkey patches/whatever), they make `goto` look really tame.
My point in saying "people love JSON" is that they love it because it's standardized. When you get a JSON object back from somewhere, you know EXACTLY how to use it. 
So listeners for touchstart and touchmove can no longer use preventDefault() unless they pass an option to addEventListener... You're going to need to give a *bit* more of an explanation as to how that means relying on addEventListener = broken.
For me it was picking a project I didn't know how to solve. When you do tutorials, the one thing you miss is that puzzle solving part of javascript. I call it learning how to learn. Once that clicks, then any programming language is within reach. You realize that resources like stackoverflow and online videos are all tools.
It just makes parsing so much simpler and easier. With your keys example, if you make quoting keys optional, now you have to restrict what characters can be used. Then you get into a mess of what characters are banned (eg colons, commas, spaces, Unicode spaces) or what is allowed (only 0-9a-z? Then what about _ or √© or other Unicode letters?)
I hear ya. I'd say that I'm approaching the subject from a more academic perspective. I think it's important to have the fundamentals down first. When I started with all this I arrived at jQuery very quickly. I then noticed that jQuery (as well as other frameworks) is fairly easy to learn and apply when JS really isn't. It's like picking up the crayon when I really want to know how the crayon is made before I use it
Everyone hates the regex my dude. 
&gt; Monkey patching (in JS) also doesn't modify the class, because JS doesn't have classes Not relevant. Anyhow, JS' classes are just as real as Python's. &gt; which is why we've all been encouraged not to monkey-patch built-ins It's any object we don't own. https://www.nczonline.net/blog/2010/03/02/maintainable-javascript-dont-modify-objects-you-down-own/ &gt; but when you live in an ecosystem where IDEs have a hard time helping (like JS [‚Ä¶] Extensions are a static thing. *Go to definition* would work just fine.
this! 
It's a perfectly good question. The same question can be asked of literally any language though, because every list comprehension can be rendered as some combination of `map`, `filter`, and `flatMap`. (Of course, JS doesn't have an official `flatMap`, but it's not hard to implement one.) I do think list comprehensions get overused, because in simple cases I do think that using `map` and `filter` is at least as clear, if not more so. But when the cases get more complex, the function-based version can become really opaque really quickly, while the list comprehension is still quite readable. It's part of why I said that my little rule isn't hard and fast, because any language can have "list comprehensions", it's just a matter of how readable they are when they get complex.
More and more I'm coming to appreciate that lack of configuration is actually a feature (this applies to everything even outside of tech). I'm trying to adopt this principle in ux design of the apps I build too. It's like using a multi tool versus one that's built specifically for the job. Prettier is just a good example of something that gets it right. If you don't get it right, and it needs configuration to make it work, it's just a bandaid solution to something broken. 
Class syntax is currently incomplete which is why you have to use `.bind()` or a passthrough arrow function everywhere in libraries like React unless you want to start using early-stage proposals. Even when talking about raw prototypes and Constructors, classes are seldom called for. Philosophically, classes are a poor man's closures; closures are a poor man's classes. The two are generally very similar ideas. In JS where every class is also an object, the ideas meld in a very unique way. In factory/module design, you have functions (with closures) that return objects that contain functions that access that (private) closure. Closures don't inherit per-se, but composition (which functional closures use) is generally preferred by classes anyway (I'd note that the closure lookup pattern is almost identical to the raw prototype chain lookup). One of the biggest advances for large projects was commonJS and webpack where you are guaranteed that every file is private by default (only revealing the exported bits). This is at it's core just a normal factory/module. If you impose a one-class-per-file pattern (like so many OOP languages do), then you generally have little reason to use a class in the first place. The only general argument for classes over factories is performance. It is true that there are single-digit performance increases in at least some use cases, but if your class is trapped in a closure of it's own, part of that is negated anyway. There is a slight performance advantage to classes because they are guaranteed share functions and object structure, but as compilers have gotten smarter, most of this difference has disappeared. The performance and memory difference approaches zero the fewer instances you have. If you are instantiating hundreds of instances, then it's worth considering a class (I do for datatypes I consider primitive), but that's a very small percentage of most codebases. 
Don't forget [Javascript Allonge](https://leanpub.com/javascriptallongesix/read) which is great for beginners trying to understand the more functional aspects of the language (you *will* run into them on all modern projects).
But there is no absolute "right". The best you can aspire to is to get it right - for some people. 
Can you elaborate a bit more on the points you raised? Definitely interested in your experience before I devote some time to learning the library.
ELI5 please 
It depends upon your use case. Let's talk about it in the strict sense of sync vs async in traditional styles (as in not using .done() or similar). If there are UI elements that needs this data before they can be used effectively, using sync. calls isn't a bad idea. Such examples can include initialization of features, data updates where the UI is reliant on that data. In general, sync calls aren't what I'd recommend if only for 2 simple reasons - performance and error handling. If the target data source is unavailable, how will you know if it never completes? You can use timers to timeout, but as it's a blocking code, guaranteeing the timer will fire isn't guaranteed. Using it as async, you can jump in at any point and say "OK, we're done here, cancel it" without needing to, for example, check for a 'cancel' variable/flag elsewhere (which would possibly lead to variable pollution outside the scope of the function). Sync is blocking as you're probably aware. Other functions relying on them can't continue until it completes. This can lead to poor UX compared to using async calls and building UI elements that display progress or simply advise that the operation is still in progress. However, in a lot of cases, using async calls would be a better way to go. They can lead to callback hell if going the traditional callback route, but this is why promises and async-await are prominent options. I've found promises to be rather frustrating from a syntactical point of view, and I've never had confidence in my ability to use them effectively, and in some situations it can be inherently awkward to use them. Such an example was with an online photo gallery I built that accepted uploaded images, resized and watermarked them for different social media platforms as well as for the gallery itself. Due to the design I had in place at the time, I needed information from each promise to perform further processing - the solution I came up with was using an object outside the promise scope, but it didn't feel tidy and I hated that I couldn't find a better solution. This is due to my lack of understanding on them, but I never found a different solution to the problem even after extensive research. Async-await solves this problem in my eyes, as you are simply assigning data returned from callbacks to variables, meaning that it's possible to avoid callback hell and promise chains. This also allows you to use that data in both sync and async functions - being able to fire off multiple async calls to different input sources with the data means that you can take full advantage of the scalability that async offers. It makes sense from a syntactical point of view and makes code so easy to read. The downside is that it's not as widely supported as promises. In the example you've provided, you are at least using .done and could also use .error or similar as well.
I always recommend [window.fetch()](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) over axios, `window.fetch()` is a standard API that is/will be supported by all browsers, standardization on core libraries instead of third party libraries should always be preferred if possible 
It works half the time, just run the code twice. Problem solved. Seriously though you've given us about 0.1% of the context we'll need to help you. what is `i` doing? how is it used? why is it an array? what's inside the iframe? where's the rest of your code?
The big curiosity and never give up.
As others have said, parsing is probably the reason. But, just want to say, it was actually designed to NOT be strict. There's no schema that JSON is bound to as with XML. The schema that is there, is very easy to follow, and makes for very easy parsing.
I‚Äôm view this through the Reddit app and can‚Äôt see/find the link. Can you re-link it in the comments?
Json is a good replacement for XML - effective way to describe data. keep it simple
My console has no output when I run it with that input (note that I had to switch to the http version of jsfiddle b/c the image isn't served over https)
I agree, except for the fact window.fetch has no IE support at all which is often a dealbreaker :(
https://medium.cobeisfresh.com/how-redux-can-make-you-a-better-developer-30a094d5e3ec
Codewars is great, the interface is much better than hackerrank or other similar sites imho.
I'm a Redux maintainer, and I can say that it completely changed how I approach writing code and organizing an application. I won't say that Redux is a silver bullet or magic solution to problems. However, it _does_ force you to think about what your application's state is, how that state is updated, where the state should live, and how to organize the update logic. Yes, using Redux will probably involve more keystrokes than other solutions. No, it doesn't guarantee a maintainable codebase. But, I've seen a _lot_ of Redux-based apps over the last couple years, and it sure makes it a lot more straightforward to trace through the code and see what's actually going on. There was a great comment from /u/phoenixmatrix a month ago on [how Redux leads to better long-term maintainability](https://www.reddit.com/r/reactjs/comments/7069ct/i_love_redux_but_i_hate_the_boilerplate/dn1mj4s/).
When I try to use the provided text I get an HTTPS error because JSFiddle is HTTPS and the IMG is just HTTP: Mixed Content: The page at 'https://jsfiddle.net/basictom/ab1yzzmq/1/' was loaded over HTTPS, but requested an insecure image 'http://img.ed4.net/bcbs/2017/17_10_25_176508_2017WellVisit/images_13.gif'. This content should also be served over HTTPS.
just use a [polyfill](https://github.com/github/fetch), there's [a few](https://github.com/camsong/fetch-ie8) to pick from
I figured. Seems like every kata there especially the beginner and intermediate ones were nothing but test in regex. Didn't teach anything about coding really. 
Don't tell anyone... but its this sub. 
Also you have to wrap the IMG with a DIV, which you also failed to mention. That being said, I found your problem: output += '&lt;div class="row"&gt;'; You never declare an output variable anywhere, so the browser does some hacky stuff and resolves output as the `&lt;div id="output"&gt;`. So what you're saying is "set the output of output to output plus some output" ... or in other words "set the text of the #output element to the #output element (which then gets coerced in to the string "[object HTMLDivElement]") plus the text you were expecting to add". Simply declare output as a string (`var output = ''`); and you'll be set.
See, this is the problem with pretending to have classes in JavaScript. It means people who use them don't even understand what they're using. There is nothing more relevant in this discussion than JavaScript's lack of classes (and nothing more irrelevant than whether or not Python has classes). The reason? You said it yourself. *Extension methods are a static thing.* Why? Because *classes are a static thing*. No static classes, no static extension methods. Seems relevant. If you really want extension methods, use proxies. They do all that extension methods could do and more, and they have the extra added benefit of actually working. 
Been taking some courses from Pluralsight cuz my employer offers it for free. They have pretty good js classes
nice post, why didn't you post the link directly?
On the job training. 
Your explainations are great, and accomplish what a lot of other tutorials fail at: explaining *why* you do things. Most tutorials just keep tell you *how* to do things, but do explain why you're doing them. They don't paint the big picture. Your first sentence right off the bat would make sense even to my grandma (hopefully). "JavaScript was initially created to ‚Äúmake webpages alive‚Äù."" Good work!
There *are* still things XHR can do which fetch can't, at the moment. It's not always best to use fetch, but once it's feature complete that will change :)
[Webmonkey](https://en.wikipedia.org/wiki/Webmonkey), though there may not be many people here old enough to remember it. [Thau's JavaScript Tutorial](https://web.archive.org/web/20000815054226/http://hotwired.lycos.com:80/webmonkey/programming/javascript/tutorials/tutorial1.html) was my starting point if anyone wants to delve into history.
I'd say it's a bad explanation. The metaphor doesn't really reflect the nature of promises as compared to other _delayed operation_ constructs. In particular, it doesn't explain what is fundamentally different from, say, using a callback. If you removed the italics from the "key" words, the explanation would be just as applicable to using callbacks. "You send Jenny off for the cake. At this point what you have is the promise that when she's back she'll give you either a cake or an error. (Let's omit that `undefined` thing because it's completely not correct). When Jenny does return, then you can take your next steps depending on what she returns with. If she..." The explanation, because it fails to point out the fundamental details, ends up being too generic, ends up not explaining what _is_ a promise, just that it is something involved in a general delayed operation. In fact, if you look closely, not only there's no mention of asynchronism, the way in which it is stated can easily make a five year old think that you did nothing while Jenny was out, that you were somehow _waiting_ the whole time. At least until the last paragraph. But then again, that paragraph... &gt; The benefit of Jenny making a promise here is that it didn't interrupt the rest of your programme, where as if you had gone to the store yourself, you couldn't do anything else until you were done. ...is confusing in itself. The impression given was precisely that you only "take your next steps" "when Jenny does return".
https://www.youtube.com/watch?v=v2ifWcnQs6M&amp;list=PL62E185BB8577B63D
It seems all the problems you mentioned wouldn't apply to single quotes being allowed.
Bind your chart's rendering to the data. When the data updates, the chart rerenders. Without knowing your setup though I can't recommend any particular data binding method.
In your first tutorial, why do you do `this.shadowRoot.querySelector('.card__full-name').innerHTML = userData.name;` instead of `.textContent = ...` ?
Sounds a little more like traits from Rust.
True. I wasn't trying to address every point OP had, just explain in general why "strictness" isn't bad.
Yep. In fact, this is Douglas Crockford explaining it himself https://plus.google.com/+DouglasCrockfordEsq/posts/RK8qyGVaGSr
Wait. You wrote an article about this but now you come here asking us the question?
https://jsfiddle.net/ab1yzzmq/3/ Try it with... &lt;div&gt; &lt;img src="/img/logo@2x.png" alt="something" /&gt; &lt;img src="/img/logo@2x.png" alt="something else" /&gt; &lt;/div&gt; as input.
He might just be trying to start a conversation. Convinced me to look into it anyway ;)
Thanks! I could post it directly as a link but I wanted to start some discussion about Redux and find out what others think about it
You can use that as well. I used innerHTML as I have a habit of writing it like that. Text content should be better as it won't try and parse the contents. 
No, I don't think so.
Very cool! I've used RXJS to stream XML responses then parse as well.
&gt; How Redux can make you a better developer I love Vuex and Vue, but I'm *VERY* glad that I learned React/Redux *first* before getting into Vue. 
Pipeline operator, scala(or kotlin "it")-like method shortcut, if, match, block expressions
I definitely tested that and it seemed to work?! Apologies for it not working, but thank you for looking past it and noticing my error... errors. Defining 'output' solved my woes. Thank you sir.
Redux goodness isn't limited to the JavaScript. I wrote a client-server game prototype in Kotlin with LibGDX and Kryonet, with the client and server living in different processes, each having their own store. And it worked wonderfully! Each new feature that was to be added to the game was just another type of action with its accompanying reducer (generally speaking of course). Keeping the server and client in sync was effortless, because you could send an action from the server to the client containing a partial or complete update of the current state of the world. I'm very thankful for Redux and I can't see myself going back to writing games or apps without a Redux(-ish) architecture. 
The problem with `NaN` and `Infinity` is more that they aren't universal across languages, i.e. how do you write a value of `NaN` from C without getting all hacky?
&gt; Extensions don't actually modify (patch) the class. They also aren't global. You have to import them wherever you want to use them. So does that mean the only thing they do is allow method call syntax? We could write an `abs` function and use it as `abs(-3)`, but method extensions would let us write `-3.abs()`?
I completely agree with you. I was not so familiar with functional programming concepts until I came across Redux and those concepts were not only thing that I grasped while learning Redux. Because of it, I have a better overview of an application and my code is better organized and structured. Now, I can clearly see what benefits you can get if you choose Redux as state management. But, as you said, it's not silver bullet and we need to decide if Redux is right tool for our problems.
I've found that while the concepts are straight-forward enough, the biggest difficulty has been figuring out how to organize your store, and translate it to/from API calls. Typical first learning experience: "I need to display a list of users!" store: ``` { users: [{id: 1, name: 'Bob'}] } ``` "Wow this is awesome! OK, so if I click on Bob, I need to edit him..." store: ??? wait what do I give the redux view now? How do I know which user in the array I'm editing? What if I navigate directly to a user to edit without having loaded the full array? Should the user under edit just be a second top-level store? `{ users: [], userUnderEdit: {} }` That's where IMO a lot of the confusion comes in. I was just reading this today as well: https://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html
Yep. And maybe things like properties/getters/setters. Well, the important thing is that it doesn't have all those downsides you get with monkey patching.
Nice article but it reads more like an introduction to the benefits of FP and not necessarily what application level benefits Redux brings to the table. 
IÔ∏è want to learn React and Redux. Where is a good place to start if I‚Äôve been doing PHP and handwritten html / css for the past 10 years
Hi /u/rockawella, in the future, please submit links using the "Submit a new link" option. Thank you!
For learning - https://javascript.info/ is great. Also mozilla docs are great, but javascript.info is much more of tutorial.
\#9 Automatic currying would be hugely problematic since it doesn't allow optional arguments. `xhr.open(method, url)`. Should this run the function with defaults for async, user, and password? Or should it return a new function waiting for more arguments? \#7 and 8 If and try expressions would be a *minor* improvement, a sugary coating over IIFEs. I'm not sure it makes enough of a difference to matter too much. // If expression with iife var result = (() =&gt; { if (param == 1) { return "one" } else if (param == 2) { return "two" } else { return "three" } })() // Try expression with iife val result = (() =&gt; { try { return count() } catch (e: ArithmeticException) { throw IllegalStateException(e) } })(); \#4 Implicit name "it". Haven't the functional folks been seething over "this" being implicit? Do we want more implicit parameters? That means "it" won't be lexical anymore, just like "this" wasn't lexical. Just like we had to do `that = this`, I guarantee you someone will have to do `thatIt = it`.
https://redux.js.org/ is actually a really good place to start. The video tutorials are very helpful.
The standard can *not* make any breaking changes though. This is why we still have `var` working like it does, for example. Now have a look at the JSON rules you may want to change: allowing single-quoted properties, allowing comments, allowing other data types other than strings, whatever you come up with is going to be a breaking change as it allows for more flexible syntax which JSON parsers are not set up for yet.
Downvoted, not enough React. (/s, as if that is even necessary)
Yeah okay, I personally am still using jQuery for most things so only occasionally do I have to use a plain JS DOM function like that, but when I read about it it just seemed to me like the recommended official way to change the text content of an element is .textContent Thanks for producing this content man. Web Components are something that's interested me for a while, and your work here seems pretty thorough.
Yep, and that's the kind of advanced scenario that becomes relatively straightforward [when you follow Redux's constraints like serializable actions](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367). Someone wrote a couple articles about doing something similar for syncing clients in a web VR game: [VR Redux](http://jimpurbrick.com/2017/01/04/vr-redux/), [ReactVR Redux Revisited](http://jimpurbrick.com/2017/07/04/react-vr-redux-revisited/).
I think others have tackled the first couple of points well, so I'll try to address the last &gt; Javascript has continuously evolved. Are any groups trying to evolve the JSON spec? JSON has no intrinsic or safe way of "evolving", it was released with versioning. Versions in documents allows parsers to insure they are interpreting it properly. e.g. xml begins `&lt;?xml version="1.0" encoding="UTF-8"?&gt;`, YAML has `%YAML` directive, html sticks loads of stuff in `&lt;!doctype &gt;`. JSON does not have the equivalent of this. Without a versions, if you change the spec, there is no way for parsers to tell they are interpreting the document correctly. This means you cannot ensure data integrity. There is and only can be *one* JSON spec (there are [*technically* a couple](http://seriot.ch/parsing_json.php#1), because it's defined in a few different places). Any changes to the spec would mean you would essentially creating a new data format, which means you would loss the benefits of JSON's universal adoption for interoperability i.e. just about every modern tool and language will have a way to interpret and understand JSON, which makes it very flexible. i.e. I can write a JSON file manually during development for something and as I start to automate and expand the system, I know every build system, CI system, deployment system etc. will be able to read, understand and modify that file if they need to. So if you want to evolve JSON, you need to come up with a new format that has enough *significant* advantages that it will justify people moving stuff over to it. Which is a big task, that is unlikely to occur outside a fairly big paradigm shift (instead a few incremental improvements). JavaScript is a bad example to show this with since it's a programming language instead of a data format. With JavaScript we can use the language to interrogate it's running environment to find out features are supported (polyfilling) and use the general robustness of the language to ensure it at least tries to run if it hits a stumbling block. This simply doesn't work with data formats, they are static and need to be a lot more stable and accurate. 
wes bos 
Yeah, and that's exactly why I wrote the "Structuring Reducers" docs section and that "Normalizing State Shape" page. My [React/Redux links list](https://github.com/markerikson/react-redux-links) has sections of articles on [dealing with side effects in Redux](https://github.com/markerikson/react-redux-links/blob/master/redux-side-effects.md) and [Redux reducers, selectors, and normalization](https://github.com/markerikson/react-redux-links/blob/master/redux-reducers-selectors.md), and my ["Practical Redux" tutorial series](http://blog.isquaredsoftware.com/series/practical-redux/) also demonstrates some more "real-world" concepts as well. Hopefully those help clarify things for you. If you've got any further questions, or suggestions for improving the docs, please
MDN.
Glad that you liked it! 
Software companies are very poor at identifying the traits of great developers. They are obsessed with knowledge of libraries and academic computer science. I've worked as a front end developer for four years. In that time I've only written two real "algorithms": a non-blocking quicksort for an enormous Knockout table, and a Hough transform for recognising finger gestures. That's it. And both of those I googled, having no comsci education at all. And there's the crux: what makes a developer isn't their academic knowledge, nor rote familiarity with an API - it's their research skills and their willingness to keep kicking at a problem. Yet not one interviewer has ever asked me how I solve problems, how I validate technologies, how I stay tenacious in the face of intimidating problems and looming deadlines. I really think they should.
Here's my standard advice for learning React (and then Redux): The article "A Study Plan to Cure Javascript Fatigue" ( https://medium.freecodecamp.com/a-study-plan-to-cure-javascript-fatigue-8ad3a54f2eb1 ) is a great place to start. It gives an excellent series of steps for tackling modern Javascript concepts one piece at a time: Javascript, React, ES6, and state management. There's also a "Front-End Study Guide" based on that article that's very good, at https://github.com/grab/front-end-guide . On that note, definitely don't over-complicate the learning process by trying to learn many different things at once. Some people will say you should use a "boilerplate" to learn React, and they're wrong - boilerplate projects almost always come with too many pieces configured, and are confusing for beginners. Instead, the best advice is to focus on learning React itself first. Once you have a good understanding of how React works, you will better appreciate why a state management library like Redux can be useful, and you can learn about other tools later. You should start out by reading through the official React docs and tutorial at https://reactjs.org/, and I'd encourage you to use the official Create-React-App tool ( https://github.com/facebookincubator/create-react-app ) for setting up projects. It creates a project with a solid build setup, with no configuration needed on your part. There's an excellent post called "Simple React Development in 2017" ( https://hackernoon.com/simple-react-development-in-2017-113bd563691f ) that gives some more specific instructions on the actual steps to follow. For an even simpler setup, CodeSandbox ( https://codesandbox.io ) is an online editor that lets you build entire React projects right away. For Redux, start with the official docs at http://redux.js.org/ , and watch [Dan Abramov's tutorial videos on Egghead.io](https://egghead.io/series/getting-started-with-redux). Past that, I keep a big list of links to high-quality tutorials and articles on React, Redux, and related topics, at https://github.com/markerikson/react-redux-links . Specifically intended to be a great starting point for anyone trying to learn the ecosystem, as well as a solid source of good info on more advanced topics. It includes links for learning core Javascript (ES5), modern Javascript (ES6+), React, Redux, and much more. I also published an "Intro to React (and Redux)" presentation at http://blog.isquaredsoftware.com/2017/02/presentation-react-redux-intro/ , which is a good overview of the basic concepts for both React and Redux. Once you've got the basics down, my ["Practical Redux" tutorial series](http://blog.isquaredsoftware.com/series/practical-redux/) shows how to implement a variety of useful techniques in the context of a sample app, and my ["Idiomatic Redux" opinions series](http://blog.isquaredsoftware.com/series/idiomatic-redux) discusses different ways to use Redux, what I think are the "right" ways to use it, and why a lot of common usage patterns exist. I can also recommend this [8-part "Build a Simple CRUD App with React and Redux" tutorial series](http://www.thegreatcodeadventure.com/building-a-simple-crud-app-with-react-redux-part-1/) as well. Finally, the Reactiflux chat channels on Discord are a great place to hang out, ask questions, and learn. The invite link is at https://www.reactiflux.com .
# 3 interesting features that *I'd* like in JavaScript **Operator functions** For example (borrowing Python's syntax): class UInt64 { __plus__(other) { ... } __lt__(other) { ... } } x = new UInt64(42); y = new UInt64(0, 0xffffffff); x + y // performs x.__plus__(y) x &lt; y // performs x.__lt__(y) Not only does this let us make types that are nicer and more intuitive with natural operators, but this more general solution could also wholesale replace Proxies that were recently introduced, where `x.y` could perform `x.__get__(y)`, or `new X()` could perform `X.__new__()`, allowing us to make wrapper objects that "trap" those operations. **Multiple inheritance** We've been hacking this in for decades. Off the top of my head, YUI and Dojo classes allowed multiple parents. And today we're *still* hacking this in with Object.assign or class factories. I think all we need to make this happen is, rather than each object having a single prototype link, instead each object could have an array of prototype links. Python already works this way, I believe. **Deterministic destructors** Because memory isn't the only resource. Imagine if we... function f() { acquireLock() openDb() beginTransaction() // ... endTransaction() closeDb() releaseLock() } Seems fine and correct? But what if we return early? Or throw an exception? Or call a function that might throw? function f() { acquireLock() openDb() beginTransaction() if (condition) { return } if (condition) { throw new Error() } mightThrow() endTransaction() closeDb() releaseLock() } Suddenly cleaning up our resources becomes a lot messier and a lot easier to screw up. But if instead... class ScopedLock { constructor() { acquireLock() } __destructor__() { releaseLock() } } Then our function could instead be... function f() { const lock = new ScopedLock() const db = new ScopedDb() const transaction = new ScopedTransaction() if (condition) { return } if (condition) { throw new Error() } mightThrow() } And now, regardless of when or how we leave "f"'s scope, all the destructors are executed and all the resources released.
I can sorta drag the point around now, though the page still pans when I do. Still no visible cropping.
There is something called WSDL, it‚Äôs not so strict and hell ensues with every possible integration. I‚Äôve never had possibility to integrate in a non hacky way.
This is awesome. Thanks! I will start working through this today. It sounds like this is the best first step before getting into react.
Explain why performace is not a reason or give an example please
I keep my API stuff separate. Import API methods and actions into components that need them and trigger actions that way. 
Yes, it's definitely possible, and some people prefer that approach. There's also been a recent upsurge of interest in "Redux-first routing", where the URL itself is updated based on the current state of the store. See some of the articles I've collected on [Redux and routing](https://github.com/markerikson/react-redux-links/blob/master/react-routing.md#routing-with-redux), and also the [list of Redux-related routing libraries](https://github.com/markerikson/redux-ecosystem-links/blob/master/routing.md).
They provide components for you to use that get rendered to native components. A client may want something that isn't supported 
You don't understand IEEE 754. It's not the writing, it's the actual bits. How the user sees those bits is a separate question. When the exponent bits are all ones, if the mantissa is all zeroes, you have +/- Infinity (depending on the sign bit). If any of the mantissa is not zero, it's NaN regardless of the sign bit. This is the same in EVERY language that uses compliant IEEE 754 floating point numbers. Some hardware did not support it (you can still emulate in software at a performance penalty). Every language I know of does support it, so getting rid of important parts to push your (naive) agenda is a bad idea. Instead of allowing these, Crockford wanted everyone to explicitly check for and reject them.
Take a look at redux-first-router.
This course was done by Dan Abramov, Reduxes creator: https://egghead.io/courses/getting-started-with-redux I mean there's that, haven't seen anything as on the point as his own. It's dry, but when you come out, Redux aside - it's just a simple pattern after all, you are a better programmer. This stuff has honestly helped me a lot, i use some of these concepts for everyday programming tasks.
Sorry to hear you had a bad experience! Definitely right that viewing the database has been tricky due to the lack of a Windows based database browser and on Android it's annoying you have to get the file out of the device first. Realm Studio offers the ability to view/edit those Realm files on Windows and can also manage Realm Object Server. Previously the Realm Browser was only for Mac. Studio can also view synced realms on the server, which means that if your app just uses a synced realm, you don't have to copy it off the device, but you can view and edit live directly in Studio while your app is working or being debugged. And yes, Realm Object Server doesn't (yet) run on Windows, so you can run it locally on Windows in VirtualBox with a Linux for instance. Or alternatively on any cloud linux of your choice. E.g. Digital Ocean. Hopes this helps. If you have problems you can also seek out help in the Realm Forums or StackOverflow that is monitored by Realm developers. 
Not w3schools
If you're considering maintaining a fork, it's worth proposing to the current maintainer to add you as a contributor to the main project, that way if they have time to come back in the future people wont have to switch back and forth. However, consider if you actually have time to commit to maintaining the project, whichever approach you take.
Having already learned Scheme (SICP mostly) and Javascript, the Good Parts after that.
Thanks I will check it out
Hey, great article. Found a little typo, might want to fix it: const animal = { name: 'Mouse' } // Object.assign const anotherAnimal = Object.assign({}, animal, { name: 'Elephant' }) // Object spread operator const yetAnotherAnimal = { ...animal, name: 'Crocodile' } console.log(anotherAnimal) // {name: "Crocodile"} console.log(animal === anotherAnimal) // false console.log(animal === yetAnotherAnimal) // false
I will! Thanks /u/kenman
thanks /u/log0behaviour for pointing out! I fixed it :)
I mean - every design is a choice. JSON is meant to be human readable. If you want to optimize for performance, why not choose BSON or protocol buffers.
Why not use the file extension?
This is an unorthodox place to ask, but I'm having trouble finding the answer to a simple redux question. I want to make a POST of data from my store. When I click a button, it should post store.someAction. I have an action creator that checks a local cache and fires the API call, but I'm not sure what the proper location for the store state retrieval is All my Google searches just point to redux-saga (I'm using redux-pack), but don't explain where the appropriate place to pull store state from is, and Dan has said it is antipattern to pull from the action creator
[This talk](https://www.youtube.com/watch?v=IcgmSRJHu_8), although it is from an Elm perspective was extremely illuminating to me about data structuring, in a way which is directly applicable to Redux apps. 
r/LearnJavascript is more appropriate for this.
Because the spec doesn‚Äôt say *‚Äùyour JSON must always be associated with it‚Äôs file extension‚Äù*. There are tons of places where JSON is stored in memory, in a DB, in transit or in the middle of other files, where you have no idea what the extension is (same story for the MIME type). File extensions are not a safe, established or sensible way to version data formats.
for unit testing, most people think of them as more complicated than it needs to be. You are trying to ensure your unit does what it expected to do. That is all. If I do X, it should do Y. Nothing more. Beyond that, you should capture its edges and maybe limitation. I can see you haven't been working on large teams as these are things that are almost critical for large teams. Especially, version control. I vote version control first then unit testing. Start with what you know, maybe a new version of Angular ? Don't try to learn all of these at the same time. Another option, is take some online courses from good instructors. They usually cover good breadth, enough to get started. 
You are right BSON is smaller and faster to serialize. But the fact is that is more easy to writte parsers on strict environments. 
In regards to Dan's comment, I know _exactly_ what Stack Overflow answer you're referring to, and I disagree with him :) I [wrote a blog post discussing why I disagree with several concerns about using thunks](http://blog.isquaredsoftware.com/2017/01/idiomatic-redux-thoughts-on-thunks-sagas-abstraction-and-reusability/), including use of `getState`. You should totally feel free to go ahead and use a thunk to check the store and determine if a value is cached.
Not being contentious - I use Redux daily at work - I still prefer AltJS.
Making parsing less strict is a good thing to do to get a standard to catch on. It‚Äôs the same reason a simple language spec invites many implementations. Now that we have many implementations of JSON parsers, it‚Äôs possible to imagine a next gen version of JSON which requires a more complicated parser, but provides more capabilities.
Granted I've only toyed with them but I like Vuex better than both Flux and Redux. It eliminates all the pain points (to me), doesn't introduce new ones (to me), and does the "Elm pattern" thing very elegantly. There are a couple of things in Vue which I'm not too happy about (I'd love it if computeds, methods and hooks would receive the viewmodel as a function parameter and not as heavily oversugared 'this') but Vuex is spot on.
Fork and move on without him.
This is a good point. The only answer would be to have a new standard with a new name. I could see that being more trouble than it‚Äôs worth. Thanks.
Agreed! I did at least 1 kata a day one summer, and that is how I got my foundation for Javascript. Once it hacked my solution, I could see other people's awesome solution, and figure out where I could improve. 
How am I supposed to retrieve store state to use as the body in a POST request. Abramov says that getting store state in an action creator is an antipattern (and I can see why) but redux-saga and redux-pack all seem to place api calls as the payload in an action
This but god is it annoying lol. You end up with multiple forks from different people at different stages and random merge ins. So fun :-)
Thanks to Redux, I've learned about state management, wow! :) Before that, all variables were flying in the air, now I see them all in the state tree. The idea to render on state change is pure joy. I'm using parts of Redux tree as models for my mustache templates, both work together like magic. The deep nested state tree (against the rules) is trivial to update with object-path-immutable (inside reducers). Redux is so simple and easy to understand. For me, ES6 and Redux are the biggest joys in front-end development for years.
What pain points are you thinking of in regards to Redux? Any suggestions for how we can improve things?
https://stackoverflow.com/questions/35667249/accessing-redux-state-in-an-action-creator Yeah he agrees that checking the cache in action creator is a reasonable use. But I don't understand how it is even possible to post state data from inside a reducer. is the idea that you dispatch a "POST_CAT" action with no payload, and then the cat reducer would make the API call and manage a saga/thunk/pack action transition?
`Object.assign` Use the spread operator instead (`{...oldObject, prop: newValue}`)
It's pretty easy to make a component using the android SDK though. No idea about iOS. Just need to be aware of limitations in advance and plan the extra time to build it natively.
There is a very important difference to be noted here: `Object.assign(obj1, obj2)` will mutate obj1. The spread operator snippet you listed will return a reference to a new object reference. For React and fast shouldComponentUpdate, checks this is great. Sometimes however you want to maintain that same original reference instead.
Auto imports. I could cry, what beautiful js times we live in
fork it
I can not back this up enough. The YDKJS series was a game changer with me and working with JavaScript. 
Commenting to read later tonight!
It sounds like you may not have found Effects or Side Effects / Middleware yet. Basically, rather than updating the store directly, you fire an action to the store that is received by an effect or saga, the saga then calls your API to post, and then depending on the response from the api, you send another action ( success or failure maybe or something more complex depending on your app ) and that will finally update the store with data. 
Nah.
Hold on. What do you mean by "post state data inside a reducer"? One of the rules of Redux is that reducers do _not_ execute any side effects, which includes things like API calls.
I'm interested in cryptocurrency, but not really as it intersects with JS. I'd use whatever tools or language was available. I would make me more inclined to mess around with it, if I could leverage my existing JS skills. 
I would handle that work in a redux-saga
I have the same question. I've been using both Redux and Elm and in love with both.
so happy to be back to blue . 
Right, so that's pretty much what I don't understand. Im sure that you aren't supposed to make a POST from a reducer. I'm also sure that it is recommended not to retrieve state in an action creator (with the only exception being to check a cache). So, I feel like that eliminates the only two places to make an api POST that contains state. If it can't go in an action and it can't go in the reducer, then where? I'm using redux-pack as middleware, but am still not sure where to feed the state into my API call 
Could you expand on how this would be any different if developing in ocj-c/swift or java?
Everyone says they‚Äôve come a long way
And that's what I said earlier - you _should_ check the state in a thunk action creator or saga if you need to. API calls qualify as side effects. Side effects _do_ go on the action creation side of things, generally via middleware. I'd encourage you to look through [this gist of common Redux thunk usage patterns](https://gist.github.com/markerikson/ea4d0a6ce56ee479fe8b356e099f857e), as well as the articles in the [Redux Side Effects](https://github.com/markerikson/react-redux-links/blob/master/redux-side-effects.md) section of my links list. Afraid I don't have time to specifically help solve this question further right now (busy at work), but I'd also suggest dropping by the Reactiflux chat channels on Discord and asking this question in the `#need-help` channel. The invite link is at https://www.reactiflux.com .
When you say it‚Äôll look idiotically done, do you mean the stuff done by him or done by others ?
Api caching and side effect management as a standard part of redux take away a lot of pain. Even if it was just a simple standard that could be extended by those who knew how to
You can use redux-thunk along with redux-pack (it shows this in the redux-pack docs). The risk with checking state before dispatching an action is that you‚Äôre not guaranteed to get a stable state tree: actions immediately before and after your dispatch can easily modify whatever you check. That‚Äôs why it‚Äôs important to really only use getState in certain cases; really it‚Äôs only a good idea when you know only the action type itself is what‚Äôs modifying the state in the reducer. I think it‚Äôs also worth pointing out that since you‚Äôre using promises with redux-pack, you can also use whatever caching capabilities are built into your `http` library. 
devs are interested in whatever makes them $$$, which includes blockchain. Otherwise why would they be creating mining scripts that run in browsers for distributed hash processing?
Personally I like JavaScript more than pure functional languages due to flexibility and (if I'm being honest) familiarity. Add in TypeScript for type safety and some libraries like Monet, lodash, RxJS, or Ramda and you'll have a really functional environment in a familiar language.
All you need to know about CSS in JS: don't do it, there are better solutions like CSS modules.
I like pulling Haskell experience into js where it makes sense. I do monadic error handling and avoid loops/conditionals in favor of contexts and functions. That said, JS has great clojures, generators, and objects. I guess it's a mix for me.
I appreciate the response, thank you! I don't see myself going back to Realm until I can access my Realm files live, directly from either my actual device or the emulator device without needing to run anything on a virtual machine or remote server. Will definitely keep my eye out for any updates that make that possible though. 
I'm using Vuex with Vuejs and I love it
a few months a go my boss wanted to port an old anroid app to react native. it is a simple app: 50mb sqlite file, a search field, list view. simple right? because it is. the android app breaks no sweat searching, displaying thousands of data, and flipping thru it. probably an ios version would have no problem seen i have seen something similar. doing the same thing on react native is impossible! i've tried hard never got it to work. so if anyone have a good example on github, please tell me so i can study it :)
What are the top problems that come to mind when you say that *Redux isn't a silver bullet* to problems?
yep, you're right. ListView initial rendering is too slow or scroll performance is bad for large lists. Use the new FlatList or SectionList component instead. Besides simplifying the API, the new list components also have significant performance enhancements, the main one being nearly constant memory usage for any number of rows. If your FlatList is rendering slow, be sure that you've implemented getItemLayout to optimize rendering speed by skipping measurement of the rendered items. See more details on: [facebook.github.io](https://facebook.github.io/react-native/docs/performance.html)
People should check out Elm.
Have you tried Elm?
Have you tried Elm? 
;) 
 function getData() { $.get(url).done(function(data) { if (data.length === 0) { // I wouldn't do data == [] // do something } else { // do something else } } } 
var checkbox = document.createElement(‚Äòinput‚Äô); checkbox.type = ‚Äúcheckbox‚Äù; You will then need to append the checkbox to a parent element.
Just curious why are you doing: if (myData == [])
others.
Of course.
Look into the selector pattern. E.g., you've got a top level slice of your state maybe by high level feature, create a set of selectors that define the contract to that slice. Use those selectors in those feature/components to get the data you need and feed into whatever action you need to fire. 
I love design patterns. I liked Redux at the first sight because it is a useful use and revival of the state machine. Think about it, before redux, how often do you the state machine in an web app? Not too often, I suppose. I'm so happy that the thing I love so much is being used in such a brilliant and productive way. 
True. How about asking the existing developer to at least give their blessing to a particular fork.
hell ya https://code.visualstudio.com/updates/v1_18#_support-for-multi-root-workspaces
i remember have tried everything, like flatlist/purecomponents/etc and the performance is just not acceptable. like i've said i just need an example of a relatively large sqlite rows being fetch, display in a flatlist, when you scroll new rows are fetched, and preferably with good with good performance.
I must say. I hate all things Microsoft. I've been a JetBrains user for a while now and its been starting to suck for the past two years. I got fed up and tried VS Code, going in with a bad attitude ("this is going to suck", "I'm going to hate this"). I FREAKING LOVE VS CODE! To top it off, I found a bug, reported it and it got fixed 5 days later. Try that with JetBrains and they say people have to upvote bugs for them to even look at it. I still hate (most of) Microsoft but damn son, VS Code is the shit! Goodbye JetBrains. 
Do you remember your first exposure to something functional? Lid ash or Ramada, or just straight Haskell ?
IÔ∏è find that a lot of people I talk to are picking up functional ideas from other disciplines, and bringing them back to JavaScript. It‚Äôs such a flexible language with great support for first class functions, and other traits you mentioned. Not tempted to go full functional with PureScript or another language that compiles to JS?
Vertical panels is the truth!
https://imgur.com/b3iIQmS
Per the quotes in [my React Boston talk on the Redux ecosystem](http://blog.isquaredsoftware.com/presentations/2017-09-might-need-redux-ecosystem/#/9) and my post ["The Tao of Redux, Part 1 - Implementation and Intent"](http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/), Redux was deliberately designed to move side effects out of the core. Instead, that was intentionally left up to the community, so that users could use their own preferred syntax and approaches for managing async behavior. Because of that, we have no plans to include anything related to side effects directly as part of the core Redux library. However, because Redux was built as a set of low-level primitives, many people have built extensions, addons, and higher-level abstractions on top. This ranges from [action/reducer creation utilities](https://github.com/markerikson/redux-ecosystem-links/blob/master/action-reducer-generators.md), to [prebuilt entity/collection querying and management](https://github.com/markerikson/redux-ecosystem-links/blob/master/entity-collection-management.md), to [side effects middleware](https://github.com/markerikson/redux-ecosystem-links/blob/master/side-effects.md), to libraries like [Kea](https://kea.js.org/) or [Dva](https://github.com/dvajs/dva) that provide their own APIs and use Redux internally. I personally am _very_ interested in finding ways to make it easier for people to get started with Redux. I'm also interested in making it easier for people to plug-and-play pieces of Redux-based functionality. My addons list already has [a section listing libraries that are related to Redux modularity and plugin-type behavior](https://github.com/markerikson/redux-ecosystem-links/blob/master/component-state.md#modularity-and-encapsulation). Unfortunately, I just don't have time to sit down and play with any of those myself, and none of them seems to have really taken off within the community. Earlier this year, [I filed an issue asking for discussion on ways to make Redux easier to use](https://github.com/reactjs/redux/issues/2295). There were some good comments, but the discussion trailed off, and not much has come of that so far. Again, I don't have time to really tackle some of the suggested solutions myself, but I would _love_ to collaborate with the community on anything that helps people solve problems with Redux.
I've been using it for a few years and it's just been getting better and better. Welcome to the group lol
Several things. Redux doesn't actually solve the problem of managing state for you. It gives you a suggested pattern to follow, and provides some tools for following that pattern, but it doesn't actually enforce that pattern out of the box. (Specifically, [it doesn't enforce things like immutability or keeping side effects out of reducers](http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/#laying-the-foundation).) That's why one of the most common errors when using Redux is accidentally mutating state, which then usually leads to the UI not updating properly. Similarly, Redux doesn't provide strict guidelines or rules on [write the part of your code that does deal with side effects](https://redux.js.org/docs/faq/Actions.html#actions-side-effects), or how to [structure your project files or split logic between action creators and reducers](https://redux.js.org/docs/faq/CodeStructure.html). We _do_ provide [suggestions on how to structure reducer logic in general](https://redux.js.org/docs/recipes/StructuringReducers.html), but that's all ultimately up to you. This is great if you are comfortable coming up with your own solutions to questions of structure, but not so good if you don't know what you're doing and want a set of predefined boundaries to follow. Redux doesn't magically make a codebase maintainable. I've seen some Redux codebases that were really easy to understand, and I've seen others that were bordering on unreadable. Since Redux is a global state store, the tradeoff is that centralized behaviors become much easier, but concepts like encapsulation and plug-and-play behavior become harder to implement. They're not _impossible_ (my addons list [has an entire section devoted to libraries that implement per-instance component state in Redux or forms of plug-and-play / encapsulation](https://github.com/markerikson/redux-ecosystem-links/blob/master/component-state.md). But, all that said: if you use Redux the way it's intended to be used, then you _should_ end up with a codebase where state updates are traceable and data flow is predictable. Long-term, that should mean that the application is maintainable and understandable.
The frustration and the lack of confidence don‚Äôt go away. The problems you solve do get more complex and therefore more satisfying, though. Stick with it!
I've been using it to write video games, dispatching state upon key presses, and handling the draw on subscribe. Combined with immutable, my draw state is entirely predictable and functional. I've not yet ran into situations where the redux throughput hinders the game performance. It seems to be just fine for ~50ms game loops. BUT none of the games I've made were twitch gaming. It's also just been "for shits and grins" but even things that require low latency, like mouse motion, I'm dispatching. Combined with Pixi.JS it works fine. 
Isn't redux basically just events?
Yes and no. The store does have a single generic "change"-type event in the form of `store.subscribe()`, and if you squint hard enough, you could say that `combineReducers()` acts sorta like an event emitter too. But no, it's much more than just events. I'd suggest reading through these articles for a much deeper look at how Redux is meant to be used: - Dan Abramov's [You Might Not Need Redux](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367) - Justin Falcone's [What's So Great About Redux](https://medium.freecodecamp.org/whats-so-great-about-redux-ac16f1cc0f8b) - My own two-part post [The Tao of Redux, Part 1 - Implementation and Intent](http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/) and [The Tao of Redux, part 2 - Practice and Philosophy](http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/)
CSS files make your website look pretty, but they can take a (relatively) long time to show up in your browser. Rather than making the user wait for the CSS to show up, this project puts all critical CSS (e.g. what the user will see initially before scrolling or otherwise interacting with the page) in the HTML file so it‚Äôs available to the user immediately. Or at least that‚Äôs what I assume, I haven‚Äôt used this project myself.
Time.
Im in your position, and I started this yesterday. It‚Äôs a free Ebook and clearly explains all the basics: https://roadtoreact.com
For everything I've learned from redux, I've learned even more useful strategies (that I employ in js/ts) from [Elm](http://elm-lang.org/).
Good overview. Unidirectional flow and immutability in Redux really revolutionized my way of thinking. Trying to maintain control over app and DOM state when there were so many things changing it was total chaos in retrospect. 
The entire react community is indoctrinated with this immutability nonsense.
Fork that m*therforker
If its for yourself, do do things that are "in-fashion", for the lolz! Don't bother with suitability if you like programming, and its only for yourself, go for the cool challenges!
When you use a sync ajax in chrome, it yells you in console something like ‚Äúsync ajax is deprecated and it may be removed in the future‚Äù. Sync ajax is toxic because it FREEZES the UI thread until the response comes. If the server never responds, you will easily get a frozen tab. 
What do you think of using RxJS instead of Redux?
Am i crazy or the pricing are a bit off ? Who's that for ? Programmers who won't bother hosting their things ? Being api based it appeals to technical people but its like a costly firebase. I feel i could use content tools paired with meteor or gunDB for similar effect for free. I guess big enterprises who existing application wanting to integrate a cms part in their product... i really don't know
Why the negativity? The project was sill active recently and the author was honest about the lack of time. Do you maintain a project like that yourself? Do (would) like that kind of comment about your contributions?
Yes, I was thinking about this usage from OP's article: &gt; const anotherAnimal = Object.assign({}, animal, { name: 'Elephant' })
When upstream is not responsive I usually publish a scoped package to let people try it and provide some feedback.
Forking isn't considered bad ettiquet, as long as you give appropriate attirbution wherever relevant and keep within the original license, so go for it. It is polite, though by no means neccessary, to let the current maintainer know - so do that too. When/if his other priorities abate next year the forks may merge back together, he may be pretty happy that his project has a carer for while he is unable to give it much attention! Of course by publically forking a paused project you essentially become de-facto maintainer for at least a time, so you might need to consider a little time impact. If you can't afford that time then make it clear in your fork's documentation so others know in advance that you might not be able to be terribly responsive to *their* PRs and queries.
I got into functional programming in JS a few years ago using Underscore/Lodash. I also use TypeScript and RxJS in production. I‚Äôve done prototypes in Elm, and now I‚Äôm learning PureScript for personal projects. For me, diving into PureScript has given me a new perspective on functional programming. Once I learned about the underlying mathematical concepts (like categories, functors, monoids, etc.), I noticed I began to use types to plan. It‚Äôs become easier to know how to compose parts of the codebase. It wasn‚Äôt easy for me to learn the concepts in PureScript, but was well worth it in my opinion.
&gt; Javascript has continuously evolved. Are any groups trying to evolve the JSON spec? Why should someone change an already pretty flexible data exchange format just because a scripting language gets changed?
If you want to optimize for hand-editing the data instead of simple transferring, for example when creating configuration files and such where humans need to view and edit a lot then you can look into formats like YAML or TOML.
source https://github.com/cristijora/vue-light-bootstrap-dashboard
As someone who has not gotten into redux yet, whats the anwser? I'd suggest just having users be another object with userId's as keys.
&gt; What do you think of using RxJS instead of Redux? You mean Redux with RxJS, right? Like in ngrx for Angular. They work fantastic together.
Wow VSCode is amazing! Quickly closing the gap of some of the great features Jetbrains has. Does anyone know how to bind extract to const and method to a keyboard shortcut? 
I been making frontend applications for about 20 years now, desktop, mobile and web. For me React was close to a revolution. I've known and worked with frameworks before, namely jquery, knockout, Angular and Vue. But the way React lets you define and compose components is in my opinion unmatched. Especially when combined with Redux. Both aren't so much frameworks that determine *how* you solve stuff, you'll solve problems in the same way you solved them before, just more elegantly. Redux changed the way i think of a component. It is nothing but a pure function that takes arguments and returns a view. And when the arguments change, so does the view. const Bold = ({ text }) =&gt; &lt;b&gt;{text}&lt;/b&gt; const Header = ({ children, color }) =&gt; &lt;h1 style={{ color }} &gt;{children}&lt;/h1&gt; &lt;Header&gt; &lt;span&gt;hello&lt;/span&gt; &lt;Bold text="hello" /&gt; &lt;/Header&gt; No registrations, no globals, nothing cuts off access to local state, composition is natural and logical. When i first learned it, and figured that 30 minutes into the video lesson i could actually go and build user interfaces, i thought that was pretty crazy. Redux on the other hand taught me to think of the application state in a different way. My view merely reflect, there is no complexity any longer in the user interface. I can refactor, rip something out here, include something there, like building blocks. As well as knowing *full well* what is actually going on, being able to inspect every thing the application does - i did not experience that before. Especially not in traditional MVC or MVVM. 
This article is using the copyrighted icon of [our Android app, Hermit](https://hermit.chimbori.com/), without permission or acknowledgement. Hoping this is just confusion and simply not understanding that app icons found in Google search are copyrighted and not open for reuse to promote and entirely unrelated startup, but this act does not inspire our trust in their core product.
I found that using both works best for me. I keep both open and jump back and forth to handle whatever I'm trying to do. VS Code has greatly improved in the last year, and the plug-in support is great. 
Github. I remember reading through Backbone's source a few times and there was this moment where something just 'clicked'. That would have been in about 2010. Honestly reading other people's code is *such* a helpful way of progressing your learning. I remember spending a lot of time analysing the different techniques they used, and then Googling things I didn't properly understand or that didn't align well with what I already (thought I) knew. 
Great set of resources there, thanks! Looks like I've got some reading to do today :) I'm actually doing my first real React/Redux app, and 2 screens in I think I'm going to be refactoring my store structure already.
Saying something is better doesn‚Äôt mean it is. 
People don't give Microsoft the credit they deserve. It was trendy to hate Microsoft, and new developers are brought up in work environments where that feeling is propagated for no good reason. Maybe I'm in the minority here, but I think Microsoft is great!
I wouldn‚Äôt schedule my day in that fashion. Some days/weeks will be focused on existing work. Some will provide the opportunity to investigate new tools, and build prototypes. There is no hard-and-fast rule that says 20% of your time should be spent on new stuff. Ideally, you should find ways to use your smaller work projects as an opportunity to experiment with new technology.
Thank you for taking out the time to help out. I want to learn vue.js so should i learn the framework first? Any tips?
What about his statement was negative? Not working on a project and ignoring PRs is a detriment to the project. That's not negativity to state a fact. If I were in the author's position and someone said that about me I'd agree. What else could I do *but* agree?
The reason is that development on Windows is painful in a lot of ways. I couldn‚Äôt be happier to only touch Mac OS and Linux, but VSCode is really great!
Find a tutorial, and try it out. Find a small project at work that doesn‚Äôt have to be perfect, and try it out. Also, if you really want to learn, it doesn‚Äôt have to be during those 9.5 hours at work. Some of my best work at edX was done on my couch at home. 
I think the idea here is that JSON can and will outlive IEEE 754. Infinity and NaN are pure programming artifacts and are not real Numbers. For example Python automatically converts big Numbers into an internal objects that can hold more precisions. JSON is future compatible with new number types that can go beyond the restrictions of old numbers designs
Lodash isn't a functional library, Ramda is the functional equivalent. The docs are a bit more esoteric but I'd highly recommend it.
Pretty much that. 
Wow then /u/gugador's point is pretty useless. Thas something not at all specific to redux, just basic state management. Well then..
Okay great, I guess if I have to make a login page or something small I'll use vue.js so I can learn and also get the task done. Thank you for guiding me, means a lot.
[removed]
I should clarify. Don‚Äôt use your experimental tool solely because you want to try it. Use it because it‚Äôs the right tool for the job.
Yes, main thing is trying to get a job in the field and these new frame works are in demand. I tried react but was kinda complicated, vue is easier for me at this moment. 
I‚Äôm guessing angular switched to semver? Last I heard it was on v2
Make daily goals in the shower. When you hit your daily goal, move over to new tech stuff. * Today, work out that replication issue It helps to even make daily goals for each weekday on monday. * Monday: work out the replication issue * Tuesday: finish the User object * Wednesday: implement User signup * Thursday: do the user management backend CRUD * Friday: integration None of these event may take 9.5 hours, so whatever's left in the day, Vue.js for the rest of the day. Perhaps even try to re-create that day's task in Vue.
It has indeed! I detailed some of it at the time here. http://jsdiaries.com/2017/01/23/angular-2-upcoming-features-and-semver/
what do you mean by &gt; add checkboxes in to my JS file also why u want to &gt; check their status in the JS file if you only create checkboxes w/o showing them in the UI -- they gonna have the default state. unless you then set `.checked`. do you even want to show those checkboxes on the page as the end result? if not -- use variables instead. i just cant see the big picture from your description and you provided no code sample, so..
I‚Äôve always had mixed opinions on semver for projects like this. Angular 1 vs angular 2 was a rewrite with an incompatible API. If that happens again from say angular 11 to angular 12, it gets very confusing. Job listings are ‚Äúangular 2-11‚Äù and ‚Äúangular 12+‚Äù, new devs don‚Äôt know how far back their knowledge goes, recruiters fumble, etc. I‚Äôve always wanted a number in front of semver that was controlled more by marketing than anything else. Angular 2, v3.x.x. Then eventually Angular 3 
5 working 0 learning
I'm an experienced developer and never thought of doing this. Definitely going to give this a try. Thank you. 
You'll love it. No longer will you have sleepless nights over half-finished tasks, since you won't start any more 8 hour tasks at 3pm.
more info needed: - what url you try to crawl - what node version do you use - which npm (global) modules/versions have to be installed pls make a live example on [glitch](https://glitch.com) to spare us the pains of setting up the correct environment based on guesses
fuck the blue icon. i liked orange :(
It's early in the morning, so maybe I'm a just confused: seems like your work day is the number of hours you're on the clock, working for your client. Your personal research isn't part of that 9.5 hours; it's outside of work. It's free time. The amount of time you have to spend on personal research indirectly is determined by the agreement you've made with your client. You have a scope, a backlog, and an expected delivery date. Your research time comes out of the time you have left after you've achieved a work velocity that lets you meet your expected delivery date for the sprint. Or milestone, or the project as a whole, or whatever you go by. If you want your work day to be 7.5 hours, leaving you 2 more hours to do research, you factor that into your estimate. This is relevant because, practically speaking, the time you have to do research isn't always something you get to decide, unless you get good at knowing and planning for how long it's going to take you to do something &amp;mdash; not to mention getting good at writing contracts and negotiating with clients for a less aggressive schedule. As to your exact question, the answer is: figure out how long you can study something before reaching the point of diminishing returns. If you get fried after an hour, there's no point in going longer than an hour, right?
You say you want to "invest your time", but the problem is that your employer is paying you for that time. Unless your employer specifically gives you time to spend learning new things, which is pretty unlikely outside of learning something you need for a project at hand, you should be learning on your own time.
I would recommend this here: https://laracasts.com/series/learn-vue-2-step-by-step
learn git. now.
The official statement is that Angular &lt; 2 is "Angular.js" and anything higher simply "Angular" For all I care they should've just given it a new one since they're so unrelated 
0%. 
State management overall is such a beautiful concept. I was building a POC on Vuejs with Vuex and it seemed so natural and correct that it makes you wonder why we weren't adopting it earlier. I implemented a custom state management functionality for my Angular1.x application, and it's bloody incredible :) 
Correct. The problem presented is no different in any other system.
I'm sorry I forgot to mention. I'm a freelance junior developer. I'm trying to finish client projects and also learn new technologies. Just not sure how to break the time up.
Hello, I was in the same situation. Even worse, I work for 9 hours and spend 2.5 hours in travelling. What I did: 1. I have a daily activity log(a simple notebook, nothing fancy) I write everything I have to do in a day. 2. I spend time reading book for the Subject I learn. Mostly JavaScript and React Js. 3. Spend at least 1 hours after work learning or working on a side project. If 1 hour is not possible or I am tired or procrastinate, I still manage to spend at least 15-20 mins to study. This helps in consistency. 4 Spend 4 hours each on Saturday and Sunday. You can try follow this. Remember, do not be inconsistent else you will loose interest. 
something relatively minor i'd love to see; ability to swap left and right editors
Okay makes sense: Example: Monday: Landing page + about page. Whatever time left focus on Vue.js. and rest days other pages. Sunday I can focus on something i want to do personally like create a look animation effect. All this can help build my portfolio.
Without looking at this, my solution would be to get the x,y coordinates of each vertex, and the x,y value of the point. I would then make sure the x and y value of the point is within the range of each x and y edge. It would be 3 iterations, 2 comparisons each. I have not confirmed this works yet though. Intuitively it seems like it should.
&gt;I want to learn vue.js Buy this and get it within the next 6 days while it's $15 https://www.udemy.com/vuejs-2-the-complete-guide/ You can thank me later.
* 4 hours: Personal Project - Can be put on resume * 2 hours: Tutorial Videos/Books - Learn the modern tech for your project * 1 hour: Career Education - Cracking the Coding Interview, r/cscareerquestions * 1 hour: Whiteboarding - Pick a problem, solve it on a whiteboard, work through explaining your thought process, and thinking on your feet * 1 1/2 hours: Codewars, Hackerrank Take 20 minute breaks every 90 minutes or so to let things absorb in your brain. If you look at the successful coding bootcamps this is generally how they break down their day. Source: Changed industry at 35, doubled salary, left a Masters in CS program for a bootcamp. Total amount of time learning programming -&gt; attending a bootcamp -&gt; doing a fellowship there -&gt; getting fulltime job = 9 months.
I‚Äôve used the fp section of lodash as a sort of beginning point when talking to JS devs who are new to functional ideas. It‚Äôs a nice sort of, ‚Äúoh, IÔ∏è know lodash‚Äù type of thing https://github.com/lodash/lodash/wiki/FP-Guide 
Thanks for sharing. Your journey echos a lot of my own habits from learning about functional, and it is definitely a struggle for me to learn PureScript and Haskell. But so well worth it. IÔ∏è am an all around better developer for it. 
I think you're correct in that prototype software has efficiencies and is dynamic. It takes a skillful dev to be able to prototype natively at the same speed - personally, I'm not quite there yet, but I value the other advantages in spite of these drawbacks. Anyways, yes, your point is absolutely valid. I'm curious can you work with data APIs in Axure? That's one reason I do things in code - seeing the scope and breadth of live data and content helps tremendously with information architecture and organization. For me this is really exciting and also really important because it's one step closer towards what the product actually is as opposed to how we might represent it through design. Another supreme benefit is being able to partake in all the amazing open source codebases and imaginative projects developers are making available. There's so much cool stuff out there. I thought not being able to leverage it was such a shame - this is what I mean when I say my sandbox got bigger. Yes HTML/CSS/JS and all their transpilation languages. Sometimes I pass it on and it gets massaged and integrated by other devs. Most of the time my code goes direct into production. The gap isn't as large as you might think. You just have to be willing to go through the hoops of responsibility and debugging. Again there's the actual work product (the code itself) and the intangibles -- the CS knowledge -- that sustain and inform the product. Being able to be a part of that process is very important to me as a designer.
Are there water proof dry erase boards? This is good stuff. 
Job Listings will undoubtedly get confusing. But it might be something you can take advantage of as dev by proclaiming you know new shiny version of Angular X. Recruiters won't know the difference and you could jump the queue if you were going through one that is.
aka just another expensive cloud headless cms
the post can be summarized as simply declarative vs imperative dom updates. of course using raw dom was always possible and always fastest. it's easy to dismiss the need for diffing the world if you're willing to write custom update functions for every bit of your UI; when your UI is 1-bit "Hello World", why even use a library? RE:DOM seems to provide sugar for initial dom creation but leave the updates painfully imperative, as they would be in plain DOM. littering the entire codebase with `this.el.textContent`, `this.el.className`, `this.el.style.color`, etc will grow the final bundle size very quickly. while the lib is tiny, the majority of app code will rapidly erase any size benefits unless you write helper functions as a level of indirection to reduce byte size. looking at https://redom.js.org/documentation/#conditional-children how are conditional children supported after construction? do you have to repeat the same logic in all `update` calls?
everyone has been giving great solutions for my journey, I'm very grateful for this. I have taken all advice into creating a new plan, please let me know if this is something you advise: Daily - Monday to Friday 5 hours - personal project for portfolio development/resume 2 hours - vue.js / new tech 1 hour - Math: because I really enjoy canvas effects and math helps with it 1.5 hours - canvas effects: this is something i truly love and is also good for learning javascript Sunday: 6hrs - just have fun and build some fun things: effects, animations and etc. Can be used for portfolio and also learning javascript.
If you're working in javascript then that means you will spend 8.5 hours reading blogs about the newest .js library or framework
I'd also suggest looking into RescueTime or something. It's kind of neat to see how you wound up spending your time. My RescueTime says I've spent too much time playing Factorio. 
I think I may be an unusual case, because I've been doing functional programming for as long as I've been doing JavaScript. Or at least, I've tried to, I think most of my old code is pretty imperative compared to my current style. I think JavaScript is really a mixed blessing for FP. On one hand, JavaScript gives you first-class functions, and ES6 gives you a lightweight syntax for working with them. With classes, instanceof checks, and nested ternary statements you can easily simulate pattern matching. This means that JS basically provides the bare minimum you need to get going without FP, without throwing a whole lot of other distracting language features at you. Using these features I've had success porting a number of Haskell papers almost line-for-line into JavaScript; the result is just more verbose and requires manual thunk creation wherever laziness is needed. On the other hand, JS lacks any kind of functional standard library, is rife with mutability, and lacks types. It's possible to go the dynamic functional programming route a la Clojure, but I think Clojure's quality as a dynamic functional language is largely supported by language features that don't port to JS, like namespaces, core.spec, multimethods, an extremely rich standard library, etc. I also think functional programming in JS also suffers from overuse of libraries like lodash, which tend to be aimed more at convenience than at providing a strict implementation of mathematical functions. In the case of lodash, its functions each do a huge number of things and are very difficult to provide good type definitions for. It's good that these libraries act as an on-ramp to FP by showing people the power of function composition, but I often find code that uses them heavily to be hard to maintain. I see the biggest value in FP in the usage of algebraic structures (functors, applicatives, monads, etc.) to encourage the use of standard abstractions and generic code, so for people doing FP in JS I try to recommend things like the FantasyLand or StaticLand spec. I like types and greatly prefer Flow to TS, so I use flow-static-land as my standard toolset, and it's made problems that I struggled with for a long time much more clear to me.
It's showing as $10 for me. Even better!
You need to learn Linux. Then all 'new tech' will just be compilers, toolchains, and code. Then you can learn while you develop whatever you or the client wants. Then If you want to implement 'new tech' it's just reading docs, analyzing network requests and returning the appropriate response.
Its a scam, they show the price depending on your cookies. 
9.5h is too long, i'd get cognitive decline and do a lot of bullshit. I don't think there is a domain in which work smarter not harder apply more than in IT. You can spends weeks building a crappy solution you could spend a day making. The simpler app will always be easier to maintain. Real a lot on patterns, in my opinion read on functional programming and streams. Once you get the hang of it, need a new feature ? Create a stream for its data and filter/map/reduce it. Theses 3 tools are weird at first but once you know them, you can solve nearly all your problems with them. Which makes everything the same and easier to get into. Also stay put on new library and new fashions, tons of things are easier today than it was few years ago. Say a realtime distributed database, used to be a hell to implement, now with rethinkDb and its change stream, anybody can do it alone. Check out GunDb for prototypes, its fast AF. You don't need to learn database replication with its performances problems. Of course if you get specialized dig into one of them but only then and most case, you won't need it. Now being a junior freelance sucks.. Look for a job, get experience, find mentors. Then freelance and you can offer worthwhile value. Something i think really suck in the fields is the amount of people launching themselves in business without correctly knowing how to do things. Since most client can't tell the differences, it makes the whole domain suffer. 
https://github.com/substack/point-in-polygon
Hi /u/dmitry-budko, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I think I had similar questions when I first started using it. the answer below is pretty good and we follow it in our app. Except we do get state in our thunk actions to get certain pieces of state that are more global to our app like the current user. Fetching that kind of data in every component that makes an api request would just add noise/fluff and apart from the overly broad/vague "antipattern" warnings you have nothing to worry about. Our app is pretty big and complex now and that is the last thing I would worry about creating issues. 
First of all, don't work 9.5 hours per day.
Yes, only doing freelance to build portfolio for a job. I want to get a job and be part of a team. Thank you for your guidance and support. 
Programming with Erik! Google it
Yes. I'd suggest starting with Dave Ceddia's [A Visual Guide to State in React](https://daveceddia.com/visual-guide-to-state-in-react/) and James K Nelson's [The 5 Types of React Application State](http://jamesknelson.com/5-types-react-application-state/). Both of those are React-centric articles, but the core concepts apply no matter what UI layer you're using. Beyond that, you might want to read some of the other articles in the [React State Management](https://github.com/markerikson/react-redux-links/blob/master/react-state-management.md) and [Redux Tutorial](https://github.com/markerikson/react-redux-links/blob/master/redux-tutorials.md) sections of my [React/Redux links list](https://github.com/markerikson/react-redux-links).
I'll check these out. much appreciated.
I took the that course and it was excellent. If fact, I've done 3 of Max's courses and they were all excellent. 
I would recommend spending 1 - 2 hours a night studying computer science fundamentals and practicing algorithms/data structures. Having been in the industry for almost 2 decades and one thing I've noticed is that frontend devs who have strong CS fundamentals are worth their weight in gold. Plus, you'll find that learning new tech becomes easier both in terms of grasping new concepts and being quickly ramping up with unfamiliar tools. [Here is a great resource](https://github.com/jwasham/coding-interview-university) to get started. 
Just replace [your sword fighting sessions](https://www.xkcd.com/303/) with learning.
You could probably write on a mirror. Not sure how dry erase markers would do in the shower, though.
Once you get to be very sr you'll spend half or less of your day working, and the other half wondering around the internets aimlessly. 
Just a tad over my head.
I keep running it trying it to figure it out and sent it to a couple people that I know. Turns out it was just my testing environment because it worked for all of them except for me. I uploaded it to an ec2 server and it worked on there too. Next time I will definitely use glitch next time I have a problem, thanks!
You have options to become a front-end developer (JS/TS, HTML, CSS); a back-end Node JS developer or a full-stack (front-end + back-end) developer. Given your experience in creating games, you could also be picked up by an indie company that makes HTML5 games.
Hi /u/bor83j, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
[JSDoc](http://usejsdoc.org/)
Double recommend laracasts - excellent tuts on there.
I tried searching for water bear, but I get this weird animal thingie that can survive in space. Mind sharing a link?
You know we might have slight problem with promises when there's an academic paper on how to reason about them.
Good response, I had the same question. My only thought it maybe if you were a freelancer you could price your hours in such a way that ongoing "training costs" are baked in. Might make your pricing less competitive, but it also might not matter that much. 
Figure out how new / old / boring stuff can accomplish problems and learn that way . Don‚Äôt be afraid of boring and old things .
Kind of unrelated, but you're like the 10th unity developer -&gt; web development I've seen this week. What the hell is going on in the unity world?
One of the great things about Vue is that you can drop it into an existing site/page really easily. So you could just take an existing project and change one or two parts into Vue components while you're getting to grips with how the framework functions. Then you could start building complete projects.
Robert C Martin reckons 20 hours a week self study. 
I agree that there's pros and cons in every library out there. There are some overhead writing update methods, however that gives you a lot of freedom and flexibility what comes to creating complex animations and interactions. I have strong Flash background and like to be in control. So I agree what you said, but that's by design. What comes to the performance, I haven't micro-optimized everything, because I've wanted to keep the source as minimalistic and easy-to-follow as possible. For example I haven't used Levenshtein distance to calculate diffs, instead I've gone with O(n) operation and let the DOM do the work: https://github.com/redom/redom/blob/master/src/setchildren.js That's something I will study, so it might change in the future, probably giving even more performance. Let's see. I've already created couple of large single page apps with RE:DOM and it's been a real joy to use, because of logical stack traces, strong performance and flexibility. But like I said: there's pros and cons in every library, it's just a matter of what do you value. For me it's flexibility, and embracing web standards and pure JavaScript. Thanks for the comments, I appreciate it!
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [redom/redom/.../**setchildren.js** (master ‚Üí d701e3d)](https://github.com/redom/redom/blob/d701e3d4a16309a7f73ee1a3a844d0ad89098f94/src/setchildren.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
If you are a Junior developer I would mostly look at what companies around you are using and learn that if it is reasonably modern.
totally, I bet this is the only paper written on promises too. Just hopelessly complex. We should use callbacks, I bet no one has written a paper about them before.
&gt; How can i teach myself to build with JavaScript without spending so much time on HTML / CSS? Use node. No DOM, no CSS, no HTML, no worries, no cry.
Definitely. And, if OP is committed to improving himself like that every day, he'll soon be so awesome that he can spend less time working, but bill at higher rates, for better and more interesting projects.
You can't "fix it". If something is async, that means you have to use it asynchronously. const feed = await Promise.all(articles.map(async (article) =&gt; ...) 
i feel like backend developer have so much easier to learn programming that frontend guys. Maybe using Node.js is actually a good idea but i heard that you should already know a bunch of JavaScript before you dive in into node.
wow good idea!! Thanks bud!!!!
don't listen to them. Just write some simple scripts and cal em with node. It's easy my dude.
if you go with Levenshtein, make sure you use Damerau-Levenshtein which also supports neighboring transposition as a single op. FWIW, some libs are trying to implement the Myers' diff algo used in https://github.com/yelouafi/petit-dom. [1] https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance
It's actually not that complex, really. Probably some people are not accustomed to the _formal_ style of this kind of paper and that can require a bit of effort. But I really encourage you to read it. It's not specially interesting (it is interesting but nothing tremendously groundbreaking or anything), but on the other hand if you don't usually read formal papers, this one is easy enough to serve as a good exercise to familiarize yourself with the style.
I'm glad somebody agrees with me. I recently found out about node fibers and really wish these had become more popular. They really simplify concurrent javascript programming and its a shame they weren't adopted by javascript in general (maybe there are deep V8 reasons for this). If anybody has used ruby's eventmachine, node-fibers are basically eventmachine for node.
Do what you're good at and what you enjoy doing. If you're learning a skill to get money it won't work - period. I've been doing development for 20 years and I'm at the very top of the pay scale because I love what I do and I'm good at it. Even if c# pays more in general it won't for a crappy developer compared to a JavaScript dev that codes like a warrior.
I found this book too on data structures for js: https://www.amazon.com/Learning-JavaScript-Data-Structures-Algorithms-ebook/dp/B00OYTCT02/ref=cm_cr_arp_d_product_top?ie=UTF8 Do you recommend this?
It sounds like you're trying to build an entire webpage to test js on. I would just use some of the pure js learning resources like code academy, and when you feel like you understand js, go on GitHub and look for boilerplates that feature your flavour of js, ie, what js framework you're using.
I haven't used the Drive API that I remember, but it's quite probably expecting that you pass either a `Blob` or a `FileReader`, instead of that string you're passing as content (`media.body`). For dynamically generated content, you can do with a `Blob`, but in any case: [Blob@MDN](https://developer.mozilla.org/en-US/docs/Web/API/Blob) [FileReader@MDN](https://developer.mozilla.org/en-US/docs/Web/API/FileReader) 
Yeah, I've seen and heard lots of different algorithms ‚Äì Levenshtein was first to come in my mind :) RE:DOM's simple diffing is surprisingly fast. Of course it depends on which direction your mutating etc, but usually it's enough. It still beats most of the view libraries and it's O(n) :D - http://mathieuancelin.github.io/js-repaint-perfs/ (waiting for PR https://github.com/mathieuancelin/js-repaint-perfs/pull/125) - https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html
I agree that back-end is easier to get going with, and developing a node/express API really helped me wrap my head around how the entire modern web app works. Also, using a CSS framework will remove a lot of the HTML/CSS boilerplate work you'd have to be doing, so you can focus on functionality. 
You should do some basics like events and dom manipulation, I‚Äôve started learning JS last year and now i‚Äô m doing very interesting stuff, i feel like when i have to do some html or css just google it even if it‚Äôs just a form or some basic stuff JS i feel like it will be the future 
I wouldn't bust your ass the first 3 months on the job (unless necessary) Set expectations somewhat below your ability and overdeliver once in a while. Exceeding expectations is more often about relative than absolute performance. You should spend as much time as you can get away with, frankly. As long as you meet your deadlines and your supervisor is satisfied with your output, you should be good. Unless your boss is looking over your shoulder constantly, no one is going to be able to glance at your IDE and tell what you are doing. Another tip is to get into the office when no one is there, early or stay late. You can get so much more done during those times as Most people only get about 3 hrs of productive work done per day. 
Personally, I'd recommend React. Huge community, lots of tutorials and resources, backed by Facebook, same concepts as VUE, but most importantly, lots of jobs for it. 
If you are building an GUI outside of the terminal, there isn't much you can do without knowing HTML/CSS/DOM. If you are just wanting to learn JS and build functions that you can see the result in the terminal, you can use `node` 
Try the Quokka extension (free community version) for VS Code. It executes JS as you type....great for learning.
JS is (and has been) in its golden age for a few years now. I believe this golden age ends with the proliferation of web assembly, after which JS will be one of a myriad of options for developing front end code for the web. NodeJS will remain niche.
Honest question: do you find async/await hard to reason about?
https://waterbearlang.com/
Isn't that Babel-transpired only? AFAIK object spread operator is a stage-2 proposal.
Probably, but personally I'd be reluctant to work in a JS-stack without Babel. Anyway it's mentioned explicitly in the Babel docs: https://redux.js.org/docs/recipes/UsingObjectSpreadOperator.html
I've never read it, so I can't make a recommendation. What I would recommend to start is to watch videos to learn about data structures and algorithms. Youtube has a TON of them and you can find great content on udemy, coursera, and other sites like that. I find when self learning devs start with books, the theory can be overwhelming at first, especially for folks who prefer to learn visually. The benefit of video over books is that it teaches you how to visualize the process by which you reach conclusions. Basically, how to "show your work". The skills you'll develop are valuable for learning how to break down a problem to it's most basic parts but for your use case, they'd be especially valuable for learning how to do a technical interview. Technical interviews take a lot of practice. Video is also biased towards a more practical approach to learning the subject. You won't get a lot of depth, as most of them are beginner level, but by the time you're done, you'll be armed with enough knowledge to know what questions to ask and what books to read to find those answers. That's where books really shine. When you want to deep dive into theory and more specialized topics. 
Using promises is simple, I won't give that up for callbacks. I sorta got lost around here: https://www.dropbox.com/s/ersuwfpfhd5sk0z/promises.png?dl=0
How to get Udemy courses for almost no money: &gt; Put on wishlist &gt; Wait &gt; When the next big sales happens they'll "coincidentally" also be on sale for almost nothing Pretty shady site but if you play their game it's reasonably cheap
Why don't you write a blog about them.
Right, so either more than two days at work are spent not doing business important tasks or I'm working a crazy number of hours or I'm part time. Nice if you can get it but, 10% time is a perk. 40% time is taking the biscuit.
Or if you're employed, you find an employee willing to offer 10% of time or so for professional development.
If you're back-end you're expected to get familiar, over time, with DB frameworks (if not actual SQL / HQL / other querying) instead. Swings and roundabouts. You need very little HTML and CSS to provide a platform to learn JS.
Its not async/await thats the problem. Things can get complicated. What is calling your async function? is it supported if you are using a framework so do you need a try/catch? Are you mixing in or converting existing callback API, etc.
js-repaint-perfs is basically a joke. all it tests is if you can efficiently change `className` and `textContent`. it'll tell you if a lib is obviously slow, but it doesnt do much to differentiate libs that do the very basics mostly right. i use it for sanity checking domvm for perf overhead regressions via an unoptimized 0% mutation bench [1]. however, i've stopped submitting domvm updates there. &gt; simple diffing is surprisingly fast as one data point, the full regen of the vdom, diff and dom reconcile of the ~2900 nodes takes 1-1.5ms. this is without any sCU or other optimizations [2] which are possible in domvm that bring the cost down to effectively 0. &gt; ps. domvm's results are also impressive :p [1] https://leeoniya.github.io/domvm/demos/bench/dbmonster/index.html [2] https://github.com/leeoniya/domvm/blob/3.x-dev/demos/bench/dbmonster/app-subviews.js
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [leeoniya/domvm/.../**app-subviews.js** (3.x-dev ‚Üí 908195c)](https://github.com/leeoniya/domvm/blob/908195cfbbc48a2652e23a8fe17e922cd8458e92/demos/bench/dbmonster/app-subviews.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
Isn't that a contradiction already? There are tons of options available for the backend (go, java, c++, c#, ...), without even a need for web-asm, yet node happened. There are tons of languages available on the desktop and mobile, yet javascript is eating into that space. 
Can you explain?
Okay makes sense. I found these two video courses: https://frontendmasters.com/courses/data-structures-algorithms/learn/ https://www.udemy.com/learning-algorithms-in-javascript-from-scratch/ These videos seem good. And Then Ill practise these: https://javascript30.com/ 30 day JS challenge. But you have more experience so if you say do it.. I'll start lol :) Thanks.
That, or use `for (const article of articles) ` instead of map. 
First things first, you should work less. If you're learning, two sets of 3 hours is optimal. If something interests you, THEN put more time into it. Two hours a day should be a workout. If you want to learn Vue, hop into the documentation. It's stupidly easy and is actually the best resource available. Try and build something like a calendar with weather forecast based on location. Use some existing API for the weather. Have fun.
not shady at all! i remember they used to have those big prices, but then changed tactic and now they almost always have a promotion for 10, 12 or 15$
I lol'd 
Any function that has `async` in front of it will return a promise since `async/await` is just syntactic sugar for dealing with promises.
Well afaik there's still a big problem with piracy on their site so yeah somewhat shady.
You‚Äôre right about that, it doesn‚Äôt even test diffing, which I usually find the most interesting. :D I‚Äôve thought a lot about creating a better bench, however it‚Äôs a burden to write versions for different libraries and maintain it (even just accepting PRs). Let‚Äôs see if I do some day.. Been keeping hurry with our two children, hopefully it will change once the smaller grows a bit :)
The other thing is, I don‚Äôt know what to expect going into these jobs. I know it‚Äôs nothing like sitting at home working on a website or creating my own apps.
I think people are sick of the process of uploading and updates app store games. It's easier to make it Web based so no one is in control f the store. Phones are being able to support it a lot easier now.
And unity html export file sizes are too big
Just went through these - they're really good, and succinct. They cut out all the useless stuff that YouTube tutorials for example tend to leave in, which wastes your time.
No worries. I wasnt correcting you. I just wanted to make other people aware of the slight difference between assign and spread.
Cheers. Back end seems more what I'm in to. Maybe even full stack.
Yeah, I think he meant those 20 hours were above and beyond the 9.5 :) That's only a 13.5 hour day for OP :)
I don't really understand the popularity behind Vue. It seems most people that use Vue are primarily PHP developers.
Honestly, you probably should have learned HTML5 first. I teach a lot of newbs how to code and always start with HTML... It gives people a chance to learn about professional coding skills-- how to test, debug, use versioning-- in an environment that's much easier. It's a way to "ease in." Plus HTML is handy to know...
Yes, but JS is far from the majority on the desktop/mobile space, and likely never will be. OTOH, there is no JS alternative on the front end, and there will be before too long. It's a little different, IMO.
The beauty of Vue.js is that as long as your already comfortable with Vue.js, then all that you really need to get going is the [Vue.js Introduction](https://vuejs.org/v2/guide/index.html). Just as an example. About a year and a half ago, we where kicking off our first Laravel/Vue.js project. It took our PHP backend developer about an hour to go through the introduction at the time, and that was enough for him to be able to comfortably add to the front end code.
Awesome!
Javascript is a language used to add interactivity to web pages. CSS and HTML are pretty much prerequisites for Javascript. That isn't to say you need to be an expert at HTML/CSS before learning Javascript - but you should have an understanding of how HTML and CSS interact with each other. &gt;i start with basic HTML / CSS and then its just goes for couple of hours If you are spending hours situating your HTML/CSS, perhaps it is the types of projects you are giving yourself that are the problem. Experimenting and learning JS don't need complex layouts, and you don't need to jump right into designing whole page layouts. Start small with single elements, like buttons or divs - that way your you HTML/CSS really only contain a few elements.
Yeah, web development just inherently entails getting close and personal with a bunch of different technologies, no matter which side of that fence you want to be on. Plus, it's not like backend devs aren't expected to be at least vaguely familiar with HTML and other frontend tech. 
Have you heard of Waka Time? It records how long you code, I think it's pretty neat.
Always open Udemy pages in incognito to get the course for $10
Vaguely familiar at best. They really don't need to know it though. 
Yes. 
As a freelancer, I wouldn't suggest billing any unrelated research as part of your project work. At large companies, you're paid a salary. So there, it doesn't matter if it takes 40 9-to-5 hours or 60 hours with a lot of goofing around to handle your responsibilities. You get paid the same either way. Your managers just care if you're doing what you agreed at a reasonable pace and reporting your progress appropriately. In the corporate world, working above and beyond is rewarded with bonuses, promotions, etc. Now, as a junior, you should be learning a lot from your regular work. It's understandable and okay for a lot of work to involve research. As a senior engineer, I'm always researching whatever it is I'm doing. It's in part to get ideas/solutions, it's in part to sanity-check my own thinking. If I'm building a Button component, I'm going to look up a few other Button components. Just having experience doesn't mean I'm not going to look stuff up and do research. Things are complex and you'll never remember the hundred different things a simple button can do, especially when coding for evolving/new platforms. I'm sure an iOS button now is different from what it was like when I played around with the platform five years ago. As often as possible, you want to get things right the first time. If you spend half your time googling some days, it's not wrong. I'd suggest always spending at least 20% of your time on activities you're learning from. I'd expect junior developers to learn primarily from their projects, not additional side-projects or academics. Try to get involved in projects relevant to your interests and do the best job you can. The last 10% of polish it takes to ship something awesome is where you learn the gritty details of a platform. For example, you can learn some Vue by reading up but you won't get any experience debugging performance bottlenecks that way. Junior engineers need experience from actually debugging real apps they understand. Working on large applications is a different beast from learning new libraries. And finally, don't be too quick to jump from one technology to the next to build a profile. Depth is valuable. I'd rather be an expert at one thing than tinker with five other things. If you feel like you know something but aren't sure if you're an expert, take the time to keep working there. It's okay to play but avoid shiny object syndrome. Abandoning an area before you're an expert is a waste in the long term. Subject area experts can be *significantly* more valuable than generalists.
Just node doesn‚Äôt replace any of those things.
if MyData was an empty array, I wanted to add all available data, but if not just load the latest point. Someone else commented that I should be using `if (myData.length == 0)`
Use jsfiddle. whenever there is something I‚Äôm confused on I just create a fiddle and mess around until I understand what I‚Äôm doing. Or codepen. Best way to just start testing 
Use Bootstrap for your html+css.
...how can NodeJS be considered niche at this point?
For what purpose? Ultimately it is very difficult to make things really immutable but you probably don‚Äôt need to.
I meant niche as in NodeJS fills a particular niche in the back end. It has pros and cons that weigh against their options.
Oh, yeah, I was probably thinking of Wakatime. That tracks projects.
WASM isn't a JavaScript replacement. It is a Flash or Java Applet replacement. Essentially it is a standard bytecode in an isolated memory island without an API. If you are hoping WASM will allow you to magically write in any language and interact with web pages you will be sorely disappointed.
That's what it will be for at first. Once frameworks progress further and further, however, I believe it will be used more often to create generic CRUD applications from any language. Again, just a hypothesis.
I was not super skilled with css and html, I still look up how to do simple things in css all thing time. I started learning to use React which contains a hybrid of Javascript and html elements. It's mostly javascript though. You can also do some inline styling as well which is pretty neat sometimes for small things. Although most of the time you can install a library like bootstrap or material-ui that come with a bunch of styled components for you to use. The best part about it is that you can create reusable components very easily. There are tons of great resources on it too.
Currying is one of those things I always see in interview questions... but I avoid using it in my code for fear of another developer getting confused. I understand there are certain applications that are ideal for currying, but if you were to throw currying at a junior or even most mids they would be lost for a good hour at least.
Is your question, "is it possible to program in JavaScript as though it were an immutable language?" or "is it possible to enforce that no mutability is used within a project?" The answer to both is yes. If you're doing a lot of manipulation of maps, sets, or arrays, then immutable.js may provide performance improvements, but the library isn't strictly necessary. The performance gains from immutable come from structural sharing, so you can do things like adding a single item to an array without making a whole new array. A lot of functional JavaScript is heavy on using functions like map and filter, which already create new arrays, so if these are all you're using then immutablejs won't buy you anything. I use mutation extremely sparingly in JS, and I also very rarely use immutable. As an answer to the second question, Bodil Stokke made an eslint config that disallows any mutation: https://github.com/bodil/eslint-config-cleanjs The ESLint plugin will help keep you or anyone else on your project from accidentally slipping back into mutable programming, but this approach isn't necessarily perfect. The complexity that mutability adds to programs comes from data structures which are shared between different parts of your program being mutated; small utility functions which create a data structure, mutate it and then return it don't harm the composability of your program on a large scale. These functions can often be written more efficiently and easily by using mutation, so I follow the personal rule of allowing mutation locally in general-purpose utilities, but disallowing its use on shared data structures or in functions which contain business logic. Unfortunately there's no way to mechanically enforce these conditions.
Not sure if this is ironic or not but the idea that software development and programming languages shouldn't have a grounding in academic research makes me die a little inside
You've received a lot of answers that have said Node, which is good for serverside Javascript but (obviously) not so much for clientside JavaScript. Clientside JavaScript might be what you're already more familiar with. If so, I'd recommend Create React App in the sense that it has modern (Babel) JavaScript with hotreload so you can have half your screen running a browser, and half your screen running the browser with devtools open and then you can `console.log()` or whatever the results of your JS 
Currying may not be idiomatic to JS, but neither are any number of useful functional or object oriented techniques. And it's hardly complex enough that being non-idiomatic will cause a major maintenance burden. Currying all of your functions regardless of their usage would be bad for performance reasons, but there's some code that's extremely difficult to write and some techniques that are impossible to use without currying. Also, to the note about types, it's trivial to write the generic functions curry2, curry3, curry4, etc., and use whichever matches the arity of the function being curried.
Thanks, I hadn't thought about using a Blob. Unfortunately, it still didn't work. Same result as before, blank file with no name in the root of the drive. I did happen to find another way to do it, making a request rather than using the library. I'll update the post to include a link.
If you want to build some simple apps and scripts without worrying about the DOM, JavaScript might not be the best language to start with. I'd actually highly recommend Python as a simple but powerful language that will fill this niche (and is super friendly to learn!). If you are really excited about JavaScript, absolutely go for it but know that the DOM is an integral part of what makes JS useful, and there's really no way around it. There's some comments around Node, but honestly it's not the best choice because its purpose is to provide a way to code application back ends in JS. Yes, you can use it for scripts and local apps, but it is NOT the right tool for that particular job - again, Python is a much better fit (but is certainly not the only option). That being said, understand that interacting with vanilla HTML and CSS is actually not that common when you get into more advanced JS. The real power of the JS ecosystem is the abundance of frameworks which enable you to do most, if not all of that work in JavaScript. When you get comfortable with the vanilla language, 999/1000 times you're going to be using one of these frameworks for styling and layout. React is the industry standard, but Angular (not recommended due to its use of Typescript), Vue, and Ember are all fairly common in smaller projects and you'll eventually want to move into expertise in one or many of these frameworks if you stick to JS. HTML and CSS teach you about how the browser works and are essential to building a working understanding of JavaScript. But, most of the value is in the learning experience they provide. I'm happy to point you in the right direction if you'd like, but good luck on your journey! There's nothing quite like JS in terms of its ubiquity and its beautiful (imo) expressiveness, but it can be daunting at first.
Its not an academic paper about promises, its about, or claims to be about, a "model" about "reasoning" about them. This further confirms my long held believe that promises are just too hard to reason about, or too easy to screw up. Imagine a paper called "A Model for Reasoning About Prototypal Inheritance". If such a paper filled more than one page people would run screaming from javascript.
You can get in-browser stack traces without CRA. It‚Äôs a webpack-dev-server setting (overlay: true). That said, I think OP should learn HTML first before getting into React and Webpack :)
I don't think the author has tried currying in a functional language. You don't normally implement curry by hand via `.bind` in functional languages. There are higher-level utilities called `[curry](https://wiki.haskell.org/Currying)` or `[partial](https://clojuredocs.org/clojure.core/partial)`. There are also utilities called `uncurry` to unwrap it. Also even if there is default argument values, currying doesn't change the invocation of the function. If you curry a function w/no arguments, it doesn't magically call itself immediately. So if you curry a function w/2 arguments that has default value, you still have to invoke the curried version twice, just with empty arguments. 
uhm http://www.bracha.org/oopsla90.pdf Inheritance, including prototypical inheritance, took years of academic fighting to get worked out. Also, JavaScript itself is extremely complex, and models of it run from [twenty-five pages](http://cs.brown.edu/~sk/Publications/Papers/Published/gsk-essence-javascript/paper.pdf) to [thousands of lines of formal semantics](https://github.com/kframework/javascript-semantics). It's important to note that these models aren't so much to help humans reason about programs, as they are to enable machine reasoning about JavaScript via static analysis. From this perspective, promises are much simpler than callbacks, which are a watered-down form of continuation-passing style. (A thing which is the subject of a number of entire textbooks.) I agree that there are problems with promises, and I personally prefer tasks/futures. That doesn't mean that they don't have advantages over callbacks, though, and the fact that there's academic research on them isn't proof that they shouldn't be used.
The full prices are nuts but the Angular course I got (same guy, Max) is pretty great. Totally worth the sale price. They also have apps and viewers for everything. So scam is definitely the wrong term to use.
What is and is not idiomatic in Javascript differs from team to team and week to week. It is the English of programming languages. Want to write pure functional code with currying? There's a way to do it, and there's probably a library/framework that makes it simple, pretty, and mandatory. Want to write statically-typed Object-Oriented code with a style and workflow that makes it possible to forget you're not just writing Java? That exists too. Hate both and want to write procedural code? No problem. Dislike any math that doesn't run in the form of matrix operations on a GPU? It's not idiomatic in any community yet, but I wouldn't be surprised if Arrayfire catches on as JS developers start getting spooked by WebASM. It's made up of the scraps and popular features of every other language, without any streamlining. Arguing about what is and isn't idiomatic is roughly as meaningful as arguing over the colloquial use of "literally."
I‚Äôm being very specific in what ways I think JS clashes with currying. Feel free to criticize those.
f this response...has nothing to do with the inital question...shoulda??? ridicoulous, how are they suppoesd to go back in time?!
I mean, he's not wrong. But I still love currying, and I'm still going to keep doing it. I will admit the style definitely makes more sense in a language like F# or haskell where it's the default, instead of trying to shoehorn it in, though.
&gt; I don't think the author has tried currying in a functional language. I‚Äôve used Haskell where every function is automatically curried. Helper functions for currying are great and they help with using it in JS. I do briefly mention them, but they don‚Äôt change the points I‚Äôm making. &gt; So if you curry a function w/2 arguments that with default values, you still have to invoke the curried version twice, just with empty arguments. I‚Äôm referring to how omitting a parameter means something different for currying than for default parameters: const curried = x =&gt; y =&gt; x + y; const uncurried = (x=0, y=0) =&gt; x + y; curried(3); // &lt;Function&gt; uncurried(3); // 3 As a consequence, you can transparently add parameters in plain JavaScript with default values. But you can‚Äôt with curried functions.
That link is a 9 pages of light reading on inheritance in multiple languages, its not even close to the paper on promises, which is just about javascript promises, and gives me a headache. We agree that there are issues with promises. My vote is for javascript fibers ( example implementation is node-fibers ). I've worked with eventmachine, which is very similar to node-fibers, and that is such a light lift you barely even have to think about it, that blows promises and async/await away, its a shame they didn't go that way, I wonder if there's a good reason for it.
Repl.it/javascript Ez as fk to use
Ah, cool, I hadn‚Äôt even thought about typing the helper functions where indeed you can‚Äôt be generic w.r.t. arity. I meant typing the results of such helper functions: function curry2(func) { return function (...args) { if (args.length &lt; 2) { return func.bind(this, ...args); } return func.apply(this, args); }; } I don‚Äôt see how.
I found I understood state and state management much better after reading the Vuex doc. https://vuex.vuejs.org/en/intro.html Hope it helps.
let jsonArr = json.split(''); let newKey; let newVal; if(jsonArr[i] === `[` &amp;&amp; result === undefined){ result = []; i++; } if(jsonArr[i] === `{` &amp;&amp; result === undefined){ result = {}; i++; } //ARRAYS if(Array.isArray(result)){ if(jsonArr[i] === `"`){ if(jsonArr[i + 1] === '\\'){ result.push('\\""a"'); i++; return parseJSON(json, result, i); } result.push(jsonArr.slice(i + 1, jsonArr.indexOf(`"`, i + 1)).join('')); i = jsonArr.indexOf(`"`, i + 1) + 1; return parseJSON(json, result, i); }else if(jsonArr[i] === `,` || jsonArr[i] === ' ') { i++; return parseJSON(json, result, i); }else if(jsonArr.slice(i, i + 4).join('') === 'null'){ result.push(null); i += 5; return parseJSON(json, result, i); }else if(jsonArr.slice(i, i + 5).join('') === 'false'){ result.push(false); i += 6; return parseJSON(json, result, i); } else if (jsonArr.slice(i, i + 4).join('') === 'true'){ result.push(true); i += 5; return parseJSON(json, result, i); }else if(Number(jsonArr.slice(i, jsonArr.indexOf(',', i + 1)).join('')) || jsonArr[i] === '0'){ result.push(Number(jsonArr.slice(i, jsonArr.indexOf(',', i + 1)).join(''))); i = jsonArr.indexOf(',', i + 1); return parseJSON(json, result, i); }else if(jsonArr[i] === `{`){ if (jsonArr[i + 2] === 'd' &amp;&amp; jsonArr[i + 3] === 'o' &amp;&amp; jsonArr[i + 4] === 'c' &amp;&amp; jsonArr[i + 5] === 'u'){ result.push(parseJSON(jsonArr.slice(i, jsonArr.indexOf(`}`, i) + 3).join(''))); i = JSON.stringify(result).length; return parseJSON(json, result, i); }else{ result.push(parseJSON(jsonArr.slice(i, jsonArr.indexOf(`}`, i) + 1).join(''))); i = JSON.stringify(result).length + 1; return parseJSON(json, result, i); } }else if(jsonArr[i] === `[`){ result.push(parseJSON(jsonArr.slice(i, jsonArr.length - 1).join(''))); } else if(jsonArr[i] === `]`){ return result; } //OBJECTS }else{ if(jsonArr[i] === `"`){ newKey = jsonArr.slice(i + 1, jsonArr.indexOf(`"`, i + 1)).join(''); i = jsonArr.indexOf(`"`, i + 1) + 3; if(jsonArr[i - 1] === ' ' || jsonArr[i - 1] === `"`){ if (jsonArr[i - 1] === `"`){ i--; } if (jsonArr[i] === `"`){ newVal = jsonArr.slice(i + 1, jsonArr.indexOf(`"`, i + 1)).join(''); i = jsonArr.indexOf(`"`, i + 1); } else if (jsonArr.slice(i, i + 4).join('') === 'true' || jsonArr.slice(i - 1, i + 3).join('') === 'true'){ newVal = true; i += 5; }else if(jsonArr.slice(i, i + 5).join('') === 'false'){ newVal = false; i += 6; }else if(jsonArr.slice(i, i + 4).join('') === 'null'){ newVal = null; i += 5; } } if (jsonArr[i - 1] === '[') { newVal = parseJSON(jsonArr.slice(i - 1, jsonArr.length - 1).join('')); } if (jsonArr[i - 1] === '{' || jsonArr[i] === '{'){ newVal = parseJSON(jsonArr.slice(i - 1, jsonArr.length - 1).join('')); } if (Number(jsonArr[i - 1])) { newVal = Number(jsonArr[i - 1]); } if (jsonArr.slice(i, i + 4).join('') === 'true' || jsonArr.slice(i - 1, i + 3).join('') === 'true') { newVal = true; i += 3; } result[newKey] = newVal; if(typeof newVal === 'object'){ i = JSON.stringify(result).length - 1; } if(jsonArr[i + 1] === `}`){ return result; } else if(jsonArr[i + 1] === `,`){ i++; return parseJSON(json, result, i); }else if(jsonArr[i] === `:` || jsonArr[i] === `,` || jsonArr[i] === ' '){ i++; return parseJSON(json, result, i); }else{ return parseJSON(json, result, i); } }else if(jsonArr[i] === `:` || jsonArr[i] === `,` || jsonArr[i] === ' '){ i++; return parseJSON(json, result, i); } else if(jsonArr[i] === `}`){ return result; } } return result; 
Made an interactive data visualization app of our U.S. Congress - http://whogovernsus.org
&gt; const curried = x =&gt; y =&gt; x + y; &gt; const uncurried = (x=0, y=0) =&gt; x + y; &gt; &gt; curried(3); // &lt;Function&gt; &gt; uncurried(3); // 3 const curried = (x = 0) =&gt; (y = 0) =&gt; x + y; curried(3)(); // 3 //or const uncurry = fn =&gt; (a, b) =&gt; fn(a)(b); const defaultable = uncurry(curried); defaultable(3); //3
http://daringfireball.net/projects/markdown/syntax
Yes, but you lose the main purpose of parameter default values ‚Äì defining a function that supports different arities: `curried(3)()` is still basically an invocation of a function with arity 2.
Is this supposed to behave the same as JSON.parse?
arity 1 + arity 0 !== arity 2
I also don't see why any of this matters. const es6 = (x = 0) =&gt; ++x; //is just syntax sugar for const es5 = x =&gt; { x = x || 0; return ++x; }; console.log(es6());// 1 console.log(es5());// 1
Does this do the same thing as JSON.parse?
I'd recommend not "learning for the job." if you're already a dev, use your liesure/down time for learning new things, but don't do it at the detriment of your current gig. If you're already a dev, picking up a new language or framework should be fairly trivial... Look at a tutorial, try/fail until you try/succeed and then take your skills to a better paying/more scure/more exciting/closer to home job. If you have 9.5 hours at work, and you can leverage x number of hours to self-improvement... You're golden.
OK, I take back my speculation that you didn't try a functional language. My apologies. In order to use that `curried` function in your example, you would need to call `curried(3)()`. Currying is internally consistent about the input/output types of function. It converts uncurried type is `(T1, T2) =&gt; TR` to `(T1) =&gt; (T2) =&gt; T3`. So if an argument happens to be optional, it is kept. `(number?, number?) =&gt; number` would become `(number?) =&gt; (number?) =&gt; number` not `(number?) =&gt; number` 
I thought JSON parse was recursive?
I'd just pick a book and learn from there. Personally, I found that Secrets of the Javascript Ninja by John Resig (creator of jQuery) was the best JavaScript book out there to get started with. It has some flaws which I can get into for anyone interested, but I think the structure of the topics and explanations was by far the easiest to understand. I first picked up Javascript: The Good Parts, but it moved too fast for me and seemed clinical, if you will. While the examples are basic, they tie into one-another. So many books seem to just randomly choose examples with no relation to the previous example, even if it's an entirely new concept. That's what I liked about John's book. I'm only one person and it's just my preferred style of learning, so take it with a grain of salt. 
Currying doesn't change arity. Also with the currying-variant you are proposing. You lose the ability to supply non-default value for 2nd argument (or any argument there after). const fn = (a, b = 2, c = 3) =&gt; a + b + c; const curried = rauschma_curry(fn); curried(1); // 6 curried(1)(-2); // error - 6 is not a function curried(1)(-2)(-3); // error - 6 is not a function 
Hmm. I could give it a shot. Using typescript and redux-loop also really helps bridge the gap and let's you leverage some of the same techniques that Elm helps with (exhaustive pattern matching, data modelling)
Let me put it another way. Assume I want to transparently add a third parameter to a binary function. With normal functions, I can: const add = (x, y, z=0) =&gt; x + y + z; add(3, 5); // 8, same as before With curried functions, I can‚Äôt: const add = x =&gt; y =&gt; (z=0) =&gt; x + y + z; add(3)(5); // now: a function; before: 8 You can, of course, trigger the default value, but that‚Äôs not the same: add(3)(5)(); // 8 In other words: in my opinion, parameter default values are about the ability to omit parameters, but with `()`, you aren‚Äôt really omitting the parameter `z`.
See other comment: https://www.reddit.com/r/javascript/comments/7c4iry/currying_is_not_idiomatic_in_javascript/dpno2fg/
Never said you didn't. I don't think your argument is poorly reasoned, insufficiently supported or badly written. I'm not criticizing your specific points because I don't disagree with either of them. You raise some pretty good points, and I like that you actually brought up something novel rather than beating the dead horse that is "it's confusing for most devs and will introduce bugs into your codebase if you're the only one doing it." I understand that you've apparently interpreted criticism not targeting the specific arguments as just criticizing the title without reading the article, but my criticism is for the central premise that the argument as a whole depends upon. That premise being the idea that 'not idiomatic' and 'Javascript' are in any way compatible concepts in light of the number of distinct and barely-compatible-at-best ecosystems there are in Javscript. A lot of styles of programming all-but require a library/framework which re-implements much of the standard library in order to make sense. I'd hold that *every* style of coding requires being consistent within your own code, and occasionally even consistency with the implementations used in the ecosystem you expect whatever you're writing to be used with, unless you want to spend a few hours beating your head against a wall at some point. Currying definitely doesn't belong in every project. It probably doesn't belong in most. Neither does functional programming. Neither do Class declarations. If you're working with a framework that hasn't had a major update since 2013, occasionally you'll find arrow functions don't belong there. Everything you can do in JS has an ecosystem of libraries and functions where it works seamlessly, ecosystems where it works with a bit of extra effort, and ecosystems where it is not worth the effort. This is just opinion, though. More importantly, since I'm not inclined to go through my Big List of Incompatibilities That Have Eaten a Saturday line by line, you are more than welcome to treat this as unsubstantiated - and therefore meaningless - criticism. I've also only just recognized that this might be a nonstandard perspective. I'm just more used to Javascript refusing to play nice with most things it isn't specifically designed to be compatible with out of the box than the alternative. As such, the whole idea of anything being 'idiomatic' or 'non-idiomatic' in Javascript as a whole rather than 'Idiomatic React+Redux' or 'Idiomatic JQuery' doesn't really parse as a meaningful concept.
Got it! I‚Äôll admit that the headline is a bit flame-baity. That‚Äôs why I tried to be specific as quickly as possible.
I've got no problems with click-bait titles, honestly. I understand why people use them and they're universal enough that they aren't an issue. 
What is Vue best used for?
That makes no sense, or seems arbitrary. If anything the extra () gives you more control, making the code more purposeful. Also, side note on the OP, there is no single idiomatic javascript. It depends on if you're a js native developer, coming from a c syntax oop background like java and c, or a hipster with python or ruby or functional programming influence. Each of those styles have their own idiomaticity. TL;DR - If you have a good use case for partial application, you probably don't need that same function to be so flexible arity vs defaults is a major stylistic issue. Final note: If you have more than 2 arguments, you should probably be passing an object and deconstructing it anyway. If you only have two arguments and absolutely have to curry and support the one argument use case, do this: const unary = x =&gt; 2x; const curried = x =&gt; y =&gt; unary(x) - y; unary(2); //4 curried(2); // y =&gt; unary(2) - y; Final final note: chainability and monads, or making everything unary and composable, solves this problem too. 
JS templating. 
[removed]
I mean, DOM manipulation is kind of an important part of JavaScript, is it not?
SPAs or incrementally adding a client-side view library. It's functionally equivalent to Angular, React or Polymer but has more in common with the last too. I've been using since this summer and I love it. A real pleasure to use in my experience (which is limited, I jumped straight from JQuery to Vue SPA). 
It is very poorly written :(
Assuming the syntax you wish for works, you would never be able to call `add(3)(5)(1)` because `add(3)(5)` would return the result (a non-function). Did some more digging, the only major FP language that does what you described is Ocaml, but their optional argument system is fairly special, they are all "labelled", while required arguments can be unlabeled. * Haskell - doesn't natively support default argument, you can use specific 3rd-party packages with their own currying behavior * Scala - consistent with what I have described, you have to invoke it X number of times where X is the arity. [ref](https://stackoverflow.com/questions/5074421/default-parameters-with-currying) * Clojure - doesn't have auto-currying, when you call `partial` it behaves like what I described * F# - optional parameter and currying are mutually exclusive [ref](https://stackoverflow.com/questions/34550526/why-cannot-f-function-with-curried-arguments-have-optional-parameter/34550907) * Ocaml - supports what you want, but has explicit behavior based on order of optional and non-optional arguments [ref](https://stackoverflow.com/questions/9647307/how-to-curry-a-function-w-r-t-its-optional-arguments-in-ocaml) 
Vue or the article itself?
The article itself.
What price are they showing to you on that link? If you check back later when the price is apparently off sale (next day or so), the price will be different. But in reality it is not different as you will see if you clear cookies - they are just tricking you. I wouldn't support these fuckers when there are others like Lynda, Laracasts, Treehouse etc.
Then you are a good person who deserves nice things. Where ever I've seen it used it always felt like they were doing the cool thing instead of the right thing. The code didn't function better and it was one more conceptually discreet pattern to mentally process. I wouldn't say don't ever use it, but don't use it for the sake of using it.
Take a look at crockford's implementation and the json spec: * https://github.com/douglascrockford/JSON-js * https://tools.ietf.org/html/rfc7159 If you want learn more about parsing/lexing take a look at these guides: * https://ruslanspivak.com/lsbasi-part1/ * http://www.craftinginterpreters.com You also might want to google these phrases: * recursive descent parser * predictive parser * Lexing * scannerless 
JavaScript have bad parts that you should avoid like "with" and "eval". Now JavaScript is getting a lot of new parts, but I am not sure if we really need all these new parts and if they are going to he used by everyone.
I think that it's more accurate to say that overloaded function calls and default arguments do not mix well with programming techniques inherited from lambda calculus. Both overloaded functions and default arguments are not consistent with a model of programming based on mathematical correctness. Currying is idiomatic of functional programming. "Simple currying", as the article calls it, is idiomatic of strictly typed functional languages. Overloaded function calls and default arguments are idiomatic of dynamically typed imperative languages. JavaScript borrows from both idioms, among others. It's inevitable that using both idioms in the same program produces these rough edges. What seems the most idiomatic here is the rough edge. Idiomatic JavaScript, as far as I can tell, is the mixing of different paradigms. The fact that this doesn't always work well, as the article describes, does not make it less idiomatic. 
Currying clashes with variadic calls and/or default argument values. Whether or not that makes it _idiomatic_ is probably too subjective.
It‚Äôs not really functionally equivalent to angular... but the others yea.
Just opened link quickly and saw highlight: Only use jQuery when you need it for querying. After that it was enough, I just had to close it. 
1. there is definitely not enough good JS/web programmers, so don't worry about it, you can more-less easily get a good-paid job or work as a freelancer. Of course, in best case you should know not only JS itself but lot of things and techs around. 2. Some of my collegues moved to js (just because the company where I'm working currently has mostly JS code base). As for myself, I'm trying to learn other languages and fields, because for 10+ years I was working almost only with web/js and now I feel some limitations because of it. The most concern about JS ‚Äì it's relatively hard to maintain/test/etc, because it's dynamic and weakly typed. JS is for sure not a "toy" language, it's very powerful both for browser code and as a server-side language. 3. Developer environment is highly depends on personal preferences and specific project which you're working on. I'm prefer to write code in Sublime Text with some plugins, while preferred environment on my current place is highly-customized vim editor. Some of developers prefer to use IDEs such as WebStorm and so on. In general, in addition to your editor/IDE you should know how to work with console tools and linux environment, as well as know how to check your code in all major browsers (e.g., using virtual machines for different OS, or something like that). And, of course, version control systems. 4. I don't have much experience with writing native apps in JS so can't say about that.
That was a poor choice for a highlight, but if you'd read the paragraph that follows it, you'd have seen that it's something they specifically decided _not_ to do because it would've been a bad idea. 
1) There's definitively a problem with salaries. I don't think it's about there being too many developers, though. There are, in my experience, too many inexperienced devs, sometimes poorly qualified and sometimes not. This has both made it difficult to find good, experienced devs, and for those to find salaries similar to those in other areas. This last part _is_ getting better lately, but I don't think we're there yet. 2) There is always movement. Both ways. As for the hate or the struggle, that really depends on each case. There are valid reasons for most things. The problem arises when you hate/struggle/love for the wrong reasons. Notice I included love in that. 3) I'm willing to answer this, but won't. I've noticed people see this as some sort of recommendation and I wouldn't particularly recommend what I use in general. E.g. I use Vim for most of my editing needs, but I almost never recommend it to anyone. One thing I can tell you is I also use other editors and even Webstorm and Intelli J. And even C9 sometimes. The thing is that I use those under some circumstances and that's what you should focus on: using tools when they fit your needs appropriately. 4) Sorry.
I'm completely new to Javascript and I made a little [website where you can check if all the keys on your keyboard work properly](http://keyboardchecker.com) Wondered if some of the experienced people here could tell me if my javascript makes sense (I mean, it works, but maybe there's a way more efficient way to do this!)
JS has been the most in-demand language with some of the biggest salaries for the past several years. Coding schools have focused on that, producing tons of recent grads. Recent library and tools also make JS development significantly easier. These 2 aspects will cause salaries to plateau or drop IMO.
I'm not sure what you're trying to do here, but a cool aspect of JSON.parse is it takes a second argument. The second argument is a hydration function that allows you inspect each parsed value and return a value to be inserted into the tree. This allows you to completely customize parse behavior without needing to write any of your own string parsing code. I'd highly recommend using that method if you need to customize JSON parse behavior instead of implementing your own parser.
You can learn Vue or React and be very well equipped going into the job market, they're massively in demand as a type of tech at least in London.