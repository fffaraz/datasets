There are some good replies here about how you might use some kind of Map data structure to essentially implement a join operation on these two sets of data, but based on the nature of this being a fairly novice question, I can't help but think that you might already be going the wrong direction before you even got to this spot. Normally you do this kind of operation on the database level which will be way more efficient, and then there is no work to do in the application code at all to get the desired result. The thing that you should almost never do is put data that needs some kind of relational operation or joining into a document store like mongodb because of this exact problem. If you control this data, are you sure that you don't mean to have this in a relational database?
Brief thought: so many people here are recommending third-party libraries when the task can be performed with a single line of pure JS.
I could be wrong, but I believe most of Google's flagship/consumer products don't use frameworks. So that's search, Gmail, YouTube, etc. A few of their backend platforms famously use Angular, but I believe the above are hand optimized. Good luck analyzing the source, though. =/
Deploy to web, desktop, and mobile using web components which seem to be a solid future for web development.
Hi /u/jade878cheung, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/ILJC_07, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/artgraphics, this post was removed. If you'd like to post a link, then please use the "Submit a new link" option. Thank!
Ain't nobody got time for that. I'm rewriting our app for the 3rd time in 2.5 years (massive app, and rewrite has nothing to do with my side of things). All code goes through me and I still write 90% of it. Tests would have saved me maybe once or twice and would have meant losing a shit ton of functionality or months of my time. And they would have been thrown away. That being said, I think tests are important for certain things. Have something that calculates dosages or does conversions for medicine? You bet your ass I have tests there. I deploy code multiple times per day and I can't remember the last time the site went down. The other app the dev writes tests for everything. He breaks shit all the time but then writes new tests each time. Then 6 months into the project he wants to move stuff around and the thought of making all of his tests happy scares him. 
 // object array is a map the values to new object var z = a.MessageCount.map(x=&gt;{ 'day': x.day, 'count': x.count, 'visits': a.LinkCount.visits })
Maybe it'd just me but I didn't find this to be a good read. Better for reference, but then I'd just use MDN's online documentation. 
Mongo Express React Node, as opposed to MEAN with Angular 
Just use the globals. You may also override the require logic to make it shorter (ex require @app/file instead of ../../../file You may also group common requires into a file
Man, I wish I have seen this repo a couple of days ago! Thanks for sharing. I had to create a simple project, without even a good looking design and amount of obstacles I've gone through to make a running version was amazing o_0
Thanks. Does that mean memory is not an issue here?
Look at the aggregation pipeline of MongoDB. You can do a $lookup, which will allow you to effectively combine collections.
I went down the rabbit hole but couldn't get it to work. Every time I try and supply a `ReadableStream` to `fetch` (or `Request`) via the `body` option it just `toString`s it to the text "[object Object]" (in Chrome), or complains about an invalid argument (in Edge). Firefox still has streams behind a flag so I didn't bother. Looking at the [compatibility table here](https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#Browser_compatibility), it lists "Send `ReadableStream` in request body" but doesn't show any browsers supporting it yet. I'm wondering if you were just reading the response stream / talking about download progress?
What do you mean exactly by ‚ÄúEcommerce part‚Äù? If it‚Äôs processing payments, there are a bunch of APIs out there. If you want to accept credits cards look into stripe, braintree, square, authorize.net, etc. PayPal is really easy to integrate too. On a personal note, if you‚Äôre trying to build a real e-commerce website (store) and make a business out of it, I would suggest to look away from custom built things like you‚Äôre describing. There is plenty of features that you‚Äôll need down the line, like inventory control, reports, coupon codes, etc. There are open source systems out there that do the job perfectly, all you have to do it set it up. This may not sound as fancy as ‚ÄúMERN‚Äù, but at least it‚Äôs realistic.
Terrific, a huge help. Thanks so much for the suggestions!
Hwy man thanks(: For your question, I believe its a matter of choice and there is no problem to add proxy to your server! Ill have to digg into it though to see whats the best practice and maybe if it is, to add it to the lib. 
this was actually why I build it. Any project I start I had to make all those features again and again it was a nightmare , So I decided no more! üòä
can you screenshot code of reportGeo.js on line 330 - 370?
Yeah this is a bit sad
Ty
Because the event loop also checks for execution. Javascript in the browser is single threaded and share the stack
I edited my post please have a look again.
I get this warning *every* time I use gulp. Despite it being an issue that was closed 2 years ago. 
That is spelled SERN ;)
[removed]
https://www.reddit.com/r/ProgrammerHumor/comments/621qrt/javascript_the_good_parts/
It will watch any file. I know I have .sql and .json in some of my supervisor cmds
Max heap and pop the root n times
Sorry, I'm unable to find your problem since I can't get dt.editor. [https://jsfiddle.net/hj0ks56e/3/](https://jsfiddle.net/hj0ks56e/3/) maybe if you can replicate it there, I can help you find your problem.
Nope. Someone in dev tools was like "this would be cool" and then it went well. I do not think there was almost any project in MS using React at the time. (Source: was a frontend developer at MS at the time)
I love you
You need to be null checking, or at the least use a try/catch. Also, have you debugged it stepping through like by line?
You might want to use posgres if you‚Äôre going to have user accounts. MongoDB is non relational and Postgres is relational data
+1 For Dominic Tarr's modules as good reading. Nothing flashy syntax-wise but good, solid, really fast code. 
yes I did debugging too . but did not get exact issue in code where it is acur .
Broken link...
A fairly good news for javascript. Sadly, i'm using chrome.
You know you can use more than one browser on one single computer. It‚Äòs like a magic feature. 
Thanks for sharing your open source project, but it looks like you haven't specified a license. &gt; When you make a creative work (which includes code), the work is under exclusive copyright by default. Unless you include a license that specifies otherwise, nobody else can use, copy, distribute, or modify your work without being at risk of take-downs, shake-downs, or litigation. Once the work has other contributors (each a copyright holder), ‚Äúnobody‚Äù starts including you. [choosealicense.com](https://choosealicense.com/) is a great resource to learn about open source software licensing. 
sorry to be that guy but go here - /r/learnjavascript/
But I do mind additional dependencies. That‚Äôs what I said in the article. 1. Listeners on pause should be removed because streamReader is paused and doesn‚Äôt want to get ‚Äòdata‚Äô events. Listeners on stop should be cancelled, because streamReader is stopped and shouldn‚Äôt listen to anything after it‚Äôs stopped. 2. Because the listeners are added using `.once`. 3. My bad, it should be `readStream` instead of `func`. Thanks for noticing, I‚Äôll fix that. This code is not a part of a bigger project, it was written for the article and is missing only handlers.
python
Tensorflow JS https://js.tensorflow.org/tutorials/
Oeh sounds interesting 
50% of the internet is currently JavaScript tutorials...
I have resolved it by own. Thanks.
enjoy! üòä
[This might help](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else) :P
The book is from 2011. JavaScript has changed a lot since then. The book misses all the ES6 stuff and is clearly outdated. I'd rather spend my time on a more recent book like [Eloquent JS](http://eloquentjavascript.net/).
Hey I'm in Mobile and looked quickly but I couldn't find the webpack config. Did you bootstrap the react part with create react app or is it custom?
Using just one browser for dev stuff because "it's better" is like using only the right hand to type because "it's better". The web was built on diversity. It only makes sense that our tools are also.
Good point, I'm waiting for the latest release of eloquent JS coming out at the end of October.
I used create react app 
Doesn‚Äôt create-react-app hide the webpack config by default?
it's asking you to add a line of code like: `assertEqual(`every(`[1,2,3], function(x){return x*2}), [2,4,6], "it should double every memeber");` possibly others too, then make it work
It's not like that can't change.
A cool smart. I made a simmilar boilerplate a year ago which I never thought to share on here and I didn't use create react app but I should have.
Unfortunately that figure is more like 85% for IE11 amongst out clients. With a smattering of IE8 still sometimes seen.
The free version of the 3rd edition is already finished. The only thing that's missing is a single bonus chapter for the NoStarch release.
Use indexes to retrieve specific character in the string. e.g. `str[0]` for the first character. Use a loop to retrieve a number of characters from a string. Use the `+` operator to join characters or strings into one string. Be it append or insert into existing string, or create a new string.
That's amazing! Direct link to the gist with the details: https://gist.github.com/jasonLaster/1e220992c294a571dd9b59abd084ccf2
yeah create react app is absolutely amazing. My lib is just wrap it with the missing parts to be really dope!
Just went down this path myself last week. Definitely got frustrated more than a few times by dropping in some examples to play with and spending more time fixing up their removed methods than playing with the actual Observable parts I wanted to learn. Best resource is still learnrxjs.io , but the hard part is that ReactiveX is just _so big_ it's daunting to looking through everything. Lodash may be huge, but you start out understanding the basic concepts of most things and just looking for good implementations. Rxjs, on the other hand, starts with a big learning curve. You can find lots of usage for the various methods, but figuring out which method to use is very difficult. For me, I love flux, I like the redux-approach of reducers and one big state object, but I wasn't comfortable with the whole ecosystem (and middleware) I saw swirling about redux. I knew in theory that Observables, with the ReactiveX operators, was probably enough to manage my actions and reduce them, but no idea which to use. Eventually figured out I could use a `BehaviorSubject` as my action dispatcher, observe that with the `scan` operator to run it through my reducer function, and use `combineLatest` for merging multiple streams together. Code splitting was making the whole `combineReducer`s thing very clunky (replacing a reducer is incredibly mutable and flies in the face of the whole reason to use redux), so merging these streams was a huge win. I should probably blog about the whole thing. Here's a basic summary: const action$ = new BehaviorSubject({}); const reducer = (state = { count: 2 }, action) =&gt; { switch (action.type) { case 'ADD': return { ...state, count: state.count + 1 }; default: return state; } }; // Undefined so the initial state gets picked up. It uses // the old Array#reduce behaviour for initializing the // accumulator const store$ = action$::scan(reducer, undefined); The [accumulating an object](https://www.learnrxjs.io/operators/transformation/scan.html) section is pretty useful too. For fluxing it up, just follow redux patterns to update the state. 
Good bot!
Make the recursive function accept an array and an index. What the function should do is to "walk" the array to the end by calling itself using the given index increased by one. When the end of the array is reached, it should return the last array element. After the recursive call returns, compare the returned value with the array element at the current index (which should be one less), then return the one which is larger.
Chrome dev tools are objectively better though.
There‚Äôs room for a lot of improvement, tbh, but RxMarbles is imho the most useful for getting your head wrapped around it regardless of version. http://rxmarbles.com/
You have a problem with reading comprehension. I never implied that. All I claimed was that currying is the term **specifically** for the transformation from nary {or ntuple) form to nth order form. Which is exactly what the wiki entry claims. Now, consequently, in order to have a transformation, you first need to have the nary form to transform. 
Me too
You frequently mentioned a queue, but you didn't mention what exactly is in the queue. So, I can't know what solution to give. i.e. the data, or the function itself? In most async tasks, whether a queue is involved or not, there's always a code which either notifies the task completion (signal based synchronization; JavaScript built-in or not), or periodically check the task completion status (polling based synchronization).
They do some things better but they have poor support for css grid, variable fonts and a few other things. If you need to work with CSS grid I think sticking to Chrome dev tools just because you are used to it is plain silly.
It's not like you people cannot understand a joke, rofl.
Let me guess - government or finance?
Nice
but why listeners are connecting directly to the readStream? Wouldn't it better to create a service, which will gather low level readStream data and filter them (basing on some simple variable `pause`) and emit events to second EventEmitter? &gt; This code is not a part of a bigger project, it was written for the &gt; article and is missing only handlers IMO it misses context. What is readStream? Is it streams data from data source to an application? If so, why does it gather also control events from listeners like `pause`? And from what `pause` events come from? From player or from listeners? I just feel that I don't understand wholly the problem because example is put out of the context. &gt; we have an object that can read some data from a stream and this object uses an event emitter to notify everyone i.e. one stream is used both to read data from input and to write data to output? It just feels weird, unexpected (maybe even wrong. But it is more like "I'm not sure if I fully understand this example"). &gt; But I do mind additional dependencies. Is it Node or frontend? If you do this on frontend you still have to bundle EventEmitters that aren't available in browsers. 
While not updating their browser, yeah. The irony of this is quite good. 
I am so happy that finally the languages I use today are catching up with the innovations of Smalltalk in the 1980s, and Visual Studio in the 1990s. It sounds bad, but its honestly true, I really missed all these ease-of-use features.
No, Firefox is missing some more important things like WebSocket inspection, DOM breakpoints, conditional breakpoints, event breakpoints and many more that I can't remember. I genuinely tried to switch over to FF for development a month ago as I prefer it as a browser and a company in general, but all these things that are still missing kept me from doing so.
Thanks for reading this seemingly incoherent post of mine, i will try to specifiy: The function itself works just fine, returning an array of links. Those returned links need to be passed into this funtion as well (each link needs to be passed into the function). Every returned array needs to be aggregated, the aggregated flat array (consisting of links) this is the result that is needed. But my problem isnt about the function (`parseLink`) in itself, more about the processing. As in this works well in a recursive sequential processing but takes about 20 min to finish which is simply to long. The following excerpt is an (simplified) extraction of this "sequential processing": temp_arr = await parseLink('something') links = [] while (temp_arr.length &gt; 0) { for (var i = temp_arr.length - 1; i &gt;= 0; i--) { to_array = parseLink(temp_arr[i]) links = links.concat(to_array) temp_arr = temp_arr.concat(to_array) temp_arr.splice(i, 1) } } The result of this would be an array (`links`) which would have all the the parsed links. So how would i make this run paralell but with a control over how much concurrent `parseLink` are called?
Conditional breakpoint have been in FF for quite some time.
There may be another and there may be a better approach to writing asynchronous code on callbacks than this. But‚Ä¶ what‚Äôs the point? Remember, the reason for using async/await was to get a flow described by the code? I really don‚Äôt see, how callbacks can do that.
Nah just give Google all your data.
Yeah. Regulated industries generally, banking (investment &amp; savings) mainly.
This is pretty cool! How long did it take you to build?
The 3 other function don't need to check the parameter unless they are directly exposed in your "public" interface. If those 3 functions are privately used somewhere else, this somewhere else has an entry point in your "public" interface which should also validates the inputs.
¬¥¬¥¬¥ MessageCount.concat(LinkCount).reduce( (resultObject, item) =&gt; { const key = item.day; return { ...resultObject, [key]: { ...(resultObject[key] || {}), ...item } } ): ¬¥¬¥¬¥ You convert it back to array format via Object.entries and map. Also you can use Object.assign({}, x, y) instead of spread operator
This! ü§£
most of the code I took from my previous projects but rewrite it all took me about 12-16 hours
Honestly, RxJS 6 is still pretty new. I doubt there are many tutorials about it yet (even its own documentation has some parts that are "under construction"). That being said, the old tutorials are still useful for learning RxJS 6. Don't throw them aside just yet. Just bookmark this page: https://rxjs-dev.firebaseapp.com/guide/v6/migration Give it a good read. It describes the new import paths, the `.pipe` method, any deprecations, method renames and so on. Use this workflow for learning: Follow the old v5 tutorials, making sure to use `.pipe()` syntax for operators instead of method chaining, and the very second you hit a stopping point, refer to the v6 migration guide to see if anything there might explain it.
I can just tell you that there are numerous resources. Here are the ones I find best-- 1. Learn-js .org 2. The Odin Project 3. Codecademy 4. W3 Schools 5. edWisor Of all these, I these I would rather recommend you to edWisor. There are more practical concepts that are frequently used in Javascript development, while the rest teach you mostly used theoretically. As a complete beginner (as I see you asking about nested lists ) the last two would be good. Then further, you can go for edwisor. It has tutorials on Javascript, Node,js, express.js, Angular. Basically, it's complete Javascript development. [https://edwisor.com?ref=redP](https://edwisor.com?ref=redP) 
Thank you 
Holy shit, I had no idea this kind of tech was in the works. Cannot wait to start using this.
If you want parallel data processing, use [Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API). You basically need to refactor everything, and you'll need to use window messages for synchronization/notification as well as to pass data between the main thread and worker threads, and between worker threads themselves. Keep in mind that in parallel processing, multiple threads must not try to write into the same variable/object at the same time, by using a synchronization mechanism. Otherwise, data integrity will be broken. You'll need to track how many worker threads that were created, in order to limit on e.g. how many parsed links can be processed simultaneously. i.e. the `parseLink()` function when the argument is an URL, should first check how many URLs is still pending. If the limit is already reached, put the URL into an URL queue array. The do either one of below. - Once an URL has been processed by `parseLink()` (but before returning exiting the function), call `parseLink()` using an URL taken out from the URL queue. - Have a function periodically executed to check how hany pending URLs. Once it's decreased, take out one URL from the URL queue and pass it to `parseLink()`. 
Thanks for the discussion! I don't disagree that we should use native libs as much as possible. There are so many additional tools I use in bluebird that i usually include it for simplicity. At 15K it isn't light but the majority of my work is in Node too. The main upsides to Bluebird in comparison to native promises are: * a+ compliant * Cancellation * Doesn't swallow uncaught errors * All the super helpful tools like `.disposer`, `.using`, `.promisifyAll`, `.map` Again thanks for the discussion!
Not like this question has not been answered 10 million times already, you are not that guy in this.
JavaScript port of Ecoji standard [https://github.com/dimabory/ecoji-js](https://github.com/dimabory/ecoji-js)
Thanks a lot for this incredible detailed answer. I have never heard about Web Workers before, but i will try this out.
Sounds like a good strategy! The new book will be out soon ‚Äì but it won‚Äôt be free to read online until 2019.
Sounds good, I will probably buy it straight out if I have good success with your other books. Thanks for the information.
Sure, I haven't planned to just throw away v5 tutorials, I've just started learning it, but as soon as I saw there is a newer version of it, I thought I could find some related tutorials with v6. I will look at them, thank you!
You're welcome :)
&gt; fonts I absofuckinglutely love that Firefox dev tools underlines the font being rendered by the browser. 
So, is this just like the standard debugger op in chrome, except with the ability to step backwards as well?
Good luck with your endeavors!
Generally no, you'd be able to fit 35x that amount of pointers on a floppy disk. But if the value that `d` points to is unique and *very* large then memory might be a constraint
I like to read the code for my favorite npm modules. Try to figure them out and build my own.
This sounds like fun. I'm not aware of any "easy" ways to do the text extraction on a web-app with just javascript. With that restriction it sounds like sending a smaller image to the server side is your best bet. A very crude but easy way you could reduce the size of the image is by doing something like [this](https://i.ytimg.com/vi/VEuX23iy2A4/maxresdefault.jpg), where you force the user to put the license plate in the restricted area while taking the image. On the server side I would recommend looking into [ALPR](https://github.com/openalpr/openalpr), which takes care of all text extraction from an image, etc. I'm sorry I don't have a more sophisticated idea for the client side.
Unit testing will always feel like a waste of time. Every time I have had to do them, it felt absurdly dumb. I think people who champion the whole concept do so for brownie points.
Cool, that's how I asked my wife if she wanted to marry me, only without the seizure colors and the "no" button was the only one avoiding the mouse.
If you want to see an example of redux + rxjs then check out [ngrx store](https://github.com/ngrx/platform/tree/master/modules/store). [The store](https://github.com/ngrx/platform/blob/master/modules/store/src/store.ts) in particular is basically what you described above.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ngrx/platform/.../**store.ts** (master ‚Üí 22284ab)](https://github.com/ngrx/platform/blob/22284ab7206717b19b20be389f062e115a34aa2a/modules/store/src/store.ts) * [ngrx/platform/.../**store** (master ‚Üí 22284ab)](https://github.com/ngrx/platform/tree/22284ab7206717b19b20be389f062e115a34aa2a/modules/store) ---- 
Maybe tell them how to use it?
Is there a way to debug nodejs like in chrome?
Last time I used FF dev tools to look at our admittedly large bundle, it took *minutes* for it to load the file to set a breakpoint. Maybe it‚Äôs improved drastically, but if it hasn‚Äôt, it‚Äôs basically unusable for my use case. Chrome dev tools doesn‚Äôt trip on this large bundle FWIW. I imagine some smart folks at Mozilla will get it nailed down, but it‚Äôs been pretty disappointing so far. 
Can you please download Firefox Developer Edition or Nightly and record a performamce profile? The devs would really love to see why it is not performing well on your app. https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Reporting_a_Performance_Problem For me Nightly is really fast on our app.
Unfortunately you can only debug node using the Firefox debugger outside of the Firefox browser :(
Fixed, sorry.
I'm gonna review it :D Please comment back on them if you have questions :D
Matter.js doesn't use ES6+ or anything super modern but the code is very clean and well commented. 
I'm gonna review it. Please comment back if you have questions or if you think that I'm not right. It's all about finding a solution that fits you :D
Ohhhh! Ooooh! I do that too! https://youtu.be/1A6IS1f7ua8
That‚Äôs a great suggestion‚Äîthanks!
Using js try creating a script element and append it to the div and search the divs children to remove the previous, but I'm not sure if that will run it but it will at least add the script
Change the src attribute of the script node.
I think if it were a smaller project with only myself working on it... And I knew it would always be small and never have anyone else working in it, they would definitely be a waste. But once the project grows to any size, and/or you get multiple devs working on the project they become important. Good regression cases from integration tests become esp. so I think.
I am missing TypeScript as a best practice from the list. Otherwise it gave me a lot of useful info, so thanks!
Maybe because it's not related to security practices
You can absolutely debug node using Chrome dev tools. https://blog.codeship.com/debug-node-js-effectively-with-chrome-devtools/
Practice 
Firefox has always had the standard JavaScript debugger like chrome. But as you mentioned, it's now able to step backwards as well.
Yea i have been using that. Sorry my question was incomplete. I meant that whether firefox have a similar option to debug nodejs. I have been wanting to switch to firefox for a sometime now. 
About pt.3: The main reason for pt.3 mentioned in article is that accidentally, my repository may became public. And if this happens, than all my secrets became public. But many devs doesn't host their code on github or any other public source control system. I.e we host it on private Stash. Can we say it's safe to store configs and passwords in vcs in our case? We all know this cut in stone words: separate config and code. But why? Do you know any REALLY good reason for that? Because for now, I know a lot of pros and only few 'ephemeral' cons to do that. About pt.8: 1) Using external binary modules may bring you more issues 2) crypto have no dependencies 3) crypto have perfect pbkdf2Sync. PBKDF2 is so good, even NIST recommends it [https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf) About pt.11 Better not use JWT at all. [https://paragonie.com/blog/2017/03/jwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid](https://paragonie.com/blog/2017/03/jwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid)
I don't remember firefox NOT having conditional breakpoints. https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Set_a_conditional_breakpoint
Use typescript
A little terse, but absolutely correct. Just program things. Easy things at first. If they're too hard, do easier things. As you continue doing things, it'll become second nature and you can gradually expand to more complex things. Also, if your functions have logic that is too complex, that's a "code smell", or a reason to think your code is going wrong. In that case, you should probably break it down into smaller functions that do simpler things, and then use your functions together to do the complex thing.
Depending on how you get the image, you may be able to overlay a box where the user must frame the license plate. This works like a credit card scanner for your bank app. Then simply trim the area you already predefined using canvas (plenty of tools/tutorials for that). I wouldn't bother with AI/smart detection to autoclip, probably not worth it on mobile.
I like this site, but some of the suggestions/alternatives ignore things or won't give the same result as the jQuery variant. For example: elem.querySelectorAll('.my-selector'); won't always give you the same result [as you'll have to add the :scope selector](https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll#User_notes). Same with the event handlers ignoring event delegating.
This is awesome! Literally as I am doing a MERN project and am about to implement Passport for the first time. I'm new(ish) to coding and have implementing an authentication gem in a rails project (devise) but still pretty unfamiliar and in the learning phase. One question I have is that your project doesn't have a client/src/UserPage/Post file so the npm start on the client side fails to compile. Am I being stupid and missing something? 
I livestream myself coding and I pick a project. I was lucky enough to get a job so learning on the job forced me to get better. But on my days off I‚Äôll work on personal projects usually tackling things I don‚Äôt fully understand, and the live-streaming I feel holds me accountable while also forcing me to write better code because I don‚Äôt want to disappoint anyone who is smarter than me on the stream lol.
You should create a new node element like so: var el = document.createElement('script'); el.src = "FTFMap.js"; document.getElementById('mapArea').appendChild(el);
Oh I got the joke, my joke was it warns a lot about it.
Its fairly new in VS and still only for enterprise edition.
Thank you. I will start doing personal projects, starting from easy things. 
Hi /u/stefannhs, this post was removed. Please, no campaigning. Thank you.
Hi /u/shobhit_c, this post was removed. If you'd like to post a link, then please use the "Submit a new link" option. Thanks for your understanding.
Hi /u/shobhit_c, this post was removed. If you'd like to post a link, then please use the "Submit a new link" option. If there is additional commentary or links you wish to add, please do so in a comment. Thanks for your understanding.
It would run it.
Hey man thanks for that I forgot to remove 2 unexcited files. I removed the import call and pushed new version try it now it should work 
Oh lol
sorry I added new v. now its works. lol I had to remove some calls that I forgot from other projects 
Amazing thank you! I think it will work but I'm also getting this error: (node:4506) UnhandledPromiseRejectionWarning: MongoNetworkError: failed to connect to server [localhost:27017] on first conne ct [MongoNetworkError: connect ECONNREFUSED 127.0.0.1:27017] This I know is not your side, but when i try to run a mongo server (run 'mongod' in the command line) nothing is happening. This one's definitely a stupid question but how do i run the mongo server? (I'm using lcoud based mlabs for project) 
try ‚Äòsudo mongod‚Äô
This is true, however my goal is to create a marketplace application with a few custom features. I haven't found any open source systems that allow to integrate the features I'm aiming to have with my platform. 
Are you on twitch?
I am yes.
It means those of us who can write it without a library will be more competitive in the marketplace :)
Take a look at this library [https://www.npmjs.com/package/image-compressor](https://www.npmjs.com/package/image-compressor). It'll allows you to compress image client side before sending it to server. I doubt you'll be able to find anything client side that'll perform OCR read.
Build shit. Then build shit, less shit.
Yeah, sorry, I was looking at the github list, and there are more general best practices, not just security ones. 
Moi oui, j'aimerai bien apprendre React.
Hmm, I‚Äôm not so sure I agree here. Can you give me an example of your simple one liner that is not O(n^2)? To use a built in Map we still a have to do some set up, and then things still need to be folded, which we now do more manually. likes.concat(msgs).reduce( (m, { day, count }) =&gt; m.set(day, count + (m.get(day) || 0)), new Map() ); This is as terse as I can get it with pure ES6 and O(nlog n), and I don‚Äôt think it‚Äôs any clearer as to what‚Äôs going on.
Super! Tu peux t‚Äôinscrire pour √™tre inform√© de la sortie du premier chapitre qui te permettra d√©j√† de r√©aliser tes premiers composants React ;)
Oui ;)
But if we remove resolve/reject in favour of return/throw, how would you create a promise that waits for a callback to be called before resolving?
This is not dependency injection (aka Inversion of Control), as the dependencies are not injected -&gt; this is a basic creation pattern. Whether you are using a class constructor, a creation method or a factory, it is all doing the same stuff. @scaleable , using `require` is not bad but it does have its downsides: 1. you cannot create 2 instances of the same unit, with different dependencies. 2. often you will require the "how" and not that "what" unit. Meaning you'll probably use `require("mysql")` and not `require("getUserById")`. 3. This is not a language related problem per se. Though it maybe harder to get it wrong in Java, as it is stricter, I've seen bad Java code that imports implementations with static methods - thus rendering the code unmaintainable (Yes, you could use reflection to override that, like you can mock `require`, but why bother if the solution to it would 2 more minutes constructing your code correctly)
You are correct, I write it like your second example. Just wanted to make a point here:)
Yeah me. Not for the book, but for French. You lucky bastard, France is a dream that will never come true üò≠
resolve/reject allows for a much higher flexibility when composing promises than return/throw would.
Haha! I‚Äôve actually been living in Montreal for a few months now. Qu√©bec is not bad either ;)
Similar approach (BehaviorSubject to take the actions, reduce them by scanning, etc.) This project is pretty enormous, and does a whole lot to link those observables into an Angular component. You don't really need any more to get a store going in React though -- it's almost a drop-in replacement for the `'redux'` module by itself. Main difference is your store is downstream from the action dispatcher, instead of the dispatch being part of the store itself.
I'm currently devouring [https://eloquentjavascript.net/](https://eloquentjavascript.net/) then there is [https://github.com/getify/You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS) or try codeacademy or [https://www.freecodecamp.org/](https://www.freecodecamp.org/). OR search this exact post in reddit for more resources. Check out courses on Udemy and Lynda. It is so important in this field that you learn how to teach yourself new skills/ tech / languages because the field is constantly evolving. Aim for 5 hours a week of self-learning and you'll be surprised at where you'll be in a year.
Ah this gets rid of that error! I now get this error though https://imgur.com/a/t4AIVgP. I'm on the train with poor internet so limited on what I can do. I did some googling and checked that i have a data/db folder (which I do, and it has mongodb stuff in it). People have suggested reinstall, which i will try too tomorrow when I have internet - if you have encountered before or anything to try jumps out at you then let me know! Thanks for the help :)
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/wL1FlYB.jpg** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20e3568zd) 
This looks like homework or actual work, but I've tackled this as I would an interview problem. Btw you're missing a closing \] in your original code. let both = {original posted object}; let countHash = {}; both.MessageCount.forEach(obj =&gt; { let key = [obj.day](https://obj.day); countHash\[key\] = obj.count; }) let solns = \[\] both.LinkCount.forEach(obj =&gt; { let key = [obj.day](https://obj.day); solns.push({ "day": key, "count": countHash\[key\], "visits": obj.visits }) }) My code iterates over the arrays: O(N) operation each. The hash retrieval is O(1) Runtime is O(N) Are there optimizations? Probably, but I think this is straightforward. Anyone have code review?
hmmm you can try ‚Äòmkdir C:\data\db‚Äô to create a folder for mongo to store its data and run ‚Äòsudo mongod‚Äô again
&gt;This project is pretty enormous It's definitely grown. But the fundamental store part is like 70 lines of code. As a whole project though yes it is quite big. I just thought you might like to be able to look at a working reference. &gt;and does a whole lot to link those observables into an Angular component Actually no, it doesn't. The only angular specific part is the module provided which, when included, calls a few functions to init the store. You can just call those functions yourself and it works without anything to do with angular. Once just to mess around I instantiated it and made a small react app backed by ngrx instead of redux. Now, once you get outside just the store yes a lot of the sub modules they provide are angular specific. But the store itself and the effects library are both agnostic. Anyway, I wasn't really trying to suggest you should use it. I just thought you might find it interesting.
Confirm(), prompt() and alert() are good ways to experiment around and get to know the language better. I for example programmed a little game with these 3 where you prompt the player for an action he/she has to type in and then evaluate the word. Depending on what the player typed in, something different will happen, much like games where you have different endings. These projects really only take a hour or two and are fun and good practice :) Eloquent javaScript also consideres these 3 functions as a good way to experiment. Try it out.
&gt; That‚Äôs 15k repaints reduced to 1. browsers aren't that stupid anymore, they will batch this. see https://github.com/infernojs/inferno/issues/223#issuecomment-224114369
Maybe... Plane ticket...? 
I've already visited France. That's why it became an obsession. The problem is that Albania is not in EU, thus I can stay only for 3 months there. Dream is to live there! üò≠üò≠üò≠
React by itself is pretty friendly to JS. Away from your components you can write all helpers etc. in plain JS and make use of advanced stuff. Sooner or later you will face some problems that need deep knowledge of the language.
Yeah I guess it's pretty though when you're outside EU... You'd have to find a French girl to marry and/or a company willing to support a work visa application (I'm not quite sure how these procedures work, I just know it's very long and complicated but there should be ways if it's really what you want) 
You also have another option, investment. If you have ‚Ç¨10M, you can instantly get a permit for 10 years and then you can easily apply and get citizenship. All you need is 10M to invest /s. Actually France is the most expensive one at 10M, there are countries with less money, like Spain. Btw... Did you just assume my gender? 2x/s üòÅ
FWIW, I‚Äôve always felt a debugger to be a time sink. Write a test or a few prints and then understand why the program has an unexpected state by reading the code. 
Oui, oui, j'apprends le fran√ßais maintenant
Afaik pipe operators are fine, but chaining is still okay if you bind the methods instead. All the reasoning for using pipe also applies to bind (tree shaking, etc.) Eg `thing$.pipe(map(` vs `thing$::map`. You can keep writing code that looks pretty close to the v5 tuts if you simply import the operators (instead of importing from the `/add/` dir), and :: instead of .
I think you might be wrong here - I didn't see any sentences on the v6 docs that mentioned that the context of each operator is automatically bound to the underlying Observable. Even if it were, that is not standards-compliant JavaScript. It isn't even a thing in TypeScript. It is simply a proposal. TC39 could at any moment decide not to add that syntax to the language. You could argue that the pipeline proposal is even better (because it uses the same operators exported from `rxjs/operators` and is compatible with `.pipe` should the pipeline proposal not be successfully added to the language): thing$ |&gt; map 
You can use sites like hackerrank or codewars to do daily JS challenges. They increasingly get harder which is nice and you can also see how other people solved the same problems. That's a great way to learn in general. The only issue I have is that sometimes the "most clever" answer bubbles up to the top and it isn't necessarily the "best answer" in my opinion. https://www.codewars.com/ https://www.hackerrank.com/
Most of these have nothing at all to do with security
I'm starting writing books about French in React
Storing secrets in your repo may expose them to external contributors of the project for example. Or Backend secrets for the Frontend guy and vice versa. 
Go for it, use localStorage. It‚Äôs slightly easier to work with than cookies. 
This. 
Currently on 6.2.2, and it's working fine. It's even recommended in the installation docs (with the caveat that it's stage1 in tc39 right now): https://rxjs-dev.firebaseapp.com/guide/installation I do wonder about the future of bind and pipelines. They're both stage1 right now, but I think the added value of either diminishes quite a bit if the other is added. I'm team-bind personally, mainly because it also includes the very cool `::console.log` syntax, but when it comes down to it both bind and pipelines exist so we can write things out in the order they run. `map.call(filter.call(thing$, filterer), mapper)` isn't as nice as `thing$::filter(filterer)::map(mapper)`, but your example reads just as well. This isn't really the place to pit `::` against `|&gt;`, but suffice to say `::` does let you continue to use many of the &lt;=5 tutorials with few modifications.
If you need to do something that makes you think "I should look for a package for this," don't reach for a package right away. Try to write it yourself with JS first. An example, I'm working on something involving client-side input validation and I've created my own set of validators that are just functions. Lots of JS, less dependencies, win-win.
You should say what you're trying to achieve overall because I suspect that what you're describing is not a good way of doing it. 
It's time for you to observe the first rule of holes, kid: stop digging. You might not care that I know you're a fool, which is fine, but you're eventually going to tip that hand to someone whose opinion you \_do\_ care about, and that's not going to work out great for you. Stay in school and keep working on your reading. You'll get there eventually.
The `return new Promise((resolve, reject) =&gt; throw resolve('lol'))` made me chuckle out loud. Cause I knew it was going to choose to resolve instead of the intuitively throwing. Is this what Stockholm's Syndrome feels like?
Doing it over and over and over and over and over and over Also find some people on YouTube and watch them. Theres also a lot of people that stream on twitch as well. But honestly I feel this post hard. I was in the exact same boat. Just dont get discouraged, learn one concept at a time. Once you pick up a few things, the easier the rest of the puzzle becomes. 
[https://github.com/whatwg/html/issues/793](https://github.com/whatwg/html/issues/793)
I think the trick with resolve/reject is to remember that these are a low-level API, and you want to be working with them as little as possible. They're basically there to bridge the gap between callbacks and promises, but for regular promise usage you shouldn't need them at all. The way that they work is definitely confusing if you come at it from the perspective of promises, but they mirror callbacks in a fairly obvious manner, and most of the gotchas inherent in resolve/reject (and the whole promise constructor) are also found in callback-based programming. However, 90% of the time you never need to touch resolve and reject. Once you've got a promise, you can just use standard promise handling code (`.then`/`.catch` or async/await), and if you're trying to create a promise, use one of the many promisify utilities found all over the place (including now in Node itself).
The resolve function has to be executed in order to get the value to throw, so it seems intuitive to me that it would resolve instead of throw. Once you understand Promises only take the *first* resolve/reject, it seems reasonable. I don't get why this was considered an issue in the article.
Dont use react
That‚Äôs like saying ‚Äòif you want to learn how to cook don‚Äôt use a stove‚Äô. 
Why?
Great points, some will require to change some of the content, for others I have to think for some time before replying :]
Hi /u/versatile_man, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Thanks for your understanding.
Good luck finding edge cases 
I don‚Äôt follow.
If you're not open wood-fire cooking, is that really even"cooking"? I mean, you're totally reliant on the stove framework. React is basically sous-vide boil-in-a-bag coding, it's got no heart. My grandparents only wrote vanilla JavaScript in their log cabin and they were happier for it.
For the record, I‚Äôm pretty sure the script tag doesn‚Äôt work the way you think it does. For instance, placing your script tag within a div tag has no functional value, as far as standard browsers are concerned.
When you are in exam and you use the calculator to multipy 1312234143418 by 1 lol
You should be suspicious of your grandparents. Saw their code and it was nothing but talks of $ and binding things. Something tells me they may have had a ‚Äòside business‚Äô. 
Those two functions don‚Äôt always roundtrip everything.
if visitedNodes gets mutated, this is a way to log a traversable snapshot of the object to the console without having to worry about how the state the object when you expand it being different than the state when the log first occurred. 
If `toJSON` method is redefined this may print entirely different object, though. 
You can enlarge the container div and generate scroll, the graph will adapt to container
I use the same method time to time to clone an object without a reference to the original object. Probably he had a similar reason, ie: seeing the original data before sending it to a function to be processed etc.
CSS .feature a
wat
[removed]
I wish I'd have known about this a few weeks ago. A buddy asked me to debug some code he was having issues with and figuring this little quirk out cost me a solid hour of saying "what the fuck." over and over.
It seems people consider promises a black art and that if there is an error ANYWHERE it must reject even after it resolved. Which defeats the whole purpose or promises.
Not as crazy as it seems at first glance. This is a simple way to make a deep copy of an object which can be pretty useful for a lot of things assuming you don't need functions, etc
I'm not always debugging my code, so I don't always have the option to "add another test or print", sometimes it's just me, minified JavaScript, the debugger and patience
this whole blog post is an ad for catchjs.com, which is only mentioned at the bottom of the article. gross.
Sweet deep copy.
string.lastIndexOf() ? 
I know exactly what it is and does. Why is this kid posting it
https://github.com/alexweininger/recent-pdfs First chrome extension. Finally got the main functionality to work today.
 function schr√∂dinger2() { return new Promise((resolve, reject) =&gt; { throw resolve("huh"); //&lt;-- this throw is executed }); } async function callAsync() { try { await schr√∂dinger2(); } catch (e) { console.log("caught error", e);//&lt;-- yet, this isn't reached } } &gt; Here the promise has a single line of code, a throw statement. Yet, the try {} catch {} is never triggered. This is because resolve was called, and the rule still is that whatever was called first is what wins. So the throw is executed, but it is silently swallowed by the runtime. This is bound to cause endless confusion. This is to-spec what promises do. You wrote your code in a shitty way so expect shitty error handling. Always `return void resolve/reject(...)` and you'll _never_ wonder why this error happens. &gt; What about when you want to set up a global catch-all handler for all unhandled errors, for example to log these errors to a server? Yeah because that's what we need in our call stack is a global function which enables you to write piss poor promise handling. It's not that hard to ensure your chain doesn't lead to unhandled promises but it requires discipline that a lot of devs seem to lack. They do go into why having this _wouldn't_ work because something at some point could handle that error but you have no way of knowing. &gt; _Originally published at catchjs.com._ Oh the article is just an ad. Cool. No wonder it's so misguided, they're just trying to find an issue they can slap that their product fixes.
He picked the wrong friend.
What's the use of a deep copy when all you're doing is logging it?
wtf?
My favorite is the /r/ProgrammerHumor-like headline. 
Is this really a good way to make a deep copy of an object? What if the object contains dates or functions or undefined -- none of these are supported by JSON
I don't know. Downvote and move on if you don't like it? 
What do you mean by "roundtrip everything"?
Maybe his house is cold and needs extra processing to keep it warm?
IIRC it's really unperformant though. If I wasn't on mobile I'd look it up
Can only be used for simple objects obviously. You as the dev have to know it has no functions or circular references. Needs to be able to be safely stringified to JSON.
How does this compare to `console.log(visitedNodes.concat())`? Wouldn't this also log a snapshot of the object?
Can you explain more the traversable snapshot part? 
In my case it does. The script draws a map in the element where it's called. It works just as is in the example above.
It depends on whats in `visitedNodes`. If `visitedNodes` is a flat array of primitives, `concat` would be just as effective. Anything else and you could have problems. For example, throw this into the console: var visitedNodes = [{x:1}, {x:2}, {x:3}]; console.log(visitedNodes.concat()); visitedNodes[0].x = 4; Then expand the logged `visitedNodes` array. You'll see there that the first `x` is 4 despite this assignment happening after the array was logged.
Yup. And for a solid hour.
I mean what you get out is not always the same as what you put in.
Fascinating, thanks. So is there no cleaner way to create a frozen-in-time clone of an arbitrary array or object? We're stuck with JSON.stringify/parse hacks?
The script draws a map and places it in the div. The second script also draws a map but uses different data input. I ended up solving this in a whole another way though. Now I draw both maps on page load and display:none the second map. When I want to view the second map I display the first and hide the second with jQuery. Probably not the most efficient way but it works out for me.
Pretty formatted output in the console. In other words, normal console output of an object (at least for Chrome and FF).
Downvote, comment, move on*
By "snapshot" I just mean a copy of the object at the time the `console.log` function is called. Traversable is a reference to how many consoles (notably in browsers) will represent logged object values in an expandable tree component letting you expand/collapse object values to navigate through the object's structure. https://i.stack.imgur.com/v738C.png If you notice the little "i" icon in the picture, that's a hint in chrome that when hovered says "Value below was evaluated just now", letting you know that what you see in that tree is the state of the object when you first expanded the tree, not when you logged the object. So the tree when you first open it is a get-the-current-object-value operation rather than a show-the-object-when-logged kind of deal. You can also skip the back-to-object part of this if you just want to see the object in full in the console by logging the JSON string directly. This also won't change as the object changes and also lets you see the full object at once (though for larger objects this might not be preferable) console.log(JSON.stringify(visitedNodes, null, 2)); The extra arguments in in the `stringify` call just adds some formatting.
I feel like this is legitimate code. `visitedNodes` is probably a complex class, OP probably wants to strip away functions before logging, and logging it as a string after just `JSON.stringify` is ugly and unreadable. Op might want to make a deep copy that doesn't mutate when expanded on the log. Op might also have some custom behaviour in a `toJSON` method, making it suitable for serialisation/logging.
Chrome's debugger lazy loads the value, so if you log an object, mutate it, then you open it in the debugger, it will get the latest value. This takes a snapshot of the object at this exact moment
When you expand a logged object in dev tools it shows its state at the moment you expand it. Logging this way would preserve its state at the moment you log it.
Mutation is probably the largest cause of unknown errors in JavaScript. There's a reason we use things like redux, normalizr, and immutable.js
I love FM. Great source of quality content. Amazing JS content. 
For deeply nested objects, pretty much. But it depends on what you're doing with your objects. If you're mutating them directly, you'll likely want some form of clone for this purpose, though it doesn't necessarily have to be from JSON methods (they do generally tend to be the easiest). If you're working with code that follows more of them immutable practices, something this probably won't be necessary; log the object directly and you're free from worry about it being changed. It's one of the benefits of working with immutable objects.
Got it. Thanks for explaining.
Legit code.
Does it have something to do with pathfinding?
Sometimes I wish there were an `use immutable;` mode like `use strict;` where mutation was impossible :(
I do this all the time to squash pass by reference bugs.
It depends on your goals. The more code you write, the more code you have to maintain, and the more opportunities you create to introduce bugs. If your goal is purely to learn then I agree. If you're building a real-world app though then this is not a good idea.
&gt; About pt.11 &gt; Better not use JWT at all. https://paragonie.com/blog/2017/03/jwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid I love how you provide that JWT is terrible and that everyone should just use sticky sessions. What happens if the server ends up gone? The session is dead and therefore your user logs out. Creates a pretty crappy experience. If you offload this to an external session storage you're considered over engineering your solution and shouldn't ever have to do that, you'll never run at that scale. JWT's are fine but with every technical decision comes with caveats. Having revokable tokens can be easy. Generate a signing key that sits with the users' account on the DB. That key can change to revoke _all_ tokens of that user. You shouldn't be storing a lot of data in the JWT in the first place that it wouldn't fit in a cookie, they should be base64 encoded as well to cut down on space. You can also alleviate a lot of the issues with having roles in the token by just storing the user id and evaluating the roles from the DB. 
I do like the automatic binding in the case of `::console.log`, and what you say about the added value is correct, however, I do not think `::` will ever be added to the language when the value it provides is superseded by the combination of the pipeline proposal and the partial application proposal. Your example with `::console.log` could be expressed as `|&gt; console.log(?)`. In any case, you won't catch me using either of them in production until they reach at least stage 3. I'll stick with `.pipe` for now... (...sort of, I'm more in favor of using Ramda's `pipe()`.
Your new solution doesn't sound unreasonable. It looks like your original `ISLANDMAP.js`/`FTFMap.js` are scripts that automatically execute code that targets `.mapArea` or similar, and you're invoking it by adding it to the page. This is a little unusual. More usual would be for the scripts to both be loaded on page load (or combined together) and then you would have code that conditionally calls a function in one or the other, depending on which map you want to display. That way you would replace all that element insertion with a function call. 
Oh that makes so much sense, thanks man, I guess I deserve some of these downvotes :P
It is not a good way, but it works. It's not very efficient, printing and then parsing JSON is very expensive compared to operating on the objects directly. It's not too hard to make a smarter/better/faster deep clone. Start with underscore's clone for example and then put a recursive wrapper around it. With some effort you can even make it preserve multiple references to the same objects and handle circular references.
`str.replace(/bar(?! bar)/, 'foo')` Breaking down the regex: * The // are just delimiters saying this is a regex, like how '' delimits a string * Both instances of `bar` are literal. Note that the space before the second instance of `bar` is also literal and very important. * The `(?!&lt;...&gt;)`is called a negative look-ahead and it only matches when it does *not* find what it was looking for in the `&lt;...&gt;` bit. So from left to right for `/bar(?! bar)` means: match `'bar'` as long as there are no `' bar'`s after that. This was a good tool for testing the regex: [https://regex101.com/](https://regex101.com/)
This is question Angular folks should be asking!
`console.log` is horribly slow by itself anyways.
Iirc you can also just do let copy = Object.assign({}, obj) 
_.cloneDeep();
That's how you're supposed to do deep copies of objects in javascript, unfortunately.
Yes and no. There are some language features that encourage performant code and code reuse. Enums optimise well where a developer might be tempted to pass around more inefficient types / configuration. Classes in TypeScript generate prototype inherited objects which are more efficient than some other ways of writing OO in JavaScript. You can always mix and match TypeScript and JavaScript if you want to super optimise.
It doesn't cover everything.
You don't understand what the code is doing do you? It's to easily recursively convert objects to string, which might be better for readability if you are logging some huge ass js object.
Which in this case is a feature. The stuff it leaves out is what you don't want to see.
What about Object.freeze
Browsers have scrollbars just for that
Did you just assume their assumption of your sexual preference was an assumption of your gender? /s
I prefer to use the Chrome debugger (also available on Node.js with `--inspect`) with breakpoints and inspect variables under the "scope" section. I don't need to worry about using tricks like these and I don't have to type `console.log` statements that I may or may not forget to remove before deploying to production.
It's not JS, but TypeScript has [readonly properties](https://basarat.gitbooks.io/typescript/docs/types/readonly.html) and the [readonly mapped type](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html) - they work great &amp; I use them all the time.
Where is the person that tells you to just use Haskell?
This is going to be a problem when debugging in browser, right? Node logs works as expected. 
So this is maybe a silly question but why does console.log not render its argument immediately to a string to be written to the console buffer? I always imagined that function being sort of the equivalent of writing to stdout, so your example looks to me like writing to the screen and then a later change to the written object causing the screen buffer to magically retroactively update, which seems crazy. I take it console.log is somehow lazily evaluated so that its buffer only contains pointers to the objects rather than finalized rendered strings?
You can check out orbitjs. Ember uses it for offline usage. https://github.com/orbitjs/orbit
No, it isn't how you are supposed to do it. The purpose here, since it is a console log, to to record the object at the time it was logged. Colsole ligs are lazy, and will display the object only at the time you actually view it. If changes happened then you would only seel the mutated object in your console, not the original.
This is a great method to perfectly clone objects without worrying about expensive conversions. It's also probably quicker than anything a person could write themselves.
This is not a beauty. This is normal JS debugging behaviour. It is the quickest way to ensure your object log is not mutated at a later time and to keep it nicely formatted. Most of the time you're logging an object for debugging purposes, you only care about the keys and values. 
For front end that would be * Elm * PureScript And I'd like to add ClojureScript but it's not typed. It's hella functional but not typed.
It‚Äôs trying, but not succeeding.
That‚Äôs exactly what you want them to do in this example though.
Cold
tl;dr: try { setTimeout(() =&gt; { throw new Error() }, 100); } catch (e) { // Not caught } Promises and async/await don't add any special behaviour to make this magically work.
Couldn't you use Object.assign() to do the same thing?
Don't be a dev who is always looking to criticize other people's code. Even if this was a legitimate mistake, you shouldn't do this.
One programmers worst practice is another programmer's best practice. 
I guess this is Vue related stuff, cz I use it too
Maybe give [console.table](https://developer.mozilla.org/en-US/docs/Web/API/Console/table) a try? 
i think, it is mostly about how browser console works. 
If you get the luxury of time, definitely try the do it yourself first. But remember that with every function, you should write a test too, and oftentimes those libraries have already done the testing.
Error: visitedNodes is not defined
FWIW, OP is reposting from Weekly Javascript. If you like these articles, maybe subscribe. 
Yeah. Don‚Äôt ever post anything unless it‚Äôs purely, completely 100% original. That‚Äôs all that matters. 
Could you elaborate?
I‚Äôll never let go, Jack... I‚Äôll never let go. 
You need to let go.. And have lots of babies.. 
throws a giant sapphire away into the ocean or something, later comes back looking for it (jk)
Object assign only goes one level deep. Nested mutations would still be a problem.
right, node dumps and string version of the object to the console so it doesn't have the same problem.
Nice. Looks very good. Side Sheet is broken (uncloseable) on mobile.
This is an implementation detail for the consoles that do this. Instead of a string, like you said, they keep a reference to the object so you can inspect it dynamically. This keeps the logs succinct, reduces memory, allows you to walk through circular references and other things you couldn't do with a string (or at least wouldn't be easy). Conversely, you can run into problems where the object is GC'd and no longer available at which point the console can't give you a dump of the object.
In what way is this related to Vue?
I think I checked once and it‚Äòs actually one of the fastest if not actually the fastest ways, but I may be misremembering.
This is a legit way of forming deep copies of an object as opposed to Object.clone() which only copies the first level). I use it often and have to explain myself quite a bit too. It definitely works
Thanks! Appreciate the reply. 
Thank you very much! 
Yup, I did this many, many times when I worked in angular 1.x.
Yeah, but that‚Äôs a library. You can do the same thing with just browser. 
The fact that this can happen is totally incomprehensible to me. Surely dev tools should give you the option to explore the values at the time the console.log was executed, and at the time it's expanded/read.
Kinda. Firefox introduced timetravel debugging in the latest release, which might allow you to do just that. But for most real wolrd scenarios you would rather just use a breakpoint and the debugger which pauses the execution at given point.
Makes sense :)
I'm not sure it can clone a non-built-in that has a constructor.
I think if elements of visitedNodes are mutated after logging, the console will not reflect the pre-mutated state if you don't inspect the log until post-mutation. But stringifying it locks the state in place and then parsing it turns it back into an object that has nothing pointing to it that can mutate it; it's just sitting there in the console.
1.5k month is nothing, don‚Äôt sell yourself for cheap. I‚Äôm Brazilian as well
Think in terms of annual salary, 75k I think is the bare minimum
Greece with 250.000 euros. Just buy a house there or something, stay for a couple of years and get a citizenship. Since France is out of the question, because of their extremely high quota, a Canadian passport would also be a great alternative. However, they changed the way this works and now they accept only a specific amount of people, due to the fact that a lot of Chinese millionaires went through this investment program and Canada as a nation only gain a couple of billion of dollars and didn't really helped them that much, it just made their passport weaker, that's why they only accept a small amount of people, I think around 1500 per year.
Haskell can be compiled to JS and there are front-end libraries for it. But yeah. I'd go Elm if I wanted the robustness of a purely functional frontend, and PureScript if I wanted a Haskellish frontend without waiting half an hour for it to compile.
Don't see the problem with this ü§∑
This is a cool trick. Thanks for sharing.
Const and functional code all day long.
Alien kills her. James Cameron crossover. Could be the abyss, could be alien. Who's really going to say? 
TypeScript is that language that should replace the standard but game theory prevents it from happening. 
Yep, it's actually a super easy way to get a deep copy of an object. Egg on your face OP
Also, this is another way to deep clone an object.
Well, you don't have to "know" that is has no circular references, you can wrap it in a try catch.
I just used the same method to easily transform ISO-27001 date strings into js date objects sourced from a socket connection. Taking advantage of JSON.parse‚Äôs magical second argument and a simple regex gave me nice, functional dates, rather than date strings
custom elements are really cool, though.
Is it bad when you can't figure out what to do and you use Google to find other people's solutions until you figure out what to do and sometimes use other's code just to solve your problem? Isn't that cheating? Is it bad? Its what I mostly do atm.
&gt; PBKDF2 is so good, even NIST recommends it NIST's recommendation should not be considered an endorsement. This is the group that also recommended Dual-EC-DRBG remember. Since you're going to reference paragonie, I'll point you at this article: https://paragonie.com/blog/2016/02/how-safely-store-password-in-2016 And specifically the quote: &gt; PBKDF2 (nearly everyone except FIPS agrees PBKDF2 is the worst of the acceptable options 
Or you know, you could just use a debugger.
What is mutation? Noob here. 
If readability and speed is important, console.log(JSON.stringify(yourObject, null, 2)); will log the JSON in a nice way, usful if you're wanting to check what small objects contain without clicking to expand or copying them to an external formatter.
Had to remove read only restriction from an object once, and had to stringify and parse aswell, this had legit uses
Promises are just as weird as (err, data) callbacks signatures that they were trying to solve. They should've gone from callbacks straight to Async/await and made them standalone having nothing to do with Promises, just like generator functions.
There are eslint rules that forbid mutation, I've used them just for my redux reducers in the past.
&gt; The purpose here, since it is a console log, to to record the object at the time it was logged. ding ding ding, that is called a "deep copy". &gt; Colsole ligs are lazy, and will display the object only at the time you actually view it. It's not just console log, in js sometimes you need a copy, deep copy to avoid mutating the object or deeper nested objects when passing it around. For that, you need a deep copy. This is the fastest way to do it. If you know a better way to do deep copies of objects (ie. faster and just as bug-free) please let us know.
explain to low iq person thx
JavaScript is amazing. Here's a comprehensive list of things you can do to learn more about it: * Learn NPM and package managers. The community has written tons of great libraries, and the best way to use them in your projects is through NPM. * The N in NPM stands for Node. Lean Node. Learn how modules work, exporting/importing. * Promises and Async Await are modern approached to asynchronous Javascript. If you intend on performing network requests, this is vital. * Standard libraries. A lot of times you'll find yourself needing to perform data structure manipulation that isn't covered by the built in stdlib in JS. Learn what Lodash can do for you. * Frameworks. Learn how to build the modern web with Single Page Applications. React is the best in this field. * State management. React is just the view layer. For the data layer, you'll need something else. MobX and Redux are my top choices. If you find this really intriguing you can go deeper the rabbit hole: * Web workers for not blocking your UI thread * CSS in JS * Servers in JavaScript with Express * GraphQL * React Native for mobile apps * Electron for desktop apps * Deeper understanding of module bundlers and transpilers because create react app takes care of these for you * Reactive JS (RxJS) * TypeScript for JS that scales You can use JavaScript everywhere. It is the most popular programming language.
OMG this. My uni had an ancient version of node installed that literally never notified you about failures, ever. You could straight up pass it malformed syntax and it would just chop off the parts of the tree that didn't parse right before chugging along
JSON.stringify still has a flaw. Its only shallow cloning of an object. So if you referenced a nested object before doing this and then changes one of the attributes, it would change in the stringified version as well as the reference is kept.
I wish man....nobody would hire me so I became an unpaid intern working two jobs until I can. And the one interview for a paid position was 35k and they were developing a porno website... I'd literally kill for 75k.
Immutable JS is a popular simple library (made by Facebook) that does exactly that.
I don't see how. Sure, having typings for all third-party code would be helpful, but TypeScript brings benefits even if you are the only one who uses it. 
Yes, that's exactly what I am seeking for. I've quickly checked the docs, but don't seem where I can define the the behavior (on server of how the offsets (of changes) are treated), nor auth. I am exactly looking for this, except for more control. 
Actually code a recursive function? Or else you lose all methods... For logging it's fine, but for production please no one use this seriously just don't.
Yep. A very legit way of deep cloning in a pretty darn performant way too. 
Oh oui ! Lances-toi ! üöÄ
Extending React.Component is obviously a very common example
Do you use "classes" or functions called as constructors? If you do, then you most likely make use of prototypal "inheritence". Do you use built in methods like .map(), .toString() or .filter()? That's possible thanks to prototypal "inheritence".
Have to give up on this fight on afraid... Change your wording to ECMAScript... This is why people stay away from any open source tech that Oracle buys 
[https://github.com/stepanvanzuriak/Finite](https://github.com/stepanvanzuriak/Finite)
Get a fucking job so you arent foraging for non existant $1 whole chickens.
IMHO writing (directly) proto inheritance in JS has been really clunky overall before the arrival of \`\_proto\_\`. All of the \`Function#prototype\` thing is quite confusing. One good example I hit today: Let's say I got a data object (something that came from JSON serialization) and I wanted to attach some methods to this data. I could just write something like const enhanced = { \_\_proto\_\_: methods, data: dataObject } //or const enhanced = { \_\_proto\_\_: methods, ...dataObject } Unfortunately things like Flow and TS dont seem to like this, since one has to usually add a lot of type annotations to make the \`this\` work properly (or it is hard to make them infer the thing properly in an elegant way).
obligatory es6 version... `console.log(object.assign({}, visitedNodes)`
Yes. Also like the standard debugger Firefox already has, but now with the added ability to step backwards :P
Have you tested that in Safari and IE too? I had a bug recently related to how those browsers deal with ISO 
People often get tricked by the wording of `new Promise`. Newcomers often think: hey, I want to create a Promise, so I'ma gonna write `new Promise`, since its a constructor, right? WROOOOOOOOOOOOOOOOOOOOOOONG So, there should be big red letters popping at yours screens everytime you even think on writing `new Promise`, saying: **IF YOU DONT INTEND TO CONVERT CALLBACK TO PROMISE, HOLD BACK YOU ARE USING THE WRONG API**. Notice that once you are inside a `.then` group things are definitely safer since now sync errors can be thrown. Ok, its still dangerous bc ppl forget to `return` inside those blocks. Not an eslint user but I hope you guys have a rule for that. One should never implicitly return an undefined inside a .then block, in any code path. Now even async/await can be tricky async function callee() { throw Error('Err') } async function caller() { try { calee() } catch(err) { console.error('hey') } } Since we forgot an `await` on calee(), that error will never reach the thread. If we somehow `return`ed calee, at least, the error would propagate. Otherwise, bad news. Functions who dont return anything and merely produce side effects can be really dangerous.
Wow. Nice! Thanks!
Actually, the console apis already use the structured clone algorithm 
Super useful. Thank you!
I got it to work by reinstalling mongod and then creating the data/db file and granting the right permissions. Something about my previous configuration must have been breaking it. I am now getting this error! ./src/Screens/Admin/ResetPassword.js Module not found: Can't resolve '@material-ui/core/Button' in '/Users/robertfaldo/Documents/Makers Academy/Lendit/react-express-boilerplate/client/src/Screens/Admin' When I comment out both this line (where it's being imported) and then the line it's being called in the doc it still doesn't work. Sorry to keep throwing issues at you but in case anything jumps out at you as being at cause 
Wow thanks! Missed many opportunities for it.
Even easier: Set a conditional breakpoint with the condition being the console.log(stuff). It returns undefined, which is falsey, so it will never actually break and you can enable/disable without having to reload.
I have a slight feeling that if he wasn't aware of the comma "operator" he won't know how to do that 
All a MITM has to do is drop connections going to that server address, and they'll have all your users on plaintext. Is that really what you want?
That produces a shallow clone, not a deep clone.
I found [this jsperf](https://jsperf.com/deep-copy-vs-json-stringify-json-parse/5) that evaluates it as one of the slowest, but jsperf isn't always reliable for real-world performance
Speaking of redux! I recently found out that that when you do map state to props, and then mutate the prop in the render your mutating the object in redux directly! For some reason I always thought you'd be getting a new copy of the object in the component, but it's not, it's just a reference.
What is that, can you elaborate further?
What's more efficient this or deepClone from lodash?
Wth? Sometimes you just want a clean copy of a dumb object, that's the fastest and cleanest way to do it. Can you use proxies and recursion? Sure! Generic enough for all Ur dumb objects? Not so much, sadly.
I never find the comma operator worth considering due to readability. However, what you had before was very straightforward.
Sadly, assign only destroys root props, meaning any other object inside visitnodes would not get "dereferenced"
Got it working! I hadn't npm installed in the client directory \0/ This is awesome - thanks so much for sharing it and for your help. 
no worries! Thats why Im here lol. Did you cloned the last version? I fixed it there but you can just ‚Äòcd client‚Äô and run ‚Äònpm i ‚Äîsave @material-ui/core‚Äô because for some reason it wont added it at the first time to package.json so you need manually install it 
People will never learn to use debugger
Glad to hear you managed to make it work!(: 
Here‚Äôs an article showing the performance of a lot of deepClone techniques. I think lodash might do some recursive stuff, but you can get an idea from this: https://dassur.ma/things/deep-copy/#performance-extravaganza
Same issue with debugger here
another option is const example = (stuff) =&gt; console.log(stuff) || stuff;
Nah, everyone uses resources like stackoverflow and mdn to find answers when theyre stuck. As long as youre making an effort to understand why that code works then youre doing fine. 
No there isn‚Äôt. Use one of the many ways available to use the Chrome developer tools as your inspector and you can set break points at multiple places on the same line. 
No we're talking about plain objects (data) not something with methods and other stuff. I'm not aware of any recursive function that does this copying faster than stringify / parse combo under any js engine. You'll find this in millions of production sites because many of the most popular frameworks use it, because there is no faster method.
Interesting thanks!
Mutation is change. Immutability means you cannot change any properties on an object, so in order to change a property you need to clone the object and set the new value against the desired property/properties.
Updated the **[First Working AGI Steps](http://ai.neocities.org/AiSteps.html#AudMem)** doc for any **[JavaScript](http://ai.neocities.org/FirstWorkingAGI.html)** or Forth or Perl coder to create an artificial general intelligence that will think in any desired human language known to the coder. 
What do you mean?
I was talking about the debugger js keyword. Using chrome dev tools you can set it, true. But you can‚Äôt do it while coding. You have to go through the code in the browser and set it there.
I assume console.log always returns undefined right?
https://i.imgur.com/35ScqaA.png
Why are you using quotation marks? It is an operator..
Oh come on. I am using JS in many different contexts: the browser, nodejs and various test runners and there are plenty of situations where attaching a debugger is tedious for whatever reason. 
From my experience usually if it is tedious to attach a debugger means you're doing something wrong. How is it tedious in a browser? You cannot run node --inspect? Test runners do not use node?
Constantly, but not in ages -- basically not since babel became a thing. And, spoiler warning: this is ancient history with very few direct applications today (unless you are targeting legacy platforms/browsers and can't use babel). Consider these two functions: function Foo() { var _foobar = 321; this.bar = 123; this.baz = function () { console.log(this.bar); console.log(_foobar); }; } var foo = new Foo(); foo.baz(); // echos "123" and "321" function Qux() { this.bar = 123; } Qux.prototype.baz = function () { console.log(this.bar); // echos "123" }; var qux = new Qux(); qux.baz(); For ages, the first format (`Foo`) occupied a real sweet spot for me. It was readable. It was completely self-contained. It folded down to a single line. But most of all, because there was a single closure, it allowed explicit public/private variables -- see that `_foobar` variable? That's what I'm talking about. This is impossible with prototype methods. There was one gigantic problem though. For large constructors (with lots of functions/methods), this format chews through memory like crazy. Create 1000 `Qux`s? No problem. Create 1000 `Foo`s? Time to refactor, because it means 1000 `baz`s. Also, in my own (very, very extensive tests), prototypes were appreciably faster. How much faster? It depended. A lot of that was simply a result of simple memory allocation, but it seemed that even small constructors with little overhead were faster when built prototypically. I probably would have stayed writing things as non-prototypical, single-closure constructors if the speed difference were not so significant. 
Huh, weird, I knew about console.log returning undefined but I didn't know the comma operator either......
Yeah let's bloat code with console logs. And can you change console logs in runtime as easy as breakpoints?
The object literal shouldn't have `this` in the property identifiers. It's syntax is a little different from regular assignment. It should just be: this.address = { street: street, number: number, suburb: suburb } https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer
Yes, it does, simply because the value of anything that doesn't return something is undefined by default. Console.log returns nothing, doesn't it? But wait, even "nothing" is a definite value. So it's more accurate to say that it *doesn't* return anything. Which simply means that its return type is not defined, i.e. *undefined*.
Oh thanks that worked perfectly but why don‚Äôt you use ‚Äòthis‚Äô does the this.adress already access it for the entire object?
There's very little reason to use prototypal inheritance in an application, it can be useful for the memory saving if you're dealing with \*very\* large sets of objects but generally you'll just make your code worse.
They're fine if you wrap an if (debugMode) around them IMO, even helpful at that point.
right. this.address is saying address is being defined on this (the person being created). Inside the object literal, this isn't needed because it's a shorthand for address.street = ... + address.number = ... + address.suburb = ..., not for assigning those properties on this. In fact there's a shorter syntax you can use to that is less redundant: this.address = { street, number, suburb }
wow thanks so much that new code looks and works so cleanly.
There are instances where your scenario is not a concern; see the ‚Äúwhy use this script‚Äù section. If your scenario is a concern, then HTTPS needs to be enforced site-wide &amp; server-side with HSTS and this script is not for you. 
I just came across similar code in our code base this week and at first was shocked, then realized what it was doing and was kind of impressed by the solution to deep copy an object. 
**street, number, suburb** already inherit the parent **address**. Using this is simply incorrect syntax in this use case. You also want to pay attention the the use of **:** and **,** and not **=** and **;** inside of an object. 
Yes while I was trying to debug the problem it still didn‚Äôt work I just assumed due to the way the class constructor was working maybe that the syntax changed slightly. Either way the problem ended up being the ‚Äòthis.‚Äô Thanks for the response either way.
C'mon, that doesn't count. That's just inheriting from the base Object class, it happens every time you create *any* object.
Oh sure, I definitely used to do this before the `class` syntax was a thing. But this isn't really "inheritence", it's just a convenient way to write down a class.
That isn‚Äôt an ES6 issue, that‚Äôs just JavaScript in general . Object properties are what they sound like - just properties on the object you created (address) and can‚Äôt be anything fancy. 
fair enough. I'll delete this.
This is a nice example. I actually considered doing something similar recently when developing a Web Extension. There's a message passing system, but you can only pass JSON-type objects (so no methods). I was thinking about using this exact technique to be able to pass fully-fledged objects with methods.
You cannot deep clone with JSON.parse/ JSON.stringify
React only extends Component to ensure *new* can be used on, it's not for prototypal inheritance. [https://github.com/facebook/react/issues/4599](https://github.com/facebook/react/issues/4599)
Well, it was still an interesting point. No need to delete it.
So why put the method on the prototype rather than just the object?
I agree, trying to figure out how to get - - inspect-brk passed to a mocha test runner is something I can never remember and always have to look up. But, have you seen the module called ndb? I think it is fairly new. It is a module you can install globally, and use to start any node process (including one's called from a test runner or whatever) in debug mode. It also opens its own debugging window instead of having you open a special tab in chrome. I suggest you give it a look, it seems really slick from what I read and saw about it last week. 
What on earth; how did I not know about this? Been doing bracket-conversion debugging for over a year :(
Personal favorite since you can toss it into any composition: const tap = (wrap, fn =&gt; (...args) =&gt; { wrap(...args); return fn(...args); } tap(x =&gt; console.log(x), fn) Lodash has this implemented nicely. 
omg this is brilliant
The problem is that there's no "deep clone" functionality in JS... and if you ever try to write one you'll realise why. Spoilers: the weakly typed nature of JS combined with its use of closures and lack of copy-constructors means it's impossible for a function to *perfectly* reliably copy any tree of objects passed to it. All you can do is try to handle the most common cases (primitives, built-in objects like Arrays/Strings, etc) and hope that a solution that covers 90% of the problem is good enough for your particular use-case.
I was able to get a $5000 p/m salary working remotely as a junior front end engineer for a company in the US (I'm South African). I worked for them for 2 years. After those 2 years ended I learned I was immensely underpaid compared to my colleagues just because I worked remotely (even though my hours were the same, the work was the same, the responsibilities were the same - and I didn't get any benefits like the full time on-site devs did, and due to bad infrastructure in my country I had to do all this with the risk of a 48 hour power outage happening at any moment). Take /u/mostpretmen's advice - do not sell yourself short. Demand a higher salary. 
Yes i had a slider element that worked in the same way as the netflix slider does. Then i needed a version that centered a particular item, instead of adding more config options to the slider i created a subclass and overrode behaviour as needed
You can have "private" variables inside a JavaScript object by declaring them inside the constructor. You also declare and attach functions to the object properties in the constructor, so they will be able to see the private variable because they're under the constructor's scope, but nobody outside can see that. const MyType = function () { let privateVar = 'foo'; this.method = function () { console.log('The value of the private var is:', privateVar); privateVar = 'bar'; console.log('I changed it to:', privateVar); }; } const instance = new MyType(); instance.method(); There's no way to clone such an object *and* retain its state, the most you can do is instantiate another object with the same constructor or prototype, and copy the enumerable properties.
From the manual: &gt; An empty object is returned for uncloneable values such as error objects, functions, DOM nodes, and WeakMaps.
I'm wondering if it's possible to attach Visual Studio debugger to my browser to debug JS in it. It's just so damn nice to use.
I rarely use inheritance in dynamically typed languages. It's mostly to get types to fit in the type hierarchy in static languages like Java. However, sometimes it's useful. Like, if your building a UI component system, and you need some common code shared between different types. Whether it's prototypical inheritance in JS or classical in, say, Python doesn't really matter. Achieves the same effect either way.
I'm sure OP isn't talking about actually comitting this. They're just pointing out that when debugging, the latter option is quicker to type out.
I recently published more debugging tips using Chrome devtools. Can be useful. Check it out at [https://medium.com/@PrashantPalikhe/art-of-debugging-with-chrome-devtools-ab7b5fd8e0b4](https://medium.com/@PrashantPalikhe/art-of-debugging-with-chrome-devtools-ab7b5fd8e0b4)
I avoid console logs for debugging, but setting debugger; in the code is more handy than looking for the piece of code you‚Äôre trying to debug once again in the browser
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring
I haven‚Äôt used conditional breakpoints before! And you can use them as toggleable code, very clever.
Everything in javascript is a reference, which is why you simply should never mutate anything ever =p (Not seriously, but it should be exceptionally rare.) This would suck if it wasn't for object destructuring. Return { ...myObj, name: "New Name", }
You need to split the string using string.split() and inside the parenthesis the indexes in which you want to start and end the splitting. 
3 u/arktippr
u/georgeharveybone. You have received ` —¶3.00000000 ARK ($3.74 USD) `! [Check this transaction on the Ark blockchain](https://explorer.ark.io/transaction/0ef7c94ea87dff77e97fd4208fdd93a59a85dac4e731dc66238a455b34ee7561) --- [Use ArkTippr](https://np.reddit.com/r/arktippr/wiki/usage) | [FAQ](https://np.reddit.com/r/arktippr/wiki/faq) | [Ark.io](https://ark.io) | [Explore Ark](https://arkdirectory.com/) | [Terms of Use](https://np.reddit.com/r/arktippr/wiki/terms) | [r/arktippr](https://np.reddit.com/r/arktippr) Ark provides users, developers, and startups with innovative blockchain technologies. Point. Click. Blockchain.
console.log(stuff) || stuff Also works 
**react-simple-keyboard** \- [https://github.com/hodgef/react-simple-keyboard](https://github.com/hodgef/react-simple-keyboard) has been updated! react-simple-keyboard is an onscreen virtual keyboard for kiosks, web and mobile that focuses on customization and responsiveness. It's the React version of my other package, [simple-keyboard](https://github.com/hodgef/simple-keyboard). Feedback is welcome !
Rather than `--inspec-brk` I just use `--inspect` and a `debugger;` statement in the test I want to pause on
Did someone provide a linear-time solution that uses a third-party lib?
Until recently I would say attaching a debugger to a clustered app is pretty tedious but just heard about nbd a couple weeks ago that might solve that problem.
Sorry to be pedantic on this but wouldn't "closures" be a better term here instead of lexical scopes since "serialGenerator" is calling "next" outside of it's declared lexical scope?
It is. 
Cool. Would you happen to know how I would go about doing that? I can not seem to figure out the next step to keep the text persistent.
Even easier (assuming that "using a debugger" at all is easier, depending on what you're working on): right click in gutter, select "add logpoint" 
I think OP means, ultimately, if you default to using const x = (y) =&gt; (whatever); instead of const x = (y) =&gt; whatever; then it's easier to add a console.log() with a comma, then remove it later, without having to reflow it as a bracketed function with a return. 
If there‚Äôs a day where there is a message but no link, or vice versa, this will fail. Not clear if this is a possible case, but it would be safer to cover it. Better to have both iterations write to a single map keyed by day. Then convert the map to Array. Although keeping it as a map seems more useful, depends if look ups or ordered iteration is needed. Still O(n) for creation. Also could cover duplicates by adding to things already in the map. Interviews often look for cases like that.
‚ò∫Ô∏è
LinkCount is an array, you‚Äôll have to index into its corresponding day somehow.
You're absolutely right. And I definitely concede that this would be valuable for a quick test without committing.
Also, for bonus points, the iterations are really reductions. So first one reduces the messages into an empty map. The second reduces the links into the first map.
Why not just use a break point?
genius 
You are right I I forgot to add the index a.LinkCount[i].visits
Omg 75k/yr is a really good salary, but I don't know where to find jobs... Do anyone has some tip to find a remote job? I'm trying here on reddit...
 const str = "hey I'm cool" const shortStr = str.substr(0,5)
Wow, I actually learned quite a bit from that. Thank you!
Awesome! Thank you. I'm aiming to be a front-end web dev so JavaScript is really important for me.
Yeah, that's what I do. I look for other people's codes then understand it, then solve the problem with my own approach and when I make it work, its the sign that I did understand it but sometimes it doesn't feel good because I can't start on my own, I always look for that "push" from other people's effort in order to get an idea.
Thanks. I'll check that out.
**wordlist-password-generator** \- [https://www.npmjs.com/package/wordlist-password-generator](https://www.npmjs.com/package/wordlist-password-generator) Creates memorizable passwords based on words from a wordgames. *i.e* \- password would looks something like **lahs.guru-10**
FYI: &gt; Warning: Although String.prototype.substr(‚Ä¶) is not strictly deprecated (as in "removed from the Web standards"), it is defined in Annex B of the ECMA-262 standard, whose introduction states: &gt; ‚Ä¶ All of the language features and behaviours specified in this annex have one or more undesirable characteristics and in the absence of legacy usage would be removed from this specification. ‚Ä¶ &gt; ‚Ä¶ Programmers should not use or assume the existence of these features and behaviours when writing new ECMAScript code. ‚Ä¶ https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substr
It‚Äôs a backend thing having to do with how mongoose and the mongo driver interpret dates v date strings differently in aggregation pipelines in mixed scheme types
There's also [slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/slice) "hey I'm cool".slice(0, 5) // "hey I" Or regex (though overkill for something as simple as this) "hey I'm cool".match(/.{5}/)[0] // "hey I" Or maybe a loop if someone was like, "You can't use any string methods!". And you're all like "FINE! I don't need any!" const str = "hey I'm cool"; let first5 = ''; for (let i = 0; i &lt; Math.min(5, str.length); i++) { first5 += str[i]; } first5 // "hey I" or const str = "hey I'm cool"; let first5 = ''; for (let char of str) { first5 += char; if (first5.length === 5) { break; } } first5 // "hey I"
That does count, and in fact all inheritance in JavaScript is prototypal. There's always a chain of prototypes for your objects, and using a constructor function or the class syntax is using prototypal inheritance under the hood.
actually Visual Studio or VS Code? I know the latter can be attached, but the former is better.
Actual Visual Studio can debug JavaScript. 
Hi /u/dougieqwer123, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/RiceKrispyPooHead, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/I__am__dead, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Or just say it returns undefined, which is easier for everyone
JSON.stringify fails if there‚Äôs a circular reference.
That's probably not the OP's question; this is not about 'did I ever use it, maybe involuntarily and unknowingly', but rather about 'should I actively use it when writing code myself'. 
Yes but doing a Json.parse again gives you a frozen "interactive" version in the console. So you can collapse or expand nodes as needed.
Instead of pointing that out, you could have easily used the effort to explain how to set a conditional breakpoint instead. For those who don't know: https://davidwalsh.name/debugging-conditional-breakpoints 
A basic web server in nodejs. It's a mess... https://github.com/botdevteambdt/httpengine
That article is good, if you want another source on learning chrome Dev tools check out https://umaar.com/dev-tips/ It's hard finding good resources and tutorials on debugging it the various tools you use to accomplish it. I try to keep a list of them wherever possible.
I just finished adding [browser benchmarks to `bitcoin-ts`](https://github.com/bitjson/bitcoin-ts), which wraps WebAssembly versions of secp256k1, ripemd160, sha256, sha512, and sha1. Interestingly enough, if your use case involves hashing lots of small inputs (like many Merkle tree implementations), the overhead of `Crypto.subtle`'s Promise interface seems to make it much slower than equivalent WebAssembly implementations.
Problem with chrome breakpoints alone is you have to \*find\* the spots in the code to add the breakpoints. You're hunting through some awful tiny source code dump in chrome to find where to insert them. Versus being in your actual editor and just dropping in a console.log or debugger statement, far easier. And if you're using a transpiler or other build tool to produce compiled javascript, as many are these days, the source chrome sees is often just a huge concatenated file full of less readable code - very difficult to use as a first class environment to find and debug relevant code sections.
Fantastic article! Thanks for writing/sharing
**RBR - Role Based Rules,** A library for writing rules and permissions based on user roles. Github [https://github.com/jjohnson1994/rbr](https://github.com/jjohnson1994/rbr) NPM [https://www.npmjs.com/package/rbr](https://www.npmjs.com/package/rbr)
Pretty cool, in firefox you need this https://github.com/webcomponents/custom-elements
dude... just search in the dev tools for the line of code. Also, detach the debugger and fullscreen it alt+tabbing or desktop switching is not a tedious process for shifting between contexts (when you are only really focusing on one anyhow) Why do people make things sound insane for the sake of making their way sound better? Legit just open the source tab and do the ctrl+shift f (or ctrl+p to find the named js file) whatever the keyword for "search all" is in your OS of choice and find code near what you are looking for that is unique and ta-da. It's not some nightmare scenario. It feels only even slightly different from using your ide.
You just changed my life.
\*\*react-simple-translate\*\* \*\*github:\*\* [https://github.com/kwhitaker/react-simple-translate](https://github.com/kwhitaker/react-simple-translate) \*\*npm:\*\* [https://www.npmjs.com/package/react-simple-translate](https://www.npmjs.com/package/react-simple-translate) We use react-translate-component pretty heavily at my job, but we wanted something written in Typescript that targeted the latest version of React; so, react-simple-translate was born. It's a very straightforward library which will handle localization, string translation and interpolation. Any feedback is welcome!
Also interesting. I've always been looking for some more in depth tutorials for the chrome dev tools
Maybe just not even necessary given how similar it is to Keras.
Ok, so I just found out MDN disencorages the use of __proto__, says it "may" incur heavy performance penalties (though I'm not sure if that would occur if just using it to construct objects). I actually have seem the `__proto__` pattern on express code the 1st time. So one would mostly write const itemEnhanced = Object.assign( Object.create(itemProto), item ) 
Yeah! His tips are very helpful. I haven't paid for his course but every week he gives some decent insight into new/existing features in CDT. Definitely worth the newsletter.
Performance (reduced construction time). You reuse the same object for methods, instead of setting each key on every new instance (that happens on classes too). But JS performance is always a tricky issue to state anything. Non-obvious behaviour may happen with all those complex engine implementations.
Yeah, this on prototype automatically dont get serialized or enumerated (unless using `for in`)
I would understand the use case if the result is not just used for console.log. But I don't understand why would you copy the object only to console log. 
way better cos you dont have to add ( and )
The only problem with the chrome Dev tools is that I feel like I'm being punished when I have to go debug something in Safari.
Holy moly, I think I understand what this does but I am not sure. Are ...args the returned values from function fn, and you use this ...args as function parameters? I'm confused... 
eh. performant is in the eye of the performer. stringify can be extremely slow for big objects.
The code snippet is missing a closing parenthesis after the argument `fn`. `cb` and `fn` are arguments of the tap function. When you call that function, you are returned with another function whose arguments (`...args`) will be logged and then returned.
Hehe, sorry, I got carried away :D
Fantastic article! Thanks for sharing :)
You want to write down the logic on the paper first. If you cannot do that, then it's a problem. If you can do it, and have a hard time translating to the code, then it is a different kind of problem. In CS program in the Universities, that's how they teach the first semester programming course. Because you are taking a course in bootcamp style, they expect their students to pass the stage very quickly or have passed the stage already. 
The Coding Train channel on YouTube has many ML in JS videos. The host is a NYU CS instructor. Very very nice for the introduction. Since he is not a mathematician or ML practioner, there is something not correct about the theory, but his command on JavaScript is excellent. 
I wouldn't. Its like asking to change some answers on a test you took.
I think AngularJS implements scopes this way. IIRC this is now an antipattern and every scope should be isolated to only its component.
I provided a pure ES6 and third party lib that has O(nlogn) performance, linear time is impossible (though, your sarcasm isn‚Äôt lost). The answers I provided are hardly optimized in the sense you are referring. We go over list twice, we use higher order operators like reduce, etc. Some simple complexity analysis helps us understand that the initial data structure chosen was incorrect for the task‚Äîand clearly shown when our code got much simpler when using a more appropriate structure. The list implementation is harder to read and maintain.
Let's get wiggy with it. (Spoilers: I have no idea what "wiggy" means and just hope it's not offensive) ``` const str = "hey I'm cool"; const first5 = str.split('').reduce((substr, c, i) =&gt; i &lt; 5 ? substr + c : substr); ``` (don't do this)
What about \`stuff =&gt; console.log(something) &amp;&amp; stuff;\`? Easier to cleanup
Do you/does anyone know what those undesirable characteristics are? You can also use `.substring` which would be used identically *in this case, coincidentally* and does not have the same warning.
Elaborate.. I'm using chrome. 
Imagine up-to-date chrome/node can run ES8 so you don'e have to transpile while developing, even if you're coding in TS you don't have to mange the output, and it also supports global search though source files and can open files with ctrl+p
Both good movies imo
I hate react and angular.
Aliens wasn't great but yeah, both good. 
We've all been here, but never did this occur to me once. Kudos for sharing this!
There are legitimate reasons for using console.log instead of the debugger. What if that code path gets called 300 times but I am only interested in a specific one of them? A breakpoint would be painful, but in the console I will see immediately what I was looking for.
For a 'dumb' object sure, but if you're using this outside of logging, and your working with many hands on an app that's supposed to last, you might want to rethink this approach.
What framework deep copies like this? Does the framework tell users that they can only use said deep copy function on dumb objects? I think sustainability of a function is more important than speed. Do what you will on your own terms but if you're programming within a team I'd cringe if this was encouraged without at least acknowledging it's just jank code.
Oh right, I don't mind them all, I'm an easy to please space film guy
Feature of VSCode 
Does she live in Seattle or Silicon Valley? Where I live (not a big city) all the job postings seem to say 4 years of CS major or equivalent experience. What kind of lessons did the owner of this account give to you? Also did you learn HTML CSS and Javascript only or some other things too? 
Do you know about conditional breakpoints?
She isn't here atm but I'll answer in her stead. We live in Houston TX. It's not a giant tech community but I referred her to my company, she probably wouldn't have gotten in otherwise. I'm guessing your town probably has a similar job climate. Apply to the job that say 4 years of CS anyway, worst case they don't say anything. Me and some of my friends taught her enough HTML, CSS, JavaScript, React, and CS fundamentals to be dangerous. We just planted her in our office and gave her a list of things to learn. We were available 24/7 to tutor her when she got stuck l, but she managed. Hope this helps.
Let them know about the changes and make a PR or something for the push if you're concerned. It's not going to hurt your chances, only increase it.
in other words function tap(cb, fn) { return function(...args) { cb(...args) return fn(...args) } } function adder(x, y) { return x + y } const result = tap(console.log, adder)(2, 4) // &gt; 2 4 console.log(result) // &gt; 6 // or const printAdd = tap(console.log, adder) console.log(printAdd.toString()) // function(...args) { // cb(...args) // return fn(...args) // } const newResult = printAdd(2, 4) // &gt; 2 4 console.log(newResult) // &gt; 6 
Not yet...
Any asynchronous call should be done with a promise. The most common usages are for making HTTP requests. 
Because it blocks application execution. It works if you're ok with that; depends on what you're after. In OP's case, looks like the code was "finished" so it sounds like interruptions by the debugger would not have been ideal.
Oups, I forget this example yes, it's so logical haha... Apart from this example, we use everyday at work do you have some other explicit example ? 
If I had to guess, confusion with `substring` is what would be wrong with `substr`. They're so much a like in name but the difference in their behavior (length vs indexEnd for second param) could cause for some problems. In fact this is one of the reasons why I prefer `slice` to either of them. 
Communicating with a database userRepository.findOne(1).then(...) If you're calling some native library (inside node) that will run in a separate thread crypto.hash('md5')('hello').then(...) importing a module with the new import syntax let module = await import('/modules/my-module.js');
No
&gt; ndb Link for the lazy: https://github.com/GoogleChromeLabs/ndb
If they're bugs, do it. If they're not, to me it feels like you're saying that you can't finish a project and will just keep tweaking it, even after you've given it to QA.
Wait how does a Canadian passport help? Or are you, just stating Canadian citizenship would be a nice alternative to EU citizenship? (Wondering as I am from Canada)
I gotta spend some more time on that. The built in debugger debugs a copy of the source code, due to perhaps some web pack chunking shenanigans. 
Someone comment so I can have an opinion
You could also use `.slice()` for an array of primitives, which seems a little clearer to me?
Thanks! i was told to create something from a mockup. Finished it all including the bonus parts ahead of time. They gave me a week but I did it in 4 days. Then today i was just looking at everything and found 1 little bug and also did minor style fixes. So made that change and then decided ok shall i push this or not. Before the change, it looked and worked as required..after the change you can barely notice the difference, but there is a slight difference - but no difference in functionality. So I plan on pushing it because i feel like this shouldn't hurt my chances? the job i am auditioning for is ui engineer and they would expect things be done in detail no? either way this has been a great first time experience lol
And of course, using JSON parse/stringify won't handle those cases either. It will, for example, omit function properties, or properties whose values are `undefined`, entirely.
I work for a large software consulting company and I work with both. Lately, our clients have been requesting Angular, but I enjoy working with React more and try to pitch that instead... I usually lost that battle.
Exactly, yeah - decomposing an object to a string and then reconstructing it is pretty much the worst way to clone an object... although it has the advantage that it's very fast to implement and it works well enough for *most* cases (where the objects are all just plain objects/arrays/primitives with no hidden/closured-in internal state).
I work in enterprise and it's very popular. Lots of migrations planned from silverlight to Angular.
Nice.
Looks like your pen is using an older version of marionette that doesn't support everything you're trying to use.
Man, I have the exact opposite problem. 
yes you can, I'm talking about data objects.
I prefer ``` const log = (...args) =&gt; console.log(...args), args[0] const example = (stuff) =&gt; log(stuff) ``` this way, it's easy to see the 'log', and fast to remove. In production, replace the log function with an identity function
&gt; Does the framework tell users that they can only use said deep copy function on dumb objects? It just comes up when you are programming something. You have some data packed in an object, and you want to pass that object **by value** (and not by reference) to a method, to another object etc. What do you do? You run it through this code. It is the canonical way to do it in javascript. With JS, the terminology is a bit vague, when I'm talking about cloning objects, I'm not talking about saving the state of an object with its own methods and internal state. I'm talking an "object" of key value pairs, which can have nested objects, arrays and other types included within. Sometimes you need a deep copy of it to pass it by value to somewhere to avoid mutating the original object in the target, and stringify / parse does it most efficiently in the case of JS. This is not jank code, if you need to pass a data object by value to somewhere, this is how you are supposed to do it in JS. It is readable, and any programmer in any team that is experienced with JS will know what it is upon seeing it. 
I use this one all the time, but I always cringe a little when I do. I think I will start using OPs version.
If it doesn't meet the brief, then yes, you should submit the update. The risk is that if they don't know the problem, you would point it out. But if they do risk the problem, they'll probably be thinking less of you for it. IMO, it's better to admit the problem and fix it. It shows attention to detail and honesty.
These both add the same number of characters.
How is it quicker? It‚Äôs the same number of characters. 
*MLP Implementation using Tensorflow JS* https://github.com/bolt12/mlp-tf-node
I have never encountered this as advised. I'd really appreciate any articles or sources you might have on hand that discuss this as an accepted practice. You do you by all means, if it works it works, I'm certainly not trying to undercut my conception of you as a programmer, I just seriously thought that this was ill advised , along the same lines of using eval in production code.
Absolutely! I use both, but with some small objects I want to just glance at them to check they're behaving as I expect. If there's only a small amount to expand, and I don't want to write a custom test for it, this is a quick way to do it. 
I've worked with Backbone and Marionette, and one of our apps still uses them heavily. My honest advice: don't bother learning them. Go learn React or Vue instead. Backbone was useful in its day, but React (and Vue) are just fundamentally better approaches for writing web apps.
I did some simple stuff with cycle a while ago but struggled some concepts that would be simple to describe in a normal, non-stream, and mutable world. Personally I didn't see enough of a benefit in sticking it out to go all in on the tech so I switched back to react/vue/vanilla/etc.
Protip for the future, don't delete comments just because you are wrong. Someone may have the same question in the future and now that the original one isn't in the thread it will be repeated over and over.
Not good. I want to see you commit and defend your choices. I don't want you to seek my approval. I have too much shit going in
appreciate the 2 cents.
The comment wasn't wrong. It was an answer to a different question. The question was about prototypal inheritance and my comment was about prototypal constructions. Analogy: he was asking how to mill your own cake flour and I explained how to bake a cake. I am pissed at myself for skimming OP's question and the answer contributed really not much at all.
love it! `console.log({stuff}) || stuff;`
That... is not right. The Component constructor sets this.props (and I think freezes props as well?). 
Sounds like you might want Next, which Nuxt is based on. 
Here in Germany there are a lot of Angular jobs. Besides Angular I'm using ASP.NET Core. I have to say that Java EE seems to be more popular than ASP.NET Core.
So I tried **Next** with this code: &gt;const express = require('express') const next = require('next') const dev = process.env.NODE\_ENV !== 'production' const app = express() const server = require('http').createServer(app) const nextApp = next({ dev }) app.use('/static', express.static('static')) app.use('/\_next/static/commons', express.static('.next/static/commons')) app.use('/\_next/-/page', express.static('.next/server/bundles/pages')) nextApp.prepare().then(() =&gt; { app.get('/', (req, res) =&gt; { nextApp.render(req, res, '/') }) server.listen(3000, err =&gt; { if (err) throw err console.log('&gt; Ready on r/http://localhost:3000') }) }) then it gives me these errors on the browser:
Here's a sneak peek of /r/http using the [top posts](https://np.reddit.com/r/http/top/?sort=top&amp;t=year) of the year! \#1: [my new dog.](https://i.redd.it/wb1ocujnqmqz.jpg) | [2 comments](https://np.reddit.com/r/http/comments/752jyz/my_new_dog/) \#2: [Cracking the Lens: Targeting HTTP's Hidden Attack-Surface](http://blog.portswigger.net/2017/07/cracking-lens-targeting-https-hidden.html?m=1) | [0 comments](https://np.reddit.com/r/http/comments/6qbpf7/cracking_the_lens_targeting_https_hidden/) \#3: [aye join me if you dare bet i beat u skrubbeths](https://gartic.io/05aOn) | [0 comments](https://np.reddit.com/r/http/comments/8uov9r/aye_join_me_if_you_dare_bet_i_beat_u_skrubbeths/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
You read a lot. We like that. You‚Äôve reached the end of your free member preview. Upgrade for unlimited access or sign in. That kinda sucks :(
https://stackoverflow.com/questions/19059580/client-on-node-uncaught-referenceerror-require-is-not-defined On a side note I'd say always use semicolons, don't always trust JS to figure out it for you, sometimes it will break the code. 
Spambot pls ignore
I've seen either way work. Just show that you aren't expecting that they'll definitely consider the changes as part of your submission and you're okay if they don't.
I got an example code from [here](https://github.com/zeit/next.js/blob/canary/examples/custom-server-express/server.js). Thank you very much!
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [zeit/next.js/.../**server.js** (canary ‚Üí 7282f43)](https://github.com/zeit/next.js/blob/7282f43f7b934c14976e68181a0523a680062a62/examples/custom-server-express/server.js) ---- 
Please read the [addEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener) and [deviceorientation](https://developer.mozilla.org/en-US/docs/Web/Events/deviceorientation) documentation. 
We need more specific details. What format is the email in? Where is it located? What environment do you plan on using to achieve this?
For this kind of thing test where there is an actual possibility of inputs being garbage/wrong. There should be some level of confidence in most of your system about parameter values. If not you're probably doing something wrong.
If you're having that issue with transpiled code you can usually solve it with sourcemaps. Webpack has always had it
Lots of If statements lol ü§£
If your account is on gmail, google's explanation looks really good. https://developers.google.com/gmail/api/quickstart/nodejs
I don't think so. Douglas Crockford (who wrote the book) also wrote JS Lint with the same principles. Later "strict mode", and ES6 disallow a lot of the parts of JS that he describes as "the bad parts", and modern linters similarly guide away from those to the good-parts. In 2018 much of what the book instructs you to avoid is simply forbidden by using a modern toolkit. Now it's mostly valuable as a historical relic of a more primitive time.
It is a nice alternative. The Canadian passport is one of the strongest passports. You can go wherever you want. Believe it or not passports such as mine are problematic when it comes to traveling. For example, to travel to UK, USA, Canada and Ireland I need to get a visa. I can almost travel freely in Europe, but only up to 3 months. As a result, I can't live in the country that I want and start my life there. I am stuck here, unless I have enough money to invest or get a work visa from a company. This world is not that open I guess...
Figures. I was an IT contractor for a big bank once upon a time. They had some cutting edge tech for the stock trader guys, but the more run-of-the-mill guys had some really ancient shit. This was around 2005 or so, but some offices were still using green or amber CRT screens. I even saw a mechanical check processing machine that looked like it was built in the early 70s. It was about the size of the President's desk in the Oval Office, and hella loud.
https://www.highcharts.com/docs
Anyone has more efficient (good) way to debug publish/subscribe or observables??
Is the e-mail uniquely identifiable? The flow should be: - Fetch inbox - Locate uniquely identifiable e-mail through iteration - Parse E-Mail content - Make logical decision on what next step is. 
Nice resource! &gt; One simple rule: "Design and code with performance in mind" ... but optimize for maintainability first.
I would say do your eyes a favor and never use semicolons.
Current jobs by city |City|React|Angular| |:-|:-|:-| |Berlin|[756](https://de.indeed.com/Jobs?q=react&amp;l=Berlin)|[434](https://de.indeed.com/Jobs?q=react&amp;l=Berlin)| |London|[3189](https://www.indeed.co.uk/jobs?q=angular&amp;l=London)|[1552](https://www.indeed.co.uk/jobs?q=angular&amp;l=London)| |New York|[3117](https://www.indeed.com/jobs?q=react&amp;l=New+York)|[1066](https://www.indeed.com/jobs?q=angular&amp;l=New+York)|
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://de.indeed.com/Jobs?q=react&amp;l=Berlin) - Previous text "756" [Here is link number 2](https://de.indeed.com/Jobs?q=react&amp;l=Berlin) - Previous text "434" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Natural language processing
Thank you for your reference.
Sorry it wasn't the right link either https://www.highcharts.com/maps/demo
Any recommendations for a more recent comprehensive book that would cover idiomatic JavaScript, design patterns, best practices, etc.? I.e., something for someone familiar with programming, but not JS.
I would skip it and go for the "You don't know JS" series, free on GitHub (but you can also buy it to support @getify) https://github.com/getify/You-Dont-Know-JS
Delete post, this is a bot copying old posts to try and rack up karma 
Thanks for posting this. I really appreciate information formatted like this instead of having to pour through an article to find what I'm looking for.
Yes, and...?
Jesus fanboys are so fucking boring...
What's your devtool setting in your webpack config?
Getting a book from 2011 in 2018 is generally a bad idea in the JS world. And this particular book is a bit misleading, since most of the content has to do with manipulating the DOM. I would send it back and get something more modern.
You are not going to get very far with generic questions like this...
Well, you DID write it wrong...
I don't get the joke "... that runs faster than the others", would anybody kindly explain?
It means "I want my 5 mins of an Internet fame".
REAL coders stack their if statements in the hundreds and never use &amp;&amp;
So how do you find this breakpoint to set in a huge react bundle file during development for example? You have to keep opening bundle.js in the resources tab and search for the function name and hope to find it in 20000 lines of code?
This is what I was looking for.. Thanks a lot :)
This is real help :P Thanks :)
A Node.js stock predictor using a Neural Network and Alpha Vantage training data GitHub: [https://github.com/blakesanie/Stock-Predictor](https://github.com/blakesanie/Stock-Predictor) Youtube: [https://www.youtube.com/watch?v=KcroXid645k&amp;t=0s](https://www.youtube.com/watch?v=KcroXid645k&amp;t=0s)
Why are people using Github as a personal blog platform?
Where are you selecting the element? You need to select the element when the value changes, which means you need to use the `onclick` event on your radio inputs.
&gt;It looks like you didn't get thge points from article. &gt; &gt;Yes, I can use additional signin key. But in that case, I have to fetch that key from db for every request. This negotiate benefits of JWT. We like jwt because we don't have to fetch anything from external storage at all. &gt; &gt;Same aplies to the idea of storing only user id in token. That't just reimplementation of 'slow' sessions. &gt; &gt;Also, you can't use base64 to cut the space. The main purpose of base64 is encode binary data as text. Using base64 oppositley will increase the size. Take a look: &gt; &gt;{"hello": "world"} = 17 symbols. &gt; &gt;base64 encoded: eyJoZWxsbyI6ICJ3b3JsZCJ9 = 24 symbols. 
Because they‚Äôre pushy 
What if company rules didn't allow any external contributions? One additional point: if I accept the idea of not storing passwords in vcs, than I have to store them somewhere accessable for other team members. And that place is probably will have same vulnerabilities as vcs itself. So, why complicate your life?
&gt;We had to import and register all the valid values for the `:is` prop. We had to import and register `UserInfo` and `CompanyInfo`. &gt; &gt;Only if someone allowed us to dynamically import all these components on the fly so we wouldn‚Äôt have to import and register them‚Ä¶ &gt; &gt;‚Ä¶oh wait! &gt; &gt;Did you say ‚Äú*dynamically import*‚Äù? The author skips a step there. You can also just do this to reduce the registering of components: &lt;script&gt; import UserInfo from './components/UserInfo' import CompanyInfo from './components/CompanyInfo' export default { props: { isCompany: { type: Boolean, default: false }, }, computed: { componentName () { return this.isCompany ? CompanyInfo : UserInfo }, }, } &lt;/script&gt;
I've used it. Architecturally, I find it _superior_ to others. This, however, does not always or necessarily translate well into a "this specific particular thing is easier to do this way than with React". It has a larger, but more generic reach. _In the large_, I think it is a better solution. That is, it _generally_ results in cleaner, less _hacky_ code, better structured. On the other hand, it _is_ true that it needs a change in perspective / mindset. And while I understand React team's intention of keeping it _familiar_ or _beginner-friendly_, I just don't think Cycle's model and concepts are in any way _more complex_, just different. In fact, I think Cycle is _simpler_ if anything. So the main obstacle is not complexity at all but unfamiliarity. And I know, yes, that may be an obstacle for many. (It probably why Cycle has gained much less traction than React) About the react-cycle bridge... Well, I'm not _that_ interested in it, but clearly it's a pragmatic concession. React is, today, the popular thing. Having an easy road to integrate with it is understandably desirable.
This article might help a little: **I created the exact same app in React and Vue. Here are the differences.** [https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd?source=collection\_home---6------0----------------](https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd?source=collection_home---6------0----------------)
We use promises to represent the _success_ or _failure_ of some _thing_. Usually you see them for some _asyncronous_ thing but they can be used for any _thing_. For example, let's say that you want to pass around the `sum` of two numbers. We could use promises: ``` const num = 2 const sum = (a, b) =&gt; new Promise((res, rej) =&gt; { res(a + b) }) const promise = sum(num, num) const double = num =&gt; num * 2 const doubledPromise = promise.then(double) ``` Now, `promise` _contains the result of a + b_. Now we are free to treat the value `promise` _as if_ it was the result of `2 + 2`. We see that we can "pass" that value around when we create `doubledPromise`, which is a Promise of the value `(2+2) * 2`. Bringing this into the "real world", let's replace `a + b` with some sort of `async` call: ``` const getUser = () =&gt; fetch('api/users/1').then(x =&gt; x.json()) const promise = getUser() ``` Now, instead of `promise` being a Promise that wraps the result of `2 + 2`, `promise` is a Promise of the _fetching_ of data. Just like we could pass around `2 + 2` and use it _as if it were resolved_, we can pass around the `user` response _as if it were resolved_. The whole idea behind Promises is that you can say "This _value_ represents _something_" and treat that _something_ as a First-Class Value. 
Oh shit! That one sentence you said has completely changed the way I code. You must be some sort of a wizard or something.
Why not? People use GitHub to serve websites. That‚Äôs a supported feature. Why would blog posts be verboten?
What if one dev gets hacked? Also the backend guys still have access to secrets they dont need / should have. As for storing secrets there are solutions like hashicorps vault. No need to complicate your life. 
Nice one
Hi /u/l33t_supa_h4x0r_, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/LowerCustomer, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
A few quick thoughts: you can use Ajax (or an npm library like request) to ask your server for data after the page has loaded. That said, how complex is the function that finds the route? And are you saving the routes, or is it ok to recalculate them each time someone looks at it? If it's not huge and you're not saving them, you might considering doing everything on the front end. 
If you use Gmail, check out Google App Scripts. 
I agree with optimizing for maintain ability first but I have a coworker that is adamant about performance first, maintainability and readability be damned. Do you have know of some resources online that talk about that balance I could direct them to?
&gt; The annoying thing was that, even after both frameworks being in existence for the past four years, I couldn‚Äôt find anything that tackled this [TodoMVC.com](http://todomvc.com)?
I think he meant a comparison like this? Don't take my word for it tho'
It's free, easy to use, fast, and familiar to the audience.
I'm not super new to /r/javascript and I've been here for a while. But what surprised me when I started it was this post. It is considered now as a serious post of the subreddit, but is it really a serious post and useful to people or it's just a troll that eventually was found on my feed on a Sunday morning?
You could just pass this post if you don't have anything that is related to my question.
Out the gate with an error. React apps usually have css in the component. Having a separate css file is allowed, but it's not truly the "react" way. These things shouldn't be done by someone who just knows one framework, and slaps together the other one. It should be two developers, each specializing in one of the frameworks both making the same thing. And react is much more of a coding style than a framework. This article mentioned it a bit, but far less than I would have liked. React looks weird until you understand the "whys" behind things. 
Build some very fast code that's unreadable and have him peer review it
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/amaaggregator] [How I made and released my first big React Native app. AMA.](https://www.reddit.com/r/AMAAggregator/comments/92vwe6/how_i_made_and_released_my_first_big_react_native/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
&gt; Having a separate css file is allowed, but it's not truly the "react" way. What on Earth? Attacking the style because the CSS is in a separate file? I've been writing React professionally for over 3 years and never wrote an app that uses CSS in JS. I always use separate files.
The writer uses create-react-app which uses separate CSS files for each JS component. Can hardly fault them for this, given its the defacto React CLI.
I'm not quite sure if my class conventions are right, I'm not familiar with OOP implementations in JS so I'm looking for tips that can help make my implementation usable by others. It's not very robust I am aware of that but I'm very proud of it! Thanks in advance!
`styled-components` is life-changing. Seriously. Even `CSS-Modules` doesn't come close. 
You know what, you were right all along. Since last time I checked, this practice is abandoned it seems, and a proper recursive copy performs much faster. Actually parse / stringify combo is the slowest since a couple chrome versions ago: https://jsperf.com/deep-copy-vs-json-stringify-json-parse/5 Thanks if it wasn't for you I wouldn't look into this twice.
I‚Äôll never understand why all these comparisons never include async behaviors. It‚Äôs complexity layer that basically every web app is going to have to deal with, and should absolutely be part of evaluation criteria.
&gt; react is much more of a coding style than a framework what...what do you think a framework *is*?
&gt; And react is much more of a coding style than a framework. It is neither a coding style, nor a framework. It is just a view library. Why is that so hard to understand?
Use both daily, they both have their trade-offs
What's your opinion on Vue vs React on that topic?
Vue and React don't handle asynchronous behaviour natively. We gotta rely on third party libraries 
[https://changebot.app/](https://changebot.app/) \- Automatically generate [CHANGELOG.md](https://CHANGELOG.md) from your GitHub project's commits, issues, pull requests, &amp; tags. Previously wrote [https://github.com/ericclemmons/github-semantic-version](https://github.com/ericclemmons/github-semantic-version), but found that a 1-step manual release was the sweet spot.
Couldn‚Äôt you just handle asynchronous events with promises/callbacks/async await? 
In addition to the low overhead cost, I bet collaboration is probably a factor. If he wants to keep this resource up-to-date long-term, then pull requests will be a helpful way to accept changes from strangers.
It seems like the author is trying to foster collaboration and long-term stability. PRs are one of the most accessible collaboration tools for developers, so Github seems like a good choice‚Äîas opposed to blog platforms, which generally capture one person's perspective in one moment.
&gt; this.$parent.$emit &gt; &gt; this.$on FYI this is an anti-pattern and you should avoid $parent like the plague. And if you are inclined to use $parent you may as well just call methods directly instead of using the event system. See https://vuejs.org/v2/guide/components.html#Sending-Messages-to-Parents-with-Events
As someone who has said something stupid in this sub and had their ass handed to them, I suggest you carefully read through some of these comments.
Or you could just emit the event yourself and let the parent listen to it itself.
I completely agree with you, I don't understand these downvotes. I wouldn't use most of these patterns in the react app. This is what happens when you dumb down the tutorial for teaching purposes and it's taken literally. 
https://material-ui.com/customization/css-in-js/ I understand where you're coming from, but times have changed from 3 years ago. 
bummer, serialize, deserialize via JSON is lossy too.
A framework provides functionalities/solution to the particular problem area.
Instead of taking an MVC approach, Just serve raw JSON from your server. You can then deploy your front end separately and use ajax requests to have it communicate with your backend. This gives you flexibility because it decouples the way your app looks from the way your app functions. This is what your stack might look like: MySQL &lt;-&gt; Node &lt;-&gt; Create-React-App / curl / a mobile app / etc
Slightly oofffff topic...but I think Vue‚Äôs method for code splitting is phenomenal. I just wanted to state that, though to be honest it‚Äôs mostly down to the power of Webpack. 
The general idea is that writing "optimal" code is more difficult to do in a timely and readable manner and the optimization might not even be necessary. This costs the business money and burns away development hours that could have been focussed on improving the quality of the aspects that provide more value. These ideas align neatly with Agile and eXtreme Programming. Of course, it all depends on whether the performance requirements are known, realistic and measurable. A popular adage is "Premature optimization is the root of all evil". It was first explained in [Donald Knuth's Structured Programming paper](http://web.archive.org/web/20130731202547/http://pplab.snu.ac.kr/courses/adv_pl05/papers/p261-knuth.pdf) from 1974, page 268: &gt; There is no doubt that the grail of efficiency leads to abuse. Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We *should* forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%. A good programmer will not be lulled into complacency by such reasoning, he will be wise to look carefully at the critical code; but only *after* that code has been identified. He talks more about this in his [Computer Programming as an Art speech (1974)](http://www.paulgraham.com/knuth.html). Keep in mind that the above quote stems from a time where higher level languages were not as available or powerful as they are today. A more modern take on this is found in Kent Beck's UNIX-inspired mantra: "Make It Work, Make It Right, Make It Pretty". You can see the foundation of the TDD-concept of "Red, Green, Refactor" in this. All this has been repeated, in other words, in[ Nathan Marz' post "Suffering-oriented Programming"](http://nathanmarz.com/blog/suffering-oriented-programming.html): " First make it possible. Then make it beautiful. Then make it fast." Furthermore, [Do The Simplest Thing That Can Possibly Work](https://www.artima.com/intv/simplest3.html), [You Ain't Gonna Need It](https://martinfowler.com/bliki/Yagni.html), [Prevent Gold Plating](https://blog.codinghorror.com/gold-plating/), [Optimize Later](https://codecraft.co/2012/08/28/a-quibble-with-martins-optimize-later-notion/) and [Profile Before Optimization](https://martinfowler.com/ieeeSoftware/yetOptimization.pdf) are ideas that have been expressed many times. In general, I would recommend the following books as they touch on the subject: * Steve McConnell - Code Complete * Martin Fowler - Refactoring * Kent Beck - Extreme Programming Explained * Dave Thomas - Pragmatic Programmer * Robert Martin - Clean Code
Rectal Suppository GUIs.
I wasn't keen to start with, then I started reading &gt; Some changes are happening with Dojo. As the project continues to stabilize around a set of modules and APIs, we are continually evaluating feedback from the community as well as our processes. I.e. = it's not stable yet. &gt; First things first, when we released the next generation of Dojo, we wanted to strongly disambiguate between the legacy Dojo toolkit by naming it Dojo 2. Now that we have released Dojo 2 and are moving on with further releases we are going to drop the version number, and from now on we refer to it as Dojo. Yep. Not stable yet. &gt; Also of note during the Dojo 2 cycle, we identified that pain points were going to become bottlenecks and affect the momentum of the project. Central to these issues was the complexity of managing the eight projects that make up the basis of the dojo framework Nowhere near, in fact. 
I hope it works without the parentheses because if not, then you are literally using the same number of characters as your "tedious" conversion. You are simply replacing { with ( and ; with ,
No, a framework is a particular way of structuring code. That‚Äôs it. What a framework can *do* is provide a solution to a problem, but that‚Äôs not what you said.
Div element with a click handler. If only there was an HTML element that works like a button or link.
All the more reason to include it. Glue code at the edges of the system is usually where there is least hand holding, and where non idiomatic code/crappy hacks can creep up from
Why do you bundle during development?
sounds like a frustrating bump in the road. it may be you need to look at generic programming concepts, like loops conditional etc, ui work also always takes you into callbacks and \`this\` related things that are not entry level so you may be hitting some advanced topics. js is a great cut n paste lang and i find most questions exist on stackoverflow. especially things related to beginner frustrations, you get generally good answers AND explanations so it builds your knowledge too. keep at it, it'll come together.
When would you use css-modules over styled-components? I also use both, and I've found that css-modules, even with careful coding, inevitably ends up a mess that becomes difficult to refactor, especially when components grow in size and need to be broken up. I've also found that multi-line css wizardry (e.g. custom borders, grid setup, etc.) self-documents much better with styled-components and prevents you from accidentally relying on implicit cascade (which can still happen with css-modules within a module).
[In computer programming, a software framework is an abstraction in which software providing generic functionality can be selectively changed by additional user-written code, thus providing application-specific software. ](https://en.m.wikipedia.org/wiki/Software_framework)
That is quite deep.
Yeah, that‚Äôs a fair point. Even Redux doesn‚Äôt handle async out of the box, and there are at least four mainstream options to incorporate it. I just feel like it‚Äôs disingenuous to say, ‚Äúlook how easy it is!‚Äù when we only tackle the easy parts. I‚Äôm probably asking too much, but I want to know what happens when apps get big and scary and start doing a lot with many interconnected pieces. These are the things that I usually spend my time on and keep me up at night. Writing a simple sync component is not.
Wow thank you SO much! I really, really appreciate the detailed answer!
I use this exactly, and I still put the JSS in another file and just import it. Code splitting is not a bad thing.
Elm :) To answer seriously, I do less frontend now, but I did a lot of React+Redux+Redux Loop, and we were able to make some complex apps that stayed manageable as new features were added‚Äîbut we did hit a number of hard to solve problems along the way. I haven‚Äôt used Vue, so I unfortunately can‚Äôt offer insight.
SCSS has performance benefits that we take advantage of. We try and keep CSS in JS limited to things requiring specific theming between brands that needs the benefits of being dynamic. We allow our scss modules to do the heavy lifting for the rest of the page.
What do you mean? Webpack dev server creates the bundle during development.
I believe transpilation in some form is the future. Developers can write improper code, and transpilers will make it correct. Write ES6, get IE6 compatible output (as an example, there won't be demand for this, so likely not this level of compatibility). I think this applies to JS, CSS, and HTML too. Cross browser won't be a concern, and likely even on-OS, the way Electron is doing. I have no evidence of this being the future. Just my belief. Maybe the next 20 or 30 years, but could definitely just be a pipe dream.
I think the real differences start to appear with complex things like routing, transitions, state managing and refactoring. Scratching the surface just isn't enough.
I meant what I said, you don't need everything bundled during development. Webpack only does whatever you configure it to do
This is useful in some cases, but I don't know why they keep describing it as idiomatic ‚Äì this is not idiomatic Vue. The first version is idiomatic Vue ‚Äì that's why you see code written that way everywhere.
Cool! So we can use builtin crypto.scrypt / scryptSync It doesn't matter what algorythm will be choosen until it considered as 'safe', but IMHO, what really matters here is ability to build / install packages on old systems. I.e I saw RHEL 6.9 with 2.6 kernel in some company as 'standard linux distro for vm's'. And this boxes can't build a lot of external modules because it have too old compiler. So, i'd better stick with builtin implementation than external binary module. 
Okay, now try to do the same app in pure vanilla JavaScript. 
Unless I misunderstood, I think this misses the point. The idea is that you **don't** import the components statically. You're trying to avoid repetition. You can dynamically import components without "knowing" what they are. The example is very basic and shows 2 component options. But what if you have 5? 6? And you are adding more? You have to add the import manually, and register it. The article is showing a method that doesn't require you to do anything, providing that the component already exists. Keep your code DRY! üòä
thanks for the thoughts! yea thats a good point. React is "just javascript", Cycle is "xstream + javascript". that is maybe the biggest sticking point.
Reading The Good Parts made me a much better coder. I‚Äôm not the only one. It went a long way in maturing JavaScript as a language and the community. These days, it‚Äôs a lot less relevant I think, because a lot of what it contains is so prevalent that we don‚Äôt really use ‚Äî and perhaps more importantly, we don‚Äôt really teach ‚Äî the bad parts as much anymore.
It will *almost never* break your code. It‚Äôs almost entirely a matter of preference, especially when nearly everyone uses a linter in their workflow, and people need to just accept that and do their own thing.
&gt; You have to add the import manually, and register it. And I am trying to show that you don't have to register it. There are two differences between version 2 to 3: - not registering components - adding async import I am just pointing out there are two differences, and that async import is not the solution to reducing the amount of registers. 
When you say avoid $parent like the plague, do you mean just in vue, or in general? 
I don't know what other libraries you are thinking of when you say "in general", but if they work similar to Vue and React (where communication happens through props and events), then yes, in general. 
Doesn‚Äôt Babel do this already?
So they are the exact same thing?
- in both case, it is Webpack or any package bundler that covers lazy loading - Comparing state management would be down to a comparison between redux VS Vuex ( though using redux with vue is a perfectly reasonable option IMO. - HTTP request would be covered by external libraries (Axios? Fetch?) My point is, it is not of the component library responsability to manage those topics. 
I would also really love to have these parts included for the same reason. Angular (which I'm most familiar with) has observables, which is the main way to handle async behavior. However it also comes with its own pros and cons. In angular the main pros of observables are in my opinion the following: * reactive updates (so if I create a stream (a) that depends on another stream (b) and the stream (b) emits a new value, a new value will automatically be calculated, unless I explicitly opts out of additional results. We use this at work for easily combining configuration updates, language updates, user authorization changes and query parameter changes, so if one changes we just magically fetch new values, without actually having to create event handling for all that) * the async pipe makes it extreamly easy to write network results to your templates, and update templates when values changes. * multiple result values (useful with websockets for example) Cons: * loading indicators often requires some sort of "hacks", with Boolean behaviorSubjects and hooking into the stream. * streams can sometimes not trigger the change detector in weird ways, so if you are not careful, the component might not pick up that a value has changed (which leads to requiring the above mentioned behaviorSubjects instead of just a plain boolean)
If your site is so convoluted it slows a modern browser, performance enhancements aren't going to help you.
Is it more convenient or has more features than tween.js?
I think the thing that's nuts about programming, and even language in general, is that we all take for granted stuff that is handed down to us or just happens to enter our circle and we just use it because it's just flat out useful. I'm totally a mixed bag of knowledge, I definitely don't have a clear idea of best practices at any given moment, and even this one had me questioning my real knowledge about it. And ultimately the questioning is always good, that's what I'm starting to reside my confidence in. Cheers, and glad we had a good spar!
I didn't know that place exist, sorry.
It was inspired by Tween.js. Our main goal was to enhance its functionality and rewrite in ES6 (in tween.js you have to use regular functions to access value from ‚Äúthis‚Äù, while in between.js you can simply use arrow function and get value from first parameter). Some other features: - loop mode (advanced, you have repeat/bounce options) - Color tweening that supports multiple color fromats (hex, hsl, rgb, ...) - Intorpolating just between numbers, while in tweenjs they should be objects The library is on its early stage and we would welcome any contributions and support!
Another reason: the github domain isn't gonna get banned/blocked for mass submissions
Hm not sure what you mean, I used create react app &gt; eject. It's setup to bundle one file for development.
Great resource. It looks like the author has actually created 3 lists for web developers, one of them has 20k+ stars on GitHub. Here's an overview of them: [https://levelup.gitconnected.com/3-essential-front-end-checklists-for-web-developers-d873b226b1f0](https://levelup.gitconnected.com/3-essential-front-end-checklists-for-web-developers-d873b226b1f0)
sure it is, but it has a different approach then others, there is no special meaning keyword in html to do conditionals and so on, you write js and thats it.that kinnda makes it clean and easy, at least for me. every other lib does it different afaik.
Why do you need a third party library for Async with react? It‚Äôs just JavaScript. 
No we don't need them in fact, you're right. Neither in Vue (I guess), but eventually people go for state management libs (most of them, I'd say). If it's redux, we gotta stick with other libs for side effects. In Vuex we can use promises/generators. In mobx too. 
I see a lot of alternative ways of doing things in that post. I don't see anything that you couldn't accomplish with class names and CSS variables. I get that people like using styled-components, which is fine, it's an option. I just don't see how they change the game in any meaningful way for the apps I work on. I think that simply providing a map of class names and a default style sheet would be pretty close to all you need to solve styling in React. React is flexible so either solution should be encouraged, but neither of them should be considered the '"react" way'.
There's also something lost here when we don't see how it scales. It's really easy for him to dismiss Vue's 3 files vs React's 6+ files as "personal preference" but when you start to scale, having more than twice as many files introduces significant cognitive overload. I have a hard enough time at work teaching juniors Django just because the number of files required for even a minimal example is totally overwhelming.
This. The first thing I do when reading articles like this is ctrl-F for the word "test", and I'm usually disappointed. Framework comparisons should always include something about how to do automated tests (FWIW, as much as I like Vue's syntax and approach, React has a maturer and better-supported testing ecosystem)
&gt;in both case, it is Webpack or any package bundler that covers lazy loading They only handle dynamic imports and code splitting. Lazy loading depends on some level of support from the code you are writing yourself or from your framework
Probably for this article specifically so you can fork it and use it as your own checklist. 
That's true, but I was responding to someone who seemed to misunderstand JS. In answer to OP, I try to only extend protypes explicitly when it was expected by the extended object's creator, like in the case of React's Component. I've run into issues before in projects where someone extends a class and then proceeds to break base methods. Not to mention all the risky stuff people do monkey patching Number, Array, String etc. You just don't need to implement a deep classical OOP hierarchy to get stuff done in JS, and part of that is because there's already a powerful prototypal hierarchy under the hood.
Someone says this every time. React and Vue are View libraries. What async behavior would you expect that isn‚Äôt perfectly covered in vanilla JS?
You just agreed with him IMO
Pain in the arse to style though
I guess almost is the keyword. I was watching a video by a guy who teaches other programmers new technologies. He was showing an example of an ES6 feature in Node.js and it didn't work, and he said Oh probably that feature is not implemented yet. I tried the example with semicolons and it worked. I always use semicolons so I don't have any other examples but I'm sure there are more than one.
Just in Vue. Tell your mom you love her.
WebAssembly everywhere
Eh. Hope not.
Even if they don‚Äôt, take bad practice to tightly couple components to other components. It makes both unit testing and refactoring difficult.
thanks for clarifying the meaning of CLI in an article about the differences between highly abstracted javascript imlementations
Hmm, tween.js has looping and bounce already, and whatever you do you need a transpiler (or TS) anyway, so it doesn't matter what the lib was written in. I am asking because basically tween.js is THE solution for inbetweening and I just can't imagine what else could it do. Perhaps have a bit clearer API because it is easy to make a memory leak with it. Anyway I wish you guys luck and have fun developing it!
Maybe hold off on it. The guy is going to publish another book soon 'how JavaScript works' (he wanted to release it this year but has been set back a bit) which covers a lot of his thoughts on the latest has and so e more advanced features of the language. Saw a preview at fullstack conference a few weeks back. Not sure I agree with everything he'll say in it but I'll definitely be buying it. :) For reference you can watch the conference video about his new book on the skills matter website if you register for free. 
This made me chuckle
https://deliciousbrains.com/vue-vs-react-battle-javascript/ Found this on my first search of ‚ÄúReact vs Vue.‚Äù The author thinks they‚Äôre the first to write on this topic? That‚Äôs a surefire way to make yourself sound like a true moron.
I decouple my logic from my components into their own pure js modules so my components are just reactive GUI essentially and any front-end code that is reusable or is likely to be implemented again should our component lib change is separated out. Sounds obvious but some ppl don't do it at all. As stated previously though, react is js with bells and whistles added for reactivity/state it's not a different language, it's just a set of tools and a way writing it for a specific purpose. Don't worry so much ;)
Progressive web apps and web-assembly in my humble opinion :)
Have a read on APIs. Maybe take a look at some express+mongo API tutorials. I think you're looking at the right sort of tools but you're missing a little something. Express can load a page and also handle API requests from that same page after initial load.
 I haven‚Äôt used IntersectionObserver, but without it you can use: - A scroll listener - getBoundingClientRect() to detect where the elements are positioned on the screen On each scroll event, get the elements‚Äô client rects. Since we‚Äôre only concerned with vertical intersection, we check if they clip with the following conditions: - The top of the image is higher than the bottom of the clapper (scrolling down toward the image) - The bottom of the image is higher than the top of the clapper (scrolling away from the image) We need to loop over every "wide image" on the page and check if any of them are intersecting. If so, we add a "hidden" class to the clapper to hide it. If not, we remove it. https://codepen.io/anon/pen/wxPLMd?editors=0110
**My first chrome extension, Recent PDF** https://github.com/alexweininger/recent-pdfs Recent PDF displays your recently downloaded or viewed pdfs and lists them in a popup. Feedback is appreciated!
I mean they could literally ask you anything, depends on the company. Based on what you said I would suggest reading the docs about the changes relating to component will mount/will update etc. They are now considered unsafe and will be deprecated in React 17. 
I‚Äôd recommend disconnecting the api from the business logic, using AST for static analysis and using a resolver map and getting familiar with schematic stitching.
Please, this is what I am searching for.
I wonder if it's worth knowing the bad parts, though.
Nice, I'll be keeping my eye out as well - thanks for the tip.
I have never seen the change detector fail to trigger on a value pushed through an observable **except** the documented and intentional case of when you push the same object through the stream only mutating it's keys or values. The cd in angular does dirty reference checks to determine if it should rerender. I won't claim it's *impossible* to not have the cd go off when it should. But I've never run into it and have used observables and the async pipe extensively. Is there a bug report or something about this you can link to?
That's very true. I know they depreciated componentWillUpdate . I never really saw a use for it. 
Personally for a last minute study I'd focus more on cultural questions like the company's recent products and services. 
Except for the fact that one CSS file per React component isn't actually standard practice. You're extremely correct that it wouldn't scale as presented in this example. It would be completely overwhelming. This isn't how I often see stylesheets implemented in React apps. 
That sounds really solid to me. I do like their product and the guy who interviewed me. 
Go way down in the redux docs and get familiar with building your own undo/redo states and timetravel debugging. And read up on Redux devtools, redux debugger. I find that if you mention some obscure thing way down in the docs for dev-stack items it really shows you take the time to know your stuff. Also, do a tutorial on setting up react from scratch w/ webpack and babel just to know the ins and outs of setting it up and adding what you need as you go rather than using create-react-app. Look into virtual Dom, possibly Airbnb‚Äôs enzyme for react testing (there might be newer things now) but anything that takes advantage of react‚Äôs core functionality is good to know. 
If you look at the source code, you will two very different ways to implement a ToDo app. Vues version is written very simple, while Reacts version is somewhat exhaustive to be extensible and split over several files.
I second this. We definitely look for people who are a) not only familiar with the product we're working on but also b) that they have an interest in that product and working on it themselves. Having a passion and interest in something can sometimes supersede a lacking technical ability.
Yeah, I‚Äôd say just for practice look up the differences in using different database calls/queries in componentDidMount vs componentWillMount (I wouldn‚Äôt use either now but for some reason it helped me understand the differences when I first using it). It should just help you understand why it was deprecated and help you get more rounded feel for it. Just keep the general mindset of ‚Äúwhen/why would I use this‚Äù as you prep for the interview and keep reading until you have a good idea of how to answer both. A typical question for company stack items is ‚Äúwhat have you used it for and what bugs did you find, edge cases not supported‚Äù etc. if you can find a few good answers for that it shows you squeezed out every last drop of functionality from a library or framework. Just relax and keep reading and writing down notes until it all clicks. 
I've interviewed for more generalized front-end development, but not React specifically (it's always been a bonus if someone was familiar with it but our current use of React is limited so it was never a hard requirement). If I had to guess, I'd say make sure you're familiar with - in no particular order: * The virtual dom * props, state and store * setState(&lt;object&gt;) vs setState(&lt;function&gt;) * class vs functional components * Component vs PureComponent * Event handling (vs DOM events, binding event handlers, etc.) * Conditions and loops in JSX (e.g. logical and ternary use) * JSX vs HTML (e.g. class, style, etc.) * refs * Why immutability and pure functions are important * Redux middleware * Terms like: actions (action creators), reducers, render props, higher order components, presentational components, container components I think understanding keys is good too. It sounds like you got that down, which is good. Just make sure you also know why it's not always good to assign keys to an index value in a loop. 
I used to hire for AngularJS &amp; I would test for vanilla JS fundamentals more that any framework. Questions about Angular would be 20-25% of the interview Typically do a whiteboard test in Vanilla. The I. Would ask some questions related to the frameworks. 
Why not? It will be a single bytecote for compilers to target that will run on all platforms with a universal api 
Wes Bos has a good course on ES6 here [https://es6.io/](https://es6.io/) I also learned a lot from Kyle Simpson [https://github.com/getify/You-Dont-Know-JS/tree/master/es6%20%26%20beyond](https://github.com/getify/You-Dont-Know-JS/tree/master/es6%20%26%20beyond) that's his book, video courses are available in the [frontendmasters.com](https://frontendmasters.com) platform.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [getify/You-Dont-Know-JS/.../**es6%20%26%20beyond** (master ‚Üí f0d591b)](https://github.com/getify/You-Dont-Know-JS/tree/f0d591b6502c080b92e18fc470432af8144db610/es6%20%26%20beyond) ---- 
Well to push you in the right way, have you thought about what a winning game would look like in your array? Try that and then model your function around what a winning array state would look like.
Rayo can now be hunted on ProductHunt [https://www.producthunt.com/posts/rayo-2](https://www.producthunt.com/posts/rayo-2) Happy coding!
in my jobs use react for tow years, but in this moment rewriting many parts in vue; Vue it‚Äôs more fast for creators.
Thanks I will take a look, I have done Wes Bos javascript30 that was entertaining. 
Dang prints to the console? haha Trying to think how you would make it `O | O | O` `O | O | O` `O | O | O` Ehh... I guess that would work. yeah as /u/babygetoboy pointed out, think of your coordinate system and what a win means in terms of that coordinate system. A win could look like: `O | X | O` `x | O | x` `O | X | O` What are the coordinates for the winning line of O's? `0,0 ; 1,1 ; 2,2` You would need how many for-loops to go over 2 axes? How can you make sure you check each coordinate? One loop, runs and the other one is inside, the first loop, so the main loop runs 3 times, and each time the main loop runs, the inner loop runs 3 times = 9 coordinates checked. You would need to check horizontals(3), verticals(3), and diagonals(2). Your check limit counter is 3(or 2 if you start from 0) since a win has to be 3 matching symbols in a row. You'll need a state array(your board) stored so when a person plays, you store their position/value. Then check for a win, if no one has won yet and the board isn't full, continue.
Try it in Mithril OP. 
A benefit to technical articles (and the kind of thing that can be forked/contributed to): - if it's a personal blog, and they stop caring/coding, it can disappear. Hopefully it got archived. - on GitHub, it's not going anywhere if the author walks away. 
There are sensible overlaps though. This is why \[context\]([https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html)) exists in React. 
This is just a thought, I have no idea Can you install Expo on an \[emulator\]([https://stackoverflow.com/questions/4512458/how-to-run-apk-file-on-emulator](https://stackoverflow.com/questions/4512458/how-to-run-apk-file-on-emulator))?
I've never used vue but dang that is ugly.
Which sounds more employable: being mediocre at two languages or being good in one language? 
Personally, I like the GoThinkster [mother-of-all-demos](https://github.com/gothinkster/realworld) which has the front and back end of the same app implemented in lots of different languages/frameworks. 
You don't in general, but for a complex app you'd like your async behavior to interact with your data store. The third party libraries aren't even complicated. `redux-thunk` is basically a one-liner. They provide the team with a well documented, unified interface to perform async actions. In a team context, taking your advice literally, we'd end up with a complete disaster. Need some data from the server? Just `fetch` it in `componentWillMount`. And maybe update it in `componentWillUpdate`. Or in `componentWillReceiveProps`? And for sending data back to the server, do we do it directly in an event handler, or do we handle the event, update internal state, and perform updates in `componentWillUpdate`? OK, you say, we can answer all of those questions in our internal documentation. And our team will always read and obey the internal documentation. Oh no! Under certain conditions our app is making too many HTTP requests. Our target market includes mobile users in Africa, and their experience is degraded. The issue here is latency, not bandwidth. We'd like to batch our HTTP requests app-wide to reduce latency and improve performance for those users. If you've used a well-documented external library, or even an internally developed equivalent, this is reasonable request - we discover the requirement on Tuesday, we have it fixed by Friday, maybe one team member needs to work out some corner cases in the following week but it's not a show-stopper. If your policy is "it's just JavaScript", you have 15 different ways of interacting with async resources, none of them sharing a common interface, and oh boy is this going to be a !!!FUN!!! month.
I feel like code splitting is an important part of scale. In my large React app, what gives me cognitive overload is multiple large code chunks managed in a single file. I export JSS the same way I export function dependencies. It leaves the remaining code readable. Nothing about React requires the CSS be external, yet I do it anyway, because it's better that way.
JavaScript is viable as a career choice. Just remember it's currently very competitive and many libraries and frameworks change fast.
Thank you for explaining this! I've been stuck recently and thought tic-tact-toe would be too challenging, but the way you broke it down makes it seem reasonable enough to attempt :) 
It always works when pushing through observables. What I'm talking about is when you start to combine normal values and observables. Am only on mobile right now, so you will havr to do with a bit of pseudo code: @Component({chnageDetection: OnPush}) class FooComponent { loading = false save() { this.loading = true // this gets picked up this.form.save().subscribe(() =&gt; { this.loading = false // this doesn't })) } } Had I done that with behavior subjects, and the async pipe in the template that would work fine. Alternatively I have to request the changeDetectorRef, and markForCheck in the subscribe callback. I'm also pretty sure that is intended behavior due to the OnPush change detection.
Right. Gotcha!
yeah man logic haha From my experience it's better to think first/draw it out, before you code. Also try to test each piece independently before you stick into the whole so it's easier to debug stuff that breaks.
JavaScript is a really good language to know at the moment. There is a lot to master. If you're doing React, then get to know functional reactive programming and how the redux pattern works. Check out stuff like TypeScript. Get to know tooling and how modern module loading works. Sure you can start picking up another language, but why?
As furthest advice and in case it wasn't autocorrect, it's "deprecated", not "depreciated". 
I was honestly squinting at that for a while trying to figure out what the heck he was doing there. It's so bizarrely against the whole *point* of emitting events. 
These are base-line benchmarks with little relevance to a real world app. React 16 isn't going to render 100.000.000 rows if only 10 fit the screen (occlusion), or it's going to give rows in general a lesser priority if another control should take precedence, etc. 
Context, similar to an event bus, is a layer of abstraction which prevents tight coupling. Coupling a component or functionality to an interface is required of almost any software, but that‚Äôs much different than tightly coupling two specific components to a specific hierarchy.
I would suggest you to explore the trending JS frameworks like React, Node Js etc... instead of learning a new language. It will automatically make you strong in Js.
Way? Probably the popularization of yet higher levels of abstraction. People are now commonly using functional styles. Perhaps next they will be using functional reactive style everywhere it makes sense. Also, something like webpack, but better, will probably appear. Something that does/downloads the ‚Äúright thing‚Äù in response to the input abstract goals and custom algorithms for each individual project‚Äôs specific needs, rather than configuration and plugins based on assumptions about the nature of ‚Äúevery project‚Äù. More concepts from other languages through wasm, including real multi threading.
Thanks for clarifying. I'm not too great with the technicalities of programming so this is good to know.
I would try to pick up another language. You can learn a lot of programming practises by using a different framework or language. I‚Äôd also recommend a strict typed language. Java would be an excellent choice since there is also a lot of work related to Java.
Check out ‚Äúproviders‚Äù with react. A provider provides context of a certain interface. Under this contract, any component utilizing this interface can work with any provider adhering to it. In practice, there‚Äôs always issues with drift in interface support but IMHO it‚Äôs usually better to be flexible than to not.
Thanks for the info, sounds pretty neat
No worries.
I'd also say that depending upon where the OP is, React-native is still in high demand across many of the tech hub's of the UK (Leeds, Manchester, Sheffield, etc) despite being sunset by AirBNB and some other big companies (it's also still an incredibly fun platform to develop with).
There are lots of Java job posts because it's such an established language, particularly in enterprise. PHP is similar, but it's been fading out in favour of things such as Node.JS because node can do everything that PHP can do (that doesn't mean it's better at everything, but in many cases it performs better with a few exceptions, but you can often work around those) and it also means you can build for the front-end too but there's still many places that use PHP because they have older systems built around it. JS is well worth learning to beyond a beginner level. Look at things like promises (and async-await), asynchronous coding styles, modular coding, transpiling and build workflows. There's a lot of things that go beyond coding that are crucial to learn. Take a look at frameworks like React, Vue or Angular. Take a look at nodeJS. I moved out of the call centre life because I focused on improving my JS skills. I used them to develop projects for the call centre in my own time, but I worked to learn more. It took many years of having a moderate level of knowledge before I was able to land a job as a developer, but it took another ~11 months of focused learning to bring myself up to modern day standards. It might take time to land your first role, and that's OK. Keep learning Javascript, and keep challenging yourself. Find projects you would find useful in your daily life and make them. I learnt React-native by building a train times app because the options on the market didn't provide the information I needed in a quick enough manner (i.e. I don't like having to go through 3 screens just to know what trains are arriving or departing from stations near me). With that, I'm now able to write for front-end websites, backend node servers, and mobile applications. There's a million tutorials on how to make to-do lists, but they often don't teach you how to utilise those skills and code samples in a more useful project. TLDR: Keep learning JS. It's an in-demand language because it can do almost anything.
Thank you! :) Please give between.js a try next time you will need tweening engine. Maybe it will satisfy your needs better that other solutions 
Hi! I have found the error in your code. If you notice the first loop in the javascript, you would find that you are adding the event listener to all of the buttons (including equal button). So, when you click on the equal button, the event listener would add the `data-num` to the value, which evaluates to `null`, Thus, the eval fails at `5+5null`. A fix to it that I can give is to either to use `equal.removeEventListener` or exclude the equal button in the loop. const btns = document.querySelectorAll('.num'); const screen = document.querySelector('.screen'); const equal = document.querySelector('.btn-equal'); const clear = document.querySelector('btn-clear'); function btnClick() { let number = btns[i].getAttribute('data-num'); screen.value += number; } for (let i = 0; i &lt; btns.length; i++) { btns[i].addEventListener('click', btnClick); } equal.removeEventListener('click', btnClick); equal.addEventListener('click', function() { let value = eval(screen.value); screen.value = value; }); Or: const btns = document.querySelectorAll('.num'); const screen = document.querySelector('.screen'); const equal = document.querySelector('.btn-equal'); const clear = document.querySelector('btn-clear'); for (let i = 0; i &lt; btns.length; i++) { if (btns[i] === equal) continue; btns[i].addEventListener('click', function () { let number = btns[i].getAttribute('data-num'); screen.value += number; }); } equal.addEventListener('click', function() { let value = eval(screen.value); screen.value = value; });
Hi! I have found the error in your code. If you notice the first loop in the javascript, you would find that you are adding the event listener to all of the buttons (including equal button). So, when you click on the equal button, the event listener would add the `data-num` to the value, which evaluates to `null`, Thus, the eval fails at `5+5null`. A fix to it that I can give is to either to use `equal.removeEventListener` or exclude the equal button in the loop. const btns = document.querySelectorAll('.num'); const screen = document.querySelector('.screen'); const equal = document.querySelector('.btn-equal'); const clear = document.querySelector('btn-clear'); function btnClick() { let number = this.getAttribute('data-num'); screen.value += number; } for (let i = 0; i &lt; btns.length; i++) { btns[i].addEventListener('click', btnClick); } equal.removeEventListener('click', btnClick); equal.addEventListener('click', function() { let value = eval(screen.value); screen.value = value; }); Or: const btns = document.querySelectorAll('.num'); const screen = document.querySelector('.screen'); const equal = document.querySelector('.btn-equal'); const clear = document.querySelector('btn-clear'); for (let i = 0; i &lt; btns.length; i++) { if (btns[i] === equal) continue; btns[i].addEventListener('click', function () { let number = btns[i].getAttribute('data-num'); screen.value += number; }); } equal.addEventListener('click', function() { let value = eval(screen.value); screen.value = value; });
Splitting in a component framework, I argue, should involve splitting down into more components, not spreading the component's responsibilities out into multiple files. We moved to components to centralize these responsibilities. If your css is so unruly, I'd wager your component's scope is way too bug and it ought to be broken down further.
In this post I write about the new, blazing fast library by Google, which totally changes the paradigm of how we do RPCs in microservices architecture. The post challenges the prevalent REST API model and provided reasoning to this new route. Finally, we also try to implement a very basic NodeJS application using our learnings. The post is divided into 2 parts as below - Part 1 - [https://medium.com/@chittorashobhit/blazing-fast-ipc-with-grpc-part-1-9af1b7d99553](https://medium.com/@chittorashobhit/blazing-fast-ipc-with-grpc-part-1-9af1b7d99553) Part 2 - [https://medium.com/@chittorashobhit/blazing-fast-ipc-with-grpc-part-2-227635faa361](https://medium.com/@chittorashobhit/blazing-fast-ipc-with-grpc-part-2-227635faa361) PS: I've just started writing my learning out. I'm learning in the open and would like any help out there. Please provide your feedback so that I can improve. If I've made any mistakes, please do point out. And do share if you like.
You should always learn new languages, regardless of whether you will use them or not. It helps to keep you mind flexible and open for new ideas and different approaches. 
I've heard virtual assistants will be the next big interface change.
"Understanding the why of react" so many people parrot this sentence but no one ever seems to explain what that why is.
&gt; (componentDidMount, componentWillMount, render, &gt; componentWillUpdate, etc But remember that for example `componentWillMount` is considered legacy and you should avoid it in new code. https://reactjs.org/docs/react-component.html#unsafe_componentwillmount Also it's good to know about some new lifecycle methods like static method `getDerivedStateFromProps()` or others https://reactjs.org/docs/react-component.html#the-component-lifecycle 
It‚Äôs literally the same... just need to override like, 3 styles. 
Am not an expert but have you looked at the request config ? Request Body goes as ‚Äúdata‚Äù param. 
and that is why we all should benefit from a couple of years of study in good courses in OOP with Java 
To be honest I only ever wanted to be a designer, not really sure how I've ended up here.
Yeah. 3 more pains in the arse
It depends if you prioritise being employed, or being a professional programmer (and being employed). With 5 months experience and looking to get into the game there's nothing wrong with solidifying your game with JS a little more, particularly as it's an excellent language to develop a good theoretical background in. However I would **strongly** encourage you to at least start to look around at other languages. A programmer who knows just one language is at a severe disadvantage IMHO - indeed knowing multiple languages for the interest is one of the hallmarks of a truly good (as opposed to the merely competent) developer. I've been coding professionally for 25 years plus, and I once estimated I've learned a new language to the degree I've written something useful in it, on average once about every 18 months. The number of languages I've been paid regularly to write code in is well over a dozen. I'd recommend considering one of the following :- C: Because it's the programming equivalent of Latin. You're unlikely to get employed with C, but K&amp;R is a thin book which will teach you a solid conceptual underpinning for practical programming. Learning C is worth it *just* for how it forces you to get to grips with pointers. Java: This used to be the mainstay teaching language for CS101 up until maybe a decade ago. There's a great deal of Java code around and it will solidify your OOPS knowledge. It's never been my favourite language, but YMM Python: Not everything uses C derived syntax, and Python is a joy to learn and work with. Obviously extremely active and it will give you a different perspective on code than JS. PHP: I'm sort of loath to suggest this because although you can write solid code in PHP it has a well-deserved reputation for having a large codebase of poorly written code because of it's history. Still, from a practical POV it's likely to be worthwhile having an acquaintance with it - just be aware it's going to have less to teach you than the others. If you're going to learn it best to do so in conjunction with Laravel or Symphony. Myself I'd recommend Python &gt; C &gt; PHP &gt; Java. That's because Python has both direct practical usage and will give you a different perspective on coding than JS - which is the main point of learning another language. Reading K&amp;R and doing the exercises is worth your time as soon as you can find time to do it, but unless you develop an interest in the specialist fields where it (and it's bastard child C++) is still used treat it as background reading. PHP scores purely because of practical usage. Honourable mention: SQL: Obviously not a programming language in quite the same sense, but I would strongly advise you to get to grips with SQL. In my experience the understanding of SQL among most programmers is usually quite poor and you can put yourself at an advantage by mastering a little more than the basics. If you're approaching this from a learning perspective I'd advise playing with Postgres over MySQL. 
Strong typing is an excellent point. 
If you are confident enough I would suggest that you don't focus on finding a job rather finding experience. It sounds cliche but it is much easier to find a job with some experience. In most cases, when you become good enough, the job finds you. Look for things in your day-to-day life that an app could make easier, for example you want to track your expenses and make an as simple as possible app for that. Also you could go to a local or family business and offer them to make them an app that makes their job easier FOR FREE. With the apps you have you can apply to entry level jobs at a lot of local IT companies. Most of them are in constant search for interns/beginners. Also you can try to use a freelancing platform like Upworks to get some initial jobs done(It is not that worth but you can earn some bucks here and there). Don't be too picky for your first dev job(e.g. I they want me to learn the XXX framwork and I don't like it), show your best and gather all the possible knowledge. This will enable you to be more confident on your next job search. One major thing that companies value which is hard to get outside of work is knowledge of the Agile Workflow. Also be sure to understand how to use Git works. TL;DR Make sure you have some apps to show. Make them for yourself, a local/family business or for freelance stuff. Accept any job as your first then start looking for a better one. Know things that are not just programming.
YDKJS for sure. (You don't know JS). This is a free series of books on github that will teach you the the basics but also some more complex concepts like closures and prototyping.
Programming is not about languages. Once you have been grinding away for lets say 5 years you should be able to pick up any mainstream language in a couple of weeks. Most patterns apply cross languages. Instead focus on the bigger picture that is patterns. Learn about OOP and FP (being my favorite) concepts.
I second this. Go through this series of books. I started my JavaScript journey beginning with Eloquent JavaScript and then immediately read YDKJS. You get some really nice insights into how to structure your code in the Eloquent JavaScript book and the YDKJS series covers pretty much all of the basics of the language. After doing that, try some Vue or React tutorials and you should be ready for bootcamp.
Thank you that is great advice 
Creating a makeshift event bus by exporting a vue instance works imo, but if you need a lot of component interaction you should be using a store imo
If you want speed, try EmberJS...
Because people will still use around a million other frameworks in parallel, and then it's just yet another complicated language to learn that gives you nothing but a little more speed and a lot more complication. Wouldn't mind if it were the only thing people were gonna use. But, that's never going to happen.
or even a quantum abstract language
3 pains in the ass that forces good accessibility. Write a utility for u-notButton that resets its style. 
Well, bonus for explaining what the differences between REST and RPC are in the first sections and how this relates to gRPC. I found that to be a good read. Especially for someone that knows just enough to be dangerous about those items but always wanted that nice overview that put it all together. I'll hit section 2 and do the example later.
Completely agree. There's this myth going around that you have to split your code into multiple files just because it gets "long"
Can't you not use psuedoselectors and stuff though?
Likewise, this format is very helpful
Great resource, the list format is nice to work with and easy to digest.
Being strong in a framework does not make you strong in javascript.
I disagree. If you‚Äôre not great in one language, learning a new language will just muddle what you know. Plus, why learn another language when you haven‚Äôt even mastered one yet?
I would know how to build a basic app using create-react-app. They are going to see if you know the basics. - react lifecycle methods - using JSX - using props - handling events (ex onClick) - managing state (setState or Redux) - making an API / side effects - how you separate your folders - create a list with .map() One big thing is make sure what you've told them lines up with your knowledge. If you've been using React/Redux everyday for a few years, they'll expect to see that. If not, just make sure your honest and say so. They may not be looking for specific things in react but that you can work through an application and learn if you have the resources and can look things up.
This is the answer. The Good Parts is fine, but YDKJS is the essential resource for knowing JavaScript.
[bea.com.ru](https://bea.com.ru) A webpage with random ads feedback is welcome please
its just a todo demo...
I'm growing a bit tired of these blog posts demonstrating absurdly simple javascript concepts and no real innovation.. It's starting to feel very spammy.
&gt; Plus, why learn another language when you haven‚Äôt even mastered one yet? To keep your brain working. Your whole career depends only on the agility of your mind, and not on how good you know only one particular language. The languages come and go. 
You mock the other users/data for the most part 
To each their own. I was asked about this on Friday and I'm more than happy that someone has put this together for me to share to help them out.
Taking advantage of this thread to ask about one problem I have with Vue: to achieve bindings, AFAIK it uses some custom getter/setters. This has a performance cost when states update very frequently that React doesn't have. Is there a way around that?
That's /r/learnjs territory though... 
[removed]
These tips are to lower the page load time.
[removed]
This is a bit hard. Learning a new language can help better understand an over language.
[removed]
Considering that's an invitation only subreddit, I can understand why people would post these articles and link them in on this one.
Why on Earth is that sub private?
Are you sure about that? https://www.stefankrause.net/js-frameworks-benchmark7/table.html
Is google cloud a development environment? 
Hi! I apologise as I don't work with the microbit, but I assume you want to pass in the frequency for the note... The equation I use is: ``` function getFrequency(keyNumber) { return Math.pow(2, ( (keyNumber-49)/12) )*440; } ``` Where keyNumber is 1 through 88 on an 88 key keyboard/piano. If you only have A3 or Aflat3 or whatever, you would need to convert that to the appropriate number first. I hope that helps!
Finally a decent Node version for GCP
That's not true. Your career depends on you being good at your job. If you're not good at your job, then learning another language will just make you equally as not good at another job.
/r/learnjavascript
To me that is all fine, as long as it works. Using "===" and "!==" is a good sign. Good readable variable names. But if you want "roasting", okay. Too many comments, i mean comments are great, but sometimes i feel like you place comment because its time to place new comment, not because code is hard to understand. For example: "If currect iteration is not array, initialize"; it is so obvious: you checking it via "isArray", and then you assign something to it. Array declaration, please stick with one way, at top you do "\[\[\]\]", in the middle you do "new Array()". Also you use "let" where you should be using "const", e.g. cellsChecked, cellDictionary. General rule: if you dont reassign something -- that should be declared using "const" (its not like java or c#, const in js more like "final" or "readonly"). Also your functions like getNeighbouringCells and others (the names are so long i cannot retype it from image :D ), should be declared with "const". And the last one, if the task specificaly required to do it using recursion, than all fine. But if it is your choice and the array can be any size, i wouldn't use recursion. But maybe task had constrains which you just didnt mention here, so as long as it works for any task-constraned input -- all fine. But if array can be bigger, like 100x100, i'm not sure if recursion-like solution will be suffice.
Yes that's how it's supposed to work. Or rather I would say you shouldn't be mixing observable inputs and non observable local state mutations.
 Noted, thanks!
At this point rather than learning a new language I'd suggest fleshing out what you already know. Try the popular frameworks so you are at least vaguely familiar with them (this will make them easier to pick up if you need to for a job opportunity, and will help you better understand your existing framework as you will see other ways to do the same thing and can weigh up the pros/cons). Experiment with design-/display-side things like CSS (and possibly SVG) in more detail. You may not want to be a front-end developer at all but even as a back-end only person you'll get benefits from understanding what the other side gets up to, what their pain points are which you might be able to help with in the design of the server-side, and so forth. Also, definitely look into other database options. You almost certainly will run into a SQL style database at some point so having a working knowledge of at least basic SQL concepts will be valuable.
I agree 100%, but it's one of those things that would make sense to outline in blog posts like this in my opinion, or at least on the topic of async behavior in the frameworks. It's one of those things that makes a lot of sense, and is quite easy to do, but it takes a moment to discover.
And I'd suggest that you'll get to greater general competency faster by learning more than one language. The prominence of different concepts tends to be different in different languages (use of recursion for example - and JS's object model is a bit odd compared to most). 
No, but learning React requires you to get good at JS. 
cheap-module-source-map
It's probably more moneyless--servless hosting. I'm sure there's a case for random cloud functions. 
&gt; Muddle I don't think that's true at all. Learning more than one language is often helpful because different languages emphasise different concepts. A concept that's underused or obscure in one language can be more prominent in another and helps you to general competency faster. Javascript has more than enough oddities to it that I think learning *something else* is positively beneficial just to emphasise that. You don't have to Major in both, but a second or even third is a good idea to gain a different perspective, once you're past the basics (which OP obviously is)
Thanks to letting me know , where i did it wrong. By the way i'm a new programmer and this is my first blog post anywhere. Commit if someone have any issue regarding the post. 
I was talking about speed of development, see ops comment: &gt;Vue it‚Äôs more fast for creators.
No, it's a cloud platform. Just like AWS or Microsoft Azure.
So by default it's using 3 fullstops as the ellipsis - Why wouldn't you use &amp;hellip; as the default? Or have I misunderstood the Readme? It looks like out of the box it adds '...' but you can use the custom parameter to make it something else, correct? If I've understood it right, I'd consider changing it so a &amp;hellip; is the default considering that is it's purpose.
You'll have to explain a little more. From what I see you are already adding bodyFormData to the body of the [axios.post](https://axios.post) method. // `data` is the data to be sent as the request body // Only applicable for request methods 'PUT', 'POST', and 'PATCH' // When no `transformRequest` is set, must be of one of the following types: // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - Browser only: FormData, File, Blob // - Node only: Stream, Buffer `axios.post(url[, data[, config]])`
The tuples in this library are similar to [Python's tuples][tuples]. The basic idea is being able to equality test groups of values without having to use a helper function for deep equality testing. Tuples can also be used as keys with `Map` and `WeakMap`. Basic example: const o = {}; tuple(1, 2, o) === tuple(1, 2, o); // -&gt; true tuple(1, o) === tuple(1, 2, o); // -&gt; false [tuples]: https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences
[removed]
&gt; being good at your job If you think your job is only to be good at coding in one language I have some very bad news for your future you. 
Got to be honest, I'll keep using Babel. You get all the new features and you're not bound to the current GCP version. That a luxury python devs don't have (GCP used to have only python2.7 and then they added python 3 but with limited features)
Here is my roast 1) Store tableGraph.length(other for loop condition as well) in a constant in for loops. This improves the performance. 2) forEach loops are expensive compared to a simple for loop. Avoid if possible. [https://hackernoon.com/javascript-performance-test-for-vs-for-each-vs-map-reduce-filter-find-32c1113f19d7](https://hackernoon.com/javascript-performance-test-for-vs-for-each-vs-map-reduce-filter-find-32c1113f19d7)
Today's the day! [How to set conditional breakpoints in Chrome](https://stackoverflow.com/questions/14598561/javascript-how-to-set-a-conditional-break-point-in-chrome-debugger-tools)
It‚Äôs not even english. Very poor quality.
I always used html5 boilerplate.
What I find interesting is that Discord is NOT using React Native for Android - arguably the platform where most of the other companies that have sunsetted React Native had had issues with inadequate performance and visual differences. That being said, I'm personally still a huge fan of React Native, but I'm not counting this as a full support statement until they use the platform to its fullest extend and then report back.
Meh. We use it with python 3 and Django and have been pretty happy so far
It's not really worth reading. ESLint configured with any popular \`.eslintrc\` such as [Airbnb's](https://www.npmjs.com/package/eslint-config-airbnb) will stop you from using the bad parts. The book was great for its time, but many of the code examples are outdated by now and many of the questions Douglas Crockford was asking at the time and trying to answer have already long been answered by evolution of the language, or tools like ESLint. It was a revolutionary book for its time, but I would focus on the "You Don't Know JS" series as others have suggested.
I tend to prefer [Composition over Inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance), so I rarely use it. I can't say I've never used it though. It does come in handy sometimes.
Good to know about performance tweaks, I‚Äôll definitely try experiment with stupidly large tables to see the difference. Thanks üòä
I often see people that use React Native say that they use shared code for web Frontend codebase and React Native codebase. Practically, how do most people go about this? Pluck the code that can be reused and move it to another repo? Have one big mono-repo? Copy/paste sounds terrible, and I can't really see people doing it that way. Any thoughts?
YOU do, I was talking about what's the react way. I'm not saying you can't, just if this article puts the css in for vue, it should for react as well. It's worrying that so many of you misinterpreted me so much. I expected better from this sub. 
I could write a blog post about how much you misunderstood my comment.
They're honestly idiotic. Stuff I thought, "should I warn against this? Nah, no one can misinterpret things that much!" Boy was I wrong. 
&gt; This improves the performance. Sounds like micro-optimization. Will this ever be relevant in a real life scenario? &gt; forEach loops are expensive compared to a simple for loop Again, this will never be the bottleneck of a program
I would have given less hostility. But basically look into functional programming. The whys of react borrow heavily from functional programming. Plus if you've struggled with front end state and trying to get components to efficiently share state, then react redux makes a lot more sense. 
Yup, and what happens when you speak to frankly about react in a JavaScript subreddit. People just don't understand the flexibility or main ideas behind react. Look at the top reply to me, someone saying that leave css out of react. As if that means anything. Like yeah react allows you to do a lot, but there's also a recommended way to do things. You don't have to follow them, but don't pretend they don't exist because you choose another way. Got to say, very disappointed in this place. 
[ Backend ] - Node - Express, Spife or other HTTP routing/middleware/etc library - A driver for your DB (and a DB to hook it up to) - An ORM to query your DB using a more object-like syntax (optional), or write raw queries if you want fine grained control and know the risks and how to mitigate them - Provides routes that query data from the database and then sends it to the client (e.g. GET to /api/users should return a list of users) [ Frontend ] - React app built to production - Served on a public folder from your express server - Uses fetch to request data from your server endpoints and then updates your state stores which will in turn cause your UI to update Essentially, you're creating something like a MERN stack (mysql, express, react, node.js). The React app knows nothing about the server it's connecting to (and the server knows nothing about what it's serving, only where to serve it from) and is basically a front-end for API data to be displayed. When building full stack like this, keep things simple. Don't overcomplicate or you're in for a world of pain when it comes to tracking down bugs. If you need something like server-side rendering, then that's more complex and your app and server may need to know something about each other, but in most cases, you're going to be separating out your front end from back end, letting the backend handle DB queries and serving the HTML/CSS/JS of your front end, and the front end will in turn interpret the data it receives from the server when it calls to your /api endpoints.
Growing tired? I'm seven feet tall of tired already. Coming soon on Medium (and repeatedly crossposted to several subreddit as well as Hacker News): *Addition and subtraction in Javascript*
This is silly. Of course it does. Learning a framework helps someone apply what they already know to something they don't yet know, which just recycles the feedback loop of learning programming concepts in general. Frameworks tend to be built upon best practices, so they also help expose develops to those practices. React leads the way to better understanding concepts such as functional purity, modular code, state management, side effect management, unit testing, e2e testing. There isn't really a natural learning path from "just JavaScript" to these concepts better than what the react ecosystem offers, and that's not even considering the community of developers that React exposes us to. C'mon. It's good to understand JavaScript, but learning React doesn't prevent that, and it exposes junior developers to marketable skillsets and communities that can help them. Let's give good advice here.
Shame and embarrassment.
The performance advice above is bad, feel free to ignore it. Performance of any JS feature can vary between browser, JS engine, the version of browser or engine, what you're using it for etc. etc. The performance of array functions will change over time, and performance metrics in blog articles can be highly suspect. Further, with any piece of code it's highly likely that there will be significant bottlenecks in other places, so writing random pieces of "performant code" is usually a fruitless endeavor. Unless you specifically need performance improvements, it's best write for readability and maintainability first and foremost. IMO `forEach`, `map` and `reduce` provide much more descriptive, readable and refactorable code than loops. But that's up to you. 
I can't remember what was the pain point when we tried it, something about flexible environment. Could you use new version of python (for example 3.6 with the hude memory reduction)?
Well at least you can set your Babel env target to node 8 now...
Just keep coding! You will learning more by building something even if it's just for yourself. Stick with javascript and build off that.
:(
We are on 3.6.1 on flexible environment. To be fair, I don't have experience with AWS or Azure so I can't really compare them, but we have not had many issues. Though the documentation could stand to be improved, certainly. 
Why would the client ever request that?
True. I don't think it's gives a big performance improvement (if at all?). Just a smaller bundle size (maybe less memory usage?)
Well, it looks like the Vue app is written without any components, i.e. the entire app is just a single, monolithic component, while the React app models todo items as a separate component. Other than that, whatever added complexity you are seeing is just a matter of React's API being more complex and verbose than Vue's, and nothing else. If anything, that example is a testament to Vue's cleaner API and increased flexibility over React.
Hi /u/CompileF5, just FYI, it's highly preferred that you post code samples using an online coding platform like codepen.io or similar. Screenshots make it impossible to copy/paste code (so we can easily comment or iterate on them), obviously.
Hi /u/sssunil9255, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/oneevening, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/spabsa, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/Lojain19, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Hi /u/GohanSolo23, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Put your common components in a different folder, add package.json, and commit to git. Then in your projects you can import the git repo as a NPM package. 
that's like saying "couldn't you handle the sync stuff with functions and values?"
If I could think of any way to do it, it might be through something like an NPM package or separate git repo? You could have some sort of ‚ÄúToolbox‚Äù with components like buttons, input boxes, forms, color/animation constants and all you‚Äôd need to do is ‚Äúimport { Button, color } from ‚Äòtoolbox‚Äô‚Äù. That‚Äôs at least how I would do it
Hi /u/rumyra, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). Thanks for your understanding.
Hi /u/articlestack, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Thanks for your understanding.
Agreed. But for a very large array this will make a difference. Same way an algorithm running in O(n\^2) will not have any significant running time difference from other running in O(nlogn), until the input is very large. Still, these these are worth knowing. On a lighter note this was also about roasting the code :)
I'd suggest looking into typescript or flow. You get to learn about static typing but you'll still largely be writing Javascript. It's two birds with one stone.
You would call that config file before the index.js file based on how you are trying to do it now. You can use ECMA6 import/export but browser support isn‚Äôt 100% yet so you will need fallback options. Last I would change what you are doing and use classes. The configuration can easily be managed in the class constructor. 
GCP? Platform?
Infinite scale. It's really good for ebb-and-flow business models. If your business does 5TB of throughput one hour a month, GCF is a godsend. Also, if you run a primarily static app, this *may* the cheapest solution if you cross the free tier on things like Firebase, or want something just a bit more flexible than Firebase. I worked at a company that seriously considered Lambda (AWS's equivalent of GCF) attached to SES for a non-blocking massive-throughput queue. Honestly, price was the big deterrent.
Yep you were right, all i had to do was call the config first, then the index.js. Cheers man i appreciate the help!
My bad, it should have been /r/learnjavascript
Here's a sneak peek of /r/learnjavascript using the [top posts](https://np.reddit.com/r/learnjavascript/top/?sort=top&amp;t=year) of the year! \#1: [If you're looking to learn javascript, a professor at my college made a really cool free to use online textbooks that includes: exercises, clickable links, and lots of example files.](http://profsamscott.com/javascript/) | [4 comments](https://np.reddit.com/r/learnjavascript/comments/7xd7x0/if_youre_looking_to_learn_javascript_a_professor/) \#2: [To everyone currently enrolled at a college: don't forget to get your Github student developer pack. It contains a free domain name, digital ocean credit and much more.](https://education.github.com/pack) | [13 comments](https://np.reddit.com/r/learnjavascript/comments/8b81be/to_everyone_currently_enrolled_at_a_college_dont/) \#3: [Algorithms and data structures implemented on JavaScript with explanations, examples and links to related YouTube learning videos](https://github.com/trekhleb/javascript-algorithms) | [6 comments](https://np.reddit.com/r/learnjavascript/comments/8l09o2/algorithms_and_data_structures_implemented_on/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
My bad, /r/learnjavascript .. I guess there must have been some drama ...
Hi /u/jstndn, this post was removed. For javascript help, please visit /r/LearnJavascript. Please see our rules, and do know that 'Java' !== 'JavaScript'. Thanks for your understanding.
Google Cloud Platform
Not necessarily. I've seen some pretty awful React and vanilla js in React projects. Same with Angular. 
Which is a problem with the developer, not the framework.
I mean, it is to be good at coding. If you're spending all of your time learning new languages while falling behind in your primary language, then you're probably not going to go far. That being said, I have some great news for you: I make a rather considerable sum as a javascript developer. I'm not expected to code in any other language.
I'm not saying learning React prevents anything. What I'm saying is that if you don't know vanilla js, and you focus solely on React, you're going to be a React developer. That does not make you a good javascript developer. If you only learn how to do things the React way, you're not becoming a better javascript developer. One can learn both, but let's not assume that getting good at React makes someone a better overall javascript developer. There are nuggets of information that translate, like knowing what state is, but that doesn't help a person to know how to manage state in vanilla js, just because he knows how to do it in React.
&gt; ES9 Don't call it that. ES6 was the last single digit "version". Now they're named after the year of standardization (such as ES2018). 
Thanks for the link! I'll share it with my buddy, I'm sure they'll appreciate it
Hi /u/NeSTR-_-CCX, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
Thanks!
Maybe explain what it would do...? 
Oh ok. I guess I had a hard time parsing GP's statement.
garbage
&gt; If you're spending all of your time learning new languages Nobody says you should spend *all your time* learning new languages. But there is also no point to spend all your time learning exclusively only one language. &gt; I'm not expected to code in any other language. Well, good luck with that. 
Yes. That's exactly the point I'm making.
&gt; Well, good luck with that. I've already had excellent luck with it. Thank you.
We can investigate un-garbagifying it if you have any constructive feedback. üòÑ
Trump needs to drop a nuke on Redmond, WA
Most projects have a `dist` folder with the packaged and minified source to be used in a browser.
Sure I'll look into it, but the team's really big on work-life balance.
THanks you saved me!
Now if only they would bring their app script into the modern world, ideally by synchronizing it with their Functions platform.
You didn't saying in your post that would clarify your context, so you opened yourself up for misinterpretation. I'm sorry, but effective communication could have avoided all the downvotes.
Pretty cool.
Coming from Vue/Vuex, sharing state between components couldn't be more simple or straight forward. Redux on the other hand feels like the most complicated over engineered thing ever.
We are on 3.6.1 on flexible environment. To be fair, I don't have experience with AWS or Azure so I can't really compare them, but we have not had many issues. Though the documentation could stand to be improved, certainly. 
That's very interesting, indeed.
I, for one, welcome our new radioactive Seattleite overlords.
Remove the static typing /s
You can use a monorepo (I think this might be easier). Or use several smaller modules, and the main apps that are composed of those. You don‚Äôt want to manually move code around. 
I would evacuate Redmond. Infrastructure is what we're interested in destroying so we don't have to put up with garbage from Microsoft anymore.
Most of the time they have Angular.js implemented and feel continuing with Angular seems right. It‚Äôs hard for them to understand they are different animals and going with React will require same amount of work. Another thing is outside influence. What I mean by that is they talk to friends, other developers, and whoever else on the tech I‚Äôm requesting and they feel Angular is a more complete package out of the box... router, forms, etc... that sounds like a ton of work for them as well. I explain it‚Äôs a matter of installing the correct library and we are good to go. I guess since it‚Äôs not a core library they feel weird about it... dunno. All they see is code time and money.
I'm having trouble figuring out the practical use of `unknown`, the "type-safe counterpart of `any`". 
You can't nuke the cloud, you goof. 
Goodness, finally!
If you think you're going to make a living on one language you're in for a shock. Myself... Early 1980s: Fortran, C and Pascal (to analyse results I was working on) Mid 80s-late 90s : COBOL, Natural - first professional coding jobs Mid 90s-Early 2000s : Delphi - Desktop Apps Briefly Early 2000s :- Cold Fusion - First web systems Mid 2000 onwards: PHP, Javascript - more web systems Recently: Python Honourable mentions in passing (have been paid for code in) Java, C++, Objective-C, C#, VBA, VB.Net. Also I've worked as a DBA betwixt and between so lots and lots of SQL. Virtually every single one of these was *The Mainstream* in one form or another at the time. I see no reason to expect JavaScript to be dominant for more than a decade. 
&gt;please If you make one, I too would love to see it :). If you made a new post I'm sure a lot of people would appreciate it
Great suggestion thanks. The default is indeed 3 full stops. This is because I did not want to assume the character to be available in the used font. The current default served the need I had very well. As I already noticed when I got this message the encoding in the notice turn ‚Ä¶ into &amp;hellip; since this is not a problem I want to introduce by default I'm not convinced the default should change. 
Hi /u/HarmonicAscendant, this post was removed. For javascript help, please visit /r/LearnJavascript. Thanks for your understanding.
The idea is that you use it on the borders of your code, where external untyped inputs might happen. It is a request to the compiler to hold your hand and make sure that you do proper sanitation of data On the other hand you use any if you know that your code is truly type agnostic (think console.log)
If anyone's got questions, I'm around to answer! I work a bit on both the TypeScript and JavaScript languages.
A way of enforcing type checking before use. The RC blog post explains it better. https://blogs.msdn.microsoft.com/typescript/2018/07/12/announcing-typescript-3-0-rc/#the-unknown-type So it's great in that you can assign anything to a type of 'unknown' (similar to 'any') but instead of "assume it can do anything" like we get from 'any' (which effectively arguably just throws away our type checking for that value) we get the "assume it can do nothing" so we're then forced to type check before we can do anything with it. 
There are two ways you might want to handle an argument of a type you don't know. Either it doesn't matter what the type and you can use `any` or it does matter and the function should figure it out, in which case you should use `unknown`. The latter basically forces you to use `typeof`, `instanceof` or some other type narrowing operation before you can use it.
Would anyone recommend converting a project to Typescript, what advantages does it bring apart from debugging?
Or should it be, now that we have `unknown`, what's the practical use of `any`?
Don't care about anything other than the improved error messages. That alone makes me want to upgrade right now.
168 hours in a week. 84 hours should be work. Perfectly balanced. As all things should be.
I would be nice in long chains of functional expressions to just say "oh in this case break" _(data) .where({age:32})
I think the shortest way of explaining it is that `unknown` is a way of forcing users to think about a type before they use it. It's kind of the opposite of `any`.
`unknown` doesn't do the same stuff as `any`, so `any` isn't any less-useful. `any` allows you to do anything you need, whereas `unknown` forces users to perform certain checks before they use those values.
A better `{}`, essentially.
same, probably going to have to wait a few months before angular supports it though
you can also use https://unpkg.com for a quick cdn link. For example: https://unpkg.com/easytimer.js@2.2.3/dist/easytimer.js
&gt;what the hell is the [x : string ] any; about? `{ [key: string]: any }` is the signature of an object with string keys that have any value. Without actual type annotations VSCode can't be too strict with what it infers because JS objects are mutable. For example the following is an error in TS, but not in JS: const foo = { a: 1, b: 2 }; foo.c = 3; In TS `foo` will be inferred to have the interface { a: number; b: number; } but since we can't have our editor telling us perfectly valid JS is an error, JS will use the interface { [key: string]: any; a: number; b: number; } So you still get suggestions and types for known properties, and you aren't prevented from adding keys to the object later. To "fix" this for your code you might be able to use a JSDoc typedef. &gt;I can't find ANY official docs to tell me what to do or if this the correct use of @param {KeyboardEvent} for this situation. https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript 
Ah so \`unknown\` basically requires you to do any necessary type checks at runtime? Cool.
Sounds like you're one of those people that like driving without a seatbelt
I'm more used to Flow, but for me the main benefit imo is reduced cognitive load. You don't have to always remember the shape of objects, the types a function accepts, or anything like that - your editor will complain at you if you use them wrong, and a definition is just a hover away. Just makes a lot of silly simple mistakes impossible so you can focus on the bigger picture. It's of little benefit on small, single-person projects, but when more people get involved it's a godsend.
The biggest advantage is the ability to undertake GIANT refactorings with confidence. With TypeScript can you shuffle thousands of lines of code and pass all your tests on the first try üòù
Makes sense, in terms of consulting I would imagine Angular would be more lucrative due to all of the repeat business in updating/rewriting between versions 
You're underselling it! It also grants us mere mortal developers the ability to write code for hours and having reasonable confidence it'll work when we finally run it. I've written thousands of lines of network-dependent code on long haul flights which worked first time when I had the ability to run it. It is a godsend.
You're describing an anecdotal fallacy. Just because you, in the past, needed to learn multiple languages does not mean that in the present or in the future I will need to learn other languages. Right now, the Javascript landscape is so broad, and Javascript is so powerful, that all I need to know is Javascript. Now, *maybe* at some point in the future I will need to learn something else. But all signs point to that not being the case currently. Now, I've developed in Java and PHP, but I don't consider myself a Java or PHP developer. But there's one thing that I did learn while coding in those languages: programming is programming. The languages are all basically the same. The fundamentals are the same, and now, with Typescript, they're basically even laid out the same. The only things you really need to learn for a new language are the syntax and the nuances. For instance, in Java, you need to know what you can and what you should import. I'm currently working with a C# backend, and when I pulled up the code, it basically looks like Java with more syntactic sugar. The point I'm making is that - as stated - I make a considerable sum of money for being an Angular "expert." If, at any point in time, I start to see the landscape change, well, I can spend a couple of weeks to learn another language, and all will be well. But learning another language is A LOT easier when you have already mastered one, because, as I said, they're all extremely similar.
I think that's largely because a lot of people hate to document properly. 
At the end of the day, the point of typescript, for me, is to give my IDE enough information to know when I am making mistakes in my code, and enough information that intellisense actually works properly. 
So then what's the way to access attributes or functions in the parent without tightly coupling? Honestly curious what other methodologies or philosophies there are on this 
You can't access attributes or functions in the parent without tightly coupling. What the author should have done here is emit a "delete" event from the item, not reach into the parent and make *it* emit a delete event. Then the parent handles delete events coming from its todo items and decides what it wants to do.
Just used this little trick to parse an Axios response into an array of objects. Thank god I remembered it haha.
Redux has the perfect place for handling async, middleware, which does not require any libraries. L
clean coal!
You can use npm to fetch from git? 
If the git repo has a package.json, then yes. See [https://stackoverflow.com/questions/17509669/how-to-install-an-npm-package-from-github-directly](https://stackoverflow.com/questions/17509669/how-to-install-an-npm-package-from-github-directly)
Well the past is generally a pretty good guide to the future. And whilst I would agree that once you can code learning an API is generally more of a challenge than the language I would point out that those you mention - JS, Java, PHP, C(varients) are quite strongly related OOP C syntax derived languages. You might be under something of a misapprehension thinking everything useful is extremely similar, both syntactically and structurally.
Helpful when you want to see the spread of data in large datasets. Made with node.js, express.js and d3.js. Source code [here](https://github.com/ameya98/JSBlot)! All feedback is welcome :)
What do you consider to be the biggest weakness of typescript? Why? 
Regarding the \`defaultProps\` changes, does that mean every reference where I use \`JSX.Element\` I need to do\`LibraryManagedAttributes.Element\`? Also I see in the code sample they use \`...extends React.$1Component&lt;Props&gt;\`, is the \`$1\` a typo or is that now required for the \`defaultProps\` changes to work?
Dang you came out swinging. I guess I asked for it. I think my answer changes based on the day, but it's mostly about type system functionality I wish it had but doesn't (yet). Right now, since I'm working on my library [strict-event-emitter-types](https://www.npmjs.com/package/strict-event-emitter-types), I'm super sensitive to the lack of full [variadic types](https://github.com/Microsoft/TypeScript/issues/5453). While what was added in 2.9 is super helpful (e.g. [this tweet](https://twitter.com/bterlson/status/1023985305911623680) covers some of the magic I can do now), there's a lot of really neat stuff I could do with variadic types. For example, calculating the result of concat/push/pop/etc. on statically known tuple types ala [this issue](https://github.com/Microsoft/TypeScript/issues/24579).
I remember ripping out a highly coupled dependency in my code base, took about 20 minutes to swap out the dependency and I got everything working on the first try. TypeScript is definitely a life-saver there.
Return would break out of a function. Throw-catch will break anywhere you want.
It's not magic, but it's close enough to be indistinguishable in practice.
Now what do you consider to be the biggest strength of the language and how does that play into the long term viability of typescript? 
Biggest strength is my answer somewhere below - how you can confidently do huge massive complex refactorings on a codebase you're barely even familiar with. Even if TS did nothing else, that value is more than enough for it to stick around forever (or at least as long as JS does, or until JS grows a static type system of its own).