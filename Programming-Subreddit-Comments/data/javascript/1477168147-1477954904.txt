What does your function do? Maybe I can help you optimize it...
There are "vanilla modules". This is an excellent explainer: http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html
I literally did that exactly, without the error :P
doesn't work in latest chrome.
What errors are you getting? I'm on the latest version of Chrome and it has worked for me.
Good point. I've noticed that there are significant differences between the habits of industry professional webdevs and the "hobbyist programmers", and it's important to stay cognizant of that. There are so many blogs/tutorials out there aimed at "hobbyist programmers" that show how to use some shiny new tool and all they demonstrate is how to build a "todo app" or some extremely simple "component" that is nowhere near as complex as something that would ever be used on an enterprise-grade application.
Ahh well as someone who developed an app using angular I totally understand.
Most likely isn't there less stackoverflow because fewer people are using it than react or angular? I could release a framework or library tomorrow and there would be 0 stackoverflow questions. But if I had as many people trying to use it as currently use react or angular, I suspect the number of stackoverflow questions would be greater than 0.
&gt; but if you need to support any version of Internet Explorer Just use Babel or TypeScript. ES6 offers a bunch of nice features and async/await is also extremely handy.
There is no way to master all those fundamentals and patterns without working on large applications. And there's no working on large applications without using frameworks. All the tutorials and courses of the world will never prepare you for what you're going to have to deal with when working on live production apps.
Neither `tilt()` nor `sidepan()` are valid jQuery methods, so whatever it is that you're using isn't jQuery. It may be a jQuery plug-in, and if that's the case you have to load it explicitly. 
I'm pretty tired of marketing texts disguised as blog posts. "Inbound Marketing" Anyway thanks for your effort but I wished it would be more in-depth/technical and not just follow the hype, benefits, benchmark, &lt;enter email here/engage into our product&gt; 
What about guys like me. I don't have any experience with a front end javascirpt framework. But I have started with Vue and it is very much understandable from the documentation. Is it the right way to go ?
Setting session cookies is not hard and is secure and well implemented in all major frameworks. It should be used unless you have a very good, well though out reason not to. JWT was not created to solve the general problem of authentication.
Can someone explain the reasoning behind the invention of vuejs? What problem is it trying to solve that react or angular didn't?
well, I guess you just need to remove the "[id]" from the css selector and querySelectorAll should return you a complete nodeList of tags inside your body (if you remove "body" from the css selector, it will select even elements outside of the body tag). Just to make one thing clear: querySelectorAll returns a NodeList wich is similar to an Array but doesn't have the same methods (that's why I converted it to an Array using ES6's spread operator). You can read more about them here: https://developer.mozilla.org/pt-BR/docs/Web/API/NodeList (looks like I could just use forEach instead of transforming it on an Array and using map, welp...)
ummm.. here is my idea. import the data from spreadsheet, to say a database like Mongo, or flat .json, build a basic API, then you can manipulate it to do whatever you want. there is prob a simpler way.
Oh, businesses do this professionally too. But they at least bring a whole bunch of people along with them for the ride, and they don't do it quite as frequently as some hobbyists do. 
Who keeps thinking rebuilding everything every time a new framework is worth it? Who's bankrolling this sort of practice?
No clue on how to implement this tbh. &gt;custom scripts built which will analyze the data Something to watch out for here is data validation. I don't know about Google docs but with Excel you can enforce data validation on cells and for example make sure cells which should be numerical aren't input as string values. This seems like it could become a source of error so might be worthwhile to try and mitigate that by enforcing validation upon input in the sheet if you can. My $0.02
What's there to get? It's a JS front end framework. You don't have to use it if you like how you are doing things now.
It's probably implementation-dependent, because in a browser console I see &gt; Object.getPrototypeOf(document.createElement('img')) &lt; HTMLImageElementPrototype { alt: Getter, src: Getter, srcset: Getter, crossOrigin: Getter, useMap: Getter, isMap: Getter, width: Getter, height: Getter, naturalWidth: Getter, naturalHeight: Getter, 13 more‚Ä¶ } JavaScript doesn't technically have interfaces, but the DOM is described in terms of them. That's because the DOM isn't supposed to be tied to any particular language. [In the standard, it's described with IDL (interface description language)](https://www.w3.org/TR/html5/embedded-content-0.html#the-img-element) which I guess is supposed to be a language-neutral way of describing something. The point is that you have these image element objects, and they're supposed to act like they have a `src` attribute. How that is actually made to happen depends on the implementation ‚Äî in the above output it appears that on this particular implementation they're ES6 getters and setters, but since these are host objects they really don't have to obey any rules. They could act like regular JS objects that just happen to have magic actions associated with certain properties (e.g. setting `src` is supposed to cause the image to load.)
Updated my spider to ES6: https://github.com/fcostarodrigo/Spider
&gt; not needing to jump on every new library that comes around As you shouldn't. &gt; If you're a fan and can articulate why, would you mind sharing? Firstly it's important to understand you can only compare Vue to other frameworks of the same type i.e. ones only addressing views in the typical MV* pattern. For this reason vue is probably the biggest direct contender to : - React - Riot And perhaps an indirect contender to devs who've been using utility libraries such as underscore / lodash, jQuery, etc and have been wanting more of a concrete implementation in regards to organization. As for the comparison of front-end view frameworks. Vue gives a pretty good comparsion : https://vuejs.org/guide/comparison.html Performance benchmarks aside (which can be biased + i havent checked them) the TL;DR version of why i'd choose Vue vs React for example has to do with the way code is being structured. The typical way devs are taught / think about web pages : - HTML tags data. - CSS tells HTML how to look - JS tells things how to behave (not commenting on CSS animations #cantBeAssedQualifying) VueJS maintains this initial conceptual structure in their implementation[(see specifically the HTML section)](https://vuejs.org/guide/comparison.html#HTML-amp-CSS), whereas with react everything is javascript. 
I'm pretty sure by "Less stackoverflow" he means they don't find them selves having to go look stuff up as often. Not talking about the volume of questions that are on it.
I definitely saw improvements in my technique after using this for a while. Like legit mavis beacon style typing
You must be a joy to work with, considering your brash certainty about things you are totally ignorant about.
can it delete tags?
If you want to care about edge cases and implementation details like this then yeah, it's complicated, but that's because JavaScript has more than 2 decades (yes, decades!) and is implemented by a bunch of browsers so it can't change otherwise it breaks the web. If we don't care about implementations details and start using the "good parts" of JS then it's pretty decent, although some stuff like the `class` keyword are subject to heavy discussion.
When I was first trying it I loved the fact that you could just include the vue.js file and start coding without a compile/transpile step. Of course, I've been using JS for 20 years, so going old school like that was like a euphoric breath of fresh air for me. I also like the options that I can use jsx (like react) or templates (like angular). I'm impressed by the benchmarks, though I've been around long enough to know to take benchmarks with a grain of salt. 
&gt; jsx syntax makes me feel physically ill in how badly muddled your markup, logic, and behavior get when they are smashed together It's all a matter of taste, but Vue muddles markup, logic and behavior as deftly as JSX.
Sorry but I don't really see any reason to jump this bandwagon. I read the documentatii√•n and gtvreally angular 1.x feeling about it. I stick to react and redux
I dont have a machine where i can test it right now. Does this throw a good syntaxerror and tell you whats happening?
I'm writing tooling for a game engine in redux + jquery + jquery ui + pixi.js it's been working marvelously..... :P I feel like I'd get burnt at the stake for announcing that stack....
Does browserify count as an module system? Because i'm very happy with it
Chrome console gives a red error as `Uncaught SyntaxError: Illegal 'use strict' directive in function with non-simple parameter list`
Few months ago, I was asked to rebuild a frontend app 1 month after its completion, although it works fine.
Fatigue is only real if you feel like you have to constantly be learning everything the community puts out. You don't. You can just stay up to date, look into libraries and frameworks that you think might be cool, and then when you do your next hobby project, use it to dive into those new things. Staying on top of everything is hard, and you shouldn't even try to do so. Just do what you can, don't make things overly complicated, and start with the basics. If you're just starting, don't worry about react, webpack, or anything else, just learn the DOM. Learn how the language works. Then move on to jQuery, lodash, etc. Then when you've mastered the basics, you can move on to the happy abstractions that make your life easier when you want to do big things.
Well, first of all, map and filter don't mutate anything. Anyways, I think you're talking about generics, which is the whole idea behind the Iterator interface, and Maps and Sets. 
I wouldn't say so. Vue templates are pretty simple and the logic you can put into them is very limited. In my opinion templates should just bind your data to proper elements in your DOM. Everything else is made by computed properties, watchers, validators etc. 
Try Webix, js.devexpress. The main widget in ExtJS is grid. About Grid try FancyGrid. http://fancygrid.com 
[60 million](https://trends.builtwith.com/websitelist/jQuery) sites still use jQuery. The most used ~~framework~~ *library* on the web AFAIK. It has a beautiful API which fixes the shitty DOM API. People talk about it as *dying* because since the extinction of the Internet Explorer, it's no longer the go to ~~framework~~ *library* for **everything**. edit: library
monitorEvents. I haven't known this. Kudos for this one.
There are many articles about [primitive obsession](https://www.google.com.au/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=primitive+obsession+in+Java), it's hard to explain in a comment. &gt;&gt; instead of just building "mapeable" or "filterable" functions/objects &gt; What do you mean? Sorry I will try to clarify. That was just an example, there are many ways of preventing primitive obsession, for example (pseudo code): `mapDomain(toSomething)` or `DomainResult = DomainObject#toSomething` (Uses map). There's also `makeCar(withoutWheels)` (uses some sort of filter) or `CarFleet = CarFleet.without(DamagedCars)` (without method is a filter without having to use the primitive method). That's what I meant by `mapeable` and `filterable` domain parts that implement the `mapeable` or `filterable` interface that Array Literals implement. These are the examples that come from the top of my mind right now. Make sense?
Looks like this is a thing in classical inheritance languages. Why? What problems arise from *primitive obsession*? In your pseudo code, are you creating custom `filter`/`map` methods for different classes?
I love it now as much as I hated it before. It was really just a poor scripting language without a style. And the community has become so active, with sharp experts leading the way...
&gt; Why? What problems arise from primitive obsession? The domain is tied to the language constructs and the objects are restricted to the capabilities of the primitive, which leads to data structures that are harder to extend. &gt; In your pseudo code, are you creating custom filter/map methods for different classes? Internally it doesn't make any difference of what the api is using to filter or map. It can be using `Array.prototype.map.call(input)` or a custom implementation of map, the important bit is that it's not tied to the language the same way it would be tied to a library or framework if I had been using the map feature of them instead of abstracting it into the domain. It's all about not using primitives because it ties the architecture to the capabilities of those primitives. I know prototypal objects allows us to extend them by adding new properties at runtime, but it is a hassle having to mess with the enumerable properties of those primitives in order to get things right. It would make much more sense if JS could allow us to have more tools to wrap and compose them inside our own domain without having to deal with their idiosyncrasies.
Well, thats awesome, it exactly tells you whats up. Awesome.
Yeah, I remember watching a talk a few years ago by someone about React, talking about separation of concerns vs separation of technologies. And I found that a very convincing argument, and it made me get over the "JSX looks weird" or "it's bad to put HTML in your JS" first impressions. Going back to old projects, having to constantly switch between templates and views, figure out how the data used in the templates is generated (especially when using computed properties), what actually happens when a user clicks on something, etc, etc, is really tedious and confusing, and just seems an inferior approach. Who knows, maybe something will come out soon that will change my mind again - but for now a lot of libraries doing it the "old way" just aren't appealing to me.
That's because they want to provide 200+ icons, and a font is a "slick" way to hide all those icons in one container. Semantically it's not good. Most sites use 10 icons or fewer. I'd rather have them as separate files or inlined in a template.
This is about ES2016, not ES6/ES2015. But I kinda agree. ES6 is a very complicated language. Its spec is massive - even though it doesn't cover things like generics, union types, and things like that. I wouldn't say that it's more complex than it needs to be, though. Thing is, it grew over 20+ years, mistakes were made, and breaking backwards compatibility isn't an option. The good news is that you can keep things manageable by sticking to a modern subset + sane linting rules (e.g. Airbnb's). The bad news is that the language is rather hard to learn. The messy ecosystem also doesn't help.
Overall I think it is a logical progression from react. It is not wildly different, which is a good thing. The things I like about React are in there, the things I like about Angular 1 are too. The things I didn't like are largely missing. It's easy to get started, and I don't really see any downsides. It strikes a balance. A lot of times a simple template makes more sense for a simple component. The problem with templates is that if it doesn't explicitly support something, you end up fighting with it. In these situations though, Vue gives you the ability to drop down to the lower level render function and do everything like you would in react. This is a 0 cost abstraction since the templates compile down to a render function (actually I believe the compiler does some static analysis to make the generated render function more performant than a handwritten one). It also comes with more opinions than react. For some people this will be good, and others it will be bad. There's no right answer here. For example it comes with a mobx like reactivity system baked in, so it can know exactly what needs to render, and also let you write computed properties nicely. There is also an official router and official Flux implementation, which reduces the cost of getting started. 
That way of working aims for a completely different sort of web page.
There's not really a "right way to go". Most front end engineering jobs are not going to be so specific that you must have experience in a particular framework. If you know Vue and can talk about it you should be able to get through an interview process even if it's a React shop. Use what you like to use (and what will continue to teach you new things), not what you think the industry wants you to use. Frameworks come and go. Surely this time next year something else will be all over /r/javascript. I say that as a big fan of Vue.
"this" is always set by how you *call* a function, not by how or where it's defined. More specifically, it's set by what's immediately before or after the function call. So, if you call a function like this ... myFunction() ... there's *nothing* before or after it. In other words, you didn't call it like this: someObject.myFunction(). Nor did you call it like this: myFunction().call(someObject). Since you didn't set a "this," the JavaScript interpreter uses the default, which, in strict mode is undefined. In non-strict mode it's the global object, which is window in browsers. function foo() { console.log(this) }; foo(); //undefined (or window) prints in console foo.call(someObject); // someObject prints in console There are three methods you can add to the end of a function, all of which will set a this object: foo(); // undefined or window foo.call(someObject); // someObject foo.apply(someObject); // someObject call and apply temporarily set foo's "this object": foo.call(someObject); // someObject foo(); // undefined or window To make a permanent binding of a "this" object and a function, use bind: var boundFoo = foo.bind(someObject); boundFoo(); // someObject boundFoo(); // someObject foo(); // undefined or window You can also prepend a "this" object to a function, which will work as long as the function is a property of that object: var someObject = { foo: function() { console.log(this} } }; someObject.foo(); // someObject someObject.foo.call(someOTHERObject); // someOTHERObject Which answers your question. When you call filter, do you call it like this? filter(...); No, but if you did (if you could), "this" would be undefined or window, depending on whether or not you were in strict mode. In fact, you call it like this: someArray.filter(...); Which means that "this" will be someArray, *unless* you do something like this: someArray.filter.call(someOtherObject, ...); In which case, this will be someOTHERObject, and that object had better be array-like (e.g. have an length property) or you'll get an error, because filter expects to operate on array-like things. Notes: -- It doesn't matter how or where a function is defined. The rules that apply are the ones above. function outer() { function inner() { console.log(this) } inner(); } What is inner's "this"? Well, how is inner called? Is there anything before or after the function name? No. It's just called like this: inner(); // see above So "this" will be undefined or window. It makes no difference whether or not inner was defined inside another function. If you think it does, you're confusing the "this" object with scope. Sometimes people purposefully save "this" to scope by, in the outer function, typing "var self = this". That adds a variable called self to outer's scope, and, since inner is inside outer, it inherits outer's scope and has access to outer's self variable. That's just an example of a closure doing what closer's do: passing a parent function's vars to its child function. -- ES6 fat-arrow functions are an exception: they don't have a "this" object. Since they don't have their own, they will always inherit "this" from their container, using normal scope rules. function outer() { var inner = () =&gt; console.log(this); inner(); } Here, inner's "this" will be whatever outer's "this" is. So, if we call outer by typing outer.call(someObject), inner's "this" will be someObject, too. -- The only other exception is when you use the new operator to turn a function into a constructor: var instance = new foo(); new causes the context to be a new, empty object (the instance), and that object will be returned, even if foo doesn't have a return statement. -- The only difference between call and apply is how you add other parameters to the call. function add(b, c) { console.log(this.a + b + c) } add.call({a: 1}, 2, 3); // 6 add.apply({a: 1}, [2, 3]); // 6 .call takes additional arguments and passes them on to the function being called. .apply takes an array of arguments and passes it on to the function being called. -- .bind can, if you want, create a curried function. That's a big topic--one for another post--so I'll just add an example, here: function add(b, c) { console.log(this.a + b + c) } var boundAdd = add.bind({a: 1}, 1000); boundAdd(10); // 1011 boundAdd(50); // 1051 
Thank you for the hints and the info. I just got home from work (almost 10:20 pm here in Shanghai) so I'll tackle this again tomorrow morning :) I'll let you know of my progress!
How can it be both non-blocking and synchronous? Do I miss some subtle distinction between the two? 
Start with some intro to JavaScript courses. There are some issues here including but not limited to a paragraph in the head and an assignment in your while loop.
Came here to ask this. 
You're right about the scope of variables - I have old bad habits from other programming languages. I used onclick instead of a loop to keep the code as short as possible. I don't understand your comments about reflow or querySelector. Please provide a code snippet and explain why it's better. 
Still not really sure what your problem is. https://jsfiddle.net/4xerL71x/ Seems to work fine.
I know, but then im supposed to add a return that gves back the value. And then prints it out. Thats where i cant get the value to display
It can clear all tags, but not delete them individually. I can't really think of a case where deleting a single tag would be beneficial. If you can however, please let me know and I'll add it to my to-do list.
They are often used in Java, because everything needs to be inside some class in Java. In JS, you don't have this problem. You can declare functions anywhere and your library module can be also nothing but functions. JS doesn't have named constructors or factory constructors. Static methods can be used to emulate them. A simple example would be a Java-like singleton implementation where a static method calls the private constructor only if an instance wasn't created yet. However, this pattern is complete nonsense in JS. If you want a single instance, you can just use an object literal.
I agree that's a matter of taste, and I'll cop to throwing a biased judgement into that paragraph. To me, there is inherent value in doing new things with older, more familiar syntax, primarily in that there's simply less to learn. That's helpful when you pitch a re-write to a team of 15. I will say that everyone agrees the React learning curve is steep, and the correlation there points to jsx syntax.
It is a way to organise code that is about the class as a whole instead of a single instance. 
Any idea if these more advanced ones work anywhere besides Chrome?
The exotic ones (debug, monitor, monitorEvents) don't exist in Firefox and IE.
 `Math.round()` - static method. `Object.keys()` - also a static method Using `const math = new Math(); return math.round(value);` would be annoying;
I guess I just don't see it. As I understand it, function composition is hooking up the output of a function directly into the input of the next, obeying a specific set of laws. So composing components would be if you could hook the output of one component render function into the input of the next. But that's not how React works nor should it: Components accept props and renders sub-parts imperatively, including children. But children's render output isn't input into their parent's or vice-versa, it happens inside the scope of their parent render function, according to the structure laid out by the jsx and the props and context passed though.
Browserify is a bundler based on CommonJS module system.
Is lychee module system available as a separate project? Or is it tightly integrated with lychee platform?
Didn't know about monitor and friends! That's awesome!
You just made me more confused as to what you're talking about. Maybe try providing an example?
does it have a lot of points to draw?
Yeah, I've enjoyed using Chrome debugger attached to node inspector, especially if you set up a little alias or npm script to launch (and kill stale detached instances of Chrome). 
So adding more gotchas like this is making the language more simple and concise? It seems like the opposite of that. There are plenty of other gotcahs added by ES6. It's getting *more* complex, not less complex. You can't keep adding features without also adding complexity.
Well whatever fits yours needs! The switch is pretty easy too, just use [raw-loader](https://github.com/webpack/raw-loader) and place the output in your span and not in the class. I was looking for a loader which does does this, which is really declarative (the way I like my code) for fonts and couldn't find, so I wrote it instead.
It's a nice way to handle client side validation in MVC.
Try to write it in a way that you only have to append one character at a time. How many nested loops would you need?
This is node.js specific, not for the browser context (from what I can tell). The lib deasync is what he is using to accomplish this: https://www.npmjs.com/package/deasync The description of that package might help.
&gt; What really needed is a way to block subsequent JavaScript from running without blocking entire thread by yielding to allow other events in the event loop to be handled. I see, clever.
Think we're meant to only use one. Row and column. 
I gotta admit, 99 times out of 100, console.log() is all I use and it's quite sufficient (or alert() if I think I might miss something in a lot of output). That 1 out of 100 times is when it's a much more insidious problem and then I'm in full debugger mode and tracing through. I've been doing this a LONG time though, decades in fact, and debugging is mostly an intuitive process at this point, so the console or alert output is just confirming my hunch (which is right the majority of the time). I think less experienced developers are probably better served with a proper debugger most of the time, until they get some dev time under their belts and built that intuition up.
/r/learnjavascript (It's an actual subreddit, I'm not making fun of you)
&gt; Math.round() - static method. Math isn't a constructor function (or class), though. It's just some object with properties. In Java, the math functions are static methods, because everything needs to be inside some class in Java.
You need to UPDATE the field when the value is submitted. Right now the field only gets updated when the js runs the first time. 
\#nothelpinglol &gt; (Array.from({length: 30}, (_, i) =&gt; i / 3 | 0).join('') + '\n').repeat(3) 000111222333444555666777888999 000111222333444555666777888999 000111222333444555666777888999
You don't have to submit the form. You need to run your function when the input is updated though
You mean Varnish, right, not Vagrant? One thing I've done is hook up Nginx to the Redis cache for read's only, then do writes via the application layer. That way you can do the often complicated process of deciding what to write/when within the app. Speed-wise, it doesn't seem to be too bad. We're hitting 3000+ requests per second on the Nginx frontend.
Had modules existed from day one it would have made more sense to be able to import a `random` function from a `math` module. But since modules are pretty new, static methods were a convenient way of grouping things.
Great explanation! Thanks for sharing!
I too haven't heard anyone talk about "primitive obsession", but I googled. It sounds like the difference between, for example, representing a month as an int (a primitive) vs representing a month as a class (an abstraction with clearly defined values, operations, and semantics). I think arrays typically *don't* suffer from the "primitive obsession" problem, because the semantics are already exactly what they need to be: multiple of something. We can represent a month as a class, and we can represent multiple months simply as an array of months. The only reason why we might not use an array directly is if we need special constraints. Maybe our list of months needs to contain exactly 12 unique month objects. *Then* we can ditch the generic array in favor of a more specialized abstraction.
There are many ways to do this, but I believe whoever gave you this problem is expecting to find this solution: var output = ''; // repeat for three rows for (var row = 0; row &lt; 3; row++) { // all digits from 0 to 9 inclusive for (var digit = 0; digit &lt;= 9; digit++) { // repeat each digit three times for (var repeatDigit = 0; repeatDigit &lt; 3; repeatDigit++) { output += digit; } } output += '\n'; } alert(output); (a some smarter solution will appear to be from someone more experienced) 
 var x = 9007199254740992; x === x + 1; Try it in your console. :)
Your code looks fine, except for the `if`but we can talk about that later. Please show us your HTML.
Hehehe `Number.MAX_SAFE_INTEGER`
Why in the world would you check that on your development environment?
I would honestly start learning React and then start introducing Node/Express/MongoDB as your hobby SPA project integrates / relies on a data source.
I admit I'm too lazy... 
https://www.npmjs.com/package/ticker-log can be useful in showing console statements on-screen 
Reminds me this [talk](https://www.destroyallsoftware.com/talks/wat) from Gary Bernhardt.
I think it's much more efficient because the method doesn't have to be created on every single instance. Having said that I've never tried a jsperf on it or anything like that. 
I wish someone would rewrite all the popular jquery plugins without the jquery dependency.
I mean, it has been obsoleted even before it was included in the JavaScript specs. It is not a part of the language.
Yeah, even in that case I always explictly convert the value and then use `===`. I have enough JS weirdness to worry about without bringing `==` into the mix.
Thanks, I took a look and seems interesting. Another thing which I didn't originally mention is‚Äîlearning the syntax/language takes time, then the API, then the tooling. After a while to pile on (while interesting) algorithms gets a bit much. Personally I love "high order functions" i.e. reduce, filter etc. But to me it would be like having the skill to illustrate the human form with all the accuracy and precision in regards to anatomy and the like. At some point someone is going to say "How long did that take you?" And how many people are going to appreciate that amount of elegance in your work? 
Same here. Anyways, normally you would not be testing a value against a direct number like that. Real life example would probably look like : `parseInt(someVal) === SOME_CONSTANT_VAL` thus putting emphasis on the importance of explicitly converting the value. Reading this you could know instantly that you're testing an Int vs another one without know what's in that constant.
Readability is a great point. My first instinct when reading something like "2" == 2 would be that someone made a mistake and I should fix it. 
You can save a few bytes with template strings: `${Array.from({length: 30}, (_, i) =&gt; i / 3 | 0).join('')}\n`.repeat(3)
Only ever used d3. Can recommend that.
That's behind a paywall üòï
Yes, sorry, brain fart.
This isn't so much a Javascript failing as running out of space in the data type. It's equivalent to UINT_MAX+1 == 0 in C. There just aren't enough bits to represent the number. https://en.wikipedia.org/wiki/Double-precision_floating-point_format
Many style guides even include this as a standard (as `eqeqeq` in eslint) so you have to use `===`. `==` made more sense if you don't think of ecma as a real language that you'd program serious things in, but just something that manages a few input fields (but the logic is almost entirely declarative in the HTML). The most common case is to not have to care about casting your vars if you compare strings to numbers. e.g. if you're reading user input and someone types in 5, you actually have the string `"5"`, but you could compare directly to a number, since `"5" == 5` but not `"5" == 4`. Nowadays you're going to make either your PM or whomever has to maintain your code in the future (probably you) very angry if you don't explicitly cast. `5 === +myinput` is more clear and less error prone.
I worked on a project where the webservice I called, returned a status message with every response (since it called other services which might fail). It would sometimes return success: true, sometimes success: "true". I therefore had to stop type checking when evaluating the response, since (true === "true") is false.
Yeah and while !([] + "true") == [] and !([] + "true") == ![] also, Still !([] + "true) != ([] + "true") fortunately.
I might be slow but why is the array on the left hand side first converted to a string? And not first a boolean as well?
You could also have typecasted it to true with`Boolean("true")`, but then again if it sometimes returned `"false"` then yeah, you would need to use the `==`.
It's just a name space. You associate a helper function with the constructor of the object it's suppose to help. The main use case is to provide an alternative way to create that object; e.g: - `Promise.resolve(value)`. - `Array.from(someArrayLikeObj)`. 
They are same as static methods in every other language, to provide a something that is certainly "class related" but do not require instance itself. For example a static method that implement singleton pattern and return its instance if it does not yet exist.
There is an ambiguity on what "primitive" means and it's meaning depends on the context. If I were talking about primitive values of the language, this thread would be talking about `Undefined, Null, Boolean, Number, Symbol, or String`, but it's not. /u/MoTTs_ is [spot on](https://www.reddit.com/r/javascript/comments/58x8mb/ask_rjavascript_what_are_your_thoughts_about/d94kz1p/): &gt; It sounds like the difference between, for example, representing a month as an int (a primitive) vs representing a month as a class (an abstraction with clearly defined values, operations, and semantics).
i have only used this http://www.highcharts.com/
It sounds like the problem is not with yarn...
&gt; It sounds like the difference between, for example, representing a month as an int (a primitive) vs representing a month as a class (an abstraction with clearly defined values, operations, and semantics). You are right. Your example is if we are working in a OOP style, it can also be a simple function wrapper if we are talking about FP. &gt; I think arrays typically don't suffer from the "primitive obsession" problem, because the semantics are already exactly what they need to be: multiple of something. I would argue that semantic is too low level (primitive) and require us to work too close to the native API. As you say, if we need special constraints it might be impossible for us to change all the places where that array is being used to account for the new functionality. For example, if we are iterating the months with an Array Literal holding an Object Literal: for(month in months) { month // =&gt; {} } If we add a new property to `months` like a factory to build a date from all months, for example (`months.asDate()`), then `asDate` will be iterable in the `for in`. If we could just wrap the "primitive" Array Literal in our domain then it would be much easier to just add the functionality we want in our wrapper instead of having to deal with everything in a single object representation. Our wrapper would become iterable and it would choose its way of how to iterate itself without exposing the primitive implementation details.
I've used and enjoyed [NVD3](http://nvd3.org/). It has a bunch of great chart types.
Second this. Found it rock solid and has plenty of charts. 
Maybe [this answer](https://www.reddit.com/r/javascript/comments/58x8mb/ask_rjavascript_what_are_your_thoughts_about/d94kz1p/) will help?
Maybe [this comment](https://www.reddit.com/r/javascript/comments/58x8mb/ask_rjavascript_what_are_your_thoughts_about/d94kz1p/) will help?
You **can** wrap (extend) the built-in Array class with ES6 classes. Same with all built-ins, including Map, Set, TypedArrays, etc
it's worth noting that you should always provide radix to parseInt (e.g. `parseInt("2", 10)`) since it can behave differently depending on the string formatting (e.g. `parseInt("0700")` would produce `448` considering 0700 to be an octal)
We had a discussion around this not long ago, [plug](https://www.reddit.com/r/javascript/comments/589wfx/subclassing_builtin_constructors_yay_or_nay/). To me it looks like this could be cool but I haven't seen much fuzz about it besides people shitting on the `class` constructor in general. Maybe I'm missing something..
Jquery plugins in 2016? 
Nah, it's a known issue, if you have bower.rc, it loads the dependencies and then drops them, emptying the bower_components or whatever directory in bower.rc
C3 is nice because it's an abstraction on top of D3, which means you might gain some efficiency without losing the power of D3
You can specify whether a property should be enumerable if you want, [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)
Ah yeah, the "ridiculous input results in ridiculous output" talk that people love to parrot to explain why &lt;language they don't like&gt; is bad and everyone who uses it should feel bad? 
&gt; If we could just wrap the "primitive" Array Literal in our domain then it would be much easier to just add the functionality we want in our wrapper instead of having to deal with everything in a single object representation. Our wrapper would become iterable and it would choose its way of how to iterate itself without exposing the primitive implementation details. I think I understand what you're saying. For example, I've been learning C++ recently, and to be able to iterate over any arbitrary type, the standardized convention is that iterable types must implement member functions "begin" and "end". That way, it doesn't matter if your'e iterating over an array or a linked list or a tree or a hash table or any other arbitrary user defined type, we can always iterate just like so: for (auto i = whatever.begin(); i != whatever.end(); ++i) // ... And it sounds like you too would like a consistent iterable interface. Not "begin" and "end", of course, but maybe something like "map". And you'd like to wrap array literals in an object of your own design so that you can implement that consistent iterable interface. I'd say that's a good goal... except [ES6 beat you to it](http://exploringjs.com/es6/ch_iteration.html). ;-) It turns out we can upgrade our arrays into more specialized wrapper objects and still maintain their iterable-ness. // The original, "primitive" design // const monthsArrayLiteral = [1, 2, 3]; for (let month of monthsArrayLiteral) { console.log(month); // =&gt; 1/2/3 } // The new specialized wrapper // const monthsCollection = { _months: [1, 2, 3], asDate() { /* ... */ }, [Symbol.iterator]() { const months = this._months; let index = 0; return { next() { const nextValue = { value: months[index], done: !(index &lt; months.length) }; index++; return nextValue; } }; } } for (let month of monthsCollection) { console.log(month); // =&gt; 1/2/3 }
(‡≤†_‡≤†) try { throw new TypeError("Gotta") } catch (em) { all(em) }
It would have been incredibly cool 10 years ago when Array was missing so many useful methods, and we relied heavily on libraries like PrototypeJS or Mootools. Today, the standard has incorporated the most useful ones, so it isn't as big of a deal anymore to make our own better Array type.
One fewer character, downloads 33% faster... /s (though sadly I've heard this argument made un-ironically.)
Yes, features like block scoping and arrow functions (with the way they handle this) make it much easier to write simpler and more concise code. The complexity of the entire language matters little to me if their is a subset that allows me to do what I need in an elegant way.
And obviously `!![] != ![]` :)
And also: `!{} != {}`
Can you run this through 100 generations of Conways?
Yes, but luckily `typeof NaN === "number"` is `true` so everything makes sense now.
To the insane asylum with ye
The fuck... 
I never said there weren't gotchas in other languages. What I said was that adding a shit-ton of features to a language inevitably makes it more complex. Javascript *was* a simple and powerful language, and now it is a becoming more and more complex. This 'strict mode' article is a perfect example of how javascript is more complex, easier to misunderstand, and it's getting more gotchas, not less gotchas. 
also `"string" === new String("string")` is ... drum roll please ... ... `false`! Congratulations, you are the winner of your very own silent error!
Yea I literally never use ==. One of the nice things about standardjs is it prohibits it except for I think one scenario.
Yea I literally never use ==. One of the nice things about standardjs is it prohibits it except for I think one scenario.
Indeed you should!
Yeah, my team is using chart.js in a rather large project and liking it a lot.
What does boxed it mean? 
D3 - If you want to start from scratch and has endless possibilities for your client requirements. Learning curve is steep. Am charts, high charts, nvd3(Based on d3) - All of these are prebuilt libraries which you can use to get results instantaneously. But restricted to the inbuilt features.
Very interesting https://en.wikipedia.org/wiki/NaN
So FreeCodeCamp had me kinda build quite a few SPA actually. I don't know if it was in ES5, but I just used regular JavaScript so I'll assume it wasn't. But I feel that it's important for me to approach learning JavaScript well.
TIL the JavaScript Equality Table is Turing complete by itself. /s
This feels more like self promotion than a resource to learn. Even has a signup wall to read any courses 
&gt;you need frameworks less and less What we can't do 5 years ago in browser and can do now?
I have tried them all and I must say I liked [canvasjs](http://canvasjs.com) the best.But it wasn't hands down the best, just the best suited for particular app i made that also just so happened to use React as well. I actually made a video about it were I discuss the charting libraries I used in this [youtube video here]( https://m.youtube.com/watch?v=lE2TMC8UwGQ ). Sorry for the weird grammar it's hard to use Reddit on mobile.
Nice writeup, a though process every JavaScript programer should be comfortable with. If I were to highlight a word here, that would be *coercion*.
I didn't knew any more examples, and yeah should've mentioned it aint constructor :/
Equality checks are one of the cheapest operations you can do, whether `==` or `===`. The performance difference doesn't matter. They have different behaviors and give different values. You should almost always use `===` and almost never `==`.
Sounds more like, "you don't need jQuery" than "you don't need a framework." If you're doing a project with a large scope and complexity, you should be using a framework. 
Well, there are many different UI CSS component libraries, like Bootstrap and Foundation. There's jQuery UI, which has a few nice utilities for drag and drop, moveable dialogs, etc. You might think about using a framework depending on how many components you think you'll need. 
People bring this up like it's weird, but it's not. To quote straight from Wikipedia: &gt; In computing, NaN, standing for not a number, is a **numeric data type** value representing an undefined or unrepresentable value, especially in floating-point calculations. It represents numeric data, hence why it's type is number, even if it specifically represents the absence of a valid number.
You should look into the Ramda `pipeP` and `composeP` methods. http://ramdajs.com/docs/#pipeP http://ramdajs.com/docs/#composeP
Not necessarily. Some helper libraries of course if needed, but who says a framework is compulsory?
The purpose of frameworks is to make complicated things easier by lowering the cognitive load on the developer. This is don't by abstracting away updating the document into something that can be a single function per component. It's not compulsory, but it sure as hell will make your life easier.
yeah, if it was intended then I'd expect it being preceded by a `// eslint-disable-next-line`.
[MDN reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference) Rauschmayer's [Speaking JavaScript](http://speakingjs.com/es5/) and [Exploring ES6](http://exploringjs.com/es6/)
What I mean is, are things really anymore as complicated as they used to be? Sometimes frameworks are the ones making things complicated and we don't even realize it. Just think about it: how many times you've wondered how to do this and that with framework x and y. Or why doesn't the thing you want to do won't work with framework x or y. With the DOM itself there's amazing documentations like MDN / W3Schools and everything's standardized and well thought through. And there's no worry of everything changing every year, because (almost) everything's always backwards supported. How many times you've had to rewrite, because of the change of framework or just a version. What if you'd use just the web standards? You wouldn't had to rewrite anything.
Check out my talk from HelsinkiJS / Frontend Finland and you might understand better what I mean: https://www.youtube.com/watch?v=0nh2EK1xveg
The spec says for `x == y`: &gt; If Type(x) is Object and Type(y) is either String, Number, or Symbol, return the result of the comparison ToPrimitive(x) == y. `ToPrimitive(x)` on an empty array is an empty string. Then you're comparing an empty string to a number, so you then call the abstract operation `ToNumber(x)` on the string to compare it with another number. 
I had just built a utility function to solve this less than a few hours ago too. export const fnCascadePromiseThunks = ( aThunks ) =&gt; aThunks.reduce( ( p, fn ) =&gt; p.then( fn ), Promise.resolve() ); and promiseThunks are built like this, on demand: const fnMakeThunk = ( seq ) =&gt; ( aPreviousResults = [] ) =&gt; new Promise( ( resolve, reject ) =&gt; { // async fetch in my case fetchPost( `${CONST.ADDR}/callSomething/`, { seq } ) .then( ( result ) =&gt; resolve( [ ...aPreviousResults, result ] ) ) .catch( reject ); } ); then... fnCascadePromiseThunks( _.map( seqList, fnMakeThunk ) ) .then( ( aResult ) =&gt; {/* got 'em! */} ); One weakness of my implementation would be `undefined` returns I guess.. but this was enough for me. 
Because you can't animate hidden. Hidden will instantly hide the element.
Interesting, i can certainly see applications for this pertaining to ngrok. &gt; What's missing? What do you want to see next from us? How can we help make your lives better? You already have zlib implemented, i'd like to see implementation regarding code diffs / delta's to save on bandwidth even more. May only be relevant when updating staging dev environments in the cloud but every little helps.
Aha. Great comment - as a registry / package management tool our goal isn't to compete with GitHub (or GitLab, or, well, git in general). GitHub should still (ideally) still be your central source for managing diffs / code reviews / etc. I'm not sure right now how much of what you're asking for can be done with the right GitHub integrations and how much we can build ourselves - we'll have to scope it out. Thank you!
Ask /r/DoMyHomework/ or /r/javahelp/.
Thanks for the mention. * ‚Äú[Speaking JavaScript](http://speakingjs.com/es5/)‚Äù covers ECMAScript 5. * ‚Äú[Exploring ES6](http://exploringjs.com/es6/)‚Äù covers ES6 (=ES2015). * Additionally, there is ‚Äú[Exploring ES2016 and ES2017](https://leanpub.com/exploring-es2016-es2017/read)‚Äù. All three books are free to read online.
It's not weird, it's just counter-intuitive nomanclature
caveat: might result in numbers with floating point which might be not wanted
Never said they should be equal. Just pointing out it can be a source of unexpected error. Like if `this` refers to a primitive string and is passed as an argument it becomes a string literal if you're not running in `use strict`.
[YDKJ](https://github.com/getify/You-Dont-Know-JS) by Kyle Simpson
This. To clarify, `value !== undefined` will throw a ReferenceError that `value` doesn't exist, while `typeof value !== "undefined"` while run along like everything is fine
Well now that's in my search history
"made an object out of it", or "objectified" if you will.
Promising because it's open source :) Cheers for the mention
It can often be used for metadata about the class. For example, React components can define static methods or properties that define the component's PropTypes (a piece of React metadata that helps validate code). Another example might be a class that might have methods that return an enumerated string ("one of `['hello', 'goodbye']`" for example), and it might be helpful to know what go in that enumeration. I'll throw in a bonus example. class Greeter { constructor(greeting) { if (Greeter.canGreetWith(greeting)) { this.greeting = greeting; } else { this.greeting = 'goodbye'; } Greeter.theresANewGreeterInTown(this); } greet() { return this.greeting; } static greetings = ['hello', 'goodbye']; static canGreetWith(greeting) { return Greeter.greetings.includes(greeting); } static greetersByGreeting = {}; static theresANewGreeterInTown(greeter) { greetersByGreeting[greeter.greeting] = greetersByGreeting[greeter.greeting] || []; greetersByGreeting[greeter.greeting].push(greeter); } static getHelloGreeters() { return Greeter.greetersByGreeting['hello']; } }
Makes sense, thanks. 
Such elegance.
Don't forget the [radix]( https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/parseInt) if you're using `parseInt()`. `parseInt("2", 10) === 2`
Surely you have at least 2 1-char variables on either side of that operator. So in essence, you're only saving a maximum of 20% as you're reducing 5 characters down to 4. x===y vs x==y So even if the argument is made un-ironically, it should be made accurately.
I think you're going to enjoy a [Javascript journey with only six characters](http://jazcash.com/a-javascript-journey-with-only-six-characters/). See, e.g., [jsfuck](http://www.jsfuck.com/).
Yeah I saw that the other day. Loved it. I think it was that article that spurred me on to dig a little deeper. 
Awesome, i will look into it! :)
Oh JavaScript #wat
The coercion also explains why [] == ![] &gt; true but [1] == ![1] &gt; false In the final comparison step, the value of [1].toString() is compared to the integer-coerced value of false, so we have 1 == 0
I started to recreate my [HTML5 Deck of Cards](https://deck-of-cards.js.org), you can check it out here: https://github.com/pakastin/cards
ahhh... that was a stupied msitake of me ! thanks
You sounds like a kid itching to sit at the grown up table
Here it is in Life 1.06 format. Use your favorite life app or import it into https://copy.sh/life/ Spoilers: it stops at 22 #Life 1.06 1 1 3 1 8 1 20 1 2 2 4 2 9 2 11 2 16 2 18 2 19 2 1 3 3 3 8 3 20 3 2 4 4 4 9 4 11 4 16 4 18 4 19 4 5 5 10 5 6 6 7 7 1 8 3 8 8 8 20 8 2 9 4 9 9 9 19 9 5 10 10 10 2 11 4 11 11 11 16 11 18 11 12 12 13 12 12 13 13 13 14 14 15 15 2 16 4 16 11 16 2 18 4 18 11 18 2 19 4 19 9 19 1 20 3 20 8 20
Oh my mistake, I should have clarified. It's JSX that I don't like. I'm aware that you don't have to use JSX, however, on my team we do.
Thanks! I'm not sure that's exactly what I'm looking for. I'm not really looking for some cross-platform, i.e., working on mobile, web, etc. I'm simply looking for something that will allow non-technical users the ability to select a template for example which will load a new page and then from there they could drag/drop items into the page like images, text areas, etc., and create basic flyers/brochures which they then could save as PDF. Something like this maybe: https://carrd.co/build. Select a template and then you'll see the sort of features I'm looking for. 
Thanks. I'm not totally worried about design as I'm comfortable there and haven't really ever liked trying conform to fit something like Bootstrap or Foundation. I'm basically only talking about the interface where non-tech users could "design" their flyer/brochure on screen. Here's a good example of something I'd be aiming for as far as on-screen functionality for altering elements: http://carrd.co/build &gt; select a design and you'll see the interface they use for "building" your carrd.
Why don't you like it? It's HTML with a few caveats but you most likely learned all of them your first day with React...
This seems to have been written from a pure server side web perspective. JS is becoming a real language for real solutions in many ways, in both server as well as desktop situations. A desktop app written using JS in Electron is usually around 50MB. Any application written in Qt needs at least 100MB in supporting libraries in order to function, and that excludes the app itself. 
If you use Webpack you can use the DefinePlugin with a global (e.g. `DEVMODE`) so that you can write something like `if (DEVMODE) console.log('hi')` and have it be pulled out during production builds.
That's an implementation detail. Your input component should adjust behaviour based on incoming props, is what I meant. 
TBH I don't see why someone would push console.logs and debug code to production.
Why would one want to do that ?
See it as something like "an arbitrary number of values" or "a number of values likely unknown at compile time". Math.max(...[2,100,1,6,43]) Isn't the best example, because using an array literal shows you know exactly the number of values and could just as well done Math.max(2,100,1,6,43) But for demonstration purposes, it shows that any array can be used that way, even something that is dynamic and could change between calls Math.max(...someArbitraryArray) Similarly, with ...rest, you don't know how many values are going to be passed into the function. So that unknown quantity is represented with "..." (fixing the typo in the link's example). function printf(format, ...params) { console.log(...params); } Here, printf could be called with 1 arg, or 20 args. Its an unknown quantity until the code is run. The context determines the direction of the values. Are you taking a collection and converting it into many values (spread) or taking many values and making a collection (rest)? Ultimately "..." is the middleman between that transition. 
Transpiled is preferred, definitely. But if you're hitting performance bottlenecks, maybe those places can be ok, getting by with the original code so long as its ultimately tested more thoroughly further down the line as transpiled.
Really? What alternative nomenclature would you suggest? `NaN` is specified by the floating point standard. 
Kind of light on details - like how does HTML handle forms better now, how broad is that support across browsers/devices, how customizable is the behavior and display within that support? How is AJAX dead? What replaces AJAX in a less expensive way? This seems more rhetorical and anecdotal than proven out in any meaningful way. 
Wow what a great article
That actually a problem.. My tests need special babel plugins because they use features that distribued code is not using
Yeah but when writing unit tests we are supposed to test and only test our logic.. that's why mocks and stubs exists.. not to overkill unit tests and only to focus on our logic. I'm I not supposed to trust BabelJS?
Can you recreate this in jsfiddle or codepen? The code you've pasted isn't logging the same values, as you've commented out the relevant line in the second function.
https://github.com/StefanKjartansson/drf-react-skeleton
That's hasn't been true since ES5 support has become ubiquitous, `parseInt('0700');` produces `700` in all [compliant ES5](http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.2.2) environments. The only time the radix is inferred as anything other than `10` is when the string is prefixed with `0x` or `0X` and then it is assumed to be `16`. I'd still recommend it for readability though, I prefer to be explicit so other devs maintaining my code have fewer misunderstandings about what I intended.
I call bullshit in that one person's ignorance is not another person's problem. Seriously consider how much people spend to learn Java in a major 4 year university. Then consider the speed of code delivery and frequency of iteration achievable by a developer in that language. Compare that to JavaScript. Although JavaScript might execute 4x slower on a modern multicore machine compared to Java, I would argue it is massively cheaper to train people and develop in. So much cheaper that the cost reduction (fewer developers and more rapid iterations) make up for the performance difference by substantial factor. &gt; IMHO both are true and I'll try to explain that later. But nobody says what should be evident by now: JavaScript is failing. They forgot the third alternative.... ignore all the trendy crap that you really don't need. Bam, fatigue problem solved. Learn the standard technologies first. Then if you have energy left over to waste on the madness you can choose to do so (personally, I would rather watch a movie or go for a walk).
... is used in two contexts : * One is to "spread" a given array/object's keys as arguments * One is to gather "rest" of the arguments in an array So if you do const joinNames = (with, ...names) =&gt; names.join(with); You'll be getting rest of the params after with (first one) in names array. This is rest operator And if you do const names =['Andrew', 'Salman']: console.log([...names, 'Picaso']); You'll be spreading names array into comma separated arguments. This is spread operator.
huh, that's neat! somehow missed it. thanks for pointing out!
So you're saying `typeof NaN === "a non-valid number"`? What use would that be? What actual code would that be good for?
No. I'm saying it's stupid `NaN` is called `NaN`, since it's a number
It's not a number. It's a specific value used by a numeric data type to represent an invalid number. There's a difference between a "numeric data type value" and a "number". `Infinity` isn't a number either, but it's also numeric-type data.
This article feels like a collection of random statements about JS tied together with no regard for relevance and no real insight into the state of the ecosystem. "jQuery is a library that a lot of people use. jQuery simplifies DOM operations. jQuery downloads faster from a CDN. ES6 added arrow functions and stuff. You can use a package manager, or you can not use a package manager, if you like." --- http://stateofjs.com/ is a far better article on the state of the JS Ecosystem.
 { "name": "test", "version": "1.0.0", "description": "", "main": "index.js", "scripts": { "build": "babel src -d lib" }, "author": "", "license": "ISC", "devDependencies": { "babel-cli": "^6.16.0", "babel-preset-es2015": "^6.16.0" } }
https://babeljs.io/docs/usage/options/ The default for minified is false. You can try explicitly setting that. "build": "babel src -d lib --minified=false" If that doesn't work then I've no idea.
Oh. Now it makes more sense. I thought ... []... []... [] was building a new array. Thank you! Now what I have left is understand the special cases for arrow functions and their common idea.
Thank you, i guess i was asking is what are the advantages of running node in a JVM. 
No problem. If you need anything else Joe let me know.
Could have gone val
I think you forgot to post a link.
Javascript didn't have any kind of module definition format built into the language originally, so the community invented several approaches, each intended for a different use case (CommonJS, AMD, etc). At the same time, libraries needed to support being loaded with each of the different module formats, so people came up with a pattern that allowed one file to work with each of the formats (UMD). The JS language spec finally added a module format with the ES6 language version, but that only specified the syntax, not _how_ to load files. Yep, it's complicated :) My [React/Redux links list](https://github.com/markerikson/react-redux-links) has some relevant sections for this. The [Basic Concepts](https://github.com/markerikson/react-redux-links/blob/master/basic-concepts.md) section points to overviews of Javascript terms, concepts, and technologies. Also, the [ES6 Features#Javascript Module Formats](https://github.com/markerikson/react-redux-links/blob/master/es6-features.md#javascript-module-formats) section lists several articles describing the history and usage of the various module formats out there.
Do you think this code will slow down the browser? Noob here
Nope. Minified loader code is 4.300 KB, webfonts used by theguardian.com are 196.4 KB. Also, the point isn't to "cache harder" or something, it's to avoid a flash of invisible text. Read the first line of the linked file. If caching were the only goal then they'd just use caching headers.
&gt;The malware arrives on user PCs as a malicious file attachment via email spam, and despite being a JavaScript file, it is not executed inside a browser, but via the Windows Script Host, the Windows built-in JavaScript executor. There was a better write up posted to r/javascript about a week ago that went into the details a little better.
Amen. What was wrong with "con"?
I prefer: const thing7 = "thing7"; const thing8 = "thing8"; Easier to rearrange (especially if git is involved) and automatically aligned.
Super neat.
Man, this sub is volatile, haha. I got a pretty negative reaction when [I mentioned the same thing a few months ago](https://www.reddit.com/r/javascript/comments/4h2ryt/how_much_performance_does_using_const_with_es6/d2mwwmb/). I agree with you, especially in cases where you have a mix of const/let variable declarations like: const var1 = [] const var2 = {} let var3 = 30 let var4 = 40 It would look neater if you used `let` everywhere (although of course you lose the added safety of `const`) let var1 = [] let var2 = {} let var3 = 30 let var4 = 40 Although I have seen a lot of people who *do* use `let` everywhere, and only use `const` for imports and for the old way of declaring "constants": const fs = require('fs') const MINIMUM_PAYMENT = 5 // Use `let` for everything else I know Mozilla does it that way ^
Pro is to con as progress is to ________.
Nice. Is this quick enough to run real-time? i.e., panning across an infinite procedural-generated background?
Sadly it should've been `var` and `let`... unfortunately `var` was taken. :(
Amcharts = ‚ô°
[removed]
Then you suck at merging.
conquest
But what if you have a mix of `const` and `let`? const thing7 = "thing7"; let thing8 = "thing8"; I imagine you wouldn't do this: const thing7 = "thing7"; let thing8 = "thing8";
This. Just wasted some precious minutes. Edit: Very nice article you mentioned! Subscribed to help next year.
I'll certainly take a look! Won't be for a fair few hours though; y'anno, work and all that tedious boring stuff :( haha Having said that I have been able to get away with coding at work before.. though that was semi-work related :P
Love it! Some nice shader explanation there too, I really need to start understanding those!
Both good ideas, I'll do that when I get home. Thanks for the feedback :)
Work on bringing ES6 modules to Node.js is also progressing nicely. I wouldn‚Äôt be surprised if we had broad cross-platform support for ES6 modules (incl. loading) in early 2017.
true - but that's more code to write ;) to be honest i'd rather leave them in and have the logger disable them. also, i could potentially run a production build with logging enabled to track down elusive bugs...
Easy solution, don't align
In fairness, "const is 5 letters long" is pretty off-topic in a thread about the performance implications of `const`; I'm not surprised you got flak for that reply.
I use `let` so infrequently that it's pretty rare that I actually see `const` and `let` mixed.
there is a demo at the bottom of the page, it's really fast, even at 4k resolution
You have a point, but it's also about using the right tool for the right job. If you're looking for mass parallel performance, you'd be better off with languages more optimized towards that. Not to say that there aren't jobs which are unsuitable for Java or other general purpose use.
That's true. `const` was a reserved word long before it got actually used. It already was in ES1's list of future reserved words. It has been there since 1997. `import`, `export`, and `class` also have been there since the beginning.
&gt; I know Mozilla does it that way I also do it that way. If I have a handful of short-lived variables, I don't really care if they get assigned some value just once or more than once. The write and read aren't that far apart and you have to read both lines either way. There doesn't seem to be any tangible benefit. It doesn't simplify my mental model. I'd only go with immutable bindings everywhere by default if they were less work. E.g. like "let" vs "let mut" in Rust. What actually would simplify things is if the editor would color single-write variables (no matter if it's const or a single-write let) differently.
At least it's not "constant".
I get the exact same results for both functions on Safari. There are a few things to consider: Like I said before, you've commented out the relevant output in the second function, so I'm not sure you're looking at the right numbers. The second function is fired from the scroll event, so the numbers *should* be different as you are returning the position relative to the viewport. I'm sure this one is an edge case, but safari will scroll past the normal document constraints for its elastic effect, so the position could be unexpected while the screen bounces, but the coordinates should still be accurate. 
 let agree = true;
Instead of forEach and push, you should probably just use `Function#apply` like so: arr2.push.apply(arr2, arr1);
agree = false; Sucker, shoulda used const!
Read up on their slack channel. Although RethinkDB as a company is shutting down, RethinkDB is very much alive. The RethinkDB owners are working through all the legalities and helping all the people that will be maintaining it as a community driven open source project. Edit: And they started releasing weekly updates last week. Next update is tomorrow.
Gotcha. So they're moving to make it a more community driven project. That's definitely interesting but I would expect it to prevent them from achieving larger adoption as I don't expect large companies to bet on the community driven database when there are corporations that support other databases. I'll take a closer look though, thanks!
FOUC and FOIT both can go really bad. It is very noticeable in CJK fonts easily eats up 3mb per a weight if you need to support all the exotic letters. (cutting-edge optimization can cut it down to 700kbs -- per a font weight -- but still.) Mobile browsers often freeze their main thread only to decode a ttf file. (this is a case where caching cannot help) `[a-zA-Z0-9!@#$...]` ? pfft. try `[a-zA-Z0-9Í∞Ä-Ìû£]` üòÜ
Some of the core devs are committing time towards continued development, which is awesome. I was thinking the same thing, but there's plenty of community driven projects that either get used by corporations and/or get funding from them after they gain popularity. I guess we'll see what happens. 
I'm very surprised Node.js hasn't implemented modules yet. Require syntax is fine, but explicit imports just seem cleaner.
Yeah that's true, but based on the responses it seemed like it had more to do with complaining about `const` rather than it being off-topic.
There are different philosophies between CommonJS and ES modules which cause some strange edge cases where the two systems are used together. There has been quite a large discussion with Node and between Node and the standards committee to help find solutions to these problems while preserving the existing ecosystem.
Yea, I guess the fact that some libraries will need to be loaded in the browser and in Node is going to cause some debate when compared to any other language that will almost be always loaded in the same environment. I just can't wait for HTTP/2.0 and modules to become the norm.
I see your edit. What part is giving you trouble now that you have a general algorithm?
Didn't know people worried about that too. One of the things I liked about `var` is that you can type it with just your left hand. Although it is useful and intuitive, I dislike the use of `const`, I'd rather just have it in the start of my code, usually for `require()`s.
It's actually not about browsers, it's about the difference between CommonJS and ES module behavior. CommonJS modules can be loaded at runtime and modified at runtime but ES modules are static. There isn't, though, a good way to know if you're looking at a CommonJS module or ES module when parsing the file and so handling the case where one module system references the other or is part of a cycle becomes pretty nasty pretty quick. [Here's the history of the discussion](https://github.com/nodejs/node/wiki/ES6-Module-Detection-in-Node).
java != javascript /r/java
No. It's executed via the Windows Script Host
ES6 == ES2015?
haha! there's a joke buried in here! there really is! javascript - learn how to type! haha! hilarious!
Are you fucking kidding me?
I understand, but even then. Same thing applies.
RemindMe! Ten Years "Check if browsers can do what rollup achieved eleven years ago"
The fascinating backgrounds were what I loved the most about Space Rangers 2.. I think I am gonna spend tomorrow trying to replicate those.. That is freaking amazing
const has other disadvantage, as well. You can't postpone assignment, e.g. `const a; //error!!!!! Uncaught SyntaxError: Missing initializer in const declaration` `if (true) {` ` a = 1;` `} else {` ` a =2 ` `}` but you have to use `let`. Or `var`.
I tried mixing es6 and cjs modules in a project some time ago. Es6 for everything I built, cjs for all npm dependencies. It was really messy, you had to remember which module system each module is built with, because weird errors occur if you try to 'require' a es6 module or 'import' cjs. I gave up in the end, it was a lot easier when everything was cjs. 
Yeah that actually looks pretty cool. I suppose my challenge will be to make loggerplus compatible with other packages that edit `console.log`... This will be fun :3
Type var, and on a commit hook, replace them with let. ;-)
PostgreSQL doesn't have this problem. This would be like not using Linux in your day job because you can pay for Windows. 
That's a great point. My hope is that it not considered a marketing tool because the plugin truncates text within dom elements in a very optimal way!!! üí™ 
const t = a ? 1 : 2;
Yeah pretty much ;) I had the need to timestamp logs as well as "tagging" messages from different parts of the code, and like I said in the original post, I decided to make it into a package just in case anyone else needed the same. Then I guess I went a little overboard adding features; but the simplicity of `console.log()` is super appealing, which is why I don't want to add too much clutter to the logging aspect - it's pretty much setup and forget.
More power to ya. If someone finds it useful that's probably all they care about.
Absolutely agree! I love going back to it. The HD update on Steam acts as a great expansion. I wish there were more games that captured the spirit of SR2
You might like http://store.steampowered.com/app/264080/, it's not exactly similar to SR but for me they feel pretty close
&gt; I had the need to timestamp logs [Have you seen the configuration panel for the console in Chrome?](http://imgur.com/a/aSJem)
If you want a free option to get started and know git (and if you don't, start learning git), you can host simple static sites on [github pages](https://pages.github.com/). 
Silly me. That did the trick. Thanks
Yes! I really skipped over the actual development process haha.. The above is very good advice :)
Yeah, I think I'm definitely not a boilerplate person. Imho the "basic stack" should only have react and atomic design. React router, webpack and jest are already too much of imposed stuff to me for the following reasons: * one might want to use redux + a route store instead of react-router * say, renderToStaticMarkup + cheerio over jest * rollup/browserify(/typescript?) over webpack
examples need to be lower-poly
Yeah, that's where it all originates. 
Sadly I can't open it at the moment. It seems overloaded.
TL;DR: Vue.js allows for high efficiency ‚Äì meaning less code than in many alternative frameworks ‚Äì all the while still being very easy to read, and easy for those not familiar with Vue to understand and work with.
Wow really? That's pretty cool. Is that in the US?
Also small and fast.
That's an over simplification. Linux and PostgreSQL along with a number of others are heavily supported by the community and also by corporations. Take a look at the supporters of the Linux Foundation which provide monetary support for it. You have a similar thing with Node for example (part of the Linux foundation now).
React feels more hardcore - everything javascript. Vue allows that, but optionally keeping the convenience of Angular-inspired custom attributes. Like an Angular without annoying "angularisms". My concern is this - in principle, borrowing good ideas from others is good. But could Vue be relying too much on a sort of "me too!" approach rather than coming up with innovative things other frameworks will want to borrow? At the beginning the framework had its own ideas, but lately it's been like, oh yeah we do virtual dom diffing too. Sure we do JSX too. Angular-cli? We have a cli too. SSR? We do that too. I fear the dependency tracking will be the next thing to go, replaced by something like "v-shouldComponentUpdate".
Exactly, I've been holding off using ES module syntax for this reason.
The primary button reads "Yes, I subscribe". All your mailbox storage are belong to us. :)
&gt;Completely different from React, which uses only bare CSS, Vue happily let‚Äôs the programmers incorporate CSS and HTML without making them reinvent the wheel each time. What does this even mean?
I tried to board the hype train but ran away very quickly, its very tedious to create components, and there is no proper documentation on how to create a proper nested structure using components like React.
because, especially for a news site, the font is the content and users expect content to load in under 4s. If the font was to load in after it might look like the page is broken or not rendering correctly.
Hi /u/larholm, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Came here to say same here. Hence I have no idea what the article says. Fortunately though, I'm already fully hooked on vue...
Probably talking about the .vue file convention where you can just write CSS/scss/stylus/whatever without having to import it into your js file 
What is the point of using this tool instead of css : overflow: hidden; text-overflow: ellipsis; ?
I agree that bundler, tests and router are somehow required, however there are different implementations/technical choices out there for each of these. That's the fact that one implementation is imposed rather than letting the user chose that bugs me.
I didn't realize the fonts were that largr
That's absurd. Why would you neglect such a useful language feature? Because you might forget to use it and run your constructor as a function? You're just going to shoot yourself in the foot some other way eventually.
Join our FUCK OFF YOU PIECE OF ANNOYING SHIT.
There should be a block filter subscription for "html overlay ads" like these that appear on page load.
For those annoyed by the pop up. &gt; Why Vue.js? &gt; JavaScript to web development is like an engine to a mechanic ‚Äì it‚Äôs just not going to work without it. As there are about as many (good) JS frameworks as there are car brands, picking the right one can get confusing pretty fast. Whoever you ask will have an opinion, and asking five people will likely get you five different answers, all with good arguments as to why their favourite is the best. &gt; &gt; Unfortunately, there is no one-size-fits-all. Personal preferences, projects, teams all factor into making the ‚Äòright‚Äô decision ‚Äì but some frameworks are definitely more versatile than others. ‚ÄòPurists‚Äô will argue that Backbone, being very small and light is the best choice, ‚ÄòTraditionalists‚Äô will argue that jQuery is the go-to solution, and so on and so forth. &gt; &gt; While some trial and error will probably be required to find the best solution for you, vue.js is definitely worth a look. Not as ‚Äòbare‚Äô as Backbone, not nearly as rigid and huge as Angular or React it gets the job done without any additional libraries, extensions, plug-ins or what-have-you‚Äôs. &gt; &gt; That isn‚Äôt to say that there aren‚Äôt any ‚Äì in awesome-vue you will find anything your heart desires, the selling point is, however, that you won‚Äôt need them. Focussed on the view layer, it is still perfectly capable of powering single-page apps all by itself. &gt; &gt; &gt; How does vue.js compare to the big players? &gt; All that is good and well, but what is it that makes vue.js so different? Let‚Äôs take a look at what it can do. The most similar in scope would be React.js, in that both focus on the core library, using companion libraries for things like routing or GSM. &gt; &gt; Completely different from React, which uses only bare CSS, Vue happily let‚Äôs the programmers incorporate CSS and HTML without making them reinvent the wheel each time. This makes Vue more easily legible, while also simplifying the effort needed for a piece of code. &gt; &gt; The other big competitor here is Angular. Angular 1 inspired Vues developers very early on, however ultimately, Angular is by far more rigid and restrictive. Angular 2, being a completely different system much better suited to bigger applications and projects, is known for it‚Äôs rather steep learning curve. It‚Äôs not a difficult to use framework, but it can be difficult to get into. Vue is much simpler ‚Äì it assumes only that you know HTML and JavaScript, making it easier to get into. &gt; &gt; The developers even boast that you can write complete applications within less than a day of reading the documentation and guide ‚Äì they‚Äôre not wrong. It‚Äôs that easy. &gt; &gt; Vue‚Äôs ‚ÄòHello World‚Äô &gt; A good example to show off Vue‚Äôs simplicity is its variation of Hello World. As mentioned before, it really doesn‚Äôt assume very much about what it will be used for, simply that the data given will change. This can be shown easily, with just a Hello World. &lt;div id=‚Äùapp‚Äù&gt; {{ message }} &lt;/div&gt; var app = new Vue({ el: ‚Äò#app‚Äô, data: { message: ‚ÄòWelcome to vue.js!‚Äô } }) &gt; To those familiar with JavaScript, this code should be easy to read. Vue.js allows for high efficiency ‚Äì meaning less code than in many alternative frameworks ‚Äì all the while still being very easy to read, and easy for those not familiar with Vue to understand and work with. &gt; &gt; Using this example, all you would need to do to change the message displayed in the app is to use the line app.message to assign a different output to it in the console. Vue is very much built towards input changing the data given ‚Äì and that makes it an invaluable framework for projects of all sizes. &gt; &gt; Though this is very much standard now, Vue.js comes with very well-written documentation. They boast that you can write code within a day of reading it. Assuming you know JavaScript and HTML, maybe even CSS (and if you don‚Äôt, why did you read this far?), you‚Äôll be well on your way to building your first app halfway through the documentation. &gt; &gt; Vue.js is the new kid on the block ‚Äì Vue 2.0 has only been out since April 2016, so it‚Äôs still very much in progress. The developers are very much open to input from developers that use their framework. Less rigid than established frameworks, even the likes of lodash/Underscore, changes to it are still possible and depend on user-input. &gt; &gt; You could influence the very system you use, and help improve on it. As a developer ‚Äì who wouldn‚Äôt want to help with the very framework they are using?
Google has nothing to do with Angular. That's the biggest misconception about the framework. It just so happens that the people behind it work at google, but google - the company - neither support nor guarantee anything about angular.
Hi, I'm having the same issue again but this time with the other Hand object I've created. If I post my code on jsbin or something like it, could you take a look and see where I'm going wrong? 
maybe use jquery.offset() in stead of jquery.position() ? (https://api.jquery.com/offset/)
Every feature is "dangerous" if you don't know what you're doing with it.
...[which is being pushed to the background more and more](https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components).
I guess because I don't consider it a useful language feature. But to each his/her own I guess...
I can't help but feel that Vue.js is a step back. Fuck templates.
Yeah! 
I don't see it changing much. The original motivation, at least, [wasn't the awesomeness of Polymer/WebComponents](https://news.ycombinator.com/item?id=11654199) but for other reasons. I like Polymer and think it's a perfectly reasonable system to adopt, particularly if your problem domain involves being on the same page as content you don't control (embedding, front pages of major publishers, mashups, etc). I had perf problems with it for years but it's been working fairly well of late** and if I joined a project with it in use, I'd be okay with it. React wasn't about moving things to the client. If anything, I'd assign that to the Backbone movement in 2009-2010 and I've been seeing the pattern since 2006. React is about component composition and state control. There are things that don't compose (notably CSS) but React composes far better than anything that came before. The vdom model is also uniquely well suited to functional languages so even though React won't stand the test of time, the vdom model will have a home on the frontend for a long time. I don't plan on switching off vdom unless I have a very strong need for component isolation. ** I tend to get a blank page on firefox dev edition (my daily browser) for pure polymer sites. No idea why that is but I know when I run into a pointlessly blank site, it's probably polymer and I need to switch browsers.
https://www.youtube.com/watch?v=VBbejeKHrjg
Ha, that's why I don't like it, it interferes with my `console` auto-completion. 
What change? We still have to support IE 11
You can use JSX if you want.
To each their own... I much prefer to work with templates. It leverages all the years of experience me and my team (some of whom are more designers and markup people) have with html and css, and more easily allows us to integrate into our existing tools and processes. Also, it's a bit more future-proof... for all their faults, html and css are here to stay for the long haul, whereas the javascript framework of choice changes every couple of years.
I'm not quite sure what you're saying. Yes you can stick `&lt;Fancy-Component/&gt;` in the source code, but that's it. That's not going to mean anything for web crawlers or users on slow internet connections while they wait for the JS to boot up.
String isn't actually a string. It's a global object, which inherits from the global Object object, that defines the string data type (and its prototype methods). typeof String; // "function" 
My designers like templates. I don't care either way as long as it's easy to read when I come back to it after a year or so. 
Ellipsis only applies to a single line. This technique is called text clamping and does the same thing on multiple lines. Webkit has an experimental property for it. As with most implementations of line clamping, this one is done na√Øvely and thrashes the DOM. If you have a few clamped elements then it's fine but if you have dozens/hundreds, you're going to have perf problems.
&gt; One of the things I liked about var is that you can type it with just your left han I know. Very useful when debugging porn websites
With a client rendered app, the client would load the assets, make some Ajax calls for data, parse the data, then render the UI by looping over things like arrays to create a component for each element dynamically, then the browser actually paints it to the screen. Traditionally server side rendering (when talking about web apps), just cuts out the middle man there. The server does the "Ajax calls", it parses the data, it loops over and outputs the tags, and then the client just does the last step. You can still do that with web components just fine. It works the exact same way. The part about web crawlers is kind of another discussion. Until they understand web components (which some already do), they won't work on a page that uses them regardless of where it was rendered.
`export default constant final important foo:String = "bar"`
haha
Polymer isn't a polyfill for web components, it's a framework designed to make building web components easier. Includes features like data binding and automatic creation of ShadowDOM from templates. `webcomponents.js` is the polyfill that Polymer recommends, and it's a separate component from Polymer.
You could use an IIFE: const foo = (() =&gt; { const a = 5; const b = 10; return a + b; })(); It's not very pretty though.
&gt; Shave, made by Dollar Shave Club Engineering. I see what you did there.
Uh... the link you have up there features this: https://www.edx.org/course/introduction-mongodb-using-mean-stack-mongodbx-m101x-0
Sorry, I read "I get different results in two functions" that way. Anyway, while Safari *is* returning different values, they are *not* incorrect. Since you don't specify any, the dimensions of your elements are being defined by the content inside them. In your case, the content is text which is being rendered slightly differently in Safari. It shouldn't matter that the actual pixel number is different because it is the actual coordinate location of that element.
Polymer supports IE11 via polyfills, but also in spite of this youtube news polymer is really targetted at future years. And in a year or two, the gap between IE11 and the evergreen browsers will have grown so large that there will be a lot of pressure to dump IE11 for consumers apps. And unlike with IE6, MS will be leading the charge to get people to drop IE11.
Doesn't every university do that? If you go to your department website and search faculty, they usually have their own webpages, right? Most students don't realize it, but anyone can use that server space to host theirs, too. In addition, lots of universities have CS or programming courses that require students to create web pages, no? They have to have a place for those students to do that. For example: https://itservicedesk.msu.edu/CAisd/pdmweb.exe
interesting!
Seeing huge performance regressions in my test suite. It seems like it may have something to do with `node-canvas`, although I'm not sure. My tests went from taking 7s on v6.7.0 to 23s on v7.0.0
Not the author, but extremely great read on how a huge product is using Electron. Check out r/electronjs for more discussions around Electron!
So I should change LinkedByIndex to something that checks for links between A and B? I'm sorry. I'm new to JavaScript. Not being able to do things iteratively is hurting my brain.
AFAIK it should never be used. Funny thing with `eval` though.
Thanks for the summation! It seems like you've dealt with some of the some relevant issues with truncation plugins. SHAVE was written for that exact reason. It is light weight, maintains the original text and does that within a selected element. Github issues are appreciated! üëå https://github.com/dollarshaveclub/shave/issues
jquery animates using an interval loop and changing the CSS property. CSS animates how CSS animates. They are entirely different animation systems. So using transistions; it'll try to transition through each jQuery animation step
Why do you consider React a proper framework? I think it's light enough that it's comparable to Polymer. A "proper framework" in my opinion is something like Angular2. You can certainly use a "framework" to implement a web component, but I don't see that much value in using React in particular in the implementation of a web component.
hehe, its hangman without the canvas atm. dont know if its visible but i have a counter for wrong guesses and right. But for soem reason i cant get the wrong guess to only count +1 everytime i guess wrong. 
Hi /u/Clowncher, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
Yes, I had `dom.webcomponents.enabled` turned on from earlier experimenting with it. Thanks for the tip.
So... polyfills are bad and react is good? Where is the logic in that? The end result with polyfill vs react is more or less the same. And btw. ALL browser vendors are agreed on shadow dom v1 API.
Nope - polyfill is webcomponents.js and polymer is a library that help you work with things, gives you databinding etc. Those two compliment eachother. So the amount of code to download and parse by client will reduce - but it will not go away completly.
After some more reading, I think I understand what you meant. This is the code after I added what (I think) was missing. &lt;!-- Create linkedByIndex array --&gt; var linkedByIndex = {}; &lt;!-- Checks if nodes "a" and "b" are related --&gt; neighboring = function(a, b) { return linkedByIndex[a.id + "," + b.id] || linkedByIndex[b.id + "," + a.id]; }; &lt;!-- Establishes which nodes are related and stores in linkedByIndex --&gt; links.forEach(function (d) { linkedByIndex[d.source.index + "," + d.target.index] = 1; });
Yeah, basically what he's saying is pick one not both.
It's impossible to help debug unless we have all of the information (code).
Something has to render the html. React is a library for generating html.
Make a JSBin please.
To be fair, this library is something we _are_ in fact using. Why not dress it up when we open source it? We care to share the love, spread awareness, and open source cool shit. Thanks for the feedback!
&gt; this one is done na√Øvely and thrashes the DOM Can you elaborate more on this? Which parts thrash the DOM? I can see that Shave makes (at most) 4 DOM updates (3 to remove/clean, 1 to add). It could stand to probably make less updates, but what about this is wrong?
The embedded video has just wrong hash id (0 at the end)
One thing to note here - An `HTMLCollection` is a bit of a special case. It is returned by `getElementsByClassName` and `getElementsByTagName`. It is special because it returns a "live" collection - it will update itself automatically to reflect changes in the DOM. If, for example, you mutate the className of elements returned by `getElementsByClassName` removing the class you queried for in your iteration, you get some strange results with length/indexes changing. It's been my experience that iterating from last -&gt; first in a for loop is the most reliable way to iterate over an `HTMLCollection`.
Not that anyone is reading this thread any more but: I've taken your advice and added a start button. 
You'd be surprised how many requests we've had at Cosmic JS for a static website that can be managed by a non-developer (without Markdown). I wanted to show that you can have your cake and eat it too: A fast-rendering, light-weight static website, powered by an API, content that can be managed by both a developer with Markdown and a non-dev with the intuitive Cosmic JS CMS. And yes it was a lot of effort, but worth it and actually a lot of fun ;)
Yes, I realized there are cases to watch out for given the generous type conversion happening. For example `[1, 2, "x"].every(Number)` fails as expected but not `[1, 2, "3"].every(Number)`. You can however do `[1, 2, "3"].every(Number.isInteger)`
 do { const lastSpace = trimmedText.lastIndexOf(' '); if (lastSpace &lt; 0) break; trimmedText = trimmedText.substr(0, lastSpace); el.textContent = trimmedText; } while (el.offsetHeight &gt; maxheight); This will write (`.textContent` assignment) then force-read (`.offsetHeight`) once per word removed. This is a quintessential example of DOM thrashing. Even if it didn't thrash per-word, it thrashes per-element by performing a dom manipulation (`.insertAdjacentHTML`) and then reading `.offsetHeight` on the next element. If you're in doubt about whether something will thrash, use the dev tools. In chrome: flip to timeline, hit record, click on the "truncate" button on the demo, hit stop and zoom in. You'll see a bunch of red "forced reflow" arrows, which means you're thrashing. As I mentioned a sibling comment, I outlined an alternative approach [last time this came up](https://www.reddit.com/r/javascript/comments/54wil0/ellipsisjs_a_pure_javascript_library_to_add_some/d85qztv/). I'll also note that the important thing for DOM performance isn't the number of operations. The DOM is a C++ datastructure with a relatively efficient set of bindings, you can read from it and write to it a whole bunch and you'll be fine. You just can't write then read because it forces all those changes to go through reflow. Reflow is the slow part of the DOM.
I don't disagree, but how often do you really do that in node? I like using node for io heavy tasks, rather than cpu heavy ones, that's why for me, I was very disappointed when I found out that generators themselves are sync. I'm really looking forward to the async generator proposal to be implemented, so that `for await (const row = executeSqlQuery(...))` can be done
How does React "compose" better than any other framework with a component model? In just about every UI framework ever a component can 1) render itself, using other components as part of its implementation 2) contain children 3) render the children into specific slots in it's internal implementation. Angular, Ember, Polymer, React, Vue, etc. can all do this. Polymer doesn't do anything special for composition on top of Web Components: HTML can do composition natively too. Shadow DOM even allows for style encapsulation and composition, something React has to do with various styles-in-JS schemes.
[Here you go.](http://jsbin.com/seqofusabi/edit)
Awesome! Thank you for your reply! I'm fairly new to programming, if it's not too much do you think you could provide an example of how to complete this? I am looking at Vanilla JS now.
Are they writing it in JS or Dart?
Yup, to be clear - I reviewed your comment on the other post. Sorry if you felt like I kept asking questions and not reading what you had already wrote. I did. üòä What you wrote above makes a ton of sense and the plugin should be improved based on your comment. THANK YOU!
Yes. I agree. Once web components are a standard though it will only improve working with HTML in any context. Web components allow you to abstract patterns and behavior in the DOM, something almost any framework can benefit from. I'm referring to basic concepts such as embedding a header or a footer, or generic containers for images, etc. Let the frameworks handle things like routing and data binding and the behavior of your app, web components can handle the abstraction in the UI.
JS
Here's a simple example written in Angular: https://jsfiddle.net/zackschuster/q2hm2bx3/2/ It won't work over jsFiddle because Wal-Mart inexplicably forces you to get data over http (not https), but you should be able to hack on it locally.
Dart is pretty much dead afaik.
Step one would be to learn JavaScript syntax. (Maybe http://www.codeacademy.com) Step two would be be to learn about DOM manipulation. (You'll really only need document.getElementById and setting the HTML of an element). Step three will be learning how to make an ajax request. If you do those three and attempt something I'll help you from there.
Someone else beat me to it. http://jsfiddle.net/7Ubch/
Safari scrolls the body element, while Chrome scrolls the html element. This is why you see things like: jQuery('html, body').scroll(); They should both support window.scrollY, though.
i think this happened because he observed what people used and how they used it. But I really don't know. It's usable for big apps.
I know that darts used a huge amount internally at Google (for example, their use of angular is supposedly largely the dart variant). They also seem to be very interested in flutter (native dev for Android and iOS). Was hoping someone knew something more concrete.
Hi /u/goshakkk, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `goshakkk.name`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [goshakkk.name](/search?q=%28and+site%3A%27goshakkk.name%27+author%3A%27goshakkk%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|25|76%
Instantly more readable: body { ...body, color: #c7c7c7; max-width: 1000px; margin: 0 auto; font-size: 1.1em; font-weight: 100; }
Thank you. Now for the hit yourself in the head with a hammer portion of the request... I need it to work in IE 11.
The mithril gitter chat is the place to go for quick help and discussion. There's a mithril rewrite 1.0 in progress right now, which provides a major performance upgrade and makes for a much [nicer API](https://github.com/lhorie/mithril.js/tree/rewrite/docs) to work with. So a lot of attention is on that right now. I've rolled my own simple build toolchain using typescript and browserify. I think others have gotten HMR working with rollup. I think more starter kits and tutorials would definitely be helpful, but the community is pretty small so it's tough for people to find the time. I do love working with the framework though. It's pretty much perfect for me.
That's one of their big use cases. Lets say I develp an app that comes packaged as a webcomponent &lt;my-app /&gt; Then I can allow users to embed that app in their pages, simply by importing the correct files and putting the custom tag in. The person designing that page doesn't need to know what the app actually looks like. 
&gt; Webpack isn't as good as what? Isn't as good as a build system. Webpack is a bundler but with the plugin system it also somewhat functions as a build system. It has at least some intelligence around partial builds but last I checked it didn't have as much dependency tracking as Broccoli. After writing this out, I realize I haven't looked into this part of webpack in two years and I know webpack2 is in the pipe, so it's likely that I'm out of date.
very light on content anyway, so you didn't miss anything.
I don't understand what you mean at all. Vue is pretty similar to react. Hell, you can even use jsx in vue if you don't like their single file components. I can't see how vue is closer to jquery than react is.
Preach! Been saying this for years
Try a sending the request with postman, it may help you 
Postman is an extension that asks for permissions on install to run cross domains so Postmans requests don't run into CORS
http://codepen.io/pwfisher/full/ozVAyr/ Thanks for the notes. We greatly improved Shave today. Here's ellipsis.js compared to shave http://codepen.io/yowainwright/pen/LRvYpz/. Thanks again! üçª
&gt; If someone has literally never come across this, and never wondered, they have no business calling themselves a professional. There are plenty developers who don't write JavaScript full time, but occasionally need to write some JS--both back end engineers and CSS/HTML or WordPress developers for example. Also, there are plenty of junior developers and interns, whose code I review from time to time. &gt; If your first thought is that they are incompetent, then either you, or them, or all of you have no business calling yourselves professionals. Note that I never said they were incompetent, just unfamiliar with a particular caveat of the language. Honestly, I'd consider them much more competent if they didn't know about this particular wart than if they were deliberately using it as pattern.
Ah. Well, that's what I meant by "being pushed to the background" - not that it's no longer used, but used less often. But apparently Vue does that as well.
Components in React are first-class objects: you can return components from functions, pass components to functions and pass components to other components, so you can generate components on fly and use them as children. It's definitely possible in other frameworks, but often requires quite a lot framework-specific manual plumbing.
Enable CORS by adding the proper headers to your server's responses `Access-Control-Allow-Origin: *` and do the ajax thing. Or initiate the request using cURL
Generators do allow some things previously impossible with async/await alone: - limited interpreter API. While async-await can wait for any promise to resolve, a generator interpreter can be overly picky and choose to only recognize several commands. I.e. `await` accepts a value of type `Promise&lt;T&gt;`, however, an interpreter can only accept `CommandA | CommandB`. Such is the case with redux-saga: function* welcomeSaga() { yield take('REGISTRATION_FINISHED'); yield put(showWelcomePopup()); } - testability. the way redux-saga works is, calling `take(smth)` doesn't do anything in itself. Instead, it creates a data structure `{ type: 'TAKE', args: [smth] }` that represents the side effect you want. It is up to the interpreter then to give to any meaning. In production, it would connect to the redux store and wait for an action, however in tests, you can simply use this saga as an iterator to ensure it produces the right side-effects. No mocks or anything required. In other words, it allows to operate on a higher abstraction seamlessly. The purpose of this post was to show that generators really are something more than lazy collections. People see the typical lazy collection explanation and they're bored and they don't know how they'd apply that. I just wanted to show that generators are more than that.
I recall having this conversation with you somewhere else already. So with polyfills polymer will behave like react or angular - and for some reason those solutions are "proper" vs polymer. And since you never used polymer in production I wonder what makes you think its "not proper".
http://codepen.io/anon/pen/XjQbXL I'm lazy so this doesn't do the bisection and there's plenty of room for further optimization (e.g. use line-clamp on webkit, guesstimate where the cutoff is by finding the cutoff rect in the list and dividing by the length, update the range start to generate fewer rects, set the height as an attribute on the element to avoid the forced reflow every time you call shave). I'm using this on ~8-10 line media items cut to the same height in one pass. The `getClientRects` call is cheaper than a reflow but still pretty expensive on the longer text here and timeline is showing a lot more overhead than I see in my app. P.S. As a heads up, your `break`s should be `continue`s. 
[removed]
Ha, that could very well be :P Coincidentally this week I've started contributing to a production (but closed beta) Polymer app, so I'm curious what my opinion will be in a few weeks. But what I've seen so far: on top of the polyfills, Polymer adds some data binding and HTML elements that perform tasks like data fetching. The data binding appears to mostly have been inspired by what Angular 1 did, but which most frameworks are moving away from. React has components, but its main idea is clear data flow through your application. Angular 2 is mostly about being very explicit about your code structure, enabing it to perform many optimisations. Polymer, as a framework, appears to mostly be about "use web components for everything", which I think hasn't found wide adoption for a reason. I should admit that "proper" might not be the best wording. Perhaps it should be something more like "actual ideas about how best to structure your application".
Translated into humon: Future youtube will be even slower and more bloated than today.
This totally reminds me of an entity modelling UI they've got at Mendix. It's the reason why [MobX](https://github.com/mobxjs/mobx) was created. It is not that complex to model with MobX. For rendering you can use react/inferno/d3 whatever rocks your boat.
&gt; But i think you still got it wrong - FLUX !== react - you can use flux with polymer too, in fact polymer 2.x aims to make it even easier. True, but React is very much nudging you in this direction. The key enabler is React's virtual DOM, which Polymer doesn't have. Even if Polymer were to go that way, it'd be somewhat like Vue - will probably see some adoption, but doesn't bring revolutionary new ideas to the table that will see it get as widely adopted as React or even Angular. &gt; It found adoption in industry leading companies like ING, EA, IBM, GE, Comcast and others. Lots of react/vue posts on HN/reddit do not mean adoption. Enterprises using solutions for mission critical systems hints it is getting adopted just fine ;-) True, but that's still very little adoption compared to React. These "industry leading companies" have been using it for small projects - nothing close to how widely and for how critical systems React, Angular and jQuery are used. (I don't consider Vue to be widely adopted, despite the many posts here.) (In fact, I think my employer is probably one of the few placing the largest bets on it, but we'll have to see how that will turn out :) )
I am more interested in *why they didn't use angular2?* after all that way they would have gotten Universal rendering, native rendering and what not. 
[removed]
Polymer 1.0 is ES5 and 2.0 is ES6 if i remember correctly. No dart :-) I think they also mentioned some better support for typescript too.
Because they want to use browser API's instead of big lump of js code that tries to replace them. The main goal is to push the web platform further. &gt; "why didn't they use flash and went with HTML5 elements like canvas/audio" Basicly same thing. 
and they use angular 2 when they **don't** want to use browser's API instead of big lump of js code that tries to replace them? surely there must be other reasons which are more believable than yours 
Funny you'd say that. Their [developer summit](https://events.dartlang.org/2016/summit/) starts today. There's quite a bit of Dart activity, but most of it is internal use within Google. I investigated Dart myself, and I must say that it's a pleasant language to work with (rivaling ES6+ with object spread, promises, fetch, class fields and static properties) up until the point that you have to start working with APIs or SDKs that'll require JS interop - which is an absolutely horrible way of going about development. I've seen clever/hacky ways of working around this issue by communicating between Dart &amp; JS by broadcasting events, but to me that's not a sustainable way of working.
Just because you _can_, doesn't mean it works well or that you're guided in it by the framework. Frameworks that stimulate a new and better way or coding have a chance, I think, and Polymer doesn't. _That_'s my point.
Well, if you would watch polymer summits where Google developers advocate to use the platform that browser provides you would believe me :-) They did it a year ago on google IO and progressive web app summit, and they do it on polymer summits too - they are very clear about it. Taylor Savage in his opening keynote already mentioned that polymer is probably the most important frontend framework for Google. https://youtu.be/VBbejeKHrjg?t=11m7s It is also very eye opening to watch Rob Eisenberg's talk on aurelia and why he left Angular 2.x team.
I'm in the process of writing docs to cover those aspects for the upcoming 1.0 release. Hit me up if you have specific questions
Here you can find an interview with the winner: https://hacks.mozilla.org/2016/10/an-interview-with-giovanny-beltran-js13kgames-winner/
Benchmarks?
Forgive me if this is a stupid question, but every time I use let it breaks my site on Safari desktop and mobile. Why is that? I can't use let, const, .forEach, .filter, etc. It has been a problem multiple times on production so I have avoided it all together.
As soon as Edge/IE and Safari implement the Web Animation API, it should be even better! For now though, the polyfill which does rely on requestAnimationFrame does a pretty good job for those browsers. 
No, I think he's just alluding to the length check being redundant, since you're anyway doing forEach. I'm not sure which is most performant, however, aborting early or forEach'ing over an empty array.
In the meantime, I hear the screams of all the computer scientists who wrote the specification that still includes 'var'. Don't you love statements like this: &gt;I am of the opinion that you should never use var. &gt;Technically, var is still useful
[Are you still on Safari version &lt; 10?](http://caniuse.com/#feat=let)
`const` is for variables. Freeze is for values.
If you only need function scope, there's no harm in still using `var`.
It's not an editor, it's a font. [FiraCode](https://github.com/tonsky/FiraCode)
Hm, I'm not so sure I like this. I guess for debugging, it's nice, but it pains me to see unneeded code. But to each their own I supposed. I enjoy very elegant code, sometimes even prefering the elegance over readability (note: only in tiny cases like this).
The prettiest version and the most sane of that would be the following: const onFinish = () =&gt; { Object.keys(this._taskGroups).forEach(this._reRenderTaskGroupById) }
probably you should use some transpiller, like e.g. Babel to get ES6 support
I imagine the story would be very similar to those who adopted SPA, but a bit slower when clicking links.
What about Rails 5 with the new turbolinks? It replaces the DOM body when changing the route. There is a significant performance gain over reloading the page and no need to add an insane amount of complexity.
We'll just try again, making a new link!
I continue to prefer `var` for console use. The inability to re-declare a binding with `let` is positive on the whole but it means declarations and redeclarations of a binding can't share the same value so you have to do at least two edits when modifying a line of console history.
&gt; will throw an error after an attempt is made to change its value This is true, as written, if you think of the "value of the variable" as the object the variable is pointing to. 
But the next part of the sentence says "a useful feature to prevent accidental mutation", which is exactly what const doesn't do. 
You both /r/bokisa12 and /r/jodraws mean such thing https://gist.github.com/tunnckoCore/fbf90d540e0a3dfc2d9e38cecc0c9755? This sucks. Even if it is different and something similar. The problem is how can I know inside `task` function that cb is called? **Notice:** called, not passed. Passed is easy. And just `fn.length` sucks and not works well. That's why I created before years http://npm.im/is-async-function and http://npm.im/is-callback-function -- there's a diffs, read the readmes.
javascript /s
It prevents some forms of accidental mutation, but yeah it doesn't prevent all accidental mutation.
In the callback of task, check whether 'cb' is undefined or not.
No, please make a new post.
Cool, dart looks interesting, too bad it never got adopted by other browsers.
Web components: solve nothing, break a lot. And every other framework out there can do everything better. Google is trying to force it through. It's like Microsoft trying to push Silverlight: impractical, some big users will adopt it, but nobody is happy with it. See how Polymer and web components aren't booming? A dead subreddit, hardly any support anywhere, no real awe-inspiring production websites, no measurable positives. I'm sad they're wasting so much talent on this. I used to say "3 years too soon" but it'll never become useful. &lt;/rant&gt;
Ok nice. Its not const too a scope though, it just makes the entire object permanently const does it? 
You can just `JSON.stringify` the object, and write it to a file. const obj = { name, data, charges, bond }; fs.writeFileSync('out.json', JSON.stringify(obj), 'utf8');
From my cold, dead, hands
I feel I must take a contrarian viewpoint. First of all, technically "hoisting" does not exist. I've read the relevant areas of the spec. It's not there. However, it is a useful mental model because of the two-pass nature of the JavaScript compiler. &lt;sarcasm&gt;"Hoisting" is a lie you have been told by the propaganda perpetrated by the mainstream media.&lt;/sarcasm&gt; hehe, sorry, couldn't resist :) Second, var must be used for the time being until all A-level browsers support let and const unless you are using transpilers like Babel or TypeScript. Not everyone is using those. Unfortunately, we are going to have to live with IE11, IE9, and possibly IE8 for a little while longer.
Thanks for taking a look. I used a bit of each of yours. 
Even if the latest versions of browsers start supporting them, chances are you'll still have to support some older browsers that don't. Why not just use something like webpack or browserify? 
Wow, one if too many, totally excessive! /s
Once cookie per browser profile. Across tabs it shares the cookie(s)
What would you use electron for in that context? QEMU seems to be a virtual machine that should be able to run Ubuntu on Windows by itself.
Depends on how embedded your logic is in your view Polymer is pretty slow. VueJS looks cool but would be clunky to convert from Angular 1.5 Angular 2 isn't very compatible. The rest I'm not sure about.
Is "let" compatible with older browsers?
Although ES2015 standardized the module syntax, actually loading these things off the network and resolving all the connections turns out to be tricky, especially when it has to interoperate with all the legacy stuff that already exists. The WHATWG is working on a standard for all this stuff: https://blog.whatwg.org/js-modules Once that's done, we can hope to see this stuff appear in browsers and in node.js.
[GWT](http://www.gwtproject.org/) [Dart](https://techcrunch.com/2016/10/26/googles-dart-programming-language-returns-to-the-spotlight/) &gt;Google is hosting a Dart developer conference in Munich this week that marks Dart‚Äôs return into the spotlight. &gt; Internally, Dart has also been a major success at Google. Both the AdWords and AdSense teams (which drive most of Google‚Äôs revenue), as well as the Google Fiber teams, now rely on it to write their consumer-facing web apps. 
Right after I get off of es5... :(
It's because variables is an imprecise word. Const is for *bindings*, that is, "this name points to that object". A const binding will always point to the same object, but the object to which it points can mutate.
Yes that is exactly what our goal was. We felt that Redux+React Router uses disparate libraries that weren't really made to work together. So we created a single library that gives the developer the functionality of both.
Exactly!
&gt; Dead subreddit TIL subreddits are factor of popularity
I should have probably gone more into the architecture. Anything we can abstract out, we do. We tend to create universal libraries that can run identical logic on the back-end and front-end. Directives and components could definitely use some spring cleaning but most of the logic they deal with has to do with the view: if you click on "selectAll", what happens to the collection? If you click "Save", what methods are called to save that model? Etc. But still, I'd love to hear a recommendation on those frameworks/libraries and how well they play with others. 
Don't you run into the same issue when using a default value for the first arguments and using rest arguments at the end? function f(a=0, ...tail) { } f("t", "a", "i", "l"); // a = "t", tail = ["a", "i", "l"] How do you supply tail rest arguments while also using the default value for `a`? I would assume the only way to provide a default value for `a` when it's at the end is to provide no arguments: function f(...head, a=0) { } f(); // head = [], a = 0
That is pretty cool
I figured the non-rest arguments would be taken until they are all accounted for then any prior arguments would be passed as `head`, so in your example: `head=[], a=1, b=2, c=undefined` Here is the functionality implemented as a function decorator: [codepen](http://codepen.io/anon/pen/rrbJYR?editors=0010#)
Why not create a router that is designed to work with redux (or I suppose vice-versa a redux for react router)?
Just a side comment, rest arguments are not a JavaScript exclusive. For example, both Java and C# have had this feature for some time. In Java they're known as [varargs](https://docs.oracle.com/javase/8/docs/technotes/guides/language/varargs.html), and in C# as [params](https://msdn.microsoft.com/en-us/library/w5zay9db.aspx). (I'm sure other languages have it, but I'm only familiar with these). In all cases, though, the rest arguments must go at the end, for reasons already explained. Also because its' easier for JavaScript not to reinvent the wheel and take other languages as a base.
/u/mlfree is a 3 day old account with the following no summary link bait posts. * WHAT IS JAVASCRIPT? (mlfree.com) submitted 48 minutes ago by mlfree to /r/javascript * TYPES OF WINE (mlfree.com) submitted an hour ago by mlfree to /r/wine * 2017 AUDI A4 ALLROAD FIRST DRIVE (mlfree.com) submitted 23 hours ago by mlfree to /r/Audi * 5 BEST SECURE MESSAGING APPS (mlfree.com) submitted 1 day ago by mlfree to /r/apple * WHAT IS IT ABOUT COFFEE? (mlfree.com) submitted 2 days ago by mlfree to /r/Coffee * LEXUS‚Äô SPORTY FLAGSHIP LEADS THE WAY (mlfree.com) submitted 2 days ago by mlfree to /r/Lexus * HP SPECTRE X360 (2016) FIRST IMPRESSIONS (mlfree.com) submitted 3 days ago by mlfree to /r/HPfanfiction * WHAT I LEARNED WHEN I WON THE $112 MILLION LOTTERY ‚Äì MONEY CHANGES THINGS‚ÄîFAST (mlfree.com) submitted 3 days ago by mlfree to /r/Lottery * THE HISTORY OF CAKES (mlfree.com) submitted 3 days ago by mlfree to /r/Cakes * 2017 BMW G30 5 SERIES ‚Äì DESIGN AND INTERIOR (mlfree.com) submitted 3 days ago by mlfree to /r/BMW * THE HISTORY OF THE GALAXY: HOW SAMSUNG‚ÄôS SUPERPHONE HAS EVOLVED OVER THE PAST SIX YEARS (mlfree.com) submitted 3 days ago by mlfree to /r/samsunggalaxys6 * 5 PREDICTIONS FOR THE NEW FORD BRONCO (mlfree.com) submitted 3 days ago by mlfree to /r/FordBronco 
Well yeah for small things. But you can use let and const with a transpiler.
Booming, sure man. Statistics say otherwise. Vue.js is nothing at the moment, it's the new kid on the block, and only gaining in popularity since about half a year or so. Compare Polymer to React or Angular instead. Even Backbone is more popular. The shadow dom standard, or web components, aren't fully supported yet. You need Polymer for that. I've worked in a production environment with Polymer for over a year, full time, about 1500 hours worth. And I disliked it for too many reasons. Working with React now, much less hair-pulling involved. My old team did love Polymer. Though I couldn't understand why. The most trivial tasks took them way more time than it would've taken them in any other framework. Many things out there simply don't work with Polymer because no solution out there takes web components into account. Let alone the shadow dom standard. Anecdotal statement incoming: I built an app in about 2 weeks using React that took a team of 5 FTE four months and they didn't even get close. My page got loaded (appeared ready) in under 1 second with less than 700KB of network material, about 20 requests in total. Theirs is (just tried their live site) still loading after 50 seconds at 16MB, 176 network requests. Every web component is another .html page to load, every image, every javascript file referenced, etc. Maybe I just haven't seen it done right. But a big app made with Polymer sounds, to me, impossible to realise without absolutely ludicrously stupid results.
This is why the rest operator is only allowed at the end in Array destructuring ‚Äì it is based on iteration and works lazily: const [first, second] = potentiallyInfiniteIterable; Array destructuring would have to work completely differently whenever the rest operator appears at the beginning or in the middle ‚Äì you‚Äôd first have to eagerly read all elements before matching them against destructuring patterns. Rest parameters work the same for reasons of consistency and to avoid needless language complexity.
Wow! We need this for webpack!
This certainly sounds concerning. You'd think they would at least symlink the binaries.
Thanks!
You should be fine regardless of how you decide to solve this issue.
&gt; Google is hosting a Dart developer conference in Munich this week that marks Dart‚Äôs return into the spotlight. &gt; Internally, Dart has also been a major success at Google. Both the AdWords and AdSense teams (which drive most of Google‚Äôs revenue), as well as the Google Fiber teams, now rely on it to write their consumer-facing web apps. The Ads team has terrible technology choice. They originally used GWT. Then it was deprecated. Then they decide on Dart which is going nowhere. You could have made the same argument about GWT being used widely and that it will never die. No new project would decide to use GWT. It's dead. [Google Fiber is dying](http://arstechnica.com/information-technology/2016/10/google-fiber-laying-off-9-of-staff-will-pause-plans-for-10-cities/). Probably because of Dart :p. Angular 2 is using Typescript. Its crazy to think that you would maintain a Dart version for the next 5+ years. ES6 is awesome. What is the reason you would use Dart? Can it do things that ES6 can't? ES6/7 will become widely deployed while Dart will still be transpiling. The original benefit of Dart potentially being run natively on browsers will not happen. If WebAssembly becomes a thing, there will not be a compelling reason to use Dart, people would prefer other languages. Dart failed to see the future which is a move towards browser standards which is a good thing. At its time it looked really cool. Its incredibly obvious that Dart will eventually die.
What are these lines in the code? &gt; // You can't fix this, but if you try please increment this number: &gt; // Hours wasted here: 43
You're right in what you saying about hoisting. I recommend anyone who is looking to learn the ins and outs of javascript to read the technicals. Kyle Simpson's *You Don't Know JS* talks about this here in [his online book](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch4.md) and there's also a small mention of how JS interpreters handle variable declarations. I wouldn't say you had a contrarian view tho' - if you can drop 'var', do so, but if you're still having to support old browsers, then you don't really have a choice. If you were *really* contrarian, you'd have list of advantages of using 'var' over 'let' ... I mean, there's probably an edge case or two where hoisting might be useful, but I think the majority agree 'let' is a better idea.
But afaik, "passed into its parent" isn't composition. As far as I can tell, it's traversing a tree, not chaining the running of component functions together. If it's composition, then what would the type signatures of two component functions be that they would match up on input and output?
no longer using the hot framework could be a problem... I think the JS developers need to chill a little bit with regards to the fear of being left alone in the dust by everybody heading to a new platform. Probably a matter of trust to backwards compatibility from browsers? I'm doing fresh development on a framework born around the same time as my youngest colleague, that would probably be considered crazy in the JS world.
Link to Rob Eisenberg's talk?
What's the input? I believe you can use vue itself to render HTML text, so you could use a vue component to achieve your solution. There are tons of templating engines, including ES6 template strings, handlebars / mustache, EJS, and many more.
http://eloquentjavascript.net
Technical question: ** how does 'let' get transpiled? ** My guess (how I would implement it): replace the 'block' it's in with a self-executing anonymous function. { let x = 1; } becomes (function(){ var x = 1; })()
One of the features of React is the "virtual DOM" that React uses behind the scenes. Whereas jQuery will just force a re-render of all the elements it's swapping out, React will diff the new virtual DOM with the previous one and do only the changes necessary on the real DOM (often, no changes at all...) With complex layouts it can be much faster.
Solely for the purpose of your usecase I guess both will work fine. The thing you need to consider though is that if you ever add more features to the same app, react components will save you from creating a spaghetti code. So is it something you see yourself working a lot more after you make the pagination? Use react. Is this a one time contract, where you won't touch it in the future? Probably ok to stick with jQuery.
Babel will set you free.
The harm could be code readability, which is the point being made here.
I'd read that.
I get a null or undefined
Do you know any metrics that can offer an insight in to how much faster? I understand it's a balancing act between the re-rendering speed of react and only needing to retrieve JSON vs the additional initial size of downloading react + reactDOM + my react code which will be degrees larger than JQuery and a small pagination script.
https://www.youtube.com/watch?v=6I_GwgoGm1w there you go
&gt;[**Choosing a JavaScript Framework - Rob Eisenberg [61:33]**](http://youtu.be/6I_GwgoGm1w) &gt;&gt;In the last couple of years there has been an explosion in JavaScript frameworks. How is a developer or business to make a wise choice? What are the advantages, trade-offs and differences? In this talk we‚Äôll compare and contrast six popular front-end frameworks: Angular 1, Angular 2, Polymer, React, Ember and Aurelia. We‚Äôll look at the same ‚ÄúHello World‚Äù example in each framework so we can see, side-by-side, the differences in development strategy and philosophy. &gt; [*^NDC ^Conferences*](https://www.youtube.com/channel/UCTdw38Cw6jcm0atBPA39a0Q) ^in ^Education &gt;*^32,102 ^views ^since ^Jun ^2016* [^bot ^info](http://www.reddit.com/r/youtubefactsbot/wiki/index)
JQuery and React solve two completely different problems. JQuery is a standardized convenience interface for DOM-manipulation that smooths out inconsistencies between browser javascript and DOM-implementations. It also supplies a small tool box of utility functions for stuff like ajax requests. React is view library for generating html. You can't manipulate the DOM directly with React, and there are no additional utilities included. It only generates HTML. From a more architectural point of view, the main advantage of using react, is that the view becomes a function of your applications state. This makes it a lot easier to reason about how your view will behave, because you know that for a particular application state, your view will always look in a particular way. In your example with JQuery, the DOM carries the application state directly. Lets say you have some counter, some place else in your html, that counts the number of items in your list, every time you update the list, you have to update the counter as well. If you interact with the list at several points in your code, then you have to remember to update the counter every time as well, or your view goes out of sync. React solves this by keeping state and view separate. The counter is a function of the number of items in your state and the list are the items themselves. When you change the list, both the counter and the list display will automatically stay in sync since they are simple functions of the state of the list.
Naming your script/library/tool/program/app after a common object is not clever. I really wish people would stop it. 
IE11 supports `let` and `const`.
I know there's a way because it's necessary for server side rendering. Regardless, ES6 template strings should work great for your use case.
Will do! Thanks for the respectful reply!
I absolutely agree with that but you shouldn't state to not use var anymore.
k, thanks. Is the comment from d1sxeyes ES6 template strings? 
Like this maybe? class Monster { constructor(jsonobj) { for (var index in jsonobj) { this[index] = jsonobj[index]; } } }
Thanks for the reply! That looks like a good solution, but I have just stumbled upon a solution that seems to have worked. class Monster { constructor(jsonObj) { Object.assign(this, jsonObj); } }
I really like names like this. It's memorable! There are already too many routers with generic-sounding names. Curious what your preference would be?
I like [dimple](http://dimplejs.org/) : simple and powered by d3.
 &amp; is for serial &amp;&amp; is for parallel Shouldn't that be the other way around?
`basePropertyOf` takes an object (or `undefined`/`null`), and returns a function. The returned function then takes a key, and if the object passed to `basePropertyOf` isn't `null`/`undefined`, the function returns the value at that key in the object passed to `basePropertyOf`. Here's a simple example: const user = { name: "joe", age: 50 }; const getUserValue = _.basePropertyOf(user); const name = getUserValue("name"); // returns "joe" const age = getUserValue("age"); // returns 50
&gt; Something unique that when you search for it, that's what turns up. I tried Googling: * desklamp js * desklamp react * desklamp router All three returned links about this project as the top result. I would say that by your criteria, they succeeded.
You shouldn't use var anymore. ;-) Or, more specifically, there's no situation where var is the better choice, so it's simpler to forget that var exists and just use let/const.
If you have correctly described the entire scope of the project, and it's unlikely to grow beyond that, then yes, the jQuery script will be vastly smaller, quicker to write, and will work just as well. The second you need to start adding features (caching, navigation, routing, undo, displaying state in multiple places, needing to manipulate the state, incremental updates, basically anything other than the bare minimum you listed), the jQuery solution will be very difficult to extend (at best) and will more likely be a horrible disaster. Keep in mind, jQuery (when used as you describe anyhow) is a library for manipulating the DOM; React is a library for creating and managing components with internal state which, when rendered, will manipulate the DOM for you. The scope of React is a hundred times larger than the scope of jQuery (again, focusing on this use case), so it becomes a question of whether you need all the extra stuff React adds. As a *practical* matter: Yes, you will need those features. But based on your hypothetical: No, you don't. Make of that what you will. :)
You can test this out with Babel's online REPL, what it appears to do is just change the let to a different name if there are any previous usages in that scope. 
You aren't writing code with `var` and its semantics. The same is true for any language with block scope which can be compiled to JS.
What about "ruby", "python", "apple", "backbone", "react", "java", "meteor", "ogre", "metal" or most other programming langs/libs that have been named this way? You're arguing against the industry standard. Java was actually supposed to be named "oak", inspired by the Oak tree outside Goslings office.
Yeah. And? 
Might help if you posted some code. It all depends on how you're storing your nodes.
For-loop iteration scope doesn't work in IE11. IE11 doesn't behave as the other browsers when it comes to let/const. You still need Babel. http://kangax.github.io/compat-table/es6/
Part of it is probably marketing / wanting to push adoption of it. It's also quite lightweight and maybe they can build reusable widgets for other projects.
You can abstract the storage from the object using the repository pattern. In this way your objects can take one form and they are serialized or deserialized to storage by a single place in the code.
Well, I'm trying to place these nodes on a circle of radius "Hops" but I started writing the code and got stuck on the first bit. I could maybe separate them into arrays based on their Hops value and then just throw each array at a circle? My nodes and links are stored in arrays pulled in from d3.json()
.... and you need help with what exactly?
mustache is what you want, no unfinished es nonsense.
http://codepen.io/shyndman/pen/amxRvg
Return a promise instead. Or have `moveTo` take a callback like `moveTo(callbackFunction)` and return your target like this if (typeof callbackFunction == "function") { callback(target); } Hope this helps.
I mentioned it in my previous comment but the fear has more to do with support of the framework and support of 3rd party libraries. There is also the issue of hiring and featureset. I can't imagine trying to build an SPA, for instance, in jQuery in today's world. BUT, I could do it easily with Knockout. The problem is that KOjs might not have some more advanced features that I might want like: 1. support for code splitting so that I can deliver optimized bundles of JS 2. a nestable/dynamic router 3. support for one-way data flow that might make building larger applications easier 4. ability to do unit and e2e tests 5. initial server-side rendering for either SEO purposes or just better optimization/speed 6. hot reloading for development environment and so on. And support for those features probably won't ever come about unless I write them myself. The community is probably scarce so getting help can be a pain and so on. The fact that a lot of frameworks now support interoperatibility with other frameworks in order to facilitate an easier transition makes sticking to an original framework that is on its way out of the door nonsensical.
I'll take a look. I just want something quick and easy. Thanks for the suggestion
Ah, fair enough - I hadn't noticed that little wart. As in, it hadn't broken any of my code... Edit: looking at the tests that fail from the compatibility suite, I'm used to that behaviour from [C#](https://blogs.msdn.microsoft.com/ericlippert/2009/11/12/closing-over-the-loop-variable-considered-harmful/) and Python anyway... however suboptimal it may be (from a functional perspective). So yeah, I'll happily carry on using let in my IE11 code! 
[removed]
The op was asking how to test CSRF vulnerability so, if you need to test via ajax requests, you kinda have to allow the request to hit the app, don't you think?
I do use babel for some project but I don't see how using the new syntax with babel would be faster or simpler than simply generating a min.js file with weback. It would still harken back to the same problems I have with weback (that is the fact that I'm forced to use a 3rd-part black box tool to do things for me, instead of using a language built-in feature)
Any framework on your list should be successful for you. My two cents: &gt; Elm - I heard about the huge productivity gains from using Elm. It's not a silver bullet. If you're going to do React+Redux+Immutable+Flow/Typescript and you don't plan on leveraging the ecosystem for components, your life will be easier in Elm but I would not give it an unqualified recommendation. The community is fairly small, I think the ideas around data normalization/projection to components are more developed in the Redux/Relay/Apollo communities, and language service type editor support is lacking. &gt; React I'm in this camp for my own work/projects. I'm actually in the clojurescript subcamp so not really a fan of Redux (excessive boilerplate). &gt; EmberJS - I'd love some input here. The main benefit of Ember isn't the tech, it's the governance process and framework evolution policy. The only piece of Ember tech I think is best in class is the cli and build system but everything else is decent and I've been consistently impressed at how the project is run and they go about adopting things. They also do a pretty good job of leveraging the uniformity of their overall ecosystem to do things like json api. I'd pick Ember for consistency. I haven't run across any real trainwreck Ember projects. It's not my favorite (too heavy, maybe less of an issue with serviceworkers) so I've been periodically checking in since the Sproutcore 2 days but I haven't taken a look since 2.0 and have more been waiting for the "glimmer 2 is here, come and get it" posts to do another pass. &gt; Polymer? - Seems like the way of the future but Idk. The parts that are the future (component isolation) are more or less applicable to all frameworks. I'm less convinced about the value of templates and html imports. Polymer itself is mostly about attribute data binding. I've always thought of it as a cleaner version of Angular, though the everything is a tag so databind all the attributes pattern makes it the most unique in how apps are put together. Unlike most of the other options here, it does not have a strongly prescribed architecture so you'd have to bring your own there. The 2.0 release is on the way and each major release has been a significant size/perf improvement. The main benefit to picking it is that the camp at google behind this is very much focused on the low-end mobile web page load times and code splitting. I don't feel like it gets much traction outside Google but they're pretty proud of their youtube rollout so google backing seems pretty safe for the next few years. I value state control so I think typed functional programming on a vdom is the future. I like the consistency / performance predictability and persistent datastructures mitigate the model's main weakness and fit the programming paradigm. I'm not convinced of the longevity of React itself since I see the community fracturing into Inferno / Preact pretty easily but the model has longevity. I like a lot of things about Elm but I don't really love it. Protocols/Traits/TypeClasses would tip the balance for me but Evan is opposed so I'm watching for community growth to decide whether to commit. They're kind of going into Elm is superior, rewrite everything rabbit hole. I prefer OCaml over Elm as a language and bucklescript can tap into the js ecosystem much more easily but I'd be truly out on the fringes with that option. Most likely I'll just do server side-projects for the next year and see how the wind is blowing.
Because it encourages you to think of your view as a the output of a pure function with the application state as input. This was (at least in the front-end world) a new and helpful way of looking at how your application comes together. I don't think the creation of Redux is a coincidence - it's somewhat the natural sequel to React, [applying very similar concepts to the domain of state management](https://vincenttunru.com/A-short-history-of-Javascript-frameworks-a-comparison-of-JQuery-AngularJS-and-React/#react-to-the-rescue). So I think a main factor contributing to React's popularity is that it introduced these concepts. And while you can probably use it with Polymer, I don't think that's a reason for it to become popular - introducing and encouraging new (better) ways of thinking about your application is. (I noted elsewhere that "proper" probably wasn't the right word. Hopefully the above makes my intent somewhat clearer.)
3d.js
Vivagraph
Tried the demo. Actually a little wobbly/innacurate manipulation for a lib dedicated to this, imo.
Good idea! There's room for improvement in that space.
Why, for this weird edge case that is less readable?
Ever since I discovered MDN I've almost stopped crawling through stackoverflow and such. So good knowledge source. 
in es6 this should be possible too class Monster { constructor({ name = "", hitpoints = 0 }) { this.name = name; this.hitpoints = hitpoints; } } You will need to transpile it from es6 to es5 if you want the support with something like babel. You can find out more here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment
Never. Looks really cool! Thanks man. I don't feel like it is very plug n play though. How would you recommend getting started?
No. You would write code and test with `let` and `const`, which throw errors. For all other intents and purposes, they function identically to `var`. So when you transpile to `var`, you know it won't be used incorrectly.
`&lt;A&gt;&lt;B/&gt;&lt;/A&gt;` is almost the same as `A(B())`. edit: I didn't answer your second paragraph. JSX when compiled into JavaScript results in a number of React.createElement calls. Nested components are passed to their parent as the third parameter (`children`). So the type signature for a createElement call is more or less: `function createElement(type: string, props?: Attributes, children: ReactNode[]): ReactNode`. A `ReactNode` can be a string, null, a ReactElement... (I vaguely remember this from the typescript type annotations so don't quote me on correctness here).
There's some good responses here. I would like to point out that /u/rauschma, along with those two books he posted, also has a site that is a great es6 resource http://www.2ality.com/ I also like eloquent js, another one posted here.
+1 for the MDN docs. Respect 
text-overflow: clip
That is not my point. You can write correct code using var. There is no need to pretend that it is somehow broken.
Lol, you're right, *clip* - edited I stand by the sentiment of my comment though...
Yes, since native line-clamping support is very spotty. 
My first thought indeed. What makes this shit modern compared to the clusterfuck that is state of the art clipping.
React is not based on OOP paradigm. The core idea is using functional composition to build UIs. Just my 2 cents.
&gt; I'm used to that behaviour But IE11 is the only browser which behaves like that. Aside: Dart also has for-loop iteration scope. This is where they borrowed that feature.
It's the new "lightweight", I think. Sometimes it feels like Github just has a madlib that you can fill out to generate a README :P
I don't understand your question.
&gt; Shave is faster üöÄ when compared to Ellipsis.js, jQuery.Trunk8.js or jQuery.DotDotDot.js; plus, zero dependencies. So many good laughs in that sentence.
I'm guessing it's because it's using ES6 syntax.
I'm a little confused at what you're trying to do. Is there a reason you stringify the function in the first place? Since JS has first-class functions you could just bind arguments to your function and envoke said function when it's ready to go. Generally speaking, `eval` is a bad idea because it's slow and error prone. Also, you should look at `setTimeout` and `setInterval`, both of which seem like something you might want/need to simplify this code. If you are trying to return `false` every 100ms until the timeout is up, `setInterval` is a good bet, just be sure to clear the interval once you are done. If you just want to wait for the timeout to be up and execute some code, `setTimeout` is your guy. Info about both of these can be found in MDN docs.
Check out facebook's Relay library. It's a bit intense but very interesting you basically abstract away the data source completely, still in the process of mastering it myself.
I'm just trying to count the number of nodes in an array with a certain property, so that I can use that number to determine the angle required for equal spacing of the nodes with that property. Still haven't gotten it to work :(
 .truncate { text-overflow: ellipsis; overflow: hidden; white-space: nowrap; }
Just a little more detail about what's really going on for anyone not familiar: The comma operator (`,`) serves as a separator for multiple expressions. Its kind of like a combination of a semi-colon (`;`) and the or (`||`) operator, allowing you to have multiple inline expressions where normally only one would be allowed, but also returning one of the values of those expressions. The comma operator returns the last expression, unlike or, which short circuits and returns the first truthy one. x = one(); two(); three(); // all expressions evaluated, x = one() y = one() || two() || three(); // expressions evaluate until one of them returns truthy, // and that value gets assigned to y, remaining ignored z = one(), two(), three(); // all expressions evaluated, z = three(); (last in group) Note that the comma has special meaning in a declaration group (var, let, etc.) where it doesn't return the last value, rather simply allows multiple declarations at once within a single statement. var x, y, z = 1; // declaration statement, does not return The parenthesis (`()`) should be pretty explanatory. They allow for grouping of expressions, largely to help determine order rather than (or in addition to) relying on precedence. The contents of the parens resolve to a single value that gets evaluated with whatever other expression it might already be in. When combined with expressions separated by commas, what gets resolved in a group is the value of the last expression. (1,2,3,4) // = 4 But parens around a single expression resolves to that exact expression without resolving its value. For example: var obj = { prop: 1 }; (obj.prop) // resolves to 1 // but this still works delete (obj.prop); // rather than it resolving to delete (1); This is important as it plays a role in how dynamic context (value of `this`) is applied to method calls. When functions are called from objects, context within that function call is set to the object from which the function is called. obj.method(); // this in method() is obj Similar with the delete example, this is maintained when that method is referenced within parens. (obj.method)(); // this is still obj However, once you create a more complex expression within the parens that needs to be resolved into a particular value, you lose that association. Then, what you get is analogous to assigning the expression to a variable and then using that variable in the surrounding context. (0, obj.method) // is the same as var temp = 0, obj.method; // temp assigned to method function reference // which when called (i.e. (0, obj.method)()) becomes temp(); // no object for `this` to be assigned; defaults to global (undefined in strict) So by grouping `_module._myFunc` in an expression in the parens group that resolves to just the function reference of `_myFunc`, it is able to be called without its would be `module` context. Eek, sorry for the length... **TL;DR**: The parens expression returns the function reference `_myFunc` without including the `_module` context so when called its like calling `_myFunc` alone, as though it were assigned to another variable first which means `this` is not retained.
You don't have to use `var` or `let` in the console...
Sorry for the shameless plug, but I think this is quite relevant: I recently created a library for this to do the same thing (but also for HTML content, which you cannot clip through CSS nor this library), but outside the DOM: https://github.com/arendjr/text-clipper While you cannot specify a max-height that way, it does allow you to specify a maximum amount of characters and optionally a maximum amount of lines. The good news is that by keeping everything outside of the DOM, it's a *lot* (as in: orders of magnitude) faster. I also spent quite some effort in making sure text-clipper really is the fastest, which you can read about here: http://www.arendjr.nl/2016/09/how-i-made-text-clipper-fastest-html.html.
Why it doesn't seems to work? Looks ok for me, matches ' his ukul'. https://regex101.com/r/wnbUg3/1
that was an example of my attempt. I tried an html form, no good due to not being able to post json through html form without the right content header. i tried ajax, no good due to CORS, im looking for the next step. Maybe the app is secure already and my security friend's tool had a false positive
*README generator* is a modern, lightweight, un-opinionated library that adds sanity, extensibility, and high performance to your READMEs. Full documentation at https://imadeanorganizationforthis.github.io/readmegenerator
you're bad at being nice
Anybody here uses Dart in projects? Like ready for production, complex projects. edit: If I'm not mistaken there are not much going on in Dart lang besides development inside google, sooo... This news is for Google... from Google. https://github.com/trending/dart
Maybe start small so the team does not get frustrated with you. Feel out who has a sincere interest and drive to learn this and teach them first. Let it spread slowly. I don't know how your team works, but if it is possible, you might want to start tracking regression bugs that make their way into production. Then over a period of time, you can prove that features you did most of the work on have less regression bugs. Then you can use that to sell more unit testing to the rest of the team or to management.
Which environment are you in? Both browser and node should have those as properties of the global object. So if I have function foo: function foo(string) { return string.toLowerCase() } And function bar: function bar(fn) { return fn() } I can use binding to attach arguments to foo and send it into bar as an argument (not stringified): bar(foo.bind(null, 'hola mundo')) The first argument to bind is the context inside of the function you are calling, which only matters if you are using this inside of the bound function. There are other ways to solve that problem, but bind is very common. Sorry if there's formatting issues, on my phone :)
After all that if the team still does not want to unit test, you have enough evidence to prove this is a real problem. Appeal to managers, going higher and higher up the ladder until it gets addressed.
After all that, if the company does not want to unit test, work for a different company.
exactly. I would love to be proven wrong! show me a link. 
It exists because text-overflow only works if you want to truncate a single line of text. IIRC, the only way to do this without compromise is with `display: box`, which doesn't have wide support. Along the same lines, it's sad that there's no CSS equivalent to [FitText](http://fittextjs.com/) (viewport units doesn't count).
I would suggest that you lead by example, ie, create an small suite of working tests that show the guidelines you would like to follow, in terms of technology stack, I am not very keen in technology evangelism so I would just say pick whatever you are more familiar with, whatever is easier and faster to start going. Then from there, make it a sort of free for all, people can contribute and suggest improvements, I think the best approach to engage people is when you get them to take ownership. You should just there take care of empowering and making sure that any changes introduced are for better and not for worst.
Very good explanation! In the language spec, JavaScript handles method calls via _references_. A reference is a data structure with three fields: 1. Base value: is either `undefined`, a primitive value, an object or an environment record. `undefined` means that a variable name could not be resolved. 2. Referenced name: is a string or a symbol. 3. Strict reference: flag indicating whether or not the reference was created in strict mode. `obj.foo` returns a reference, invoking a reference via parentheses (`obj.foo()`) uses the Base value to set up `this`. If you use the comma operator, the reference is converted to the value it refers to and an invocation `(0, obj.foo)()` sets `this` to `undefined` (in strict mode) or the global object (otherwise). More information: ‚Äú[Why is (0,obj.prop)() not a method call?](http://www.2ality.com/2015/12/references.html)‚Äù 
Because Javascript was slapped together in ten days. It wasn't meant to be used for building large web applications. Now we've got new features in the spec, but browser support is horrible so we have to transpile. I don't think anyone wants to keep transpiling forever. But you probably knew that already.
...sourcemaps
I guess this is off topic a little but what is yarn.lock? Why it need to be committed
Comment about koolaid is my point. I'm interested in outside usage.
What is the line of css that implements ellipsis on a multiline text area? Spoiler: there isn't one, and you don't know what you're talking about. You can add white-space: nowrap to force the text to a single line, but that's a completely different scenario. 
Absolutely simplest - jQuery, good enough at start, but then becomes a mess of ad hoc code. Then I would look at React / Redux , cause they have a great idea of a state and possible commands.
Why would someone need this when we have ECMA2016, async/await, babel, react, typescript and a lot of other cool stuff ? 
Wow, my twitter world and reddit world just collided.
What specific functionalities are you looking for? I guess wrapping the child process module could work for most cases. Haven't used [node-webworker-threads](https://github.com/audreyt/node-webworker-threads) but it seems very complete documentation-wise.
Redux, seriously? The author mentioned simple DOM manipulation and some XHR requests plus some basic filtering logic for items. Plain old Javascript is all that's needed to achieve everything mentioned.
Can't safely reach website. I have an error in chrome, problem with https. :/
Thanks allot guys! I appreciate all the responses! I think I'm going to order the 'You Don't know JS' book for ES6 on Amazon. That looks to be what I'm looking for. Thanks again!
What do you mean by inaccurate manipulation?
Thanks. Pretty indispensable when working with bleeding-edge web tech.
I don't think it is. I would just dig through their code and see where/how they're using the d3 lib. I'd just clone it and start digging through it! If you look look on their tutorial pages they have a graph view embedded in the browser as well which may or may not be easier to reverse-engineer.
Gonna go out on a limb here. So jQuery or vanilla JS is what you need with these requirements. But as stated it can become a mess, especially with DOM management. DOM can be hard and DOM manipulation code can get kinda gross (for things like your filter functionality). If you are looking to only write your "business logic" and want to leave the DOM manipulation to someone else, then I would recommend mithril: http://mithril.js.org/ Once you understand the paradigm, it hides all the rendering bits in the background. Less stuff than React, so no learning bloat, and it follows closely with the current SPA tech out there. So it will be easy to transition to a React or CycleJS for this or other projects in the future.
Hm.... I don't know. Dart tried to be new JS (I mean they even built browser for Dart - Dartium, which works exactly with Dart, with Dart debugger), but something went wrong and they made Dart another transpiled-to-js language.
Good idea, [done](https://www.reddit.com/r/node/comments/59p3qx/chrome_devtools_can_now_hotswap_live_edit_nodejs/)!
Damn, didn't knew it was an actual thing. And I constantly use it in most stuff I write. So I suppose it's actually cool stuff, and not some lazy-ass stuff.
Chrome as an IDE? Not bad. Does this work with typescript?
This functionality is inherent in HTML forms. &lt;form action="page.html"&gt; &lt;select name="name"&gt; &lt;option value="Mark"&gt;Mark&lt;/option&gt; &lt;option value="Steve"&gt;Steve&lt;/option&gt; &lt;/select&gt; &lt;input type="submit"/&gt; &lt;/form&gt; This form will send the user to /page.html?name=Mark
Dependencies list
Wow, that is awesome! I do wonder how this works exactly though. It seems quite 'magical'. What happens when you rename a variable? What happens with variables in closures? It doesn't seem trivial to handle all of that. Whatever the case, this is pretty cool.
I commented in the hopes that something like this actually existed. Thank you for coming through!
Well if you do Angular in the first place you kinda deserve all the pain
Not sure if this will help, but here's the code for the drop-down box: &lt;label for="purchase" class="label"&gt;Item:&lt;/label&gt; &lt;select name="purchase" id="purchase"&gt; &lt;option value="speakers"&gt;Speakers&lt;/option&gt; &lt;option value="headset"&gt;Headset&lt;/option&gt; &lt;option value="mouse"&gt;Wireless Mouse&lt;/option&gt; &lt;/select&gt;
I've been doing this in WebStorm for a while, but WebStorm sucks. I wish I could do this in Visual Studio Code (is it there yet?) Does anyone program 100% in Chrome? That would be cool. I know they did make some efforts and every once and a while there's a write up -- but it isn't fully there last time I check about a year ago.
This is really cool, but can someone explain why this would be useful? Just so that you can see your server messages in the same place as client messages? Or am I just hopelessly confused? If there was a way to live edit *client* code, now that would be something!
Have you looked into [ParallelJS](https://github.com/parallel-js/parallel.js)? Seems to be a bit more active.
+1 for mithril 
http://codepen.io/anon/pen/WGBRVv
So if you dont care about that stuff and just want to use it like npm i guess you can gitignore it? Why dont we just trust semver anyways
What is your overall goal? You want a function that... As you have it now, it's too confusing. Where are these objects and methods and functions defined?
name will be pretty much useless here as the parser will have carried on past that let long before it gets defined.
OP it depends what you want to do with `name` after it has been given the value you wish. If you wish to simply define a value and leave it at that, for some kind of class or something, use ForScale's answer, but if you wish to do something useful with it you will need to use a callback or promise.
You now trigger the event by clicking the button, would it not be way cooler to have it calculated instantly bij selecting a product?
There's probably a better way to do it, but without much to go on, you could do something like this since you're already iterating through them: var lowest = 999; var lowest2 = 999; var lowAd; var lowAd2; iterator{ if (adCTR &lt; lowest) { if (lowest &lt; lowest2) { lowest2 = lowest; lowAd2 = lowAd; } lowest = adCTR; lowAd = thisAd; } else if (adCTR &lt; lowest2) { lowest2 = adCTR; lowAd2 = thisAd; } }
I'm a huge fan of choo, it is a lot like Elm. People need to check it out.
Chrome has a clamp-linebox thing which is okish. Edit: (line-clamp, see here: https://css-tricks.com/line-clampin/ )
This is actually a phenomenal change. Hopefully we get full ES7 in chrome ASAP so I can ditch transpilation
Downvotes but then doesn't post the CSS. I like it. /s
I've tried the ES6 template strings, and it basically works for me. I'm not sure how to handle dynamically sized arrays though. What if, for example, I want to create an HTML list based on an array. From what I've seen so far ES6 template strings are not meant for that. Starting to get the feeling I'm using the wrong tool for the job..
There aren't threads. So, web workers?
I've been enjoying all the topics here on vuejs recently, but I was a little sad it was always hello world. So, I tried to put together a video covering something more involved within the vuejs.
Perfect! Thank you!
That JSX plugin would reduce the scope of refactoring React to Vue if it followed the same JSX patterns...
Don't do it, go Linux! All of the major development tools (Eclipse, Netbeans, the IntelliJ line, etc.) work on Linux, and you don't even need to ask: &gt;How does it go with command line stuff? Personally I find the middle-click extra copy/paste buffer alone makes using Linux worthwhile for me.
What?
It's funny how Dart feels closer to JS in terms of syntax/features than TS, yet is more distant to JS than TS as the API is completely different and has more built-in.
&gt; **Has much changed?** A fair amount yes. Thankfully they brought back the start menu in win10. edge is better (more performant + more features) then previous editions of IE. Still requires significant modification, however once you get past the initial stage of config (editors, version control, etc) then it's not too bad. Still doesnt hold a candle to linux though IMHO. &gt; **How does it go with command line stuff?** Thankfully there's cygwin + apt-cyg. Also MS released a bash shell for win10, it's not a true replacement (think inverse WINE) but it's certainly worth a look. https://msdn.microsoft.com/en-au/commandline/wsl/about &gt; **Is Vagrant still a pain?** Dunno haven't used it in a long time. &gt; **How about docker?** Has gotten much better support particularly when MS implemented containers on their azure cloud platform and after docker incorporated FIG. 
I was developing on Windows in a regular basis. I was doing OK but I was requested to use some docker setup for the project. I started running into problems, that Mac and Linux didn't have...I tried using vagrant but I ran into other different problems. So I decided to stop with the bullshit and go full native. I installed Ubuntu on dual bot, and I'm surprised how good it's for development. I would suggest to give a try to Linux/Ubuntu. You can install it some OSX theme if you feel nostalgic lol
Can I quote you on that?
It's allright. Macs are definitely the favourite platform for web dev, so when new cool stuff come out, you're stuck waiting until a windows version comes out. See Hyperterm. The command prompt in general takes some getting used to. I'm using babun to fake a Unix/.zsh like environment because I couldn't get used to the non-zsh (I really love oh-my-zsh) PowerShell oddness, but its not great. No tabs, ctrl key based copy and paste is weird, node commands don't always die off so you have to pid find and kill them, other weird stuff. Babun at least fells like I'm in Unix (powershell mos def does not and has the above mentioned problems too, though node seems to run a bit better and you can copy and paste), but then something weird will happen and I remeber, 'shit, I'm on windows now.' Getting the right version of node to run in MVS wasn't too hard and the GUI even has pretty great support for things like webpack, grunt. Nothing too hard there. As a primarily frontend dev, yeah, it's been OK, but to be honest, I miss my old mac (I switched about 3 months ago) but I ain't all suicidal and disgruntled about it, you know? Windows is weird, I guess. You have to remember to run some commands as an administrator if you open them from the GUI menu. The start bar sometimes doesn't auto hide, you have to deal with SO MANY MORE updates and sometimes they force them on you in the middle of doing shit (as far as I can tell from fucking with the options). Again, nothing terrible but it's just not as "nice" as OSX? Not sure how to say it.
&gt; is the only way to determine the two ads with the smallest click-through rate to create a series of if-then statements that go through every possibility? No need for an if/else, you can just sort the array and use the first two items. Use [array.sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) adSetContainer.sort( function(a, b){ return a.ctr &gt; b.ctr }); that reorders the `adSetContainer` array by the `ctr` value. ...so you can then get the two lowest items as `adSetContainer[0]` and `adSetContainer[1]` If you're using ES2015 then the sort is shorter adSetContainer.sort((a, b) =&gt; a.ctr &gt; b.ctr); 
&gt; I think you can quote Anoian but don't quote me on that. ~ */u/acloudbuster*
ts-node and babel-node and other programs like this are just wrapper scripts to node. Aka they are node scripts. All most of them are doing is transpiling it down and then just running it through node proper
not without all the shiny ES8 features that will be out at that point D:
npm update dns *crashes internet*
If you were dealing with a large amount of data, and concerned about efficiency, you would want to construct a min-heap and then pop off the first two items. This can be done in O(n) time vs the O(n log n) time for sorting.
I don't see the issue with following semvar. The v8 engine its based on is up to v55 already so..
Fewer bytes.
&gt; Fiddlers Postman FTW https://www.getpostman.com/
Nice. I wrote something like this last year for a site. It is Vanilla, so when you embark on jQuery removal, take a look... http://codepen.io/anon/pen/rrgGav
What's the MBP announcement just out of interest?
You need to indent all of your code with 4 spaces for it to show up properly: function calculateBy() { var tableHTML = "&lt;table&gt;"; tableHTML += "&lt;tr&gt;"; for (i = 1; i &lt;= 10; i++) { tableHTML += "&lt;td&gt;" + "Year" + i + "&lt;/td&gt;"; } var principle = document.getElementById('principle').value; var interest = document.getElementById('interest').value; interest = (1 + (interest / 100)); for (i = 1; i &lt;= 10; i++) { tableHTML += "&lt;tr&gt;"; var total = principle * (Math.pow(interest, i)); total = total.toFixed(2); tableHTML += "&lt;td&gt;" + total + "&lt;/td&gt;"; } tableHTML += "&lt;/tr&gt;&lt;/table&gt;"; document.getElementById("result").innerHTML = tableHTML; } Regardless, the problem is that you aren't placing your `&lt;/tr&gt;`'s in the correct place. I would suggest to add a `console.log()` to the last line of your function so you can see the HTML that you're generating, like this: function calculateBy() { var tableHTML = "&lt;table&gt;"; // removed for brevity console.log(tableHTML); } Then, open up your console in your browser, and copy/paste the HTML into your editor, you should get this (after formatting): &lt;table&gt; &lt;tr&gt; &lt;td&gt;Year1&lt;/td&gt; &lt;td&gt;Year2&lt;/td&gt; &lt;td&gt;Year3&lt;/td&gt; &lt;td&gt;Year4&lt;/td&gt; &lt;td&gt;Year5&lt;/td&gt; &lt;td&gt;Year6&lt;/td&gt; &lt;td&gt;Year7&lt;/td&gt; &lt;td&gt;Year8&lt;/td&gt; &lt;td&gt;Year9&lt;/td&gt; &lt;td&gt;Year10&lt;/td&gt; &lt;tr&gt; &lt;td&gt;1100.00&lt;/td&gt; &lt;tr&gt; &lt;td&gt;1210.00&lt;/td&gt; &lt;tr&gt; &lt;td&gt;1331.00&lt;/td&gt; &lt;tr&gt; &lt;td&gt;1464.10&lt;/td&gt; &lt;tr&gt; &lt;td&gt;1610.51&lt;/td&gt; &lt;tr&gt; &lt;td&gt;1771.56&lt;/td&gt; &lt;tr&gt; &lt;td&gt;1948.72&lt;/td&gt; &lt;tr&gt; &lt;td&gt;2143.59&lt;/td&gt; &lt;tr&gt; &lt;td&gt;2357.95&lt;/td&gt; &lt;tr&gt; &lt;td&gt;2593.74&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; Which we can figure out if we talk through your code: * open a TR * loop begin * write 10 TD's * loop until done * loop begin * open another TR (why? you should be closing the previous TR first) * write 1 TD * open another TR * loop until done When you need this to happen: * open a TR * loop begin * write 10 TD's * loop until done * close the TR * open a 2nd TR * loop begin * write 10 more TD's * loop until done * close the 2nd TR (hint: don't open or close TR's inside your loops) Hope that helps!
üöÇ
Yeah. I'm assuming it would work here as well if the source maps are properly set up. 
There are a lot of resources out there for learning JS. Tons of books, video series, and online courses, many of them free. I would just search back through this subreddit and you'll find plenty of discussion on the various resources available. I can't dig too much into the code you posted just yet. But as far as '_this' - whoever wrote that code was trying to be clever and not thinking about future devs. They are running an IIFE to generate the callback, which probably won't mean much to you yet. Google 'Javascript IIFE' and you'll find some definitions. You can see that they're passing the actual 'this' as an argument into the function inside the IIFE. They're using the underscore since they can't reuse the 'this' keyword. Long story short, the '_this' variable is a reference to the Warper object, because it's value is the 'this' from inside the prototype method 'attach_ux'.
Do you believe so ? I kinda doubt it, I mean, modules would also mean the abillity to dynamically load javascript when needed (or even better, a few seconds before its needed). Minifiers will still be a thing if we don't advance past the stone age when that still matter to interpreters. But I'd hope "bundelers" wouldn't. Even if they were, bundling might look much more natural.
If you wanna use Vue, the `v-html` directive should allow you to do that. 
Thank you! I will have a look at that after work.
That's a bit different. Source maps help map the runtime code back to the original. The code being ran is still the compiled version. This would require a the file to be watched for changes and compilation to JavaScript. Depending on how long it takes to compile the file back, love edit might not be feasible.
That code doesn't preserve the reference to the newly created `Warper` object, so you'll need to get a reference of it first, before you can call `click_submit()` in its proper context. i.e. you'll need to change the code. 1. Declare a new variable named e.g. `recentWarpedObject` after the `Warper` variable declaration. e.g. var Warper; Become: var Warper, recentWarperObject; 2. Change this line near the end: return new Warper(); To: recentWarperObject = new Warper(); return recentWarperObject; Make sure to declare the `recentWarperObject` variable so that it's accessible from both the `new Warper()` line, and the code that needs to call `click_submit()`. To call the `click_submit()`, use: recentWarperObject.click_submit(); 
&gt; ts-node can run .ts files You also has [tsun](https://github.com/HerringtonDarkholme/typescript-repl) which can be embedded in other processes (like Emacs). ts-node looks nice, but fails when invoked as an inferior process, and there's no way to force the correct mode using the `--interactive` parameter you would typically throw at node for instructing it about correct execution-mode.
Or cookies, but yeah, web storage is probably the way to go. 
To me it's more the lack of focus on what should actually be considered important to the supposed "Pro" model. For instance, the updates to the CPU, GPU and battery are not enough. Then there is some shit that just doesn't make any sense. Headphone jack? Ok but, you said headphone jacks weren't needed, so how does one use the iPhone7 earbuds with a MacBook Pro? Oh yeah you can't charge that iPhone7 through your MacBook Pro anymore either. Honestly? I hate ios10, it's the worst iOS software update ever. I have an iPhone6, my phone app (you know the one which makes it a fucking phone) constantly crashes and freezes. Touch ID is a fucking mess, I can't unlock my phone if my fingers are even SLIGHTLY damp if I'm in the gym or something. I don't need your stupid fat notifications that introduce about 7 different ways to swipe within an established swipe interface. It's becoming so clear that whatever actual creativity they had died with Jobs. They used to be about solid products that "just worked". They are so far from that now. If you step back and look at what they are doing it's changed from "just works" to "just works if you do everything the way we say, the way we want, and abandon all the standards you are used to". I don't agree with it at all. I still, however, far prefer OSX over windows. Granted I quit windows around v7 but what I saw of 8, I didn't like. 10 looks sort of better. Maybe dual boot windows Linux is the way... hmm. 
&gt; === "We are not a bunch of noobs creating damn shopping carts and such, like the rest of you!" 
Don't you get all that with regular livereload? This is neat, but I too, fail to see the real day-to-day use.
Good answers to what comma operator, which is evaluated as sequence expression does. Here is another great explanation what it does and how it can be used: https://javascriptweblog.wordpress.com/2011/04/04/the-javascript-comma-operator/ *React.js* JSX users can find the use of comma as interesting way to emulate if-then-else statements with multiple expressions inside JSX like this ` { do_increment ? ( console.log("did increment to ", ++i), &lt;b&gt;Then {i}&lt;/b&gt; ) : ( console.log("did decrement to ", --i), &lt;b&gt;Else {i}&lt;/b&gt; ) }` However in this particular case, I think the reason they used it is that the code is transpiled from something from this ``` import { myFunc } from "module.js" ``` To first something like this ``` _module = require("module.js") ``` And then, finally, when the imported function is called, call it with `(0,_module.myFunc)()` . The advantage is that you can get all the imports from the variable `_module ` which pollutes the variable scope less. 
With Windows 10 it got a lot better. Docker support is great (it uses Hyper-V in the background), command prompt is way nicer (keyboard shortcuts like CTRL+C/V, text selection, etc., possible to resize window by dragging the borders), alternatively you can use the Ubuntu Bash on Windows, multiple desktops are a helpful addition and you can test in MS Edge and I noticed another benefit: when you work on windows, you are way more sensitive to platform-independent development.
Well, when you have clicked 5 times to get the app to a certain state you don't want to lose that. With a normal live reload your app would be in a "fresh" state, with hot reload you would keep the state
Reddit has an api!
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt: &gt; &gt; If radix is undefined or 0 (or absent), JavaScript assumes the following: &gt; &gt; If the input string begins with "0x" or "0X", radix is 16 (hexadecimal) and the remainder of the string is parsed. &gt; If the input string begins with "0", radix is eight (octal) or 10 (decimal). Exactly which radix is chosen is implementation-dependent. ECMAScript 5 specifies that 10 (decimal) is used, but not all browsers support this yet. For this reason always specify a radix when using parseInt. &gt; If the input string begins with any other value, the radix is 10 (decimal). The most likely reason to put 0 as radix is to indicate that this has been done on purpose, and not accidentally forgotten.
I've had mythril under my radar for a lightweight, modern and simple framework, but maybe Choo is even more interesting...
Yeah, we'll always be transpiling for the latest features and tricks realistically.
Thanks for the tip. is there a name for that process that I could research? 
people, who uderstand the power of typescript, dont seem to understand how it works or limits production
someone told me about this thread so I had to take a look, my apologies if anyone was insulted, that was defiantly not my intention. i wasn't aware 'shopping carts' or 'online social media websites' had bad connotations - i was trying to explain we come from building enterprise software, not consumer facing portals. i'll update the post. again apologies if anyone took offence.
Tried `change` instead of `onchange` and it worked.
I just started making an application with this last night - very promising! I'm also learning Vuejs along the way.
A module loading API would allow us to load at runtime and such n API is being standardized but others already exist today. The import syntax, however, cannot be used to load modules dynamically. Minifiers, assuming you classify gzip as a minifier, will also be necessary because bandwidth costs money. It's not about the interpreter at all, it's about bandwidth.
I really like [choo](https://www.sitepoint.com/functional-programming-choo/)
Livereload doesn't reload the page with css changes, it swaps out the stylesheet...
So what about changing HTML? 
Yup, addEventListener doesn't use the "on" prefix. It uses "click" instead of "onclick", for example.
If you're not going to use NPM then just give up learning JS. 
In strict mode it will break in either case if you try to use an undeclared variable. You should use strict mode anyway. It is the default in ES6 modules.
yep, that why I said it is not a natural solution. It does make you stop and think the first time you see it. But it can be an idiomatic piece of code for a specific project if everyone involved agrees. I think you can think of something like using short circuit when declaring defaults (which are now replaced by real default parameters).
But then the parenthesis wouldn't match up O.O
That's fair, I could see it being useful on certain projects :)
Pretty cool. But I thought the purpose of using React is that the client can do all the cool speed stuff for us?
To the best of my knowledge there is only one type of cookie. https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies
This is awesome!! How would I modify this so I have two different dropdowns on the same page, another one for contact type. Thanks again!!
Thank you very much for your comments! So in my case, the company, the team, everybody wants to start adding tests. The thing is: - How would you include it in a workflow, having some people that never wrote a test? What we are going to do is booking some time per sprint to write some tests, and maybe do some test katas and things like this, so the people get the concepts. After that, i'll review tests written and try to teach in the code reviews. Basically we are putting time on it, and i hope it will work :D
Hmm... It's initialized outside of the event handler and then updated within the event handler. I suppose you could scope it to the event handler too... Are you saying that approach is superior? How so?
Here, updated: http://codepen.io/anon/pen/qaGgeZ 
Surely you know what I mean and you're just being pedantic? It is initialised, true, but it is initialised pointlessly with an empty string and it won't hold a meaningful value until the event has been triggered. &gt;How so? Well for starters, what reason do you have for defining `name` outside the scope it's used in? Secondly, since `name` will defined asynchronously it can't be relied upon anywhere else in the code. So unless OP has a specific reason to define it outside the scope it's used in he shouldn't. You should define everything where it is needed and nowhere else, what reason do you have to do anything else? Defining a `let` above a different scope is common, since it is block scoped, but that only works with synchronous code.
There are a bunch of libraries for "Metro Tiles" which might be what you're looking for. http://www.drewgreenwell.com/projects/metrojs
Abstractions can be good while keeping them simple. The longer the inheritance chain the harder it is to understand and follow. I agree and can notice the same in Java at times. Node is stupid simple because it's so easy to see how things go
Some people (me included) can actually choose audience for their application so writing with newest tech without transpilation is reality already (except some small things). On other in this case the transpiled code is more performant then it's native alternative, so it's probably better to keep that.
Yeah, that IIFE a weird way to write a normal thing. It's more normal to write: var _this = this; $('#btn-submit').on('click', function() { return _this.click_submit(); }); And, for OP, the reason we do that is because every function secretly defines its own "this" value, so the click callback's local "this" shadows the attach_ux method's "this". We can avoid that by assigning attach_ux method's "this" to a variable of pretty much any other name that won't be shadowed in the inner function. I used "_this" but "that" or "self" are also popular choices.
Oh so it's a little hard to explore the site and see the examples, but this looks like more of an interface, I'm just trying to make a randomized pattern, essentially an image. I plan on using it for a background, initially at least. Another possible application would be to render a material for architectural imaging, without obvious grid repeating elements, because the could be rotated and randomized. Maybe this has that ability and I've not found it, I just wanted to make sure the goal was clear. 
It's hard to consider without more information about what these images are. You said they can be any size and orientation? Can you provide an example where you've manually created what you want from these images?
When they go low-level, we go high-level.
oh at least Java is more explicit and doesn't have duck typing or dynamic meta programming 
I've been a JavaScript developer for my entire professional life. I've worked with PHP, C#, Java, and now Rails. Rails (and coffeescript) are in my opinion the worst languages in the bunch. Simply trying to update a package is painful since their interdependencies are so tightly coupled, and I've found that package developers love to deprecate features regularly. They don't just remove old features, they'll move very useful features to entirely new places and not document it. On the documentation side, why is the rails documentation so utterly useless? Even PHP and JavaScript have better docs. Hell, w3schools has better documentation. I've looked into more source code with rails than any other system trying to understand what a function does. I've come to the realization that rails is just PHP on steroids, and JS/node is a much cleaner stack.
Yeah. Running it, storing it, calculating the layout with thousands of styles, that's a lot of overhead for an index page. The same look could be achieved in 100 lines of CSS and 100 of JS.
[This](http://freedesignfile.com/upload/2015/04/Hexagon-layered-seamless-pattern-vector-material-03.jpg) isn't it (still on mobile) but it's close enough. It tiles perfectly, the edges line up with no seam, but notice the three light hexagons in the middle, those will noticeably repeat forming a grid, as will all the other identifiable clusters, making it obviously tiled rather than one big randomized pattern of hexes. If I created 4 images with the exact same edges but changed the internal hexes, and then mixed the tiles, many different clusters would form, and they wouldn't repeat in a grid. That's the goal, something that looks as random as possible, with as few unique pixels as possible (fewer, smaller images) 
Unless you're targeting mobile devices for this, I really don't think it's a problem, we're talking milliseconds. This smells like premature optimization. OP used two popular libraries to extend a popular web server stack. Solving what looks to be a common problem other people can easily extend because he *used two popular libraries* and the code is relatively simple. Here are two alternative ways to approach this problem, using far more assets than OP but doesn't seem to bother people in 2016: - [h5ai](https://github.com/lrsjng/h5ai) - [Apaxy](https://github.com/AdamWhitcroft/Apaxy)
It's not premature optimization when this replacement index is slower than the original.
It's easy to tell just by loading the page. I'm done arguing about whether a bigger webpage is bigger, so if you want benchmarks take them yourself.
I'm not being overdramatic, I'm just trying to say to op that if he wants to compete with the default index page he should work on making it load faster. Also, it isn't just a few milliseconds. It takes several hundred, you should totally benchmark it.
How can it possibly take you 5 seconds to load a couple CSS stylesheets in your local environment?
the only use i have for it is fetching gravatars
I'm not sure. I have a late 2012 macbook with latest Firefox. 4GB of RAM.
We will build a wall and the DOM will pay for it!
Played with this a fair bit. Overall it's really impressive, but there are several design decisions that create a few limitations. I'd recommend reading through the issues for 15 minutes before starting to get a feel for the current pitfalls. 
i had a case recently in a hot code path where going from `forEach(x =&gt; {...})` to a plain anon func was 3x faster, and another 1.5x faster for dropping down to plain `for` loop. i think the difference is that arrow funcs are not just anon sugar but also bring scope implications (lexical `this`) that aren't handled well by javascript JITs (yet?)
This is pretty good: https://github.com/getify/You-Dont-Know-JS He has actual books and a video series you can buy as well.
You can retrieve individual characters from a string: https://jsfiddle.net/dh0qc6mv/
Oh right, really sorry, I thought you were being sarcastic. You're right in that in this situation that declaring the variable over and over isn't ideal. I think in this situation I wouldn't bother declaring it at all and I would just pass the `element.value` straight to the callback (in this case `alert`). No no, don't ever declare anything in the global scope! What if a third party library needs to use that variable? Or you just lose track of what you've declared and misuse the variable or redeclare it. Also there's the thing I mentioned earlier of the value of `name` being pretty much useless to the wider application because you can't be sure when it'll be defined, and if you can't rely on it, you can't build your app with it (unless that's what you're going for for some specific reason). &gt;...would give other functions access to it if need be If there comes a time when it needs to be used by other functions only then should you define it in the parent scope (never global!). Ideally you'd want to pass it as a parameter.
but i dont really see how it works.. i got a little further now. Added a array that has 9 0's . The plan now is that each number i put in input is being placed into the right place in the new array which contains 9 0's. 
C and Java are taking our jobs, and it's very unfair. We need to put WebGL and Web Assembly to work for us. We're gonna bring back jobs from x86. We're gonna bring back jobs from C++. We're going to get great jobs for people writing in Node. And we're going to be just fine.
Javascript fatigue is a hoax invented by China. 
This is a JavaScript subreddit. Java is not JavaScript, just as Ham is not a Hammer.
One practical thing: When searching for learning material make sure the book you're getting teaches JS **in the browser**, a good number of JS material is about JS in the backend, or NodeJS and that has nothing to do with HTML and CSS and the frontend programming you're trying to learn. JS is easy to learn **if** you know programming beforehand. Focus on learning basic and core concepts, because JS has gotten very feature heavy and has a lot of libraries and Framework built for it, which is nice but you get totally lost if you don't get the basics down first. The best slow and basic book I've seen is [A Smarter Way to Learn JavaScript](https://www.amazon.com/Smarter-Way-Learn-JavaScript-technology/dp/1497408180/ref=sr_1_1?ie=UTF8&amp;qid=1477697715&amp;sr=8-1&amp;keywords=javascript). If you can understand HTML you can understand objects, because HTML is just a type of XML - and both Objects and XML are almost logically equivalent ways to structure data. Maybe this helps but the Javascript object: `var o = { "div" : { "p": "Ayyy", "date": 3/2/2018 }, "meta" : "much" } ` Is equivalent to HTML ` &lt;o&gt; &lt;div&gt; &lt;p&gt;"Ayy"&lt;/p&gt; &lt;date&gt;3/2/2018&lt;/date&gt; &lt;/div&gt; &lt;meta&gt;"much"&lt;/meta&gt; &lt;/o&gt; ` And the code to select the date node and the date sub-object is quite similar: `o &gt; div &gt; date` in CSS, but in JS: `o.div.date` (and also `o["div"]["date"]`)
At least we can all agree that JavaScript could use some improvements.
No problem, you're not the first to make the mistake :D.
 [].reduce.call('84732432443', (h, n) =&gt; (h[n]++, h), Array(10).fill(0)) // returns [0, 0, 2, 3, 4, 0, 0, 1, 1, 0]
Cool! Do you have a blog or a link to resources where I can learn this? Or are the three.js docs sufficient? I understand the source, but never fully grasped the whole light/camera thing (similar to after fx).
In regards to leftpad, let‚Äôs dispel once and for all with this fiction that npm doesn't know what it's doing. It knows exactly what it is doing.
arrow functions' primary purpose is to allow the surrounding context to be the functions' context without an explicit bind. example: function foo() { this.bar = 'baz'; return () =&gt; console.log(this.bar); // 'baz' } or, a less contrived example: class Foo { constructor(items) { this.arr = []; items.forEach(item =&gt; this.arr.push(item)); } } (apologies for formatting; typing this on my phone) 
What a horrendous post 
- Freecodecamp is one of the best, as others have said. You could also try looking at lots of JSfiddles. The code is usually compact enough that you can work out what's going on. Like here, for example (this is JQuery, not pure JS): https://jsfiddle.net/svArtist/9ewogtwL/ - MPJ of Funfunfunction is one of the best teachers on the internet. He splits JS into functional and object oriented, and starts from the beginning on each subject. Both OO and FP are necessary in the long run. https://www.youtube.com/watch?v=BMUiFMZr7vk https://www.youtube.com/watch?v=GhbhD1HR5vk - You Don't Know JS is technical but deep. - The Net Ninja is another good teacher: https://www.youtube.com/watch?v=0Mp2kwE8xY0&amp;list=PL4cUxeGkcC9gKfw25slm4CUDUcM_sXdml
Yes they will. I thought you would be intelligent enough to make the connection. I was simply showing the spot where the extra parenthesis goes. Put a single extra opening parenthesis immediately after the 'x' in "Math.max"
Hey check out this tutorial I found on youtube. The guy goes really slow and is very detailed. Its helped me out a lot. https://www.youtube.com/watch?v=XL9Ri8pO68w
Would it be better than this? ;) https://www.youtube.com/watch?v=AaGK-fj-BAM
Hahaha wow. Probably not.
Take a fundamentals of CS course somewhere. When learning programming as a proper beginner I think you should learn the general concepts before learning anything language-specific. Once you've got that down writing JS will be a breeze, it is a very forgiving language.
Np, you might find this interesting: https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)
Sadly California is overrun with the identity politics people who think of Trump as their arch nemesis or some sort of final boss 
The answer is yes you can do it, I'm sorry I've never used math.js and I'm not even 100% sure what sin is, but since you have a string, you can use a regex to test your input and see if you need to make changes. I'm on my phone so this might not be perfect, but this is a regular expression saying - at the beginning of the string I'm looking for 'sin(' - and using the test function it will return true or false. if ( /^sin\(/.test(myInput) ) { myInput = // change input here }
Build a shadow DOM and keep their css out!
I don't know what sort of language Donald grew up coding with, but I know that for millions of developers, javascript is and always has been the greatest language on this planet.
TypeScript is a mess, TypeScript is a waste.
 const select = attr =&gt; [].slice.apply(document.querySelectorAll(`[${attr}]`));
X-Post referenced from [/r/reactjs](http://np.reddit.com/r/reactjs) by /u/sabakumoff [React Entourage](http://np.reddit.com/r/reactjs/comments/59zguk/react_entourage/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Hillary has got no class... She is a prototype of a president.
here they discuss ie https://github.com/rstoenescu/quasar-framework/issues/139
Do you have code reviews? Introduce that. Meaning a change is not introduced into the main branch until it has passed a code review. This means having other team members look at the changes. If no tests are provided, it does not pass review
Since the article mentions Crockford's multi-var statement I thought I should share this from the JSLint G+ community. &gt; The old rule was from 2001, when JSLint began. Function scope was not a well understood concept then, so I recommended putting all var declarations at the top of the function (which is still good advice) to avoid weirdnesses due to hoisting. It was further recommended to use a single var statement to declare all variables. This made compliance with the declare at the top rule easier, and it resulted in a smaller file size, which mattered before gzip was widely used. JSLint used to have a onevar option that suppressed warnings on multiple var statements. &gt; Things are different now. gzip is a well established practice. Function scope is better understood, and with ES6, becomes irrelevant. One variable per declaration simplifies indentation and reduces potential confusion with the comma operator and object literals. Most importantly, I have observed that multivar was confusing to beginners, and I want to remove sources of confusion when I can.
 const makePies = (type, person, number) =&gt; Array(number).fill(type); "problem" solved.
I assume it can't output uncaught exceptions, like ReferenceError: something is not defined ?
Why not just multiply by pi/180? Edit: you can also use `math.unit(x, 'deg')`
Found a part of the problem. I had to remove .sort causee it wouldnt be able to get to the lower numbers anymore x). But still no clue how to count the lower numbers now, sinze it resets them to 1 
You are counting correctly, but with `innerHTML = current ...` you are only outputting the last line, since your are overwriting all previous lines. Try this: var tallArr = []; var btnAdd = function() { var checArr = []; var count = 0; if (inpTxt.value == "") { return false; } tallArr.push(document.getElementById('inpTxt').value); document.getElementById('inpTxt').value = ""; checArr.push.apply(checArr, tallArr); checArr.sort(); var current = checArr[0]; var outTxt = ""; for (var i = 0; i &lt; checArr.length; i++) { if (checArr[i] != current) { outTxt += current + " excists" + count + "times&lt;br /&gt;"; current = checArr[i]; count = 1; } else { count++; } } outTxt += current + " excists" + count + "times&lt;br /&gt;"; document.getElementById('outTxt').innerHTML = outTxt; }
Just a small not to otherwise good explanation: you can't really switch HTML to JavaScript Object that easily, because HTML/XML elements can have many children with the same name, for example `&lt;o&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/o&gt;` thus not possible to generally represent the HTML tree without using "children" -Array. Other thing is that HTML attributes generally correspondent to the properties of Object, like `&lt;o style="..."&gt;` to the property `o.style` but XML can not have child properties of properties.
The /r/learnjavascript subreddit is also useful.
It was my first proframming language, and it's still the most fun to use in my opinion!
No. Single-var is about forcing you to put all your declarations at the very top of the function. This is supposed to make your code look how it actually works (hoisting). With let and const you can just declare your variables on first use as you would do in any other language with block scope. Furthermore, declaring variables separately is encouraged because it keeps diffs cleaner and it's easier to move things around. [I didn't read the article. The page took too long to load and it didn't render progressively. I don't know how much longer I'd have to look at that spinner. Fuck that.]
Anither reason to transpile es6 to es5.
My question was responded here: https://github.com/rstoenescu/quasar-framework/issues/148
It's a bit more straightforward if you get the tallies first and then stick the results into an array and finally sort them. Formatting the text and interacting with the DOM is something you should do outside of that function. If a function only does one thing and if it's furthermore free of side-effects, it's much easier to test. While this isn't that important for you right now, it's something to keep in mind for the future. [Pure functions](https://en.wikipedia.org/wiki/Pure_function) are super convenient. Here is how a naive implementation could look like: https://jsfiddle.net/ce6abLoq/ The first loop can be sped up by wrapping the counter in an object and keeping a reference to said object. This way you only have to do the (somewhat costly) lookup once instead of twice. Since I'm playing the smart-ass here, I should probably also point out that my "tally" function does nothing to put ties in a particular order. This part is implementation-dependent. Strictly speaking, it isn't pure. It can be easily fixed by using a slightly more elaborate sorting function, though.
is there any way to implement tor over javascript then? Without using servers in between? 
 var nodes = document.querySelectorAll('[hope="0"]'); nodes = Array.prototype.slice.call(nodes); var length = nodes.length; Should work, if all you want is nodes with 0 hops. If you're working with an entire set of nodes, you could perhaps benefit from something like var allNodes = Array.prototype.slice.call(document.querySelectorAll("[hops]")) var tier0 = allNodes.filter(function (n) { return n.getAttribute("hops") == 0; }); One thing though - Not sure how well hops="0" is going to work. I would advise using data attributes for your custom attribute needs, at least if working with vanilla HTML and JS, and I would suggest using classes for selection, rather than data attributes. They aren't ment for it. So you'd get somehting like &lt;div class="node" data-hops="0"&gt;&lt;/div&gt;
Does he actually know whats a linter even is? He probably just says anything his scriptwriter asks him to at this point
&gt; every forum I go on people say it's easy to learn ES6 is a very complicated language with a massive spec. There are a lot of things missing from JS (types, threads, operator overloading, etc), but that doesn't mean that what's there is super straightforward. I've literally used over a dozen different languages and JS certainly isn't on the simple side of the spectrum. Getting started is easy, though. All you need is a browser and some text editor. You can make it a bit easier by using a smart editor like VS Code with a linter plugin (ESLint). Furthermore, you can make things less annoying by sticking to a modern subset of the language. Unfortunately, I'm not aware of any resources which teach JS by starting there. Anyhow, there are many online resources available. If you don't understand a particular explanation, see what another online book has to say about this topic. And if everything fails, you can still ask on /r/learnjavascript for a clarification.
I wasn't going to say anything because defending your unserious article on the internet is kinda lame, but meh. I didn't want to pack the thing with hedging against the kind of misunderstandings going on here, but yes, I also: - get annoyed with all the syntax quibbling articles - understand approaching shiny new toys with caution - understand the unbound semantics of arrow functions - don't use them everywhere. The problem I've identified is still totally valid. I wrote it as if I were declaring a function, but I do run into this usually in the context of anonymous functions. E.g., class Whatever { function method () { this.stuff.forEach(x =&gt; this.otherthing(x)) } } In that case the semantics are super helpful! But the syntactical changes needed when, for example, adding the index as an argument to that map function are just distracting. This is a principle style guides often appeal to, but airbnb's style guide, for example, encourages preferring syntactic sugar over a more flexible and complete syntax in the case of arrow functions. Anyway, /bikeshed
Not a complaint. Just observing that the exceedingly high technology involved in this demo delivers a result that harkens back to 90's web garishness in an ironic sort of way.
Sort of. The interesting question is what happens if there's a variable with the same name in an outer scope. For example, in C++: auto x = 42; { cout &lt;&lt; x; // 42 auto x = 7; cout &lt;&lt; x; // 7 } But the same in JavaScript: let x = 42; { console.log(x); // Reference error let x = 7; console.log(x); // 7 } So there's still some... let's say *semi*-hoisting... behavior going on.
Personally I stopped following the single var pattern a long time ago. As soon as we had linters that could warn me about hoisting mistakes, then the single var pattern wasn't useful to me anymore. I prefer to declare my variables at their point of first use.
I've used BatteryManager web api to create this small battery status checker: [Repository](https://github.com/Krizzu/batterystatus.js)
You could use window error event.
VB6 was solid. It was by far my favorite language at the time. 
i was only trying to find a replacement for mongoose.
React isn't about speed, it's about deterministic rendering. There are plenty of faster ways to do specific things; React just happens to be pretty darn good at many of them. Server-side rendering addresses one area of speed that no single-page application will ever be able to address- the fact that browsers can render to the screen before all of the JavaScript has been loaded, parsed and executed. By creating HTML first on the server, users with slower internet connections (and occasionally faster internet connections if the JS payload is large enough) will be able to start viewing your content sooner. There are a number of studies that show that users will abandon websites that take too long to fully load, but I'm a little skeptical that those apply to single-page applications; in most cases they really apply to either (1) sites with simple content or (2) sites that initially start to load, but are so bogged down with ads, modal popup windows, and images that reposition content a user has started reading that they give up waiting for the site to stabilize. Even still, the performance boost can be useful depending on what kind of website / application you're building.
I think I'm a fan. Id love to see where this goes. Watching some vids, and the reading through their tic tac toe, some really great ideas and i can see how this could really work. Least favorite part was the bind @browser with all that inline css stuff. Prefer the more template-like ways of angular, or react, even razor and classic ASP was template like. So yeah that aside i liked the language at first blush. Very terse and the search where variables are introduced reminds me of my favourite part of F#, the pattern matching. I think I'm going back to website now. It might be fun to try and build a tiny little something with this. Wonder how stable a 0.2 release is
love async functions. this is the first time i haven't been like "promises are a useless abstraction that makes things more complicated"
Is this to pass into math.parse? I thought it took absolute value bars. Try it out, if not, let me know.
Renaming won't work. Source: I worked on a daemon that enabled this called Amok for a long time.
I see. But i like p5. Im gonna use that in my tutorial
At some point you will have to learn npm, is how you organize your dependencies. But for now you can do silly projects importing all javascript with the &lt;script&gt; tag. I never used inferno, but seems that you can put a cdn link in the script tag.
Vb6 was really cool. You can go from zero to a simple windows application in 5 minutes. I wrote an entire IRC client in VB6, it was rad.
I'm shaking my head at the notion that Js is supposed to be easy. If you come from another language, it's still not easy. Asynchronous control flow , prototypal inheritance, functional methods ... These are 'easy' if you want to do something trivial, but otherwise you'll find that the language itself isn't very well designed, and in that respect, it's hard. My advice is to pick a few topics you want to learn and explore them fully by experimenting in your browser console and saving them as scripts. Don't rest until your questions are answered. If you learn things in depth then you have something to build on when you take on new topics. If you don't learn a given topic in depth you'll forever repeat your mistakes. My method saves you time. I reject Js for dummies type books and ESPECIALLY codeshool because they treat you like a child and keep you dependent on the notion that you need a guide to show you how 'easy' it is. 
There really isn't a "framework" that is going to support "everything". From a JS perspective, all modern and slightly old versions of browsers can cover 99% of any cross-environment issues by utilizing a transpiler (like babel) along with jQuery. Those tools are designed to convert modern/next JS to plain ES5 (which is what modern/slightly old browsers completely support) and also cover browser-specific issues like how IE determines document client height vs how Chrome does it/etc. CSS is a whole other ball game and while there are tools to make life easier, you will just have to learn/test those as you go. In our work environment, we utilize all of these modern tools and still test every single browser we intend to support as again there isn't any tool/combination that will alleviate any cross-environment concerns. Hope that helps!
The best combination I've found is ExtJS plus Sencha Touch. You do actually have to write the UI twice but there's so much code shared that it's not really much of a hassle. Big down side is ExtJS is stupid expensive (and Sencha might be charging for Touch now too, I'm not sure). 
It's a stage 3 proposal atm so it will almost assuredly land in es2017. 
You probably don't need to crosspost this to every JavaScript related subreddit. 
Haxe is a language which will compile to many targets. It's based ActionScript, so it's similar in syntax to JavaScript.
Electron for desktop, React native/Nativescript/Ionic(2) for mobile. There is no all-in-one solution unfortunately, bit this way it would be easiest.
This doesn't require switching from promises - this builds on promises. For node, this will be supported in v7/8. It currently has to be enabled with a flag but that is just temporary - it will be fully supported in v8.
Is wrapping await blocks in try/catch bad for performance? I just remember hearing that it was something that would trip V8 up when jitting.
Actually it's a Stage 4 proposal, so it has been formally accepted into ES2017.
[Here's a JSfiddle demonstrating how to do this][1]. You're essentially writing a compiler. [1]: https://jsfiddle.net/18zub13j/
I'm beginning to get the feeling I'm in over my head here... Thanks anyway.
Hey, that function works, you should be able to use it for anything. Just plug and chug, you don't need to know how every piece of code you use works.
I disagree, someone might follow one of those subs and others might follow the rest. There will always be someone that will miss this and I want to prevent that from happening. In /r/node, it will generate discussions related to node support and their insistence on callbacks. In /r/javascript it will generate discussions that provide a general overview of the functionality from a low level perspective either node or the browser. In /r/webdev it will generate discussion of how this affects web tooling and browser support, same for /r/frontend (The reason why I post in both is because I know people that don't look at /r/webdev, just /r/frontend).
Promises are not easier to read, readability is all up to the developer in this case. Using proper principles like separation of concerns you can make callbacks easier to read too. The reason why Promises are better is not about [legibility](https://medium.com/@fagnerbrack/the-legibility-argument-d1ec889b9c8a), but about trusting the data to be properly wrapped and immutable in a functional structure without allowing additional vectors of complexity.
How do you feel about VB.NET? I did like VB6 (though I had limited experience at the time), but now with C# around VB.NET feels like a hack to me. It's trying to shove all the C-sharpy CLR things in awkward places.
Reminds me vaguely of a Lisp.
When I skimmed the page, I was screaming [squeak](https://github.com/squeak-smalltalk/squeak-app) multiple times. That's a programming language, designed for humans, in 1996. 
I'd leave it up to the moderators. Post away.
I agree. I find myself translating async functions into their promise form to understand how they work.
I guess, it's just that I'm not sure what I'd do if I wanted to add other functions.
&gt;Each smoke tint should have its own cache canvas. Draw once. Ah, ok! I didn't think that was possible, because the tint is a combination of light colors / distance. I've got red, blue, green, slight purple, yellow, green, and light green so far.... Each particle is an illumination source (can't do that in three.js until I learn hot to do deferred rendering in it)... and its effect changes by the distance. So every smoke particles brightness is a combination of all the surrounding colors that can influence it... Are you saying I should make a group of discreet color images running through the different shades? Rather than running through the existing light source colors (red, green, blue, yellow, light green, purple.. and so on) it sounds more efficient to just go with discreet RGB steps. Say if each primary color has 8 steps, that's 8x8x8 = 512 cached images for the smoke. Hm, that's doable.... I'll need to run some tests to see if the jumps in tint are too obvious. Thanks for the info! Ohhhh - just noticed something: https://www.reddit.com/r/javascript/comments/59t0k8/xpost_rlearnjavascript_canvas_whats_the_fastest/d9dn8mp/
Well, it will be definitely against the fundamental sharing purpose of Reddit to remove a link because it's being posted in a different sub.
Of course, developers inject a JS engine into many environments, not sure what your point is here though.
Do you know any redux application which its business logic is not entirely made of actions and reducers (and maybe middlewares)?
yeap, just 2-3 down me, but yea finally got 100/100 ;d
I'm sorry but do you make any app at all then? I understand that you don't want to be constrained by a massive Angular / Ember framework or libraries like Redux for the architectural flexibility, but what is your solution then? Do you write your own flux library, or create abstractions around all libraries that you use so you can replace them out in the future?
looks to be deleted now, but yes that does sound douchey
The author didn't understand how to write ES6 arrow functions initially, and had a few gotcha moments related to parentheses and lack of implicit return statements. He decided to call arrows functions "terrible" just because he doesn't like the syntax. Now that people in comments section reminded him of different `this` semantics, he's in the defensive mode.
So, instead of going through all of them to get final result, it resets each time? \#1 UX design.
Cool, I've been using discord more and more and I'm hoping it gets popular enough so I can stop using IRC
I'm kind of happy i don't know them all
[And I don't Javascript, Bro.](http://imgur.com/a/lf9sU) 
https://blog.risingstack.com/async-await-node-js-7-nightly/ It's in node.js 7.0.0 behind a flag (`--harmony_async_await`). Apparently there still is a memory issue somewhere, but I think it's already been fixed in V8 and we are only waiting for a newer node version to pick up that newer V8 version.
\#You need a backslash for your hash.
 let apromise = new Promise(dothing); apromise .then(dothis) .then(dothat) .then(doanother) .catch(error); vs async function apromise() { let x = await dothing(); let a = await dothis(x); let b = await dothat(a); let c = await doanother(b); } apromise().catch(error);
exciting!
300 words article, have you read SEO for beginners ?
Even easier: var solve = setInterval(function() { if (document.querySelector('.logo')) { if (document.querySelectorAll('.ripple-button')[0].innerText.toLowerCase() == document.querySelector('.logo').alt.toLowerCase()) { document.querySelectorAll('.ripple-button')[0].click(); } else if (document.querySelectorAll('.ripple-button')[1].innerText.toLowerCase() == document.querySelector('.logo').alt.toLowerCase()) { document.querySelectorAll('.ripple-button')[1].click(); } else if (document.querySelectorAll('.ripple-button')[2].innerText.toLowerCase() == document.querySelector('.logo').alt.toLowerCase()) { document.querySelectorAll('.ripple-button')[2].click(); } else if (document.querySelectorAll('.ripple-button')[3].innerText.toLowerCase() == document.querySelector('.logo').alt.toLowerCase()) { document.querySelectorAll('.ripple-button')[3].click(); } } else { clearInterval(solve) } }, 100);
Who says that?
So many times I've searched around for "the best" boiler plate, only to ditch it later a DIY solution. I think the comprise is to just borrow bits here and there as needed
Hm interesting, although a bit disingenuous, since you could place the promises function on separate lines and it would be just as if not more legible. I guess to me A then B then C then D, just looks easier to read. But back to your example, what's the syntax for the await functions, I'm guessing you still have to return a promise or? For example, to chain then functions you have to have return promise(); I'm guessing you need to return something with await so it knows the async call has completed and returned data. Also, with then I can pass success and fail functions at each step to catch errors, can await do the same? 
&gt; Do you think that writing pure Object-Oriented code is the ultimate perfection for developing server-side business logic? What a strange hook. "Do you think the world is flat? No? Well, you're right. But some stuff you think is wrong, and I don't need to prove that, because some other stuff some other people once thought was wrong!" &gt; If a library comes with architectural requirements that‚Äôs a very bad signal. As does every state management library for React, of course. Then again, React does too! And...wow, so does Backbone. And Angular. And Ember! The rot goes deep! So what am I allowed to use? jQuery and Lodash? But as soon as I use those to start writing code, my code will start to impose architectural requirements on me! Does the madness never end? Okay, fine, I'm being overly snarky. But seriously, you need to rethink your line of arguments. Every app has an architecture; I want my libraries to support that architecture. It's quite easy to write a flux-pattern app (eg, one way data flow, passing methods and immutable data down as props) without anything but pure React (and not a bad idea in many cases). And then you could, sure, toss Redux into the mix to make your life a bit easier. The fact Redux works with your existing architecture is not, to say the least, a black mark on Redux. (Ah, you say, but what if my architecture doesn't work well with Redux? Then maybe you shouldn't pick it!) &gt; Does Redux, as a library, require using a specific architecture? It's uses a flux based architecture, so...yeah? &gt; Is Redux action-reducer architecture functionally complete? I bet that sounded a lot clearer inside the authors head. Suggestion: Maybe don't use a word as ambiguous as "functionally" when discussing programming styles. (Also: The action-reducer architecture is just a flavour of flux. It seems kind of odd to have an article about Redux and architecture that doesn't even contain the word "flux".) &gt; Is it easy to replace Redux with another state-container or data-storage without updating entire app? If you're not changing the architecture, yes. If you are changing the architecture, no. Just like, you know, every other architecture and paradigm ever. This seems like a really, really weird complaint. "If you use a library to enable a specific architecture, then you'll be using that architecture, and if you want to rewrite your app, you'll need to rewrite your app!" Um...yes?
There's a special place in Hell where you're forced to build projects with over-engineered React boilerplate repos forever. "We have such sites to show you..."
So many medium shit posts... so little time. I wish the sub would ban medium. The shit to not shit is like 10:1. Every time I see one of these shit posts I think to myself. Show me what you've built. Show me what you've contributed to the JavaScript ecosystem in a positive way.
Seems strange to me -- maybe this is meant to be a convenience feature of dev tools, but it's not especially useful in my opinion: I would typically use $0 in Chrome. I would be dismayed if you didn't need `getElementById()`. 
Well redux is definitely overhyped, and that hype making many newbies listening to founder of redux and other people behind about functional programming, without even knowing and working fully with OOP. But I'm using just Flux and pretty happy about it! Not redux, no alt, reflux etc.
Me either. I just thought it was interesting enough to share. 
Another reason to avoid using the global scope!
class Leggable extends Barkable extends Doggable
What I understand from this is that we should never adopt anything because something better will come along later, which is absurd.
&gt; Apparently it only works if your ID happens to be a valid variable name, so no hyphens. window['foo-bar'] works. https://jsfiddle.net/f3xcovyk/
I agree. I'n not sure whether to make it simple or slightly technical that's my problem. 
White space as syntax causes maintenance problems. Some common languages strongly reliant on white space as syntax include: * coffeescript * jade * elixir * sass To a far lesser extent most languages have, at a minimum, white space as syntax for word token type separation. The problem with this is that white space isn't a character. Its a classification of many characters where that classification is not universally defined or which some are rarely used and not universally supported. This introduces severe portability problems. If you are operating under the assumption that code lives only on your local computer before being transpiled to something else then the portability problem isn't immediately clear. If the code is part of a git repository then the code is portable. Fortunately git is pretty safe since it captures code against a hash that it can use an both an integrity check and an identifier. There are other transfer mechanisms to consider: * http * ftp * email * udp When code is transferred via http it is encoded and decoded at the distant end by a mime type. Typically with text you are generally safe, but not so much in this case. The most easily corrupt-able data in text transfering over http is white space. Before text can make sense to a human it must be interpreted by a consuming application, which in the online world is typically called a user-agent. Different user-agent applications provide different levels of support for text by format, range, character-set, operating system specific conventions, and other factors. The most universally supported text format is 7-bit ASCII, which is still the standard for email, that is consumed by Unicode, but with different limitations. A common misunderstanding, I do this all the time too, is that when you get code from github through your browser you are going through formatted HTML delivered via HTTP. All of the awesome fidelity and integrity provided by git is ignored, because you used your browser instead of git. You don't know if the characters you are copying to your clipboard are identical to those written by the code author. While this could be true for any character white space characters are almost invisible. Some white space characters are completely invisible, such as zero-width non-joiners (ZWNJ). Some systems will strip white space characters it doesn't understand on text render. If your verification is a visual glance of characters you can't see anyways there is no way to know that the code is changed or at which point in a process the change occurred. For example was the code changed in your browser as it is rendered for you, or on the server before this, or an a transfer operation between this? If the code is solid in the browser it could still be changed in the clipboard or on paste depending upon the consuming application. It is hard to tell. Even if corruption weren't a cause for concern it is one of the biggest causes of holy wars in language design discussions. For example bring up any conversation about ASI. Thanks to ASI line termination is language syntax and language syntax is not universally defined. ASI is also a good example of potential code corruption. If I were going to design a new language from scratch I would eliminate white space as syntax. The problem there is that the same amount of syntax is required, but now it looks like code instead of a novel. This turns many people off. Don't care. If you think the white space problems aren't real then try using email (the email message body and not file attachments) as your version system instead of git. You have all the same distribution and blame benefits, but with a high level of white space corruption.
I've simplified it with analogies so it is is more beginner friendly. The animation will also support the explanations.
I don't feel like neural networking in JavaScript was explained at all. The app seems to load the README.md and some annotations about the source code. You don't hand someone the blueprints of a car to drive it.
X-Post referenced from [/r/node](http://np.reddit.com/r/node) by /u/Gurkenpete [Logging HTTP Requests Concurrently](http://np.reddit.com/r/node/comments/5a6yfz/logging_http_requests_concurrently/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
I don't get it. Can't we just use require? It's a very commonly accepted syntax and seems to work as expected
I think the problem with that is require is only part of the nodejs API. If require() were to go through the es spec track, the API would do one of the following: 1. It follows 1:1 the node require() API spec 2. The require() API changes If 1 were to happen, it probably won't work with any browser since require is not asynchronous. And then people ask for import() to be part of the es spec. If 2 were to happen, any node project using require() would be facing (extremely probable) breaking changes (since it now conforms to this new API). Node _could_ just make require not follow the es spec, but then anyone using something like webpack would be asking for import() üòâ The benefits to import() is require can maintain its natural synchronous behavior, but you also get this new asynchronous version with import(), which can actually work in a browser environment üëç
If you take a moment to look at the link, you'll see that the API would be completely different: import(`./section-modules/${link.dataset.entryModule}.js`) .then(module =&gt; { module.loadPageInto(main); }) .catch(err =&gt; { main.textContent = err.message; });
This is already covered by the JS Loader standard: [spec here](https://github.com/whatwg/loader/blob/master/README.md)
I'm pretty new to JavaScript, but have been programming in other languages for a while now. I'm a huge fan of React (despite getting used to some of it's quirks) for its ability to keep large scale front-ends organized to the exact degree that you want it. Also, be sure to write automated tests for everything, that way when you make a change, you can just run all your tests and ensure everything still works. Hope that helps. 
Writing UI code is hard because the interaction is not always linear but that doesn't mean the code needs to be messy. You need to be careful with how you manage and update state and with how you split your code base. I've found that React's model of unidirectional data flow combined with Redux's methodical state management has encouraged massive architectural improvements of projects. Remember that jQuery isn't a framework, it is a library designed to abstract away browser inconsistencies and to add convenience functions to the DOM. The architecture of the app is external to these features.
Ahhh, the async. Yeah I didn't think about that. I never remember that require is synchronous because I always use it in node when i want it synchronous anyway
Half of them have their name in the image...
Sure. But the Loader spec is old and is going nowhere. Whereas Domenic's proposal is credible and already at TC39 stage 2. It's small/focused enough to reach stage 4 quickly.
Great that it's solved, sorry for not seeing this (library author here). Questions are also welcome on Github, or just drop a note if you ask in Reddit so I can see it and help, but Magixxxx did a GREAT job explaining it.
Feels like the annotations started out great and then didn't explain anything better than the variable names themselves after the beginning.
Like most of us doesn't create what we're paid to create. What a bunch of idiots 
Give React a try, one of its main strengths is component composition. So you can organize your code by components that are easy to reason about, maintain, etc. Don't use a boilerplate, but do consider using create-react-app and stick to its defaults (don't eject). That will give you a sane setup with zero config, the latest JavaScript features, testing ready to go, etc. It's by far the easiest way to develop a structured web app right now. 
Exaggeration is equivalent to clickbait in this context, if you titled your article "I don't like ES6 arrow syntax", that wouldn't be clickbait. The point is I had to get in your article to see that sentence. Also, when I wrote that you didn't understand, there was no insult in my words, you literally had trouble with the `return` keyword. &gt; It's bad design. It's not perfect, that paranthesis problem in `const makePie = type =&gt; ({type})` also bothers me, but it's far from bad design.
*Note: I am relatively new to the language, that being said I'd like to take a stab at what I think is the answer... It means functions in JavaScript can be treated as objects. You can add properties to them. If you'd like a in depth example check this out. http://stackoverflow.com/questions/705173/what-is-meant-by-first-class-object And http://helephant.com/2008/08/19/functions-are-first-class-objects-in-javascript/
I would use a database. Import the data and use a query to get the data to your page
And it only works if you are in Chrome and in the console. So don't go thinking you don't need to do any coding, redditor and you still have to think, if you ever have before.
Man, even when you have a decent point to make, you choose to word it in such an impolite manner.
I'd say this was one of those features that was added so that people could quickly write inline code in onclick attributes and the like: `&lt;button onclick="alert(myInputElementId.value)"&gt;Log&lt;/button&gt;`
I think there is a bit of misunderstanding here. This is not a faux repository that clones projects from github (and is maintained by others). It is an annotation tool for anyone to share their insight/opinion/explanation about their project of interest. I simply thought this was cool and wanted to share w this group. One thing that troubles me is this sort of accusatory tone in your comment. They simply want to write notes on the project they like, and share those notes with other. I don't think there is anything wrong with that. 
[No need to wait!](https://github.com/tc39/proposal-cancelable-promises)
install Wordpress for her and BAM!
&gt; I guess we agree that Redux requires business logic to follow a specific architecture Only if you mean "it requires you to seperate it from your presentation". If that represents a change, your design is bad and you should feel bad. &gt; but React doesn't Clearly incorrect.
[&amp;sect;5.2.4 Named access on the Window object](https://www.w3.org/TR/html5/browsers.html#named-access-on-the-window-object) 
Yep. You're right. I misread the question.
Stream it to your server as a WAV, then you can use [FFmpeg](https://www.ffmpeg.org/) to convert it to MP3. There's a good demo here: http://subinsb.com/html5-record-mic-voice
 document.getElementsByClassName("btn btn-small btn-icon btn-primary btn-play") Will return a list of the elements that have all those class names. Is that what you want or are you searching for a list of the elements that have any of those name?
www.eloquentjavascript.net
I just wanted to point out that it's a bad practice to store audio or any type of media files in a database. These files are stored in a directory on the server. In DB you can store the path to the file, name, description, etc.
To answer your first question: I think community agrees that currently solution for OO in JS is [ES2015 classes](https://www.fourkitchens.com/blog/article/practical-introduction-es2015-classes) and solution for namespaces is [ES2015 modules](https://strongloop.com/strongblog/an-introduction-to-javascript-es6-modules/). You would make use of these in the actual production code with [Babel](https://babeljs.io/) and [Webpack](http://webpack.github.io/docs/) for each task respectively (or [Bubl√©](https://buble.surge.sh/guide/) and [Rollup](http://rollupjs.org/) if you are feeling adventurous; are you feeling JS fatigue yet?) To add to answers about your second question: I think it actually gained plenty of buzz in JS community kind of by proxy via [ClojureScript](https://clojurescript.org/) which produces JS code that is specifically designed to be optimized very well by Google Closure *because* it's so good at it.
It's still highly experimental.
We've certainly come a long way.
For which browser?
You'll at least need access to the XHR object, in order to use its `addEventListener()`. The other way is to hook the `XMLHttpRequest` methods.
It looks like the term, 'Explained', is the center of discussion here. Perhaps I used the term too liberally. There was no intention to mislead others, and I apologize if you felt that way. 
Is this like MIDI but for the web?
WebAudioFont does not apply to General MIDI standart. Not on your nelly. At all. Main benefit of WebAudioFont is easy access to ready to use musical instruments. You need to spend many worktime to recreate Harp, for example. With WebAudioFont you need about 10 minutes to seek Harp in Catalog and choose sound variation that you like. Sound library and player has enough quality for 90% of applications. If you need better sound quality for new app like FL Studio - contact me 8) Application are for WebAudioFont are - virtual instruments/drums - sound effects for non-musical sites - music that generated on the fly Of course, you can parse midi files and play them via instruments from WebAudioFont if you wish. But i don't understand why do you need this. There are hundreds of midi-players.
October 2016. Still using the phrase 'Javascript Fatigue'. I'll give it a miss thanks.
I always look at commits first: https://github.com/facebook/immutable-js/commits/master Last code commit 15 July, A tiny README change in September.
Sort bugs by most commented: https://github.com/facebook/immutable-js/issues?q=is%3Aissue+is%3Aopen+sort%3Acomments-desc+label%3Abug Not every project needs constant development. It's quite possible that the tool is considered ready and minor improvements are not really important. 
For the longest time I always wrote my classes, or in Javascript "simulated classes" (with a prototype, same thing that the ES 2015 `class` keyword does in the background). I always got angry at all those often over-opinionated blog posts telling me I'm doing it wrong and I should use a functional style, and classes are soooo yesterday. After all, it worked very well! Whenever I get angry at opinions voiced by more than just a few people I don't feel comfortable yelling back without having solid arguments because I don't actually understand their side. Besides, I knew I had mostly ignored functional programming (as much as possible) during my CS study. Back then it just wasn't practical. So I decided to bite the bullet and study up on FP. Well, to cut a long story short, today I write large JS projects without any use of `new` (mostly), `class`, `prototype`, `this`, `call`, `apply`. I just don't use those Javascript features. I have no need. Of course, I still need to use `new` for a few cases that I have no control over, no big deal. I'm not religious about it, it's not like I'm trying to avoid it at all costs, instead it's that I don't *need* it. Flexibility of a functional style is *much* higher. Instead of having everything bound to some object (and then I have to deal with `this`) it's all in a closure where I can do whatever I want. Closure + lexical scoping rules! If I want to hand some levers and pipes to the outside world to communicate with my inside I build an object, attach everything I want to be visible, and hand it to the outside. This is a *much* better control over what I want to make visible than any "public", "protected", "private" scheme for fields in OOP. And as I said, I don't need to deal with `this`, I can just use all my variables as usual - they are part of the closure. I don't need to do even that very often, just functions are enough a lot of times. I also see the value of monads now, and of getting rid of special-case treatments (liek checking for `null` results). I'm not an "FP zealot" by any means. There is no "side-effect free" in the real world. In a blog post somewhere I found a tiny 3-liner in Haskell that does nothing, uses only the identity function, but it brings down your computer. I used to do some embedded stuff long ago and just for fun a few months ago to remind myself that 32K RAM are plenty for a surprising amount of tasks, and with some FP constructs you lose ever more connection to what's going on on the machine. But when you don't get overzealous I think functional style elements *can* give much more flexibility also in Javascript compared to "old" style based on prototypes, `this` and the "this"-management methods (bind, apply, call).
You could threaten to fork it into a successor project. That might motivate them. That's a ton of responsibility too.
That would be the JavaScript way... but not necessary. I guess the ideal situation is that they add a few external contributors from the community. It basically looks like a one man project: https://github.com/facebook/immutable-js/graphs/contributors
Also, it looks like [`&lt;script defer&gt;`](http://www.w3schools.com/tags/att_script_defer.asp) can do exactly what's needed. I'm investigating. :-)
This is mostly a joke. I don't think it should discourage you from doing one. Even if no one else were to watch it (which I'm sure they will) there's still value in you doing one yourself.
This is a terrible, terrible idea, but if you really want a blocking sleep... function sleep( ms ) { let start = Date.now(); while ( Date.now() &lt; start + ms ) {} } console.log('a'); sleep( 1000 ); console.log('b');
If you know the value, can you not reassign it to something local? AFAIK you can't do this, you can solve for x but you can't solve the value of x for x.
I know the value, but the script that the site uses is quite complicated and gets that value from somewhere, and I would like to change that "somewhere". 
Using setTimeout ... function sleep(ms, callback, next) { setTimeout(callback, ms); return next &amp;&amp; next(); } sleep(0, () =&gt; console.log('a'), () =&gt; sleep(1000, () =&gt; console.log('b')) ); 
Nice, would be a good cross post in r/learnjavascript ! 
So maybe you want to ping the guy on Twitter? Afraid us on Reddit won't really help much... would be interested how it goes though! :)
I've been maintaining a company fork of immutable just to fix the typescript typings. I found the same thing as you, that they were totally unresponsive on even small PRs.
I disagree with the notion that you shouldn't learn the core language in depth first. There are too many framework programmers out there who don't really know JavaScript.
thanks for the help. how do you suggest I learn js to get to your level and do what you just did? I mainly do alot of dom manipulations and string rewrtes so I am comfortable to an extent at the basic level. I just haven't worked much with OO js. I'm assuming thats what that is?
Also it's super slow.
Thank you, I'll check it :) 
If I understand your request right, you can do it easily with just plain Javascript: const onlyItemsWithInvoice1 = obj.items.filter(item =&gt; item.invoice === 1); 
a chrome extension
If you're a JS developer yourself, you're probably more in the "JavaScript Fatigue Fatigue" phase (or you're like me, and don't care much about it in the first place). But if you're not, chances are you just heard about this "JavaScript Fatigue" thing (I noticed this with some of my colleagues) and recognize some of it with yourself. I think it's that second group this article is aimed at ;)
Modals
A modal with an iframe? Put the form in the iframe, then use postMessage or the load event on the iframe to close the modal when the form has been submitted?
I wrote a tool a while ago to intercept all requests on a page (for the purposes of adding headers). Not sure if this is what you are looking for. https://github.com/DylanPiercey/side-step
Thanks for the response, it's a modular pattern that exposes an API. Very nice. I thought you'd gone down the composition over inheritance route by not using prototype. I have actually used your method above and it does work well, the only time I had to adapt from it was when I had to process binary data and translate it into JS readable objects. I used prototypal inheritance for memory and speed efficiency but that was preference. It could have been done as above :)
They've been rebranded as... "modals." They're essentially popups but in the same window/tab. People still hate them.
I fixed all your concerns with a about 15 more lines.
You can't intercept HTTP requests, it's a security limitation. You can however intercept requests from an extension [1]. [1] https://developer.mozilla.org/en-US/Add-ons/WebExtensions/Intercept_HTTP_requests 
I've released a couple of cross platform apps using [Electron](http://electron.atom.io/) and [Cordova](https://cordova.apache.org/). Cordova allows you to package web apps for mobile and Electron allows you to package web apps for desktop.
go into console. type this: for (var e in window) console.log(`%c${e} %c${window[e]}`, 'font-weight:bold', 'color:blue'); (note use of backticks - this is necessary) Now what do you mean deep enough? All globals get dumped into the window object, which is already heavy on lots of things. for (var e in window) if (window[e] == "lookingForThis") console.log(`%c${e} %c${window[e]}`, 'font-weight:bold', 'color:blue'); will find "lookingForThis", if it's a top level global variable. If not you'll have to go deeper into each object, loop through it's values, recurse if necessary. 
Could mean the Facebook guy is working on another project. The way Facebook's open-source projects work is in order to pull in changes they implement it internally first and then approve the changes and merge it publicly (or something. I don't fully understand it, but basically they have to find an internal use-case first). If the guy had to pick up a new project he's not around to merge changes and then the project gets "stale."
Interpreters like v8 might eliminate this altogether
Why do programmers always confuse Halloween and Christmas?
Why do they?
&gt; Yeah... but that's still state. YES??? Of course!! &gt; but actually it's exactly an object in the OOP sense No. The meaning of an object at least as far as actual wide-spread usage in languages like Java or now ES 2015 Javascript is concerned it is a bundle of methods and data, and the methods use the special word `this` to access "their" data (and other methods). That is different from the above. &gt; but you're still doing the same thing. I have a growing feeling you either didn't read what I wrote or you have no clue what you are talking about.
I use composition - of functions. The above was, as I said, a special example based on what I had originally written. I did not see the need to explain function composition, since that's pretty clear. So again: The above is not my typical pattern, in fact it's very rare. I continued expanding what I had written in the first comment since you asked about `Object.assign`, and the only possible use for that would be when I actually have an object. Most is just functions and lexical scope and closures.
So it seems that there is nothing we agree about! :)
oct 31 = Octal 31 dec 25 = Decimal 25 Octal is a base 8 system, so conversion to decimal is basically just division by 8 on the decimal number and multiplying by ten, then getting the integer of that. 25 / 8 = 3.125 * 10 = 31
That's actually multiple inheritance, sometimes also called mixins or traits, and definitely not composition. For example, since Python natively supports multiple inheritance: class saysName: def sayName(self): print(self.name) class saysAge: def sayAge(self): print(self.age) class person(saysName, saysAge): # &lt;- inheritance from multiple bases def __init__(self, name, age): self.name = name self.age = age matty = person("Matt", 24) jenny = person("Jenny", 30) jenny.sayAge() matty.sayAge() And since this is inheritance, your JS example is still vulnerable to the fragile base problem as well as all the other classic inheritance pitfalls.
That's awesome xD I didn't know there was an octal system in JavaScript. I assume it's not useful for anything?
No, these are not Javascript specific. There are base-8 (Octal), base-16 (hexadecimal), base-10 (decimal), base-2 (binary) numeral systems, among many others. This is a programmer humor joke and not just something that exists in javascript.
&gt; The meaning of an object ... it is a bundle of methods and data And that's exactly what you return. Functions that carry data with them. &gt; and the methods use the special word this to access "their" data (and other methods). That is different from the above. That's a very superficial and cherry picked way to say what is or isn't an object. Yes, Java uses `this.data`. But also Python uses `self.data`. Ruby uses `@data`. And C++ just uses `data`. It doesn't matter if you call it "this" or not, it's still the same thing.
That.
It's definitely vulnerable to the fragile base problem but it is composition. That might change if those I composed from had more than one function, essentially turning into a 'class'. A better example would have been a compose function instead of person class but it would essentially be doing the same thing. It would crudely look and work like stampit https://github.com/stampit-org/stampit Edit: I actually think my example was more multiple inheritance than composition on reflection. 
Date object hands down. The most sinister of all. 
Doing dev work on Linux is so much easier than mucking about with cludges like homebrew on macs.
typeof NaN === "number" Spoooky.
The price.
I was being glib. They aren't awful. Yet. I am really worried about the direction of the platform though. The lack of MBP updates for years, dropping the escape key for a flashy gimmick, arbitrarily limiting RAM to 16GB in order to preserve "all day" battery life . . . these are not the decisions of a company that is committed to maintaining a professional development platform. I dabble a bit in filmmaking, and it feels a lot like when Final Cut Pro X was released, and subsequently died. Seems like sometime soon I'm going to I'm going to need to invest some time into learning a new platform. Wondering where everyone else is looking.
I don't think you know what any of these words mean.
Looks like it's not changing.^^^^sorry
It's number system... it's useful when you want to use octal! It's main use in the past was for confusing the fuck out of you when you tried to parse a string as an number with a leading 0: parseInt("010") // 8. Thankfully that behaviour is deprecated now, and also we all learned to use the radix parameter of parseInt! 
Honestly I would be on Linux if didn't dev as many iOS apps as I do. 100% up for someone saying "Ow but little Timmy you just need to install this on Ubuntu and you can develop iOS app like a pro" 
Yes, JavaScript supports octal literals. To see, try entering `010 * 3` into your console (you should get 24 instead of 30). They're deprecated however, so you can't use them in strict mode.
That's unavoidable. I'd be on Mac too if I were doing mobile. Thank god I do JavaScript, so the DX is same everywhere.
Yup. This was a problem before MV* frameworks too. A lot of jQuery developers didn't take the time to read about vanilla JavaScript. For example, I worked on a lot of code that was 90% DOM manipulation and that leaked into the global namespace.
I work with Java and Objective-C, on top of Javascript. I'm pretty much stuck with a Macbook. I honestly don't care about the touchpad thing, my laptop sits on the side as a third screen anyway. All I wanted was more than 16 Go of RAM. That's what I have now, it's comfortable, but it won't be in five years. Really sad about the Air though, it's been the best laptop I've owned.
What sort of projects do you use Angular for, and why not React? *Also another quick question if you don't mind. How much did you know about JS before you started building in React / Angular. Basic, intermediate or advanced?
/r/ProgrammerHumor/
That equation you wrote makes little sense. To go from oct 31 to decimal, multiply the 8s place (normally the tens place) by 8 and add the ones place. So 3*8 + 1 = 25. To go the other way, divide by 8, that's the 8s place. The remainder will be the ones place: 25 / 8 = 3 r 1 =&gt; 31
We won't, it works, but is bad unless you like using your computer as an inefficient heater :-P
&gt; help
Thats why `!function(undefined){ ... }()` is a thing. See: http://stackoverflow.com/questions/9602901/what-is-the-purpose-of-passing-in-undefined
Thanks for the reply, yeah I am working on something like that right now, im able to extract the id's of all the post with var audio = document.getElementsByClassName("post"); var postId = []; for (var i = 0; i &lt; audio.length; ++i){ postId[i] = audio[i].childNodes[1].id; } console.log(postId); doesnt the for loop run all at once? how will it all the different clicks? or is it ran constantly? Thanks again for the reply. 
How convenient that there's no requirement in reddit or this subreddit to explain why anyone posts something. In fact, the very format of posting links does not leave room for an explanation outside of a separately posted comment by OP, which, again, is not required. The fact that there is a separately maintained repository really doesn't matter. That fact and this post are mutually exclusive.
The loop I posted iterates through each play button and attaches the event individually at each iteration. (It assumes your play buttons have the class "playbutton.") It is actually attaching the exact same function to each button, but the "this" variable will reference whichever button was clicked at the time. (It also assumes that each play button has an id set.)
I have to partially disagree, at least for beginners. I think you should learn the basic language but maybe not incredibly in depth. Make your first project pure js, so you can experience first-hand what it takes to do certain things and gain an appreciation for what libraries and frameworks provide.
I think there's a subset of developers that have absolutely zero architectural knowledge, they simply learn how to do things one way and stick to it. It just so happens that these guys and gals happened to learn jQuery first because of how easy it was. The same applies to lots of WebForms developers as well. Bang out 100 lines of code in a click event handler and leave half-open SqlConnections everywhere just because it 'worked on my machine'.
Anyone else in that weird middle-ground situation where you really like the OS but dislike the hardware?
haha.. armature hour over here.. Thanks for pointing that out and helping me solve this. Now i just gotta work on making it so only one can be played at a time and pause all others when a new one is chosen to be played. Thanks again for your help, i really appreciate it!
I respect that you didn't delete this comment. The web is a pretty big deal right now. If you aren't developing in JS, what are you working on?
savage
[A Week of A-Frame 31 + 32](http://aframe.io/blog/awoa-31-32), weekly roundup from the A-Frame WebVR community.
I don't understand why I'm being downvoted. I wasn't being sarcastic or hostile. That's why the library is on Github. Forking the project rather than submitting a PR seems very strange to me.
`Object.is(NaN, NaN)` is true, though.
For a large number of tasks any machine will do fine for development. At home I use a desktop I built 8 years ago running Windows 10. At work I use a MBP. Both are equally capable of handling everything I need. Pick a machine you like.
Anything that gets coerced into a number. It's a float.
You can check out how http://bluebirdjs.com/docs/api/delay.html does it.
Sorry, what announcement?
When did you last use Homebrew? It works quite well as far as I'm concerned.