MSI makes some awesome laptops https://us.msi.com/Laptops/#?tag=GS-Series 
From a glance at the examples, it looks like `setup` and `draw` are expected to be defined in the global namespace, but you're defining them inside the `run` function.
I guess it's an operator, not a type . Never mind
Quick, edit in /s before you get downvoted!
parent.removeChild :O
Write a single paragraph on what you've learnt about JS types and I'll remove the down vote
This is by design, and every language should do that.
I'm curious to know about the logic behind this.
Yeah, well, I feel pretty stupid right now. I actually took 5 minutes to read through the documentation and realized that there are functions built into p5.js for exactly this! 
That hasn't worked since ES3.
Not unless you're still rocking an ES3 interpreter or below.
or `void 0`
It's actually been roughly five weeks, and he's on IRC right now chatting, if you want to ask him yourself. He generally takes PRs in waves about two months apart, if you [take a look at the actual PR logs](https://github.com/facebook/immutable-js/pulls?q=is%3Apr+is%3Aclosed). My opinion is that that's quite good for a side project at a major company. Your mileage may vary. It's worth noting that he's a lot better about PRs than forks.
NaN doesn't represent a numerical value. It represents the *failure* of a numerical computation. By definition it can't numerically compare with any value (including itself) because that would require it to have a numerical value (and then horrible things like `NaN/NaN === 1` would be true). The whole point of NaN is that once you get one in your code, no matter what calculations or computations you do with it it's going to do its absolute damnedest to remain the result of any computation you do with it, in the hope you spot the obvious error and don't fall prey to subtler, less obvious bugs caused by things like `NaN/NaN === 1`. Lots more interesting info [here](https://www.google.co.uk/search?sourceid=chrome-psyapi2&amp;rlz=1C1MSNA_enGB674GB674&amp;ion=1&amp;espv=2&amp;ie=UTF-8&amp;q=why%20doesn%27t%20NaN%20equal%20itself&amp;oq=why%20doesn%27t%20NaN%20equal%20itself&amp;aqs=chrome..69i57.5215j0j7).
New Macbook Pros. TL;DR: - Top row (ESC, Fn keys, and Power) have been replaced with a "touch bar" multi-touch display - Four USB-C/Thunderbolt/Power/Display/Everything ports and one headphone jack (no mag-safe or SD or anything else) - Maxes out at 16GB RAM - New chips - 14% thinner! Some are understandably upset about the limited RAM and lack of a physical ESC button. The USB-C only design also upsets some people, but they're wrong.
Jumping off of /u/Shaper_pmp, consider the following: function example(val1, val2) { var x = Math.sqrt(val1); var y = Math.sqrt(val2); return x === y; } You wouldn't want it to return true when running `example("test", "another_test")` even though both x and y are `NaN`. There are SO many ways to get NaN, it's safer for it to never equal itself to avoid these problems. 
eww... that return statement. return x === y; FTFY.
[Hey there, just so you know, there is an edit button right under your comment.](http://i.imgur.com/0weOdCI.png)
Ah yeah. I was planning on going a different route to be deliberately verbose and then ended up doing bool return halfway through. Guess that's why you shouldn't drink, pass out candy, and reddit ¯\\\_(ツ)\_/¯
Yeah but I get more comment karma this way
Hey guys, I submitted this about a month ago. Sorry to spam. I want to know if there is interest in doing a second one with Angular 2 and Typescript. Let me know. Cheers!
It was more of a joke than anything I know Javascript has types jut not declared. I also use typescript. Fantastic way to get rid of stupid bugs preemptively. I don't blame anyone for downvoting it was in poor taste. 
I usually celebrate both on Hexember 19; saves time.
But most modern frameworks don't have digest loops or scope issues, that's an Angular thing. 
Why not a desktop computer? Desktops are better than laptops in so many ways: cheaper, more customizable, better for your backs and eyes.
The [performance numbers](https://github.com/sass/dart-sass/blob/master/perf.md) are interesting. Really excited to see where this goes!
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;MIS3690 Survey&lt;/title&gt; &lt;meta http-equiv="content-type" content="text/html; charset=utf-8" /&gt; &lt;style type="text/css"&gt; p, select, input, button {font-size:16pt} h1 {text-align:center} body {width:900px;} &lt;/style&gt; &lt;script type="text/javascript"&gt; /* Your JavaScript goes here */ function bckgrds() { document.getElementById("bckgrd").style.backgroundColor="cornsilk"; } function doubleclick() { document.getElementById("doubleclicks").style.backgroundColor="cyan"; document.getElementById("whites").style.color="white"; document.getElementById("fontty").style.font="30pt'"; } function changetexts() { var words1 = new Array("Lists","Multimedia","JavaScript","Forms") document.getElementById("hello").innerHTML=words1[Math.floor(Math.random()*4)] } function frowns() { if (document.getElementById("difficults").checked) document.getElementById("mood").src="frown.jpg"; document.getElementById("changing").innerHTML="Which topics did you find to be difficult?"; } function smiles() { if (document.getElementById("funs").checked) document.getElementById("mood").src="smile.jpg"; document.getElementById("changing").innerHTML="Which topics did you find to be fun?"; } &lt;/script&gt; &lt;/head&gt; &lt;body id="bckgrd" onload="changetexts()"&gt; &lt;h1&gt; &lt;span ondblclick="doubleclick()"&gt; MIS3690 &lt;/span&gt; &lt;span onmouseover="bckgrds()"&gt;Student &lt;/span&gt;Survey&lt;/h1&gt; &lt;p&gt; &lt;span id="fontty"&gt; Please &lt;/span&gt; complete the following survey. When you are finished, click the Submit button. &lt;/p&gt; &lt;form method="post" action="mailer.php" id="doubleclicks" name="doubleclicks" enctype="text/plain"&gt; &lt;p&gt;What do you want the next &lt;span id="whites"&gt;question &lt;/span&gt; to be about? &amp;nbsp;&amp;nbsp;&amp;nbsp;Fun &lt;input type="radio" name="q" value="funs" id="funs" onclick="smiles()" /&gt; &amp;nbsp;&amp;nbsp;Difficulty &lt;input type="radio" name="q" value="difficults" id="difficults" onclick="frowns()" /&gt; &lt;img src="smile.jpg" id="mood" alt="mood" style="width:30px; margin-left:40px" /&gt; &lt;/p&gt; &lt;p id="changing"&gt; Which topics did you find to be fun?&amp;nbsp;&amp;nbsp;&amp;nbsp; Images &lt;input type="checkbox" name="fun1" value="i" /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; CSS &lt;input type="checkbox" name="fun2" value="c" /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; Tables &lt;input type="checkbox" name="fun3" value="t" /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;span id="hello" &gt; Forms &lt;/span&gt; &lt;input type="checkbox" name="fun4" value="fo" /&gt; &lt;/p&gt; &lt;p&gt;What grade do you expect to receive? &lt;select name="grade" id="selectgrades" name="selectgrades"&gt; &lt;option value="x"&gt;Selectgrades&lt;/option&gt; &lt;option value="A"&gt;A&lt;/option&gt; &lt;option value="B"&gt;B&lt;/option&gt; &lt;option value="C"&gt;C&lt;/option&gt; &lt;option value="D"&gt;D&lt;/option&gt; &lt;option value="F"&gt;F&lt;/option&gt; &lt;/select&gt; &lt;/p&gt; &lt;p&gt;Enter your GPA: &lt;input type="text" name="gpa" size="4" /&gt;&lt;/p&gt; &lt;p style="margin-left:300px"&gt; &lt;button type="button" onClick=myFucntion()”&gt;Submit&lt;/button&gt; &amp;nbsp;&amp;nbsp; &lt;script&gt; function myFunction() { alert(“Select a grade”);} I &lt;/script&gt; &lt;input type="reset" name="reset" value="Reset" /&gt; &lt;/p&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 
The type you meet at a party. You know, he's got no social skills... once he discovers you're a developer you're fucking stuck with him all night... and even then he disagrees with every single thing you say, has to name a better library than every thing you mention you use, laughs if you aren't using the the latest version of absolutely every dumb library in existence. And eventually toward the end of the night when he's drunk you finally realise he's never worked on a production project. That's the javascript type I find scary.
I use my desktop at home but I like to code on the go. I know it might not be that common but I've seen others coding at the bar in the evening and on the weekend. 
Not deprecated anymore. With ES2015 you can use octal literals again by prefixing them with 0o. 
Add that to the Most Wanted playing cards featuring regular expressions.
&gt; bar i do this truly all the time. i'm with you here. 
Symbols are scary, because type-conversions can actually throw errors: var sym = Symbol('boo'); try {''+sym;} catch (e) {console.log(e.message);} //=&gt; Cannot convert a Symbol value to a string console.log(String(sym)); //=&gt; Symbol(boo) try {0+sym;} catch (e) {console.log(e.message);} //=&gt; Cannot convert a Symbol value to a number try {Number(sym);} catch (e) {console.log(e.message);} //=&gt; Cannot convert a Symbol value to a number Also, trying to make wrapper objects, as ill-advised as that is for primitives, is frightening: var sym; try {sym = new Symbol('boo');} catch(e) {console.log(e.message);} //=&gt; Symbol is not a constructor sym = Object(Symbol('boo')); console.log(typeof sym); //=&gt; object console.log(sym); //=&gt; Symbol wrapper object with [[PrimitiveValue]] Symbol(boo) console.log(Object.prototype.toString.call(sym)); //=&gt; [object Symbol]
I think you have to look at what macbooks will likely still have over their competition in battery life, screen quality, build quality, and reliability. Sure the announcements are not popular (as usual) but I think everyone else has a long ways to go in building machines that rival macbooks. A few peripheral changes and (relatively minor) hardware limitations are not going matter much. 
Are you working with Node? If you're not, no, not really. If you're working with node you can just set the answers array to a JSON file and require it. const answers = require('./answers.json'); Otherwise you could use a build task to give you require functionality in your frontend code.
[r/nottheonion](https://www.reddit.com/r/nottheonion/)
Things like the issue with os.networkInferfaces not working with bash on windows because of missing functionality is a dealbreaker. There are several other major bugs with the Bash on Windows implementation. It just makes more sense to actually use Ubuntu at the moment then to hack Windows into something palatable. As for why people would choose mac, Prior to the xps 13 it was hard to find a laptop that I actually liked spending 10-14 hours a day using like the solid piece of equipment that Apple computers are. Furthermore as much as I love Ubuntu, using OSX had always been a more favorable experience in my opinion. 
I tried it in chrome. It works but I am very upset by the performances: it takes around 500 msec for 100 iterations! n= 100; start = new Date(); co(function * () { for(i=0; i&lt; n; i++) { yield sleep(0); } console.log("done: " + i + " iterations; elapsed: " + (new Date() - start) + " msec"); }) // done: 100 iterations; elapsed: 472 msec 
My personal MacBook is 2014, my work MacBook 2016. By the time I get a new one USB C is everywhere and all the ports will be max. speed. Still not sure about the lack of an escape key though, but I'm quite keen the macOS workflow overall (terminal+apps and a quite all right ‘user experience’. 
The type behind the window is quite scary.
Article nicely written, but saying You should jump into react first instead going bit in-depth of JS? I like the analogy of swimming pool, but with this approach, many people will possible drown (not literally, but You know what I mean).
Lol extjs is shit.
I sold my 2015 MBP and got a [2016 Razer Blade](http://www.razerzone.com/gaming-systems/razer-blade). The case design is almost identical to that of a MBP apart from it being slightly larger and black. It's an awesome machine, the trackpad can't compete with the Force Touch trackpad, but's it's pretty reasonable. I missed OS X for a while, but Windows 10 is alright and has some decent shells available.
I always used `void 0` because it made more sense than `undefined`.. just now I realized it saves space too...
The ESC will still be present there, it won't be a physical button but included via the touch bar.
I'm asking that over at threeJS right now - the HUGE issue is WebGL only supports a few lights, and my particles are ALL lights that can potentially illuminate my smoke volumes. So I'd need to implement differed lighting, doing particles in batches for just around 6! There could be thousands. =/
I've been running Arch Linux on a Dell XPS15, works a charm, setup exactly how I like it.
Yes we have code review for every PR :D
Not sure if you are the author but one thing that should be clarified is the binding of events. &lt;button @click='toggle()'&gt;Open/Close&lt;/button&gt; is not the same as &lt;button @click='toggle'&gt;Open/Close&lt;/button&gt; and that isn't the same as &lt;button @click='toggle(data, $event)'&gt;Open/Close&lt;/button&gt; In the first you are inline binding empty data so the event doesn't get passed through. In the second you use the event handler like a callback. In the third you use the inline binding but you also use the variable to pass in the $event data. If you use this for something else and bind the event incorrectly you may get frustrated trying to get access to the event object.
For the same reason that &amp;infin; does not equal &amp;infin; in mathematics
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/vuejs] [Onsen UI with Vue 2 will soon be possible!](https://np.reddit.com/r/vuejs/comments/5aip17/onsen_ui_with_vue_2_will_soon_be_possible/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
the biggest problem is that windows sucks lots for "power" users so it's not an option for most developers (aside c sharp or game devs) the thing is there's no one giving you a superfast ssd + 8/10 hours of battery usage + backlight + sturdy design for transport and a unix based OS that handles all this out of the box
this is the only right response (I've used windows a couple of years, 4 years of linux and 3+ of osx all working full time as dev) sad but true!
programming on windows? ugh... just no (even if I wanted lots of libs are not usable - E.g. the ones you have to compile on your machine) It's pretty much a "brake" (obviously I can list loads of other reasons) - I can see you never worked on a Mac anyway, there's no other viable solution (sadly)
Too real.
Hi /u/otabekrt, please don't post links as self-posts. Please resubmit as a link post, thanks!
Thanks for your sage words. 
This is fantastic. The users of the library can choose between "fast" and "easy to install" based on what they need (by either going with the native DartVM version, or just using the NPM version), and the developers of the code don't need to worry about handling 2 codebases. 
The other explanation is terrible. 31 in base 8 (octal or "Oct") is the same as 25 in a base 10 (decimal or "Dec") number system. It's both a play on words and a play on numbers. Never convert from octal to decimal the way that OP suggested. In this case you multiple the first digit (3) by 8 and then add the last digit, 1. 24+1 = 25. To go the other way, divide 25 by 8. Which gives you 3, remainder 1. Append the 1 to the 3, and you get 31. To explain further would require a whole post on number systems, but you can learn that online easily.
true
Good question - I can't think of any good reason, so I suspect it's a cock-up.
Usually there is an ESC key displayed on the touch bar, and yes software that depends on it, like Vim, is already mapping alternatives. My point isn't that it's the end of the world, my point is that they prioritized a gimmick over the needs of professionals. On their line of "Pro" computers. That does not give me faith about where the platform is going. 
This isn't a "performance" problem, it's just how event-loops work. You might want to read up a bit on the event-loop in JS. Timers like your sleep function or a setTimeout aren't exact. In fact they have a lower-bound of like 15-50ms or so (depending on the browser, device, and even things like if it's charging or on battery). not only that but only one thing can be running on the event-loop at a time. So if your timer ends, and some other function is still running, you won't be able to run what comes after your timer until whatever is running is done.
Nice read! 
Hi /u/gudangw, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `Azzam Vid - YouTube`. Also, please do not use all-caps for your titles; there is no reason to scream. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [youtube.com](/search?q=%28and+site%3A%27youtube.com%27+author%3A%27gudangw%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|53|98%
isNaN(null) === false null is number!!
TL;DR maintainer of open source project emailed me personally and made me feel good about myself.
&lt;3 SP4
@ me next time
My question was narrowly targeted towards my own future needs as a software developer. That is why it was posted in a development subreddit. Any broader supposition about Apple's strategy I made was incidental. That said, I'm not sure what use case there is in *any* industry for that touch bar. Literally the only thing they demoed that seemed even marginally useful was as a slider for brush size in Photoshop. But even there, professionals are already using hotkeys for that, and the hotkeys work pretty well. It is a gimmick targeted at customers who prefer something flashy to material improvements: i.e. consumers. More importantly, the new MacBook Pros are arbitrarily limited to 16GB of RAM. Media professionals are going to be even less happy with that than I am. That stated reason is to preserve "all day" battery life. That is a consumer priority, not a professional one. So while the new MBPs are not unusable (far from it), and may even still be the best option on the market (for now), I maintain that Apple is no longer building computers targeted at professionals, and it is probably a good idea to start looking into alternatives.
Side note: don't be afraid of expectations of "EXTENSIVE experience". Sometimes they mean it, sometimes they don't. I'm not saying you shouldn't try to learn new things, but don't see a posting somewhere and think, "they're looking for someone better than me". You won't know until you try. And the more you don't match what people are looking for, the more you'll see what people are looking for and what you might need to learn for yourself. I had a manager that used to encourage all of his reports to pursue interviews for new jobs - not necessarily to get a new job, but just to see what people out there are looking for, what current trends are, and to be on top of your interviewing skills should you actually feel you needed to move on to something else.
Follow this subreddit, follow blogs, take on personal projects. Learn how to bullshit. If you read everything you find and know how to bullshit then you should be able to form an answer that sounds like you know what you are talking about for pretty much anything.
NaN is a number.
2nd play button can't be stopped :/
 var javascriptVariable = " &lt;?php echo $phpVariable ?&gt; Basically, just make sure whenever you want to do something PHP-y in JS, you wrap it with &lt;?php ?&gt; tags. You can put that JS inline in your PHP document to get the variable (like an index.php with a &lt;script&gt;Here's My Js, blah blah&lt;/script&gt;), or include the JS file in the PHP file in a script tag (like an index.php with a &lt;script src="myjs.js"/&gt;). In your case: var eventos = &lt;?php echo $array ?&gt;
No idea what you mean.
I don't know anything about sound or music or production or types of waves, but this was really neat!
It's really short for "Not (even Not) a Number"
You should always escape variables, which can be done by json encoding your stuff: var jsVariable = &lt;?php echo json_encode($phpVariable) ?&gt;;
Try to work on personal projects that broaden your experience with new technologies you know little to nothing about. If your experience has mostly been building CRUD apps with Angular, trying building a data viz app with React and D3, a command line tool with Node, etc. Another thing I've noticed as a hobbyist turned professional developer is that there is a big experience gap for someone who has only built sample/hobby apps and someone who has experience building an app that has gone to production. For your "shitty little web app" that you built to learn Angular, you probably didn't care to tune for performance by looking into things like web workers, caching, etc. So you'll need to connect the dots between what you know from your current experience and what you would need to know if you were to be maintaining an app that needs to scale to a large number of users.
Sorry if it was unclear, but yeah the stop button is a bit later on... I figured it'd be easier to understand if I separated the two pieces of code, but maybe I was wrong :)
I didn't know much myself before starting working on it!
It does. I could be wrong, but I would assume that when performing free work--which is what open source is--a big question in your mind would be, "but who will pay the bills?" You're right, there are a lot of reasons to open source and I'm only touching on one of them here. I may have made too big of an assumption thinking that money would be the barrier to entry.
&gt;If I understand the problem correctly the issue is mainly that when &gt;the second POST is handled the "DataBaseResult" should ideally &gt;return true? Yes you are rigth &gt;If so, this would be solved using a database that support transactions (MySQL, Postgresql, etc...). In this &gt;case the database would handle the issue of the race conditions with a proper implementation using &gt;transactions. As far as I can see this would be considerably easier than the alternatives you are proposing. &gt;I've run into this exact problem and ended up switching database. If you don't like SQL consider using an &gt;ORM like Bookshelf.js which is pretty close to Mongoose. The problem is that at this point of development we are very close to the launch, and it would be very expensive in resources and time to rewrite the backend in order to migrate to something SQL, but maybe that´s the simplest solution. We didn´t have this problem before because I didn't have the experience a year ago about concurrency, and parallel async operations, so the importers were writen to process the items in sequence. In order to connect the importers to the brand new backend, this bulk importers needed some refactor, well they needed almost be rewriten from scratch, and now I've done it a little bit better, now all the job that is candidate to be processed in parallel is processed in parallel, and that's why this problem has been detected rigth now. &gt;If you don't want to switch to a RDBMS I would consider going for option #2. I don't think doing one big &gt;request to the endpoint using HTTP/1.1 instead of several concurrent connections using http2 will impact &gt;the performance in any major way. Also, as you point out people could still abuse the api endpoint for &gt;"single" posts, so you might want to add some sort of rate limiting/queue to that route. The only problem I still see, is that the problem is not resolved, I mean, I will provide a batch process solution with the new batch endpoint, but, as the other way is working as well, other application may find the same problem, but perhaps that is not my problem. 
/r/LearnJavascript
If your JS is in a separate file and you don't want to start creating global variables you could create a hidden element on the page that has a special data attribute e.g. &lt;div id="uniqueIdentifier" style="display: none" data-events="&lt;?= json_encode(phpEvents)?&gt;"&gt;&lt;/div&gt; Pick this element up in the JS and grab the data-events attribute off of it. As /u/name_was_taken has said if you want real time responses to user actions without page refresh, look into AJAX and XHR requests.
https://gist.github.com/sokra/27b24881210b56bbaff7 For the actual changes in webpack 2; tldr; its mostly es6 support.
Everything jQuery does already exists in the native DOM api, you just have to write more.
yeah, relying on three frameworks to remain popular in JavaScript is absurd. (es6, webpack, yarn)
Sorry to hijack the thread, but could anyone please link me some good libraries for AJAX that are compatible with ES6 promises? I tried searching for `ajax` in libraries.io and NPM but I just get a ton of weird poorly-documented libs.
ES is a language specification of which ES6 is the latest publicised version. webpack is incredibly powerful though, and uses a completely different methodology for building web apps than traditional methods. But yarn and longevity used in the same sentence is a bit ridiculous.
a specification the requires a framework to implement.
By framework you mean an engine such as V8 or Chakra?
I don't have any strong opinions on the library, but props for such a robust readme.md!
Sure, sent an invite. From Holyniwa. 
Let's just gloss over treeshaking like it's not one of the main selling points of Webpack 2. : p
You just put something in the php file and then get it from the javascript file later. You could use a script tag to declare a global variable or use a html hidden input, anything would work... I've also seen projects that compile all JS files as php (it adds a &lt;script&gt; tag in the beggining/end), and instead of linking your files with a &lt;script src=''&gt; tag, you would use a php function to include it. It works but please stay away from that. The best/right way though, is to make a request to your webserver and send the data as a JSON response. This will be great for you/anyone that is working on the project in the future.
I do know Angular, and I used it for a year before switching. I personally do not encounter scope issues and understand the $digest because I do my research. But! Other frameworks do not have these types of quirks and don't suffer from major design flaws since they have the benefit of learning from the mistakes of earlier Frameworks. I mean there is a reason why NG-2 was a complete rewrite. the problems of NG-1 can be mitigated if you ration your watchers and consciously manage state. . . . . but having to do that is limiting and complicates app development. 
Hi - thanks for the comment (I'm the author) Good points, perhaps for a follow up post. I think that's a little higher level than the rest of this particular tut
Pretty cool. An option to start the high-res download on hover would be cool (so the high-res is more instant).
Is your site a SPA already? That would have a big impact on how you go about it. Basically something like: - fetch data for new page - push new url to history - render new page - add rendered page to dom - animate new page in, old page out - delete old page node
There are lots of ways to approach this. A simple way would be to utilize CSS animations and transitions to do what you want. You can create CSS classes that defines what happens when a page is visible, and when a page is invisible: /* hidden by default */ .content { transition: 0.2s; opacity: 0; transform: translateY(-10em); } /* class for showing the content */ .content-visible { transition: 0.2s; opacity: 1; transform: translateY(0); } Add the `content` class to all of your content divs. Then, add the visible class for the one you want to show. So it'd be something like this in JS: // it'd be fine to use jQuery here as well, for less verbosity function showContent (content) { document.querySelector('.content-visible').classList.remove('content-visible') content.classList.add('content-visible') } // react when a nav is clicked or something someButton.addEventListener('click', event =&gt; showContent(event.target)) Then, you'd probably wanna make sure all of the content divs are styled so they all appear in the same place, but other than that, you'd be set I think.
Work on your own challenging projects from scratch. I've been doing this over ten years and still brush up on interview tech questions for any tech in the position. 
If your webpages currently load via the normal way, 'page reload'. You should look into pjax. It loads html via ajax and injects into the document. Here is a lib which also helps with transitions in pjax: https://github.com/luruke/barba.js
&gt; But! Other frameworks do not have these types of quirks No, they don't - **they have other quirks** *that Angular 1.x doesn't have*. I'm not sure you're getting this simple idea. Yes, Angular 1.x has a digest loop and scope. No it does not have the same quirks as React (html in javascript, making transpiling necessary, mangling 'separation of concerns', as well as other quirks), Backbone has difficulty with nested models, etc, etc.. It certainly is not difficult to come up with a quirk for any framework you care to mention. You seem to be saying Angular 1.x is flawed so using it is bad while other frameworks are also flawed. If you can't use a framework because of some implementation quirk then you wouldn't be able to use any framework *because they all have different implementation quirks*. 
Sweet, thank you!! I used the Json method and I got it working now!! Thanks!
I've used DataTables with Meteor. I'm far from an expert, but if I know anything I'll weigh in.
I'm not convinced Angular2 is the way to go yet, but it is sorta nice to start with a build system which includes launching points for both e2e tests and unit tests (we are considering https://github.com/mgechev/angular-seed). We've got an Asp.Net Web Forms application (CMS based on an ancient fork of DNN) and are evaluating options for replacing it with something much more modern and the idea that we can bake in tests at every level is very appealing (we currently rely on a massive library of tests in a UI tool, Telerik Test Studio, which take a very long time to run and are quite brittle). The benefits as I see them for Angular2 are: * appears designed to make it easy to write testable code * permits me to depend on type safety enforced by a language where stuff is tightly coupled, allowing me to avoid either excessive defensive coding and tests or the seemingly inevitable `foo() is not a function` bugs that future me eventually will attempt adding * appears to offer a well considered DI platform to make it easier to remain loosely coupled to the implementations of things * After AOT, the resulting application (a very basic prototype of something we expect will be actively developed for the next 7+ years, similar to the platform it is replacing over the next 5) seems quite small compared to the non-AOT and to a roughly comparable react version. On top of that it manages to hit the perf benchmarks we are looking for. Admittedly none of those are likely to appeal to someone who wants to get up and run on project after project of largely one-and-done deals with little shared reuse between them. It is certainly not the drop in project that angular.js is, almost to the point that one would consider them totally different projects instead of a major release. 
Webpack 2, the future.
That... that doesn't make sense. 
So one thing I want to say is that Incremental rendering could wind up being a lot of hoopla for minimal gain, https://localvoid.github.io/kivi/experimental/01_incremental_rendering.html 
If you're focused on tree shaking, you've already switched to Rollup.
Interviews suck. You get good at them by doing more interviews. If you are using Angular right now I definitely recommend digging into caching and http.
I'm tracking with you. But if that was the case, the only people building libraries would be people who need "learning experiences." Or, we might expect to see a shortage of highly experienced maintainers. Yet one of the best learning experiences I've had is being a contributor on a project that has a very experienced maintainer. This begged the question to me, how to you justify doing free work when you could be making bank.
If you hit play more than once, you have to reload.
Maybe it will be implemented in a way that completely blocks all "non-interactive" components from updates when user clicks/drags/etc, so when there is some interaction it will just update high-priority components. Incremental scheduler in kivi worked in a way that it always updated interactive high-priority components on each frame and then tried to update low-priority components until it used all dynamic time frame budget. I didn't implemented full lock on "low-priority" updates, because in some use cases it will create a terrible user experience when nothing is updated when user starts some form of interaction with an application.
Arrow functions are sweet. I had no idea these were available in normal javascript but I love using them when using Coffeescript. 
canvas
Could you elaborate a little bit on how this would be accomplished? There is a timestamp on the record that gets passed down to the client and when the client saves, the timestamp is sent back to the server. The server compares the timestamp to the one currently in the database and if it matches then it goes ahead and updates the record. The part I got stuck on is what to do if the timestamp doesn't match. 
Input, output, stateless, recursion, no side effects... it's about taking everyday, imperative code and refactoring it until it's more inline with functional programming. I'm doing so in a 4 step, illustrative and iterative approach.
Not sure if this is the problem you're trying to solve, but if you just want your browser to do this you could use an [extension like this one.](https://chrome.google.com/webstore/detail/autoscroll/kgkaecolmndcecnchojbndeanmiokofl/related) Found that [here](https://www.quora.com/Is-there-a-way-to-automatically-load-a-page-with-infinite-scroll-until-it-gets-to-the-bottom-of-the-feed-Is-there-a-software-or-a-setting-that-helps-to-do-this), where there's a method if you wanted to design something that does this programmatically. In the future, you might get better, faster answers if you ask a question like this in /r/techsupport , /r/learnprogramming or /r/learnjavascript depending on what you wanted to do.
&gt; The six ES6 features literally everyone knows about already (you won't believe how little content is in this article!) Fixed the title for you. 
It didn't stop for me though.
See https://www.reddit.com/r/javascript/comments/5aicnb/getting_started_with_webpack_2/
Another difference is the 'patent rider'—React is BSD-licensed, but the thing with the patent rider is, as was well-summarized in this HN comment: https://news.ycombinator.com/item?id=11270213 Which says: &gt; The problem with React is its patent rider. React.js comes with a BSD license, but has a patent rider that gives you a license to React's patents. This sounds like a good thing, right? But this rider has a "strong retaliation clause" which says that if you make any sort of patent claim against Facebook this patent license automatically terminates. Which means Facebook can now sue you for patent infringement for using React. You may think this is no worse than not having a patent rider at all. But that's not the case. If there is no patent rider then there is an implicit grant which cannot be revoked. If you work for a software company and your company has patents then keep in mind that by using React you are giving Facebook a free license to your entire patent portfolio. More info on weak vs strong retaliation clauses: http://www.rosenlaw.com/lj9.htm Inferno is MIT-licensed and doesn't have a 'patent rider'. If React and Inferno were completely equal, and depending on what the endgame strategy is for your project (i.e. will you be competing with Facebook in any way, or is there a chance you'll sell to someone who is), this could be the dealbreaker for React
Thanks for all the help guys. Would making the site a SPA make this easier and more performant? Instead of extracting content from different html files and swapping them in and out?
Its really just a proof of concept. Maybe its a really bad idea, but I wanted to find out if I can work out a practical solution. What do you think about it? What are the cons? I couldn't find the exact term for multible signatures in functional programming, do you know it? Do you know other libs implementing similar features on a small footprint?
I'm amazed at how the WebAudioAPI can be used to make a realtime player of MOD format songs - http://mod.haxor.fi/Jugi/gates_of_ixtlan.xm
It would be hard to do it in a general way. This "load more on scroll" feature is done with JavaScript, so the page could keep adding more content *forever* if it wanted to (like adding more digits of the number π, or random cat pictures from the internet). You might be able to write some code that scrolls to the bottom, waits, and scrolls to the bottom again when the page gets longer, or stops if it doesn't get longer after a few seconds. You could also write specific code for a website like Facebook, but you would have to figure out how the page, like the friend list, works. That could be harder, and Facebook might change it at any time.
On the flip side, [another legal analysis](http://lu.is/blog/2016/10/31/reacts-license-necessary-and-open/) says it's mostly a good thing: &gt; tl;dr: React’s patent license (1) isn’t a bad idea, because the BSD license is not explicit about granting patent rights; and (2) probably meets the requirements of the Open Source Definition. &gt; Is the React license elegant? No. Should you be worried about using it? Probably not. If anything, Facebook’s attempt to give users an explicit patent license should probably be seen as a good faith gesture that builds some confidence in their ecosystem. &gt; But yeah, don’t use it if your company intends to invest heavily in React and also sue Facebook over unrelated patents. That… would be dumb. :)
https://code.facebook.com/pages/850928938376556
I just copied that SVG code into the page here with Chrome's devtools, then used jQuery to find the #Add element and it all worked fine. Without seeing your *code*, there probably isn't much people here can tell you. Make a CodePen of it or something so people can play with it.
It's not the same, but allowing 1 param as an object and using destructuring sorta gets you there: function bar ({ foo, baz }) {}
I actually ended up figuring it out (funny, it took me about five hours over two days to figure it out) I was using the wrong property int his case... background color when I should have been using fill.... The learning continues xD
Could you write some usage examples so that I can test this code out in a repl?
I prefer (typeof(obj)==='object'?obj.constructor.name + ' - ':'') + typeof(obj)
You can have named optional parameters via destructuring. The syntax is hideous, but it does work fine: function foo({a = 1, b = 2} = {}) { console.log(a, b); } foo(); // 1 2 foo({a: 11}); // 11 2 If they hadn't recycled destructuring for this, it could look as nice as it does in Dart: foo({a: 1, b: 2}) { print('$a $b'); } foo(); foo(a: 11); // no {} here
Basic definition of the function starts at line 15. Examples start at line 89 :)
What would that look like? HTML is a way of marking up the parts of the document - it isn't a programming language and has none of the features of a programming language. You'd need to add variables, functions, etc. You'd need a way to specify which part of the document is to be interpreted as the executable language and not the markup language. You might end up with something like the original form of PHP. You might end up with something like one of the XML applications that can describe algorithms. However, as time has gone on both of these have fallen out of use in preference for the separation of concerns that having a dedicated markup language and having a dedicated programming language being.
I find it amusing that the opposite would have been asked a few years ago.
As a sidenote :) for a cutting edge, production-ready library and not a small prototype on codepen I would use lodash or something else to test the typings, and definitly not just a fast, efficient, but probably not stable regex solution from a blog xD
what do you mean by "morally dubious task" ? there no need for you to broadcast such aggressive words. im just learning the process and im not expecting an answer. it just some advised.
For what it's worth, Dan made this comment yesterday (https://twitter.com/dan_abramov/status/793606878668451841 ): &gt; There should be no visual bugs, only computation is chunked. The DOM updates are all flushed together at the root when whole tree is ready. One way or another, it'll be interesting to see how it pans out.
Some honest questions: This essentially reimplements [IP broadcasting](https://en.wikipedia.org/wiki/Broadcast_address) or multi-casting, depending on how you look at it. If JavaScript lacks the ability, given that you have C, C++, etc source in your project, why not write the [broadcast code](http://cs.baylor.edu/~donahoo/practical/CSockets/code/BroadcastSender.c) in one of those languages and avoid the reimplementation entirely (thus utilizing what's already built into networking hardware firmware)? Are you planning to use this outside of extranets, i.e., across the Internet? I scanned through the code, and discovered that you connect to each peer individually to send datagrams, correct? Short of utilizing threads for each socket handler, how do you plan to scale this for, say, thousands of peers? Is that even a concern? Given that this is labeled P2P, what exactly is the use case? This seems more like an experiment than a practical project; I don't see any new research into P2P networking here, so I don't understand why we would choose this project over something like [webtorrent](https://github.com/feross/webtorrent) for JavaScript, and BitTorrent in general (or some other existing and mature P2P protocol). Given that you mentioned queues, if the goal of a project is to grab a message and operate on it, why would that project utilize this over a network message queue service like MSMQ or RabbitMQ?
you just do this [ "you will have poor fortune", "you will have okay fortune", "you will have great fortune" ] You can also store json into an array itself (if for whatever reason you need to) using `JSON.stringify({ some: "object" });` 
You mean by adding a separate programming language that can interact with HTML. Just like say... JavaScript?
&gt; This essentially reimplements IP broadcasting or multi-casting, depending on how you look at it. If JavaScript lacks the ability, given that you have C, C++, etc source in your project, why not write the broadcast code in one of those languages and avoid the reimplementation entirely (thus utilizing what's already built into networking hardware firmware)? Two reasons, actually. First, because I haven't implemented any of the networking in C/C++ yet. Once I have that there, I'm going to provide hooks for the various other runtimes. Even when that happens, though, I still want to have it in as many languages as possible. I can't speak as confidently for the Javascript world, but in Pythonland, having C hooks means you can run in 40-50% of possible implementations. Sure, that covers &gt;90% of actual installations, but you'd like to to work in *every* runtime you can. &gt; Are you planning to use this outside of extranets, i.e., across the Internet? Eventually, yes. At the moment NAT-busting and the like isn't in my scope. I'm trying to make sure the networking components themselves work before I worry about that. &gt; I scanned through the code, and discovered that you connect to each peer individually to send datagrams, correct? Short of utilizing threads for each socket handler, how do you plan to scale this for, say, thousands of peers? Is that even a concern? It's (mostly) not a concern for two reasons. First, this doesn't do much threading. In Pythonland there is a single daemon thread which checks these. And that's okay, because it's not *really* concurrent anyways. In Javascript world, it's done using event emitters, so I don't need to manage that myself. In addition, there's a limit to the number of connections each node will automatically initiate. You can *force* it to go above this limit, but it won't do so on its own. The only place this might be a concern is if thousands of peers all tried to connect to the *same node*. That one I haven't quite covered yet. But I don't expect that to be happening anytime soon. &gt; Given that this is labeled P2P, what exactly is the use case? This seems more like an experiment than a practical project; I don't see any new research into P2P networking here, so I don't understand why we would choose this project over something like webtorrent for JavaScript, and BitTorrent in general (or some other existing and mature P2P protocol). The use case is communication between languages. I was looking for such a library, and the only ones that I found were either abandoned, or far too specific. The use case I'm going for is "I have Python and Javascript and Smalltalk and ..., and I need them to talk to share X data". I would like to provide a bunch of abstract network architectures, so that people can implement them simply by instantiating an object. &gt; Given that you mentioned queues, if the goal of a project is to grab a message and operate on it, why would that project utilize this over a network message queue service like MSMQ or RabbitMQ? You might. It could be that this works for your needs. But I doubt there's a single messaging protocol which works between every language, and that's the end goal here. I want to take every useful network scheme I know of, and set it up in such a way that it works no matter what runtime you like the most. Most of this is "just for fun", rather than a serious project. But I do hope that people find a use for it, and I've had times in the past where I would have wanted a similar library.
no, fusing them into one
Thanks for the response. Some further observations: &gt; you'd like to to work in every runtime you can. Excluding environments we typically don't have control over (browsers) this can generally be resolved by writing a module for your runtime of choice. Almost everything is possible once you write for the runtime or compiler, rather than the "user-land" code, e.g. C# vs .net runtime. &gt; First, this doesn't do much threading. In Pythonland there is a single daemon thread which checks these. And that's okay, because it's not really concurrent anyways. In Javascript world, it's done using event emitters, so I don't need to manage that myself. I spaced on this, but this can be extended even further. There are mechanisms like IOCP that will allow you to avoid threading or multi-process architectures entirely. &gt; The only place this might be a concern is if thousands of peers all tried to connect to the same node. In addition to my above comment, at this point your limitation is a hardware and OS one (what the OS allows, and what the hardware is capable of). &gt; The use case is communication between languages. I was looking for such a library, and the only ones that I found were either abandoned, or far too specific. The use case I'm going for is "I have Python and Javascript and Smalltalk and ..., and I need them to talk to share X data". &gt; I would like to provide a bunch of abstract network architectures, so that people can implement them simply by instantiating an object. I understand this, but there are many such protocols that are cross-language, cross-client, cross-OS, etc. HTTP is one of them, for example; BitTorrent is another. While the protocol language implementations might not be written by the same person, there are a huge number of language implementations for both. &gt; But I doubt there's a single messaging protocol which works between every language RabbitMQ, for example, supports a [huge number of languages and runtimes](https://www.rabbitmq.com/devtools.html).
i didn't know #1 ^^and ^^i'm ^^a ^^senior ^^engineer.....
Like angular or VueJS?
yes, I guess thats pretty much what I was thinking they may have had that vision back in the past but it didnt get adopted
Write applications. Fumble through the code. Refactor. Enhance the original application with additional requirements and repeat the process.
i wonder what walmart is hoping to gain by this?
I would suggest to search such basic answers on stackoverlow. Because there are plenty of full answers with examples and etc. Anyway, think about steps you need to perform, in your case: * Decide which event triggers class change (click, hover, on window load, etc); * Select an element by its class name (preferably id); * Set (change) a class of the element. Now you can look any of these steps and different ways to do it. [This looks like nicely explained answer](http://stackoverflow.com/questions/195951/change-an-elements-class-with-javascript)
 var s = document.querySelector ('.option-select'); // get element s.className = s.className.replace (/ ?hide-important/g, ''); // change class attribute by using magic of regex 
So.. template files?
The article is well written, although is pretty basic and could lack depth for some people. I would recommend it for new developers. Anyway, good job spreading the knowledge and practicing second language!
Here we go, another round of libs comming, instead of using good and tested alternatives.
This is extremely cool. I'll look at it later
i've been to their HQ as a contractor its gonna take more than that
NodeJS is one of my favorite environments to use as a foundation for task runners, build processes, etc. It also happens to feature a lot of modules/packages for React and additional developer tools. Also, when you need to write something for the backend (such as spinning up server virtualization), you can utilize express rather simply to mock a backend accordingly. I usually pair that with a lightweight and customizeable editor like Sublime 3. What you'll find in the frontend world is that under the hood any environment you setup will initially be cumbersome. However, once you start building projects you'll find you can clone your base setup over and over and thus the initial overhead eventually subsides.
What do they mean by "Over The Air"?
Personally I like to wrap `fetch` with a custom wrapper per app, handling the data and errors for whatever is specifically required. The wrappers are so small to begin with, I feel like a library isn't required (you sacrifice customization for only a small amount of boilerplate removal)
Yup! Gotta get in while the getting's good ;) I was originally going to use superagent, then I realized "Eh, since I'm already rewriting this whole thing into React+MobX, might as well try to use fetch() as well". And here we are.
Love it! Link?
Just a note, this is the @WalmartLabs arm that has released this and you can find more information here: https://medium.com/walmartlabs/publish-react-native-bundles-over-the-air-with-the-first-electrode-rn-release-3780edb387ba#.3icsqa1qg
What are the specifics you're trying to achieve as your pastebin is incomplete. Do you want to use jQuery as you can achieve this as easily as: $('.option-selected').removeClass('hide-important') 
Is it me or is that a hefty page? &gt;6MB, 7+s load time... lot of images though.
Why? MongoDB is a nightmare? Why not use Redis, SQL, or PostGRES? Or any combination of those. 
Or you can do it with plain javascript : `document.querySelector('.option-select').classList.remove('hide-important');` Works with IE10+, Safari 5.1+ and all other browsers (since around 2010) If you need it to work will all ".option-select" elements, you can do : var spans = document.querySelectorAll('.option-select'); spans.forEach(function(span) { span.classList.remove('hide-important'); });
lol why is it a nightmare? Are we on the mongodb hate train now?
fuck, I got 1/2
I'm guessing that this has already been said (because it is the right answer), but: Make stuff. Come up with an idea for a deployable little project you'll have fun with that you can finish in a month or two (or a week or two if you're working on it full time). Target the toolsets you'd like to learn or get better with. In terms of toolsets that are useful to learn: I would say build a single-page app with React and/or a RESTful API with Node/Express. Here's an example of [a little side-project I worked on](http://meeba-farm.github.io) in order to learn D3 (and because I really liked the idea). Turns out I spent a lot more time with physics math and various game dev skills than I did with D3 or anything else particularly marketable in JS, but I had fun. 
I suspect Walmart Labs in San Bruno/Mountain View, CA and home office in Bentonville, AR are probably a lot different.
It's allowed as long as it doesn't significantly alter the app functionality. So it depends how you use this.
omg! stop acting like a childish kid or some wanna be dictator!
Makes me wonder whether xamarin acquired Walmart labs instead of the other way round 
Walmart's engineering team has been pretty influential. #nodebf where they switched to serving all mobile traffic through node for black Friday 2013 was quite the feat. Sure it seems like a no brainer now, but three years ago was a huge risk.
Have to admit I have the same reaction whenever I see a technology stack that involves MongoDB, or really any document DB. Document databases are good for a very narrow set of applications. However, if the purpose is just to do a quick prototype in order to have a backend and some other element of the stack is what's being focused on, then perhaps it makes sense in that context. I do like looking at the combo of Hapi and GraphQL in this case.
Can you elaborate?
no, I want them fused into one like gotenks
It makes things not only easier, but also more efficient because all these components are reusable. Create a module for, say, 5 + 3; whenever you need 5 + 3, just reuse it ! 
Ok, now I know you're trolling me.
no, i just meant in one package
I'm not a _huge_ fan of `react-router`, but if you structure things correctly, it doesn't really put your routing logic in your views. Just because they both use the `JSX` syntax doesn't mean they're both "views", as it's just a supserset of XML. Put your routes in their own `routes.js` file, wrap your app in a router, and tell it what your routes are by providing a data structure that defines them, and in this case, that is JSX (basically XML). And to play devils advocate a bit further, those other two examples you gave are pretty interesting ways to add control structures to a view templating language that didn't natively support them. If you think of this as `npm install mustache-control-structures`, and it added `if` and `for` to Mustache, you wouldn't be making the same complaints. JSX is a data structure, and is used for two different things in your examples (view templates and route declaration, respectively).
I love how you're being sarcastic about react-router, but there's not a single valid complaint in your post about it. Only misguided bullshit.
The only problem with those control structure components it that they're solving a non-issue. Sure, doing return ( &lt;div {true ? ( &lt;span&gt;Hello&lt;/span&gt; ) : ( &lt;span&gt;Goobye&lt;/span&gt; )} &lt;/div&gt; ); Might look a bit weird at first, but you get used to it pretty quickly. Alternatively, replace that with `{ this.renderStuff() }` and just use two different returns with if statements.
This is true, they basically add a light wrapper around a syntax that a lot of people don't find enjoyable, but that's the neat thing about JSX, it's acting as both a templating language and a DSL here, and allows us to create new functionality via nodes. Sure they complicate things by adding a layer of abstraction, but no more than using ES6 through Webpack, or Coffeescript, or TypeScript, etc. The point I'm really trying to make is that the examples that were provided were meant to be examples of how bad the react ecosystem can get in regards to "over complicating" things (which is the joke that the `&lt;Math&gt;` tag is making. The difference between **all** the examples provided is that they either prettify or simplify logic/functionality, or are not true at all (in the case of "routes being in views"). The `&lt;Math&gt;` joke is actually making things harder in every conceivable way (it's harder to read, harder to write, less performant, and less extensible). I get the joke, but it's not that funny, and yes I'm hilarious at parties.
&gt; 1+1×2 &gt;&lt;Multiply by={&lt;Two/&gt;}&gt; &gt;&lt;One/&gt; &gt;&lt;/Multiply&gt; It's been a while since I last did math, but I'm pretty confident those expressions are not equivalent.
`document.head.innerHTML += "&lt;meta charset='utf-8'&gt;" ` Then run the script from a setTimeout, it just might work?
The problem is that saying "it's just for prototyping, I would never use this in production" is often step 1 on the road to using it in production. And why using Mongo in production is a very, very bad idea has been documented sufficiently, I'd say :)
http://cryto.net/~joepie91/blog/2015/07/19/why-you-should-never-ever-ever-use-mongodb/
It has been advanced, but it has to be done gradually. Only the most important ones are extended or added. Otherwise, there would be too many features left unused. IMO, the current HTML(5) specifications is already quite large. Also, HTML is not a programming language, so it's impossible to replace the infinite probability that a programming language can achieve. Not to mention the human mind.
&gt; I'm looking for Javascript specific documentation of spec on this matter Why? You already know what it does
I hope you're kidding... this has got to be one of the most ridiculous micro-optimizations I've ever heard of! IF it's more efficient somehow (it's not), it would be so absurdly minuscule
Put your stuff in an iframe and you'll have complete control over it.
Feels a bit slow - 48MB memory, comparing to Reebock 21 and Adidas 25. Amazon has 11MB and loads quite fast. Zalando 22. The thing about React I'm a bit worried is the amount of memory used. The performance of CanvasRenderer is the color selection during one click it is bottlenect, takes 121ms. GC 117.6 ms and neo.js about same. Not sure what to think of that, but not 60fps at least.
&gt; there's more job security than a startup don't you fucking believe that 
I can finally write my React-based Excel clone!
You need to grab one node then insert it at the position you'd like. See `insertBefore` http://stackoverflow.com/questions/9732624/how-to-swap-dom-child-nodes-in-javascript
I can't find anything either. Like you found, there's a parser for all numbers and some algorithms probably run slightly faster. Practically speaking, it will vary by browser so this might be a fun test for you: https://jsperf.com/int-vs-double-implementation Looks like you can add your exponential test case and run. But to echo the other commenters, this is entirely academic. But whatever. Have fun in the rabbit hole!
/r/jshitpost
Oh! Three... wow... - that's a cool feature. Thanks!
Here you go &lt;!doctype html&gt; &lt;title&gt;My app&lt;/title&gt; Html here &lt;script&gt; // code here &lt;/script&gt; 
This is a boilerplate i made for my projects and thought i could share with you people. Now i can just concentrate on code and all the build scripts are taken care of. No more scripts required. Suggestions and queries appreciated. Also feel free to send PRs and file bugs as you find them. Thanks
In the examples given, those values don't look like they should/will vary - so it fits the usage you are talking about too, right?
and it's fast!
YES! Finally. ( ͡° ͜ʖ ͡°)
Well I agree with you about this, but in these specific examples, the values not only _aren't_ ever reassigned, but _shouldn't be expected to_ either - the functions are calculations that I would never expect to change, which makes them perfect candidates for using `const` in either philosophy. At least that's how I see it.
Fuck. No.
Your `moveDown` functions will receive the click event as their first argument, not `currentRow`. You need to first find the current row element from the click event, using `evt.target`
What is special about returning JavaScript code? It is just text right? You probably use a template string; old-style `%s` mixes well with JavaScript as new-style `{}` has the same braces as JS. There are a few other template gadgets in the standard library, or else look at pypi or your framework if you use one allready (django etc).
 var a='a', b='b', c='c'; undefined var result = a || b || c; undefined result "a" It's not an if statement. It's getting the first non-falsy value. var a='', b='b', c='c'; undefined var result = a || b || c; undefined result "b"
It's basically saying, if a can be evaluated to true, then accept a, if not, look at b, if b can be evaluated to true, use b, etc, etc. So, what can be evaluated to "true" you might ask, well that just follows type conversion, so basically, false, undefined and null would cause it to be evaluated as false whereas a string, true, object, etc would result in accepting the value. It's not the same as saying if (a || b || c). Take a look at this fiddle: https://jsfiddle.net/7w6fnped/
If a, b, or c are set, then set result to equal the first of the 3 that is set. a, b, and c do not need to be boolean values to be used in the if statement. It will evaluate to true if any of the variables have a truthy. [Here](https://www.sitepoint.com/javascript-truthy-falsy/) is a tutorial explaining true/false in javascript.
I'm not an expert on the matter, but shouldn't you be sending the UTF-8 charset in the HTTP headers for the script?
I tried a couple of methods including setting var currentRow = event.target; but none seem to work. I also tried changing the html to pass the function onclick-- https://jsfiddle.net/vu0tc0my/1/ Could you please tell me how to?
event.target will be the button that was clicked. 
[This part](http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.3) might include what you're looking for?
but is it webscale?
If nothing else, I'd love for web developers to understand how to develop for the web before diving into fancy javascript libraries and complicated webpack configs. Docker's "store" website renders each of it's clickable items as `&lt;div&gt;` elements, meaning you can't use built in browser features like command-clicking links to open in new tabs: https://store.docker.com/search?q=composer&amp;source=community If talking progressing enhancement makes those type of mistakes less numerous I'm all for shouting the conversation and buzzwords at new developers. I care much less about the javascript only websites if they understand how to structure their markup.
The website requesting our JS page sets the headers, not us. Our partner is in code freeze. Ideally you are right, that would be the proper way to handle this. 
The actual React bundle is 652KB. Yes the images are the main resource for the customization tool. We load 6 different views for the carousel and each image has several pngs stacked on top. The image resolution depends on the screen size so for smaller devices the overall girth is cut by a lot.
The parent wrapper is an entirely different applications. Our React app is just the 652KB js bundle this page pulls in (once you click "edit design"). The main performance hit are the images it downloads, but scales depending on screen size (desktop, tablet, phones). Smaller screens get smaller image resolutions, which means faster load times. Check out the responsiveness in phone mode.
Still down for you? Strange. Did you get infinite loading?
TBH it looks more like Angular that React. 
How much time had you spent with React before? Did you end up plugging in a separate state management system for Vue?
Languages are just a tool, one of many in your toolbox. If it works then it has done it's job. Do you think guys were bitching about which hammer of rivet-gun to use when building the Empire State Building? Maybe, but after it was built the public marveled at their creation, and no one cared about which tools they used.
This is a simple boolean expression, and has nothing to do with strong vs weak typing. It means "this.result is true if a or b or c are true." Pretty much every language implements boolean logic with the same syntax (though C# appears to use a single | instead of the double ||). The equivalent C# code would be something like bool result = a | b | c; 
http://codepen.io/anon/pen/BQBbXr
Here is a working example based on your layout with no additional ids or data attributes used: https://jsfiddle.net/ronilan/tpqev6pe/ Note that if you expand this into an app you may want to consider how all UI controls and events play (pun intended) together before diving into specific implementations. 
Yah, let's just use JQuery shitty spahgetti crapola all over the place like 5 years ago. Fuck React for making my job easier, fuck it right off.
Check out microjs.com 
Yup, exactly. It uses the exact same code push client on the mobile app, but now you're not tied to azure for the back end.
So how would I go about doing this? If I made a python function that returns a string that is some JavaScript code, how to I then actually use the JavaScript code?
http://i.imgur.com/tn0NZMx.png
 $ node &gt; false || true || false true
The thing I'm having trouble with is actually executing the formatted code. If I had a function like this: def hello(name): return """alert("hello, %s")""" % name and I run it like this: hello("brtt3000") It will return the string alert("hello, brtt3000). Now how do I make a web browser interpret this string JavaScript code so it will use it?
tldr; vscode is written in Typescript that allows type generics. JavaScript is supported, as are custom types using a *@type* annotation. vscode 1.7 is using NPM to host blessed custom type definitions. This spike in traffic is equivalent to all of India's use of NPM. vscode rolled back to 1.6. The resolution is that MS will cache popular type definitions in their cloud before distributing them via NPM. The real question is why vscode even bothers with NPM at all for this. They could easily host this themselves as MS already has superior distribution capabilities via Azure.
Why are you using heroku to serve static content from GitHub? You can use webpack to build a "dist" version and then upload it to the gh-pages branch of your repo. And I wouldn't call the link "demo". It's not a "demo". It's the real thing :). Interesting project, BTW :)
Fuck me, I guess I'm learning Vue.js then. Based on the stars, and all these comments. I just started using React in my last few projects, and React native for a mobile app. Wow ok, and there's a ["vue-native" called weex, from Alibaba](http://alibaba.github.io/weex/index_m.html). I guess I'm going to have to learn that too.
What kind of tools/features are you building? 
Thanks!
Because it's a good thing that all JS-related packages are kept in one repository. 
gh-pages is optional now. You can publish direct on master or within master -&gt; /docs folder
I'm playing around realtime stuff using socket.io - to be most precise, I've created 2 real time chat apps - one build with react, other one with Vue. And I must say that working with vue made it much more easier (and I make my opinion about Vue based on that)
Yes, you have to use the standard DOM methods. That really means follow DOM level 2,3, and 4 while forgetting DOM level 0 and 1 specs. Here is the most direct way to go about it: document.getElementsByTagName("view-content")[0].firstChild.textContent; You could also check out this handy dandy approach and just get all text nodes directly: https://github.com/prettydiff/getNodesByType
It's not a single point of failure, there are several npm mirrors.
So you're saying Maths is useful for Project Euler problems? Ridiculous! 
Thank you for your reply. I got the request to return JSON instead of XML, now I can access elements like: count = response.body.view_count; Not sure why XML wouldn't do the same, but this works fine! Thanks again.
Laravel is pushing Vue really hard, so I imagine a lot of hype is coming from PHP devs.
Some day there will exist an article titled "NPM: A fractal of bad design."
Oh, very cool. If you have time I think the fact that you made the same real life application with both frameworks would make for a great blog post. Most comparison articles are very shallow.
This article needs an editor not only for the language, but for the incorrect information presented. &gt; JavaScript remembers where you did the call. It does that because your function—for example—may require accessing external variables from where it was called. Here is what a [call stack's](https://en.wikipedia.org/wiki/Call_stack#Functions_of_the_call_stack) purpose is. &gt; for performance reasons—there is a limit to the call stack size [The limit is not present for performance reasons](https://en.wikipedia.org/wiki/Stack_overflow). &gt; For the js engine this optimization means: ‘oh cool I don’t need to remember the previous function call environment, so I will just forget about it since i have everything I know here to do my job. It means a new call is not pushed onto the stack, and a new return address is not stored. The same variables used from the previous "call" of your method are reused for the current iteration. To utilize TCO in supported browsers, you don't need an accumulator, for one; the JIT compiler will handle TCO for you, if it can. If you want to simulate TCO where it's unsupported, you can use [trampolining](https://gist.github.com/aholmes/8f6bee6334ddb849b751).
Lol welcome to the world of javascript.
Have you tried riot.js? I find it to be another tier of easy again over vue.
I'm pretty sure most React people can grasp Angular and vice-versa.
Haha, the great thing about Vue.js is that it's fairly easy to pick up. The API is really well made. There's a vue-cli to help you quickly bootstrap an app. Don't feel like installing vue-cli? Create a Codepen/JSBin/JSFiddle, add the library, reference a root element and off you go.
Not a lot of frameworks have chinese documentation I'm guessing. But honestly, it's a great framework and worthy to stand with the giants of React and Angular. Evan You's a good dude.
Huh, neat. I've never actually used mathjax, just seen it around. That's pretty nifty.
Listen I started with Vanilla Javascript, then Angular so I know all about templating. Also Angular doesn't actually adhere to the separation of concerns mantra since it puts JS in HTML! Virtual Dom + JSX is proven and most new frameworks follow this pattern such as Inferno and a few others. React also is proven and used by the best of the best, have you ever used Netflix? That amazing UI was built in with React and embraces many of it's design patterns all the way out to how their whole backend is like a composition of stateless micro services comprised of a multitude of technologies. Why don't you try it first before you start preaching outdated best practices. You know I myself came into React skeptical, but after using it I realized how genius it's overall design patterns are.
Ok thanks, I'll have a look again!
What a horrible mix of templated HTML, script, and CSS all in one file.
Holy hell! I remember stumbling across this a while back and thought 'this will be useful later', then bookmarked it. I completely forgot about it. Vue is sweet!
Well [their site](http://skate.js.org/) is a cluster...
Note that .sync and .once are deprecated in Vue 2.0.
I highly recommend veux for Vue state management
It doesn't but that's still the case. I'm a laravel dev and because of that got tied into vue but I wouldn't have it any other way. It's a great framework. If or the record, I've tried angular 1 and 2,react,and several others. Vue gets out of my way and let's me build things more quickly than I've found with the others. It has less to do with Laravel deck pushing it and more to do with vue being awesome. 
For big projects, wouldnt Ember be a better choice?
Even in small projects, if it's easy to set up and decreases the number of loads why wouldn't you? Setting up something with gulp to watch your app and recompile is trivial. 
JSX really has nothing to do with React though. I believe React was one of the first libraries to make use of it but it's certainly not the only one now. This is because JSX compiled to Javascript _just makes sense_. What I mean by that is it's a very simple API that can describe a complex DOM well. It's easy to iterate and probably hooked straight into whatever Vue used after creating an AST for its normal templates. TL;DR - JSX isn't just hype, it's just a really awesome way of describing the DOM in an easy to use way.
I'm not really talking about mastering a framework or library just FYI. Just valuing a firm grasp of core language concepts and design patterns. Switching frameworks all the time is just going to slow that whole process down cause instead of focusing on writing good code you're focusing on learning new APIs.
But JSX lacks so many features that a decent templating engine should have, you often have to use third party packages to do trivial things that the templating engine should be doing (e.g. classNames) or implement it yourself, and this is because JSX is not really a templating engine. React has NO templating system, that's one of the reason it's considered a minimal framework. The templating engine that comes with Vue and Angular can do the job just fine and I often find it much better than writing JSX and mixing JavaScript code with the presentation code. The first time I've found out about Vue I was wondering why everybody was so obsessed with React when Vue much simpler to use and just as fast, yet it was getting almost no attention at the time.
+1 for first library that clicks me :)
Love DataTables :) using it for a project at work right now. 
React, angular and vue are basically interchangeable in terms of what they can do and the size of projects they can handle. That is, any site built with one should be able to be built with either of the other two and perform just as well. The real issue is which way of doing things are you more comfortable with. 
Vue is absolutely suited for large-scale applications, the only real issue is state management and Vuex takes care of that very intelligently; like Redux with React but built specifically for Vue, so it makes a few decisions for you. I've been building a marketplace the last 4 months and the front end is 100% Vue. There are over 200 components, 50 mixins and 40 vuex store modules. Not massive by any means but we add new features daily and haven't run into any major structural or organizational issues. The simplicity of Vue and how well it scales up has been a huge part of our success. Anyone who says otherwise simply hasn't used it at any decent scale. Read this for an in depth comparison with React: http://vuejs.org/guide/comparison.html
That's not the same thing. v-once is for rendering a component once. .once is for a one-time prop binding, and future changes on either end are not synced to the other.
You failed to describe why jsx is easier and awesomer than the default Vue templates. I say because I'm genuinely interested. 
What is the problem with directives? Under the hood is all JavaScript, directives are there just to abstract and nicely integrate JavaScript with HTML so you don't have to implement everything yourself. It's true that you don't have to learn a new framework (although templating engines are often very simple) but you have the overhead of writing basic functionality yourself with JavaScript
Oooops, thanks! I was rushing too much. Thanks for the link, I'm going to use it a lot! I've got lots of JS all over the place.
I've literally never had to call on the community for riot. It's been easy enough to pickup and I've just had no problems. I've used the other three too in the past. Much stronger community - which is good because you need them. 
Same here. I was able to refactor my 70+ files in React+Redux to 100 lines in vue + 350 lines in a server html template. Amazing! And I did all that within a day whereas React and Redux took me weeks
Never had to call on the community either. What I meant is that the framework itself doesn't have that much support behind it( people working to refine the framework). I think they got some more developers working on it recently though. For small or personal projects, I think Riot is decent. As with anything else, use the right tool for the job. EDIT: To be clear, I like the framework but like anything else, it does have its faults.
Vue.js was the perfect option to create a JavaScript Guessing Game: https://github.com/samiheikki/javascript-guessing-game
I was specifically addressing a concern about the complexity involved with starting a small project, so I offered that they can start as simply as dropping the Vue file as a script on a normal HTML page. If we all pretended the only way to make Vue apps was to go through the whole ringer, Vue will not become as popular as I would like it to be. In a world where the overall popularity of a framework can affect the quality of the documentation, how quickly questions are answered on StackOverflow, and even how bug-free the framework itself is and how long it's maintained, I want it to be as popular as possible, regardless of whether everyone is using it in the same way I am.
I don't like when people compare Vue to jQuery and focus only on its simplicity. It's not a "toy library", it's a mature, well-designed project that is suitable for any scale. It supports all you need for building large scale applications: hot reload, server side rendering, Flux-like datastore, router etc. There are tons of components, directives and plugins for it. I think Vue and React are pretty much equal choices. You should choose what you like more.
For forms there is [`v-model`](https://vuejs.org/guide/forms.html).
That's not specific to Vue though, that's how native web components look like, template + style + script
Hence the question
In that case, NaN is a very bad choice of words
Really? Cool beans 
To me it seems like you could accomplish the same thing by using native html onclick attribute, etc. 
I'm a very happy React/Redux/TypeScript user. I find the rigid fundamentals fantastic for quick development and predictable, stable results. If I had to start over, I'd pick the same stack. I am hesitant to believe claims about Vue's scalability until the honeymoon is over. It's still a "cool" library and so many of the people extolling its virtues seem to lack real experience with other libraries and/or large projects. If warts exist, they're unlikely to become common knowledge until more time has passed and something new captures the imagination.
Okay but why would you mention it in a comment where you list reasons not to use riot.js. I do agree with the rest but this is out of line.
Never used Google App Scripts. But from what you say and after a few minutes searching their docs, roughly those two pages should cover the basics you need to know: Get data from sheets and send mail based on this data: https://developers.google.com/apps-script/articles/mail_merge time driven trigger (to run a script every minute/hour/day): https://developers.google.com/apps-script/guides/triggers/installable#time-driven_triggers Obviously it wouldn't be too bad an idea to work with some of the other basic tutorials to get some confidence in using this service: https://developers.google.com/apps-script/articles 
That's a good thing 
it's a fad. no one will be talking about it next year
You can hook to the event mouseover fullcalendar event: https://fullcalendar.io/docs/mouse/eventMouseover/ Thus you have the event object with all its data as well as the javascript event that holds mouse position. You can then make your own function that renders a popup. Use the https://fullcalendar.io/docs/mouse/eventMouseout/ to hide the popup
Some people might find the traditional templating engines to be limiting at times. My anecdotal edge-case example of this when I was trying to make [this exact table](http://forums.htmlhelp.com/index.php?act=Attach&amp;type=post&amp;id=1827) using data in the form `{ column1Title: { column2Title: [...column3Data] } }`. I was using Bootstrap where the styling does not work for nesting tables within `td`s, so I had to use one table element and use old-style `rowspans`. Using JSX, you can use two reduce functions to get this working. Neither StackOverflow or myself could not get this working with Angular’s templating engine.
You could use a JS side Lame - http://stackoverflow.com/a/30760287
A question to any professional JS developer; is there a valid reason to switch from React to Vue if I'm familiar with the React ecosystem? I do mobile development (React Native), web development (React) and server work (NodeJS). I asked this same question before moving between Angular and React and the advice was invaluable. 
Bad style is bad style, even if in some cases it's defendable. 
Hi /u/umaar, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `umaar.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [umaar.com](/search?q=%28and+site%3A%27umaar.com%27+author%3A%27umaar%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|15|65%
Hi /u/kris749b, if you have a specific question and have already attempted to answer it, then we're more than glad to help, but we're not going to do your homework for you.
Some problems with that approach: * If there were a problem with that one part of the library, it'd require an arguably unnecessary update to the entire library. Modularity makes it so that others can update their part as needed. * It's not Vue's responsibility to build-in what other libraries do perfectly well. When you add http functions, then you have to ask whether you should add Date formatting, currency formatting, filtering, etc., all of which were removed from 1.x -&gt; 2.x for this reason.
Dear God, yes. Can we finally stop with all the whining.
Separation of language is not separation of concern when you are dealing with UI composition. Components are.
Neat.
Don't listen to the bot. Never stop being you. Your stuff is amazing and highly shared around my dev shop.
[removed]
Thanks so much! This helped out and knowing what to search for has worked in getting everything to load on click instead of waiting for 3-6 seconds.
X-Post referenced from [/r/webdev](http://np.reddit.com/r/webdev) by /u/OriginalEXE [Created a new library for displaying video background. Supports both self-hosted and YouTube videos.](http://np.reddit.com/r/webdev/comments/5b3kxr/created_a_new_library_for_displaying_video/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Thank you, that's very kind of you to say. Super pleased to hear you like it! I guess it could come across as a spammy self-promotion tactic if I only post links to my own site.
Vue's official state management lib is pretty close to Flux/Redux. If you aren't using a state lib, it's still similar to React where it tends to be a mix of passing props, and/or emitting events through an Event Bus.
Learning code with CodeAcademy and co is fine. But you'll really get better by doing small projects: try experimenting with all the things you already know, and challenge yourself with stuff you don't know. Create a small website, a TODO app or whatever. Practice is important :) Good luck!
I googled some examples and sorta see what you're talking about, but would it be plug'n'play? Would I just swap setInterval with setTimeout?
Check this implementation, I modified your playbackArray() function. Let me know if the code is unclear. http://jsfiddle.net/jz7e9yep/1/
If you're trying to follow trends, you're gonna have a bad time. Stick to mastering core Javascript, and jumping on flavor-of-the-month library/framework is relatively trivial. 
Not in one file usually.
Announcing Winds 0.1.0 \0/. An open source RSS reader built on React/Redux &amp; Node.js 7.0. We would love to get some feedback and hear what features you'd like to see.
It's just a different way to make a callback. Promises didn't kill callbacks.
That's my point. Horrible by design.
As someone who has spent a lot of time working in angular, I feel like it's simply not true that this ``` &lt;div ng-repeat="user in ctrl.users"&gt;{{ ::user.name | lowercase }}&lt;/div&gt; ``` reduces boilerplate any more than this ``` users.map(user =&gt; &lt;div&gt;{user.name.toLowerCase()}&lt;/div&gt;) ``` Directives and components both reduce boilerplate in the same way -- ``` &lt;div users-list="users"/&gt; ``` vs. ``` &lt;UsersLists users={users}/&gt; ``` Seems like the same idea to me. There is a ton, a ton, a ton, of boiler plate involved in writing redux, but that has nothing to do with the view layer.
A bit defensive don't you think? I've reported your comment to the Mods. Try be more civil next time.
Yes, because people like you with your shitty attitude piss me off. You reported me to the mods? I have no words to tell you how devastated I am. Now run to mommy and tell her as well.
Honestly you don't need to spend much time with Vue before you know if you like it. Just go through the getting started guide for simple examples of the syntax, and then look at the tutorials here: https://coligo.io/vuejs-components
Most ES6 projects actually use the `class` keyword. It makes for terser code and it's understood by tools like analyzers or doc generators.
congrats! for a static site, you've already waaayy over-engineered it.
Alibaba or some other mammoth from China is using it, hence it's gaining traction there.
http://vuecasts.com/ the URL for that.
Can you make it so that people can upvote/downvote your tips? 120 is a bit TL2R.
So what do we do with best practices? what makes a good developer? Is it really context based? 
That's if you ignore the render function and return around it.
But, but, compositional error handling
I checked the post date when I saw the test cases in the comments (Node 4/0.12, io.js - remember that?!), over a year ago. Thanks for the update.
Because you should have just written 3 static pages and served them with nginx. 
Because you dont need javascript or nodejs to serve static html, css and js files to the client. 1. extract `nginx` [1] 2. start it 3. dump your files into `/html` It'll work faster and more efficiently than any nodejs setup. [1] https://nginx.org/en/download.html
I will draw the line one after another all connected
That's kind of my point. I'm not hating on react. I've very rarely found myself or someone in my team stuck fighting angular internals though.
Im not sure wheter I'm in favour of the synthetic event system, it's an abstraction with some pitfalls and I fail to see prevelant benefits, aside from onChange perhaps. Am I missing something?
I'm pretty sure that /u/leeoniya knew that. I did. Just giving you crap. But, a guy that writes about creating web applications should understand what a framework really is, and what they're actually doing when they're writing a series of blog posts about how to create webapplications, in his opinion. A 'framework' is simply a bunch of ideas and beliefs encapsulated in code. A good framework is a bunch of good ideas, design patterns, best practices, distilled from years of experience, encapsulated in code. When you're done with your series of blog posts, and decide you want to write another web application, what are you going to do? Are you going to start with a blank editor window and start typing 'const http = ...'? Are you going to realize that quite a bit of the code you've written for your first web application is applicable for your second, so you copy/paste it and change a few things, and now you've got another web application. Now, do that for the 3rd, 4th, 5th.. nth web application. At some point, you're going to say, "damn, most of this code is the same, going to abstract it out to a library, and include that each of the web applications. And maybe abstract another bit of code out into a different library, and so on... What if, after you're done with your series of blog posts, I decide that I like your ideas about how to build modern web applications, and ask you to post it on github so I can use it? Guess what you did? You just wrote a framework. Of course you can write a modern web application starting from nothing (well, node, but whatever, right), after all, THAT'S HOW ALL THE FRAMEWORKS ARE WRITTEN. They're all just code too. So, do you need a framework to write a single web application? No, of course not. You don't need a framework to write 100 web applications. But, what you've got when you're done - when you've finished the first web application is a framework. It is a manifestation, in code, of your beliefs about how web applications can or should be built, and that's all a framework is. 
&gt; Am I missing something? The upside is that enough people have banged on it that I'm reasonably confident that event handling code written in one browser will work in other browsers without resorting to in-browser testing. They also put in some niceties. You mentioned `onChange` but they also normalize key events and I think some other input events. How valuable this is depends on your supported browser set. All the issues I've had with React have been synthetic-event related but it's been at least a year since the last one. I see it as a positive if you're not worried about k-weight.
Can't recommend anything specific, but look for courses that mention working with the canvas, as that's probably what you will use for drawing the graphs.
These are amazing and the format is perfect. Thank you!!
hoffentlich, please use respectful tone and words.
I just recently found and fell in love with yield &amp; generators. This seems to be more of the same idea, except it doesn't require a library like co to manage the generator... I like it.
As a web developer that once had to produce a PDF document, I've found [this tool](http://wkhtmltopdf.org/) to be incredibly useful. It lets you design a page with HTML &amp; CSS and then render its output to PDF. Not exactly Javascript, but definitely useful for most web developers...
oh i see, are you saying that because i have a "return false" that stops the submit button from proceeding to the next page, the validator never gets that far?
I like callbacks too. The inability to address exceptions at the source, or outright eating them, has been the cause of many an hour of debugging.
Check to make sure the fields value length is greater than 0
I think Ira Glass' quote about the [taste gap] (http://images.liveluvcreate.com/create/i/ira_glass_quote-530541.jpg) applies here. The only way to get good is through creating a bunch of crap that is not up to your own standards. So the sooner you start creating crap, and improving your crap, the sooner you will get good. So get going.
Check out FreeCodeCamp's D3 JavaScript tutorials as well as their intro to JavaScript tutorials! 
I wrote a codepen for you showing how to draw a few lines. You will have to repeat the process to create the entire tree. http://codepen.io/anon/pen/RowEeQ
After reading this article I tried swapping in Axios for VueResource and the initial transition was pretty easy! Take a look at the Vue wrapper for axios, made integration really straight forward. https://github.com/imcvampire/vue-axios Note: for those of you using webpack ect.
&gt; What tools would you reccomend I use to build an app? VSCode is a good IDE for web. Atom is also a decent free solution if you don't mind the rough edges. Another invaluable resource is sites like https://jsfiddle.net/ or http://codepen.io/pen/. Using tools like these, you can practice a new technique or do practice problems without setting up a project. When you get to the point where your projects contain several files, you should consider: * Downloading Node so you can use npm to download dependencies * Learning basic Git usage and using GitHub for free project hosting. Also, I know I'm just adding to the chorus, but you get better by biting off more than you can chew. Good luck
Promises are ❤️ Async await are also great Callbacks will live on
It slipped for a moment. I will from now :)
I assume you only use pure JavaScript ? No framework ? Oh sorry I sense jQuery in there ...
I've been told that bind() and apply() are very important functions to understand for JavaScript today. How true is this?
They're just sugar around promises, and promises seem to be hard for people to pick up. I think that alone will never kill the callback. As with most things, it ends on: "do what works for you"
A bit more verbose but I really like breaking things out a little: function _renderItem(p, c) { return p + `&lt;li&gt;&lt;a href="${c.href}"&gt;${c.title}&lt;/a&gt;&lt;/li&gt;` } let result = `&lt;ul id="${data.id}"&gt;${data.list.reduce(_renderItem, '')}&lt;/ul&gt;`; Remember that the goal isn't less code, the goal is more legible, maintainable code. I'd argue that my example is more legible and maintainable. By requiring no third party library, it's considerably more likely that new developers can read my code without learning new things (ie. a template engine). By breaking the iterated logic out, it becomes obvious where I go to change things about the list vs. the list items. Instead of having non-JavaScript people learn handlebars syntax for loops and whatnot... just have them learn JavaScript syntax for loops and whatnot.
Using `map` instead of `reduce` makes more sense to me. It also avoids having that `p + ` in the callback. You do need to join things afterwards, but you could make a helper for all of that: function each(arr, callback) { return arr.map(callback).join(''); } Edit: Regardless, handlebars is easier for non-programmers to reason about. This same thinking applies to handlebars vs EJS, too. Templates are great, and it's nice being able to just use JS, but the issue is that a lot of designers aren't very good at coding. 
Thank you for the constructive feedback. We'll be improving the sign up flow in the coming weeks. Stay tuned!
Re Edit: I'm just not convinced. Why do you believe handlebars easier for non-programmers? It's still just programming, no? You've got a function call to iterate over a collection. The syntax is just different, not logically any simpler. Why not learn the more useful of the two options?
It’s a TypeError to call a class without `new`.
We run it with external auth and it goes perfectly for our simple realtime components, Our system still highly rely on relational data but our live components switched to it and we're in love. Basically it runs our webRTC signaling service sharing SDP offer, our whiteboard and interactive tools as well as live learning analytics. We would never have that many killer scalable feature if that wasen't for horizon And horizon will be supported. If not something else will take over. Its just RxJs once you know that API and some noSQL patterns you can get around 
Line Height made that interesting article so hard to read on mobile, defeating it's own point. Other than that thanks for sharing!
The bots are sentient!! (Sorry about that, I'm used to these mod messages being automated!)
It's pdeudocode, man. 
it looks good to me, what are you trying to fix exactly?
Hi /u/MoonblazeBoxcat, We don't take requests here. You need to demonstrate to us that you've attempted the problem. Please show what you have tried, and we can help point out where you went wrong. Please reply to this comment once you have updated your post, and I will make it public. Thanks!
/r/botsrights would like to have a word with you ;)
if you dont want to give your email away, just use this -&gt; https://github.com/DrkSephy/es6-cheatsheet
Demo doesn't work. :( http://winds.getstream.io/app/personalization-feed
So you can't help me out here?
Is the $ jquery? Thanks Sorry, I'm just trying to learn.
generating checksums takes too much time - even `tth` and `md5`. anymore options?
No it's part of the ES6 Template strings syntax. http://exploringjs.com/es6/ch_template-literals.html
Hey, thanks a lot man!
&gt;new Point(0,0).add(new Point(0,10)) How are you arguing that Point is non-mutating? 
One problem with your Point class is that it is not necessarily compatible with other 2D vector classes since you can't assume they will have the methods you expect. Plain functions that operate on 2D points/vectors will work on any object with x &amp; y properties. That said, vector objects tend to be used in tight loops so you probably don't want to allocate new ones; generally it's better to provide an output point for the result, and to write your functions so that an input can be also used as the output. See [this library](http://glmatrix.net/) for reference. Note that it uses arrays for compatibility with WebGL. (And maximum compatibility overall.)
I implement the method like this: add({x, y}) { return new Point(this.x + x, this.y + y); } 
Is only a subset of JS supported? I tried prompt() and it crashed
Shouldnt the middle be json api instead of css?
with that logic, map/reduce/filter methods of the array object are also not pure? that is what confuses me, because they are often referred as the functional side of javascript but I don't see the difference: `point1.add(point2)` vs `add(point1, point2)` to me this is just different syntax for the same things.
Map, reduce, filter are all pure. They take an an array and return a new array. The original is not mutated. Also about your syntax point. You are correct with arr1.map(add) vs map(arr1, add) they could be pure or impure depending how the function is written. Like string.splice() impure vs string.slice() pure
That's irony. I've seen many people who love React Native. It's just so much time saving to build an app cross platforms - ios, android
Wanted to get user input for a conversion tool. I tried a couple different ways and it crashed the app both times
No its not
I'm not sure that `OO` and `FP` paradigms are mutually exclusive. It's more so that `OO` code is typically imperative (EDIT) or encourages mutability. EDIT: I think it's also fair to say that the second example of `add` is in an `OO` while the first is more `FP` style. Note one is a function and one is a method-type-thing. http://stackoverflow.com/a/3949641
What's backend developer doing with CSS?
And you put non-UI component code in separate JavaScript files, just like what he did. What's the problem?
Pretty sure Firefox does this. Or at least it did not long ago.
ok will dig into the prompt bug. in the meantime, could you use HTML to get user input? you can use both JS and HTML?
/u/jacksonmills was mistaken. Your interpretation is spot on. To recap (and confirm) things you've already said: `reduce(a, f)` and `a.reduce(f)` are slightly different syntaxes for doing the same thing. It's important to realize that `this` is effectively just a parameter. In fact, that's almost literally the case... `reduce.call(a, f)`. Some functional folks have decided that `this` is evil, but it isn't. It's just a parameter. Don't mutate it, and you're fine.
Yeah good idea. Window.prompt was undefined so it must not be supported 
ok ... was it not clear you could use HTML in the app as well? sorry for the confusion! and thanks for the fast responses!
The reading of the feeds is done by DiscoverService: https://github.com/GetStream/Winds/blob/master/api/services/DiscoverService.js And https://github.com/GetStream/Winds/blob/master/api/services/ScrapingService.js The feed personalization logic is done using getstream.io. The list of tech we use: https://github.com/GetStream/Winds#powered-by We do use third party services for some things. All of them have a free plan though, so you can easily run this on Heroku or your own servers if you want.
&gt; it is using state information to produce a new Point, so it's also not pure If Point's interface doesn't allow you to mutate `x` and `y`, then it's pure. 'State' used the way you're using it is shorthand for 'mutable state', and we have no information about whether the state in question is mutable.
&gt; 280MB memory use with 1.000.000 items What? What items? I don't see any examples in that Github repo. I am sure that it is not possible to load, say, 1000000 **different** images (or 1000000 **different** iframes) by AJAX, and end up with 280MB of RAM used, even if you remove all of them from the DOM. Even a page refresh does not help (because the memory is controlled at the OS level)! Long ago, I hoped that freeing the DOM would help to avoid serious memory leaks. But now I know that this practice is pretty useless for a real-life usage. Browsers will leak memory in any case, even if I remove elements from the DOM. The following Stackoverflow answer explains the situation in details: [Stackoverflow — “How to remove DOM elements without memory leaks?”](http://stackoverflow.com/a/3785323) 
Try defining the anonymous function that attaches the listener before you do the loop and put it in a variable , then call that function in the loop. I think the issue has to do with you using the same variable names, maker and property, in the anonymous function, and some complex scope rules kick in causing unexpected behavior. 
Personally I'd argue that it is very weird object orientation as well. Why do points multiply like that?
It seems to me that you're making a distinction where there is none. What makes `reduce` invoked on an array a pure function, when OPs `add` function is not? Neither have any side effects (except for object creation), neither consider any state other than their parameters (including `this`). Both will have the same result each time they are invoked with the "same" arguments, and both will potentially change behavior if the parameters are somehow mutated. Assuming the function passed to `reduce` is well-behaved, of course.
In what ways is Elixir OO? I had not heard that before.
Try running your code through JSHint: You would have caught the missing comma after `window.location.href.split('?')`
&gt; I'm always a bit in doubt to understand what is object orientated code and what is functional. &gt; &gt; For example, map/reduce/filter methods on arrays are seen as functional, because they are not mutating and without side effects. But it seems also that they are object orientated, because they are methods on an array object. They are not implemented as a global function. Let us say that we wanted to implement `Point` in a functional language like Haskell: type Point = (Int, Int) In JavaScript, datatypes boil down to classes/object prototypes. So something like this would be analogous: class Point { constructor(x, y) { this.x = x; this.y = y; } } Now, if we wanted to implement a `move` function, which "displaces" the coordinates of a given point, then in order for it to be *functional*, it must construct a new point instance and **not change the internal `x` and `y` variables of an existing point**. So in Haskell, it would look something like this: move :: Point -&gt; Int -&gt; Int -&gt; Point move (x, y) dx dy = (x + dx, y + dy) If it were implemented as a global in JS, it would look like this: function move(point, dx, dy) { return new Point(point.x + dx, point.y + dy); } And if it were a method inside of our class, it would look like this: class Point { // ... // note that since we have the internal state available, there is no point // to pass in as a parameter move(dx, dy) { return new Point(this.x + dx, this.y + dy); } } All that matters is that our functions interact in a way that does not mutate the internal state of our objects. Implementing the functions as globals doesn't make them more/less functional: *the immutability of our data is what is important*. This is why `map`/`filter`/`reduce` all return new `Array` instances. I would argue that one of the main points of object oriented code is that it manages state (contra-functional), and it aims to keep the state-changing methods all within a reasonable scope (the class of the object whose state is changing). So you are correct that syntactically, both global and prototype-based methods can be functional, so long as they don't affect state. # An important aside... However, a functional programming enthusiast would prefer global functions because global functions make it easier to reason about the program mathematically. In particular, functional composition exactly mirrors the composition of mathematical functions. So for example, let us say we had a program that mapped two functions, `f` and `g`, to an array (or list). In JavaScript, with chaining, we can write this: list.map(f).map(g) In Haskell it would look like this: map g (map f list) It is clear that the result of the first map is being given as a parameter to the second mapping. It can be proven (by induction on lists) that this mapping is equivalent to the following: map (g . f) list where `(g . f)` is a function that first applies f to it's arguments, and then applies g. So in JavaScript, if `map` was a global function, we would have: map(g, map(f, list)) (which is exactly how the Haskell code would have looked with [uncurrying](http://stackoverflow.com/questions/36314/what-is-currying)). Then we could derive from the above algebraic law that it can be written as: map(x =&gt; g(f(x)), list) Now, even though this isn't a shorter visual representation, it is in fact more efficient in execution, because doing two separate maps would mean *reconstructing the full list twice*. Leveraging that algebraic law thus allowed us to write more efficient code (although, the result of this example might have seemed obvious at the start). So in this case, globals (or more specifically, functions wherein we **don't** obscure input parameters or returned results via chaining) make it clear what data is being returned; how it is being passed on to the next function, and how the functions are being composed together. In the `move()` example, even if it were a class method, from this perspective, it would be preferable to write it like the global version: class Point { // ... // no more dependence on an internal state; just like the global // except it is namespaced by the class, i.e. Point.move(point, dx, dy) static move(point, dx, dy) { return new Point(point.x + dx, point.y + dy); } } This makes it much easier to reason about the control flow of a program from a mathematical perspective, and use the results of algebraic laws about the composition of certain kinds of functions (if one were interested in that). If one weren't interested though: chaining methods are more intuitive to read, and more compact to write.
Some people interpret erlang's processes (and thus elixir's) as objects, possibly even the first true realisation of the original object concept: their state can only be private and they can only be interacted with through messages, so much so that these messages are asynchronous and getting information back necessitates a new message going the other way (the "callee" has no idea who the "caller" is unless they're told)
No unit tests?! I'm just kidding. Nice work! I like the implementation and the code is pretty easy to follow as well.
No, what I've done is started experimenting. I never said "what I've build is awesome and you should abandon your libs and frameworks", no, I'm just having fun here, learning how to build modern web application using as less of technologies as possible. It's not a guide to action.
&gt; Where do I progress from here? What now? Write applications. Build something useful.
Then that's fair enough. But it's not modern, if anything you're trying to solve a problem that doesn't exist. Have you seen the web components spec yet? That does't require a framework and does everything you've set out to do, and standardised by w3c. Check it out :)
Right, it's not modern yet) But it's only part 1 of the series. In this part I've created the basis, then I will add features. I'm aware of web components, they are definitely modern, I would even say they are futuristic (almost none of the browsers support them natively). There is Polymer, of course, but anyway I'm not going to write about web components. I'm willing to experiment with Vanilla JS way)
That SO question is more than 6 years old, as are the answers. I believe the memory leaks described on that page are only applicable to old versions of IE where event listeners would cross-reference with DOM nodes, preventing those from being garbage collected. This is no longer an issue in any modern browser. Nodes *in the DOM tree* cannot be GC'd, which is good, you don't want elements disappearing. Nodes that have been removed from the DOM tree and are not referenced anywhere else can be GC'd, and of course the GC is different across implementations and devices depending on the amount of free memory available on the machine, etc. I think you're misinformed or confused about the scope of this issue in present day. To sum up: &gt; I am sure that it is not possible to load, say, 1000000 different images (or 1000000 different iframes) by AJAX, and end up with 280MB of RAM used, even if you remove all of them from the DOM. You could reuse `&lt;img&gt;` elements regardless, but yeah, you probably can do that if you don't have more than say 20 images on the screen at a time. &gt; Even a page refresh does not help (because the memory is controlled at the OS level)! Memory is only freed when it is needed. This is normal behavior. If you don't need that memory, there's no reason to go around clearing it or reallocating it to a different process.
&gt; Mixed Content: The page at 'https://thednp.github.io/bootstrap.native/' was loaded over HTTPS, but requested an insecure stylesheet 'http://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css'. This request has been blocked; the content must be served over HTTPS. This page is so totally broken without the stylesheet lol.
Promises have already killed both callbacks and made it easier to centralize error handling. 
Your example makes me wonder if the biggest achievement of OO is doing obj.method(args) instead of method(obj, args).
Try having a separate infowindow for each marker, and hiding/showing that infowindow as required. for (var x = 0, length =hotels.length; x &lt; length; x++) { var marker = new google.maps.Marker( { position: new google.maps.LatLng(property.lat, property.lng), map: map }); var infoWindow = new google.maps.InfoWindow(); infoWindow.setContent('&lt;b&gt; &lt;u&gt;Hotel Code&lt;/u&gt;: ' + property.Inncode + '&lt;/b&gt;' + '&lt;br /&gt;' + property.Description + '&lt;br /&gt;' + property.Address + '&lt;br /&gt;' + property.City + ',' + property.State + ' ' + property.PostalCode + '&lt;br /&gt;' + '&lt;a href="'+ property.URL + '"&gt;Link to Website&lt;/a&gt;' marker.addListener("mouseover", function () { infoWindow.open(map, this); }); // mouseout listener to close window if required }); 
It is because it treats it like any other browser request. So you have to explicitly tell it not to cache either on the front end or via response headers. 
Yes, I'm well aware that he's not on the committee, considering I keep the meeting records. 
Hey, I've crated a web app that allows You to find other people to play a video game Dark Souls 3 together. You get into a queue, and if someone is matched with You, both of You get a randomly generated key that You can use to play together. Also, with given key, You can go to a Chat, where the key is a room name, so You can talk with each other. It works based on socket.io and vue.js 2.0. (Both the match the queue thing and chat). App is available here: [ds3arena](http://www.ds3arena.online) GitHub: [GitHub Repo](https://github.com/Krizzu/DS3Arena)
Thanks for the read. In your last example though, I think you mean: static move(point, dx, dy) { return new Point(point.x + dx, point.y + dy); } Otherwise, you can only call the `move` method on an instance, and it will look something like: point1.move(point2, dx, dy) which is weird as the value of `point1` is not used in the calculation.
Well, based on the implementation he posted elsewhere, the idea is to add two pre-existing points together, and having an `add` method that does that is totally object oriented, as non-mutating objects are also object oriented. He just got lazy with his example and newed them up inline, making it look like we're constantly instantiating these objects. If he had wanted to illustrate his approach better, he could have done something like this: var point1 = new Point(0, 0); // imagine this was defined and used elsewhere var point2 = new Point(0, 10); // imagine this was defined and used elsewhere, too. var sum = point1.add(point2); // this creates a new Point that is the vector sum of point1 and point2. That would have illustrated the object oriented approach he was trying to achieve as well as made it clear that it was non-mutating. 
Yes, you are right, this is what I meant.
Just to be clear, I was talking about a class like this: class Point { constructor(x, y) { this.x = x; this.y = y; } add({x, y}) { return new Point(this.x + x, this.y + y); } } &gt; A pure function can only access what you **pass** it, so it’s easy to see its **dependencies**. We don’t always write functions like this. When a function accesses some other program state, such as an instance or global variable, it is no longer pure. The method access `this`. But if you call the `add` method. You pass `this` along as well. In the case `point1.add(point2)`, `point1` will become `this` and is clearly passed to the `add` method when you call it. It is no global variable somewhere else defined. Therefore, according to your definition, it is pure.
It's not pure because this.x an instance variable. That's it. It's not pure. This.x resolves before Point() is invoked, you aren't passing "this" along, and your constructor does nothing - zero - to prevent x and y from being free variables. Therefore, add is impure. 
well a polyfill for a stupid browser is probably an exception to monkey patches. The smalltalk crowd used to patch object a lot too (isMySpecialThing returns false on object), but CS folks have always known that self modifying code is a major headache.
&gt; A pure function can only access what you pass it, so it’s easy to see its dependencies. We don’t always write functions like this. **When a function accesses some other program state, such as an instance or global variable, it is no longer pure.**
What is the reason you think Ember is bad? Genuinely curious
&gt; There's a difference between myObject.reduce and reduce(). Arguing the difference between `fun(a, b)` and `a.fun(b)` is not how I want to spend my Saturdays, so fine. But JavaScript's `reduce` is of the latter form, and OPs `add` can be implemented in either. What I'm trying to argue is that versions of the two functions on the same form have the same purity. What makes `collection[0]` different from `pointA.x` in terms of accessing internal state? Distinguishing between array elements and object properties makes no sense as they are both (normally) mutable in JavaScript.
Array.prototype.reduce is an impure wrapper around a pure reduce function. The following two, however, always have the same result: function reduce( [1,2,3], (x,y) =&gt; x+y ); function reduce( [1,2], (x,y) =&gt; x+y ); Here's an example implmentation - I'm not sure it works, but its close: function reduce ( collection, fn, memo ) { if( collection.length == 0 ) { return memo; } var result = fn( memo, collection[0] ); //take the subcollection //collection.shift(); var newCollection = collection.slice(1, collection.length); //call recursively return reduce( newCollection, fn, memo ); } That function above is pure. Array.prototype.reduce probably maps to something like this: Array.prorotype.reduce = function reduce( fn, memo ) { return reduce( this, fn, memo ); } The wrapper is impure, what it wraps around is pure.
But okay, I could do the same trick with my `add` method: class Point { constructor(x, y) { this.x = x; this.y = y; } add(otherPoint) { return addPoints(this, otherPoint); } } Then it also a wrapper around a global pure function.But my whole point, was, that I don't see the value of this. Given two points, `point1` and `point2`, we can say the following: 1. `point1.add(point2)` will give the same result, independent of the state of the rest of the **program** 2. `addPoints(point1, point2`) will give the same result, independent of the state of the rest of the **program** 3. the result of `point1.add(point2)` and the result of `addPoints(point1, point2)` will be the same point. Therefore, I think must be clear for anyone, that we are talking here purely about syntax, and not about semantics. You can define a pure function however you want, but I think you miss the point where pure functions really are about and what the benefits of pure functions are.
There is no (exposed) `reduce` function for `Array.prototype.reduce` to wrap. So by the same logic, `Point.prototype.add` is a wrapper for a (non-existing) pure version.
No, its not just about semantics. It is all about the implementations and syntax. Your add() function above is impure. addPoints() is pure. It's that simple. If you are referencing member variables - I don't know how many times I have to say this - *the function is not pure*. In terms of what the "value" is, the value is different to different people. Typically, pure functions are easier to predict because of referential transparency. Does that mean you shouldn't use objects? No. But that's a whole other discussion. In your case, I actually don't think there's anything wrong with your add function. It's just fine. But is it pure, in this implementation? add({x, y}) { return new Point(*this.x* + x, *this.y* + y); } No.
I'm not sure what you are tying to say, but .add is impure as it is implemented. If it was implemented as a wrapper for a pure function, then sure. 
What I'm getting at is that you are very quick to describe `Array.prototype.reduce` as a "wrapper around a pure function", but seem unwilling to extend the same generosity to `Point.prototype.add`.
load the file with the called function first, with a script tag or whatever the kids are using these days to try to keep such dependencies straight. If you have made a circular dependency then stop doing that.
&gt; But why would you write those method so that they don't refer to this? That is just bad programming.... So yeah, pretty much every well written method is impure according to your definition. Including the map, filter and reduce methods of Array. I don't think many people use this definition, as those methods are often seen as the functional part of javascript. That's not a true statement, and is highly opinionated. You can produce large, complex programs without ever using a single "this", and have them easily reasoned with. I understand that you want to have a discussion about why functional programming is "bad", but I came to tell you why your .add function was impure. "pure" doesn't mean good, it just means something particular from a functional standpoint, which you already clearly do not prefer. Also, I understand your arguments perfectly. I've been "writing" Javascript for fifteen years. 
Btw, of course, for static methods, and global functions, there is no need to use `this`. And yes, they are both powerful and I use them a lot. But if you don't use `this` in an instance method, you could refactor it as an global function, or an static method. In other words, there is no need for pure methods in your definition. 
I lol'd.
Just goes to show there is no one formula to build professional-grade software in JS. Whatever works.
Ah, good old MooTools... bless
haha, i'll definitely get around to throwing some tests in there, thanks!
One big difference between functional ("FP") and object oriented ("OO") strategy is that for OO, you ought have a distributed state and concurrency strategy up-front. The reason is because if you have even a few objects with their own internal state, then you actually already have a problem of distributed state. I think a lot of people learning OO don't realize this and they end up with very complicated state.
How would you compare it to knockoutjs?
what's the point of this
You removed your question. But you can check here: https://jsfiddle.net/pgd0wrt7/
&gt;Is having 8902 lines in one Javascript file remotely ok? Yes, bundling all your js into one file is standard practise. 8900 lines isn't even very big. &gt; Would that slow down our site? No, it will speed it up. If you can get all of your scripts in a single HTTP request that is a good thing. &gt;Also, would having a whole backbone setup, like a complete backbone app in that one file be ok? Yes, it would be expected that your app is bundled into a single file.
I would agree if this wasn't posted as sample code for google chrome apps...
&gt; So what do we do with best practices? You enforce them up to a certain point. Have a code style guide that is agreed upon by everyone in the team and try to strike a balance between people being comfortable with what they're writing and setting standards. You need to agree this with everyone, not just decide one day that this is what everyone will do because you say so. &gt; what makes a good developer? Keen eye for detail, good problem solver, good at maths, good memory, able to work out how an app works no matter if it's following a camel case or underscore convention... There is a problem I notice in the JavaScript community coming primarily from front end developers who think the best developers are the ones who follow standards the most strictly. It doesn't matter how closely you follow a standard if you don't know a single pattern and you can't work out logic for shit. &gt;Is it really context based? Entirely. If you work primarily with CSS then organisational skills will make or break someone. If you work with AI then a mathematical genius will trump organisational skills. That same mathematical genius could fall over as a full stack developer if they fail to take in the bigger picture.
Hmm, you've made some great points. Thanks! 
You'd recommend *Dart*. Not to belittle Dart or you, but that's a lot like recommending Actionscript in 2001. Great idea at the time but in ten years it'll be gone. Probably sooner. Those languages come and go, and Google is notorious for that. See the angular fiasco. We can agree to disagree, but I still think you're focusing on the wrong facet here. Again, no one is saying JavaScript is perfect or even the best option for any one use-case. But for how easy it is to pick up and learn, for the wealth of information and examples and libraries out there, there's no better place to start programming than JavaScript. The point of the article is not about the end-game of "what language should I develop my programs in", it's addressing where a new programmer should begin to learn programming concepts. 
&gt; but in ten years it'll be gone. Doesn't really matter in the context of being someone's first language. JS isn't the only language you know, is it? &gt; Those languages come and go, and Google is notorious for that. Google created only two languages: Go and Dart. Both still exist. Google is notorious for dropping Reader. Google actually doesn't drop more projects or products than other companies. &gt; See the angular fiasco. 1.x is still maintained. I don't see your point. &gt; I still think you're focusing on the wrong facet here. Having standard solutions for everything is great. Dart's homepage pretty much answers all basic questions. Everything is extremely straightforward. Also, there is great tooling. Things like fields and methods can be discovered. You can go to definition and things like that. You also get these things with TypeScript. However, TS comes with JS' fragmented ecosystem. And it makes ES6, which is already a complicated language, even more complicated. You've to google around a lot more to get going.
Thanks for that valuable info. I will try to put that together! Thank you for the reply, it was very helpful. 
great questions! we use the script engine provided by WKWebView, so it's supported by apple. in terms of security, we deliberately limit access to phone functionality (e.g., no contacts, no camera), so there's not much you can do to the user.
&gt; /r/apple might let you post if you haven't posted any other self-promotion posts in a while, and /r/ios If there is demand, absolutely. But isn't there something like this available for Android already?
Mutability makes things really damn sticky. Immutability is the bee's knees. At the core, however, it depends on what you mean by "mutable state systems" and "immutable state systems". Do you have any examples? In JS, all scalar values are immutable by default. Numbers and strings. Composite values are mutable by default, like arrays and objects. Example: function addOne (number) { number = number + 1; } var i = 1; addOne(i); console.log(i); // 1. In order to turn our variable into a 2, we would first need to `return` our result from the function, and also assign it to `i`. But with an object? function addProperty(obj) { obj["baz"] = "qux"; } var o = {"foo": "bar"} addProperty(o); console.log(o.baz); // "qux", because we mutated. This is just for the values themselves. There are also mutable or immutable bindings. `var a = 1` is a binding, and in JS, it is mutable. We recently got `const`, which is an immuteable binding, which means that this will throw an error: const MY_CONST = 1; MY_CONST = 2; This works fine, though: var a = 1; a = 2; There are ways to remedy both of these, or at least some of them, with properties, new language features and frameworks like lodash/fp and Immuteable.js. This is a grand old argument, however, and one that extends beyond the scope of isolated systems, or languages. with different languages and paradigms incorporating different forms of mutability (or the lack thereof) for different reasons. I am of the opinion that mutability often causes more problems than it causes: It makes concurrency harder, for isntance, and makes it harder to track your code throughout the application while making it easier to introduce weird side effects in your code, but it depends largely on your needs, your language, your platform etc. 
I assumed the false == part was to for the second part to evalute to a boolean, but it doesn't matter as false || console.log('hi') still executes the second part. Even if def equaled 'false' you'd have false == (false), which would return true... but why? It's not like there is another || after this.
&gt; Yes. You have to "Google around a lot more". That teaches you fundamentals: learning documentation, the concept of syntax, terminology, the whole environment - in other words, "How to learn to program". Compared to Dart, you have to google around a lot more if you use TS, because there are more issues. Issues which get in the way of programming. Like why doesn't the compiler doesn't know about WeakMap? Which of those many flags should I use? How do I get tree-shaking to work? Should I use SystemJS? Why does it complain about this JS function not being a constructor? This crap is pure noise without any intrinsic value. It's all about dealing with the ecosystem and not about programming. None of this can be transferred to other languages.
"What programming language should you learn first?" I literally do not care, go with whatever you think is cool or fun or will get you hired or get you laid or whatever. I'm just glad you're into programming. LEarn one, you'll learn another quickly.
I have the same here, literally nothing happens after clicking on 'Try Winds RSS' apart from this error popping up in the console. (FWIW: macOS, on both Chrome &amp; Safari)
Completely disagree. Instead of learning a template DSL, just learn JavaScript. 
Look through the replies to this comment. Template DSLs have a lot of pros that Template strings just don't.
cli tool for traceur built with bash. It still undergoing development though https://github.com/zombieleet/traceurCli
https://jsfiddle.net/oj7r13er/ function textWidth(text, font) { let canvas = document.createElement('canvas'); let ctx = canvas.getContext('2d'); ctx.font = font; return ctx.measureText(text).width; } console.log(textWidth('hello world', '12px arial')); console.log(textWidth('hello world', '18px arial'));
 console.log('/\\')
"/\\\\"
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Escape_notation
Thank you, this is an elegant solution
I created (yet another) HTTP client for the browser. I know this space is already fairly cluttered. My main inspiration came from writing a lot of Express code in the last couple of weeks building an API, and finding myself really loving the middleware pattern Express uses and how it encourages you to write very DRY code. It occurred to me that API calls from the client could really benefit from this kind of workflow. When writing JS heavy web apps I find myself repeating a lot of code for each request, particularly when it comes to authentication. I'd encourage you to read the docs and give it a try. It's available on NPM or can just be grabbed from the Github repo. [It can be found here](http://github.com/ergusto/ptth). 
The point is to provide a visualization of the metrics collected on various Javascript frameworks. This can be useful in understanding approaches to building applications as well as getting perspective on the inner workings of frameworks and libraries you may be using. 
I thought I'd share a small personal project I completed using Typescript. **Purpose** Create a view showing the listings of my favorite TV channels so that I can look up what's on TV, from the TV, while I'm sitting on the couch. **How it works** I press a button on my TV remote and the TV switches from shows to the TV listings grid in the original topic link above. A Raspberry Pi with the Chromium browser full screen showing the listings page is plugged into an HDMI port on my TV. There is no user interaction other than switching TV inputs. The grid refreshes and scrolls to the bottom automatically after 10 seconds, then repeats again from the top. **The code** The Typescript code associated with this page can be viewed and stepped through, as source maps are attached. Use your browser developer tools to step through the Typescript as it executes. **What happens** * Function "main()" is invoked on window DOMContentLoaded. * JSON data for the current listed are requested through and XMLHttpRequest. * A series of collections are iterated over to build the HTML that is the listings content. * The cell widths are calculated using show start/end times and some extra adornments are added, such as "cont'd", and start/end times in human readable form. * To scroll the grid a css transition is calculated based on the size of the browser window, channels listed, and the cell height of each row. * A dynamic css sheet is requested based on that information. See http://tv.codebot.org/?method=css&amp;height=1337 as an example. * When the hour changes new data listings JSON is requested and the process repeats.
When you prompt the user for a number, it will be returning a string, not an integer. This means that both variables num1 and num2 are STRINGS and not integers. Because of this, when you try to add them, the + will mean concatenation and not the mathematical addition operator, so you will log "12" instead of 3 if you were to have 1 and 2 as the entered numbers. However, there is a native javascript function to help with this problem. parseInt(x) will return the number in the integer form so that you can work with the variables in a mathematical context and not as strings. Does that help? 
But can it really be truly useful? I think it's super neat and a really cool project, but I'm afraid I don't see how it's beneficial to so deeply encode in metaphor what is otherwise just a matter of hierarchical relationships. 
It might be a good idea to think about it this way. If I was to make all the methods in this file public, could some of them be re-used in other applications or other files to do a similar task? Could I make them more generic and pass in a parameter so they work with this function but can be used in a generic way with another parameter from another app in the future? For example, a date formatter, a string prefixer, a calculator of common operations, a sorting function, an array manipulator, a translation fetcher, an Ajax call to an endpoint to fetch a piece of data, or a data transformer. If any of these functions can be refactored to be more generic, go ahead and turn them into standalone modules. What you'll end up with is a leaner controller style file that makes decisions and stitches together functions into a more powerful functional service. I hope that helps.
Thanks! That makes sense. Can you send me a link to a JavaScript file, of a website, (i.e. not a plugin, but a full webpage) that uses the module pattern approach? Thanks!
Indeed, the template pattern is just about the only time we're *supposed* to use inheritance. There are, unfortunately, tons of tutorials out there that say if two classes have common code, then that common code should be refactored into a base class, but as it turns out that advice is actually wrong. &gt; Don’t inherit publicly to reuse code (that exists in the base class); inherit publicly in order to be reused (by existing code that already uses base objects polymorphically). ... The purpose of public inheritance is to implement substitutability. -- [Herb Sutter](https://www.safaribooksonline.com/library/view/c-coding-standards/0321113586/ch38.html) Every use of inheritance should be an implementation of the template and strategy patterns, and if it isn't, then odds are good we're misusing inheritance.
`(Math.random()*16777215|0).toString(16)` You get color value in decimal, and convert it to an HEX
There has been some speculation on it being some interpreter optimization magic, and I'd wager it's something like that. Good catch on the expression type.
Looks quite nice! One improvement I can think of for the intervals is to let components with identical intervals use the same timer. This is advantageous for battery usage, because it only needs to wake up the CPU once for a batch of work instead of often for tiny units of work. In addition, it might give a more "clean" impression when several UI components update through a synchronized timer rather than all individually. Of course the downside is that the first interval occurence for a newly mounted component typically occurs within a timeout less than the full interval, which may or may not be a problem. For example: In one of my own projects I have a `&lt;Timestamp /&gt;` component that displays relative timestamps ("Just now", "1 minute ago", etc..."). A typical page can have quite a lot of such timestamps, so I let them all be updated once every 30 seconds through a synchronized interval, which I think gives quite a calm appearance.
I take it that the number there is 0xFFFFFF?
Not an expert, so don't take my word as gospel: # Mutability ## Desirable * Generally intuitive to learn (given that imperative programming is often the starting point for most people) * Fits very well with JavaScript's dynamic, state-driven world (i.e. intuitively we have a document that is continually changing its state in response to user input) * Can be leveraged to make code very computationally efficient in comparison with its immutable counterpart (since objects can be modified, instead of entirely reconstructed) ## Undesirable * Bugs can quickly be obscured by being tied to the state of an object, which makes them difficult to fix * Not knowing the state of an object at a given point in time can lead to verbose code that tries to capture all of the desired scenarios # Immutability ## Desirable * Easier to reason about mathematically, and to prove the correctness of your programs (a priori) * Geared more towards a functional programming style, which depends on breaking a program down into small, stateless functions (again: easier to formally reason about, and building larger programs just come down to composing these stateless datatypes and functions accordingly) * With certain languages, you can pattern-match on immutable datatypes, which is much easier to do than analysing your variable's state with `if-else` blocks ## Undesirable * In many cases, computationally inefficient, as it requires more space in memory for building/rebuilding data structures * Functional programming scares many people away; on a team, you are far more likely to have your workers well-versed and confident with imperative/OOP styles
I fucked up my math.. :(
Interesting. One thing we thought about is doing something like this for the Key events, instead of adding one listener for each key we could have only one listener with all key events. Thanks for yor input, we will discuss it :D
I mean, it's totally possible. Have you seen what asm.js does to source? This: size_t strlen(char *ptr) { char *curr = ptr; while (*curr != 0) { curr++; } return (curr − ptr); } Becomes: function strlen(ptr) { ptr = ptr|0; var curr = 0; curr = ptr; while (MEM8[curr]|0 != 0) { curr = (curr + 1)|0; } return (curr − ptr)|0; } Before translating to JS so that types can be guaranteed. It actually kind of blew my mind when I realized that asm.js programs will run in ANY JavaScript/ECMAScript interpreter but the reason it is so fast in specific engines is because once they can guarantee the types they can optimize behind the scenes to make it amazingly fast. So, it might be something like this. I went from absolutely hating JavaScript years ago to loving it once I understood it's nuances more. These days I have a very love/hate relationship with it. It gets so much hate because of it's early implementations and issues that have mostly been solved, but there are legitimate reasons it is a mess, still, that the same average coder doesn't even know. Let's just say I'm (initially) *very*, **very**, skeptical when we're interviewing someone and they say they are a JavaScript expert.
The Object Oriented languages are a bit dangerous because they do not define the type of the `this` parameter at all. For example, consider the function `add` which is always returning classes of type `Point`. Even though you might have multiple subclasses working on the data, this function is not re-usable even though inheritance kind of suggests it will be. To illustrate the problem, just subclass the `Point` class to class like `Point3` and forget to override the method `add` it will **not** be returning classes of type `Point3` but objects of the parent type `Point` unless you override the add. http://codepen.io/teroktolonen/pen/yVyoKr JavaScript does not give any warnings about this at all! And even a strongly typed language does not know that the purpose of the function is not to convert some values to type `Point`, although it would complain if you still try to use it as `Point3`. With functional approach in strongly typed language there would be no problems. You would have a function parameter of type `Point` and it would be returning value of type `Point` and you could not have done mistakenly conversion from the `Point3` to type `Point` because compiler would have either selected the correct function automatically or created error. 
&gt; This can be useful in understanding approaches to building applications as well as getting perspective on the inner workings of frameworks and libraries you may be using. It is totally enough. I really liked it, as I said. It reminded me of the technocore space in Hyperion by Dan Simmons, which describes an abstract digital space in which huge cities made out of data and processing structures are roamed by powerful AI who seceded from humanity. I was specifically responding to the guy who said it was useful though for understanding and building applications and frameworks. Like.... okay.... maybe. But probably not. Usually. Really neat though. 
saved
&gt; It makes concurrency harder, for isntance this is irrelevant in the case of web fronted applications, because you're running on single thread only, so you can't really get race conditions in the same manner as in multi threaded environment. &gt; makes it harder to track your code throughout the application In my experience it was quite the opposite- the redux app is much harder to follow, because if you need to trace a change and how it is applied you need to find the reducer. To find that you need an action name, to find that you need to look into action creator. So much boilerplate, so much indirection. That's 3 files. Whereas with MobX, whole app state manipulation is just simple assignment in one place in one file. Data getters are like functions in an excel spreadsheet. Very minimal and easy to grok.
Mostly comparing our Redux code to our Backbone code. With redux and react, we have a SomeComponent, that responds to ACTION_FOR_SOME, that goes to the SomeReducer. With backbone, we have views getting data from models in a magicla fashion, sometimes with even more magical syncing features that are unpredictable, at least given cruft. As for race conditions and concurrency problems, and similar, lack of threading is not a guarantee. You oculd hypothetically get them from using web workers, and it's quite easy to get messy code from aynschronous operations.
Yeah maybe I havent formed my question well, I'm not saying all my knowledge of programming will disappear, I'm just wondering what do people think of js future, will wasm slowly take over or is the number of programmers who work on js and the whole ecosystem kind of too big to replace any time soon.
It includes all of the libraries and everything that they use: jQuery, charting library, etc
A lot of people really like JS. Even if it is superseded by WASM, people will just move on to a superset language like TypeScript and compile that to WASM. 
Hey Throwaway, I just got done trying out your recommendation and it works great, exactly how I wanted it to. I have one other question while on the topic of audio and instead of making a new thread, possibly you could be of help The other comment that posted in here said it was bandwidth inefficient to load all the audio at once, which makes sense, but what would be the most efficient way to load the audio on demand when played? Thanks for any further input!
No. Learn COBOL.
Running tests in a for loop is generally a bad practice unless you write as such that you can clearly and easily identify exactly when/where the test failed. So with your for loop, I would add in the expect a failure message; eg expect(someTest).toEqual(someValue, 'failed at index ' + i). The other thing to keep in mind is tests are usually for some other reason than just the test themselves. In particular, using tests in test driven development, so you should write tests where it's 100% clear just by looking at the code what the code is supposed to do.
I see, thanks for the explanations, now it starts making sense. Too bad that this means there's no easy way to find out what part of the code they wrote themselves to make it so slow.
Yeah, good call. I added that in and failed some tests on purpose, having the messages there helps pinpoint the exact spot where it failed. 
nice, that sounds good. Yeah I was debating to just trimming the files to save on space and load times. So probably trim the audio before uploaded to the server so that the file is just the required duration and smaller file size?
Well, if you are looking for simplicity, I don't even use the action creators :) I dispatch directly in mapDispatchToProps, and I find it quite comfortable! (I don't use action-type string constants too, despite the fact that Redux creator actually encourage their use)
&gt; Can-restless for the restless: https://www.npmjs.com/package/can-restless
I don't have a many-years-long programming experience to wave, but I think you should not focus on a specific language. The future is for polyglots! There's very much to learn from how different languages approach the same problems. You'll gain from other languages so much that you won't even care about the specific language. I especially encourage you to take a look at a classic language such as python or ruby, then to improve your skills on some "strange" language as clojure (a lisp dialect immutable by default) or haskell (considered difficult, great inspiration). They are so exotic you'll rarely use them on the job, but they will blow your mind! As for the WASM issue, I think that will take many years. Just think about CSS3 and how many browsers support it smoothly...
Yeah I agree with you there but on job posts people request to have X years in Y language and I do think 1-2 languages should have your main focus. Now I have programmed in C/C++, Java, C# and Ruby I kind of just liked Node.js and the whole ecosystem so I'm mainly working with that now and quite frankly I'm getting a lot of hate because of that as a lot of programmers see it as something only kids trying to be cool use.
Actually promises or async are not going to help to have predictable state modifications in the callbacks. What Redux has over Mobx is that reducers contains and declare every possible way the state can be modified. This will certainly help consistency in a bigger app. Mobx wins with the terseness of the code, but adds lot of "automagical" behavior that could be difficult to scale or extend in the future of the app. I found it also more difficult to debug, in certain situations. I think any of these have an use case, so "it depends" :) OP: take a look at clojure, that has immutable data structs by default.
Here you go: http://codepen.io/Paulooze/pen/YpPaqM?editors=0010.
strategy pattern in higher order functions, composite in the DOM singleton in commonJS (every require is cached), prototype is the base of JS oop, template Method is n reacts lifecycle hooks, factory in angular services. 
Well... You could always try to ask them. Maybe they want to keep it a secret and maybe they will tell you the name of the algorithm used or whatever.
The upper boundary doesn't work. You can fly right through it. (Using Chrome 54, haven't tried anything else)
&gt; declare every possible way the state can be modified. This will certainly help consistency in a bigger app. consistency problems? I never had an app in an "inconsistent" state, doesn't matter if I used mobx or redux. Developers seem to think that the view as a pure derivation of your state is an attribute specific to redux, but that's just not true. A typical MobX app is also a pure derivation of state. There are no inconsistencies-you just change your state and your UI rerenders. Predictably, reliably, efficently. Just like with Redux, only without all the boilerplate, without wasting memory on discarding and recreating the state every time. Like you mentioned-if you really want to write nice apps with immutable data, use some langugage which is actually made with that in mind. Elm or clojure are great choices. Javascript has only mutable data natively. It's only fitting that it's easier and faster to work with those.
Hi /u/HappyCoder2016, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `Happy Coder - YouTube`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [youtube.com](/search?q=%28and+site%3A%27youtube.com%27+author%3A%27HappyCoder2016%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|8|100%
My personal take: If it's an array of primitives (e.g. strings)/we aren't asserting a key in an object (looks like this from the example) and the array isn't too long (e.g. 6 items), then use deep equality: ``` expect(foo.bar).to.deep.equal(['barFoo', 'barFoo', 'barFoo', 'barFoo', 'barFoo', 'barFoo']); ``` The reasoning is: - Error messages from assertion library should tell you what's wrong (e.g. different lengths) as well as values so you can visually check - My personal opinion is that expectations should rarely be dynamically generated; they should be clear/obvious to debug and not doing the same logic as the source code (as that would be redundant and unnecessary -- same as verifying `true === true`) For an array of objects, use something like `_.pick` and compare to a hardcoded expectation For long arrays, use `new Array(100).fill('barFoo')` For dynamic length arrays, the test shouldn't be asserting values of dynamic length. You are probably missing mock data somewhere
If you're coding defensively, you might want to consider for the case where arrays A and B are of different lengths: var minLength = Math.min(a.length, b.length); for (let i = 0; i &lt; minLength; i++) {}
TIL that i use patterns
You can put a catch wherever you want. I know most people will just pass on the error when dealing with callbacks: function callback(err, data) { if (err) { return next(err); } } Instead of dealing with it right there anyways. That's not any different from `.catch` applied at the end of a `.then` chain. The `err.stack` of the error passes to `.catch` seems to be just fine. The following code points to exactly where the rejection occurred, at least on Chrome. (function test() { function delay(ms, thing) { return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(thing), ms)); } function timeout(ms, err) { return new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(err), ms)); } Promise.race([ delay(700, { name: 'bob' }), timeout(500, Error('request timed out')) ]) .then(x =&gt; x.name) .then(name =&gt; delay(ms, { name, score: 123 })) .then(x =&gt; x.score) .catch(err =&gt; console.error(err.stack)); })();
Thank you for the stack trace. The issue has been fixed!
So what you're saying is, not to test against the actual data but to make some new data and test the functions that way?... You ever have one of those moments where it's like duh it supposed to work that way i'm just an idiot... I just had one of those moments, thanks. Is it cool to test against actual data and test against randomly generated data? Edit: Even with BDD?
&gt; The push() method adds one or more elements to the end of an array and returns the new length of the array. push() does its real work in-place on the array you're calling push() on. Its return value is just a length in case you care about that. The "real work" doesn't have to go in to the return value.
Yeah just googled it and you're right. So I'm guessing setting the push function to a variable, which I did in the second function, will force it to return what it was meant to return, which is the length. But if I make it push my array, and then only return the array, I see the work it did and don't have to see what it was meant to return, like in the first function? THanks for the fast response. I think I get it now.
We'll just have more options to use on the web, that's all. We already have another options for server, desktop and mobile apps and JS is still used on those. I really don't think JS will die, at least not anytime soon.
Nice job! Like it.
Dunno about Scala, but in regularly minified/browserified/uglified code the actual content just... starts at someplace, obviously after all the required libraries. Start from the end, work your way backwards and pay attention to comments - you might luck out!
It has its problems, but I much prefer Addy Osmani's JavaScript Design Patterns book, which is also [available online](https://addyosmani.com/resources/essentialjsdesignpatterns/book/). I recommend this to non-JS programmers all the time. This came out when I was doing a lot of C# and Java and I found I finally understood and was able to easily apply certain design pattern concepts after reading his book. I have a few small problems with the dofactory patterns list. The descriptions and code examples are so reduced and generic that it sometimes isn't clear what the pattern actually is good for. In fact, sometimes I need to know about a design pattern first before the description begins to make any sense. Some of the implementations also are so boiled down that they don't really show a way you'd actually use the pattern in real life. Almost all implementations rely on inheritance, which is fine now with ES6, but is very burdensome in vanilla browser-safe JS or FP. And this is a small quibble, but it really wish the site would show related patterns for each pattern, since some many of them solve very similar problem (e.g. [Adapters](http://www.dofactory.com/net/adapter-design-pattern), [Bridges](http://www.dofactory.com/net/bridge-design-pattern) and [Facades](http://www.dofactory.com/net/facade-design-pattern)).
Well done! 
this is awesome, keep up the good work!
good stuff
It wasn't computer generated?! It even says "Narrated by Peter Baker" at the beginning.
Wow. If that's a real person, three things: 1. Wow has text to speech become so good that I was convinced that's TTS. 2. There's some pretty significant audio quantization going on. The audio sounds rather computer generated. 3. Boy do I feel silly. Edit: Just looked up Peter Baker. I guess his voice just sounds sawtoothy and quantized to me. Either that or maybe his recording setup is doing this? Am I going crazy? Does anyone else hear this?
Wow! THIS is called God Mode :D
Thank you I'm glad you liked it :) Honestly I just wanted to use something quick and Firebase did the job in that regard. It was easy to set up and it's super simple to deploy using the CLI. Have never used Google Cloud or compute so let me know if you think any would have been a better alternative 
i see it's still running! How much has it cost you so far, especially if you don't run ads on it. And why not run ads on it?
Is coupling your UI to your backend a good idea architecturally speaking?
i is just telling it what page to go too, it needs to keep cycling the pages until the entries on the page aren't equal to 10, which is what the global.count = info.length; part of the code does, but it doesn't seem to be working
 var content = document.getElementById('content'); content.innerHtml = 'Hello'; The above will add a string that says 'Hello' to an element with the id content. 
I thought it was computer generated as well. Felt very unnatural in pace and monotone.
You would be better off using a while loop. I am not sure what exactly you are trying to do but something like: while (info.length === 10) { 'code that eventually sets info.length to something other than 10' } Something like that will run until info.length is not equal to 10. Rather than a for loop which runs until it hits whatever number you specify it to stop at. Make sure there is something in the loop that will eventually cause info.length (or whatever variable you use) to something other than 10 otherwise the loop will never terminate.
You have the right idea on where to start. function interest(amount, rate, years) { 'your code' if (condition necessary to call interest again) { interest(amount, rate, years) } That is one of a number of ways you could go about it. It is hard to help without more information on why you need to write a program this way.
Not quite, see http://exploringjs.com/es6/ch_maps-sets.html#_iterables-for-entries for how to loop with key/value using .entries() and further down for easy array operations by using the ... operator. The amount of typing involved is so minimal that personally I can't justify the 57KB of additional minified code.
Are you using the console to check for errors? Like my first comment said, you are not using the correct syntax for a for loop. You should also use simply: var global = 10 I think using global.count without defining global should cause an error. Later in the code you could change the value of global to info.length.
I saw this on HN yesterday and spoke about it a bit with a colleague. We're gonna use it for a current low-risk project at work to evaluate it. Looks great, thanks for sharing.
The `return` isn't needed in your example, all objects (including arrays) are reference value types... function pushArr(ar, val) { ar.push(val); } let a = []; pushArr(a, 'foo'); console.log(a); &gt; ["foo"] And... function mutObj(o, key, value) { o[key] = value; } let obj = {}; mutObj(obj, 'foo', 'bar'); console.log(obj); &gt; { foo: "bar" } Aside from using `Array.prototype.concat`, you could also do: function pushArr(ar, val) { return ar.push(val) &amp;&amp; ar; } let a = []; console.log(pushArr(a, 'foo')); &gt; ["foo"] Do note the substantial difference with `concat()` though, that it returns a _new_ array; there's nothing wrong with that, but it's something to be aware of. let a = []; function concatArr(ar, val) { return ar.concat(val); } let ret = concatArr(a, 123); console.log(a.length); &gt; 0 console.log(a === ret); &gt; false 
Clear and no more jargon than necessary. Well made!
Have you **ever** seen a webpage which allows you to load 50K-100K (let alone 1M) images while scrolling, but staying at the same page, and without facing huge problems with the performance and/or memory consumption? If yes, post a link right now, I'll enjoy that site. There is **a lot** of infinitely scrolling webpages, but they **all** (I repeat: all) become unusable in **any** (I repeat: any) browser at some point (after you've loaded a fair amount of new content into the same page). Browsers cannot load an infinite amount of new content into the single page, and there is no way to fix that, no matter how hard you try to reuse/remove the DOM nodes, and GCs cannot help here (strictly speaking, they can slow down the process of increasing RAM usage, but they cannot prevent the browser from eating all available RAM, without any chance to free some memory by the OS). But I'd be glad to be proven wrong on this subject, if anyone would show me the demo of how to load 1M **different** images staying on the same web page... &gt; Memory is only freed when it is needed. My own experience shows that I can never rely on this assumption. Yes, the OS can free up some amount of RAM when it decides to do so, but the problem is that it **does not do that as soon as the memory usage hits some predictable limit**. But the average user won't wait. As soon as the browser freezes, the user will close the tab, and that's all. On Windows, I've noticed that the OS will do its job freeing everything that is possible, but this happens **only** after I turn the computer into the sleep/hibernate mode, and then return to the same page again. But this behavior is far from being reasonable. You simply cannot tell your user "Please, hibernate/restart your OS, and then come back to our site!"
I'm sorry, I have some really bad news for you. I think Javascript is doomed: http://www.bbc.com/earth/story/20150602-how-will-the-universe-end . PS: You don't understand how knowledge works in general, and programming languages in particular. Go to edX or Coursera or a huge number of other sites and learn the basics.
Yea, if the normal data is hard to test against (e.g. it's hidden in objects in an array), then it's easier to derive it (e.g. extract values from the objects) and test that. It's better to test with actual data/what you would expect so your tests are consistent/obvious. There's something known as fuzzing where you feed random data to an application/library to see if it breaks in interesting ways but you can't really test anything -- only get different stack traces if it does indeed break. I typically don't go this far as I expect people to use my library in a sane manner and it adds a whole lot of unnecessary edge case support/testing (e.g. nobody is going to pass `{}` as a number so why would I force type coercion).
What about neither and use Bucklescript, Purescript or Elm then ? They are all 3 better when it comes to types.
I think trying to link reduce w/ memento is stretching too far. I've heard some say that classical GoF patterns are more examples of deficiencies w/ java or c++ than patterns to adopt in other languages. With that said the iterator pattern is present almost everywhere in js.
TypeScript and Flow are both superset of JavaScript, while the ones you mentioned are totally new languages. And if we should consider other languages, then there are ClojureScript, Scala.js and many others.
Thanks for the pointer! My brain moves like a rotten sloth so it will take some time to absorb this...
Haha this is hilarious.
Not everyone's going to jump ship. I think introducing types to JS will help bring more people on board.. not to mention usage of 3rd party tools that have type definitions already will save a lot of time.
 function interest(amount, years, rate) { if (!years) return amount; return interest(amount*rate, years-1, rate); } There, your homework done for you. Now why does this work? Think of it like this. You know that the only thing the function should be doing is taking the amount, multiplying it with the rate and subtracting a year until there are no more years. So, you end up with the above, where you continuously call the same function, subtracting one year at a time and timing the new amount with the rate, until years = 0, which in JavaScript is a falsey value, therefor the early return statement in the start.
Use AngularJS. You load the JSON with the http service into a variable, and then with Angular you can bind the data to HTML with ngRepeat and the {{item.information}} template handlebars. As you add more items your HTML dynamically reflects the changes. If you have errors in your data you only need to update them in your JSON file and the HTML will automatically match up. If you're feeling extra ambitious and want to over-engineer your project just a tad, Aurelia is a wonderful modern alternative, and it does this kind of thing just as well. If you're in a position where you need to learn your first JS framework for a big new project, I would recommend Aurelia. You use fetch to load the data just like Angular, and then bind it with their repeat.for="item of yourData" and ${item.information} in the HTML. It has lots of other advantages like an excellent router, component-based HTML design and excellent support against future standards like Fetch, JS modules, shadow DOM, web components etc. There are many years of relevance ahead for that framework. In either case, you'll have to spend a good 10 hours in tutorials and guides to get started with either framework. That will pay for itself though in future efficiency and resume bragging rights! These data-binding frameworks are purpose-built for turning raw data into HTML. The one thing I can heartily discourage is trying to roll a solution yourself! Much too much work, and after a good week of building debugging you end up in the same place.
Sure thing! You'll probably find yourself using the variable a lot, though, so it might be wise to rename it to something like 'dt' (delta time).
Nice looks like a winner
No need for AngularJS for a simple thing as this. Take a look at jQuery to request your JSON file (jQuery.get), go at a random index of that file and then append the quote to an HTML selector or replace it. $('#myQuote').html(data.quote) 
&gt; Overhead. jQuery will add 30KB to your page size. Wow! Much overhead. People call a JS file of 30KB overhead meanwhile they are using multiple images on their website that are larger than 1mb each. &gt; When you put Vue in charge of the DOM you don’t want to have jQuery in there messing up the place. You are dropping out jQuery because you think it's messing up the place. Meanwhile you are altering all kinds of stuff to make your Vue implementation work with Bootstrap? You are removing something that is tested and used by thousands of developers for the sack of what? Implementing more fixes to make your solution work? Use the latest greatest? Create extra technical burden for the next guy? I really think your downsides don't weigh up to the extra **** you are creating. 
I'm using node so file size isn't such an issue in my case
+1 to all of the above. I hate this new era trash journalistic style of "stop a. do b." Which are almost always totally baseless and subjective to the author's needs. I don't use jQuery anyway but thanks for saving me a click. 
&gt; Create extra technical burden for the next guy? Reason enough not to do this. There's nothing worse than joining a project where previous developers are gone and seeing a custom modified version of a framework.
As I said above I don't want to use any kind of framework. I want to get confident using pure JavaScript before I delve any deeper. Never the less, thank you.
As I said above I don't want to use any kind of framework. I want to get confident using pure JavaScript before I delve any deeper. Never the less, thank you.
Seems like what I'm looking for. However the usage of CSS instead of JSON confuses me greatly and I can't really comprehend why and how this works. But thank you.
I simply misuse the CSS pane on codepen.io to "simulate" an external file. You need to replace this function's content with the actual code to retrieve the JSON data. For exampe by using [XMLHttpRequest()](http://stackoverflow.com/a/3038972) or by [loading another JS file](http://stackoverflow.com/a/4634669) containing only the JSON data as variable, or by [loading said file regularly in your DOM](http://javascript.info/tutorial/adding-script-html#external-scripts), or you can ignore separating code and content and write the JSON directly into the file that displays the quotes - be creative :)
If you're using an `.eslintrc` file, you should add this: "env": { "browser": true }, "globals": { "PIXI": true }
Honestly? It's alright, information all seems fine- but it's not massively interesting. It looks more like a powerpoint presentation than an animation to me, is a bit slow, voiceover is too monotonic, lacks music, sound effects, etc, needs a conclusion and some design issues (the (4) isn't *visually* centralised, non-hanging bullets, some weird kerning, etc). Edit: I realise in retrospect that this comment is maybe a bit dickish, but was just trying to provide some unbiased crit!
yeah i put in the answers right but it keeps saying that i have the wrong substring for "January" perhaps i am doing something wrong?
How did you come up with the name? What were some of the other possible names?
That 30kb is rather useless though, that's my issue with it. If you're developing for IE9+, all it does is add an abstraction layer over vanilla JS (what benefit does that bring?) in exchange for extra data to travel over the network and significantly (though likely still not that noticeably) worse performance. Just... *why?* Can you explain why I should use it?
I put together some code that does what I think you want to do. I tried to keep it very simple. The comments make it look way longer than it actually is. The following code does no error checks whatsoever, but it should give you an idea of how you could solve your problem. Feel free to ask any questions you have. # Again: The following code is deliberately very, very basic. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Random quotes&lt;/title&gt; &lt;script&gt; // Wait until the entire page is loaded. Some prefer to put their // &lt;script&gt; tags at the very bottom of the &lt;body&gt; instead. I like // to keep everything in the &lt;head&gt;, though. document.addEventListener("DOMContentLoaded", function () { // Get the contents of the JSON file. We need to pass a // function as a parameter because the script will not wait // for the HTTP request to end. requestFile("data.json", function (response) { // response holds the file content as a string. You // have to parse it as JSON in order to access the // data in it. var data = JSON.parse(response), // Now get whatever you need from that newly created // object (an array in this case) quote = data[Math.floor(Math.random() * data.length)]; // Get the HTMLElement in which you would like to display // your quote and set its content. document.getElementById("myquote").innerHTML = quote; }); }); // A rather simple function that uses XMLHttpRequest to fetch a // resource from a server. Its parameters are a URL string and a // callback function. function requestFile(url, callback) { // Create a new request object. var request = new XMLHttpRequest(); // Set the onload event handler so that you can react to the // request being done. request.onload = function () { // Call the callback function and pass the response as a // parameter callback(request.responseText); }; // Set some options for the request. request.open("GET", url); // Start the request. request.send(); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="myquote"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 
using angular for this is like killing pigeon with nuclear warhead.
Component has issues that I saw using Chrome (Android). Each time I entered a character the keyboard disappeared requiring me to touch the field to make the keyboard reappear.
Does anyone else cringe when they see unnecessary DOM access in event handlers? For all the progress and "best-practice" suggestions JavaScript has had over the last couple years, let's not forget the basics. Some code review: // Pull the vars out of the handler. // Encapsulate the vars and method however you please. let passwordInput = document.getElementById('txtPassword'), toggle = document.getElementById('btnToggle'); function togglePassword(e) { e.preventDefault(); // Technically you don't need the identity operator here, but it's not a bad habit. // Only the string 'password' can match the string 'password'. if (passwordInput.type === 'password') { passwordInput.type = 'text'; // Use innerText. There's no reason to make the browser parse this string. toggle.innerHTML = 'Hide Password'; } else { passwordInput.type = 'password'; toggle.innerHTML = 'Show Password'; // Same. } } 
I´m studying programming so I´m a noob xD I´d like to know what is ES6. Thank you :)
Sails has gotten a pretty bad rep over the last year. Mike McNeil got in a huge public fight with a co-maintainer, lots of respect lost. Waterline (Sail's ORM) still sucks, shows no signs of getting better. Personally, I still use Express for all of my serverside stuff. I've tried several different frameworks all had their problems. I found Express to be beautify simple, It's easy to move code around and refactor. You will likely miss a TON of stuff that Rails or Sinatra gives you. 
Yeah my experience has been the same as /u/bel9708, Express seems to be where it's at at the moment. 
That's a real shame about Sails and the kind of insight I was hoping to get, thanks for that. Yeah, Express seems like a safe approach if for no other reason than avoiding crap, but I worry about all the things I'll miss, like you said. Are there good/recommended libraries for sessions, auth, params validation/coercion, and JSON view creation? What about an ORM comparable to ActiveRecord? I've mostly settled on [Grape](https://github.com/ruby-grape/grape), [grape-entity](https://github.com/ruby-grape/grape-entity), Devise, and Rails for its bootstrapping and ActiveRecord.
ES6 is ECMAScript6, the new syntax and features of JavaScript which you can now use. Some older browsers don't support this yet, so that's why I am using babel to transpile my ES6 code to support older browsers.
It was a play on turbolinks and I am a diesel fan. I didn't really think too much about it beyond that.
Everyone seems to have a pretty dreary perspective, but yes the Sails drama drove me away from it too. http://nodeframework.com/ Has most nodejs frameworks and their github stars. It's a good place to get an overall view of what's available. Personally, I love [FeathersJS](http://feathersjs.com/). Besides being active and having clear milestones, the userbase is growing really fast. Feathers is very small, built on top of express and socket.io (fully compatible with both), works well with front-end frameworks (if you're using one), and it's service oriented. [You can read more about Feathers here](https://docs.feathersjs.com/getting-started/introduction.html). As far as other frameworks go, besides the standard express alternatives (hapi and Koa), there's [Adonis](http://adonisjs.com/) and [ThinkJS](https://thinkjs.org/) which some people seem to really love, but who knows if they'll take off like Feathers has. 
As everyone says, sails is no good. I haven't used any other node MVCs. To be honest, if using an MVC framework is a higher priority than leveraging the useful features of Node for the particular project you're working on, I wouldn't use node for it.
I'm of the opinion that Node's most novel features are wasted on most APIs. The things I find most appealing about a node backend are TypeScript, less context-switching, the constant performance improvements in V8, and Immutable.JS to a lesser extent. That said, I'm not willing to reinvent the wheel and the benefits offered by a mature framework can pay off immensely as a project and team grow.
Yeah it's kind of disappointing to be honest. I have more or less rage quit using node in the backend unless I specifically need something with high IO performance and don't feel like using go. For most of the work I do MVC's are a huge help.
What is it you're trying to add? Why not contribute to documentation/education instead?
&gt; If yes, post a link right now, I'll enjoy that site. I'd happily write a quick demo, but I'm not even sure where to get 1 million different images. If there was a way to find a directory of those images I could probably write up a quick proof of concept. However, I could write up a proof of concept that generates images, or just generates random text. Would that be okay with you? Regardless, sites like Facebook, Instagram, twitter, etc make a large use of infinite scroll, and I've never encountered much of an issue on those sites. Given, my computer is pretty good, and I don't pay much attention to memory usage. But I'd assume if these kinds of things resulted in decreased performance over time, which would be a detriment to the users, then those sites would avoid that, as keeping users browsing in their site is their main source of revenue. &gt; There is a lot of infinitely scrolling webpages, but they all (I repeat: all) become unusable in any (I repeat: any) browser at some point This is an assertion, not a proven fact. You must provide reproducible evidence that this occurs on modern browsers. You are the one with the burden of proof, as you are the one claiming that these memory leaks occur. I am claiming that modern browsers do not have this issue, and I can not prove a negative claim. &gt; Browsers cannot load an infinite amount of new content into the single page, and there is no way to fix that, no matter how hard you try to reuse/remove the DOM nodes, and GCs cannot help here This is an assertion, not a proven fact. If you were showing thousands of pictures, you could easily display them with only tens of DOM nodes at once, and simply move around those nodes, reusing them perfectly. I cannot see a situation where that would result in a memory leak, unless you're considering the browser's cache, which is usually on disk, not in RAM.
That was great! Are you making these?
It's not dickish at all
Yeah, I fear I might end up in the same place. I can get most of what I'm looking for in Java by way of Spring Boot, I just find its love of magic a little intimidating.
Feathers looks promising! Thanks for the suggestions!
Glad you liked it!
Nice, this is nice.
&gt; Not sure if serious Not sure if serious. Choosing yarn over npm is a no-brainer for a new project.
The text on that page is so hard to read I decided not to read that article. I don't like this trend of low contrast text :(
Meh, as long as you know the difference, use whichever you prefer
&gt; Choosing yarn over npm is a no-brainer for a new project. Convince me.
Except that by using it, you're forcing anyone who reads your code to know the difference, forcing people to waste brain-cells committing [this chart](https://dorey.github.io/JavaScript-Equality-Table/) to memory. One behaves like the equality operator in any other language, the other has weird edge cases, for only obscure niche benefit that isn't even being used in this case. Why on earth would you prefer the latter? Is the single extra keystroke really that painful?
 document.addEventListener('DOMContentLoaded', function () { var previousImageSrc = 'http://i.imgur.com/Rd0EgO2.gif'; var menuBtn = document.getElementById('main-menu-btn'); var headerImg = document.getElementById('header-img'); menuBtn.addEventListener('click', function () { var tempImgSrc = previousImageSrc; previousImageSrc = headerImg.src; headerImg.src = tempImgSrc; }); }); This assumes your menu has an ID of 'main-menu-btn' and your header image has an ID of 'header-img'. https://jsbin.com/jusugupine/edit?html,css,js,output Good luck.
Correct. I was assuming years to be an integer, but if it's a float it's not much different: if (years &lt;= 0) return amount;
the show password button should have a `type=button` on it, otherwise it will default to submit, as it is inside a form, and submit said form
jquery is shit.
Just wanted to second this. Node.js projects these days are very often more about serving REST API endpoints to a single-page application than serving a traditional server-logic-driven MVC site. I evaluated several different alternatives and found that Feathers's "services" were the simplest and easiest way to build REST endpoints in Node.
Yeah you're behind what you need to know for this assignment; you need to learn programming basics with JS first. Only after should you learn how to get JS to work with your page alongside HTML + CSS. This is not an assignment you can dive into, you gotta do your reading first.
Don’t think about it too much. Experiment, see what works. In JavaScript, you can often do the same thing in several different ways. The more you use JS, the more it makes sense (much like spelling in human languages).
Haha you're totally right. Just put it in there and forgot about it. Thanks for pointing it out!
Converting an object to json for (string) comparison has a number of caveats. You can't compare anything other than a primitive value and object's key order isn't fixed. 
Without using lodash, what's your recommended implementation?
I would love to... however all issues and PRs are ignored so there is no way to contribute.
&gt; mobile users need a solution in the meantime Which is where we end up with a whole bunch of legacy stuff which turns out exploitable in future. &gt; If the former, do you have anything specific in mind? Without looking up details I imagine in different browsers a `password` type would have specific protections against script attacks (XSS or whatever vector) where behaviour of operations such as clipboard copy and the like are blocked. Where if another element can have an event triggered on it, which will change the field type, potentially becoming a way to bypass browser protections and script further interactions with the password field.
Oh no, you're forcing people reading your code to *know the language*? Oh, the humanity! 
If you are passionate about a library's place in the community, you can contribute to the community's understanding of the library without contributing code to the official repo.
I appreciate the help everyone! I'm learning "on the job" which is a pain. The formatting guide is very helpful as is JSHint. I added the comma, but I still cannot get the ID to append to the end of the link in my example. It should obviously replace ID=survey-id, which is in the script I am using as an example. In jcunews1's example I still don't understand how to append the ID to my NEXT button. Sorry, all. Thanks for your help!
It's much better to make it a habbit, coders should be humble &amp; accept that they make mistakes, so they should do anything that can prevent em.
Do template literals in ES6 take away people's incentives to use things like Handlebars? I know written some pretty huge (50+ line long) Handlebars templates. Would anyone do the same thing with ES6 templates?
Then there's countless popups telling me to subscribe and showing ads. I noped out of there 
I really don't think we should be forcing people to learn the awful parts of the language if we can help it. Stuff like `==` is half the reason there are always so many (in my view, ill-founded) complaints about JS being an awful language.
&gt; No user is going to be bothered by this who doesn't want this feature. I don't remember where, but I signed into a site recently that had the "show password" state by default. Really bothered me, because I really would prefer not to have that.
&gt; What does 'false' do? The third argument is `useCapture` which switches the direction events propagate through the DOM. MDN (the Mozilla Developer Network) has really great (the best) documentation on the browser API. Check out the documentation for [addEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener). If `useCapture` is `true` it will use "capture" mode. If `false` it will use "bubbling". [This article](http://themousepotatowebsite.co.za/javascript-events-capturing-and-bubbling/) explains the difference between bubbling and capturing pretty well. &gt; What is the evt parameter in the init function? The `evt` parameter is the [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event) object that is passed to your event handler. It contains information about the event. You can give it any name but most people call it `e`, `ev`, `evt`, `event`, or something like that. Depending on the type of event it will be a different kind of Event object. Like in case of a `click` event the event object will be a [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) where you could for example read out the X and Y coordinates of the mouse when it was clicked. In the above case `load` ([docs](https://developer.mozilla.org/en-US/docs/Web/Events/load)) is the event, `init` is the event handler, and `evt` is an instance of `Event`. It's a good practice to always look up stuff in the MDN and try to understand it.
The majority of web users _are_ on ES6-compatible browsers. The rate of users that aren't is just not insignificant.
So ... The answer is: no, not possible to bank on an unwinding stack of return statements to give you the result like you would in synchronous code. As that would mean your original Ajax request woukd still be waiting for an answer, and thus the rest of your code following it would be blocked. What if you never got an answer?
Instagram won't approve the app, it's against their tos. 
That's interesting. Could you provide an example of some functional code that works better with flow? I'd be happy to add it. Also vs code ftw :-).
Calling `==` awful is, in my view, ill-founded.
He's trying to learn Javascript man, let him be!
I literally had to refer to the chart I just linked to remember that `x == null` is shorthand for `x === null || x === undefined`. Personally, I'd recommend `if(!x)` except when it's possible that x could be `0` or `''`, in which case I'd either just use the longform or else the lodash equivalent: `if(!_.isNil(x))`. Either one is easier to read.
mean stack is vastly overrated and the setup is grossly complicated. just stick to what works: lamp
How did you feel about Hapi? As a beginner, I found it really easy to get setup and running as an API platform.
A little bit, though it's not quite the same thing. Template literals reference variables in-scope, so they're not for dumping into a `&lt;script type="text/template"&gt;` or `&lt;template&gt;`. The bigger trend that's moved most of the community away from handlebars is the move towards components/compositional templating. It's an old concept, but instead of thinking of your "page", and filling it with branching conditionals and iteration inside the template itself, you define standalone components that render properties, which can include being composed of other components. Obviously you *can* take a compositional approach with handlebars templates, but once you strip out all the `{{#if`ing and `{{#each`ing, it has few advantages over simple lodash templates, or even just `String#split`ting on `{{` `}}`. By far the biggest library that got people thinking in terms of components was React.
I've been saying that for years, only to get immediately downvoted into oblivion. What's your secret? EDIT: Laughing as I watch two-faced redditors talk out of both sides of their mouth. 
Now, you can't be going around correcting redditors like that. You will loose a lot of karma doing things like that, spelling and grammar.
Then what's the point of Fetch as Google?
The point of 'fetch as Google' is to submit URLs to their index. Unfortunately, Its designed for static or server side generated webpages. Its pretty consistent for those. But with SPAs you'll get different results. Its also not the 'real Google bot' it's a preview bot one of many bots Google uses to scrape webpages. It's adding your URLs to the que for Googles other scrapers. 
Ideally, you shouldn't think of HTML as presentation, but rather as presentational information structure, just the semantics. Presentation should be purely in CSS. The generated HTML should be just the minimal HTML necessary to mark the text semantically and nothing else. In other words, HTML is not something a designer should be creating. I wonder if thinking of it this way would affect the convenience of JSX or a templating engine like the one in Vue.js.
As of October of last year, google spider traverses links on SPAs if you generate anchor tags in the DOM.
Hasn't cost me a cent yet :) So far the data transferred is still within the free tier per month so I'm happy there. Haven't considered putting ads on here, it was a fun side project so I don't know if I want to be putting ads at all.
wow that's awesome! I'm not sure if you know, but can you have a the spark free tier on each project instead of on an account basis? I'm not sure if it works like that, but it would suck if you are limited to x amount of free sideprojects without having to do self create accounts for each project. 
https://www.youtube.com/watch?v=NTTLpUiT35U
&gt;[**TF2: Dear God No - Soldier (Expiration Date SFM) [0:03]**](http://youtu.be/NTTLpUiT35U) &gt;&gt;Buckets.. Lots of buckets. &gt; [*^Asougi*](https://www.youtube.com/channel/UCJyE-M-rdoh8NlZF0JKpKKQ) ^in ^Gaming &gt;*^35,529 ^views ^since ^Jun ^2014* [^bot ^info](http://www.reddit.com/r/youtubefactsbot/wiki/index)
Lee's busy, man. And "Soon" is vague. I wouldn't consider a week without activity as being a sign that he's changed his mind. Just that he's juggling a lot of things and this particular concern is not at the top of his priorities list. As an OSS maintainer myself, docs PRs are the easiest to review, the most likely to get merged, and generally thrill me. So consider submitting one- or write a blog post and share it here and on Twitter. Wouldn't even be surprised if Lee retweeted it. Maintainers like help, just don't pressure too much. :)
Yes please. Obscuring passwords should be the option. I can think of one time in the past 3 months that I'd click a button to obscure it. All the other times the only one who doesn't get to see it is me.
Whoops, so I was. Fixed now. 
Hi /u/KeyholeSoftware, please post links as link posts. If you have further text to add, do so in a comment. Thanks!
JavaScript is a good language to learn. If you are a beginner (or even intermediate but want to fill in some gaps and learn some cool stuff) I would recommend the book 'Eloquent Javascript' which is free to read online!
Meteor is a pretty cool framework to check out
folks should stop using words like "beautiful", it is meaningless and looks dumb.
Javascript isn't going away anytime soon. 
Doesn't seem to work. I open the link in the readme, and I see just a black bar, and the "Fork me on GitHub" link. 
I'm using ES6 for a project I'm making, but I never used a transpiler. Anything you can tell me on how to use it, or can I find a guide somewhere? I'm thinking about detecting if the browser is compatible with ES6 if that's possible, and if not, make it use the transpiled code, would that be right?
Was reading your code and found this // Returns a random integer between min (included) and max (excluded) // Using Math.round() will give you a non-uniform distribution! function getRandomInt(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min)) + min; } Wow, I'm using the same function in [my snake clone](https://github.com/Metsuryu/Crawler/blob/master/public/js/crawler/sketch.js#L211)! I took it from MDN.
Okay, so I just coppasted your solution and still can't get it to work. I don't know what went wrong where, but at this point I frankly don't even care anymore, too frustrating. Thanks for your effort, though.
Reading your post on my mobile browser... Pressing a button to communicate with you driven by javascript... 😱🤓😎
Don't sweat the language too much. When you grasp a programming paradigm, you can generally apply it in multiple languages as long as you've got the syntax documentation at hand. Package managers, build tools and such have their own quirks for each, but when you know what you want to do, it's pretty straightforward to find the answers. Javascript, Java, Python, C# and such aren't going anywhere and allow learning a variety of programming methods. At least the former also have a whole bunch of different flavours to choose from. Naturally you'll get most comfortable with the syntax you write the most, but it can be beneficial to sometimes look at other languages and learn from them too. For example, if you mostly code in JavaScript, writing a simple program in Haskell or Clojure can open your eyes to functional programming practices and allow you to apply some of the really good stuff in JS as well. TL;DR: JavaScript is fine, although this is a very biased sub. Just pick something and focus on learning some universal programming concepts and practices. Syntax is the easy part.
But with the sugar you don't need to pick up promises. 
Learn Javascript. No framework. Learn the basics first. Understand how it works, and what downsides there are.
Im in the same boat. I came to the conclusion that i wouldn't focus on js specifically, but to learn the foundations of functional programming. Seems to be where the likes of js, java, c# are heading so i think it's a much smarter approach. 
Same :) no need to reinvent the wheel.
1. As I said above everythings locally on my computer. So yeah, no webserver here. And if somebody would have told me that I can't acces the filesystem, I wouldn't have asked in the first place, because apparently what I'm trying to do is impossible. 2. I may be really unexperienced when it comes down to programming but I'm not that stupid. My JSON file is called data. 3. I don't how how many structures a JSON file can have, nor do I care anymore at this point, but according to JSlint.com I do have a VALID JSON file. And yeah the structure looks different. And If I really need a webserver no matter what, well fuck it then, I'm not made up of money. I'm just gonna flair this shit as solved later and be annoyed about wasting 5 days of time on absolutely nothing. But again, thank you for your effort. I appreciate that.
In my experience it's better to transpile to oldschool es5 JS before deploying. Babel is actually surprisingly easy to get setup and use from the command line. I did it "manually" for the first time recently, and I wasn't too overwhelmed.
A lot of ES6 functionality is "syntactic sugar." It's doing the same thing on a lower level, but is easier to write. Class syntax is a great example. You're REALLY just defining Object prototypes under the hood, but it's much cleaner to read and write. Same with backtick templates instead of string concatenation. I write a lot of React code using as much whiz-bang ES6 and JSX as possible, and at the end of the day it transpiles down to not-quite-human-readable ES5.
Do you know any programming language yet? If not, Javascript is easy to pickup and with it being part of web browsers you will be able to use it as long as browsers will be around, be it desktop, mobile, playstation, xbox, refrigerator, etc. NASA also use it[[0]] to support spacesuit operations, processing and logistics.[[1]]. PS. have a look at http://jsforcats.com/ and [JavaScript in 30 Min Video](https://www.youtube.com/watch?v=_cLvpJY2deo)(you might watch this multiple times to get everything) [0]: https://twitter.com/CollinEstes/status/738767017843515393 [1]: https://twitter.com/CollinEstes/status/741994459349417984
My bad! That's clever. Not Found or something like that would be more appropriate though.
Nice indeed. Small correction: on the first tick() call you have an undefined timestamp, imo it's better to init with RAF (so it will have a correct timestamp).
I know you're not working on it anymore, but I think you misunderstood me somewhere. So let me clarify: 1. You can install a webserver on your own computer. I assume you're using Windows, so you can just head over to [Apachelounge](https://www.apachelounge.com/), grab the latest version of Apache and use that. It's completely free. Then your files are on a webserver **and** locally on your computer. * I didn't imply you're stupid. I just listed all the possibilities. * There is no limited set of structures a JSON file can have. JSON can be any combination of arrays and objects (known in other languages as associative array, dict and others). Posting the first two or three entries in that file would have enabled me to tailor the example to your needs.
The serious answer: yes, it's the status quo language of choice for many platforms, so you better learn it. Nobody knows what the future brings. JavaScript is here to stay, like C/C++. In the far distant future, we will write programs in plain English (or rather, just spec it), and then an AI will compile that to native code for us.
The black bar is the game, it's a CSS problem in Firefox. The game-field doesn't get a height. Just open Developer-Tools and give the &lt;main&gt; element a height of 620px. 
They appear even for logged out users. Seems to be some sort of ranking. Makes sense that modules like chai and protractor appear with good rating.
Yup, it was! We replaced our previous solution with something that uses ES and takes way more factors into account. Hope you enjoy it!
Yup
/thread 
It isn't a plugin, it is a font you can use Fira Code for example.
What I meant is users can star modules and I guess the star number is the number of people who did it, like on Github
Correct. (Also, I feel like I should clarify - we were using Elastic Search beforehand as well, just very naively and without making use of its more advanced functions. Now we have a full cluster with a *ton* of factors involved.)
Hey /u/mmalecki! Do you guys plan to add some "extended search" features later on? Things like searching for tags specifically, or sorting the results by the amount of downloads only would be very helpful. 🙂
I had that script invoked in a Makefile: https://gist.github.com/kapouer/260b2a0f7d83cb675a33a22dc36af99a It uses a directory of *.po files to translate strings in html files. It fits most needs !
Not Udemy, but I have links to several cheatsheets, articles, and references on ES6 as part of my React links list : https://github.com/markerikson/react-redux-links/blob/master/es6-features.md. 
1. Meteor - No idea. 2. RxJS - This is just an `observable` data library. In basic terms, it lets you subscribe to the changes of a variable/data. There are some fantastic videos on Egghead.io. 3. Angular1/2 - Again, not really related to backend &amp; realtime JS. Any front-end framework can be used in conjunction with realtime stuff. If you want to use Angular2, that's perfectly viable, but you could get away with just a view library (like React, Inferno) or a lighter weight framework like Vue.js. Infinite choices, really. 4. Feathers is a really neat framework which can you get up &amp; running with a realtime backend quickly. Since it supports so many ORMs and databases, you could get a fully functional API quickly by defining some data models. I haven't used it extensively yet, but I'm a fan of what it does and the docs are excellent. 5. Express is just a very simple wrapper around the built-in Node HTTP server. Node is the runtime engine which all the backend Javascript runs on, it's not a framework, so I'm not sure where you heard its losing popularity. 6. CloudBoost - no idea. 7. RethinkDB is a really interesting database with built-in realtime stuff. It lets you subscribe to a changefeed of the data you put in. The company behind it has folded, but I believe they're trying to keep the open source project going. 8. Redux is a library for handling data flow within your front-end app. You keep all of your application state in one place, and if you want to change it you have to use `actions`, which trigger functions that can change your data. 9. React - Yes, Angular2 does something similar, but Angular2 is a gigantic framework. React is just for views, but the ecosystem is enormous so you can build your own ad-hoc framework. Some alternatives to React with better performance are Inferno and Snabbdom. My advice? Read up more on the concepts involved. For realtime stuff you should read into these: * Node * Websockets The basic steps which need to be solved for realtime: * User posts new data to your database * Backend server needs to know that happened (change feeds). * Backend server pushes new data to clients via websockets. * Client code sees that websocket message and updates the UI. After you understand those better, try to read through the Feathers.js docs and some examples, because that seems to be one of the quickest ways to get a basic realtime API setup.
I just tested on a React project using react-router@2.8.1 and it rendered pretty much perfectly.
any insight on why you chose ES over solr? I can certainly understand the "its what we know/like" argument. 
Noted for the future! Thanks!
Wes Bos: https://es6.io
&gt; because so many people are saying that websites as they are now will become obsolete and everyone with just move to their phones full time. yes and no. people will move from PC to phones, but the mobile web is still a thing. at the same time, there's many people that are saying people are moving away from native apps towards mobile web; people aren't downloading new apps all the time for everything. and even if it moves more towards apps, you can build those apps with javascript. JS won't die anytime soon : ) 
&gt; Add [...] Sound to Your Web Page Nooo, no, no, no, no, no. No.
https://leanpub.com/understandinges6/read
It has a gotcha with timezones, but it is written like someone who never had to use Java Date/Calendar. Now that was a heap of crap, you could tell Calendar was written by IBM.
Why not? I despise any audio that autoplays, especially loud music, but this is something that plays as a result of a user initiating a call to action; it's an additional form of feedback in this respect.
It looks OK to me. How about some more info: what version of node? Any flags used when launching it? What does "crashing" mean -- what error is reported?
Hi /u/ptrstpp950, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `stapp.space`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [stapp.space](/search?q=%28and+site%3A%27stapp.space%27+author%3A%27ptrstpp950%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|16|89% [self.dotnet](/r/dotnet/search?q=%28and+author%3A%27ptrstpp950%27+is_self%3A1+%29&amp;restrict_sr=on&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search) (also `stapp.space`)|1|6%
It's very much a personal choice, and somewhat dependent on your dev experience. I think frameworks like Angular and Ember, which come with data fetching, routing, and view templating out of the box, have some great use cases. Not every developer will feel comfortable patching libraries together, so the appeal of frameworks is that it was all designed to work together, and there is generally an encouraged way to structure your app and do various things. You might find it to be a safe choice to use those, since you'll likely find more support in forums &amp; Stack Overflow when you get stuck. When you use the smaller library approach, you naturally get more freedom. With React/Inferno/etc..., its totally up to you! This can be good or bad, depending on your experience and preferences. All those libraries care about is being told to re-render after you've done your state updating/data fetching/etc. There are of course some commonly used combinations of libraries which you'll see in 99% of the tutorials (like React/Redux/React-Router). Vue.js likes to promote itself as an in-between option (aka. "progressive framework"). You can use just the view templating piece, but once you need more stuff you can add in the official router (vue-router) and official state management solution (vuex).
If it's a site about sound samples or interviews, fine, than please do it. But in all other cases sound on a page is distracting. No matter how well it adheres to your bandwidth.
I use that too but also now npms.io
I didn't try Hapi, but if you're curious about the other frameworks I looked at see: https://www.reddit.com/r/javascript/comments/559jcr/looking_for_a_nodejs_rest_framework_but_loopback/
In short, Javascript is going to become one of ***the*** most important languages out there soon. And I say this as a professional C# developer who knows Delphi, VB, C++, Java, etc. With the advent of HTML5, we now have multithreading, 3D, hardware acceleration, etc. in browsers. These were (IMO) all the missing pieces to making Java truly powerful enough to push complex applications. The day of secondary interpreted browser languages (eg: flash, silverlight, etc.) is past. Javascript with its varying libraries (JQuery, AngularJS, etc.) will be the new "norm". While there will always be a need for application software for heavy number crunching, gaming, etc. The fact that I can create a single application, run from a server (thus requiring little in the way of distribution and zero installation) that - when written correctly - works on all devices from smart phones to windows, from Linux to Macs, and soon even on your toaster and refrigerator, it just simply isn't going anywhere, and is only slated to grow. Honestly, it's going to take the invention of an entirely new language that can "act" like Javascript while having some advantage that Javascript doesn't offer (fully compiled and encrypted code, perhaps?) before you're going to see Javascript slow its increase in popularity. If anything, I expect the few features Javascript is missing (encrypted compiling, more robust multithreading, etc.) will be added long before that happens, especially as there's nothing even on the horizon threatening to compete. So yeah, I think it's safe to say Javascript will be with us for the next 50 years at a minimum.
Someone should submit a proposal to make Moment.js part of the JS core standard. No one should ever have to use native JS date logic.
I see this mistake all the time: you have to remember to do `date1.getTime() === date2.getTime()`, because `date1 === date2` can return `true` when `date1` and `date2` are in different time zones. 
This is now possible in Jumpsuit 1.0 as every state defaults to acting as a global reducer. :)
Is ES7 already out? I thought ES6 was the newest version of ECMAscript.
No, but using polyfills and babel to transform code to ES5 you are able to write your Javascript with most of the features from ES7+, and have it still be compatible with some older browsers.
&gt; However, there are many things you cannot or do not want to do on a phone or tablet Like the vast majority of people who have desk jobs.
That's one way to do it. You'll also see people use variables names `self` or `_this` (or even `that`, though to me that implies something else) for the same purpose. It's not your only option, though. In fact, you only need to do things like this if your `ExecuteCallbacks` function ever gets called without a reference to its owning Dependency instance. var dep = new Dependency(); dep.ExecuteCallbacks(); // `this` is correctly the Dependency instance var exec = dep.ExecuteCallbacks; exec(); // `this` is lost since not called from `dep` While that may look unusual, its not too uncommon for this to happen. When working with callbacks, for example, you're passing in a single function reference that gets called without its respective owner. document.addEventListener('click', dep.ExecuteCallbacks); // ^ addEventListener only gets the function reference to call as // `ExecuteCallbacks()` not `dep.ExecuteCallbacks()` losing `this` If you're writing in ES6, you can use arrow functions which maintain the context of the outer scope so this outside the function is the same this inside it: this.ExecuteCallbacks = () =&gt; { this.IsLoaded = true; for (var i = 0; i &lt; this.Callbacks.length; i++){ this.Callbacks[i](); } } If not, you could also use `bind()` which creates the function with an explicit `this` value to use when its called. this.ExecuteCallbacks = function() { this.IsLoaded = true; for (var i = 0; i &lt; this.Callbacks.length; i++){ this.Callbacks[i](); } }.bind(this); // `this` is always whats in `bind()`, e.g. the current `this` 
The code should work in modern Node versions. My tip is that you are using Node v4 without 'strict mode'. (Since arrow functions work but let doesn't). Try adding 'use strict' to the top, if you did not do it yet. Can you provide an error message by the way? Thx (:
I generally agree with the consensus here. But one thing you should keep on your radar is that [Web Assembly](http://www.2ality.com/2015/06/web-assembly.html), while a ways off (several years, likely more), is in [development](https://hacks.mozilla.org/2016/03/a-webassembly-milestone/). What it will amount to is compiled languages being able to target the browser. Of course this does not mean JS will be kicked out of the browser. It does however mean that certain parts of web apps may be written in something besides JS - such as high performance functionality in C/C++. 
But would you not extend that to notifications resulting from an action that the user has invoked? I understand that in a commercial setting, an option to disable such sounds would be required, but even the browser-based Notifications API [supports sound](https://developer.mozilla.org/en/docs/Web/API/notification/sound). Time will tell if this idea gains any further traction.
I think the app vs. mobile page topic is very interesting. From the developer perspective, more businesses that want their own app means more business. From the consumer perspective, I don't want your app that doesn't usually add much/any value to my experience. I don't want to allow it whatever permissions it thinks it needs and have it on my device all the time. I want to go to your site, get the info I need and be done with it. There are plenty of things that do add value with an app, but it feels like I'm constantly being berated by ones that don't. And I hope you're right with the shift prediction.
The software engineering / dev industry will always be a moving target. In fact, things will only continue to accelerate. You've gotta be comfortable with the idea that your competitiveness as an engineer will decrease over time unless you adapt / expand. Think about how much of a baller you were in the 90s if you could write some basic HTML. Now static sites are so commoditized that they're either free or effectively free. "Web developer" used to mean writing some basic PHP scripts for a guestbook and some ugly UI, now shipping a competitive web app on a senior level requires knowledge that would have included several entire departments just 5-7 years ago. The most important thing you can do as a dev is continue to improve your fundamental / portable engineering and problem solving skills. What language(s) / framework(s) / domain(s) that is will always be fluid and ever-expanding
could you post that to a codepen or whatever? You got some reddit formatting taking over in there (with the \^ character for 1)
&gt; note that the month is 0-based https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date
Because I started with TurboGears2, hated the boilerplate and the fact that a lot of decisions were basically made for you. So I Google'd around for a framework that didn't make me want to kill myself and the first result was Flask (Bottle came in a close second. Forgot why I didn't go for it). So, I investigated via reddit, read the docs and loved the fact that I can start from 0 and build up my app the way I want, so didn't look further. Plus it's pretty well documented and it just works for me. Tried Jinja2 and hated the fact that if I needed to, I could not apply in-template logic, whereas mako has &lt;%%&gt; script blocks. To be clear - I no longer do this, since generally coupling templates and backend logic belonging in controllers is a bad idea, but ever since then I stuck with mako and didn't feel a need to move anywhere else. I honestly have no reason for using one over another at this point in my life, in which case a switch to Jinja would have to have considerable benefits, otherwise I might as well stick to mako. Well I lied a bit. I kind of like that mako logic blocks are pure python syntax apart from the preceeding "%" symbols. So yeah, most of this is pure preference, a bit of a tendency to want to control every nook and cranny of my stack (whenever possible) and some things that just happened - all contributed to me using the things that I use.
I've used lamp more or less 4-5 years ago as a learning exercise. Didn't like it, and I also hate php because that's what people on the internet told me to hate. /s Seriously though - I do hate php, but that hate is merited through horrifying experiences I'd rather not recount. Perhaps I just suck at php, who knows?
Why do people still use Date over moment?
Yeah that was my fear. Well I will try and keep it minimal, perhaps the only good way to start is to just jump in and actually do it. By the way, I honestly don't want to sound stupid, but does react fully handle the DOM for you? I mean - how do you pass around certain objects when using react? I'm used to this: * Access pre-defined controller route (www.mydomain/hello) * "hello" controller returns a rendered template which had "World" passed into it. (Template reads &lt;h1&gt; Hello ${answer} &lt;/h1&gt;) * Dom is then "Hello world". When using react, do you still utilise templates or somehow pass controller output to react to build your dom that way? (I mean, more like an ajax call or something?) 
To be fair, sqlalchemy has one benefit imho over most other ORM's. It doesn't abstract away everything, so you get to use your head more. But once you have the base knowledge, I suppose it won't matter what to go with? I saw some nice little orm's that basically make relationship handling a one line affair and have all these sexy ways of creating tables and objects, which both made my dick rock hard and made me a little afraid as to what you would do if a bug occurred using one of those orm's.. Guess I shall have to give it a shot (Knex and the others I mean)
 "its what we know/like", I was the engineer doing some work on our search cluster and this was definitely part of it. I've used ElasticSearch quite a bit in the past. [Edit] I should add that we'll be writing a post in the near future that goes into detail about the new tech.
And how long did all that all take you to figure that all out? I guess I don't understand why you just don't follow that same path in Node-land? Why do you think you should be able to have it all figured out in 3 days? Just pick something and try it. If it sucks, try something else. 
We have some ideas in the works, look for an official launch post in the not too distant future.
You are correct; the star currently represents the weighting we've given to the search result. We will be making some more UX changes in the near future, and will have a follow up post going into detail about the new algorithm.
PDFJS doesn't seem to natively support promises. So I'm not sure why you are using '.then()' inside your promise.
node 6.8.0 =&gt; nodemon has crashed waiting for saving file (something like that, will be more precise tomorrow).
My need a better title than the URL, but I did like the content. Deduping a TAR archive and having a small compressed metadata stub for the deduplication indexing sounds like a smart idea, and you can't complain about the results! Try Bzip once if you get a chance, I'd love to see the file sizes on tar.bz files :P
Worth using? Or just stick with the usual, Google Fonts CDN download?
ES7/ES2016 is absolutely out already, it just had fairly minor new things added.
Is that I think too. For me let has been designed to solve for/while issue when calling a callback inside. I think let cannot handle multi-scope as var do, but not sure of everything because as I said I'm new to it (:
Babel transforms whatever you tell it to. If you configure it with `presets: [ 'es2015']` then that is only es6 to es5, but you can also include `es2016` in there to enable exponential syntax and such
-rw-r--r-- 1 arnaud arnaud 31678 nov. 6 22:22 jntar.tgz -rw-r--r-- 1 arnaud arnaud 27116 nov. 8 20:11 tar.bz -rw-r--r-- 1 arnaud arnaud 44771 nov. 6 17:17 tar.tgz But my next move is to add zstandard compression to jntar to get: best compression+meta-compression 
I guess that depends on how you define "out"
This library allows you to control the browser's font rendering behavior, such as preventing Flash of Invisible Text (FOIT). Where you get the fonts from doesn't matter. You would use this in conjunction with Google Fonts or any other font service.
You still make videos? I remember you used to make League Vids back in like season one. You'd play with Quill18 and WatchMeSC, then you swapped to Diablo. First league YouTuber I ever watched, I remember your video with HotShot Do you ever think it's crazy you just casually played League with one of the biggest players in NA League?
The scope extends to sub blocks for both let and var, and there's no var hoisting here, so they should be equivalent.
Could you elaborate some more or give some examples?
The only reason I can think of is that moment is a pretty huge dependency.
You will need to run this algorithm in your main loop or anytime your system changes. This type of collision system depends on catching collisions early, IE when penetration depth is minimal and will not work at all if you allow objects to traverse too far without correcting any potential overlapping. 1. Loop over all pairs of bodies you wish to resolve checking if they overlap. If they do overlap, record the overlap vector between them. 2. Loop over all your collisions, moving the objects apart along the vector. if your vector is { x: 1, y: 2 } you could for example just move the first object by -1, -2 ( somewhat naive implementation ). 3. Repeat step 1-2 until there are no collisions or some upper bound of attempts to resolve them has been reached ( for example 3 ). This is a very simplistic algorithm to try to separate bodies but it may be enough for your needs.
&gt;[super reliable](http://i.imgur.com/gqQhZyS.png)
ok but how would i find the overlap vector? Right now i can tell if two objects are colliding and have access to all of their properties (collider width/height, position x/y)
Well, I feel like I bet on the right horse! anyone have a counter argument?
I wonder if it's smart enough to infer that `a`'s type is `Array&lt;string|number&gt;` let a = []; a.push("a"); a.push(1); edit: It does! edit2: And the type is `Array&lt;string&gt;` until the second `push`! 
Perhaps have some pre-written code and let them just change the variables around. Have a canvas with a blue ball bouncing around in it, let them change the color, speed and so on? 45 minutes isn't enough to teach them any fun code, but it's enough time to show them some things they can do with it.
if you have an id, you don't need a query selector at all: `if (document.querySelector('#violationSel').value)` `if (violationSel.value)`
I just started with ts maybe a month ago. Im def not cought up and now its only getting harder!
That wouldn't be too hard, although I don't know how exciting it would be.
Thanks! I'll check it out.
I suggest drawing it on paper and working the solution out yourself. You have position, width, height so you have everything you need to calculate this.
Is object spread available on this release?
just try it
Yes I agree, C# is a much better language to use then unityscript for unity
https://www.youtube.com/watch?v=cTwZZz0HV8I
mmm with just 45mins idk, teaching kids is a whole 'nother topic. I spent 1-2 hours with a couple of kids aged 8 or 10. I didn't bother teaching them JS, but I showed them what they can do with CSS and how to get used to the syntax. They had fun for a bit changing parameters around, we got up to animation transitions. I had some pre-written JS for them, but yeah they would simply change parameters there as well. Kids have short attention spans so you gotta go with the more dynamic material with just enough variation to keep them amused, although you are dealing with middle schoolers so their sensibilities will be different. Maybe you can show them that it's possible to use the inspector to debug/manipulate the DOM, though I'd be cautious as someone may see it as a cyberbullying tool. If I were you I'd definitely write the whole program beforehand, give an outline, educate them a bit about super basic language features like iteration and variables, and show them what is possible when you put all these simple instructions together. I think it'll definitely raise some eyebrows to write a few blocks of code that is capable of doing a lot. Though I would definitely focus on the big picture of what's possible with software development in general, and show them how empowering having development skills is (creating fun-gimmicky web apps, data visualizations, video games, medical tools, IoT, robots, et cetera). And I would also emphasize how accessible software development is, that ANY one can learn for themselves online or with a friend if they're motivated enough and pointed in the right direction. There will definitely be kids who will feel they need to be "mathy" type students to even consider writing apps, so definitely encourage those who put that doubt on themselves, and especially encourage the girls too. Obviously this is coming from a front-end developer. 
Lol yea had some good times. I mostly play games for fun atm, I started to lose the fun when Youtube and streaming became my job. I just enjoyed making guides and helping people...I still do enjoy that, but the help I give is to junior developers at work :)
No :c
Not yet, but it's scheduled for the final 2.1 release.
I feel PWAs may be doomed as well. PWAOS is a PWA that hosts PWAs. Write once, run everywhere. For real this time.
Let's be very clear: this isn't about being innovative but creating something that is usable/useful. He works with/for archive.org they want to preserve as much information of ours cultures and societies as possible and make it available to as many people as possible in a way that works as much as possible as the original. One of these ways is to use emulation. They do this in the browser to allow anyone anywhere to run the software anywhere where a browser is available. Which is probably one of the most widespread pieces of software on the planet right now. They are going to try and do the same for DVD, etc. content. How ? You make VLC portable to work in the browser. So you can have the DVD-menu work as it was intended. It might offload the playing of the movie content to the browser. Or it might decode the file because the format which is not supported by the browser. They are just looking at using VLC (which supports many, many formats) as a way to make as much content available to as many people as well. Don't forget, they want to add as many wants to make sure the content is still available in many, many years. And don't forget Moore's law isn't dead yet.
&gt; Ironically, even though Apple pioneered many of the progressive web application technologies, iOS seems to be the only major obstacle to progressive web app adoption. Unsurprising. Developing for iOS is such a painful process, they have no real reason to keep up with the curve, that 30% cut is too sweet.
What is PWAOS?
**P**latform **W**ith **A**n **O**perating **S**ystem.
Totally agreed, was speaking only in terms of dates only (and really just being crass) :) On collators, there is Intl.Collator.
Your start variable is in a new isolated scope for each recursive function call so it will always be zero. Maybe just use a loop? https://jsfiddle.net/esmfmc7c/2/
Modern day JS does already enable ambitious projects, but for further improvements, I would wish for: - A finalized loader (spec in progress) would be nice to begin with. - Complete removal of loose equality checks (should result in broken syntax) and other wtfs - Uniform, consistent support for the entire ES7 spec (stage 4+), especially modules (import) - Native type annotations in some form or the other (TS / Flow sorta thing) - All of this by the end of 2017 (pipe dream) On a more personal front, I would love to see the death of CommonJS and that bloody require(), which is cancer, but that's not going to happen in the next 10 years.
so hot.
I think you can await on anything PromiseLike 
&gt; - A finalized loader (spec in progress) would be nice to begin with. It's almost done, you can use the new syntax with Babel or Webpack 2 just fine. &gt; - Complete removal of loose equality checks (should result in broken syntax) and other wtfs This will break the web, I'm not sure how you can even suggest it. &gt; - Uniform, consistent support for the entire ES7 spec (stage 4+), especially modules (import) I'm beginning to believe you're not very informed. ES7 (ES2016) was finalized this summer and is implemented in most browsers. Modules are from ES6 (ES2015). &gt; - All of this by the end of 2017 (pipe dream) Uh.. Why? &gt; On a more personal front, I would love to see the death of CommonJS and that bloody require(), which is cancer, but that's not going to happen in the next 10 years. How on earth did you arrive at this number? The syntax is already dead pretty much and with the loader spec being implemented the implementations will die out too. 
Well, I just wrote a quick test (generating some random markup and setting `document.getElementById('container').innerHTML = randomMarkup`) loading relatively big portions of different random data into the same element, and my browser showed surprisingly good results (no memory leak). So, I must admit that exaggerating the problem was my mistake (but I'm still not sure about the result if I decided to load images or iframes instead of text-only dynamic HTML; a few years ago, I loaded a few big different iframes to the same page simply replacing the URL of the target element, and could not avoid an error message from the OS when the browser consumed all available RAM). 
why are people so eager to add a type system? 
Typescript to compile ES6 with types. tsify (browserify) to create bundles and use npm modules. node-sass to compile sass files. http-server and npm-run-all to set up simple recompile-on-save tasks. No grunt/gulp, just scripts in package.json Mithril.js for an app framework. Add other libraries as needed.
I also have all my eggs in the JS basket, but my counter argument is WASM.
They will probably make a JS or typescript like language that will compile to webassembly byte code. But of course it would be less optimized but would probably allow for some super speedy UI. Anyways I'm excited.
Sorry, I meant using public content to other your own. If it's just your content your app doesn't need approval. 
&gt; It's almost done, you can use the new syntax with Babel or Webpack 2 just fine. Native support. Babel or Webpack doesn't cut it as top requests for "JS" per se. They're not the standard, and their implementation of the ever evolving standard doesn't mean much. &gt; This will break the web, I'm not sure how you can even suggest it. You mean websites, the poorly coded ones. So much sympathy for those who couldn't bother to improve their code over the years, so instead this will last forever as a means of supporting them, while penalizing others. &gt; I'm beginning to believe you're not very informed. I'm beginning to believe that you're a little presumptuous with your remarks with subtle hints of condescension, and also quite poorly informed yourself about what is natively supported and what is not (in bleeding edge browsers, sometimes with special flags). &gt; Uh.. Why? Not sure what your question is. &gt; How on earth did you arrive at this number? The syntax is already dead pretty much and with the loader spec being implemented the implementations will die out too. At this point, I'm pretty sure I have a fair idea about things. For someone to claim that the require() syntax is dead, and additionally, not be able to distinguish between complaints of existing proliferation added with the lack of native support for import, marks the end of a meaningful conversation for me. Curiosity question: How did you conclude that the require() syntax is dead? Do you ever grep through common libraries from npm? Anyway, feel free to make further assumptions. I'm out.
&amp; smaller dependencies that don't have many sub-dependencies....
I challenge anyone to make this library smaller without changing the interface or making any additional assumptions about the page css. I've been researching this for about a year, off and on, and I have not been able to make it smaller for about a month.
RubyLouvre/avalon Dang, I can't edit the title... 
Express + middleware for backend, Webpack with Babel + Sass loaders for bundling Vue / React for interfaces 
Betteridge's law of headlines applies yet again. The idea of making one build that works the same on all the platforms sounds very nice in theory, but it's never ideal for the end-user. Different platforms have different capabilities, with different expectations from their users. There's a reason many companies opt for either completely separate native builds, or a middle ground that allows them to selectively share logic between platforms like React Native, instead of relying on WebView to build their applications. My team is working on a relatively big Cordova/Angular mobile application, but I recently got two weeks to test implementing some of it in React Native. It has it's own set of quirks, but in general was about as easy to develop and debug despite being truly native for Android and iOS.
Members of the IT Central Station user community interested in embeddable databases read reviews for Oracle Berkeley DB. You can read what real users have to say about this solution here: https://www.itcentralstation.com/products/oracle-berkeley-db
The spec has been fixed for a while. Polyfills don't matter as long as they adhere to it AFAICT?
Looks like it's OK AFAICT? https://docs.angularjs.org/api/ng/service/$q &gt; This is a Promises/A+-compliant implementation of promises/deferred objects inspired by Kris Kowal's Q
Will spec TODO's be filled in by 2.1 release? Surprises me that asynchronous functions are still TODO since I've been using them with target ES6 for a while now. All I looking in the wrong place? https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#6.8
Solid example. Only thing I would say is a little strange is the no arguments invocation of your "reducers()" function. That took a few more cycles than necessary. Again, overall good stuff
all the point of tar is that it's a standard.
This assumes that types are erased after parsing (I.e. fully static). Runtime types also open interesting doors, such as pattern matching and automated form generation against types that were completely defined by user-created metadata from an API; I've been using tcomb for just such a system. Of course, no new type support is necessary to achieve this, it's more or less purely functional. However, it's a real pita to get static type inference (such as typescript) to understand. Personally, I seriously doubt that ecmascript will add a compile step (Edit: as in an additional step beyond the parsing step) that will crash because of a type mismatch; it seems like it would stay too from the web we know today (for better or worse).
When an attacker is able to steal your cookie, the attacker is already "in". No point to add extra security checks at this point.
"JavaScript" is the trademarked name which is owned by Oracle. "ECMAScript" is the name which is used by the language specification since 1997.
Thanks! I don't know a simpler way to do it other than invoking it without state to fetch the initial state from the reducer's optional parameters :P
Types make it easier to write larger applications in a team. They provide immediate feedback and rudimentary documentation. APIs get more discoverable and you can navigate faster via "go to definition" and "find uses/references". They enable better refactoring. Furthermore, they act as a safety net. You can skip unit tests which merely exercise lines. This part is almost completely covered by the type checker. I've used many scripting languages: JS, Python, AS3, TS, Dart, Lua, and even crap like PHP. I definitely prefer to have types. I preferred AS3 over ES3/5 and I prefer TS and Dart over ES6+.
Why? Couldn't find a matching reason in the guidelines.
Fuck yeah! Now to learn it...
&gt; Python has support for object oriented programming with classes and classical inheritance, unlike JavaScript which has prototypes with prototypal inheritance. Just FYI... Python's classes and inheritance and JavaScript's classes and inheritance are strikingly similar. Python's classes are themselves objects that consume memory and can be passed as arguments, just like JavaScript's classes. Python's inheritance is implemented using delegation and allows monkey patching, just like JavaScript's inheritance. Remember this the next time someone tells you JavaScript's classes are "fake". JavaScript's classes are just as real as Python's classes.
Couldn't actually the js interpreter do that automatically?
Good idea! You could have it both ways; write a macro that transforms React-JSX into VueJS. http://jlongster.com/Stop-Writing-JavaScript-Compilers--Make-Macros-Instead
Wouldn't installing npm via nvm solve that issue?
So EcmaScript 5.1?
Can you point out the area of your post where you discuss javascript?
If you have yarn together with your other dependencies in the same node_modules folder, strange things happen. E.g. phantomjs fails to install, and the yarn command hangs... You could also cd .yarn and then npm install. But npm install is a bit slower than downloading the tar.gz file and extracting it.
Yes, if you have nvm, I think that will let you npm install -g yarn even if you don't have root permissions. (But I didn't have nvm on the CI box)
There are parsing errors, not compile errors. The current 'compiling' performed by modern JS engines are from dynamic to more static inference of types, and if there's an error or a mismatch, the engine bails out to the slower interpreted mode. Google has certainly played around with what they called strong mode, and some more sound typing, so I'm not really suggesting that it's impossible or won't happen, but it seems like it would be rather difficult to get all browser vendors- not only chromium / chrome / mozilla / apple / MS, but also all of the open source browser vendors- to get on board with a single type system that doesn't have incompatible implementations, extensions and so forth. After all, that's largely the reason that ECMAScript 4 was abandoned by web vendors, and only ever implemented by ActionScript.
No, that wouldn't make any sense. What if fooFn has a sideeffect that mutates some global state that barFn depends on, meaning that you can't run them in parallel.
I can't find anything about support coverage without compiling a phonegap app to a native format, didn't even know it was possible. I'm curious about how it works and device coverage if it is possible, got a relevant link?
Is there any plans in future versions of JS to add some sugar to async/await so that we don't have to wrap everything in try/catch? To my eyes it totally destroys the readability gains made by making things synchronous-looking in the first place.
The last version that resembled Javascript.
You don't have to wrap everything in try/catch unless you plan on catching and dealing with the error. If you don't catch anything, it will just bubble up the stack until something does (or it hits the global level and the engine deals with it)
Nah. If you want a "not ECMAScript" JavaScript, you've to use the one which was shipped with Netscape 2.0 (1996).
Could you elaborate please?
no i mean, should i learn os specific languages for native apps -in the face of how easily js apps can be transferred to all os's. 
if you want a working demo, iirc imgur can use your phone's camera. 
IIRC goal of WA is to make to compileable from any language.
Ah cool. Looking into that on iOS it's simply using an html file input option and doesn't even need cordova. It doesn't provide full native functionality, though. Can't stream camera input or manipulate the capture view, but it would probably work for most simpler cases. I'll have to look into storage capabilities which I'm more interested in, but I'd bet there is an arbitrary limit to how much drive space a web page can delegate. Seems as though things have gotten better since I last looked, but still doesn't look to be an ultimate replacement.
I want this sugar: ``` const [foo, bar] = await [fooFn(), barFn()]; ```
No idea if libraries are available to do such a thing (they are, most likely). I did find [this SO question](https://stackoverflow.com/questions/3099322/how-to-add-undo-functionality-to-html5-canvas) though.
Try doing complex selection of jsonb fields. GL HF Edit: see https://github.com/sequelize/sequelize-performance the performance difference is not like 100ms. Its fucking SECONDS.
X-Post referenced from [/r/reverseengineering](http://np.reddit.com/r/reverseengineering) by /u/athre0z [[wasm] WebAssembly decoder &amp; disassembler in Python (library + objdump style tool)](http://np.reddit.com/r/ReverseEngineering/comments/5c2shw/wasm_webassembly_decoder_disassembler_in_python/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
The spec doesn't necessarily reflect the state of the compiler right now, but we do intend to update it in the near future.
True, an obvious answer I didn't think of.
Yeah! But we'll have to wait for ten years more for proper finalisation and adoption. I don't think I'll be doing any front end work in ten years...
I'm on a phone. I go from wifi to LTE. My address changes. 
Do my eyes deceive me or is this really using MD5 for password hashing?
Speed, binary representation, types, and a compile target for any language.
You don't have to use try/catch. You can use `.catch` on any promise returned by a calling an async function.
I'm not really convinced that static typing needs to be a language feature. Seems like tooling that already exists in the form of TypeScript or flow can fill that gap nicely without adding significant baggage to the base language. Now runtime typing, I could get used to that. 
You make a good point. I think there's a debate to be had over whether the addition of typing is worth the rather large increase in language surface area.
[removed]
I suppose you first generate the url. You can then do the following to redirect your users: window.location.replace(url); [SO post](http://stackoverflow.com/questions/503093/how-do-i-redirect-to-another-page-in-jquery)
Start the script via node and not nodemon. What is the error you get?
Prerender.io uses PhantomJS internally. It's slow (it basically runs a browser). Instead try isomorphic rendering.
Any examples? The "Try it out" link just takes you to a blank editor with no info on what to try.
I've recently looked into this with video and the answer isn't very straightforward. In theory you can do it and here is an excellent example. http://codepen.io/ollieRogers/pen/lfeLc/ I was not able to reproduce the smoothness of these results when I was looking into it. My only guess is that I would have had to tweak the compression on my videos to find some magical settings.
This is what I have so far and it seems to work for the percent side of the equation but not the flat side var f = this.getField("NewTarget").value; var p = this.getField("Percentage").value; var b = this.getField("PropAnnualRate").value; if (this.getField("BonusMethod").value = "Flat") event.value = f; if (this.getField("BonusMethod").value = "Percent") event.value = b * (p / 100);
Hi front-end team. Thanks for doing an ama. I hope this doesn't sound too rude, but why in the fuck do you still have the mobile app banner on the website? I don't want the mobile app even though I use my phone all the time. Make it so closing the stupid banner sets a flag in the account to never show that shitty thing again. I want the desktop site and that's it. Again, I don't mind you asking once, but only once. Don't pester me with your shitty app.
thankyouu!!!!!
WebAssembly is just Native Client 2.0. The standardized version, if you will. Google had their idea of how to do it. Mozilla had theirs. They got together with some other players and had a baby: WebAssembly.
It looks very interesting. Performance seems to be good and the simplicity of the code catches my attention. Last week I developed some related code with Typescript, ThreeJS and Ammo.js. The full article is available here: https://componenthouse.com/2016/11/08/having-fun-with-typescript-threejs-and-ammo-js/.
Yeah, but lots of people seem to think they will be coding Angular or React with WebAssembly. 
Track your mouse coordinates by adding an event listener to the page. Every time your animation loop updates calculate the distance from the mouse and the object. Calculate the angle, and then determine your new x and y velocities (using the speed of your snake). Rotate your context by the angle. Draw your new object by updating previous x and y position by your new velocities. If the speed is dependent on the distance of the mouse, correlate a max distance with a max speed. If the distance of your mouse from the object is below the max distance, just multiply your max speed by your mouse distance/max distance. If you want your snake to 'slither,' treat your snake as an array of bodies, each one following the successive body's prior position, with your top body, or head, following the mouse as described above.
Wait wat
Well, we'll have to agree to disagree about semicolons. As for subscribe you are right, but I think leaving it out makes it simpler for people who don't know how a redux store works understand the big picture better.
just build the app in jquery lol, why are you using react if you're still going to use jquery smh
this!
i am using d3, jquery etc to convey the idea. 
It's not a great example but surely it does abstract you from the implementation? newGame is probably a bad method name but it doesn't have to be called.
Classic: Programmers that don't understand how [reddit](http://mashable.com/2012/06/06/reddit-for-beginners/#c4S8xDbu5kqi) works yet. hint: you have to click the title to get to the AMA. 
Examples can be found on the Github page.
What would be some good exercices/challenges for a beginner in Javascript
How about this https://regex101.com ? :)
Even Assembler afaik
At a guess, I assume they mean that if you can do something in 4-5 different ways, they probably will. You'd need to have guidelines about things like where your templates go etc.
&gt; While Vue is being picked up by large organisations like Alibaba and Baidu, it’s integrity at scale is still not really a known quantity. Spot on! __It is integrity is an unknown quantity!!__
Don't want to be rude either, but the mobile app banner annoys me no matter the website. If I want to install a mobile app, I'll search for it in the AppStore.
Thanks. I was wondering, mainly because we cannot again have fixed-size canvasses. So whatever they come up with, they better make sure it's possible to make your application responsive across devices from day one :-)
It's not really a case against Classes; you can use Classes (because it's easier to read) and not expose them. 'use strict'; class Game { constructor() {} static from(...args) { return new Game(...args); } } exports.create = Game.from; 
Thank you for the elaboration.
Why not? I came across many skilled and achieving programmers who never used prototypical inheritance during my career. Not saying that you should leave out that part of the language but it could be worse. In my opinion the basics are the most important: loosely and strict comparison as well as what loosely typed (or how ever you want to describe it) means and what the pros and cons are. And for that's pretty irrelevant which edition you use. ES6 makes it easier for programmers of other languages to join in, because it sounds more like traditional OOP languages. The only thing that's not that brilliant in ES6 right now is that you need at least a module loader or some sort of transpiler for the more interesting parts. As closing words go: *At least you teach them. That makes it all the better. I can't say how many people I regularly talk with that "learned" javascript by c/p snippets from rotating_animated_fire.gif pages and think they are now fricken ECMAscript sages.*
Someone has to tell them! Redding really needs a better way to do crossposting. It reminds of RT on Twitter, looks like a "workaround".
No, because you won't survive as a JavaScript programmer without knowing ES5. ES5 is the most used, most known and the only version of JavaScript that can run natively in any browsers (sometimes poly-fills are needed). You should first learn ES5 then you should learn ES6.
**Edit: Elliot is completely wrong about constructors in Javascript. I've edited the comment below. Lesson learned, never trust ANYTHING Elliot says.** Elliot is somewhat (in)famous for his tendency to invent his own unclear terminology while failing to grasp some core OO principles; I wouldn't feel bad for struggling with his stuff. However in this case he's ~~mostly right~~ completely wrong. I disagree that this has anything in particular to do with the Open/Close principle, but constructors ~~*do*~~ **don't** limit you in ~~some specific ways, although as a practical matter it's arguable how important that is~~ **at all.** Here's a concrete example: You want to allow people to integrate with various externals services. Maybe you want to let people post things to their Facebook wall, Tumblr blog, Tweet something, etc. So you've written an `AbstractIntegration` class to handle the general case, and then a number of concrete classes which extend that class to integrate with different services, and now you have a dropdown which lists them all. The user selects one from the dropdown and you instantiate a new `FacebookIntegration` object (or whatever) and do stuff. And it's as simple as a quick ``` const integration = new FacebookIntegration(user) ``` Awesome. But now it turns out that the way your `TwitterIntegration` works is fine for some people, but Twitter is incrementally rolling out a new API, and you basically need to rewrite it from scratch, but you can't just replace the old integration with your new one, because most of your users are still stuck on the old API which is incompatible. And you certainly don't want to have both items in the dropdown; it'll just confuse users since they can't even tell which one they should pick. What a mess! What you probably would *like* to do (especially if you love inheritance) is have a base `TwitterIntegration`, plus a `NewTwitterIntegration` and an `OldTwitterIntegration`, and then have the constructor method on the base `TwitterIntegration` class do a bunch of checks to figure out which one is appropriate, and then return the correct one. So when you do your: ``` const integration = new TwitterIntegration(user); integration.send(message); ``` Then boom, you magically end up with a `NewTwitterIntegration` or an `OldTwitterIntegration`, whichever is appropriate, and that `send()` call is actually running the appropriate method on the appropriate underlying integration class, and everything works perfectly and magically. ~~Except...~~ ~~...that's impossible. You can't return anything from a constructor, and you'll always get an instance of the class you instantiated.~~ **In some OTHER languages that would be impossible. But in JS, that's quite legal. So do that, boom, your done. But if this was Java, you'd be stuffed.** But what you *could* do is change from using a constructor to a static factory method: ``` const integration = TwitterIntegration.getInstance(user); integration.send(message); ``` A static factory method can return whatever it likes, so this will totally work. ~~So what's Elliot's point? Just this:~~ **But again, in JS, you don't need to do that, which is why Elliot is wrong. But if this was Java, or PHP, or some other less flexible language then his point would be this:** If you're using the `new FacebookIntegration()` syntax, and then you realize you actually need the flexibility of a factory method, you'll have to change all your code to the new `FacebookIntegration.getInstance()` syntax. That's a pain! If you used the factory syntax everywhere from the start, even before you needed the flexibility, you wouldn't have to change anything outside the class. On the other hand, many people would argue that this entire example is just one anti-pattern piled on top of anti-patterns. They would say that you should prefer composition over inheritance, and this entire tree of integrations is a horrible mistake. For example, your base `TwitterIntegration` could actually delegate it's behavior to an appropriate instance of `NewTwitterIntegration` or `OldTwitterIntegration`. Because in reality: ``` const integration = new TwitterIntegration(user); integration.send(message); ``` This can totally work; all you need is for the `send` method on the base integration to call the send method on the appropriate underlying class. No big deal. (Elliot's example of object pools is slightly more complicated, but also easy to solve.) In short: Elliot is claiming that the constructor pattern ties you to the details of how the object gets instantiated, but is failing to grasp that this ~~doesn't matter very much if you use composition.~~ **doesn't apply to Javascript. Plus even if it did, you could just use composition.** Still, if you **are writing in Java and are on the wrong subreddit and** want to follow a very specific (and many would say, ill-advised) pattern, then constructors can get in your way in certain cases, and you might be better off with a static factory method. **TL;DR: Don't assume Javascript works the same way Java does, or you'll sound like an idiot like Elliot and I just did.**
The ongoing WebAssembly logo competition is hilarious https://github.com/WebAssembly/design/issues/112
There are things from ES6 that can be taught as you go like arrow functions, let, const, and classes. The rest is better to leave off. It's not that important and isn't supported by all browsers anyway. IMO OOP, FP and getting familiar with standard libraries are way more useful to know first. 
yeah, i am using webpack v1
JavaScript the good parts (ebook) to understand how it works ;)
Its a low level target for stuff like C++. There is no need to "learn" it. Like there is really no one doing raw assembly these days. And no, it wont replace javascript, javascript will still be there, and imho javascript will be even more popular in the future. Think of it like this: Want to run unreal tournament in the browser? Then compile the C code to wasm and your good. Want to build a fat client webapp, then write your app as you did before, in javascript. The only thing i think that could "replace" webapps are more cpu intensive stuff, like say, photoshop. You could port it to wasm and have a photoshop app running similary as a webapp, int the browser. But for 99.9% of apps, vanilla JS will be the correct way!
If you're being a traditionalist, then backbone templates are written inline with the HTML as `&lt;script type="text/template"&gt;`. You're only able to apply a template literal against those using `eval` (or an equivalent `Function` definition), so if that's acceptable (it's usually not) then go ahead. My eslint would lose its mind if I started templating like that, though. const template = 'Hello ${name}, are you feeling ${mood} today?'; const name = 'Buddy'; const mood = 'happy'; eval('`' + template + '`'); gives you: "Hello Buddy, are you feeling happy today?" and of course, `template` could have come from a `&lt;script type="text/tempate"&gt;` tag. For backbone, it fortunately doesn't tie you as directly to a particular template type as many other libs (e.g. angular) will. Backbone anticipates that you're going to use iteration and conditionals inside your templates, so you'd have to handle thinking in components yourself, e.g. const items = things.map(thing =&gt; `&lt;li&gt;${thing}&lt;/li&gt;`).join(''); const message = isMorning ? 'Good morning!' : 'Hello!'; this.$el.html(` &lt;h1&gt;${message}&lt;/h1&gt; &lt;ul&gt; ${items} &lt;/ul&gt; `); So sure, there's all sorts of ways you _could_ use it.
Well they *could* do that... Eventually. However I think it is much more likely that they'll use a framework more like QT that replaces the DOM entirely. So instead of relying on HTML and CSS to layout/style a site/app and display content they'll just write *everything* using their framework of choice in their language of choice. Ever wish you could code for the web in Python or C or Java or some other preferred language? WebAssembly will make that possible. Right now any language that works with LLVM can (likely) be compiled down to WASM (WebAssembly) with a little bit of work. The pioneer on that front (right now) is Rust but you can also use C and C++ (which were the original languages to compile into WASM). Eventually there should be support for compiling many other languages into WASM as well. In fact, I wouldn't be surprised if some alternate, non-JavaScript interpreters become normal on the web! Wouldn't it be cool if you could embed a Python interpreter right into your site and handle everything that way? With WebAssembly you could do that and so much more.
Browserify isn't a bad choice but having started there myself and then moving to webpack, I would suggest starting at webpack. You can treat it like browserify until you're ready to utilize it's other features. For your inline scripts have you considered moving them to separate modules and just packing those up as well?
&gt; Making an HTML5 game? Want to change from new object instances to use object pools so you can recycle objects and stop the garbage collector from trashing your frame rate? Too bad. You’ll either break all the callers, or you’ll end up with a hobbled factory function. For what it's worth, Dart has factory constructors for this. You can just turn your constructor into a factory without having to change any of the call-sites. It's a very convenient language feature which ECMAScript should copy. https://www.dartlang.org/guides/language/language-tour#factory-constructors Anyhow, in the context of a game this doesn't really matter. There just aren't many places where objects of a specific type are initialized. If you use TypeScript, you can just make your constructor private and you'll immediately get a list of places you've to fix. You can also use right click -&gt; *Find All References* to figure out where those call-sites are. A better example would be a game engine which is already used by a couple of games. Replacing some public constructor with a factory would result in an API change.
It's a fine article, but I can see the other side to each of its points. &gt; Focus Unquestionably a Good Thing, but I'll caution that I've seen many other libs start out the same way. The HTTP request or promises implementations in jQuery or Angular weren't written because they thought they could do better than the standard: they were creating something that didn't exist yet, and in many ways helped shape what our standard would become. &gt; No polyfilling, no transpiling, no wrestling with a bundler. This can also be read as "an additional microlanguage!" One of the big sore-spots with angular, that drove hordes of people to React in the earlier days, is around microlanguage. They give a really stripped-down example, but as soon as you start doing this, you're giving yourself another language to manage: &lt;div v-for="(value, key) in object"&gt; {{ key }} : {{ value }} &lt;/div&gt; Notice a few things: you're giving loop (and can also include conditionals) inside of a string literal on an element. This is feeling like an old-fashioned approach to templating, and has overwhelmingly been replaced in favour of compositional templates. When you align your presentation logic closely to the language itself, things stay more readable, lintable, organized and logical. I work with students and juniors all the time who learned to appreciate `Array#map`, `Array#reduce`, `Array#filter`, `Object#keys`, etc. because of React. Polyfilling isn't necessary for most libs, but I would never sell "no polyfilling" as a benefit. You're claiming that not using standardised features is somehow a good thing. Transpiling is usually optional -- it's used because it's a better approach, not a necessary one. Not being able to transpile isn't necessarily ugly, but the new object syntax is gorgeous and such a natural fit. Destructured arguments + stateless React components are a wonderful thing: `const Hello = ({ name }) =&gt; &lt;h1&gt;{name}&lt;/h1&gt;;` is standard, keeps your arguments organized together at the top, and doesn't require some custom `{ data: { ` structure. It's also not even super vendor reliant: you could easily apply that pattern with another lib. JSX is fine; it's a super-simplified XML and a lot more logical than HTML, with its arbitrary end-tags. `&lt;img src="foo.png"&gt;&lt;i class="fa fa-question"&gt;&lt;/i&gt; Q&amp;A` is silly. `&lt;img src="foo.png" /&gt;&lt;i className="fa fa-question" /&gt; Q&amp;A` is consistent. Personally I don't even use JSX, as well-organized modern JS works quite well without it. import { createElement as ce } from 'react'; const Foo = ({ color, userName: name }) =&gt; ( ce('section', { className: 'foo' }, ce('h1', { style: { color } }, `Hello ${name}!`) ) ); No JSX, but just shorten that bulky `React.createElement` to `ce` and it's pretty clean. Again all the es6/es7 object syntax makes things so pretty too. Notice the implicit property name on `color`. Bundling can definitely be tricky, but create-react-app has definitely streamlined a lot of that. &gt; Flexibility I won't belabour this one, but I don't really see this as something vue "got" at all. It's not nice about JSX, and anyone could build JSX to compile to a `Node` tree, and that's what an HTML string does. This is already covered in the "where vue is lacking" anyway. 
I think they decided to use semver from now on. Major releases will occur much more often, but will also be much smaller than the 1.X -&gt; 2.X upgrade.
Try to think in smart and dumb components. Example: fetching trending Twitter hashtags: You want your hashtag list to render some strings, so this should be a prop. You can then take the list component and put it inside a RemoteItemList or something like that, and this component is only responsible for getting the data (from cache or from rest api) and passes this data to the list component. 
The main errors I noticed were to do with "it's". Every "it's" in the article should be 'its' except for the first ("it’s had the advantage of"). Hope this helps.
This is about on par with how rapidly Angular 1.x versions changed. Now that Angular is semver, we will see the major version number change as often as the minor version used to change. 
You are correct, thank you. Fixing now.
This is a bit of an awkward example. There's a bit of complexity going on along with some errors (like public static properties). But to answer your questions... Namespacing is just a matter of nesting in an object. Using modules, you would simple create the object and put your definition(s) inside. return { // would assign to Namespace Object: { ChildObject: thisObj } } The public static method works because it is assigning a function member to the constructor definition (rather than to instances). It's a little confusing in this example because the constructor is named "thisObj", but if you look at it as it ultimately gets defined to, it might make more sense MyClass.ShowCount = function () { console.log("Count? " + intCount); };
There is one more "it's" to fix :P
I put the blame squarely on the Australian education system ;)
Turns out I'd used "it's" instead of "its" about 5 times. Awkward.
I've changed the code, and this seems to work more "as expected". Anything stand out to you as wrong?
If you're prepared to make a small assumption that instanceof Array is the same as saying that the object has .length (and length greater than 0)... (function(w,a,s,g,l){w.onfontsready=function(e,t,n,o,i,z){for(n=n||0,o=i=0;o&lt;e[l];o++)z={},z[a]=n[a],z[s]=n[s][l]?n[s][o]:n[s],z[g]=n[g][l]?n[g][o]:n[g],w.onfontready(e[o],function(){++i&gt;=e[l]&amp;&amp;t()},z);n[a]&amp;&amp;n.onTimeout&amp;&amp;setTimeout(function(){i&lt;e[l]&amp;&amp;n.onTimeout(i=NaN)},n[a])}})(window,'timeoutAfter','sampleText','generic','length') 334 characters?
O use to use catch in the most low level possible, usually the catch of a promise, and I deal with data with this structure: ``{error, data}`` So the promise **always** resolves an object with that structure and you don't have to deal with try-catch in higher levels, but you can do ``if(error)``
4 things they got right compared to what? Every single one of these Vue.js articles it's like... dude no one cares unless you give exact reasons why it should be used over React, very specifically, very upfront so we don't have to go hunting for it. Just from a popularity standpoint no one should use Vue.js so the only thing it has going for it would be that it works better for some reason. Make the article that shows that and does so effectively.
May get downvoted, but jQuery will help with this. Simplified DOM manipulation and AJAX calls. Plus plenty of examples on the web and documentation for what you want it to do.
If you're not doing any fancy ajax-y stuff, you could just post form data to your express routes. Then use something like [Passport](http://passportjs.org/) to do the authenticating and session handling. If you're looking for something more structured on the back-end I've used Sails.js with success in the past (though it seems to have fallen out of favor lately). Adonis seems pretty decent too.
Visit https://kangax.github.io/compat-table/es6/ Suport in Chrome 54 and Node.js 6 and 7 is 97%, Safari 10 is 100% and Firefox 49 is 92% (without flags used for non-production ready stuff). FP, OOP and standard libs all are nice things to learn, just don't discourage people off learning the full ES6 when they don't plan it for production usage.
I'll try and take a look tonight, but 334 before gzipping is good right ;). A quick gzip file.js resulted in a file 238 bytes long... I'll clone the repo and see what I can do to get the whole size down ;)
Understanding what it even is &gt; learning it.
&gt; No JSX, but just shorten that bulky React.createElement to ce and it's pretty clean. Other vdoms do that by default too, e.g. the factory function of snabbdom is `h`. ES6 proxies might even allow a builder-style API e.g. `h.section({}, …` although I don't know how fast ES6 proxies are in existing implementations.
~~Have a look at http://www.iteral.com/jscrush/ (https://github.com/gre/jscrush)...~~ ~~If I manually gzip the file using linux gzip, rather than the gulp compression (I'm not familiar with this build environment), the original file is 381 bytes (vs the official 371 bytes). If I JSCrush this, I get a file that after gzipping is now 362 bytes... (which if this were in the build process, it could be a couple of bytes smaller I guess).~~ ~~This is without doing ANYTHING to the source code.~~ I tried using gulp-jscrush, it made the original file smaller, but gzip not so much. The way the source is transpiled from ES6-&gt;5.1, I'm not sure if I'll be able to do anything to reduce it from the source side... but I'm going to try :)
Well, that doesn't seem like it benefits you in any way. Maybe you should work on that.
you mean, if I have app.html, app.js(script linked to app.html with jquery) and server.js(where are node and express), I send a post request from app to server and server return true or false if user exist in database?
There's plenty of view specific logic I see little need to put in the component controller, like a boolean to toggle whether an expander panel is open. Like any tool, you can take it too far.
Interesting idea - it's not that far off from haml (or slim) in the ruby world, if it could look like that. One thing I didn't mention that I really like about the `ce` style I use, is it's much more explicit about what renders to an element named that in the DOM, and what's a React component. JSX simply implies from the name, which relies way too much on convention. e.g. if you had `import { Table } from 'furnituretypes';`, then later went `&lt;Table`, then that's not a `&lt;table&gt;` element, but the object. Doing it sans-JSX lets that be clearly defined, `ce('table'` vs `ce(Table`.
Oh, I get the hate for logic inside the template, but you're absolutely right that it was ubiquitous in almost every templating language. The first earnest attempt I saw at components-based templates was in the highly-academic but overly-strict (and always poorly implemented) XSLT. In XSLT-2.0, they saw the problems with branching conditionals and loops inside of a template, and defined everything as an individual component template, you would include via `&lt;apply-templates&gt;`. It's not just a problem with inlining the JS, but thinking in terms of components is important in moving away from writing "pages". We've seen these trends in other areas too: web components (obviously), shadow DOM, OOMCSS and BEM, etc. Personally I'm fairly ambivalent about inlining JS, it's when I can't understand why a line of HTML gets rendered without looking through 4 branches of conditionals inside a loop first.
Glad they got rid of the asterisk actually. I think Promise.all works fine and it's explicit.
"Why semver sucks" in a nutshell...
I got 49 the first time, and then the second time I ran it, there were two invincible ones at generation 15.
https://css-tricks.com/almanac/properties/c/cursor/ You would look for the mouse-down or click event and change it to the other image. 
JavaScript is structured, or rather uses the *scope model*, after lisp. If you want code structures to make sense in this language you absolutely have to understand how scope works. Secondly, you are probably going to want to understand inheritance. I am sure you probably come from the Java/C#/C++ world where you cannot escape the OOP classical style of inheritance. That world does not apply here. If you attempt to force that bias into this language you can hobble along for a little while, but eventually you will fail and your code will be a mess. **First, lets learn about scope.** The term *scope* is a fancy word that determines access to or availability of resources. Before ES6 there was only global scope and function scope. var a = function () { var b = 1; }; In the above code *a* is in the global scope. Everything can access it. Anything can reassign and clobber *a*. Variable *b* is in the scope of a function. *b* is not available to the global scope as it is only available within that function. var a = function () { var b = 1, c = function () { var d = 2; }; }; Scopes can be nested. Again, *a* is a global. *b* and *c* are declared inside a function. *d* is declared inside a child function. *a* has no visibility of *b*, *c*, or *d*. *a*, *b*, and *c* have no visibility of *d*. The single most important concept in JavaScript is **closure**. There is a big fancy definition for that term. The simple definition for closure is when you *cross a scope boundary to access a reference*. Look at the following example: var a = function () { var b = 1, c = function () { var d = 2; return b + d; }; }; Notice the statement `return b + d;`. *d* is declared locally, but *b* is declared in a higher scope. This is referred to as a *closure*. Closure can be used to share information between various areas of code that otherwise cannot see each other. Closure can also be used to output information from a lower scope to a higher scope as in the following example: var a = function () { var b = 1, c = function () { var d = 2; b = d + 2; }; }; *b* is reassigned to the value of *d* plus 2. References declared outside the child function, such as *b*, cannot see into the local scope and so cannot access *d*. However, lower scopes can access references declared in higher scopes. With ES6 JavaScript gained block scope in addition to global and function scope. Since function bodies are blocks you don't really need to worry about function scope any more except for backwards compatibility with older software. A block is typically code encapsulated by curly braces that is not an object literal, such as the bodies of loops and conditions. **Now let's look at inheritance** In JavaScript inheritance is optional. It is never forced on you and you can happily avoid it forever if you wish. I prefer to never use inheritance as my personal opinion in my own code, for example. As such I am not an expert on the inheritance model, but this is: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain
Vue is faster, licensed better, and the syntax suits me more than React's. Those are _my_ reasons. 
97 for me
Seriously. That's like teaching beginners directly to level 6 instead of level 1.
&gt; ...that's impossible. You can't return anything from a constructor, and you'll always get an instance of the class you instantiated. &gt; Nope. For instance, try this out: class F {} class G { constructor() { return new F(); } } var a = new G(); a instanceof G; //false a instanceof F; //true
You should refer to Abode Acrobat's documentation regarding their document framework in JavaScript context. Anyway, in your code... I'm guessing here. Event object should represent the event, not the object which triggers or involved the event. So, if an event has a `value` property, it's probably the event type. e.g. click or key press. The radio button object should be in the other property of the event object.
&gt; Moreover, I'm not sure the pooling example is even a good argument because use of constructors wouldn't break that kind of implementation change since you can return objects from them that aren't the newly instantiated instance. Presumably the point is to avoid object allocation/deallocation, but even if you're pulling from the pool inside the constructor, you would have already created an object with `new` which would then just get garbage collected away. 
The Vue docs have a detailed comparison between React and Vue. They got feedback from some React maintainers so it's as close to unbiased as it can be considering its source. In my opinion, if you're comfortable with one there isn't much reason to use the other. With the Vue 2.0 release, they are very similar. Switching to Vue comes at the cost of giving up React's ecosystem, which is probably too much of a barrier for most. One of the concrete reasons to use Vue over React is if you are hitting React's performance ceiling. Vue is faster than React without need for hand optimization, with the caveat that React is normally more than fast enough. Personally, I prefer Vue so I'm likely biased. I just feel more comfortable tackling problems with Vue than I do with React. 
X-Post referenced from [/r/reactjs](http://np.reddit.com/r/reactjs) by /u/UnReaL816 [How I Learned React &amp; How you can too](http://np.reddit.com/r/reactjs/comments/5c9qa7/how_i_learned_react_how_you_can_too/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Hi /u/llSourcell, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `Sirajology - YouTube`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [Sirajology - youtube.com](/search?q=%28and+site%3A%27youtube.com%27+author%3A%27llSourcell%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|261|57% [Sirajology - youtu.be](/search?q=%28and+site%3A%27youtu.be%27+author%3A%27llSourcell%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|37|8%
[I cheated](http://imgur.com/a/oy6v1). Wondering why the downvotes. I thought it was interesting that 1,000 "birds" created a successful generation in just 2 generations.
Something like https://github.com/dozoisch/react-async-script
What are the advantages of saving source to the url?
Yes.
Actually, now that I think about it, wouldn't this: &gt; of course you risk collision with existing globals. Be the same in all languages? Thus the reason you'd want the robust namespacing convention. (In most languages this is: extension.url.namespacing, for example: com.yahoo.namespace). So this shouldn't be any different than other languages I would think. As for the lack of garbage collection, would you not also NOT want your 'definitions' of classes and objects to be garbage collected? In my head, the idea would be to load the script so all definitions are on the "window" object, then in a closed module, actually run the code that creates instances of those objects, no? 
If you're targeting only the browser environment, this is fine. `window` is global there, and its the easy way to both check for and create if needed the top level namespace object by going through the `window` object. Alternatively you could use `typeof MyNamespace` and then, if undefined, define `MyNamespace` directly in the current scope (no `var`) which would likely make it global, getting around the call out to `window` directly. But this fails if your code happens to be wrapped in any strict-mode function call where attempts at global definitions like that are disallowed. For more cross-environment friendly coding, you'd likely instead want to define your code in node-friendly modules and have a tool like webpack compile those down into a browser-friendly js file. The concept of namespacing changes then since you'd be using something like `require()` to capture a module definition as a single value defined however you want in the context of the caller, and possibly namespaced further in the module definition itself (if not simple just mapping to multiple definitions within that single return)
Thats the _idea_. But I think that's debatable, especially in modern JS runtimes. I think the overhead of creating unique functions like that is minimal. Every time it comes up I think about trying to test it out, but I ultimately don't care enough to go through with it ;) Nevertheless, its good to know each approach since you'll likely run into code that uses them both. Plus, as I mentioned before you have the `class` keyword now... class MyClass { constructor (value) { this.value = value; } setValue (value) { this.value = value; } getValue () { return this.value; } } As well as other variations of the module pattern on top of actual modules in which the module pattern largely simulates, though you're very likely to see prototype-using definitions there (and Node modules are separate from newly spec'd ES6 modules too...). Like with a large box of legos, people found many different ways to build a house.
Did not know about this specific awesome list. The awesome lists are truly an awesome initiative. Thanks for sharing.
dun read this wrong – i'm not saying ES6 is bad or shit isn't worth the time to learn. it's in context to a beginner and what to learn first. i assume there are things any developer must pick up out of own curiosity. to a beginner it's more important to introduce FP, OOP and some standard lib stuff than explain how promises work and when to use them, which is something an intermediate programmer should learn on its own IMO.
found it! https://jimwebb.com/unicorn/ 
&gt; If you're using the new FacebookIntegration() syntax, and then you realize you actually need the flexibility of a factory method, you'll have to change all your code to the new FacebookIntegration.getInstance() syntax. That's a pain! If you used the factory syntax everywhere from the start, even before you needed the flexibility, you wouldn't have to change anything outside the class. This is also a perfect use case for _interfaces_ and DI, which will get you out of this bind as well. You no longer have to worry about how to create the concrete type, nor do you need to concern yourself with the concrete type.
I use airbnb but add a few overrides like not forcing comma dangle, and I'm used to using 4 spaces for indents.
Interesting, tries &gt; 150 and highest score is 1k and most of the time its not getting passed like 10 pipes.. Other ones have became invincible after &lt;30 or &lt;50, and another one took 94 i believe edit: screenshot: http://imgur.com/a/IYhFv edit 2:Still going 190 tries, something interesting to note is that it keeps getting a high score then dying http://imgur.com/a/mm3qv edit3:200+ tries http://imgur.com/a/P0lSu edit4: Notice the high score, usually by that point its invincible, no? http://imgur.com/a/95Qr4 edit:5 Got up to 20,000 then died: http://imgur.com/a/Ov42b edit6:214 tries it got all the way up to 80k and died: http://imgur.com/a/4UOMl
Nice. And likewise in C++, we can define what calling "new" on a class actually does. class Foo { public: void* operator new(size_t size) { return new string{"Wha-eva! I return what I want!"}; } };
The original iphone/android game had more difficult controls. The head would go more down if you had to go from very high to very low in one jump, and I think it accelerated more. I'm not yet convinced that this algorithm will beat me in original iphone/android game :P 🤓 It was quite difficult to time those headlong dives correctly sometimes. But yeah, for the rest, quite awesome.
It's fine, nothing is sent anywhere.
Do you find when you have loads of test files, Ava is actually really slow to start and spawns processes like mad taking over your computer for the duration of the tests? We've got around this with the `--concurrency={x}` flag but it's a bit mad that it will just uncontrollably spawn processes rather than pooling processes to keep it under control. 
Here you go: https://jsfiddle.net/utzd6mwr/
thank you!
Invincibility at 32nd generation.
I asked this a few weeks ago, some of those responses might help. https://www.reddit.com/r/javascript/comments/58m352/why_we_chose_vuejs/d91ploh/ My takeaway from it was "no, there is no reason to move from React if you are happy with it." The majority of glowing Vue reviews seem to come from people who didn't like React's rigidity or are new to SPAs. I happen to love the React approach, it feels predictable and encourages many heathy practices. 
UPDATE!: I've let this run for about 2 hours, High score was 241K, but it died after that.. It's on 225 generations now Pic below vvv: http://imgur.com/a/FC5XR Also, I have another one running for about a little over 2 hours on 5X and it's been going since it became invincible and high score is 1.5MILL+ , Pic below: http://imgur.com/a/WLEzu
idk, maybe because it's not really cheating?
It's what made the game such a success, I think. We've probably all made a game like flappy bird but flappy bird had a good art style and it got the feel and difficulty just right.
That would likely be the best way to do it. Alternatively, you can always do something like &lt;script&gt;window._MyData = &lt;?= json_encode($data); ?&gt;;&lt;/script&gt; In your template before your bundle is included. Then just create a module that has something like: export default window._MyData; And import that data in from your other modules (not strictly necessary, but a good way to not have "window." littered around the rest of your modules - accessing window. should be avoided unless absolutely required).
&gt; This can also be read as "an additional microlanguage!" One of the big sore-spots with angular, that drove hordes of people to React in the earlier days, is around microlanguage. That's odd, because I had the opposite impression. It seemed that people moved to React *despite* JSX, not because of it. Every blog post and comment I've read about moving from Angular to React a year or two ago, treated JSX as something you "get used to", or at most, something that's "now that I think of it, it makes more sense". The reasons to move seemed to be mostly around performance, two-way binding shell-shock, and the weird and complex API and terminology, rather than its templating language. Honestly, it seems that Vue's choice to use Angular-type templating, while being much simpler and faster than Angular, is its main selling point over React. And the fact it's growing in popularity, shows that it might have a place. Like in cases where you don't really need to create a full-on SPA, or a completely self-contained "component", but to add some functionality to an existing web page. Finally, you called it an old-fashioned approach to templating, that was overwhelmingly replaced. What did you mean, exactly? Because I might be living under a rock, but it seems that this approach was only replaced in a single major framework, React. Aside from Vue, Angular 2 still uses the "old" approach, and while I'm not that familiar with Polymer or Aurelia, they both seem to have similar constructs (dom-repeat/repeat.for etc). Did you just mean that in your opinion, React replaced all the other frameworks?
I just published a blog post about this: https://medium.com/@thejameskyle/awards-in-open-source-35d21fc38f29
The counterpoint to *that* is that Angular is *waaay* more popular than React, and Vue is much more similar to Angular than React is, while still providing the traditional React advantages (simplicity, performance). You might see less job postings asking for experience with Vue at the moment, but it seems like a very likely future. The industry invested so much in Angular, and now that Angular 2 threw them under the bus, they might be looking for the most friction-free alternative. And Vue is a great candidate.
Why is there so much variance in how quickly it learns? I would think that it would break the same score in roughly the same amount of generations.
Got invincible after 5.
&gt; The microlanguage was in angular Yeah, I got that. I just didn't get the part where you said that this microlanguage drove people to React and JSX. It seemed to me that that microlanguage is one of the things people were actually fine with in Angular. They moved to React because of its speed, the simplicity and relative sanity of its API, and the server-side rendering. Moving from Angular's templates to JSX was mostly presented as a reasonable price to pay, rather than a reason, let alone *the main* reason to switch. *Especially* in the early days of React. Note that I'm not saying anything about whether JSX is objectively better than Angular's templates. I'm talking about how they were accepted by the webdev community, especially in the early days of React. It seems that my recollection of how it went down, is dramatically different than yours, and I wonder why that is. &gt; React has certainly not replaced everything. There's polymer, sure, but I'm referring to the pattern, not a particular lib. You could be using underscore templates, handlebars, or even just wrapping template functions that return strings Sure, but in this particular case, I just wondered what you meant by calling the Vue/Angular method "old-fashioned", that was "overwhelmingly replaced". Replaced by whom, and where? If we're not talking about the fickle world of Javascript frameworks, do you mean the industry at large? Because I haven't seen any industry-wide tidal shift to the React's approach to templates, over Angular's or Ember's. Hell, Angular specifically is still a freakin' behemoth compared to React. Or did you just mean replaced in your own company's code? Or maybe *should* be replaced, because it's worse? 
If y'all have any feedback, make sure to leave it on GitHub. The guys in charge of this project are super cool and very receptive to feedback.
&gt; Using Math.round() will give you a non-uniform distribution! Why? 
Looks great!
Anything remotely connected to MS Office makes me nauseated. But the new stuff coming out from MS I like - Typescript and VSCode are superb.
Office? Does anyone even use that proprietary garbage anymore?
There were some clues! I managed to reduce the compressed size by 5 bytes to 366 bytes (and 4 bytes for legacy: 440 bytes). window.onfontready=function(e,t,i,n,o){i=i||9,i.timeoutAfter&amp;&amp;setTimeout(function(){n&amp;&amp;(n=document.body.removeChild(n).e,i.onTimeout&amp;&amp;i.onTimeout())},i.timeoutAfter),o=function(){n&amp;&amp;n.firstChild.clientWidth==n.lastChild.clientWidth&amp;&amp;(n=document.body.removeChild(n).e,t())},o(document.body.appendChild(n=document.createElement("div")).innerHTML='&lt;div style="position:fixed;white-space:pre;bottom:999%;right:999%;font:999px '+(i.generic?"":"'")+e+(i.generic?"":"'")+',serif"&gt;'+(i.sampleText||" ")+'&lt;/div&gt;&lt;div style="position:fixed;white-space:pre;bottom:999%;right:999%;font:999px '+(i.generic?"":"'")+e+(i.generic?"":"'")+',sans-serif"&gt;'+(i.sampleText||" ")+'&lt;/div&gt;'),n&amp;&amp;(n.firstChild.appendChild(e=document.createElement("iframe")).style.width="999%",e.contentWindow.onresize=o,n.lastChild.appendChild(e=document.createElement("iframe")).style.width="999%",e.contentWindow.onresize=o,e=setTimeout(o))}; * Changed `options = options || 0;` to `options = options || 9;` * Changed `monospace` to `sans-serif` (knew about this one, but was wary of it, and it didn't compress any better before), also legacy also changed outer `monospace` references to `serif` * Changed the ending innerHTML string parts to to use single quotes instead of double quotes: - Changed `"&lt;/div&gt;"` to `'&lt;/div&gt;'`. - Changed `"&lt;/span&gt;.&lt;/table&gt;"` to `'&lt;/span&gt;.&lt;/table&gt;'`.
It's amazing how the game AND learning algorithm takes just 500 sloc without any dependencies. As someone without any ML knowlege I'd love to read this code explanation.
Ugh. Fucking Aussies. 
Hassle free. No reboots. No crashes. Software works. Looks beautiful. Amazing short cuts. 
If this is what they're using for O365 Outlook then it's great, and improves almost daily. 
The problem with short URLs is that you still need a database to store the long URLs in. The problem with long URLs is that you still need a site that converts the string to the code. After 2,048 characters it breaks in IE.
A lot of design tools are only available on OSX
ES6 has no proper classes, it's syntax sugar for inheritance. 
Express is by far the most popular, but development has almost stopped since it was acquired. It also suffers from "callback hell". Koa is actually the spiritual successor to Express (both were created by JS legend TJ Holowaychuk), but although development is ongoing, it's still progressing slowly. Koa is further hampered by the ongoing transition to Koa2, which is still in beta. Hapi is another contender, supported by Walmart, of all companies. It favours a more declarative approach and seems better suited for enterprisey stuff. FeathersJS looks promising. They build on top of Express, but will soon allow you to run it on top of Koa. Finally, the new kid in the block is micro, developed by the guys behind socket.io and the amazing next.js. It favours a micro-service architecture and is as far as I can see the only one to fully embrace ECMAScript 2015 (aka ES6 aka Harmony), which coming from Python is really the language you want to be using.