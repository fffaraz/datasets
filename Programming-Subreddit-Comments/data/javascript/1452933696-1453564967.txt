I agree. And if you want to be nice to your users, make sure your github process involves minifying, posting to a cdn and updating the readme with links to those versions.
explain to me how you get confused by `\n` as opposed to `;\n`. because if that is all it takes to tilt you're creative mind im just happy you don't run dev ops at my work
Except not really because it isn't compatible with anything that isn't WebTorrent. They basically have their own protocol which is similar, but not the same as bittorrent - so no compatibility between them.
Either WebWorkers or batch processing. I'd first try batch processing because it'll be easier to integrate. If that doesn't pan out you can invest to move the heavy work in a WebWorker. To use batches simple put all your jobs (SVG element additions) in an Array (or generator!) and only process a part of it per cycle and then use a setTimeout (or better a requestAnimationFrame or setImmediate) to give the UI an opportunity to update. Ideally you don't have to do much work for this: generating 100000 closures upfront might not be a good idea, instead use a simple array that holds pointers to the SVG elements you want to process. You'll have to experiment (measure!) to find the ideal amount of work per frame. You can go fancy and use performance.now and dynamically chunk the work for a certain update frequency (so it might take longer on slow machines but still keep resonsive, and do a lot at once on fast machines). Best to run some timers and animations to measure and see if this helps.
Could this be turned into something like a peer based cdn?
I thought the limit for peers on webrtc was 256, maybe it changed.
He's probably working in the military
Or he uses standard...
Put your code into as many ES6 modules as you need to keep things organized. There is no performance downside to this. What's ultimately sent over the wire is a single bundle which only contains the parts you actually used (tree-shaking). The unused constants/functions/classes do not contribute to the file size. If you want to improve the performance of your application, profile your code to identify the actual bottlenecks. If you fail to improve the performance, revert to the previous version if it was more readable.
Storage is actually unlimited on all platforms, you just need to use Indexeddb and request the right storage permissions on all platforms.
I'll have another look at the code and see what I can do. As for three.js performance, it can handle much more than the few thousand polygons I throw at it and not suffer a noticeable drop in responsiveness.
It means that the JavaScript should be loaded in after the page loads, not before or during the page loading. This here is a PERFECT example to explain why to hire a web developer. Everybody always says "I can just use those tools to drag N drop make my website, why should I hire someone else?". Well. . . this. The drag N drop tools create horrible code, do little to no optimizations, and will make it even harder in the future for a dev to fix things. Anyways, sorry about the rant, this was just too perfect of a situation.
&gt; Or he uses standard... standard... what?
Go to [coursera.org](https://www.coursera.org/) and [edX.org](https://www.edx.org/) and learn something. You seem to concentrate on thee *tools* - equivalent to people wanting to learn all about all the types of hammers and chisels and saws etc. The bottom-up approach certainly has some appeal, just learn the tools and then figure out what to do with it, but it seems you are at an end so why not try the opposite: See what problems there are instead of what tools. Also, I found it VERY enlightening to learn R, the statistics software. When you do that you really don't learn "R" the language, that would be most useless (it's just another programming language), but you learn STATISTICS. Hopefully thoroughly and not just superficially. Back during university I loathed statistics (in my 2nd study of business administration, it wasn't even part of my main study, which was CS), I had no trouble getting good grades but I really learned only for the tests and promptly forgot everything afterwards and never cared about really understanding it on a deeper level. There are great courses on both the above mentioned platforms, many of them have a biological or medical background - statistics is HUGE in genetics and medicine (medical studies). Or you can go the route of IoT (Internet of Things), embedded, modeling, machine learning (which requires a good knowledge of statistics because that's what it uses a lot). If you take courses on the above websites you'll get plenty of ideas. Trying to model neurological circuits from data in computational neuroscience for example exposes you to statistics, modeling, neuroscience, programming. [Coursera had a course on how to interpret the (huge amount of) data coming from an fMRI](https://www.coursera.org/course/fmri1), to give a high-level example (finished courses can still be accessed). So my advice is to *step up and outside*. Or you'll end up one of those filling the endless discussion threads about "Javascript: to semicolon or not? --- read the valuable comment #5,434,123,001,234,173 on this exciting subject!" Or you'll write the 1,000,000th ultimate blog post on monads. &gt; Any tips, ideas on how to get 'into the circle' of advancement? As far as I'm concerned, not by staying *within* the field. IT is all about IT for too many people already. In my area there are various meetups (on [meetup.com](http://www.meetup.com/)) of IT people for IoT or "Health 2.0 - the quantified self" (with the meetings taking place right at the university clinic, so truly with doctors and programmers). You won't believe how much IT of all kinds the health field requires, and it's such a huge growth field! . PS: Ignore the useless "verified certificate" crap on those websites and they are 100% free. If you want proof you took a course take a screenshot of your results and save it as your own self-made "certificate". That was the tip of an HR person here on reddit. 
https://github.com/feross/standard That's where all the "don't use semicolons" stuff has come from recently.
udacity.com, coursera.org and edX.org all have courses that you can take for free (if you are smart enough to ignore the useless "certificates" - you can simply take a screenshot of your accomplishment page and save that if you think you need something to show). Also read [my comment in this thread](https://www.reddit.com/r/javascript/comments/417cr8/advancing_from_development_to_innovative/cz0di19?context=3).
you might get better help searching something like "speedy wordpress javascript" or "improve wordpess javascript load times" try adding "async" to the script tags in the &lt;head&gt;, ex: `&lt;script src="plugin.js" async&gt;` That might give some speed, but it might break some stuff. Explanation: the page you linked suggests what many html devs do: &lt; html&gt; ... &lt;body&gt; [images and content that is rendered first] &lt;script&gt; document.onload = function() { ... do js stuff ... }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; the bad news is, looking at the code it has * 10 scripts in header (not that bad, just a little heavy) * the wordpress plugins all use inline scripts ex: `&lt;myimageslider&gt; &lt;script&gt; $(function() { docrazy_jquery_stuff() } ) &lt;/script&gt; &lt;/myimageslider&gt;` * does WP let you move scripts out of the header? you might not be able to move them if all the those imageslider/etc plugin scripts use jquery's ready function, you can move the header scripts to the body. but idk if wordpress will let you, they might be printed there. maybe someone else can advise maybe using cloudfare CDN will help and thats a free service. (tbh 8 sec is not that bad, it didnt seem slow for me really)
 &gt; One Style to Rule Them All https://xkcd.com/927/ It's not even better than eslint, it looks like he just npm'd his favorite eslint config. &gt; No decisions to make. No .eslintrc, .jshintrc, or .jscsrc files to manage. It just works. &gt; No configuration. The easiest way to enforce consistent style in your project. Just drop it in. That's weird, I don't remember any of those requiring managing or not instantly working out of the box. In fact, when the project manager disagreed with a style, he was disable it with less than a minute of googling. &gt; Catch style errors before they're submitted in PRs. Saves precious code review time by eliminating back-and-forth between maintainer and contributor. But that was already a feature of the pre-existing standards... &gt; - No semicolons – It's fine. Really! &gt; - Never start a line with ( or [ &gt; - This is the only gotcha with omitting semicolons – automatically checked for you! Seems like it would be easier to just use semicolons and not worry about things like gotchas.
The very first byte of the document already takes about 2 seconds which is pretty bad. A browser is unable to send any other requests before it hasn't seen anything of the document. It takes about 3 seconds until anything is rendered and 4.5 seconds before any text shows up. There are caching plugins for WordPress. Try one of those. Also, hijacking the mouse wheel is pretty annoying.
Now that you know the basics its time to apply. You can use this book https://pragprog.com/book/bhwb/exercises-for-programmers 
Hey I'm done defending it, look at all the downvoted answers in this thread for my responses to you here. But you can use what you want, I'll continue writing JS without maintaining silly config files, without caring about semicolons, and all while having all my shit look the same.
My only beef is that it's pretty arrogant to add nothing to a solved problem and call it "standard" instead of "ferosslint".
I generally put the "why" near the point of the code, either inline for small comments or atop the function/block for larger ones. Of course don't bother is you are simply stating in English (or your preferred natural language) what the code is saying (I'm sure we've all seen "increment loop counter" comments and equivalent). Comments like that describe briefly why the code works the way it does (for long text, consider including only a summary and a reference to external documentation either also in the repo or elsewhere). Commit messages are to me a *summary* of the changes with the more detail "why" being in the code. Of course for small check-ins (for simple bug fixes rather than larger changes for example) a small commit message is sufficient space to provide the full explanation.
I mean the readme answers that.
Oh I understand that, and the rant wasn't at you specifically, but I see posts on here all the time of people asking how can they explain the true value of hiring them over doing it themselves. This here is how (well at least part of it)
I love Ruby but miss the clarity that semicolons and braces bring. Edit: I also really like comic sans and Nickleback. Trump 2016!
There is no return in the function I wrote
I know something that can give you more downvotes than not using semicolons: I love comma-first var foo = 1 , bar = 2 , foobar = 3 , lorem = 'ipsum'
I'll describe a path for you that should open your eyes to using js in websites. - learn some html and css (assuming you haven't already) - get familiar with &lt;input&gt;s and &lt;button&gt;s and the like... html elements that typically have some js functionality - get real familiar with these guys: `document.querySelector()`, `document.getElementById()`, ...`ElementsByClassName()`, ...`TagName()` - then realize you can move things around with js code and you can change most all if not all css style elements either directly or by adding/removing classes Message me if you want any guidance. Feel free to join us in /r/javaScriptStudyGroup
I'm not saying you shouldn't learn. I am simply stating this is a perfect example of the value gained by hiring a developer over doing things yourself. Again this wasn't specifically at you, or your situation. Many developers on here have a hard time explaining to a potential client what value they are actually providing, when the client could use point / click things to make their own website. I was simply stating this was a perfect example to use to show the added value of a developer.
Exactly! Luckily imaginary internet points don't matter when it comes to my work, so they can downvote all they want. I'll still laugh at their pathetic attempts to persuade. 
It's pretty arrogant to force your personal preferences on other people too. Yet here we are.
Uhhh, I use a linter to catch other mistakes. Saying "Just use semicolons you won't have to use a linter then!" is foolish, and quite frankly if any of my developers said that to me, I would fire them on the spot.
And you're being downvoted for saying the exact same thing the tard yard is upvoting me for, only difference is you mention not using semicolons. This sub is really full of some special people, and I'm not talking about special in a good way.
Does that book focus on JavaScript only? I don't see any mention of JS. When I see "Exercises for Programmers," I assume it involves a variety of programming languages. Please confirm. 
Cool, I'll definitely follow along. Also, subscribed. 
Awesome! Feel free to join in on the discussion! Another tip... when you get to manipulating css... `element.setAttribute("class", "className");` and `element.style.cssStyle = "cssValue";`
unless you're publishing a library
Are you doing this for client side Javascript? If so, this is a very bad idea. If the data is sent over plain HTTP, as you claim to not have HTTPS, the attacker can see any keys you send to the browser. The encryption is useless because the attacker will have the keys used to encrypt. The data must be important if you are thinking about encryption. Use HTTPS! That is the only way to ensure the data is protected in transit.
Read this book and do the projects it suggests http://eloquentjavascript.net Also check codeschool.com and udacity.com (https://www.udacity.com/course/web-development--cs253)
If you paginate through the data on the popup, you'll see this URL in the Network tab on Console: It's a POST request with form data, but it seemed empty, and I was able to use a GET and retrieve data for it. https://ptabtrials.uspto.gov/prweb/PRWebLDAP2/HcI5xOSeX_yQRYZAnTXXCg[[*/!STANDARD/$WorkProcessing?pyActivity=ReloadSection&amp;=&amp;&amp;pzFromFrame=&amp;pzPrimaryPageName=pyWorkPage&amp;StreamName=DocumentListReadOnlyForPublicView&amp;RenderSingle=EXPANDEDSubSectionDocumentListReadOnlyForPublicViewB&amp;StreamClass=Rule-HTML-Section&amp;bClientValidation=true&amp;PreActivity=pzdoGridAction&amp;ActivityParams=gridAction=PAGINATE&amp;gridActivity=pzGridSortPaginate&amp;pyPaginateActivity=&amp;PageListProperty=.pyFileAttachment&amp;ClassName=Data-WorkAttach-File&amp;BaseReference=MasterDocList&amp;startIndex=21&amp;currentPageIndex=2&amp;pyPageSize=20&amp;isReportDef=false&amp;prevStartIndex=1&amp;UsingPage=true&amp;BaseReference=MasterDocList&amp;ReadOnly=0&amp;FieldError=&amp;FormError=&amp;Increment=true&amp;pzHarnessID=HID1452966613502 It's a simple pre-rendered HTML page that has the links to the other items. Also looks like the URL query params `startIndex=21&amp;currentPageIndex=2&amp;pyPageSize=20` are your pagination params. Not really sure which part of that is the actual ID used for reference of the Patent. Figure out which is the ID, how to get the ID, and write a small script to parse the HTML to create your own dataset. Fairly simple web scraping.
That one is understandable because you can remove lines without worrying about commas. Looks fucking weird but it's fairly practical.
Not bad! I guess that's like, "medium level" AI hehe. Nice work though =D
I like how it explodes when you set "relaxation" to 0.
Unless you code with that style AND semi colons. Then you always have to fuss with the last line.
Only had one interview give a quiz, but it was "write an algorithm to calculate the total number of gifts recieved in the song 'the 12 days of christmas'" 
That's a nice one! Kinda sums it all up in a few nice slides. Cool.
People still use Heroku? LOL, why?
aws lambda
ty :)
Build it into the tracker.
How big is `replacementTable`? It looks like you're doing a tree traversal for every item in that array.
For one thing, it's going to be more efficient to loop through the nodes and scan the replacement table for each node rather than scanning all nodes for each entry in the replacement table. Also, I think there's a jquery selector that allows you to select nodes based on text content in the node. Not sure what that is doing internally however and whether that would really be more efficient. 
I don't know what you plan on using for your server side, but if you really want to take advantage of learning, try getting a Node server running https://nodejs.org/en/ which is just JavaScript on the server side, then as you build your front end stuff, you could start maybe implementing some more server side, websockets, whatever you want to make your front end stuff more interactive
[Github](https://github.com/AdamColton/asmJsMandelbrot) Wanted to try writing ASM.js by hand, this was what I came up with.
Is a partridge in a pear tree one gift or two? var gifts = 0; for (var i = 1; i &lt;= 12; i++) { for (var j = i; j &gt; 0; j--) { gifts += j; if (j == 5) sleep(10); } }
It's kinda more a part of being competent on a team. I cowboy all kinds of shit, I write coffeescript constantly and use whatever I need to get the job done. Best practices are for refactoring. **At home.** If you work with other programmers, you are fucking up by writing non-standard JS. You can't think it's a good idea to expect every new hire to familiarize themselves with your own particular dialect of JavaScript. 
Tough to answer, the best coding questions start really simple but are adjustable: there is an easy "brute force" solution, but then several potential optimizations, and the difficulty can be varied by adding constraints, i.e. "can you scale to a million? a billion?" or "can you make it thread safe?" Most interesting one I had was something like given a set of players in a game and a complete history of their games played (who played and the score) generate a fair tournament ladder.
 &lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset="utf-8"/&gt; &lt;title&gt;To do list&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;MyTo Do List&lt;/h1&gt; &lt;h2&gt;These are the things I have to do:&lt;/h2&gt; &lt;div id="todo-list"&gt;&lt;/div&gt; &lt;a href="#" id="action"&gt;Click here to run.&lt;/a&gt; &lt;script type="text/javascript"&gt; (function () { var toDoEl = document.getElementById("todo-list"), tdl = []; tdl.push("Mow Lawn"); tdl.push("Cook Dinner"); tdl.push("Wash Dishes"); document.getElementById("action").addEventListener("click", function(){ var myString = prompt("Please enter another item", ""), l = ""; tdl.push(myString); l += "&lt;ol&gt;"; tdl.forEach(function (s) { l += "&lt;li&gt;" + s + "&lt;/li&gt;"; }); l += "&lt;ol&gt;"; toDoEl.innerHTML = l; }); })(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;
how do I marked this as solved or delete this thread.
Really? Just because I said some people find it easier to read and maintain code without semi colons, *without* indicating that I was in that group? Does that seem rational at all to you?
Type "Ionic JS tutorial" into google. Follow them. You are going to need more than one tutorial unless you are really familiar with a bunch of these topics and also very quick at picking things up. It's been about a year and a half since I last wrote one so stuff has probably been updated. 
I just wanted to share that I posted this yesterday and yesterday the application was downloaded almost half a million times. https://www.npmjs.com/package/prettydiff I don't suspect half a million people visited this thread in the later half of yesterday and all rushed to download the application, but since I have absolutely no idea where the traffic came from I will simply thank you for your interest.
Maybe. It seems to have something to do with latent coffeescript hate as well. I just don't think that emotional response is going to help anything. People who don't prefer semi colons aren't going to be convinced to use them just because they're downvoted or called retarded.
Try this: '！Ａ８～'.replace(/[\uFF01-\uFF5E]/g, function(char) { return String.fromCharCode(char.charCodeAt(0) - 0xFF01 + 0x21); }); Output: "!A8~" See also: https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms https://en.wikipedia.org/wiki/ASCII https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace **Edit:** I should probably mention that the key point is that textContent is only read once and only written once. Keeping the number of DOM interactions lower should help quite a bit.
The exercises are language agnostic but going through a lot of them would definitely strengthen your javascript chops.
This is probably the closest thing I can think of: https://github.com/getify/You-Dont-Know-JS It's not as focused on code examples like phptherighway. 
I've literally never ran into anybody I showed the lib to who felt that way neither newbies or seasoned veterans. Just like semicolons, it's haters using the potential issue of confusion as a reason for bitching about it, but nobody can actually say anyone was confused. Except you know the tards who go "Well I've been writing code for 93 years and I thought that the package was THE standard". Yeah because people use things blindly, purely on the name and not actually look at the package and see what it does. I mean, I installed Bookshelf ORM thinking I was really installing a bookshelf into my code. I was ecstatic thinking I could legitimately have a real bookshelf IN MY CODE. See how ridiculous this argument sounds?
Sweeet, now turn it into Mount Your Friends !
I made a React Native component that can wrap any View and cause the wrapped view to respond to touches with a bounce animation and onPress prop. https://github.com/slavik0329/react-native-bounceable
Was the experience positive? Is it like writing in any other assembly language?
Yea, that works because the fullwidth stuff is conveniently in exactly the same order as the regular ASCII characters. So, you only have to subtract the char code of '！' (0xFF01, the first full width character) and add the char code of '!' (0x21, the first ASCII one). It was relatively straightforward for me because I happen to know the right bits of trivia. I knew the wide ones are called "fullwidth", I've seen the ASCII table countless times, and I also know that there is a regex/function version of "replace". Well, now you know that crap, too. :)
Its not forcing anything, you don't need to install it... If standard is forcing you to use it, than your eslintrc is forcing me to use it.
I didnt write this application but why would you think that? ASM.js is just a subset of javascript.
I don't know if ASM.JS includes a virtual machine concept or registers, etc...
Learn more languages and programming paradigms. Are you already an expert on reactive programming with JavaScript? If not, that's an area fertile for advancement. 
Now you're grasping at straws.
&gt; ASM.js is just a subset of javascript. A subset which is meant to be written by a machine. There is no garbage collection, no strings, no objects, no anything. You get a typed array as "RAM" and you can create some functions which do some arithmetic. And of course you have to litter your functions with those pseudo type casts. It's a bit like taking C and making it a bit more like Brainfuck. A subset like this is very different from a subset which is meant to be written by humans (e.g. strong mode).
Most interesting and difficult question I had in an interview wasn't coding related at all. &gt; What is your favorite canned food?
Your comment is perfect.
Seriously! Way to go discouraging new people from even trying to learn JS with this nonsense. If I have ever learned anything from my non-techie friends, it is that they hate when there is more than one right way to go about doing techy stuff, in this case programming.
Oh wow.. First semicolons, now they want me to add a space after my function names. No frigging way. They'll be lucky if I add spaces in betweens the function's parentheses, when I have other functions or variables inside of them. This is how I have found it best for myself to read my own code when writing up functions: Just calling variables: function doMyTasks(task1, task2){ ... } Calling a function with variables: function doMyTasks( taskCaller(task1, task2) ){ ... } The lack of space with my style, shows (at least to me) a connection between the function's name and the parentheses that push whatnot to it. Those parentheses are "leaning" to one side. Not just floating out there on their own. Just my $0.02 ...
Then don't use standard... It's a choice, just like everything. At my company we went with standard because it's easy to setup and it just works.
There isn't anything wrong with my script. It works exactly as I intended it to since you never mentioned any of the reasoning behind anything and I had to guess. Same reason other people are asking for more details. Looking at the network tab shows that the work you need to 'spam' is in the "offer" function which is the click handler for the "B button". This is the only button you should be spamming. The code I wrote just needs modified to spam that button instead of C. The A button doesn't do anything except bring up the modal. In fact, you don't even really need to click it ever. Just go straight to the B button after the item has been selected. Then, on an interval use the code I put in the third example to see if the C button can be clicked (it's there always so you don't wanna spam it. It's just hidden. My code detects when it's visible.) Once it's visible just click it once. Be careful when clicking the B button though, there is a reason they want you to wait 60 seconds and it's highly likely their firewill will auto ban your IP if it thinks a DDOS is occuring or something from all the traffic coming through from a single IP. Good luck!
Alternate way, without nested loops: var presents=0; for (var i =1; i&lt;=12; i++) { presents+=i*(13-i); }
wait. What? AWS Lambda and Heroku are completely different platforms. The things that Heroku does Lambda is bad at, and the things that Lambda does Heroku is really bad at.
It has less to do with the language than the implementation. Comparing a weekend project to a more mature piece of software doesn't tell you much. See Xaos in JS. http://jblang.github.io/XaoSjs/ It runs well and presumably even faster if were using ASM.
&gt; The things that Heroku does Lambda is bad at, and the things that Lambda does Heroku is really bad at. Could you at least explain this?
It was actually the only question asked. I was perplexed and later asked why he asked that and why it was the only question. He said because everyone studies the usual questions and has predetermined answers already chosen. He wanted to get to know you as a person and see how you really are. All the other stuff was just technical mumbo jumbo. He wanted to know if I was the right fit for the team. He went on to literally become one of the greatest people I ever worked with. We fit together like peanut butter and jelly. We did some great things together for the company we worked at, at the time. My response? Baked beans.
I wouldn't call it positive, but I got what I wanted. ASM.js really isn't meant to be written by hand, but it gave me an understanding of the language (or whatever it is). I had to use an [ASM.js Validator](http://anvaka.github.io/asmalidator/) a lot to get this working. It's more like assembly that it's like JavaScript, but it's really not like anything else. You have to assert type all over the place. You've got access to some higher order functions (anything in the Math library). If you're interested, give it a try. I spent about an hour messing around before I decided to try this, then the core only took 2 or 3 hours to write.
Thanks!
Exactly, I chose it because I'm sick of the bikeshedding and it was easy to get started with.
WebRTC doesn't expose raw sockets.
 &gt;JSTorrent is a web browser extension. Yes, it is. &gt; This article is talking about plain Javascript that can be run on a web page without the user installing a browser extension. I guess, but I don't see much difference. &gt;Also it should be noted that this isn't really a standard torrent client, it needs a special intermediate server that it can communicate with (unless standard torrent clients decide to become compatible with it). AFAIK, it's a standard BitTorrent client. Wait, which one are you talking about? &gt; But it sounds like it would be a useful way for websites to let users download large files in a peer 2 peer way (to speed up downloads and save the server bandwidth). Isn't that what torrents do? &gt;And users wouldn't have to install anything or do anything special other than clicking a regular download button (I believe). Yeah, so you mentioned already, you really think torrenting is a one shot thing with users? There's very little overhead to Chrome extensions. 
What steps did you take to go about learning how to create something like that? Did you follow any resources / books / tutorials to help you with the process? 
http://jstherightway.org/
Also been working with it for a bit. Feel free to reach out. I'm writing an IRC client in it right now. It's basically a browser once you have it set up. Here's a tutorial I followed to get started: http://youtu.be/ojX5yz35v4 What are you building?
I'm using lambda (nodejs) to run a website, so i'm not sure why you think it can't. It's doing everything a server would do, there are endpoints that do all manner of things I used to do with a linux server. Not sure why you think AWS Lambda can't be used for that. Heroku and Lambda have differences in architecture, sure, but it isn't so fundamentally different that you can't do practically the same thing you mention doing with Heroku, though with a slightly different approach. S3 storage for static assets and Lambda for authentication, processing, database interactions, etc. Your '60 seconds' figure is also somewhat wrong I think. Each Lambda function has a timeout, but it's not 60 seconds unless you set it to be that value. From the Amazon site https://aws.amazon.com/lambda/faqs/: "How long can an AWS Lambda function execute? All calls made to AWS Lambda must complete execution within 300 seconds. The default timeout is 3 seconds, but you can set the timeout to any value between 1 and 300 seconds." I also like that I'm not paying for a server 24/7, I only pay for the execution time of the Lambda function. While true that you can't use it for long-running nodejs processes, it doesn't mean "you can't run a website on it".
Very nice. Writing ASM.js by hand is odd and wonderful and my hat is off to you for sharing it. You've answered the question, "do you even mandel, bro?"
FYI: That is a pretty basic freshmen or sophomore year computer science thing to know.
The `.npmrc` save-exact recommendation doesn't actually fix the issue of dependencies drifting because of deep dependencies. What you'll actually want to do is run [npm shrinkwrap](https://docs.npmjs.com/cli/shrinkwrap).
If you need to get all the text nodes on the page I wrote a handy little library that does that for you: https://github.com/prettydiff/getNodesByType You would just have to do something like `document.getNodesByType(3);` which would get you an array of every text node in the page. You can loop through the nodes and alter them directly without having to walk the DOM. You can test this out immediately and play around with by copying the code directly into your browser console
Pretty interesting, though at ~23 seconds, this is still worringly slow compared to /u/x-skeww's approach.
&gt; Lack of semicolons in JavaScript is a sign of some very shitty JS That's not true at all. All of npm is written without semicolons. All of Redux is written without semicolons. GitHub's style guide doesn't allow trailing semicolons. You're quite misinformed if you think a programmer's preference on semicolons indicates whether their code is "shitty" or not.
Then something failed. This function can traverse very large documents in mere milliseconds. /u/x-skeww's approach is for converting text strings, which is half your problem. You still need to walk the DOM to gather that text.
I don't know where you're coming from, but I recently went from having just heard about Heroku to having one of my beginner node projects built and live in a matter of *minutes* and with $0 spent. This kind of streamlined process completely blew me away. I'm currently considering upgrading a dyno just because I think this service deserves some money from me as I use my free dynos all the time for learning. Can you actually recommend a better alternative for this kind of usage?
Wait, what? Implementing sorting algorithms by heart is basic freshmen CS knowledge? What school did you attend?
Agreed, but you're obviously missing the point if you submit that in the interview 
My favorite came from Atlassian. Guy asked me how I would build Minesweeper in the browser. It has a number of interesting problems to solve, that can be done in a number of different ways. 
Was exactly my thought, couldn't have said it better ;)
filterable list of cat names using virtual-dom and main-loop http://requirebin.com/?gist=cd100a67dbfa1280241f 
Somebody should port a decent fractal zoomer written in C to asm. Then we'd have a comparison.
What are the side-effects?
Doesn't Reddit do that? Why is it bad? (I haven't looked into it, so I don't know)
Hi GSargi, I run [React Newsletter](http://reactjsnewsletter.com) and [Front End Newsletter](http://frontendnewsletter.com) so I can offer some insight on how we find content. Where we find content: Reddit Twitter Hacker News and a few smaller sites Once we find a piece of content that we think will work, we then check to see how the community is responding to it. For example, if it's on Reddit and a large majority of the comments are negative, we'll usually skip it. However, if there are no comments or if the comments are positive, we'll then read it. From there if it's a well written post that we think others would find useful, we'll throw it in. Feel free to post any specific questions and I'll see if I have the answer.
Well, they actually linked to a list of cluster abstractions: https://www.npmjs.com/search?q=cluster Though node's built-in clustering is fine for running two apps on a Heroku dyno: https://nodejs.org/api/cluster.html Not really controversial advice, mate.
Yes, it is my blog. I haven't published yet my articles about javascript.
Wow! That is very useful thing for bug reports. Bookmarked this, thanks.
Thanks for your response and opinion. I try to write something good, but if nobody notices my posts and I don't have any feedback, I don't know if it is so bad or not :) I subscribe react and javascript newsletters and just wondered how articles are promoted, thats it :)
side effects are any modification that occurs outside the scope of the promise (here scope means variable scope, you can declare variables and run computation inside a promise, and what was still confusing me even after my realization, is that you can access a promise's fulfilled value in the fulfill function of another promise). Examples: setting a variable that is scoped to a larger context e.g. the function a promise is initialized inside of, or printing to console or other input output devices like a log file
I don't think I would ever expect a self-taught FED to have written a merge sort. It doesn't really sound an appropriate question, and I think any company that would insist on it is really going to lose out. Their loss, I suppose.
The discussion in the post (if you read it) was much more nuanced than that.
Nice, that actually sounds like a fun weekend project.
Yes that makes perfect sense. For some reason I was getting hung up on the fact on why is was spitting out 14. In both console.logs(). At first I did not understand that that I was manipulating the first global variable within the function. So in order to print out 7 in the last console.log() (meaning I don't want to manipulate the global variable. I would have to declare another variable inside the function. Like so. var my_number = number * 2 this would declare another variable called my_number but its scope would only be inside the function right? P.S. I know I'm a couple days late. 
Okay I'm working on it! **** I'll send you some screenshots later
"Documentation is excellent" must be a good joke. It gets dry very fast, e.g. doesn't even mention in what environment `postinstall` is running and how to access user's local directory still remains a mystery.
Your concerns appear to be about the quality of Node and npm's documentation as a whole. The post specifically references npm's documentation of the scripts feature, which I find quite good. 
Postinstall is npm script, and this lacking information is just one level below the basic one.
I would say that properly understanding `this` and the mechanisms surrounding it is the most important, yet difficult concept for people to grasp coming from other languages. Cover `bind`, `apply`, `call`, and how the order of precedence between these and the actual caller works. Also ti give a proper background to understand why `this` makes sense in the context of a prototypal based language. Kyle Simpson does a great talk just on these subjects. Other notes: &gt; lack of modules Note that ES6 does support native module syntax. &gt; lack of native classes. It took me a while to figure out how to write a class equivalent. I think this is the wrong approach to exploring languages. Every language provides certain mechanisms for extending behavior. Classes represents a broad spectrum of specific implementations to do this, classes vary in implementation between almost every language. The real question is, what are some good patterns to share, and override, or mix in behaviors in Javascript. There are tons of approachs, - Mixins - Extending prototypes - Decorators - Composition - etc... I think it is misguided to attempt to recreate strongly typed languages class systems in Javascript. Other notable mentions: - Javascript's `number' type, everything being a flow - Lexical scoping of arrow functions (how `this` refers to the surrounding lexical `this`) - Implicit casting with `==`, and how `==` is not associative. - understanding `strict mode`, as well as associated non-strict mode settings (such as implicit global declarations)
This really leaves me with bad feelings about IBM, control of express seems very important to them. I hope Doug and the gang start up Open Express, or what have you, so such an important framework in Node doesn't get left in the dust.
Indeed, this is something the wider JS community should be concerned about as so many frameworks build on top of express.
I think it's interesting to talk about how weird it is that dynamic binding (`this`) is the default abstraction in Javascript. As in we generally dislike it yet the ecosystem tends towards using it. It seems to always find its way back into your toolbox. Meanwhile in Clojure, for instance, you have to opt in to dynamic binding: (def ^:dynamic x 42) And you're still hard-pressed to even find one good use for it that's an improvement over lexical binding. I think we Javascript's `this` in the first place because it looks and at a glance acts like `self` in Ruby/Python and similar lexical abstractions in other languages, so you kinda get suckered in to using it because it seems familiar, and by the time you wonder if you really want to be using it in the first place, you're used to most of its idiosyncrasies because everyone else uses it. For example, even http://koajs.com/, a greenfield rewrite of Express, used `this` in it's initial 1.x release, decided it's just a shittier way to pass around another argument, and refactored it into passing around an explicit `context` object in Koa 2.0. We just can't stop.
I didn't how the situation was until now. Last time I read about Express-related drama was when it was handed over to StrongLoop. But I was 100% expecting who ever maintained and leaded the project to be on StrongLoop's payroll. I thought _sponsoring_ meant _giving_ resources.
Fork the repository, call it Currentpress, move all the effort over to the new repo, after a year IBM will abandon Express and hand it over to the Apache foundation and we will never speak of this again. 
First time I looked at JavaScript: &gt; What the hell is this `$` variable and why is it all over the place? On a serious note, probably allowing users to modify the native library (i.e. Objects they don't own). A good example is [date.js breaking transitions with d3.js](https://github.com/mbostock/d3/issues/1302) and [date.js overriding Number.prototype](https://github.com/datejs/Datejs/issues/12). Bugs like these literally cause hours and hours of frustration. 
While you can certainly use plain Bash, npm scripts can work great cross-platform as well. Combining cross-platform compatible commands with npm packages produces a cross-platform compatible solution.
How odd- basically expressjs as an open source project was sold behind closed doors by github.com/tj? I suppose since he has a lot of dev karma with tons of contributions people turned a blind eye? People seem to be directing irritation to IBM/Strongloop but the situation would not exist if it wasn't sold in the first place. Regardless- pretty interesting discussion which makes me wonder if the common OS licenses have became dated in the world of social coding. Perhaps the freedom to create derivative work may not be enough to protect project maintainers, contributors and consumers from the ultimate control project owners hold.
https://twitter.com/SlexAxton/status/686787954237308928?s=09
[**@SlexAxton**](https://twitter.com/SlexAxton/) &gt; [2016-01-12 05:53 UTC](https://twitter.com/SlexAxton/status/686787954237308928) &gt; Q: How do you know if someone uses npm scripts instead of grunt or gulp? &gt; &gt; A: Don't worry, they'll tell you. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
https://devchat.tv/js-jabber/155-jsj-webtorrent-with-feross-aboukhadijeh
Kinda funny how people started white-knighting and defend @dougwilson, but then he himself came out and confirmed @TrejGun's suspicions. The IBM/StrongLoop bureaucracy is leaving a bad taste in my mouth.
You'd be the surprise. The point is even at medium scale, in app memory node clustering is known to cause a number of problems. 
And suddenly your stuff doesn't work on Windows. I don't use it but I do feel sorry for the few people with Windows computers at my work.
Yes, they definitely are. But that also means you have to be "in luck" to come across the right ones. I actually never had this problems with Gulp. Its abstraction is really tiny and much simpler to reason. Also the plugins I've found of high quality and easier to deal with than with command lines directly. Gulp forces plugins into standardised API, which is why they are easier to use than the non-standardised command line options, that you are stuck with inside the npm scripts. Imo. 
I like it. Then we can change from MEAN to MOAN.
For anything non-trivial you depend on plugins pretty much the same way. Plus no standard interface, so more time spent on learning.
I would argue that to do the heavy lifting while subscribing to the npm method, you should write that functionality as separate node modules that your pre/post/regular scripts simply reference. At that point you're just trading the maintenance of gulp/grunt scripts for the maintenance of custom node modules. It's not necessarily better, but I certainly wouldn't call it worse to maintain.
Look at that [github activity graph](https://github.com/dougwilson)
What heavy lifting exactly for example?
So you're making a makeshift build system that's less maintained against edge cases and a wide variety of people, and to what? Say you use npm scripts? Okay, you do that. I'd rather not introduce bugs into my stuff just to be trendy.
I use Gulp to not only build changelogs based on commits, and figure out if it should deploy a major, minor or patch release from that data, all the way to building and deploying docker containers.
Exactly this. We have these posts every month, and the response is always the same: that's nice, but talk to us when you're doing more than running `werbpack -p`. 
So gulp is to npm scripts what jQuery is to the DOM? (Talking in laymen terms)
[this guy and his useless comment](https://github.com/strongloop/express/issues/2844#issuecomment-170649308)
Those are all over github too. The freaking thumbs up and "+1". I know big repo maintainers have been asking for some sort of voting system for a while now.
Except loop back is built on top of express. 
Are you running into cross-domain issues?
Please read my response to /u/Veeediot in this same thread.
The vast majority of build related tools in npm provide a standard interface: A CLI. 
He never said when he started.
If you want to rebuild Gulp/Grunt just to say "I don't use Gulp/Grunt" sure. I don't want to.
Yeah that's all I've done with it to be honest. It's very comfortable to get started and just send something up fast. But running a facebook compeditor on it? You'd better have some deep pockets.
I would say that first-class functions is a concept that is very difficult to grasp for the newcomer. Of course they are not exclusive to JS, but they are all over the place, yet intellectually difficult to manage if you are not used to them. Throw in es6's syntax and there you go, you've lost the junior. For example, this syntax for creating a redux middleware: ``` export default store =&gt; next =&gt; action =&gt; { ... } ```
&gt; Mixins Extending prototypes Decorators Composition etc... I'm also from a traditional background, and the problem I have with these solutions is that they don't offer encapsulation, which is a must-have for large apps. Once I got a handle on revealing module pattern JS made more sense for me.
A few dozen lines of script for a particular purpose is hardly rebuilding Gulp/Grunt. It just depends what you are doing. Sometimes writing Java/Python is easier than using Gulp/Grunt too.
&gt; I suppose since he has a lot of dev karma with tons of contributions people turned a blind eye? IIRC, people were pretty upset and disappointed. 
A few dozen lines of a script usually fall into not very much stuff that would require heavy lifting. My commits analyzing code is longer than a few dozen.
Don't forget about $.proxy ...
not really "may", they are :(
I do have huge respect for TJ for all his contributions to OSS, but selling the repository was a cheap shot. Even now he seems to defend somehow his decision at that point and doesn't recognize he screw up.
Source: https://twitter.com/samccone/status/688809217692545026
I like to combine both approaches. I'll use my npm scripts to call the local gulp like so ``` scripts { "build": "node node_modules/gulp/bin/gulp build-task" } ``` and do some of the most common tasks. This way if you have gulp, it's easy to use. If you don't have it, you have access to some of the most important tasks, and can install globally if you really want it. I typically try to avoid forcing people to install globals by giving them npm scripts as an option
AFAIK, there's no package manager for shell scripts, which means that you can't share code as easily between projects. Nor can you as easily leverage the efforts of others. I don't know about you, but I'm too lazy to give that up.
Ah, when did you start?
https://github.com/dear-github/dear-github
As a lead who's had to see various people run through Windows setup, no. It's actually much worse to get a Windows machine working with node than any other platform. Don't use the excuse "you can just install x" ever. For your own solo project nobody will touch, sure. But if you're publishing stuff to npm or working on a team, no.
Transhuman
This is good practice. Nobody should have to global install to use your project.
Go's a great language. So is Rust, Haskell, etc. Ecmascript has its blemishes, but the strength of node is writing the same code everywhere. And on top of that, TJ left node before the io switch and the steady implementation of ES6 features
Haha. IBM has something like 11k employees. 2 is really showing off their 'commitment'. They don't give a fuck
Create a minimal test case and put it on JSFiddle, JSBin, or CodePen. Passing "workTimer" to the Timer constructor is pretty bizarre, by the way. "workTimer" should be `undefined` at this point (unless you're redeclaring it which you shouldn't do either).
That example of "streaming" shows a common "useless use of cat".
If the fork is gonna be a battleground it should be [ypress](https://en.wikipedia.org/wiki/Battle_of_Ypres)...
time for everyone to start using https://github.com/koajs/koa/ :)
Just to clarify - Goblin doesn't care what you use to render (Three, Babylon, etc). I have a totally separate project (Physijs) which merges Goblin and Three together.
nice to see it using KoaJS too!
The easiest examples are `shuffle`, `sample`, `throttle`, `debounce`, `curry`, most of the string functions. Which are functions that aren't built into the standard library and aren't necessarily trivial to implement and test quickly. You could just view Lodash as a library of utility modules since every function can be included individually (`require("lodash/invoke")`). In which case you can just ask yourself if it's worth the time/effort implementing/testing something that is already in Lodash. 
Predefined and I should have included it. Away from my PC now so I'll chuck some minimal code examples together later. 
... Which is also stagnant, riddled with outdated documentation and flaky features and is pretty much dead. 
Yea. It's not an 'absolute'. Of course Apache Foundation has some great projects, hell, Apache web server for example, but it has increasingly become known as the place that companies dump projects they don't want to deal with any more. [Article](http://www.economist.com/blogs/babbage/2012/05/digital-archiving) There are a lot more articles and posts about it out there. It may not really be 'true' (I think it has some substance to it personally), but it has become a 'thing'. Basically, companies start projects, and when they aren't popular or in their waning years, they donate them to the Apache Foundation to take over ownership so they don't have to any more.
Thanks for the tip! I didn't realize it would do that automatically.
Well that's more than $120k per year donation. If they did that without owning people would be fawning over such a commitment. 
A good example for pipes is usually like sort or uniq or something. Just curious, I think a big reason people use gulp and grunt is for the file watching capability. Do you use something like guard for this or do you just not use that for your workflow?
Or just use grunt/gulp?
Definitely, and V2 with async and await looks amazing 
Yeah I love Koa. I know express is tried and true, but Koa and the async handlers just feel better to me.
It's only missing. http://documentation.js.org
Are you having a rough day, StrongLoop? Here, let me start a new JS framework to distract everyone.
I'd like to submit my single purpose module for inclusion. https://www.npmjs.com/package/fuzzy-equal Its purpose is to provide a percentage of similarity of any two javascript objects. I was developing some migrations and roll back scripts for some unruly mongo data and I developed this to see how close they were to correct conversion. It is 100% unit tested.
Don't use loopback or their other modules. I never needed them. They were trying to give you a hint.
The examples I've provided are seriously powerful - hot reloading dev server, minify, bundle, sourcemap, automated tests, linting, production build and deploy, and so on. npm scripts actually offer more flexibility than Gulp/Grunt because you have 200k+ npm packages and all the compositional power of both your OS's CLI and Node directly at your disposal. No plugin abstractions required.
Aside question, just because you're here: using constraints in physijs would it be possible to do basic ik for an armature or something approaching it?
Probably the source of where OP heard about it from -- like you say, it's been open 11 months -- op decides to post this the day someone else on twitter mentions it?
`use strong` is actually a thing, it's relatively new: https://developers.google.com/v8/experiments?hl=en &gt; Strong mode hence not only should make development easier, it also codifies a reliable “contract” for predictable performance: it can guide programmers towards writing code that VMs can handle well (or in some cases, hopefully do in the future) and away from excessive optimisation/deoptimisation cycles due to unstable types. There's a lot more to it, but that's the gist.
Biggest caveat: strong mode is completely non-standard and only works on a single engine (V8). Therefore, for most projects, it doesn’t make sense to use this feature.
There's so much useful stuff in ES6 and ES7 that it's become quite common to cherry pick features one might want to develop with and transpile them. Problem with this is that often I'm not sure where to draw the line. But wherever that line is, it sounds like this is waaaay over it.
Well, darn. I just got around to working on a project so I could learn the framework.
cool thanks for the info. Learn something new every day. Even though its only v8 could be cool for Node.js code. Definitely worth looking into further. I've been writing a bunch of node code on AWS lambda lately, where optimization saves you money so could be cool.
You know you can do the same thing in gulp right? Not EVERYTHING has to be a gulp plugin. Use `through2` and you can use any package you need. I do it here: https://github.com/kratos/kratos.github.io/blob/develop/gulpfile.js to pipe markdown files into a jade template for rendering of pages.
The original reason my old company started including lodash/underscore in their app was because not every browser implements foreach, filter, map, reduce, etc. And the ones that do don't always do so consistently.
I wonder if there are many people using express. EDIT: manner
&gt; Therefore, for most projects, it doesn’t make sense to use this feature. It's primarily for development (at this point). And it's a subset. If your code works in strong mode it will also work in strict mode. So, if you're fine with the added restrictions and if you like being told if you step outside some array's bounds, if you access nonexistent properties, and things like that, strong mode makes perfect sense. You can easily add "use strong" via a Babel transformer, for example.
Thanks for the well-sourced and detailed rebuttal of the article. Exactly what we need more of here. /s
OSS politics are such a shit show. I'm amazed that maintainers sign up for this stuff. 
I think the main point is the visibility of the inner name, that it's only internally visible when the class is assigned to a variable. const a = class C {} Now `a` is `[Function: C]` and `C` is not defined. If you don't assign it and write class C {} then `C` is `[Function: C]`. But internally you can *always* use `C`.
Joking aside, you'll run into considerable fees very early if your app grows. The moment you need to run a non-trivial app in terms of CPU, storage, high disk IO, or high availability, it's going to get pretty expensive quite fast. And most non-trivial apps need all of these. Seriously, $250/month for 2.5GB of RAM? That's crazy. Someone like Linode will give you nearly double that for just $40 a month. Check out their prices. Look what you can get for for just $160/month. It makes Heroku's pricing seem comical: https://www.linode.com/pricing And there are quite a few other hosts out there offering similar bang for the buck. If you're looking for other hosting options, this discussion has quite a few: https://news.ycombinator.com/item?id=10415199
I prefer Ramda as well. Been using it for about 2 years.
&gt; chaining: _(elements).map(...).map(...).filter().filter(...).value() Is lazy evaluated, and all those maps and filters are reduced (shortcut fusion) so the data is only being traversed once This would be better done using compose and reduce, e.g. var program = compose( add, muliply, removeOdds ); var result = reduce(program, elements); Chaining function calls is just function composition without the benefits, it sounds like under the hood lodash implemented the benefits back in for people who are unaware how to compose.
Precomputed ik is just regular animation, I appreciate the reply though.
No way man, can't use anything that doesn't have `gulp-` as a prefix. Them's the rules.
You have 200k packages available to you whether you use NPM or something like Gulp. That argument is irrelevant... Just because a package doesn't have a "gulp-" prefix doesn't mean you can't use it with Gulp. That said, those 200k packages also don't all have relevance to scripting a dev environment... So let's not muddy the water with obscene numbers that have no real meaning. 
Yes, and this is the problem --- there is no standard for CLI. Or maybe there should be but I've never seen one. Gulp forces your plugin into standard pattern which is a good thing. With CLI you are your own cowboy doing whatever you want. Which for your users isn't a good thing apparently. This is the key difference why I find Gulp plugins much easier to use. It is unfortunate that people abuse Gulp's power creating over-engineered scripts, but every powerful tool can be abused, doesn't mean the tool itself is bad.
200k+ npm plugins Wild West is less user-friendly than 100 top quality standardised Gulp plugins. More choice is not always better quality.
The diagram in the presentation is a correct way to explain what's happening abstractly. That's a fine way to visualize a call stack. The commenter's point is that language implementations, at a very low level, wouldn't actually write out the activation record for the currently-executing function onto the stack until right when that function calls into another function. So at the very beginning of `main`, the stack would be empty until `foo` is called, because the information written onto the stack is mostly useful when `foo` finishes and needs to figure out how to get back to `main` (ignoring calling conventions that pass arguments via the stack). To me, the comment ends up being fairly irrelevant to the discussion in the video, because there are many ways that an engine like V8 could choose to implement the call stack in JavaScript. They could take an approach like [Stackless Python](http://c2.com/cgi/wiki?StacklessPython) and avoid using native-level stacks at all. The ECMA standard that defines JavaScript uses language that talks about [execution contexts](https://es5.github.io/#x10.3), so whether or not there's actually a return address in the stack, and the rules about *when* that address is stuffed into the stack, aren't important to understand when giving a 20-minute introductory talk on how JavaScript VMs work.
[after](https://lodash.com/docs#after). It's incredibly useful in asynchronous code when you have n things that need to be done before you move on.
So you want to use it more for linting (incl. runtime linting during development)? That makes sense. IINM, it may occasionally clash with strict mode (e.g. when transpiling modules).
Everything in our world runs on money. Unless you are independently wealthy, you have a need to make money. Its ExpressJS, not the Red Cross or something. Besides there already were a ton of other options besides Express.
practically everything lodash does is faster than native with a more consistent API, and better browser compatability all those iterators are ~ie9+, so you had to use polyfills anyways if you wanted to support older browsers
&gt; My commits analyzing code is longer than a few dozen If code was written correctly to begin with, code analyzing is not that important.
I can think of two approaches. 1) `Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, 'action').get.call(document.querySelector('form'))` 2) Use `getAttribute` even though you seem to suspect that it'll break in some cases. I think it'll work even if you do set the `action` property on the form via JavaScript: E.g.: document.body.innerHTML = ` &lt;form action="/test"&gt; &lt;input name="action" value="broken"/&gt; &lt;/form&gt; ` var form = document.querySelector("form") form.setAttribute('action', 'hi') form.action = 'test' console.log('getAttribute', form.getAttribute('action')) console.log('accessor', document.querySelector("form").action) Prints: getAttribute test accessor &lt;input name=​"action" value=​"broken"&gt;​
ReAngular, that's old. You should be using Angurelia instead, coupled with the Gux metholodogy for data flow.
But you're still missing out on a clean way to leverage the work of others to build your project-specific shell scripts.
Gulp hasn't been totally perfect for me, but nonetheless it's made build tasks relatively painless to write and as a dev that uses both Windows and Mac its portability is huge. Writing bash scripts, especially for any non-trivial tasks, seems like a step back to me.
The use of array like objects is really cool, like mapping over a NodeList for example. 
[removed]
`debounce` and `.cancel` on the debounce'd function are very useful when handling user input.
I think it's only lazy for arrays with 200 or more items.
...really? You *actually* wondering if anyone uses a package which is currently: * [The most starred on npm](https://www.npmjs.com/browse/star) * [The fifth most depended upon](https://www.npmjs.com/browse/depended) * [A package downloaded by 90k people per day](https://www.npmjs.com/browse/depended) Really? Okay, fine: Yes, a lot of people use it. If you're using a nodejs-based solution (and maybe if you're not), it's a safe bet that a lot more people use it than whatever you're using.
Where do you take that from? There is no notion of that in the docs "The execution of chained methods is lazy, that is, it’s deferred until _#value is implicitly or explicitly called."
You'll get better performance using nginx as a load balancer.
It's in the docs under chaining.
Keep reading from there, it's in the next paragraph. ;)
I personally like also _.remove and _.sum ones.
Could u explain more?
As an ideal I agree there and I try make new code self documenting where practical. I spend a lot of time dealing with legacy code without the time to properly refactor though, which makes that more difficult. Where we need to use workaround for bugs elsewhere, limitations in a framework, or bad business logic we have no choice but to maintain a detailed comment is pretty much required so someone else (or me in a few months time) knows why that particular smell was created (essentially a warning to "leave this smell alone unless you have time to fix the other things too and QA have time to verify the wider change"). Also be care about assuming that your code is readable without comments. You might end up working with team members with either far less or vastly different experience and if you have to be referred to when other people work on the code you risk being locked into it instead of having tome to work on something more interesting. That is part of why I work on the legacy products here so much (leaving the company might be my only way to get away from the damned things) - I'm the last one left of the original team (and I can tell you that some of the other people from "back then" were even more wrong then the younger me about documenting their code being unnecessary).
here's your confirmation directly from strongloop guys: https://github.com/strongloop/strong-tools/pull/42
https://jsfiddle.net/4qscv91d/ note i added `div { margin: 0; padding: 0 }` key for stuff like this sry for using diff var names, i couldnt tell what was wrong
PR is for a project used for releasing strongloop's packages. When express gets packaged, `blip.js` gets added to it, and is added as a script to be run at install time. Thereafter, anyone installing express will by default have that packaged [blip.js](https://github.com/strongloop/strong-tools/blob/master/.sl-blip.js) making a simple phone home. 
NodeJS support services company
&gt; I'd like to submit my single purpose module for inclusion. https://www.npmjs.com/package/fuzzy-equal Its purpose is to provide a percentage of similarity of any two javascript objects. please submit it as a PR on the github repo
/r/learnjavascript
codereview.stackexchange.com It is not only for javascript but it is more or less active place to post your code for review.
Anyone can fork and continue express. Community would def back the top contributors. I don't see any issue here.. His repo, he just sold it. Until that point.. Whatever was there will always be licensed under MIT.
Angurelia is dead. All hail Relianguactionary. - medium.com/jsdevelopr/angurelia-sucks-relianguationary-doesnt
No he didn't.
The fifth most depended upon, thats impressive. Thanks for the data!
This is interesting and somewhat related [Reduce Your bundle.js File Size](https://lacke.mn/reduce-your-bundle-js-file-size/)
I've heard bad things about Cordova. Nothing but good about Qt, though. They're not really comparable, though. What I was getting at is, cross-platform is a very broad term.
Ah, I see, thanks for the explanation.
Lodash is great, but if you don't need to support old IE then you can continue using simple forEach/map/etc. Your code will often be easier to read and you will be sending far less bytes over the wire. Using lodash just for performance reasons is a classic case of premature optimization, if you ask me. :) For other methods like cloneDeep and debounce, you can usually find these on npm. 
Thanks a lot for your response!
Has nothing to do with the code and all to do with the commits. Using a certain commit style allows you to programmatically determine if the new release should be major/minor/patch and have it automated.
Hi there, I saw one site posting that a solution was to include this: async='async' inside the line of code. When I do this, the Google Pagespeed score of my site rises by 2 points, which shows it is working. On Firefox web and Safari iOS browser, the method works. But on PC Edge and Internet Explorer, the method simply makes the entire Javascript blank. Any help? 
https://lodash.com/docs
According to http://www.w3schools.com/tags/att_script_async.asp It should be working fine for IE10 &amp; above. There must be something else causing the problem. 
Is this implemented in Chrome? It would be nice to use for testing, even if the errors are only caught in Chrome it would be useful.
Have a look at [little loader](https://github.com/walmartlabs/little-loader) Hope it helps you out.
Does Gulp truly provide a standard pattern? How do I know how to configure Webpack vs React vs ESLint vs Mocha in Gulp? Answer? I don't. I have to read the plugin's docs. And since the plugin's docs aren't comprehensive, I also read the underlying tool's docs. Then I try to determine how to configure the Gulp plugin accordingly. I often end up writing a chunk of JSON that's specific to the tool. Configuration is certainly not standardized. In contrast, when I use a tool that exposes a CLI directly, I interact in a standardized way. The CLI exposes flags and accepts parameters. I only need to reference one set of docs: The docs for the tool I'm working with.
You don't have to `import` all of lodash if you don't want, you can just use the utilities you need var chunk = require('lodash/chunk') EDIT my bad on syntax, fixed.
could you try not making it a self closing tag? use &lt;script&gt;&lt;/script&gt; instead of &lt;script/&gt; (this used to be a bug on older IEs, not sure if it still exists)
That's amusing to hear, as I had a PR open for loopback for something like half a year, and the only response I got from them was telling me to rebase after they reorganized a bunch of files, it was rather irritating.
I tried this, and my post immediately got flagged and closed. It appears to only be for small code snippets.
Yeah, I had tried that already, as have I tried using double quotations. Nothing doing. 
https://jsfiddle.net/7vpeay2f/
Are you getting an error in the console? Anything?
Yeah, I figured ammo may be a bit clunky to use being compiled from C. One niche that I'd personally love to see filled in the JS/physics realm is vehicles. Cannon (and ammo/Bullet) have raycast vehicles, which work impressively well. But... if you're trying to make a driving game, there are certain playability limitations with those implementations that I've been hard-pressed to solve working within the available API/configuration options. Satisfying drifts, countersteering, etc. (For an example, [this](http://www.spacejack.ca/h5tt/alpha2.html) is a prototype of a back-burner project I've been working on from time to time, and [this](http://www.spacejack.ca/projects/drive/) is a tuning sandbox.) Doing some googling a while back turned up [this doc](https://docs.google.com/document/d/18edpOwtGgCwNyvakS78jxMajCuezotCU_0iezcwiFQc/edit) which describes some possible approaches to improving on Bullet's raycast vehicle. Most of which are a *bit* out of my depth, lol. I'd guess writing a decent vehicle sim (even just fun arcade physics) could be more difficult than an entire physics engine. Unfortunately I'm not sure if there's sufficient incentive for one to get made (like UnityCar for example.) 
The dependents are listed on the npm page: https://www.npmjs.com/package/prettydiff
`async` is a boolean attribute and usually its value is not required. The other browsers are ignoring the value and carrying on as its presence is enough. Try: &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js" async&gt;&lt;/script&gt; Please see: http://caniuse.com/#search=async
&gt; to the Global JSConf Community What's the point without context.
Hi /u/BoltKey, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
There are a few reasons you might want to consider abstracting this away to a library. * performance: as has been noted elsewhere, the native methods are sometimes slower than library methods that are optimised for their environment (they may simply wrap for/while under the hood) * composability: if you use a function first library like [ramda](https://github.com/ramda/ramda) then you gain the ability to use functional programming patterns that can often lead to more "correct" or succinct code. * idioms: In large projects, you can often get a range of implementations around iteration depending on the dev's preference. If you prescribe a default method of handling that problem, it takes decisions like this off the table and makes the code more uniform, *arguably* creating a more maintainable code base
Why does your backend need to support http/2? Isn't it going to be behind nginx or something similar?
Might be off topic, but what's holding off http2 in node js?
The author missed the final destructuring step to make it sexy again: let [valueA, valueB] = await Promise.all([promiseA, promiseB]); So, in this case, something like: let [user, org] = await Promise.all([ User.findById(), Org.findById() ]); res.json({user, org});
Like I said though, it works on all browsers except IE/Edge and there is official documentation showing async supporting an XHTML way of writing. 
No proxy is planned. Was thinking of deploying to heroku. Don't need http2 right now, but who knows if I'll want it later on?
Used together, Wow.js and animate.css make this pretty effortless, and smooth because it's CSS-only animations which are optimized very well in browsers. And you have many more options than just fading them in. http://mynameismatthieu.com/WOW/ https://daneden.github.io/animate.css/ 
So, Socket.io has just released their latest version this month and their website says their focus is on speed and reliability, yet you say if you use it you will experience the opposite? I've heard of socket.io, it's been around for years though haven't used it. Never heard of this bunny thing before. I have done WebSocket and that worked very well. I'd say the only caveat of doing straight WebSocket is that you have to handle your own acknowledgments to ensure recipient has received the sender's message.
What would you say the advantages of JavaScript's pattern are? I always hear about "flexibility" but what does this practically mean / look like in code?
The web platform competes with Microsoft's operating system. There have always been incompatibilities and issues like this with sites not loading in MS's browser. It is deliberate and will always be like that. MS does not want websites to work properly on their browsers. You can use a workaround like an async loading library, minify and bundle, use an HTTP2 server for faster loading, put the script tag at the bottom of the page, or detect MS browsers and put a large banner that says they are not supported.
There are a few common helper modules used by a bunch of the babel modules in the presets. The suggested fixes are to use `npm dedupe` or migrate to npm@3 which dedupes by default. However, npm@3 is super slow, and`npm dedupe` in `npm@2` is also super slow. A good solution I came up with is to manually dedupe, but installing the common babel helper modules at the top-level, and then reinstalling your babel-presets. npm@2's dep resolution algorithm, will look in the top-level of node_modules for dependencies first, and if they exist, it will not install them nested, which prevents the duplication which causes huge amounts of time requiring. **Solution** *1. Install babel shared dependencies locally.* ``` npm i babel-template babel-code-frame babel-helper-function-name babel-helper-regex babel-traverse babel-helper-replace-supers babel-types babel-helper-builder-binary-assignment-operator-visitor babel-helper-define-map babel-helper-call-delegate babel-helper-get-function-arity babel-messages ``` *2. Reinstall presets. They should use the locally installed deps instead of installing duplicated copies as long as the locally installed versions match up.* ``` rm -rf node_modules/babel-preset-es2015 node_modules/babel-preset-react node_modules/babel-preset-stage-0 npm install ``` 
True, if they apply.
What does that?
The crossfit of javascript.
That's not what he needs though. The userid for the 2nd promise is coming from the result of the 1st promise.
Nice to see that after C#'s async/await people are finding the same issues and workarounds for Javascript too. History repeats itself.
The step by step tutorial on how to use nvm script for quick node installation. Allows to install many node versions, with quickly switch between them. 
I was referring to the first and last examples where Org.findById does not depend on the value returned by User.findById.
Only is his example of when using two awaits would be necessary. 
Pretty sure that syntax was dropped.
when will async/await hit node?
Or checkout [Hapi](http://hapijs.com). A most excellent alternative to the Express/Koa ecosystem. 
I have no idea. Still works with Babel. Proof?
I think express will stay around for a long time, at least several years. But people have more experience with node now, and have a better idea of what *they* want to do with it. So you'll see smaller projects that are specific to a certain way of doing things.
Does a commit style refer to a SemVer comment formatting determined from interface changes (breaking = minor) and count size (aka major)?
&gt; Koa middleware is more robust, easier to write, and generally more composable than Express middleware... All POV "facts". &gt; Koa is much more stable than Express Says Koa contributor. I've to trust his word since he didn't say anything about why, compared con Express. 
Fixed. That's a little weird that their site doesn't have tls enabled. 
cool. as much as i hate MS its good to have give google some competition for v8
Babel error'd on this pattern when I upgraded to version 6.
Cerebral is just controller part, and it can be combined with any view package (React, Angular1/2, other vdom libs, etc) and with any immutable store (baobab, Immutable JS) Feel free to join our server on discord (https://discord.gg/0kIweV4bd2bwwsvH) and ask any questions.
TIL more languages have await than I realized. https://en.wikipedia.org/wiki/Futures_and_promises#List_of_implementations
well that's actually a good starting point, the post didn't reference neither of both graphs. that's what I consider a good write up, the one that show the facts and lets you take your own conclusions, not force an opinion on you. you might want the [graph for the actual repo](https://github.com/strongloop/express/graphs/contributors) and not the one for the website, though.
ES7 : let's put SYNC back into async ... sigh...
Async/await are non-blocking. 
Oops, thanks. Added the correction!
Still works on *your* version of Babel. Such are the hazards of using an unstable spec.
No it isn't. It's to *simulate* blocking syntax. Very important difference. 
When we talk about blocking being a bad thing in node, we mean thread blocking, not blocking execution of a function. The difference is that Node can still do other things while the function is hanging around waiting on the `await`. Whereas with thread blocking (e.g. using one of the built-in `*Sync` methods) the entire process is locked up.
Well I have a medium-large Node app written with Express. Has anyone gone through switching it over to Koa? How much of a pain was it? From what I understand I would have to write a lot of the middleware myself since Koa is more minimal than Express. With Express, a lot more of the work has been done for you out of the box.
Unless I'm missing something, that's the last example provided in the article? Has the author edited it in? Or is there a difference I'm overlooking?
&gt;An automated code coverage tool would be largely useless: what would it assert? Logic issues and / or unreachable code (beyond the obvious ways)? [The Flycatcher](http://www.doc.ic.ac.uk/teaching/distinguished-projects/2012/j.delafargue.pdf) paper seemed interesting, but I'm having difficulty loading the code.
I don't think they will. async/await does allow handling of errors via try catch blocks, so I think it rethrows errors if the exception is rejected. Edit: Oops, I'm wrong. Looks like "vanilla" async/await allows try-catch blocks but using `Promise.all` eats them.
Definitely that last one. The less time spent hunting down NaN problems the better.
Callbacks will be looked back on like pointers or goto. Useful, but too low level for most purposes.
Will we start seeing MANK stacks on the buzz-O-meter?
This is the best solution IMHO. Because it's cross-platform, and you don't have to install gulp globally to make it work. Simple fork, local install and run. And like another comment said, no need for the `node node_modules/gulp/bin/gulp` part. But the reason is because the npm execution will have its own `PATH` filled with the `./node_modules/.bin/` folder. edit: phrasing
nope, it doesn't (I've been burned by that). the same way the promises do not do it.
It's not a workaround, Promise.all is perfectly fine.
Might help to link to the post.
I enjoy the way they implemented that, definitely worth a read! Thanks!
"Someone has made promises and not followed through in the past; now they've made some *more* promises and have yet to follow through; why aren't people super happy?" IBM has damaged the community's trust in their stewardship of the express project. It will take time to rebuild; even once the alleged resources and devs show up, we'll have to see how long they stay committed to the project, and how effective they are. 
&gt; &gt; Koa middleware is more robust, easier to write, and generally more composable than Express middleware... &gt; All POV "facts". The middle-ware functions can yield to each other, so I'd say that it's objectively more composable. As far as stability, I'm not sure. The case could be made that Koa is more stable by virtue of it having less surface area, and therefore less potential bugs. We'll see how it plays out.
That's old example code (Apr 9, 2014). Someone should fix it. `await*` was dropped. Use [Promise.all](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise/all) instead.
just did a quick [write-up](https://medium.com/@yamalight/danger-of-using-async-await-in-es7-8006e3eb7efb#.8ll5w58os) on that topic if you are interested in details :)
Message queues have been around a lot longer than socket.io. this solution with socket.io creates two HTTP servers for backend communication and is susceptible to all the problems of web servers... What if there's a network hiccup? What happens when you add another server? A server behind a load balancer? Solving these issues with a queue gets a lot easier.
I'm guessing this yes. jQuery is required and something else will fail. But mostly it will throw an error with `$` being `undefined`? Or the script does an `undefined` check but does not show the user that. Still, things not working is probably because there is no jQuery available to depend on. Why the other browsers don't do it, might be because they get loaded just after and MS might skip it because of the async tag. I'm guessing jQuery should be loaded and the others should be async?
Speaking as a user and contributor to open source, I don't know if we would *boycott* Express - but I think there's a healthy debate about whether Express should be forked and run by an external organization (either a caring private entity or an amalgamation of caring developers) or whether the primary project should live with IBM. Hopefully, this will lead to IBM dedicating more resources (as you seem to indicate they are considering) - but only time will tell. Regardless of more resources, there will also always be tension between the needs of Strongloop, IBM, and a user like you or I.
Do you use `application/xhtml+xml` as MIME type when you serve your page?
I've been using N instead
I solved it File / Setting / javascript / Other / Align Var statements and assignments
Lol, implying anyone ^validates ^^http ^^^errors ^^^^on ^^^^^the ^^^^^^client ^^^^^^side ^^^^^^^anymore 
Yes, I think most of the frameworks are depending on express, and thats why I ignored it and take it for granted. Now I realise that express is so commonly used, I started hating IBM and loving Doug.
In my opinion, the solution of reducing those spams is not building a vote system for them, but ban their accounts for x days because of violating the rules. We should not build something to please spammers.
Seems clearer to me using something like ramda.js, but to each his/her own. var refine = R.filter(R.allPass([ filterByRevenue, filterByYear, filterByCustomer ])); var result = refine(projects); 
Lodash v4 doesn't even support old IE and has over 200+ modular methods. Far more than forEach/map/etc., which also allow you to write easier to read code than reimplementing these helpers inline by way of ES5 methods. Lodash methods for things like cloneDeep and debounce can also be found as individual packages on npm https://www.npmjs.com/browse/keyword/lodash-modularized Lodash continues to embrace ES6 and beyond with support for things like symbols, typed arrays, array buffers, iterables, etc.
I'm using es2016 feature. What about 2017, 2018?
True, but that is just a syntactic sugar. More important is the mechanics underneath. Those were prominent on many other languages.
The only downside I can think of, is that they can be abused to make bad/amateurish code.
Right now it's an experiment towards evolving JavaScript towards a more optimization friendly language in the future. It's not something you should use except for experimentation. 
You're right, async/await does allow try/catch blocks, but using Promise.all doesn't :)
I also prefer `| 0` over `~~`. But if an expression I wanna truncate is already wrapped in parens `()`, I find `~~` more æsthetically pleasing than `| 0`. :-P 
Can you provide an example that demonstrates the broken behaviour? I was trying to replicate it in order to post in my workplace's internal JavaScript group about it, and just couldn't get it to break. I tried this: function broken(message) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(new Error(message)) }, 10); }); } async function main() { try { const result = await broken('1'); log('SUCCESS 1: ' + result); } catch (ex) { log('BROKEN 1: ' + ex.message); } try { const [first, second] = await Promise.all([broken('2a'), broken('2b')]); log('SUCCESS 2: ' + first + ', ' + second); } catch (ex) { log('BROKEN 2: ' + ex.message); } } main(); Which resulted in this output: BROKEN 1: 1 BROKEN 2: 2a It seems like the try-catch is working as expected there? `throw new Error(message);` instead of the `setTimeout` resulted in the same thing. Perhaps I'm doing it wrong.
As I posted in [this comment](https://www.reddit.com/r/javascript/comments/41k55t/the_only_bad_thing_about_es7_asyncawait/cz3fx1v), could you please provide an self-contained example that demonstrates the broken behaviour? I was trying to replicate it in order to post in my workplace's internal JavaScript group about it, and just couldn't get it to break when using `Promise.all` :/
I don't know, I feel that since this is one of the most significant changes to js in a while the growing pains will be over by the next iterations of es6. It would be in the best interest of all js engines to have the most up to date js implementation. Maybe save module loading 
That's a regular object literal. By the way ES6 has shorthand methods for this kind of thing: let foo = { bar() { // instead of "bar: function() {" ... }, baz: 5 };
Ok, if the author is here lurking the comments, I am sorry but your post demonstrates a fundamental misunderstanding of how exception handling is supposed to work. Errors don't "disappear without a trace". It's your responsibility to handle errors correctly. I realize that most JS devs never really used try/catch style exception handling in the past because it was always cumbersome, not standardized among environments and didn't play nice with the asynchronous nature of JS but that is exactly what promises are trying to solve. It has been argued that the biggest win from Promises *is* better error handling. From the OP, option 2 is very close to how exception handling is supposed to work. For example in a koa.js web app I am working on, I have a middleware function that's primary purpose is to catch all downstream errors within a try/catch block. If any errors are caught (errors that have been derived from the base Error object that contains the appropriate http error code and any other extra info) that error is then converted to a plain object/JSON and served is the response. It catches any and all errors whether they were generated from within a Promise or async function. If I need more fine grained control when handling an error, I will catch it in the appropriate context or let it keep traveling up the call stack depending on the situation.
No idea what this is all about, but "CoC" is probably "Code of Conduct" in this case, going by the context.
So is the tilde `~` (unary operation) so we can't have `~&gt;`. So is the `-` (subtraction) sign so we can't have `-&gt;`. So is... what are you on about? Lambda functions or anonymous functions (C#) have used the arrow syntax for a while and I've never heard of it being an issue. Certainly not in C#, Java or Ruby. Fat and thin arrows are used in Haskell, and those same characters can be used with a different syntactic meaning). It's not an issue for me, and I doubt it's an issue with majority of developers I've spoken to. If it's an issue for you, you're more than welcome to use functions since they're obviously not being deprecated. ES6 is completely backwards compatible. The same ideas behind "JavaScript, the good parts" still apply. But if you fail to see why arrow functions are an improvement, then I'm lost for words. If it's a matter of taste and you don't like the syntax, everyone can have a preference, but spreading misconceptions like "magic scope" when in fact you mean to say "i don't understand how scope works with arrow functions" is just being unhelpful to the community - because if a JavaScript beginner reads your comment they could be led to think that it's difficult to predict, or understand, how arrow functions behave. And that's just not true.
Exactly! When used properly they're wonderful.
I believe they added promises recently
Yeah as you said it gives you more control. There were too many different ways people were trying to use Babel for it to be one-size-fits-all anymore. It's easier for lots of other people now, unfortunately you aren't one of them :(
Lodash doesn't focus on micro or premature optimizations. It goes for substantial wins like avoid linear search (like for-loops) for things like `difference`, `intersection`, `uniq`, `union`, &amp; `xor`.
Your ES6 solution isn't really a clone for things like typed arrays, date objects, regexes, maps, etc.
To break it down further, that was an object initializer with members (keyed by `read` and `save`) whose values were anonymous function expressions (an object member whose value is a function is also known as a method); ES6 shorthand method notation effectively does the same thing, except that it provides an explicit name for the method, which may be used internally for the purpose of recursion. (Then again, modern JS engines will work hard to find a name for a function defined by an anonymous expression; in the case in the OP, it will likely be the object key, and in the case of a variable initialization like `var a = function(){};` it will be the variable name. In the past, JS engines did not do this, which made debugging a little bit more difficult; also, ES6 arrow functions are always anonymous, so you shouldn't make them complicated.)
Correct :D
`async` and `await` are just compiler syntax transformation for Promise implementation. It handles the common/naive Promise usages. It doesn't fully replace Promises. If your use case is a little more complicated (e.g. you need `all` or `race`), it's better to use native Promises even in ES7. If your use case is something even more complicated (e.g. caching layer, scheduler, state machine), then you should probably write a API or use a library specifically designed for that, instead of exposing downstream application code to Promise/async/await idioms. 
Np!
One of the plank's in Reddit's platform is bandwagoning so yes. And it appears we will have many weeks of postings and articles about the horror Express has become to the point where it is the new evil. Until then, there seems to be an issue with Express but boycotting? No. 
Do you know of any example code with this already in place? 
Yea, that pretty much works the same, but I have the feeling that it's a bit less idiomatic since promises are rarely put into temporary variables. Getting all the values in one go via destructuring and Promise.all will be probably the more popular way to do that kind of thing.
I would suggest you connect as high as possible in the tree, and pass down raw data via props. If you find you need access to your source of truth, you can subscribe to your Redux store inside leaf components. Give https://egghead.io/lessons/javascript-redux-extracting-presentational-components-addtodo-footer-filterlink?series=getting-started-with-redux a watch for an example. 
Yes, a good alternartive to nvm. 
It think it just sucks that you need to use babel on the server. Most people will balk at a compile step like that because it changes line numbers and makes debugging harder, in addition to making development one step more complex.
Nice project! And that doc is a good find too. There definitely are a lot of details which can be added to a vehicle simulation and someday I hope to have many of them accounted for in Goblin, or perhaps an optional library to use with it.
Native browser promises can stop on uncaught rejection and the browser will console.error them. Unfortunately a bug in Chrome promises and a lack of pragmatism in the community prevent us from using it.
Just a clarification. &gt; when you run "new X()" it duplicates the prototype to a new object It doesn't duplicate the prototype object. It creates an internal property on the created object (\_\_proto\_\_) pointing to the constructor Functions .prototype object. function X(){} X.prototype.booger="green"; console.log(X.prototype); //X { booger: 'green' } var test = new X(); test.__proto__===X.prototype; //true console.log(test.__proto__); //X { booger: 'green' } X.prototype.booger="yellow"; console.log(test.__proto__); //X { booger: 'yellow' } 
Any `async` function is in fact just a `Promise` under the hood, so unless you try/catch every single promise within a route, the exception will get eaten. This will catch the error: app.get('/', Catch(async (req, res, next) =&gt; { let user = await User.findById(); })); function Catch(fn) { return function(req, res, next) { fn(req, res, next).catch(next) }; } 
That's just a regular JS object literal.
thanks for the reminder. I just couldn't remember the syntax of what I saw and couldn't figure out how to look it up.
&gt;The only bad thing about ES7’s async/await is the ease in which we fall into the anti-pattern of serializing work which should be performed in parallel.
It's already in [Edge 13 behind a flag](http://kangax.github.io/compat-table/es7/#test-async_functions_await_support), so could very well hit the [Chakra-node](https://github.com/Microsoft/node) before v8-node. 
Good point!
&gt; I hate callbacks. Seriously, what's the good way to do this, without async / await? Promises. I love them 
I understand the frustration, and I think that this has been good for bringing attention to the project, but I personally see a lot of hype and over reaction. Express is stable at this point and it's early in the year. This is around the time that larger companies are budgeting for their projects for the year, hopefully with the hype they'll give it a little bit more funding.
http://www.phpied.com/3-ways-to-define-a-javascript-class/ 
Add yeoman for MANKY
The best would be to look on other frameworks and libraries. Just look how other does this and compare some of them and decide for yourself what you will do.
Thank you, briliant idea! &lt;3
As I said, it's not a take-all-or-leave-all language, and you don't need to master the entire JavaScript reference to be a productive developer! I agree that the language is becoming harder to master, in a certain sense - the scope of language features to master is growing. The fact that old APIs are still there might also be confusing to new comers. They'll now have to know that there's a difference between `function SomeConstructor() {}` and `class SomeClass {}`, but that needn't shy them away from the language. JavaScript's main platform is the web and it's evolving with the web. We need modules, we like having syntactic sugar to avoid having to `.bind(this)` in every callback, etc. I also don't think new developers will find JavaScript necessarily harder to learn than a few other alternatives. As for the path JavaScript is taking... I don't think we need to be worried. C# developers mostly use TypeScript, and Ruby developers tend to favour CoffeeScript. I'm happy for it to remain that way. 
Here is something to get you started. https://hacks.mozilla.org/2012/03/browserquest/
On your first profile page only, didn't bothered to go further: &gt; 80% of all redditors are full of shit &gt; One of the plank's in Reddit's platform is bandwagoning &gt; Typical redditor. Knows nothing about the subject so tries to make it all about the poster. &gt; As a true redditor, now comes the time you start making things up to justify your position. &gt; Obviously this is waaaaay over ever redditors head &gt; So, like most redditors, you don't know anything about it &gt; You're a clueless idiot. But that's OK. Most redditors are. &gt; Did you stop reading after the first period and ignore the rest? Typical redditor. &gt; Absolutely clueless redditors. It's why I always say, 80% of all redditors are kids and/or make comments about things they know nothing about. &gt; 80% of all redditors are full of shit, couldn't justify anything they say We love you too. It's quite funny seeing you stay on a website you apparently despise.
If you're going to switch frameworks every time someone writes a blog about "the next best thing" you're going to have a shock. 
hey there. I am indeed lurking here :) As I mention in the very beginning, this article was kind of answer to the previously discussed here article ["The only bad thing about ES7 async/await"](http://codeplanet.io/the-only-bad-thing-about-es7-asyncawait/). It lacked error handling of any description and in my opinion it's way more important than parallel execution. And if you look into the discussions - both in the article comments and here on reddit - you'll see that nobody talked about error handling as well. It is indeed true, that promises considered to be better in terms of error handling. The thing here is that a lot of people still don't understand how promises work, so they don't handle those errors correctly. That's why there's [so](http://jamesknelson.com/are-es6-promises-swallowing-your-errors/) [many](http://odetocode.com/blogs/scott/archive/2015/10/01/javascript-promises-and-error-handling.aspx) [articles](http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html) on that topic. Async/await is a very new thing in javascript world and not that many people use it yet. How many know that it's based on promises and needs special error handling or errors won't appear? I can bet that not that many. That's why I wrote that small article. 
neither with the original usage of “work” nor the contextual one
That's very neat, thanks for sharing.
The issue is partly because of the libraries that don't implement good error handling when they should. For example, assuming that express had ES6 support (it has been implemented, but the PR hasn't been merged yet), your "does-not-work" code would work just fine, as well as if it was a sync code (because the library would then catch any error and return a 500).
same way as with promises - when you don't handle errors at all. In non-promise code your node/browser would show an error to you in console - if you don't handle errors in promises you won't see a thing. that's all I wanted to point out.
because reimplementing unix tools in javascript just to make them work on Windows makes a lot of sense, yeah...
if [that's the bug](https://bugs.chromium.org/p/v8/issues/detail?id=3093) you are talking about, seems like it's been fixed. and that's some great news!
Well, the other bad thing about it, is that just like using promises directly, unhandled exceptions get swallowed. Thankfully browsers are starting to warn in the console when this happens, but I'm pretty sure node doesn't do this yet.
Node. It's like MEAN but with Koa insteand of Express.
You don't compile in development no? 
[removed]
Thank you for sharing this! I'm new to Scala and I was looking for some real-world open source projects to learn from. This seems to be a perfect match.
I get the feeling that if I had suggested triggering Makefiles from within the package.json file, it wouldn't be so unpopular.
Because we are javascript and we are edgy and we like new and we hate old and we make quick decisions based on NOTHING.
assuming foods and drinks are independently changed, connect them separately, giving each one just the part of the state that changed. @connect(({foods}) =&gt; ({foods})) const Foods = ({foods}) =&gt; &lt;ul&gt;{foods.map(food =&gt; &lt;li&gt;{food}&lt;/li&gt;)}&lt;/ul&gt;
Maybe it is because I used to code in C: I just don't like JavaScript *guessing* where I intended to end statements. And it *is* guessing. It is a pedant point but the semicolons *are* required, but there is a pre-processor that puts missing ones in for you - that is why people refer to "semi-colon insertion". I like to be explicit and say where I intend statements to end. Of course the opposite problem is possible: it adding a semi-colon where I *don't* want one (see http://cjihrig.com/blog/the-dangers-of-javascripts-automatic-semicolon-insertion/) though to be honest in most situations where this is an issue you are being tricky so it is my own fault for trying to be clever.
Interesting article! However, is "concatenative inheritance" (composition) really prototypal inheritance at all? In the article it's put under "Three Kinds of Prototypal Inheritance" which I find a bit weird.
Perhaps you should...contact codeacademy?
Well, that's good to know. Not because I didn't understand promises, the opposite: I didn't get around to checking out async/await yet but I've known about promises for quite a while now. So now I know that async await are actually pretty simple :D
You're not listening for or adding any ICE Candidates to your RTCPeerConnection object. Once your offer/answer is complete and you set your local/remote descriptions your RTCPeerConnection object will raise the onicecandidate method several times. You need to emit these over your signaling server and add them to your remote connection on the receiving end. It would look something like this: pc.onicecandidate = function(e) { socket.emit('whatever_event_name', JSON.stringify(e)); } and then on your receive end you would set up like this: socket.on('whatever_event_name', function(context) { var obj = JSON.parse(context); pc.addIceCandidate(new RTCIceCandidate(obj.candidate)); }) That is why you pass in the iceServers when you create your RTCPeerConnection on line 15. var pc = new peerConnection({ "iceServers": [{ "url": "stun:stun.l.google.com:19302" }] }); Without these candidates your peers still don't know HOW to reach each other. STUN/TURN provide the network information necessary to make the actual connection.
Chances are a gulp plugin will work on Windows a lot more than a bash file with `#!/usr/bin/env node` at the top.
So, effectively, is there any reason at all to prefer one over the other? I'm a huge fan of using Promises, and I've been struggling to figure out what the use cases of choosing either style would be.
sounds good thanks
You are right, Typescript is not vanilla in any case :) The way I ment it is that we can implement Flux, or one way data flow without any library just by using well known concepts as services, models, listeners etc... As for example implementation, I have chosen Typescript but I am only using some types and no fancy stuff so it should be realy similar to ES6.
Yeah, in theory... I tried to make gulp-scp work, oh sorry, it's scp2, oh sorry, it's sftp, oh sorry, it doesn't work anyway, I better start a process running rsync, that'll work for sure, it's been doing its job since 1996. And so I did. And it works on windows too. 
A lot of frameworks are finally leveraging it. Koa v1 uses generators as middleware. React already encourages a preprocessor, so a lot of boilerplate/skeleton code adds in ES7 before you even code a single line. I'm sure there are others that use it, but those are the ones I've used. As JS frameworks and skeleton projects become yet more popular, the newest stuff gets higher and higher adoption. Also, companies don't really like to invest in technology that's brand new. The timing just works out like this.
Sharing this here for anyone interested! It's a really good beginner friendly guide that taught me a lot about all these new technologies. It's mostly free aside from the advanced chapters, but do support the author and buy the ebook if you like it. 
&gt; Our browserify task is a good example of a task that would be near impossible without gulp Bad way to start, all this can be done with webpack too... And here is the catch. Cory House is still using webpack so his argument is true for his case. Personally i too abandoned gulp in favor of webpack but i wouldn't say that all I'm doing now is "npm scripts" when in fact i let webpack do the heavy lifting. you can also make a npm script that runs gulp so there is that...
Or longer if you come from other languages, like python or C#. That and ES7 decorators.
If you've ever written a long promise chain, you'll know the answer. They can get out of control. You shouldn't use a lot of promises inside your app logic, it should be used to modularize your code and your business logic should use generators or async-await.
And to further your example, it can be anything that takes time to compute or that you want to run asynchronously. For example, calling an ajax, and running an animation at the same time, and only callback when both are done. Or things like DB requests, on serverside, or maybe something with heavy computations, like image processing client side. You can get away with using callbacks, but promises just make it easier to write, read, and is much cleaner and simpler.
Mongo, Angular, North Korea.
This bugs me: &gt; My final point is this: gulp is at its core not a build tool. It is a task runner. This just strikes me as a case of special pleading. This bogus "build tool" / "task runner" distinction is completely irrelevant because the actual question is: Which tools is better at supporting our build and related tasks? 
Yeah, might remove that bit. it's a bit weak EDIT: It's gone!
This wasn't a gulp vs webpack article, it was a gulp vs npm scripts article. I haven't used webpack that much so am not qualified to write about it :)
/r/codecademy is somewhat active. You should be able to get a response there.
I don't think it's that simple. For one OSS contributors on prestige projects have a lot of clout and I'm sure use it to their advantage when negotiating salaries.
Honestly I can't say anything about those. But it's not unknown that Node.js doesn't accommodate Windows very well. Most developers are on Mac or Linux. Windows needs some more love. 
That's for taking the time to look at my code and you're right I'm indeed not handling the iceCandidates. I'm working off the MDN documentation on webrtc, and they don't happen to mention the ice candidate events or where in the sequence they take place. https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection I'll continue reading up but is there a specific time in the offer/answer that this should happen or is it a continuous thing that gets update? edit: For anyone searching and finding this, I found this additional documentation which proved fruitful for filling in some of the knowledge gaps in the first tutorial. https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/WebRTC_basics
I've definitely experienced this in the majority of projects I've worked on for my agency. I think the issue is really that there's a difference between Agile (with a capital 'a') and agile. The distinction being, Agile is the product that someone has sold to the company in question, and agile being the idea as it pertains to software development. It seems like when a company has adopted Agile, it's because it's a buzzword, and the client thinks they should be using it. They haven't actually adopted the idea, they've adopted a trend, and at the end of the day you get something that ends up being akin to "waterscrumfall" (waterfall, but you have a scrum on the daily). This seems to be a product of marrying what the client wants with how the client actually works. I think, oftentimes, in the agency world, we've agreed to such aggressive timelines that agile can't actually work. Because the timeline is so short, too many stories get crammed into too little time. As you know, the team will create new stories for tasks that need to be completed. When you're in an abbreviated timeline, this tends to get the client spooked. They see all of these stories, and they figure "there's no way this can get done in that amount of time" (which, of course, is probably true), so developers end up touching 10+ stories a day, and writing crappy code. When the client gets spooked, account puts pressure on the PM and the PM puts pressure on the devs. It's not as if the devs don't CARE that it's crappy, it's that they don't have time to care. They're definitely aware that the code isn't maintainable or necessarily stable. But there isn't a whole lot to be done about it. And it's easy to say "just push back against your PM", but I've been in too many projects lately where that accomplishes nothing and only wastes precious minutes of dev time. There's nothing you can do other than suggest the better way, give an estimate, and carry on when your timeline doesn't move. On the other hand, I'm now on a project where the client has removed the pressure of a timeline. They have a vague idea of when they want to complete the project (in terms of "we want it done x month"), but they have no drop dead day. Agile actually works, and nobody's freaking out about the number of stories. I'm starting to believe that agile only works well if you remove the crazy deadline. The folks from my agency (and myself, tbh) are a bit out of sorts. We don't really know what to do without this crazy deadline, but ultimately, it's rather pleasant. We're actually doing things the proper way, and the code that gets released is actually stable, and quite maintainable. 
Hi /u/SHIGGA, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `franciskim.co`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [franciskim.co](/search?q=%28and+site%3A%27franciskim.co%27+author%3A%27SHIGGA%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|19|68%
Typescript is new to me. ES6 is still new to me. When I read this: export default class MainComponent extends React.Component&lt;{ children: any }, {}&gt; { My brain shuts down because of: `&lt;{ children: any }, {}&gt;` Man. Now I have to first study typescript before I can have any sort of clue what's going on here.
A couple quick things. - You can pipe JavaScript into the [uglify-js](https://www.npmjs.com/package/uglify-js) module - Hacks like the "Only one jQuery" look pretty absurd, and are generally only needed when you fit a square peg (jQuery, MooTools, etc) into a round hole (npm/modules). The same complexities arise when using `browserify-shim`, `deamdify`, etc. What do you do when you need that browserify gulp task on more than one project? What do you do when you need that task across *hundreds* of projects? The idea of npm scripts is to abstract and modularize your common tasks; things like uglifying, envifying, optimizing and stripping console logs from a browserify bundle could be abstracted into a single npm module, instead of copy-pasting the same Gulp boilerplate from project to project. Your module could use Gulp, Grunt, or whatever under the hood – the idea is that it is abstracted away from the end-user, so they don't need to maintain/tweak a massive and overly complex build script. Nobody using `npm scripts` wants to replace a long Gulp script with an even longer `package.json`. :) 
You are right, but then again that's the least important part of the example / post. The main focus is on how to implement Flux like data flow just by using familiar concepts like models and services. Basically `export default anything` is equivalent of ES5 `module.exports = anything`. As for magical part `React.Component&lt;{ children: any }, {}&gt;`, you can rewrite it as `React.Component&lt;MyPropsInterface, MyStateInterface&gt;` so the interfaces that enforce the "shape" of `this.props` and `this.state` objects inside of components. I in-lined the interfaces because as you can see they are really not that extensive :) Cheers ! EDIT: typos
maybe this? https://github.com/metaodi/iphone-preview https://github.com/Upstatement/mobile-preview (almost perfect but its a wordpress plugin) https://github.com/threefunkymonkeys/mobile-preview there was a good one on github a while back also, not sure if this is it.
I can't quite do that, for two reasons: 1. I work as part of teams, therefore there must be standards within the team's code 2. I'm a consultant. I work in many teams. I need *reasonable* recommendations I can then give out.
&gt; Naturally, people realised that it is better to group files by components. And your test file componet_test.js should be next to your source file component.js, not hidden in some remote folder called "unit". Now Ember simply won't work with that! I call this enforcing bad practice, so no thanks. Ya, I strongly agree that this separation can be bad, we are working towards a better designed structure. It is taking time (as turns out many good ideas, don't actually compose well together), and also because we want to be relatively confident before subjecting such a convention change as we realize even churn for good reason, has high cost. On a positive note, we are confident we can actually support both concurrently, allowing for easy migrations (and a strong churn cost mitigator). Expect to see more information in our RFC's as this exploration continues to evolve.
ember-cli remains optional, it became the default on guides because it is the most streamlined approach to take an app from experiment to production. Batteries Included. 
I believe the following popular editors, atom/sublime/vim/emacs and even VSCode have this feature (or one aligned with the design of said editor/IDE), under the hood they merely delegate the work to the CLI.
Overall, your team should pick a standard and stick to it. It doesn't matter which, as long as everyone's using it. I have my own preferred way of indenting, which is to use tabs when indenting a block, and spaces when indenting to line code up visually. function () { var x = 2, // one tab y = 4; // one tab followed by four spaces } Which I like, but it's really pedantic, and I don't see teams actually using this system.
This is completely the frequency illusion kicking in here, but I hadn't even heard of `await*` before yesterday, and now i'm seeing it everywhere. It's been dropped from the ES7 spec by the way, it's not valid syntax any more :)
What wrapper did you use to make it a native app?
i dont think there is a community consensus on anything in web development :P. Do whatever makes you most comfortable, as i said before i let my environment (visual studio) deal with that.
This is not the same as Promise.all, this will wait for the first task to be completed before starting the second.
https://www.reddit.com/r/javascript/comments/41k55t/the_only_bad_thing_about_es7_asyncawait/cz3mn53 It's like the second snippet. The key point is that both promises were kicked off before the first await was reached. **Edit:** Or let me put it this way: The gears are already set in motion when a promise is returned, not as you await its result. Anyhow, this is basically the reason why I think it shouldn't be written that way. This construct is easily mistaken for a sequential one.
As always, I'm here if you want to ask me any questions or give me any feedback
Ahh that's fair. Async/await can definitely seem like magic if one isn't aware that promises are being used under the hood. My introduction to async/await was a realization that I could replace all cases of Promise.coroutine(function *() { yield someAsyncOp(); }); with async () =&gt; { await someAsyncOp(); } So it was obvious at first that promises were still being used. I agree that if someone know nothing about promises and jumped right into using async/await that they might end up scratching their head trying to understand their behavior.
I don't really care all too much about the device sensor info, but the WebRTC has been a concern for a while. Hope somebody comes up with a fix soon. 
I'm assuming you're the creator because of your username? In that case, I thought that I'd let you know your website is unreadable on my phone. The mailing list popup fills the screen, and any cancellation button is not visible on screen. Additionally, the image header is gigantic vertically, and must be scrolled through to even get to the content. I recommend you test your webpage using mobile emulation. Both Firefox and Chrome have different ways of doing this. I have an iPhone 4S. Of course, you could just ignore this and accept the minor reader loss - it's up to you. 
LOL spoken like a true redditor!
WebRTC has been [abused](https://webrtchacks.com/dear-ny-times/) in the past. BTW have you heard of [WebRTC network limiter](https://chrome.google.com/webstore/detail/webrtc-network-limiter/npeicpdbkakmehahjeeohfdhnlpdklia) extension from Google? It limits the IP addresses used by WebRTC.
You can use a regex with .match() but I couldn't tell you what the regex is as I'm dig shit with that. But it would work. 
&gt; I still don't know how to check how many numbers are in the value var nlen = "12345abc*#&amp;$".replace(/\D+/g, "").length; As for how to test for all 3, I would just create a function to validate each thing you want to validate, then you can setup individual tests for each, or just a single test that tests all of them and returns true or false. Depends on your end goal as to what approach would be best.
Thank you for this and all the work you've done with babel.
Actually, I hadn't heard of it! I'll take a look, thanks!
I just added a list of useful links to the bottom of the post and his is on the list. Regarding excessive line length, the combination of single responsibility scripts, passing params between scripts, pre/post, and punting to separate .js files as necessary provides all the compositional power I need.
&gt; I work as part of teams, therefore there must be standards within the team's code The code needs to conform to the team standard when you check it in for code review. The local code that you are actively engaged around can be whatever indentation standard you wish. &gt; I'm a consultant. I work in many teams. I need reasonable recommendations I can then give out. This is the recommendation I would give out. I was also a consultant in my previous employment. The only downside to this approach is that most common diff processes, particularly those in the automation pipeline, are not language aware. That could be a problem if beautification change the code in such a way that results in many false positives when a diff is conducted. This is largely mitigated though, by setting a team standard around a particular beautifier and a particular set of options. Setting a team standard in this capacity should be largely invisible as the beautification process should run as part of a build or commit process, which puts in the configuration realm outside of most developer's immediate visibility.
I've been using a polyfills service for over a year now, just stick it in the head and forget your troubles: https://cdn.polyfill.io/v2/docs/ You can pull it into a browserify build if you like just remember to use the gated flag. 
Thanks for all your hard work, James! Writing documentation is always painful, but it's oh-so-appreciated.
I didn't really feel like this article said anything other than "Why don't more people use the framework I love? I mean, they kinda do, I just didn't realize it at first. Nevermind."
yes, that is my current solution. However, there's ppl above me that don't like it. You know the type: `3rd party service dependency exception!!`, ` It doesn't look like java5 exception!!` . As you can imagine, I feel very dirty to add all locales to the browserify bundle. I'd rather build the polyfill service in house. I am hoping they have an epiphany and accept that using a polyfill service it's a necessity. Btw, can you go in more details about how you pull that in browserify? do you just scrape the service and download the polyfills?
Not really the same thing, you can read http://router5.github.io/docs/understanding-router5.html to understand a bit more about what router5 is. At it's core it is just router, allowing / preventing state transitions: basically an unit processing navigation instructions, and outputing state updates. URLs are not first-class citizens, and route updates can be processed like any other data update.
This is really cool. Thanks for sharing!
it’s still &gt; Makefiles, but objectively worse which makes me wonder why the fuck anyone would want to go back there after decades of build tool development.
zeitgeist? ^_^
The same thing could be said about Chinese if you only speak English. It doesn't make English objectively better, you're just already adept at it. It sounds like you'd benefit greatly as a programmer by expanding your language repertoire to something not ALGOL derived.
Hi /u/loigiani, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `loige.co`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [loige.co](/search?q=%28and+site%3A%27loige.co%27+author%3A%27loigiani%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|65|89%
Hi /u/10_6, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
The argument was really similar to the one you are making... but from the opposite side.. &gt; Why change the names of the concepts, though? Such as **Model -&gt; Store?** Seems like that will just add unnecessary potential confusion. The thing is models &amp; services (or controllers) with their fabled MVC have been around for quite some years now and Flux is rebranding of one particular implementation of MVC.
Why not just use tabs? If someone told me their standard was 'tab, or tab then four spaces' I would never follow that - and I'm a stickler for standards. But standards need to be easy to follow, and need to not be arbitrary. Standard should be: "Indent, and by indent we mean [xxx]".
Because we want users to explicitly depend on plugins/presets so that they don't have worry about breaking changes out of nowhere.
Thanks for the advice. I'll try to some interesting content from other blog I follow!
This is why I use DoneJS
I haven't jumped into Ember other than a few short tutorials but I really want to since it does seem follow OOP and MVC concepts, just can't seem to find a very good and thorough tutorial on Ember2.0. Obviously, you can find a lot on Ember pre-2.0 but i'm nervous to commit to learning using pre-2.0 tutorials if the paradigms have changed drastically. Don't want to learn old habits and then find out that the new and better way is completely different, but it's easier to find tutorials that teach you the entire framework, pre-2.0 and I can't seem to find anything that goes full circle with post-2.0.
I'd use bower + [debowerify](https://github.com/eugeneware/debowerify) to include the polyfills I need in the bundle, you'll want to limit the features requested to keep the size as low as possible, if you're minifying the bundle don't request the .min version. Add something like the below as a dependency in bower.json, then require it in your main js file: \{ "polyfills": "https://cdn.polyfill.io/v2/polyfill.js?features=Element.prototype.classList,Array.map&amp;gated=1" \} I get the concerns of your bosses, adding a big chunk of third party code to your site that is out of your control is a terrible idea security wise, especially something like this that works at a low level. I'd recommend reviewing the polyfills you chose to use.
The talk here is about alternatives to Angular. I'm an Angular developer that put together a ton of tooling with Gulp and even more with Grunt, but I liked the way Ember made decisions for you. During my time with Ember the only complaint I had was that they were too rigid and the documentation for noobs was lacking, but that probably changed now. I was particularly interested in the Ember-data package so much that I started using a parallel package for Angular called js-data. The ideas that Ember has are very well thought out and I would be happy working with Ember or Angular in any project. I don't have experience with React so I can't say good or bad about it.
ES5 for: for(var i = 0; i &lt; cars.length; i++) { cars[i].honk(); } ES5 forEach: cars.forEach(function(car) { car.honk(); } ES6 forEach: cars.forEach(car =&gt; car.honk()); ES6 for-of: for(let car of cars) { car.honk(); } I prefer for-of for simple iteration. I only use forEach if it's the last method call in a chain of method calls.
Any requests that is naturally asynchronous should have a Promise API. Anything else should be synchronous and normal function calls.
Yes, you provided a simple example, but the true world isn't that simple. If you want to convinve people to switch to more pure functions, you'll have to convince them with bigger examples. I know that's hard in a simple 10 paragraph article, but nothing of what you wrote gave me any more reason to switch to pure functions On a side note, I'm also in favour of pure functions, but I have trouble with writing applications that actually is pure due to the state I have to manage (The Redux pattern/framework/whatevs seems promising though)
This conversation is kind of stupid. People whine about moving off of Gulp/Grunt with shifting arguments. First it starts out with... *that's nice, but show me a build process that doesn't suck*. Then when you do show them **exactly** the kind of proof they asked for its more whining: *that's reinventing the wheel* or *I could never work with so much NIH*.
 function Person(name) { this.name = name; this.sayName = function() { alert("My name is " + this.name + "."); } } var bob = new Person ("Bob"); var personArr = []; personArr.push(bob); personArr[0].sayName(); //alerts My name is Bob.
I thought I was going crazy. It's the Groundhog Day of /r/javascript.
I completely agree, finding tutorials which are relevant to 2.0+ can be a bit daunting. Luckily the guides/api on the official ember site are much better than they were previously and are constantly being improved, another really awesome site I highly reccomend is http://emberigniter.com/ which is 2.0+ only tutorials ([this post in particular is great for starting out](http://emberigniter.com/5-essential-ember-2.0-concepts/)), explained really well and has a mix of basics and higher level ember concepts. Also the ember slack community is also really helpful and friendly if you get really stuck or have any questions.
&gt; Then we tried hiring more developers in India. Found your problem.
will add it in a couple of days
I'm all for functional programming and having "pure" functions in JavaScript. However, the article doesn't go far enough to describe the scenario; it is quite common to use closures in JavaScript (and indeed functional languages in general), so the example given isn't necessarily a bad use of the language. It would be bad if the variable were repeatedly manipulated after assignment, but that in my mind is a much a case for single assignment of variables as much as anything (i.e. Treating them as immutable)
ooh, that was a tricky one! thanks for pointing out
Nice. I was really confused as to why Force Touch and 3D Touch had two different JS APSs in Webkit - I thought the inclusion of Force Touch API in Desktop Webkit was indicative of that API coming to iOS (and thus Force/3D Touch coming to iOS). Instead they have two different APIs for essentially the same thing.
You feel like a hipster because you're bragging about using something before most people and adding literally nothing else to the conversation. That makes you a hipster.
This is incredible.
How is Angular2 comparing to Ember2 now? I am using angular2 and I found it quite good after adding those oop concepts. Is ember2 more productive than angular2?
&gt; I think what is becoming clear from the latest movements in the JS world is that pure functions are key to creating understandable and testable code. What do you mean by "pure functions"? Do you mean functions that adhere to the single-responsibility principle? &gt; But the important thing is that you do plain data object to plain data object mapping with no side effects. I'm not sure what you mean by this, either. Could you explain? 
Seems like this is just an abstraction upon the base concept that you've described, albeit without "messy-ing" up the gulp file.
First you use a regular expression (regex for short) for the words, then for the numbers, then for the symbols. Trying to do all at the same time only gets it more complicated. It could work if you only search for ANY, but to check for ALL, that's a whole different story. Anyway, you need to look for a regular expressions tutorial online. Regular expressions are a MUST-LEARN tool that will stay with you all your life, and recruiting firms often ask for regex skills in their tests. As for counting numbers, I suppose you're talking digits. You just iterate over the string from 0 to its length, use charCodeAt(i) (where i is your loop variable) and compare between 48 (that's the ASCII for zero) and 57 (ASCII code for nine). If it's in range, voila! It's a digit!
I've had the same experience. Just gave up on Ember [1] because after having followed the tutorial and the docs virtually everything else I found was for outdated concepts (Controllers) or things that plain don't exist in the 2.0 docs (like Views). I did find one site that really helped me, though: http://emberigniter.com/ Edit: I should add that I'm getting back into front-end dev after a few years out of it. Things have moved on a lot. One of the things I liked about Mithril is it doesn't do that much, and it's just Javascript, and I can follow what's going on. There's also more discussion of concepts. I readily admit that I just might not be a good enough front-end engineer to appreciate Ember and all it can do. [1] Switched to Mithril, things are moving more quickly but it also does a lot less than Ember.
What kind of breaking changes would you expect to occur if the default was to downstep ES6 to ES5? 
I would assume it is just for the fact that Ember 2 is production ready and Angular 2 still being beta.
Read "Working Effectively with Legacy Code". It's not a javascript book, but a book about how to add tests to an existing codebase. It includes a lot of good stuff on what tests are for, what kinds of tests are useful for reasons, where to add tests when you're on a deadline, and how to refactor code to be more testable. Keep in mind that the book focuses on object-oriented code (so mostly c++/java examples) but I think extrapolating to standalone functions is pretty easy. EDIT: For tools, try mocha, selenium, karma maybe? Jest?
I want to take your advice. I don't know Java or C++, though. Do you think I should still be able to follow along fairly well?
Something about this just makes me feel icky. It's a great feature, but without static typing and actual tuples, I wonder just how out-of-control this pattern will become.
There's already an ember-cordova addon. I have no idea what the plan would be for a native build pipeline though.
Super fast, light-weight AND same API as React ? I'm sold!
I prefer the level of configuration options that babel provides. I was playing around with it - and really once firefox gets let/class, *most* of the little project I've been working on will work with only transpiling parameter destructing and module imports - granted, I'm not using generators or things like async/await. The only way I was able to figure this out was to go inside the default es5-6 preset, where I was able to clearly able to see what plugins were present, and replace the preset with a list of plugins... it's nice to have that level of modularity &amp; configuration.
I think it will work fine for the typical scenario with 2-4 promises. There is of course also the option to create a function similar to Promise.all which uses an object literal instead of an array literal. Then you can attach names to things, which means that even a dozen promises won't be a problem. Here is a complete example: function delayedByOneSecond(v) { return new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(v), 1000) ); } async function parallel(obj) { let keys = Object.keys(obj); let promises = keys.map(key =&gt; obj[key]); let values = await Promise.all(promises); let res = {}; for(let key of keys) { res[key] = values.shift(); } return res; } (async function main() { let start = Date.now(); let {uno, dos} = await parallel({ uno: delayedByOneSecond('uno!'), dos: delayedByOneSecond('dos!') }); console.log(uno, dos, Date.now() - start); })();
These I feel mainly are directed at those who feel that full blown frameworks in JavaScript are bad because there's too much "magic" and that creating the glue for all the pieces of your app for 6 weeks before building the app resulting in no standard way to do it is a perfectly sensible solution.
I've been working on a bridge to wrap Inferno components for React, so you can start by replacing one section of a React site and expand from there.
[tinyColor.js](https://github.com/bgrins/TinyColor/blob/master/test/test.js) has some good tests as well, also in QUnit.
I'm going to get downvoted to oblivion for this but here goes. I'm a little tired of seeing posts like this, that pop up every so often. There's a fundamental problem with super opinionated frameworks, to which the "one tool to solve all my problems" approach tends to evoke quite consistently. Have you ever worked with an Ember app with over a million LoC? What about an angular app? What about 500k? 100k? Backbone was a perfectly viable solution for writing pristine SPAs before angular, ember, react, meteor, and all of today's players came along. But as you've noted, it takes time to learn. Using it effectively involves research to discover best-practices. So what happened? Angular came along with an opinionated vision that wired dependencies. Supported bi-di data binding. This. That. Bells. Whistles. People were ECSTATIC about angular, and how fast you could get up and running, even with complex data-driven apps. 5 years later.. What have we learned? Writing big apps using opinionated frameworks is garbage. Code becomes hard to maintain. Dependencies trip over themselves. Poor performance due to unintended data-binding side effects. Usage paradigms change halfway through features. The creators then start bolting on new features to solve problems introduced by the unanticipated ways in developers were using their product. Eventually, too many bolt-ons change the composition of the original framework. Then the framework itself needs to be rewritten altogether. Do you see the pattern here? This type of development becomes sickening in a way that you can't fathom, because you haven't crossed that threshold yet. Sure, the angulars and the embers of the world seem appealing at first, but that's all they ever are. Appealing, but not useful. This is evident by the influx of users leaving angular for greener pastures. The framework is SO opinionated that there isn't even a clear upgrade path to its successor - essentially leaving some really large codebases scrambling to figure out what's next. It's so opinionated that the second version hasn't even made it out of **beta** yet. Angular 1.x suffered the fate of every super opinionated and contained framework: those opinions don't hold up over time, they are not a "one size fits all" solution, and when you don't have the ability to easily change opinionated constructs yourself as a developer, you essentially become 100% indebted to your codebase. So then react comes along. Listen up folks. React is not suddenly the most popular because people say it's cool. It's an extremely pragmatic and unique solution that can be precisely molded to fit any type of problem. Facebook didn't release react to wag their dick. It's isomorphic. Generally speaking, it's performant. It's unidirectional. It's a compilation of fixes to some of angular/ember's worst problems. The drawbacks? It requires a **lot** of homework! Like backbone, its not a one-size-fits all solution. Far from it. But that's because the best frameworks do not force you to use them a certain way. Every app has different requirements, use-cases, and usage patterns. And your frameworks and tooling should accommodate that. Part of writing scalable, modular apps requires tooling. It requires research. It requires time, patience, and lots of effort. But when applied and combined properly, the result is good engineering. I'm sorry to break it to you, but frameworks, tooling, research, and modularity are all critical to creating products that are not only sound, but are easily scaled, maintained, and refactored. You'll never get that from an opinionated framework. Eventually those types of frameworks begin to trip you up more than they help you. And what happens when something breaks? The more opinionated, the more difficult the support. The more opinionated, the smaller the userbase. Newsflash... Ember isn't popular because it's embraces paradigms that have been outdated since 2012. It's only "mature" because they didn't bother to rewrite it, which as we're seeing before our very eyes with angular 2, would have meant brand suicide. Opinionated frameworks are nothing but a fad folks. Good for small projects and PoCs, but not much else. 
I'm porting an app from 1.8 to 1.13 (mainly for Glimmer). Templates which worked fine are failing to compile. The biggest problems are mismatched html tags (trivial to fix) and changes to the behavior of bind-attr (not so trivial!) For example, {{bind-attr class="view.foo.bar:urgent"}} used to add the "urgent" class if "view.foo.bar" was true and now throws an error. I'm not sure what you mean by "semver compliant", but I hoped a minor version update would go easier. Edit:grammar
One of the key principles, and /u/TheWakeUpCall alluded a bit to this, it to separate the object that knows about your business/application logic from the object that renders a widget, and testing those aspects independently. If we use React Components as an example, start by separating the component that responds to state from the component that renders items to dom. By having the connected component parse the stores and pass the relevant data through to the presentational component via props, you make your components easily testable, because in your test, you can just render the presentational component to a string, passing through props manually, and validate the output. With Redux / Single-Store Flux you can also trivially test your connected components by hard coding the app state in the test.
To be fair you're an entire major version behind, and your biggest problem is trivial to fix. 
Having done both, I know I'd rather spend a day writing a build script or custom functionality than fighting with a framework to just to do exactly what I want. Varies by framework and how "custom" it is you need your application to be. 
Worth reposting for others to see as well: https://www.reddit.com/r/Frontend/comments/41lpg9/slug/cz3o4pv
&gt; As I mentioned projects don't tend to mix cherry-picking and individual packages. They tend to prefer one over the other and stick with it. Sure, most (but not all) projects just stick with one approach. The problem is when you bring in a few dozen dependencies that all like to use lodash, each author seems to prefer a different require statement. The end result is that – in the actual apps I've been developing over the last two years – lodash consistently appears near the top when analyzing bundle size with [disc](https://github.com/hughsk/disc) and similar tools. `NormalModuleReplacementPlugin` sounds like a lot of manual configuration and deep knowledge of lodash internals. Is there a succinct example showing how to use it with lodash?
Found it to be very flexible to work with. It's an awesome framework overall.
I had the same experience. And I can tell you first hand Ember1.x practices often don't work in Ember 2 land. 
Check out [tape](https://www.npmjs.com/package/tape). It’s a beautifully simple testing library with a small API. All the UNIX-y node folks use it, and it’s an easy (and _fun!_) way to get started.
http://imgur.com/gw8NdJe Completely broken on iOS / Alien Blue iPhone 6S Tried in dedicated Safari and all the image demos are broken because of apples 'push to pop' on images. 
After working with hapi, joi validations are a must have whenever I write node api's.
It was a comment about the flood of async articles that came out recently. 
Lol wasn't quite what I was going for
It seems I'm a week or so late to the party. The answer is that none of the "annoying behavior" demonstrated in your fiddle has anything to do with classes. In fact, we can reproduce all the same issues (if you can call them issues) without using a class anywhere. // Not a constructor var mySharedBehavior = {}; // Create object var myInstance = Object.create(mySharedBehavior); // True as expected console.log('mySharedBehavior isPrototypeOf myInstance'); console.log(mySharedBehavior.isPrototypeOf(myInstance)); // Change prototype mySharedBehavior = { classProp : "Oh No!"}; // Now this is false because the prototype was changed console.log('mySharedBehavior isPrototypeOf myInstance: '); console.log(mySharedBehavior.isPrototypeOf(myInstance)); // If they happened to be built from the same prototype var proto = {protoprop: "shared"}; var A = proto; var B = proto; var a = Object.create(A); var b = Object.create(B); console.log('B isPrototypeOf a:'); console.log(B.isPrototypeOf(a)); // simply because they share a prototype
"semver" is a shorthand for Semantic Versioning. The official definition can be found here: http://semver.org/. It is a set of rules and guidelines to ensure a stable API surface over time. The short version is that public API changes can only be made on a major release (5.x.x). Minor releases (x.3.x) are "additive", and cannot change or removed existing APIs. Patch releases (x.x.9) are bug fixes. Let me be clear: Ember is the *only* JavaScript framework that adheres to semantic versioning. Angular changed public APIs willy nilly in the 1.x series and as pre-1.x software React is not subject to any stability rules. If this fact is out of date I'm eager to hear it, but Ember has been following these rules since Aug 2013 and we plan to keep following them. Is the execution perfect? Absolutely not. But it is damn decent, and there is huge effort put toward it. Many, many apps made the jump from 1.8 to 1.10 (HTMLBars) smoothly, and over those releases we migrated the entire rendering engine from being string based to DOM based. Glimmer (1.13) was bumpier. We're applying the lessons learned to the upcoming render refactor and plan to make it as smooth as 1.10 was. Backwards compatibility is not a high-class job. Nobody wants to be the person writing polyfills for IE8 in 2015 (which was supported all the way until the 2.x release in June), but it was all done. The Ember team is serious enough about stability to *double down* and start making LTS releases (https://github.com/emberjs/rfcs/blob/master/text/0056-improved-release-cycle.md) in addition to being semver compliant. LTS releases will serve the enterprise community, but also provide a slower release cycle for addon authors to follow. It sucks that you have had a rough upgrade, but I also hope you don't think the effort that goes into our progress is a waste. If you're lucky you're on Ember-CLI at the least and I encourage you to review the upgrade guide found here: https://guides.emberjs.com/v2.2.0/configuring-ember/handling-deprecations/
That's awesome. Thanks for sharing!
Opinionated comments are nothing but a fad folks.
Simple when you already know promises. But it's not difficult to imagine a future where people skip promises and go straight to async, given that it looks a lot simpler.
It's amazing how many circles my iPhone can draw and animate without flinching. Pretty cool!
Pity `for...of` is slower than regular `for ; ; ` loops for arrays. At least in Java, performance is the same for its both for loop types. 
This is fun! http://codepen.io/anon/pen/vLWqEb Works fine on Chrome, but beware Firefox users! Will max out your CPU.
was curious how many circles caused which visual artifacts, added a circle count: http://codepen.io/anon/pen/pgdXvN
I suppose you can simply write an npm package that *will* do all the standard setup out of the box. In fact it is surprising it is not yet done. 
Really nice read! Love the focused examples on one thing at a time, with no clutter that doesn't need to be there.
I have been around the Javascript circle and used quite a few frameworks in my tenure as a front-end developer, including Ember. I can tell you from first-hand experience unless your team is comprised of awesome developers who learn very very quickly, settle in for a long and painfully bumpy road if you go down the path of opinionated Javascript frameworks. Leading a front-end team who are spending more time learning to use a framework and fixing issues when they get pushed is detrimental to efficiency and deadlines. Opinionated frameworks are toxic in Agile-led work environments. I personally just don't understand the need. The problem with any opinionated framework is lockin, but also lack of flexibility so you end up spending your days wading through documentation and praying someone has asked your question on StackOverflow. The Javascript specification has evolved to the point where we don't need to abstract it as much as we once did, we need to learn to start abiding by specifications, not replace them with our own. What happens when the product team inform you that your application needs to work in IE10 and your framework only supports IE11? Do you attempt to find polyfills and make it work, or do you change to something like React realising that nothing you have written can be re-used? One thing I do agree with in terms of being opinionated is TypeScript. I realise that some people are against TypeScript, but in my experience, it has been more beneficial to every project we've used TypeScript for in terms of efficiency and reducing code errors. In my experience it is easier to bring a team up to scratch with something like TypeScript and put some Git hooks in place to prevent TypeScript code with errors from being pushed. Some will point out Angular 1.x was opinionated and that it was pretty successful, Angular is the rule, not the exception. The reason people used it was because of the Google support and because nothing else at the time of its initial release came anywhere near as close. Look at Angular 1.x now, no decent developer is using it to build a new application, they're using Aurelia or React. Angular 2 released into beta too late and although they addressed some issues compared to version 1, it is still over-engineered and suffers from copious amounts of lockin. &gt;Ember makes a lot of my web decisions for me. I don’t have to waste brain cycles wiring together build tools like Grunt or Gulp. This makes no sense whatsoever. Configuring Gulp for example takes very little effort. This is the problem that Rails had a few years ago, people were using it because of its "magic" and not learning the actual Ruby language. When the framework didn't do something they wanted to do and there was no third party gem package available, you were screwed. Using framework magic only gets you so far, eventually there will come a time when the product team wants a new feature and the framework can't help you. This whole attitude of "get shit done as fast as possible" is the reason I have inherited some pretty horrible codebases in my career. When you take the time to build an application properly, take the time to document each piece and ensure you are writing the best possible code you can, that in my opinion is better in the long run than shaving 10 minutes off the initial setup process. There is a reason that React is so popular: because it isn't a framework. React is like jQuery with a little more structure and versatility, it also doesn't tell you what to do. You can use it in a framework or by itself. Don't get me wrong, I liked Ember (I only used it on one project), but it doesn't do anything that other frameworks don't already do. It really has no advantage other than some command line magic and as a developer, I like to know what is going on in my applications. For me I am happy writing React applications using TypeScript. My front-end dependencies as a result are substantially smaller than any Ember or Angular application can boast.
Title suggested this would be a 400+ pages book covering past, present, future and all react’s implementation details… But it is just another tutorial. Not a bad one, but not a "bible" :)
cute, I added several circles right when it was at the bottom.
This would make an excellent loading spinner. Continual variations, a bit mesmerizing. It reminds me of watching flames. Well done.
Totally agree that if the variable being changed in a repeated manner is a bad thing and I did not want to touch things as immutable state because they are a topic for another article I think. I found through my experience that when ever you have a complex JS app and there are references to the scope outside of a function it can get pretty hairy. Especially in testing. Maybe I should have written a more complex example of actually seeing the pain points, but I intended this article to be just a start for someone to go in and explore more functional way of doing things! :) Thanks for the insight mate, good points !
Thanks for the feedback and yeah using `concat` to actually concat strings is a great way but I wanted to easily point out whats going on. :) For not being insightful enough, I agree. I probably did not make it clear in the article that its a post that should just give you enough of the cake to taste it and then you go out in the world and explore. :)
What are you on about? Ember is probably the best framework for making production grade stuff, for example the whole Twitch front end runs on Ember. You're probably having to hack stuff because you don't understand the concepts, when you use Ember you do things The Ember Way and you'll find you won't ever have to hack around parts 
@x-skeww, I was refering to `for ()` loops for arrays only exclusively. Java's "enhanced" `for ( : )` loop has special behavior when dealing w/ arrays. That is, rather than using an ***Iterator*** like it does for non-array objects, it transforms its foreach loop into a regular loop! However in JS, its `for...of` loop always wraps the container in an ***Iterator***, even though a regular direct numerical index access would suffice. 
&gt; However in JS, its for...of loop always wraps the container in an Iterator, even though a regular direct numerical index access would suffice. So does Dart. However, as you can see on slide 71, none of that iterator stuff remains after several separate optimizations did their job.
Have a list of regex + message pairs, iterate over them, and if the regex doesn't match add the message to the list of errors. If there are any errors, display them.
Ember is very serious about testing and building big applications. It has a complete section about testing. Also, testing has first class support in ember-cli. https://guides.emberjs.com/v2.2.0/testing/
The usual way to check for potentially undeclared globals is `typeof $ !== 'undefined'` or for more strictness, something like `typeof $ === 'function'`; with that said, you could combine both approaches, waiting until DCL to start running a piece of code that runs a chain of timers that keep waiting for `$` to be available to script. (Actually, timers are used more generally in a DCL compatibility shim for old versions of IE: A timer would be set that tried to move the screen a pixel to the left; if the screen couldn't be moved yet, a new timer would be set, otherwise DCL would be presumed to have occurred.)
notification! https://www.etsy.com/shop/Aminga
notification! https://www.etsy.com/shop/Aminga
notification! https://www.etsy.com/shop/Aminga
notification! https://www.etsy.com/shop/Aminga
An NVD3 React component https://github.com/NuCivic/react-nvd3 
Wait, so the original author is actually replacing gulp with webpack, and then calling it from an npm script? By that logic, I could just call gulp from an npm script!
Tape is really great. Highly recommend. It's simple and flexible.
This is even cooler! http://codepen.io/anon/pen/rxpNaz
Interesting take on FP by Uncle Bob: http://blog.cleancoder.com/uncle-bob/2014/11/24/FPvsOO.html
The example code doesn't make much sense in relation to closures, closures allow you to maintain the state of variables even after the function has been returned. This would be an example of a closure - function say667onwards() { // Local variable that ends up within closure var num = 666; var say = function() { num++;console.log(num); } return say; } var sayNumber = say667onwards(); sayNumber(); // 667 sayNumber(); // 668 sayNumber(); // 669 
The example is using the new D3 4.0 alpha version, which is a complete rewrite and takes advantage of ES6 functionality. https://github.com/FormidableLabs/victory is the only React wrapper I'm aware of which is based on D3 4.0 but seeing the terser code from people using the new version leads me to believe wrapper components will be less necessary going forward.
Contrary to what other commenters have said, this example illustrates closures excellently. The example shows that `say` has a closure over the variable `num`. I think what it is trying to get at, is that even though `num = 666` when `say` is expressed, the closure only captures a reference to the variable `num`, it doesn't take a 'snapshot' of the current state. This is really important, and is illustrated by the fact that when `num++` is called, and then `sayNumber` is invoked, it logs `667` _not_ `666`. The reason the example is written in a way that shows the variable assignment, then function expression, then `num` increment, and finally the function expression being returned, is to illustrate the fact that the variable is being mutated, but the closure is just around the variable reference, not the variable value at expression time.
The point of this exercise is not to print 667, it's to demonstrate some aspects of how closure works. In other words, it's a toy example. 
It's like you're making your own little hurricane! Surprisingly fun.
This is so cool. I can't even begin to imagine how you can achieve that. I hope one day I can make cool stuff like that too.
Doesn't seem to rotate in my browser....
By ridiculous you mean absolutely fabulous, right?
~~Strings are primitive values and are always copied when assigned to a variable or passed as an argument. So the variable last contains the string 'banana' and not a reference to the last element in the array.~~ You never assign a reference to the relative place of something in the array to a variable. You either assign a copy of the value itself (for primitive values) or a copy of the reference to that value (for non-primitive values).
Very cool. I modified it to set a random color for each circle when added, with interesting results: [http://codepen.io/charlieonthedancefloor/full/bEaNra/](http://codepen.io/charlieonthedancefloor/full/bEaNra/)
You can extend the Array type to include a "last" function. Using the slice method, you can gain access to the last element in the array. The following code snippet should get you the results you're looking for. This is a basic implementation that will cause errors if you were to use it on an empty array. Array.prototype.last = function(){ // slice returns a shallow copy of the array from the specified index return this.slice(this.length - 1)[0]; }; var myArray = ['apple', 'banana']; alert(myArray.last()); // shows 'banana' myArray.push('berry'); // add 'berry' to the array alert(myArray.last()); // should alert 'berry'
A variable only holds the last thing assigned to it, not the history of actions that lead up to that value. `length` does not track `fruits.length`, it's a snapshot of the value at a particular point in time. If you want the last element of the array, write `fruits[fruits.length - 1]`. 
Got it, thanks.
this is what lodash does. Got it, thanks.
Yes. The loop creates a new context each iteration, so `const` for the iteration variable is perfectly okay. [There was a problem with `eslint`some time ago that complained about `const`](https://github.com/eslint/eslint/issues/3104), so we had a discussion and my first sentence is the summary of that past discussion. Also - see ecmascript 2015 specs, but I admit I hadn't looked at that myself, ever, before that discussion. Here's the linked example code in node 5.5: $ node &gt; const o = {a:1} undefined &gt; for(const k in o){ ... console.log(k) ... } a Also check out [what I wrote further down (or up)](https://www.reddit.com/r/javascript/comments/41ubzo/is_forconst_i_in_allowed_in_es6/czcn035?context=3).
[Why not just check the standard instead of asking?](http://www.ecma-international.org/ecma-262/6.0/#sec-iteration-statements) It's allowed. 
I changed #content to be just overflow-y:scroll. It made it a bit nicer without the bottom scrollbar showing.
What would you consider a good alternative? 
&gt; data tables Thanks i didn´t know that library, but i don´t need a tabbed table but a list of products with x design. Something like the booking search [Booking search to Paris](http://www.booking.com/searchresults.en-gb.html?src=index&amp;ssafas=1&amp;nflt=&amp;error_url=http%3A%2F%2Fwww.booking.com%2Findex.en-gb.html%3Flabel%3Dgen173nr-17CAEoggJCAlhYSDNiBW5vcmVmaEaIAQGYAQq4AQTIAQTYAQHoAQH4AQs%3Bsid%3D3a7f99f92f92ad1bf1fa342ad80ddead%3Bdcid%3D1%3Bbb_ltbi%3D0%3Bsb_price_type%3Dtotal%26%3B&amp;dcid=1&amp;label=gen173nr-17CAEoggJCAlhYSDNiBW5vcmVmaEaIAQGYAQq4AQTIAQTYAQHoAQH4AQs&amp;lang=en-gb&amp;sid=3a7f99f92f92ad1bf1fa342ad80ddead&amp;si=ai%2Cco%2Cci%2Cre%2Cdi&amp;ss=Paris%2C+Ile+de+France%2C+France&amp;checkin_monthday=5&amp;checkin_year_month=2016-7&amp;checkout_monthday=6&amp;checkout_year_month=2016-7&amp;room1=A%2CA&amp;no_rooms=1&amp;group_adults=2&amp;group_children=0&amp;ss_raw=paris&amp;ac_position=0&amp;ac_langcode=en&amp;dest_id=-1456928&amp;dest_type=city&amp;ac_pageview_id=f94a62b3ce100026&amp;ac_suggestion_list_length=5&amp;ac_suggestion_theme_list_length=0)
It does not reset the count.
its not simple there are algorithms for that. (generating a crossword puzzle), its pretty large mathematically... can google or wikipedia it
Indeed, fighting the framework sounds like loser game. Especially against bad practices. I want to see how big companies do their TDD with Ember, and how much time is wasted on finding tests for each file :) Where time spent on useful tools with general purpose is rewarding. There is simply no comparison.
Anytime!
I think it's ridiculous, doesn't work in Firefox :) https://i.imgur.com/4y7ABUI.png Don't know who to blame, Firefox with it "access-control-allow-origin" policy or developer who didn't take time to test in non-webkit browser
&gt; Look at Angular 1.x now, no decent developer is using it to build a new application, they're using Aurelia or React. That's certainly a stretch. A1 is stable and constantly improving with enormous ecosystem, whereas the other ones are still young and immature. There is simply no comparison. Speaking of Aurelia, their starter kit is still using Grunt, no joke!
Looks like that example is using d3 version 3.5.6 view-source:http://paulhoughton.github.io/mortgage/
I would suggest a library called js-data. http://www.js-data.io/ It allows you to use adapters to interface with difference APIs. And gives you filtering which you could use to get pagination. It also has Async methods to retrieve items and place them in a data store, which you can use as a central place to render your products with your library of choice. I like Vue.js these days, but it could work with React or Angular or anything else really. 
Works for me, still I wouldn't use it.
Wouldn't get as much clicks with "Just another ReactJS tutorial" headline. Gotta be clickbaity!
My bad, Firefox developer edition has some issues with this.
Why does it bother you? A lot of people find the spec difficult to read.
Very hypnotic, I had to add in [some music](http://codepen.io/anon/pen/qbpOXJ)
I completely disagree with the premise that Node shouldn't be used for a web app with a relational db. I think this entire section is a regurgitation of a similar article from a few years ago when it *may* have been more accurate. [Sequelize.js](http://docs.sequelizejs.com/en/latest/), [Bookshelf.js](http://bookshelfjs.org/), and, perhaps to a lesser extent, [Seriate.js](https://www.npmjs.com/package/seriate) are very capable and mature tools for working with relational DBs in Node. 
I too am learning to do unit testing on my code. I went with [Jasmine](http://jasmine.github.io/) to learn. I just ready the docs and then jumped into it. My best way of learning is hands on. I later introduced karma and grunt with a few addons to make the process pretty slick. You can check out my repo here for how that all went together. [github repo - realtime chat](https://github.com/Unrestricted-Coding/realtime-chat-RethinkDB) Hope that helps a tad :)
Hi /u/mariusschulz, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `blog.mariusschulz.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [blog.mariusschulz.com](/search?q=%28and+site%3A%27blog.mariusschulz.com%27+author%3A%27mariusschulz%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|5|100%
Example code linked is definitely not 3.5.6, seems it's not been built for gitpages - running it locally worked for me.
It's allowed, but not in firefox!!!. Firefox has a bug(that they don't consider to be a bug), that doesn't let you use `const` within `for/in` loop. It's going to throw: `SyntaxError: invalid for/in left-hand side`. Use transpiler for consistent behavior.
Normally, yes. That doesn't hold true when you're dealing with closures though. I'll leave the MDN link [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) since it can probably explain it better than I can.
worked on desktop chrome OS X, but not mobile chrome iOS for me
Loved it! Hahaha
Found this on stack overflow. He outlines the approach but doesn't provide any code. Sounds like a fun project. http://stackoverflow.com/questions/943113/algorithm-to-generate-a-crossword
Haha, awesome. It's rare to see a new kind of flashy. Like everything else flashy I wouldn't put it on a usability-first website, but a neat little promo or presentation? Sure thing. FYI, you've got a little layout bug (Chrome 47.0.2526.111 64-bit, OS X, mouse plugged in). Having the scroll bar present on the main body but not the curled bits makes the main body a little bit thinner, thus wrapping lines at different points, thus gradually growing out of sync as you scroll down. I don't remember which exactly, but there's some property that will give you the exact width of the content, and another for the content plus scrollbar.
In Ember? I was told it is impossible.
&gt; From experience . . . What was your experience?
Shhh, you'll attract the gays. Happy cake day btw. Edit: Thanks for the downvotes, I'm gay and I'll be honest the world fabulous attracted me.
How is this related to /r/jacascript?
Isn't working smoothly in Chrome Mobile for me. 
I wonder if the translation is bad, or there is something they aren't telling us? &gt; Ayesha Binish is soul owner of this blog ... and she does enjoy her work as **she is demented for her profession** and wonderfully for blogging. 
 Once you learn the basics of writing unit tests, the different frameworks are pretty easy to switch between. They're all basically just stylistic differences. Some folks use really minimalist things like Tape. It all boils down to asserting that what you're expecting is the same as what you're getting. That's it. That's really all that testing is.
blame yourself for your own stupidity : )
A UI Engineer would be the person tasked with making your graphical designer's UI actually work. It's a programmer or software engineer who specializes in implementing user interfaces.
Codepen is a sandboxy environment. You can't possibly expect people to test for other browsers.
A React Native or NativeScript app is basically 99% 'full native'.
In software, nothing is impossible. At worst it is improbable.
I can't seem to get your pen to run. However I would suggest stacking your images with absolute positioning for and fading out the images in order of z-index. This will create a smooth transition between images instead of empty content in between. If you can get your pen running though I would be happy to check it out. p.s.: as a beginner I'd like to remind you to put comments throughout your code so that when you need help like right now It's easier for others to help you out. (this is something I personally suck at so it's good to get in the habit while you're new)
&gt; I'm talking about the Dart VM. I'm still puzzled why you've brought the Dart subject here! @_@ Since Dart is fully static-typed, it's much easier to get such optimizations outta it. That's precisely why I've mentioned how Java dealt w/ arrays in its `for ( : )` loop type. Again, as I had mourned from my 1st post, JS' `for...of` is slower than regular `for ; ;` loops when related to arrays &amp; pseudo-arrays. That's the truth now! And it will be for a long time! Whether Dart or Java can outsmart that is irrelevant for this topic! O_o 
Odd. I can't duplicate that behavior. Works on that version of Chrome (and Canary) for me. There have been a few recent changes; maybe its fixed? Edit: Should be better now. Needed a couple things.
Yes. 
Hysterical! Good job.
That's really ironic, I wrote a module with the same exact name and nearly the same features (mine does a fair bit more if I'm being honest). I haven't released it yet though.
There is JSDOM, but I don't know how painless that is.
Is this really a bug, though? In this context the loop variable is not a constant since it's being incremented with each pass of the loop... Seems like the other browsers are not enforcing the constant-ness (read-only nature) of the `const` type; and this seems like `let` would be better in the context of a loop, or any context-specific use-case.
Ah I see you used the machine that goes "Promise.all().then()" So yeah, you used a _hybrid_ approach. And I think this has merit! It's cleaner than creating three promises. 
That's interesting! Because many of your method signatures and parameters look identical, and your graphs look just like the graphs with UI Router Extras. :-)
Hard to find a cool name without "js" attached to it already :) 
Once you get beyond a handful of people, your programmers typically specialize. Database engineers, UI engineers, systems engineers, mobile application engineer, devops, etc. Putting "programmer" in a job req or a resume doesn't explain as much about where your specialties lie as "UI engineer" would.
I've never had any intuition of what the Fourier series was before. Fucking cool.
I am also having this issue on Firefox 43.0.4, 64-bit, Win 7 http://i.imgur.com/8jPvizA.png
With the Web Audio implementation there is no noticeable lag on the devices I've tested, even mobile. Audio nodes are cheap for the browser to create (per docs at https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode) so I'd imagine performance is pretty good across different devices. I don't know the specifics of a production grade MPC, but this will play 13 simultaneous sounds without skipping a beat and that's as far as I've tested it. There are similar examples at http://www.html5drummachine.com/ and http://html909.com/. However, there is a noticeable audio lag when using the HTML audio tag implementation, for example on IE11. This is due to the differences in precision for the audio scheduler clock; with Web Audio we have microsecond precision, but HTML audio tags we only have millisecond precision (handled by SoundJS). The need for microsecond precision is described in the article linked in the post [A Tale of Two Clocks - Scheduling Web Audio with Precision](http://www.html5rocks.com/en/tutorials/audio/scheduling/). The imprecision becomes noticeable toward the end of a loop, but corrects itself on a newly scheduled loop. I'd like to open source a version where you can record the tracks/beats using input from a microphone. But I'm interested in open sourcing as much of it as I can once the campaign is finished :D
What if I need my "UI Engineer" to write some system code in C for me? When I was an electronic engineer, we were all electronic engineers. Now, maybe you couldn't work on my project cause you were in a different department with a totally different product but you were still an electronic engineer.
Install firefox on a flash drive, show them all this cool shit, take away your flash drive and tell them they can have cool shit again when they get rid of IE. problem solved.
Oh, no, I dev to chrome then if there's ff issues I fix them, then I'll use the chrome iframe thing if anyone looks. Piece of fucking nonsense, ie8.
Do it the diplomatic way and let them know that it can be done, but it will take 500 hours.
Some EE's specialize in amplifiers and generators, others specialize in integrated circuits. Are you saying that you think all programmers should be capable of doing every conceivable programming task equally well and that there is no room for diversity of skill sets? 
To be honest, I am disappointed that the relationship between async/await and promises is so transparent. Async/await is an abstraction, and it deserved to be fully abstracted and opaque. Additionally, while this *is* a "hybrid" approach, it also is not. The async/await abstraction is so thin, that's it's arguably more correct to call async/await "simplified promises." All that said, it's important that developers keep this relationship in mind. I am surprised how many developers have commented that async/await is only good for sequential work when that simply isn't the case.
Very neat project! From a quick listen on my laptop speakers, it sounds like you used a single LP filter for the effect. The WebAudio LP filter is 12dB/octave. Did you consider putting two of them in series to create a 24dB/octave filter? I believe the MPC1000 at least has two 2-pole filters that can be linked in series for a 24 dB/oct slope.
Hey! I worked on the filter part for this project and it sounds like you know a lot more about audio processing than I do haha. We never really considered putting two filters in series but def interesting to know. Reason we didn't was that creative and the client were happy with the desired effect!
&gt; Firefox has a bug(that they don't consider to be a bug), that doesn't let you use const within for/in loop. That doesn't seem to be the case. https://bugzilla.mozilla.org/show_bug.cgi?id=950547 https://bugzilla.mozilla.org/show_bug.cgi?id=1101653
GifMe is an add-in sample I wrote using JavaScript. I think it's pretty awesome (and may work on getting it published), but I wanted to share it with y'all to demonstrate a non-corporatey scenario where Office extensibility can be great.
I think it's pretty damn cool!
They are all EEs but apparently software programmers are not all software programmers. Now that I think of it, I knew some mechanical engineers that designed mechanical interfaces to equipment. Doesn't that make them UI Engineers, too? This just confuses me.
The last release was over a year ago
For unit test you can skip phantomjs all together and just mocha or jasmine standalone
How does this compare to socket.io ?
&gt; "There is no reason for iterator-based loop constructs to be any slower." Iterators are objects w/ methods calls. No way they're faster than a simple direct numerical index access. &gt; There is a huge difference between being currently not fully optimized and being inherently slow. I've never said anything like those above! I've just stated the simple truth that regular loops are faster than iterator-based traversals for array-like containers. How much faster? Dunno! Just that they're faster due to the virtue of their implementation nature! @_@ And just to leave it clearer: I'm not advocating the abandonment of latest loop styles in favor of traditional loops. I've just mourned an "alas" b/c even though `for...of` is über cooler, it's not the same performance as the old &amp; faithful loop styles. Moreover, I'm talking about the real ES6 `for...of` loop, not some emitted ES5 transpiled code! BtW, I use &amp; love TypeScript. And am very aware that its ES5 transpiled code never emits `for...of`. :P 
Well its en entirely different technology. Its a different protocol and is mostly used for peer to peer. It allows for data, audio and video to be transmitted as well as super low latency. 
&gt; That's certainly a stretch. Not in my experience, it is not. Most Angular 1 apps I have encountered are legacy apps. Nobody is going to go back and rewrite a legacy application using the latest framework unless they have too or asked too. I don't see or hear of many developers recommending that you start an application in 2016 using Angular 1.Maybe in your circles things are different, but in mine, everyone has moved on from Angular, mostly to React. &gt; A1 is stable and constantly improving with enormous ecosystem Most of those improvements I've seen seem to be for the sole purpose of making it easier to migrate to Angular 2, with exception of improvements around binding related aspects of the framework. The stability does not make up for the ridiculous abstraction and complication. &gt; whereas the other ones are still young and immature. There is simply no comparison. React might be young, but it is quite mature. React is not a framework, it is a library that gets used as a framework and honestly, it does a great job. It doesn't take an overly mature or stable framework to beat Angular 1 which suffers from more performance problems than Lance Armstrong. &gt; Speaking of Aurelia, their starter kit is still using Grunt, no joke! I am currently building an Aurelia application and there is no Grunt in the starter kit, evident by [the gulpfile](https://github.com/aurelia/skeleton-navigation/blob/master/skeleton-es2016/gulpfile.js) in the root of the repository, they are using Gulp just like every other project. And honestly, even if they were using Grunt, what does it matter? Grunt is still great.
You're right about the boilerplate - that didn't sit right with me either. I created a new library which doesn't require any metadata definitions: https://github.com/justmoon/reduct Feedback is highly appreciated!
I get it, just don't like that const is being used for loop keys in the case of a for/each loop... Defies the meaning of constant to me, so I would (personally) always use let or var...
browsers with standard mice show a scroll bar. 
&gt; Iterators are objects w/ methods calls. Again, none of that iterator stuff has to remain, because none of it affects the observable behavior. You've heard of things like function inlining, right? Compilers are free to do whatever they want for as long as the observable behavior doesn't change. They can inline functions, move things outside loops, unroll loops, and stuff like that. JS VMs can do the same kind of optimization as the Dart VM does. They could also simply add a special case for for-loops with arrays. &gt; No way they're faster than a simple direct numerical index access. "Not slower" doesn't mean faster.
Gotcha. Yeah I actually have an MPC1000, and I wrote [this synth](https://www.resistorsings.com/106/) (which has a 24db/oct filter, like the original) although I haven't updated it in quite awhile.
Basically the data doesn't pass through the server, only between clients.
This has been discussed hundreds of times. The web, at this point can't compete with native apps. You can't force the square peg in the round hole. All of the tools and tricks that are used to make the web try look and feel like a native app are awful and just end up piling garbage on top of garbage. The web is best suited to work along side native apps, not replace them. The sooner JS developers realize they aren't mobile app developers, the better off users will be. 
Do name that closure, comes in handy when errors hit the fan.
Here you go: https://tonicdev.com/tolmasky/56a026577cbc550d0064a2e5 ...,
It's behavior reminds me of what a tornado looks like. Perhaps a top-level-view of a tornado.
Is this for the Win32 office or the UWP office? 
Thanks for following-up!
Don't use var. **Edit:** Do I really have to add "instead of const"? The context is obviously ES6. Do not use var in ES6 code.
Definitely made me want to try Cycle.js.
You do understand this isn't simply an embedded webview like other mobile JS app frameworks? The result is real, native UI widgets. It's like programming in pure ObjC or Swift without xibs. But there is no new language to learn, so you can leverage much of your existing engineering resources with less training time. 
Something mentioned in the article might be inaccurate but then again I might be wrong. The author states &gt; ...and every single thing you await must be a promise. In my experience this isn't true using async/await via Babel. For example I am working on a validation utility (something that gets unnecessarily repeated ad nausium but nothing pre-built fits my scenario!) where some validation routines are synchronous and others are not. I return the result as a primitive, an object or a promise, it makes no difference, the awaiting function resolves the value. Is this an unintended side effect of using Babel or does this conform to the spec?
Very well done. I love it.
Trust me, I hear you... but this is a shipped product, and people care about installer download sizes.. and ultimately disk space required. It's a borderline obsession for some people, but I'd rather have their money than change their opinions. :-D
I only quickly scanned through this, but this stood out to me: &gt; Neither of these two are unreadable (as long as you know the language), yet JSX is more verbose. `&lt;` and `&gt;` add no value, they are noise, among other quirks like `{` `}` blocks. I don't think the brackets are good or bad, but this statement is false. Like any language, they are part of the syntax and denote important tokens. I understand that this post is about the signal-to-noise ratio in your code. Keeping that in mind, neither approach is better than the other. If signal-to-noise was the only thing that mattered here, Elm or Cycle.js would take advantage of a syntax that did not require these tokens. For example, in F#, the "JavaScript way" would change from (noting that `(` and `)` are "noise," to make a fair comparison): ul('#bestest-menu', items.map( item =&gt; li('.item', attrs(item.id), item.title)) ); to List.map (fun item -&gt; li ".item" (attrs item.id) item.title) items |&gt; ul '#bestest-menu' The "noise" can be reduced further: let mapItems item = li ".item" (attrs item.id) item.title List.map mapItems items |&gt; ul '#bestest-menu' Or, if you prefer not to use the pipe-forward operator: let mapItems item = li ".item" (attrs item.id) item.title ul '#bestest-menu' (List.map mapItems items)
Outlook add-ins are supported on Outlook 2013 and later for PC, Outlook 2016 for Mac, OWA, and Outlook on Devices (which I *believe* would include UWP Outlook, if that is a thing). [Source](https://msdn.microsoft.com/en-us/library/office/jj220082.aspx#StartBuildingApps_SupportedApplications).
I don't think /u/avery51 was to say completely against your opinion. Mobile webs that imitate native UIs are indeed having a bad time competing with snappiness &amp; responsiveness not to mention native API limitations.
It takes a lot for me to say "whoa! That's fuckin cool!" out loud. Nice job!
Can't you still sense changes to a DOM? Like yeah there seem to be a few minor issues around full integration testing, but can't you create a DOM tree as a fixture? (Edit: I write node.js rather than browser code typically)
Tell us more about what you're trying to do, and where you are seeing the issue: the question doesn't make much sense at the moment. There are no limits on the size of a JavaScript file - certainly not 24.13kb. Here's a [stupid jsbin snippet](http://jsbin.com/jigujamafe/edit?html,js,output) I whipped up with 1000 case statements, 60kb in a file... it's not even going to make IE6 blink an eye, let alone any modern browsers. I guess you're not talking about browsers though? What are you making a mod for? The JavaScript language doesn't have a concept of a "mod" - is it for a third-party game, or application? What environment are you talking about? Are you editing the text in a text editor like Atom or Sublime text, or is part of the game/app? Where is the code running? 
I'm working with Mocha and am stuck. I have no idea of how to associate my test files with the source files I'd like to test. Also, when I attempt to run my tests via Karma (and not directly from the command line using the "mocha" command), I get a separate error that reads: Chrome 47.0.2526 (Mac OS X 10.11.2) ERROR Uncaught Error: Module name "assert" has not been loaded yet for context: _. Use require([]) http://requirejs.org/docs/errors.html#notloaded at /Users/UserName/.nvm/versions/node/v5.0.0/lib/node_modules/requirejs/require.js:140 I've been battling with this error for three hours. I've no clue how to fix it.
I'm working with Mocha and am stuck. I have no idea of how to associate my test files with the source files I'd like to test. Also, when I attempt to run my tests via Karma (and not directly from the command line using the "mocha" command), I get a separate error that reads: Chrome 47.0.2526 (Mac OS X 10.11.2) ERROR Uncaught Error: Module name "assert" has not been loaded yet for context: _. Use require([]) http://requirejs.org/docs/errors.html#notloaded at /Users/UserName/.nvm/versions/node/v5.0.0/lib/node_modules/requirejs/require.js:140 I've been battling with this error for three hours. I've no clue how to fix it.
I found this post to be a little overly critical, but [this post about unidirectional UI architectures](http://staltz.com/unidirectional-user-interface-architectures.html) is gold. Those diagrams are very clear.
Would you ever do a YouTube articulating your process? 
This blew my god damned mind.
Because that statement is totally indicative of their recent external changes and product releases. Get out from under your rock.
What's a strong alternative to the React + Redux architecture that allows me to not have to mess with traditional html templates and lends itself well to immutable data and a very clear flow of state? I'm new to it but React + Redux has been pretty enjoyable to make a SPA with. But the one thing I really don't enjoy is all the boilerplate. A pretty simple application can end up with a lot of actions and a ton of cascading props further and further downward.
[Mocha](https://mochajs.org/) as your testing framework (runs the tests, provides the suite tools (`describe`, `it`, etc). [Chai](http://chaijs.com/) as your assertion library (`expect`, `should`, etc) [Sinon](http://sinonjs.org/) as your mock/spy/stub library [Chai as promised](https://github.com/domenic/chai-as-promised/) for promise assertion support
Check out Blessed and Drawille: https://github.com/chjj/blessed -- https://github.com/madbence/node-drawille 
Can you provide a set of frameworks for building a CRUD based ERP system. Both frontend and backend. Thanks!
Amazing - thanks!
Almost got a wave pattern: http://codepen.io/anon/pen/adEyLe
React is different from other solutions to this problem, in that it generates native components, and does not run in a webview. I tried react for an android project a few months ago. Unfortunately, I was designing a form and wanted a drop down select box, but it didn't exist, and so I went with ionic. React has a long, long way to go, but the workflow is undoubtedly superior to native app development in every way. 
http://caniuse.com/
&gt; Neither of these two are unreadable (as long as you know the language), yet JSX is more verbose. &lt; and &gt; add no value, they are noise, among other quirks like { } blocks. &lt; and &gt; help amateurs like me transition from HTML. I am pretty sure that was by design.
You can see on https://code-cartoons.com/a-cartoon-intro-to-redux-3afb775501a6
This doesn't offer what are two of the primary advantages of pattern matching in functional languages: static typing against your match rules, and "exhaustiveness checking," which is described (for Rust) [here](https://doc.rust-lang.org/book/match.html). For this specific library, use a switch statement instead. It will work exactly the same (except for a bug in the `match` implementation), and JavaScript let's you check against any initial value. Better yet, a switch statement will perform much better. https://jsfiddle.net/ognupLrs/1/
callbacks are fine for this. The key is a single piece of logic waiting on multiple independent paralell requests to complete. 
Isn't the trick using 'use strict'? Part of the issue is that the const keyword existed in firefox long before es6, and meant something different.
I'm guessing this is a code challenge by a potential employer? I see two ways of going about this. Lets start with option 1: var Word = function(word, cellIndexes) { this.word = word; this.letters = this.init(word, cellIndexes); this.discovered = false; } Word.prototype.init = function(word, cellIndexes) { return word.map(function(letter, index) { return { letter: letter, cellIndex: cellIndexes[index], discovered: false }; }); } // var word1 = new Word('hello', [3, 4, 5, 6, 7]); Each word and letter explicitly has their cell index defined. Option 2 would involve some logic to automatically determine the cell index of each letter with just one cell index given. I'm at a hotel with a hot tub and an ocean front view of the pacific coast, so I'll have to pass on writing that. Good luck! P.S. Anyone hiring on the West Coast? California is beautiful.
I think you will be hard-pressed to beat native branching speeds. Your implementation not only has its own branches, but a couple of regexs, method calls, casting, and data normalizing. If you manage, I would certainly enjoy seeing your work, and I think more than a few JavaScript engine developers would be interested as well.
No advantage, just started messing around with rust and I really liked the syntax so I tried to copy it. 
If you scroll it to the end, it becomes the toilet paper view :D (awesome work)
I think you're looking for push, pop, shift, and unshift var listOne = ['herp','derp','merp']; var listTwo = []; listTwo.push(listOne.pop()); // listOne -&gt; ['herp', 'derp']; // listTwo -&gt; ['merp'] listTwo.unshift(listOne.shift()); // listTwo -&gt; [ 'herp', 'merp' ] // listOne -&gt; ['derp'] check out the docs for [array on mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) to learn more.
Even awesomer, there's a [cli](https://github.com/sgentle/caniuse-cmd) » npm install -g caniuse-cmd » caniuse history Session history management ✔ 81.43% ◒ 8.33% [WHATWG Living Standard] Method of manipulating the user's browser's session history in JavaScript using `history.pushState`, `history.replaceState` and the `popstate` event. #HTML5 IE ✘ 5.5+ ✔ 10+ Edge ✔ Firefox ✘ 2+ ✔ 4+ Chrome ✘ 4+ ✔ 5+ Safari ✘ 3.1+ ◒ 5+ ✔ 6+ Opera ✘ 9+ ✔ 11.5+ ⓘ Older iOS versions and Android 4.0.4 claim support, but implementation is too buggy to be useful. 
Jasmine’s API is bigger. You’d have to bring in another helper to do [spies](http://jasmine.github.io/edge/introduction.html#section-Spies) or [the clock](http://jasmine.github.io/edge/introduction.html#section-Jasmine_Clock) with tape. Try both on small projects and see what you like. ¯\\\_(ツ)_/¯
Strings and numbers are not objects.
I think GraphQL makes a lot of sense if you have a big team and a lot of data that is being accessed in pretty uniform ways that the team responsible for data access can optimise a lot even though they aren't very familiar with the end use case. That said, at Spotify, we've had things improve a HOGTON when we moved from our prior generic data access API model to view-specific endpoints on app-specific backend services, inspired by Netflix (http://techblog.netflix.com/2012/07/embracing-differences-inside-netflix.html). The team owns the backend service and views of their features, and it works really well compared to the data model being centrally structured. 
The one thing that particularly caught my eye about this is the comparison between Elm and Redux. I think the article pretty much hit the nail on the head when saying Redux adds noise. Elm, a language designed for those features, is naturally more concise for expressing them. Trying to take those features and smash them into a language not designed for them is definitely going to add noise. This same problem is very evident with libraries like Ramda. Expressing much of what Ramda does in a language like Haskell is fine, but with JS, it becomes very noisy from all the utilities you need to make it work.
I´ve found this library called SearchKit for react that it´s almost 100% that i need https://github.com/searchkit/searchkit https://github.com/searchkit/searchkit/raw/master/docs/assets/codepreview.png My only problem is that it uses ElasticSearch as the data store so i should need to replace that to something else. i´ll try to look if there is another option 
Just putting a few other alternatives out there: 1. https://github.com/natefaubion/matches.js 2. https://github.com/natefaubion/sparkler 3. https://github.com/puffnfresh/daggy via catamorphisms 4. https://github.com/SimonRichardson/squishy-pants/blob/master/src/match.js I've just hit the tip of the iceberg! Seems like this is a very well trodden route.
&gt; If you were making the UI for a medieval/fantasy game Please yes.
Same here. I have Cycle and Inferno on my list of libraries to checkout this weekend. I might also give Elm a chance too – as much is said about it.
You shouldn't need to pass props down if you're using a Redux store. I personally use Vue and Vuex over React and Redux but I think the concepts would be similar. All my application's state lives in a single store, and each component has computed getters that simply returns a state object from the store. Not saying there aren't instances where it makes sense to pass props down to something, but you shouldn't need to be doing it heavily. 
I read the one on Flux too. She has a nice writing style and this is a quick, easy way to pick up the main points of popular new libraries and tools. I hope she does more and does her book she mentions because it could really help people who are starting out or catching up again. 
Every single WebRTC has one issue, not a single one helps to configure TURN and STUN servers, without it 90% of the WebRTC apps do not work.
What's your opinion on vue + vuex over react + redux? I've been looking at vue recently and I'm interested. I particularly like how everything, including scoped css, can live in a single file. But I'm not sure if it's worth taking the time to learn when I already know react + redux. Would you say it's worth the time investment?
The code that you suggest would be a better match to Rust's implementation isn't possible. The `message =&gt; console.log('the value is hi')` is an inline function with one parameter, message. `"hello" =&gt; console.log('the value is hi'),` creates a parse error since it doesn't make any sense in JavaScript. 
Each page we load displays 30 charts, each chart with 250 - 300 data points. The minimum number of 30 charts is specified in the design requirements. Each chart looks something similar to [this](http://www.actiprosoftware.com/content/images/products/controls-wpf-charts/LineChartType.png) The reason I mention the infinite scroll functionality is to enforce the point that results are not paginated in a way that I can destroy the 30 charts when I change the page. Instead, 30 more charts are injected onto the page and I now have 60 charts on the page and all their associated data points. Also, the reason I mention I am not in control of the design requirements / acceptance criteria is that the design specification says that all these charts must be displayed at the same time. If I was in control of the design requirements I would probably be only showing one chart at a time and performance wouldn't be an issue.
Various methodologies depend on your framework, which one are you using?
[GIFV link](https://i.imgur.com/WAwfLcR.gifv)
You can do it either way with this, as I'm sure you saw in the readme. 
&gt; Vuex You should have a look at RiotJs, its a view side framework as well. pure html/js/css Its super sexy and simple with very minimal API and is un-opinionated as per architecture. so flux, reflux, redux, you name it. I did go back to react after using Riotjs for a project that would use Native but i decided not to after a little while i could not look at ReactComponents anymore. Its not mostly me, i work with people, i show people a RiotJs component, everyone know what it look likes seeing the code... Not so much with Reacts 
Now here's the really cool part about D3, even though you can use it to generate SVG it's perfectly doable to use it for calculations and use it to render a scene on canvas or even WebGL. Also, are you plotting each datapoint individually? Animating anything more than around 600 nodes in D3 will become somewhat slow, but as long as you are rendering relatively simple charts that don't continuously update it doesn't really matter.
True callbacks are fine, but I've found that when I'm writing code that chains multiple callbacks, it becomes unreadable really fast. Using promise chains makes code way more readable. Besides that I agree with you that parallel requests is definitely a great reason to use promises.
tl/dr: Emulating React via Angular2 is possible, but requires serious effort ;)
Thanks! Definitely one of the more interesting projects I've worked on, lot's of fun to build too.
COOL!
I just starting looking at vue.js yesterday, so I'll keep going on that. What are the chances of finding vue.js example code that does something similar to what I want to do?
It would be super sweet. ;) monetize it maybe make a few bucks too. Also live coding.tv
If you are not sure about frameworks, go to the TodoMVC site and check the code. None of them is perfect, unfortunately :(
Yes, I can surely rewrite Ember to fit all my requirements. :-) There are just easier ways around to reach the same goal. Having said that, kudos to Ember for such an awesome tool!
I'll give it a try. Thanks!
&gt; co(function* () { &gt; var result = yield login(username, password); &gt; var posts = yield getPosts(result.token); &gt; return posts; &gt; }).then(value =&gt; { &gt; console.log(value); &gt; }, err =&gt; { &gt; console.error(err); &gt; }); please dont abuse generators
Sweet. I hope your project goes over well. Did you take a look at the stackoverflow link posted above? That approach looks solid. Are you able to transform that approach in to code?
Now that Angular2 is in beta, IMHO the most important part is for the dependency set to gel, and not be so fluid. There should be a good solid well-documented method for creating an Angular2 app, rather than "try this," or "try that." A close #2: they should make it less difficult to include non-typescript NPM modules in runtime dependencies. 
Ok, yeah it sounded like you might be partways down a path already. As far as building dynamic filters, here's a quick [jsFiddle](https://jsfiddle.net/lexicalnoscope/p8jfomf2/) for doing that with map and filter. The example has 1000 entries in a randomly generated JSON array. Click on Get Data and enter one of the property names, and it'll generate a deduped list of all available values for that property. If you throw something like that into the endpoint of your data observable, you should be able to use it to build your dynamic filters pretty rapidly on the fly. If I get more time I'm interested to do a performance test with that vs a straight while loop. If you're culling from multiple fields at once, it might make sense to pull them all at once in the same loop.
Just start with one and go through it. Then do the other one. You will not be less knowledgeable as a result. I would also recommend finding someone(s) to review your work and offer feedback. 
I think I fixed a few of the problems with using it outside of babel. 
Mmm. Redux, RxJS, Angular two? Nope. Also, this guy has two first names. What an asshole. 
Angular2 uses RxJS pretty heavily, they are meant to go together. Redux not so much.
because the implementation is nicer that way. I wish it could work with multiple words but it can't that way. There are plenty of cases where you are checking single words
Added exhaustive checking: https://github.com/zackify/match#exhaustive-checking
Given that javascript is solidly pinned to be single-threaded. How would you have changed the aync/await spec ? I guess my point is thus. It would be awesome if javascript could grow out of it's current single-thread box. And a solid async/await abstraction could be one piece of that puzzle. BUt given the lack of programmer training and language abstractions to support the rest of the puzzle, it's not clear to me what the value of a more fully abstracted async/await puzzle might be. Languages have roots which constraint how they can grow. Oh how java would love to ditch the primitive datatypes. Python might wish that they didn't have the GIL. Aside from the spaghetti that arises from the async model originally choosen, I'm sure javascript would love to clean up the chaos that are the comparison operators. So I guess I'm just not sure where the async/await would have gone that was more cleanly abstracted. I'm not argueing against the notion. It would be nice. 
While I believe OOP isn't exactly how you should structure an entire application, I've found it to be very helpful with code reuse when developing a component based architecture 
Reactjs's core component architecture already is object oriented, specifically, it is a state machine.
It's possible, but he'd have to adjust what's fed into the match() method. match(message, { "hello" : () =&gt; console.log(`"hello" === "${message}": ${"hello" === message}`), 23 : () =&gt; console.log(`23 === ${message}: ${23 === message}`), _ : () =&gt; console.log(`No idea what your message is: ${message}`) });
Don't worry about building things that "look visually appealing". Focus on building useful, functional interfaces that are fast, maintainable and reliable. Less is often more when you build applications, you just need to spend some time learning what works and what doesn't. Try to find the best patterns to present the data your end user cares about. Aesthetically pleasing designs and fancy animations are useless if the functionality of your application sucks. Make that your top priority, and you'll learn over time how to make things look better. If you can try and make friends with designers, subscribe to design blogs and newsletters, listen to podcasts and watch talks on YouTube. In regards to tooling, I think Sass/LESS are useful, but they'll give you massive problems if you don't understand how to write good CSS. Take a look at CSS Wizardry and/or give the book SMACSS a read, it'll help you organise your CSS - and make things easier for yourself in the future. Sass is great, I don't tend to use a lot of its functionality as I like to write my CSS as vanilla as possible. I can't comment too much on JavaScript modules, I tend to use Babel with Gulp in the majority of my projects. Works for me and I haven't found a reason to switch yet.
Cool. :) I see that the fall-through to `_` has been resolved. Is the exhaustiveness checking not present in 0.1.7? https://jsfiddle.net/ognupLrs/3/
Thanks for the invite! Definitely going to check out the group. Did you use any books to supplement your learning at FCC?
Thanks - definitely going to look at the sub!
Yep! Nope, between Codecademy, Sololearn, reddit, and my own experimenting/practice first and during... FCC has been a breeze. At least the front end part, which I've nearly finished. I do think it's good though! Especially the algorithm scripting challenges and portfolio projects. They algo scripting challenged and reinforced my "programatic thinking" skills, and the portfolio/projects make it easy to come up with little projects.. just giving the idea and parameters for them.
Done.
I'd be happy with await* +1. Having a thenable means you're constructing a function ( read "callback") again, which is the whole reason to do async/await in the first place ( fewer functions created ). So yeah, doing the Promise.all() route means you've semi-defeated the purpose of not creating all those functions. But hey, if there are functions, then we can all call it a functional language right ? 
Try adding this to your config: plugins: [ require('karma-mocha'), require('karma-chai') ] Obviously you will need to install these dependencies with npm install but that should do the trick. In your test file you can then just call describe, it, assert, etc as if they were globals.
yes it is, if you remove the goodbye function it will throw an error. I'm confused what you think is missing?
Nice! I always end up doing `mdn &lt;whatever&gt;` into the omnisearch anyways, so that's cool
lol, yep http://jsperf.com/match-vs-switch/11
Is there a reason why you don't want to search for the malformed quotes and replace them? Maybe it's the messed up formatting on trying to search for / in regex
you should check out [ngrx](https://github.com/ngrx/store), if you wanted to use flux with angular2 this is the ticket
Couple things from what I can tell: One, your IIFE function (ObjectOrArray), you need to pass in the collection to invoke it with like so: (function ObjectOrArray( collection ){ if ( {}.toString.call( collection ) === "[object Array]" ){ dataStructure += 1; } else if ( {}.toString.call( collection ) === "[object Object]" ){ dataStructure += 2; } })(collection); As it is now, the dataStructure var isn't being set. Once that is fixed, the map function provided won't work. The `callback(collection[item])` is going to try to get an index in the collection, it should be just `callback(item)` Here's an updated fiddle based on what you had: [fiddle](https://jsfiddle.net/1u7vge5a/2/)
If you don't want to use new every time, then take it off the prototype and it can be accessed statically. Player.prototype.CalcCountDown becomes Player.CalcCountDown In the using code you can do Player.CalcCountDown();
Yes, as a parameter. 
If you like vue but want to stick to React, you definitely should try mobservable. The computation model (transparent reactive programming) is quite similar.
I think we have a front runner for best post title of the year.
If you var x = '{\"startTime\":\"2016-02-20T09:45:00.000Z\",\"endTime\":\"2016-02-20T10:00:00.000Z\"}"}";' - but in single quotes, the backslashes get treated as escape characters so it should auto store the string without backslashes. Otherwise this will remove the last 2 characters in the string, and then look for and replace all '\' characters with "": var result = x.slice(0,x.length-2).replace(/\\\\/g,"")
I've actually managed to get the tests running--but only for simple, standalone tests (like the example above) that aren't connected to my front-end code. Do you know how I'm supposed to go about associating my tests with my front-end JavaScript without using Require?
If your database accepts DML (all SQL databases, and Couchbase with its N1QL), you could do update table set json = replace(json, '\"', '"') And boom, your whole database is fixed. It seems you have to look at your database documentation to see what commands are available and how to use them. Maybe make a dump of the database, upload to a second copy and run some tests to fix the issue directly in the database.
We didn't really have churn back then. We had a whole bunch of competing DOM manipulation libraries and jQuery was the one which eventually emerged as the winner. No one felt compelled to jump from one library to a new one other every 6 months. Mind you these libraries did mostly the same thing and we didn't have huge JS code bases back then. 
The observe function works by defining property getter and setter that trigger a callback on every change of the observed property.
Your `clickedFileSave()` function's definition calls `this.getGame()`, but `this.getGame()` doesn't exist. Beyond that, we'll need to see the actual (full, not just partial) code you're working with to help more - and you might benefit more from posting in /r/learnjavascript .
3 years ago, large projects were done with Angular and smaller jobs were jQuery. Now we do smaller jobs with jQuery and large projects with Angular.
Author of the Hackathon Starter project here. This looks great! I am currently working on something even bigger in scope than hackathon starter -- completely customizable web-based boilerplate generator. I am pretty sure reactathon will come in handy when I get to the React ecosystem (React, React-Router, Redux, Relay, GraphQL, Babel, Alt.js). Meanwhile, here is a preview of what's to come: [Imgur](http://i.imgur.com/0gxuVwt.png) P.S. This plugin just may convince you to switch from Gulp to Webpack: https://github.com/gaearon/babel-plugin-react-transform It's awesome and works with server-side rendering enabled without any issues. I have tried many different hot reloading solutions with Gulp, including browser-sync, but never quite as good as babel-plugin-react-transform.
/u/Benny_jr has the right answer, but you probably want to consider what you're doing. If you're dealing with an instance of a class and you're calling functions that do work on that class, you might want to just add them as methods onto the class instead, like your existing CalcCountDown and FireAwayCountDown methods. If they really don't belong in the class, then pass an instance of the class in instead. One of the big benefits of this approach is that if you decide to write tests for your code (and you _should_ do this), it's much easier to test when you're passing something in than when it just appears from nowhere. If you just make the Player in your function, your test needs Player to exist. You're either unable to break your code into real, independent units for testing, or you're forced to mock a lot. If you're passing it in, you just pass in something else instead when you're testing--a fake version of Player that just returns what you expect, so you're just testing your function, and not also sort of testing Player in the process.
Exactly. If you're not sure when the duplicate `"}"}` will occur either, you can also do a replace for that instead, replacing doubled `"}"}` with single `"}` `var result = currentDate.replace(/"}"}/,'"}');`
Karma is widely used **IF** you need to run code in a browser. If at all possible, you should avoid doing so, especially for your unit tests. It's slow, requires some ugly build steps, and as you're finding out, it's a nightmare to configure, because you'll end up needing to process your code with webpack/browserify in order to even test it, which makes it even slower + breaks source maps and code coverage reports. I'm working on a React based project, and we're currently using mocha, expect (which includes basic mocks, so we don't need sinon), and jsdom; it's fast and easy. Plus, because it runs in node, we don't actually need to use webpack/browserify to run our tests, just babel. Testing in JS is a hard problem, but a good architecture can make your life a lot easier; the higher % of your code which are pure functions that can be `require`d and tested in a node environment the better, while any code which relies on a "full" browser environment and DOM manipulation, the worse things will go. I worked on a project a while back which used Knockout and tons of jQuery, and wouldn't even *run* in jsdom. Trying to write tests for it was not fun.
At that point you might as well just make a Rust-to-JS compiler. ;)
Rewrite the function so it's not anonymous and make it take an argument that lets you specify what sound to play. 
Cody, thanks again for responding. I feel like you're the person with whom I need to be communicating about this, because you're further down the line than myself toward what I plan to accomplish, which is to build a full-stack application using the following setup: * Node/Express * React * Babel * Postgresql. I'm confident there are some major pieces of the stack that I'm missing here, but this is all I can foresee at the moment. Plus, I don't want to jump ahead into anything too advanced without understanding some of the more basic, composite parts of the stack. I will stick with Mocha as my test framework, as it seems to generally be regarded as superior to Jasmine. (I don't mean to incite a debate with anyone who thinks otherwise; this is simply what I'm seeing in blogs and various forums. I actually started with Jasmine before I encountered the same issue that I'm dealing with now and decided that giving Mocha a shot my save me some headache. Wrong!) If I'm testing my front-end code, is there any way to do so *without* a tool like Karma? I mean, Mocha seems to only be capable of running my tests in isolation. What I mean by this is that it doesn't seem to be capable of applying my tests to my actual source code. I've as yet only been capable of testing for trivial, isolated conditions which essentially amount to "1===1". But this evaluation is in no way related to any of my actual code, nor do I see a way to associate tests with my actual code. Jasmine, Mocha, etc.--the documentation for these tools doesn't even show how to run tests on your code, only on simple examples like the one above.
Well ... I am interested in lexical analysis and parsing, and I haven't really had a chance to study abstract syntax trees, so I might be, to be honest. If you kick off a project, I'll try to contribute; I know if I start it, I won't stick to it, and I have other obligations that make finding the time to lead a project difficult.
Using path directly instead of using a router is definitely possible. Here is an example of a route that uses the request path directly: https://github.com/componentjs/boilerplate-koa/blob/master/server/routes/index.js
&gt; If I'm testing my front-end code, is there any way to do so without a tool like Karma? I mean, Mocha seems to only be capable of running my tests in isolation. I'm not 100% following what you mean. Unit tests are intended to run your code in isolation. My package.json file includes a 'test' command in the 'scripts' block that reads `_mocha --compilers js:babel-core/register './src/**/*.spec.js'`, which basically means "run every single test in the src tree, but pass it through babel first". Then mocha is configured (via a line saying `--require ./test/mocha_helper.js` in my 'mocha.opts' file) to import a helper that looks like this: import jsdom from 'jsdom'; import expect from 'expect'; import TestUtils from 'react-addons-test-utils'; const doc = jsdom.jsdom('&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;'); const win = doc.defaultView; global.document = doc; global.window = win; global.BASE_URL = 'http://api.com'; global.expect = expect; process.env.NODE_ENV = 'test'; global.render = component =&gt; { const renderer = TestUtils.createRenderer(); renderer.render(component); const output = renderer.getRenderOutput(); return {output, renderer}; }; // from mocha-jsdom https://github.com/rstacruz/mocha- jsdom/blob/master/index.js#L80 Object.keys(window).forEach((key) =&gt; { if (!(key in global)) { global[key] = window[key]; } }); Which basically just sets up some globals and initialises my jsdom so it works with react (some react functions assume a dom and will fail otherwise). And then one of my front end tests might be as simple as: import React from 'react'; import {shallow} from 'enzyme'; import Dash from '../Dash'; import FooWidget from '../widgets/FooWidget'; describe('Dash', () =&gt; { it('should render a FooWidget', () =&gt; { const props = {metrics: {current: {}}}; const wrapper = shallow(&lt;Dash {...props} /&gt;); expect(wrapper.find(FooWidget).length).toEqual(1); }); }); Enzyme isn't needed here but it's a nice helper. Anyhow, what this does is grab one of our React components, does a shallow render (as described in the React docs), and then confirms that when it's rendered it will render a single `FooWidget`. Obviously, a complicated component might have a TON more tests as we try out different situations; if it's passed a loading flag does it render a loading spinner; if we pass a table that paginates data 100 rows does it properly render the first 20 and then display the pagination widget, if you change the page size to 40 does it properly reduce the number of pages from 5 to 3, if one of the rows has the 'doSomethingSpecial' flag set does the component properly hide the third column, if you click on the submit button does the form properly trigger it's onSubmit callback, whatever. But notice that this is running 100% in isolation in node; we're not using webpack or browserify, nor is the code running in a browser. And we have an associated foo.spec.js file for every single component, container, helper script, redux reducer, etc. we have on the front end. We recently had a bug where some code was meant to hide a column in a certain condition, and was accidentally hiding *all* columns instead. So we added a couple of test cases to the associated unit test that passed in props that triggered and did not trigger that condition, counted the number of columns being redered, checked that it matched expectations, got a failing test, fixed the bug, got a passing test, boom, done. Standard stuff, but it's really nice when it's working. Now, it's also helpful to have integration tests that pull together your entire app (probably using webpack) and runs *that* in your browser, doing "full" tests like "if I load the page and click the load more button does it actually do what I expect", and Karma is one way of doing it. But unit tests are different; that's where you want to test code quickly and in isolation, with dependencies mocked out as much as possible. Integration tests are slow by their nature, and when you're having to do a full webpack build and then get karma to load that in a browser, that goes double. We don't even have integration tests (although we should) but they're generally something extra you do to make sure your unit tests are correctly verifying program functionality; they're not a replacement for unit tests. Each module/class/component/whatever should have a unit test, ideally. Does that make sense? If not, feel free to post some example code or link me to a gist or something and I might be able to clarify more. :)
You're right, Sass came first. I had thought Bootstrap might have pushed Less into the lead for a time, but [Google trends seems to imply that Sass has always dominated](https://www.google.ca/trends/explore#q=%2Fm%2F0gjd0jv%2C%20%2Fm%2F054k6n_&amp;cmpt=q&amp;tz=Etc%2FGMT%2B7). At this point switching to Less to avoid Ruby would be ridiculous. LibSass, phpSass, and JSass removed the dependancy on Ruby years ago.
 &lt;li *ngFor="#todo of todos$ | async"&gt;{{ todo }}&lt;/li&gt; I really try to like Angular 2 but then I read something like this and I'm disgusted. Every other article I give it another chance but the syntax is just too off putting. You can't tell me the engineers at Google couldn't come up with a better solution. I'm sure there's a nice framework underneath it but they really dropped the ball with the html side of things. JS looks ok, the bootstrap process is ugly as hell but I'm optimistic that v1 ships with a clean solution.
I agree with you because I am framework agnostic for development preferences (at the moment), but at the same time a small part of me wonders 'what's wrong with having one more complicated framework?' I say that because my first app I stepped into professionally was a backbone app, and that was incredibly difficult for me. But the next one I worked on was knockout, and it was pretty simplistic. Should we expect or require all frameworks to have a low learning curve, regardless of functionality / power? Just a thought :)
Actually, with this approach you'll usually end up landing on a search results page on MDN. This brings you directly to the page for the top search result for your query. Similar to Google's "I'm Feeling Lucky" feature. I actually built a chrome extension once for doing exactly this with MDN by leveraging I'm Feeling Lucky: https://chrome.google.com/webstore/detail/mdnjump/mfjekjhknpjgpgchoghlemhgchpmkiha?hl=en
thx
what is the difference between this and node-inspector ?
I think these video's are great: https://www.youtube.com/channel/UCVTlvUkGslCV_h-nSAId8Sw 
&gt; "It's just sugar!" They keep claiming that...except the sugar isn't supposed to be hard to understand than the non-sugar version. What the fuck are they smoking over there? That syntax means literally nothing to people who haven't used angular 2 before. Shit, it means nothing to me and I'm incredibly skilled in Angular 1. That's a huge fucking problem.
haha thank you. just wait till part 2!
&gt;I'm using alien blue and I noticed it does not work well in the in-app browser, use safari if you want to have a look If you load it in standard mode, it displays just as it would in safari. Just a heads up. 
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 2447 times, representing 2.5308% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cz781xv)
Async 2: Electric Boogaloo
Angular v2 v1
As surprising as it seems, due to sheer lack of interest on the field, this humble JS file is one of the very few available **optimal** implementation of functions on Earth. Even functional languages such as Haskell implement them sub-optimally and, thus, there are [some functions](http://stackoverflow.com/questions/31707614/why-are-%CE%BB-calculus-optimal-evaluators-able-to-compute-big-modular-exponentiation) on which that implementation beats Haskell by several orders of magnitude. Of course, that is only really noticeable in functions much more complex than you'd use on your daily life, so its usefulness is dubious. Nether less, of the few other implementations available, this is the most efficient in terms of applications, although it is somewhat restricted as it only accepts EAL-typeable functions (a subset which includes most functions you'd ever use in practice, but not powerful enough to, say, emulate a non-terminating turing machine). I'm posting merely because I find it curious, and for raising some awareness about this sexy, cool algorithm :)
Or use DuckDuckGo's !bang syntax: [!mdn Array.prototype.some](http://duckduckgo.com/?q=!mdn array.prototype.some). Edited to add: This is the weirdest down-vote barrage I've experienced.
Still supporting a Prototype.js app. Starting to port it now, probably to [Bliss](http://blissfuljs.com/). Somehow it was able to miss the jQuery Age.
A lot of this is developer [navel-gazing](http://www.urbandictionary.com/define.php?term=navel-gazing). Think about the trouble this makes outside of the developer circles: A business owner sitting on an angular 1 app, having (from his perspective) this group of devs telling him he needs to use React, another group of devs telling him he needs to move to Angular 2, and another telling him they need to just jeep working with this codebase as it is. And all he really knows is this is costing him a ton with no end in sight. At some point the people in charge of the money are going to start wondering if the web developers are iterating frameworks just to stay employed! 
*Here's the Urban Dictionary definition of* [***navel-gazing***](http://www.urbandictionary.com/define.php?term=navel-gazing) : --- &gt;Engaging in self-absorbed behavior, often to the point of being narcissistic. --- _If she would stop navel-gazing, she would realize the light had turned green._ --- [^(about)](http://www.reddit.com/r/autourbanbot/wiki/index) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autourbanbot&amp;subject=bot%20glitch&amp;message=%0Acontext:https://www.reddit.com/r/javascript/comments/42165j/what_is_the_javascript_churn_effect_on_your/cz7a7b9) ^| ^(**Summon**: urbanbot, what is something?)
Unless the README has changed significantly, it didn't call `var` a bug. Which it may have, I haven't looked at the history or anything. It was saying "this bug" referring to the scope of the `snack` variable and how in that particular case it was probably not returning what you wanted due to not being hoisted. Granted the code wasn't a great practical example of something you might do in the real world, but it did illustrate the hoisting difference.
I believe the bug was that you got the value of the `snack` outside of the function because the let inside the if statement was not hoisted to the top of the function. I think it's really a matter of expectation versus reality and not so much a bug, and it should probably have some more explanation. It may not be the best representation of that particular situation, but some of the rest of it would actually be pretty useful for a newcomer. And, since it's on GitHub, you could always submit a pull request to update whatever bothers you. I'm sure the author would appreciate it. It's certainly not perfect, but I think it could be useful for people who are learning to utilize es2015.
We have a language standard. Things don't evolve without the ability for people to improve. You can search on google or node-modules.com or npm or whatever to find the projects with the most stars/popularity today, and pick up one of the latest things when you get bored with the status quo. If we really standardized things everyone would be stuck with one shitty out-dated solution.
There have been plenty of giant JS applications for years. The guy is complaining about the number of tools and frameworks to pick from, which is different from a development strategy.
whoa! I really like what you're building so far, Sahat! That looks really cool. I haven't figured out server-side rendering yet, so when you finish your project I'll definitely check it out.
&gt;This bug highlights that we need to be careful when refactoring legacy code which uses var. I don't have a better example for a pull request but I read this line to be the bug was the act of changing var in a legacy app lead to different outputs. In the original example you got the value from outside the function scope so that couldn't be the bug that we should be careful to avoid when refactoring code into es6
It should probably say something about being careful to take note of hoisting when refactoring code from var to let and const. In the original es5 example you were getting "undefined" because the var initialization in the if statement was hoisted to the top of the function. In the second es2015 example you get the value of snack from outside the function because the let initialization inside the if statement is not hoisted so snack at that point refers to the outer declaration of snack. It's more of a side-effect than a bug in this example, but could easily lead to bugs if other code relied on this function.
You said the same thing twice. Not sure if that was intentional. 
&gt; That syntax means literally nothing to people who haven't used angular 2 before. I'll have a guess as a professional programmer, although I've never used Angular before: *ngFor Some of kind of loop, although I don't why there's a * to start #todo of todos$ For each todo in the list of todos.... again, the # and the $ seem a bit odd | async You pipe it through something? It's asynchronous in some way? {{ todo }} So we get display the actual todo here? So we have a single &lt;li&gt; with a list of todos? I imagine the intent was a list of &lt;li&gt;'s. This syntax does indeed suck.
feel free to send a pull request with things that make it more like Rust. I actually just got the name `rust` on npm, I may move this to there and requiring it will be `rust/match`. I might actually build out some other rust things in js for fun sometime
Yes, it was. It's a gross oversimplification, but our front-end tools are mostly the same as they were 3 years ago. I mean, you don't have to throw yourself into the churn if you don't want to. But I guess some people work at companies where they get pulled in regardless. On the server side, we've seen a big shift in demand from LAMP stack to .NET. I don't know if that's just us or if there's a larger trend happening. There's a certain amount of churn happening in the .NET world right now. :)
&gt; I stopped reading after it called var a bug. Fun fact: You can't use `var` in the proposed strong mode. 'use strong'; var x = 5; -&gt; Uncaught SyntaxError: In strong mode, 'var' is deprecated, use 'let' or 'const' instead The behavior of `var` is also generally undesirable: for(var i = 0; i &lt; 3; i++) { setTimeout(() =&gt; console.log(i), 0); } Output: 3, 3, 3 for(let i = 0; i &lt; 3; i++) { setTimeout(() =&gt; console.log(i), 0); } Output: 0, 1, 2 Fixing it without using `let`/`const`: for(var i = 0; i &lt; 3; i++) { (function(_i){ setTimeout(() =&gt; console.log(_i), 0); })(i); } Hideous.
My apologies if it seemed wrong. As others have stated, I was trying to show what happens if we replace var with let blindly. The behavior when var is used is correct, however when we use let we end up with unexpected behavior. The main idea was to be careful with refactoring &lt; ES6 code and blindly replacing all instances of var with let. I'm completely open to more practical examples :)
You have more problems if you have a 1000 line switch statement. You should restructure your code so you can understand it better. Read how to break it up into groups of related functions. 
[uhh...](http://i.imgur.com/CSjrhsX.jpg)
You can just `await Promise.all([taskOne, taskTwo, taskThree])`, there's no need for a callback.
We'll see. While rust-match is a fun experiment, I don't believe that it's practical, so I will likely be dedicating my time to other projects. If I see some of your work pop up that's a bit more practical and along the same lines, I'd be interested in contributing.
https://jsfiddle.net/ewcpdxLs/ Something like that. Try Firefox Developer Edition if it doesn't work for you. In that "action" function I have two hardcoded ifs. In a proper text adventure, you'd have something like "rooms". When you enter one of those, its descriptive text is printed (something like that text I'm printing in "main") and each one has some things to do (take X, open Y, etc). You'll also need some kind of inventory if you want to make things a bit more interesting.
declare your vars: `var Triangle=false` `sides = (...)` is wrong, its either arrays `sides=[1,2,3]` or a fn, `sides = function_name(1,2,3)`
You are a life saver! Thank you so much and I hope you have a wonderful day/night/evening/24hourcylce!
It would be better to explain the block scope of let. Your example doesn't explain why snack is "Meow Mix".
Wow, that´s fast and a smart way to do it. Thanks for the code. I´m going to use that in so many places...
I guess "another mistake" is a meta-message, describing the message itself rather than the commit.
Haha, yes indeed
Some notes: * one common solution at the *Arrow functions* example is to use the *thisArg* as the 2nd parameter in the *map()* function. :) * you still need to escape ` char if it exists inside the Template literal string *(but not if it is interpolated, see reply)* * you are still using *var* at a lot of the ES6 examples even after the first topic * The *Similar to Python, we have named imports:* example is broken (remove the extra *} from* part) * I'd suggest adding a more complex example for the Rest parameters where you have e.g. 1-2 parameters + the rest ...args, basically the first example @mdn page * At the Symbol example besides the mentioned problem by /u/zohogorganzola, there should be the same string for both of the Symbols because it would represent that they are really unique * We didn't use naming conventions to store private data (because they were not really private), we used closures for this * Iterables / Generators topic I should have made a PR about these though
I liked the post. Functional is great but not definitely if you want to create self contained components that can be plugged in and out your apps without coding for them. It seems a good idea: *Your app code: Functional *Third party components: OO
One of the problems I ran into a few years ago was how charts treat missing data points. In stock charts, for example, the weekend and public holidays don't have values. Take a look [here](http://finance.yahoo.com/echarts?s=AAPL+Interactive#{%22range%22:%221mo%22,%22allowChartStacking%22:true}). You'll see that even though the chart looks continuous, it just skips over weekends. Some libraries let you configure if you want to have those values on the x axis or not. Maybe they only let you skip weekends. Maybe they allow you to interpolate (by just drawing a line) through the missing range, but maybe you just want it to be blank. This behavior may be something you can't quickly see from the docs, maybe it would be a nice addition to your guide.
I'm not a member of codeacademy at al so I don't know about their example - you might need to go into more detail to get useful answers. Do you mean a game that will run in a genuine command line environment? In that case the most obvious starting point would be to use node.js, it has a built in wrapper around readline for input from stdin and in that context console.log goes out to stdout - the documentation includes a simple CLI program as an example that should illustrate the "show relevant info, wait for command, update state depending upon input, loop" process of such a program. If you mean something else then, well, tell us what you mean...
Can someone explain the behavior in the first example for me? var snack = 'Meow Mix'; function getFood(food) { if (food) { var snack = 'Friskies'; return snack; } return snack; } alert(getFood(false)); This prints "undefined" var snack = 'Meow Mix'; function getFood(food) { return snack; } alert(getFood(false)); This prints "Meow Mix" var snack = 'Meow Mix'; function getFood(food) { if (food) { var snack = 'Friskies'; return snack; } return snack; } alert(getFood(true)); This prints "Friskies" I'm trying to understand what's happening, in the first function food is either true and snack gets overwritten or it's false and in that case shouldn't it retain its global value? Does the whole function content get evaluated and initializes its variables even if the code path doesn't get executed?
Very valid point. Will make sure to include this in my guide! Thanks pinegenie :)
&gt; you still need to escape ` char if it exists inside the Template literal string Not if they're nested. For example, the following is correct: ``` var a = 'hello'; console.log(`${a} ${uppercase(`${a} ${a}`)}`); ``` It will print `hello HELLO HELLO`. 
If you want the equivalent of prompt I'd suggest you take a look at this node module. https://github.com/flatiron/prompt it works similar to the browsers prompt function but then for node.
Food is false, and the interpreter is redeclaring the variable snack inside the function getFood (even if in the code it looks like it is redeclared only by going through the if statement), making the variable snack outside getFood invalid. Since only a true statement gives snack a value, the variable doesn't get defined and hence the return.
think of a range like an array try `console.log(range)` maybe you have an array there so you have to do like var cell = range.getCell(1, 1); console.log(cell.getValue()); the valid FNs for your variable `range` are: [here](https://developers.google.com/apps-script/reference/spreadsheet/range) Something like `console.log(range.getValues())` should work if you just want A1 (try this): cell = whatever.getRange('A1') console.log(cell.getValue()) cell.setValue(123) console.log(cell.getValue()) if (cell.getValue() == '123') console.log('value matches!') (if it doesnt work, IDK, if it works its because getRange('a1:a1') returns an array...) 
I try to focus on CSS and front-end in general. High performance animations, SVG's, WebGL, canvas elements and animations, etc. It's client-side high-performance that drives me. If my code doesn't have a visual effect in the browser, I get bored quickly. So I separate people by their preferences. Based on my current work environment, I have a few different types of JS developers: 1. The Node.js developers that write code all day. The guys that know dtrace and revel in optimal code and all that jazz; 2. The javascript web developer that writes JS for the browser. Except they do it in ES6 and transpile everything and automate building it all efficiently. They take care of business logic and efficient usage of data; 3. The front-end web developer that takes care of the views. User interaction, user experience, user interface, animations, cross-browser styling, cross-browser performance, cross-browser scripting, responsive, cross-device, etc. I don't know anyone who kicks ass on all levels, or even 2 out of 3. The front-end dev doesn't like to write code all day and look at terminals. The Node dev doesn't like writing CSS and figuring out how to get something to display properly in IE10. The man in the middle, the javascript developer, is typically able to work server side in Node, and does it well. The ones I know still enjoy seeing a visual end-result when they alt+tab and refresh the page. I'd advise anyone to specialise. Maybe not in these 3 specialties, because they might just be 2, but if you don't know (and don't want to know) proper CSS and cross-browser differences, then please don't and let someone else take that responsibility. Because people like me absolutely love it :)
Why are so many of your ES6 examples still using `var` instead of `let` ? edit: I just did a PR for that
For most stock markets they open and close every day, so there's an overnight gap on intraday data. Which was ok apart from the couple of times a year when time zones change and stuff broke. I think I left sometime after considering that * some markets close for lunch as well as overnight. * time zones can be changed by governments * time zones can have weird daylight savings rules, including in some cases change-over dates that are decided *each year* by whoever is in charge * national holidays are often pretty arbitrary as well, and markets may not match their opening to them perfectly either Trying to keep track of it all so you can render nice consistent candlesticks in real-time started off challenging, became frustrating, and has given me a hatred of Java's date and time handling API :)
PVS-Studio team. ChakraCore: analysis of JavaScript-engine for Microsoft Edge - http://www.viva64.com/en/b/0370/
Duh, it's easy. Class has 5 letters, devil has 5 letters. Coincidence? I think not. Classes are the devil!
Thanks for your input, I've edited my reply
thanks
Amusing that the [documentation for the function types](https://github.com/MaiaVictor/optlam/blob/master/optlam.js#L56) is written in Haskell syntax.
Does this really degrade performance? Care to explain? &gt;I really don't see why anyone would want to do that. About this - just trying to write clean prototypal code in JavaScript to see how easier and productive it can be as opposed to using classes and new. Also, in this particular case - it's easier for me to write objects and store them in document oriented database. I even do not write methods. I just use helper function to operate with objects. (like not vegetable.isItSellable() but isItSellable(vegetable)) But last paragraph is not about OOP, it's just my case.
I'll check this out, thank you so much. 
if getFN is itself returning a promise, not sure why any of the then steps or the extra promise are necessary. That is: function memoizeWithPromise(promiseReturningFn) { let memoizedCalls = new Map(); return function(...args) { let serializedArgs = JSON.stringify(args); if (memoizedCalls.has(serializedArgs)) { return memoizedCalls.get(serializedArgs); } else { let promise = promiseReturningFn(...args).promise(); memoizedCalls.set(serializedArgs, promise); return promise; } } }
In the last code you're using get name() { } Well yes, there is some caveats in this situation. I personally never used getter, only special methods like .getName() which in your code would not have any problems. Basically you're implying that those useful features when using classes has their powerful benefits as opposed to plain Objects. I'm still trying to figure out why all the fuss about plain prototype-based usage of language was, if it has this flaws. Maybe when there was not class but only function - plain objects were preferable. Anyway, you have the point. Right now my approach has such pros as: * easy storable objects in document oriented db and * little or no risk of breaking code with "inheritance" confusion of those who used to play around with old "function classes" and their prototypes.
Factory Controller is easier to mock out the ApiClient for unit testing. And you can always make another file that does the same as B from the code in A, while the other way around is harder. That's why so many big companies do factories or some kind of DI. 
Can you use a default argument to get around this whole thing and go Full Factory? // Factory: let defaultClient = require('lib/api'); export default function FactoryController(apiClient = defaultClient) { return function controller (req, res, next) { apiClient.getById(123).then(data =&gt; res.json(data)); }; }; ------------------------------------------------------ // mymodule.js let defaultController = FactoryController(); let betterClient = require('lib/api/better'); let betterController = FactoryController(betterClient); This way the factory handles defaults but lets itself be open for extension and testing through dependency injection.
Haha the getFn does return a promise. The additional promise is indeed unnecesary hehe Thank you! :)
I'm not saying that I fully protect my approach as my child. I'm trying this approach because I'm not the only one in community and I'm trying to find flaws and see all cons/pros. &gt;As you can see, the Object.assign strategy gets more and more verbose as your codebase grows. If your schema changes the name of a mutable field, you have to change code at every instantiation point. If you add a mutable field, you have to change code at every instantiation point. If your users get multiple address fields, you have to Object.assign every single one of those too. At some point, you probably need some sort of Factory pattern, like I already have factory function, that do hide all things that is likely to grow/be changed, protecting code with errors (yep, those still functions, I don't know how to throw objects and check which error is up there without `instanceof`). Instead of Project.new() I use simple const vegetable = vegetableModule.createVegetable(params); I mean I know about those situations when codebase grows and there is this bloat of code which nobody can restrain. So I'm using basic rules without reinventing the wheel like 'modules' or 'objects with factory methods' etc. My modules (node) have factory functions and this OOP approach. Some constants. And that is all. So when working with objects and changing them/creating them I'm using helper functions, when working outside one particular module (eg.: `const vegetableModule = require('../vegetable');`). No Object.assign outside. Only helper functions are allowed to go outside.
Your problem here is stateful modules. `apiClient` should not have global state, if it does need state then it should be exporting a class, each instance of which stores state. Then `factoryController` can keep its own private `apiClient` instance, and exposure configuring it where and how it chooses.
Well, this should give you the equivalent of jQuery $.each: var each = function(obj, callback) { var value; var key; var i = 0; var length; if (obj.constructor.toString().match('Array')) { length = obj.length; for (; i &lt; length; i++) { value = callback.call(obj[i], i, obj[i]); if (value === false) { break; } } return obj; } else if (typeof obj === 'object') { for (key in obj) { if (callback.call(obj[key], key, obj[key]) === false) return obj; } } }; Not sure why you want to recreate map though.
Your first example has nothing to do with classes, you're just comparing default arguments to none. You could do the same thing with a function that contains `Object.assign`. And it's true the second breaks, but that's because you're purposely writing code that's naive to getters. It's entirely possible to replace `Object.assign` with your own function that handles getters (and the rest) just fine.
It is an anti-pattern to instantiate your own dependency. See the last section of https://medium.com/p/356d14801c91 Also until something can replace proxyquire I don't think es6 modules is testable without perfect code that has all your dependencies injected
 // Object.assign const Vegetable = { name: 'Default vegetable, do not use' daysBeforeRotted: 2 }; const tomato = Object.assign({}, Vegetable, { name: 'Tomato', green: false }); // Object.create const Vegetable = { name: 'Default vegetable, do not use' daysBeforeRotted: 2 }; const tomato = Object.create(Vegetable); tomato.name = 'Tomato'; tomato.green = false; // Class class Vegetable { constructor(name = 'Default vegetable', green = false) { this._name = name; this._green = green; this._daysBeforeRotted = 2; } }; const tomato = new Vegetable('Tomato', false); My first observation is: None of these are so different that it's going to change how we organize and architect programs. We sometimes like to think we're revolutionizing programming. We're not. This comes down to nuances of readability, tooling, and maybe performance if you've measured. Second observation: Initialization functions and encapsulation are important. The Object.assign and Object.create examples would need a factory function and private data. Classes already have initialization functions (the constructor) that is invoked automatically for you. Third observation: We don't have to pick just one. We can use the class syntax most of the time and use Object.assign (or other clever solutions) when we need multiple inheritance. The call to Object.assign can even be abstracted away. class Foo extends mixin(MySuperClass, MyMixin) {}
&gt; little or no risk of breaking code with "inheritance" confusion of those who used to play around with old "function classes" and their prototypes. You actually still have all the same inheritance problems. Inheritance isn't the "extends" keyword. Inheritance is incorporating structure and behavior from another type into your own, and Object.assign does exactly that. Imagine the owner of the Product object decides "name" isn't sufficient anymore, so they get rid of name and switch to "sku". Now Vegetable and tomato break because they "inherited" data members from Product. You still have the same fragile base problem.
This reference from Google talks about their object performance optimizations. https://developers.google.com/v8/design?hl=en#prop_access The lesson is: Don't assume something will be faster. Our assumptions and intuitions are often wrong. Any claims of better performance must be proven by measurement.
Hi /u/Nabukadnezar, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). No exclusive offers, i.e. "invite only", "request a trial", etc. The content should be freely open to all.
This case sounds like solution to it will be - delegation. But using methods. Just theorizing here. Like only `public` methods (getters, modifier methods) are allowed to use in outside usage but... This is not the case here. The best solution for this problem is architecture of exporting original object allowing using only several methods, which is access modifiers, which we do not have in JavaScript.
[Momentum](https://chrome.google.com/webstore/detail/momentum/laookkfknpbbblfpciffpaejjkokdgca?hl=en) And... what /u/persianprez said
class pattern? This is factory function. Not class. Factory function is opposed to class based approach because there are no `blueprint`. About nested Object.assign madness - I did not yet confront this issue. Mainly because I'm using functions to modify objects and create complex objects. You can try to write simple app in this approach too. Of course after reading some thoughts of people who oppose classes and constructor in JS nowadays (Eric Elliott, Dan Abramov etc). Just trying this approach. No classes. No constructor. Like in first line in op post. Imagine, there are no new, no constructor. Actually it's not better nor worse than classes. Only "multiple inheritance" is easier, when you know that everything is object and there is no thing that pretends to be "class" - blueprint.
This would be my preference as well. Also helps simplify testing.
&gt; Gee, of course I'm aware of composition. I use compose objects in the meaning "add properties from one to another". I would write "I'm using composition" if I like to use other meaning. Didn't mean to offend. I wish I could take it for granted that everyone understood what composition is, but there's actually been a lot of bad information circulating recently.
Yup. A guy named Eric Elliott has literally re-invented the meaning of object composition based on the generic Webster definition. And he has enough readers that it's become a problem. There are people now using inheritance more than ever, all the while thinking they're "favoring composition".
Actually: lol. I wrote medium article about why people should use classes and forget about prototypes. Now I'm trying other approach. Exact approach which has been talked about by Eric Elliott and some others (Dan Abramov if I'm not mistaken). But somehow I missed that Eric somewhere changed classic meaning of composition. Or somebody else. Maybe I missed some posts. I assume you're not talking about this article? https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750#.hu73lavl0 edit: I remembered. There was thread here, this: https://www.reddit.com/r/javascript/comments/3oy9c3/composition_vs_eric_elliott/ Oh. And this is you, who wrote it. Interesting. Actually you are one of my favorite people here now, because I was thinking about using classes and not pure objects with prototypes too, but did not get much attention about my half-troll-half-sincere article. Would you be so kinds to share your github/medium/blog? Interested in your work.
Updated post you answered to.
It is advantageous to change your selection once you know that one of the two doors you didn't pick doesn't contain the prize. Look at it this way. You start out with a 1/3 chance to pick the right door on the first try. There is 2/3 chance that the prize is behind one of the other doors that you didn't pick. Now the game master tells you that you can pick one of the remaining two doors and shows you which of the two doors not to pick. Since the remaining two doors had 2/3 chance of containing the price, by changing your selection you are essentially replacing your original 1/3 chance of getting the price with a 2/3 chance. You should jump at this opportunity.
X-Post referenced from /r/node by /u/the_legend_of_dave [How I fixed Node.js](https://www.reddit.com/r/node/comments/3zy5my/how_i_fixed_nodejs/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Best practice would be to use browserify imo. It's really easy to setup and get into. Otherwise, internal nested functions is the best practice, all the others are anti patterns, especially the last since you're creating a ton of globals. In this case what you're really doing is creating a single namespace with "modules". We do this at work, but you're still populating the global scope with your namespace. We actually ran into a conflict with one of our names once. In any case, I recommend the switch to browserify, much easier to do modules, no nesting.
Results are up http://daily-javascript.com/challenges/tic-tac-toe/results/ great work guys, check out this weeks challenge. http://daily-javascript.com/challenges/workshopper/
Yes, it was considered a pattern to implement class-like semantics (instantiation, inheritance, encapsulation, etc). Again, I strongly recommend looking up the old discussions because we're literally beating a dead horse right now. Now that you're mentioning Eric Elliott and Dam Abramov, I'm guessing that what you actually have in mind is that you have a more functional-oriented architecture, with unidirectional data flow, etc etc? In that case, you can use pseudo-metadata like `type` fields instead of using `instanceof` and friends, and you could likely go a long time without ever needing a taxonomy hierarchy or hitting OOP-related pitfalls. There are some known performance de-optimization caveats in chrome with regards to adding too many fields to an objects and bumping it into hashmap mode, but in my experience rewriting mithril.js' virtual dom engine, I have observed that having a large number of objects with nulled properties at the beginning actually performs slower than if I were to add the properties at runtime. Conclusion: I would not sacrifice idiomatic code to try to cater for some chrome optimization, since chrome is not the only browser in the world and not even guaranteed to have the same performance optimizations from one situation to the next or even from one day to the next. In a functional style, it's more useful to think in terms of a data transformation pipeline - FP doesn't concern itself with what the data is taxonomically (i.e. rather than think in terms of `tomato` methods and `user` methods, you might write a function that uppercases anything with a `name` and then use that on both `tomato` and `user` data structures.) Under the FP paradigm, you don't really want to think in terms of "inheriting" and prototypes... it's kinda distracting. For FP purposes, it kinda doesn't really matter what mechanism you use, as long as the end it results in a union of all the properties in a single new object. But with that being said, you'll want to be aware of the technique used by some libraries of using `hasOwnProperty` guards in for-in loops to defend against Object.prototype pollution
&gt;But with that being said, you'll want to be aware of the technique used by some libraries of using `.hasOwnProperty` guards in for-in loops to defend against Object.prototype pollution. You mean when `.hasOwnProperty` is used to determine whether property belongs to object and not prototype? In my case there is only Object.assign, so hasOwnProperty is really have no side effects. It will return true/false whether property is in this object. This was one of the main reasons to use Object.assign instead of Object.create Which also means that I'm using objects exactly as data structures and nothing more, just combining them one with another and then using them in functions. If you mean something else about `.hasOwnProperty` - provide some links please, I'm really interested in seeing this technique.
Agreed, especially for the improvement in testability. 
Best practice is to avoid namespaces altogether, and use modules to encapsulate and separate your APIs. CommonJS and ES2015 are popular choices.
Nice read =D
Node has modules built in, browserify webpack etc all bring the module idea down to the browser. You would be living up to your name if you did not spend the 5 minutes required to learn the module pattern in node and use it from the start.
&gt; In my case there is only Object.assign yep, so you're fine
i can link the code, i just didnt want to post a huge amount of text
you tell us?
Could be... It's pretty hard to spontaneously debug such a wall of code in mobile :p When you encounter such errors, just take a look at every place where this variable is used/set. Somewhere should be an error :p
I'll see if I can dabble around with it some more. Thanks for noticing the one error that I had though. I'll reply later if that helped
Was this yours? http://codepen.io/ajwhite/pen/jWGGyb
&gt; Also, about permissions. Yes, yes. This is what makes easy concatenation impossible to exist in JavaScript. Those actions you wrote - they all can be encapsulated in factory functions You could do, but why would you want to? Why not just use a paradigm with less boilerplate and less risk of misleading readers? &gt; but of course in those functions one should be aware and always remember about reference types People will forget. You will forget. You cannot build scalable software on the back of patterns that add mental overhead to manipulating even the most trivial parts of your codebase. You seem to be taking the position that the Object.assign pattern you've invented is acceptable because it and its contortions are all at least machine readable. You seem therefore to have set the yardstick by which we judge your code as whether it merely compiles. You almost seem offended when people detail the exact semantics of your pattern - misunderstanding that they are not trying to show you how the language works, but how the semantics of your code will be misleading and often unwanted. You seem to dismiss these problems, and that worries me, because I've worked before with developers who are happy to build constructs that blow up without proprietary knowledge, and I know first hand such software does not scale.
She wrote really good.
I did not submit one. I have implemented tic tac toe before though, I even have one on codepen that's made using functional techniques, but no AI (though I should port my minimax code from the server into it, it's a very short function. http://codepen.io/alex-wilmer/pen/waXKgL
Is it possible to put multiple modules in one file? My functions naturally break up into 4 groups/modules. But it seems a pain to create four files when some of the modules would only be 20 lines long. I can see the value for a large project, but for a tiny one-off project, modules in separate files seems like overkill.
Nope... Here's what I was working with (only does one computer turn): https://jsfiddle.net/qgxsjsya/ I still haven't looked much in to algorithms I can use to ensure a computer win or tie.
Question rephrased: "This is legal in Babel and does not throw: what is the value?". Also, are you not in favor of object spread? I find it to be one of the most useful additions in ES7
Gotta say I liked the idea, it's very interesting, but it raises some questions: Is there a limit on how complex my scripts can be? CPU-intensive? Size? Restrictions are also part of the fun, can't say I don't like the very creative limitation your team has figured out, cleverness and inteligencie, I don't see it as such a long term game that is fun for everyone. What stops someone for developing the chosen-one script, one that rules them all? Because that would slowly end the game for pretty much everyone, even more if that kind of people decides to share scripts. All it takes is one very logical individual. Also, great work on having me connect using my github login, that was pretty cool, however, I don't have a twitter account, which was rather anti climatic (unexpected, but understandable). I feel like there should be an option to play offline, like a single player to save and can be continued, that would be better to get people hooked on the game, otherwise there's too many players who will feel left out.
The spread operator works only on iterable objects. I don't think Object.prototype has a Symbol.iterator property, so that would cause this to result in an error, correct?
Object spread: let x = { a: 1 } let y = { b: 2, ...x } y // { a: 1, b: 2 } Our codebase uses this heavily, not just to combine objects but to destructure unknown properties in function arguments. It's not different than what I'm doing here.. this was a mistake in our codebase, that when found, was surprised by the result. You may say it's a bug in babel, but maybe it's intentional? 
No it did not throw an error, but I think it should! I updated my post to say this was in babel, and can be replicated in the babel repl.
It is different. Notice that the ...x is contained in an object literal in your example there, but in the example in OP it's in an array literal. That makes all the difference - you can't spread an object into an array without the object being iterable. AFAIK Babel tries to be standards compliant. I doubt they would intentionally deviate here.
When the hell did MEAN become a repo? It's three separate apps and the system on which they run, the stack doesn't need a repo. You don't see a LAMP repo, that's stupid. Second, Express? It's barely seeing updates and has been far surpassed by Koa and others. I'd love to see something else, although it wouldn't fit with the acronym. I do like seeing a transactional relational database being used in a node stack, good stuff. Mongo is good at what it does, but most web db schemas are relational.
I don't know about ChromeOS but it would be very easy to do so with Date.now() and a switch statement and acting on the day of the week from the timestamp
Not to sound discouraging in any way, you don't yet know a decent amount of C# if you're new to Programming, and JavaScript is not "essentially C#", though there's a cursory C family syntax resemblance.
&gt; I am new to the scene of programming, I know a decent amount of C#, and the basics of javascript (which is essentially C#...) To really throw you for a loop consider these: * Scope and inheritance are different unrelated concepts in JavaScript * Inheritance is optional. You can write completely modular and deconstructable large applications without ever using inheritance. * JavaScript does not have true classes. The class keyword is finally available as of June 2015, but it is really just a vanity convention over the standard prototype scheme. * JavaScript is loosely typed and does not have a static compilation mechanism, which is hugely different from C#. * Scope is inherently lexical. There is no convention to turn this off or make it behave like scope in Java or C#.
Rename "myArray", "myVariable", and "s" to something more descriptive. Indent your code properly. Put a runnable test case on JSFiddle, JSBin, or CodePen. Explain what your code is supposed to do and what exactly the problem is.
Pretty sure there will be lots of input, little value :)
snap lol. I heard java script is very confusing. and I realize that but not trying to boast or anything but I can learn computer stuff very well, like I know the BASICS. how to make variables, loops, arrays, etc.
Awesome idea. My ID is "riotgrrrl" in Screeps Love this concept. I will edit this post as I'm playing here. - If you make the tutorial not a lightbox then people can read it and type it in console. - I can't seem to close messages once it's opened - I can't find where my energy is. I recommend using general RTS conventions and putting it in the top right - Got a glitch for the second time, stuck and not transferring. Before I suicided my worker, made a new one, it worked for a bit, then glitched again and now i'm stuck http://i.imgur.com/AvbqcHh.png - I literally used the exact code from the tutorial and the creeps.. getting -8 from my attempted transfers. Code formatting is not working for me here's a link: http://codetidy.com/7784/
Maybe prevent copy-pasta-ing scripts. It's not a perfect solution but it would go a long way I think. Or you could randomize a bunch of variables at registration for each player so my Game is another persons MainGame is another persons Game1 or whatever. You could also enforce globally unique variable names
I like tabs. At work we're using spaces. Its ok, and most code editors now help make space indention behave like single-character tab indention for many operations, so that helps. I also like 4 spaces for indentation. 2 is too short, especially for JS. 2 can be fine for CSS (though with SASS I prefer 4) or HTML, but not so much JS. Consistency is key over anything else. Though I like tabs, since we're using spaces at work, I use spaces at work. If you're working on a project with other people contributing code with tabs but you like spaces, use tabs. If you're indifferent, but are working with some library or framework whose examples tend to use a certain style, then follow that style since its likely others using that lib/framework will be doing the same (and any example code you steal from their documentation will seamlessly blend in with your own). Also don't forget about vertical spacing. I tend to keep things very tight. I like seeing more code on my screen at one time. But throwing a few empty lines in there can go a long way towards readability. I'm getting better with this.
4 files can be really typical for a small project, and a module with less than 20 lines is very normal. You require a module by its file name, so you can't export multiple modules, but any module can export multiple object, functions or any value. For example: function add(a, b) { return a + b; } function divide(a, b) { return a + b; } module.exports = { add: add, divide: divide, };
Where did gc() come from? It's not defined in my console, running 4.2 Edit: [link to the PR](https://github.com/nodejs/node/pull/4071)
This might be a great way to teach my kids how to program. Assuming I can pique their interest in the game, that is. 
Right you are! To get the gc object to exist, invoke node on the command line with the --expose-gc parameter: https://simonmcmanus.wordpress.com/2013/01/03/forcing-garbage-collection-with-node-js-and-v8/.
I've played. This is way too tough for kids who don't already know how to code, even in singleplayer mode. It involves at least basic AI design. You could do it if you know how to code, but learning to code while solving these problems would be tough and probably counterproductive.
If you want to get started and have some idea of the existing designs, many people have put their code up on github. Do a github search for screeps repositories and you'll find them.
Also the posted code tries to iterate through `myArray` with a for loop, but `myArray` gets reassigned to a string (twice) a few lines up, so that loop will never run.
This probably the most controversial question to ask any programmer. Some don't care at all, others ruthlessly argue for one or the other (try googling "tabs vs spaces" and have a read through some articles :)) In reality, it doesn't matter - as long as you are consistent. Personally, I use tabs. One character for one indent level. Using multiple spaces is just asking for "off-by-one" errors in your indentation :)
XML is better
please elaborate
Blaze meter. It's a SaaS version of jmeter 
&gt; but can't you send an object literals stored in variables over web servers too Yes, by sending JSON...
variables in JavaScript are stored in memory when running JS code. If that code wants to send some variable data to a server (which may not, itself, be JS), it needs to convert that variable data into some easily portable data format. This could be binary (a series of 1s and 0s), but its often easier to use something thats more human-readable, such as a string. What's nice about JSON is that its able to represent data easily and clearly in a hierarchical format which can be parsed easily, no matter where its going (most languages have JSON parsers available), but it also works as literal code directly in a JavaScript file. If you know JavaScript, you basically know JSON, or at least can very clearly understand the data its depicting.
whoa that's pricey 
Having a hard time believing that you can write this code but you don't know how to debug.
Well, sometimes I am kinda offended, because people often forget, that class-based structure is not the only one structure to work with and you are talking from position where remembering about reference types is the problem to keep in mind. I'm talking about situation, where is it's natural to know about referenced types like you know about why `const a = arr[0]; a.apples--;` does affect a[0] also. This situation called "I'm working in JavaScript" and not "I'm working in JS, but my main language something else, duh". But you somehow misunderstood me and thought that I am preaching about Object.assign and it's benefits. I'm trying to work with prototypes in JS, checking benefits of delegation/concatenation for better knowing pros/cons, as other people trying to work with classes in JS or with classes and patterns, using mixins (often hand-made right here, where they did not have possibility to use multiple inheritance). You heard it right, `trying`. Classes are not the best solution as this solution is not the best either. There is no best for all solution objectively. Everyone has their own in JS world. Yes, classes are provided by the language right now, but as objects, you see? You've gone far away from discussion about Object.assign to thinking that I am one of your former coworkers from teams, where you worked with code that was not scaleable. You also tried to point what people tell me here and somehow missed that I was telling them - my situation: object as data structure, functions for using them. With classes one could not achieve this because of unnecessary constructors with prototypes when I do need just data, also when using classes one might want to use methods. I don't have any methods in my objects. Shall we continue not talking about ourselves but about code? edit: also, keep in mind - you do not know my `readers`. They can be anyone. Even people who does not know and doesn't want to know about classes. Code is not for github. I'm writing it right here.
so chromeos you can make a native app, a browser plugin, or just a website to do that. browser plugins are simple its just a .js file and a plugin.json that lists the path to the js file. it should be pretty simple function gourl(){ var time = new Date() // current time var hr = time.getHours() switch (hr){ case "12": window.location = 'http://newurl'; break; case "13": window.location = 'http://newurl'; break; } } setInterval(gourl, 1000*60*60) // run this every 1 hr can google 'window.location' to set the url, 'date()' to learn about getting date info, 'setInterval' for creating a timer. 
possibly the 'events as functions' (not objects) is that. not sure but, it kind of makes sense that you have to write a function to determine wether this is a 1st/15/30th event (Date) or every monday (Day of week) thing. and then generate a new event (or a never ending list of them) on the fly (when the user changes views). kind of hard without some logic. also hard to generate a never ending list, so better to use a fn. edit *yea its that! gl* http://fullcalendar.io/docs/event_data/events_function/
JSON and object literals are different kinds of things. They are apples and oranges. An object literal is a snippet of source code that you write. JSON is a string that you send or receive to some other program. JSON originated as a subset of what you can write write in JavaScript source code, i.e. it looks like array literals and object literals with specific restrictions. But the important difference is that JSON is an interchange format. You send a string containing JSON to something and they parse it and get the data out. You don't send raw JavaScript to them, because that would require a whole JavaScript interpreter to evaluate. Moreover, when you receive JSON you parse it using `JSON.parse()`, not `eval()`. The point is that it's a restricted subset meant for interchange between arbitrary languages/environments. You aren't sending raw chunks of JavaScript source to code to someone. 
Yeah, I almost jumped on board when this launched they had a deal on their service for it coming out of beta. I just saw it in the long run as one of those micro-managing things that you can eventually find some scripts and have to do very little problem solving (mostly just efficiency on algorithms etc). I'd love it if every week they had like a new "event" that would crop up in your sector and you had to defend/defeat it and you'd get bonuses for doing so.
Your energy is not global. Every object (spawns, creeps, structures) contains its own energy in its storage. -8, or ERR_FULL error according to the docs, means that your spawn is full and you can't transfer energy to it anymore. Spawn some creeps and keep on.
There is a CPU limit which grows with each new level achieved. Also there are gameplay limitations which don't allow any single player to rule the whole world. And the game world is not uniform, each room and sector is pretty unique, and there will be even more uniqueness soon, when different mineral deposit types are released. You just cannot get someone other's script and simply drop it into your case, the gameplay scenarios are too much different.
JSON is JavaScript Object Notation, turns out it was pretty simple to understand and easily parseable so people started using it in other languages and its popularity took off. They're fairly similar but JSON has a few restrictions to make it easier to use in more languages that aren't as loosely typed as JS. For all intents and purposes you can basically treat JSON as an object that became usable for sending data over the web because of JavaScripts immense popularity.
Spent a good 8 hours on this if then loop. another morning, another cup of coffee. Thanks for your help MC, but console.log is not a google script function, which does not rule out the rest of your code. I've figured out how to use getValue nearly so maybe later today or by weekend ill have this solved!
The last was 4 months ago. It's probably been updated by now and is different, and definitely deserves the extra attention.
Please don't mess with indexes or normal expected behavior from javascript...
what are you using for your view rendering engine?
If I couldn't copy-paste I just wouldn't play the game, I will be writing the code on my usual editor then pasting it in the game.
Two reasons; it is simpler to implement as you have to worry less about executing derivations in the right order. Secondly it is a trade off; asynchronous is harder to reason about because you might see stale values, but the advantage is that you don't need the concept of transactions if you want to update many value simultanously without wasting CPU cycles. So for example if you have (pseudo code): b = 2 c = 3 a &lt;= b * c b = 4 log(a) // will print 12 if sync, will print 6 if async c = 4 log(a) // will print 16 if sync, will print 6 if async // wait some time log(a) // will print 16 in both cases So sync will compute more often if not using transactions, but always be consistent. Async will only compute after end of tick, but you might be using stale data
Except it isn't first.... gr1d, anyone?
there was a game at the fidonet times where you had to code your own robot and send it to fight (robowar or something like that). indeed someone found the "golden-code" that basically defeated every robot in the arena.
&gt; Shall we continue not talking about ourselves but about code? No. I don't enjoy interacting with you.
Serious question. How do you learn what all of these options are?
Are isomorphic apps considered SPA? that's what I do. react/redux on both clientside and serverside
yes.
What kind of options? Like, for overall architecture? Read, experiment, talk to people, experience, I guess. I've worked on traditional Django/static HTML apps, massive Knockout apps, several different Backbone apps on desktop and mobile devices, and now a large and rapidly growing React/Redux app; at different times I've worked on projects that used grunt, gulp, npm scripts, browserify, webpack, and in one memorably ugly experience, a bunch of python scripts calling buggy java executables to try and mangle the JS code into a production build. (Pro tip: Don't do that.) Over time, you start to figure out what works and what doesn't, and maybe a little bit about why, and you start to be able to figure out which "hot" new technology actually has a chance of solving real issues. Coming into the JS ecosystem fresh...I have no idea what you'd do. Pick a stack at random and home for the best I imagine. (Or realistically, apply for a job and use whatever your boss tells you to...)
Do you know any other persistent MMO (not just match-based or single-player) with scripting gameplay?
Hate to be the one to ask about performance when the code is beautiful and sensible, but isn't there a massive performance impact? For instance, calling immutable.js's 'get' 4 to 5 times and compose vs a single call to 'getIn' or similar? Also, don't you lose the lazy evaluation provided by immutable's sequences and the deforestation of intermediate arrays provided by transducers? Or, I suppose there's nothing stopping one from calling transduce on a series of lenses, but then are we in weird, perverse cousin kissing territory? 
Holy crab cakes. This is sheer talent and/or intelligence that I've ever seen. First of all, thank you so much for putting an effort to show me the step-by-step process of how my code can be improvised. Much appreciated! I'm going through all of these now, slowly. Hopefully^^^*hopefully* I should understand them in no time.
About that last function declaration: that's the object function shorthand which expands to ``` set: function set() { ``` It works on any object, not just classes.
Specifically, the reason to do this is so browser debuggers identify function calls by name. If you didn't explicitly supply a function name, your debugger would identify it (and other unnamed functions) as "anonymous function." Annoying if you're trying to follow a stack trace, or your looking for the slow function in the timeline. 
Substack created an awesome browserify plugin called [hyperxify](https://github.com/substack/hyperxify)! I plan to use hyperx for serverside renders (works with modern versions of node) and use hyperxify for my client side bundles (it replaces template strings with vdom.h expressions for older browser support)! https://github.com/substack/hyperxify 
Angular is not a framework like Rails. I guess the one that comes close to this are Sails, Hapi, express, etc. But they each offer different level of convention. For example Sails is more like Rails by offering you a lot of conventions
Finished this (at least for now): http://omnicrola.com/projects/spacerocks/v1.0/ Github: https://github.com/Omnicrola/SpaceRocks It is an Asteroids clone, nothing particularly special except that I actually got it to a point where you could consider it "done". It was made using TDD practices with mocha, chai, and sinon. Only client facing tool is browserify, rest is all written from scratch. To-do: add high score tracking
None yet in terms of consensus, but if you want an all in one solution, you might pick Meteor or Sails. Might be better to learn pure/vanilla Javascript fundamentals first tho..
Try calling `main()();` instead in your first example and see if it clicks for you. It's not the fact that you're passing parameters. It's because in your first example, you call the enclosing function (main) and get the enclosed function back, but you never actually invoke it, so nothing happens. 
Javascript is weird. I have been defining class-like structures like below. Is it recommended I start doing like b_n's second example? var Pressure = { set: function(selector, closure, css) { loopPressureElements(selector, closure, null, css); }, ... 
I am not at backend programming yet. But am I correct to assume that object literals and json are just two different ways to create objects in the front en
Makes sense, thank you.
Well that's gonna be annoying for folks like me who like to play around with geolocation.
It said my browser did not support pressure when in the WebView inside alien blue, but did when launched in safari. Is that right? I figured the WebView would basically be safari.
They are actually [removing](https://code.google.com/p/chromium/issues/detail?id=520765) a bunch of features on insecure origins. * Device motion / orientation * EME * Fullscreen * Geolocation * getUserMedia
Ember.js for the front end. Read the guides and use ember-cli to bootstrap a project. There is no batteries included framework in the backend that has similar community support or market share as rails/django.