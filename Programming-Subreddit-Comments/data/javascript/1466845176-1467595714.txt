Why do people always say "Oh if you use React you will have to use another library"? it's like people speak of these things as if writing Javascript is like writing assembly. Angular2 going the whole Component composition route is essentially admitting the fruitlessness of giant opinionated frameworks all together. Whenever I get the chance(or choice) I always choose VanillaJS over any framework. Unfortunately there is a belief that learning frameworks makes development faster, or that it's easier to maintain, but as someone who suffers the pain of a large angular1.x app I must say that it's completely wrong. These frameworks are about as useful as most "as seen on television" kitchen appliances, half the time they only solve imaginary problems. Angular 1.x not only had a convoluted syntax, but it's awful performance limits design and only causes issues without bringing any solutions. When I use VanillaJS I can optimize and write lightweight fast and purposeful code. When I use angular I spend the majority of my time rationing watchers and designing around angular's limitations. Angular 1.x is like a overly complex highly coupled ball of spaghetti which is ironic since the main argument for using frameworks is to avoid such things. If I had to describe what a large Angular code base looks like, i'd have to say, it's like opening up your living room drawer where you keep all of your old electronics. . . . everything is entangled together. 
You can flatten the array of promises with Promise.all. Check out the docs: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise
this is mitigated very easily: http://www.2ality.com/2016/04/unhandled-rejections.html But you're right, if you don't subscribe to this event, then it might become very hard to debug. 
even with Marionette it was meh. Angular might have it's flaws, but at least it made frontend development of stateful apps easy. Backbone gave it a bit of structure, that even I'l admit, but it didn't make it easier.
I agree, very useful. However I don't believe it is a little known fact, but that might just be me
Type-wise a lot of what you said is a non-issue in typescript - asong as the types are optional and can be easily turned off, you gain all the advantages and lose the problems. 
Super useful that one. There were definitely a few people in my team who didn't know that one when I first busted it out.
adopted from coffeescript
If you chain them like you do there is no difference. It helps thinking of each pass more like a task that has to accomplish something specific, then you can break up logic easier. In your case that could be: fsp.readdir('./files') // 1. Read all files .then(files =&gt; Promise.all(files.map(file =&gt; fsp.readFile(`./files/${file}`)))) // 2. Then, print contents in order .then(files =&gt; files.forEach(file =&gt; console.log(file.toString()))) This is going to be simpler once async/await is available. fsp.readdir('./files').then(async files =&gt; { for (let file of files) { let content = await fsp.readFile(`./files/${file}`); console.log(content.toString()); } });
I think destructuring in general was taken from CoffeeScript wasn't it?
I literally read this in your voice. 
I created this visualizer for Cuberite's (A custom Minecraft server) latest biome generator: http://javascript.nilspace.nl/Cuberite/GrownVisualizer/index.html (My host can be slow at times. You might have to wait a few seconds before the page shows.)
Wow I think this should be the top comment, because it seems like that is what happened, and what is still happening. The second I decide to learn React, I'm now hearing about Vue.
[Async functions](https://github.com/tc39/ecmascript-asyncawait) are an ECMAScript proposal that is currently at stage 3 (chances are good that it’ll be in ES2017). In Node.js, you can use them via Babel. If everything is set up correctly for ES6, you need two additional plugins: * Transformation: either one of the following two plugins: 1. http://babeljs.io/docs/plugins/transform-async-to-generator/ (requires support for generators, which are part of ES6) 2. http://babeljs.io/docs/plugins/transform-async-to-module-method/ (requires [the Promise library Bluebird](http://bluebirdjs.com/docs/getting-started.html)) * Either plugin will automatically also enable the following plugin, which is required to parse async functions: https://babeljs.io/docs/plugins/syntax-async-functions/ More information on Babel: * Configuring Babel 6 (incl. how to use it with Node.js): https://leanpub.com/setting-up-es6/read#ch_configuring-babel * A minimal Babel preset for recent Node.js versions: https://github.com/rtsao/babel-preset-es2015-node An alternative to async functions is [the library co](https://github.com/tj/co), which is based on generators and can thus be used with plain ES6. That is, in Node.js 6 (which supports most of ES6), you may not need Babel.
Vue is really popular here on reddit for some reason. You probably won't hear much about it elsewhere though -- unless you're into PHP development with Laravel. I don't know what your personal goals are in getting back into JS, but for me, I had a short look and decided I'll pass. There are too many small frameworks vying for attention -- I decided the safest bet is to stick with the big ones.
I honestly just want to stick with Angular beecause it what I know and I really liked it. I'm learning React at the moment, but I don't feel like its all that superior.
The best products are ones that the developer can personally relate to. Don't make something for the masses, make something for you. If it turns out people like it, then people like it. 
Surprisingly this is news to me, Thanks for the tip!
Which I don't understand. It's a (very) slower variation of text editor, why use it?
Well, that's 15 years of improvements and bugfix I expect. Angular1 oldest public version is from 2010 I think, people started working on angular2 in 2014, so just 4 years.
I haven't used this in the wild yet so I'm still not clear what the benefits of destructuring are.
Or any of the decades-old ML languages, maybe (where it's just part of a more powerful feature known as "Pattern Matching"). ;) 
The above code instead of `let x = object.x, y = object.y` which can be quite verbose.
Yeah you can use it with default values it looks like: function printName ({ firstName: first='john', lastName: last }) { console.log(first) console.log(last) } printName({ lastName: 'smith' }) // Output: // ------- // john // smith 
I think it's a valid point. It's easy to get up and running and you don't need to learn another language like SQL, you'd just commit json.
This is the wrong way to go as it lends towards OOP styles. If want objects to be unwritable just freeze them: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
 It's super handy for mimicking keyword arguments like some other languages have: function something ({ these, arg, order, does, not, matter }) { // do stuff } var object = { these: 'foo', matter: 'bar' } something(object) or combined with shorthand notation: var these = 'foo', matter = 'bar' something({ these, matter })
I don't like OOP either, but I still feel like this is a good addition to the language. If you don't want to use the feature with `class`, you can use most of it with plain old objects.
I don't think it have any really helpful usage. They can make variable names more clear after destructuring but I think there's little to no need for it. Maybe like: const userObj = { id: 1 } function doSomethingWithUser(user) { // or doSomethingWithUser({ id: userId }) { const { id: userId } = user // ... } But since `doSomethingWithUser` already has the user type as mental context, hence it's name and signature, using just `id` wouldn't make it any harder to understand from where it comes.
You probably also want to make sure that `i &lt; j`: if (i &gt; j) [i,j] = [j,i] 
Or perhaps from Destructing Bind, in Lisp.
Made a [webpack plugin](https://github.com/Klathmon/imagemin-webpack-plugin) that minifies images from the whole project using imagemin. I needed it because the image loader wouldn't minify images added by other plugins. It was my first webpack plugin, so I think I still have a few bugs to work out (someone just reported one today that I need to look at tomorrow)
[removed]
True but I hate the JavaScript syntax. I prefer Python but it doesn't have that flexibility Node does. That's why I use ICS.
Yeah, in hindsight that would have been a good idea :/
Agreed, I used it for about a week and switched back to Sublime. I've also had good experience with VSCode, I like the built-in debugger.
Not at all! `Promise.resolve()` simply [creates a Promise that automatically resolves with the value passed into it](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve). If you don't pass anything in, it just resolves to `undefined`, and you can basically ignore the resolved value. Because `Promise.resolve` creates a Promise for you, it's a handy way to start a Promise chain. This has a couple benefits that I really like: - **Allows all of your Promise-related code to be structured the same** - Most of your promise-related code is probably written in `then` callbacks. If you use `new Promise` to start a chain, however, the first function in your chain will have to handle `onResolve` and `onReject` manually, leading to a different coding style depending on where the Promise is in the chain. Starting a chain with `Promise.resolve` means that all of your code is consistent. This also keeps everything in your chain at the same indentation level, which (IMO) looks nicer. - **Easier chain reordering** - Because all of your code is structured consistently, it makes it much easier to rearrange the items in your chain. - **You don't have to worry about synchronous throws during Promise creation** - I think most (all?) Promise implementations convert thrown errors to rejections in the `new Promise` constructor, but why have to worry about that at all? If you start a chain with `Promise.resolve`, then all of your code will handle errors consistently, with all synchronous exceptions automatically converted to rejected Promises. - **Helps avoid [the Deferred promise anti-pattern](https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern)** - If you avoid explicitly creating promises, you avoid accidentally using this anti-pattern. If you really don't like starting a chain with a dummy promise, you can use something like bluebird's [`Promise.try`](http://bluebirdjs.com/docs/api/promise.try.html) or [`Promise.method`](http://bluebirdjs.com/docs/api/promise.method.html) instead. --- See also: - [What is Promise.try and why does it matter?](http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/) - [We have a problem with Promises](https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html) (see Advanced Mistake #1) - [Stack Overflow: promise.try vs promise.resolve error handling](http://stackoverflow.com/questions/30082237/promise-try-vs-promise-resolve-error-handling) - [Stack Overflow: Bluebird.JS Promise: new Promise(function (resolve, reject){}) vs Promise.try(function(){})](http://stackoverflow.com/questions/32148305/bluebird-js-promise-new-promisefunction-resolve-reject-vs-promise-tryfu)
ML it is then! :)
I may be a traditionalist, but I don't like the syntax of this. The `firstName: first` part looks backwards: the variable being introduced is named `first` but it appears on the right-hand side of the expression. Doesn't mesh well with the older Object Expression syntax in the language, IMO.
That is really slick man. It brings me back to Windows XP cursors, and it's a pretty cool technical achievement. Neat!
Unless they've updated it *very* recently (within the last two weeks): * For most of the final two steps, they direct you to use a class that has "Deprecated" right in the name. * The entire final page is half-assed. They tell you to do a bunch of stuff, then say "hooray, you're done"... except that it doesn't actually work and doesn't actually look like their screen shots. You have to go through the example code at the end and copy in a bunch of styles, some HTML and a good bit of Javascript. And at that point it contains a bunch of stuff that was never discussed in the tutorial.
Thank you for your reply, I believe this is the relevant part. At this point, I am in over my head. div class="NotificationBar" style="margin-bottom: 0px;"&gt;Additional content now available&lt;/div&gt;↵ &lt;div class="NextPageDisabled navbar navbar-inversed" style="display: none; top: 73px; left: 652px;"&gt;↵ Please go back over the material on this page. &lt;br&gt;There is good information on it.↵ &lt;/div&gt;↵ &lt;script&gt;↵ var TimeLeft = 165;↵ var TimeElapsed = 0.1461716;↵↵ function toTimeString(seconds) {↵ return (new Date(seconds * 1000)).toUTCString().match(/\d\d:(\d\d:\d\d)/)[1];↵ }↵↵ function Toggle()↵ {↵ $('.NextPage, .EndPage').each(function(){↵ if($(this).hasClass('on')){↵ $(this).data('href', $(this).attr('href'));↵ $(this).removeAttr('href');↵ $(this).find('img').attr('src', $(this).find('img').attr('src').replace("-on","-off"));↵ $(".NotificationBar").animate({marginBottom: '0'});↵ $(this).hover(function(event) {↵ $(".NextPageDisabled").css({top: $(this).offset().top-65-$(window).scrollTop(), left: $(this).offset().left-20}).show();↵ }, function() {↵ $(".NextPageDisabled").hide();↵ });↵ } else {↵ $(this).attr('href', $(this).data('href'));↵ $(this).find('img').attr('src', $(this).find('img').attr('src').replace("-off","-on"));↵ //$(".NotificationBar").animate({marginBottom: '-100px'});↵ $(".NotificationBar").text("Additional content now available");↵ $(this).unbind('mouseenter').unbind('mouseleave');↵ $(".NextPageDisabled").hide();↵ }↵ $(this).toggleClass("on");↵ });↵ }↵ if (TimeLeft &gt; 0) {↵ Toggle();↵ setTimeout(function () {↵ Toggle(false);↵ }, TimeLeft*1000);↵↵ }↵ $("#TimeElapsed").text(toTimeString(TimeElapsed));↵ refreshInterval = setInterval(function () {↵ TimeElapsed++;↵ $("#TimeElapsed").text(toTimeString(TimeElapsed));↵ }, 1000);↵ $(".NotificationBar").hover(function(event) {↵ $(".NotificationBar").animate({marginBottom: '-100px'});↵ },function(event) {↵ $(".NotificationBar").delay(1000).animate({marginBottom: '0'});↵ }↵ );↵ &lt;/script&gt;↵↵ &lt;/div&gt;↵ &lt;/div&gt;↵ ↵ &lt;div id="FooterRow" class="row"&gt;↵ &lt;d&gt; 
I am guessing I need to edit the var time left or time remaining?
its just another paradigm. put everything in one place, the opposite of the way frameworks were going [html template, css file, js files: controller, model, view, build script]. a lot of css is not reusable so you can get faster page loads. 
VSCode is about as slow as Atom, but the intellisense and debugger make it worth it.
I like to think of it as matching the `import { firstName as first } from ...` syntax, so it is like `let { firstName as first } = ...`
Fixed formatting of code.
You should be able to call the `Toggle()` function in the console. For future reference, you'll want to paste the code in a way that keeps new lines. I found the Toggle function by searching for setTimeout and setInterval which are the two basic ways of setting work to be done at a specific point in the future. You can see that the setTimeout function calls Toggle in TimeLeft seconds, and Toggle changes a bunch of styles to make things clickable.
&gt; I'm not sure why some of the code is displaying properly while the rest isn't but hopefully the part that is is readable Reddit automatically treats anything indented 4 spaces as code, so that's why you see what you see. You need to indent _all_ of your code by an additional 4 spaces when posting to reddit to have it properly formatted :) You can edit this post to do so, no need for another post.
I think that optional typing is acceptable, and even optimal if used on the api edges of libraries and programs. Internally, not as much.
Formatted code: server side code: var http = require('http'); var fs = require('fs'); var path = require('path'); var types = { '.js' : 'text/javascript', '.html' : 'text/html', '.css' : 'text/css' }; var server = http.createServer(function(req, res) { var lookup = path.basename(decodeURI(req.url)) || 'a3.html'; var f = 'content/' + lookup; fs.exists(f, function(exists) { if (exists) { fs.readFile(f, function(err, data) { if (err) { res.writeHead(500); res.end('Error'); return; } var headers = {'Content-type': types[path.extname(lookup)]}; var s = fs.createReadStream(f).once('open', function() { res.writeHead(200, headers); this.pipe(res); }); }); return; } res.writeHead(404); res.end(); }); }); server.listen(8080); console.log('Server running at http://127.0.0.1:8080/'); client side javascript (only the first two buttons just to get an idea): $(document).ready(function() { $("button#arts").click(function() { $.ajax( { url: "./nytimes.json", method: "GET", dataType: "json" }).done(function(json) { for (var i = 0; i &lt; json.num_results; i++) { var $text = $("&lt;p&gt;&lt;/p&gt;").text(json.results[i].published_date + "&lt;br&gt;" + json.results[i].title + //"&lt;br&gt;" + obj.results[i].abstract + "&lt;br&gt;" + json.results[i].short_url + "&lt;br&gt;"; $("section").append($text); } }).fail(function(jqXHR, textStatus) { alert("Request failed: " + textStatus); }); }); $("button#aut").click(function() { $.ajax( { url: "./nytimes.json", method: "GET", dataType: "json" }).done(function(json) { for (var i = 0; i &lt; json.num_results; i++) { var authors = JSON.stringify(json.results[i].byline); var names = authors.slice(3); var singlename = authors.split("and"); var $list = $("&lt;ul&gt;&lt;/ul&gt;"); $("section").append($list); if (singlename.length == 1) { var $text = $("&lt;li&gt;&lt;/li&gt;").text(singlename); $("ul").append($text); } else if (singlename.length == 2) { var $text = $("&lt;li&gt;&lt;/li&gt;").text(singlename[0]); var $texttwo = $("&lt;li&gt;&lt;/li&gt;").text(singlename[1]); $("ul").append($text); $("ul").append($texttwo); } } }).fail(function(jqXHR, textStatus) { alert("Request failed: " + textStatus); }); }); }); and client side html file: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="content/style.css"&gt; &lt;script type="text/javascript" src="content/jquery-2.2.4.min.js" defer&gt;&lt;/script&gt; &lt;script type="text/javascript" src="content/script.js" defer&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;Click the "View Articles" button to view the basic information on all articles.&lt;/li&gt; &lt;li&gt;Click the "View Authors" button to view all known authors.&lt;/li&gt; &lt;li&gt;Click the "View URLs" button to view short URLs for all articles.&lt;/li&gt; &lt;li&gt;Click the "View Tags" button to view all tags connected to articles; tags are sized from largest to smallest based on tags with the most and least articles, respectively. &lt;/li&gt; &lt;li&gt;To view a specific article, enter the article number (beginning with 0) in the "Article Number" field and click the "Find" button. &lt;/li&gt; &lt;li&gt;Click the "View Media" button to view all articles as hyperlinked images or video&lt;/li&gt; &lt;/ul&gt; &lt;button id="arts"&gt;View Articles&lt;/button&gt; &lt;button id="aut"&gt;View Authors&lt;/button&gt; &lt;button id="url"&gt;View URLs&lt;/button&gt; &lt;button id="tag"&gt;View Tags&lt;/button&gt; &lt;form method="post" action="/"&gt; Article Number: &lt;input id="entry" type="text" name="ArtNum" value=""&gt; &lt;input id="art" type="submit" value="Find"&gt; &lt;/form&gt; &lt;button id="hyper"&gt;View Media&lt;/button&gt; &lt;section id="data"&gt;&lt;/section&gt; &lt;/body&gt; &lt;/html&gt; 
When developing with Node here are some things to practice or keep in mind: * Meaningful organization of callback hell. This will determine the shape or your application and will determine how quickly you can perform maintenance. * Avoiding collisions and race conditions when performing numerous asynchronous operations in a finite space, like the file system. * Document the decisions you make in the code. Callback hell can be confusing, but numerous work arounds make it much worse. * Nearly half of all NPM packages use stupid crap you could easily do yourself like `isArray` and ASCII colors on the command line. Don't punish your users with unnecessary madness. * Build strong unit tests. In my own Node app I do a lot of file system operations, so I wrote a simulator to stress test my application against the file system. * Between using the Node API and running similar operations as child processes keep in mind what works better for you. The Node API really is stable and well supported across supported operating systems, but sometimes you just need that nuclear weapon like `rm -rf`.
Netflix, Facebook, Google, Amazon.. "Insert near any good website here".. Separated by comma...
That's good - or "synchronous" maybe.
I created a gif running this code on Chrome and on Safari: http://www.giphy.com/gifs/3o72Fb14R1TlauqbhC
You can also set default values: const {a = 4} = obj And you can combine that with renaming too: const {a: A = 4} = obj
If you are using Babel/TypeScript in Nodejs, you can already use async/await. Since you are asking about IcedCoffeeScript, I assume you might be using CoffeeScript? If that's the case, you would need to wait for non-polyfillable ES6/ES7 features to be ported into CoffeeScript. CoffeeScript was partially abandoned by the original maintainer, as in there was no major update for a while, but recently (a few months ago) there has been some community talks to get it in sync with ES6 again. 
I thought that now with 1.5 there's a "clear migration path" to angular 2, no? 
The spec file includes tests for the JS file itself. The JS above will make a lot more sense to you after you read about JavaScript's prototypal inheritance. Google about it.
It sounds like you're a beginner to we programming, in which case, most of these answers aren't helpful. For simple websites, you might not need any JS. But if you want anything remotely fancy, JS can do the following for you: - DOM manipulation (move elements around, add/remove elements, dynamically change styles) - Listen to events (clicks, scrolls, window resizing, typing, etc.) - Ask the server for data without refreshing the page. - General programming (If you want a web "app" instead of a web "page") - And More And that's only on the front end. You can also use Node on the server, use Node on some microcontrollers, write mobile applications with frameworks like React Native and Ionic, etc.
I wrote a game of life that runs completely in webgl shaders: http://nanodesu.info/stuff/cells/
Even with CoffeeScript syntax, there simply no need in IcedCoffeeScript, cause native javascript async+await are good enough. And they are more composable cause they based on Promised, instead of Randevu. (I've wrote couple of thousand lines in IcedCoffeeScript, and I really liked it. But Promises * async+await are simply better)
We have very similar usernames. What's the story behind yours? (I normally have Swadq)
It's a relatively silly question to ask, because the modern web is entirely built on Javascript, it literally does everything. If it's doing anything more complicated than displaying text, it's using Javascript. Even this website--which is still functional without Javascript as it mainly display, again, text--has close to 10,000 lines of Javascript that it loads. 
Nice try MS. Still not switching to Windows.
Can you post an example of this? I'm confused. Thanks
Hmm I must admit to follow some of these patterns, namely the short circuiting, `something &amp;&amp; somethingElse()`, never realised this would be considered a hack. And I get why Boolean magic can be harmful, but doesn't having a doubled payload in method names to remember also come at a price.
Fractaly's example is built on the idea that you can figure it out by repeatedly asking "what's the biggest coin I can add to my stack without going over the number?". All you have to do is clarify that to be "what's the biggest coin that hasn't been picked more times than it exists, that I can add to my stack without going over the number?". You can choose to modify Fractaly's example, or implement the algorithm yourself instead of modifying his. Since logical thinking is pretty central to programming, I'm not going to give you code - you'd learn little from that - but rather encourage you to sit down, think over how to implement it, do it and test it.
Once you get used to it is fast enough. The advantage is that it has WAY more addons than Sublime, and making and managing addons is very simple. But yeah, if battery life is an issue it might be a problem as sometimes it uses more CPU than it should.
These are all red herrings. You've not really talked about the bypassing semantics of resolve/reject at all. I could also go through all of these issues one by one, and show you why they either aren't correct, or just don't matter. But I'd hate to encourage this behavior.
That syntax gave me cancer.
&gt; dependencies listing in the top of each file is very-very useful for big software and for team-working. You can still wrote one line / dependency to be git-proof Same with WebPack+babel. Though the syntax is considerably more robust and cleaner. Compare: define("math", ["thing1", "thing2"], function(thing1, thing2) { function inner() { } return { add: function(left, right) { return left + right; } } } To import thing1 from "thing1"; import thing2 from "thing2"; function inner() { } exoprt function add(left, right) { return left + right; } And that's ignoring the other ways you can use [import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) and [export](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export). &gt; wrapping all files in one file, as the other frameworks you can build a final js file with r.js and then load it with a very minified version of RequireJS if your builded version doesn't need async. Webpack does this by default. Though it also allows code splitting, where you can designate certain modules to be bundled into a separate file (for caching, etc). &gt; you can use it same on front and back, which I do (instead of standard node-require) You have two options here: require the files directly from a node module, or use Webpack to create a server bundle. The first option is easier, though the second option is more powerful if you want to use features of Webpack such as custom module resolution options. Either way, it's as simple to do this as it is in requirejs (though much more powerful). &gt; on front it's good to force your team to preserve the global scope and don't throw things inside when you are in front of an architectural problem (something that lot of people forget, it's easier to go nasty sometimes and requireJS prevent this) Every module in Webpack is, by default, isolated from the global scope. If you have an ill-formed module that you can't change, however, you can [shim](https://github.com/webpack/docs/wiki/shimming-modules) them in. &gt; you can easily make 2 config files (the one listing all dependencies you know) and set a different path for the same dependencies, letting you the ability to call the required one depending on the platform (exemple, if you want to build for Android and for iPhone and for browser, well you can have generic code and for the non-generic parts, you only change the path of the dependency in the "iphone-config" etc, and when you build with r.js it take the good dependency automatically which avoid to load unused code. I'm not sure exactly what you're saying here, but you can certainly create multiple Webpack config files that resolve different modules to different locations. &gt; and of course you can build your application and load async dependencies depending on the usage of the user (something I already done, loading the main-app non-synchronious, then if the user ask for other features it load other builded-files and when all is loaded, all dependencies can talk and require each others). Webpack has this feature out of the box. See: [code splitting](https://webpack.github.io/docs/code-splitting.html). **Conclusion:** Webpack does literally everything that requirejs does, and much more: * load in non-JS modules without a second thought as to weird pathing issues (styles/audio/images) * load in modules right from NPM (goodbye bower!) * powerful compilation step for styles and scripts * hot module replacement - supports hot-reloading styles without any additional work, and also has plugins for hot-reloading react components * super-quick compilation times, even on large projects, _with_ sourcemap support * powerful module resolution options so you can lay out your project how you want without having to fight the filesystem * very popular, with decent documentation and community support * can load AMD/commonjs/UMD modules It does take time to learn the configuration options, but it's well worth it. I've used both in applications, and in my experience, while requirejs was easier to get going, it caused many problems down the road. Once you get a stable Webpack config setup with the proper loaders, you can pretty much be certain that everything will work fine both in development and production.
This sounds like the NP-complete [Knapsack problem](https://en.wikipedia.org/wiki/Knapsack_problem)
every api call is executed when it is called.
thanks i'm new at coding and i think you're right, 
You seem to be asking about two completely unrelated things. If you want your code to be notified when elements are added or removed from the page, then use a [mutation observer](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver). It is very flexible; you can listen for changes to a specific node, or to a node and all its children. If you apply that to the root of the document then you can monitor the entire document, although if you can confine yourself to a specific subtree you'll generally tax the browser a lot less. You can also specify the exact kind of mutations you care about, such as attribute changes, text changes, or node additions/removals. You can also use polling, but that's a nightmare for performance. None of this has anything to do with local storage. I don't see what that has to do with making changes to nodes that are dynamically added to the document. 
Don't have much of a story haha my first name is Saad and my last name starts with a Q
So I found this. Readline();//**Reads a single line of input from stdin, returning it to the caller. You can use this to create interactive shell programs in JavaScript.**// So does this mean, the variables n and temps will be read in stdin? What exactly is stdin (standard input)?
Awesome! Please make another post when you do, since I removed this one.
You should at least use a VM ...
I guess my point was if you wanted to solicit feedback on an idea, it might be better to go close to that source rather than here. 
The only thing I could see local storage being used for is storing original values? No idea, just a shot in the dark as to what it would be used for.
hey thanks for the reply :) when i was talking about the the local storage i was talking about a chrome extension i was looking into to try under stand how it works, anyway i found this http://pastebin.com/VfmnayQk and it works to replace text in most places but things that load after just stay the same as you can see here http://imgur.com/l1u0XiU you can see in the red box the text changed, im guessing that if i added the observer it would fix it but i cant find out how to add that, sorry im new to this and iv looked around and understand most of it but i cant work this out :P
Wish they were half as good at standards support.
I actually develop internal front ends. It's a 100% Linux environment, so no worries. I also auto prefix and only use ES5. My comment was intended as tongue-in-cheek. Much like the top level.
I feel like I read this same headline every 6 months or so, but it never seems to translate to the real world. edit: from May 2015: http://www.windowscentral.com/microsoft-edge-already-beating-ie-chrome-and-firefox-javascript-benchmarks from 2013: http://www.cnet.com/news/microsoft-claims-massive-speed-boost-in-latest-ie-11-build/
And won't be available on Android or iOS so it's moot. Doesn't matter how fast it is. Opera is the fastest browser but nobody uses it and it's available on all platforms.
I actually develop internal front ends. It's a 100% Linux environment, so no worries. I also auto prefix and only use ES5. My comment was intended as tongue-in-cheek. Much like the top level. For some even greater irony, my front ends launch VMs...
Well this is Reddit, any time you go against the grain, you're going to get beat up for it. But yeah, if it's an internal app, push your browser pref by all means
I care less about speed and more about debug tools. And the speed of debug tools. 
It feels backwards when you LEARN it but when you USE it feels natural.
If you look at the calculate prototype/function, it takes in an object and a function. In this case the object is it self. The function is a callback which has two parameters a + b which are basically values from an array. 
There are a ton of online resources for learning JavaScript. Udemy.com has sales on their courses often, but even YouTube has a lot of good tutorials. But I really enjoyed reading this book: JavaScript and JQuery: Interactive Front-End Web Development https://www.amazon.com/dp/1118531647/ref=cm_sw_r_cp_api_ix2BxbGRFDH10
Check out Codecademy.com. It's a really great program and completely free. If you want to learn more about front end development check out Udacity.com and the front end web developer nano degree (you can take some courses for free here, but the nano degree is $200/month - but they do help you find work). 
As a hint: parseInt takes a second parameter, which represent the number system. It is better to provide it to prevent unexpected results: parseInt(readline(), 10)
It is bytecode like our most beloved technologies Java and Flash :|
and from our perspective here, specifically as */r/javascript* developers, we can be happy that they are trying to get people on to a new OS/browser with better, consistent standard support. That makes our jobs easier. (not saying I don't come up against Edge-only bugs -- but happy not to have to support ancient IE workarounds)
Are you novice programer who doesn't know how to program, or you a guy who knows how to program and looking to get into js waters? I like how naive other answers where!
Totally agreed. There is a link in article to his comment, so I hope nobody missed this.
That's a fair argument. This is good and all, but very few websites are bound by JS performance.
Because MS try to create this image that they have caught up with the other browsers, by adding cutting edge features, while they still miss features other browsers added years ago. 
angular2 is newer and less documented, but man the typescript integration makes it a shocking joy to learn with your IDE supporting you throughout the process of how to use it. react is the bigger player at this time, and has a HUGE and wonderful community around how to manage your views, state, etc. angular2 is newer and has yet to have this community, but their multiplatform support and integrated type checking with typescript is, in my experience, is amazing beyond expectation but the choice comes down to you! react will have more open source tools and best practices at this time, but we will see what happens as angular2 is fully released and the community starts building up the ecosystem around it! it is quite exciting frankly and having built multiple production project swith angular2 already I would personally seriously recommend it! edited: grammar
That's hard to believe, because Opera uses the same platform as Chrome. So page rendering/js execution should be basically identical to Chrome. Only difference could be performance of the shell... which usually isn't a major issue. Also, the only full browser truly available on iOS is Safari. All other browsers (including Chrome) are a UI wrapper around Safari.
It looks like they did pretty much start this one frmo scratch, i dont think theres any IE in it.
Thanks a lot, bookmarked.
Yeah looks great, and affordable too. thanks for the help.
I would suggest you Heads first javascript Programing as your first introduction, or javascriptbook.com(either one). Later on you can take some of udacity FREE courses. After that codewars for 3 month.
Very interesting! Are there any benchmarks on how it performs compared to ASM and normal JS code? Even something simple like measuring how much time it takes to run doubleExp a million times for example.
Most of the time, it feels like Firefox is the new IE.
Like what? 
Not when it does what the standard web specifications say it should do?
Angular2 or React aside, in most cases a relational database (such as PostgreSQL or MySQL) works better than a NoSQL. And even if your data model is more suited for a document database, [RethinkDB](https://rethinkdb.com/) is a much better choice than MongoDB. 
Yeah, I'm using it mainly as a development target, just like Firefox back when FireBug was the only decent development console around and classic Mozilla back when Venkman was the only option. Safari is my default browser, has been since its 2.0 release and I use it for all the everyday web browsing, since it renders quickly and has a low energy impact and doesn't use much resources for the gazillion pages I keep open.
I'm pretty sure Safari is the new IE.
It's always better to have fewer browser headaches when finally tweaking the MS browser in their respective virtual machines.
I find myself switching back and forth between Firefox and Chrome pretty frequently because their dev tools have different strengths.
+1 for RethinkDB over MongoDB. Stellar database, and pretty easy to deploy. I usually use the [rethinkdbdash](https://github.com/neumino/rethinkdbdash) driver as you get the connection pooling for free.
In our evaluation we eventually chose [Vue](http://vuejs.org/). We initially had React in mind but then we glanced over Vue just for getting a complete picture. It the easiest to learn and handle, while being every bit as powerful as the other two. Vue emerged in a comfy spot between Angular and React, learning and cherry-picking from both. It avoids their obvious pitfalls and encorporates their strengths. Reason why we prefer it over React: it does not fight HTML and CSS. That was critical to us. You *can*, if you want to, use JSX, render functions and inline styles. A .vue component still felt more natural to us and we still enjoy the benfits (reactivity, components, routing, redux, etc.). Reason why we prefer it over Angular2: it is written in ES6 and embraces modern Javascript. It doesn't throw you into complex boilerplate, getting up and running is a matter of seconds. If you have an issue, the documentation and community-support are great.
I tried but I couldn't figure it out ;P. I'll try again until I got it !
Then we're probably using a different set of features. My strategy's always been about using the lowest common denominator, which has saved a lot of headaches. Most of the compatibility tweaking I deal with are in event firing differences and memory constrains of mobile browsers.
No extensions, this list compared to Chrome: http://caniuse.com/#compare=edge+13,chrome+51
Why would anyone want to disable paste on password fields??? Sry if it was explained on the article I cna to read it...
It's as if they think you can only interact with their backend through this UI. And that it is impossible to inject custom code, capture, and/or edit the running code before and after requests. Certainly hackers would strictly stick to the rules and confines set by the client UI. /s
A proper dev console. Cross platform builds including mobile. Sync among these platforms. Real world extensions, here and now.
Looking at the code is far different than using the code. The people who work on javascript engines don't need to look at Microsoft's code to do the same thing.
Thats the question the whole article tries to find an answer
You can go on GitHub right now and look at prs. there are a number of active prs from non-msft tagged people. So, yes, Microsoft will review your code. You can run the benchmarks yourself... I did check edge vs chrome on octane, and edge won. It didn't look like as big a gap as the graph in the blog, but I also am looking at the stable versions instead of beta ones.
Can you maybe help? I have been trying for about 1,5 hours now and still can't get it. I am currently here: http://pastebin.com/2t4vMzf3. What I'm trying to achieve is that if for example the requested amount is 6.44 it will add 6xRef, 1xRec, and 1xScrap, and that there can never be infinite loops. Help would *really* be appreciated, I've been stuck here for quite some time :/
[Here you go](http://pastebin.com/WdJGrfSn).
I don't really see the point of this tbh. It just seems like people are asking for a huge amount of added complexity, just to satisfy their irrational attachment to the file extension. Can somebody explain what the advantages are?
The real answer is that it depends on what you are planning to do. And on your background and how much you are used to enterprise software and or functional programming, especially the ideas about mutable state. I develop apps in both, and here's how I pick one or the other depending on the project: - Angular, simplifies big time the interactions with extensive APIs (restangular ) and will definitely feel more familiar to ppl with a J2ee-like background. If the customer is a Java shop, angular wins. - React is quick and easy to learn for people exposed to functional programming. It's great for apps where there is not much state to manage. It lets you do easily Amazing things, but you might find yourself struggling with the philosophy. I pick React every time I can. So to summarize: if you are not used to immutable state pick angular 1.5 with ng material design. Otherwise pick React.
&gt; It didn't look like as big a gap as the graph in the blog Which should give you pause. Nothing Microsoft gives out ever matches reality. And "a number of active prs" compared to how many submitted? As I said, "open source" to companies like Microsoft are a marketing buzz word with no foot in reality.
No opera started using blink a few years ago.
Wow thanks a lot, you're awesome ! :) I've added remainder = Math.round(remainder * 100) / 100; After the remainder is set so it adds a Scrap if there is 0.10999999 left. Thanks a lot! :D
Correct. The changed from Presto which they've been using since the 90s. Chrome is one of the new kids on the block.
 this is the bug `if(confirm){}else{} doclick()` one of the conditions should either trigger the loop (click) or cancel the loop. should probably be `if( !confirm()) { doclick() }` or ` else { return }; ` would also work (cancels the click by returning)
Sync across platforms is why I use Firefox. The other features I can't say I care much about. 
guessing from this i would say `Window()` is an internal browser API that builds a window object? `window` is where everything on screen is stored * ex if you type `var foo = 123` then `window.foo` it will show 123 (so its the namespace all global variables are stored in) * window is also where `window.document`is stored. document aka the html nodes. im sure youve seen `document.body`.. its the same as `window.document.body`, and `document` may just be a C++ pointer to `window.document` 
youtube has tons of great tutorials, i like 'building a flappybird clone in vanillajs' (or jquery or react) 
If the goal of the project is to get something done, as opposed to learning something, then try to stick with what you know. It will let you focus on building the product. If you're already switching out the backend from php/mysql to something new, then switching out the frontent as well for something you don't know won't do you any favors. If you do want to learn a frontend framework, then i would suggest a full-featured one like Angular or Ember. Learning a pick-and-choose style framework like react+flux will take much more effort and time.
Fortunately, this is an issue I've actually had to tackle; basically, the process goes like this: * On the frontend (web app, mobile app), use the Firebase SDK to do a login * From the returned Auth object, extract the JWT token * Use the JWT token for further requests to your own server * The JWT includes in the auth'd user ID * You will need a JWT library to validate the JWT token is signed by Firebase * Make REST API requests from your server In terms of making requests from your server, you have two options: * Use the user's JWT token to make requests; you can then take advantage of Firebase's inbuilt auth handling system to restrict read/write access to various objects * Use a server token to authenticate with the Firebase API with full access. That puts all permission checks on your ASP app, to ensure the user is permitted to access whatever objects they request. 
You can just toggle the "hidden" property (which is reflected to the "hidden" attribute). It's not supported by IE10 and below though. button.addEventListener('click', e =&gt; div.hidden = !div.hidden ); https://jsfiddle.net/zb9uc5x8/ See also: http://caniuse.com/hidden https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/hidden
I think field masking is also a pretty antiquated concept that people don't think about. It's of limited value and one could argue the ability to see typos or chopped-off paste input would be of equal or greater value.
Funny, I've made a [chrome extension called Analgesic](https://github.com/Apercu/Analgesic) to deal about this and track links a few days ago since it pisses me off. You can also look at the DontFuckWithPaste one, with this only purpose
"Force", freedom isn't something forced upon anyone.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/meteor] [How To Parse Remote CSV Data Without "Access-Control-Allow-Origin Header"? : javascript](https://np.reddit.com/r/Meteor/comments/4pxzlt/how_to_parse_remote_csv_data_without/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
And here I was crying out loud that iOS safari broke again. Turns out it was those sites blocking paste functionality!
If you want to load it dynamically, add a script tag to innerhtml of the body in your existing JavaScript code. This should cause the browser to load the file.
Creating the http requests without the ui at all.
Your issue is with "PapaParse" downloading your data from the Client. Your Server should be able to use Meteor's [HTTP](https://docs.meteor.com/api/http.html) to fetch the data and then use whatever you want to parse it.
Well you definitely should do that since you'll run into issues sooner or later. Running a simple http server to serve your files is not hard.
Hmm you should probably watch some basic html tutorials on youtube like: https://www.youtube.com/watch?v=3JluqTojuME
In my CSS I currently have the class and ID 'irc' defined in my CSS with display:block You're saying including the style tag in my div, causes it too ignore the properties i set in the CSS?
No, masking passwords keeps people behind you from seeing what you typed. We used to have to ask everyone to turn around while we logged in. The dark days. 
Hey its me ur browser
For real. It actually made me close the tab once and circumvent it via JS browser console another time.
It takes a truly terrifyingly stupid person to think that disabling pasting of passwords is somehow a security layer, or even a benefit to users what-so-ever. I want to be clear: people making these kinds of decisions likely get paid *more money* than people who know what they're doing.
That's an interesting idea.. I tried #1 quickly, no dice :( #2. Brilliant. this works 100% thank you! I can fetch using http and then parse the file locally. Kudos! 
Eh, yes, it is. The freedoms of others defines where your freedoms end. And the freedom to have property is considered only legal, if it is used for the benefit of society, in most European countries. (Take the German constitution, for example).
I like that some sites or apps (especially typo-prone mobile) will give you the option of showing the password, but I'm also in the camp that it should be masked by default. For the same reason the ATM doesn't show your PIN.
This is called "mental gymnastics".
Don't rely on JS for content?
&gt; Initially downvoted because I assumed I hope this caused serious self reflection on your future voting habits.
No, I don't. I have JS content which is not crawlable to Google. I am looking for a way to solve this.
Move the Papa parse to the serverside code. Is it a dynamic CSV?
No.
I meant the content generated by JS :)
It's so goddamn annoying when people do this. It completely circumvents being able to use a password manager. Since I have to type it manually each time, instead of a long randomly generated password, I'll tend to use something weaker for these sites.
You are probably correct. :(
Well done. This is pretty awesome. 
what do you use?
Yeah, Google supposedly simulates some stuff, but you're really going to need to make sure the content is there if you have JavaScript turned off. Server-rendering is basically necessary.
If I understand correctly, Edge not implementing new APIs as fast as Chrome has to do with Microsoft waiting until there's a standard defined so that their implementation is stable and compatible with the rest of the world. Have you ever noticed how many experimental APIs Chrome has? Some of them have already been deprecated, but Chrome can't remove them because some web apps already depend on it.
Can you make your question more specific?
That comic is bad simply for the fact it's using IE9's logo to criticize what was characteristic of IE8. Since version 9, IE actually started becoming a decent browser (shocking, I know).
&gt; IE IE is no longer in active development (I guess it might be getting security updates, though). You can't ask for IE to have ES2015 features when the focus during 2015 and 2016 has been on Edge.
The concern is that websites are able to hijack the data in your clipboard. The hope is that you won't be inclined to copy the data if you aren't able to do so. The problem / catch-22 here is that a user doesn't know about this until after its copied. I better solution would be to use the HTML5 clipboard / setData API to clear out the clipboard after someone pastes into a password field.
Saying that's how React works is a stretch. It's something you can do with React but saying that's how it works is inaccurate.
should be in the sidebar.
I occassionally paste passwords and I always "flood" my clipboard after I paste to avoid such issue. Also I don't think websites have a native way to read your clipboard (flash does I think)
For a second I thought this would be a guide on how to disable pasting and prepared to express my utter rage on the subject. *Sigh of relief*
Machine code is low level instructions, specific to a given cpu architecture, made up primarily of mathematical instructions, memory operations, and jump instructions. High level languages operate on higher concepts like functions, recursion, built in operations for memory management and other things. High level languages need to be compiled down to machine code to run, either directly, or inside some interpretted enviroment, where a native program actually runs the high level code. Now, this WebAssembly is an intermediate step. It turns high level js (and later other languages) into low level forms that are still logical and NOT specific to a particular cpu architecture. Then, the running program just has to do the final conversion down to the specific cpu architecture to run it.
I use two-ply. Single-ply just doesn't have the tensile strength to keep from getting poo on my hands and more-than-two-ply is just superfluous fluff.
yeh, simply setting display:block in the style tag seems to have done the trick. thanks!
Any freedom for one person is a restriction for another person Light can not exist without shade, and shade can not exist without light. The job of our democracy is to find a balance between each freedom and each limitation. And no, you're not free to kill people, cause you go to jail for that.
That's literally React's original purpose, and the entire reason that `react-id` exists.
You can see for yourself. https://github.com/Microsoft/ChakraCore I don't understand why you have such a visceral reaction.
Could you please provide me a source? I'd be surprised that it's actually it's literal purpose since I've been using it for a while and I know it to be practical for so many other purposes.
node's file i/o library has a handful of synchronous file manipulation functions. If they aren't deprecated then they should be at least discouraged in practice. 
I was going to fume. Thankfully, the article was the complete opposite of what I expected it to be about.
I flat out won't. My immediate response to this article was 'Fuck off'.
&gt;Non-standard event defined by Microsoft for use in Internet Explorer. &gt;C’mon guys, we’ve been down the non-standard implementations in browsers before and it always ends in tears \*cough\* box-sizing: border-box \*cough\* 
Whenever I encounter this, I paste the pw into a texteditor and drag&amp;drop it into the pw field. Actually, I do this after I reevaluate if I really need to use a site with such retarded policies.
It also breaks the rule where security is done on the client side. It doesn't work that way with web software...
&gt; Freedom for someone is the lack of Liberty for someone else? Yes.
This is how spammers abuse form api's to send spam. They don't load the page, or rather they do it once and then just echo the same form fields with spam again and again. Generate and send them a key with an expiration on your end and validate on that.
At work, sometimes I have to develop crawlers to get data that sometimes are in the JavaScript code. It is always a pain. So far I came up with 3 different solutions for this problem: 1. Run the code that has the information that I want in a controlled environment. 1. Try to parse the JS code. 1. Render the page with JS before extracting the data. All 3 have problems. If I could talk to the developer of the page to solve this issue, I would ask to put data in the JSON format and write functions that take that data as an argument. To answer the question, I think Google uses the third solution sometimes, but somehow limited, but I don't know the details. So make sure you at least put that data in the DOM.
Sure, Chrome is newer. But Opera changed from Presto to WebKit, which Chrome was using, and then changed to Blink when Google forked off of WebKit. So I think I'm accurate in saying Opera uses the same engine as Chrome, and not the other way around.
Please don't do this!
&gt; The claim is that you cannot determine an es module from a commonjs module, which seems sort of far fetched to me. Well how would you determine one from the other? Is this a CommonJS module or an ES modules: module.exports = { foo: 'bar' } export default module.exports Additionally you want your reads to be fast where as writes can be more complex in this case since you'll be doing a lot more importing than you will be writing those files to disc. If node had to generate some kind of AST to make the determination between ES or CommonJS modules every time you imported something you would probably notice a significant performance hit.
Force... That's the thinking that led to BREXIT for the EUSSR...
&gt; Force... That's the thinking that led to BREXIT for the EUSSR... Force is also the only thing that keeps multinational corporations from fucking over consumers, that keeps the tories from privatizing the NHS (in fact, the leader of the leave campaign said he’d try to privatize the NHS anyway), the only thing that keeps the European internet market from becoming the same as the US with Comcast and Co fucking over people. And calling a democratically elected parliament and council "EUSSR" shows how you have understood not a thing about how the EU works.
Validate your HTML. It's not as exciting as JavaScript but it's crucially important to get it right.
Exactly! If you're unfamiliar with CSS specificity then you may want to check out the [MDN page](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity) on it. This particular concept is explained in the [Selector Types](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity#Selector_Types) section: &gt;Inline styles added to an element (e.g., `style="font-weight:bold"`) always overwrite any styles in external stylesheets and thus can be thought of as having the highest specificity Glad you seem to have got it working for you though! :D
You might want to research these 2 a little more, as they accomplish very different things. Meteor is a full-stack JS web app development environment, whereas Electron is a framework that lets you create desktop JS apps. I've seen cases of people developing Electron apps using the Meteor environment. If you're interested in desktop apps, check out NWjs as well.
I think you should try reading the article again.
Google is capable of crawling some JS content. They've been discussing the capabilities in their developer docs for the past two years or so. Conducting a fetch and render as google through the webmaster console will give a decent sample of their JS rendering. I think they recently released a headless Chrome to the public as well. For reference: https://webmasters.googleblog.com/2014/05/understanding-web-pages-better.html That said, rendering on a server and picking it up on client side is a more robust solution.
Your code is trying to act on an asynchronous api as if it was a synchronous api. You'll need to do something like: var entries; document.querySelector('#fileChooser').addEventListener('click', _ =&gt; { chrome.filesystem.chooseEntry({ 'type': 'openFile', 'accepts': [ {'extensions': ['jpg','png','gif','pdf']}, {'description': 'Images'} ], acceptsMultiple: true }, openEntries =&gt; { // Build up an array of promises for files let filePromises = openEntries .map(entry =&gt; new Promise((resolve, reject) =&gt; entry.file(resolve, reject))) // more succinctly //.map(entry =&gt; new Promise(entry.file)) // Wait until all the files have been opened (the promises have resolved) Promise.all(filePromises).then(openedFiles =&gt; { // Set the entries global (no idea what you're using this for) entries = openedFiles.map((file, i) =&gt; ({id: i, entry: openEntries[i], file: file})) // Template out the content. I don't know the api you're using so .filename is made up document.querySelector('#list').innerHtml = entries .map(({id, file}) =&gt; `&lt;div class"row file" id="file_${id}"&gt; &lt;div class="three"&gt;${file.filename}&lt;/div&gt; &lt;/div&gt;`) .join('') }) }) }) Edit: after re-reading your sample, looks like I got the format of `entries` wrong on the initial pass. 
I second the vue.js recommendation. Vue.js 2.0 should be out soon. 
It's freaking annoying as hell on mobile. I use lastpass so I have super awesome, complex passwords. When I copy the password from lastpass and then go back to the web page (and some apps do this as well) and try to paste it, I can't. do you know how big of a pain in the ass it is when you have 18+ character passwords that are a combination of letters, numbers, and symbols? It's enough to make me not use the service - which I've done unless it's something that I HAD to use like a bank or something.
Would something like [this](https://m.reddit.com/r/javascript/comments/4pryy6/showoff_saturday_june_25_2016/d4nk11d) work for you?
Yep, that was it
It can be. It's worth noting though that the simplest configuration (just bundle my JS, no changes) looks like this: module.exports = { entry: "./entry.js", output: { path: __dirname, filename: "bundle.js" } }; Which isn't so bad. Everything else is just building atop this.
So, if I'm a user and I want to paste my password then I copy it followed by pasting it into a browser. That may seem fine, but let's try to find a way to exploit this behavior. Let's say like I create a site called example.com, and example.com has a button to "Login with Twitter". When the user logs in with Twitter, we can then read their clipboard with flash after login finishes. If the user copied their password for the Twitter login, then example.com can leverage this specific attack to steal your Twitter password - and authenticating will also give them your username. Another example is that maybe you login to Twitter and you click a link to a news site on there. The news site steals your clipboard and logs it as a potential Twitter password since it knows that Twitter was your referrer (or maybe it does this without even caring where you came from). These are two specific attacks that I have just made up, but I'm sure that there are other ones. However, this is still a UX issue and the user will still copy it even if the password isn't allowed to be pasted. This is why I would suggest that it is more secure to let the user paste their password, but then use the HTML5 clipboard API (with a Flash fallback) to set the clipboard to an empty string after a page occurs. I wouldn't be surprised if Facebook already did this in their native app (and maybe web as well) since they read your clipboard whenever you open the app and try to automatically suggest things for you to post based on its contents.
very cool! Thanks for the explaination. I've been reading up about the HTML5 clipboard. I've been aware of the flash method which is not ideal as flash should burn in a house fire.
Node cache's all requires IIRC, so a 1 time read hit is nearly meaningless. How would you determine that line of code? Easy. You see exports default and you assume it is a es module. You opt to the newer module system if it is ambiguous.
It also breaks the rule that security features should improve security, not degrade it.
&gt;having built multiple production project switch angular2 Just curious, how do you keep up to date with angular 2's breaking changes and router?
Yes and no. Some validation on the client side can enhance usability to allow for quicker feedback. As long as that is not used as a substitute for backend validation 
Depends on what you're building, most of my apps are SPAs with a high amount of shared functionality. If a large library is only used by one part then it makes sense to async load but as the different parts are generally just templates which are very small it's easier to just bundle everything (and take advantage of better compression) Images are generally the bandwidth killer, I rarely bundle these. 
I just check the changelog from time to time, they are good at documenting breaking changes in big bold sections for each release https://github.com/angular/angular/blob/master/CHANGELOG.md
I ran the command and now I have all of your generated passwords!
I think he was just agreeing with whom he replied to
No, this is most likely cygwin then. Try if cmder does the same.
well thanks for this advanced answer can't ask more :) I'll have to test all these features with a pooc. And when you say it's isolated from global scope (of course it is by default in a NodeJS environment) but if for example you are working with NW.JS, asking for a front dependency and typing window.something throw an error or what ? If not, You name a new variable but this variable isn't in the window by default ? So Webpack is encapsulating the file in a private scope right ? (doing for you what rjs ask you to do when typing the define, function scope). I tested browserify and wasn't satisfied, will give a try to this one with a complex environment. I will rapidly know if it has some advantage (syntax evolution isn't to me a big point to deal with, when your RequireJS config is set once, you can use it for everything. Difficulty is to learn how to config stuff and if I can't do what I want in an after-noon I leave it aside, because it's not worth it anymore since my configs files today are okay). For example I had the case with my gaming engine, I build the engine with r.js and I have the "engine.js" compiled file. This file need an amd-loader. Then I want to work with this compiled file (for the engine) and all other files not compiled yet (developing), so I got a double require. Order is important. And when I compile the final file r.js, I have to load first the compiled engine then all files and compile all together. It took me few days the first time to get it achieved, and even if there is few interesting features, I'm not sure it'll be on my advantage to switch for this project excepted if the config became easier. I'll see it quickly anyway.
Actually Google will crawl any XHR url if you don't use robots.txt to block paths. Crawlers are stupid so if you have the path stored in a var, that will result in a 404 error. Eg: xhrObj.request(data, basePath + '/user/info', function (response) { // parse response }); You will see in Search console that the mofo didn't even see the value of basePath.
No! We need more. If it's not EXACTLY the right tool, we go make a new one.
Client side is usability, not security.
Well, key logging. There is a difference between capturing a CTRL+V instead of a real password. Of course a good key logging tool would probably have low level access to much more memory level stuff - so it could easily grab the contents of the clipboard too... I think passwords are past due - and the baseline security policy is to include MFA. So even if people know or steal your password, you have something to fall back on. 
Doesn't use semicolons in the code examples. Too hipster for me.
 eslint . --fix Instant awesomeness.
Thank you for the recommendation! Didn't know that there are already boards that actually run node. How cool is that? I will definitely try one of these! I'm the author of that post, btw.
As I said, Microsoft is famous for issuing "paid for by" releases like this on their own that later proves to be false. And "IE7/8/9/10/11/Edge is the Firefox/Chrome killer!" You can't trust Microsoft.
I wrote this script a while ago (getpass being a small wrapper to a password manager): #!/bin/sh pass=$(getpass "$@") || exit printf %s "$pass" | timeout 60s xsel -nip &amp; printf %s "$pass" | timeout 60s xsel -nib &amp; Within a few days I found myself needing this: #!/bin/sh getpass "$@" | tr -d \\n | xdotool type --clearmodifiers --file - The more people build stupid things like this, the more I find myself building even stupider hacks to work around it...
I see a constant stream of questions asking about how to use Angular that I'm of the belief that it is the epitomy of a library/framework that has reached the pinnacle of too complicated for all human understanding. But I also find a lot of these questioners rely too much on the same libraries and frameworks and lack understanding of the fundamentals, too.
`createClass` accepts a~~n `initialState`~~ `getInitialState` function that gets called once when the component is mounted.
[standard](https://github.com/feross/standard/) or [semistandard](https://github.com/Flet/semistandard) give you this, and have SublimeLinter contrib plugins.
Love this framework, it's one of the few Node frameworks that use principles from big "standard" frameworks like Laravel, CodeIgniter, Ruby on Rails, Django, etc.
I agree, 2 byte (or even 2 kilobyte) size improvement doesn't matter if the page loading stalls. Thanks for making your tests!
This is my bachelor-thesis. Hope someone finds it interesting.
It really depends on the complexity of your app. Basic views and the UI don't require too much js. The data you will be processing is the harder part. Depending on what technology you're using, you will need to learn some angularjs or jquery. Basically you won't be needing more js than you would need to build a website / web app with the same functions.
Yes it's possible — If possible make them local though or save them in a cache.
I think the problem isn't so much NG2 as the advent of transpiled to-JS languages (typescript, ES2015+) and their associated build tools and bundlers and what have you. If you're using any of the more popular new JS frameworks you'll have the same problem. People forget that you can use NG2 with ES5 as well even though most of the samples use typescript.
the high volume of dependencies and separate files in most projects today creates way too many requests if you don't bundle. for example, angular 2 with material 2 base projects contain ~600+ individual files if you don't bundle. this cases a page to take ~15-30 seconds to load even when hosting locally. When bundling the load time gets down to a few seconds. You can set up lazy loading zones with some bundling tools, such as webpack or jspm, so it will load chunks depending on the routes that are hit in your web application. it's confusing but that's what we have to deal with for now, since http2 is taking it's sweet time.
Well, for me, I don't like putting extra attributes on the DOM. I prefer generating the elements in JavaScripts then appending them to the DOM. But you could have a wrapper on the element with methods to accomplish some of that. var bound = el('div').bind(myBoundObject).forEach('cars');
I don't agree, GitHub offers the right tools for discussion and contribution - even for single binary distributions. However, i'm presumably going to hand in the LaTeX-Code once i am convinced that there are no legal issues with my licensing.
I built two very small projects with AdonisJS and had some issues with both where the author's advice was to switch to the dev branch of 3.0 (about a month ago, didn't know release was so imminent then). This doesn't inspire great confidence when it comes to LTS. The main problem was that there are so few people out there using this framework that you'll probably run into an issue you can't fix via Google sooner rather than later. So while it seems like the learning curve is less steep than ExpressJS, it can bite you in the ass in the long term. Apart from that, I have to say I liked the overall simplicity and clear structure of the build, and if I had some more experience with NodeJS I might be more inclined to use it again. As it stands, I feel like a novice user like myself is better of just going with the flow and using Express.
Github == Free web hosting. They even [advertise](https://pages.github.com/) it.
After working with a Meteor code base, I would not recommend the framework. I don't think it's mature enough (Meteor tried to do a home grown dependency system away from npm), and there isn't canonical ways to do things. If they improve things in a year or so, I'll revisit my opinion. But as it stands, I will not be doing `meteor init` ever again.
One of the best comprehensive guides for learning JS. I'd fiddled for years, but it wasn't until I read these that I started to appreciate JS as its own special snowflake language. 
check out https://cordova.apache.org/ , better licensing. more info: https://www.quora.com/What-is-the-difference-between-PhoneGap-and-Cordova-and-why-would-I-select-one-over-another
For open source projects. Which this hardly is when there is no source 
maybe /r/mediumdeviation can't read, therefore not understanding the advertisements :(
On mobile, I cannot open the PDf, I get "cannot open file" with both the Drive PDF reader and FBReader's PDF plugin. Maybe it's a mobile thing, I'll try again on my desktop when I'm home, but just wanted to let you know.
do you need any prior Angular knowledge or a good understanding of vanilla js is enough ?
Yup! I believe the whole framework is based on Laravel, it's a nice transition from PHP to Node compared to a bare boned Express or Hapi.
God bless Chrome timeline.
Correct, but you gain usability by duplicating simple validation on the client
Kinda late posting but I finished enough of my reddit client called [imggit](http://www.imggit.com) to do a soft launch last week. I built the server using Node.js and the simple front-end with plain old javascript and a few calls to jQuery. Tried to keep it simple. I query the reddit API for whatever subreddit the user clicks on. Then I try to find an image for each post using a couple different methods (direct link, thumbnail, or scraping link for a primary image), crop the image to a square (actually hard to do automated composition detection), and then I use websockets to notify the client that an image is ready to display. If I can't find an image, I just hide the post. I also utilize some caching so that the next user to retrieve that subreddit page will be delivered the cached images (with a ~5min ttl). It seems to be working so far.
The code is only "ambiguous" because someone decided to write terrible code. I don't consider that a real situation that should be supported. The article made it sound like it is impossible to determine es module or commonjs module at all. I also don't actually consider this ambiguous. The parent who provided this "ambiguous" code was trying to prove you cannot determine es module or commonjs. My hardline view is that you used es modules, you get es modules. If you never intended es modules you wouldn't have used the syntax. JavaScript itself supports things that look ambiguous. If I write `if (x == null)` it is ambiguous if I intend undefined to work here, which is why people advocate to only use `===`.
You'll definitely have to check angular first. I dived straight into angular 2 which is a complete rewrite and it was also the first framework I learnt. It is very intuitive and the official tutorial should be enough for a simple app. Then you can head to Ionic which makes the use of angular even simpler (such as navigation, bootstrapping, etc).
yeah this looks convincing, hi browser
TIL. Brilliant sentence. Thanks.
Expected '===' and instead saw '=='.
Hey, I hope this helps, but I tried to run ghostscript over the thesis since that often fixes bad PDFs. Here's the result: https://github.com/xcthulhu/Modelling-A-Purely-Functional-Subset-Of-ECMAScript-2015/raw/master/thesis.pdf If you would like to use this trick at home, assuming you have ghostscript installed, you can type: # gs -q -dNOPAUSE -dBATCH -dPDFSETTINGS=/prepress -sDEVICE=pdfwrite -c .setpdfwrite -f broken.pdf -sOutputFile=fixed.pdf
Yup, works! I'll read it later, thanks!
Ok cool. Ill look into it! I mean, if it does super lazy loading using promises, I'm sold!
Have you actually tested this in a real browser? Again, the bundle means nothing if your initial bootstrapping is 10% of that bundle. I would agree that the granularity of these modules creates a lot of requests in total. But that static granularity could be used to your advantage. 15-30 seconds? That's absurd. Did you make this number up? Is it because your local host only serves on asset at a time? A CDN will stream multiple simultaneous assets and a modern browser allowed for 8+ requests pre-2010. Lets go back in time to the days of 28.8kbps... Even if you had only one stream, would you load and initialize all your code up front? Or would you progressively load a minimum to improve user perceived performance?
Javascript will add twenty new functions and classes and symbols and features. Just because.
He should really use strict mode and LINT. 
As someone who never got around to hopping on the Angular train, what's up with NG1?
X-Post referenced from /r/node by /u/joshmanders [Node.js application boilerplate for rapid development.](https://www.reddit.com/r/node/comments/4q44nl/nodejs_application_boilerplate_for_rapid/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
TIL only GitHub.toString() evaluates to "Free web hosting"
do an npm install my good man
Someone else already has sum issues up very precisely, so I redirect you to the following article: https://larseidnes.com/2014/11/05/angularjs-the-bad-parts/
Yea, on second thought it doesn't make sense except as an option because of screen sharing, etc. being so common these days.
Thanks, i merged the pull-request.
I don't get it. Is this like a nodejs laravel?
I disagree, I use functional js where I work and the result has been fantastic, but also caution extremism. There will be times you need performance and you should fall back to imperative code when that happens. Otherwise, I'm excited for shared memory with Web workers. Looking forward to putting concurrency control to use
Thank you! Still no lovin' cheddar, though. I added the `npm install` step (which by the way, reported nothing) followed by `npm start`. Along with the previous message, it provided this: (which I really should have included in my previous post.) npm ERR! adonis-app@3.0.0 start: `node --harmony_proxies server.js` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the adonis-app@3.0.0 start script 'node --harmony_proxies server.js'. Am I like a complete idiot or what. Funny thing is that I haven't had much trouble with trying out `Node` with `Electron`. Maybe my set-up is wonky.
What is the actual issue that _you_ are having? It looks like internally, Safari's sort is different from the others, but it still sorts the elements in the correct order. NOTE: The arguments are _not_ reversed or anything. Safari is just using a different sort algorithm.
How the array is actually sorted is implementation defined, i.e. different browsers may use different sorting algorithms and there's no guarantee that your compare function is called in the same sequence across different browsers.
Thanks for persisting with me on this. Still in a satisfaction-free situation. I'm on a Mac (Yosemite 10.10.5 if that makes a difference.) I'm running through `zsh`, also if that makes a difference. I'm wondering if the `--harmony_proxies` switch is expecting some configuration that I don't have, or if I need to do something to `server.js` for my environment. Sorry about this, but I hate giving up without understanding why.
Hey don't even worry about it. Seriously there's not one thought going through my head questioning your intelligence. Been doing this a long time and you would laugh out loud at the mistakes I've made that cost DAYS of hang ups.
~~https://www.npmjs.com/package/fetch~~ https://www.npmjs.com/package/superagent
What is 2.5MB? The raw bundle? Is it minified? GZip'd? 2.5MB is pretty tiny if it's raw. I'd imagine that minifies down to around ~500kb, and then gzip's further down to ~80-100kb depending on how the files conform/repeat.
Hi /u/floppydiskette, This post was removed. For posting links, please use the "Submit a new link" option, and if you wish to add some text, just submit a comment. Thanks!
I'm not sure about replacing CSS with JavaScript but, as the exploding number of CSS compilers/pre-processors fortell, CSS is widely considered harmful. It is truly awful at layout (vertical centering, anyone?) and hostile to style reuse (can't define reusable font, color constants, etc). If the article had simply said "CSS is ripe for overthrow. Good riddance", its prediction would be a sure thing.
&gt; here will be times you need performance and you should fall back to imperative code when that happens. There are plenty of functional programming languages with great performance. In fact, for distributed computing, functional code is much better suited. I don't see at all what performance increases you get from imperative languages over functional languages. Perhaps you meant to be comparing interpreted languages like JavaScript against compiled languages like Java? I also don't see how anyone can say that imperative languages are at all less legible than functional programming languages. If anything, the verbosity of some imperative languages allow you to paint a unidirectional picture that is much easier to keep in your head than the potential callback hell you can end up with in some functional languages. Functional programming is powerful and elegant; but it's not inherently more legible or worse performing than imperative programming.
You could also just use window.fetch and polyfill for old browsers: https://www.npmjs.com/package/whatwg-fetch
I think that has the funny name "hingleton", or "helper singleton". A class / factory function / abstraction mechanism wouldn't enforce its own singletonness, but rather some other function would. // Not a singleton class MyThing { thereCanBeManyOfMe() {} } // A helper singleton (aka "hingleton") const getThing = (/*iife*/() =&gt; { let instance return () =&gt; { if (!instance) { instance = new MyThing() } return instance } }()) As for passing in "defaultState"... sorta yes, sorta no. State should be treated as private and encapsulated. But what you can do instead is take ordinary arguments (that don't assume knowledge of the internal state) and let the constructor / factory function initialize its state appropriately.
I kind of feel like more functional aspects of javascript are a good thing. But to go fully functional is not realistic. If someone wanted to go all the way functional they should just pick up ELM.
And be ready to embrace a clusterfuck of node_modules/ folders and 55.000 files for a Hello World application
Vue.js built a place for css right into their components. That feels like a nice compromise. Though you better make sure your sourcemap is setup when doing development otherwise you'll never find your styles. 
My web dev career got going around 2005 and at the time people were exalting the virtues of separation of concerns so maybe I am a bit indoctrinated and I haven't delved into React yet (or something similar) but I plan to soon. Could someone explain why it's now acceptable to embed CSS into JS now? This was absolutely frowned upon not that long ago. Is the CSS actually written in the JS code, or is it just using classes/ids to hook onto? If the CSS is directly in the JS code, how is it overridden elsewhere? Can it be overridden?
I use [XS.js](https://gist.github.com/plugnburn/9229beaadbe23819f118) when I work with modular JavaScript projects (modular interfaces can withhold their own styles and configurations until required...) but I don't think this is what the author meant when wanting to write CSS within JavaScript.
Not sure. I'll try to check when I've got some spare time.
Ok, thanks. Also how would you make the close minimize and maximize visible 
I like xhr or xhr-promise https://www.npmjs.com/package/xhr-promise
I'd say JavaScript is quite well suited for FP, especially now with arrow functions. It's a little presumptuous to say that at some point on the FP-OO spectrum you should switch to elm. You should only switch if you want what elm gives you (such as static types, although typescript/flow are good options now), but you can go far enough using JavaScript to reap some serious architectural benefits and simplify your code a lot without losing performance.
Out of the box, fetch is very limited compared to $.ajax. I've used fetch on a few projects to save size, but I really miss the simplicity of $.ajax, furthermore $.getJSON('file.json', function(res) { console.log(res); }); is a lot more readable to me than fetch('file.json') .then(function(res) { return res.json(); }) .then(function(data) { console.log(data); }); Fetch also behaves funky in some cases. Ie it won't reject a promise if the request returns a type 400 or 500 error message, like you would expect if you're used to jQuery. When I use fetch I always end up writing a lot of helper functions on top of it just to keep my code sane. I.e.: https://gist.github.com/Ahrengot/26761d02ff3260b27237b4efc89fdab9 
i would not use fetch. its 400 lines of code and does require() http https zlib and 6 more packages i used this idk. its 10 loc.. based on`google stackoverflow jquery ajax() replacement` function ajax(url, cb,err) { var xmlhttp = new XMLHttpRequest(); xmlhttp.onreadystatechange = function() { if (xmlhttp.readyState == XMLHttpRequest.DONE ) { if (xmlhttp.status == 200) cb( xmlhttp.responseText, xmlhttp ) // else if (xmlhttp.status == 400) { } else err(xmlhttp.status, xmlhttp) //should be xmlhttp.responseText for 2nd? } } }; xmlhttp.open("GET", url, true); xmlhttp.send(); } ajax('/bar/api/', (data,x) =&gt; alert(data), (status,x) =&gt; alert('error '+status)) just to save a few kb. witha few tweaks (add `POST` method) it worked well for me
How do you deserialize them to instances?
I see a lot of awesome choices. I haven't seen Axios listed yet: https://github.com/mzabriskie/axios I found it very easy to pick up.
I'm talking specifically Javascript's functional paradigm vs imperative paradigm since this article is 100% about javascript. It is well known that map/filter/reduce is far slower than the for loop (We use lodash implementations which are far faster than native, but even they cannot compete with the native for loop, although it seems some JS engines are changing this so this may not always be true), and immutability is slower than mutability due to the sheer nature of cloning your data (I understand immutability is not something specific to functional, but functional languages tend to be built around immutability. JS is not, but it has immutable constructs and libraries) As for readability, I don't touch this argument because it's completely subjective. I use a linter, and ensure all my variables have sensible names. Under these rules, functional code tends to produce better stories than for loops do, but again this is semantic and I would rather not waste time on a discussion that doesn't better anyone.
See my response to aradil
I agree Angular 1 is straightforward but only if you can figure out how the features connect together on your own since its docs and tutorials are ridiculously difficult to comprehend for any new user getting into it. I only managed to understand Angular 1 after doing a project of my own using it and that took a great amount of time of trial and error to figure out. After that, it's really easy to use and I'm glad I was able to figure it out. But... Angular 2 is like repeating the nightmares I had when learning Angular 1. I really want to learn it now but I might have to hop off its train if it gets to a point where it's just not coming to me.
You can't. Thats why I didnt mention deserialization. Wasn't trying to say this library is useless, just adding more information.
Thanks! &gt; Like /u/nicfolai said, it depends on what you want to make. I should have mentioned this in my post, sorry. Here's what it should do, Have a form that has a few text fields (name, email, phone) and an image which is uploaded by the user and reaches my email box. &gt; Phonegap simply gets your HTML/CSS/JS and bundles it up into a downloadable app Well, I've tried it out with a few existing webpages and it works wonderfully. &gt; Phonegap has some JS libraries to help interface with device hardware, like the camera and storage etc. I don't need all that for this particular app but to use them would I need to know any JS library?
That's a very clean solution 
Dang, looks great! Any idea how this stacks up against [MoJS](http://mojs.io/)?
Ahh I see what you mean. Sounds useful then! I'm used to working with singe page apps where it's all asynchronous so we never have to worry about that. If you have any use-cases or "before and after" I'd love to read it
&gt; As for readability, I don't touch this argument because it's completely subjective Then you won't touch 50% of his argument in that paragraph, in which case do you really agree or disagree at all with it?
Ah, that is surprisingly easy with typescript since the compiler will point out to you any breaking change that has affected your project. Then you just need to take a peek at the changelog which typically has good documentation of how a class or method changed (before and after) so it's pretty straightforward from there The company I work for already has multiple angular2 projects in production and the breaking changes haven't been much of a problem frankly. Since angular has been on rc1 the breaking changes have been pretty minimal and upgrading it and any packages dependent on it (e.g. we use ionic 2 as well) usually takes less than 30 minutes every few weeks It's certainly more work than being on a project with a fully stable API, but it hasn't been much of a pain point to update for us frankly
&gt; And when you say it's isolated from global scope (of course it is by default in a NodeJS environment) but if for example you are working with NW.JS, asking for a front dependency and typing window.something throw an error or what ? It's similar to how requirejs works. You can still access "window." to get to the global scope, but variables defined in your modules aren't added to it (it wraps each module into their own private scopes in the compiled code). I haven't used NW.JS before, so I don't know how it handles module loading.
I second this. Awesome library. One of my faves. 
that's what the [observable](https://github.com/jhusain/observable-spec) spec is intended for. besides, if you need to roll your own cross-app communicator, [here](https://jsfiddle.net/ouxppckc/1) is a toy example i cooked up in ten seconds that you can work from.
How does this compare with greensock?
What's hard about what? I just don't want to use Ajax since I no longer use jQuery. Right now I just XHR, and it works just fine, but I heard there is a reason why people use ajax over XHR, I can't remember why, but there are reasons. 
Looks very complicated :s
The idea behind it is to separate by concern rather than technology. I think it depends on the project, but having small modules that are self contained and reusable is a benefit that some people find by using react, etc. If the markup, styles and interaction are all within the same file, there's no file searching necessary to make a change to a single component. I'm not advocating for or against this style, I personally find it useful in some circumstances but also have projects that would end up being a maintenance nightmare with this approach. 
zepto
On the subject of superagent, I also recommend [superagent-promise-plugin](https://www.npmjs.com/package/superagent-promise-plugin). It's the one missing piece.
You can do that right now with template strings and a bit of DOM manipulation... If you ask me the build steps/overhead of preprocessors are considerably less of a pain than just writing everything in javascript. I tell you what I'd like to see: native less/sass processing done by the browser. That would turn my head and given the 5-year span seems totally plausible.
I'm sure it does! Especially if you have to load all of them up front! :| 
&gt; I also don't see how anyone can say that imperative languages are at all less legible than functional programming languages. Come on, mathematics have been working with better ways to express complex equations for hundreds of years and FP uses those concepts in programming. I am sorry for using the authority argument, but really there is no way someone can explain the benefits of FP if someone have never worked with a lot of imperative entropy. The human brain did not evolve to understand complexity. &gt; When an application is composed of expressions and devoid of side effects, truths about the system can be derived from the parts. -- Equational Reasoning That's what I mean by "legibility".
^ My only concern.
The author meant that something will come up out of the mess, the same way React/Angular, npm and jQuery came out of the mess, but for writing CSS in JavaScript, whatever is the paradigm or the way it is being done.
Can I make a new season of Cowboy Bebop with this
I understand that for many applications functional programming can result in plenty of bite sized chunks that are easy to understand and much more legible. But modeling complex structures and processes that are inherently sequential is much more suited, and legible, in systems designed to handle such things. I'm not saying that there are some systems which can't be more legible in functional programming. I've written plenty of code that is more succinct and understandable in functional languages than it would be in imperative languages. But most programs can solve problems in an iterative fashion without the confusion caused by the indirection of functional programming. I've been part of a hiring process designed around finding developers capable of grokking functional programming; those with a math background excel at it, and are often able to do great things with functional design. But it is fairly plain to see that the majority of young developers can much more easily understand imperative languages easier. Is that not a statement on it's readability?
Here's probably a good place to start: https://developers.google.com/maps/documentation/javascript/examples/event-simple#try-it-yourself Assign your marker to a variable, then add that listener.
I think it's time to code this scene. Get all the npm modules together. Okay, three, two, one let's jam.
Don't hesitate to shoot me a message if you have any questions!
Use them. A lot. Write lots of code and keep looking things up until you don't have to anymore. If a bunch of kids can memorize all 151 Pokemon, you can remember all of the features of a programming language. You will never stop looking things up. After time the language features will become second nature. However, the real complexities are in the myriad of libraries that you need to use. Google is your best friend here.
Yes, Google which often leads to StackOverflow but use SO as a secondary resource and try to Google the actual documentation if any. For JS I have had great results with the Mozilla Developer Network (MDN?). Also try to stay away from w3schools. They were food once but now have lots of samples with bad practices. 
For syntax -- where you place commas, semi-colons, parens, new lines, etc. -- you just have to learn it, which should come naturally as you practice coding. Since JS is a C-like language (just one of [many](https://en.wikipedia.org/wiki/List_of_C-family_programming_languages)), it borrows a majority of the syntax from C, just like Java, C#, and PHP do. But just keep learning and practicing, it'll become second nature after awhile. The various objects and functions you interact with you'll just have to google, and that will probably never stop no matter how long you program. You'll learn some that you use a lot, but it's not as important to know each of them by memory as it is to be aware that they exist. Just be sure to learn the correct terminology, since the quality of your search results will be directly correlated with how well you can write a search query.
That saves one byte. This saves 3: onfontready = function(fontName, onReady, options) { I'm not sure how I feel about these since they are implicit. They could mean different things in different contexts. But then, nothing stops the end user from overwriting the `window` variable.
&gt;you need to clear your timer and start it again from its original interval. I see! I will try it out!
Hi /u/battlmonstr, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `dobegin.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [dobegin.com](/search?q=%28and+site%3A%27dobegin.com%27+author%3A%27battlmonstr%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|21|91% [self.learnprogramming](/r/learnprogramming/search?q=%28and+author%3A%27battlmonstr%27+is_self%3A1+%29&amp;restrict_sr=on&amp;sort=new&amp;feature=legacy_search)|1|4%
Have you ever seen any Elixir code? It's a functional language (impurely so) for concurrent processing on the ErlangVM, and has a great deal of language semantics that make it easy to write sequential code. You don't have to use recursion in Elixir, ever. In fact, I'd go as far as to say the 'best practices' way is to use the enumerables libraries to map, filter, or reduce with functions rather than doing so with simple tail-recursive calls.
You ruled out PHP and jQuery in a single line. Bravo.
JavaScript could turn into a fairly decent language in 5 years. WebAssembly could give us some choice of languages. All good. But the DOM and CSS will become an even larger pile of crap, until it is replaced by something more suited for what people are trying to do with it. That probably won't happen in 5 years, but if we're lucky, maybe in 10. In my imagination it would be replaced by a layout engine based on constraint satisfaction, where some of the constraints are inherent in the device, and some are specified by the web developer. CSS media queries are an attempt to get at something like this, but they lack generality and are limited by CSS itself. Ideally a distinction would be made between layout and style. And it should be possible to skin a web page without breaking its layout. The main obstacle to overcoming DOM/CSS is the dependence on browser vendors to create an alternative. For one vendor to strike out in a different direction is just too risky, so they all just try to incrementally improve DOM/CSS. Virtual DOMs and canvas could provide a way out of that. I think it's only a matter of time before someone (probably not a browser vendor but some random hacker) renders a virtual DOM to canvas instead of the real DOM. Then it will become clear that the DOM itself is a representational (if not speed) bottleneck. 
Yes, that's correct. The `()` at the end is the key. The outer function is an IIFE (immediately invoked function expression). This happens as part of the definition of `fibonacci`, before you get a chance to call the function (which is whatever the IIFE returned.) 
ajax is xhr. What are you talking about? 
Just as an aside to how it's called, it also makes a closure over the `memo` array - it's doing [memoization](https://en.wikipedia.org/wiki/Memoization) to help make the subsequent calls faster. Mainly so that the `fib(n-2)` part of each run through will be nearly instantaneous with just an array lookup.
Is there a reason you seem to need your comparison function called in a predictable order?
I don't have anything for you here, but I'd be interested in the answer. I'm using sql.js but it's pretty limited in terms of being extensible. No ORMs or abstractions like sequelize are built to handle it.
&gt; I don't need all that for this particular app but to use them would I need to know any JS library? Nope, not for what you want. I mean unless you want something to do form validation for you. Something like that. &gt; Have a form that has a few text fields (name, email, phone) and an image which is uploaded by the user and reaches my email box. The only thing I will say is you will need a web server running with a script to send your email. The phonegap app would then do an ajax request to this with the information entered by the user. You can't run any server side stuff with phonegap.
I mentioned it right near the beginning of the video, just get rid of "frame:false" in main.js. 
Thanks again! &gt;The only thing I will say is you will need a web server running with a script to send your email. The phonegap app would then do an ajax request to this with the information entered by the user. You can't run any server side stuff with phonegap. A few questions, 1) This script that is running on the server- is it built using JS? 2) Will the data entered on the form be sent to this script which then emails it to me?
awesome! this is what I need ;)
this guy knows.
Well done man. I will definitely give this a try.
This is another plugin, might be this will help you to get shit done :) http://maplacejs.com/
Not sure what is being said in "use comments in JSON". The example doesn't include a comment at all, and comments are deliberately not valid in the syntax. They were in early drafts of the proposed standard (see https://plus.google.com/+DouglasCrockfordEsq/posts/RK8qyGVaGSr) and some parsers support them, but not all so they break interpolarity unless filtered out (as mentioned in in the above link).
The main purpose of AVA (Agnostic Virtual Assistant) is create a clever/fast assistant for any kind of context. This repository concerns the core of AVA so feel free for try in your NodeJS projects. Nowadays we can find a lot of assistants, and more and more in coming years, all of us know that Apps in future will be more conversational and less click/action. For that reason our approach is create an agnostic and reusable system for help developers to create any kind of virtual assistants.
&gt;Could someone explain why it's now acceptable to embed CSS into JS now? This was absolutely frowned upon not that long ago. It is still frowned upon, except by those who evangelize this ~~practice~~ abomination. 
Well, I thought so because my method was returning unexpected results accros browsers. I have however made some changes that made it work accross the board.
This is awesome! I threw together this really fast using it: http://kingofthewifi.com
Thank you guys for your help! Really appreciate it :D! 
Also Haskell, amusingly.
This is weird, but if you capitalise `testComponent` then it works. Seems to be a thing judging by http://stackoverflow.com/questions/33259112/why-do-components-in-react-need-to-be-capitalized 
Oh... well that is something which I totally missed. Thanks a lot!
Thank you for posting the question. I had no idea about this and it could have cost me a LOT of time debugging.
Thanks
Why not just use `.filter()`?
Note that you can use lowerCase if you use `React.createElement(testComponent)` instead of JSX. https://jsfiddle.net/fa4kkg37/1/
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
Makes sense actually. I never thought about that.
Nice set of resources. Thanks
I don't want to downplay the significance of React.js I truly love the project but the idea is really simple. Maybe not obvious at first but it's not groundbreaking. All they are doing is shifting part of the burden on to you as a library user. Which is fine by me.
Yeah, functional readability can fall down just as fast when devs don't have good naming and pay attention to single responsibility. And when devs -do- both of those things, imperative styles aren't all that horrible... so...
What a surprise, he included his own book in the list.
oh! very nice~
I converted this to ES6, https://github.com/SaulDoesCode/anime I also added a build system
Mine too
It is #4. *Shrugs*
Thanks! I found the exact info I was looking for from your docs page! &gt;Event delegation: React doesn't actually attach event handlers to the nodes themselves. When React starts up, it starts listening for all events at the top level using a single event listener. When a component is mounted or unmounted, the event handlers are simply added or removed from an internal mapping.
Your problem is that your buttons have multiple ids. Remove the 'play' id from the buttons and it should work
You don't need jQuery and it's actually really simple to play a sound: check out this fiddle https://jsfiddle.net/2ottdbm2/
Looks pretty decent for a first go at games with JavaScript :) Did you use any frameworks or just pure JavaScript? I love making games with pure vanilla JavaScript and I always end up having weird collision problems when I go for free moving games :/
excellent stuff - are you open to pull requests for us to add new stuff as well ? :)
Here is a revised version of your code snippet which works for all the buttons: http://codepen.io/clementallen/pen/pbedjK
&gt; Having some knowledge of statically typed languages like Java or C# would be a huge help but isn't required. I built a 'Hello World' app to get started, and THIS was my exact thought when I was getting started.
Using ES6 classes, the `getInitialState` function is replaced by the constructor - just set `this.state = {some: 'object'}` in the constructor.
Excellent post. Thank you. Let us know how you did in the interview.
Head First JavaScript Programming I enjoy their style!
That reduce function would simply sum up all of the numbers. Not sure why reduce was recommended. Filter can be used to return a new array of only truthy values contained in the old array. 
You could do something like this function isAllTruthy(array, testFn){ return array.reduce(function(m,v){ m &amp;&amp; !!v &amp;&amp; testFn(v); }, true); }
This is a good collection for anyone who wants a structured way to learn JavaScript. Thanks for posting.
read the read me and look at examples from code pen
Sounds like [`Array.prototype.every`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/every) would be a better choice in this case. &gt; The **every()** method tests whether all elements in the array pass the test implemented by the provided function. var allTruthy = items.every(function (item) { return !!item }) ES6 Syntax: const allTruthy = items.every(item =&gt; !!item) 
Thank you so much bro 😊 
&gt;Why not CSS being done natively by the browser using JS? CSS is basically a mechanism to hydrate the DOM. The browser will always handle that deserialization &amp; hydration faster than a custom JS layer in between. Always.
Eric Elliott can have some good points but I really am not a fan because of how his writing is presented in a know-it-all manner.
you should definitely budle, minify and compress your assets. 65request, 10s until first meaningful render is too much.
In this post we will go over the current state of ES6 modularity, by learning how to use the Jspm package manager and its associated SystemJs module loader (the sample code is available here). We will go through the following topics: - Using ES6 modules today - Why is modularity important in Javascript - The Jspm package manager and how to use it today - creating a ready to use bundle with Jspm - The SystemJs module loader - Jspm vs Bower - Jspm vs npm - Conclusions
So in JavaScript, you can select elements that are currently in your HTML through a couple different methods (for example; by a direct ID, or by a tag (such as input) or by a class, etc). For a simple example, if you add an id to your input, you could use the following: &lt;!-- this is your HTML --&gt; &lt;input id="myInputID"&gt;&lt;/input&gt; // this is your JavaScript, note you'll need to load this into your HTML via &lt;script&gt; tag var someValue = document.getElementById('myInputID').value; I would recommend reviewing some tutorials out there to get you started on HTML/JS.
Depending on the type-conversion comparison you use (e.g. strict vs type, etc), JavaScript will do a couple adjustments to your values when comparing. So for example, triple equator (===) is strict and when you compare values (e.g. 1 === 1) it will check if the value and type are both the same, which they are in this instance (e.g. true). However, if you do ("1" === 1), then this will return false, because although they are technically the same value/text, "1" is a string and 1 is a number (so they are not the same types, thus false). If you use double equator (e.g. "1" == 1), then this will return true, because double equator only requires the text/value to be the same, and JavaScript will automatically convert the string "1" to a number for you (it tries to convert types when comparing correctly). So, going back to your previous question, null == 0 (false), this can be found under the definition of types on MDN: Null and Undefined Types are strictly equal to themselves and abstractly equal to each other. So basically, you just have to know their behavior (there's no real logic that null should technically be or not be equal to 0, etc - the JS spec. defines it's outcome). Check out more on operators here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators
I ended up doing a lengthier version of this with if and else clauses. I totally forgot about the !! coercion. Thanks! 
A minor nitpick: &gt; When projects get to a certain size, they will have to deal sooner or later with the 'dependency hell' problem. This happens when two different versions of the same library are needed at the same time. Dependency hell broadly refers to any of a variety of problems associated with runaway dependency management, such as: size, circular dependency chains, broken sub-dependencies, version collisions, duplication, and so forth.
 ._every = function(collection, iterator) { return (iterator === undefined) || _.reduce(collection, function(m, item) { return m &amp;&amp; itterator(item) }, true) }
Yes, I'm well aware of the difference between `==` and `===` :) That distinction isn't relevant in this case, though. Edit: I found the source of this behavior in the ECMAScript spec: When comparing two values with the `&gt;` or `&lt;` operator, and the values are not both strings, both values are converted to numbers first. Calling `Number(null)` returns `0`, thus `(Number(null) &gt;= 0) === true`. http://www.ecma-international.org/ecma-262/5.1/#sec-11.8.5
[This is a great article](http://higherorderfun.com/blog/2012/05/20/the-guide-to-implementing-2d-platformers/) on implementing collision detection.
Here is a quick start using just the standard technologies. If you need to dynamically create the input field, which means it is not already in the HTML, you do this: var myInput = document.createElement("input"); myInput.setAttribute("type", "text"); myInput.setAttribute("id", "uniqueString"); //optional, but generally needed for accessibility Now you will need to insert it into the HTML: document.getElementById("something").appendChild(myInput); //the .getElementById method is the fastest and easiest way to navigate to a point in the HTML //the appendChild method is the standard means of adding an element node to the last child position of some other referenced element. Now the field is added to the HTML, so we want to retrieve a value typed in by a user: myInput.value; //The current value of the element at the time of execution. //Please note that we are using a prior created reference to the inserted node instead of looking it up again. If you need to look it up again need to walk the DOM to the node, which in this case is as easy as: document.getElementById("uniqueString"); Also note that input fields demand an internal link to a `label` tag for accessibility. This could be: &lt;label for="uniqueString"&gt;Short descriptor&lt;/label&gt; or &lt;label&gt;Short descriptor &lt;input type="text" id="uniqueString"/&gt;&lt;/label&gt; or use Aria attributes, now you are risking discriminating against visual users. Here is some additional information about the DOM: http://prettydiff.com/guide/unrelated_dom.xhtml
No, you talked a bunch about strict vs non-strict equality comparison, which isn't what's happening here. OP used non-strict comparison (`==`) in his example, which already does type comparison. The trick here is that `&gt;` does special type comparison, which doesn't follow the same rules as equality - which you didn't mention, nor is it mentioned in the MDN page you linked.
My bad. Thanks for explanation, I'll fix it. It's still confusing that it probes the global instead of using my local (yet with the same name). Wrapping it into a function crashes as expected.
This release also seems to be accompanied by a HUGE update on the documentation! Just look at the curves docs: https://github.com/d3/d3-shape/blob/master/README.md#curveMonotoneX
&gt; Time is now frozen in the background Now all we have to do is find a way to implement this in real life.
I submitted a PR a few hours ago with 2 node articles, I'll let you know if its merged/discussed :)
However you want to interpret the question is simply your interpretation. I'm glad you an OP viewed it in the same manner. I gave more than enough information to resolve the issue: &gt;So basically, you just have to know their behavior (there's no real logic that null should technically be or not be equal to 0, etc - the JS spec. defines it's outcome) And then the next response from OP, "I read the spec". K. I'm done here.
So why do you x-post it in **JavaScript** sub?
document.write() won't really ever be used for general single-page app development (generally you append or manipulate the innerHTML property). Check out some tutorials, there's a lot you're missing out on by trying to skip ahead to just a working page example: http://www.tutorialspoint.com/html/
Sorry I didn't make it clear. This wasn't a question - I was just pointing out of a funny quirk of the language (of which there are MANY). For example, guess the result of this expression: `1+[]`. One of the mods must have tagged this post with the "help" flair - I didn't put it there.
Sure, we're going to show what we learnt in following blog posts, I'll let you know when we publish them
There could be anything in a box!
Uh, the title should've included: "when working with bytes" at the end.
I appreciate this. And I think it's great that you took the time to build this. What I think is anathema to maximal performance is using webpack to build this. If you were to code this in "vanilla", code optimizations would be more transparent.
Can't wait to curl up in bed with my phone and the new d3 docs.
[removed]
I like this one: “Even if you don’t do TDD, you should learn the principles that drive it. Working under new paradigms will turn you into a resilient developer.”
I take issue with &gt; Libraries and tooling can also be a barrier for new developers. I recently built a project using EcmaScript 7 (babel), only to later realize that our junior dev was getting stuck trying to figure out what it all meant. Huge toll on the team’s productivity. I underestimated how overwhelming that can be to someone just starting out. Don’t use tools that are still too hard to get a grip on. Wait for a better time. It's the responsibility of both the senior and junior developers to keep up with technology. It's hardly a stretch to assume that a professional _JavaScript_ developer understands, or is aware of, ES2016 (which I assume he's referring to by ES7?) and the build tools used to transpile its source. Forcing an entire team to bow to the lowest common denominator isn't "good code". I could perhaps see an issue if one developer decided to use PureScript or something; but ES201X is _literally the specification of the language that's in their job title_. It's not some esoteric compile-to-JS language with funky syntax. IT'S LITERALLY JAVASCRIPT. Whether you personally like the new features or not, not being up to date on the language you're _paid to write in_ is like an oncologist who hasn't read up on chemotherapy drugs that have reached the market in the last decade.
was gonna say, "stop telling me what to do"
It is pure javascript, no framework
this doc is truly awesome. I have a new project that will use D3 a lot. My last D3 project was still mid 2015. Can't wait to try this! 
This is impressive. Any chance of you releasing the code?
Right on! This was the solution. After removing the "\r" character the error disappeared. Thank you very much for the suggestion!!!!
Oh nice. Thanks for the heads up.
This is not just about using JS to change styles through the DOM, but a way to either transpile JS to CSS as React does with JSX or natively build something that can access the DOM just like CSS but with JavaScript. The first option is more likely due to the obvious limitations stated in the sibling comment of @cosinezero.
Just curious, since I don't really use bytes that often, what specifically are they useful in doing?
Unidirectional data flow is the key. Doesn't matter if you use redux or setState
brah.
If this is eye opening, I suggest you read some articles on what the hell is going on under the hood.
Impressive work. Cloned it. Will definitely take a look at this. Thanks a lot! You might wanna change the repo name, though. I don't see this going well
Hi /u/Jack_Ricardo124, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
The number one thing that steered our decision was SEO and server-side rendering. There's a project called angular-universal that looks promising, but isn't quite there yet. We're hoping it'll be stable in the next few months, or whenever they start supporting the new router, currently they only support the old router-deprecated version. If that's not ready in time for launch thrn we're probably going to spin up prerender.io server.
No, it's not on production yet. We just wrapped up the second dev sprint today, 5th sprint if you count foundation, UX and design.
https://github.com/walterhiggins/ScriptCraft/blob/master/docs/YoungPersonsGuideToProgrammingMinecraft.md Looks like you can use Javascript as well? Codecademy is good for that.. (https://www.codecademy.com/learn/javascript)
You should still be able to GZip that and see some really good results. If you can enable http2+gzip you could probably do even better in some browsers.
The Flanagan book changed the way I understand JavaScript. It has an easy to follow explanation and covers many nuances. I'm actually still reading it :).
Never received stickers from you. :/
&gt; https://github.com/vctrysam/Snapchat The first file that I looked at has completely weird indentation. Is this intended or something went wrong somewhere? https://raw.githubusercontent.com/VctrySam/SnapChat/master/App/Reducers/index.js
Awesome - maybe this'll finally trigger me to actually start playing with it. Also see [the release notes](https://github.com/d3/d3/blob/master/CHANGES.md).
Minecraft is **Java**, not Java**Script** - they are completely unrelated languages.
This is also worth checking out: http://todomvc.com/ https://github.com/tastejs/todomvc/tree/gh-pages/examples It contains a list of todo applications implementation in various JS frameworks.
&gt; What is the event loop? I like [this explanation](https://medium.com/@fay_jai/what-is-the-javascript-event-loop-98707ed20a90#.m2a9ifx1q).
Wow, this worked. Thanks man.
Thanks! :)
So far as I can tell, it isn't possible. The browsers don't support it, and there's no way to force it.
Ah that seems much more simple! I need to stop overthinking in JQuery. Thanks!
Perhaps the D in D3 stands for Dio.
Solution: Just don't rely on `this` in the first place ¬¬. You can do anything without having to rely on `this` anywhere in your code.
No you didn't... EDIT: Snapchat is a bit more than just some fancy looking frontend guys.
First, come up with an idea for something you'd like to make. Keep it simple. Second, Google "Hello world [JavaScript]" where "JavaScript" is whatever language or framework you're interested in. Third, build on that. (Note: if you're going to build for the web, take a second and learn about writing clean, semantic HTML.)
Thank you for letting me know it's an Eric elliot article. I won't be opening that link. 
Yep. I sure looked at Marionette, though never used it in a real project. It is certainly more handy than pure Backbone. But I am slightly concerned by the [sad state of the Backbone ecosystem](http://benmccormick.org/2016/03/07/the-sad-state-of-the-backbone-ecosystem/), so I am wondering if the new hot frameworks can do the same tricks as well. I am looking wistfully at how easily React re-renders child views when the data changes, and then I look back at our Backbone monstrosity where we re-render views manually, and shudder.
Do you know, when React or Angular2 are used with pre-rendered html, do they need to have run on the server as well? Are there any specific labels they leave in the rendered html that will tell them where to take over on the client side? *(Because my question is about* **not** *using JavaScript on the server side, but letting the backend framework prepare html on its own)*
Ember also does this with the addition of FastBoot. 
That's where marionette comes in. It goes a very long way to bridge that gap. I also look at React (and it's popularity) but we're so integrated with Backbone, that we just sort of "modernized" it with Marionette (and webpack). Marionette handles all the listeners and events, and cleans up after itself, and can re-render only single lines of collection views when they change. If you're good in Backbone, try a hello world in Marionette, or [TodoMVC](http://todomvc.com/examples/backbone_marionette/).
When you talk about producing SEO-specific content, how would you do that without JS having to erase it once it's loaded (which will be visible as a weird blink on the page)? Because it seems that if we put this content in a block with `display:none`, search engines may ignore this block entirely. &gt; You'd have to write everything in JS and whatever backend language you have, and then test everything for both, too. &gt; Alternatively, the backend guys will have to just accept that the only way to pre-render is with the same code that will be doing the final render because otherwise you do everything twice. &gt; And all of that is 10x worse if different people are coding the JS-rendered and backend-rendered html, too. I am with you on these. Looks dirty and redundant. Dunno if I can sway the backend people though :-(
Check out both [Code School](https://www.codeschool.com/) and [Codecademy](https://www.codecademy.com/). Free online tutorials for beginners.
I've done the Code School introduction for Angular, and it was fantastic. If the Javascript course is similar, it's where I would start if I were OP.
Not really, only with those simple stuffs playing around variables and if else and some copy paste editing things that is why it has been problem for me to catch the concept;
Perhaps this would be the simplest solution for you to implement: https://prerender.io/
jcready is probably right. if not: that error usually means you didnt JSON.parse() or JSON.stringify() the post-data or response data first. if that code is exact maybe i would use .innerhtml or .value or jquery: .val() or .attr('content').toString() my other guess is make sure your form is not missing any closing tags ex `&lt;/form&gt;` and maybe you have to serialize() your data. `data:data` is kind of weird without setting data in the `submit` function, are you sure data is a valid object? it sounds like one may be a html element not a `string/int/float`
I noticed that jquery doesnt select the appended forms even though I use ".on"
Lol. I had too much work to think about that you know? I was working for a long time to get this out
Lol. No you didn't
Why would I use this over Vue? Size?
Is the class (cart_add) you're setting the listener to the actual &lt;form&gt; element or is it a button/etc? The submit event will only fire if the listener is added to the form, not a button/etc. Also, I should add that you probably need to natively add a listener once you append (or create the element in JS and append it then, etc). I don't use jQuery anymore but I recall that one method to add listeners doesn't pick up newly added elements (although I think you're right that .on is supposed to) - either way I just steer clear of jQuery for these very reasons.
It would be nice to include a component created with raw JavaScript (to see why using a framework is easier).
Everybody is giving you pretty sad advice. This is easily possible. First off pick a templating library that works in your backend language of choice and the client side. Mustache is one that renders everywhere, we use google soy at work since it compiles to javascript and works well on the jvm. The next thing is to get your architecture right. You want your data which flows into your template to be the same data that you send down the wire or you will have to write a transposal layer in two places. The way we do this is modeling our data 1 to 1 with our UI's, which actually yields numerous other benefits. We have been prerendering like this since 2010 and our sites are tiny, super fast and work beautifully on mobile and desktop. 
[I think you can do this with Choo](https://github.com/yoshuawuyts/choo#rehydration) even though the docs show you how to do it Node. All it's doing is updating html at a selector though, so you should really be able to use any backend.
&gt; First off pick a templating library that works in your backend language of choice and the client side. In our case, the app is already several years into production; it's just that we didn't optimize for search engines from the very beginning, or rather that old optimizations are pretty much irrelevant now. So we already have two templating engines: on the client side, it's underscore’s template function (something very similar to ejs/erb I guess). The backend has Django’s templating language. Which is a bummer, because it does mean duplication of work :-(
TIL it can be called `kebab-case`.
I don't know if that would be the best thing to do for this specific case since the examples are pretty simple. Using vanilla JavaScript might actually be easier for these cases. I think libraries/frameworks shine more when the examples are more complex.
jsfiddle it and ull get more responses to me runsequence implies a series of events, youve posted only one event, is that the cause? i dont know probably not ;o but try two events. body may be undefined? try `$('body')` looks like the `p` key is double-nested, most runsequence are p: { foo:bar } you have p: { scroll: {offset: shift} } 
My first guess would be your table cells are rendered after the clickCell function is called, then there are no DOM objects with class .expandText
What are you exactly trying to do with the nextUntil method? I think that is likely what is holding up your code and there is probably a cleaner/less DOM-intensive method you can use once we get an idea of what you're doing.
handlebars?
It's another dependency. but I like to use lodash's _.cloneDeep when I have nested objects. I wonder if lodash's _.assign has the same behavior here as Object.assign? 
I thought that was the point, that they were self-describing? kebab-case snake_case CamelCase
This is the "shallow vs. deep copying" debate. The main problem with deep copying is that it is nearly always dependent upon semantics. It's easy to write a naïve deep copy function, but once we escape the narrow confines of a blog post, production code often contains things that should not be deep copied. For example, what if we have a list of employees, e.g. Alice and Bob? Deep copying this list clones the employee objects, so we get Alice2 and Bob2. Now what if each employee has a reference to a manager, Charles? Do we clone the manager as well, creating Charles2? If we do clone the manager, do we create Charles2 for Alice2 and Charles3 for Bob2? Or should Alice2 and Bob2 both have a reference for Charles2? And on it goes. It's quite usual to write specific deep copy functions for containers in a production application because such functions often have to incorporate business logic that is not universal to all applications.
if this is a click handler on a link etc, make sure you `.preventDefault()` or `stopPropagation()` on the event, can throw you off if you have `href=#` or no `href`. 
Thanks /u/mc_hammerd I am just reviewing to see what i missed. Before your response, I thought I should have removed it but it still did not work. I tried to create new functions but it was not working. I will work off your code. On to the next iteration 
Angular 1.x has a deep learning curve? Didn't take me too long (to transition from Jquery to Angular). Don't mind the setup that much, either. I guess I can understand. I liked Backbone for a while, but stopped. I like how Routing works in Angular.
Actually in that example you can get rid of the element completely.. component reuse happens in JS not in html...
Thanks! I didn't want to create a fiddle since it was more of a syntax question and thought someone would spot it. 1)This is only the event which is causing the issues. 2)body is defined since it works for the other events. Your last point about it being double nested. This might be the issue but I don't know the correct syntax for scroll. How would you write this using velocity and runSequence? thanks again. 
Do people really need a library for that?
No idea, haha. I just tried to make this super easy, because when I was trying out other boilerplates, I still had some sticky bits to deal with. I was aiming for being able to use React without dealing with babel/webpack
Is getData() an asynchronous function that gets data from a web source($.ajax maybe)? Then you should pass clickCell() as a callback for it.
Yes, of course http://monkberry.js.org/benchmark/
Examples are too simple to compare. 
the demo site is very slow for me...and there's not much there...what am i missing? 
No, because there are no ui libraries what meets my requirements: be fast and small. 
Better to use Ractive.js or Vue.
neat as heck
Step one is going to be learning to get good at googling, I mean this in the least offensive way; if you are unable to solve your problems through researching the interwebz you're going to have a bad time. Step one is go do some research and get comfortable with struggling to find the answers you're looking for, because there will be a lot of research in your future :)
This used to be true around 2000s, createElement was like 1 order of magnitude faster (or maybe even more). But last time I made some benchmarks (1 year ago), HTML string vs createElement were basically on par with each other - withing 2x range and heavily depending on browser / situation. So unless my benchmark was wrong or something changed again, choosing one or the other for performance reasons doesn't make sense anymore.
it will surely show how ridiculous it could be. it this less readable? less maintainable? &lt;div data-component="hello"&gt;&lt;/div&gt; or old school &lt;div class=hello-component"&gt;&lt;/div&gt; 
Hi /u/Nangsaigon, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `howtoprogram.xyz`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [howtoprogram.xyz](/search?q=%28and+site%3A%27howtoprogram.xyz%27+author%3A%27Nangsaigon%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|9|82%
Thank you for this
How does this compare to [Marko.js](https://github.com/marko-js/marko)? Both in features and performance-wise. 
You are copying an object, just not deeply. Usually this is what I want. Anything nested I'd want to maintain. Deep copy is, in my opinion, the edge case and is handled extremely well by user land libraries like Lo-Dash.
Do you mean like you pull something out of DB (data) and create an instance of some class initialized with it (models)? &gt; for some reason or other That kind of was my question :)
Coinbase has a great websocket api. [coinbase websocket](https://docs.gdax.com/)
Doesn't matter to me right now man. Do that in your version 
I think LoDash introduced that name, though it may be someone before them. 
Isn't it PascalCase and camelCase?
I'm the happy developer and user of https://github.com/kapouer/window-page which does offer a way to separate, in the most general way, route from build from setting up ui. It's not yet final version, though very close. I'm also using https://github.com/kapouer/domt, which is a pure DOM tool for merging data, capable of resuming a merge on already merged templates. This, with https://github.com/kapouer/express-dom, allows one to prerender on server and pickup on client where you left. Note that window-page also supports prerendering on client (e.g. the prerender visibilityState on latest browsers), and also note that express-dom is able to tell when the page has finished loading and running xhr, promises, and timeouts. You also get for free (well - at the cost of compiling the addon) pdf and png outputs if needed. These tools are not really frameworks: you still get to decide if you need jquery, semantic, or any other lib. I've been using them in production for a while now.
The FRZR pattern is nice. I use something like it right now.
Coming from Chrome's dev tools, this seems... unecesarry. [The native error display](http://i.imgur.com/JMSVU3B.png) tells me most of these things in a much more compact format, which is much easier to read: - It's an error, thus it's logged in red (and with a red "x") - The date is available if I need it, but doesn't take much attention since I usually don't - The filename/position is available to the right, and *is clickable to take you straight to the erroring code* The StackOverflow link *does* seem useful, but most errors are pretty self explanatory anyways. Definitely a fun exercise, and I can see its usefulness if you're stuck with inferior/no dev tools - but in most scenarios, it just seems to lack some of the features only native dev tools can implement. Once the on-screen logging is added, the usefulness will obviously improve greatly.
&gt; Your development tool should not dictate what language features you're using IMHO. Either should developers who like to chase new/shiny. There is something to be said for slow/sober adoption of new technology, especially when current tech is getting the job done. Chasing new/shiny can waste time/productivity too.
Who cares?
I'm appending raw html like this "append("&lt;form"&gt;&lt;/form&gt;");"
PascalCase is a subset of camelCase I think.
It's bugging me way too much that the button is `Add #{{ todos.length }}` and not `Add #{{ todos.length + 1 }}`
Because the code formatting sucks diaherrea out of a straw. 4 space indent for code? Cool. I indent 4 spaces and Ctrl+V the code. Half of it isn't identified as code. I didn't feel like adjusting every single line that wasn't right. Same BS with StackOverflow. I honestly didn't think anybody would give me grief about it
What a shit article. The reason flash was replaced was not security but that Apple did not support flash on the iPhone, and later Android. With more and more mobile traffic using flash for an ad meant missing out on a large market. Finally, no shit its not the technology but the advertisers themselves that ruined the ad market. A simple fix would be to not allow advertisers to run javascript, why do they need Javascript anyway(yes I know tracking but seriously).
It just says HTML5 ads aren't that safe compared to flash, which is true.
Hi /u/Gaurav0, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
This is actually a really interesting and unique approach to MV\*. Pairing a Twig templating language with some syntax inspiration from VueJS. The API seems minimal and clean, and I *really* like how you can treat Monk templates as pure ES2015 classes. I will give this a go for sure.
What does that achieve. No snooping on the ads?
JS in SVG for complex interactive animations
The way it is worded, the title implies that Flash is the more secure. Replace the words: "Fire isn't that safe compared to radioactive fallout." &lt;- implication: radioactive fallout is more safe than fire, when compared on safety.
Hi /u/hamstersjs, can you please post it as a link post, and then add your comments as a comment? Thanks!
Sure thing, thanks
I remember thinking like this when I first started out, after years you realize most clients aren't that pushy, maybe we're just lucky, our clients are more concerned with effective advertising than specifically getting something they want.. They get us to generate the idea, if we didn't want JS, which we do, we wouldn't suggest it. We rarely get clients who have ideas they want us to produce.. It's usually other agencies who come up with the fancy stuff and are looking for a vendor to facilitate the technical side.. we never argue with them either as it's not our client we have to provide for.
Hi everyone it's been a long time since i've posted, had to make this new account because I forgot my old one's login. Some of you may remember my library formerly known as webhamsters, over the last few months Hamsters.js has been going through some upgrades with many more to follow here shortly including a new website with proper documentation. One of the latest upgrades was react native support, essentially if you have a computationally intensive task you can now multithread that logic either by using multiple functions across single threads or splitting a single function across multiple threads. Only tested in android thus far but should function fine within IOS as well, all the major library functionality is working just fine. These features will be offically released when version 3.9 is launched in the mean time please make use of the dev branch version but note that memoization features are broken at the moment across all platforms not just react native as I am working on replacing that part of the library with a faster and more capable storage medium. Thanks!
bookmarked!
Yeah i've also had a lot of years but again different type of agencies than yours perhaps. A lot of the places I've been have clients who have decided what they want how they want before it gets to your plate and nothing will convince them otherwise. The clients who are lineant are always long term ones who trust you enough to make changes or push things because they know you follow their brand standards. And of course the client directly isn't always the pushy one but the chain is usually client &gt; client's sales team &gt; sales person &gt; art director &gt; client approval check&gt; designer &gt; approval check&gt; qa person to check brand standards &gt; ad ops person &gt; you. And it varies of course but when you want to suggest something you sometimes need to go all the way up the ladder for someone to listen , and by the time they do it's too late since a lot of the campaigns are due in less than 4 days. But yeah in saying that there was always the 10% that give the fun work that make the rest of the annoying stuff worth it.
This alone achieves nothing ... third party scripts can and do run over secure HTTP.
Should be `addEventListener("change")`, not `addEventListener("onchange")`... right?
It just sounds different out loud, imo. "It's not *that* safe" is implying that it's more dangerous than people think, but not actually all that dangerous either. "Jacob isn't *that* much hotter than Edward". It's ambiguous wording and should just be avoided entirely.
Sorry for the late reply on this. I'm fairly new to JavaScript promises. What are some good resources to learn about them?
There are some websites who are http only, because their ad networks aren't https capable. If the ad networks did https, the site could do it.
yea good catch, onchange is jquery specific.
I generally recommend [checking MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) when you run across an unfamiliar piece of frontend tech.
What's your position in the waiting-list?
Google "certs". 
Try [normalize.css](https://necolas.github.io/normalize.css/), or just html, body { margin: 0; padding: 0; } and see if one of the two options solves it.
I agree with this guy. I actually thought you replicated the filters in js.
I'm guilty of this too. We're such nerds lol.
can someone ELI5 what malicious, injected JS can do on your computer if it runs in your browser? Generally how are these vulnerabilities exploited? 
junior devs are the worst.
Twitter has a streaming API
You probably shouldn't learn this instead of React if your goal is to get a job.
If they aren't properly encapsulated, they can basically access all of your data on the specific site the ad appears on - as well as make any requests on your behalf - changing your settings, read all your user data. Eg. Not that this would ever happen because gmail uses text ads, but if gmail decided to give me complete javascript access to the main frame, I could read all the emails of every user that saw my ad. The ad could just loop forever and make your browser tab crash. Beyond that - display whatever malicious link they want - prompting you to download something. You'd still have to click it, but run it by hundreds of people and some of them will. Any reputable company will do the encapsulation properly, but there's a lot of terrible web code out there written by people who have no idea what they are doing.
innerHTML is fast in modern browsers. But still, browser need to parse html to create nodes, Monkberry templates a precompiled, so we can skip parse phase. But true performance come in there you need to rerender view on state changes. Monkberry is blazingly fast here.
Thanks! Will fix it :)
So you are a programmer ? You could add an event on the select box ( jQuery event on change for example) and the event handler would changes the value of pricebox. TBH nobody will want to look at a pastbin code, if you have an issue try to post examples via jsfiddle.net or pastebin.com.
Thanks! :)
Flash and HTML/JS are two different domains. While Flash is annoying, because Adobe never was able to build a secure base without security holes, JS and HTML5 are offering a lot of opportunities, because automation of elements are always easier to abuse. A fine example are the frameworks who makes it necessary to implement an scroll anchoring point in Chrome. The ad industry is on the verge to kill a lot of jobs, by offering unlimited ads for their customers. In some developed countries more than 50% of the better educated people are using an ad blocker because ads are annoying or a security risk. The answer to this trend are sometimes worth of being posted into /r/nottheonion , when publishers trying to ban ad blockers with the help of legal procedures or whining about morally depraved people, because owner of a web site can't earn money. The some people who are whining about ad blockers are those who are delivering malware and disturbing the process of reading by putting elements over the text. 
I meant mostly Angular 2, I have done some projects with Angular 1, it’s learnable but not that pleasant to learn.
What website operator would willingly take that risk? It's only penalties with no benefit. They simply wouldn't adopt. If a browser enforced it, people would blame the browser for breaking the site, not the site for breaking trust.
For your simple use case of eliminating duplicate code, there is probably little effective difference between the two, though any framework or render library will have some form of templating within it.
I really disagree, you get a glimpse of how at it's core level the different frameworks think about componetizing very quickly. I learn how Polymer does it without having to get read Polymer docs, as a passing curiosity. To be that's valuable, and the point. It's not looking for series A funding, its just a fun little app.
This isn't a component.
This isn't a component. Id's are unique.
I'll look into normalize.css. margin: 0; squares it up for the top left, but now the bottom/right is off by 30. padding: 0; at least evens things out to be the same amount on all sides. Thanks for the help! EDIT: Ok so right after posting that I found what I would consider the 'real' answer: First in the css: body { margin: 0; } Then, in the js, when trying to find values for the viewport it needs to be var viewWidth = window.innerWidth; var viewHeight = window.innerHeight; **NOT:** var viewWidth = $(window).width(); var viewHeight = $(window).height(); // nor: var viewWidth = $(window).innerWidth; var viewHeight = $(window).innerHeight; 
change the checkValidation function to this: function checkValidation(event) { event.preventDefault(); checkFirstName(); } the form is submitting and reloading the page before you can see it print out in the console.
wow u are the man!! Why do you need to pass a parameter of event tho?
Because you might want to know where the user clicked (for example) or where the user is dragging something. All this information is in the event object which is passed in by default in any event listener.
Why do all these Medium articles 404? I use the Reddit App on iPhone 6s. 
Make your own application with backbone from scratch. Follow tutorials, learn the ways of the framework. You are simply overwhelmed by the complexity of frameworks since you have not worked with them. 
Why not css in svg? There's better hardware support, and no need for gsap or snap or whatever...
css can't get mouse coordinates, something that is used quite a bit in ads for advanced hover effects.
Don't be afraid to ask questions at work. If you're a junior dev I'm assuming there are other devs working there who are much more familiar with the system that you're working on. Ask them questions. I'm always happen to explain things like this when asked, and unless your coworkers are dicks they should be happy too. You can't be expected to know everything, especially as a junior.
Be honest with you colleagues and team lead about the fact that you feel that you're progressing too slow, they will appreciate the candour and offer their help. I would also look at lynda.com and plural sight for courses on backbone, use their free trial and see the videos.
CSS can layer transparent objects that can then have hover states. 
the answers in this thread are good. i usually get a book on JS/backbone and keep it as a reference, and try to refresh myself one chapter per night. when stuck i google+stackoverflow the question, if i cant find it i ask on irc freenode.net. usually can get my answer in &lt; 60 seconds from really smart people. especially irc is great, rattle of 4 insanely hard questions and get 4 answers in 60 seconds.
i guess the other option would be `p: scroll, o: {offset: shift, duration: 1000}` i would try this first
In angular2's case there is integration with ASP.NET (and intentions to add other server-side run times) to run the JS server side during request processing to generate static html
I've struggled with a lot of these things myself and really agree with points 3 and, especially, 5 (I even specified one of my professional targets for this quarter was to work less!) I hope there's more acceptance/acknowledgement of the negative impact of overworking on any individual's output aswell as their personal wellbeing.
I've recently being doing a security audit of our 3rd party advertising platforms. I'm a front end developer and ended up down this route because I had to add a new 'sticky' (the ones that follow you scrolling) advert and it was constantly overriding my styles set on the container of the iframe it was supposed to render in. Strange, I thought, that it can set properties on it's parent outside the iFrame it's been rendered into. Turns out the mechanism the adserver uses to load in content gives them the ability to break out and get access to our main page scope. No one seemed that concerned in the business (the devs were) despite me spelling it out as much as possible. Oh, also turns out the mechanism is common practice to avoid a certain bug in IE 8 or something, so by fixing that one browser, they opened up a can of security shaped worms for every other browser.
My advice would be to do unit testing and check cyclomatic complexity, and then try to reduce that complexity to low levels. It's going to be a *huge* pain in the ass, and it'll take you a while to get good at them, but 2 things are going to happen. First, your code will be *tested* in a way like never before, and the stability will be amazing. Second, you'll be forced to code better. You'll have to work in smaller, more modular chunks in order to test it and keep the complexity low. It's not that you can't do it without these things, but they just happen to force you to do the things you already want to learn, and they give very clear indications when you are failing *before* you get too far along.
Please, please ask questions of the the senior developers when you run into problems. Please. -- A senior developer
Yes, but that returns a List - not an Array (which can be changed with a toJS(), sure) - which also contains some internal Immutable types (not plain JS Objects).
I am still a junior, my Seniors told me they rather answer too many questions than find out i learned it the wrong but working way from stackoverflow. Make use of their expertise!!
As I understand it this cached the result of heavily computed function calls, if so when would this be applicable?
I see. Well, I was looking for a slow refactor - something that would (at first) let me map over an array of objects and change them easily without changing the original copy. Guess I'll just jump into the deep end of the pool, and do it the right way ;)
The hard part with a Node.js application is callback hell, especially if you are doing many operations with Node's API and they are all asynchronous. There is no special advise to solve this problem. Just organize the code as best you can into relevant groups/hierarchies and document the flow control as much as possible to demystify the depth of callback insanity.
Also I would suggest to have a solid background on the fundamental things: 1) Learn all the aspects of the programming language; Know the good and the bad parts; 2) Study the design patterns; 3) Understand the importance of testing, and if possible apply software dev. processes like TDD. When answering on StackOverflow, I noticed how many developers dive directly into a JS framework, without a good knowledge of the JavaScript. A common misunderstanding is that a good framework compensates lack of language knowledge: but this is wrong. We pass through jQuery, Angular, React,... and many more in the future. But the language syntax is always there. 
Haha I guess the 5 year old thing wasn't the best way to ask. But a huge thank you for that lengthy explanation, this community is great! 
I just want to add something to the "Fundamentals" section - knowing fundamentals is all well and good, but IMO what's more valuable is knowing *problems and best practices/patterns for solving them*. I'm not talking about programming patterns, I'm talking about things like implementing OAuth. If you know what OAuth is and how to implement it, then the language / framework you use becomes a minor detail. Same is true of JWT implementations and things. If you know all of the best practices around JWT, you can identify and pick an appropriate library for your language/framework, or you know how to write your own implementation quickly. Same is true of building APIs, securely allowing image/file uploads, or content entry, and a whole host of other common scenarios. Simply knowing these problems, and best practices for solving them, makes your skills instantly transferrable between frameworks and languages.
Hmm well flash applied compression to all assets images included back when flash ads were bigger which was one of the reasons you could fit everything in 40k but for todays standards with retina for example this isn't really true. Petty sure the article is poorly researched 
Wait for the 15-year old script kiddies to come along and downvote you into oblivion.
I just built a little evolution simulator using D3 3.5, and I had to roll my own for most of the physics. I wonder how much the new velocity verlet layout could've handled it.
That is a very great read.
I didn't try your first reply suggestions but: p: scroll, o: {offset: shift, duration: 1000} didn't work for me before. Seems we are doing the "the monkey and typewriter method" now :-) . I will use the velocity() function syntax for now and be done with it. If I find out I will let you know. Thanks for the help. P.S: Next time I will create a fiddle so it's easier to see. 
&gt; We pass through jQuery, Angular, React,... and many more in the future. But the language syntax is always there. That is absolutely the right way to think about this. Learning the standards is knowledge that remains relevant well into the future. Example: walking the DOM. This remains standard core knowledge and remains relevant. One day jQuery came along with its *Sizzle* selector system, which offered less code to write. This system eventually became a WHATWG standard, but its slower and more limited than walking the DOM. To extend how I can walk the DOM I wrote a library called [getNodesByType](https://github.com/prettydiff/getNodesByType) which I used to create an [accessibility tool](https://github.com/prettydiff/semanticText). People will often say that you don't need to know how to walk the DOM anymore, but I have not found a way write tools like that accessibility tool using query selectors, and this is all very simple code, that is extremely fast, and easy to extend.
Hi /u/prtkgpt, it looks like you're new to /r/javascript, welcome! Thanks for the submissions, but please make sure you read our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `pluralsight.com`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [tutorials.pluralsight.com](/search?q=%28and+site%3A%27tutorials.pluralsight.com%27+author%3A%27prtkgpt%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|63|76% [blog.pluralsight.com](/search?q=%28and+site%3A%27blog.pluralsight.com%27+author%3A%27prtkgpt%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|8|10%
While at it, Bulma is looking awesome (similar to Spectre, less bootstrap-ish). http://bulma.io/
Not sure why you got a down vote, I think that's actually a very reasonable addition.
good answer but worst ELI5 ever :) also, JS now has block scopes, functional closures are no longer the only pattern to use. think of it like this: most kids like pizza. most kids hate cheese. as a responsible parent, your job is to stuff a pizza into your hungry child whilst completely hiding away the fact it has cheese, it's irrelevant to the them. all that matters is the end product _API_ (unless they are lactose intolerant).
Unless OP drastically changed their site since you made your comment, I fail to see how it's a clone. OP's site is a bootstrap site deployed without any sort of module bundler, which appears to be the opposite of your site. You both give away 3 free stickers from sticker mule, that's the only similarity I see.
I am just looking at the spike in Alexa data that started at the same time I withdrew from NPM. There is a direct correlation.
Don't get too discouraged from JS frameworks/libraries. Frankly backbone.js sucks -you should feel much better if you'll get into a react or even angular project.
http://mathieuancelin.github.io/js-repaint-perfs/ I have implementations for Angular 2, React and Mithril here, if you need a reference: https://github.com/lhorie/mithril.js/tree/rewrite/examples/dbmonster
I'm by no means an expert, but I use Vue a lot, and I like it. The one appeal to this library is that it forces you to write more of your own methods, and customize your code structure the way you like it. I do like how simple the state management is, but I do the same thing with Vue using this technique: [vue state](http://skyronic.com/2016/01/03/vuex-basics-tutorial/#solution-2-shared-state:13821831b3195014bcef9dd11de6b6e4)
Some people have an aversion to using javascript this way, I can't really comprehend it as it works just fine in the real world nevertheless thank you for your support!
I would suggest trying TDD. It leads to code that is clearly encapsulated and easy to change.
- Semantic UI (http://semantic-ui.com/) - Skeleton Framework (https://github.com/skeleton-framework/skeleton-framework) - Milligram (https://milligram.github.io) - PureCSS (http://purecss.io/) if I think of more, I'll reply to this comment.
Huh, then how do you know? Did you re-enable npm and observe it inversely spike? That's a pretty bold statement to consider that a direct correlation.
It was minified. The best you could do would be to beautify it. It'll never look like it originally did. http://jsbeautifier.org/
Semantic is my favourite, it looks fantastic. But it has an old convoluted gulp build process, is hard to use with webpack, depends on Jquery and isn't modular. I found a bootstrap theme for it, and together with react-strap, angular-strap or vue-strap it might just be perfect. I have a hard time making it work, though. I will check out the other links, thanks for that!
The other thing you might consider is keeping track of the previous input value so that the last keyUp request isn't cancelled by the onChange event if it's going to make the same request.
They are talking about Coffeescript that compiles to Javascript, they want you to use only Javascript itself. It is questionable if it's worth it to interview with someone who writes "Coffeehouse Script".
hmmm I want to agree with you. Most web pages are not complex enough to even need a frontend framework. It really depends though. On a complex page if you don't use a framework you tend to naturally over time write your own. Then when you come back to your code it's harder to figure out what you were doing and how you were doing it. But if you know your fundamentals then learning a framework is much easier. 
You should try just this CSS: body { margin: 0; width: 100vw; height: 100vh; }
Thanks for the suggestion. However, I need the values for vw and vh calculated later/used for other things, so I need to be getting it with js anyway. But I will remember that for future projects.
I like https://www.lightningdesignsystem.com/
This is somewhat true. On the other hand, I've actually learned _a lot_ about good architectural decisions by being exposed to different frameworks. OO didn't click until I used a framework that forced me to use it properly (or at least, somewhat in the right direction :P), and the same for FP and now RP. Then by switching between different frameworks (and their respective different paradigms) I learned what the advantages of each of these paradigms were and what the limitations.
SproutCore does use jQuery but abstracts it away for almost everything. In most cases you don't have to touch it and you can still write full MVC + statechart code.
Thanks for the tip. Lodash is exactly what I needed.
I wrote that functionality in manually. Tied nicely to my Redux store state.
I'm a senior dev and I was in a similar situation recently. Put on a legacy Backbone application and while it was simple to understand the application, it was not so simple to explain why things didn't behave correctly. It almost always came down to too many events with handlers doing too many unspecific things. Data changed? Re-render the entire table view, because who knows what needed it?? My recommendation would be to trace how data flows to the specific view you're working on. Ensure you understand that path crystal clear, and if you don't because of confusing events. Remove all the existing ones and write your own to make it work. Backbone is a pain in the butt, but depending on the architecture you may be able to isolate yourself quite a bit in the Views and work backwards from there.
A linter.
You hit the nail on the head. I've got six years of experience as a frontend developer. Not the html/css kind of guy - proper programming in javascript, unit testing, following functional programming paradigms, good tooling setup, adding static type annotations to our codebase, etc. Where I want to get at: I'm actually kind of good in my niche. But the problem is, I always stayed in my niche. I always worked alongside backend engineers. I always joined companies where the tech stack was already set up. I'm pretty knowledgeable and capable in my core area of expertise. However, I am extremely ashamed to admit that I have no clue about pretty basic things. I have no idea how sessions work. I know that *http is stateless and sessions are managed at the application* level. I know that *the web started as a scientific document repository and thus the way we implement web apps is held back by the legacy of "pages"*. I can hold myself up during lunch discussions with other engineers. I "know" these kind of things because I can read. But I lack fundamental *experience*. I never had to really stomp something out of the ground. There were always other people to do the "real" work. And that makes me afraid. I chicken out of greenfield opportunities and wait for a possibility to "fix" a bad JS architecture decision. If I could give one advice to younger me: don't become an expert in a niche. Jump at opportunities, and don't be afraid to ask for help. Telling the world, "I think we need to solve this problem, but I don't know how. Who wants to join me in figuring it out?" is the best attitude you can have in the world of software engineering.
[React Toolbox](http://react-toolbox.com/#/) - Material Design-styled components using CSS Modules and SASS. [Material UI](http://www.material-ui.com/) - Material Design-styled components using inline styles. You *can* use SCSS or whatever for styling, but you'd have to use `!important` or inline JS to override anything. So probably not a good choice here. [More](https://github.com/enaqx/awesome-react#components)
There aren't many sites that use a @ in the URLs. Maybe the Reddit app is encoding it wrongly.
Promises are much cleaner, but most of Node's API methods are designed to take callbacks.
what's Googles approach relative to this? They don't appear to be doing any debouncing(), as the results are instantaneous.
One path that helped me was building tools for doing things on the front end, that has me touching backend technologies and it's not like taking a steep dive off a cliff, there's a goal and that goal serves my primary focus.
The article in question: http://cultureofdevelopment.com/blog/build-your-first-thing-with-web-assembly/
Very nice article! One question: you wrote that flatMapError is part of Promise.then() But I think that the error function is the .catch() As far as I always thought it to be, .then is a combination of map and flatMap 
I'm sad to announce that I was trying to cache a POST request. I are dumb.
Here is what I tell developers new to JavaScript: * Avoid inheritance until you are familiar writing in this language. Just straight into inheritance means you will be attempting to write Java in JavaScript only to discover this isn't actually Java. * Scope and inheritance are different and unrelated qualities. Learn the concept that scope can be nested. When a reference is declared in an outer scope and used in an inner scope you have a closure. Closure is amazingly expressive, requires no added code or conventions, and is always available. * JavaScript does not have Java like explicit public/private expressions. Public and private are implied by whether a reference is resolvable from a given scope. * Be aware of and avoid type coercion. Code reliant upon type coercion is generally sloppy crap. * Use a validation tool. The most popular is ESLint. I still prefer JSLint because I am old, I don't want something entangled with NPM, and because I want something really strict. * Use a beautifier. I have a handy one I wrote at http://prettydiff.com/ * Ask very details questions about the remaining concepts you don't understand or that look foreign. Odds are that you might just be reading really bad code that should be thrown away.
You've described my role as a UI engineer at my company perfectly. I only needed to learn Angular and then the specific architecture my company has built. 90% of my job is writing directives, services, controllers, and unit tests for everything, but I wouldn't even know where to begin setting up my *own* complex SPA, or how to properly configure build tools such as gulp, karma, browserify/webpack etc. I'm sure I could learn if I applied the time, but I do not have such an opportunity where I work, because it's all built for me and I just have to work within that architecture. I'm learning the SHIT out of JavaScript and Angular, which is very valuable, but it's a narrow skill set nonetheless. My last job was client services, so it was 100% building new things from the ground up. But because the projects were so short-lived, they only ever allowed for broad exposure to new technology and solutions to specific problems, but never deep exposure to something. I'm lucky because I'm the primary developer of my own personal gaming community and I do everything from the design in Photoshop, to server-side programming in PHP, to server administration, to the front-end development. I get to touch everything, go as deep down a rabbit hole as I want, and really force myself to learn new things and solve actual problems to build up experience. While it's hard to come up with an idea, I would encourage everyone to pick a personal project they want to work on in their spare time - even if it's just purely make-believe (as in, you're the only person using it), and just build everything from start to finish, deploy it to a Digital Ocean droplet for $5/month, and even slap a Lets Encrypt free SSL cert on it. Build a fully functioning website - auth, password recovery, weekly email digests/newsletters, cron jobs for calculating things, security concepts (CSRF tokens, escaping output, password hashing), SSO, proper live/fuzzy search, an app that would allow potential staff to post to your Twitter account without having to them direct access to it - the works. Hell, even fill up a database with MILLIONS of records of fake data to see what happens to full text search performance the larger a data set grows, and how to solve that issue (for example my gaming site has ~ 10,000,000 posts in it, and doing full text search with plain MySQL is simply not possible. We had to throw Sphinx onto it, which was a good learning experience). It's the only way to get really broad and deep experience in a relatively short period of time - at the very least, exposure to common problems that you encounter when building websites.
I didn't write the article, but I think what the author was referring to is that .then() takes two arguments. The first is a callback for success, and the second is a callback for failure. If you so choose you can use that second callback parameter instead of .catch()
This up here is the perfect answer. Go through this OP and once done read Addy Osmani's book on same lines.
How much code? Maybe you could post the really confusing parts so we could help decipher it?
I haven't used spring MVC, but I believe it's Java based. In that case I would say Angular would be better over React due to familiarity with OOP vs FP. That said, Angular is comparatively a bit heavy for small sites, but it's good to know something a bit larger, which can be applicable for more use cases later on. Plus there are plenty of starter-kits or generators on github for quickly scaffolding out simple stuff. 
Here's a super simple pubsub to get you started: http://jsbin.com/nibalop/edit?js,console
I'll have to check this out then. I dream of a world where I can run all my reducers and sagas in a thread seperate from react
Are the promises in your `Promise.all` ever reliably resolved or rejected? Could it be your promises aren't always resolving or rejecting, so it is waiting forever for a promise to resolve that never does?
Arguments to `Promise.all` don't wait for one another, both of your `ask()` calls are executing at the same time.
Absolutely! It's hosted live on gh-pages at [meeba-farm.github.io](http://meeba-farm.github.io/meeba-farm/), and if you're curious the code is at [github.com/meeba-farm/meeba-farm](https://github.com/meeba-farm/meeba-farm). There are still some balance and performance wrinkles to work out, but it works reasonably well. You can mess with the config settings if you click on the gear. Let me know if you find a balance that seems to work well.
Can't believe the author missed the opportunity to title the article 'Callback to the future'
The second `rl.question()` is called while the first one is still waiting on user input, causing the second call to fail. Wait for the first `ask()` call to resolve, then call a second time. function ask (question) { return new Promise(resolve =&gt; { rl.question(`${question}\n`, resolve); }); } let firstName, lastName; ask('What is your first name?') .then(fname =&gt; { firstName = fname; return ask('What is your last name?'); }).then(lname =&gt; { lastName = lname; console.log(`Your name: ${firstName} ${lastName}`); rl.close(); }); 
So is this the only way to be able to do it? Seems just like nested callbacks :/ ask('What is your first name? ').then(firstName =&gt; { ask('What is your last name? ').then(lastName =&gt; { console.log(`Your full name is ${firstName} ${lastName}`); rl.close(); }); }); 
Angular is basically made for OO/Java people. Learn Typescript while you're at it.
The intention is when you view source it's decompiled, I hope that'll be the case. I'd bet there's more than a few who'd think otherwise.
Yeah thats what I've been hearing. Would it be overkill too have react and angular with spring backend?
What is a atob method?
I work on a spring stack for a decent sized e-commerce site and we use a handlebars view resolver to render handlebars from our rest API (more or less) on the backend then serve the rendered content on first request. Whenever we need client side rendering (which really isn't that often) we can then use the same exact endpoints and templates. I always thought it would be pretty sweet if someone did this with react as the view layer.
Images can appear different sizes on different devices. Fonts are generally proportionally the same on all devices. If I could use fonts, it seems like it would be easier to make it look better on all devices.
Can't you wrap the character/iconic font/image in a div and drag that? 
I'm a Java dev gone full stack JavaScript for the past few months. Having worked on large spring and Java EE apps in the past with ExtJs and Angular js, I would definitely recommend React and Redux now that I've used them. Composing your views out of components with immutable state just makes sense for UI's. Handle your client stuff with those two libraries and build your api with spring boot.
Awesome! What library is this using? Tone.js?
I just recently went and read all this from top to bottom https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference Very well written and a very good refresher/reference 
Corollary: code should tell you _what_; comments should tell you _why_.
Like the other comments say I guess they refer to code that needs to be transpiled. Es6 js even though is js most of the times wont be understood by the browser so the use of a transpiler is needed, like babel.
Looks like it was obfuscated, not just minified/uglified, it is possible to debfuscate but it will take a while, where is it from? 
Or stop using jquery all together please 
What about object.freeze and .seal? Have you used them? 
Thanks to everyone for clarifying this ! I always find good help and smart answers when I need something here, I really appreciate :D I hope I'll get the job, it's quite hard for me, I'm following my girlfriend to Stockholm (she has a job already). On November, we are moving from France and as a Web Developer, I'm doing my best to have a job as soon as I get there ! Finger's crossed 
Nice job. Now make it more customization in terms of sounds. And it would be great to see actual notation.
Cool video, straight to the point. I like it
Wow. this is AWESOME!!
There is no obvious volume control.
The url fragment identifier is composed of the channel id and the encryption key. What you're seeing is the channel id, which the server uses to identify a particular pad, and to deliver messages to users who are editing that pad. [this function](https://github.com/xwiki-labs/chainpad-crypto/blob/master/crypto.js#L33-L42) parses the key, and [this one](https://github.com/xwiki-labs/chainpad-crypto/blob/master/crypto.js#L52-L62) produces the `encrypt` and `decrypt` functions.
Google does not seem to be doing debouncing. Probably coz they are doing auto-complete suggestions.
I was just reading one of the most upvoted comments on reddit, yesterday, that stated one of the biggest mistakes one can make is chasing after the latest hot library or framework. So good luck to you.
Servers aren't "RESTful". Protocols are.
Off topic, but, what's that syntax theme he's using in Atom?
Cool, thanks!
He actually set a breakpoint the madman!
REST is not a protocol, HTTP is a protocol. REST is more of an architecture style for designing networked applications. Saying "RESTful server/services/backend" is how the term is commonly used. Don't try correcting and downvote someone when you don't know what you're talking about.
If you have any questions on how to best make use of the library for your use case don't hesitate to make an issue on the repo and I'll do what I can to assist. The biggest issue I think you'll run into is that everything is asynchronous but you should be able to make use of asyc/await within react which should make it easier 
Render it to a canvas, and convert the canvas to a bitmap, drag the bitmap. (You may be able to drag the canvas, which would be easier).
If you still wanted to use Promise.all then I would take s1dd's advice. One possible way to do this would be to make your ask method take a promise as an argument and it will resolve that promise when an answer is given. Then Promise.all will take those two promises as args and you can easier control when the questions are asked.
Even though it may be terrifying this is exactly the kind of experience you need and bravo for taking a job slightly out of your comfort zone. It will help you grow! As others have mentioned: read some books on JS, do some tutorials on backbone, etc. You're on the right path.
Isn't it easier just to right click the page and then click Inspect?
where and how do you even learn about this debugging trucks?
tl;tw: On the elements tab you can right-click an element and set it to break on attribute change, which will allow you, for instance, to break when an element has its classes changed. On the sources tab you can use the XHR Breakpoints on the right to break on a request happening in the background. Also on the sources tab, if you right click on a breakpoint's marker (on the line numbers) you can edit the breakpoint to turn it into a conditional breakpoint. 
[Spring Boot Angular 2 Starter](https://github.com/kucharzyk/spring-angular2-starter/tree/v1.8.0)
I recommend checking out theme called "One Dark Vivid". Also it's looking amazing with font "Fira Mono".
&gt;Wahoohoooo Hoohoooo Baby!! FTFY
Data comes in, data goes out. Can't explain that.
We don't use experimental features where I work but generators and promises make this easy enough. 
Clients will start to care when nobody allows their luddite ads to run.
Wooohooo!
Fuck fuck fuck fuck it's fucking awesome!! #LoveCode #LoveMetal
https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/atob `atob()` and its reverse `btoa()` convert from and to base64 encoding. The chunk of text at the top is processed later as binary values.
Woohoo49Baby back at you with another gameplay.
Nope, not angular. this is a *mostly* vanilla web site that I'm trying to test. I've spent close to 30 hours trying to figure out how to get selenium running, because that's what my boss asked me to learn. What I've learned is: * No one who uses selenium actually understands JavaScript promises * no one seems to be comfortable with an asynchronous automation framework 
This is totally awesome. Much appreciated!
An object argument is basically a service locator in sheep's clothing.
brilliant !!!
awesome. some of the text inputs are a little wonky, though, you may want to look into debouncing updates.
This is a valid but old way of maintaining session. In this way the server establishes session and stores a hash in a cookie that sits in the user's browser. Each page request the hash in the cookie is checked to verify if the session is valid and within timeout. Cookies are old technology and a terrible to work with. In this case what is important is the hash that is stored in the cookie. On Java technologies this is typically a numeric jsessionid. When working with legacy Java apps you don't even need a cookie at all because the jsessionid will be embedded in the page HTML anyways. Cookies are just used for convenience when requesting page content from the server. Sigh... this is just another example (in a long line of them) of why Java developers are not web developers. A smarter way to think through this problem is: 1. Check if the user is already in an active session. Always verify session id against a last known IP address to avoid some man in the middle attacks. 2. Session does not exist. 2a. If the user is requesting a page that requires an active session respond with an error or direct them back to an entry point. 2b. Create the session on the server. 3. Send the session identifier as a HTTP header field to the user when responding with the HTML. 3. Once in an active session always send the session identifier as a custom HTTP header in the HTML's http request. The primary benefit is that the session id is easy to gather for analysis by looking at the http traffic, but it is stored. This makes it harder for malicious parties to subvert the security. It is fine if the browser is sending forward a valid or stale session identifier, because it is entirely on the server to verify timeliness and integrity.
Awesome. Hope it's poking fun at djent though!
Have you considered something like http://nightwatchjs.org/ ? We're using it now. Its still a little rough around the edges, but uses selenium and does a pretty good job of providing a simple abstraction for it.
That's what I'm thinking. I mean, it makes sense to use another Vue object for utility, but I'm not sure how it's better than what we had before.
his enthusiasm makes me want to watch more great tips britishcode.js
If vue.js 2.0 was out (it's basically in beta now) I would say go with vue.js since I think it is the logical successor to React (just as React was the logical successor to Angular). The real question is, what will be the successor to vue.js? ;-)
cmd+shift+c you're welcome
Neither are servers but you're right. At 5AM this morning, I used the wrong word. If I was still talking to Roy on IRC or my other access points, he would scold me in his to-the-point manner. Fortunately, he didn't scold me often when I first started asking him questions about REST years ago when I wrote my first app using this. Now that I have 10 large apps under my belt, all very "RESTful", I see a redditor thinks I don't know what I'm talking about. As a Fielding student, I'm sorry I embarrassed him for using the wrong word before my first cup of coffee.
Having so much fun with this atm
Renders amazingly well in mobile/desktop! My phone struggled not to drop frames, though. Or whatever the audio equivalent is.
Weird that it says "Go for the most popular framework" and inmediatly after says "Don't always jump on the bandwagon"
I'd say go for React. Why? Because it's stable and it's pretty popular right now. Angular 2 and Vue.js 2 are still in beta and I think only Angular 2 might be as or more popular than React due to the popularity of Angular 1. (I don't have much knowledge about Vue.js tho)
Interesting!
Depends on the demand in your area, I think. I prefer Ember (current is 2.6 or so) over all of them. Of the big four, I rank them as Ember &gt; React &gt; Angular/Polymer. However where I live, Angular jobs are the most prevalent. But you will find that as your learn/use them, you will have your own preference. 
There is a lot of misnaming in this area. Object argument is basically a form of dependency injection. You are inject the dependency (in this case your object) into your code via argument. Other forms of dependency injection include * constructor injection * property injection * config injection. Larger Dependency Injection frameworks would support many ways to inject. The major distinction that people miss here is difference between the act of Dependency Injection and architecture of Dependency Injection. A DI architecture is more of a competitor to other architectures like "unidirectional flow", or even SOA. * In **Unidirectional flow**, you manually scaffold the app, and data is expected to flow one direction. * In **DI architecture**, the scaffolding and data flow is managed by the DI framework. You just give it a bunch of classes/modules, and the DI framework would automagically scaffold the entire app for you. (For better or worse) * In **SOA/microservices**, you try to split your app into a bunch of smaller services that needs to be linked somehow (usually via config files or service discovery). Data flow is arranged in a server-client manner. Of course, you can also mix and match. For example, you can implement MVC using a DI framework. You can also implement MVC using SOA/microservices, but that's not really practical. 
I honestly would, I haven't taken a look at angular 2 yet, but I've found React and Redux a pleasure to work with.
Yeah I think im about to mess around with react over the next week then try to learn some of angular too see what they hype is about and go from there. Thanks for the advice.
What you learn is entirely based on what your requirements are. Are you doing it for fun or future marketability? Learning a new library can be fun, but it can also be frustrating if you don't have a clear goal for what you're doing. Angular is a good widely popular library - it's also in flux because of the switch from 1 to 2. React is popular but requires a different way of thinking which is different than typical MVC ways of doing things. Then you have other platforms like Aurelia which is focused on being standard's based (ES6, HTML5). I personally would say learning standards beats learning framework du jour. However, Learning Angular or React are much more marketable at the moment.
This is great. ES2015 modules are not destructuring though. I know it looks like it. Try assigning the default export to an object and then use destructuring. It won't work. `import { MyExport } from 'somewhere';` is retrieving the named export, not destructuring.
Oh, interesting! Maybe I've been running loose mode then. I'll try to fix the blogpost then :).
Something smells here. There's no way a library implementation of a native method is slower. Another thing to remember is that unless you're iterating over thousands of nodes per second, the "slower" vs "faster" perf stats don't matter
At 7am in the morning I'm a little snippy
My understanding is that lodash optimizes for the most common cases moreso than native implementations, rather than them not covering them at all.
Try [these](https://laracasts.com/series/learning-vue-step-by-step). I've also found the vue documentation to be extremely comprehensive.
Yeah. I went through those tutorials. They are quite good. 
Also there is this sort of bullshit in the readme for the native example: var arr = users.map('user'); // error! Of course that errors.
Vue js is definitely not a logical successor to react. Vue started out trying to be angular + backbone, now it's trying to throw jsx into the mix to be more react like. But it is still too imperative, and with the scattered methods of implementation it will lead to vast gulfs between how devs use it, removing one of the main benefits of a framework: easy collaboration. I'd stay away from vue.
/r/proceduralgeneration might like this.
Have you tried the built in "device toolbar"? Not really an emulator but you get size, touch events and user agent, might be enough.
I am so raw in javascript that I use jquery only when it is absolutely needed for bootstrap or the likes. Ya I mentioned code spaghetti because I like big complex codes, but I am very organized, it indeed doesn't look like a spaghetti ... most of the times =p
It sounds like you've been programming for a while so I assume you're familiar with programming theory, but in case not, I'd highly suggest reading about declarative and functional programming. React is heavily inspired by these "conceptual frameworks", and being familiar with these will greatly help any code you write.
The jQuery.ajax block. I believe that's where the upload happens, so once it's over I want to refresh the page.
&gt; There's no way a library implementation of a native method is slower. How do you think the native method is implemented? It isn't usually native code. In V8 many array prototype methods are actually written in plain old JavaScript. [This](https://github.com/v8/v8/blob/master/src/js/array.js#L1153), for instance, is Array.Map. No C++ at all.
Could I maybe DM a couple questions about your project?
&gt; import { namedExport as newName } from 'my-module'; I wish destructuring would also use "as" instead of ":". Using a colon there is just weird.
My man... Tell me your address to send some beers &lt;3
It's pretty crazy how popular React is in Asia. 
If you want to keep it simple and only want the list on the same machine, you can store the data in local storage. Here is an example: http://jsfiddle.net/apougher/GcR9Q/ http://www.w3schools.com/html/html5_webstorage.asp
Dyk about the mobile button in the chrome dev tools? It's not safari rendering, but I think it might interest you.
I don't think one can conclude much out of this since countries like Japan, Korea and China use their own search engines and not Google. This also does not take into account search results made in other languages.
Well, my thought here is that even in countries with their own search engines, it's still representative, because otherwise, how could you explain the data? IMO, it's like saying data from Bing is not accurate because Google is more used. It's an approximation. I should have included this disclaimer. :)
You are going to need a backend server for that. You can try parse (https://parse.com/docs/js/guide) or some other hosted service if you don't want to deal with managing your own server / database.
Okay I really don't understand Greenkeeper. Dude wrote a script that auto-updates npm dependencies, which resolves the lack of an obvious update feature in npm, sure, but fucking anyone can write a script to update their npm dependencies! Now sure, he could have posted it on npm for free and people would have probably used it. He could have even sold it as a software package. But no, he made it a *paid, monthly service* and people are actually *paying* for it?! What the fuck. Aside from that I'd be very reluctant to auto-update npm dependencies, because anyone who's worked with node for a while can tell you that will **break your shit**. Not everyone on npm writes good code, and it shows. I frequently have to check my package.json in github to see what version of a library I was using before I installed an update and it **broke my shit**. Seriously though, what value does greenkeeper actually bring, other than saving you the EXCRUCIATING effort of taking a few hours to write a script that queries npm and changes package.json and runs npm install? Am I missing something? It can push to github WOOHOO. Fuck.
I respectfully [disagree with examples](https://github.com/StoneCypher/You-Dont-Know-Lodash-Underscore/blob/master/README.md). These can all be written tersely in vanilla. `:)`
It's frustrating that backwards compatibility has such a stranglehold on all of these new features in ES6. As a primary backend python developer, I initially was getting excited when our front-end devs were going to get useful new tools for avoiding the hacky "maps" we're used to (keys all being string coerced) and thought that JavaScript was going to get a step closer to Python. But then I realized that since JavaScript's array access operator [] is also its arbitrary attribute lookup operator (it's basically getattr/setattr and [] from python) they have to implement maps as objects with .get and .set methods so that they don't break the ability to do my_map['get'] and other weird dynamic lookup stuff that is uncommonly used. This has serious drawbacks: * *No clean upgrade path.* We have a codebase that used object maps for data storage in various places. Putting ES6 maps in required rewriting every access into those maps. There's a lot more codebases we have that could take great advantage of ES6 maps that simply aren't going to because of the time investment required to do so. * *Soft API failures* This is pretty much my first point rehashed: let's say you do refactor your codebase. You can obviously still add arbitrary attributes to your ES6 map as well. So if you did refactor your codebase to use ES6 maps but forgot one place in your code that says mymap[key] = 2, you won't get an exception or anything as this is in fact a completely legal assignment. It drives me crazy that JavaScript doesn't let you override the behavior of [] for your object, or let you override the *in* operator for an object, or basically any of these language features that exist but are entirely unused because of their serious drawbacks. This ability would basically make ES6 maps useful in current codebases instead of only good for new development and retrofitting.
My search is partially biased on the most popular ones, I didn't want to clog the graphs with 12 frameworks.
It gets worse: here is the function used to determine whether two values are considered equal for the purposes of key lookup: http://www.ecma-international.org/ecma-262/6.0/#sec-samevaluezero. Yes, that's right. For anything more complex than a String, you have to use *the exact same object* that you initially used to add the key-value pair in order to retrieve the value. There is no hash-based lookup like there is in Python, as far as I can tell (someone please correct me if I'm wrong).
Looks promising; I've been looking around for a good, SMALL view libraryn. Using React on small-ish projects feels like complete overkill... Whenever I start building out an application in React, I inevitably feel obligated to then utilize Redux. Then comes a need for routing, 'oh, better install react-router'. 'Now if only there was a good way to sync up Redux...' Boom React-Router-Redux. Three dependencies later you have a 2MB dev-bundle and an unhappy developer...
I thought they were all c++, learn something new every day.
Brilliant. Learned a lot from this
even better with destructuring: peeps.some(({user, active}) =&gt; user === 'barney' &amp;&amp; active === true); works in latest Chrome &amp; Firefox. "Underscore/Lodash may exit iteration early by explicitly returning false" is example of bad design which can very well be source of numerous bugs. Lodash/Underscore uses functional paradigm, it means "no side effects".
&gt; you can't destructure them ~~How would you want to destructure them? I suspect you can probably do whatever you'd like to do using the various methods that they provide.~~ Ok, I guess I see what you were saying here - you can't use something like object destructuring on them. &gt; Then, for no reason, they're completely mutable The entire rest of Javascript is mutable. They're mutable for consistency with the rest of the language. &gt; makes them totally useless as state stores How so? Redux manages to be an immutable state store while using mutable values. The immutability isn't enforced by the language, which does open you up to making certain mistakes, but mutable values are clearly not "totally useless" as state stores. If you want enforced immutability and an API that is more friendly to immutability, nobody will begrudge you for using something like immutable.js. 
This is a good thing IMO. It would be difficult to define a searching behavior for Maps. 
This is essentially how every single language that has maps/dictionaries implements them. It's not convoluted at all. In fact, Javascript is very much the odd man out in this respect. EDIT: To clarify, it's not a single function that works for all types. Each type implements the computation of a hash value, and also does whatever it needs to to incorporate the hashes of constituent values. It's like a tree.
&gt; PointerMap (not sure if that's actually a thing) It's not. &gt; I think that you are confusing the JS Map ... with HashMaps in other languages. "Confusing"? I'm saying that JS Maps are hugely deficient compared to types in other languages that have the same purpose. It's not like JS Maps and things that are called HashMaps in some other languages (though of course, plenty of languages also call them maps or dictionaries) are intended to have vastly different purposes. They're all for associating a key with a value. Javascript's version of that type just sucks at it. Feel free to try to implement this yourself. However, seeing as you only just discovered that this is even a thing, I think you should hold off on assuming whether it will be easy or not.
Absolutely!
Now, I have no idea if you were being facetious, but it's hard to tell since you didn't give any proof otherwise... &gt;What is a "hashmap"? Where is this being introduced in Javascript? I don't know if you're being ironic or not. Objects and Maps are both hashmaps. &gt;Now "dictionary" has entered the ring I still don't know if you're being ironic. He's not wrong. A dictionary is a pretty common term for something we is Js-land call objects. For instance, in python, this data structure is called a dict. Which, in classical computer science, is similar to a hashmap. You're right that objects don't use the length keyword usually... But I think they start to touch on an interesting difference between objects and maps, being which you can easily retrieve the length/size of a map, where you can't do so with *objects*. A hash function in this regard would be the method in which hashmaps/objects/maps/dictionaries are able to translate their keys to their values, as its methods and properties are stored in "buckets," rather than "numbered indexes" like arrays. Now, I know that you don't necessarily need to go through a CS program to be an amazing programmer... But I think you're picking apart terminology that OP is using that's taught pretty standardly in a CS program, of which you seem to have little knowledge of. Which is fine. You'll probably have a great career even without knowing the lower level implementation of the buzzwords you need to know. It's not really necessary. I agree that OP's post wasn't very deep, and could've dug a lot deeper... Like how Maps are a lot more "array-like" than objects due to the nature of the methods that are given to you. So my rebuttal, if anything, is to show you that being a dick on the Internet doesn't work in your favor if you pick apart semantics over anything else... Especially if the semantics aren't even particularly wrong. It just makes you look ignorant. 
Ah well I dont have to deal with that luckily. Huge codebase but looked after by 3 "full stack" developers. Is it really against rest standards to include sub objects? All our objects are part of one large hierarchy. Client -&gt; Projects -&gt; tasks -&gt; users -&gt; time So the projects service could technically return tasks and users if someone requested it in their "query/field specification" header. Likewise the users service can return times for users etc. Sucks to be in that situation though :(
If you want to develop reliable and maintainable applications i would recommend you Angular 1.5. 1.* branch of angular pretty old but still best on the market. How do you think why so many angular.js jobs outside? Because decision makers usually architects or someone experience enough to see that using one framework is much more better than using whole zoo of different libraries. So my point, if you want to play around with something new and fun- use react, if you want to get shit done - use Angular 1.*/Ember, if you want to be successful in future - start to use Angular 2.
The author refers to the same thing using multiple bits of terminology, and uses terminology that is simply not commonly used in Javascript. It makes him look sloppy. It's really not hard to not look sloppy. Just organize your own internal thinking and you won't be throwing out three different words for the same thing in one article.
Well, guilty as charged here, I want to play around with something fun =p This is a change I am looking for, not imposed on me, But I think that after I get used to React I will definitely look into getting the basics of Angular so if I need it in the future, I already too the baby steps. Thanks for tips!
Can't imagine not using TypeScript once I worked with it.
This is how I do it. You can jump right it without any practice to get a feel for how this works. It takes a bit of practice to really get right. I am still learning refinement even in my own approach. 1. Determine the major one goal of the application. Your application will accomplish that one goal only. The code can be extended to accomplish other goals later or broken down for modularity later. 2. Form major tasks to accomplish the primary goal. What major steps are needed? 3. Work each step in an ad hoc manner according to a universal code style. 4. Code organization is complete. Write all the code and test the application for basic functionality. Does it work in the most primitive way possible? 5. Consider edge cases and refine the application. The edge cases are only those that would break the primary goal. 6. Document learnings and structure of the application. This will eventually become formal user documentation. 7. Write automation. 8. Write unit tests. 9. Evaluate enhancements and defects and document these items. 10. Solve for each enhancement or defect. 11. Repeat steps 5 through 10 for each defect and enhancement. 12. As maintenance becomes too exhausting reevaluate code organization for possibilities of reducing the codes, refactoring for modularity. Organization by the numbers (according to the steps above): 1. primary goal -&gt; a major function that contains everything except boilerplate for modularity. Universal flags, objects, and data stores will be declared here. 2. major tasks -&gt; child functions. Separation of concerns is important. 3. write the internals and nitty gritty of each child function from step 2. Make use of closure at the lowest appropriate levels to ensure reuse balanced by cleanliness. 4. Complete the writing of the application code and refactor the organization to ensure the smallest footprint and cleanest organization to get a first time run. Cons: * You will not achieve 100% test coverage * You will rarely have to refactor the basic code structure, but when you do it is a really big effort that pays huge dividends Pros: * Code is inherently organized. * Both maintenance and initial code writing are really fast * The code is super small * Separation of concerns is absolutely achieved * The organization of the code reflects how a human would read it and how the computer will execute it. * The documentation contains all the basic details, but still demands refinement
Am I the only one who's really excited and happy about TypeScript's existence, but can never bother to actually use it?
Thank you! What a puny mistake. How embarrassing. Thanks again!
Glad that i was able to help you. But just recommendation: do not even spend time on react. If you need to do something right now - use angular/ember, if you would like to have successful career in front-end -- invest your time into angular 2.
2.0 comes with non-nullable types, which is a pretty big deal. You should definitively check it out some day. Use it for a toy project or something like that.
Sorry, my mistake. I learned from it. 
Knowing javascript well, I can't imagine needing TypeScript. Half that article is about the editor you use to help you write it and libraries needed to help you make it work. No different than any other language but needing helpers to write code always makes me look at it strange.
Gee. How did we ever manage over the past several decades writing code without TypeScript?
Ofc you managed, it could be faster though with typescript
I drove crappy old car too, but now I have a better one.
Exactly. My car has warning lights and error lights now, so I know when shit is about to go bad. That's what Typescript is.
Oh, we certainly did manage. Poorly, that is. Also note that many big "JavaScript" projects weren't actually written in JS. Many used GWT (e.g. Google Maps), CC (Sim City, many Google projects), or a mixture of both. The more your PC can do for you, the better. Machines don't complain about brainless grunt work.
Maps can use objects as keys, that's the big difference.
We wrote smaller programs, and had lowered expectations overall
If you thought duck-typing array-likes simply by the presence of a length property was weird, wait till you hear that promises ditched/passed up an entire programming paradigm just so they could duck-type "thenables"
Said no professional programmer ever.
Haven't been following how much more ambitious js programs have become?
So no one ever wrote, or writes, code in C or Java or PHP or ... cause it's not TypeScript?
There is so much Babel and es6 gets wrong that Typescript gets right. After using Typescript on a few toy projects at home I am officially done with crappy "true" javascript and ready to move to a strongly typed alt.js language. I get angry dealing with es6 at work while at home working on my Typescript projects is frankly a joy. You don't even need livereload anymore once you move to a strongly typed language. You just confirm your code once in a while. It's absolutely fucking fantastic and I want a job using it.
Hasn't Flow had that along with better type inference and an easier transition to gradually adding in types? I haven't used either before, but why would I want to choose TypeScript over Flow?
Languages don't exist in a vacuum. When you actually use a language, things like documentation and tooling become extremely important. You are free to use a dumb editor, but most people - given the choice - would opt for a smart one which provides maximum assistance. So, pointing out that such a choice exists makes a lot of sense if you want to pitch a language and its ecosystem.
They are talking about large JavaScript codebases. Writing large JavaScript applications in pure JS is needlessly difficult. Even more so if you're working on it in a team. You can't memorize all of that and you can't keep track of every commit.
Flow had zero Windows support until recently. There's some third-party support now. 32-bit Linux is unsupported. So, I couldn't use it on my Windows machine and I still can't use it on my 32-bit Linux netbook (which I currently use to write a stealth game). flowtype.org also only mentions Vim, Emacs, and Nuclide. TypeScript is cross-platform since the beginning and you can use Visual Studio, VS Code, WebStorm, Atom, Sublime, Vim, Emacs, and Eclipse. I use VS Code on my Linux netbook. Works great.
Even for small projects?
https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes 
of those, Angular is the only framework. I would rather see a comparison of client side frameworks specifically, i.e Redux, MobX, Angular2, Ember, Mithril, Riot, Vue, the variou flux frameworks. It would also be interesting to see some backend frameworks too - Express, Koa, Hapi, Sails, Kraken etc
Ah yes, C and Java, two fine examples of dynamically typed languages to support your argument.
Well if you don't care about modules then typescript is dead simple. Just set up an outDir in your tsconfig.json, run `tsc -w` to compile on save, and you can code &amp; reload like you would with plain ES5 js files.
I don't see DI as a useful tool for userland code. But for module loaders/framework plugin loaders it is awesome.
You won't necessarily have a "dumb editor" if you don't use TypeScript. You can just use a good plugin like [TernJS](http://ternjs.net/) which works pretty well with most editors. Here it is in Sublime: http://i.imgur.com/ptGjgJg.png
I mean, what's the alternative? You have a whole host of browsers and even non-browser consumers of JS, some of which don't even deign to communicate publicly about what they will or won't implement or on what timeframe (cough cough, Apple). Then you have an unbelievably vast universe of pages that all rely on, sometimes in bizarre ways, on exactly how JS presently works. So you can't risk any change breaking the web, but nor can you see a way forward to release a new/breaking version of the language, even if its opt-in. Heck, browsers have had to delay implementing some ES2015 features because _despite_ ES2015 including no breaking changes, parts of the web STILL broke when things were switched on (due to stupid code that modified native prototypes in goofy seats). What's the alternative?
1. Brainstorm idea. 2. Begin coding with no plan. 3. Add new features instead of fixing bugs. 4. Release it in alpha. 5. Take feedback but never implement it. 6. Realise you'll never finish it. 7. Release it as "early access". 8. Never finish it.
In concept I like typescript. But I can't justify adding such a significant additional technical dependency. To me it means another major piece for someone to learn to be useful in my team. Our code is vanilla enough that all you need to do is understand react and JSX and you then have 100% of the technical knowledge to be effective. It also means that not all our code is as similar as it is now. Either everything becomes typescript, or we end up with more than one style for everything. I think for smaller personal projects I would love to use it. But it doesn't fit in my team's current ecosystem.
How would you destructure an object reference key? Maps (arbitrary type key-&gt;arbitrary type value) have no guarantee of string-like label to use on the left side like objects (string type key-&gt;arbitrary type value. {label} = someObject; // cool, get the "label" prop let map = new Map(); map.add(someObject, "foovalue"); {whatingodsnamehere} = map; // how to get someObject out?
I have not seen a post like this since Stack Overflow 2014
The nice thing about Greenkeeper is that it triggers automatically as new versions come out and they create pull requests for you. So there is no need to periodically check for updates anymore, instead they are just presented to you as they come. Also they run your automated tests for you, so as long as you got decent coverage it's quite reliable. You mention having to check old versions of your package.json, because some update broke shit. Provided you got good tests, that's exactly the kind of situation Greenkeeper prevents, because they warn you when a new version of a dependency breaks your tests. I'm using it for an open-source project of mine (so it is free in that case), and am quite satisfied with it. This morning I saw it already offered me a PR to upgrade ESLint to v3.
It seems like they are deprecating a lot of the things people enjoy about Vue --.sync, filters, events, etc. 
I really want to like type script but I've had a fairly negative experience with it at work. It's given our oop people liscence to try and write js like Java on the front end, and being progressively typed, there have been a lot of issues in our code base that a robust type system should have caught that TS has not. My first exposure to a typed front end was a few toy Elm projects and coming from that, type script has been very underwhelming. To be fair, though I'm sure there are TS best practices that my team isn't familiar with that could make the experience much better.
You could trigger it off routing. I haven't used uiRouter or ngRoute in a long time, but can you just grab the path?
I don't think he uses three different terminologies. He is referring to different things with each term. I think if anything he uses "hash map" and "dictionary" to refer to the sort of "species" of data structure that both hash maps and objects are members of, with the former being the underlying design pattern and the latter referring to a classical implementation of one. Hash functions are essentially the method in which the key:values are discerned. They're not a data structure in and of themselves. So yeah, he should clarify a bit when introducing words that aren't used explicitly by the language, but I'm not sure grilling him on referencing hash maps as a data structure is bad at all, considering that he's basically comparing two implementations of hash maps. Maybe he just shouldn't have used the term "dictionary."
It's completely fine at any level but it's especially good on large projects.
The hardest part is getting it installed, there's zero learning curve from there if you use a code completion editor, normal JavaScript is valid typescript so you would be able to only add one single typescript feature at a time
Well I can see the reason behind deprecating filters - computed properties do the same thing with less confusion. Filters can still be used in template bindings for modifying bound data, becoming a sort of mix between a method and a computed property. I think they should rename 'filter' as it could cause confusion. Event removal is annoying, but I ended up using a global event emitter anyway so I can see why they did it. The big one is .sync. I hope a hassle free replacement is implemented as development moves along. --- Interesting to think that this is the opposite of what happened to Angular where more and more features were added until there were multiple (not always obvious) ways to everything. In Vue's case, more and more features are removed until there's only one way to do anything.
I've come from a Java background, but have been working with javascript the last five years. I've noticed that I seldom need a class (nor constructor function in es5). Most of the times I want one instance of an object. That's also what the spring developers noticed in the Java world : every instantiation creates a singleton by default. One of the best parts of javascript is that you can create objects without creating a class first. But _sometimes_ it's nice to define a class that I can use to create objects. I've never written an entire game engine, so it's difficult to say that I'd build it without something like classes/constructor functions, but it's definitely possible to build really complex applications without it. Edit: I realized that by asking about building a game engine, you probably ask if I wouldn't need to write stuff like ``` let foo = new Object3d() ``` And probably do something like ``` class Object3d extends GameObject ``` You can do that with javascript without classes. But the javascript classes are a little syntactic sugar that makes it easier than constructor functions
The lodash guys are fanatical about performance and I don't see any particular reason they couldn't beat the built-in stuff.
&gt; There's a reason why one of the biggest JavaScript job interview trick question is... No real life interviews ask that question or expect that answer. You were duped by a troll with an ax to grind against classes.
There is an app for just that, called Postman. It is using electron. To answer your question, yes electron can support http server, I have a project that has http server and also uses webockets.
This was my main concern introducing typescript into a re-write of a large aplication at my work. A lot of documentation and blog posts centers around using class based inheritance and OOP which I would like to discourage. Our solution was to establish clear conventions and enforce them through linting and CI. Flow was considered as well but I found the TS ecosystem to be more mature and 3rd party libs tended to have better TS definitions than flowtypes. I'm a big user of Clojurescript and to a lesser degree Elm. Languages designed around a strict paradigm like those can provide a lot of extra safety though currently aren't realistic for use at my work. Typescript has proven to be a good middle ground that is management approved that we can use to give us some of that safety. the main benefit being preventing new devs coming into the project and calling existing functions incorrectly etc.
I've got simple webpage with multiple subpage, and i want to make it SPA, so I made router for each page/subpage, but the thing is that on subpage it's jquery slider, and when i click this subpage to display it, it gives me blank page except the navbar which is defined in index.html and it's shown everywhere. To see the subpage with slider I must refresh that page and then it loads normally
&gt;One of the more intriguing aspects about maps is that, unlike with objects, the keys in question do not necessarily have to be strings. Instead, they could be objects, functions, even other maps. In the latter case, what is actually passed is the internal resource pointer for the resource in question, which means that even if the contents of that resource changes, the object itself can still act as a key. *This* is something I've wanted for years, and it's been frustrating not having it, when it was always completely obvious that there's an internal reference that can be used for the hash. Everyone has different wishes and priorities, but *this* is why I'm happy that maps are here. It is great, for example, for implementing metadata. Before Map, you'd have to stick metadata onto its object somewhere, implement a slow version of Map yourself, or use some other workaround. Now you can just directly point metadata to an object. I'd love to be able to use [] for the keys, but oh well, maybe that'll come in the future.
I haven't used typescript, but my impression is that it is only useful if you are programming in an OOP manner. Is that true. Is it useful for procedural or functional programming paradigms?
It's not that easy, if you just use the hash value as key you will have issues with collisions, therefore hash as key and arrays of values below that. That's doesn't sound very efficient, having that available natively would have been nice. 
microsoft also has way more experience designing language and tooling. theyve really hit their stride here. i was never a c# guy but i can appreciate how well done it was.
32-bit Linux is indeed a very small niche. However, Windows is very popular. You see, C# + Visual Studio is quite nice and there are also many devs who are gamers. Windows can be quite appealing even if its command line is kinda lame.
Not at all true. It's delegation not inheritance. They're not the same thing 
it is not true. typescript embraces functions as well.
With Ubuntu coming to Windows I don't see why companies would want to spend resources supporting Windows APIs. &gt; there are also many devs who are gamers Completely irrelevant.
If I had a fairly large codebase written in React / Redux + webpack / Babel, what would be the best method to introduce Typescript if I wanted to?
This is the only way libraries like bluebird and q are able to work with other Promises (native or otherwise).
You won't have collisions unless the objects are deeply equal, in which case you want collisions anyways. If the objects are not deeply equal, they won't have the same hash. 
We don't necessarily need libraries like bluebird or q in the first place if we have a good native Promise type from the get go.
Surely they could have just defined some non-enumerable `__promise__` property in the promises spec, or something a little bit less fragile than just checking for `then`?
Example, please.
Windows has a significantly larger game library. I bought hundreds of games at Steam and only a dozen or so of them work on Linux. Even emulators tend to work better on Windows.
Usually you would use a bad and fast hash function for hashmaps (not a cryptographic one). In Java for example hashmaps use 32bit hash values, collisions are common and likely. The strings Aa and BB hash to the same value in Java. 
http://stackoverflow.com/questions/18881487/why-is-lodash-each-faster-than-native-foreach The answers here go over them. 
They aren't inherently, inevitably going to be slower at all: if they are, they were made that way (and probably n part because they were made with compatibility with these older libs n mind instead of what made sense). And lodash methods aren't all inherently faster than native methods either (which are at any given time, and why, is a changing matrix): think about what you're saying as a general principle, it makes no sense.
You should use Webpack plain and simple. Require.js is years past its prime, and way too convoluted and complex. Webpack will split your code when you require.ensure modules, it will otherwise generate a bundle for code that you require. It also manages common chunks and makes sure they're distributed properly. For this to work you don't have to do a single thing, just code and it will act. The only tough part is the config file which you set up in the beginning. You also won't need dedicated minifiers and things like that. Webpack is your build system. Everthing comes in the form of loaders, which lint, minify code, markup, images, parse sass, read jsx, transpile es7 to 5, etc. Hot-reload dev-server is included as well.
That's silly, in that ~ all serious FP langs are typed.
You're so witty and kewl !
That's the whole _point_: no one forced promises to be written in that way. No one required that to be the spec. That's not because of some insane, nonsensical principle about custom libs always being faster than native. It's because of the spec. And so now yet again we have a kludged space of tons of Future types each with their own quirks.
I'm unclear what point you're trying to make. I mean, the people who wrote the EMCAScript 6th edition specification decided to force everyone to write promises that way. Those who wanted to adhere to their spec anyway.
Maps are supposed to be great at storing state. Composing them is trivial (just use merge), and functions operating on them are polymorphic by default (as long as the necessary parameters work, your function works). Consider the following: const Position = Map({ x: 0, y: 0 }); const Boundary = Map({ height: 100, width: 100 }); const Rectangle = Position.merge(Boundary); const Circle = Position.merge({ radius: 50 }); function shift(position, amount) { return position .update('x', x =&gt; x + amount.get('x')) .update('y', y =&gt; y + amount.get('y')); } shift(Rectangle, Map({ x: 50, y: 50 }); shift(Circle, Map({ x: 50, y: 50 }); This is a super effective pattern, especially when you're working with large code bases, since it forces a separation between data and how the data is manipulated. It's how everything is done in Elixir, and Elixir is amazing for large apps because of it (the other million great features of Elixir help too). Unfortunately, the pattern relies on immutable structs that can be composed easily (not necessarily maps). But, because JS maps are so poorly designed, they're useless here, and relegated to only being used in the rare occasion that you need an object key. You have to write your own merge method (which is basically what seamless-immutable does), use a non-native implementation of a map or map-like data structure (Immutable.js Maps and Records are great), or add/remove keys to/from objects the old fashioned way. Or you could write OO JavaScript, but there's no way I'm doing that to myself. It's just unfortunate that a feature in a language that should have widespread usage can only be used in rare situations. It's just so much easier to implement Object.prototype.merge than it is to deal with the Map API. Destructurable, immutable maps (and records) would completely replace objects and would be the best update to the language in years, but all we got was a cumbersome way of using objects as keys.
If you can destructure a map, you can use it instead of an object in every situation, instead of using it only when you need an object key. That gives you a native way of merging/differencing key-value stores, which we don't have right now. Not being able to destructure maps is the only reason you don't use maps for everything
A lot of it is due to browsers though, not JS.
Type systems are used by developers. Many developers, especially game developers, use Windows. It's not that hard to see the correlation.
If only they had said C#, with its `dynamic` keyword.
The Phoenix framework (Elixir) chose brunch after examining a bunch of tools; brunch is like webpack but simpler. You might like it.
So mostly sparse arrays, it looks like?
I hate this misconception. TS adds no additional OO features to JS.
This should keep you occupied for a flight or two: https://leanpub.com/javascriptallongesix/read (and its very good)
I have a number of links to ES6-related pages and articles at https://github.com/markerikson/react-redux-links/blob/master/es6-features.md . Not so much "design patterns", but certainly plenty of reading material on what the features are. In particular, https://ponyfoo.com/articles/tagged/es6-in-depth has a number of longer articles on the various features, and http://exploringjs.com/es6/index.html is _the_ in-depth reference guide to the nitty-gritty details of ES6.
Not at all. In fact I'd say the reverse: it frees you from OO by allowing you to declare struct types that can be passed to functions. I will concede however that the `private` keyword is probably one feature that counts toward OO and maybe `abstract` as well. I guess it depends on your definition of OO. I think [this video](https://www.youtube.com/watch?v=QM1iUe6IofM), despite its inflammatory language, is pretty useful as a discussion about what is or isn't OO. I would agree with him in that OO revolves around encapsulation.
Non-nullable types in TS are based on union types and there is also control flow based type analysis to make this smarter. https://github.com/Microsoft/TypeScript/pull/7140 https://github.com/Microsoft/TypeScript/pull/8010 E.g. if you have something like this: function foo(bar: number | null) { if(bar === null) { return; } x; // is a number } Then the compiler will know that x can't be null after that `if` above. This flag isn't backwards compatible though. You've to be explicit about null and undefined now. If something is a `number` and not `number | undefined`, you won't be able to set it to undefined anymore. If you want to try it today, you can just install typescript@next and set the "typescript.tsdk" property in VS Code: https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions
How about writing Gulpfiles in TypeScript ;) 
In the absence of an implements keyword, I think I'd agree with you, that would essentially give us record types which I am a huge fan of. &gt; I guess it depends on your definition of OO. That's definitely a key point here. By the definition given in that video, the notion of an "OOP feature" doesn't really exist. I think that's a fair point in the same way that use of anonymous functions doesn't necessarily mean "functional programming". BUT, I happen to believe that documentation and community are features of a language as well. When you look at the TS documentation and see what most (not all) of the community is doing with it, there are many features in the language that are intended for oop. Thanks for the link to that video, I found it really interesting
I think webpack is past it's prime too. If you are going to go the webpack route, why not instead use System.js which uses the system loader and jspm? Much cleaner and simpler.
You can make that kind of correlation with virtually anything. Also, the type system in question is Flow, a type system for JavaScript. &gt; JavaScript. &gt; Game developers.
sorry for another newb question, can you show some example http code?
I've been working on this for weeks now but I haven't revealed it to the public (other than IRC) until now: https://github.com/liftoff/HumanInput It's a lib for handling all sorts of input from humans. I made it to make handling keyboard shortcuts easier but then I needed to be able to do things like 'shift-click' (which is like, "keyboard+" hehe) and it grew from there. In the README.rst on that Github page is an example of how you can use it to let users define their own keyboard shortcuts which is one of the big milestones in my TODO list. Now that that's out of the way (it really works!) I am ready to move on to better demos, tests, and whatnot. I'd love to hear what other folks think about HumanInput. How's the code? The usefulness? The documentation? Etc. Any and all feedback is appreciated :) **Edit:** I just wanted to point out that the reason why I wanted to write a keyboard event lib was because none of the existing/popular keyboard libraries handle non-US keyboard layouts *at all*. For Mousetrap, Keypress, keymaster, KeyboardJS, and more it's "US or nothin." They're all based on key codes (as in, numbers) which vary wildly depending on keyboard layout (and localization!). I wanted to create a library that supported all the features of existing keyboard libs but worked with natural key definitions and didn't use character-to-letter keymap tables. Unfortunately, about 2kb of HumanInput is devoted to keyMaps specifically to support Safari since that browser doesn't support the modern KeyboardEvent.key attribute (or it's sister, KeyboardEvent.code which is also useful).
I find SystemJS much harder to use. Webpack just works and bundles for me while SystemJS needs an odd configuration and doesn't bundle
The subject in my answer has nothing to do with dynamically typed languages but redditors seem to be struggling with understanding the subject.
Or I can just code with plain ES5 js files and I don't need to install or learn anything new.
I suspect it's sold as an "OOP language" to .NET developers who've started writing browser front-ends for their apps. If you're ever on the typescript gitter you'll see a ton of C# devs there. But if you look at what the language actually is, for the most part it's just adding types to JS. It's not opinionated as /u/irrational_design seemed to think; it doesn't force you to put code in classes or anything like that. All the interesting stuff is in the types.
Perhaps he was referring to conventions. People have to learn how to use typescript if you're expecting them to submit code that looks and works like all the other typescript you've got on the project. 
lol... right, why would you want to do that?
&gt; const Position = Map({ x: 0, y: 0 }); &gt; const Boundary = Map({ height: 100, width: 100 }); Note - ES6 maps don't have an auto-conversion function from objects, nor do they natively support merge(). Adding that support for shallow objects is easy enough, but it's not native. /* map.merge() */ Map.prototype.merge = function(newMap{ Array.from(newMap.keys()).forEach((key)=&gt; this.set(key,newMap.get(key)))} Map.prototype.fromObject= function(obj){ let arr = []; for(key in obj){arr.push([key,obj[key]])}; return new Map(arr);} let a = (new Map()).fromObject({x:10,y:20}) let b = (new Map()).fromObject({z:30}) console.log(a) // Map {x:10,y:20} console.log(b) // Map {z:30} a.merge(b) console.log(a) // Map {x:10,y:20,z:30} Deeper conversions require recursive iteration, obviously. Immutable maps would best by defined by creating a new class of map, then use the .has() method to determine if a set is about to overwrite an existing field. 
Indeed, looking at stats from npm would already be much much more relevant.
I think it's still relevant, has some of the technology changed? yes. But patterns and anti-patterns exist, and it's a asset to be able to recognize them. 
That's how immutable js maps work
sure thing, here it is https://github.com/jareddlc/notifyte you'll be interested in the electron folder. 
&gt; I guess it depends on your definition of OO Definitely, because there are many proposals and I am not sure which is the "official" one. See http://wcook.blogspot.com.au/2012/07/proposal-for-simplified-modern.html.
What "odd configuration" does it need? You simply specify a loader like Babel or Traceur and that's it as a base. Also, it does have a bundler, aptly named systemjs-bundler.
Yes, you can destructure maps: let map = new Map([["x",10],["y",20],["z",30]]) for ([key,value] of map){console.log(key,value)} // x 10 // y 20 // z 30 
You can also do this: class ImmutableMap extends Map { set(key,value){ if (this.has(key)){ throw new TypeError("ImmutableMap is immutable"); } else { super.set(key,value) } } delete(key){ if (this.has(key)){ throw new TypeError("ImmutableMap is immutable"); } } } var map = new ImmutableMap([["a",5],["b",10]]) // Map {"a"=&gt;5, "b" =&gt; 10} map.set("a",10) // Uncaught TypeError: ImmutableMap is immutable. map.set("c",30) // Map {"a"=&gt;5, "b" =&gt; 10, "c" =&gt; 30} That makes the map object property wise immutable. If you wanted to clone the object, have set and delete *return new ImmutableMap(map)* instead. class ImmutableMap extends Map { set(key,value){ if (this.has(key)){ let iMap = new Map(this); iMap.set(key,value); return new ImmutableMap(iMap); } else { super.set(key,value); } } delete(key){ if (this.has(key)){ let iMap = new Map(this); iMap.delete(key); return new ImmutableMap(iMap); } } }
You can add the ts-loader in webpack to run before Babel. Then configure Typescript to target es6 and preserve any jsx. The output will get piped into Babel which will create your bundle. Here's a good [tutorial](http://blog.tomduncalf.com/posts/setting-up-typescript-and-react/) for that, just ignore all the Typescript 1.9 stuff. You can also configure Typescript to process normal js files so you don't have to change the extension on everything in one go. Just look at the compiler options on the main site. 
The tldr is they're proposing to make ES modules require an import or export statement to grammatically distinguish them from scripts (both of which are ways of embedding js in a web page according to the new standard). This is because modules have a bunch of characteristics like avoiding globals that they want to be grammatically evident. 
As you learn the patterns, look them up and see if/how they have changed.
Greenkeeper is free for open source projects and 1 private repo. And it doesn't auto-update anything. If one of the npm packages you depend on get updated, greenkeeper will run your test with the updated package. If the test fail, it will send you a pull request so you know that your project will not work with the latest version of your dependencies.
But damn, I feel like anyone writing a decent amount of javascript should be able to implement this (or even just parts of it) themselves at no cost, as another commenter mentioned.
ECMA262 has defined differences between how JS is interpreted depending on whether it is a script or a module. Existing bodies of JS code are most likely running in script mode and will quite possibly break if you suddenly flipped a switch to say "module mode for everybody" - so there is active discussion on how to handle the transition. The core of this proposal is to make JS files unambiguously either a script or a module - by requiring either an import or an export statement for any code that is intended to run in "module mode" It also proposes a high level intent mechanism - for example a package could hint that its source was made up of modules or scripts. This intent would indicate which parser to try first but falling back to the other parser if the first parser failed. Given that scripts are unambiguously either modules or scripts, this intent is more of an optimisation than a requirement. 
This isn't really necessary for tc39 to add. Modules can only be imported via &lt;script type="module"&gt; or an import statement. Node should either follow suit, or implement this heuristic themselves.
...or a globally unique symbol, like Symbol.iterator for iterables. But still you wouldn't be able to safely use that value as a key in an object dictionary. Basically, an object's properties are meant for API: methods, properties, stuff like that. The [] operator is useful for reflection of that API. Using objects as a dictionary has big problems, even though the syntax makes it feel good, and we've done it for years in the absence of a native Map. Finally we have native Map; we'll just have to accept the use of `get` and `set` methods like in some other languages.
I think the point being made is precisely that the people who wrote the spec *did* make that choice and that they could have chosen a better alternative.
This gets a lot harrier if you're, say, an editor or IDE trying to provide type information or do autocomplete.
There are two competing ideas here: &gt; 1. CommonJS modules continue to be named module-name.js, while standard JavaScript modules are named module-name.mjs in the Node.js ecosystem. It is not necessary for the wider JavaScript ecosystem (web browsers, web frameworks that have already adopted standard JavaScript modules, etc.) to adopt .mjs as they can continue to use out-of-band configuration. &gt; 2. Packages can opt into standard JavaScript modules or specify which files Node.js should interpret as standard JavaScript modules using package.json. This aligns with existing practice in the wider JavaScript ecosystem that has already adopted standard JavaScript modules, but has a number of non-trivial technical and ergonomic challenges [In defense of .js](https://github.com/dherman/defense-of-dot-js/blob/master/proposal.md) 
Yes, it is definitely relative. Design patterns don't change.
yes, strict is safer because instead of undefined behavior your code will fail, and you will find the bug and fix it.
You can go through the list of behaviors changed by "use strict": https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode Generally, it aims at catching things you probably didn't mean to do and failing loudly (throwing exceptions) rather than ignoring bad code. 
If there are things I can do without a computer I like to do it that way. List of objectives, class design etc I like to do on paper. It's important to get away from the computer for a while. I usually start coding before having designed the full architecture, then refactor when I see how things could be done in a better fashion.
http://s2.quickmeme.com/img/0f/0ff49113f737f6725161e579f345863f0a8b6d82d260aca7a3726c18b760b024.jpg
Yes this can be very time consuming. I've yet to find a library without type definitions. I guess I use more popular ones and don't have this problem. What you can do is declare types as 'any' in your .d.ts file and not deal with types until they become available. Then there's this https://github.com/teppeis/closure-ts
&gt; Given that scripts are unambiguously either modules or scripts, this intent is more of an optimisation than a requirement. That clarifies a lot, thanks.
I think this is a pretty bad proposal. For one thing, the situation already exists and their proposal would require changes to existing code which I think is highly undesirable. Second, it just feels counter-intuitive to intentionally insert parse errors for one environment to force adoption for another. I have a large project with CommonJS modules which I intentionally parse in module mode despite not using any of the new module syntax. This gives me some very real benefits: * My code is automatically in "use strict" mode without me having to specify this manually for every file. * CommonJS already makes sure every file has its own local scope, rather than making declarations implicitly global, so treating the code like it were true modules seems the right thing to do. Unfortunately module import statements are not allowed to be used inside functions which means that if were to use that syntax and let Browserify package everything without transpilation, it results in invalid syntax. This is the reason I still use CommonJS require calls and module.exports definitions, because the use-case without transpilation is valuable to me because it saves seconds due to the size of my codebase. Now I can understand my use case is already a bit of a gray area, but it sounds like this proposal would make it flat-out impossible, which I would naturally be quite unhappy about. So my money would be on the proposal linked by /u/der_flatulator below (which seems all-round better thought-out anyway) instead.
I think the problem is that if you include a 3rd party module as a dependency in your node project, you don't necessarily know whether it was written as a CommonJS or ES module, and node wants to allow you to `require(module-name)` or `import module-name` and have it work as you would expect. So they can't rely on the importing script giving any indication about what the imported script is. Many projects have a lot of existing modules written in CommonJS, but their authors may decide they want future code written as ES modules, while progressively migrating the older code. So they may then have ES modules and CommonJS modules living side by side during a transition period.
You don't have to make changes. You just require and that is it. It is just the config file that you set up once that can be tough due to the terrible website they have. But there are many examples and tutorials out there that help you creating it.
True, but if they know something like c# it's not going to look too foreign.
Thanks! Anything in particular you like about it?
Seems cool, perhaps make it modular though as 8.8KB is quite steep and it seems to cover every possible input type of which most are likely redundant on a per project-basis.
What exactly does it do? I started read 3/4 of the post but still have no idea what it does lol
And the name dropping begins
Hah! You're not the first to say "make it more modular." I do have plans to do that but honestly, I'm having trouble imagining much of a byte savings. Having Safari support as something that could be removed would probably save *far* more file size than, say, limiting the lib to *just* mouse/keyboard. The majority of the lib code is in regards to handling *events*, keyboard stuff, and a few bytes here and there for the other event types. For reference, when I first had working mouse/keyboard code the gzip file size was about 6kb.
I will give you that, webpack does handle CSS, which is very nice.
is it normal to use express with electron?
I see, then I'd say you made the right call.
Hah! That's *exactly* what I was planning next: Getting rid of all the prototype and self.whatever stuff to replace it with a nice merging function and a single big object (or similar).
Sure you can write it yourself. I would store all my projects and their respective dependencies in some db, use a cron job to continuously check for npm package updates, if any dependencies updated then run the test suite in that project and if the test fail submit a pull request. That's cool. That actually sounds fun to do when I have the time. But for now it is just simpler for me to run `greenkeeper enable ` and let someone else's servers do that. At no cost to me because I don't have personal private repos, so it's free.
Hey, folks! I just published a new lazyloading module to Bower, and I'd love to get feedback on: - the API - implementation ease / ease of understanding - the examples - any bugs (so far I've tested it back to IE11, but it should be fine in any older browser thanks to feature detection) The source is linked in the example above, or you can [check it out on GitHub](https://github.com/jlengstorf/responsive-lazyload.js). Thanks so much!
i don't think anyone really cares enough pro tip: things like this do not actually matter in the real world javascript containers rarely have more than a couple hundred elements in them
So... are you saying I don't have to explicitly use strict for es6 ... Like if I am using modules the interpreter is *always* going to run use strict?
how odd. Architecturally speaking, the relevancy of webpack seems to be reducing, right? Am I the only one who sees it this way? Webpack is awesome now but, what is the use of a bundler in a world with full http2 support? In many cases, bundling would be less performant than http2 multiplexing, and world's less complex(uh, just do nothing but follow web standards). Especially when you consider long-term caching: In common webapps, cached bundles invalidate themselves with almost every release you make (cause it so much stuff bundled up). In an http2 world, smaller caches can be valid for much much longer. It's a game changer. I know webpack can do a lot.. but it's by far the most complex build tool out there; i've see so many devs struggle with it. When those complex things that it can do are no longer problems, then it's just not worth it. Smaller, easier to configure build tools will take over. My prediction is that the final nail in the coffin will be js module support in browsers; we're probably a couple years away from that though. Also AWS support for http2 in Cloudfront CDN and ELBs should be a major turning point. Maybe it will become one of those tools only used for people needing older IE browser support (to get es6 via babel). 
Not yet, modules and sharedarraybuffer, let alone https2
Hmm...yeah...do you know any tutorial that covers this? Sorry but I am a noob in Webpack that's why it's going little above my head. But maybe I need to try harder and spend some more time on docs :) Thanks for your help!
just because there is one doesn't mean you shouldn't make yours, good fun and practice. 
It's not just the bundle, it's the ability re import everything else besides source code, to have loaders handle it for you, to get cache-busting out of the box, to specify different builds for different environments... Webpack is the best fully integrated build tool available as of now !
No - you would put express on the separate nodejs application, not the electron application.
You're missing something... cache busting is the problem. 
Once you "get" Webpack it's really no harder than any other tooling system. You create a plain object that points to an entry file and output location. Add built in plugins or download ones you need and create loaders and plugin keys in your object. Then run Webpack with the JavaScript object you've created.
&gt; Webpack is freaking awesome. &gt;I haven't done anything that complicated with it So, webpack is awesome as long as you don't try to do anything complicated with it? 
My only gripe is that IE throws more errors than Chrome, and I forget to test IE before commit and then get page breaking defects logged against me later when QA tests IE. So I lazily remove the use strict and call it a day. I know it has something to do with inner functions in the wrong place, but I prefer to declare the function right next to the usage for readibility.
I disagree. I've seen some very talented developers working in companies i'm sure you've heard before try and fail hard to replace gulp and grunt completely with webpack(some thing are easier than others). You can pretend it's not hard to use but you're only fooling yourself or maybe just downloading boilerplate all the time, which I agree is very easy. 
I can't argue that boilerplate is not easy to download. I also can't argue that webpack is not great for fun little side projects. enjoy!
HTTP2 won't remove the need to bundle, even if people keep saying that. Even with HTTP2 serving hundreds of modules is more expensive than bundling. And having ES6 in all major browsers won't make the need to compile transpile/compile go away.
Yes, modern JavaScript build tools are complex. They can be made easier to use. However, moving complexity from the end user / browser to the build step is generally a good thing, and will not go away.
Webpack is awesome, but I am still not a fan of the way it handles stylesheets/css/preprocessing. I'm a bit set in my ways but I prefer distinctions between my js &amp; css. I know there are workarounds but for my projects gulp just handles that side of things better.
Can anybody ELI5 to me what webpack is? Is it something like Browserify?
I've got a number of tutorials on Webpack in my [React/Redux-related articles list](https://github.com/markerikson/react-redux-links). See the [Webpack Tutorials](https://github.com/markerikson/react-redux-links/blob/master/webpack-tutorials.md) page and the [Webpack Advanced Techniques](https://github.com/markerikson/react-redux-links/blob/master/webpack-advanced-techniques.md) page.
I remember when Grunt came out I was equally bewildered by it as Webpack. I wasn't familiar with the fairly unique declarative syntax that Grunt had and had a very hard time making anything complex. Exact same thing with Webpack -- plus their initial documentation was garbage, which made it even harder. Now Webpack is just as trivial as Grunt in my eyes, just way more powerful. Learning something new with subpar documentation and no google results is a pain in the ass. Webpack suffered from that but has gotten much better. Trust me, the more you and your developer who works at companies I've heard try using Webpack the more intuitive and simple it will seem. Most people have a sour response to Webpack because it's fairly unique and poorly documented. But just because something is initially hard to learn shouldn't discredit it for the awesome features it brings to the table.
It's awesome yet, because he hasn't done anything complex yet :) Quite an important difference :)
oh we're just we're talking about webpack/bundling here. I've no beef with other build tools which don't add complexity for a bundling feature which might not want with a more modern architecture. Hey if you want to use webpack forever go ahead. I'm just trying to get people to realize there may be much simpler solutions for their use cases. I mean that's kinda what web standards are built for. JQuery is dead because of web standards and soon your other favorite tools will be too. don't get so attached.... 
don't bother... it's got an expiration date. 
Depending on the stack it can totally be done. I wouldn't ever consider myself a 'top' developer but I baked it into a really old rails app just recently without too much trouble. I can only say personally but after an initial WTF I did find webpack pretty easy to understand. That being said I have seen people struggle, its mostly junior level devs who struggle to understand what kind of tooling they really need.
I mean... I did that exact process all by myself for a massive enterprise project in about month with not all that many issues, and I wouldn't consider myself to be a super talented developer. We've been using it ever since and had no real hiccups. I'm not saying you're wrong, but maybe it's easier to grok for some people?
Wow, you're right. I just assumed that many users didn't support ES6 yet. Most Safari users are on 9. Internet Explorer is only about 6% (I don't check very often, I would've thought that'd be at least 20%). Edge 13 is growing but it's still only about 1%. But now that Microsoft is forcing everyone to upgrade to Windows 10, that's bound to increase faster.
[Here](https://github.com/webpack/webpack/tree/master/examples/named-chunks) is the example for named chunks, I think this the most of a tutorial you're going to find. If you need more help though I just got done organizing a system this way so I can probably help. Once you figure it out *YOU* should be the one to make the tutorial.
Um, how is using webpack not leveraging the"simplicity" of the script tag?
what next gen feature are you trying to use? if you are using something that's taking years to settle... you probably shouldn't be using it. Unless of course you wanna rework it all later. Babel was great when browsers couldn't keep up with accepted standards. Then can now. Babel is on life support for anything but side projects. 
&gt; Webpack's bundling solution can never beat the simplicity of a basic script tag It is made to simplify that. https://blog.tighten.co/assets/img/toomuchcode.png
I'm saying you can get better performance than webpack bundling your code in most cases just by using simple html tags over http2 without bundling. 
Yup and so much documentation or "guides" out there don't even begin to explain the basics or they use terminology like you are already semi-expert in the area.
Have you looked at browser usage stats for a large website? The platform I work on ($2b annual revenue) won't be able to drop the transpiler for the foreseeable future because 5% of our users are still on IE11 and 15% are on mobile Safari without full ES6 support. Side projects where you don't care about revenue are where you can drop the transpiler, but on a large system it's not even an option unless you're willing to turn away 20% of your customers.
It's not like I'm the only one: https://twitter.com/mikeal/status/747217789094502402?s=09
I feel the same. I mean, I don't want to program in Java and get stuck using JSF for 10 years... but I don't want to learn a new technology every 6 months.
sorry i think the thread got too confusing. two points: gulp and grunt are great because they don't try to solve the bundling problem that is already solved by modern architecture with web standards (http2). webpack's core complexity is it's bundling ability which is much less important now due to advancements in web standards web (http2). 
Fuck off!
Dude i am sure you are not the only person who thinks this way. Trust me, I'm not only person who sees http2 changing the web. This article was about the future of webpack and it's evolution. If we're talking about the future, you're just a fool to ignore web standards. And as I keep mentioning, http2 support is here &amp; now, for many use cases. 
I'm not ignoring web standards and I'm not a fool. HTTP2 and ES6 modules are great. But it's simply not true that they remove the need to bundle. For some cases, sure, but a lot of people seem to believe that they magically solve everything which they don't.
 Sure do what you gotta do for now. This article was about the future though. If for some reason you think full es6 support is too far down the line to think about then yes, please ignore http2. good job. And uh ya know a transpiler is not necessary right for much of es6 in saf and ie11 even right? If you've been ignoring what you can and can't use in safari and ie11, that's just bad development. So you decided to server transpiled code your end users for which unsupported es6 feature? hmm. interesting. 
How do you add your dependencies then, going back to your original claim that tags are so easy to handle. A UI components lib alone will cause you 30 with ease. Now you're using them in 10 separate html pages. Tomorrow their version changes. You're tail chasing your code, which is what you've done before Webpack has put an end to it.
Every time you open the web app you read the names from the spreadsheet. Everytime you add a name - you add a column to the spreadsheet.
I do something like this. https://gist.github.com/arajparaj/e16cd9ed42669ea890c3290a15ecde6d You can use getChildRoutes, getIndexRoute etc also as a way to split and lazy load codes. 
Its part of the package.
i have much more confidence in this generation of their languages than a first attempt from facebook. especially given ms longevity. fb is still a new kid and just a social network. think aol making a language early 90s.
I too think that treeshaking is a huge feature. React is [experimenting](https://github.com/facebook/react/pull/7178) with tree shaking and dce. They managed to drop 10% just by converting their requires/exports to es6.
I am no expert but I think I have a sense of what's going on here. Think of it in terms of what happens first, the callback passed into th{1-3} or, the response resolving before receiving the callback. In `getFile` if the async op finishes (`fakeAjax` callback is executed) *before* `th` is called, the `fakeAjax` callback has an opportunity to set the `resp` variable to the actual response. It might seem counter intuitive to think that the `fakeAjax` callback might actually have a chance to be called before `th` but it could be that the operation on the other side of `fakeAjax` *is* synchronous, in which case the callback definitely will fire before `th`. There is also the possibility that for some reason the asynch op does finish faster than you have an opportunity to pass in a response callback. Also, since in your example you are chaining callbacks within callbacks to th{1-3}, `getFile` is managing the async ops. Now in the `th` function, let's say the async op has not finished yet when it's executed. At that point `resp` will not be set so we don't have the response yet so well set `resp` to the actual callback that was passed into th{1-3} so that when the async op *is* done, the callback can be called because in the async callback context, `resp` *is* set (to your callback to th{1-3}) so we can just pass the file contents to it. But if we *do* have a response when `th` is called, we execute callback as `cb` instead of `resp` passing the response to it. It's tricky because there are 4 different scenarios that can play out and the `resp` variable is juggling purposes depending on the current state of whether the async op is finished or not. I hope I haven't added to the confusion. Just want to add that `th` is executed whenever to execute any of the th* functions are executed, is case that was unclear.
&gt; Side projects where you don't care about revenue are where you can drop the transpiler, but on a large system it's not even an option unless you're willing to turn away 20% of your customers. You made it sound like you didn't have a choice on whether you use a transpiler or not. You're doing it so you can arrow functions. I guess that's fine, but you certainly won't need babel for that pretty soon so what will be your next excuse? 
Decorators. Also I'm a different guy than the one you quoted. 
glad it helped :)
I've used https://github.com/webpack/react-proxy-loader in the past. Works well.
I still struggle with what the benefit is of webpack over browserify. Browserify works fantastic for me.
Same. Honestly I just studied "complex" configs like [this one](https://github.com/mxstbr/react-boilerplate/tree/master/internals/webpack) and started using [this](https://github.com/HenrikJoreteg/hjs-webpack) for small projects and it was fine. But honestly, if you don't like Webpack it's fine. You can still use whatever you like!
Was curious what a mash of Lisp and DustJS would look like, so I started to create a Lisp-like template language. Crunching on tests today to find and fix bugs. https://github.com/HallM/lisplate
Your question needs more information since the regex `/\W_/` behaves exactly like it should--i.e., match a non-word character followed by an underscore. What are you trying to accomplish?
X-Post referenced from /r/webdev by /u/okwolf [Example Maven Frontend Project with JSHint, Jasmine, Karma with Coverage, and LiveReload](https://www.reddit.com/r/webdev/comments/4r3zwt/example_maven_frontend_project_with_jshint/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
Yeah tree shaking is crazy. Its especially insane to think of something like d3 where you may only use a small portion of it, but doing it on you own would be crazy hard. The benefits you can get from it can be hundreds of kb potentially.
https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/getImageData
&gt; Webpack is awesome now but, what is the use of a bundler in a world with full http2 support? "HTTP/2 is used by 8.4% of all the websites." https://w3techs.com/technologies/details/ce-http2/all/all
Great question. I've spent a number of hours researching Angular 2, but I haven't read much about Aurelia, yet. I just uploaded, to my personal web site, an essay with my thoughts on Angular 2 which may be helpful to you: http://danielsadventure.info/Angular2/PrimeTime.html
Why isn't jspm very popular? I understand that jspm specializes in applications, not libraries, and so might not has as broad a reach as webpack. npm-stat for jspm is at about 10% the monthly downloads vs. webpack, but most troubling there is no clear growth trend for jspm.
I highly recommend https://github.com/easy-webpack - it is quite new, but the goal is to abstract complexities of Webpack into configurable modules. Developed for use with Aurelia first, but supports any Webpack project to be honest.
 the article was about the future. if you think you should ignore http2 in the future, you're a fool.
I'm not an authority on JS or anything like that but I started with jquery because it was easy. Now that I'm learning Javascript native and design patterns relating to more abstract aspects of programming in general, I've come to appreciate why jquery existed rather than just accepting it. My recommendation is to start with using javascript native then use Jquery. It'll be a little painful but you can only rely on jquery for so long until it catches up with you. For more, have a read of this - http://blog.garstasio.com/you-dont-need-jquery/why-not/ and http://youmightnotneedjquery.com/ 
Obviously I'm not saying to ignore it. Right now though, http2 is not in wide use which is good to be aware of.
hey well i tried.... you go ahead and keep using jquery forever... completely ignore the fact that native JS will always be faster and more future proof. Here's a very popular link you probably should have seen years ago: http://youmightnotneedjquery.com/
Thanks, I really appreciate it 
I will, thanks!
I assume that was the point, the ES2016 spec is out and is now the standard, why write an article title about an outdated version?
Been looking for a project idea to play with Electron. I think you just provided the proverbial lightbulb. 