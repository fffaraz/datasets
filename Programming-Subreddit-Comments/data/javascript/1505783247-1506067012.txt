package.json isn't even necessary, most of the scripts I actually run with `node` explicitly don't even have one. I'm more in favor of an `--esm` flag that eventually becomes the default over the course of a few versions.
[GIF](https://imgur.com/a/85aAY)
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/v3cCzI0.gifv ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dn70xqi) 
But it goes into `import` `export` module syntax? Dunno, to me `async` and `await` falls under "modern javascript"
It would. I'm pretty sure this is just so you can do the equivalent with Promises directly (although you already _sort_ of could). 
I, for one, like Redux. &gt;For each component, you have a file for the Javascript, a file for the style, and one for the JSX. Redux compounds this with action and reducer files and another for bringing it all together. If you have a 1:1 relationship between components and reducers, you definitely shouldn't be using Redux. Not that this is necessarily what the author was implying. Not sure why you'd want a separate file for JSX either. Am I sinning against best practices by putting my JS, JSX, and mapStateToProps all in the same (container) file? I mean, I'm pretty sure I'm supposed to be using mapDispatchToProps, but I never have.
Es6 seems interesting 
Nice! Next step... getting those charts rendered as SVG e.g. Chart.js / D3 / gRaphael? :D 
I'm personally in favour of this as well. I always thought it would be best if `import` were for esm and `require` were for cjs.
It's a React prep sheet. The name should be different as that's the intention.
YEP. Absolutely annoying. I hate it so much. 
Perpetually.
I have a [saved chat log where I discuss the relationship between "containers" and folders](https://gist.github.com/markerikson/ea312b5ee398627ffceb09f89904831f). So, to me putting the "plain" component and the `connect` definition in the same file _is_ the best practice. And yeah, I have no idea why anyone would want to put the JSX in a separate file. A weird holdover from string templates or something? My standard component file layout looks like: import React, {Component} from "react"; import {connect} from "react-redux"; import {addTodo, toggleTodo} from ""./todoActions"; const mapState = (state) =&gt; { return { todos : state.todos }; } const actions = {addTodo, toggleTodo}; class TodoList extends Component {} export default connect(mapState, actions)(TodoList); And, while [I'm not personally a fan of the "ducks" pattern ](http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/#defining-actions-action-creators-and-reducers-in-separate-files) for combining Redux action creators and reducers into one file, it's totally a legitimate pattern if you want to cut down on the number of individual files involved.
I think its because he wants to show that you can have a default value when you are deconstructing
This title should mention react. Do you actually think that all modern JS devs use react? 
It's a scam, don't go to the website.
Oh, I see. I think what tripped me up is that he emphasises that he's using his `const Person` object for the entire section and then up pops an undefined `Person.city`. Emphasising default values in a section about deconstruction seems to be a bit of a detour. 
Considering that you simultaneously cross-posted this to Rhino's github issues, I'm not sure what kind of magic you were expecting to happen here as opposed to there. 
No idea, but you are definitely either abusing mod powers or didn't read my post. Either way, good for you.
I think we also need a `.penultimately()`.
Yup, I've got this working in Ayo as well: import require from 'module'; Although you can also import CJS from `import` but only default works :-/ Really stinks for stuff like this: System.import('module') .then(({ default: require }) =&gt; require('fs')) .then(({ readFile }) =&gt; { console.log(readFile) }); Although eventually the Node core will be ESM-compatible allowing for direct access like: import { readFile } from 'fs';
Yeoman perhaps? http://yeoman.io
Those charts are SVG...rendered with D3.
Hi /u/rmccaul3, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (/r/javascript is not a job board).
Hinging the premise of the article on the fact that "children" is an improper name for a render callback and then using "Width" for the same purpose in the final example was a real head-scratcher. Do you even `onResize`, bro?
This article seems to have been written a week before Merrick Christensen's [Function as Child Components](https://medium.com/merrickchristensen/function-as-child-components-5f3920a9ace9), which is also worth reading Interesting to note that despite React Router Co-author Ryan Florence's quote in support of Functions as Child Components, React Router 4 actually seems to favor the "Function as Prop Component" solution via the [`render` prop](https://reacttraining.com/react-router/web/api/Route/render-func), or as the explicitly passed [`children` prop](https://reacttraining.com/react-router/web/api/Route/children-func)
"I accidentally pushed a breaking commit to the new release so obviously I'm understaffed"
Regarding the hotspot part, I made something similar for a library I was working on : [link](http://elbywan.github.io/quadtree-lib/demo/collisions/collisions.html) It's actually quite easy to make in vanilla javascript. Simply put you just need two nested tags : one with position relative, the other inside with position absolute. Then this code which should turn the nested element into a draggable (and resizable) square : [link](https://github.com/elbywan/quadtree-lib/blob/master/demo/common.js#L64)
Yeah I noticed that too about weex. It's a real shame.. Thanks for the info. I got Cordova installed but I give Quasar a spin too then. Are you able to use Cordova plugins in Quasar just fine?
Good suggestions, I will add this specific behaviour with default value in the document because I think it's indeed expected for default to be used when null is passed on, while it's not. As for async / await, it's on my list for next updates ! It makes me think I might put that list I have on paper on the bottom of the readme :).
A new extension has appeared.. this will be fun! 
React UI animation made simpler. Don't use React!
bro take it easy, i spend my weekends for this project to help other developers out there, if you don't like React it's cool too :)
video and music are just data... wtf is this drm special snowflake treatment crap?
Yeap, unfortunatelly, it was ignored by community, but it is very useful in making Web lighter
The best [JS](https://developer.mozilla.org) and [Node](https://nodejs.org/en/docs/) cheatsheets. Unlike this one those will be updated regularly.
The problem I intend to solve is with ionic I may have to learn angular and/or bootstrap to develop some applications. What if I didn't have to learn so much? What if I can do all that with one framework that does all of this for me? One framework for all. This is what I aim to gain.
I haven't had a lot of experience with WebdriverIO - could you point out the reasons you like it better?
They used the coinhive client
Let me repeat - not testing something at all because it is difficult to test is problematic. Granted, a few years ago it was really *too* difficult to be pragmatic, but in the last few years the tools have become increasingly professional. The main changes that happened were: 1. The main thing - the image comparison algorithms are smarter. They don't perform bit-wise comparison anymore (which never really works due to different painting algorithms in different algorithms/operating systems/gpus), but are much smarter than that, in that they look at the different "regions" of the screenshot. And AI techniques are making them smaller! 2. The ability to fine-tune *what* to check in the screenshot, so as to remote the dynamic areas. 3. Commercial companies (like my company Applitools) are investing significant R&amp;D in this area And if you're already doing functional testing in the browser - whether using selenium, webdriverio, or others - then adding visual tests to them is not a big deal today, as I hoped I showed in the blog post. 
You know that ES2015 cited CoffeeScript as one of its main inspirations, right? Without CS, there wouldn't be an ES2015 quite like what we have now.
It wouldn't make sense to take the default when null is passed. null is not undefined. It might make sense to use the default if undefined is passed. It is important to be able to explicitly pass null.
First, put the brakes on this. Then go learn JavaScript.
I'm not saying it should be different, just that it might be counter-intuitive at first :)
The difference between undefined and null is that null *is* defined, so it shouldn't be as a great surprise.
I'm pretty sure the author decided to take 'React' out of the title for this exact reason at some point, but forgot to change the title in the ToC. 
I get why you would need the special handling for script tag though, since you need backwards compatibility.
Unlike this one, those are enormous with thousands of pages. Do you know what a cheatsheet is?
It feels like a workaround more than a solution imo
Literally written an article about it https://medium.com/@gajus/the-wheels-of-open-source-weve-got-many-of-them-b345b74b1496
Does OP know? Because it's not a cheatsheet either.
This is one that splits people and not just in JS: people often expect DEFAULT constraints to take effect in SQL when a NULL is provided for a column (it won't, if you want it to you'll have to use a trigger). Personally, it has always made sense to me: I've explicitly put NULL there, I want NULL there, not the default value. Not having it that way leads to having to create extra flags that need to be set when you really want a null value in a variable/column and can cause a further proliferation of unknowns (VBA's four constants of the apocalypse: empty, missing, noting &amp; null).
Why so?
If you take a look at the document, you will see that I often suggest to check MDN to find out more about notions addressed. About the updates, I will do them when I or people will find things are missing. If it goes out of control for any reason, I will indicate it in the top of the document :). However, I agree that the "Modern" word might not be the best choice for a title. I've chosen to use it anyway because most people will understand what they will find in the doc today and in the next coming month, maybe years. Indeed, if the doc was about a fancy new library I would agree. But it's about JavaScript, what is described there is not going anywhere. The industry is not moving very fast so people might find it useful for some time. Besides, the doc purpose is not to replace nor compete with MDN or official docs. The purpose is to have most notions encountered now in a single page that sums them up and points to references for more details.
It was a mistake, at first I wrote such a doc for friends and then changed my idea but I forgot to change the table of contents accordingly.
If you're referring to this [var](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var) it's just good old javascript (no jQuery involved). You should try to learn the [basics](https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/JavaScript_basics) first !
Ive tried to read this a couple of times, it it makes no sense to me. I guess there is a typo and you actually meant to say "shouldn't bundle" instead? The reason I want to use bundle is only for Dev purposes, to remove one step and get more instant feedback 
Async await is es8/ES2017. Es7 is only the ** operator and array.includes
Thanks! Isn't Jquery better to start though.
I guess a lot of sites won't work properly anymore.
You need to know javascript to use jQuery properly.
It was a mistake, at first I wrote such a doc for friends and then changed my idea but I forgot to change the table of contents accordingly. Thanks for your positive feedback by the way ! :)
First step would be to learn the difference between Javascript and /r/java ... :-)
I see. I've been told It's easier to start with jQuery in order to understand JavaScript. Anyway. What could possibly be a fun project to play around with JS? I assume I could create an interactive chess game?
Or the same using a decorator, makes it a little leaner. I figure that most of the time i have no need for the plain component and exporting it connected right away saves some overhead. import React, { Component } from 'react' import { connect } from 'react-redux' import { addTodo, toggleTodo } from './todoActions' @connect(state =&gt; ({ todos: state.todos }), { addTodo, toggleTodo }) export default class extends Component { render() { return &lt;div /&gt; } }
its completely fine to use it. Just don't go too excessive here (as everywhere). One of most popular solutions for dropdown menus in vanillajs requires stop propagation. 
I am not sure whether I am correct or not, so I really need your help to improve ðŸ™‡
That's basically what's collected internally. But you just turn Type Profile on or off, you don't need to annotate your whole code with `console.log()`. Kind of like you'd rather step through with a debugger than put `console.log()` everywhere. You could collect type profile of your production code without changing a single line of code. 
apparently you didnâ€™t even spend 30 minutes looking at ionic or other frameworks. good luck.
And a new syntax error (if you use "use strict" into a destructuring function)
What are you trying to mine?
I made a home page generator that can make a resume style website from a single JSON file using Preact last week: https://github.com/tomasswood/preact-homepage-generator
Having high-level containers coupled to Redux is no problem. Most of the time, components that take a lot of data from the store and primarily compose smaller components together are very app-specific and it's not worth the increase in complexity to move all the Redux stuff out of them just to "be correct". If it turns out you want to re-use the container later, it's trivial to move the mapStateToProps/mapDispatchToProps Redux stuff out and put it somewhere else anyway.
&gt; Is that the loader they were talking about in the post about implementing WebAssembly support in Webpack? Not exactly - I think the high-level goal about supporting WebAssembly in webpack is actually more about enabling non-javascript assets to be bundled with the rest of the code (not entirely sure, don't quote me on that :). WebAssembly would probably be the main consumer of this kind of technology, but I guess it would also be useful for images, sounds, etc. &gt; However, to address the separately compiling issue, I believe it has to become a Webpack plugin rather than a loader: only plugins can access all files at once, whereas loaders work on a per file basis. Hm, maybe, that's something I'll have to investigate. I liked the simplicity of a loader, but maybe shipping with an extra optional plugin would make sense for power users. &gt; From a quick glance I see the conversion to/from TypedArrays is done by iterating over and converting each element. That proved to be very slow in my case where I used the build-in vecFromJSArray doing a similar thing. Totally! The current implementation is very much a work-in-progress, since I wanted to quickly have a working prototype. I left a comment on the issue about an idea I have to improve the perfs on this side.
Nice! I like that it has no dependencies besides React :) I notice though that you're using JSON.stringify to compare objects, that won't always be correct (attr order) and it can be slow. Since you're comparing style objects, they are shallow and you should be able to check that the `Object.keys` length is the same and for each key in one, the other has the same valueâ€¦
Thanks InconsiderateBastard... De_Wouter not anything specific I would prefer lower easier to mine currencies just wanted to test it out and play around with the whole concept of replacing adds on a site.
Thanks for reading this, but I have found the problem. I had colons : instead of semi-colons ; after each break. Runs OK now.
I did and and as a beginner I didn't understand it as much. That's why I came up with this. If you can see I started this about a year ago when I started learning about js and frameworks.
Imports are read-only views of the exports. Read-only in this case works similarly to const. That is, you canâ€™t assign a different value, but you can change the value (if it is mutable).
awesome mate! thanks for looking into the source code, i will patch that over the weekend. much appreciated :)
Your browser's dev tools (F12) display the DOM as a tree.
Preventing events from bubbling up isn't necessary if those listener for whom it's important check the event's target (`if (event.target.classList.contains('foo'))` or whatever).
Great resource man, as someone that tries to get more into javascript this is a awesome.
Just wrote this, might interest you : [repo](https://github.com/elbywan/htmltree) [demo](https://elbywan.github.io/htmltree/) It's just a quickie and it needs a lot of refining, but if you are interested I can take some hours to polish it.
Some days around here it feels that way
Thanks for this. Its really helpful for a quick brush-up.
I don't care. React is the latest fad. In two years, it will be something else and React will join the dung heap. If one were to stick to fundamentals of web development and not all these fads, web development would be naturally be simpler and not tangled up and confusing like React has made it.
Really good article, thanks for sharing. Must say the fragmentation of the JS Open source community does seem crazy. Even among the bigger players, like Facebook creating another NPM client instead of just trying to improve the current one is rather frustrating.
Right, but what's the difference between modern JS and Coffeescript now? JS has absorbed most of Coffeescript's ideas, so much so that Coffeescript is basically just a wrapper and its' output needs to be transpiled back into ES5. At this point, why use Coffeescript? What does it offer over modern JS, other than allowing you to skip braces?
youâ€™re right: not much. but saying that while leaving out that it helped to get us there is doing it a disservice.
so that your coffeescript project doesnâ€™t compile to old JS syntax anymore when thereâ€™s a faster native browser/node implementation of the feature. so that you can continue to use CS if you used it before or just like the few remaining things it brings to the table (significant whitespace, implicit returns, postfix conditions, other small niceties) so that you convert it to JS, clean it up, and switch the codebase to JS that way. quite some options!
No it's not yeoman. 
you mean like const $g = (foo,ref) =&gt; foo &amp;&amp; foo[ref]; $g($g(temp,'doSomething'),'someProp'); 
What you're seeing is a console oddity rather than a module one, the console isn't fully rendered when it's not open. When the console is opened after the setTimeout has fired both references it holds are pointing to the object `{ a: 11, b: 20, c: 30 }` (as it is a single object being mutated, not two separate objects) You can observe the same behaviour with no module syntax: let anObj = { a: 10, b: 20 } setTimeout(() =&gt; { anObj.a = 11; anObj.c = 30; }, 2000) console.log(anObj) setTimeout(() =&gt; { console.log(anObj) }, 3000) 
You can use script nomodule for backwards compatability
I'd say that "the fundamentals of web development" is the fad, and it already died
I suppose it would be more like: const $g = (cond, ifTruthy, otherwise) =&gt; cond ? ifTruthy(cond) : otherwise(), foo = $g(getSomething(), x =&gt; doSomething(x), () =&gt; doSomething()), equivFoo = getSomething() ?! x =&gt; doSomething(x) : doSomethingElse(); But it's got much more clarity, I think, and removes the need for wrapping a function around the *otherwise*. I suppose that makes the normal ternary operator, considered in the same functional way: // normal ternary const $ternary = (cond, ifTruthy, otherwise) =&gt; cond ? ifTruthy() : otherwise(), foo = $ternary(checkSomething(), () =&gt; doSomething(), () =&gt; doSomething()), equivFoo = checkSomething() ? doSomething() : doSomethingElse();
You should call these cheat codes
And that's why you won't be in this business three years from now.
Less likely to burn out
So you can only build things from other people's code and can't create anything on your own. In a factory, you're the guy on the industrial line just piecing things together but you will never be the engineer designing and creating those things.
Yes but with "type" property that is unknown to a browser, scripts within it will not run. Which is why you need a specific module type and just not nomodule...
Well it depends what it is your objective about using Javascript, I think validating a form will be a better starting practice and closer to a most often use of javascript. I mean animations + validating + ajax + managing response.
You do realize that your precious vanilla javascript is interpreted by an interpreter you didnt write to interact with a browser you didnt write, which was compiled by a compiler you didnt write, both of which are hosted by an operating system you didnt write, running on microcode you didnt write which yields machine code in an instruction set you didnt design... But heaven forbid you let a transpiler touch your code 
I do IxD / UX design. Thus, whatever would be best for practical use with internships and all.
Exactly, so the nomodule needs no type but Module supporting browsers won't run the nomodule one, so it can be used for bundles or such where the browser doesn't support es6 modules.
Hi /u/orenog, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (/r/javascript is not a job board).
Hi /u/Darwinian28, For javascript help, please visit /r/LearnJavascript. Thank you!
Yes, also I would recommend PhoneGap (which is a wrapper around Cordova that offers some helpful additional features).
"gluebert.js is a tiny helper lazy loading DOM Elements, StyleSheets and JavaScript files using dynamic import and code splitting https://gluebert.com"
And that's why I said initially, I understand why the type module is needed to make to code not run. So I'm not sure why you needed to point out to me that nomodule is for backwards compatibility? No offense
[removed]
Communication issue there I guess.
Thank you for the efforts, i was on the market to figure out ways to animate react correctly. Ended up using css transition groups and its doing well but this is a nice way to introduce. I guess the "made simple" is triggering weariness as its way overused in this day and age :P Everything is "made simple" and while possibly "simpler" its often not that "simple"
He is a troll (or just an asshole). His post history is full of shitting on javascript.
For me(beginner), Redux is all about traceability. When multiple asynchronous request/responses changes the state in the app. If some thing goes wrong your list of dispatched actions that mutated state will help a lot to trace back the problem.
&gt;JS API to expose the device Memory to web applications. That's a pretty bad description. Why not "amount of device memory"? Instead it sounds like it's about native memory access.
It's comments like this that show why I have no respect for most redditors.
I'm afraid we haven't named it yet, it's a homegrown solution influenced by CoreNLP but simpler.
gluebert.js is a tiny helper lazy loading DOM Elements, StyleSheets and JavaScript files using dynamic import and code splitting https://gluebert.com 
Yes, I meant to type "shouldn't bundle". Sorry!
/u/alexendoo is right. If you want to see the behavior you're expecting, use `JSON.stringify` to eagerly turn `anObj` into a string before logging and avoid the console's lazy expansion.
did you just type a message in a language you didn't invent on a keyboard you didn't injection mould to post an encoded message, in an encoding you didn't devise, on a computer made from silicon you didn't mine, to a system of interconnected switches you didn't personally arrange throughout the world, using an internet protocol that you didn't specify yourself resulting in it's storage in a proprietary system of which you have no control? flipping millennials will never be real programmers
Js is a language. Though it may be less efficient than c++ for executing high powered compute tasks, it can still do them just fine. Direct access as you call it, is not required. People already used maliciously injected scripts to do ddosing, nothing new there. Also, js has access to multithreading-like capabilities (web workers) and gpu programming (webgl) to improve its ability to do high cost compute from the browser.
"I got called on my bullshit and now I'm upset! WHAAA" - you
For one, one action does not necessarily correspond to one reducer. A single action may be handled by many reducers. Second, when you trigger an action you don't need to know who is handling it.
 export function fib(n: i32): i32 { let i: i32, t: i32, a: i32 = 0, b: i32 = 1; for (i = 0; i &lt; n; i++) { t = a + b; a = b; b = t; } return b; } How different is this from the equivalent C++ function? I feel like it's pretty much identical. So, you're pretty much writing C-style code in typescript to assemble to webassembly? I imagine the typescript has to be "C-style" because there must only be a subset of typescript/javascript available. 
FWIW, both the React and Redux teams still advise against using decorators in general, and especially for `connect`. First, the spec and Babel plugins are still changing. Second, in the case of `connect` specifically, using it as a decorator will cause use of `propTypes` and `defaultProps` to apply to the _wrapper_ component generated by `connect`, not the plain component, which is rarely what you want. Also, the recommended approach for testing is to export the plain component separately as a named export and focus on testing the plain component and your `mapState` function, and decorators make that harder.
aka "Strongly Typed Languages Reduce Bugs by 15%"
More over, I always heard (from NodeJs architecture / conception) that you should never change the state of an exported or imported object. Because /u/rauschma is right: you can't assign again but you could modify AND you will share the same object between multiple imports. To prevent this, you could use Object.freeze =&gt; https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze But be careful: 1) You work will not work anymore (due to bad practice) 2) Object.freeze does not a deep freeze If you want a deep freeze, see this module: https://www.npmjs.com/package/deep-freeze Regards
Depending on your perspective, you can view Redux as a Flux library, an FP library, or a simple pair of pubsub event emitters. There was also a post that [compared Flux/Redux to a Win32 `WndProc` function](https://bitquabit.com/post/the-more-things-change/) ([with good discussion on HN](https://news.ycombinator.com/item?id=10381015)), and an excellent recent post that [made the same "OOP message passing" comparison](https://medium.freecodecamp.org/whats-so-great-about-redux-ac16f1cc0f8b) (with further tweets from the author [that inspired the post](https://storify.com/acemarke/redux-pros-cons-and-limitations) and [followed up afterwards](https://twitter.com/modernserf/status/886426115874717697) ). However, Redux itself is definitely more than _just_ a "pubsub event emitter" or "a crude imitation of OOP message passing", and brings several important benefits to the table. The combination of a centralized state tree and plain object actions enable many valuable scenarios, like time-travel debugging, easy state persistence, serializing actions over a network to keep remote stores in sync, crash logs with a complete history of the user's behavior and the current state at time of the crash, centralized logging, and other centralized manipulation of behavior. And, as another commenter said, the overall goal is to make state updates predictable and traceable. You should be able to see _when_ a value changed, _why_ it changed, and _where_ the action that resulted in that change was dispatched. For more information, see [Dan Abramov's post "You Might Not Need Redux"](https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367) for discussion of the tradeoffs that Redux asks for and the benefits it can give in return, and my own two-part blog post [The Tao of Redux, Part 1 - Implementation and Intent](http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/) and [The Tao of Redux, Part 2 - Practice and Philosophy](http://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-2/) for a look at the history and design of Redux and why common usage patterns exist in the first place.
If we're comparing between Flux/Redux and OOP, I'd say the concept being reimplemented is encapsulation. In both cases, we have some state - either in a store, or in an object - and we want to avoid letting anyone from anywhere reach in and modify it. And so we so we use gatekeepers - actions, in the case of Flux/Redux, and methods in the case of objects. If you want to change the state of the store or object, you have to go through the gatekeeper. The internal mechanisms tend to be different. The way you cause state to change different between objects, Redux, and other Flux implementations. And in Redux/Flux, it tends to be easier to track the state changes happening in yoru application, using something like Redux Dev Tools. Not that you can't add that kind of tracking in OOP - It would be relatively easy to add annotations/attributes/decorators to methods that mutate state and log state changes. It can be nice that you get it right out of the box with Redux, those. You mentioned that you don't see much advantage to Flux/Redux aside from more fine grained control, but that fine grained introspection into state mutations and transitions can be a *huge* time saver when trying to fix bugs in a front end application that's maintaining a lot of state that changes frequently. So I think there are definitely parallels between some aspects of Flux/Redux and some aspects of OOP, because there are some similarities between the problems they're both trying to solve. 
I read somewhere on stack overflow that const was slightly faster in some environments. Aside from that, I don't care what anyone says, there rarely any good reason to use it. If you're worries that your function names will get reused then your code sucks to begin with. Good scoping practices &gt; const.
Ur moms funnily
&gt; What i mean is that as far as i am educated HTML code makes calls for JavaScript libraries that are executed on the server side and displayed in my browser and not vica versa. That's completely wrong. Javscript is downloaded from the server, but run entirely in the browser. It has always been this way, so the coinhive thing is nothing new. It runs in a sandbox so can only do certain things, and can't just do anything it wants on your computer. It doesn't talk directly to the CPU, the code is executed by a Javascript interpreter within the browser that actually runs the code, and it does it within certain constraints and limitations. That specific javascript just does computational things, and then communicates with a remote server via a websocket to get/submit data. You could write javascript that do bulk HTML requests to servers yes, but that's how almost all modern websites work, with their javascript performing requests for data to display.
gluebert.js is a tiny helper lazy loading DOM Elements, StyleSheets and JavaScript files using dynamic poop and code spitting https://gluebert.com
&gt; It's comments like this that show why I have no respect for most redditors. Self-referencing comment.
It can really simplify your code in that it provides a lot of functionality by combining calls together for you. A simple example would be this: driver.findElement(By.css('.button')).getText() vs. driver.getText('.button'); // supports many types of selectors The latest version uses promises and they push you to use their own test runner, but you absolutely don't have to and can run it independently using whatever you like. And since you're already used to using async/await, the change is minimal. It's also very easy to add your own [custom commands](http://webdriver.io/guide/usage/customcommands.html) to the driver object, which will get executed through promises and you can chain/await on them as well. I have several custom commands that are applicable throughout all our webapps.
Sounds weird! Your first link 404s btw
I usually feel the same way... especially with things that nobody every wants to do, such as reassigning the value of a function.
Wow, thanks very much for sharing the code. I'm currently studying vanilla js at the same time as learning frameworks. Your code is a tad over my head at the moment, but it looks like it will be very helpful in the near future.
oh, right! I've updated the code and the repo name today. Thanks for bringing this to my attentions. I've updated the links!
Here's an article about one that works on most pages I tried in Chrome: [Explodz - A WebKit DOM Visualizer] (http://blog.scottlogic.com/2012/03/09/explodz-a-webkit-dom-visualizer.html) On GitHub: [Explodz](https://github.com/chrisprice/explodz) - "A bookmarklet which uses webkit-transform to z-translate each element in the DOM based on it's depth" Warning: It aggressively captures your mouse which is a problem since I could never figure out how to get out of 3D mode except to reload the page.
Wouldnt the problem be then of how required modules are processed? Package would solve this, but a run time flag, I cannot see how it would help
**Adding documentation link: https://mikechabot.github.io/maybe-baby/** We often deal with objects that missing key attributes, which leads to a lot of defensive coding (i.e.g null/undefined checks): const person = { firstName: 'John', lastName: null, address: { street: '123 Main St' city: null, zip: null } }; But we need to interact with these objects regardless. So rather than: function _getPersonZip(person) { if (!person || !person.address) return; return person.address.zip; } Why not the following? import Maybe from 'maybe-baby'; function _getPersonZip(person) { return Maybe.of(person).path('address.zip').join(); } Or: function _getPersonZip(person) { return Maybe .of(person) .path('address.zip') .orElse('N/A') .join(); } Or even: function _getPersonZip(person) { const zipCode = Maybe.of(person).props('address', 'zip'); if (zipCode.isNothing()) { throw new Error('Missing required zip code'); } return zipCode.join(); } Edit: fixing operator Edit2: Adding another example Edit3: Adding documentation link
Sounds like you need TypeSctipt
About time
my immediate thought as well
Not always an option when supporting legacy frameworks. Do you have an example of how typescript could address this issue? I'm interested.
[Eric Eliot's view on the matter.](https://medium.com/javascript-scene/you-might-not-need-typescript-or-static-types-aa7cb670a77b)
Don't know but you could just use [Babel](https://babeljs.io/) for the time being.
When everyone around you an asshole perhaps it's time for some introspection.
this is an extremely common pattern, and i believe it is optimized quite well. i imagine that it would be more expensive for the engine to create a new shape for every variant where some value could be null/undefined rather than runtime-testing it in a single shape. regardless, it shouldnt matter from a coder's standpoint since it would be a nightmare to create and call different functions for each variant in your app either.
What's the difference between this and kitematic?
I am asking about using them in release-version products, but if i can just test them out in Babel instead of using my Android browser for the time being, that would be great :)
Well the way Babel works is it lets you code using all the fancy new features in whatever editor you're using. When you transpile it, it will spit out a version that your browser can understand for the release-version of your product.
When you use const you have to define the function first. When you use function you can define the function at the bottom of the file, which is handy for creating well organized readable code.
That isn't what const does in Javascript. It's not the same as a typical constant in other languages. It's javascript after all, nothing is the same in js.
So... two things. First, JavaScript's const will stop you from reassigning a different value later. So even if I were talking about JavaScript there, it's still right. And second, I wasn't talking about JavaScript there. I was talking about the C++ source code I had posted, so I was referring to C++'s const.
Great app! I like adding project from docker-compose.yml feature. Keep it up, guys!
It's always controlled by who runs the code. If a code path leads down to a require call it's CJS from there down regardless of `--esm` or not. The flag only indicates how the initial `runMain` code gets processed. Once the initial module is loaded you have enough information to load the rest of the dependency graph. A package.json field doesn't appear to really solve anything if you have `index.js` and no idea how to run it in the desired environment. Expecting folks to create a package.json just to run a script is never going to happen in Node.
Thanks :) :) :)
Confused by downvotes. Bots? This is vanilla implementation of the Maybe monad in JavaScript...
This guy likes getting close to the metal. Get this hero some punch cards!
1) The equivelent code in javascript will in fact not stop reassignment. like I said, it's not the same in Javascript. The following is perfectly valid in javascript since js constants are not truly immutable.. const poop = ['1']; poop[0] = '2'; console.log(poop[0]); 2) The thread is about javascript and what you said is misleading.
IPFS
OK. I'll clarify... Const will stop you from reassigning a different value **to the variable**. Cool now? EDIT: In my original post, I also explicitly used the word "variable". &gt; The thread is about javascript and what you said is misleading. The OP said he had experience with C++, so I was relating to what he already knew. I don't see how my post was misleading considering I explicitly said I was talking about C++.
At this point it's pretty cringeworthy. I'd rather put "made with [tech stack] by x" and maybe spark some interest or discussion in my project/siteâ€¦
For fuck's sake I have accidentally finished React projects before just because the React/Redux combo makes everything so damn easy. It feels like cheating sometimes. What is the old way, even? jQuery? Vanilla JS? In the real world, the "old way" was absolutely jQuery. Given the option to use React or manage a relatively giant codebase of vanilla JS that *also* includes code that manages the DOM for me, yeah I'm gonna take React 100% of the time. I don't really have the time to recreate everything it does for me that I use. Even if I did, I'd introduce dependencies to take care of the underlying infrastructure and, hang on a second, we're moving straight back towards the "new way" again. Why am I managing ten jQuery extensions using script tags? Oh boy, scope headaches! Nah. Give me data flow.
Freecodecamp.org is a good place to learn
Hi /u/yinjiz, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/brettdavis4, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/smartapant, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
I think the general consensus is that `python` is python 2-something and `python3` is python 3-something. Not sure about the differences between the two but it seems they are significant enough that differing them is necessary. If your dev tools/dependencies include python I'd recommend installing both, and at least on Linux it's honestly not that much of a hassle
Maybe baby. That's fun to say. [Source](https://www.youtube.com/watch?v=-cCXsqiMqxo).
Then if the code can figure out that require calls ar cjs, why is a specific logic to handle this needed at all? Like flags/params/.mjs. 
I don't really like using *property path strings* for property resolution. They are not good for code maintenance and refactoring. I think they might be good for really dynamic data, but I rarely encounter projects where there is not a clearly defined model. There is actually an ES proposal to support the safe navigation operator (obj?.property) in JavaScript, which in my opinion is more useful and better readable. The upcoming 7.0 release of Babel has already a plugin for it: https://github.com/babel/babel/tree/master/packages/babel-plugin-transform-optional-chaining
I have tried phonegap. Not sure I would use it because I am not quite sure about the licensing / pricing ...
Browsers that support modules support const and let. See caniuse
Is there a reason to use Maybe over lodash's get method? _.get(person, 'address.zip', 'N/A')
why is music or video data different than any other data? I mean if we can't even drm our own javascript code (a kind of data), or any of the data it serves, why make special exceptions for music and videos, at the hardware level no less? I get there is an "industry" but that isn't an excuse for preferential treatment. Either sort out secure web delivery for DATA or don't.
What he meant was the opposite direction, like almost all the browsers that support let and and const since a few versions back, but only the latest versions of chrome and firefox support ES6 modules. Anyways your comment about caniuse still stands
Smaller dependency footprint. Monad data structure. Helper methods such as `isJust()` and `isNothing()`. Other than that, nothing really.
That safe prop chaining proposal looks great - that's really all I was trying to accomplish with this Maybe monad. I work with healthcare data, which is formatted dramatically differently across each health care provider, so the ability to easily look *really deep* into certain objects has been helpful. Also, the string literals (i.e. the path itself) is often housed in a constant somewhere, so no magic strings are ever really floating around. 
Completely uncalled for.
fuck that was useless
- The app works with Docker Compose. You can import your existing docker-compose configs. - We group containers by project - You can work with local and remote nodes. - We provide remote connection non-standard way of connection via SSH (also we support plain connection and connection with certificates) - App has resource monitor where you can see stats of containers - You can convert "docker run" commands to docker compose format. - You can use the app without local Docker installation (if you want to work only with remotes containers) - Also the application has many other small features to describe which will have a very long time
Ok. I'm sorry.
Should be possible to run everything in a container and sidestep the issue altogether. I agree that the dependency is weird, though.
Thank you, looks promising!
Looks awesome, thanks.
I'd recommend going for someone who does vue.js or angular gets the job done instead of playing around with different libraries
So with [pipeline operator](https://github.com/tc39/proposal-pipeline-operator) it would be essentially the same as this? const foo = getSomething() |&gt; x =&gt; x ? dosomething(x) : doSomethingElse(); Or without pipe, like: const foo = (x =&gt; x ? dosomething(x) : doSomethingElse())(getSomething()); Not trying to say it's a bad idea. Maybe it would be a neat step to see after we get pipeline though. I think I'd prefer a syntax like: const foo = getSomething() ?&gt; doSomething : doSomethingElse; So `condition value ?&gt; passFunction : failFunction` 
The path strings completely break refactoring tools for renaming :(
2:20!? I thought my 8 second webpack build was slow...
I've yet to find an interesting topic we agree on. 
I use typescript, how does it solve this? 
It's a long story, but it boils down to this: 1. Many optimizations. 816K of raw LESS + 4.3MB of raw JavaScript + 189MB of node_modules becomes about 10 different apps with around 300KB of JavaScript footprint per app, plus styling. 2. A lot of code splitting and such 3. It's actually 10 different apps BUT! When you're coding, incremental builds usually take 3 seconds or less :)
&gt; !person &amp;&amp; !person.address This is wrong (which is just another reason to use a library instead). It will crash if person is null/undefined. Just in case you have this example duplicated in a readme somewhere... 
I see the reason why you needed the touchbar progress bar! Cool hack!
I've yet to find a topic I disagree on. He provides the practice behind the principal, and usually has a use case to help support his concepts.
That should read ||. Fast typing on mobile. 
[Beware](https://www.reddit.com/r/javascript/comments/6q2lk0/why_composition_is_harder_with_classes/dku34cl/)^1 [referencing](https://www.reddit.com/r/javascript/comments/5c5lkq/what_eric_elliot_wants_to_say_can_somebody/d9u6tv3/)^2 or [learning](https://www.reddit.com/r/javascript/comments/3x91ac/why_not_to_hire_people_who_like_es6_classes/cy2o6zj/)^3 from Eric Elliott.
[Hey OP, if this is your site... it sucks.](https://i.imgur.com/5X3P2T9.png). "a few" seconds into the video and it gets covered up by stupid popovers or whatever. On another note (since I dont have the latest MBP with the touchbar), I used [webpack-notifier](https://www.npmjs.com/package/webpack-notifier) and hooked into my build so I just get a MacOS notification and it dings when the build is finished.
Why not use lodash get instead? https://lodash.com/docs/4.17.4#get
You can, but see here: https://www.reddit.com/r/javascript/comments/713w9l/defensive_coding_sucks_use_maybebaby/dn81bf0/
It looks like performance has nothing to do with Webpack, but with Babel transpiling the default param to fun with `arguments` on line 127: var iterations = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : 100000000; If you rewrite `doComputations.js` to this: export default function doComputations(iterations) { var iterations = iterations || 100000000; // Uncomment to destroy your performance: // arguments[0]; const arr = []; for (var i = 0; i &lt; iterations; i++) { const val = i * Math.sqrt(arr.length); if (arr.length &gt; 1000000) { arr.length = 200000; } arr.push({ val }); } return arr; } ... then performance seems to return to normal. It seems like if you touch any index inside the `arguments` object, Chrome completely hammers the function's performance. If you take a performance snapshot while running the deoptimized version, Chrome does _a lot_ of 'minor GC' work that it doesn't do if you don't reference `arguments`. I know `arguments` has traditionally been a source of weird perf issues, but I'm not sure if this particular construct is a documented cause for bailing out. In any event, it looks like someone else has already raised a flag in the babel repo: https://github.com/babel/babel/issues/5922
The general consensus is that if you *need* a particular version, you should specify it as python2/python3. Python is just a name the system can assign. There are several distros which have switched to 3-as-default schemes. Edit: [PEP 394](https://www.python.org/dev/peps/pep-0394/)
i'm gonna disagree here. not on the choice of frameworks (each one has its uses), but on the negative sentiment put on "playing around with different libraries". if you dont play around with these libraries, how will you know which one fits your needs best? what it's strengths and weaknesses are? how its paradigms work? playing around with new technologies makes you a better developer, not a worse one.
"Here, use this library so you don't have to use libraries.."
And the free web weeps
if your main concern is to improve site speed, you need someone who can demonstrate that ability. site speed is also a bit vague. page load time, or page render time? if it's render time, webpack wont be a magic bandaid for you.
Sounds awesome, I'll check it out. 
Popups only happen if it thinks you're leaving the page. And yes, it's not ideal but it works. As for webpack-notifier, I like the idea, but I keep my computer in Do Not Disturb mode. Then again, webpack-notifier actually sounds useful, my thing is just a fun hack because I wanted to play around with the idea. Until somebody solves the "app needs to be in focus" problem, it's not practically useful.
Nice lib. I use undefsafe: https://github.com/remy/undefsafe (doesnâ€™t have as many features though it seems).
ye and to be honest template strings don't really do that much magic. I use the same technique in feather-ts.com but it allows for reordering and filtered views. still I wouldn't piss on vdom as it allows for easy SSR and has a centralised point to optimise DOM writes. doing the same without a vdom was sort of painful.
Haven't there been rumors on twitter that JavaScript is getting the `?` operator natively? So if you have potentially undefined properties you could do something like this `object?thing?otherThing` and it would Just Work(tm). I'm not gonna be able to find the exact tweet where they were discussing this, but it seemed like a great idea. Hope it happens
Yeah, someone commented around here about that proposal. Looks very promising, I'd love to see this implemented: https://github.com/babel/babel/tree/master/packages/babel-plugin-transform-optional-chaining
Very cool, this would surely do the trick.
To make your library also work with direct object access, in addition to property paths, you could use arrow functions to provide a value. The "Nothing" case would then be, when a TypeError is thrown. Something like this: Maybe.of(() =&gt; person.address.zip) Maybe.of(person).prop(p =&gt; p.address.zip) 
GitHub: https://github.com/kodie/progress-img
Eh, I just put `say done` at the end of my long NPM scripts to know when something has finished. It only works on Mac though. Edit: Something like `npm run build-production &amp;&amp; say done`
That wouldn't help in most cases, since the problem is not "who sent the event" but rather "who is listening to the event. Also that's usually not good design. Most of the time, the listeners shouldn't care where specifically the event came from. 
Holy fuck. My incremental builds take a couple hundred ms at the most.
&gt; the problem is not "who sent the event" but rather "who is listening to the event Why would a listener care who else is listening for it?
This is a great idea! I wasn't really pleased with the property accessors, hence I supplied 3 public functions `path`, `prop` and `props`, but this approach could potentially unify those three into something much more readable. And I should able to implement this pretty easily. The `props` function is just a wrapper for `map` which allows for any transformation on the monad value: /** * Apply a transformation to the monad * @param transform * @returns {Maybe} */ Maybe.prototype.map = function (transform) { if (this.isNothing()) { return Maybe.of(undefined); } return Maybe.of(transform(this.join())); }; /** * Get a property value on the monad * Example: maybeInstance.prop('foo'); * @param property */ Maybe.prototype.prop = function (property) { return this.map(function (value) { return value[property]; }); }; 
You need to know which environment to start with, if you have an ambiguous file extension, then the only indication you need to provide to Node is how to start. After that it can infer by *how* you require. If you use `import` then it loads ESM, if you use `require` then it loads CJS. Without a flag there would be no way to indicate which to start with. This is why Node introduced `.mjs`. I just disagree with a wholesale extension change vs a simple flag.
knowledge in javascript &gt; knowledge in any framework
remember when transpiling/compiling wasn't necessary on interpreted languages? pepperidge farms remembers. these framework developers have their heads so far up their own asses they are trying to hack javascript into a compiled strongly typed language. oh its microsoft doing it, im sure they dont have any nefarious motives or wont splinter the community when they decide they want to be paid for every TS site in development. google polymer cant come soon enough, please save web development from this unnecessarily verbose contrived insanity.
how many gigs is your node_modules folder? edit: probably too embarrassed to say. been there done that with 700mb of dependencies, with all the duplicate sub-dependencies.
Oh, I really like that. I'd change it to a *failExpression*, though, since a falsey input would usually not be useful. Maybe have two variants, with the choice between them determined by using a colon or a different character. Broken pipe? Double-colon (only because my phone keyboard doesn't seem to have the broken pipe...)? ?&gt; passFunction : failExpression ?&gt; passFunction :: failFunction
historical baggage. gyp was written by google using python 2; they eventually switched to a different build system, never bothering to update the code, and node just kinda ran with it because change is risky &amp; the native modules people generally use are almost locked in stone at this point (if not shrinking). i think you'll see better long-term work come out of the [N-API project](https://github.com/nodejs/node/commit/56e881d0b0), which looks to eliminate the need to recompile native modules altogether (which, by the way, would permanently remove a huge blocker to node accepting new versions of V8, so you can see why that might be given priority over an arguably lateral upgrade like gyp.py -&gt; gyp.js).
As I said in my comment, only 189megs. Honestly I thought it was more :D
I shaved 30s off the full build and 5s off incremental build by buying a newer MBP :P
"a kind of data" is quite flawed as a comparison. They are totally different things. For now let's solve the media problem, if you want to encrypt JS create a ticket for the W3C and it will be dealt with separately. Media encryption is important to some providers of free content. I worked on a VOD platform that couldn't show historical, copyright free, non-profit content because of the legal implications of it not having DRM. Not all DRM is evil. 
oh i missed that. 4.3mb of raw javascript is a ton though, good job on being lean with your dependencies.
Thanks mate for the comment! Yea, I feel for you for sure. I think I used transition group as well, it's awesome. This component is simple and the limitation is obvious too, I would like to keep that way so it does one thing only, which is take care animation from a to b. i hope this will help some of us out there and give back to the community. Again thanks mate :)
&gt; Media encryption is important to some providers of free content. all you have is assertion though, it is no more important than someone elses spreadsheet data or the code that "secures it". And the fact that you needed DRM only proves my point. so you have video, it is still data. 
yeah man Introducing docker as a dependency for my npm projects sounds GREAT
It is!
Using [union types](https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types) and [type guards](https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards) with strict null checks on gives you access to a very basic Maybe type (not including the additional features of your library). For example: type Maybe&lt;T&gt; = T | null; function maybeAddOne(maybeNumber: Maybe&lt;number&gt;) { if (maybeNumber === null) { // compiler knows that maybeNumber is null here return 1; } // compiler knows that maybeNumber is a number here return maybeNumber + 1; } If you have strict null checks on, then the following will error with `Object is possibly null`. type Maybe&lt;T&gt; = T | null; function maybeAddOne(maybeNumber: Maybe&lt;number&gt;) { // compiler error here return maybeNumber + 1; } You pretty much just get basic null checking. Without pattern matching, flatMap, other monadic combinators, it is much less powerful than something like the `Option&lt;T&gt;` type in Scala. Hope that helps and cool library!
Can you share what kind of apps you're building? That sound like a huge amount of code and styling. 
If i'm not mistaken that only applies to es5 prototype props, i believe es6 class props shouldn't be on the wrapper. @connect(...) export default class extends Component { propTypes = { name: PropTypes.string } defaultProps = { name: 'Stranger' } } As for connect in general, it's already stage-2, have made it through lesser specs before. It will come anyway one day, so redux will have to adapt eventually. I just like the syntax of it. On the other hand, easier testing is a solid argument against it. Since you work as a react-redux maintainer, does the HOC statically expose the wrapped component? Then there'd be nothing in the way. const connect = (mstp, mdtp) =&gt; WrappedComponent =&gt; class extends Component { static get Wrapped = () =&gt; WrappedComponent // ... render() { return &lt;WrappedComponent {{ ...this.props, ...this.state }} /&gt; } } import renderer from 'react-test-renderer' import MyComponent from './ConnectedComponent' const component = renderer.create(&lt;MyComponent.Wrapped /&gt;)
That seems very very unlikely, events are not a common source of slowness in VDOM. Perhaps you were misusing keys, triggering remounts?
its just a reductio ad absurdum of his own argument, which I admittedly didn't invent
Not to be overly pedantic, but technically this is only satisfying one half of the monad typeclass (`of` operator implements `unit`). For this to be monad, it would need to define a `bind` or `flatMap` method with a type signature of `(F[A], A =&gt; F[B]): F[B])`. This is what allows monadic composition (ie. safely chain function calls with a Maybe type). Sorry to be an FP stickler, just wanted to clarify for people still wrapping their heads around the idea.
Man, no one cares and no one is stopping you from writing plain js.
[uBlock Origin](https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm?hl=en) gets rid of most of the ads on this page. OP should consider removing all the ads all together because his site is substantially better without them. Then again, the page is [2.9 MB and takes 3s to load](https://i.imgur.com/vaeVKFl.png) for a blog, 434 KB alone is sitting in [this animated gif](https://swizec.com/blog/wp-content/uploads/2016/03/particles-step-5.gif) which is just a thumbnail at the bottom of the page! A better hack to put together would be to fix the site instead of setting up a progress bar to monitor it. With that heavy of a payload, it could [at least work on mobile](https://i.imgur.com/wah0beb.png).
Redux is the command pattern with a pub sub interface. Just calling it pub sub alone doesn't really describe it very well imo. The command pattern is what easily enables things like time travel and traceability.
I'm glad someone said it. I always get the feeling that he has a narrow perspective when it comes to software development.
I find the [fantasyland spec ](https://github.com/fantasyland/fantasy-land) explains this in a not completely terrible manner 
I remember that time, it was terrible. Not even sure what Polymer has to do with anything, [they use Webpack](http://robdodson.me/how-to-use-polymer-with-webpack/) since html imports have died. 
It's free to use, perhaps you are thinking of their cloud services. Apache Cordova started as PhoneGap, which was bought by Adobe, but the license remains the Apache open source license. Let me put it another way, I really would recommend that you use phonegap, it is itself an open source distribution of Cordova and has an expanded ecosystem of plugins to interact with native APIs. I don't use the phonegap GUI at all, I use the CLI to install or remove plugins just like npm or yarn, to emulate devices, and to build. The phonegap developer app is a nice way to get your app running on your phone before you are ready to dive into Xcode and Android Studio.
ah-mazing!
If that listener calls stopPropagation ...
This is pretty cool - thanks for sharing!
Crap, I forgot to document the `map` function, which applies the transformation and returns the monad - I think this satisfies the requirement, correct? Maybe.prototype.map = function (transform) { if (this.isNothing()) { return Maybe.of(undefined); } return Maybe.of(transform(this.join())); }; It's actually utilized by `prop`, `props` and `path`: Maybe.prototype.prop = function (property) { return this.map(function (value) { return value[property]; }); };
Huh, that's an unexpected but welcome surprise!
Thanks for the tip! I'll go remove everything that doesn't directly contribute to my ability to continue writing the blog. *blog becomes 302 redirect to checkout page*
I experienced this before with node-sass. IIRC, they ship pre-built binaries targeted for your system (and node version), rather than having you go through the long process of building it locally.
This thing: yup.com Whole corp site, tools for tutors, large swathes of the mobile app, a couple of internal tools. All JS.
Stop liking things I don't like!
One argument against that is compile-time type-checking (e.g. flow). When your props are in strings, you only see the error in `.path('adress.zip')` at runtime, potentially hidden behind several clicks, whereas with flow, you get the squiggly underline as soon as you make the typo, right in VSCode. Also, code size/parse time/JIT time/script running time, etc. 
But DRM doesn't actually stop anyone from capturing the data. If nothing else, they can capture the output of their browser.
That's a good point, folks keep mentioning typescript (and flow), I haven't dabbled any, but it seems likely. I came from Java, and using JS as my first untyped lang felt really freeing - funny to see the pendulum swing back where we start type-checking our untyped languages.
Really?! Thatâ€™s exciting. Itâ€™s one of the reasons why Iâ€™ve been loving Swift (I used to do a lot of js) 
I know that propTypes/defaultProps defined outside the component (`MyComponent.propTypes = {}`) will definitely apply to the wrapper if `MyComponent` is the output of `connect`. I _think_ that also is the case if you do class properties, but I'm not 100% sure. I believe the component you pass to `connect` is exposed as `Wrapper.WrappedComponent` or something like that. I assume you meant to say that _decorators_ are stage 2. Also, the decorator spec is a lot more complex than what `connect` actually does. `connect` is a function that returns a component, whereas decorators are actually a very complicated thing that involves getting access to information about what the decorator was applied to. As I understand it, to some extent the fact that "plain functions" can be used as decorators right now is almost an accident. I know I saw some chatter about that on Twitter after the most recent TC39 meeting. So, while `connect` _may_ work as a decorator right now, we have definitely not _intended_ it to be usable as one.
To clarify with an example, `import`-ing something is \*mostly the same as just if the exported code were in the current module. For example this: // file1.js export const foo = { x: 10 } foo.y = 20 // file2.js import { foo } from "./file1.js" console.log(foo) // { x: 10, y: 20 } Is essentially just the same thing as: // combined-file.js const foo = { x: 10 } foo.y = 20 console.log(foo) // { x: 10, y: 20 } \* *The only difference is that if you export a `let/function/var` you can only change the variable (not the object in the variable that can be changed anywhere) in the original module, whereas with the combined example you'd be able to mutate it anywhere.*
Nice work! This is the sort of thing I would have loved to have built when I worked for ( insert name of large media organisation here ), instead of endless poxy image sliders and map pop-ups we churned out.
1. At my current employer, mostly bash and, not competently, c. But I know php, typescript, c#, python and visual basic.net as well. 2. Never used c# or java in a Enterprise setting so I can't speak to that. 3. NA 4. I'm a senior dev with 15 years experience. Linux, Neovim, neomake, bash.
This is the correct answer. Node-sass doesn't "break." It throws a warning that can be ignored. 
&gt;remember when transpiling/compiling wasn't necessary on interpreted languages? Remember when C++ was a bunch of precompiled directives on top of C?
Well you do want the ability to test multiple environments for compatibility. And it's always a good idea to be able to test your production environment if nothing else. Docker is a pretty easy way to achieve this.. In the context of automated testing Docker is always a great idea.
I'm not that old.
Your page took over 10 seconds to load on mobile and I gave up. I'm in the digital marketing industry and feel your pain on finding the right balance between monetizing your site and a good user experience. That being said 30-40% of your desktop users will be AdBlock users if you're running a programming blog. I'd check your mobile experience and be honest with yourself if it's something that YOU would tolerate :)
This guy writes books to teach other people how to code. Yet produces a bloated wordpress blog with react front end. Nice... 
You do great work. That's a very optimized wordpress blog.
Does it ding when there's toast?
I was hired as a Frontend developer, had experience in Java and python and so was asked to learn enough C# to get by in order to help out on the backend at my current job when necessary. Highly prefer the Frontend side. To answer your questions 1. Javascript/Typescript confidently, C# decently enough to get something done when tasked or extra help is necessary. And in practice its not 100% about the language of choice, any developer can debug logic. 2. C#/Java will always have their place imo, and Javascript/Node have been carving out their niche. I love writing in node, but at my job they won't allow us to write any backend features in anything but C#. To be fair all our current backends devs are not very proficient in javascript, and never touch the JS codebase so it's understandable. I think a fair answer would be that JS won't replace C#/Java, but it does have its use cases and so will continue to see growth. 3. No experience with native apps, I tiptoe around the topic at work because our native app developers get snarky and elitist when I mention JS mobile apps. 4. Transitioning Junior to intermediate would be my own fair assessment. Current setup -&gt; Visual Studio 2017 for C# development, VSCode for anything client side, and good ol' pen and paper beside me for doodling ideas/problems. Nothing too fancy in the way of plugins. 
Well. You have done everything to keep people from reading it.. so why not. 
Yeah thereâ€™s work to be done but it honestly just hasnâ€™t been a priority. Thereâ€™s more important work to be done first and I only have so much time in the day.
Nope. No reason. I was learning angular and that was the project I picked up to learn it. Turned out well, so I decided to continue it. ðŸ˜Š
The fact that it is called Maybe does not mean it is a monad. It is a functor (because it has a map method). To be a monad it needs .chain and .ap (obeying the laws of each). Please have a look at fantasy-land specification to see what is missing for it to become a monad
No. A security gap would be if the javascript was accessing files or data on your machine. Javascript however *is* free to perform calculations. Browser based games, tools and applications all work this way. The script is downloaded to your browser, and executes within a sandboxed (protected) environment -- performing whatever calculations it needs to. Bitcoin mining is just another set of calculations. What's being used is your CPU. But your data is safe. 
Yeah we need Lang support for Monad comprehension in order to smooth out usage
K bye
"Old way" would be jQuery + backbone (+ Marionette). Before that you had shtml server side includes.
[removed]
Good, go ahead and make a proposal to encrypt spreadsheet data
But it's not trivial 
Fyi Chrome on Android (Galaxy s7) the arrows for the scrolling bottom testimonials - both point left initially, then when you scroll to the end (all the way right) the right arrow is grayed out (as it should be) but the left one disappears. Then when you scroll back to the first testimonial the left one gets grayed out but the right one disappears. Also it looks like the whole page width was just over 100% of my screen width as I could scroll horizontally slightly.
My 2 cents, assuming that the "relative complement" is removing all elements from an array if they are contained in another array : - result.splice(x, 1) =&gt; x is the element but should be [the index of the element](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) - you assign the result of the filter to a "symd" variable which is never used - `a.indexOf(x) === -1` will always be false - **do not use .filter** it does all the dirty work for you, and try to rewrite using only 2 nested for loops and indexOf
1. JS, Python, Java, php. 2. Will JS replace everything? Nope, because static typing has it's own benefits, not to mention in terms of cross platform compatibility as wide as the gamut is for nodeJS, java still beats it. JS does have it's place but it also has its pitfalls. 3. Not really much to argue. Unified libraries provide better cross platform compatibility while sacrificing access to specific capabilities / tuning options. Specific SDK's for native app dev provide access to all features but because phones have different OS's it means you have to maintain separate codebases for the same app on different platforms, which isn't a problem if you're a large corporate but otherwise can be detrimental to ROI. 4. Intermediate - Senior dev, config would take too long to explain going into huge detail, but the main components are: zealdocs + sublime text + Vim + styleguide + whiteboard app + decentralized version control (git) + decentralized testing environments (VM's / containers).
The site is unusable on my phone. Half the screen is taken up by crap (https://i.imgur.com/LWNgRY4.png), scrolling is a painful drag, and content flows out of the screen.
None of the demos work in Chrome 61 on Windows 7. The user can't scroll inside of any of them. Hope that helps with debugging. Not sure what the issue is, but I had a similar issue when I have updated to Chrome 61. I had to change body to scrollingElement: document.body.scrollTop to document.scrollingElement.scrollTop Hope that helps.
I see the problem with using Redux as a pub-sub. In pub-sub you can add listeners to the particular events/topics. like this: channel.subscribe('todoList:addTodo', () =&gt; {}) But in Redux if you want to trigger some side effect after some specific action - you can't do this using `subscribe` because (AFAIK) `subscribe` triggers after each action and there is no information "which action was sent lately". You rather don't want to this in reducer itself (because reducers should be pure functions and adding side effect would destroy this effort). So, the best option to implement pub-sub in Redux seems to be middleware (if I understood Redux correctly). But this is a little bit cumbersome. I think there are things better suited to pub-sub than Redux, e.g. EventEmitter from Node. 
&gt; Popups only happen if it thinks you're leaving the page. And yes, it's not ideal but it works. Except apparently it doesn't. How would it know?
Well yeah I mean if you just need a generic pub sub implementation for other uses I wouldn't use redux just for that. I'm not sure that your contention about being able to fire actions inside of subscribes is really a fundamental part of pub sub though. It's been a while since I've read the formal definition but I don't remember the ps design pattern specifying where it is and isn't safe to signal the publisher. Seems like it's something left up to being implementation specific.
You realize TS (or Flow, for that matter) isn't even the main reason people use Webpack, right? It's being able to use newer language features without worrying about browser support, things like [vue-loader](https://github.com/vuejs/vue-loader) that would never be possible without a build system, and optimizing your assets as much as possible before delivering them to the client. 
I guess I give it another try, coz I don't see huge differences right now, but perhaps if I give it another go. Main issue was being afraid of the license but if thats all good then why not! Currently also trying out nativescript.
Well, do not call stopPropagation.
Your SSL has just expired
Hey OP your certificate just expired: https://imgur.com/a/qDY6V
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/KcvM6Qo.png ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dn93b01) 
Unwritten in the documentation but what does join actually return if the resolves path is actually a type error?
[removed]
thanks
If you're not already deploying nodejs projects inside containers you're doing it wrong.
What about three.js? 
Thanks for your reply. Sorry for my bad interpretation of how JS works, you are right. So with the "within certain constraints and limitations" do you mean that the scenario i envisioned (DDOSing a remote server or Building a botnet) is not possible with JavaScript? I guess if JavaScript can give direct command to CPU to calculate data it can access other resources and do different things.
Thanks. My concern is that if JavaScript can directly command my CPU to perform calculations is it an unlimited/unrestrained set of calculations? Can someone write code to overclock a the CPU and cause a PC shutdown, or build a botnet for example? Botnet is just another calculation also (depends on what it is used). Of course i recon it would only work when the site is displayed, since closing the browser will terminate all running code. 
Yup, they are similar. But still, you can use the JS syntax and tooling you are used to. It's obviously not plain JS, but I think it's still more accessible for a JS developer than C++ or Rust. Exatly: AssemblyScript code written in TS is assembled to wasm. The code has to be "C-style" (needs specific types) so it can be compiled. The drawback of JS being a dynamic language is that it can't be compiled efficiently, because there are no type guarantees. By adding these exact types, the compiler is able to make the necessary optimizations (allocate the exact space needed etc).
Yep, learned this one the hard way. It makes sense since Python 3 has radical breaking changes. Never had this problem on Linux, where my distros have proper binary names for the separate versions. Windows needs some annoying environment tweaks to run both versions simultaneously.
Javascript only runs whilst on the page it's served from, as soon as you go to a different page, or close the tab, it's immediately terminated, so there's no real way to build a botnet, and even if your site had a lot of users on it at the same time, there's a limit to what each can do. Javascript can not issue low-level network commands only simple HTTP ones for the most part, and is limited by the browser in how many simultaneous HTTP/HTTPS requests it can make to a single host, 6 in most cases, and these requests can't be early terminated or anything to increase the load on the remote end. Javascript does not talk to the CPU. Javascript is loaded by the browser's Javascript engine, where it is interpreted into commands that the engine will allow, and then issue to the CPU, before feeding the result back into the interpreter. Think of it as a bank teller, the Javascript is a customer and the CPU is the vault. The customer could come in and ask for all the money, but the teller is going to check their account first before emptying the vault. The javascript engine is written by a large number of people who care a lot about security and will do their best to ensure that it won't allow anything really nasty to happen.
Usually by putting an invisible div at the "[line of death](https://textslashplain.com/2017/01/14/the-line-of-death/)" (The border between the page and browser UI, usually at the top) and watching for mouseover.
Of course it did. Should be fixed now as soon as Webfaction propagates the update Thanks
Of course it did. Should be fixed now as soon as Webfaction propagates the update Thanks
I think it's meant to detect exit intent by looking for your mouse leaving the viewport. That's as much as I've been able to reverse engineer.
A bookmarklet can't navigate to some page and then do something else. Once you navigate away, all the JS stuff is no more. You could navigate to example.com/#whateveryouwanthere and then use a user script (Tampermonkey or Greasemonkey) which runs on that page and takes the stuff from the hash (or query string) and uses it to populate the fields.
&gt;google polymer canâ€™t come soon enough You lost me here? Polymer has been out for a long time now. Hell, Polymer 3.0 will use Webpack and NPM modules due to HTML imports not gaining any traction, unfortunately. 
 function relComp(b, a) { return b.filter(v =&gt; !a.includes(v)); } console.log(relComp([1, 2, 3, 4], [2, 5])); // [1, 3, 4]
&gt; " Of course i recon it would only work when the site is displayed, since closing the browser will terminate all running code." Exactly. Remember that any particular sandbox only 'lives' as long that page is open. While there are ways to preserve data past a session or browser restart, execution does not. But yeah, it's not hard to write a script that's intended to eat up all your CPU power while a page is open. Although many modern browsers have protection against that: You'll get a "One or more scripts on this page is running slowly" message or some variation thereof if you pass a threshold in terms of available CPU cycles on many browsers. But as you noted, you could just close that browser tab and its associated sandbox -- and with it the offending code -- would cease to exist. Of course, when talking about browser security, there's the way things are 'supposed' to work, and then there's the way they 'do' work. You're not supposed to be able to drop a package onto a client system with a drive-by. But I've seen it happen. Have those holes been closed? I sure hope so. But again, there are plenty of old versions of browsers in the wild as well. Today I'd say the biggest risk posed by Javascript is by way of third-party ads embedded on pages and the potential for communication between the ad and the page it's embedded in. Again, it's not 'supposed' to happen, but... And then there's browser fingerprinting which IMHO is a giant elephant in the room of browser security that nobody talks about. Some browsers (eg: Brave) have taken steps to thwart it, but tons have not. 
Thanks, that is exactly the explanation i was looking for. You helped a lot.
Are you going to base an important business decision on a few comments on reddit ? 
I do agree. There was not a single valid point in the article. It seems like the author wanted to let go some of the steam, and it just so happens that a black .txt file was open.
Thank you, that makes sense. I figured that the browser would prevent such CPU overuse, tho i am not sure about the exact threshold given that the Monero miner had a bug that used too much CPU power instead of the 30% they advertise. Anyway, thanks for you help, i now understand that this itself is not a great security concern as i initially thought.
Tracking mouse position and trigger an event when the mouse is moving closer to viewport.y=0. Unfortunately this would trigger if the user clicks on back, fav or whatever.
&gt; I'm not sure that your contention about being &gt; able to fire actions inside of subscribes I meant side-effects, not firing actions. For example AJAX calls etc.
Too bad that most of my customers still run Windows 7 and Internet Explorer in their corporate business...
Wow, thanks for your input! This is definitely the reason. I'll post to the babel community to see how they are doing. I'm really glad you found the code leading to this performance drop.
Well sure but then how do you solve it? Do you really want the store to publish every action it receives back out to subscribers? That seems messy to me. It's much cleaner to use Middleware. And it doesn't even have to be complicated. If the only thing you want is to initiate a side effect when a specific action is dispatched that can be done in like 4 lines of code (barring the code the side effect itself takes). It's a little opaque to the view layer but isn't that the point? The store is your model and the model should be taking care of that stuff itself. It's cleaner than passing a signal all the way to the view just to have the view initiate a side effect and then pass it back to the store.
https://polyfill.io
Are you going to assume this is the only research I am doing? Thanks for an insightful and helpful comment. I was really almost going to do that before your big brain pointed out the flaw in my plan.
I havenâ€™t used jQuery since 2013. 
That doesn't mean a thing. My company has been developing unique, high performance web sites for 14 years and has never used jQuery and never felt the need to.
I love seeing all that stuff and that you can use it NOW and then at the end they tell you that IE is not supporting it. Super useful.
Well yea, a company like that is going to have a suite of its own libs. For everyone else that doesn't want to sit around re-creating that crap, jquery is a great thing. 
People who claim to have never used jQuery are like people who say they don't own a television. 
So instead of $() you just have your own proprietary wrappers that make onboarding new developers lengthy.
[removed]
i dont own a television, as many of my friends. Well, in the age of internet, tv seems a bit... redundant
The German government doesn't care you still have to pay for your television.
Like adding NyanCat to your touchbar? 
No, it pretty much is. There have been programs that do this almost as long as there have been GUIs. You install one and hit "record".
Itâ€˜s a good thing. You donâ€˜t pay for television. You pay for neutral journalism
This guy thinks using javascript is a "proprietary wrapper" and takes longer to learn. lol
Jquery itself is getting more lightweight and dropping various compatibility hacks for older browsers, and it still provides more convenient DOM manipulation than straight JS. It still has quite a bit of usefulness and life left in it. Especially when you have to support IE 10...
People who think you can't do anything without jQuery are like redditors who claim they know how to program.
Here's another one of those redditors who think, every time one writes a program, they re-create every little thing and there are no standard javascript functions or APIs in the browser. This is why we've been around for 14 years and you won't be in this business three years from now.
neutral...
Yep. Neutral. At least they try as much as possible.
But why?
"But why", what?
Why do you need to hide the log level. At that point you may as well just use `console.log` instead of `log.info`
I need to write some log to a file. Winston has the facilities to write smartly to files :)
That doesn't mean a thing. 
I think what OP was referencing there is (assuming) your own internal libs and functions to reuse on each project. jQuery is a very useful stopgap way of quickly implementing cross-browser solid functionality, and with caching &amp; CDN, minimal bandwidth footprint. Granted, for simple DOM manipulation, pure JS is fine but anything more complex and it just becomes simpler to pop in jQuery rather than type out longer-hand syntax. Things like eg AJAX is "nicer" with jQuery providing promises and whatnot. (and, importantly, IE support)
So no Ajax then?
Why do you think Ajax has anything to do with jQuery?
Is it a separate bill you have to pay like UK TV licenses? Seems really stupid to me compared to just taking it from regular government taxes like everything else. Massive waste of time policing it, and even if you don't own an actual TV at your own property, that doesn't mean you don't watch the shows. Most other services that regular taxes pay for aren't used by everyone. So why is TV different? Of the "not everyone uses the service" services, TV is probably the has the highest population usage compared to most of the rest. 
This sounds like hell. Does your "company" include 2 people who've worked there the full 14 years? Because that's the only situation I'd see it would be appropriate to use custom js libraries or no js at all. I'd also wager your portfolio is chalk full of real estate agent landing pages that use flash. If be pretty pissed if I was a developer at your company. My skills become extremely non-transferable, onboarding is a bitch, and my company forces me to do everything the hard way "just because". I mean for god sakes, you're in the business.of making websites and you don't even use highly agnostic, modern, and repeatable tooling/libraries? How do you feel sticking your clients with these custom frameworks? It's like when electronics only come with power cords you can buy from the manufacturer, you fuck them with long term maintenance.
Redditors never like to think and their experienced is extremely limited so being able to plug in other people's code, despite all the implications and bloat, suits them just fine. For us, we're professional programmers who know how to write code and don't consider the few lines of implementing Ajax and such difficult. In fact, it's fundamental.
To amateurs like you it doesn't.
I'll be sticking with jquery for a long time, regardless of whether I actually use it myself. Mainly due to all the useful widget libraries etc that use it.
We have 10 developers, seven of which have been here since the beginning. Two of our web sites are two that I guarantee you go to monthly at a minimum but the rest of our sites are mostly in the entertainment and restaurant industries. We have never used Flash. While your "skills" may be in plugging in other people's frameworks, our skills are based on fundamental engineering knowledge that you are incapable of handling. iow, javascript that runs in every browser everywhere without needing handholding by some downloaded library or framework that will fall out of favor every two or three years and you need to re-learn.
Why what news sources do you read? 
One of the best features of jquery was its handling of browser differences, and Ajax was one of the worst offenders in terms of just how differently the browsers made you do it. You said youâ€™ve been developing for 14 years. That means he had to write different Ajax code for old IE, Netscape, and modern browsers. Doing that without jquery or another library that handles it for you is just plain stupid. 
Itâ€™s a separate bill. https://www.rundfunkbeitrag.de/e175/e5283/Informationsflyer_Buergerinnen_und_Buerger_englisch.pdf
I'm rubber, you're glue. Whatever you say bounces off of me and sticks to you. Am I doing this right?
I really didn't expect this to go this far, all those down votes lol. I'm sorry about that.
This is the exact feeling I get reading this person's replies. They have no real experience dealing with teams, and have never needed to measure the cost of reinventing the wheel because it's one self-righteous developer who thinks libraries and utilities are for plebs who don't know vanilla JavaScript. He's a one-man show with a decade and a half of experience, yet he'd likely never get hired as even a junior in any software company he doesn't own. I've interviewed a number of these developers. They operate within a vacuum, and think that because they "get by" they're actually all-stars. The opposite could not be more true. This guy cloaks his inadequacy as idealism. What a hack.
A pretty significant chunk of the web is built on 3rd-party libraries though, so limiting yourself to only hand-rolled code can be a bit of a hinderance. Ultimately, it really does come down to an argument about what constitutes programming knowledge (for, say, front-end designer-developers, cursory knowledge of JS is likely fine, and jQuery is a useful tool) and whether jQuery is really "bloat" when it may well be part of a site loading a few MB of image assets and other libraries anyway (and loading from a CDN or HTTP2 takes away more concern) It's easy to get hung up on what is "best practice" when that doesn't necessarily equate to quickest or most cost-effective.
Thought this was the poll results, it is not.
Now if only they tried for quality standards.
&gt; limiting yourself to only hand-rolled code can be a bit of a hinderance. How so? Our code never changes, everyone knows it, it works everywhere, we update it as soon as some new thing comes out (if needed), we wait on no one, it doesn't require external references to libraries or frameworks, it's easy to understand as it is standards based, it runs as fast or faster than anything else. 
Yes but it only shows you have nothing technical to say.
Hi /u/rcardin, For javascript help, please visit /r/LearnJavascript. Thank you!
IE has supported querySelector since 8; that's easily half of what I used to use jQuery for. That and a decent ajax handler and I'm pretty much set.
Hi /u/klcams144, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/ViettelDaNang, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/systematical, For javascript help, please visit /r/LearnJavascript. Thank you!
If you're using something like react, you haven't needed jQuery for quite a while.
Ok, thanks. However, I don't think that this question is on "learning javascript", but on a how can I use a popular logging library ;)
Never had an issue with Ajax. We just coded around the problems back then. No big deal. Wasn't hard. There might even be a few redditors who can do it. &gt;You said youâ€™ve been developing for 14 years. No, I said my company has been around 14 years. I started life as an electronic engineer. Most of my programming involved assembly and C till 1992 when I went to work for Pixar and then SGI. &gt;Doing that without jquery or another library that handles it for you is just plain stupid. We wrote all our code for Ajax before jQuery became popular or we even heard of jQuery (don't recall). So we could do ajax on all browsers before you could. So how stupid does that make us?
I've used jQuery in the past, and I don't own a TV. 
I know you are but what am I?
Cool
I think all this is avoiding the central point of the article, which is that for people who *don't* have the benefit of several years coding experience, jQuery is a useful tool *but* it's wise not to consider how you can utilise (slightly) quicker operations to do the same thing (but oh yeah, just forget about I.E. in that case) jQuery in this situation offers the same standardised capabilities that your company has developed over the last 14 years. In effect, you've developed your own "jQuery". I'm sure you do have a perfectly fully functional pile of legacy code which you can rely on to power websites, but it also sounds like it's cemented in thinking from a decade back when third party libraries *were* a lot less reliable but now, with the likes of, say, composer, NPM and so on, installing 3rd party libs is a much more streamlined part of development.
Oh god no, they don't. It's a tax paid state sponsored set of corporations for content creation. It is tightly gripped by the German establishment and far from neutral. (I'll admit a bit of variety in coops like arte.) This does not mean they don't create good content though. Just don't use it for politics.
How do you not know that the pains of Ajax were one of jQuery's major selling points? How are you so ignorant about the history of web development and the importance of jQuery in that history? Did you all live in a cave over there for 14yrs?
That's no bad thing though, no-one's advocating taking existing working code and replacing it with jQuery if it serves its purpose. If it works for you, that's great but look at it from the point of view of someone starting out who doesn't have that framework in place. Libraries like jQuery provide a quick and stable way to achieve things that a decade or so back we're much more technically challenging. As is the way with any technological progress. Last year's tricky problem becomes this year's quick solution.
For any juniors reading this. Don't feel bad if your work is using JQuery, and you are too. It's ok. But in your own personal projects, ***please*** try to learn vanilla JS. JQuery is not the devil, it's just bloated especially when not used appropriately (eg: loading the whole library just for hiding a div), and is a performance hit at the cost of doing something easily. There's always a tradeoff. I personally avoid using it but that's because I was versed in Vanilla JS long before I used JQuery :p but I've had to work on client websites where it all relied on it so I used it too since it was part of their ecosystem. 
My biggest issue with jquery is it tends to fail many DOM operations silently, without throwing any errors. This is convenient for small projects or moving quickly, because you don't need to handle failure cases, but is terrible once you get to a much larger project.
See that big red "NO" in IE/Edge columns of caniuse? THAT's why you still need fuckin' jQuery. The real reason you don't need jQuery though is simple - you use a library that abstracts the DOM rendering away from you, something vdom based, like React or Vue.
If you have any significant frontend to your site having your own file of utility functions is not really that complex. Any developer that can't glance through our short list of utilities or doesn't know how to write plain JavaScript (or is unable to pick it up pretty quickly) wouldn't really get hired for our frontend team.
Polyfill
The framework problem is a bit of a nightmare, granted - mostly on the JS scene. So many and hard to determine which (if any) have staying power. Personally, I think less opinionated frameworks like Vue stand more of a chance. jQuery has already shown it's staying power though. I feel it'll be around for a good few years yet, until all the browsers get their game together with properly useful standardised functionality. Even then, library wrappers like jQuery can easily offer more than browser APIs
What kind of operations have you run into where that's been a problem? Been at least a couple years since i've used jQuery on a project, but I've had some bigger ones. The issues for me really came out of managing state. So unbinding and rebinding events based on showing/hiding content. Loading ajax data and replacing it on the page cleanly, across various areas. Using a proper web framework is what I needed.
threeJS is good, but it's for 3D :-)
How do you know when somebody doesn't use jQuery? Don't worry... they'll be sure to tell you.
 function autoStart () { document.removeEventListener('touchstart', autoStart) document.getElementById('video-to-autoplay').play() } document.addEventListener('touchstart', autoStart, false)
&gt; look at it from the point of view of someone starting out who doesn't have that framework in place. There's a good chance, no matter where you go to work, they are using a framework you haven't used and you need to learn it. The big advantage with our work is, if you know javascript and web standards, you already know how to use our code.
Why would I go out of my way to make personal projects more of a pain? The standard DOM APIs are super verbose and annoying, JQuery is definitely an improvement from my point of view. I understand the sentiment of teaching juniors the underlying APIs, but I honestly think personal projects should be *fun*, and those APIs are anything but fun.
Ajax existed before jQuery came along. So did we. EDIT: I haven't a clue why I can't reply to some posts in this thread. Here's my reply to /u/thened about seeing out code: As I've said twice, we update our code continually. We don't have or use any "pre-Query" code.
&gt; I'm sure you do have a perfectly fully functional pile of legacy code which you can rely on to power websites, but it also sounds like it's cemented in thinking from a decade back Whatever code we have that everyone uses here is always under constant refinement. We would never demean it by calling it "legacy code". There is no such thing here. No one is required to use it either. If they have a better way, they can use it, and we'll add it to the pile so everyone can learn from it and use it, too.
lol, the proposal is to encrypt data, not make a bunch of rabbit holes for arbitrary categories of data. It is STILL JUST DATA!
does this work for embeds as well? I guess i would have to look into their API's?
IE8 didn't support addEventListener. It also leaked memory if you weren't careful. jQuery took care of those things, too.
Don't know what you mean. We're a professional organization, not a bunch of little kids playing hide-and-seek. And our code is visible throughout the organization. It would be stupid for someone to suggest we use jQuery here when our own code is smaller, faster, easier to use, nothing else to learn, etc.
Same here. The stuff on TV isn't that interesting (compared to the internet, games, etc) and they drown you in ads. Fuck that noise.
If regular dot notation *would* result in a type error, `join()` will just return undefined, but `maybe-baby` does guarantee no error will be thrown: const foo = {}; const myMaybe = Maybe.of(foo); const somePropertyValue = myMaybe.path('bar.baz.qux').join(): console.log(somePropertyValue); // undefined You can always check however, since `path`, `prop` and `props` all return a monad: const foo = {}; const myMaybe = Maybe.of(foo); const myVal = myMaybe.path('bar.baz.qux'); if (myVal.isNothing()) { // do stuff } else { // do stuff } 
No need just use poly fill. Once we have enough, itâ€™d be nice to store them in some central Standard library for everyone to use... what can we call this library to ensure all users can use our site regardless of their browsers?
I specifically removed `chain`, which seemed to only harness `map` and `join` together - however that's how `chain` was described via https://jrsinclair.com/articles/2016/marvellously-mysterious-javascript-maybe-monad/. Would adding back that `chain` function satisfy the monadic requirement? https://github.com/mikechabot/maybe-baby/commit/8820c48c73c18a36ab70e255ab23124c80740ba1#diff-168726dbe96b3ce427e7fedce31bb0bcL47
That's not really the aim of jQuery though. Internal bespoke code libraries likely will be more streamlined, as custom solutions usually can be. jQuery exists to provide a standardised wrapper for the whole web to use. No-one's insisting that you should switch your company over to using jQuery.
I switched over to Vue for that. Binding data with jQuery really is a pita. And it has a bunch of nice ways to get the same DOM interaction functionality as jQuery too.
Does it have the same random/shuffle algorithm applied to playlist playback?
I guess so much code have already been written, dependent on JQuery, that it will be a while before it totally dies off
Now (more than ever) I still don't want to rewrite all the jQuery plugins my sites use.
[removed]
I think he's arguing against inhouse when it comes to training new employees, not when it comes to writing javascript. The appeal of Jquery isn't that Javascript is hard for developers, but that Jquery lets you avoid reinventing the wheel when it comes to manipulating the dom and doing Ajax stuff. it's a single library that someone can target and gain experience with even before they fill out a resume. Plus it makes changing stuff on a page and dealing with browser compatibility less of a hassle. Yes people should know the fundamentals of browser apis if they're going to be building websites, but not every person making a website is going to be building everything by hand. Jquery, and libraries like it pretty much exist to outsource building layers on top of those APIs, which you probably will do anyway with your own frameworks. I highly doubt every programmer builds everything they use in house, and Jquery is just another option to save some effort by putting some hooks into the dom. Yes libraries do add overhead, but so could any libraries or code you build in house. Especially 5-10 years down the line when it comes time to update your internal libraries.
This is awesome!
I don't trust anything with an Indian Ocean TLD.
Is there any reason to not be transpiring/polyfilling your code?
Different priorities. jQuery is useful when your boss isn't paying you to satisfy your developer itch to spend days dinking around normalizing browser deficiencies.
beautiful both visually and code wise. 
I've used jQuery in the past and own a TV. It's my second monitor.
Yeah. For some more info, see the [recently added Redux FAQ entry on "why doesn't Redux pass actions to subscribers?"](https://github.com/reactjs/redux/blob/master/docs/faq/DesignDecisions.md#design-decisions). (We need to republish the docs, so this points to the Markdown file.)
&gt; We wrote all our code for Ajax before jQuery became popular or we even heard of jQuery (don't recall). So we could do ajax on all browsers before you could. So how stupid does that make us? If you were writing ajax code before jquery, great. Good for you. You're very smart. If you kept writing if statements to juggle XMLHttpRequest vs ActiveXObject (and now vs fetch), and then to check for success/failure, then to figure out the type of data returned and parse it if necessary, etc,. If you kept writing that over and over rather than using jquery (or another library that handles ajax for you), just out of some silly anti-jQuery/other people's code geek pride, then yes, you're stupid.
Sweet, just a massive rewrite of all the old jQuery code for literally no benefit!
You're conflating a device with a content source.
Not to be confused with https://stateofjs.com/ folks! But still, good insights.
I've use TV in the past, and I own a jQuery.
Not as stupid as the person who thinks that, every time one writes code, they rewrite the same thing over-and-over again from scratch. Especially when told that doesn't happen.
"Dinking around" is what a professional programmer does when one isn't just slapping things together and "it works" is his only goal.
It adds a step to your build process, and places a layer between the code you write and what is actually run on the client.
Learning how to effectively utilize event delegation means never having to bind unbind events. Bind once to a parent and walk away.
jQuery is the polyfill.
&gt; Jquery lets you avoid reinventing the wheel when it comes to manipulating the dom and doing Ajax stuff. Who reinvents the wheel by re-using previously written javascript? Who writes code from scratch every time? &gt;Jquery, and libraries like it pretty much exist to outsource building layers on top of those APIs, which you probably will do anyway with your own frameworks. No. We use the APIs as is, just like jQuery does. Why would we need to build on top of existing APIs? That's what they're there for! Yes. jQuery is an option for people who don't want to take the time to learn how javascript does things in the browser. &gt;Yes libraries do add overhead, but so could any libraries or code you build in house. Especially 5-10 years down the line when it comes time to update your internal libraries. Another false statement. We continuously update the code we use. Letting internal libraries add bloat is a mistake other people make.
I never said any such thing (that others are insisting we switch). I'm saying it sounds like he's saying devs within our organization are using jQuery without our knowledge but I also said I'm not sure what he's saying.
For example, if I've queried for all elements of a particular class, getting no elements is almost always a failure case. Sometimes it isn't, but most of the time I am expecting at least one element to show up, and if there aren't any elements it's because I've typed the wrong selector in. That's the sort of error that I want to see and handle ASAP, so (in general) it should throw, or at least return `null` rather than using the null object pattern thing that it does by default. There's also similar issues with selecting one item and selecting many items. There are some cases where I make a query, and I expect one (or maybe zero) results. There's other cases where I make a query, and I expect any number of results (where 'zero' is usually a valid option). I prefer the separation of these two queries in the DOM API - `querySelector` (returns the first or null) and `querySelectorAll` (returns all, or an empty array).
They kind of mentioned that you can use polyfils
Is that a bad thing?
not to mention transpiled code is often slower than just the native js implementation (e.g. transpiling async/await via babel ends up being slower than just tackling the code straight up in es5). I will say though I'm a big supporter of transpiling :D.
So...just like every other compiled language? :P I understand the sentiment though. :) I don't like javascript tooling and the inflation of configs that those tools require, but it has gotten vastly better with the introduction of webpack and other cli tools that can simply be called with npm script commands. And many project types have project creation and scaffolding apps which can set things up for you decently.
But the benefit is you can do it without jQuery.
no
Please stop posting this.
Replacing one library for another library that does the same thing is not a good idea. Especially as most people who use jQuery will be doing so on legacy applications.
I have used it since 2008, and will continue to do so for some time. It's super convenient and concise. You might not need jQuery. I do need it.
Hi /u/icantthinkofone, you've been warned multiple times, but you persist with the personal attacks. Have a timeout on the house.
Good luck with your transition to UX design.
It's a legitimate reason to not want to transpile / polyfill your code (which means not using ES6 features of course). It adds complexity.
Why not use [Spotify's web api](https://developer.spotify.com/web-api/)? You don't even need an account to access public information.
&gt; It adds a step to your build process How can that be a good thing ?
Okay so absolute best case scenario is that your tools work 100% of the time without you ever having to maintain your build. Compare to not using them - it's a guarantee you will never spend a second fixing the transpile step. I'm not advocating against using a transpile step in all cases, I'm saying that there is a legitimate advantage to not doing it.
Straight to the point - I like it
In my experience, I've never had an issue with the transpilation failing. The only time I really touch it is to add a feature or optimize the build in some way. YMMV.
Dinking around is when you spend hours perfecting a line of code instead of spending those hours actually solving the problem that caused you to need that line. Anyway, if the js is incidental to the work, it doesn't need to be a paragon of software engineering virtue. I'd rather spend that effort expertly solving the problem that incidental js supports. jQuery (or frameworks/libraries in general) lets you focus on the reason you're in there in the first place.
I wish bootstrap and the other css frameworks had this opinion.
Because that step does useful stuff? Like adding a 'brush your teeth' step to your hygiene process?
Yeah No IE support - rubbish 
&gt; HTML5 Encrypted Media Extensions (EME) an API used to play digital Rights Management (DRM) content **(encrypted video or audio)** on web applications. the proposal is for a specific type of data
Except ? is not composable.
To me, the reason why one might not need jQuery is that virtual dom libs take care of 99% of things for which I'd have reached for jQuery in the past.
No demo? 
It's the first time I've been able to truly put something we use internally every day back out into the community - I'm very proud of that. If you want to go straight to the code, here's the repo: https://github.com/SpireTeam/whitelister Cheers.
Can we see the code you use to handle Ajax stuff? Would be great to see some pre jQuery methods people came up with!
So here is always my argument. **EVERYONE** should have a build process. Let's say you're not transpiling or polyfilling... at the very minimum you should be minifying and linting. So now we can agree that sure, a build process is a good thing (once again, it is! I promise!) Tools like webpack make it TRIVIAL now to add things like polyfills and babel. Source map support is great too. Browsers make it easy to unravel and tools like Sentry.io have AMAZING support for all these things. Build processes aren't a hack or a bad thing to bring into the JavaScript world! Embrace the build!
And the amount of noise is just as high. Reputable sites can still publish garbage information, or fail to explain security holes or assume too much. We are still in an age of "I copy/paste code, ergo I am a developer."
It is if you hear "deploy" and think "time to open my FTP client"
Thats cause Edge is the browser they are promoting now, and I wouldn't be surprised if they already have support for this since the articles publication. Also there are some things Edge supports that Chrome doesn't Firefox Nightly has some of the most advanced features available. I doubt the IE circlejerk will ever die, even though they've moved onto an entirely new browser that is actually fairly decent.
The only thing I have a problem with is altering ScrollTop on an element. There seems to be no good way to do that in React other than finding the actual HTML node and setting it using vanilla. 
No, it doesn't. It removes complexity. You're getting the computer to do work for you. 
a great portion of the javascript community had gone full steam ahead on unnecessary contrived complexity. there's job security in knowing all the trendy library names and frameworks (that won't be around 2 years later, remember Backbone? Angular 1? ...) when you download every NPM library there is, to make your javascript app 'full featured' well guess what. now you have to add another layer of complexity to clean up the sloppy lazy packaged mess that it is.
&gt; it still provides more convenient DOM manipulation than straight JS. Yes... But... Both are bad. Directly manipulating DOM, either with JQ or Vanilla tends to create "spaghetti UI". Meaning that any part of code can alter the state of the UI, and you have literally no easy way of tracing how the current state of the screen came to be that way. It was find for early websites where you just maybe wanted to hide or show a small box somewhere, but now, pretty much anything complicated will be an absolute disaster with DOM manipulations. I highly recommend everyone moves to component frameworks/libraries and uses a state management tool like Redux or similar. It's a much cleaner and robust design. 
I think they're on a little forced timeout (chuckle) but I imagine it would be something like https://gist.github.com/Xeoncross/7663273 I mean, they're going on about this like it's some sort of elaborate previously unknown JavaScript magic, but ultimately, it's just fairly basic functionality, and something that jQuery (admittedly with the inclusion of all other parts of it) enhances and builds upon.
I really wanted to see a code example from this guy. His post history is incredible! 
Honestly am I the only one who thinks itâ€™s awesome Frontend development is starting to look more and more like backend development. With amazing tooling, packages and workflows
I know! I feel that we're in the presence of one of the Great JavaScript Masters. I can only hope they grace us with the long-forgotten knowledge of the AJAX Request Wrapper Function and the Secrets of the DOM
https://jordaneldredge.com/projects/winamp2-js/
What does your code look like?
I've never had to "maintain" my build tools to a degree that matters. If I want to add something it takes 10 minutes at most to add, and if something updates and I want to update to that it generally takes maybe an hour if it's a big breaking change. That happens maybe twice a year, plus all the little things that get added, I spent maybe 12 hours in an entire year updating those things, maybe, that's being generous. Compare that to the time I save by having it do stuff for me, and also using new language features that save me time, I'm gaining way more than I'm loosing. 
I remember doing AJAX stuff before jQuery - I first used something called Sajax and then spent some time with scriptaculous and prototype, but once I discovered jQuery it made everything wonderful. jQuery really did change the way people viewed Javascript. 
How to you handle modularization for front-end projects? Tools like webpack make it incredibly simple. 
You don't have any old repos to look at?
Yeah I have a team to work with that would be completely dumbfounded by any modern JS and tons of sites that already use jQuery widely so I think I'll stick with that...
Yes, youtube supports autoplay (I believe) Vimeo does not. Autoplaying was disabled on mobile to help preserve user's data and battery usage
it's a common joke to do with 'humble bragging', like vegans or people who vape. Basically saying you're showing off that you don't use jQuery.
 const data = [ { "ReportDate": "2017-01-01T00:00:00.000Z", "ReportTitle": "January 2017", "ColumnID": 1, "ColumnName": "Column1", "ColumnValue": "" }, { "ReportDate": "2017-01-01T00:00:00.000Z", "ReportTitle": "January 2017", "ColumnID": 2, "ColumnName": "Column2", "ColumnValue": "" }, { "ReportDate": "2017-01-01T00:00:00.000Z", "ReportTitle": "January 2017", "ColumnID": 3, "ColumnName": "Column3", "ColumnValue": "" }, { "ReportDate": "2017-02-01T00:00:00.000Z", "ReportTitle": "February 2017", "ColumnID": 1, "ColumnName": "Column1", "ColumnValue": "" }, { "ReportDate": "2017-02-01T00:00:00.000Z", "ReportTitle": "February 2017", "ColumnID": 2, "ColumnName": "Column2", "ColumnValue": "" }, { "ReportDate": "2017-02-01T00:00:00.000Z", "ReportTitle": "February 2017", "ColumnID": 3, "ColumnName": "Column3", "ColumnValue": "" }, { "ReportDate": "2017-03-01T00:00:00.000Z", "ReportTitle": "March 2017", "ColumnID": 1, "ColumnName": "Column1", "ColumnValue": "" }, { "ReportDate": "2017-03-01T00:00:00.000Z", "ReportTitle": "March 2017", "ColumnID": 2, "ColumnName": "Column2", "ColumnValue": "" }, { "ReportDate": "2017-03-01T00:00:00.000Z", "ReportTitle": "March 2017", "ColumnID": 3, "ColumnName": "Column3", "ColumnValue": "" } ] const transform = (data) =&gt; { const findIndex = (array, key, value) =&gt; { for(let i=0; i &lt; array.length; i++) { if(array[i][key] === value) { return i; } } }; const output = []; for(let i=0; i &lt; data.length; i++) { let item; const existingIndex = findIndex(output, 'ReportDate', data[i]['ReportDate']); if(existingIndex == null) { item = { ReportDate: data[i]['ReportDate'], ReportTitle: data[i]['ReportTitle'], Columns: [] }; } else { item = output[existingIndex]; } item.Columns.push( { ColumnID: data[i]['ColumnID'], ColumnName: data[i]['ColumnName'], ColumnValue: data[i]['ColumnValue'] }); output.push(item); } return output; } console.log(JSON.stringify(transform(data)));
Don't forget: * [Stately.js](https://github.com/fschaefer/Stately.js) * [henderson](https://github.com/orbitbot/henderson) (based on pastafarian, but with promises) * [pastafarian](https://github.com/orbitbot/pastafarian) * [Avtomat](https://github.com/Temoto-kun/avtomat)
&gt; Why would I go out of my way to make personal projects more of a pain * Because a lot of shops don't use jQuery anymore, and knowing vanilla js is far more useful when working with other frameworks * jQuery becomes a crutch for way to many devs because they don't know how to write vanilla js. Its useful to know how things work under the hood. * Because its actually worth learning, which is what juniors should be doing anyway.
Damn, op getting roasted in here'ah.
I wonder if they even use version control.
d3 supports all major browsers and IE down to 8. What browser compatibility issues are you facing?
IKR? Kind of feel bad for OP, but they *kind of* deserve it for that site...
Interesting... but this is likely to be misunderstood by consumers... Tidbit has a good idea, they just need to prompt the user with something like... "Would you like to remove all ads for free by opting into our preferred users program? Click here if you agree to the preferred user terms of service"
I only visited this to make sure it has the intro sound. +1
&gt; and knowing vanilla js is far more useful when working with other frameworks If you mean javascript when you say "vanilla," the language, then of course, why wouldn't anyone want to learn javascript when working on web projects? If you mean the dom-api, then for what? It is neither useful nor necessary to know it. I couldn't care less about the dom, haven't touched it other than the mounting points querySelector for years. I know what it does, i still could use it, but thank goodness i don't have to.
I'll check into that..thanks
Dojo 2. Fuck.
That was literally my only question. "Does it really whip the llama's ass?"
&gt; why wouldn't anyone want to learn javascript when working on web projects? I do mean the base language. To answer your question, for many jQuery is easier to pick up, and becomes a crutch when they're first starting out. This isn't limited to jQuery, I see it a lot at my current company when interviewing people for junior React positions as well. People know the framework, but their understanding of the language itself is shaky at best. 
If you compare two builds, identical in every way except one of them has a transpilation step, which is more complex? I'm not arguing that transpilation isn't a net benefit, I'm arguing that the transpilation step makes the process slightly more complex.
Some more informations about it can be found in this thread: https://twitter.com/tomdale/status/910550838443200515
I wonder why. When i look back i thought i knew js well before picking up a framework. But things like immutablity, mapping and reducing patterns, reactive and functional programming, es6 specifics, it would constantly push me to keep tabs on the language and it still does that. Without a proper grasp of the language most examples and patterns wouldn't make much sense at all. "Vanilla" on the other hand didn't really have that effect on me, perhaps because imperative programming isn't that demanding.
Thanks for the explanation. I'm still confused, I thought the point was to have no branching code / if checks at all? If using maybe needs yet another if check for the output doesn't that defeat the purpose, or at best simply remove one or two if statements depending on object depth? One of the things that I kept hearing about maybe monad was that I can do things in FP chain or pipe operations without fear of something breaking: like when a property is missing but I'm still piping the results from one function to another. Having return an undefined means that somewhere along the fp function chain can break easily. Hope I'm explaining this clearly enough.
I tried use ease-out timing function and It seemed like animation was a way smoother. Since the content height of each accordion might differ and transition duration for each of them are the same, it does not look like that they are opening at the same speed. You may choose to calculate transition duration in runtime, based on the content height to achieve consistent animation speed. 
You're missing my point. The advantages you point out are true, but "adding a step to your build process" in itself can't be seen as a good thing. Same for "placing a layer between what you write and what runs". You have to consider the trade off for what it is, not blindly ignore the downsides of the solution you pick.
It's not being pedantic. It's a trade off, and if you ignore the downsides, you can't evaluate your toolchain objectively.
See my other replies, you are missing the point.
&gt; I thought the point was to have no branching code / if checks at all This is a good point, and one worth discussing. You are correct in stating that you should be able to chain operations together without fear of breakage - and that is what you get with `maybe-baby`. Take the initial example of getting a `zip` off of a `user` object: const user = { firstName: 'John', lastName: null }; Say we just need to display the zip code in some Header component, regardless of whether it exists or not, we could easily use the following, although both `address` and `zip` are undefined: function _getPersonZipValue(person) { return Maybe .of(person) .prop('address') .prop('zip') .join(); } Now this *will* return `undefined` since there actually is no `zip` to be found, but we don't get a `TypeError` when searching for it! Additionally, say you *did* have to take some action if the `zip` is null or undefined, that is where you can use `isNothing()` or `isJust()` to test the result; function _getPersonZipMonad(person) { return Maybe .of(person) .prop('address') .prop('zip'); } const maybeZip = _getPersonZipMonad(person); if (maybeZip.isNothing()) { // prompt user to enter zip code } So all in all, with `maybe-baby` you are guaranteed to not encounter a `TypeError` when an undefined is encountered, however at some point your code *may* need to make a decision based on whether that data is available or not. Does this help? 
I bet your CRUD forms are just the most awesome-est.
&gt; that peg CPUs Uh, wouldn't bitcoin mining also peg your CPU?
&gt;I wonder why Two fold. First of all, structured concepts are easier to learn. Second of all, which is related, we have been interviewing a lot of bootcamp graduates, who are learning how to develop in React. 
I'm not missing anything, I just disagree with your premise. Nobody is saying that "adding a step" is a good thing, just like it's useless to say that "adding a step" is a bad thing. You can make an "increased friction" type of argument for just about everything in the world, but we're specifically responding to: &gt; Is there any reason to not be transpiring/polyfilling your code? You can make a case that it's not worth it, but I have yet to hear a compelling reason of that.
I've put together a functional version not using lodash though... const data = (array) =&gt; { let output = []; const self = { groupBy: ({propName, groupName, exclude = []}) =&gt; { const findIndex = (array, key, value) =&gt; { for(let i=0; i &lt; array.length; i++) { if(array[i][key] === value) { return i; } } } for(let i=0; i &lt; array.length; i++) { let item; const index = findIndex(output, propName, array[i][propName]); if(index == null) { item = { [propName]: array[i][propName] } item[groupName] = []; exclude.forEach((property) =&gt; item[property] = array[i][property]); } else { item = output[index]; } const group = {}; const keys = Object.keys(array[i]); keys.forEach((key) =&gt; { if(key !== propName &amp;&amp; !exclude.includes(key)) { group[key] = array[i][key] } }); item[groupName].push(group); output.push(item); } return self; }, value: () =&gt; output } return self; } // Usage data(json) .groupBy({propName: 'ReportDate', groupName: 'Columns', exclude: ['ReportTitle']}) .value(); 
good
Thanks! Have just done a quick benchmark against my [functional attempt](https://www.reddit.com/r/javascript/comments/71ck2j/lodashunderscore_help_with_nested_json/dn9vwbs/). When I switch out underscore for lodash your solution is around 20% faster.
Front-end development is becoming more complex than back-end development. I feel like OP, too. 
I believe there's an NPM package for this
It does support attachEvent though
&gt; Nobody is saying that "adding a step" is a good thing Lol, that's literally (literal sense of "literally") what /u/grimonce just argued. And literally what I raised as being wrong. Like, exactly what he wrote and I responded to.
I'm so relieved to hear that I'm not the only one feeling like this.
&gt; ... getting no elements is almost always a failure case. Why is this a failure? Sometimes elements aren't on a page (you hint at this below: "or maybe zero"). If you need the element to exist, then either ensure it will exist before being queried, or check if you don't receive any elements back. Compare to document.querySelector/querySelectorAll. &gt; ... similar issues with selecting one item and selecting many items. This isn't an issue. Just check how many elements were returned.
The one without the transpiler will be more complicated. You either have to write all your code in one file or make sure you're including everything you need via script tags, in the right order. You also have to make sure your code will work on every browser you want to target, which can actually be quite difficult if you do your development on a greenfield browser, since you may be using a feature not yet available in other browsers by mistake. With a transpiler, I can do code splitting very easily or bundle it into one file, whichever I want and not worry about having to manage all my dependencies. There's some support for modules in chrome, but it's kind of shitty at best and pretty not user-friendly. If I use webpack, I just get this for free. I can also take advantage of things like SASS very easily, that reduce the complexity of my styles but making them much easier to work with. I can also use things that are not supported by browsers yet, that make my code more readable. For debugging, source maps are awesome. I can keep source maps on sentry (or whatever) to map the errors for me, which is trivial to set up. Or if I need to see what's up with a bug in production I can just drag my source maps into chrome. There's a reason people love babel and webpack. It makes your project significantly easier to reason with and removes a lot of the complexity associated with Javascript that people hated back in the early 2000's. If you work with transpilers daily you'd see that there is significantly less complexity compared to working without one. The only additional "complexity" is the actual transpiler, but the complexity is writing a couple config files, which is trivial and takes a few minutes to get going. At first, it's slow because you have to learn what's possible, but once you write two or three, it becomes trivial and easy to manage.
You misunderstood me. I'm complaining about all these articles, not about IE. Regarding standards, it's usually Safari I have a problem with.
great point about rxjs. I am using rxjs now for all kinds of things, but when I tried angular2 it was super off-putting and annoying to have to learn this another new thing that's not needed for 99% of tasks.
Always be asking, "how can I make this code more general?" "How can I use what I already have to accomplish this new thing?" "How will I see this code in 6 months? Will I understand what was going on?" "Where are the places in the code that could easily lead to errors? Is there a way to remove those parts entirely with a different approach?" A lot of my improvements have come from going back to code I already knew worked and tried to make it simpler, smaller, more general. There is a limit. Code can become too general. Also, you need to force yourself to program in different styles, even just so you understand alternate ways to solve problems. I started with imperitive, then went to oop which I regarded as genius at the time. Now I have moved on to functional and other things. Now I don't even like oop. That wouldn't have happened if I stopped exploring.
The main thing I can think of that helps me "level up" my game is to be developing with other highly skilled people. It may be a bit harder for you if it is a hobby - maybe work on some open source projects. The thing also, is there isn't too much "wrong" with the unclean solution rather that they're applying principles needed for readability in medium-to-large projects on a trivial example. If you're not going to be doing anything at more than a hobby scale I wouldn't lose sleep over it, I would instead work on writing robust testable code.
I think JavaScript community made programming harder than it need to be. There is a lot of JS libraries that make programming a little bit more complicated, more entangled, less transparent, less KISS. I mean e.g. Redux, Redux-Saga, Rx and many other similar libraries. I don't say these libraries are evil, but that they just introduce a lot of accidental complexity, and too many special concepts. An accidental complexity is a long time problem in frontend community (remember AngularJS?). When a front development becomes too easy, then community finds a way to make its work more harder (apparently "too easy" sounds like cheating and developers like to have intellectual puzzles). 
Why is this so downvoted ?
I do the exercises here every now and then to keep my brain in check: http://reactivex.io/learnrx. They really help shake up you're thinking. Another good resource is Dr. Boolean's Mostly adequate guide to functional programming: https://drboolean.gitbooks.io/mostly-adequate-guide/content 
Supporting neutral journalism is nice, as long as it's voluntary.
I think what they are more talking about is the decomposition of the problem. The second solution is more readable and easier to understand what is happening at every point of the program. You may find it overkill at the end, but try writing your code from the top down. Start with the top level function `renderAverageShoeCostForDesigner`, then in code that most resembles english, state what it does. If you find yourself saying, I should comment or indent this code, consider how you might avoid needing that with a properly named function. Writing code in this top down style is good practice and eventually will help you recognize how to refactor that beginner code into the advanced code when you come accross it in the wild. Aside: I have a colleague who came through hack reactor and it seems like an excellent program. Good Luck!
That's very nice and clean. Love that it has zero dependencies and isn't coupled to a particular middleware (Express, Koa, Hapi), will be taking a closer look at this as I'm currently building my own validator. Thanks! ðŸ‘
The useful stuff is good. The extra step is bad.
Just to provide some context... I should have mentioned that programming is no longer a hobby. I am completely changing my career course and have decided to follow my life-long passion for programming. For the last 20 years, I've been a Ux designer, and I eventually became frustrated because I wanted to understand how to build my ideas from inception to finished product. I attended a Community College and studied Comp Sci, but I was frustrated how the curriculum was structured and I was far ahead of my classmates (with no one to push me except myself) and in some cases ahead of my instructors. So I dropped out and have decided to attend a code school instead. I'm still weighing my decisions about which one I want to attend. Self-study is great, but I really excel when I'm in an environment where I can focus, thrive, and be pushed by others. I've narrowed my choices down to Hack Reactor, Viking Code School (online), and Dev Mountain (where I live). I've also been self-studying computer science https://teachyourselfcs.com/ by doing online courses because I want to be a complete programmer. Going through SICP, programming in Scheme has been real! Fortunately, I had a previous Lisp background. So there is some background. 
Thank you. I actually had those bookmarked but haven't had a chance to investigate! I've been doing https://www.codewars.com/ on and off. I REALLY got addicted, but perhaps for the wrong reasons. Doing these challenges is where functional programming finally clicked because I was able to learn from others solutions. The "wrong" part was that I got hung up on writing golf solutions (which tend to get upvoted) instead of using good old-fashioned vanilla JS. 
We're solving hard problems and creating applications with a language that wasn't meant to initially solve the type's of problem's we're trying to solve. Not only are we creating applications, but they need to run in ancient interpreters (IE8 / 9, etc) and run different all over the place. The main problem essentially though, is the complexity of what we're trying to solve has changed. It used to be that we had to move a few dom nodes around. We NEED webpack &amp; react and all these other technologies to efficiently and maintainably solve increasingly harder issues. It's not that those technologies have ruined modern web development, it's that we ask much more from ourselves now.
Soon it'll be illegal to write inefficient software because it drains your battery.
I'm not saying it's always a failure case, but I've found that, when I'm using jQuery, 90% of the time that the selector returns no results is because I've incorrectly typed the selector. Sure, sometimes the element isn't on the page, and I'm selecting it anyway, perhaps to check if it exists, or sometimes because there's a train of logic that is easier to apply regardless of how many results are found, but most of the time it's a developer error if I've returned no results. It makes more sense to me, then, for the no-results case to return "null" or throw an error, and that, if I want to deal with this case, I need to handle it explicitly. This makes quick scripts a little bit harder, but on the whole makes the sorts of programs I'm writing more stable, because I've usually caught errors due to incorrect selectors much earlier on. It's similar with selecting one Vs selecting many. By having two different APIs, I'm able as a developer to express my intention much more clearly. Do I want to specifically select one element that I know is there? Or alternatively, am I scanning for a number of elements with the same pattern selector, and applying the same operation to all of them? The problem with the jQuery API is that, to keep things simple, it defaults to the latter operation, making it easier to make subtle errors when using the former operation.
Thank you for the advice! 
there is no onboarding, they've hired 2 or 3 developers in 14 years
This article is posted weekly. I think you are misunderstanding the concept of polyfills and plenty of websites still use them. Not every large company with a reactive website using jQuery is going to convert everything. 
Yes, OP was being sarcastic
That's some freeloader mentality right there. 
Why don't you host that json file directly on github pages ? You could access it using an http request from your angularjs code. $http.get('/path/to/your/json/file.json')//...
these resources are gold, but are libraries anyway... how to do it with vanilla JavaScript? As requested everything should be done without using external libs.
Yes, it does of course have some way to deal with events. The problem was that if you weren't using a library which took care of these differences, you had to do it yourself. With IE8, doing that was way too annoying and error-prone. Using jQuery saved some precious sanity points.
You're a redditor who claims to know how to program.
https://en.wikipedia.org/wiki/Slippery_slope
If your use of JavaScript is trivial enough, then the complication of adding a transpiler might be greater than the complication of managing everything yourself. In my experience this has never been the case, but my use of JavaScript has never stayed trivial. Of course, I'm not convinced that my experience is the only valid one. 
You probably won't be able to do a cross-domain XHR to get your JSON. The workaround is to use JSONP: inside the file, wrap your JSON within a function call: myfunc({"foo": bar"}) Then include that as a `&lt;script&gt;` on your page, and make sure to define a global `myfunc` function to handle it.
While I dont really agree with the author, you can still make any modern website without the newest and slickest js framework. If you work in a team that has decided to embrace the next best thing though, you probably need to learn something new or jump ship.
Yeah I can do that too, I had it stuck in my head to have the JSON uploaded separately so that multiple of my apps/websites I might make in the future can pull data from that one JSON file (which is horrible I know but just something to try out). I'll do it as you say now :)
Just to throw in my two cents here, I learned how to think in terms of "clean code" after watching a [set of lectures](https://cleancoders.com/videos/clean-code/fundamentals) by Robert C. Martin, AKA uncle Bob. He provides an conceptual framework for how to write "clean code" and is widely accepted as the subject matter expert in the software engineering community. I highly recommend it -- He goes over things like "how to name variables", "when to split up functions into smaller ones", "how to structure programs", etc. I'm not kidding when I say that those lectures were the most meaningful improvement I have made as an engineer. He also has [a book](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) too! 
Yeah, but it's still cool to think about how much jQuery did for the javascript ecosystem. There was a solid block of years where it was pretty much mandatory for any front-end work, and on some level it's sorta the predecessor to the modern frameworks we have today. Makes me wonder how things will improve in the next 5-10 years.
Meanwhile bootstrap is still stuck with it. Probably should find another framework :/
It doesn't implement the standard interface, therefore it's not a polyfill. Why do you think it is?
Why?
&gt; Why would I go out of my way to make personal projects more of a pain? *The nice answer* Because you are a competent developer who doesn't find non-jQuery code to be a pain and the tradeoff is a faster and more stable application. --- *The short answer* Because you are not an incompetent lazy piece of shit.
&gt; If you mean the dom-api, then for what? It is neither useful nor necessary to know it. I completely disagree. Comfortably knowing the DOM has saved my ass many times. The bigger question is why would anybody bother arguing this when it is only like 2 hours of study?
Their clean solution is NOT the type of code you would write in production. Reasons: * Minor inefficiency of allocating an extra array of prices * `computeAverageCostofShoes` is tightly coupled with "Shoe" entity and the shape of inventory data, in practice, you want to be able to compute average price of a list of any product * Reinventing the wheel, computing average should be a function you use a library (or a utility function you write yourself) for, for example: [lodash.meanBy](https://lodash.com/docs/4.17.4#meanBy) Code (some ES6+ syntax included, not sure if you are familiar with it): import { meanBy } from "lodash"; function computeAveragePrice({ name, shoes }) { return { name, averagePrice: meanBy(shoes, shoe =&gt; shoe.price) }; } function renderAverageShoeCostForDesigner(inventory) { return inventory.map(computeAveragePrice); } For learning purposes, it's much more beneficial to learn how to implement `meanBy` generically, than stuff your brain with specific made-up details like "designers" and "shoes". You are learning to code, not about designer shoes. It's a good habit to start thinking in terms of data structures, functions and modules and try to solve problems regardless of underlying domain. However, if this is the problem at hand (a thing about shoes), it's your responsibility to express the problem in coding terms, meaning translating the following statement (requirement): &gt; output the average cost of all shoes by designer Into: * How do I compute the average of a list of objects by some property This becomes something you can google with, typically you will find a stackoverflow question that points you to the right library or implementation. Now assume you find out about the function `meanBy`, you also acquired a great learning opportunity: implement the function yourself. In terms of specific things related to this challenge like `reduce`, `map` etc. a good resource to get into is underscore.js annotated source: http://underscorejs.org/docs/underscore.html The code is outdated somewhat, and quite dense / complex for a beginner. However, by going through it you will gain the indepth knowledge of: * Structure code for molecularity and reusability * Higher Order function * Some speed optimization tricks * Api design of a utility library
You posted about the same thing [10 days ago](https://www.reddit.com/r/javascript/comments/6zanos/atom_is_dead). Please if you're not going to have a valuable discussion about something, stop posting about it.
Is it possible to use this for a transition-out? Right now it correctly plays the animation when it loads the page but I want to reverse the animation when the component is being unmounted. How would I go about this?
Dude, you're not being helpful. Its clear you don't understand my question and aren't trying. 
Do you think I'm joking or something? You generally shouldn't use stopPropagation, because your listener doesn't know what who else might be listening on this element or further up in the tree. This is exactly what you asked about.
Vaadin makes some really great Web Components, including a powerful grid: https://vaadin.com/docs/-/part/framework/components/components-grid.html
jQuery made web standards relevant!
Where did grimonce argue anything like that? All I see is the question "is that bad?" which doesn't imply it must be good. It's neither good nor bad, which is what I'm saying. It's like.. "car" is not good or bad. Some cars are some cars are not.
But...what downsides? Source maps solve the "problem" and if we are being pedantic none of the JS we write is what "runs" either. My argument is if you minifying with something like uglify you're already there. Give up control, feel the ES6 wind in your hair and trust babel-preset-env. The water feels fine!
This isn't a library. This is vanilla JavaScript. That means standardized use of the language instead of using dollar signs and having to keep jQuery updated and loading the entire library on every damn page. This script builds only the polyfills needed by the visitors browser on demand and loads only that.
How would you know that if you don't own a TV
Though first solution is a little bit dirty, second solution looks overengineered in typical C#/Java/enterprise way. But It's just objects and arrays, it can be handled very simply: https://jsfiddle.net/ukbvp24f/ And if flexibility is needed it could be easily refactored. No need for creating enterprisey-big-design-up-front functions like `computeAverageCostOfShoes`. If in the future average will be calculated with different algorithm, then it could be easily be refactored/rewritten (it's 6 loc in my proposed solution). But wait. Why algorithm for arithmetic average would even change in the first place? (somebody took out this algorithm and place into separate function `computeAverageCostOfShoes` after all, like as a signal that "this can change in the future and needs to be decoupled" which is weird in this context)
I had one 15-20 years ago and I do of course know some people who have one.
[idx](https://github.com/facebookincubator/idx) is great for this and it avoids using strings while being converted at compile time to avoid the performance hit.
Use Amazon S3
You're only hurting yourself if you use jQuery, it won't always be there to hold your hand, and it's an unnecessary abstraction at this point anyway. DOM APIs aren't that bad, in fact they're pretty great, they work brilliantly and a lot of thought clearly went into them. If typing out a few extra characters is something you get in a twist over, then you're in the wrong job. If the APIs were any more high level, it would be more restrictive than helpful. Look at other languages like Java, where it's convention to have long and descriptive class and method names to help determine intent and improve code legibility. The only people who I've seen cling to jQuery are people who learned it and it became a crutch they didn't want to get rid of, and throwbacks to the days of the developer/designer who had decent design chops but only knew HTML, CSS, and the tiniest bit of JS. In terms of wanting side projects to be annoying, if you're stringing together a web app with jQuery in favour of more modern tools, surely that's going to be more annoying overall. There's one or two things jQuery does well, and they're not worth importing the entire library in for.
That's an impressive background! As for your question, there is nothing conceptually wrong in the beginners code, maybe too much boilerplate. Same beginners code rewritten with boilerplate removed, nothing else changed: function mapDesignersToNameAndAvgPrice(inventory){ return inventory.map( designer =&gt; ({ name: designer.name, averagePrice: designer.shoes.reduce((total, {price})=&gt; total + price , 0) / designer.shoes.length, }) )} Looks good enough to me. Maybe moving the average price calculation to a separate function would be recommended. 
Good article! I wonder how much you don't care about IE now when you build something on the web?
Yes it is, but I'm asking for techniques that would allow me to avoid using stopPropagation. "Don't call stopPropagation" sounds like a joke response to me...
ITT: I use jQuery as a crutch but I am a super serious developer I swear
Way back when jQuery kept front end somewhat sane, now it just holds developers back.
On the point about no native `Object.observe` being a minus against rxjs, well there is a proposal for native Observables https://github.com/tc39/proposal-observable And for named routes, there are auxiliary routes which I believe, correct me if I'm wrong, are a similar concept.
My Explanation is a bit unclear so perhaps this would make more sense: how do i take part of a string and print it on the same exact index in an empty string ("")
&gt; "adding a step to your build process" in itself can't be seen as a good thing When adding that step opens up a ton of build options then of course it's a good thing. Want to add sourcemaps? Add a line or two to your webpack config. Minify your code? 1 line. Different build configurations for different scenarios, say you want to export a bundle for use in a script tag or maybe you want to import it as a module, again that's 1 line. Even saying 1 line is pushing it, it's a key and a property: `libraryTarget: 'var'`. &gt;Same for "placing a layer between what you write and what runs". You write machine code? Guess not. Do you write assembly? Thought not. How about C++? Very unlikely in the browser. The entire world of software is solutions built on solutions, you're completely destroying your own argument by saying adding an extra step is a bad thing. If nobody had added that first step we'd be stuck with 1s and 0s. At some point someone decided it was better to run a high level abstraction over a C++ engine, which ultimately compiles down to machine code, and that's fine, but webpack?! An EXTRA BUILD STEP? Hold your horses gents, that's mental. &gt;You have to consider the trade off for what it is, not blindly ignore the downsides of the solution you pick. You talk of downsides, but haven't listed a single one. Your argument essentially boils down to "why would I walk an extra 5 minutes to the car dealer to get a car, when I could save myself 5 minutes walking" completely neglecting the benefits of a car (less walking). Nobody sees getting a car as a bad thing in this scenario, not unless they fundamentally misunderstand what a car does.
I've spent many years arguing with my past self about old code that I've written and eventually needed to revisit. Over time I've learned to write code in such a way as to not frustrate my future self. In my opinion the ONLY important aspect is readability. Performance is negligible in most cases (and can very easily be considered an afterthought). Writing code like their FOUR function example is not sensible. Three of those functions would likely never be reused and "computeSum" is just a wrapper for "arr.reduce((a,b)=&gt;a+b)" Here's my take on it var expected = { "designers": inventory.map(n=&gt;{ return { "name":n.name, "averagePrice":n.shoes.reduce((a,b)=&gt;{return a + b.price},0)/n.shoes.length }; }) }; This is something you can quickly glance at and instantly remember what you were doing. 
I'm guessing we'll be reading articles saying that you might not need React (and here's some native APIs you can use instead, and P.S. they don't work in old versions of Edge)
you could make a gist on github...
sure mate, for toggle animation you just need to set `startAnimation` to false. if you want apply the element to `display: none` after animation, there is `onCompleteStyle` and `onComplete` props to do after animation completed. If none of those helps, more than happy to help here. Can you provide some code so i can understand better the situation?
This is a fantastic visualization, great job!
The [airbnb styleguide](https://www.npmjs.com/package/eslint-config-airbnb-base) is always my go to. 
the naming feels backward... shouldn't current be the dynamic element? Blergh!
https://en.wikipedia.org/wiki/Argument_from_fallacy Besides, as your article states, a slippery slope argument can be valid as long as the argument has a logical chain. But I agree in this particular argument, no logical chain that can be guaranteed. Ads though present a much more compelling "but what about that" argument IMO.
Crystal clear is the only word I can describe for the visualization.
Before I read the comments in this thread, I tried implementing my own solution. I basically came up with the same solution as yours, except for some minor whitespace &amp; parameter destructuring differences. I think this is about the "cleanest" solution possible, in terms of having the least mental overhead. Both official solutions are way too complicated.
It's right there in the linked issue. Here's the tldr: &gt;Facebookâ€™s GraphQL spec doesnâ€™t grant a patent license. Therefore, for reasons as set forth below, most GraphQL users infringe Facebookâ€™s patents. The [medium](https://medium.com/@dwalsh.sdlr/using-graphql-why-facebook-now-owns-you-3182751028c9) article would've been a better starting off point with a link to the github issue in the comments but, I'm not OP...
The Medium article [had been already posted weeks before](https://www.reddit.com/r/javascript/comments/6wure2/using_graphql_why_facebook_now_owns_you/). There is new information in the link I posted such as Gitlab abandoning GraphQL.
Look how many times we've been told over the past few years that we don't need jquery anymore: https://www.reddit.com/search?q=you+might+not+need+jquery. Obviously as time goes on jquery becomes less relevant. Is the next post going to be: **Now more than ever *ever* *ever* you might not need jquery**?
Can you please filter for this sub and show how many times this has this been posted?
Remember when we had to use `&lt;script src="" /&gt;` and include a bunch of different scripts that just used globals? I'm glad that we don't have to deal with that ridiculousness anymore...
I wouldn't be surprised if Microsoft jumped into the game and created a library that competes with React. Yeah I know it's kind of a joke that a new JS framework comes out every month, but a framework that actually gets significant adoption is rare and I feel like we're overdue for that and those usually come from the bigger companies. Microsoft has been stepping it up on the open source releases lately, plus they have Typescript, so I'm putting my money on MS releasing a framework.
Aaah ok, just wondering why they look fuzzy ( like a jpeg ) when I zoom in?
In general CORS is the better approach if you can make the server support it, because it doesn't execute an arbitrary `&lt;script&gt;` which could do anything, whereas CORS lets you just retrieve data safely. Of course if you control both domains then it doesn't really matter.
/r/learnjavascript
https://www.google.com/search?q=define%3Asarcasm Did that help?
I'm not making an argument.
one small change I would make, I would use more meaningful variable names for a and b. I like accumulator and next: reduce((accumulator, next) =&gt; {return accumulator + next.price}, 0) Mostly because I don't use reduce every day, and need to be reminded of what the parameters are.
Events bubble, so currentTarget *is* the dynamic one. As in, you click the target which doesnâ€™t change, then as the event bubbles up: the currentTarget property changes.
The trick of picking the price out of the second parameter using the {} notation made me pause for a few seconds. I like it, but it might be a little too clever, and could certainly cause confusion for less experienced developers, or even yourself in 6 months. 
yeah, really. explains it in one fell swoop.
It's really hard to tell these days. Sarcasm died in 2016. 
Their "clean" solution is worse; it wouldnt be able to scale as well in their new structure. With the original solution, if you use observables, you could deal with an infinite stream of designers with an infinite number of shoes in a fixed amount of memory. With their new solution, everything has to fit in ram at once, and it cannot scale. Its perhaps better if you dont learn to think that way.
What a shame.
&gt; It was find for early websites where you just maybe wanted to hide or show a small box somewhere Having state objects isn't unique to the new libraries with shadow dom and diffing logic. It wasn't new when Backbone was doing it seven years ago. People seem to forget that jQuery doesn't only provide a low barrier to entry; it provides a low barrier to *consistency*, too. My last job was for a billion-dollar commerce site. When I started, they used jQuery, a simple JS templating language, and a lot of server-side content generation. While I was there we rebuilt the checkout, accounts, search, navigation, and product pages. We also built a series of new features and functionality, all based around AJAX and APIs. All of that with jQuery. No frameworks. We used virtually every feature of jQuery and the website worked on IE 8 and later. We used it for exactly the reasons it was created: Smoothing out cross-browser inconsistencies to enable developers to work efficiently. We were able to efficiently maintain a large, complex site because of jQuery. ## You can write bad code with any library. But you can write good code, too.
The end is a remote possibility to me
yeahhhh what *does* that do?
You can use bootstrap's CSS without having to use their jQuery plugins. 
Their JavaScript depends on jQuery though. I think reimplementing it for my sites would be a bad plan
I have used [Pure](https://purecss.io/) and [Bulma](http://bulma.io/) on some of my more recent projects. Both are nice.
I should rephrase my question: where should I call the animation to transition out? If I put it in componentWillUnmount, the component demounts before the animation plays.
I usually just reimplement the bits I need in vanilla JS. Often it's just small things (like being able to dismiss the notices) that are trivial to do in vanilla JS. 
oh i see if you want to do animation during `componentWillUnmount`, maybe you should consider using https://github.com/reactjs/react-transition-group, while react simple animate is more likely to use for something simple and animate what's on the screen. hope this helps mate. thanks
Yeah it's generally bad form to use a and b, but in this case I'd have to disagree. That line of code is already longer than it really should be. Maybe "sum" rather than "accumulator" and "n" rather than b? 
Totally agree! When you see the examples of the modern JS API you can see how much jQuery got *right*. It may not be as relevant anymore, but I appreciate all the work those guys did and it definitely pushed the ball forward a TON on working in the browser.
Lol i just whipped up my version of an answer before checking the example code / comments and funny enough we wrote the exact same thing :P https://imgur.com/a/zK61S (other than var names) nice ( Í¡Â° ÍœÊ– Í¡Â°)
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/ab1FKhB.png ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dnang9t) 
Good spot, it's driving me mad. 
I thought the same thing. Struck me as "Functional program all the things!!!" The above function is a fraction of the code, and more readable. That is objectively superior :P 
Your comment led me on a fun 2 day coding binge that resulted in [this](https://github.com/grind086/LootML) little language for making loot tables.
Dropbox of course
Try RawGit? https://rawgit.com/
Mmm, I doubt that. They already have created/are working on a universal wrapper via React Native + React: https://microsoft.github.io/reactxp/.
You can implement .chain using .map and .join, or you can implement .map using .chain and .of. Both ways are good. However, if a structure has lawful .chain and .of methods, all the other requirements of a monad (functor, apply, applicative) can be implemented using just them - https://github.com/fantasyland/fantasy-land#derivations . Thats why I suggest you to start with two building blocks - .chain and .of and implement others using them. The tricky part here is the 'lawful', it is not an easy task to get everything right, but keep up the good work! 
Great viz! Just stumbled across the difference today, and you helped me get a grip of it!
I guess the reality is that it's a good thing because the step you add removes other steps.
On top of that - JSON is faster than JSONP.
I remember when we used moo tools and prototype for like really basic things.
Woah.
I'm not sure about what you need, it's still a bit unclear. But maybe this will help : // 9 is an arbitrary index const index = 9 const str = "a random string".substring(index, 15) // prints " string" console.log("".padStart(index) + str)
Why on earth would it load on every page when its cached? Of course this is a library, it just polyfills what's needed instead. If you're writing something new, this is fine but at the end of the day you might as well just use modern transpiling techniques. Stand by what I said, there is no use just going through old stable code and rewriting swathes of it because jQuery is no longer popular. I didn't look too deep into polyfill.io but does it also deal with animations etc. like jQuery did?
2 hours of study, ...not my experience. Having had to spend *countless of days &amp; hours* in front of dev talks and tutorials in order to learn about the art of making the fragmented api work across browsers via browser-hacks (reason why jquery exists in the first place), or subtle things like layout thrashing when reading/writing, when paint cycles happen, promoting layers to gpu to make it lag less, intricacies like querying or accessing nodes, etc. The dom is one of the more complex parts of web development. No where else is the logical tree so disruptive. Not saying someone should absolutely not learn it, many things are still good to know, but keeping tabs on the perpetually backwards compatible pile of madness they call browser api is becoming less of an issue as it has been abstracted so well to the point where under normal conditions you don't face the dom ever. Would love to hear how knowing it has "saved your ass." I assume you write without framework.
Coolï¼
you don't understand the problem space.
Edge is evergreen though
Great idea!
Came for the llama Winamp intro, was not disappointed 
I dunno, I think its just different set of challenges no more or less hard
I really understand and appreciate the thinking behind the 'advanced' solution. I tend not to agree with people who say 'oh, this is just an overengineered, smug bullshit'. From my point of view, it boils down to the question, of who's working on the problem? If it's you alone, of course, you can just write whatever you want, and then why would you care about style, it should _just work_. But if you are working with people, you can't explain to compile the reduce functions in their heads only to understand what's going on there. Naming things correctly gives a lot of help to people who want to read and understand your code. Your function names are the comments. Back to your question: how to learn to think like this? You can try to separate everything to composable functions, things that make sense in themselves (they don't need to be re-usable in more parts of your code, they only need to be something that makes sense). Strive for a hierarchical setup in your code - think of private functions, and public functions - your public ones should be the ones that are easy to read - no anonymous functions, no magic, just an elegant outline of what the thing is achieving. The private ones do the heavy lifting, with all the .reduces and magic. After all, if you're working with people, they'll let you know if you need to improve. Conversely, you will feel that their code is hard to understand too, and you should let them know.
Thanks :) 
nice one! 
Do I read it correct that this will not be open source? :)
I see! Ahhhhhhh thanks!
&gt; "computeSum" is just a wrapper for "arr.reduce((a,b)=&gt;a+b)" That part actually makes sense, why reuse reduce when you have sum(), it also makes things clearer 
Yes. For example one game I made (never polished and it looks like s***) was a "Big Brother Chess" game where you have a knight and it jumps around as does your opponent. When a player runs out of moves he loses. A simple but kinda lame game. For games like this, I tend to just use JS to write the board as rows of divs. For an 8x8 board just write 8 square divs per line and have 8 rows of them. There are several ways to do this. Here's some code I just grabbed from the BB chess mentioned to show the basic idea: -- function drawBoard(){ // executed once at load var mainBoard = document.getElementById("mainBoard"); // mainboard was a div for writing to. var alternateFlag = true; // used to alternate board colors when drawing. for (var i=1; i &lt; 9; i++){ for (var j=1; j &lt; 9; j++) { var aSquare = document.createElement("div"); var id = "sq" + i + j; // 'sq' makes this string concatenation. Squares are named sqij. aSquare.setAttribute("id", id); if (alternateFlag === false) { aSquare.setAttribute("class", "boardCellBlack"); alternateFlag = true; if (j % 8 === 0) {alternateFlag = false;} } else if (alternateFlag === true) { aSquare.setAttribute("class", "boardCellWhite"); alternateFlag = false; // alternate color of squares on board. if (j % 8 === 0) {alternateFlag = true;} // on each new row, we need to do this or white squares appear under white squares. When we get to the end of the board, don't toggle the flag. } mainBoard.appendChild(aSquare); aSquare.onclick = movePiece.bind(null, id); if (i==1 &amp;&amp; j==1) { aSquare.setAttribute("style", "color: blue"); // human piece is blue aSquare.innerHTML = "&amp;#9816"; // we could put this in a fctn if we want to set a piece into a specific square. For pieces I just used chess piece characters, that's the "&amp;#9816". currentPlayerSquare = id; visitedSquares.push(currentPlayerSquare); } if (i==1 &amp;&amp; j==8) { aSquare.setAttribute("style", "color: red"); // human piece is blue aSquare.innerHTML = "&amp;#9816"; // we could put this in a fctn if we want to set a piece into a specific square. currentAISquare = id; visitedSquares.push(currentAISquare); } } } } -- For storing state I know one should not use the DOM, but that works fine. Then rather than using vue, I just wrote functions to update the board with each move. And, you can write fctns to check if a move is legal or only allow legal moves, etc. Other options are table tags or going to html5 canvas. 
Article is very well written, I don't get the downvotes
It's getting pretty standard in the ES6 codebases, especially React and Redux. It tells that you are only interested in price, not the whole object thus simplifying the function.
Huh, why? That's a standard ES6 feature.
React or Vue are best for when you're building highly interactive "single page" applications. That's their area of strength. They can sometimes be useful even when you've got a traditional server generated site &amp; need to add a fair bit of JS based interaction, but are probably overkill if you're only interested in adding a few small bits of functionality. So yeah, if form validation is *all* you're looking for, then definitely overkill.
first you should probably learn what those libraries do.
I like React a lot and think that it is conceptually thought-out. I did a few projects with React. However, I often end up just using Pug (former Jade) and Stylus for my front-end and Express.js as the backend because I am so fast with them and a lot of projects don't need more. You can also mix in React later. I am not sure though what the equivalents are for Pug and Stylus in PHP.
If I was doing a code review, I would accept "sum" and "n".
well, 50% there. Now implement the milkdrop visualization. ðŸ‘
I'm on Alien Blue and nothing happens. LoL
yeah there's a better way .. host it on gh pages with your site so you don't have to worry about Cors and allow-origin. hosting a static json file on a remote server just for the lolz is pointless. 
That is a great visualization, and taught me about something I didn't know about before. For anyone else who discovers currentTarget here, I encourage caution when thinking about using it. I've been on projects where it's impossible to tell where in the code something is causing an effect on the page. This could easily turn into that with the event listener being on an element other than the one that might change, target. Not everyone that comes behind you, or maybe even yourself long down the road, will think of event bubbling or know about currentTarget.
Been tapping away on my phone forever before it occurred to me maybe you only did click and not touch.
Kneading blobs into HTML via PHP is an older way of serving webpages. Lots of things have changed since then. I'd read up on single file applications, just to get an idea. If you have that idea, then yes, a framework will make sense. I would recommend taking a look at what most people use: http://www.npmtrends.com/angular-vs-react-vs-vue-vs-@angular/core There's always merit in something that has managed to establish itself in a field as fragmented as the web. If you need specific details about both, then they're more or less the same, at least on the inside. Vue is a react clone that leans back to a slightly older era (templating systems, large apis, lots of magic). But some people like exactly that because it feels more familiar, while react radically broke tradition (very small api surface, no templates, no magic). Basically you're choosing between two paradigms but otherwise they sit on the same technology: virtual-dom, createElement functions, property based components with render methods.
Looks like vimeo does support auto-play: [Source](https://help.vimeo.com/hc/en-us/articles/115004485728-Autoplaying-and-looping-embedded-videos)
actually there's one and you can try it: https://avatarsdk.com/. 
You might consider to try the Functional Programming approach.
all facebook open source has this problem. anyone who is using yarn, react, graphql will find trouble if they are planning on getting acquired.
lets are better because they don't allow for redeclaration same variable by mistake. And I would recommend also working in strict mode (enabled by e.g. writing "use strict" on the beginning of file). strict mode protects you, for example, from this error: ``` let someVariable; someWariable = 4; // typo in name ``` without strict mode, new global variable `someWariable` is created, which is not what you would want. With strict mode you have a nice error `someWariable is not defined` Besides `let` there is also `const` - I use `const` most of the time, because it's even more stricter - it doesn't allow for reassign variable.
I've been using strict mode for a wee while now. I also use an IDE that highlights unused variables. My question is more about programming style.
&gt; 2 hours of study, ...not my experience. Having had to spend countless of days &amp; hours in front of dev talks and tutorials in order to learn about the art of making the fragmented api work across browsers via browser-hacks You **seriously** misunderstand the DOM. I have been doing this work for 20 years and aside from IE not creating content nodes for white space the DOM has been extremely consistent cross-browser since the 90s. And, yes, it is roughly 2 hours of study: http://prettydiff.com/guide/unrelated_dom.xhtml &gt; Would love to hear how knowing it has "saved your ass." I assume you write without framework. * 7 years ago when I was the A/B experiment engineer for Travelocity jQuery was too slow to get it right. You can manipulate the page anyway possible before the user has the chance to see the changes occur if you understand the DOM. This is true even in IE7/8 which executed JavaScript far more slowly. * At the current job there are occasionally gaps in the expressibility of the framework. Appropriately dropping the necessary framework *views* where they need to be with simple DOM methods is the most stable and efficient solution for that problem. * I remember years ago that overuse of jQuery would break simple pages in IE or simply fail to load. IE's timeout mechanism wasn't based on a clock, like many other browsers, but was based upon instruction count. * Since I generally detest jQuery and never fell reliant to that drug addiction writing cross browser CSS isn't a challenge for me, even to older versions of IE. You don't need hacks to get this right in the absence of jQuery. One thing that really pissed me off about jQuery is that helpfully imposes IE CSS hacks on your behalf, which means I have to work around their stupidity when solving cross-browser display problems. * In order to quickly access **everything** in the page I wrote this handy utility: https://github.com/prettydiff/getNodesByType
LOL. that was a good read. The only thing is that as well as FOMO I think ineffective developers are also affected by the opposite disease: stubborness. That is fear of changing something (e.g the programming language)
This doesn't even touch upon thrashing, paint cycles, promotion, debouncing, etc. And saying that the dom api is cross browser compliant is a little naive. It is not, not if you have to support IE at least. I am working with it for more or less the same time you do, and i stand by what i said. Using the plain functions you posted will not yield a passable application. The dom is a highly complex subject, understanding and using it properly means knowing how browsers work internally. The time i've spent digging through content from Paul Lewis and so on, i couldn't count it. Google-devs had an entire segment dedicated to laggy apps and the dom hacks to help it. 
whatever you say 
If you have the ability to use es6, there's no real reason you should be using var anymore (use let and const). I'll leave it to other books and resources to explain why. If you're running into a case where you need var because of the way you have your code structured, then that's a code smell and you should change the code.
Wow... didn't see that coming. What does this teach us? "If something doesn't make sense, change your point of view until it makes sense."
I realise I don't *need* var, it just feels correct to use it for variables that really are intended to be function scoped.
My way of memorizing this: &lt;div&gt; currentTarget &lt;div&gt;&lt;/div&gt; target &lt;/div&gt; The most top `&lt;div&gt;` provides more space to the right so the longer name fits there. The inner `&lt;div&gt;` provides less space to the right so the shorter name fits there. Whatever works :D
what is "programming style"? `const`, `let` and `var` differ in behavior.
You sound like a sensible code reviewer :) 
&gt; It is not, not if you have to support IE at least. I disagree.
Made a drum synth/sequencer with Vue and the web audio API: https://inverted3.gitlab.io/drum-machine/ Code here: https://inverted3.gitlab.io/drum-machine/
Even the most basic apis aren't properly implemented in IE11: http://caniuse.com/#feat=dom-manip-convenience Not to mention IE10 and below. 
`let` and `var` don't differ in behaviour within the outermost scope. But using `var` can be used to highlight a variable's importance to the whole function - unlike, say, the `i` in `for (let i = 0; i &lt; 100; i++) {` which is meaningless outside the loop.
A year later when that function has been reused throughout a product it has become a minor frustration because it's functionality isn't entirely conveyed by its name (I know this criticism is excessive). Camel case named global functions for such an abstracted concept is bad practice IMO. Extend the Array prototype with "sum" if you really want to wrap reduce like that. 
Yes. `Let` is better, and I would recommend using it over `var`, but the issues with `var` are corner cases and can be caught by a linter. It's not like `var` turns your codebase into a veritable minefield of bugs, it's just that `let` has slightly more intuitive behaviour.
&gt; but I would prefer to continue to use 'var' for variables I really want to have function scope, and confine 'let' to inner scopes like loops That is fine, and you can probably turn off the lint check that is complaining about it. But it might cause confusion either for yourself if future code edits rearrange lines in such a way as to introduce a hoisting bug or for others looking at the code (the latter not being an issue for personal-only projects, of course). I would suggest that for consistency if you are using "let" you should use it consistently, so if you want a variable to have function scope declare it ina let at the start of the function block. The only reason to keep using var IMO is if you need (or think you might in future need) to support older browsers, where "older" doesn't necessarily mean ancient (http://caniuse.com/#feat=let shows that it has only been available in common desktop &amp; mobile browsers for about a year, and there are *many* people out there running mobile browsers more than a year old), or have a large target audience in India (where UCBrowser is very popular) or China (ditto, though not as much so). Of course, in those cases you can't use "let" at all.
They DO differ. 
Not, as I said, within the outermost scope. Edit: ie function scope. If they did differ then I wouldn't need to ask the question.
StandardJS is also great
right but I answered this. let / const are function scoped, but they are block scoped as well. So putting let / const at the top of a function is the same thing. Now... if you have some variable inside a block that needs to be accessible outside that block, then you need to refactor your code.
Where's the JavaScript in this article? If I wanted generalized programming blogs I would go to /r/programming.
It was always hard for programmers to choose one of those frameworks for the project. Comparing [Angular to React](https://mobilunity.com/blog/migration-from-angular-to-react-developers/) and pointing out all of these features and flaws, it seems like React is more convenient for usage. First of all, it has simpler structure and way easier to learn and use. Angular is strongly opinionated, means you should stick to its rules, so being able to do that, programmers have to learn all these rules and complex structures by heart. At the same time, React is low opinionated and creates space for developers to make decisions, means you can use any other JS framework you like in combination with React. Moreover, React uses virtual DOM, while Angular features regular one. Virtual DOM synchronizes with the regular DOM, and this process prevents many mistakes from occurring.
[removed]
And if you have a mac it's already installed 
They differ because they are not replaceable for example if you have such code: function a(b) { var b = 3; } you can't replace it with `let` because they act differently (with `let` it would be an error). Or temporary dead zone: https://jsfiddle.net/3ahcLjgp/ &gt; If they did differ then I wouldn't need to ask the question. But this is not matter of style alone. This is not tabs vs. spaces. `var` and `let` differ on semantic level. If you know these differences, then you could choose what you want to write (I prefer `const` and `let` but some people still prefer `var`). But personal preferences won't change fact that there are serious differences between `let` and `var`.
It's *because* they differ on semantic level that I want to use both in different circumstances.
wow thank you! I had always had these flipped in my head. What an excellent visualization 
&gt; putting let / const at the top of a function is the same thing. Yes, so why not use `var`to discriminate variables that matter throughout the function from throwaway ones (declared with `let`).
Yeah, right now when trying to do it locally I've run into those issues. I bet I could fix them locally with something like gulp &amp; creating a localhost server? I'll have to look into that. Then if I upload my page(s) to GH pages, all I have to do is just refer to the link/path file right? Then I won't get those CORS issues?
Iâ€™m on Alien Blue and it worked as expected. 
And that's what the event delegation technique is based on ;)
You're right that my solution misses the point of the exercise and exploits the simplicity of the problem, but IMHO my solution offers a certain type of expressiveness that I'm having a difficult time trying to explain... The visible layout of the logic in my solution closely resembles the properly formatted/indented desired end result. This instantly conveys the overall goal of the code without needing to bother the left side of my brain (to translate words to thought), but you're right that this type of solution doesn't scale and a more complex problem likely would need functions to be expressive. 
Variables declared with `let` in the top-level of function scope *do* exist through the rest of the function. It's the correct way to declare a function-scoped variable. It's also a good habit to declare a variable before you use it, so `let` makes your code clearer. If I see `var` in a codebase that uses `let` and `const` I'm going to waste time wondering why - what corner case is being solved here?
Weird, looks like they contradict themselves here: https://vimeo.com/forums/help/topic:288335
Ooo, that's good! I don't want you spending lots of time on it... I could mold it to what I need?
when you use let in the outer scope, anything inside inner scopes still has access to let. let / const are block scoped (e.g. inside if conditionals or loops). So you can still use let to matter throughout a function. The only thing is that variable defined in blocks are hoisted to the top of the function. Because of that, you shouldn't be using var inside blocks anyway. So let's make this clear. Using let or var at the top level of a function makes no difference. You shouldn't be defining vars inside blocks, but you CAN define let's and consts inside there. With all of that out of the way... it makes no sense to use let's inside of blocks, and vars at the top level, as using let at the top level would be the same EXACT thing... and depending on how the variable is defined to differentiate the two is a fools errand as another developer can just use them however they want, or you make a mistake, then you're just relying on the name. Regardless of how you define them, you still need to go to the definition to see how they're defined, and when you go to the definition, you will see where it's defined and you'll have your answer. There are much, MUCH bigger problems as a developer that you need to solve and reason about compared to this. Just define your variables properly, and just look at where they're at in the function... it's not that hard. When you use let and const, you don't have to worry about not defining your variables inside blocks, which makes reasoning about the application much simpler. It's as simple as this: define your variables before they're used and give them as little scope as possible. If I only need a variable inside a loop, define it there. Try to group other definitions along with it the best you can, at the top of a scope
https://developer.mozilla.org/en-US/docs/Web/JavaScript wish i had this link earlier
You are boring me
Me too :)
My opinion only. 9 times out of 10, I am using 'const' more than anything else. I usually default to 'const'. As I write a function, if I find I need to modify the value, I will switch it to 'let'. I never use 'var' at all. But I am getting the feeling by reading your comments here that you REALLY want to use 'var'....so just do it. I can't come up with a reasonable excuse for you to do it, though.
There is an extremely high level of confirmation bias here. I'm sure there are also those who didn't read all of it, or much of it, or any of it... But that's just, like, you know, my opinion, man :)
Hey Reddit! Author here. Feel free to ask any questions or let me know of any bugs. Also, if you are interested in contributing, I'd be happy to find you something that aligns with your interests.
This is my experience at a major tech company. A "var" is a denied PR.
Mine's bigger, it has a once method and fits in 22 lines https://gist.github.com/SaulDoesCode/76897ef45dc825df71bd8c3173258a4f
`const` is _way_ too much typing for these fingers. In fact, I put all my variables at the end of the current function's parameter list. No `const`, no `let`, no `var`... my fingers have never been so happy! /s
Part 2 of the same article available here https://medium.com/@neelbommisetty/introduction-to-rxjs-and-observables-part-ii-db2215ec3959
Awesome. I'll add that book to my wishlist!! 
&gt; Is this considered bad style? According to most style guides, yes. According to me, yes. Don't use `var` in new code.
any example written in js? I'm reading a lot regarding this FP / FMI but I cannot translate in code of the requested task that I've written up here. 
If you could provide an example of how to improve the solution, it might help me to better understand how I SHOULD think. Thanks!
Great advice. Thank you!
ooh, didn't realize you didn't have a server. apache is easy to set up. you will need a server tho. it won't work with a file:// uri
does 'meduim.com' actually pay people to write this garbage?
Thank you very much for your solution. It made perfect sense and it represents a way that I've begun to start coding as I feel more and more confident with functional programming. Furthermore, thank you for your reply. I think the problem was that I took the "clean" solution as the way you should ALWAYS be coding. What I have learned from reading the responses, is that it is a bit more complex than the binary clean or unclean. I feel a little more confident now that I'm not broken! 
Original poster here. Thank you for such a detailed response. I picked some gems out of your stream and will surely mull them over.
Hi /u/C5Galaxy, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/user7890000, For javascript help, please visit /r/LearnJavascript. Thank you!
https://pawelgrzybek.com/my-favourite-resources-to-learn-javascript/
Hmmm... interesting. I'm on iPhone, so maybe that's the issue? Or maybe I'm doing it wrong.
Thank you for the informative reply - you brought up some things I hadn't considered.
The only valid reason to use var today is if you're working with legacy code that cannot be transpiled (because of budget constraints etc) and you support IE 10 What you're arguing for is that it should still be ok for stylistic reasons because the code still works. That's similar to arguing that it's ok to drive without a seat belt because it doesn't prevent the car from getting to your destination. Yes, `var` works, but at some point there's the question of being idiomatic, and var has definitely fallen out of fashion. The one thing you didn't mention is `const`. This signals that a variable cannot be assigned to after initialization, and given that read-only variables are very common and that they make foreign code easier to understand, `const` should be your first pick. Then `let` becomes a warning for where variable mutation occurs. If you use `var` - especially for function-scoped variables, you lose that self-documenting feature and you make it more likely to shoot yourself in the foot with missed cases in complex conditionals. 
bullshit. If you're writing food code there's no reason for let and const. var still has better support, there is no advantage to using const and let unless you're too lazy to figure out how scoping works in javadcript
Just a small issue, you misspelled listener :) Nice codepen, though 
if you're writing code that redefines things then it's your code that sucks, not how u define your variables 
Nice short story, managed to inspire me. 
var is out of fashion? How stupid. you're suggesting he use const just because it's trendy. no one on this entire stupid thread has presented a valid reason why const is better other than "my comp sci teacher said so".. 
I'm on Alien Blue and iPhone, and it worked as expected. 
You could use `var` in this way and it would be fine but at the cost of more complex rules for maintaining this style. Your rules would be something like * Use `var` at the outermost scope of a function * Use `let` for variables that are reassigned and only used in a block * Use `const` everywhere else If you never use `var` then the rules are * Use `let` for variables that are reassigned * Use `const` everywhere else These rules are simpler to explain to a new person on the project and easier to write linter rules for.
You might get more help on /r/java instead of here, different language.
That does make sense.
&gt; Ooo, that's good! Thanks :) &gt; I don't want you spending lots of time on it... I could mold it to what I need? Of course !
&gt;I'm on Alien Blue and iPhone, and it worked **as expected**. Were you expecting it to be broken? ðŸ˜‰
There is no code and your screenshot isn't public. We can't help you.
1. I already said specifically, "If you're using ES6". When you say things like "var still has better support" it makes me think you're not paying attention. 2. The moment you start talking about laziness, you're opening up a can of worms. Developer effort is not infinite and code bases are complex. Unless you proclaim that no one has spent hours hunting down some bug because of scoping &amp; hoisting then you're letting pride get in the way of sanity. As developers, we know that bugs will happen, and that other people will touch our code. The true lazy thing to do is to not use sound techniques because "oh someone should just understand this". This is why books like Javascript: The Good parts exist. It's not that we can't use the bad parts disciplined, but that there's no reason to when we can use techniques that have much less variation.
I'm not really sure how to share the code (plus it's stupidly large and I don't know that anyone would want to look through it) But the screenshot should work! Sorry, I'm pretty bad at this. I'll see if I can figure it out.
I see, I'll have to look for it/google it to figure it out :p
[removed]
It is likely that either the algorithm you've chosen or some implementation detail is what is slowing your code down. Try uploading your code to jsbin.com and sharing the link here. If people can see your code, they might be able to pinpoint the problem.
You donâ€™t see this when you click? http://imgur.com/1TJqehe
y u angry? :) I did explain why const is better. It means there's a guarantee at the language level that a variable will not be assigned to. Ever write a virtual dom? If you haven't, it's a type of thing where you can often end up with highly polymorphic functions (in plain english, functions where a variable can be one of many types). It's hard to reason about edge cases when you're trying to diff two things and there's 20+ different permutations of what their types could be. `const` and `var` do the same but at a slightly different scale. Consider some path creation code. You could do something like: var path = await promisify(readdir)(foo)[0] if (someCondition) path = path.join(root, bar, path) else if (someOtherCondition) path = path.join(root, path) fs.createReadStream(path).pipe(res) Notice that path is always a string, but it's categorically the wrong type of string if it doesn't get into either if statements (a relative path rather than an absolute one) If your code is written entirely using var, then at a glance, this doesn't seem like anything deserving any more attention than any other code. If you use const throughout your codebase and you used a let here, it'd tell an experienced person that they should pay closer attention during code review. If you used `const`s, you'd have to create new variables, so the following code would simply have to use the right variable, and you wouldn't even be able to use the correct variable outside of its block scope.
Var was a mistake, and let and const are the solution. Consider var deprecated and move on. It's not really _THAT_ much of an issue. If I interviewed someone and they said what you just said, I probably wouldn't give you the job, not because var is _that_ bad, but because you obviously are unwilling to learn new stuff and get hanged up on unimportant crap.
And here is the interactive demo to play with: https://anvaka.github.io/ngraph.path.demo/ If you are curious how it's made - I documented my process here https://github.com/anvaka/ngraph.path.demo
That's idiotic. By doing that that 'discrimination' is only visible in one place, where you defined your variable. So you constantly have to scroll up to see whether you defined that variable with var or let. If you really need to distinguish, come up a naming convention, so that you can tell just by reading the variable name. What does 'variable that matter throughout the function' mean, and what does 'throwaway' mean? You can't throw away a variable, if you define something inside a scope with var or let or const it will continue existing until the end of the scope. Or do you mean that you define variables inside blocks like that if (you_what) { var no_no_what_are_you_doing = true; } I hope you don't do that. Just start using let and const like you are meant to, and stop fighting ridiculous fights.
And the benefits are....?
ah ah found the guy that has to support IE6 You are talking rubbish - "food code" for most people is IE11 and above, plus evergreen browsers, and you can use let and const freely without a transpiler
What this guy said.
Does the demo take into account one-way streets?
I'm not mad I just think it's stupid that people jump to the latest tech just to be trendy. Nintendo for example prioritizes support for their decade old 3ds over support for their brand new Switch because they realize it has a higher user base. you can do all the same things without let and const. let could be handy for not having to scope things into a function but const is just stupid. your example would break with const. If you need an error in the console to tell you not to reassign bars then your code sucks already. 
Very smart but not very wise.
No that's exactly what I'm trying to avoid. I find myself wanting to write things like: function do_stuff(thing) { var return_var; for (let i=0; i&lt;10; i++) { return_var = do_something_complicated(return_var, thing, i); } return return_var; }
&gt; If you're writing food code there's no reason for let and const I find it highly amusing that yet another one of these "I don't use features that protect me from bugs because I don't write bugs" posts can't even spell "good" correctly. Listen. Nobody is perfect. You may think you are, you may think you understand literally everything and are gods gift to mankind. Trust me, you aren't. Not even close. People write mistakes. All the time. You make them all the time. Protecting yourself using ```const``` and ```let``` is the only sane answer. You have tools. Their cost is free. Why on earth would you let your ego make you write bad code? 
i have no problem using new shit but using new shit for the sake of being trendy is stupid. const is stupid. It's the equivalent of turning on all error reporting in a live site. best way to avoid errors is not to cause them in the first place, not to use a keyword that will shout it at you every time. better to scope your shit properly in the first place.
Everybody makes mistakes. I'm too lazy not to use helpers that prevent them.
The demo doesn't, but [the library does](https://github.com/anvaka/ngraph.path/blob/925c40c0537f858877c12835104dcec8bedc1aab/test/nba.js#L27)
&gt; var is out of fashion? How stupid. you're suggesting he use const just because it's trendy. no one on this entire stupid thread has presented a valid reason why const is better other than "my comp sci teacher said so".. Const eliminates mutability. It is a cornerstone of functional programming. Functional programming eliminates deadly bugs like the infamous THERAC-25 race-condition error, due to forcing developers to be consciously aware of how they are mutating their data at all times. It's "trendy" in the same way that seatbelts are "trendy". People use them because it protects you from harmful defects and side effects. Grow up, kid. 
why on earth are you taking my comments personally. It's not about me or my ego. const is just stupid. I use promises and all sorts of es6 stuff but const is in no way better than var.
Ah my bad. On further review it seems you're right. From the article i linked: &gt; Important: Please be aware that autoplay and loop will not work on most mobile devices.
&gt; Var was a mistake Yes, that lasted 20+ years. And is not in fact deprecated. &gt; If I interviewed someone and they said what you just said, I probably wouldn't give you the job, not because var is that bad, but because you obviously are unwilling to learn new stuff and get hanged up on unimportant crap. I do hear what you're saying and I do have a certain reluctance towards new things, which is a consequence of being in this business for 25+ years and seeing a lot of supposedly better things fall by the wayside because they turned out not to be. But I'm not saying that about `let`. It's definitely superior to `var`. But `var` has one piece of baggage that could potentially be useful to someone maintaining your code: it signals that a variable has function scope. Maybe it's not useful. I'm not hung up on it. I'm just not quite ready to completely throw it away. 
I agree that learning vanilla JS is useful, but I disagree that jQuery, at 87 kB (minified) is in any way "bloated".
calling me kid and telling me to grow up in the same sentence is an oxymoron. const does not make an object immutable in any way shape or form, it just makes that variable name unusable again. I suggest you learn how it actually works before you start praising it, kid.. you don't even understand it you're just another trend follower
Hello there, this is an experiment which uses dynamic analysis to analyze the runtime behavior of code and generate a playable game terrain based on it. The recursive version of factorial is used in this example - the larger the input ``n``, the more often the function calls itself and the deeper the generated block constructs become. You can edit the code and visualize your own algorithms. Also a short list of block types: * function calls turn into *normal blocks* * ``eval`` calls become *red blocks*, **don't** use eval in the code :p * if statements turn into *yellow blocks*
That's why people like using functional style js these days. I hardly use for loops (and when I do, I do what you did above - without var, of course) but normally I'd do something like function do_stuff(thing) { const return_var = thing.reduce((accumulator, thingie) =&gt; { return accumulator + do_something_complicated(thingie); }, ''); return return_var; } or better function do_stuff(thing) { return thing.reduce((accumulator, thingie) =&gt; { return accumulator + do_something_complicated(thingie); }, ''); }
I suggest you go and learn a different language, because you obviously have no idea what you are talking about, and are quite arrogant about it.
Thanks for your willingness to help. I will upload the code in about an hour when I get to a computer.
Thank you! Sorry I posed to wrong subreddit 
That's the best argument for const in this entire thread. at least the most honest. 
you think const makes and object immutable and you're calling me "kid" for correcting you.. but I'm arrogant.. read the mdn page for const. I remeber a big red banner saying "this does not make an object immutable"
I can sympathize with someone arguing that object spread is trendy, but let/const are supported as far back as IE11, they're not exactly new anymore. &gt; your example would break with const Yeah, that's the whole point! I purposedly wrote bad code as an example, to illustrate that good design is about making bad things hard to do. &gt; If you need an error in the console to tell you not to reassign bars then your code sucks already. What's the alternative? Let the code run without any nags until the PM notices that something is weird in staging (or worse, production)? `const`-related issues don't even make it to the *dev* runtime if you have a linter integrated to your editor.
Maybe you can learn to match the UI guidelines by different systems. 
I really enjoyed the write up. Thank you! I haven't checked but what is your license for the library?
Thanks! It's under MIT license
fixed :)
The nice thing about defaulting to `const` is when you do use `let` it's a clear signal you plan to mutate that variable.
No problem - dealt with this exact Vimeo issue on a recent project. http://walterebert.com/blog/html5-video-autoplay-mobile-revisited/ That saved me a lot of head banging!
I like that too. Hadn't occurred to me to use `const` that way.
GitHub's API allows CORS so you can just do an ajax call to https://api.github.com/repos/{username}/{reponame}/branches/master You can access trees, blobs, etc from the URLs contained in there. 
When you're skimming through a function you can pick out the variables that matter (declared with `var`) from the incidental ones (declared with `let`).
I have to say, I think my version is much more readable. Maintainabilty is a huge factor for me when deciding on programming style. Maybe it's because I also code python, but I value simplicity and ease of understanding over fanciness and doing everything on one line.
If I could get useful things to happen to my code without tradeoffs, I would. Since that usually doesn't happen, I'll try to at least recognize when there is a tradeoff and evaluate it. I don't think that's a freeloader mentality. What you might be confusing it with is a lack of cargo cult mentality.
Yup, this is a service :)
`let` isn't trendy - it's fixing a longstanding misfeature of the language. I'm not sure if it's true now, but the day will come when you get better performance using `const` over either `var` or `let`. It's like using tuples instead of lists in python or CHAR rather than VARCHAR fields in SQL. Behind the scenes optimizations can be made when you know that something is immutable. Edit: apparently it's not actually immutable, but nevertheless I'd be surprised if optimizations can't be made because of it.
I'm computer science student, I'd really love to read an article on how did you make it. Stuff like how map is made ( i see you mention graphs, but i dont see how that's related to a map) How few of the given algorithims work. But it's very fast, and impressive project. Does it take in account road speed like highway etc. even if not pretty useful for gaming
I'm also going to add that chrome recently rolled out es6 module support and other browsers are following (missed that one). Which negates some of the things, BUT, after playing with it for a bit, code splitting with webpack actually seems a fair bit better still 
The map is a giant graph. Every intersection is a node, that contains information such as distance to neighbor nodes (the length of the street) and other stuff. EDIT: Formatting
I can get behind this. It's occasionally very useful that js supports reassignment of variables to different types, but you have to know what you're doing. Defaulting to `const` does make a measure of sense, even if just to pause and think "am I doing this the best way" when you have to change to `let`.
I must admit I wasn't expecting to be talked down to so much, either, when I came here.
great 
const is actually marginally faster than var in v8, or so I've read, but so is let. I never said let is stupid I said const is stupid. the only difference between let and const is const throws an error if you reuse the var name. If you're writing code that does that then you have bigger things to worry about than which keyword to define your variables..
Your example is pertinent. I didn't realise you could re-declare a parameter in strict mode with `var`. (Didn't believe it in fact until I just tried it.) Best argument against ever using `var` on this page. Thanks.
I assume it's a joke.
ok. good points. +1. still won't catch me using it. been writing javascript for too long to have the sort of issues const will help resolve. I just feel like a lot of the es6 additions didn't do anything but make programmers lazy. my opinion.
Alright, I edited my original post with a link to the program. To reproduce the issue, change the parameter "Max Parts" to 4000 and spawn them.
Awesome man. I love it.
Second solution is definitely better but still pretty gross. Four functions? Breaking things into tiny little functions doesn't always make the code easier to understand, now I have to bounce between four pieces of code instead of one. I'd probably do something like: function renderAverageShowCostPerDesigner(inventory) { return inventory.map(({ name, shoes }) =&gt; { const totalCost = shoes.reduce((sum, shoe) =&gt; sum + shoe.price, 0); return { name, averagePrice: totalCost / shoes.length }; }); } If you have a function that's small and only called in one place it's a good candidate for inlining and simplification. One long function is usually much easier to follow than 10 small functions that are only called once.
who is talking down to you? I'll beat em up
Is that using JS canvas? You may benefit from using a WebGL renderer like pixii.js Canâ€™t check the source since Iâ€™m on mobile, is this an N-body sim?
Thanks!
Yes, it's using canvas. I had to look up what an N-body sim is, but I think that's a pretty good description of what I'm trying to make. I'll have to look into WebGL renderers, I've never done anything with them.
This was fun to review. I think your code in ngraph.path is the most interesting part
SEO. Most search engines rely on the traditional model of navigating between pages to scrape content to use in searches. Since an SPA does not have multiple pages by definition - a search engine would need to be able to fire off ajax requests in order to view the content. Google supposedly has the technology to pull this off, but results are still spotty from what I understand. Ecommerce sites rely heavily on organic search to bring in traffic. Until SPA sites are easily crawled it wont really be safe territory for Ecommerce.
1. about 10% of browsers in the wild still do not support const. It's not just IE6, IE didn't event support it til 11. that is a huge number of people you're alienating. your comment makes me feel like you don't understand how many people still won't be able to run this code. 2. I absolutely disagree. If you're writing js then you should absolutely understand how to scope properly. debugging a reassignment error is the most basic and easily fixable type of bug you can run into. I'll concede that it's helpful for people just learning though.
It is actually simple and even more readable once you get used to it - it has one entry point (`thing.reduce`) and one exit point (`return`) and hopefully it processes everything in the list withou side effects. With a for loop you have to go through every line because _anything_ could be happening in it. If you are want to go forward with JS i'm afraid that's what modern JS is all about, and what you will need to become proficient at. But it sounds like you don't like any of it, in which case I'd say stick to python...
say you have svg map of some city, that would be quite a problem to convert every street corners into a graph nodes. OR maybe not cuz i remember fiddling with svg and all shapes are kind defined so maybe figuring out corners isn't as hard. say you have a line top to bottom, a rectangle. But it gets intersected perpendicularly in middle by another line. now there should be three nodes: Start point, middle point and end point. if this is how svg maps are made then translating streets to node is crazy. imagine finding all intersections and possible quirks. different speed limits, one - two way streets, overlapping but not connected roads, etc
What about server-side rendering for SPA though?
N-body sims are n^2 complexity, 4000 bodies = 16,000,000 body-body comparisons per frame if the bodies are all interacting with each other
Yes! I also did a write up on how I made it all here: https://github.com/anvaka/ngraph.path.demo#ngraphpath-demo It has references to OpenStreetMap API - play with it and see the response. Everything on the map is a graph's node. Some nodes are connected by `ways`. `way` can be anything - a road, a river, even a building outline is a "way". Intersections of two roads are nodes (even when a road bends - it means there is a node between two straight parts of a road). Both `ways` and `nodes` have attributes. `node` has information about its geographic location (lon/lat), while way may have attribute describing its name (if it's a street), its speed limit, how many lanes it has and so on. It's a very rich data set! I don't take into account neither directionality of roads nor speed limits - that would add significant amount of data (+20% in download size for the smallest graph of Amsterdam), which would impact demo's start up time. Said that, it's totally possible to add weights to the shortest path computation. Right now i'm considering a "distance" between two points as euclidian distance. But if we have speed limits, we could translate `distance` to `travel time`, and the algorithm would try to minimize that. If we are using Dijkstra, then we'd be done with this simple transformation. However for `A*` search, we would also have to make sure that our estimated distance between two points is always smaller than it actually is (otherwise the algorithm will not give the shortest path). One trivial way to update this heuristic would be to think that each road has the lowest possible speed limit.
 player.won = true; player.score = 1000000; :D
I do javascript interviews as part of my job and I really like DOM related questions, how events work in browsers and anything that can lead to an interesting discussion about the whole stack. I think that way you can really get a sense of the experience of the other person, how much they care about the details or if they understand the bigger picture. 
computeSum is just a poor name but the intent is correct, both lodash and ramda both have concepts like sum and average, why make arrays noisier? given that most code is going to either be using es6 modules or wrapped in IIFE's it's not like scope is a concern. you can use pluck or map to get the prices and then it's just a matter of mean(prices) This generates simple code const getAveragePrice = shoes =&gt; mean(pluck('price',shoes)) const getDesigner = ({ name, shoes }) =&gt; ({ name, averagePrice: getAveragePrice(shoes) }) const expected = { designers: inventory.map(getDesigner) }; no need to use reduce, that's an implementation detail that we can abstract out.
SO doesn't treat basic or frequently asked questions kindly. They also - and that is a real minus - don't want anything that is "too broad". You have code and a concrete question, not too basic - great. But don't start anything that even resembles something like a "discussion". Even though that can be very worthwhile end interesting, occasionally.
In your demo, you have one fixed point and one that gets swept around. (I say "fixed point" because you can only interact with one at a time.) In that case, might it be better to run Dijkstra once over the whole graph to find the shortest paths from the "fixed point" to everywhere else?
I don't have the particles interacting with each other, only with the "anomalies" that you can create. Though I do get your point, there is a lot of calculation happening.
&gt; it signals that a variable has function scope. I think this should be responsibility of IDE to provide you with such hints, like in this demo: https://hex13.github.io/demos/scope.html Although I haven't seen such scope highlighting in any of editors/IDEs (this is just proof of concept I made). EDIT: actually this demo highlights scope at cursor, not scope of particular variable - but nevermind. I did the latter too, but I can't find it now. EDIT2: yeah, I've found it: https://hex13.github.io/tutorials/es6/file (click on `variables`)
If itâ€™s only comparing against certain bodies ie black holes then thatâ€™s a lot better and not as much of a concern Anecdotally, I had a JS N-body sim with a few complex/nontrivial rules and couldnâ€™t get it over 100 bodies at 60fps, switching from canvas to pixii.js brought me to 300 bodies www.teamoverreact.com/pandea as an example
&gt; I say "fixed point" because you can only interact with one at a time. You can interact with both of them at the same time on touch device :). &gt; Might it be better to run Dijkstra once over the whole graph to find the shortest paths from the "fixed point" to everywhere else? That's a very good idea if your source point is always fixed! Unfortunately precomputing and storing all possible paths for all points (when source point is not fixed) is very expensive for large graphs. There are methods which allow you to precompute paths only for small subset of "landmarks". They require solid amount of time for pre-processing, but after that they seem to be blazingly fast: https://www.microsoft.com/en-us/research/publication/better-landmarks-within-reach/
Thank you :)! I'm glad you liked it
You dont need to store each path. Just for each node it's previous node. Now you generate the path in reverse.
I've been using javascript professionally for well over a decade at this point.
Awesome! That's a huge performance increase. I'll definitely look it up. Thanks for the help!
Sure! That works if you run single source shortest path. I was talking about all source shortest paths. If we have two shortest paths: A -&gt; B -&gt; C E -&gt; B -&gt; D What should we store as parent for B? In one case it should be `A`, while in other it will be `E`... Unless I'm missing something, this would still require you `O(n^2)` storage, where `n` is number of nodes.
Mutating things is generally done for a reason. It only signals that something else *might* be assigned to that variable. Could be true today, could be false tomorrow. Static code analysis could figure out which variables get reassigned and your editor could then highlight them differently. `const` won't be needed for that.
&gt; just to be trendy `let` and `const` are block-scoped. For-iteration scope is also handy.
Instacart is pretty close to a SPA. You'll start to see more of them soon.
yea?
&gt; let/const are supported as far back as IE11 For-loop iteration scope is broken in IE11. Well, Babel and TS can take care of that.
Thank you for your feedback! :)
You are completely right.
&gt; I think my version is much more readable. It wouldn't look any different if you'd use `let`.
You don't NEED jQuery for IE tho...
If you don't know what these things are you can google them.
Having read all the responses, I'm beginning to believe that we are touching on a philosophical issue. When I posted this, I might have left out some context. I believe they were trying to communicate that boilerplate code is inefficient and that "cleaning up the code" via decomposition aids in the reduction of boilerplate. Without further context, we don't know if these functions would be part of a larger application where we would benefit from reuse. Obviously, in this limited example, I would agree with you whole-heartedly! Thanks. 
I meant yea as in what's your point.. none of that is in dispute. no one is arguing that point.
And you find an array.reduce not easily readable? Mmm.
I cleaned up my reply a bit, maybe it will make more sense now.
Original poster here. I think that the active word is "you". Did your old self understand such constructs? Would someone that is NOT you understand them? Would they not benefit from more descriptive arguments than a,b, and n? Would someone believe you were trying to be too clever? Takes these questions as rhetorical. This is part of my confusion.
Is there such a thing as "Functional programming all the way down?" Sorry for being snarky :)
Reduce is *intrinsically* hard to understand. Which is probably why it's hardly ever used. I look forward to javascript having proper array comprehensions.
hehe, fair enough. I'm a babel-hating type of person myself too :)
It is kinda crazy, but you already guessed one way of making the job easier. Yes, there are nodes at each point where two or more streets meet, that is actually how we store map data. We don't store it in SVG of course, but it is a graph. Everytime you open Google Maps, it reads the graph and builds the svg code to visually represent the section you are seeing. It's an insurmountable amount of data and goes to show how big of an achievement Google Maps is. Think about it, even if we didn't do that, we'd still have to store the information for each street's names, speed limits and allowed traffic directions, it isn't like having nodes (which essentially is just a way of storing the data of where a street starts and where it ends) is the biggest hurdle. Of course, this wasn't built all by hand. There are algorithms that can look at a traditional map (a picture, essentially) and "guess" were the nodes should be, plus read the street names. Those algorithms are becoming better and better with machine learning, but they existed before the AI craze. However, running those algorithms everytime you want to trace a path would be impractical, so they are run once, and the result is stored in the form of a graph. It might seem crazy at first, but if you think about it, everything that can be processed can be stored. These nodal maps like Google's trade the need for constant processing power for the need for storage, since it's much cheaper to have some dozens of petabytes stored than it is to have a hundreds of supercomputers working non stop, which generates more heat, brings higher energy costs and so on. That said, there's still a huge amount of human touch in Google Maps and similar solutions. As far as I know, every data that goes into it is eventually revised by human beings. At least that's how it was until some years ago, don't know about now. EDIT: Grammar
Original poster here. This looks to be the bottom of the rabbit hole. Thank you for pointing out pluck in underscore/lodash. I obviously need to take some time to familiarize myself with the object and array utility functions. 
"*just* to be trendy"
When i was at the uni ~ 15y ago I remember a lecture about searching and my professor said something about using A* to make sure itâ€™s a reachable destination. Then applying dijktstras to find a good enough path fast enough. Put you canâ€™t prove itâ€™s the best route. ;) You can just prove itâ€™s one of the better ones. Otherwise itâ€™s NP complete Looks like a good library tho. 
Why do I need a SPA? Say my catalog changes daily. I can render every product page and cache it. Dynamic components can still be done dynamically, by letting JS fill in the gaps (e.g. render the user's recommendations client-side). Unless a site is completely dynamic based on user contentâ€”think Gmail, Dropboxâ€”I don't think a SPA has much benefit compared to server-side rendering (not React's pre-rendering!). When you start accounting for users in the developing world with lower-powered devices and slow connections, client-side rendering becomes a non-starter. 
Could we have a demo that gives weight to major vs minor roads. In the demo that would be thick vs thin. Overall looks like a great library. Thanks for you work.
Thank you for the recommendation. I've had a hard copy of underscore sitting on my desk for a few years. I'm sure that when I get more into developing (instead of just learning), I'll know the library inside and out.
I don't hate babel I just don't like adding that step to my cycle when it's not necessary 
I'm lacking the time write now to have a close look at it but my first impression is very positive. Good job!
Thanks for the reminder. I've been reading Understanding Ecmascript 6 on and off and that was like a coconut to the head.
No problem! A performance tip - Since stuff is moving around and meshes have specific, unchangable vertex positions, you might be inclined to make a new mesh for a new circle position. Donâ€™t do that - make a single mesh for each object centered at (0,0), and use the _translate_ option to move things around
Yeah, that's what I meant
Do they? What about walmart and electrode?
&gt; Reduce is intrinsically hard to understand. Which is probably why it's hardly ever used 0_o No and no Comprehensions were being considered at the beginning of the ES6 discussions, but were abandoned. I think they still work in FF
For established companies it would mean a complete reworking of their website, many were built before SPAs were really a thing. I know of several medium sized (Â£100m+ annual revenue) household name UK websites that are currently re-platforming to react + redux + node SPAs, as I was involved in one of those projects and have been offered work on others.
If you work anywhere with decent coding standards, linting will probably prevent you checking in any work with 'var' in it, so I'd switch if I were you. I can't see where you'd ever want to use var over const or let. I used const 90% of the time.
party pooper
Nither `let` nor `const` are replacement for `var`. Each has it's own specific purpose.
I think you mean "creative problem solver". ;)
Your solution implies thinking through to the solution. In your head, you assembled an engine that produces the solution. His solution implies just *remembering* what *engine* does the trick. It requires less/more mental effort and that depends to whom you are talking to. If you ask me his solution is much more unreadable to me, because my memory is like 1 byte. I cant remember what substring(..), substr(..) work, I need to check like every time (for input arguments). But I can provide *my own* solution any time. Now of course you would not want to program substr(..) by yourself every time ... And guess what, since im gonna use for loops and other basic programming tools, the chance that compiler is going to [optimise](https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/) it is very high. But If you do : hahah.yeees(doThisShitForMe) Then that chance is low. But hey, computers are fast today you don't need to think about shit now, if your sweater is hipster enough then you are fine.
Every time you call find it's creating a new visitNeighbor function.
wow never knew maps are stored as graphs. and program that takes a map image and converts it to precise graph would be amazing feat. 
Stick with the pure higher order functions, then if you convert them to observables the code looks the same way but scales asynchronously. Dont break things down into functions which must run to completion and return a final result, instead chain them. Think of it like this data.map.filter.reduce instead of fully completing the map before it starts the filter, could instead pass each mapped value through to filter, and then on to reduce one at a time. That is what observables allow. Here is a tutorial I think you will like: http://reactivex.io/learnrx/ 
It's definitely fast, and I love your write up, but it doesn't seem massively accurate, at least in the demo. This definitely doesn't seem like the shortest route! https://imgur.com/a/hNAEI Also it seems it wants you to swim a bit!
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/WP6VNvc.png ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dnbm4mn) 
That was a great article. I've heard so many times people say "I'd like to test, but I just don't have the time". This shows a great way to start that anyone can relate to. I have one tip that I use a lot for when I whip up my own no-frills assert function: don't log all successes. Log just errors and the total count. This means you can have a lot more tests passing than they fit in the terminal screen, and the errors that get logged are basically just a checklist of cases to fix, with no noise in between: let total = 0, failed = 0 function assert(actual, expected) { total++ if (actual !== expected) { console.error(`ERROR: expected ${actual} to be ${expected}`) failed++ } } setTimeout(() =&gt; console.log(`total: ${total}, failed: ${failed}`))
People still send faxes?
Interesting! Can you share the url? It should have start/end points in it.
You are correct. I wouldn't expect it impacts performance too much. Compared to everything else what it does inside, this is probably going to be negligible. I ran this code under profiler a few times - most of the slowness comes from algorithm itself. Simple things like checking if node belongs to closed set were highlighted by profiler as "hot"...
I'd hesitate to say that this is the bottom of the rabbit hole but i'm glad it helped point you in the right direction. One thing to consider is that it's not necessarily about the functions and libraries that exist, it's about how you are writing or using functions. Declarative code and functional programming concepts can really help reduce the amount of code although that's another rabbit hole to dive into. 
Check out www.ag-grid.com
I agree redux saga introduced accidental complexity, but how is redux or redux thunk complex?
I had to do it again, but basically this: https://anvaka.github.io/ngraph.path.demo/#?graph=amsterdam-roads&amp;fromId=32021&amp;toId=49915
sick brah
FWIW I can't reproduce this on PC Chrome nor Android
[This is what I see](https://i.imgur.com/hzM4tgX.png?1). Seem to be correct. Does it look different for you? 
Where's the value in doing this?
Hospitals routinely use fax machines to transmit their inventory purchase orders, among other terrifying things. Japan is also really big into faxes
it spits out html from your js app served to your client so search engines can crawl it.
Hook into the change event for your dropdown, clear out the inputs for the choice not chosen? Alternately, clear them out when submitting.
are you sure they avoid it ? I believe many companies are investing heavily in this area. I can't speak to all of pages being SPA but at very least some are. There a big difference between delivering 3-5mb of bloat ecommerce assets vs &lt;50-80kb of assets on first load on a 2G/3G connection. Even further, how can you justify this data usage ? who wants to find out that visiting ecommerce sites took away most of their monthly data usage. Either way, it is a trade-off for sure. You can't win it all. 
 function factorial(n) { if (n === 0) return n; return n * factorial(n - 1); }; let index = 0; setInterval(function() { factorial(index++); }, 1e3);
Redux itself is simple, but projects written in Redux are more complicated than they need to. 
why would you want your entire site to be a spa?
you have an agenda
My coordinates seem to render differently for me. I'm on iOS, and when I pan or zoom, the markers and routes don't move with it, if that helps at all? May be more an issue with the map than the integration
Good Lord how is it so fast? I've opened it on my phone and it calculates routes across the city in 10ms. Some years ago, I wanted to create a Tower Defense game using javascript and HTML5, but I ended up giving up because one of my requirements was that I wanted to have dynamic terrain, and the AI of each enemy should recalculate the route evrytime the map was altered. I also wanted freeform movement, no tile system. I implemented Dijkstra in a very simple raycasting technique (each vertex on the scenarios 2D polygons were represented by a node) and it was pretty bad performance wise. I had some dozens of enemies at once on the screen. Granted, I was a novice and my implementation might've been bad, but I even managed to optimize it a bit treating chunks of enemies next to each other as one. In the end, 60 enemies recalculating their routes would take about three seconds each time. The node count was pretty similar to these routes I just tried here. This suggests I could maybe get them all to recalculate routes in under a second which is pretty acceptable. I'm very impressed, I'll look into it later. Congrats :P EDIT: Corrected a dumb calculation mistake
This is very helpful. I think the bug is somewhere around WebGL/SVG layer (not in the pathfinder). I remember it was easy to break older versions of Safari with SVG. What version of the iOS/Safari are you using? PS: I don't want to waste to much of your time, but if you know how to [debug safari](https://blog.idrsolutions.com/2015/02/remote-debugging-ios-safari-on-os-x-windows-and-linux/) looking into console logs might be helpful too!
I'll have a look into it further. But I was actually running it in Reddit's app (which I think is safari) and mobile chrome and both had the same issue!
The demo gif had B point starting in my neighborhood lol that was weird but cool. This project rocks, awesome docs.
I'm going to repeat this once more to you. If you **have the ability to use es6**. What part of that don't you understand? I feel like there is a language barrier but you seem to speak english so I don't understand. Go look up the word "conflation". You are "conflating" let and const into a "you shouldn't use es6" argument. You want to have that argument? Sure. I'm pretty confident I can justify my position on being pro es6. But your problem is you feel perfectly fine not realizing that our previous discussion has been under the assertion that ES6 is fine to use. The fact that you're not getting this is confusing. Also.... pssst. A lot of us are compiling our ES6 to ES5, which eliminates your browser support point. So even if we play Devil's Advocate and ignore that you're conflating two different arguments, you're **still** wrong. &gt; If you're writing js then you should absolutely understand how to scope properly. debugging a reassignment error is the most basic and easily fixable type of bug you can run into. Who the fuck says an error will be thrown? This mentality exactly is your problem. Just because there isn't an error, doesn't mean there isn't a bug in the code that hasn't bitten you yet, or isn't biting you already. https://jsfiddle.net/swdbx1j2/1/ This won't throw an error. Imagine the conditional being in a different file with hundreds of lines, and the top part of the code being in another file with hundreds of lines. Sure... just don't put the variable in the conditional. But mistakes, typos, copy and pasting incorrectly happens. Nothing is going to catch this error.
&gt;Now make that fast enough such that SEO isn't affected by its demonstrably lower load times versus a server-side driven experience delivering that content. My React app uses SSR with a caching/CDN layer in front of it. It scores 100 for both mobile and web on Google PageSpeed Insights. And even cache misses tend to respond in less than 200ms. After the initial page load (which contains just the current page's critical HTML, CSS, and JS), the app automatically prefetches JS bundles for the most common links navigated from the page in the background. Then, the app communicates directly with my REST APIs which respond incredibly fast, so page transitions happen much faster than they would if the client had to load and render an entirely new HTML page on every navigation. And I'm able to communicate loading states to users for a UX that can't be matched by static sites. I'm curious how this is not a "server-side driven experience", and how a true "server-side driven experience" would deliver the content faster.
Very cool... good job.
SPA's that are secure, SEO friendly, **stable**, that are A/B test friendly and scale horizontally are difficult, to the point where it's almost not worth it. Also take into account that a lot of these sites are HUGE and it would be a massive undertaking to migrate them to a SPA. Also take into account that there are hundreds and hundreds of developers working on these pages. I think SPA's are much more like applications and are much harder to manage when the amount of developers increases.
How about some useful critique? No one is forcing you to use TypeScript. 
Instacart does one very small thing. Here's a list of grocery stores, you browse them in their categories, add them to the cart, and then we deliver it. They're a great company but let's not compare the complexity of them to an Amazon, a Twitch, etc. Amazon does tons of custom pages and UI for not only different categories of products, but different parts of their site, and then you have AWS web interface and all this other bullshit.
Dijkstra's algorithm is accurate, but it's not very fast at all. You can notice simply in the demo it's taking about 3 times as long as A\*. You would be extremely hard pressed to find any professional game using dijkstra for path finding over A\*, where search time had any meaning in performance.
Nope. Just the initial click here screen no matter where I tap.
That's the point. There is no real benefit for continuing to use `var`. Even attempting to use it in specific circumstances is liable to add confusion.
Exactly, it's ridiculous to even have the conversation. 
This is interesting. Is A* less accurate?
loool bro you are getting so butthurt rn.. is your life that boring that u have to get your undies in a bundle over something so stupid.. i mistook es6 for ie6 holy shit i was 33% off who cares.. you apparently.. i have never said nor do i agree with the statement "you should't use es6" nowhere in this thread have i even hinted at that. i said, and i maintain, that `const` is a fucking stupid construct in javascript. const is the fucking hillary clinton of javascript and people who use it religiously are trendy fucks. you know what else is fucking stupid.. babel. what is the point of writing es6 if you're still producing es5.. aside from being a trendy fuck. i write es6 when the code will be on our intranet where we can control the browsers used, outside of that i wont write code that doesn't degrade gracefully, which means not using const. i'm not sure what point you're trying to prove with the fiddle, but it's a fucking stupid one, whatever it is. you don't put variables in the global scope. that's bad practice. `const` is not a substitute for learning the most basic best practices and understanding the language. youre just another fucking mindless fanboy.
 Yeah. But what is the actual added value in rewriting their sites to be Spas? I do not think there is one.
It's not entirely true that classes are merely syntactic sugar -- you can't emulate super with "regular" prototype delegation. And async is actually part of the ES2017 (ES8) specs. ;-)
you're toxic, not wiling to admit to your mistakes, and just overall not sound in your explanations or approaches. You're calling me names but yes I'm annoyed that it took you what... 3 posts in this thread to actually stop and read before making another comment. Moreover, I've explained my example already, tons of times. You postulated that the js engine would throw an error. I'm telling you that it won't. Furthermore... what about using var in loops and them not getting their own scope? Care to comment on that? I'm not interested in debating the advantages of using Babel. Just because you've decided that you don't care to debate your current thread of logic doesn't mean you just jump to the next thread, just to score some kind of win. Babel is great. Go actually have a full debate with someone about Babel rather than bringing it up subsequently in some argument you've started regarding why someone shouldn't use let or const when the conversation was already predicated on a person using es6 already.
I love it! I'm running into a little trouble in places though. What's going on here? https://anvaka.github.io/ngraph.path.demo/#?graph=amsterdam-roads&amp;fromId=11092&amp;toId=33214 https://imgur.com/a/nkUPK
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/OWarJi6.png ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dnbxoft) 
i'm not sure if you wrote this before or after reading my last comment, but i admitted my mistake. it was a small one and it wasn't even relevant to the argument. why are you getting so upset about it? i didnt call you names until you started attacking for something as fucking stupid as misreading es6 as ie6. i understand your example, it's basic javascript, i'm telling you that just because *that* example didn't throw an error (why on earth would you expect it to?) [doesn't mean there will never be errors](https://jsfiddle.net/m7jksjov/). "let me say this one more time for you" i have zero beef with es6. i'm not saying it should be avoided. what i'm saying, the only thing i'm saying or have said, is that **const is fucking stupid**. capisce? i'm not trying to fight with you, i'm stating my opinion as a person who's been writing javascript for more than half of my life. if you don't like it, gtfo. you don't need to tell me why i'm wrong because you don't even know why i'm wrong. you're just being argumentative and anal. who fucking cares. go get laid or something.
Thanks! I believe this is just the data. Two roads intersecting on a map do not alway mean you can make a turn. For example, one could be a bridge over the other. I think I found your path on Google Maps as well: https://www.google.com/maps/dir/52.3626229,4.9628647/52.366142,4.9451907/@52.3703753,4.9519916,14.96z/data=!4m2!4m1!3e0 - looks very similar.
I'm sure there are many who would believe I was just trying to be clever, but I was just trying to write the cleanest solution to the problem. IMHO using descriptive argument variable names in a transformation method is only distracting. The prominent descriptive words are "averagePrice" and "reduce". Of course I didn't always understand such constructs and it wasn't my intention to offend. Don't allow your confusion to frustrate you...
Ooh, that's exciting!
No, provided the world you are pathfinding in obeys certain pretty normal physical rules (i.e. no wormholes or places where there is a straight line isn't the shortest path), A* will find the shortest path. Dijkstra's is nice when you want to find the shortest path to a given node from *all other nodes*. But if you're trying to find a single path between two points, A* (or one of the more advanced ones like jump-point search) is usually what you want.
Hi /u/ElissaH1, For javascript help, please visit /r/LearnJavascript. Thank you!
[This has been already posted](https://www.reddit.com/r/programming/comments/70jxpz/electron_the_bad_parts/) a couple of times.
Yes it's considered bad style to use it as a default these days. You should use `const` by default, and then `let` or `var` when you can justify its use.
`const` means that you won't change the value of that thing. If that is your intention, then yes, it's better to use it than `let` or `var`.
&gt; it just makes that variable name unusable again Not really. In JS, object variables are actually pointers to objects. You can of course change the object a `const` points to, but you won't be able to change the pointer itself. You can't do this for example: const myConst = {}; myConst = {}; Granted, it's not as good as real constants from other languages.
Ha. I disagree with your synopsis. No one asked you to engage in some discussion of Babel, or to do fly by readings of my posts. But it doesn't matter. you didn't answer my question either. so i'll post it here for you. var array = [1, 2, 3]; for (var i = 0; i &lt; array.length; i++){ setTimeout(function() { console.log(i); }, 1000) } You realize this program won't work in the expected way right? What do you say to the developer that runs into this. To use IIFE? I do think in your answer that you were combative and you weren't really focusing on the issue here. There's no downside to using let or const if you're already using es6. Absolutely none. Here's a tip. Separate arguments out, and then argue them separately! You'll save yourself a lot of headache. And I don't know if I"d call that admitting your mistake. More like a "yeah I fucked up, so what?". If you were pragmatic, you could have went "oh my bad" and then onto es6. Even now you have the chance to reframe your argument properly to not liking es6. You haven't made one single argument against const or let that doesn't apply to es6. But you refuse to for some reason.
It looks like `flow` is the same as `ramda` `compose` or `pipe` depending on call order. If not, the rest of my comment is moot. ------------------------------------------- Let's make the `compose` function so that we can see everything our worker will be doing: const compose = (...fns) =&gt; start =&gt; fns.reduceRight((state, fn) =&gt; fn(state), start) A function that takes some functions and returns a function. That returned function is expecting some `start` value that will kick off the function calling. It then calls each function is reverse order given, passing the previous return value. So now let's see why this doesn't work for `promises`: In order to get *any* value out of a promise, you have to use `then` or `catch`. You can use `await` but it is ( I believe ) syntactic sugar for calling `then`. Basically there is no way to 'pass' the value from one function to the next via `val.then(fn)` because *where does the next value go?* In *what scope* is the return value of `.then(fn)`? What variable, after calling `.then(fn)` has access to the new value? You could write some helper functions that unwrap the `Promise` value ( which is what your `await` does above ) but you seem to not like that. You seem to want a function that will pass along values, even if they are wrapped inside of a Promise. If you are okay with the return value being a promise: *in pseudo-code. Fix before using* const compose = (...fns) =&gt; (start) =&gt; fns.reduceRight(async (state, fn) =&gt; await fn(state), start) We use the same `compose` function but `await` the result of the `fn(state)`. This means that any/all/some/none of your `fns` can be `Promises`. It also means that you will be returning a `promise` for this function.
Hi /u/alhajiash, For javascript help, please visit /r/LearnJavascript. Thank you!
You'll know you "really have it" when you write an entire application in unit tests first, then integration tests. Then, you just tie things together. 
 &gt; No one asked you to engage in some discussion of Babel you were the one who originally brought up babel. i guess i'm not allowed to respond, sorry, i know now. &gt; You realize this program won't work in the expected way right? What do you say to the developer that runs into this. To use IIFE? you say that like it's such a bad thing. yes, if your code will be run in the wild use an iife, at least i would, for now, until support is better than 90%. what is the benefit of alienating the 10% of browsers that still don't support it? why do you think google and facebook and reddit don't use that shit in their source code? at least not without including polyfills. if it's not for the wild web, use let, because **const is fucking stupid**. feel free to reread my previous posts if you still don't get my point.
&gt; In JS, object variables are actually pointers to objects. I don't understand what you're saying here. In what language are they not? Also not sure what you meant by "not really." You just verbally disagreed with me then posted a code sample that perfectly demonstrates my point. &gt; const means that you won't change the value of that thing. If that is your intention, then yes, it's better to use it than let or var. No, that's not what it means. Behold.. const shits = {poop: "farts"}; shits.poop = "asdf"; This is perfectly valid and changes the value of the object. If you want actual constants that don't allow you to change the object, use the `freeze` method. var shits = {poop: "farts"}; Object.freeze(shits); shits.poop = "asdfasd"; // won't work
My, that demo is sexy.
I'm kind of dumbstruck. So, how is this so fast? Can you differentiate your approach from others that are commonly used? What is NBA*, some version of A*?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/gis] [Really fast pathfinding implementation that makes use of OSM API. Saw this in r\/javascript and thought it was cool.](https://np.reddit.com/r/gis/comments/71nxgj/really_fast_pathfinding_implementation_that_makes/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Chrome on iPhone runs on Safari, so that would make sense.
Amazing work!
like this class Character { Stats(newAttack, newDefense, newHealth, newSpellpower) { this.attack = newAttack; this.defense = newDefense; this.health = newHealth; this.spellpower = newSpellpower; } } const bobTheOgre = new Character(); bobTheOgre.Stats(1,2,3,4); console.log(bobTheOgre.attack); 
Bad bot.
&gt; Yeah, it would be best to work with a 100% code coverage and test allllll the things 100% coverage is extremely difficult - perhaps impossible - to do. Adding a single conditional branch on one expression can double the amount of tests that need to be written or run. Even coverage tools that test expression-level rather than line-level only test if expressions get executed but not whether all permutations and combinations of possible values get tested. If anything ever says 100% code coverage, it's almost certainly a lie. If you run a fuzzer against any lib with 100% coverage you'll find an enormous amount of untested oversights. It's rather scary. Even a trivial codebase of a few thousand lines need 10x more lines of tests to get anywhere close. I think the best you can do is write tests that validate 100% of as-documented public API functionality - and this is usually sufficient.
Thx mate :P
Yes, it is essentially the same. Thank you for the detailed response! I think I might be misunderstanding exactly what you are trying to explain - casting every function's return value to a Promise and awaiting it before running the next function in the pipe seems to work just fine (per my example above). It seems like your pseudocode had a similar goal in mind, but my question is twofold: Why is this not standard for pipe()? Surely it makes sense to account for, or at least allow for, asynchronous functions. My foremost guess is performance concerns, obviously you wouldn't want to bother casting every function to a Promise if they were all synchronous, but then why do these libraries not at least expose the option? After all, we know dev time is more important than performance optimization the vast majority of the time. Also, *why is this not being requested*? I feel like I'm taking crazy pills. Surely I can't be the only one trying to pipe asynchronous functions alongside synchronous functions. I must be missing something. Also, to clarify, in my example, error handling works just fine, since the pipe returns a promise: const getYoungSortedUsers = flowAsync( getUsers, filterOld, sortByName ) const main = async () =&gt; { try { const x = await getYoungSortedUsers() ... // additional logic } catch (e) { console.log('pipe leaked...') } } This has no issue. I just have to believe that I am missing something (or maybe everyone else is just doing the same, and didn't find it noteworthy)
Will give it a go, thank you
I'm not claiming to know anything you don't so take my advice/words with a grain of salt. But! Let's see if we can figure it out together. &gt; Why is this not standard for pipe() If we say `pipe` returns a `promise` that kinda defeats the purpose of a general utility of chaining unary functions together. That's sounds like creating a very specific use-case into a very generic function. For example, if I do addAndMultiply = pipe( a =&gt; a + 1, b =&gt; b * 2 ) addAndMultiply(5) Is it intuitive that `addAndMultiply(5)` is a promise? Should the value `12` be enclosed inside of a `promise`? &gt; Also, why is this not being requested? Because `pipe`, `compose`, `flow`, et al are generic utility functions that solve very simple, dumb, no thrills issues. If you want an `async-pipe`, for sure make it and put it on npm! I'm sure a whole bunch of people want/need it! But `pipe` means *call each of these functions one after enough, passing the previous value over*. If we start saying 'And it will always return a promise', we are encoding our specific use-case into the generic problem `pipe` is trying to solve. 
I really appreciate the response! I think what you have said here is exactly what I needed to hear to let me sleep tonight. I absolutely agree that I wouldn't want to get a promise back just for a simple array transformation. In fact, I'd feel a little personally attacked. It'd be super cool if pipe detected that any single one of its arguments returned a Promise... but I think that is a bit out of the scope of what javascript is built for. Anyway, I'll plan to pop this into an NPM package, maybe I'll find out if other people are looking for the same solution. Thanks again man! I'll be keeping an eye out for your future posts!
Ramda has this in [pipeP](http://ramdajs.com/docs/#pipeP) and also composeP. 
I really need to look more into ramda. does this pipe allow for synchronous functions as well?
Hey, redux-subspace author here... &gt; Unfortunately, the documentation for this library is pretty hard to read - too broken down into too many little sections. It's funny that you find this an issue, because we put a lot of effort into breaking our single file README down into smaller logical sections the help people out when getting started with subspace. I'm interested to know what you think is missing from the README to make the first impression better (I see rikurouvila, who is now a contributer, also didn't like it to start with), as the best documentation in the world is no good if nobody wants to read it. As for how 2 sub-apps can communicate, there is currently the [global action functionality](https://github.com/ioof-holdings/redux-subspace/blob/master/docs/advanced/ScopingActions.md#global-actions), but I'm working on a new middleware that will give much finer control. It'll look something like const store = createStore(reducer, applyMiddleware(namespaceAction('ACTION_TYPE').from('child1').as('child2')) The parent application basically acts as the router for the action to pass them between the relevant namespace. This is still in development though, so no promises on the interface or when it will be ready.
i'm pretty sure as long as the first function returns a promise it shouldn't make a difference. * keep in mind this is composition for *functions that return promises*, not 'promise composition' ^(* i haven't used this so i'm not 100% sure)
Computers have scroll bars, so there's no problem putting lots of text on a single page. Anything up to about 5-10 screens worth is easy to skim through visually. When content lives behind a link however, readers have to make a conscious decision to navigate to a new area, so they are no longer skimming for information. In other words, breaking the text into tiny pages doesn't help make it more accessible; it just adds cognitive overhead. I evaluate a lot of Javascript libraries, so my goal is to quickly determine if something is going to be useful or not. If it does, I'll dive into the fine-grained documentation. What a library does and what the authors *say* it does are sometimes very different, so I mainly look for usage examples. A well-motivated usage example quickly establishes what a library's major features are and how they work in practice. This is why I think the whole `Basics` section could move to the main readme file - it is small enough to fit, and quickly establishes what the major concepts are. Based on that, a visitor can quickly determine if this is something they are interested in, and whether the want to read more or not.
So, part of the problem I had when designing the doc's structure is that it is split into multiple packages for tackling different aspects of redux application (i.e. Redux only, React, redux-saga, etc.) and most users will need details on `redux-subspace` and one of the other packages to see the full picture. But without knowing which other packages they are going to need, drawing a boundary of what to put in the README was difficult. Based on this feedback, I will look at adding something to the repo's main README and the README for each package that gives a quick overview of what they do, and review which parts of the `Basics` section of the main docs is actually required after that. My guess is it will be a summarized version of the each page, so only the `Getting Started` page will actually be removed. &gt; In other words, breaking the text into tiny pages doesn't help make it more accessible; it just adds cognitive overhead I would point out that the intention was never tiny pages to fit it all on one screen, but rather to make logical sections in the docs of functionality
I documented it here: https://github.com/anvaka/ngraph.path#why-is-it-fast but maybe GitHub's hash links are not working well on mobile. The section is called `Why is it fast?` TL;DR: Used optimized heap data structure, used GC friendly object pool, and yes `NBA*` is a bi-directional `A*` with smart and fast exit criteria.
Thank you :)! I love Seattle.
Thank you :)!
Twitch is essentially a SPA written in Ember 
Thanks for your feedback! You're right, the success logs are kind of just noise and not really needed. Personally, at that point in my coding life I'm happy about every success log, it's very motivating for me. But that's not for everyone. And yeah: with more tests it would become a bit chaotic.
&gt; 100% coverage is extremely difficult - perhaps impossible - to do. Oh. I exaggerated that intentionally, sorry if that didn't come across right. But thanks for your explanation anyways, it really helps me to hear and read about experience from others! 
wasn't criticizing, just stating personal experience :) writing tests is a real PITA.
Could you add a little copyright notice for OpenStreetMap in one of the corners of your demo? The more people know about the project the better the map data will be. :)
And I didn't read it as criticism. Just wanted to state my mistake :D 
I'll see what I can do. By the way, the link to OSM is already available if you click `About`button, also [description of the project](https://github.com/anvaka/ngraph.path.demo#data-preparation) has more information about where data comes from (the NYC graph comes from a different place).
The only benefit I've seen of SPA's (in terms of user experience) are simply faster transitions between static content at the initial offset of a slower load time before the assets are cached on any revisits. Dynamic content, etc still needs to be exposed via end points like rest api's (as even in cases of SPA's there's no reason to preload everything). The idea though of rendering static content with a JS painted on the screen to power it reminds me simply of legacy development practices. We have over 7000 static pages at my organization and it is a giant cluster f*** to try and manage with those types of legacy implementations. By having a framework and a view library supporting it that can consume common modules/etc; it is significantly easier to power. In short, SPA's/frameworks/etc are for large apps/organizations; they definitely are not needed otherwise in my opinion (unless you like easy binding, templating systems, etc).
No luck, still can't get it to display.
&gt; I'm happy about every success log, it's very motivating for me That's great. If that's motivating to you, there's obviously no need to change it. I just thought I'd also share a similar workflow that works well for me since it seemed relevant.
Anything async can be considered a `side effect` and the libraries you mentioned strive to be as functional as possible. For example, `ramda` doesn't even have a `random()`.
that's not true, Google is rendering JS since 2014, you can test it here https://www.google.com/webmasters/tools/home?hl=en-GB - SPAs are completely compatible with their crawlers, you can have full coverage (for the other search engines) with an isomorphic application, just by using Next.js or smth similar
https://anvaka.github.io/ngraph.path.demo/#?graph=amsterdam-roads&amp;fromId=43069&amp;toId=20149 This one doesnâ€™t seem optimal. 