So I had a lot of issues using string.ify because its written in es6 and my tools don't support that. So I spent a couple hours writing a beautifier myself ffs. I honestly don't know how no one has published a reasonable js beautifier in the past 20 years... Here it is folks: https://github.com/fresheneesz/beautinator
look at electron : https://electron.atom.io/
You could put everything into a 1D `Uint16Array`, then create an array of views into its `ArrayBuffer`. For example: const createViews = (width, height, data) =&gt; { if (data.length !== width * height) { throw new Error('Array dimensions don\'t match width and height'); } const views = []; const buffer = data.buffer; const BPE = data.BYTES_PER_ELEMENT; // Should be 2 for (let i = 0; i &lt; height; i++) { const offset = i * width * BPE; views.push(new Uint16Array(buffer, offset, width)); } return views; }; // 2x2 Example const data = new Uint16Array([ 1, 2, 3, 4 ]); const views = createViews(2, 2, data); // data[y][x]; console.log(views[0][0]) // =&gt; 1 console.log(views[0][1]) // =&gt; 2 console.log(views[1][0]) // =&gt; 3 console.log(views[1][1]) // =&gt; 4 See [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays) for more info on typed arrays.
Re: the lazy A\*, there's a good solution for that problem in this paper: https://nofile.io/f/HTG6Y0gGMak/Bi+Directional+A+Star.pdf. The termination condition is basically step 5 on page 131. Basically, you know that the shortest path is through a node that you've already explored. Because you've calculated the shortest distance from the start and from the goal for each of those nodes already, you can just iterate through them looking for the node with the lowest sum of those two, and then build the result path back outward from that optimal middle.
Will a day pass without an article on JavaScript's "new" ES6 features?
My guess is that the comparison is unfair to Dijkstra's. Everyone is always unfair to Dijkstra's. The way you use Dijkstra's (and I find that to be a *much* more common problem to need solving) is you run it once for a source node and then it will give you all the shortest paths to all other nodes. Then when you want the shortest path to some other node you only need to follow the pointers already saved, which will be much faster than running Astar for every node. Since this test page shows Dijkstra's being much slower, my guess is that it runs once for every time a new destination node is selected? In practice I find I need Dijkstra's a lot, almost never Astar, because there is very often a single node and you need to find many shortest paths from it, so just a single run of Dijkstra's will do that, instead of having to run some Astar over and over for every other node you need.
Have you considered using the _.chain with async/await?
_Yes_, but with two caveats: 1. Google only spends so much CPU resource spidering any particular site, and spiders with JavaScript runtimes are more expensive than those without. The limitations might be more liberal than in years of old, but if you're Amazon, with millions of pages, it may still matter; 2. Googlebot only waits so long for SPAs to render content. If a page fails to paint relevant text in time, it may be purged from the index, and ultimately reduce the host ranking. These problems are easy to detect and easy to fix if you're rendering on the server.
thanks, didn't knew about the CPU resource limits - I don't think this should be a problem as if you have something on a Amazon magnitude, you will probably dynamically load small JS bundles (similar to what Netflix do) For the rendering time I wouldn't count this as an issue either as SPAs are normally (and by that I mean 99,9% of times) faster to render (as it all happens client-side) rather than usual client-server websites. Nowadays using next.js tho it's so easy to go isomorphic, so these (potential) issues are not valid in that case. Really good points tho, didn't thought about them
Not about FP per se, but might help https://www.ibm.com/developerworks/library/wa-finitemach1/
I do this for a living it gets super boring.
Certain industries (not to mention entire countries) would basically implode if faxes ceased to exist overnight. 
&gt; No, provided the world you are pathfinding in obeys certain pretty normal physical rules (i.e. no wormholes or places where there is a straight line isn't the shortest path), A* will find the shortest path. A* doesn't care about the layout of your graph. It's almost exactly the same algorithm as Dijkstra, with the difference being an added heuristic to help check better paths first. It's up to you provide a permissible heuristic for estimating path costs. &gt; Dijkstra's is nice when you want to find the shortest path to a given node from all other nodes. You've got that backwards. Dijkstra's algorithm solves the single-source shortest path problem. (Not all graphs have bidirectional edges.)
You can still use a framework for server-side rendering regardless of the size of yours codebase/organization. Express can be used in Node. I've used Rails in the past and, currently, Django at edX. The number of pages you have is irrelevant given that they are generally generated by templates. It's the number of *templates* that matter (also associated views and controllers if you follow MVC). You have the exact same problems with a SPA. "Legacy" isn't always bad, especially if it works well for your needs *and those of your clients/users*. I have found that many SPAs appeal to the needs of developers who want to try something new and non-legacy. Users just want a fast *initial* page load. This is important in ecommerce because time and attention are dwindling. I want my users to see product info as quickly as possible so they can make a purchase. 
&gt; For the rendering time I wouldn't count this as an issue either as SPAs are normally (and by that I mean 99,9% of times) faster to render (as it all happens client-side) rather than usual client-server websites. Show your work on that claim. Is that subsequent page loads or initial? On the surface it makes no sense that a server-side rendered page with minimal JS dependencies would load slower than a page that is all JS.
Hi /u/sumairhamza, For javascript help, please visit /r/LearnJavascript. Thank you!
Hi /u/Xoax34, For javascript help, please visit /r/LearnJavascript. Thank you!
Didn't know about `pipeP`! Thanks for pointing that out.
thanks for the link - i had just read your .demo page not the actual library write up. so much to learn ... 
also, all my searches for NBA* algorithm bring back results about basketball. is this a known algorithm or did you just create something new?
I recall there was something where it would prevent playing songs which wouldn't "seem" random. Are there any resources for how exactly it did this? I'm trying to match as many details as possible.
It all comes down on how the SPA is done. Progressive web apps are a thing and the user experience on them is much better than waiting for the full rendering from backend. That's generally the same thing for SPAs, where aside from the initial loading (which CAN be progressive too, so really small load and then loading only the JS chunks you need based on who the user is and where he's going), the routing is done client side so every subsequent page is blazing fast as well.
The use of es2015 proxies is VERY welcome. Can't wait.
Yea that all makes sense; to me it just boils down to whether you want the fastest first time (pre-cached) page load or faster transitions/etc between points of your app. From there any deployment process should support modularized js/css/html. In the case of a lightweight example like you mentioned I would just use a very fast view layer library like inferno since you don't need all the overhead of something like React, Vue or Angular. The idea of going back to writing mark-up separate from the CSS and JS I'm working on feels archaic (and to be fair it is).
&gt;The main changes will touch the reactivity system, which will get a complete overhaul, using ES2015 Proxies That will be amazing.
could this be used for when a Gulp task fails?
It's very much integrated into Jest. Easily doable on Gulp though.
I notice the "A" and "B" can only be followed by the end or start nodes of each road segment. I worked on routing using postgresql and qgis to make drive-time isochrones and came upon the same problem. This brought on another effort because going through and unsplitting road segments in the network allowed higher accuracy for in real-time positions(for example addresses instead of road segments would be use). I did this technique only for cases where road segments were significantly large. To manually do this for entire city's network I imagine would be close to hell. This is where I would go next in order to improve the accuracy of your project. 
And proxies are natively supported by all evergreen browsers
It is discrimination, but that doesn't matter to those people. In their mind the end justifies the means. So discrimination is okay if it advances their goal of diversity. Personally, I'd rather have less discrimination and let the diversity sort itself out, but I guess saying that makes me a racist white dude.
Sounded good, but I still get "index.html:209 Failed to execute 'requestFullscreen' on 'Element': API can only be initiated by a user gesture.", which is a webkit restriction.
[Blame the patriarchy.](https://ibb.co/cmS5m5)
Umm.. no IE support? I hate IE too, and I like anything that slims down a framework.. but as someone that builds B2B apps, there will always be a certain proportion of clients with overzealous Microsoft security policies in place that limit them to IE only on their work machines.
&gt; So discrimination is okay if it advances their goal of diversity well, that sound like fascism actually
This person seems delusional so why are we giving them attention?
Because they're the CEO of the company responsible for a (somewhat) important part of the JavaScript ecosystem?
Hi /u/robotrocket47, For javascript help, please visit /r/LearnJavascript. Thank you!
Guessing they're dropping "IE" (IE 11 and down) but supporting Edge, which I think started at what would have been IE 12? If you need "IE" support, you're probably stuck with Vue 2.x, what you're probably using now if you're writing Vue apps.
&gt; ..and let the diversity sort itself out, lol k 
A lot of projects are starting to support only evergreen browsers for latest code, and older IE requires transpiling back to ES5 if you need that support. It's just too much of a headache to limit yourself just for IE at this point... especially with Edge being available. I assume that's the case here too, but don't know for sure. 
Few of those solutions already exists natively (array_merge =&gt; concat, array_map =&gt; map, array_reject =&gt; filter, array_take =&gt; slice)
What is the benefit of using proxies in this situation/why is it significant? Noob here who is genuinely curious 
&gt; well, that sound like fascism actually What /u/arendjr said is basically a trivia puzzle: &gt; It is ~~discrimination~~ fascism, but that doesn't matter to those people. In their mind the end justifies the means. So ~~discrimination~~ fascism is okay if it advances their goal of ~~diversity~~ moral superiority. Personally, I'd rather have less ~~discrimination~~ fascism and let the diversity sort itself out, but I guess saying that makes me a ~~racist white~~ socially inferior dude. The only winning move is not to play.
Query: I've got a conference I'm putting on. I've had 100 white dudes apply to be speakers. I'd like to increase diversity of presenters, and I'd like to tweet out to my followers a call to get some non-white dudes. How might I go about it? How is this discrimination?
I think the concern is that Proxies aren't something you can fully polyfill, and afaik the reason for the overhaul is precisely to get access to those unpolyfillable features (namely, the object property creation event). Personally, I wouldn't be *that* comfortable dropping IE11 support for my OSS things just yet. At my job, for example, we still saw 600k/mo IE users when we checked our analytics a few weeks ago.
I like the idea. I'm always a fan of seeing vanilla JS stuff on this subreddit, but there are some pretty major issues here. Can you correct these? You're teaching some fairly bad habits here. # array_unique In the keyify function: `Object.keys` is preferred over `for...in` loops, especially without a `hasOwnProperty` check. `for...in` should not be used on arrays, prefer `for...of`, or `Array.prototype.forEach`. Avoid unnecessary string concatenation of `~^%` characters. # array_merge Not sure of the use case for a destructive merge. I normally stick to a pretty functional style, so `Array.prototype.concat` is just fine. # array_chunk `if(!arr[i])` will fail on empty string, null, undefined, NaN, and zero. This is pretty broken. I was going to keep going here but I don't really have time to go through and point out everything. These are just the issues I have with the first 3, I've skimmed the rest and they seem to suffer from similar issues. I'd recommend doing some unit tests. A lot of these functions will fail in quite a lot of cases, and many of them could be drastically improved with regard to performance, clarity, or simple best practice. I'd also recommend reading through the lodash and ramdajs source, there are a lot of gems in there that will help you if you want to roll your own utils like this.
Well, if there was no any barrier for non-white-dudes in initial call (it was welcoming for everyone) and only white dudes responded...
I think constantly backfilling old browsers is a losing game that is finally being properly accounted for.
It's not discrimination, it is entirely normal to want a wider range of voices at a conference and there's nothing discriminatory about making it clear that you're looking for a wider array of applicants before you shortlist them. Honestly, just ignore those that childishly cry discrimination over something like this, *especially* those that call asking for more applicants fascism.
Gee, five seconds of Googling (a skill I would *assume* any Javascript developer had mastered) came up with [this](https://www.assertjs.com/): &gt; Want to speak about testing in the JavaScript ecosystem? We are looking for amazing talks for our single-track conference. Submit your talk today to get on the roster! But I get it. As a sad white man, it's a lot easier to get one's snowflake underpants in a bunch and run to reddit and chicken little all over the place.
So, general invite is not enough for some guys and they need "a special invitation"?
As the author of the Tweet pointed out, there's no need to worry, there will be white dudes speaking. It happens to be very difficult when you open a request for speakers to get non-white, non-dudes applying, for a whole host of reasons (that have been covered in excruciating detail elsewhere) and after many, many years of tech conferences, this has yet to magically sort itself out. Directly calling for diverse applicants sometimes works and doesn't mean that the short-listing will be based on anything but technical merit. As should also be apparent from the tweets, the author is not an organizer of the conference, they're just a potential speaker.
This is, by definition, discrimination. 
It plays a soundfile why does it need to be integrated into anything for example what is wrong with: fuck() 
This. You can't beat the game, just stay out of it.
There are literally hundreds of thousands of words written on the subject of diversity in tech conferences and the many reasons that conferences have issues getting diverse applicants, I'm not going to bother rehashing them with less equolence for you. I'm not sure if you noticed, but the person who's tweet you linked to isn't even an organizer of the conference in question. They have no power to discriminate over who talks, and even if they were, asking for diverse applicants is in no way discrimination unless they are automatically shortlisted.
Well I'd rather have it running as a custom reporter ; meaning I don't touch whatever you're doing with your tests and just check the exit. Rather than doing some `afterAll` or whatever the hook for that is on Jest. If it breaks, it does not break your tests. But I definitely see your point and could totally expose a `fuck` function just to play the sound. What I like is that it's easy to plug and follows the Jest way of doing things: through the configuration
The tweet: &gt; If you are not a white dude and have things to say about JavaScript testing, please submit a talk to Assert(js) What I just pulled out my nose: &gt; Our speaker-base seems a bit homogeneous. Add some diversity to *conference* and apply now! *link* It can't be difficult to be friendly, inviting and appreciative if someone like me can write that up in less than a minute.
Let's break down your question then. &gt; discrimination: the unjust or prejudicial treatment of different categories of people or things &gt; unjust: not based on or behaving according to what is morally right and fair. &gt; prejudicial: harmful to someone or something; detrimental What definitions do you feel actually applies to what he said? &gt; If you are not a white dude and have things to say about JavaScript testing, please submit a talk to Assert(js) My view based on that is, no it absolutely is not. He doesn't say "I am the conference organizer and I will only accept talks from non-white dudes". He, as an individual, wants to encourage non-white-dudes to submit conference talks, and that is absolutely his prerogative. What harm to you came is being done by attempting to encourage more people to contribute talk proposals? Have you been to a conference? It's 99% white dudes. The whole point of this tweet is to promote other people because the white-dude portion that he ignored _already_ submits conference talks. He's not telling them _not_ to submit. We are engineers, our first thought when we see a problem is to try to figure out a way to solve it. Is it really that surprising that people in the community are vocal about it? You're vocal for the same reason, you just have the opposite opinion. You can't drag people down for being vocal too. Given that, when I hear posts like yours, the motivation behind it seems like it has to be that you don't think it's a problem, though feel free to correct me. If that is the case, a few possible stances come to mind: * You think that white dudes are inherently more deserving of their positions in the community. * You think that white dudes are already here and we should just let things work themselves out without talking about. * You think it's all just annoying and want things to stay how they are. I'm not trying to make assumptions about you personally, and I can't say if any of those apply to you specifically, but you haven't provided any information yet on why you feel it is discrimination. Your comment seems to imply that merely encouraging people to apply to give talks somehow excludes other groups, which I can't quite figure out. Given those few points, the first I'd say actually _is_ discrimination. If you feel that way, it doesn't seem realistic to expect you to be non-discriminatory in your hiring practices, or in your day-to-day business environment. The second I'd say goes against everything we are as engineers. What engineer _wants_ to sit idly by and not talk about something they see as a problem? For the third, comfort is easy, but your personal comfort does not give you the right to discourage others from wanting what you have. It's not a zero-sum game. Getting more people involved with the community does not inherently remove your ability to participate. If you want to have a conversation, how about we do that instead?
If someone wants to encourage minorities to participate in a particular event, then I have no problem with that. But that's not what this guy did. What he should have said was: &gt; "If you're a [insert desired minority group(s) here], be sure to submit your talk proposals to X conf." Instead, he said: &gt; "If you're not a white male, be sure to submit your tech talks to X conf." The implication is that if you're a white male, you are not wanted. *That's* what people are frustrated about. If you want to proactively invite specific demographics to an event, then by all means - do _that_. But don't do it by proactively telling others _not to go_, then claim to be a flag-bearer for inclusivity.
Noob here too, don't know about proxies but the next paragraph says that &gt;That means getting rid of all quirks and limitations of the current system, for example regarding reactive updates to arrays by key or adding new properties. which is absolutely great and I'm guessing only made possible by proxies.
&gt; "If you're a [insert desired minority group(s) here], be sure to submit your talk proposals to X conf." What is the desired minority? **All of them.** As in, anybody who is not a white dude. He literally asked for what you wanted. Can you phrase it better, if the desired minority is *anybody who is either female or non-Caucasian*?
Pretty much any way *other* than the one he chose. For instance: &gt; "If you're an under-represented minority in the tech community, be sure to submit your proposals to X conf." The fact that he chose to invite specific people based on _exclusionary_ language speaks volumes about where his mind is at. Also - do you really have a desire for _all_ minorities to attend this conference? What about Nazis or Flat-Earthers? I'm sure they would have some interesting contributions. If you're going to claim that by "minorities," you're referring solely to a person's racial or gender identification, then may I ask by what standard you're limiting the scope in that manner?
instead of saying what he didn't want, he could have simply said what he did want. That wouldn't have offended anyone (few, if any)....having tact is a quality of good communication and is an essential skill
I dunno. My guess is that the plan is to create a deprecation path for Vue.set/Vue.delete, and the trade-off is that it improves developer experience (they won't need to understand why such things exist when everything else that is reactivity-related "just works"), but at the cost of making Vue@latest a flat-out unfeasible framework choice for many people due to project requirements that are beyond their control. I don't know the perf numbers for Proxies vs getter/setters, so it's hard to say if the revamp will improve things on that front. Would be interesting to see if they can pull reactivity out of core, similar to how vuex is its own module. Then people could still buy into vue+vuex and basically follow the architecture that React+Redux folks use, without necessarily ever needing `compute`.
The algorithm is known, but probably less than it deserves to be known. I think you pointed out the reason why it's not very well-known (bsketball). It was created by Wim Pijls and Henk Post in 2009. Here is a paper describing it: https://repub.eur.nl/pub/16100/ei2009-10.pdf
You are very welcome! 
Thanks for the link!
I still don't get why "Everybody! Submit your talk props..." is not working
Interesting! This is what Google Maps suggest: https://www.google.com/maps/dir/52.4288552,4.872062/52.4099466,4.890144/@52.4131114,4.8921518,14.41z/data=!4m2!4m1!3e0 They have straighter lines. Very likely they consider speed limits (I don't), and optimize for other subtle things which make route slightly longer but more pleasant (like reducing number of turns). What do you think?
Agreed.
You're trying to enter fullscreen via userland, and such restriction indeed exists. But you can try to enter fullscreen via `new BrowserWindow({fullscreen:true})`. Check out docs at https://electron.atom.io/docs/api/browser-window/
Yes. The googs definitely consider things like number of turns, direction of turns (left turns take more time at unregulated intersections ) , traffic. I want to say that what you’ve done is super fucking cool. I’m a geography and gis guy so this stuff floats my boat. The detail as to what you did is really great. My money is on someone like mapbox “borrowing” it. 
In France, we call this "discrimination positive".
Basically, the way Vue works is that you define a state shape (say, `data: {foo: 0}`), and under the hood, Vue creates an object with that shape, but with getter/setters for all properties (e.g. `{get foo() {/*...*/}, set foo(v) {/*...*/}}` in our example - and yes, that's [valid js](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get)). So when you do `this.foo = 1`, and you have a `compute` function, under the hood, Vue can efficiently compute the changes because it runs the code on the setter, rather than computing every time when you read `this.foo` or the computed value. The problem is that getter/setters only take you so far. You can't, for example, add an arbitrary property to the reactive object. Same for arrays. Vue can monkeypatch `.push`, `.pop`, etc so that those methods can run Vue's reactivity code, but Vue can't know if you do `someArray[i] = foo`. This is the reason Vue has Vue.set and Vue.delete. Proxies would allow Vue to run its efficient compute algorithm on all types of object/array mutations without the need for `Vue.set`/`Vue.delete`, so you could even do `someArray[i] = foo` and `compute` would still work.
Vue would convert state into objects whose properties are getters/setters, thereby it could detect changes. That strategy had some problems as some operations couldn't be accounted for, that's what these $set/$get functions are there for concerning objects and arrays. Proxies make real observable data-structures possible, so no edge cases any longer. Downside of course is that you can't polyfill it. Microsoft will abandon IE11 sooner or later, that'll do it.
At my job we post a gif of Cersei being paraded through King's Landing when code pushed to a PR breaks the build, with the caption 'SHAME'.
If it's discrimination they're doing an awful job of it. Almost all of their currently booked presenters are white dudes.
That doesn't seem like a huge gain to me. I guess it will improve code quality but it doesn't seem to add any new functionality
 As a Canadian, I am glad to see some progress being made in the US.
By which definition exactly?
But there are more barriers, that is exactly the reason tweet things like this.
Right, that'd be awesome, but the fact that conferences are mostly white dudes makes it clear that it isn't working. 
Currently in order to set up the reactivity system, Vue has to walk all of your objects (recursively) and modify your objects so that their properties are getters and setters (to allow it to detect the change). Depending on how much data you have, this can add significant up front cost. Further, because of the dynamic nature of arrays, Vue cannot do this walking/modifying when you have an array in your data. To get around this, every time you access an array (for instance you write `myarray` in a `v-for`), it has to iterate the entire array in case something has changed. I recently ran into real problems with this - [the issue](https://github.com/vuejs/vue/issues/6284) contains some more info. Proxies remove both of these problems, as well as make it so Vue (likely) won't need to modify your data at all. This does come at the cost of dropping IE11 support, however I believe this is why they say they will be continuing to maintain feature parity and support Vue 2/3 simultaneously. Vue 2 is basically just an ES6 Proxy polyfill (for this specific use case), and for people that don't need to support IE11 it comes at some real cost.
Interesting, an article about essential vanilla js functions that everyone needs. I makes me almost wish...that...maybe someone had written something like this already and packaged a bunch of these up into a single usable library. Maybe gone as far as to name it something clever, perhaps after a piece of punctuation...like say lodash, or underscore or underdash. Something like that. 
It is bizarre that the number of white dudes doing talks is proportional to the number of white dudes in the industry. Oh. Wait. No it's not. What I don't get is, why doesn't he spend more time trying to diversify the industry by helping non-white non-dudes get a headstart instead of bitching about the existing demographic. 
Same, I work on a product where we still encounter IE quite a bit. It sucks, but it is what it is and we don't have control over it. Looks like we'll be stuck on Vue 2 for a while. But at least they are saying Vue 2 will have feature parity with 3 for a long time. 
&gt; new BrowserWindow({fullscreen:true}) Thanks, but unfortunately that isn't really what I am trying to make fullscreen. Go to youtube, watch a video and press the full screen button [] on the bottom right. That is what I am trying to do with the video player on the web page. I talked to the developers last night and they confirmed this is a webkit security issue (makes perfect sense for a browser, just no a stand alone app) and suggested I switch to the native SDK, but I am still holding out hope for an alternative HTML container.
You can achieve the exact same result while using better language that won't upset people. "Are you a minority in field? Come talk about JavaScript in this conference" Comes across way better than "We don't want you here if you are white" But this guy likely knows that and just wanted to drum up drama with an edgy PR stunt.
&gt; A* doesn't care about the layout of your graph. It's almost exactly the same algorithm as Dijkstra, with the difference being an added heuristic to help check better paths first. It's up to you provide a permissible heuristic for estimating path costs. A* cares that you can provide an admissible heuristic, which can just be Euclidean distance with normal physics. Wormholes would cause Euclidean distance to over-estimate the cost of the solution, making it non-admissible. Edit: &gt; You've got that backwards. SSSP and SDSP are the same, just reverse the edges.
everything else =&gt; reduce I think anyone coming from php would be better off learning the proper javascript methods rather than trying to duplicate php methods 
That's not an upgrade, that's a port
So don't use such a simple heuristic in that case? If you have wormholes, label those edges as such and treat them differently.
&gt; "A* greedy" converged the fastest, however, as name implies the found path is not necessary globally optimal. This is an odd claim. A* should always be optimal with an admissible heuristic.
/r/learnjavascript
For simple arrays you can dedupe with: const arrayUnique = arr =&gt; [...new Set(arr)];
I like the idea. Mind if I integrate it as an option? Just the sound though, don't want to take too much space.
As for `keyify`, why not just use `JSON.stringify`? ;-) However I would say that it makes sense to only account for unique references here, so use a regular strict equality check. Otherwise if you made changes to one object afterwards, you wouldn't know if it was the object that made it to the unique array or the one that got filtered out... I mean, it has a reason that objects are only identical by reference.
Great, now I can skip the cursing step and go right to biting my arm in impotent rage.
Optimization of one's time is in the details
Article should probably mention that even if you aren't going to use the cli you can still generate a project with it then eject the Web pack config to provide a solid base configuration that you can then customize. It's a lot easier than trying to develop a Web pack configuration from scratch.
Hey, I'm not worried :) I'm living a happy life with my Chinese wife and work at a company with great international colleagues from all over the world. I love diversity and I don't like discrimination. That's how it should be, or so I was taught. What itches me is when people become fanatics and start to exclude people because they think their higher goal (in this case diversity) is more important than, well, other people. Note I'm not saying the organizers of the event are such fanatics. I'm merely talking about this single tweet. If it had read "If you are not black, be sure to submit your tech talks." there wouldn't be any discussion; it would be obviously racist and discriminatory. But we have to apply the same rule to everyone so that means this tweet is racist and discriminatory too. Just because it was made "in the name of diversity" doesn't make it any less so. Now if they were to put their effort towards more positive ways to increase diversity, I'd be all for it. School programs that target girls to get into programming? Great! Reaching out to minority communities? Sure! Writing tweets using exclutionary language... uhm, nope. Even if no real harm is done (at least I'm not really offended, just a bit annoyed :)), it's discriminatory and tactless at best. Now for a little story time... At my previous job we at some point hired a girl for a developer position (don't worry, she wasn't the only female developer, just the only subject of this story). Me and a colleague of mine were her interviewers before we made her the offer. Unfortunately, she wasn't very good at the job. But, because she started as an intern this wasn't revealed for quite a while so she managed to stay around for 2 years or so. I wasn't her manager or anything, so I wasn't too involved with her actual work. However, during that time I had befriended her and I noticed the longer she worked there the more frustrated she became to the point she was actually in a depression near the end. As a friend I tried to help her and we had countless conversations but it seemed impossible to get to the root of the issue. Eventually it came out that she felt we had treated her in a sexist way by making her a job offer. She was failing at the job and she felt she had screwed up the initial interview as well, so she had come to the conclusion that she wasn't judged on her merits but was hired because she was a girl (and a beautiful one, at that) instead. Of course this wasn't true, but she had completely convinced herself of it and because of it she felt an increasing amount of pressure as she tried to prove herself on her merits but couldn't. It put me in the awkward position of confessing to her that I had actually advised against hiring her but that I had let my colleague (who I don't believe had any sexist motivations either) convince me to give her a chance. This was actually a great relief to her, but she left soon after and we lost contact after that. The moral of this story? Some people are trying to enforce diversity as if it is somehow more important than merits. But ask yourself how you would feel if you're a minority and you're given a slot at a conference that might not go well with the audience. Will you start to doubt yourself, because you might have been given the slot not on your merits, but because you're a minority? If there really is no discrimination this shouldn't be an issue, but this so-called "positive" discrimination has unintended consequences that are easily overlooked. As I said, I love diversity, but I don't believe in enforcing it. And I fear the people advocating it the loudest might actually be harming those very minorities unintentionally.
A closure is where a child function declared inside of another parent function still has access to the scope of the parent function even if the child function gets returned out of the parent function.
Wrong subreddit. Go check out /r/learnjava
What is you case, precisely? Are you trying to make the whole window fullscreen or just a DOM element? In electron if you will click on the bottom-right icon, the full screen succeed, actually, because it was "initiated by user request", just like in any other browser. The limitation is, when you try to make some element full screen without user action (click, keypress, touch etc...). You can avoid this limitation by setting second parameter to `true` in window.webContents.executeJavaScript window.webContents.executeJavaScript(` document.querySelector("#movie_player").webkitRequestFullscreen(); `, true) check out [gist](https://gist.github.com/Reeywhaar/1cf94ac403750889f9575cb60d97b6c7) and [documentation](https://github.com/electron/electron/blob/master/docs/api/web-contents.md#contentsexecutejavascriptcode-usergesture-callback)
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [electron/electron/.../**web-contents.md#contentsexecutejavascriptcode-usergesture-callback** (master → ec58703)](https://github.com/electron/electron/blob/ec587032b200a0107b75836b804d6f96a3e371e5/docs/api/web-contents.md#contentsexecutejavascriptcode-usergesture-callback) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dndbq2y.)^.
A) Java =/= Javascript B) Knowing how math works in general is better than knowing a specific type of math. C) Discrete Mathematics, specifically Logic and how proofs work. D) If you want to get into programming, you don't need a huge math background! Just grab a book and you can start today! There's free books online, or video tutorials if that's more to your liking. Then there's courses, sometimes free sometimes not, on sites such as Khan Academy (I make no claims if these are good or not, haven't tried them, just know they exist).
It's all useful ... I recommend trying to use new concepts in your daily life, and moving from one math topic to another. There's no one concept that is "the best."
If you're not going to get the metaphors or examples, you're not going to understand the explanation. https://imgur.com/a/8kpcW This is honestly as simple as an explanation as you're going to get I don't have any annotation tools so I can't use those to draw but I'll explain. You see how blah is returning an anonymous function? That's ALL it's returning. It's not returning any values. When you end up calling the function that returns, even though you JUST returned the function and no other value, it somehow is able to return the value of ok. When you put a debugger statement in there (inside of chrome) it sees 3 scopes. Global, local, and CLOSURE. The trick with closure, is any function you return still has access to any values it was using, even though you didn't return those values directly. https://imgur.com/a/NxTIF You see that because the function isn't using any of the values it did anymore, that there is no "Closure" thing in the inspector anymore? That's the gist. You only are returning and have reference to a function. But that function still has reference to variables and stuff around it that it shouldn't have. Think of it like this. Let's say I break off the faucet off my kitchen sink, bring it with me, then in the middle of the street turn it on, and water just comes out as if it's still connected to the sink. That would be pretty weird right? I ONLY have the faucet. How does it still have connection to a sink? That would be impossible in the physical world but it's possible in the digital world. functions keep certain variables in memory around, so if you call the function later on, you can still access those variables. What will help you get closure if you don't get the explanations, is throw closure code examples, put debugger statements and see when the word closure pops up in the inspector vs when it doesn't. This will be annoying but if you take 10 minutes to do this, you'll finally get it easily. 
As a developer who is about to migrate an ecommerce platform to a SPA, this is basically it. Also, SPAs are massively complex when your business logic and requirements are varied.
Variables are enclosed by statements. `var` declared variables are enclosed in the first function above them (or the global environment if there is no function). `let` and `const` declared variables are enclosed within the first code block above them, such as an if statement, for loop, function declaration, etc. A closure is a collection of all the variables available to a certain block of code. Note that closures are only created when their containing blocks are created. You cannot call a function and magically it has a new closure. It retains its original environment. Edit: Fixed some really bad wording on my part that made the explanation wrong.
Yeah sorry, saying Java instead of JS isn't branded in my subconscious just yet. 
ISWYDT
I doubt Trigonometry will be very useful in coding though.
Not Java Script either. JavaScript. One connected word. The confusion was a purposeful marketing trick back when JavaScript was released. It was meant to confuse people into thinking it was associated with Java which was the leading technology at the time.
I understand (well, partially) the scope of where things are, I just don't know what part of any of this is a closure, and what it means. I understand your metaphor, I understand why the code works the way it does, but I have no idea what closure means.
I imagine you're not going to get a lot of info if you're googling for info about "closures".. try looking for info about "IIFEs" or "scope" or functions in general. in JS **all functions are closures**.
If you want to get better at programming, then write and read code and read books about programming.
I happen to be doing it right now. Trying to do little projects like, making a chessboard work. Got any sources where one can read code though? 
**closure means variables kept around even though they're technically not available anymore.** That's my best shot at it. Without the engine creating a closure for you, console.log in my example would output undefined. Edit: the important thing is to not worry about how the engine does this. I think that may be what is partially confusing you. Every function keeps a reference to what it has in scope at the time it was defined. So even though you're only returning an anonymous function, it has reference to the variable ok due to black javascript magic. Refer to my first sentence for the simple explanation for this.
A closure is just the combination of an anonymous function and variables that were defined outside that anonymous function.
I actually understand closures but this comment confuses the hell out of me. &gt; You cannot call a function and magically it has a new closure. Uuh, yea, you can. ALL functions in Javascript are closures. Automatically.
Well, for me it mostly happens in my day-to-day of using third party software and wondering wtf is going on, so I have to look at the source -- admittedly that is rather rare. I would suggest picking some piece of software that you use, and just going through the modules/files until you find one that's of interest to you and then read it. If you're still having trouble finding something to read, I heard [jQuery](https://github.com/jquery/jquery/tree/master/src) is supposed to be very good code, but I doubt it's very "modern". You could also just search [github](https://github.com/) for stuff that interests you.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [jquery/jquery/.../**src** (master → 94ddf62)](https://github.com/jquery/jquery/tree/94ddf620224d6555aaa7eaac20c583b15c6f50d8/src) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dnddaae.)^.
Thats where your wrong, kiddo. Trig is one of the most fascinating parts of math. Trigonometry is always important when it comes to animations and computational geometry. Have a look at threejs, it's incredible what's possible with a few lines of code and a browser these days.
Call vs Define Edit: Though this did point out an error in my explaination.
 class JavaScriptFunction { JavaScriptFunction(//closures passed in at function creation time) { //save references to closures here in constructor } public returnType Invoke(//function arguments passed in at call time) { //Run the function code using passed in arguments and closures from the constructor //Function can be invoked multiple times using different arguments, but uses the same closure values each time } } Sorry it's a metaphor.
Thanks! That got it with a few slight modifications. Also had to add "add.setMenu(null). 
That would work too. I wasn't really commenting on the method. I wouldn't write the function anything like how it's written. Just pointing out the `for...in` issue.
got it, my mistake.. still kind of confusing when you think about like that though. 
you could also do: const uniq = a =&gt; a.filter((x, i, s) =&gt; s.indexOf(x) === i); May be more performance depending on implementation. 
correlation is not causation
Author's merge isn't a concatenation. It's modifying the input array. I asked why, as I'm not sure of the use case for this. But they aren't strictly equivalent. Obviously native concat is preferred though. 
Would you mind explaining example 5 on here? https://stackoverflow.com/questions/111102/how-do-javascript-closures-work/17200991#17200991 I don't get why this results in undefined. I've traced the code and looked at all the answers here and I'm not understanding why it's doing that? I can fix the code so it doesn't, but I appear to be having some issues with scope since list[i] is undefined here.
That helps a bit. I think it may be a few months before I really am able to wrap my head around this one. I may just continue on at this point instead of stagnating where I'm at.
Although everybody hates IE, but no IE support will be a big no no for many people.
Not constantly, IMO the right moment to drop IE11 is when MS stops supporting it.
Mhh, that's a good point indeed.
At the moment I'm doing jQuery. Just trying to write simple click functions. Though I'm trying to learn more about JS, so I can write in algorithms. At the moment I'm having a lot of functions that show hidden html/css elements. var fadeInDelay = 1000 $(document).ready(function(){ console.log ("addaw"); $(".button1").click(function(){ $(".BoxOne").hide(); $(".BoxTwo").fadeIn(fadeInDelay); //Page two starts here// }); $("#Bone").click(function(){ $(".BoxTwo").hide(); $(".BoxOne").fadeIn(fadeInDelay); }); $("#Bthree").click(function(){ $(".BoxTwo").hide(); $(".BoxThree").fadeIn(fadeInDelay); }); $("#Btwo").click(function(){ $(".BoxTwo").hide(); $(".BoxThree").fadeIn(fadeInDelay); //Page Three starts here }); $("#B1").click(function(){ $(".BoxThree").hide(); $(".BoxTwo").fadeIn(fadeInDelay); }); $("#B2").click(function(){ $(".BoxThree").hide(); $(".BoxFour").fadeIn(fadeInDelay); }); $("#B3").click(function(){ $(".BoxThree").hide(); $(".BoxFour").fadeIn(fadeInDelay); }); }); I know it could be a lot shorter since it repeats itself.
Usage of objects as maps isn't uncommon, like a map of user IDs to user objects for example. In Vue 2, because of reactivity limitations, you'd need to use Vue.set to work. Vue.set(this.users, userID, user) Using proxies, that's no longer needed, and you can set it like normal, having Vue react to it just fine. this.users[userID] = user
&gt; It's up to you provide a permissible heuristic for estimating path costs. That's what I meant by "normal physical rules". I didn't want to use A* jargon. If your world is weird, you may not be able to devise a good admissible heuristic in which case A* may not return the true shortest path. &gt; You've got that backwards. Dijkstra's algorithm solves the single-source shortest path problem. (Not all graphs have bidirectional edges.) Oops, you're correct. It gives you the shortest path *from* a given node *to* all other nodes.
You are totally right. If you run your search in one direction - you are guaranteed to find the shortest path. `A* greedy` is my "failed" attempt at bi-directional A* search, where we perform searches from both ends. When two searches meet - I stop the process. Problem with that, is the meeting point is not necessary on the globally optimal solution. `NBA*` is also bi-directional path finder, but unlike my initial attempt, it always ends with the shortest path. 
well ill assume you understand how the for loop works - mainly that by the end of the loop `I` will be equal to `list.length`, and there is no `list[list.length]` index. the highest index in any array is always it's length - 1. anyway, since the functions defined in the array are closures (and the `i` is defined outside of the closure) it means that the reference to `i` is the exact same `i` used in the loop. by the time that function is actually called, `i` already equals `list.length`. In order to get it to behave as expected you need to put `i` in its own closure, like this... for(var i=0; i&lt;list.length; i++) (function(i){ // define functions here })(i) wrote this on a phone so forgive any typos..
How will i = list.length? The loop is set to stop at i&lt;list.length, so it's final value should be 2, not 3. var list = [1, 2, 3] for(var i=0; i&lt;list.length; i++) { console.log(i); } This prints out 0, 1, 2, but your saying in the code in the link it goes to 3? Why? 
We will develop 2 and 3 in parellel, with feature parity. Vue 3 will *not* introduce* new features that Vue 2 will not get. We just don't want to keep the advantages of a proxy-based reactivity-system from users that don't have to respect IE anymore.
Misses the best part about destructuring = keyword arguments
if you put you console logs in a function and then call them after the loop is finished they will all say 3. the middle part of the for loop (i&lt;list.length) tells the loop to keep looping as long as that condition is true. when the loop is finished that condition will no longer be true. the middle section of the for loop is the same thing you might put in a while loop. maybe converting the for to while will make it easier to grasp.. var i=0; while(i&lt;list.length){ // do stuff i++; }
You are just being argumentative for the sake of it
Edit: Nevermind, I think I get it. buildList is called once, and since the function is returned as a value, it's pulling the entire function after it all processes, thus it's getting i=3, and item2. Thank you for your help on all this, really do appreciate it! I understand that i will get to 3 to complete the loop, but the last time that result.push() is called, i is 2, so it's not making sense to me how it ends up as 3 in the actual result[] array. 
well return input_array = input_array.concat(other_array); also modifies the input array... using a for loop is preferred when the two arrays are massive (millions of entries) and you don't want to create a temporary third array
I'm in traffic right now.. hard to write code samples on my phone. when I get home I'll write up a better explanation for you.
A closure is a function plus a connection to the variables that existed at its birth place.
Consider embedded programming as well, if you're into that. Working with waves (analog and digital signals) often requires analysis of these signals, which requires trig.
it's not that hard honestly. If you were sitting in front of me, it would be easy to explain. It's actually a super super simple concept, mostly people get caught up with technical explanations and all this bullshit. Like I said, stop worry about trying to understand it. You see that small code example I showed you in my image? Write that code example out, and play with it. I can almost guarantee that you don't completely understand lexical scope. Understand that FIRST. Once you understand that, it's literally a simple simple simple concept. Child scopes have access to everything their parent scopes do. When you use some function from a child scope, it still has access to everything in that parent scope, even if the function is executed outside where it was originally. It's that fucking simple. If you were right in front of me, this would take all of 60 seconds to explain. Lastly, find examples on the web where they are using closure to accomplish something, then try to accomplish the same thing. Try the first time either with or without closures, whichever one piques your interest, then try the other one. To understand a lot of this stuff, you MUST play with it, you must interact with it. A lot of the book shit, if you just read and read, it won't do any good. Many years later I'm reading these books and finally understanding what they're talking about.
Ok, so that is good. It's not the best, but it likely gets the job done. I think maybe you should look into two resources that will prove both education and more fun that that type of programming. http://eloquentjavascript.net/ [javascript.info](http://javascript.info) Another thing I suggest is to read through and maybe attempt some exercises from [SICP](https://mitpress.mit.edu/sicp/). You don't have to read everything or try every question, but it will help you to gain a better appreciation of the art/science behind programming. 
&gt; Say my catalog changes daily. I can render every product page and cache it. You can do with with an SPA, too. A lot of people pre-render React / Vue / Angular 2 applications and put the HTML in a Redis cache. It'd be a trivial task to do this on a greenfield app, but really hard on an existing project that's not 100% written in (fill in your framework).
It surprises me when big companies say "we heard you."
"we heard you, other big company (Automattic/WordPress)"
I believe we may be coddling some of our developers a little because this would definitely be a fireable offense if I wired this up. I've had a talking to before about how Im supposed to address obvious, and recurring mistakes in a PR. 
Smart move.
https://imgur.com/a/MYAXQ Here you go. I created an image. As you look at this image, I want you to do two things: 1. There is a difference between the var = foo; and console.log(foo). One is defining the variable, one is logging it. 2. Forget about Javascript. Just try to understand the concept I'm trying to portray in the image. Completely forget about anything you know about Javascript... just tell me if you understand the concept I'm trying to get across in this image.
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/eg0JBzE.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dndixgw) 
Could you clarify? My comment is essentially &gt; saying "everyone submit talks" has not resulted in more proposals by non-white-dudes. What specifically are you saying is correlation rather than causation? Let's step back. There is clear evidence that the current approach to just saying "everyone submit talks" does not mean that a everyone actually submits talks. I think you'll agree? As you've said, the general call has already gone out, and clearly white dudes are hearing it and thinking "yes I should submit proposals". The goal of comments and tweets like this is to encourage groups that would not otherwise submit proposals to do so. Rather than try to argue one way or the other, the question is, do you believe that goal is worthwhile? It seems like you do not. Arguing about approaches to the problem doesn't seem worthwhile if we don't agree what the problem is in the first place. If you don't see it as a problem, then my question to you would be, what do you feel is to be lost by making conferences more diverse? 
This doesn't modify the input array, it reassigns the variable `input_array` with the result of `input_array.concat(other_array)`. Any references elsewhere in your code which use the original value of `input_array` prior to this assignment would still behave as expected. I have a suspicion that using a single concat operation would be faster than doing millions of push operations. Modifying the structure of an object (Array in this case) is one of the more expensive operations in JS engines as I understand it. In any case, I think if you're working with millions of entries, you may want to use a difference language. JS just isn't that fast or efficient with sets that big. I'd need to see some benchmarks though. 
http://www.dictionary.com/browse/discriminate &gt; [discriminate *verb*] - To make a distinction in favor of, or against, a person or thing on the basis of the group, class, or category to which the person or thing belongs rather than according to actual merit.
I put your image into code: function blackBox() { var orangeLine = 1; function blueBox() { console.log(orangeLine); } return blueBox; } var functionHolder = blackBox(); functionHolder(); It logged the 1 to the console successfully. So what's the point of all that? Is it to just give access to var orangeLine? But yes, I do get the image.
Although they said *We were right, but you couldn't understand our rightness.*
That's a good step in the right direction. FB realized that licensing React with BSD+ patent is a really hostile move.
I don't see where he's "just being argumentative". He's trying to make a point that judging people by qualities they haven't chosen (race, gender) is not fair to anyone. 
This is where I'm a huge fan of Ruby's `!` operator. Would be nice if Javascript had something similar built in.
Do people not realise that losing an explicit patent grant actually puts you in a worse spot? That this is actually bad news? Now, if FB wants to sue you over React patent infringement, they can do so at any time. Dumbest situation ever. Facebook has been forced to respond based in the community’s gross misunderstanding of the original license.
"_this_ community"
[Excellent /s](https://i.imgflip.com/1wd3zp.jpg) 
The blog post doesnt say why React till now had to have a restrictive license? Did they remove the parts that required it in the rewrite? I hope this is the end of the weekly 'don't use React because its dangerous' blog posts on medium.
Ditto.
&gt; say why React till now had to have a restrictive license? It was not a restrictive license, the license part was not the problem. It was always a permisse BSD/MIT style license. Then it came with a defensive patent protection clause which first gave you a promise not to sue you for patents in react and threatened to revoke that in case you sue "facebook or their associates". It was a patent issue, not a licensing issue. Their argument was the existence of patent trolls. Many users felt threatened by what they felt was an overly wide exception to the patent thing. And then there was lot of FUD.
Thanks WordPress.
So the parts of React which are patented are still present? Is this move purely a legal thing because FB saw a lot of companies abandoning React and a lot of FUD in the community? 
Like dat?
This was just a large-scale example of "vote with your wallet" (WordPress abandoning React due to the patent clause). Imagine if big players (besides the EFF) left the W3C due to the DRM fiasco. That would be sort of analogous to this situation.
React Native is still under BSD + patents...two steps forward, one step back
&gt; Now, if FB wants to sue you over React patent infringement, they can do so at any time. Call me when Facebook starts suing people over "React patent infringement". 
Great news for the JS community as a whole!
Ayyy, now we gotta put pressure for React Native and kill BSD license for good. Fuck Facebook for ruining the spirit of open source Edit: downvotes for being pro open source? Do you work for Facebook or something, lol
Already killed the spirit of open source for me. I won't be using anything from Facebook when there are better more open solutions.
Exactly - chances are pretty fucking slim right? And yet people were raging about the original BSD+Patents clause based on hypothetical situations just as unlikely. The whole point I was trying to make is that there was never cause for concern in the first place.
Vue Native (Weex) is not restrictive.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse The reverse() method reverses an array *in place*. The first array element becomes the last, and the last array element becomes the first. Return value The reversed array.
I didn't ask that question. I made a statement. Caching is built into many server-side frameworks. It's practically a one line addition to a Django view. 
Can you explain this at all please?
I guess this only applies if its an apology? Which I think is not
personally, i can accept the patents clause is fine on its face; the problem is that corporations (especially megacorps) will always push for more change to benefit themselves at everyone's expense -- it's their nature. what makes it especially dangerous is that FB indirectly controls so much of the current ecosystem through react, meaning that the more FB changes things, the more the entire web suffers.
&gt; But I do want to learn the useful math. I can imagine Logarithms are quite useful to understand? You want to look into algorithms (program efficiency) and big-O notation.
Many of the methods from earlier versions of JavaScript mutate the original object. More recent additions tend to return a new object.
Twitch's new beta is built in React anyway
God, I really wish they hadn't done this. At least it got people to think about moving away from react and onto something else. Facebook has too much pull in the web development ecosystem and it's truely worrying. Also JSX is ugly as shit
Wow, finally there is an end to this overblown discussion...
It's not that chances are slim, it's that 'React patent infringement' is not a thing that exists. You might want to display the most basic understanding of copyright/patents before you attempt pointing out others' 'gross misunderstanding'.
It's a PR thing, not legal. Users of React (us) are actually in a worse legal position now, because we used to have explicit permission to use any patent associated and now we don't. But yay, they listened to the community!
As others have mentioned, Array.reverse modifies the existing array. If you'd like to copy the array before reversing it, you can do `x.slice().reverse()`
It's not really a step back if it's no different from how it's been.
I actually think WP wouldn't have done it had Apache Software Foundation not set the precedent.
By “React patent infringement” I mean Facebook suing you for infringing on any patents they hold relating to React. Which is absolutely a thing that exists — *assuming* Facebook does in fact hold patents relating to React. Evaluating whether or not Facebook holds any React-related patents is a difficult question to answer, as while patents are public, sifting through hundreds of deliberately obtuse &amp; broadly scoped patents to determine any relevance towards React is tricky. At this stage no one has surfaced any obvious ones. The MIT license contains no explicit patent grant. It has been argued that it contains an *implicit* one, but this argument has never been legally tested. In this case, we a trading an explicit grant provided by the Patents clause, with an implicit one provided by the MIT license. So I’m not really sure what you’re argument here is.
Are they going to grant users the patent? Otherwise people using React are arguably in a worse position.
&gt; Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. &gt; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. So where is the part where Facebook can sue you for infringing on patents related to a codebase they granted you explicit permission to *use, copy, modify, merge, publish, distribute, sublicense, and/or sell* (provided you use the same license)?
&gt; Exactly - chances are pretty fucking slim right? And yet people were raging about the original BSD+Patents clause based on hypothetical situations just as unlikely. It's not just as unlikely. - With the new MIT license you risk Facebook suing you over React-related patents. Considering how the library works, I doubt there's anything patentable in it, but let's put that aside - you still only risk action on violating **React-related patents**. - With BSD+Patents license you implicitly allow Facebook to use **any of your patents for free**, as you can't react and sue back - if you do, you lose the React license, and it becomes a pretty open and shut copyright infringement. With BSD+Parents license you also become defenseless if Facebook decides to sue you first over **any of their patents**, not just React-related. You can't sue back, because, again, then you lose the React license and get into an open and shut copyright infringement. So what's more likely - that you get in conflict with Facebook over **React-related patents** or that you get in conflict with Facebook over **either any of yours, or any of their patents**? So people don't have a "gross misunderstanding" of the license, you do. You can personally afford to be ignorant about the issue as individual small-time React users aren't threatened by all these legal matters in either case. But the companies that have dropped out of React can't afford to be ignorant. 
3/4 major browser vendors have media arms. Mozilla tried not implementing DRM for several years. End users did not care they just wanted their streaming GoT.
This is precisely why most argue that licenses like MIT provide an *implicit* patent grant. Because after, doesn’t make a whole lot of sense for a company to offer something freely but also not grant patent permissions. But the problem is that this is all common sense *conjecture* that has not been legally tested. It’s hedging bets, and not really better than a Patents clause that provides more a more explicit patent grant.
&gt; With BSD+Parents license you also become defenseless if Facebook decides to sue you first over **any of their patents**, not just React-related. You can't sue back, because, again, then you lose the React license and get into an open and shut copyright infringement. This is completely false. How about you actually read the clause mate: &gt; if Facebook or any of its subsidiaries or corporate affiliates files a lawsuit alleging patent infringement against you in the first instance, and you respond by filing a patent infringement counterclaim in that lawsuit against that party that is unrelated to the Software, the license granted hereunder will not terminate under section (i) of this paragraph due to such counterclaim.
Not only can they sue you, they can demand you stpp using an entire platform YOUR COMPANY BUILT.
How do you imagine Facebook suing e.g. me for patent infringement on an MIT-licensed project would go?
Probably not well? Mate I think we actually agree in a lot of respects here. The odds of an MIT licensed React posing any sort of legal problem for you are *incredibly slim*. 
What about GraphQL tho?
&gt; This is completely false. How about you actually read the clause mate: You need to research what constitutes a counterclaim in this instance, "mate". It does **not** mean suing back Facebook with some of your patents, it means filing related claims that cancel (or reduce the impact of) the original claim, i.e. say attempting to invalidate the patent Facebook is using against you. Let me put it in simple terms. Facebook says this: *"if we launch nuclear missiles at you, you reserve the right to use anti-missile defense to destroy those rockets before they hit you. You still have no right to respond by launching your own nuclear missiles at us."* The M.A.D. doctrine (Mutually Assured Destruction) for nuclear weapons doesn't refer to anti-missile systems, it refers to the threat of launching nukes back at the original aggressor. And the M.A.D. doctrine is often referred to in patent cases, as this is the same logic that stops many companies from suing each other into the ground: not the counterclaims, but other unrelated patents that the defendant can fling back at you if you become aggressive. I advise you to tone-down your arrogance a little bit, and let the big folks Facebook, Apache, WordPress etc. sort this out. They know what they're doing. 
Why was it vote with your wallet? They don’t earn money with this or am i missing something?
Thank you, WordPress!
I don't think we do. You seem to be under the misconception that I, personally, am afraid of Facebook taking legal action against me, when I (and many others) am opposed _on principle_ to the possibility existing _at all_. React's current license is not in the spirit of FOSS.
Yeah I think you’re right. Blanket of anonymity lets me run my mouth a bit, you definitely seem more knowledgeable about the topic. Sorry for the abrasiveness.
&gt;mutating the array Oh, duh. Thank you!
My mistake on the punctuation. Edited to to reflect it.
1. You finally get closures. Congrats! 2. LOL. Don't worry about "the point" in all of that. Slow down, we'll get there. We break this down into it's easiest piece so you can see what's happening. Those are good questions but just remember that it's just important to grasp what's happening in a nutshell. Then we can continue on. So let's take your example and expand upon it a bit. https://jsfiddle.net/u25k9747/ Again. Don't try to spend too much time grasping the practicality of this. All you need to understand is what is happening at a glance. Look at the code for a bit, try to grasp what's happening by yourself based on previous explanations. Then look at the following image and then read even more elaboration afterwards. https://imgur.com/a/A7NLf Not only do closures include variables, but they include parameters. I create 2 functionHolder variables and assign to them both that blackBox function. Except!... I pass a bit of data into them. Now the way javascript works, is you can't have 2 values inside a variable, only 1. But here I am, passing 2 to this function, AND passing 5 to this function. If you look at the output, you'll see they both output the correct calculation. THIS is part of the power of closures. The thing here, is we assign the function twice. TWO closures are made. So you remember that dotted box in the picture? functionHolderTen and functionHolderHundred BOTH have their own unique closure, or memory of the blackBox function. Here's another example, once you feel you're getting sort of comfortable with that. https://jsfiddle.net/3tmuwmcw/ All you need to understand, is that x is a different value for both multiplyByTwo (2) and multiplyByFive (5). How can x be two different values at the same? The answer is, they can't. Closures however create their own copy of the local state. Right above where the function is returned, at the time you assigned that function, the value of x for multiplyByTwo was 2. for multiplyByFive it was 5. The benefits of this are enormous. You can now create smart programs. I can have one function, and change values in that function based on which function is using it, as it creates a closure of that function's scope. We can also use this to simulate private variables. Finally, we can update the values of variables in that closure and hold onto them. I won't go over this though. Once you get closures, you can google all the individual ways you can use them. Edit: in the image, I mentioned that functionHolder can't modify the variables. That's not entirely correct. You can only modify variables in the closure if you expose something inside of the function you return to do this. Don't try to conceptualize this until you get the ten hundred function holders I explained above.
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/fWjpRn7.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dndnujr) 
How do people keep upvoting this nonsense? If you sued you lost the patent license, but not the copyright license. This has been repeated over and over, but apparently not enough.
Good thing Preact and Vue exist. It certainly helped getting some leverage. Products with no substitution (graphql, react native) didn't get the same treatment yet.
The copyright license never terminates, the other commenter doesn't know what he was talking about. (Your were still wrong though, but it doesn't matter).
It feels like so much tension and confusion just got relieved all at once
I don't understand the license and don't have the time to understand enough patent law to try. There are better uses of my time and energy. But I've had multiple customers both in the United States and Europe tell me to come back with a proposal that didn't include React and it was because the original license didn't pass their legal team. I've also had customers where it passed legal and they weren't concerned about the license at all. The "no thanks" crowd tended to be larger customers who had patent lawyers on staff, e.g. global engineering firms, while the "don't care" crowd tended to be smaller companies with software products without dedicated legal teams but paid for legal advice. I'm not sure if that's because a specialist in patent law understood the license better or if the possible loss was just so much greater due to the large number of non-software patents they hold. I can't tell you that their original license had concerns, but to paint it as only "a gross misunderstanding from the community" is all kinds of wrong. Edit: That said, glad it looks to be over. These meetings, reworks on proposals, and having to split ramp up time between multiple front end frameworks has been a big pain.
I suppose it's a little different in this case where there are roughly a dozen people at Facebook that actually work on these projects. Big company, small team.
False. You now have less protection. Now Facebook can sue you for using React technologies they have patented wether or not you sue them first. With the other license they could only sue you if you sued first.
This is a highly unusual internet comment, very good.
Not exactly. The license type revoked your permission to use React if you sue Facebook. 
I'm most interested in Wordpress' final decision. If they go back to React it'll solidify React as the leading framework. If they still leave and choose Vue it'll probably be a good battle ending up in a Vue "victory". It'll be interesting to see. 
I’d prefer `x.slice().reverse()`. ES6: `[...x].reverse()`
How can you patent open source code, has anyone commented bothered to read the license or linked any legal precedent?
This is good news, but keep in mind they can always relicense it again in the future if they kill off their competition (Vue and Angular). We should still proceed with caution, but this is still a victory nonetheless I believe. I hope WordPress still goes with Vue so Vue can grow even more like the big boys React and Angular. &gt;We've been working on React 16 for over a year, and we've completely rewritten its internals in order to unlock powerful features that will benefit everyone building user interfaces at scale. Does that mean it will be "very" or at least noticeably different syntactically (think Angular 1 vs Angular 2 I believe it was), or will it still be the same or at least very similar? I.e. will it maintain backwards compatibility with older version(s) or at least the current version of React, or should we expect massive changes? 
I would say it depends of what you call 'SPA'. For a lot of people, the current state of web is confusing, and somehow frameworks and concepts get tied and mixed up. If for you doing SPA is using "modern frameworks" (angular, react, vue etc) , well, ecommerce does. Walmart invests a lot in React, ebay built its own solution called Marko. The idea of reusable components is very appealing for ecommerce, because you often work for groups who will decline a common set of elements for their different brands. Now, if you really ask about the SPA concept, that's a different beast. As others pointed out, main concern here is SEO. But SPAs aren't a problem because of bots/page crawling issues like most people think. That would be trivial to handle. To understand the real issue, you have to imagine what it's like to animate the merchandising of a big ecom site with thousands of references. The pages themselves may be static, but the global url structure is really fluid. It's christmas ? Let's make a /christmas category. Now your products must show in /productName and /christmas/productName. Your event ends? You need to quickly ensure all urls referencing your christmas event now permanently redirect until you maybe recycle next year. That's just a small example to start thinking from. The url-handling engine of a big ecommerce site animated by a marketing team is a big monster full of exceptions, mappings and redirects, and it's awfully hard to translate that to a client-side router, especially considering that the mappings could change daily. This doesn't mean however that SPAs are absent from ecommerce. Carts/checkouts/user accounts areas are more and more like satellite SPAs aside the main catalog. You can also find some 'SPA modules' here and there, usually interactive web apps developed for a marketing event/feature. [Note: Building ecommerce platforms is my job. However my company mostly makes those for big multi-brand international groups and my remarks are to be taken in this context. I think small/medium shops would be a different context]
Hi /u/stanislavb, sorry but I've removed this post as the same one [was posted 15 minutes prior](https://www.reddit.com/r/javascript/comments/71uaes/relicensing_react_jest_flow_and_immutablejs_to_mit/) (it uses a different url so the dupe detector didn't alert you).
So if I start a project with React tonight, will this future license change cover my ass later?
Never thought I'd be thankful for WordPress :P
You should read the rest of the thread. Even the person arguing in the first place conceded, that this was a bad license.
&gt; In what language are they not? In Go for example unless you define something as a pointer it will pass as value and not reference. &gt; No, that's not what it means. Behold.. Nope. You are not changing the value of the const, you are changing the object it points to.
Oops, i meant `slice`
It's a spec. FB does have an implementation, but it's basically just a reference. There are better ones like Apollo.
They conceded that the way they interpreted the patent license way wrong (you should read the rest of the thread where I had already replied to that comment). But the other comment is wrong too. The copyright license is completely separate from the patent license.
Sounds like you just want to complain about your petition and post an I told you so to those you quoted. 
You miss the point entirely.
Before, anyone suing them for patent infringement would lose the right to use React. After, anyone suing them for patent infringement can still use React. This is not a very big deal to them either way. Almost all of the people suing them don't use React. Almost all of the people using React don't sue them.
You can patent it when you created it. Patents by definition are open because the entire patent gets made public once the patent is filed. “Open” means everyone can see how it works, not that they can use it for free. 
The issue with that is that the next function in the chain will operate on the Promise returned by the preceding function, instead of the value it resolves to. So what I've done is wrap every function in a Promise (some that resolve immediately), so every function in the chain waits for the function preceding it to resolve. Let me know if I'm missing something... and thanks for the feedback!
I'm trying to get whatever the value of the inputs to be added to h2 tag. What am I doing that's not right?
How...?
None. Patent trolls were always open to sue Facebook, because patent trolls traditionally don't produce technology, and would thus suffer no recourse from being denied a license to use React. 
Yeah, It does not add new features. It removes tricky edge cases of current features. 
A bunch of mixed metaphors doesn't make you any more (or less, in this case) correct than you were previously, you're just clouding matters with more FUD. The best advise appears to be that losing your react patent grant has no tangible significance. It does not mean you can't sue facebook, or file a counter claim; It means you lose the patent grant that you had previously if you do. However, the tangible effect of that is unclear, and by all accounts, not significant *in the case of react* (and irrelevant now anyhow). Copyright is not related at all. So, tldr; you *are wrong*, and although its no longer relevant, its equally unclear if people are better off with an implict patent grant under the MIT license. Its *not* clear people are actually better off now. This may be a PR win, but I'm not sure the op of this subthread is actually wrong.
JSFiddle is being weird, but I got it to work just fine with JSBin: http://jsbin.com/sunonewari/edit?html,js,console,output not sure if that helps. edit: also, been a while since I've used jQuery, but I don't think you can provide arguments to `text()`. That is only a getter.
By assigning the promise to a variable and using the await syntax execution will wait for the promise to resolve. 
https://jsfiddle.net/mLvckvc0/ Under the JavaScript settings, I set it to JQuery 3.2.1. I then set the form to onsubmit="return false". So that the page does not reload once you hit submit. I then changed $info.text($full); to $(info).text($full); I have never used Jquery before, so I could not tell you why that works. But, I hope this helps you. 
Just off reading the Jquery documentation, I am pretty sure that text() works much in the same way as html(). http://api.jquery.com/text/
https://github.com/getify/You-Dont-Know-JS Free to read online the second book is scopes &amp; closures. https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch5.md#nitty-gritty &gt; Closure is when a function is able to remember and access its lexical scope even when that function is executing outside its lexical scope. 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [getify/You-Dont-Know-JS/.../**ch5.md#nitty-gritty** (master → c4ab888)](https://github.com/getify/You-Dont-Know-JS/blob/c4ab888b4b7d778f58591e4dee440734c0333847/scope%20%26%20closures/ch5.md#nitty-gritty) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dndylcc.)^.
You missed the dollar sign before the ('#info'). Also prevent the form redirect with a preventDefault(). Lastly, load jQuery via the dropdown in the Javascript box instead of jquery.min.js. Hope that helps! https://jsfiddle.net/gsau9xhj/
Hi /u/LearningToCode25, For javascript help, please visit /r/LearnJavascript. Thank you!
ah I must be misunderstanding. but yeah essentially I'm trying to get rid of the need to assign variables, and instead pipe the result of one function straight to the next through composition
No. As long as their other libraries still have the patent grant, there will be something we can be angry about! ;)
Why are you migrating to a SPA?
What about Reactive Native? They need to remove their stupid defensive license.
Yeah and that's great, but is that really worth dropping IE support?
The API between React 15 and 16 has not changed. There are some new things you can do, but everything is backwards compatible.
I think it makes sense for them to adopt Vue anyway. A lot of PHP devs and contributors to WordPress appear to favour Vue. Possibly because of Laravel?
Not sure what you're asking. Once 16 has been released with a given licence (eg MIT) it's immutable. Even if FB changed the licence in a future release, you could (a) not update or (b) fork the version prior to the new license and you'd be fine.
It's just an expression. To vote with ones wallet is to support/not support something by purchasing/not purchasing it. WordPress did not support the patent clause so they "voted with their wallet" and stopped using React.
This is inaccurate. Anyone can sue anyone about anything, regardless of licence or patent. That doesn't mean they'll win. I'm not sure what about the patents file gave you the impression that Facebook could "demand you stop using an entire platform your company built". Seems like a misunderstanding about the purpose of the patents grant? Either way that was _not_ the purpose or intent. The patents grant has been in place for a couple of years. Recently the community expressed serious reservations about it. Facebook took these concerns seriously and changed the licensing for the upcoming version of React to be more inline with what the larger dev community wanted. This was not an easy or simple decision. A lot of people at Facebook put a large amount of thought and discussion into making sure this could happen. And I'm really happy it worked out the way it did. I think this change (at least in my mind) affirms that Facebook never had bad intentions for its OSS or the patents grant. The people working on projects like React- from the engineers to the lawyers- have good intentions and genuinely want to help the community. At least that has been my experience in my interactions with them.
Laravel merely prefers it, for whatever reason, but there's no inherent benefit. React plays along with Laravel just like Vue does. React technically is the newer, more forward thinking stack, probably the first real standard the web has ever had, judging by its eco system and community. Vue is [barely on the radar](http://www.npmtrends.com/angular-vs-react-vs-vue-vs-@angular/core) compared to it. The license was the only thing that stood in the way. As for Wordpress switching, why would it make sense? They would have to rewrite their entire application from scratch, also loose all the 3rd party controls and components. All all for what?
The latest laravel lets you choose what js framework you want, vue, react, angular. 
I would say "yes", it considerably improves DX and reduce leaky abstraction.
Perhaps ironically, the overall project is driven by search engine exposure requirements. The SPA is just a small part of the bigger picture, however. Mostly, we're moving to a micro-service architecture, and a SPA is a way to parallelize operations. 
There are plenty of replacements for GraphQL (Falcor, Horizon, Meteor) and React Native (Ionic, etc).
Not only does Facebook have a patent on the spec, Apollo is not an implementation of that spec. It uses the official GraphQL npm package from Facebook and simply wraps it with an easier API.
The value is that the humans using your site have it faster than with a traditional server side rendering.
Inside a function you have access to anything which is in scope (no surprise there). This stuff is the environment of the function. When you pass this function around, the function continues to have access to its environment. A closure is a function plus the environment it was defined in.
I hope they do the same for GraphQL.
&gt; Not only does Facebook have a patent on the spec, Facebook has a patent *on a spec*?!? The world is getting more insane every day.
What patent?
&gt; there was never cause for concern in the first place The cause of concern was that if you use React, you forfeit any rights to sue Facebook over any patent infringement on any of *your* patents. It was much broader than just React.
&gt; if they kill off their competition (Vue and Angular) From what I have seen with working with them, people tend to use Vue and Angular for different reasons than React.
I got that, but I took it too literally 
Yes, GraphQL can never become mainstream while Facebook maintains its anti open source attitudes. 
Holy shit, I'm so confused. Clearly this just isn't a field I'll ever be able to comment on.
Patents allow the holders to deny usage, but MIT says that you can use it in any way, for anything and without any other type of impediment (or something like that). So if taken to court you probably will win, but a patent grant just skips court altogether.
&gt; As should also be apparent from the tweets, the author is not an organizer of the conference, they're just a potential speaker. which is the most obnoxious part of it. He's speaking on behalf of a conference he's not affiliated with because he thinks the world should behave the way he wants it to.
Nope. Patents. https://medium.com/@dwalsh.sdlr/using-graphql-why-facebook-now-owns-you-3182751028c9
This week I made [Wretch](https://github.com/elbywan/wretch) which is a tiny, chainable and immutable fetch wrapper. And also released [Bosket](https://github.com/elbywan/bosket), a tree view components library for front end frameworks (react/angular/vue.js/riot.js).
We already have that automated as part of our build process. Nothing was coded... it just happens.
More like "we were right about the license, but wrong about people wanting that".
Thanks! I'll look up the sources. I don't mind that type of programming though. My teacher sent me this: var isBoxOneGone = false; // of false $(document).ready(start); function start() { fadeThingsAway(".boxOne", ".boxTwo", 1000); $("button").click(buttonClick); } function buttonClick() { // als boxOne weg is, dan boxOne infaden en boxTwo uitfaden // anders, andersom fadeThingsAway(".boxOne", ".boxTwo", 1000); fadeThingsAway(".boxTwo", ".boxThree", 1000); } function fadeThingsAway(firstBox, secondBox, delay) { if (isBoxOneGone == true) { $(firstBox).fadeIn(delay); $(secondBox).fadeOut(delay); isBoxOneGone = false; } else { $(firstBox).fadeOut(delay); $(secondBox).fadeIn(delay); isBoxOneGone = true; } }
For the uninformed, link for all the "Thanks WordPress" references https://ma.tt/2017/09/on-react-and-wordpress/
But users wouldn't even notice. Being in that situation ourselves, i'd like to know, how do you plan to reconcile the two? Proxies is kind of a new feature and wouldn't observables behave different to the old way ($set/$get)?
Ionic isn't native and needs a web view. NativeScript hasn't gotten the same traction. Weex is barely out of the door in a highly complex field with pitfalls that took RN and NS years to solve. RN doesn't have a replacement just yet.
Looks impressive!
Now, who would have guessed that react will benefit most from "wordpress leaving react"!!!
By "users", I was referring to developers using Vue. &gt; Being in that situation ourselves, i'd like to know, how do you plan to reconcile the two? We are currently discussing this. We probably will encapuslate the reactivity system more, so the old and new one can have the same internal API and can be "plugge into" the two different codebases in a way. It's still to early to give more details as we don't have them. &gt; Proxies is kind of a new feature and wouldn't observables behave different to the old way ($set/$get)? Yes, the new Observables would also work when users do something that currently can't be observed (aka the "reactivity caveats"). That can mean that a component package written with Vue3 in mind may not work in an app that uses Vue 2, if the authors took advantage of the absence of those caveats - which could split the ecosystem in a way. That's of course something we don't want, so we are still discussing how to prevent that as best as possible, like recommending to still use `$set` for your published packages to ensure Vue2 compatibility (we will keep `$set` in Vue3 for backwars compatibility, but you would not have to use it). Wherever possible we will also support his with e.g. linter rules, bable plugins and whatever ways we find to support compatibility in that area. So to summarize: The API will stay consistent and backwards compatible, but you can e.g. drop using `$set` in Vue3, which would lead to bugs if used in Vue2 - we have to find a way to prevent that for published packages. 
That looks quite cool
Didn't they just update their license a couple of weeks ago starting all this madness? Could WordPress simply have not updated or forked react?
We also have this kind of magic where I work. Lack of coffee is necessary for it to work properly though
It seems like people were overReacting to this. 
No. React has had the patent grant since 2014. It was updated slightly in April 2015 in order to satisfy Google so that their engineers could use it. The recent discussion was just kind of a snowball.
But to answer your question, anyone could have used or forked React from before the patent grant in 2014 if they wanted.
I really need to give Laravel another look. 
The reason EFF left wasn't simply because of DRM but because there was no provision for security research. If security researchers can't study DRM code this increases the likelihood of browser security holes. This harms end users. 
I've expressed this before. I work for a company that is somewhat of a patent troll. The majority of company capital comes from licensing and lawsuits; it's not unreasonable given the field, we have patents, other's violate them. It's pretty standard business. I don't believe we've ever sued Facebook before, but Facebook's size and scope of product domains, I like to be practical and say "when", not "if". I've asked our own legal team if using React was allowed given the license and patent grant, and they stopped me right at reading the patent grant. The license is mostly ok, the patent grant is what has people running for the hills. If you ever decide to sue Facebook, even if they infringed on your own patent, anything and everything that you've written using one of these Facebook libraries is subject to license revocation. This gives them a leg up in potential lawsuits. You risk losing work/time spent on products or are subject to licensing the libraries from Facebook, which would only be discussed in arbitration and not through a standard contracting route. Take a gross example, we have a product that uses React and offer a demo site to a potential customer. Someone tips off Facebook that our product uses React. On the side, they decide to create a similar product to any of our other products. We sue Facebook. Facebook revokes our license. We're forced to rewrite the entire product.
How does moving to a SPA help you parallelize moving to SOA?
already switched to vuejs, sorry.
IME, the main reason for using Vue over React is counter-cultural.
See Google vs. Oracle though. An API has been ruled uncopywriteable.
FB does have a large influence, but it's not an accident. Many developers have found their software to be superior than the alternatives.
So nobody says 'Thank you'. Also I believe that Wordpress will get back to React as the migration process should be in the initial stages and could be reverted.
btw, if you prefer deeply-immutable state, i can't recommend https://github.com/arqex/freezer highly enough
I didn't expect this much positive responses :) Planning to do more.. yay or nay?
Didn't the EFF specifically join the W3C for this DRM thing only, and was going to resign anyway when stuff was decided?
Extensions do not have to follow the license of the software they're extending when it's licensed under MIT
A library I wrote using [µws](https://www.npmjs.com/package/uws) and [schemapack](https://www.npmjs.com/package/schemapack). It's been in "production" use for a variety of our internal web apps with some great success. Big shoutout to u/phretaddin, who posted his schemapack project on reddit a while ago and got me really interested
A) this is a patent issue, not a copyright one, do that doesn't apply here B) APIs were ruled copyrightable, but their reimplementation was deemed fair use. That's still being appealled by Oracle: https://en.m.wikipedia.org/wiki/Oracle_America,_Inc._v._Google,_Inc.
If the BSD-3+Patents license is bad for React, it's insane for GraphQL. I wish there was more noise about this.
Always good to clarify! It certainly depends on which definition you use. I'd generally say that in the way that discrimination comes up these days, there's a requirement that the distinction be unfair or cause people to be treated poorly. Some definitions call that out more explicitly that the one you posted. If you go by your definition that is essentially a synonym for "distinguish by race/whatever" then it's a massively broad distinction. But then I'd also ask, if there's no harm involved, why does it seem to frustrate you so much? https://dictionary.cambridge.org/dictionary/english/discriminate &gt; to treat a person or particular group of people differently, especially in a worse way from the way in which you treat other people, because of their skin colour, sex, sexuality, etc. https://en.oxforddictionaries.com/definition/discriminate &gt; Make an unjust or prejudicial distinction in the treatment of different categories of people, especially on the grounds of race, sex, or age. https://www.macmillandictionary.com/us/dictionary/american/discriminate &gt; to treat someone unfairly because of their religion, race, or other personal features 
Now they have just preemptively revoked the license that would have been revoked if you sued them for patent infringement. The only difference is that now they may initiate a patent lawsuit against you for using React, where before you had an explicit license. Yay?
&gt; may initiate a patent lawsuit against you for using React How's that? If their license is now MIT, I can freely use the library as is without fear of repercussion. They could revoke for newer versions, and I may be stuck with the last MIT version, but as long as it says MIT (and without the Patent grant), it's free to use. The MIT license states &gt;Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including **without limitation** the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions... If you obtain some software under the license above, you have permission to use it. If the copyright owner decides to stop granting that permission in the future, that's their business, but it doesn't change the fact that they've already granted permission to you, and furthermore they've also given you permission to publish, distribute, and so on provided you do so under the same terms. The Patent grant is different &gt; Facebook, Inc. (“Facebook”) hereby grants to each recipient of the Software (“you”) a perpetual, worldwide, royalty-free, non-exclusive, irrevocable **(subject to the termination provision below)** license under any Necessary Claims ... &gt;The license granted hereunder will terminate, automatically and without notice, if you (or any of your subsidiaries, corporate affiliates or agents) initiate directly or indirectly, or **take a direct financial interest in, any Patent Assertion: (i) against Facebook** or any of its subsidiaries or corporate affiliates,
It hasn't been decided whether MIT/BSD licenses implicitly cover patents or just copyright (hence Apache). I'm sure your lawyers would be happy to try to set that precedent while defending you in court, if the price is right.
React is not patented though; the patent grant is a license rider that basically says if you sue us for "any" patent, we can terminate the BSD 3-clause license, thus making the software commercial and wholly owned by Facebook. It doesn't stop anybody from creating a similar library, like Preact or Inferno. No way in hell ImmutableJS is patented, immutable data structures have been around since the beginning of computing.
The real WTF moment should be when you realize you're comparing arrays. I hope you do realize that that `[1] !== [1]`
I wrote something similar a few times, my versions were different in that they don't accept promises but instead get a function returning promises, and the work objects are descriptions of the promise that should be returned. That way, I could implement multiple workers so that I only have e.g. 10 async i/o actions running, going through 40k entries without any issues. The queue then has a promise that resolves when the queue is empty. However, I never did figure out what to do with rejected promises. I just let the given function handle it, but that encourages unhandled rejections. Looking at your project, you of course have a different goal. I was first confused about passing Buzies, until I realized it lets you group promises; however, why not add the promises themselves?
The patent grant says if you sue them for any patent, the patent grant ("license granted hereunder") terminates. Facebook has thousands of patents, many of which are quite vague. Not even Facebook can know for sure that **none** of them covers something in React or Immutable.js - or any other JS library, for that matter.
It absolutely is just that. "Waaaah, Facebook is changing it's license, I can't be a starbucks hipster and have to learn stuff again!" "Waaaaah, people are mean over the internet!" "Waaaaah, I told you so!"
Arm biting is planned for version 2. Impotence is in the works but will have to wait for version 3.
Whaa.... `yarn add eslint@~3.19.0 --dev` didn't fix a `~3.19.0` peerDependency constraint? That doesn't make any sense.... did... you do it right? I would think it'll match the highest available of your `devDependency` and warn you about non-matching constraints. If everything works, that's cool... disregard the warnings. I'm actually kind of surprised that standard hasn't been updated to use `eslint@latest` (i.e. 4.x) yet. I've never used it, myself... I typically just roll my own eslint configs.
I think you and I are in agreement, but I think there is a common misunderstanding in this thread of what patents the patent grant rider is referring to. From the grant, &gt;A "Patent Assertion" is any lawsuit or other action alleging direct, indirect, or contributory infringement or inducement to infringe any patent, including a cross-claim or counterclaim. This doesn't necessarily mean React (or the 3 other libraries) has any Patents of their own. It's a useful tool, but even if Facebook have successfully acquired relevant US software patents, it's hard to believe there's anything significant in there that had no prior art. GUI programmers have been specifying presentation details declaratively, using templates, and bundling updates for performance since long before the existence of React (or Facebook, for that matter). As an aside, it's one thing to distribute open source code and hide Patents on it somewhere. But that all seems counter to what Facebook is trying to achieve by removing the Patent grant and switching from BSD 3-clause to MIT, an even more permissive license.
In a way, this was a case of Automattic voting with *Facebook's wallet*. WordPress dropping React means losing the contributions of tens of thousands of developers from the React ecosystem. It shrinks the pool of developers with experience they need. It shrinks the pool of free/inexpensive code available to consume.
Rather than waiting for many backend operations to complete, the frontend will retrieve what it needs when it needs it.
You can do that without a SPA. Better question: how do you define SPA?
If you're doing frontend work (eg, react.js), those will be useful skills to have. You don't necessarily need to be an expert on them, but you should know the basics at least. For backend work (eg, node.js), they're not as important.
Absolutely! Web Development work generally requires 3 things: HTML - for the elements of your document/application. CSS - for the style of your elements. JS - for the behavior of your elements. While you should certainly focus on your Javascript, you absolutely need at least a reasonable competency of HTML Element/Attributes and CSS Selectors and Rules Good luck!
well the peer dependency warnings are not coming from standard(which has the `~3.19.0` eslint dependency). They're coming from the standard plugins. The plugins as you can see in the warnings have a dependency on eslint `eslint@&gt;=3.19.0`, `eslint@2.x - 3.x`, and `eslint@^2.0.0 || ^3.0.0`. I thought adding `~3.19.0` would satisfy everything but nope. I encourage you to start a new project and test it and confirm that i'm not crazy. *edit, everything still works even with the warnings. I'm just trying to fully understand what's going on
Of course.
Javascript is not a .js library, and yes you need to learn HTML, and CSS.
If you plan on making a portfolio, you'll need to know your CSS and html to make a decent looking product for the portfolio. 
Most simply: **Calling a reference from within a nested scope.**
I made a codepen to understand the difference between e.target and e.currentTarget https://codepen.io/vikas-parashar/full/WZxrYX/ PS: I already posted this in as separate post so I am not sure this belong here or not. 
The patent issue still persists.
Currently waiting for a more experience developer to respond on how I should feel about this. 
Just listening to a talk by Dan Abramov at Zeit Day where he was lamenting these exact errors. His thought was it’s pretty dangerous to release these kind of incorrect errors because it trains a few devs every time it happens to ignore them. Essentially they’re caused by a bug but have more negative consequences than you would think. 
is that talk posted online somewhere?
This appears to be a bug in yarn's peer dependency warnings. Hand inspecting the installed modules shows that they do meet the peer dependencies and `npm ls` doesn't complain either. I encourage you to open a bug report over on the yarn issue tracker, if there isn't one already open.
My experience has been that so many people got burned publicly by mongo bugs and design flaws that mongo is not considered a viable real-world database anymore, regardless of whether they've fixed their issues or not. It might be good for fast iteration and while you're working out your data models, but ultimately you end up writing tons of adapter code, and pay the price in your application code instead of your database configuration code. Competition is good, though, and mongo going public may lead to them becoming more competitive in the future. That is, as long as it's an attempt to infuse the company with cash and not just a way for the founders to cash out and run.
thank you!
look nice, but how we can do SSR with it? im missing somehting?
Don't invest in it.
not yet , but i plan to add save and load api to serialize and deserialize state next week
I think that happens when the html is invalid. I had it happen before with uncompiled jade templates being exposed as html. However, I'm kind of doubting myself right now, because it seems like that's far more fragile than the web I know and love. I've seen this error before though, and it confused me as well.
It's the latter. This screams exit strategy.
But what should you do when you're a new dev and everyone tells you not to use Mongo, but every tutorial or course you find is using Mongo ?
1. Learn SQL and concepts 2. Use something like sequelizejs.com (which is like Mongoose) There are plenty of tutorials for any mainstream database. They just need to search for some library to interface with it and follow the examples.
Zeit.co/tv
No need for all that overhead. We have packages for each of OP's functions already, just pull in what you need: `str_pad() =&gt; npm install pad`, etc.
I'm not a super experienced dev (few years of work + Masters) and I've never used Mongo for anything more than projects in school/toy apps, but I really like it. It's definitely not the Panacea to all of your DB woes, and I haven't looked over their financials, but they're definitely not going anywhere. People like to either hype on it's ability to distribute easily, or shit on some of the ACID issues, but it's like every other tool in development: "what problem are you trying to solve and what are the costs/benefits associated with different solutions" From what I understand, Graph DBs provide more of a structural change in the data storage realm when compared to the standard relational model than some of the {key:value} document stores, but any attempt to predict the future is futile.
B-but MEAN is the stack of the future!
I just got back from an overnight trip and will look over all of this tomorrow. I just wanna thank you for all of your work on this, because you didn't have to. I really appreciate it.
I gave up on mongo after trying to figure out how to search the collections was not very well supported. I'd rather put my IPO money into Roku
lol. it was for the past 30 seconds.
Umm my opinion? I dunno. I think it's a nice project, and for the design decisions it made, it did a lot right. The abstractions have stood up well over the years, even as it sorta took on more and more unforeseen responsibilities (e.g. things like streaming server-side rendering). At a glance, the Vue ecosystem feels less "hacked together" than React's, but React's has a lot more muscle behind it, especially from big tech companies that have enough employees to have platform/cross-functional teams. I think React has reached a critical enough mass that you start seeing a significant amount of duplicated effort and questionable code out there. I don't get that feeling very strongly for Vue yet. It still seems to be at a stage where nearly all users are cranking out apps, and there are very few players doing "outside-the-box" plumbing (i.e. things like nuxt). I think some areas are starting to see effort duplication already though (e.g. bootstrap/ionic clones). In terms of its actual design, I'm personally not a huge fan of the templating syntax. I would've preferred if they had kept following the style of AngularJS (the old one), rather than start introducing weirdness like new Angular and React do (talking about stuff like non-alphanumeric symbols in attribute names and things like `...`, you know, the stuff that we js insiders understand, but that bewilders backend folks just trying to get their stuff on screen) As I mentioned in another comment, I also would've liked to see the reactivity aspect of Vue - specifically `computed` - become optional, as I feel that it's not actually all that critical a feature to have in core, since vuex also exists. YMMV of course. But again, those are my personal opinions and reasonings. It's worth repeating that they have their own opinions and that their reasonings are perfectly valid, *and* the execution of those opinions/reasonings is excellent. 
You could store the sum in a global variable prior to chart creation and then you'll have it available when you render the tooltip
Can confirm, definitely sounds like an exit strategy. source: I watched all 4 seasons of Silicon Valley.
Worst case: use Postgres with JSONB store -- it can do pretty much everything Mongo can, but you can also eventually refactor yourself away from NOSQL. Best case: learn RDBS
Who uses Mongo anyways? I thought it was so 2016... /s
MERN all the way.
What a money grab 
&gt; I would've preferred if they had kept following the style of AngularJS (the old one), rather than start introducing weirdness like new Angular and React do What did you like more about Angular's templates? I really prefer how uniform Vue's template syntax is - in this way it always seemed like 'Angular but sensible' to me. It's really easy to look at a component and know exactly how props will be interpreted. Anything starting with `v-`, `@` or `:` contains JS; anything else is a string. With Angular, directive props could be interpreted differently based on their binding type AFAIR.
I really hate document stores. They seem so easy and straightforward until you need join functionality. Then you also realize you need to repeat your data in multiple places. I wash myself clean every time I attempt it.
Well you put /s but 2017 has woken up quite a few developers. Turns out that 90% of the people who used NoSQL didn't need NoSQL... 
&gt; Permission is hereby granted, free of charge, to any person obtaining a copy of &gt; this software and associated documentation files (the "Software"), to deal in &gt; the Software without restriction, including without limitation the rights to &gt; use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies &gt; of the Software, and to permit persons to whom the Software is furnished to do &gt; so, subject to the following conditions: &gt; The above copyright notice and this permission notice shall be included in all &gt; copies or substantial portions of the Software. This is good enough for me. I'll let a court precedent change my mind, not a reddit comment.
I converted some SPOOKY EYES from Adafruit's Teensy demo. https://codepen.io/SarahC/full/OxRyKK/
Almost went to work for mongo this year, glad I didn't bother as there seems to be better things on the market
This has nothing to do with JavaScript 
By don't invest in it... Do you mean short it after the first days gain?
[removed]
&gt; so many people got burned publicly by mongo bugs and design flaws The fact they sit there with a bold face and refuse to secure their defaults even as they get trashed in the press again and again and again.... Moronic. Only possible outcome is more future bad press and more exposed data. Fix the defaults you tards!
DISCLAIMER -------------- ^^^The ^^^comments ^^^provided ^^^by ^^^me ^^^contain ^^^statements ^^^related ^^^to ^^^our ^^^future ^^^business ^^^and ^^^financial ^^^performance ^^^and ^^^future ^^^events ^^^or ^^^developments ^^^involving ^^^Mongo ^^^that ^^^may ^^^constitute ^^^forward-looking ^^^statements. ^^^These ^^^statements ^^^may ^^^be ^^^identified ^^^by ^^^words ^^^such ^^^as ^^^"expect," ^^^"look ^^^forward ^^^to," ^^^"anticipate" ^^^"intend," ^^^"plan," ^^^"believe," ^^^"seek," ^^^"estimate," ^^^"will," ^^^"project" ^^^or ^^^words ^^^of ^^^similar ^^^meaning. ^^^We ^^^may ^^^also ^^^make ^^^forward-looking ^^^statements ^^^in ^^^other ^^^reports, ^^^in ^^^presentations, ^^^in ^^^material ^^^delivered ^^^to ^^^shareholders ^^^and ^^^in ^^^press ^^^releases. ^^^In ^^^addition, ^^^our ^^^representatives ^^^may ^^^from ^^^time ^^^to ^^^time ^^^make ^^^oral ^^^forward-looking ^^^statements. ^^^Such ^^^statements ^^^are ^^^based ^^^on ^^^the ^^^current ^^^expectations ^^^and ^^^certain ^^^assumptions ^^^of ^^^Siemens' ^^^management, ^^^of ^^^which ^^^many ^^^are ^^^beyond ^^^Siemens' ^^^control. ^^^These ^^^are ^^^subject ^^^to ^^^a ^^^number ^^^of ^^^risks, ^^^uncertainties ^^^and ^^^factors, ^^^including, ^^^but ^^^not ^^^limited ^^^to ^^^those ^^^described ^^^in ^^^disclosures, ^^^in ^^^particular ^^^in ^^^the ^^^chapter ^^^Risks ^^^in ^^^the ^^^Annual ^^^Report. ^^^Should ^^^one ^^^or ^^^more ^^^of ^^^these ^^^risks ^^^or ^^^uncertainties ^^^materialize, ^^^or ^^^should ^^^underlying ^^^expectations ^^^not ^^^occur ^^^or ^^^assumptions ^^^prove ^^^incorrect, ^^^actual ^^^results, ^^^performance ^^^or ^^^achievements ^^^of ^^^Siemens ^^^may ^^^negatively ^^^or ^^^positively ^^^vary ^^^materially ^^^from ^^^those ^^^described ^^^explicitly ^^^or ^^^implicitly ^^^in ^^^the ^^^relevant ^^^forward-looking ^^^statement. ^^^Siemens ^^^neither ^^^intends, ^^^nor ^^^assumes ^^^any ^^^obligation, ^^^to ^^^update ^^^or ^^^revise ^^^these ^^^forward-looking ^^^statements ^^^in ^^^light ^^^of ^^^developments ^^^which ^^^differ ^^^from ^^^those ^^^anticipated. ^^^The ^^^comments ^^^provided ^^^by ^^^me ^^^include ^^^– ^^^in ^^^IFRS ^^^not ^^^clearly ^^^defined ^^^– ^^^supplemental ^^^financial ^^^measures ^^^that ^^^are ^^^or ^^^may ^^^be ^^^non-GAAP ^^^financial ^^^measures. ^^^These ^^^supplemental ^^^financial ^^^measures ^^^should ^^^not ^^^be ^^^viewed ^^^in ^^^isolation ^^^or ^^^as ^^^alternatives ^^^to ^^^measures ^^^of ^^^Siemens' ^^^net ^^^assets ^^^and ^^^financial ^^^positions ^^^or ^^^results ^^^of ^^^operations ^^^as ^^^presented ^^^in ^^^accordance ^^^with ^^^IFRS ^^^in ^^^its ^^^Consolidated ^^^Financial ^^^Statements. ^^^Other ^^^companies ^^^that ^^^report ^^^or ^^^describe ^^^similarly ^^^titled ^^^financial ^^^measures ^^^may ^^^calculate ^^^them ^^^differently. ^^^Due ^^^to ^^^rounding, ^^^numbers ^^^presented ^^^throughout ^^^this ^^^and ^^^other ^^^comments ^^^may ^^^not ^^^add ^^^up ^^^precisely ^^^to ^^^the ^^^totals ^^^provided ^^^and ^^^percentages ^^^may ^^^not ^^^precisely ^^^reflect ^^^the ^^^absolute ^^^figures.
I somehow doubt Wordpress is going to dictate the future of frontend programming, near or otherwise. I don't see any company switching to Vue, or using it purely because Wordpress does. Regardless of the outcome of the Wordpress issue, React will likely remain the leading frontend view library for the time being.
Most of the comments here are literally the same old arguments that people had about MongoDB v2.6 A lot has improved with the latest version - MongoDB 3.4 However, the technical aspects of whether MongoDB is a good database is not the only thing to consider for the topic in discussion. MongoDB has been coming up with lots of cool products like [Altas](https://www.mongodb.com/cloud/atlas), [Stitch](https://www.mongodb.com/cloud/stitch), [MongoDB for OEM](https://www.mongodb.com/partners/partner-program/oem), which are viable solutions for startups with good funding. So that translates to MongoDB being a profitable company. The thing that I can forsee from this IPO is that it is extremely difficult for MongoDB to lose its clients. When you've gone in production with a database, it is highly unlikely that you're going to migrate to a new one and would instead work harder to work around most problems. And in fact the clients themselves would push for MongoDB to resolve their problems faster. Which translates to MongoDB going on to become a better product. Also to take into consideration is the fact that MongoDB churns out good amount of educational resources around the database. The annual conference, [MongoDB World](https://www.mongodb.com/world17) has had 4 chapters so far, and the quality of talks are truly good and give a better insight on latest developments at MongoDB. Besides, there is the certification course and other educational material that MongoDB provides. Overall, the company does look pretty dedicated to what they are doing and seem to be getting better. But to come back to the technical aspect, one would want to go through the [issue tracker](https://jira.mongodb.org/issues) for the open issues in MongoDB. There are some pretty critical bugs still open. And just the fact that it is a listed company shouldn't at all influence you to use MongoDB as the choice of database for your project. Do your research and take an informed decision.
why not call Facebook/auth in express? get the token there, create the jwt token and send it off to the client?
Can you be more specific about the tons of adapter code that you're referring to? I work with both Mongo and MySQL and I haven't experienced that myself.
ES2017 added padStart and padEnd. 
Great name. I was going to build something **exactly** like this (including using those libraries) but held off in the hope that someone else will do it for me. The lazy man wins again. Hopefully can contribute in the future.
The link is down how can I see that page? Is there a way to have an interceptor for http requests like I can do in Vue, so that I can pass along the api key from localStorage to my api server with every request?
&gt; I know there's no difference in outcome, but I would prefer to continue to use 'var' for variables I really want to have function scope, and confine 'let' to inner scopes like loops. To me it spells out which are the "important" variables within the function and which are more incidental. Is this considered bad style? Use definition closures and have shared methods, objects declared outside via `const`. Then you can use `let` in all prototype methods and you are fine. Everything is then properly written, without the need of a function scope. You really should not need it. Here's an [Example for this definition pattern](https://github.com/Artificial-Engineering/lycheejs/blob/development/libraries/lychee/source/app/Main.js).
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [Artificial-Engineering/lycheejs/.../**Main.js** (development → e4d3ace)](https://github.com/Artificial-Engineering/lycheejs/blob/e4d3acea18c09d825c8cd56afc71fefcc86ee6f0/libraries/lychee/source/app/Main.js) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dnfl608.)^.
Use `let` (ES6) instead of `var`. `let` has block scope, instead of the function scope of `var`. And this has nothing at all to do with garbage collection or RAII. 
I'm evaluating hyperapp, could you please tell me how come you don't want to use it, what limitations did you see it having?
it has not much influence on how we will use mongodb in the future. They are only taking their own MongoDB-as-a-Service division public. The money that gets raised with this IPO will ensure that they have enough resources to further develop and maintain the MongoDB software which is a good thing. Mongo is less likely to end up as a dead project like RethinkDB did. 
This looks like a scope issue to me?
Thanks! I missed that :)
Learn SQL for sure. There's a reason it's been around as long as it has and is still widely used today. But I would learn a NoSQL alternative as well and Mongo is popular enough. Once you get the differences of the two approaches you'll have a good idea of when it's best to use each one.
TLDR - MongoDB is Web Scale
I wasn't evaluating frameworks for use, just trying to recall one I saw mentioned here on Reddit a while back. I have no opinions on hyperapp otherwise. 
If you are looking for an IE 11-capable solution, note that IE 11 supports `let` and `const` but does not support for-loop block scoping. If IE support is needed, you should fall back to ES5 methods. The safest is to move this loop to its own function. Ideally, all your code should be written inside functions so you can choose/limit what is exposed to the global scope.
&gt; link is Link was down indeed! [Here](https://gist.github.com/JorgeBucaran/e63a1c7976b63df11f53bfbc1a7f4607) you go. &gt; Is there a way to have an interceptor for http requests like I can do in Vue. ¯\\_(ツ)_/¯ I haven't tried something like that, if you do let me know if it worked! 
`var` declared variables stay alive during the rest of the scope of the function, `let` and `const` have block scope. function varDemo(){ var total = 0 for(var i = 0; i &lt; 10; i++){ var rand = Math.random() total += rand } console.log(total,rand,i) } if you use this function, rand and i still are available and console will log them properly
Fixed with the following code. &lt;script&gt; (function () { function scrollH(e) { e = window.event || e; var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail))); document.getElementById('myDiv').scrollLeft -= (delta * 40); e.preventDefault(); } if (window.addEventListener) { window.addEventListener("mousewheel", scrollH, false); window.addEventListener("DOMMouseScroll", scrollH, false); } else { window.attachEvent("onmousewheel", scrollH); } })(); &lt;/script&gt;
Why not using Babel?
You should use a static analysis tool like [ESLint](https://eslint.org). In your situation rules like [block-scoped-vars](https://eslint.org/docs/rules/block-scoped-var) and [no-shadow](https://eslint.org/docs/rules/no-shadow) seem useful.
the JavaScript on that linked thread is tightly coupled to the HTML element's name "app-player". Look for something similar. 3 years ago, it was very common for major element's in a page to be referenced by id, but it's becoming much less common now with virtual DOM, web components, etc. You may need to find the element by some attribute other than id, reference it positionally from some parent, or even try to delegate events from some parent. It's hard to say, having not looked at the page content.
What you guys think about state machines? I implemented one and took some ideas from redux and redux-saga. https://github.com/krasimir/stent
This is built in to VSCode 1.16. [See here](https://code.visualstudio.com/updates/v1_16#_javascript-and-typescript-refactorings).
&gt; Say a ticket comes in for a browser you’re not explicitly supporting. Thse kind of tickets always seem to be from China.
Explaining JavaScript's features without metaphors was one of my explicit goals when I wrote JavaScript/C++ Rosetta Stone. Feel free to take a look at the closures section. https://github.com/Jeff-Mott-OR/javascript-cpp-rosetta-stone/blob/master/README.md#closures
Noice
This is actually one of the least metaphorical explanations in this entire thread. What you showed is how closures are ultimately implemented. The only change I would make to your comments is that the JavaScript function isn't passed and stores the closure, rather it's passed and stores a scope. Each instance of JavaScriptFunction [is itself the closure](https://www.ecma-international.org/ecma-262/8.0/index.html#sec-function-definitions-runtime-semantics-evaluation). /u/bpdexter85
CanIUse actually lets you import from your own Analytics. Convinced me to deploy grid much earlier due to my hip user base.
Thanks.
for devs eager to drop IE11 support, here's our breakdown for the past 3 months (US, ecommerce, home remodeling). hopefully these metrics help those who work in industries that are not high tech or web centric. We have a healthy mix of tech-savvy DIY homeowners and also contractors who couldn't be bothered to replace that dusty old Compaq that just refuses to give up the ghost. Chrome 41.75% (17.95% Android, 17.85% Windows, 3.43% MacOS, 1.76% iOS) Safari 38.06% (32.50% iOS, 5.50% MacOS) IE11 6.93% Firefox 5.21% Edge 5.02% ... &lt; 1% However, IE11 accounted for 11.10% of revenue. So, even your web traffic metrics can be off by a huge factor when trying to determine the effect on the bottom line. Needless to say, we don't test or support anything in &lt; IE11.
That's so cool
Its hard to tell what your use case is, but JavaScript has function scope, and it also has the concept of IIFEs (Immediately invoked function expressions) - For your example this would be the way to go (function() { var ss = 12; for (var i = 0 ......) { .... } })(); You can jus literally wrap your entire code in a IIFE - you will have to declare anything that you need to be global explicity - window.myVar = 'x'; - so wrapping an existing codebase might take a little work. Other times you'll want to just wrap that code into a regular function expression. var calculateSS = function() { var ss = 12; .... .... return ss; } This 2nd way would still make `calculateSS` global, but it would cut your global footprint down to 1 variable.
Babel doesn't actually solve the exposure of the variable, it just renames it. Without knowing additional details, scoping the variable inside a separate function will actually solve the problem as it is presented, whether ES5 or ES6+ is used. [See for yourself](https://babeljs.io/repl/#?babili=false&amp;browsers=ie%2011&amp;build=&amp;builtIns=false&amp;code_lz=GYewTgBAFANgpgFwgSwgXggBgNwogHggEYcUBqMgSggG8AoCCeJUEdPM47OgXzruQVsQA&amp;debug=false&amp;circleciRepo=&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Ces2016%2Ces2017%2Cenv&amp;prettier=false&amp;targets=&amp;version=6.26.0)
Thanks! I’d love some real world testing and contribution. 
makes sense, that gives me some hope that they won't jump ship and leave us hanging. 
They will develop both in parallel, so you won’t need to upgrade
&gt; If you’re working on a project that has a large IE 10 user base, then support the heck out of IE 10. That’s your job. Errrr, no.
Is this a way to turn methods into stand alone functions?
pack your shit, buddy.
Would I get the same response if the quote had "IE6" in it? Or as the author wrote in another section, Safari 3? Where _do_ you draw the line? Also, what does it mean to "support the shit out of a browser"? Does it need to behave and look the same across all browsers? Are graceful degradations / progressive enhancements not an option? Or does it just have to get the job done? Can you have a separate version of the site just for legacy browsers with a reduced featureset? 
I guess my problem here is that if I don't know what a closure is, I can't really understand this example as it uses the word in the definition. 
if your site generates $0 and you spend $0 on ads, then that line is wherever you decide what your personal time is worth. in ecommerce, that line is very clearly measured in $. if you spend $300/day in ads and those ads bring in even 15% users on IE10, you better have a great story to tell your boss's boss about how annoying it would be to get that extra 15% in revenue that he paid to bring to his site. it is your job - your primary job - to convert as many visitors to customers as is feasible; everything else that does not contribute to this is a distraction. if you refuse to do that because it annoys you, you're worse than useless to the company. a dev that can make a site work well for 97% of browser traffic will command a higher salary than a dev that can do WASM and WebGL foo in 20% of browsers while ignoring the rest. the sooner you internalize this, the sooner you'll be taken seriously. in our case, that line is 1-2% of traffic. thankfully we don't have enough &lt; IE11 users to have to support them anymore (you can see the stats elsewhere in this thread). there was a time when we had to support IE6-8, and it was a fucking nightmare, but you can't do much about what browsers people choose to use. such is the life of a web dev.
Went through this, and this really helps a lot, particularly the second example because I can see how you're essentially creating two different functions from one.
Testing is basically the same no matter what language or framework you use; it’s all about checking if expected = actual result and covering the edge cases. I personally learned a language (js) before getting into testing (which I think is a good way to do it. You should learn how to write code before being worried about how good that code is). I used a free online course called [Software Construction in Java](https://www.edx.org/course/software-construction-java-mitx-6-005-1x), which although it was in Java, the overview it gave of Java was enough for someone experienced in other languages to use. I was able to transfer what it taught me pretty easily to testing frameworks like mocha, chai, jasmine, jest, enzyme, phpunit etc after looking at their respective apis
Benchmarks are available here [https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html](https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html) (gruu-v1.6.12-keyed)
I work in a sector that is notorious for requiring support for browsers that should have died in a fire years ago (Gov't Healthcare). I found that a majority of these websites were ones that were coded to resemble client apps, usually WinForm MDI style crap, which all seem to fall apart when trying to use with Chrome/FF. I've been able to phase out most of these sights by cutting off support to them and replacing them with more modern alternatives, but it seems most of the decision makers in my field are reluctant to change anything and sticks with "what just works" not realizing that what they think "just works" is usually loaded with security vulnerabilities (and also ugly af). I really wish more decision makers would grow a pair and putting the pressure on companies that don't want do refresh their products. I'm sure it's different across the board but when I am absolutely forced to support old browsers, I only make my team code so that the required functionality is there, not aesthetics. We have one major program that had us frozen on IE 10 for several years and just now moved that line to IE 11, but breaks on chrome/ff/edge. Luckily, we are transitioning away from it but it's been pure hell for the last 10 years working with it. Enjoy the horror show: https://youtu.be/MwHrHseZP5g. 
&gt; Would I get the same response if the quote had "IE6" in it? **Yes.** If that is your marketshare it is your job to support it. I suspect you are expecting sympathy. Perhaps a magic tool to solve these problems for you, like jQuery. If you do this job for money I would expect you to be a professional. You sound like a fucking child. Get over yourself. &gt; Can you have a separate version of the site just for legacy browsers with a reduced featureset? No, learn to do your job, apply graceful degradation.
If we're talking about enclosing individual iterator values inside for-loop, [babel does exactly what you've described](https://babeljs.io/repl/#?babili=false&amp;browsers=ie%2011&amp;build=&amp;builtIns=false&amp;code_lz=GYewTgBAFANgpgFwgSwgXggBgNwogHggEYcUBqMgSggG8AoCCAZ0QBVkBbOEAVwSijU0APggBjEADsmIeADoYIAOZRklADTFM2ynQC-dOsgrYgA&amp;debug=false&amp;circleciRepo=&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Ces2016%2Ces2017%2Cenv&amp;prettier=false&amp;targets=&amp;version=6.26.0)
Take a look at https://www.ag-grid.com/ and scroll down until you see a demo like the one you linked
That's a specific case of the loop containing an async action directly. [Otherwise it just changes the names.](https://babeljs.io/repl/#?babili=false&amp;browsers=ie%2011&amp;build=&amp;builtIns=false&amp;code_lz=GYVwdgxgLglg9mABAGzgczQUwE4AoCGAlIgN4BQiiAzplACowC2mcIUuuxAvAHyIQIqcZJgB0qNAUIAaRAEYADEsIBuMgF8yZYHGyJcIqIhiIuiBSuOIAPPIvGA1A-LlKhxPlNWHiAExq3dCw8GFUNLRgnFSA&amp;debug=false&amp;circleciRepo=&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Ces2016%2Ces2017%2Cenv&amp;prettier=false&amp;targets=&amp;version=6.26.0) 
Testing is one of the most grueling things you'll do, but it's one of the greatest. I'm in the midst of writing a library, and writing hundreds of unit tests to simulate the many ways a user might use or abuse a module is really taking it out of me, but should I ever make a tiny change to how a function works, all those tests can run again and I can suit to match the ones that fail. That's the genius behind it. Do it once PROPERLY, never do it again.
I use a Jenkinsfile with a few shell commands to docker-compose up the entire stack. Then there’s a script that waits for the db to become ready before seeding/migrating. It outputs a line from *fortune* each second while it waits, to keep any human log watchers entertained.
but how many ie users were on Macs? /s
Why not just post your problem here, and explain what steps you have tried to solve it?
Yep, always smart to check % revenue that browsers give you if you're working in ecommerce, sometimes those low % browsers have a surprising amount of revenue. I've had the same thing happen with IE 11, lots of revenue from it despite only being about 5% of total users.
But why do you consider renaming an invalid approach to fake the block-scope behavior? Yes, a renamed variable still can be seen within a function block, but Babel just won't let it be accidentally used outside of a loop. And I believe it's also faster, since functions involve some call-stack overhead.
sometimes unusually low numbers can indicate significant UI/UX issues or bugs in those browsers, too.
A piece of advice: It's hard to invest in your own industry because of biases you hold. Analyze the business as a business (including the success or failure of it's products), and not solely on the capabilities or failures of the software (and definitely not on your anecdotal experiences with the products). Most of the comments here are completely biased and not analytical.
I don't even have a discord link to go to and help him...
*Why?*
This is very similar to store methods of CxJS - https://docs.cxjs.io/concepts/store
I worked on a drag &amp; drop dashboard builder - https://github.com/codaxy/dashboards What would you put on your own dashboard?
This is not a library, but if you want to look at GDAX's book, in either a L2 or DOM format - try Medved Trader. We at Medved Trader (www.medvedtrader.com) trading platform have been busy integrating crypto feeds/sites into our software. We connect to lots of brokers and our users requested us to connect to crypto exchanges recently. Right now we connect to Bitfinex, Poloniex and GDAX. Our software connects to those sites for data and does charting, tech indicators, DOM/L2 book, alerts, RT algorithmic scanning etc. Integrating trading/account management for those sites is coming shortly. Try it. 
Ok then basically how do I take 2 strings and alternate every line. For example. var x = " 1 1 1 1" var y = "2 2 2 2" and then what i would want the output to be is 12121212 
google "array compare in javascript" "object compare in js" "value vs reference in js"
Variable declarations are hoisted to the top of the scope. Because all declarations are within the same scope it does overwrite the previous variable. Your concern about overwriting declarations in the global scope does not apply because normally you would at least have part of the code in a function and therefore a different scope than a global variable. 
Testing should go hand in hand with development. It not only improves maintainability of your code, and performance of your apps &amp; components, but also makes you think about the systems you are building differently. It forces unto the developer a more focused, detailed oriented understanding of both your app and code. IMO it's the most underrated skill of a developer. TL;DR - Get on that shit
There are many ways this could be achieved. Assuming both strings are of equal length, this is one way to solve the issue: const alternate = (x, y) =&gt; { let z = `` for (let i = 0; i &lt; x.length; i++) { // z[i] = x[i] // z[++i] = y[i] z += x[i] z += y[i] } return z } Edit: Never write code on a cellphone in the middle of the night
Is there an issue with just setting `overflow-x: scroll` or `overflow-x: auto` in CSS?
I made an animation using numerical modeling of [planetary orbits.](http://qdata.herokuapp.com/orbit) Doesn't play well with mobile yet.
Nice!
Just use D3
No mention of GraphQL in there. 
Yeah /s was just in case ;)
Yes. He wants to hijack common usage and replace the vertical scroll from a scroll wheel and make it be horizontal. It's a bad idea.
I think you want the body of that loop to look like this: z += x[i] z += y[i]
My gut reaction is learning at least one testing framework for JS should be an ASAP priority. You said that you're already familiar with C/C++ and Python and Java, do you use unit tests in any of those languages? If you do, then you're already more than half way there already and it's just reading the docs for a specific framework to get the nitty gritty. 
Yeah, but that properly bit, boy howdy is it a bitch and a half to do. 
it’s a good idea but it’s bad/poor design/UX
Please link the article. I'd be interested to read it.
Hi /u/NameChecksOut27726, For javascript help, please visit /r/LearnJavascript. Thank you!
 let a = '1 1 1 1 1', b = '2 2 2 2 2'; a = a.split(' '), b = b.split(' '); const c = a.map((_, i) =&gt; a[i] + b[i]).join(''); // '1212121212' This assumes both strings are the same length. It could of course be modified to work with different string lengths but that depends on how you want it to respond when that happens.
The original question was (paraphrasing), "how do I prevent this from being exposed outside the loop". The renaming approach does not solve this problem. The Babel solution is a reasonable optimization for a transpiler. Babel operates on code inside functions for the most part, anyway, so there is little to no risk. This request appears to be specific to global (window) context.
Bounce rates and average time on site are good for that too.
yep
you can use something like: var demo = document.getElementById("demo"); demo.textContent = "myText"; 
Care to elaborate?
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#Mark-and-sweep_algorithm
Sure! Calling it an operator isn't really right - it's more of a style/syntactic sugar. Idiomatic Ruby method syntax is a bit weird at first but makes so much sense when you get used to it. There are three main points in the method naming style: methods whose names end in a question mark return a boolean (so basically a yes/no question), methods whose names end in an exclamation mark actually modify the object they're called on, and all the rest return a new object (and don't mutate the original object). So from the Array class for instance you have the `empty?` method which tells you if the array is empty or not, or the `any?` method which tells you if any member of the array satisfies the provided condition. Then you have a method like `map`, which does pretty much the same thing as the JS version (returns a new array derived from the provided array). But there's _also_ `map!`, which replaces the elements of the provided array with the newly derived ones. It's really great for readability - you can tell at a glance what side effects (if any) a piece of code has.
Keep in mind that you're not able to use **fs** package directly in browser.
if you wanna practice TDD, which is arguably part of what it takes to be an ethical coder / programmer (see point 3 of the programmers oath): http://blog.cleancoder.com/uncle-bob/2015/11/18/TheProgrammersOath.html Then yes you need to get some familiarity with testing. As for the practical benefits of understanding / implementing tests, you get extreme quality of work : https://www.youtube.com/watch?v=is41fgDrqn0 &gt; Is this the way to go or should I learn some better and easy testing framework first, because extensive nesting of callback functions and chaining is very confusing. Then you're probably doing it wrong... you should look into promises and async/await.
Looks like you're trying to implement zip then flatten it. 
Good project! I had developed a stringifier once: [string.ify](https://github.com/xpl/string.ify), but it still lacks color support, though it is not so hard to implement it :) I also develop a full-featured logging library, built on top of that: [ololog](https://github.com/xpl/ololog). It has a pluggable architecture, so it can be used with other stringifiers. I've added a docs section referencing your project as an example: [Using with custom stringifier / object printer](https://github.com/xpl/ololog/blob/master/README.md#using-with-custom-stringifier--object-printer) 
Yes!! Been waiting for this :D
You've already *done* the same thing you need to *hint* *hint*. Not being too cheeky, you could just call if(err) done(err); inside your on('error') too.
This library is mostly about what it is not.
PHLEGM is where it is at.
Does Medved Trader provide a single API to access free historical data? Could this data then be exported?
PostgreSQL with the occasional JSONB field has never let me down.
&gt; if(err) done(err); Wow, I had a slight feeling the answer was staring back at me in the face. -- I was originally thinking that `done(err)` function was only for glob to deal with. -- Reasons like this I feel like tutorials don't add enough context in their code, IMHO. Just to stop sleepless idiots like me from asking stupid questions. heh Thank you very much!
Did you really need to include lodash just to use two simple methods? :(
Not all frameworks need to be powerhouses. Providing ways of structuring code is sometimes more important that all the bells and whistles, which is one of idea behind frameworks. All the feedback is welcome
Looks like a pretty cool library. I'm currently using aframe on a VR project but this looks like a decent competitor. On a sidenote, Whitestorm as a name is pretty close the the white nationalist websites "storm front" and "the daily stormer".
And?
Nope, not tired of jQuery.
[Not related to the framework, but this is a highway to santas naughty-list](https://m.imgur.com/a/US4Cn) 
Maybe you don't want your unrelated js framework to sound similar to white nationalist websites. Mr rude person.
Right the limitations of https://www.webpackbin.com/. Apart of that great tool - highly recommended
Well, at least we know who'll be getting coal this christmas...
I honestly think this is as with the react license thing. Too much ado about nothing. By default mongodb is only bound to 127.0.0.1, sure it has no username/password but mysql's root/&lt;&gt; is not a single bit better. Those cases of mongodb 'data breaches' can mostly be traced back to the single flaw of not securing your db when going public. Whoever makes that decision should be fired... always. Mongodb provides very good documentation on what and how to secure your database, read it. The bad rep it gets due to this is mostly from SQL people who are not interested in noSQL solutions, feel threatened and found an easy target.
I can never understand the issue with JQs filesize - if you're using its more than likley pulled from cache or a fast CDN anyway.
As long as you are using CDN and loading jQuery correctly you are 100% percent right, the biggest issue with jQuery is that it lacks modern tooling and clean code writing guidelines. Smaller footprint is a cherry on top
Hey, I don't mean to be rude at all, but are you familiar with the DOM? 
unless i'm mistaken, the browser DOM cant pull files in directly to the browser. You can however use something like node.js and react on the server side. you CAN push text to the DOM with getElementByID or with jquery... but not from an outside file. $('&lt;#htmlIDhere&gt;'.text(chord[i]+ '\n' + lyrics[i]); unless you plan on using node, you could just convert the text file to a json object and embed it in the js file as a variable
Does Strudel have the same browser support as jQuery? On further reading, I don't understand your comparison between jQuery (a client-side utility library) and Strudel (a component framework.)
This guy fucks!
Help me understand what potential issues you see here? Lodash is one of the most dependent on modules on npm and most likely you already have it in dependencies of dependencies. And it’s not a frontend module to care about bundle size.
&gt; On a sidenote, Whitestorm as a name is pretty close the the white nationalist websites "storm front" and "the daily stormer". I don't think that's a common connection to make, I think you need to deliberately dig for controversy for that one. I'm a bit upset about the D3.js library, because D is the 4th character and 3 * 4 + 3 - 4 = 11 = K -&gt; 3K -&gt; KKK... shit, I think I gotta find new library to render graphs with.
i think the main competitor of this framework is [backbone](http://backbonejs.org/).
Thanks! There are many object stringifiers but I couldn’t find any that would prioritize short and readable output that you would need to debug thinks like webpack configs (my use case). 
With polyfills it can have same browser active support as jQuery - bundle size is the same as jQuery then. Although jQuery is a utility library, when you think about plugins and ecosystem around it can be considered as a framework. Strudel tries to leverage jQuery API but untangle the Spaghetti bits and put on top of that modern toolstack consisting of Webpack, Babel and dedicated CLI.
Backbone is more MVC oriented, however the idea of having lightweight structure in place is what these two frameworks have in common.
 for(var x = 0;x&lt;3;x++){ (function() { console.log(x); var ss = 10; }) () } console.log("outside :"+ss);
I'm just seeing a loading spinner.
`document.body.append('hello')` ?
No I agree with you, there are no potential issues with it except the fact that lodash is 100% not needed. I'm going to use this on a tiny AWS lamda function and having an additional dependency for no reason made no sense to me, but that's just 2c.
[removed]
`&lt;title&gt;COMP2406 Assingment 1&lt;/title&gt;` Trying to get a little homework help are we? Try asking your teacher.
Yeah that's because it's real time so you have to wait till a new tweet pop up. Thanks, working on caching tweets for 24hrs so you don't have to wait for a new tweet. 
I think we can replace _.isPlainObject with is-plain-obj and _.get with dlv. Do you want to send a pull request for that?
I got a good laugh at that. Here's to hoping jQuery will finally die out one day.
It's way too slow. You should profile whatever code you're using to pull in tweets. Also, it would be nice to be able to filter by a keyword.
Thank you. Still an early project and I'm experimenting a lot of stuff. Contributions to the code will mean a lot. 
Once Medved Trader collects the data, you can access it by a simple HTTP API while Medved Trader is running (we just copied the old QuoteTracker API for compatibility's sake with some programs): http://medved.net/quotetracker/help/qtserver.shtml it is not enabled by default. You need to enable it yourself, from Settings-&gt;Application Settings. 
Hi /u/madreader121, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (/r/javascript is not a job board).
Sorry man, missed those! Do you know of any subreddits for jobs in development? 
Maybe /r/jobbit? That would be my best guess for a sub that actively solicits job offerings :)
Caching would definitely help. It’s a great idea for an app though. 
Good laugh at what?
&gt; Unfortunately, browser support is not sufficient at the time of this writing. Therefore, we need to make use of short helper function that correspond to the jQuery methods $.addClass(), $.removeClass() and $.hasClass(): So, basically start writing our own jQuery?
The way I explain Closure is, "Functions retain access to the scope they are created in, as long as a reference to them is held." **No Closure** function blackbox() { const greeting = "Hello" // No closure is created here. } const test = blackbox() // undefined **Lost Closure** function blackbox() { const greeting = "Hello" // This function creates a closure in `closureFn` but // it will be lost once the function `blackbox` returns // because the reference will not be held anywhere. function closureFn() {} } const test = blackbox() // undefined **Closure** function blackbox() { const greeting = "Hello" function closureFn() {} // Returning the closure function does not mean that it will // be used or that the reference will be kept in any way but // returning the reference to the closure is a vital step. return closureFn } const test = blackbox() // `closureFn`; with access to `greeting` **Using Closure** function blackbox() { const greeting = "Hello" function closureFn(name) { return `${greeting}, ${name}` } return closureFn } const test = blackbox() const result = test("Josh") // "Hello, Josh" The actual closure is `closureFn` because it "closes over" the scope of `blackbox`^1. Simply creating a closure (function) within a scope creates the closure but doesn't necessarily make it useful. The thing that makes closures so useful is passing them outside of their lexical scope - the scope they were created in - because that is how you create "private" variables. ^1 *- A closure doesn't only close over the scope of the function that it is created within; it retains access to any variables that were in scope at any level of the scope chain when it is created. A closure can be deeply nested in a program and be returned to a more shallow portion of the application and will retain access to all of the nested scopes it was created within; that example will be left to the imagination and experience of the reader.*
Thanks buddy
Yes, it’s called vanillaQuery. It basically does whatever jQuery does, has even the same file size but it has the word “vanilla” in it so it reflects the present times!
This site focuses on visual plugins, so I'll focus on that with this comment. If you're going to use a bunch of visual libraries written in "vanilla js", you're just ending up including a bunch of code in each of them doing the same thing in terms of dom manipulation. I would recommend going for a base library or framework and find plugins for it. Be it jQuery, React, Vue, whatever. There are a bunch of plugins for slideshows, drag&amp;drop, animation effects, form validation within all of them. Why not conform to a standardized way of doing things within your project? What is vanilla anyway? All libraries and plugins offer some sort of abstraction. I appreciate the sentiment though, it is important to have focus on the loading time of our websites. edit: There are a bunch of projects on that site that are hardly their definition of vanilla. Such as [wheelnav](https://plainjs.com/javascript/plugins/wheelnavjs-100/). It is based on a forked version of Raphael, which is a big library in itself. 
Super cool &amp; useful! Turns out currentTarget is always the outermost DOM element...
Snowflakes are white and sometimes part of a storm yet here you are
&gt; lowerer :/
You're trying to execute a server-side script as a client-side script. It won't work in most cases.
 const zipWith = f =&gt; (xs, ys) =&gt; Array(Math.min(xs.length, ys.length)) .fill("") .map ((_, i) =&gt; f (xs[i], ys[i])) const concat = (x, y) =&gt; x + y const str1 = "1 1 1 1 1 1 1 1 1".replace(/ /g, "").split ("") const str2 = " 2 2 2 2 ".replace(/ /g, "").split ("") const res = zipWith (concat) (str1, str2) .join ("")
[removed]
jQuery is great, only a fool would say otherwise.
Thanks for the thorough explanation, not a bad idea at all. 
&gt; Using plain JavaScript will make your applications load and react blazingly fast. Seriously? Using plain JavaScript is no guarantee for anything. Really getting tired of such claims. What are they based on? On the 2 "benchmarks" on vanilla-js.com, where Dojo, Prototype JS, Ext JS, jQuery, YUI and MooTools are compared in a non-reproducible way?
Also, it's a good idea to look at the raw numbers rather than the percentage. I had a meeting at work where someone challenged whether IE should be supported, arguing that the market share was too small (having a 3% market share according to our analytics). We operate globally, so I asked what the actual number was. It turned out it was over 600k users per month, and that was the end of the discussion. 
&gt; The handler mouse has a reference to elem and vice-versa. No. The `mouse` function doesn't have any reference to anything since it's an empty function. Although the `this` object within the `mouse` function points to the element object pointed by `elem`, that element object doesn't reference the `mouse` function in any of its properties. The circular reference is the anonymous function which is assigned to `window.onload`, and the `this` object within the anonymous function. i.e. (main context): `window` -&gt; (anonymous function) === `window.onload` (anonymous function): `this` === `window` Or: `window` -&gt; (anonymous function) -&gt; `window`
Made a pull request, thanks for being so open!
reminds me of https://www.youtube.com/watch?v=mAvSoNUgMno&amp;feature=youtu.be&amp;t=83 also, isn't most of what uber delivers is its mobile app? are you guys rolling out a mobile site with feature parity? what's difficult to maintain for IE in terms of a few landing pages? i remember very clearly not wanting to download an app that would always be running in the background and doing who-knows-what. turns out my concerns were very valid [1], but there was no way to use uber via a mobile site, at all. there's nothing fundamentally difficult that i can see about implementing uber as a web-app - especially with service workers now. [1] http://www.npr.org/sections/alltechconsidered/2016/12/01/503985473/uber-now-tracks-passengers-locations-even-after-theyre-dropped-off
Basically. But there's one major difference, which is that these methods return plain old DOM structures (like NodeList). To quote [this article that's been making the rounds lately](https://css-tricks.com/now-ever-might-not-need-jquery/): &gt; Rather than smoothing over only the remaining ugly parts of certain browser API's, jQuery seeks to replace them all wholesale. By returning a jQuery object rather than a NodeList, built-in browser methods are essentially off limits, meaning you're locked into the jQuery way of doing everything. For beginners, what once made front-end scripting approachable is now a hindrance, as it essentially means there are two duplicate ways of doing everything. If you want to read others code with ease and apply to both jobs that require vanilla JS and jobs that require jQuery, you have twice as much to learn. There are, however, libraries that have adopted an API that will be reassuringly familiar to jQuery addicts, but that return a NodeList rather than an object... 
Are you running this on a web server or are you opening the file in your browser? You will need to be running through a web server if you aren't. If you're unfamiliar with how to run a web server there are Apache one-click-installers such as XXAMP (windows) and MAMP (macos) you can use. 
Didn't think I'd be seeing these words together in 2017. jQuery _was_ great, but the landscape around it has changed.
You can still access the underlying DOM nodes from a jQuery object, so built-in browser methods are not off limits. 
Lol Ext JS. 
But of course...
ok, thank you. I will try XXAMP
We do have a mobile web app (m.uber.com), which is actually what I was talking about. We also have other products that see a higher percentage of web-based usage, such as eats and u4b, though I don't have the exact numbers for those off-hand.
cool. would be a lot more useful to be able to filter by https://en.wikipedia.org/wiki/List_of_primary_statistical_areas_of_the_United_States and possibly custom tech terms like 'javascript', 'rfid', 'ml'
Thanks, Working on that. Your contributions to the code base are also welcome. 
Thanks for checking out! Those were really important considerations in writing this, so it's awesome that it didn't go unnoticed. Hopefully, you see something useful (or terrible that gives you a better idea) in Whitelister. I look forward to checking your work out!
It's called a fluent API and it results in very nice code. And you can access the DOM nodes by using the index operator on your resulting object. I don't use jQ anymore, but I've never understood this criticism of it.
I'm surprised there isn't some sort of converter made already where you run it on code that has JQuery in it and it converts it to plain-dom code.
While TheNumberOneCulprit's solution is more than sufficient I think it's worth discussing the possibility of simplifying the paradigm flow. Instead of going from callback -&gt; stream -&gt; events -&gt; stream it could be refactored to stay mostly in the stream paradigm from start to finish. Unfortunately a meeting swiftly approaches preventing me from fully testing it but I hope this at least illustrates the possibility: https://ghostbin.com/paste/qqs6a Lastly, should you find yourself motivated to explore the idea further you could use an FRP-inspired library like HighlandJS and eliminate event-stream, buffer, gulpif, and rename dependencies using simpler stream transform functions.
This site (and especially the site it links to, vanilla-js.com) is a joke, right? &gt; lower**er** speed of jQuery &amp;nbsp; &gt; Final size: 0 bytes uncompressed, 25 bytes gzipped. I get that this site is intended to guide someone who's been using jQuery as a crutch into using plain JavaScript functionality (and providing plugins that have no other dependencies), but it feels very low-effort.
Such a solution using highland would look something like this: https://ghostbin.com/paste/p4nz5
I tried this with a trackpad and it had *exceptionally* bizarre behavior.
on DOM ready
Pretty cool, but would be nice if the readme had better instructions on how to run this locally. Want to load different source art 
Hey there! Thanks for the feedback. The way this works is, one has to train a new neural network model for each "Style" image and upload it to the server. Each model takes about 6+ hours to train on a powerful (relatively) GPU. But yes, I'll be adding README instructions for running this locally. Thanks!
That would be awesome, thank you! Great work btw. Instructions for both running the demo locally and also training new images would be fantastic. I'm having trouble even running it locally with the pre-trained images :/
I am irrationally bothered by the tweets not center aligning with the header. Usability wise, instead of just filtering by the word "hiring" you should be able to type something in and receive those results.
There should be a file picker somewhere. #a11y
Anyone else getting an invalid SSL cert?
Except NodeLists suck because they're just array-like enough to trick you into thinking they're an array object. Honestly, why not just return an array? edit: I googled it, a NodeList is "live" and updates with the page
Nifty. Nice slide show.
I've added dev instructions! Let me know if you have any problems.
/r/learnjavascript
Correction: asynchronous ≠ concurrent. Even if you use async functions, everything still happens in a single thread.
I do not think you understand what you are talking about...
Just when I thought I know enough. Something else comes along the way to make life slightly easier. :) thanks guys! I'll definitely add it to the stack.
Very cool! Any plans for a command line tool? 
Alright. Thank you for the feedback. Contributions are welcome in the code base.
Hard to know exactly how this should work (or if it will) without access to the page, but assuming two elements with those ids, something like this should work: $(function(){$("#PDI_answer45015958).click();$("#pd-vote-button9835617).click();setTimeout(function(){location.reload();},500)}) 
ill check if it works when i get back to my pc
This is a __javascript__ forum not __java__. And there is no loop in that code. You should really look for some beginner resources, eg buy a book "how to program". Language doesn't matter.
Yeah looks like it's looking for a JSON result but getting HTML. Maybe a 404? The only relevant clue I can see is "Closed Sales Orders" which you probably saw, too
Yep - I found the part of the code that initializes the div and prints "Closed Sales Orders", but it looks like there is something elsewhere that actually adds data to that div. There are no 404 or other errors - it's 200 all the way through the page load. I wish it was a HTTP error code...those I could troubleshoot :P
Error on slide 31 that I would have made a couple days ago. coinFlip.then(...){...} coinFlip.catch(...){...} Will produce a uncaught warning in native promises and bluebird promises. This works: coinFlip.then(...){...} .catch(...){...} The reason is that multiple then/catch off the same promise will 'fork' and result in the first then() having no following catch. Even though there's a warning it will still appear to be working as intended.
Hi /u/blista9798, For javascript help, please visit /r/LearnJavascript. Thank you!
Let me blow your mind: jQuery is vanilla javascript.
[removed]
Concurrency is not parallelism. The example in the slides does not demonstrate parallel threads, but yes it *does* demonstrate concurrency: - https://en.wikipedia.org/wiki/Concurrency_(computer_science)
Good catch, thanks for pointing this out!
Async IS concurrent. It isn't *parallel*. https://m.youtube.com/watch?v=cN_DpYBzKso
blockchain, blockchain, blockchain.
I think it's broken. https://twitter.com/mikeal/status/911690646913654784
We are at a point where transpiling a Stage 0 feature is more accepted than just using jQuery.
From a quick Google search I found [this](https://stackoverflow.com/questions/10585029/parse-a-html-string-with-js) simple answer. Did you try Googling your question?
Suits them
It's unfair to compare js and python but only include cumbersome error handling code in the js example, particularly if you're going to unnecessarily catch errors from your request() call. Doing so only proves that inelegant code that does more results in more lines of inelegant code. It's true that continuation-passing style callbacks may result in spaghetti, but one of the goals behind chainable promise callbacks was to flatten out these pyramids of doom. So long as you're using arrow functions or named functions defined elsewhere, chained promise callbacks can be a great way of declaratively composing asynchronous code and synchronous transformations while avoiding lots of temporary variables (`contents`, `data`, `res`, `body`, `matches`, etc.) that a reader must keep track of in their head if they opt for the more imperative async/await approach. I realise that this is an intentionally opinionated slideshow but I disagree that "modern JS should read like python". Python is a great programming language but that doesn't mean that javascript code that looks like python code is inherently good code. As you note, the languages have their own strengths and weaknesses - javascript's arrow function makes writing short, reusable, quick-to-read inline functions much easier than python's bulkier syntax; javascript isn't strongly typed and its error handling is horrible in comparison to python's type matching (`catch IOError`, `catch KeyboardInterrupt`, etc.) so I'd hope any emergent *idiomatic* javascript style would take those factors into account. For these reasons I find promises (or, even better, [Futures](https://github.com/fluture-js/Fluture) ) to be a much more natural fit for javascript.
It's worth noting though that the result of querySelectorAll is not live. And let's be honest, when was the last time any of us used document.getElementsByClassName() ?
If you want something like Redux but without the overhead, have a look here: https://medium.com/@albertg/removing-the-overhead-of-redux-b95fbe55784e
So NodeList is completely pointless.
It's a joke.
Yes, there is literally no point to a NodeList.
One of the benefits of Redux is that a single action doesn't have to correspond to a single reducer. Multiple reducers can handle the dispatched action.
Have a look at svelte.
Ah, I get it. You are saying: each async function consists of one or more pieces (delineated by `await`). The pieces are not executed concurrently. But async functions are – their pieces are interleaved. 
I’ve seen many definitions of concurrency vs. parallelism. The ones I liked best were: * Concurrency: more than one task makes progress (e.g. via interleaving or via parallelism). * Parallelism: more than one task is executed simultaneously. I found Pike’s definitions a bit confusing, but YMMV. But even with these definitions, async functions can indeed be seen as executing concurrently with other async functions.
I disagree. The error handling in the JS function is required (since the other options are either throwing or ignoring in a callback, both of which are system-breaking). Error handling in the Python function is not required (since errors can be caught outside of it). In the equivalent JS program (seen at the end), errors are also bubbled up - exactly as in Python.
Hmm, have you heard of Redux-Ducks? No need for constant. I showed an example in this article: https://blog.matters.tech/10-redux-tips-from-the-trenches-55e06ed1c0a8 I never heard of actionFactory, what is the difference with an actionCreator? Those are already well tooled and supported out of the box by react-redux. 
It's hard to get an exact idea what is going on just from the stack trace, but it looks like you are on the right track. The error you are seeing is most likely because the `fromJson` function in Dojo is trying to parse a non JSON object. It could be a 404, but I've seen similar errors at my job caused by 502s. I think the next step is to isolate what data is being parsed. According to this (https://dojotoolkit.org/reference-guide/1.7/dojo/fromJson.html) it seems as if `dojo.fromJson` can be called on it's own, or it can be called under the hood while using `dojo.xhrGet` or `require` if they are called with the `handleAs:"json"`option. Since it seems like the issue is that an error page is trying to be parsed, I would guess it's a url in an `xhrGet` function in the code. Search the code base and confirm that any urls called by that function are actually working. Since you mentioned that this is working on one server and not another, I'd ssh into the broken server and try to curl the urls from there. It could be a firewall issue, or maybe data is being requested from a local file that isn't on the second server. Again it's hard to tell with the info you provided. If that doesn't work look into the `require`s and the `fromJson`s next. Again, I'd be looking at where the data is coming from, not the actual code itself. I've run into similar errors about trying to parse the `&lt;` character and it's almost always a network or server issue.
I used ExtJS as it was part of Day Communique (now Adobe AEM) and loved it and the way it worked with Communique and the unstructured Java Content Repository. There were a few tricks to work around here and there that made it extremely frustrating, but once those were handled it was a solid framework / application that could do just about anything. When Adobe bought Communique I was really surprised that Adobe also didn't buy Sencha considering the two products worked hand-in-hand with each other and that Flash was already dying at the point. (Maybe Adobe still hoped Apple would cave on Flash?) In hindsight, I think Sencha could have been another Ephox (owners of TinyMCE) and become not just owners but stewards of a good product and offered commercial solutions and plugins on top of it while allowing the basic framework for free.
Seriously, I liked ExtJS, but it's not a library. It's a powerful kitchen sink with a garbage disposal that could grind up a car.
Looks promising. Can it collect errors, and does it differentiate early errors from regular errors? Also, does it implement Annex B?
This author should have put more effort into distinguishing the differences between node and npm, it's a subtle, but important detail, at one point they even attributed a quote to a node developer that was actually said by npm developer Kat Maruchan. Just like the left pad incident, this is sure to just blow over and be forgotten about in the not too distant future, but if you think that the racist and pro terrorist tweets of the npm CEO are going a little too far, the best thing to do is email or tweet [npm's investors](https://www.crunchbase.com/organization/npm/investors) and let them know that you don't feel like npm is being lead in a positive direction.
jQuery is good if you limit its purpose to being a helper library. The second you start building DOM manipulating plugins and applications on top of it is where the trouble begins. (now with that it's possible that another library would be better, but if your company already uses jQuery and not something else, well there you go)
I'm not so sure the difference between a programming language interpreter and a package manager is what I would call subtle, but people do mix the two up frustratingly often. My boss likes to rant about Node when he's complaining about something npm did (usually path lengths, or something that isn't really npm's fault like the number of dependencies a package has). He more or less refuses to accept that they are not the same thing.
&gt; this is sure to just blow over and be forgotten about I'm not so sure. This topic is larger than the programming community these days. 
That didn't take long..
Sorry if I wasn't clear - one of my points was that once errors have bubbled up you can't elegantly match the error subclasses or groups of error by superclass without painfully introspecting the error object because javascript lacks the syntactic sugar to do so and, even if it didn't, there are no consistent standards or idioms for classifying errors produced by javascript libraries. One widely understood risk with exceptions is that by bubbling up the stack to unknown places you end up with control flow that is more difficult to reason about, and a less clear contract to program to. Unlike javascript, python has language features and a consistent standard library to solve these inherent problems. In lieu of these things, javascript's promises explicitly model that implicit control flow (success branch, failure branch) but without jumping around the stack. You achieve the same thing but with a clearer contract for composing these units of control flow together and handling the failure branch intentionally (rather than at any point in the stack that happens to contain a catch block).
The difference is that 80 per cent of your visitors will download nothing!
The thing I absolutely LOVED about ExtJS was how well documented the source code was. If I had a problem I could always count on checking out the source and having no trouble figuring out what was going on in very short order. 
What is your end goal? Are you asking about how to parse the returned data or how to display your results?
I haven't worked with ExtJS for several years now, but to this day I still refer people to their documentation as an example of how it should be done.
I was looking at ExtJS in late 2009, but opted to get into AngularJS instead. Didn't avoid an end of the line moment, though, did I?!
Yes. This. I had big dreams of using their doc engine on other projects and publishing open source docs for other libraries with it. But sadly never got around to it. Docs have gotten marginally better, but I hate that almost every library or platform has it's own doc format and there is no standardization.
You know I don't use this kind of language usually, I find it superficial and immature, but yet it's so strangely fitting here, so I need to ask... ***will this endless circlejerk of butt-hurt snowflakes ever end?*** Stop whining on Twitter and on blogs about who said what and who tweeted what. - Do you like Node/NPM? Use it. - Don't like it? Don't use it. - If you want to inform other people of reasons to use it or not use it, use *technical argumentation*, instead of going through everyone's dirty underwear and trash bins looking for reasons to justify your irrational obsessions.
Yeah I did. I'm not too well versed in Javascript but since I'm not working with any actual HTML or using jQuery I don't know how to parse the HTML into a variable using document.createElement() or innerHTML() methods.
This is a React-specific library so it may not be of use but I quite liked working with Interweave for things like you described. https://www.npmjs.com/package/interweave Edit- I read the post again and maybe I misunderstood what you wanted to do. Leaving my original answer just in case. 
 function getText(str) { const wrapper = document.createElement('div'); wrapper.innerHTML = str; return wrapper.innerText; } So if you do: getText("&lt;p&gt;&lt;span class='set-label'&gt;Set 1&lt;/span&gt;: &lt;a href='http://phish.net/song/tube' class='setlist-song'&gt;Tube&lt;/a&gt; &gt; &lt;a href='http://phish.net/song/runaway-jim' class='setlist-song'&gt;Runaway Jim&lt;/a&gt;, &lt;a href='http://phish.net/song/ya-mar' class='setlist-song'&gt;Ya Mar&lt;/a&gt;, &lt;a href='http://phish.net/song/horn' class='setlist-song'&gt;Horn&lt;/a&gt;, &lt;a title=\"Nice extended jam that has a very quiet mid section, a great peak, and strong playing by Trey.\" href='http://phish.net/song/limb-by-limb' class='setlist-song'&gt;Limb By Limb&lt;/a&gt;, &lt;a href='http://phish.net/song/on-your-way-down' class='setlist-song'&gt;On Your Way Down&lt;/a&gt;, &lt;a href='http://phish.net/song/sleeping-monkey' class='setlist-song'&gt;Sleeping Monkey&lt;/a&gt; &gt; &lt;a href='http://phish.net/song/wilson' class='setlist-song'&gt;Wilson&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span class='set-label'&gt;Set 2&lt;/span&gt;: &lt;a href='http://phish.net/song/nicu' class='setlist-song'&gt;NICU&lt;/a&gt; -&gt; &lt;a href='http://phish.net/song/david-bowie' class='setlist-song'&gt;David Bowie&lt;/a&gt;, &lt;a href='http://phish.net/song/the-squirming-coil' class='setlist-song'&gt;The Squirming Coil&lt;/a&gt; &gt; &lt;a title=\"&amp;quot;Caspian&amp;quot; seems to reflect the band's musical direction and style at any moment in time more than most songs. This version, like 7/31/99, gives a broad sense of that tone and technique in the late pre-Hiatus period. &gt; to &amp;quot;R&amp;R.&amp;quot; \" href='http://phish.net/song/prince-caspian' class='setlist-song'&gt;Prince Caspian&lt;/a&gt; &gt; &lt;a href='http://phish.net/song/rock-and-roll' class='setlist-song'&gt;Rock and Roll&lt;/a&gt; &gt; &lt;a title=\"The Borg lands and brings along some dance party, space beats. One of the biggest &amp;quot;2001&amp;quot; grooves culminates with one of Trey's great funk riffs with about 2:00 left.\" href='http://phish.net/song/also-sprach-zarathustra' class='setlist-song'&gt;Also Sprach Zarathustra&lt;/a&gt; &gt; &lt;a href='http://phish.net/song/frankenstein' class='setlist-song'&gt;Frankenstein&lt;/a&gt; &gt; &lt;a href='http://phish.net/song/julius' class='setlist-song'&gt;Julius&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span class='set-label'&gt;Encore&lt;/span&gt;: &lt;a href='http://phish.net/song/character-zero' class='setlist-song'&gt;Character Zero&lt;/a&gt;"); You get: "Set 1: Tube &gt; Runaway Jim, Ya Mar, Horn, Limb By Limb, On Your Way Down, Sleeping Monkey &gt; WilsonSet 2: NICU -&gt; David Bowie, The Squirming Coil &gt; Prince Caspian &gt; Rock and Roll &gt; Also Sprach Zarathustra &gt; Frankenstein &gt; JuliusEncore: Character Zero" EDIT: Nvm, just saw that you need this to work server side. You can do the same thing, but using something like [jsdom](https://www.npmjs.com/package/jsdom) to help you build the dom.
2 projects I would recommend (imo, other people may not like what they do): https://github.com/ng-bootstrap/ng-bootstrap https://github.com/trailsjs/trails
How do I access the document object if I'm not working with any kind of HTML? I'm writing this script on script.google.com and deploying it as a web app that responds to events in GroupMe.
Ext 3 was useful. By the time 4 came out the js file was over 1MB which made it unrealistic to use. I wasn't gunna deal with importing just the components I wanted to use. I switched to jquery and made my own grid component. 
how much could these possibly mine? 
i don't see why people use angular. It just complicates things. Why not just use jquery and the DOM for everything?
Damn, you're working in a pretty specific environment. Looks like a lot of things I can think of to make this easy aren't supported there. Sorry I can't help you out right now. You could do something like this, but the markup you're working with makes this bug out. function parse(str) { return str.replace(/&lt;[^&gt;]+&gt;/g, '') } You could improve on the regex, though. EDIT: Just google something like 'javascript regex remove HTML' until you find something that works. The fact some of your HTML tags have the character `&gt;` in their attributes is a big pain in the ol' 🐝hind.
Both the CEO and the CTO of npm are seriously disturbed, unstable, extremist and hateful. Node is ok. Recently a few morons of similar ilk self culled. From the CEO of npmjs: https://imgur.com/a/2kD4O https://www.reddit.com/r/node/comments/71snxa/npm_ceo_if_you_are_not_a_white_dude_and_have/ You should indeed email their investors: https://www.crunchbase.com/organization/npm/investors
Your single example is a hell of a lot more complex than a jquery selector
If not because of this, their CoC bullshit is pushing me away harder.
Because jquery is a library, not a framework. In the early 2000s that's exactly what people did and the frontend code based looked like shit because jquery was a bunch of helper functions. If I'm building a large scale app I'd pick literally any framework over jquery and vanilla. The more complex the app, the more you're going to end up building a shitty framework anyway.
Thanks for your input. Greatly appreciated!
&gt; We have created what is beyond doubt the most capable, fully featured, technically accomplished, most productive JavaScript framework out there. The competitors are all lacking. Their examples are faked, hardcoded, contrived, complex and buggy. Yeah as long as it's 2006 that's true. Unfortunately the constant license changes fractured the community and most of them found solace in Angular and React. Bad business decisions destroyed the product and better frameworks and libraries replaced ExtJS a long time ago.
I dunno how well you know regex, but the problem you have on your hands is well suited for learning it. It's always nice to have someone around that knows it really well, cause it's a pretty powerful tool. On the flipside, there is this classic quote: &gt; Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems. That said, I think regex is pretty cool, and it would solve your issue here. If you need a place to start, look at [RegExr](https://regexr.com/).
To be fair, I think the world has moved onto stage-3 now (which is the appropriate stage to try, since stage-3 means it will get browser support soon). It's getting better :)
Jack shit. But hey, it's jack shit more than the perps had before and it's free money for them.
I never liked ExtJS. It looked like windows.
xcdk
most code looks like shit no matter which library or framework you use.
No, not really. Stick to idiomatic design and code can be perfectly clean.
To be fair, CBS has a few million users. "Jack shit" multiplied a few million times is more than just jack shit. To quote Depeche Mode: "Everything counts, in large amounts."
nobody even knows what that is in the real world.
&gt; If not because of this, their CoC bullshit is pushing me away harder. This has nothing to do with CoC.
Fair point.
I can recommend some of the ones I developed: * [js-cookie](https://github.com/js-cookie/js-cookie/tree/82860ea5d2333a469eae7f53516478fdbd708354/test) * [Brazilian Nail Style](https://github.com/FagnerMartinsBrack/brazilian-nail-style/blob/775b895b5eed227df539a81dc62272c35ee1e485/calculate-job-cost/src/web/nail-cost-for.spec.js): TDD I used in a personal prototype project for a friend of mine. This one I went really strict using the **Transformation Priority Premise** and finding the TDD boundaries in order to uncover the pricing pattern.
It was probably someone sitting on a backdoor or 0day until they could figure out how to make money off it without exposing themselves. 
pennies. seriously the years it would take to mine a single btc with js is in millions.
Wow fuck this guy. I'm emailing.
Shouldn't be that much slower than a CPU miner. Less than an order of magnitude, I'd bet.
Chrome has gotten scarily efficient lately. It's around 3x less efficient than .NET at this point, and 10x less efficient than C++. It's more than pennies. You'd be surprised.
I work at a Big 4 and we have large products with extremely clean code. The world rarely works in absolutes.
Big4 is no way reflective of the real world though. Every place I've worked at the code has been absolute shit. Enterprise or startup, makes no difference. When we do a rewrite its good for about 6 months until new hat take over and fuck it up.
Thank you, good sir.
Check out the [Fisher-Yates Shuffle](https://en.m.wikipedia.org/wiki/Fisher–Yates_shuffle) algorithm! Edit: i kept trying to link but its not showing up as clickable. https://en.m.wikipedia.org/wiki/Fisher–Yates_shuffle
No, the CoC issue just adds to the reasons one might choose another package manager.
I saw one using wasm last week. That should be &lt; 2x native speed so there could be something to it.
Arrr, there be no taxes while sailing the high seas.
Hi. Error tracking is on my TODO. I ran out of time ATM, but it should handle errors and early errors. One of my ideas for error tracking is that you should collect errors so it can be used in editors like VIM without an issue. So when I get time to do this there will be added several options for error tracking. One of them would be if you want to group them as you mentioned into early errors etc. Annex B is fully supported yes except for Annex B.1.1 wich will take 1 - 2 minutes to implement. Just use a global bitmask for it.
The text is not suggesting to use another package manager.
npm is a package manager / repository. jQuery is a dom manip lib. just because both have been liberally overused (and often mis-used) only speaks to their popularity. anything that's hugely popular and is user-tinkerable and uncurated will end up with a few gems buried in mountains of trash. if anything, React is the new jQuery. i'm fairly certain there exist hundreds of React components that do nothing more than wrap some trivial 15 lines of code, too. here's a popular one that simply wraps CodeMirror [1] with tons of neglected issues [2] and 142k downloads last month [3]. here's another one for creating emojis [4]. the only thing it needs React for is to internally call `React.createElement` because apparently devs can't be bothered to write the `&lt;img src={emojify(":)")}&gt;` or whatever. if i wrote a `react-left-pad` wrapper for `left-pad`, hundreds to thousands of sheep devs would switch to it because "it's left-pad designed for React", especially if i made a hip bootstrap site and logo for it. [1] https://github.com/JedWatson/react-codemirror/blob/master/src/Codemirror.js [2] https://github.com/JedWatson/react-codemirror/issues [3] https://www.npmjs.com/package/react-codemirror [4] https://github.com/banyan/react-emoji/blob/master/src/react-emoji.js
They are mining Monero not bitcoin, which is much more profitable. It is actually feasible to mine a large amount with CPU/GPU's.
Crypto mining is like searching out golden tickets. JS miners might be much slower but they're still part of the search; the total hashpower is what matters. It's like using a mining pool, except whereas those split the profits among members of the pool, any blocks mined by this would go to the person running the JS.
TPB also had a miner on their site so... yarr, you be a miner now.
cpu mining is a joke... edit: y'all need to read up on crypto mining...
Maybe it's a joke if one person wants to use their own PC's CPU to mine, but we're talking about millions of people are spending prolonged amounts of time on a streaming site while a miner is running in the background. At that scale it will accumulate a lot of money.
It's mining Monero, where CPU mining is viable. See: https://coin-hive.com/#hash-rate (this is what they're using)
SSL cert is fine for me but 'Tweet Image' 500s
Jq and the dom are fine for small websites, but anything that goes larger will become [very complicated](https://pbs.twimg.com/media/C7eEVWJVUAA8era.jpg:large). There is no system behind it, state is loosely dumped into dom nodes as classnames and such, conditional reading and writing becomes a major hassle ridden with exceptions and wires thrown throughout the application. A framework gives you a clearcut component in which a part of the application is fully represented. Could be a presentational component like a button, or a logical component like the bar that attaches tasks to a row of buttons. It makes it easier to create applications. On the other hand, Angular is probably a not-so-good example for it, i still find it pretty hard to be honest. It still is easier in the long-term than jq/manual dom.
Things you have to do when building a large app with jQuery: * Create UI * Create functions that manipulate data * Create functions that manipulate UI based on functions that manipulate data Things you have to do when using React: * Create UI * Create functions that manipulate data The remove of the third line-item means that a) you spend less time getting things to render correctly, and b) each subsequent addition to the application doesn't rapidly increase the complexity. 
this guy should be locked up in a room without handles, fucking psychopath 
Maybe faster using asm (think only on Firefox) and/or web assembly which enjoys broader support so would be more likely candidate
YOU ARE A PIRATE! LOL LIMEWIRE
public trackers?... that's rookie stuff buddy
They're not mining BTC but XMR 
i just doubt it
all i hear is OPs personal frustrations 
Author is insane. Everyone I know, including me hates extjs because of very slow development. Companies wasted big amount of money on it,
I use getElementsByClassName pretty frequently when writing browser extensions to inject into other pages. It's extremely useful when the page wasn't designed for you to manipulate.
That's a horrible number. Java's a factor of 1.2-2.5 behind C, often equal to C++, and the CLR and V8 are both that slow? That's horrible
I suppose it may be easier to find an open source cloud storage app on Github and draw inspiration from it than to find tutorial about it ;) 
I love when somebody knows that bitcoin isn't generally profitable to mine yet doesn't know that other cryptocurrencies exist
&gt; will this endless circlejerk of butt-hurt snowflakes ever end? Let's hope so. More interesting code, less of everything else please. &gt; Do you like Node/NPM? Use it. &gt; Don't like it? Don't use it. I think OP likes Node/NPM but doesn't care for what he perceives as alienating and unwelcoming rhetoric coming from their leadership which he feels alienates members of the community to which he belongs. That was pretty clear for me after reading the article. I'm not sure where he said or even implied he liked or disliked Node or NPM. Personally, I really couldn't give even a fraction of a fuck what the employees of NPM say on twitter. They're well within their rights to say what they damn well please; the perhaps startling corollary to this is that these same rights also extend to the author of this article. I just thought I'd point out that you seem to have misunderstood the purpose of the article. 
I agree with that, but I almost never use that. And in Reless I can do that just by calling multiple reducers with the same payload in sync
the Bitcoin is the measure of all alts, pleb
So the guy wants to kill nazis. That isn't a crazy impulse. Nazis are terrible shitty people. I don't agree with the impulse, but I understand it. It is the impulse of a child, someone who hasn't taken the consequences of the policy they wish to adopt to its logical end. Little kids would eat themselves into a diabetic coma if left unsupervised, but that doesn't mean I don't understand the impulse to eat candy for dinner. I look at this guy as simply someone who does not bring his critical faculties to bear upon his own beliefs. He's allowed to hold batshit crazy beliefs, we all do. I'm not going to say the guy should lose his job for it any more than I'd say that James Damoore should have lost his. I'd rather not engage in or support witch hunts, regardless of the target. Do I think he should be CEO of a company? Depends on if his fetish for killing Nazis impacts the quarterly reports. It's at the discretion of the board to decide if they want someone with this particular fetish in charge, and quite it's frankly none of my business.
Great article! Thanks for sharing
That's cool, but it still has nothing to do with that happened to the CBS website
mind=blown. And here I was, thinking all this time that jQuery was written in jQuery. 
There are services that let you run these js scripts in the same way you would run ads. Difference is you are not paying with attention, but with cpu power. Coinhive is the one they are probably using. I think the profits are comparable to running ads. I think its brilliant, and am definately going to give it a try on my next site.
I find I use it frequently. If your actions are about setting particular data rather than about the semantics changes to state then it's difficult to reuse them (consider, `setIsLoggedIn` vs `loggedIn`: the latter could be picked up by other reducers whereas the former clearly says what it thinks should happen). Calling multiple reducers at once isn't an acceptable solution as well unless you're only firing an action from a single location because otherwise it is difficult to ensure that you're always calling the right set of reducers and are not forgetting to call one.
Eh, maybe not now, but it looks like the mining script they may have been using uses Web Workers, so depending on the browser limits for available threads they might have upwards of 20 threads per user and device. Assuming most devices are crap, lets say that 1000 users offer two threads per user, and you might have a small profit. If each CBS user is running two threads just for mining, and there's a million users, that's upwards of 2 million threads for mining.
that's actually really interesting. 
\&gt;what do you mean kilometers/hour?? this is measured in miles/hour! 
Afaik, js can be just 2x less efficient than c++. https://kripken.github.io/mloc_emscripten_talk/cppcon.html#/26
That's not really JS though. That's more like IR (intermediate representation) that's optimised for AOT compilation. It uses JavaScript syntax for backward compatibility. 
yes, here https://golang.org/doc/
The difference here is that D3 shares 0 characters, let alone words, with the KKK. Whitestorm shares a word with StormFront and the DailyStormer, the word is Storm if you can't tell. What doesn't help is that StormFront and DailyStormer both advocate for ***White*** Supremacy, and WhiteStorm has the word White in it.
I would recommend you go learn a little about HTML. This will make things much clearer to you, and will provide you with a lot more info that people here on the subreddit can explain you in a reasonable timeframe.
can somebody explain, why you'd ever want to share an *image* of sourcecode instead of the sourcecode itself? 
This is the best tl;dr I could make, [original](https://www.theregister.co.uk/2017/09/25/showtime_hit_with_coinmining_script/) reduced by 90%. (I'm a bot) ***** &gt; The websites of US telly giant CBS&amp;#039;s Showtime contained JavaScript that secretly commandeered viewers&amp;#039; web browsers over the weekend to mine cryptocurrency. &gt; Coin Hive&amp;#039;s mining code was at the center of some attention last week when file-sharing search engine The Pirate Bay admitted it had added the coin-gathering JavaScript on its pages in order to test its profitability in an effort to get rid of ads on its site. &gt; Code Hive not only offers in-page mining but also mining through URL shorters and CAPTCHAs. ***** [**Extended Summary**](http://np.reddit.com/r/autotldr/comments/72j2aw/cbss_showtime_caught_mining_cryptocoins_in/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ "Version 1.65, ~216649 tl;drs so far.") | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr "PM's and comments are monitored, constructive feedback is welcome.") | *Top* *keywords*: **code**^#1 **website**^#2 **mine**^#3 **Hive**^#4 **script**^#5
Basically if there is a way to only display the text that the enduser is seeing on the frontend and if thats not possible how do i parse the data?
It is still js. And a coin miner would likely use amsj. 
💩 
I think you need to read up on mining beyond just btc mining. 
Who cares what you doubt... There are articles out there that talk about this. Don't doubt, go get educated and make your mind up after. 
Yeah sorry I didn't include the css that goes with the divs. 
Hi everybody and thanks for the introduction /u/kenman ! I'm stoked to be helping out on the subreddit and I'm looking forward to seeing the community evolve :)
Looks excellent Here is a quick harness for it: https://sequential.js.org/live.html#DYewhgJgFA5AFgFwQBwM4C4D0mDGEB2AdAE5gDuA5gJYKE4gC2ucApsSGc2x5hGAAwA2MGABMo3lVQIu7MoQZUiAK1QwAlAG4AUPXyoQwFoVAUoOVnMLIwxVCwDKOYlWQJYVALwBGUQGZNDS0gA 
Or someone modified an npm package to include this, and it got pushed to a bunch of other sites as well.
This is probably not exactly what you're looking for. But I have this node file manager running on a raspberry pi, so I can upload and download files to my home NAS when I'm away from home. https://github.com/efeiefei/node-file-manager I had to modify it to add password protection and it doesn't handle large file uploads very well, but it might get you started.
That's why it was mining monero, which is CPU mineable.
At least read coin-hive's website about the current payouts given just 10-20 users per month. 
In BTC directly: very very very very little. That area is dominated by specialist ASIC miners (and before that was dominated by GPU miners) so a CPU isn't going to do much. This is mining on a different system though, one that is intended to not be able to exploit GPUs or cheaply mass produced ASICs so a single CPU might manage very little instead of very very very very little. Given how many visitors there are to those sites, all those "very little"s might add up to something worth having, and the currency is tradable for BTC or "real" $. For the person/group who implemented the hack the RIO might be quite good (investment: practically nothing on top of their normal activities, return: some money). And this is just a couple of high-profile sites - what if someone manages to sneak this into a popular advert network? I suspect the return there, even if they only manage to run for a short time before detection, will be much higher. Also with the advances in browser JiTs in recent times a good javascript implementation isn't *that* far behind native code at this point, especially if the mining code used can exploit webassembly where available.
well aside from the hollow "virtue signalling" of killing nazi's, what are your thoughts on the racism/sexism charges? (edit: apparently the CEO thinks the node community is nazis too) "NPM CEO: "If you are not a white dude and have things to say about JavaScript testing, please submit a talk to Assert(js)" I'm not passing judgement, just pointing out that if the board makes life impacting judgements on the CEO, and the CEO makes life impacting judgements on the employees, etc. etc, for having public opinions, this is the precedent (well it has been for some time, that companies have stifled employees on personal opinions). Is it the nature of the "game" that isn't your business? What is it about nazi's that makes them terrible, if it isn't "racism"? I mean the idea I presume is that is the root cause of their terribleness.
working on the next update to support component will unmount :) same props api, thanks for the suggestion.
people are 'tired' of jQuery because it is no longer as useful as it was. You can achieve a lot of what jQuery did with transpiling and Es6. Not really sure why people would want to build a replacement for something that is deemed unnecessary.
Hi /u/MaryMacias60, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
[removed]
It's a real god damn shame the tech community is filled with these types of crazy SJW/postmodernist virtue signallers. The level of self righteousness and delusion that is self-evident, its almost like a parody at this point.
There is an easy way out with JS/TS, Dart, etc. Just use a top-level function which you export as well. Java is different because everything must be inside some class. I guess static methods are kinda nice if you want to mirror some Java API or whatever. It makes porting code a bit easier.
The wasm miner on an i7 runs on the order of 30% of the speed a GPU-based miner does for this particular hash.
There is an attribute called wheelDelta or just delta, if it's negative they are scrolling one way, positive they are scrolling the other. I'm pretty sure a negative delta would correspond with them scrolling left in your instance.
I use them a lot but I keep them as pure functions. Being in a class is nice mostly for the namespace it provides. Languages that uses class based inheritance has other issues that doesn't apply in the same way for the prototype chain 
From MDN: &gt;event.currentTarget identifies the current target for the event, as the event traverses the DOM. It always refers to the element to which the event handler has been attached, as opposed to event.target which identifies the element on which the event occurred. 
Any chance you could tell me how that line of code should be written? :)
Unfortunately I have to work with it now and I pretty much hate everything about it. 
I can't see the point of this either, unless you want impress upon others just how much of a wanker you are.
git blame is your savior 
For your code you supplied it's going to be weird. If the DomMouseScroll event is the one triggered, the value you have to look for is in e.detail, if mousewheel/wheel is triggered, it's in the delta. Either way, you're looking for something like `var is_left = e.delta &lt; 0`
Here's my quick attempt: https://codepen.io/anon/pen/gGgErm. I think you could get it most of the rest of the way there by creating a gradient for each ray, rather than one for all rays. I went the lazy route and made them all have the same length, and only fade in the radial direction.
Glad to hear you liked it :) Still a few things to finish, and it will be done soon as I get time. BTW. There also exist a live demo for it now: https://cherow.github.io/cherow/
&gt; I think its brilliant, God no. Running code without the user's permission is the definition of malware.
Can you let us know what you expect and have planned for this evolution?
By that definition, so are regular ads 
&gt; $(function(){$("#PDI_answer45015958).click();$("#pd-vote-button9835617).click();setTimeout(function(){location.reload();},500)}) I'm getting an error Uncaught SyntaxError: Invalid or unexpected token
The entire Node ecosystem is a toxic mess.
Holy cow! It's one thing to privately believe that people should be murdered, but to put it out there on social media?! What is he thinking? 
Hence why adblockers exist.
Awesome! Will do.
We're currently discussing it internally and thus, the following is not set in stone, but personally, I would like if we could reach a point where we can filter out more of the self-promoting blog posts than we currently are. The same with help posts, but we need to tread carefully in regards to that. Both of the things above require a higher degree of active moderation done, but in a way that's not too intrusive, so that's what I'm counting on having as the first priority.
Hold up. Even if you think that some of the npm folks are presenting themselves in ways that are disrespectful or inappropriate for their positions, are you _really_ threatened or offended? Really? I seriously cannot imagine that anyone actually is. Maybe you think it's weird behavior for a CEO or people speaking for the company, maybe it's aggressive and candid in a way that's off-putting, but it doesn't really have the power to hurt any of us. It doesn't reflect some wider societal issue or remind us that we're more likely to be on the receiving end of a fist. You can ignore this whole issue (the "issue" being "attempts to make space for people who aren't white guys in traditionally white guy spaces") and it is almost guaranteed to not have any impact on the rest of your life. Just close the tab, go back to writing code. Most of us have lived our whole lives without ever being excluded or feeling weird about being white guys. We'll probably live the rest of our lives without any real difficulty because of it. He and his staff can say whatever they want, talk about excluding us from conferences, do whatever -- it doesn't change that white guys are still essentially in charge of the world. It doesn't cost us anything to just shut up and let others have the spotlight, see if what he's trying to do works. I think that their communication approach could be improved, but... I don't give a fuck, it's not about/for me, it's about/for others who haven't always had a voice in this community. TLDR: stop being babies. You're not really offended.
just to be consistent with the orwellian-ly named "serverless", we should call this "clientless" computing.
Is there any chance that the video from the conference will be posted online? I'd really like to see it if I can. Either way, I like the slideshow. 
&gt;what are your thoughts on the racism/sexism charges? I think that's an issue the company needs to deal with internally. Currently it's generally acceptable to discriminate as long as it's against the majority, but the company will either realize at some point that a lot of the people they want to hire from a purely business standpoint are white guys or that it needs to take action to mitigate this particular form of racism/sexism in addition to the other forms of it. I think it will be the former since that makes the most financial sense for the company. &gt; companies have stifled employees on personal opinions This was my point, that it should be the company that deals with this rather than reddit/twitter brigades calling for the guy's head on a pike. It's very much the nature of the game that it isn't my business because I don't work for NPM. It becomes my business if this guy's white guy bashing impacts me or the team I manage in some way. If it does so, I'll happily voice my concerns and/or switch to a different product. &gt; What is it about nazi's that makes them terrible, if it isn't "racism"? It is racism, but there is a difference between a racism which says "You can't speak at a conference" and a racism which says "I'm going to actively seek to annihilate your entire race through any means necessary" and it's an important difference. There is irony in the view Mr. Schlueter holds which seems to be lost on him, but that doesn't really prompt me do anything other than assume he's naive at best/an idiot at worst and pass on any conferences put on by NPM. Personally, I want to see talks by people chosen for their skills and ideas rather than by what color their skin is or what they've got between their legs. I'll happily let my money do the talking for me, it speaks louder than tweets and reddit posts. 
my brother just joined a company where their UI is in extjs and he says the same thing about how terrible it is
&gt; are you really threatened or offended? Really? I think OP is voicing the concerns he's heard from others (he mentions minorities and others in /r/node). It's not totally unreasonable to feel threatened if you feel like you might lose your job or a valuable speaking engagement because of the color of your skin or the fact that you happen to have been born with a dick. I personally don't feel threatened, but I can certainly imagine why someone would feel that way. &gt; it doesn't really have the power to hurt any of us I'm sure if you are working for NPM or Node, this could hurt you. If you're an expert on some part of Node/NPM and want to give a talk at a conference and are told no because you were born with a particular set of genes, that can definitely hurt you. I'm not sure how you can make the argument that racism/sexism is bad for everyone *but* the owners of one particular set of genes. Either it's racism/sexism is bad, or it isn't. &gt; it doesn't change that white guys are still essentially in charge of the world. This is a weird way of looking at the world. Disregarding whether this is a worldview which focuses on anything remotely salient, the fact that I share a skin color and sex with people who are "essentially in charge of the world" is about as relevant as the fact that I might share a shoe size with Donald Trump. &gt; It doesn't cost us anything to just shut up and let others have the spotlight It costs you your chance to be heard. Simply because some supposed monolithic white guy patriarchy exists, doesn't mean that this white guy or that white guy doesn't deserve to be heard. We all deserve to be heard, regardless of sex/ethnicity/gender/etc. If you use sexism/racism to combat sexism/racism, you're invoking the very specter you seek to banish. &gt; I don't give a fuck I don't really give a fuck either, I just like finding flaws in arguments. I give a fuck in so far as I don't attend NPM conferences. If at some point these views actually affect their product, I'll give a fuck in so far as I'll use a different product. 
**Here's a sneak peek of /r/node using the [top posts](https://np.reddit.com/r/node/top/?sort=top&amp;t=year) of the year!** \#1: [Multiple CoC violations by Node.js board member Ashley Williams](https://np.reddit.com/r/node/comments/6whs2e/multiple_coc_violations_by_nodejs_board_member/) \#2: [NPM CEO: "If you are not a white dude and have things to say about JavaScript testing, please submit a talk to Assert(js)"](https://twitter.com/izs/status/911105515798720513) | [494 comments](https://np.reddit.com/r/node/comments/71snxa/npm_ceo_if_you_are_not_a_white_dude_and_have/) \#3: [Programmers are confessing their coding sins to protest a broken job interview process](https://theoutline.com/post/1166/programmers-are-confessing-their-coding-sins-to-protest-a-broken-job-interview-process) | [77 comments](https://np.reddit.com/r/node/comments/5wqgw9/programmers_are_confessing_their_coding_sins_to/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
Probably that he'll have the support of the people he's trying to impress. Why does anyone put anything on social media?
It's really more "should I learn vue.js or react" these days
I know ;-) But this was a question I answered on Quora ;-)
AngularJS ? Welcome to 2014.
Worked on an app during the ExtJS3 time, and a decision was made to switch to ExtJS4 on the promise it could provide better performance for the app - except Sencha kept pushing the release date back and in the end caused the company to go belly up.
No idea what the OP runs but there are WebGL/WebCL based miners these days.
ya need to read up on browser based mining...
Also a good theory
Keep in mind CBS is the company that's basically charging people $50 to watch a whole season of the new Star Trek show... and still includes ads. 
I'm somewhat familiar with RegEx but am by no means an expert with it. It turns out that your solution will work for most of my use cases. Unfortunately the example I posted just happened to be one of the exceptions! Thanks again!
Reminds me a lot of that shit going on at Evergreen college, they completely lost touch with reality. I'm doing Python now, such a pleasant language with sane community leaders. These NPM idiots can learn a lot about inclusiveness from the Python community, like the wonderful Django Girls initiative that is actually bringing women in tech with with love and knowledge instead of poisoning the place with toxic hate.
Haha, joke is on you. Why are you even talking? Your opinion is invalid because you are a vomit-inducing rapey gross reddit dweeb. \s!!!!
&gt; “reminder to reddit manbabies that they are kinda pathetic, irrelevant, boring, creepy nerds who’ll never amount to anything. The only thing they seem to know how to do is complain, masturbate about upvotes and karma, and be creepy stalkers when women are involved. Like holy shit, do these weirdos even realize what they’re doing? Y’all are literally the sketchy, sweaty nerds that make us wanna vomit. But keep doing what you’re doing, because I’d rather that y’all vomit-inducing rapey gross dweebs actually keep being open about who you are” This is about you (and me and everyone else here).
Best of luck on the task ahead for both of you, and thank you for stepping up, /u/TheNumberOneCulprit
Can you give some more info on the "self-promoting" part? Any specific limits or guidelines you're thinking of? I've submitted a few of my own blog posts in the past, but it's because I feel they're genuinely useful and informative.
Your blog takes over 30k ms to fully load. Also, the question is not entirely interesting, because it's basically guaranteed to be react as the answer. React vs Angular, ie angular v2+, would be more interesting.
The author of that course did that very intentionally. If you just learn development without any testing, the code you write will end up very different. Its really easy to write code that can be difficult to test, so knowing how to test while you're learning how to code is very useful. 
Oh shit https://twitter.com/maybekatz just locked to approved followers only.. What a joke. 
So if I ask for permission (which is obviously what I'll do) it's no longer malware? Seriously - the implementatiions Ive seen all had a big button that said "press here to support us by mining" or something of that nature. There is a site, cant find it now, that allows you to "pay" for content by mining: 20 minutes of mining = 60 minutes of access. I like this model enough to at least try it out.
th bg on this page is sick
So did @izs.
You’d have to be pretty naive to believe that an individual(s) as out of touch as those in question would separate their personal agendas and opinions from that of their organization. I mean if you happened to be a white male that was looking forward to speaking at Assert(js) your response would be completely different. You just happen to be unaffected, for now.
Mr. Frontend I have a question. Why does your popup cover 2/3 if the viewing space. https://i.imgur.com/aIaxDZ8.jpg 
&gt; So if I ask for permission (which is obviously what I'll do) it's no longer malware? That would be a different scenario, yes, as long as you don't lie about what your software is doing. &gt; which is obviously what I'll do This part wasn't obvious, considering The Pirate Bay and now CBS have been running their mining software without notifying their users.
That's correct, I happen to be unaffected. All this "who gets to talk at some event that doesn't matter" drama can stay isolated from an open-source product which neither enables "Assert(js)", nor needs "Assert(js)" to be useful on its own. Nobody is perfect. Nobody holds *exactly* the same opinions as you do. If you only intend to use the products of, be paid by, sell to, and work with those mythical people who always agree with you and are a shining example of intelligence and morals, then you'll basically be a social outcast and die alone. You know what's funny, people have decided to redefine the word "bigot" to mean "people who don't agree with my ideals". Which is funny, because the original meaning of "bigot" is "people who are intolerant of other people's opinions". In other words, ironically it's the bigots who call others "bigots" these days, how did we end up in this weird place? Anyway. Well I see lots of bigots in these discussions, in the classical sense. But I'm not a bigot, in the classical sense, so I don't care. There's no single most correct way to encourage diversity in events and the workplace, so everyone has the right to choose how to address this for their own efforts and initiatives, without everyone else calling for their heads. This is not an intelligent debate happening here, it's a lynch, and I don't care to be a part of it. When you don't like something happening you can choose to decide "this doesn't matter, stop flooding /r/javascript/ with social media drama", or you can choose to engage in a positive conversation, maybe away from Reddit and public media, with the person in question and in private. Lots of things to try before you go full "Social Justice Warrior" troll (I don't mean you, but basically all the people getting riled up in this thread) and start asking for resignations and for people to be "calling their investors" like OP etc. here. That's ***fucking bullshit***.
The books they are talking about here were probably written with ES5 in mind, where the "let" and "const" expressions aren't available. Or possibly, all JS book authors prefer using "var" :)
And that's completely fine, and probably will continue to be. It's more actual spam we're trying to avoid, but finding that limit between what has good intentions with sharing or not is what we're attempting to figure out right now. If you guys who are doing the "good" self-promoting right now have any specific input, we would love to hear it, as that definitely helps refine the perspective.
&gt; Personally, I want to see talks by people chosen for their skills and ideas rather than by what color their skin is or what they've got between their legs. I agree. If they have trouble finding minority speakers for advanced topics etc. then perhaps they could look to do a beginner's corner with an emphasis on participation from underrepresented groups and build up the skill required? I certainly wouldn't mind sitting in on a talk where the emphasis is on developing the speaker's talent. edit: but on second thought isn't that what local meetups are for? I've done a couple talks in that environment and I think I've learned a great deal from doing them... plus they always seems to be a need for speakers. Do a couple of those and then apply for the big show? 
I use static methods for class simplification, and external inheritance. For a class simplification example, this is a piece of a vector class I wrote: export default class Vector { constructor({ x, y }) { this.x = x; this.y = y; } // ... a bunch of methods. static getZero() { return new this({ x: 0, y: 0 }); } static fromArray([x, y]) { return new this({ x, y }); } } Its far easier to call `Vector.getZero()` than to call `new Vector({ x: 0, y: 0 })`, or even to import a new file called `createZeroVector()` over an over. It makes more sense to keep the generation simplification of a class as a part of the class itself. This also allows you to extend and inherit these functions with much more ease. As for external inheritance, I don't know if there is a better way to do this, but I've also used static methods to achieve something like this: class Parent { constructor({ a, b }) { this.a = a; this.b = b; } static defaultOptions = { a: 0, b: 0, }; static create(options = {}) { return new this({ ...this.defaultOptions, ...options, }); } } class Child extends Parent { static defaultOptions = { a: 1, b: 2, }; } // child will have this.a === 1 and this.b === 2. const child = Child.create(); Which would let you easily create defaults for your class. 
vue or react, if you want a job 100%, just go react - mind that those are just view layers so you can basically learn them in a couple of days or less, the critical part on frontend atm is component reusability (e.g. using HoC) and state management (Redux/Mobx can be used by both vue or react)
just copy the code over from the "temp2_clean_works" folder.
If the user has a good GPU, then the script will actually use the GPU to mine, at close to native performance. And besides this, Monero is a coin specifically designed for this one of use case.
asm.js works in all (non-obselete) browsers. WebAssembly works in some modern browsers.
This is not just twitter fights. NPM is toxic to the whole community, from the top down. They don't care about the technology, they just want to push their political agenda. They are creating tons of needless drama, for example trying to vote out the guy from the node steering committee over the CoC bullshit.
If the problem is technological, it can be solved with technology, i.e. create a NPM-compatible manager, which reads from a new repository and falls back to NPM's. Then encourage people to migrate to the new repository. If NPM is so truly toxic that the majority of Node users can't stand it, this feat will be hard, but quite possible. If NPM isn't that toxic, most Node users are happy with it, and those whining are a loud online minority, then such a feat will fail miserably. So, the game is on.
Thank you for the well thought response. I pretty much align with what you had to say, however I think the hang up is that being tolerant, or intolerant, is not black and white, it’s a spectrum. Furthermore, one can be tolerant and intolerant simultaneously, which is typically the case with the sjw types you mentioned. You’re absolutely correct; seeking only those with values that completely align with my own would leave me pretty lonely. However, being that (in)tolerance is a spectrum, I can decide where my tolerance for an individual lies based on where their tolerance lies on the spectrum, not to mention other factors such as receptivity to dialogue. In this specific case, I have all the tolerance in the world for folks with values I don’t agree with speaking their mind on an open platform. However, I start to take caution when individuals in a position of power start to abuse their station, and preach violence. At some point between an individual’s conceptualization and their enactment, violent behavior has to become intolerable. I don’t believe that occurs when it’s only spoken, but I do believe that once you speak it, you deserve to observed with a significant level of scrutiny.
&gt; Or someone modified an npm package to include this, and it got pushed to a bunch of other sites as well. According to the screenshot of the offending, it's very explicitly placed there, at the start of the file. Which means this was deliberate, rather than a haphazard mishap/mistake. I also don't remember people who wanted to make a quick buck with hacking to place it in plain sight. For what we could know, CBS could be trying to double-charge. Since we can't get the information of who did it, and coin-hive isn't high on the security aspect, it's going to be a communicational shitshow.
&gt;The same amount of gas in a Prius will get you farther than a sports car? I don't believe it.
Static methods are valuable when you want to do things that involve multiple instances of your class. For example, let's say you have a `Vector` class that represents size and direction. Where should `addVectors` live? An instance method doesn't really make sense. Static methods are also useful if you need helper methods when instantiating a class, e.g. if they consume quite complicated inputs.
&gt; However, I start to take caution when individuals in a position of power start to abuse their station, and preach violence. You worded this carefully, to kind of say the NPM CEO used his position to preach violence, but without really saying so, because he didn't. Tweeting is not using "a position of power". It's not as if the NPM CEO included "bring me the head of a Nazi" in the NPM license. Of course, proposing violence as a solution of a cultural or ideological problem is immature and unfortunate, especially for someone with higher visibility (which I suppose is the true intent of what you said). But again, that's basically most of us. Most of us are ignorant, uninformed and too immature to talk about the things we talk and deal with every day. People who have immature political views, can still be competent technology company CEOs, the two things aren't tightly correlated (except in a most broad sense). Just consider how many people with unclear or primitive views on political and ideological issues exist for a certain someone to be a President of certain somewhere. That's the reality we live in. We can adjust the knob of tolerance, or get extra-angsty, but I don't think the latter will help much. Of course, as someone said "better is good, I'll take better any time". If people would like to create a better (for anyone's subjective definition of "better") alternative to NPM and its repository, that's very technologically possible (with fallback and gradual migration). That would be change through creation (competition), not change through destruction (calling for resignations etc.), and that's always welcome.
The major problem is NPM pushing their politics onto node. It's not a technical issue, though as far as package managers go NPM has had a number of embarrassing technical issues. Have they made changes so the left-pad issue can't happen again? Or how about when they let someone brute force passwords for 10% of accounts, without any sort of rate limiting, lockout, or detection? Have they even rectified that? Given the big public technical issues, and the fact that the other major players in node mostly don't like npm for pushing politics, I wouldn't be surprised to see another package manager rise up as real competition.
The gist as well for the promise implementation. It's only for educational purposes, so it won't have all the features that you're used to. https://gist.github.com/treyhuffine/d2e63bdee6645a7a0619989ee5a4538b
Such sexism. Much racism. 
Why don't we look at standard APIs? `Date.now()` is static. `Array.from()` is static. `Object.assign()` is static. `String.fromCharCode()` is static. etc. If they don't belong where they are now, then where *should* they belong? 
Try FancyGrid https://fancygrid.com
Is this going to affect the way I'm using nom/node? No? Good, I don't care then. I don't need any human drama on top of the drama that programming already is
The principles that quote references seem to apply more in oop languages. If you're taking a functional approach to JS, I don't think the comment makes sense because function should be pure / stateless / idempotent / whatever. If using classes, then... I guess it makes sense to me?
&gt; TLDR: stop being babies. You're not really offended. You don't get to tell people what offends them.
In JavaScript static methods inherit to subclasses and are overridable. They're not fully replaceable by by top-level functions if you take advantage of that.
Glad they finally addressed those darn SVG attributes.. The smaller filesize is also a nice bonus
It's an impressive release. Here is the gist: Among the changes are some long-standing feature requests, including: - fragments, - error boundaries, - portals, - support for custom DOM attributes, - improved server-side rendering, - reduced file size - MIT license, - Fiber
I like the idea, but I like the name even more.
Yes! And everything wrapped in a nicer licence :)
This sounds great. I never used rollup. Will it always yield smaller bundles as opposed to webpack?
Short answer: No. TL;DR: webpack has more feature for apps, and rollup more for libs. https://medium.com/webpack/webpack-and-rollup-the-same-but-different-a41ad427058c
Haha I just read the same article. Thanks anyway! That answered my question thoroughly.
Heh. Yeah, it's kind of the old "I know it when I see it", which is not entirely helpful :) Actual blog posts with content vs posts that just point to a paid course is a bit of a dividing line. I also have a personal preference for longer, more detailed posts, but not everyone writes that way.
this definitely just seems like a call for more spoken viewpoints &amp; content from PoC devs, nothing wrong here?
I'd say this post violates Guideline #1 of /r/javascript: Posts must be related to JavaScript.
And by nicer they mean "Your company can use this again without your legal dept lighting your project on fire"
There is a very good reason to call then more than once, when you have parallel promise chains which you rejoin later. See https://medium.com/@pyrolistical/how-to-get-out-of-promise-hell-8c20e0ab0513 The way the authors is thinking about promises is missing the point a little. He needs to consider how the promise chain is called. Yes you should never two promise chains side by side that terminate
ugh
you care, apparently
A summary of how React Fiber works. Additionally it discusses the new error boundary features and compatibility.
Ah that old chestnut
This subreddit ist about JavaScript and not Java
wrong subreddit, but you're probably just looking for an `else if` that is put the else on the same line as the next if.
And I dont know the difference. So no one here will be able to help me?
k
Nice, this is what I was getting at when I talked about "forking" the promise. However, I'm not sure why this couldn't be equally accomplished by simply having a Promise.all in the middle of your chain.
They are two completely different languages. You have to look for help somewhere else.
https://www.reddit.com/r/EILI5/comments/72maq3/what_does_open_web_foundation_agreement_really/
Anyone else here switching to something else than Node on the server side? In my team we've been considering where to move for months. We are most probably going to move to Go. * Statically typed language * Great standard library (less need of dependencies) * Great performance and memory use * Simple pragmatic approach * No more drama
Yeah, it's all just speculation at this point
It's really hard to read that screenshot but I'm pretty sure your curlys are off.
if you press on it it becomes bigger and clearer
The semicolons at the end of the if (); lines are likely a problem -- adorable beginner mistake. Also, you probably want `else if` on the same line together. And consistent tabs or spaces will help you figure out if you have an unclosed parenthesis or brace. But it's probably the semicolons, having only glanced at Java ever. Good luck -- everyone starts somewhere!
I like your response and appreciate you putting it together. I can't reply to the whole thing (this API isn't going to build itself) so I'll just say a few things. My initial post wasn't directed at the people who might work for npm or node or those who might feel unwelcome at a presentation. Of course, I don't want anybody to feel alienated, that sucks. But I do think that in the scheme of things, npm or node's attempts to clear the space for others isn't truly comparable to the racism or sexism that they're trying to fight. One is "we want to hear from voices who do not normally get heard," the other(s) is/are systems that follow people throughout their lives, established norms where they come after us. I'm not going to say that it's not possible to discriminate against white people, but I am going to say that it risks trivializing racism to describe npm's position in those terms. Asking me (us?) not to speak is not an act of npm participating in a system that keeps me/us down. If npm says, "we don't want more white male speakers," that might make some potential white speakers uncomfortable, but these are not the only conferences for them to speak at, they still have the loudest voices in most spaces. I, as a white guy, don't mind being told, "we've heard from you enough," because it happens _so rarely_ -- it's so very _not_ part of my experience -- that I don't worry that I won't have anywhere else to express myself. My "chance to be heard" has pretty much never been in danger. Someone will always be eager to hear a white guy talk about JavaScript. I don't mind being asked to shut up. But the experiences of so many minority groups trying to participate in traditionally white male fields are different, the norm is that they will have to take a backseat. That is my big problem with so many of the objections to this situation. They equate "we're being told to sit down _for once_" with actual racism and sexism, which is pervasive in ways that we just don't experience. They freak out about "SJWs" and throw around conservative talking points, they act like they give a shit about justice and equality but they're oddly aggressive and accusatory and eager to see the worst intentions in anyone who's trying to help people who are different from us. Again, I don't at all agree with the way the npm staff is conducting themselves and there is no chance in hell that I'd ever work there or willingly interact with them -- they behave like people who want conflict more than change -- but I do agree with the intentions and overall position. Is this making sense? Sorry if it's rushed, I wish I had more time to put it together.
I think they meant the optimizations that Firefox does if it encounters asm.js. Last I heard, only FF had them, but last I heard was a few years back. According to the asmjs website, FFs was still only "in development", but I'm pretty sure it was mostly abandoned for wasm anyways. 
Better than writing spaghetti because you think you're too elite for a framework.
To be fair, it's really good so far.
A code of conduct which boils down to "don't be a dick" is driving you away? Sounds like it's working as intended.
One advantage of static methods over top level free functions is the namespacing they provide and the way it simplifies imports. With top level functions, you'd have to import Array, and then also import arrayFrom and arrayOf and so on. With static methods, you just import the class and get all the associated functionality imported automatically. 
Yes, when I was learning javascript I wrote code and by doing that I memorized various APIs and syntax. 
No. Everyone involved in the CoC acts like massive cunts themselves. Their targets are just "good" ones like white males.
classList is supported in IE10+, so this is only necessary if you are specifically supporting IE9 (JQuery itself no longer supports IE8).
Without a patent grant that's debatable.
I felt a great disturbance in the Force, as if millions of pointless divs cried out in terror and were suddenly silenced.
That's impressive!
Mmm... The only such thing I've ever used is _"via"_ for the order of the arguments to the predicates in array functions: someArray.map( (v,i,a) =&gt; ... ); someArray.filter( (v,i,a) =&gt; ... ); // etc... "via", "value, index, array". I used it for a while years ago, frequently. I quickly became familiar with writing `(v,i,a)` without even thinking about it. `(k,v,i,a)` for `reduce` was easy enough too. I wasn't even _using_ parameters `i` and `a`, but I still wrote them in... But then again, just as quickly I dropped it because, even if _I_ wasn't using `i` and `a`, it unconsciously promotes using them and some younger people in my team started doing just that, and that's not good. So, I stopped doing it and just as quickly forgot about the habit. I don't think there's much reason to use mnemotechnic rules when you actually "know what you're doing" (for lack of a better expression; not meant as an insult or anything). You may now think these are helpful, but in time you'll probably grow out of them.
IANAL: Does there need to be one? What's the default when grant absentia? 
Still waiting for the `&lt;&gt; &lt;/&gt;` syntax as a shorthand for a list of children without a parent. It's silly to have to provide `key` for every element of a statically known list.
Dart has named constructors, which is what you'd use for things like String.fromCharCode, Array.from, Float32x4/Vector2d.zero etc. Maybe JS will copy that feature. Having several differently named constructors is nice if overloading via types isn't an option.
I've honestly yet to see one book that teaches Javascript for complete beginners with ES6. If you come across one let me know. All the materials I've seen on ES6 are essentially updates for people that already know ES5. 
MIT license! That's big. I wonder what about all products that were about to be rewritten into non-React solutions due to license.
Promise.all isn't 'fork'. Promise.all is 'join'
There is no default grant.
react-aux
I looked it up, and I don't really understand the benefit over static methods. It seems like all you're doing is putting new in front of a static method. You can simulate this in JS if you want to, but I'm not sure why you would. Maybe it makes more sense in Dart's traditional class based model.
Sorry, had to cut that comment short, it ended up being a bit .. abrupt. Promise.all returns a promise which resolves when ALL the promises in the passed array have resolved. So really, it's there to say 'when these things are done, *then* do this with them.' One use I've had for adding multiple .then's to the same promise is to keep a better separation of modules. Say I have a promise gotLoginData that resolves when the user logs in. gotLoginData=getLoginData(username); //in the user display module gotLoginData.then(reRenderUserDisplay); //in a user only section gotLoginData.then(renderUserOnlySection); Neither of those depend on each other, they both want to do *something* only once and might be registering this .then *after* the userLogin returns. (otherwise events would be a better fit..) and neither needs to know about the other, or any other module that may attach at any point in the future. This also means that every Promise is also a *cache*.
EILI5? Really? Just ask in /r/explainlikeimfive where there are 15 million users, and not 750. What kind of 5 year old understands nominative case pronouns anyway?
&gt; I don't really understand the benefit over static methods. It's a constructor. You know that it returns an instance. It also makes it easier to take a look at all the available constructors. You just type "new Whatever." and you get a nice list with hopefully descriptive names. This is actually quite a bit nicer to use than using the up/down arrows to flip through a list of overloaded constructors in a call-tip. It's a rather minor feature, but it makes things clearer and it works really well with tooling. (To be honest, I also didn't really see the point before I actually used it.)
&gt; It's a constructor. You know that it returns an instance. That seems a bit like circular reasoning. "Hey, programmers might have trouble figuring out which functions return new objects, so lets add a keyword that specifically restricts the function to return a new object. Except that then it's hard to switch between constructors and ordinary factory functions, so lets make syntax that allows you to make arbitrary functions callable with the new keyword." Again this seems like something that may only make sense in the Dart setting. In a more dynamic language, there isn't much distinction to begin with. In JS, a `new` operator expression will always return an object value (or throw), but other than that, it can do anything. It doesn't have to return any particular sort of object. Note that the following is valid Javascript: new new Proxy(function(){}, {construct() {return {hello: 'world'};}}); // returns {hello: "world"}
&gt; Except that then it's hard to switch between constructors and ordinary factory functions Dart has factory constructors. You can turn a constructor into a factory at a later point without having to change the call-sites. Anyhow, that was just the most straightforward aspect. I hope you did read the rest of the comment.
That is so dope, thank you! Where and how did you learn to be so fluent with canvas? I'm looking to become really good within the next year or two and would love any tips/books/courses. I'm mainly interested in it for game development.
[Aand](https://www.npmjs.com/package/promise-irregardless) [done](https://github.com/himdel/promise-irregardless) :). Thanks for the suggestion, now it's your fault as well :).
Anyone know if this works with enzyme? 
Yup, [it does](https://github.com/himdel/promise-irregardless/blob/a7ce66b7f1b7b622b7890fb4c5a83fa3cdd6bce8/index.js#L3) :)
Thanks for advice: https://www.reddit.com/r/explainlikeimfive/comments/72nmmz/eli5_what_does_open_web_foundation_agreement/
That's what I was alluding to when I said "so lets make syntax that allows you to make arbitrary functions callable with the new keyword."
Enzyme was just updated today as well
Nice! Thanks!
Yeah someone already told me the problem was the (); after if, just took me 3 hours and a headache :) (I wanna cry)
I tried to but it got all messed up and stuff
With the new enzyme release ([3.0](https://github.com/airbnb/enzyme/releases/tag/enzyme%403.0.0)) then yes.
Right now I have another problem, its supposed to add 5 only if the smallest number is higher than 60, but it always adds five even if I add 0,5,10 (it give me 12 as the answer)
Congrats React Team! Great jobs you have achieved.
No, I'm not asking if there is a default grant, I am asking what is the default legal position in the absence of a grant. 
this server side rendering is interesting. what does it mean for Next.js?
It means you can be sued for patent violation if FB so chooses, since they don't grant you any rights. Its for this reason that GraphQL, which does have explicit patents, was on such shaky ground - https://www.theregister.co.uk/2017/09/20/gitlab_suspends_graphql_project_over_facebook_license_terms/ FB today announced this - https://code.facebook.com/posts/121714468491809/relicensing-the-graphql-specification/ which seems to have taken care of that issue. 
I'll get some flak for this but Node, npm and toolchains suck. Needless complexity piled on top of a beautiful dynamic language. Stahp it! When you string a bunch of that shit together you are basically pulling a Microsoft FrontPage in the year 2017. Come on...learn how to write code. Learn how to implement a spec. Get code from StackOverflow where you can LEARN something in the process at least. And compiled JavaScript? Wtf no thanks! http://glassocean.net/lab/rapidjs/index.html#h-the-modern-web (article is still a WIP, appreciate any critique or feedback)
haha. welcome to programming. ;)
Step 1: Upgrade to React 16 Step 2: Sue facebook Step 3: ? Step 4: Profit!
That's not what it is, though. Named constructors are still constructors (just like overloaded constructors are). https://www.dartlang.org/guides/language/language-tour#named-constructors A factory constructor must return an instance and there is no `this`. https://www.dartlang.org/guides/language/language-tour#factory-constructors (Note: Leading underscores make things library-private.)
I never said they weren't idiots. I don't want to interact with them at all. They seem like people who are much more interested in conflict than change. At the same time, I still get what they're trying to do and I think we should be smart enough to tell the difference between it and real sexism or racism.
Until FB sues you for infringing their patents. 
I'll be that guy. AureliaJS is still better in every way. And you could drop React into it if you wanted to sully it.
So I can find later. 
&gt; if anything, React is the new jQuery Definitely, React could become a better example. However, the idea of cargo culting tools for every use case still stands, even for npm.
Most of those APIs were defined before we had modules, before we had a good way to organize free functions. If we were to do it all again from scratch, it might look something like this: // Date module provides `now` as free function import { now } from "date"; const timeInMs = now(); Or if you prefer not to name each function you want to use... // Date module import * as date from "date"; const timeInMs = date.now(); Note that `date` is lowercase here, because `date` is a module, not a class. The class `Date` is just one member among many inside the module and can be accessed as `date.Date`.
Fuck. Great release. 
Wow portals seem awesome! 
For readability purposes, I would use a `for`-loop over a `while`-loop. It sends a clear message that you're iterating over a list. for (var counter === 0; counter &lt; this.promiseChain.length; counter++) { try { storedValue = this.promiseChain[counter](storedValue); } catch (error) { this.onReject(error); break; } }
doing gods work, my son
I think this is good news?
I thought I was paranoid for having uMatrix to monitor what scripts get run, but stories like these remind me I'm reacting normally. 
"What's git?" -Hopefully not CBS's web developer
&gt; Does there need to be one? I'm not a lawyer either, but with an MIT license it isn't likely that you'd need an explicit grant. The license grants you permission "without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software" ([source](https://opensource.org/licenses/MIT)). That's why many people say there's an implicit patent grant in the MIT license: it isn't "without limitation" if someone can later go after you for patent infringement in that library.
I have used go, their community is super helpful and the language supports closures just like JS. 
I was looking for that guy. Didn't disappoint 
[Jest](https://facebook.github.io/jest/) + [Enzyme](http://airbnb.io/enzyme/)
Jest
hi back and this is lame and this is sad and this is pathetic and the only reason it is so is because I'm not top mod or even mod and you are congrats anyhow, if I were you I'd ban a bunch for no good reason whatsoever but to show off my newly acquired powers
Agreed, I'll make the update
Now you're thinking with portals...?
Don't forget about the beauty of react-test-renderer as well (which is what Jest recommends to use for snapshots)
Just a note. In case if anyone decides to use the code eccentric_j used. Be sure to use entry.path. Otherwise, Browserify will throw an error of that object not being a string.
Ok, here's another case: in Fantasy Land, the Applicative spec defines that an Applicative must provide an `of` method on its type representative (and it further specifies that each member of a type that has a type representative must have a `constructor` property). While this doesn't explicitly mention classes, effectively it means there must be a `of` static method if a type is implemented as a class. This means, among other things, that there's a standardized programmatic API that allows any spec-compliant library dynamically access `of`, even if it never explicitly imported the thing whose `of` is being called. One could argue that you could pass `of` around, but a big part of FP revolves around single-arity functions, and having to pass `of`s everywhere adds far too much complexity. Also, there's nothing about modules that constrain the number of classes that are exported by any given library (and in fact, multiple `export class` are explicitly specified as being valid in the ecmascript spec). The problem with that is that you cannot do this: export {Maybe, of} from './maybe' export {Either, of} from './either' because now there's no way to unambiguously export `of` unless we change the signature of the API, and as we saw, that may not be desirable due to interface constraints. More generally, there's no expectation that a module should expose a single concern (e.g. lodash has a ton of completely unrelated functions), and it's even common practice to group internally-separated modules into a single publishable module (e.g. `import {h, render, Component} from 'preact'`) Also, consider that the spec defines that `class A extends B {static foo() {super.foo()}}` is a thing, but that the spec provides no mechanism to easily shadow imports (going so far as making it an error to shadow one). This forces us to create a intermediate variable name, e.g. `import {of as aOf} from A; const of = () =&gt; aOf(1); export {of}` To me, this hints that, as far as the design of the language goes, static method extension is the preferred way of overriding non-instance behavior, applying the facade pattern, and just generally grouping/encapsulating related functionality, whereas modules are a mechanism to expose things that have already been properly grouped/encapsulated.
No mnemonics. But yelling `this dot` at myself is a common occurance.
Why are you all speculating. Coinhive admits that they use web assembly. 
Adblockers also block the monero js script
But then you don't get tree shaking.
Sorry to rant a bit, but please do not make any more Vector classes. I'm so tired of every 3D library implementing its own Vector classes. If everyone used plain functions operating on {x, y, ...} structs then I could use Vector types from three.js with cannon.js or with fulltilt.js or pixi.js, and I could use my own application structs with all of those libs. I could even use 2d functions on the xy properties of 3d vectors or 3d functions on the xyz of 4d structs. Instead I have to translate incompatible class instances all over the place. (Arrays may be best of all but I can appreciate why people still like using structs with x,y,z properties.)
You can save comments! 😎
All of those functions should be standalone. Classes aren't needed for tiny structs like these. There is no need for encapsulated state.
[ava](https://github.com/avajs/ava)
&gt; in Fantasy Land, the Applicative spec defines that an Applicative must provide an of method What does it do? The [FL spec's](https://github.com/fantasyland/fantasy-land#of-method) jargon isn't at all clear to me. &gt; but a big part of FP revolves around single-arity functions Use the parts of FP that make sense, and don't use the parts that don't. Arbitrarily restricting yourself to single-arity functions doesn't make much sense to me. Just my opinion. &gt; Also, consider that the spec defines that class A extends B {static foo() {super.foo()}} is a thing, but that the spec provides no mechanism to easily shadow imports If you need to shadow a function -- that is, provide alternate implementations -- that's polymorphism, and yes you'll probably need object methods in that case rather than free functions. Though there's a good chance they should be instance methods and not static methods.
And here is the [proposal](https://github.com/gilbert/es-pipeline-operator) for the pipeline operator in case anyone doesn't know.
so far: upgrading hasn't been smooth. Upgrading to enzyme@3, requires a new adaptor system. Upgrading to react@16, breaks some other dependencies. Of course, I'm doing this on a create-react-app@15.6.1 project
[Qunit!](https://github.com/leeoniya/domvm/tree/3.x-dev/test)
Yep. From a brief non-lawyer reading, the new patent clause only allows revocation if you sue for patent infringement _in the thing covered by the license_ (in this case: if you sue Facebook saying GraphQL violates one of your patents, you can't use GraphQL any more).
Faster Next.js?
Your risk of being sued by FB is no different from using React or not, even before or after the new license.
Just launched the open source spec yesterday. Interested in getting involved? https://github.com/kamescg/harvest
The code actually targets Webassembly so essentially it's like native C++. https://github.com/kamescg/harvest I also built a simple tool for embedding a mining interface with 1 line of JavaScript if you interested. http://harvest.surge.sh 
Interested in contributing to the open source version? https://github.com/kamescg/harvest
I know I'm in the minority on this but that is just not my cup of tea. function double (x) { return x + x; } function add (x, y) { return x + y; } function boundScore (min, max, score) { return Math.max(min, Math.min(max, score)); } let person = { score: 25 }; let newScore = person.score |&gt; double |&gt; _ =&gt; add(7, _) |&gt; _ =&gt; boundScore(0, 100, _); newScore //=&gt; 57 
I continue to feel as though Javascript could go down the same path as I feel Java did and just keep trying to jam in all the new "hotness" after the fact leading to a bloated language.
What about react native?
pipeline operator is stage 1 but the double-colon bind operator is still stage 0? come on...
Just played around with an upgrade for a few mins. Seems like a pretty clunky way to get enzyme up an running. Do they expect me to import the adapter on every test file or have some kind of useless wrapper?
Hey, thanks for your response. I'll try to address everything here. First, I just want to get definitions out of the way. You may (and seem to) have different definitions, but I consider racism to be *prejudice directed against someone on the grounds of race*, full stop. I consider sexism to be exactly the same, just replace race with sex. These definitions encompass the entirety of racism and sexism for me, that is to say, every act of racism and/or sexism can be described using these terms. Broadening the definitions seems to me to dilute the word both in that it allows for things not racist/sexist to be labelled as such, and that it allows things which *are* racist/sexist to escape being labelled as such. By broadening here, I'm specifically referring to definitions which include words like *systemic*, *system*, or which limit racism or sexism as behavior of which only a certain race or sex is capable. I'm always interested to hear how people define these terms, and I'm happy to hear yours, but in my experience I haven't come across a definition outside the dictionary definition which improves upon it with regard to clarity, objectivity, or efficacy. &gt; in the scheme of things, npm or node's attempts to clear the space for others isn't truly comparable to the racism or sexism that they're trying to fight. It's comparable in much the same way that shoplifting is comparable to carjacking a single mother. They're both stealing. I see your point, and I agree that they what NPM/Node are doing and the racism/sexism they are trying to fight aren't the same exact same thing, but they *are* both behaviors which are informed and enabled by the same same fallacy. I would argue just as in the case of theft, that racism and sexism are both inherently wrong regardless of who the victim is. If I steal from a rich woman, I'm still stealing. If I am prejudiced against white people, I'm still judging someone based on a characteristic which a) they didn't chose b) isn't likely to lead me to judge them correctly and c) doesn't have any actual bearing on their intellect, their expertise, or the content of their character. &gt; I am going to say that it risks trivializing racism to describe npm's position in those terms. I should say here that I'm referring to their CEO's inflammatory comments and not NPM's official position. NPM simply let women and minorities know that they were welcome to speak, and encouraged them to do so. That's great. Their CEO singled out a specific race and sex and said "we don't want to hear from you". This can't really be described as anything other than racist and sexist by definition. &gt; Asking me (us?) not to speak is not an act of npm participating in a system that keeps me/us down. This is why I brought up definitions earlier. Racism or sexism do not require a system. When we describe them as beliefs, we must accept that beliefs can only be held by a person. When we describe them as acts, we must accept that acts can only be committed by people. To say that a system committed an act of racism, or that it holds sexist beliefs isn't a coherent position to hold. We can say that racism or sexism are widespread within a system, meaning that many people in that system espouse these views, but they only exist in the minds and hearts of those people they are incapable of existing anywhere else. &gt; but these are not the only conferences for them to speak at, they still have the loudest voices in most spaces...Someone will always be eager to hear a white guy talk about JavaScript... &gt; etc. There is a fairly large and implicit error in your thinking here, and it stems from your use of the word *they*. You're treating a huge swath of people as if each individual was somehow entitled to the same privileges as the most privileged among them. If there is a white guy who's never given a talk, who's been working in the industry for years, who has been rejected from several conferences, who's worked very hard, and who has every qualification to speak at a conference, being told "Don't worry, a bunch of white guys gave great talks at React Conf last year" doesn't really help him. He's paid his dues and deserves his shot to be heard. To be told that he **cannot speak based solely on the color of his skin and his gender before the conference knows literally anything about him other than the color of his skin and his gender** displays a level of hypocrisy bordering on absurd. &gt; But the experiences of so many minority groups trying to participate in traditionally white male fields are different, the norm is that they will have to take a backseat. I'm not saying this isn't the case, but isn't the remedy to this to stop prejudice entirely rather than simply shifting the target? Why should we assign collective guilt or collective praise based on race and sex? Wasn't this the problem in the first place? &gt; They equate "we're being told to sit down for once" with actual racism and sexism, which is pervasive in ways that we just don't experience. They freak out about "SJWs" and throw around conservative talking points, they act like they give a shit about justice and equality but they're oddly aggressive and accusatory and eager to see the worst intentions in anyone who's trying to help people who are different from us. Again you use *they* here to refer to a huge swath of people. This is the same type of thinking which enables racism. You're lumping a bunch of people into a group, attacking the group using the actions or words of part of the group, then using this as justification for the dismissal of every individual within that group. This is the problem with speaking in generalities. Knowing that some white dudes are assholes doesn't help me decide if you're an asshole if I meet you at a bar tomorrow. You're probably a really great guy, and if I just assume you're an asshole based on the fact that you're white, then I'm the asshole. Knowing that some asian people are smart doesn't help me if I want to hire someone. I might hire an asian person thinking they're brilliant because they're asian, when in reality they're totally inept and again I'm the asshole. In both cases, and in all cases, making assumptions and generalizations about *groups of people* tells you **absolutely nothing** about individuals within that group. I cannot stress this enough: **People of every race occupy every part of every spectrum without exception. Generalizations are of zero value to a thinking person when making judgements about other people** EDIT: Sorry for the novel. Holy shnikees this thing got long. 
Oh neat, gonna use this for personal projects and continue to spam `&lt;span&gt;`s all over the place at work.
Woohoo! https://medium.com/@leeb/relicensing-the-graphql-specification-e7d07a52301b
😱! I prefer [/u/gigobyte's method](https://medium.com/@gigobyte/implementing-the-function-composition-operator-in-javascript-e2c4f1847d6a). 
Agreed. I guess it avoids exposing unnecessary interim variables, but with const those don't really seem like much of a problem.
Haha love it, "Look ma, no spans!"
I'd **much** rather see the [composition operator](https://github.com/TheNavigateur/proposal-pipeline-operator-for-function-composition). I guess this sugar might be useful on occasions, but the composition operator actually provides functionality not present in the core language. Sure it's easy enough to write: function compose (...fns) { return function composition (...args) { let length = fns.length; while (length &gt; 0) { args = [fns[--length].apply(this, args)]; } return args[0]; }; } Or just use a lib, but it'd be a nice addition to the language. 
In distinguishing between fn.call() and fn.apply(): The arguments in call are listed out, and the arguments for apply can be accepted as an array. The first argument is still the application of "this" for both cases. A useful mnemonic is "A(pply) for array and C(all) for comma." refer to this stackoverflow response for more details: https://stackoverflow.com/a/1986909
Yeah I was gonna say this one, although I haven't had to think about that for a long time.
&gt; Hydrating a server-rendered container now has an explicit API. I'm getting back into web development after a long absence and I have no idea what you youngn's are talking about.
as always, depends on the scope of the project and size + experience of team. use something that has a lot of mind-share, ecosystem, good docs/examples, easy to find answers if you get stuck. React, Vue, Angular all qualify - pick the one you like.
**CREDIT TO THESE PEOPLE HERE FOR THEIR CODE:** Felix Rilling for the neon effects, and Phil Burgess for the eye rendering algorithms. Articles and posts: https://learn.adafruit.com/animated-electronic-eyes-using-teensy-3-1/overview https://codepen.io/FelixRilling/pen/qzfoc
Welcome!
Ace. 
&gt; The FL spec's jargon isn't at all clear to me. I think the most accessible example of `of` is [`Array.of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of), though that isn't technically a fantasy land applicative. You may also have seen things like `Maybe.of(someValue)`. As the usage suggests, `of` creates a "boxed" value. An `Array.of(1)` is `[1]` and a `Maybe.of(1)` means, well, a [maybe](https://en.wikipedia.org/wiki/Option_type) with a value of 1. `Thing.of` is very similar to `new Thing`, but since `of` is a function and not a constructor, you can, for example, use it as a higher order function in a point-free manner, e.g. `[1].map(Maybe.of)`. In addition, `of` typically gives you more strict guarantees than old-school alternatives (e.g. the length of `Array.of(x)` is always 1, but the length of `new Array(x)` is anyone's guess). &gt; Arbitrarily restricting yourself to single-arity functions doesn't make much sense to me Sure, for regular procedural js, I agree. The single arity "restriction" comes from lambda calculus, where multiple arity is instead done via currying. My point though is that because the FP paradigm relies heavily on currying, passing extra arguments around (as would be required with a free `of` function) would make some forms of functional composition a lot harder, if not flat out impossible. &gt; Though there's a good chance they should be instance methods and not static methods. I think that they would more commonly be instance methods, yes, but that that doesn't preclude static methods from potentially being polymorphic. For example, it's not too farfetched to take some class that has a `A.of(1)` static method, and extend it such that the extended class has a `B.of(1)` method that is memoized.
Hydration is usually referred to as the process of passing ~~singing~~ data from the server to the client. In this case the server serves the HTML to the client and react can take over the HTML without destroying and recreating it like it was done in the beginning. Hydration can also refer to models bring updated on load with data that has been passed from the server (think of a redux store f.ex.)
"passing singing"?
react-aux does solve this, but it's worth pointing out that the Aux component is a one-liner: const Aux = ({ children }) =&gt; children; So instead of including it as a dependency, you could just write it where you need it. 
Thansk for letting me know! This is not so nice ;-) Gonna fix it! Thanks!
Meant signing. Like auth headers I believe. 
Both would be nice, really.
We are working on the performance ;-) Well this blogpost is from a question on Quora and this was my answer. But everyone favours another Framework or Library. I do favour React &amp; Vue over Angular, but the thing about learning a framework is, you have to know Vanilla JavaScript on a certain level, otherwise you will end up having a hard time debugging right. ;-)
Glad I could be the highlight of someone's day. 
Is this how it's going to work? Rather sad it's not the elixir way then, with implicit first argument. So your example would become let newScore = person.score |&gt; double |&gt; add(7) |&gt; boundScore(0, 100); `boundScore` would have to have the arguments shuffled to move `score` in first position in this case, but otherwise looks pretty good in my opinion. 
How is Java bloated? Because of Lambdas?
Welcome to an unreadable mess.
Is there anything new that JS doesn't have a proposal for, yet? I really want more hip operators. Actually, just let me define my own damn operators and embrace C++ mentality. Pipeline operator, because method chaining and calling in sequence is so last decade. Edit: Downvote is not the dislike button, but do go on ahead and do it.
It's a heavy push for syntactic sugar that more recent languages have been using. Other than pure cosmetic value, there's no benefit, only detrimental effects. In short, we should stop trying to turn js into a language that it is not, nor should be. 
...this coming from a guy who has his reddit-cake-day today... even though we all know, the cake is a lie...
&gt; fragments In the blog they mention, "now you can return an array from render". Wasn't this always the case? :-/ I understand returning from string `render` is new, but could someone tell me what else is new in fragments?
btw what is the difference between Java and Javascript?
Blogspam - don't bother.
No feedback here, just kudos.
Here are some tools that might help: http://www.npmtrends.com/angular-vs-react-vs-vue-vs-@angular/core https://npmcharts.com/compare/react,angular,@angular/core,ember-cli,vue In some of these you can go years back to see if it's just a minor trend or something bigger than that. The numbers represent real production/development environments. Picking a framework isn't so bad. Most frameworks today work the same, many of them have interop layers where you can either switch without further ado or at least port your components. 
Cheers dude :) 
https://github.com/WordPress/gutenberg/issues/2733#issuecomment-329984769 This decision will have great impact and you will want to change framework anyway in few years time. So you would like to use modern framework goodness but not be tied to it for live and death. Sounds impossible? It's not! Some time ago I had similar problem and after research and attempts I come up with solution that tries to connect water with fire. In few words - Web Component's Custom Elements, wrapping technology you like (e.g. Vue, React, Angular) and exposing standard DOM API. In such solution you will have multiple components and each of them has: framework you like (but of course preferably only one) standard DOM API that other components can easily consume. You can even manipulate it via plain JavaScipt As I worked with Vue at that time I wrote Custom Element's adapter for Vue - https://github.com/karol-f/vue-custom-element - so you have superior integration (e.g. Vue's $emit send standard DOM event that can be captured via plain JS or e.g. React/Angular) and IE9+ compatibility. I recommend to look at such solution as you: - will be future-proof - won't be tied with any framework you choose today - your users will see standard HTML elements and can interact with them with framework they like or even with plain JS - There woun't be manual Vue (or other framework) initialization as browser will tell you and auto-init component if it's on page (you can even lazy load component such way) and many more. Such solution is not tied with Vue - you can use any other framework you like. Also Web Component's Custom Elements are standard browser feature and won't be gone anywhere! Regards! 
&gt; It's a heavy push for syntactic sugar that more recent languages have been using. Other than pure cosmetic value, there's no benefit, only detrimental effects. Syntax sugar has value, because it makes your code more declarative and eliminates noise. It abstracts common boilerplate code into syntax that implies the same thing in simplified way. Almost anything new in JavaScript is syntax sugar, same thing can be accomplished with a little bit of extra code. Every software ever built in JavaScript (and many other programming languages) could be built with a very minimal subset of features, but that doesn't mean every other feature is useless. You don't *need* arrow functions, when you can just use regular functions and their `bind` prototype to accomplish the exact same thing, just with a little bit more code. However, when you abstract the boilerplate away into neat syntax, you can do the same thing more conveniently. Your code is more focused on intent, than repeating the same technical details to accomplish it. In turn, previously inconvenient patterns that required excessive boilerplate become more convenient and developers get more viable solutions to whatever problem they are trying to solve. Is this *good* use of syntax sugar? That can be argued about and that's why it's a *proposal* which the TC39 committee will *consider*. Moving to stage 1 means you've presented your proposal and someone has agreed it's valuable enough to further look into and figure out any potential issues with it. Developers can try it, submit feedback and if it's both wanted and doesn't cause conflicts or significant overhead with the language, it's probably a good thing to have. &gt; In short, we should stop trying to turn js into a language that it is not, nor should be. Which version of the specification you'd want to lock for all eternity? I'm pretty sure most developers are happy with the fact the language has further developed into something more expressive and convenient than it used to be in the past. JavaScript isn't the best programming language to begin with, but that doesn't mean it can't improve. The reason why many features from other languages are being considered is that they are proven to be useful. Very few language proposals are born in a vacuum with no prior use cases. You may propose anything, but it's up to the committee and fellow developers to decide what's useful to have in the language. If anything, this is a push to make JavaScript more *convenient* for functional programming paradigm. The language already has first-class functions to facilitate it, it's just pain in the ass to take full advantage of it.
that fizzBuzz example seems like a very elaborate way to return a static "20". 
Java is anything but bloated. It's actually lacking a lot of nice features present in the other modern languages 
Never really "felt" that one. Now how about that bind operator?
Until now every render needed a single top-level HTML element.