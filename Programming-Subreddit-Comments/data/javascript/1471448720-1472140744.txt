Unfortunately no. Safari doesn't support getUserMedia(). Also the older Navigator.getUserMedia() has been deprecated and renamed to MediaDevices.getUserMedia().
Yea, it's: Content-Disposition: attachment; filename=foobar.baz There should be a way to add this response header to an entire directory.
Use a promise library that has an all() method of handling all resolutions. I like q
Conceptually methods are functions bound to an object/class/instance. It differs per language what this means technically. In Javascript it doesn't matter that much, only difference is that the 'this' object is generally different on a method. On a method the this object refers to the object the method is on, in a regular function it refers to the context or the function itself, this can also be influenced by using bind, apply or call.
Except this is JavaScript, so methods don't really belong to objects, they are simply referenced.
You’re right. I overlooked that. In a function’s top level scope and in the global scope, “named” functions are also methods. Otherwise, they are not.
I like it. In C++ when a function is a member of a class, it's called a "member function". Seems obvious, right? I like it a lot better than a completely different other name like "method".
Unless you're dealing with creating a huge number of elements, I doubt there'd be much difference in how you do it. Personally I prefer creating elements on the fly and appending them into a document fragment held in memory, then injecting that fragment into the page. That way you're only dealing with the slow part - injecting to the DOM - once.
&gt; a function should always return a value, a "pure" function should also have no side effects What about a function that, say, saves to a database and has no return value? What about a class method that has no side effects?
Hey! *Pure* javascript... no libraries... written from scratch. I've been working with the `DOMSubtreeModified` event and trying to work some setTimeouts in there. Thinking about maybe doing a setInterval deal...
Do you have anyone who can help you when things aren't working right? If no then you are senior.
any plan to put this on GitHub?
thanks this is a great example
Don't hang me up on it, but browsers usually do a request looking for a favicon. So if you were to print out the routes that is hit, you should see something like "/favicon.ico"
The other request is most likely to favicon.ico, browsers try to fetch the icon. Try logging the request url with console.log(req.url) to debug it.
There's a couple ways to do this, but you obviously need access to the file reader, which is in another function, when you click your other function, right? So with that in mind, you should scope your fileReader variable correctly by hoisting it in the parent scope (e.g. make it global). Then from there, when someone clicks your add another product function, you simply can check if (fileReader.readyState == 2) { // your code to append the image }. I added on to my example for you here: https://jsfiddle.net/pL660us0/3/
[Pure, artisanal, grass-fed Javascript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)
PDF is pretty much unusable on smartphones. It's annoying to read and navigate. I'm really not much of a fan of using PDF as an ebook format. For what it's worth, some of these are also available in other formats. E.g. *The Problem with Native JavaScript APIs* by Nicholas C. Zakas is also available as ePub and Mobi: http://www.oreilly.com/programming/free/native-javascript-apis.csp
OK, now let's get pedantic. considering your second example: class foo { myMethod() { return 1.1; } } is `toString()` a function or a method with respect to `foo`? Because javascript is prototypal, `toString()` is not part of the `foo` class. 
To answer the title, yes, it's wrong. But calling a method a function is not. Methods are functions, but functions are not always methods. A method is a type of function.
It is a method you get from your prototype chain.
Why avoid frameworks? We get paid for results, not LOC, learn your tools and learn to distinguish what's good and bad 
its probably much easier to use powershell for this .... install the powershell module "importexcel" then simply open powershell and run: import-excel path\to\file.xlsx | convertto-html | out-file path\to\file.html that will give you a file with an html table with columns and rows that correspond to your xlsx file's columns and rows edit: If you first save the xlsx sheet as a CSV file, then you dont need to install any modules for powershell and can just run: import-csv path\to\file.csv | convertto-html | out-file path\to\file.html edit 2: in case it isnt obvious, powershell is a windows thing, so if you arent on windows, forget about this comment
You are an instance of class human. Functions are tools like hammers and screwdrivers that exist outside of you which you use to do singular things. Methods are things like metabolism and breathing that exist inside of you to help you do things. It's not the best analogy because those things that exist outside of you could also be instances of classes which have methods inside of them, but it more or less conveys the idea. 
Honestly, I don't think people know. Performance won't matter much unless you're dealing with an absolutely insane amount of elements. If you're dealing with that many elements, please do a performance study and share it with the internet, people will love you for it.
In C, yes, such a procedure is also coined as a function. But I try to stick to mathematical definitions when speaking about language-agnostic concepts, since computer science is essentially applied mathematics.
A quick Google search seems to indicate that you're loading your front end in the browser from something like &gt; file:// Like when you double click a file. Or similar. Try to run a local server and load your font end from there. Something like &gt; http://localhost:8080
Yep that was it !! Thank you !
&gt; toString is a method on Object FTFY
&gt; in general they are not a time-based thing. In an ideal world. But in reality, a 28 year old with "8 years of experience" on his resume will be picked over the 20 year old who's actually more talented, creative, etc. Let's not pretend hiring people don't have biases.
I like real numbers.
It's also on the number object 
We have a circle, I refer back to what I already wrote, exact same response. I don't see why you think your reply makes a difference, the problem still is exactly the same. If you can't decide within 30 seconds after clicking on the link whether or not it's worth reading you should work on that. "Experts" produce garbage too. Everybody has the same problem with all those subreddits, deciding if a submission is worth the click or not. You presuppose a) finding out about the submitter is a good predictor of content - questionable, but there's worse, b) that finding out about the submitter takes less time than just clicking the submission (which you have to do anyway) and finding out for yourself. This shows us that your argument is a *strawman*: no way this is any faster. In the same amount of time you can easily look at the content and lower your error rate *substantially*. Why use a (only loosely coupled) proxy variable when examining the real one is at least as easy?
https://www.reddit.com/r/LearnJavascript The side bar has a pretty great list.
I'm sorry. I only use OrganicJS.
&gt; 3 chars longer 4\. You forgot the semicolon.
Hi all. I built this component after being unable to find anything that suited my needs. React Grid Gallery is highly configurable yet simple to enough to use with very little configuration. If you need a gallery with selectable images then this might suit you. No careful image curation, no specific ordering and no tricks, just beautifully justified images. [Project page](https://benhowell.github.io/react-grid-gallery/) [Github](https://github.com/benhowell/react-grid-gallery) 
hehe right, there you go
This is an excellent solution to the question as presented. OP, wouldn't it be better design to not wait for the user to click the next button, and instead just show the selected image in the fileReader's callback? Also, take advantage of the "accept" attribute on the input: &lt;input type="file" accept="image/*"&gt; (Edit: remove accidental yelling) 
Angular2 with ASP.net MVC 5 is what I am using. Typescript was useful. 
Got node-red?
Many year ago i learned like this: Step 1. Do a alert on a page. Step 2. learn how to include Jquery. Step 3. use jquery to change the color of the background for example. Step 4. figure out how json looks. step 5. learn to use jquery to loop through your json. step 6. poke around with jquery to make ajax calls. And as you know from R there is a lot of trial and error and exploration. Good luck.
Named functions also help with debugging when something inevitably vomits up an error. Seeing a name means I have something to grep for. 
Does this also matter when debugging stack traces? I was under the impression that named functions provide more information (a name) for debugging.
Oh! So the inputs stop being inputs then? That makes more sense. In that case I'm a little concerned about a possible race condition between the fileReader finishing and the user clicking the button, but I didn't look that closely at /u/nickgcattaneo 's code. Otherwise it's spot on.
What's the goal/intended use of the application? Anyone can spew a list of technologies, but not all will actually meet your needs.
From an explanation in the FAQ about why a special character instead of `private`: &gt;Consider this scenario: class X { private a; constructor(a) { this.a = a } swap(otherX) { let otherA = otherX.a; otherX.a = this.a; this.a = otherA; return otherA; } } &gt; Let's call swap with an instance of X as the argument: let x1 = new X(1); let x2 = new X(2); x1.swap(x2); // --&gt; 2 &gt; In this case, the reference to otherX.a should access the private field named "a", agreed? I don't know what kind of crack they're smoking, if `a` is a private field on `otherX`, it should absolutely NOT give access. That's the point of private fields. `this.a`, yes. `otherX.a`, no. Not even if it's an instance of the same class. If a JS interpreter isn't sophisticated enough to look in memory at the context of `a` for the object passed in to know whether it's private or not, and it relies on a special symbol in the property name to convey that information, then JavaScript has bigger problems than I thought.... 
How about just using classes and you can either have myFunc() { } or myFunc = () =&gt; { }?
You mean, just abandon the whole top level function concept hehe?
Lol missed that part
What?
Despite the use of arrows or not, I'm against taking advantage of hoisting. I would declare function statements above where they are used because I don't want to have to look up or down to find stuff. I mean we *are* human.. its much more natural to read from top to bottom. Also I like treating everything as a variable. It helps me come up with better names.
I completely disagree... they should be treated no differently than variables, which when appearing out of nowhere without first being defined makes one think it's an error. This also encourages writing very compact and concise modules, where you see the function imports in the same eyeshot above where you use them.
I used C# exactly once, to fix a bug in a command line utility that was later re-written as a 10-line shell script. :-D I've never seen anything else written in C# 
&gt; they should be treated no differently than variables, which when appearing out of nowhere without first being defined makes one think it's an error. If you have a kind of decent editor/linter and you don't get an error, you can safely assume that it is a function defined later :) If they are large and meant to be reused in other modules, it is of course useful to put them in their own module. But often, they are more like "private functions" so to say, only interesting for this module. Then it is only confusing "hey, what is this module doing here, which module is even using this function?". I don't see the benefit. I think this is a convention already being used in C, where many people put their main function on top of the file. It is like, say that I have a conversation. And I talk out of nothing hours to him about how to learn javascript, and how web dev works, I may not even get his full attention, he may not let me talk out. But if I first begin with that if he learns this, he can get a very good job, it may be a very different story. Of course this example is not completely valid, as learnJavascript is likely not a private function ;) You will want to use it in other modules, but I think my point is clear. import {averageIQ, time, patience} from './you'; import {coffee} from './me'; function learnJavascript(averageIQ, time, patience, coffee) { // very long code } function learnCss(time, patience) { // ... } function learnHtml() { // ... } function learnWebDevelopment(averageIQ, time, patience, coffee) { learnJavascript(averageIQ, time, patience, coffee); learnCss(time, patience); learnHtml(); } if (learnWebDevelopment(averageIQ, time, patience, coffee)) { console.log("You got just got hired for a very well paid job!"); } I think you give the reader a better picture of what the module is doing, if you put the last 3 lines on top.
I don't know if it would have saved you some time, or currently save you from some bugs right now but Flickr open sourced their justified layout algorithm about 2 years ago: https://github.com/flickr/justified-layout 
Just put the code on that page and make it fetch the JSON data using AJAX.
&gt; vanilla JS (so no jQuery) Why? I mean, the DOM apis are better than they used to be, but they're not great. With Angular or React you deal with the DOM even less than you do with jQuery. With 'vanilla js' you will have to a bunch of DOM bs. Frankly, this is exactly what jQuery is good for.
I think it depends on circumstance which is more natural. Oftentimes when doing a code review, I'll see some function like CalculateBlah, but that function is meaningless without the context of how it is used or what Blah means. When this happens, I will first search for call sites to understand what the caller is trying to do, and only once I understand the caller do I continue reading to see if the function does what the caller is asking.
&gt; How do I get it so the prompt appears on click and not refresh. The same way you did with the `.normal` elements, with [click()](https://api.jquery.com/click/). Declare the `userNum` variable and set it to 0. In the click handler, execute `prompt()` and assign the result to `userNum` variable. &gt; The squares within each row are all filled in when I click the button, but I want it to happen when I hover over them.... Use [hover()](https://api.jquery.com/hover/) instead of `click()`.
Wait, `swap()` should be able to access private fields as it is the member of the same class. Regardless of whether the private property belongs to `this` or that
Which gets it from the object prototype
As you mentioned, recent JS engines will try to [assign reasonable names at function-creation time](http://www.2ality.com/2015/09/function-names-es6.html#caveat-names-assigned-during-creation), but other than that, there's no way to make an arrow function have a name: var a = _ =&gt; $ =&gt; ++_, b = a(-4); console.log(a, a.name, b, b.name, b(), b()); // =&gt; function _ =&gt; $ =&gt; ++_, "a", function $ =&gt; ++_, "", -3, -2
That's very interesting--I didn't quite see it that way. I may actually skim stuff and jump to the bottom of a file, to check exports or the main method. I guess I don't like having the most important part (the main method) be sandwiched in the middle of a file.
Reading the comments in the repo, it looks like there are issues with Firefox. 
jquery is for the future use in this game so not much use in this version :)
You'll get used to reading the new way.
Sweet.js would let you define this! Perhaps we've hit a point where the js world is ready for macros. ;-)
vs. "here's what we're doing - this is how we do it" : This is a chicken &amp; egg question, very subjective. Use whichever method fits your model best (*personally, I like fn 1st*) but as long as you're consistent it shouldn't be a problem.
I am confused on what this is for / what need this fulfills? immutable bindings... meaning a variable that cannot be overwritten within the class scope but who's value is mutable? It is just syntactic sugar for symbols?
&gt; Works great across all browers except internet explorer and Edge do people still test in ie? i haven't in years.
I don't spend a lot of (any) time reading random es6 code written by other developers, but is it really that prevalent to write named functions (although they wouldn't even be named anymore..) with the arrow syntax as the premise of the article suggests? To be it seems natural that you use it for the most part when you want to pass in an anonymous function to another function, or when you specifically need to take advantage of the `this` binding. And that's mostly how I've seen people use it as well. 
Absolutely agreed. function someFunction (arg1) { anotherThing(arg1); } The above reads very clearly left to right. The intent of the statement is obvious from the very first word. Whereas the below, at first glance, looks like an assignment of a comparison. const someFunction = (arg1) =&gt; anotherThing(arg1) You're 5 tokens into the line before you realize it's a function, and then the context completely shifts and your brain has to go back to start to re-parse the line.
Hi /u/gangstafat, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
I think the core of the issue is that generally speaking the js community does not embrace simplicity, or even necessarily know what simplicity is. The community does not successfully work together to create elegant and simple solutions. I think React is the perfect example of this, where you have this relatively elegant core of features whose simplicity is completely and utterly negated by its whole surrounding ecosystem of transpilers, bundlers, outdated tutorials, and shitty documentation.
I was skeptical of the arrow syntax until I realized that it preserves the "this" context. Was getting pretty tired of having to do "var self = this;" and bind() all over the place.
I think I realized that arrow functions were going to be a nightmare for readability when I first saw them chained. Way too easy to abuse the implicit return. var factory = func =&gt; callback =&gt; context =&gt; { I'm now of the opinion that they should be mostly avoided except for anonymous callback functions/procedural parameters.
Thanks so much mate, worth mentioning I don't draw the canvas, only using the canvas to Png part of that, but works well in all other browsers
But what about the rest?
&gt; Then explain to me what information it conveys. Let's say that you have a mobile interface for editing text. You want to be able to open a full-page dialog - it has to be full screen because you can't constrain the size any further - but in user testing, you find that users keep thinking they've navigated to a new page and that their changes haven't saved. Transitioning in a panel shows that they are actually still in the same place. Let's imagine a set of thumbnails. When you tap them, you want to see a detailed view. If you animate the thumbnail 'expanding into' the screen, you make it explicitly clear what has happened. If a user accidentally triggers a thumbnail, they won't be confused what has happened. Let's say you have a touch an drag interface. It works great, but users in testing keep failing to discover they can pick items up. You've tried help text but they just don't bother reading it. So you make sure the items are added with a short animated 'drop' when they enter the viewport, and that tells users that these items are not as 'fixed' as their siblings. That in turn hints they can be moved.
But he uses it wrong. From there he goes on to say: &gt; Take a look at this: &gt; const maxNumberOfItemsInCart = ...; &gt; You read all those characters and you still don’t know if the ellipsis represents a function or some other value. But that's *wrong*. It's simply not how our brain works. You all know the thing wrehe you jmbule all ltteres but the fsirt and the lsat, but are still able to read everything? That's because your brain works using pattern matching. If there's an easy to spot indicator ahead of what you're “currently” reading, you'll notice it and take it into account. `=&gt;`, especially when syntax highlighted, will work very well for that. Your brain will see `const max######rt = 100` or `const max######rt = (...) =&gt; ...`, and then consider the details.
That's pretty much my take. If youre assigning your arrow function to a variable/constant for use elsewhere - then a function is probably a smarter call. Also when working with the prototype function() is what you probably want too - for your usage of 'this'. Its also nice to just be able to grep 'function' sometimes.
But that's wrong. Brains don't work like that. You first see the code page and its general structure, including specially highlighted keywords you've learned to recognize. (E.g. you see where a class declaration starts and ends if it's properly indented. Then you do the same more finely grained for each line. Then you see the first few elements on the line without reading the words and *then* you'll start reading from left to right. So if you don't use long-ass variable names and function signatures, you'll immediately see the `=&gt;` before you started really reading the line.
It becomes especially horrible when you nest arrow functions which some people regard as elegant because they managed to shave off a few characters
Also worth mentioning that an IDE may well style the variable differently depending on type (more likely when using something like TypeScript)
http://imgur.com/NLpPOd1
As you said, jQuery is just a library for fiddling with DOM, it has little impact on the overal architecture.
&gt; I wont be using let, it'd have been better if it let was default behavior of var, but now you have 2 ways to declare variables. imagine code where let and var are thrown everywhere, either way stick with one dominant way. Just don't use `var` anymore. Use a linter which flags it and get rid of it. For-loop iteration scope alone makes it worth it. &gt; Also hate being able to declare function just like nothing in curly brackets. how is that different from block.??? one comma difference? Do you have an example?
IE9-11 doesn't support the "download" attribute. Edge 12/13 does, though. http://caniuse.com/download
I never used jQuery in any of my games. If it's for doing XHR, I'd use the fetch polyfill instead.
The elements appear when the bottom of the element is past the bottom of the viewport. And when you're on mobile, this could mean there could appear a large chunk of white space before the user sees anything. Maybe start displaying the element when it's like 50% above the bottom of the viewport.
You completely misunderstand how that works. When I read jumbled text my reading speed dramatically drops as I suspect it does for absolutely everybody else. The only exception to this rule is when letters are jumbled in such a way that syllables remain entirely intact. To understand the neurology read up about dyslexia and orthographic processing. The author's point and code examples are entirely valid. My personal thought's are that people hide behind abstractions and conventions because they are code dyslexic, which of course is still failure when the bullshit results in a wider parsed distribution than the more vanilla code it attempted to replace. This won't stop the more OCD of programmers from trying to unnecessarily abstract everything though.
&gt; Is there anyway i can fetch a json file if you are on a certain page Yes, there are several ways to fetch a JSON file when on a certain page.
Symbols don't give you privacy. `Object.getOwnPropertySymbols` lets you access anything "hidden" behind a symbol. You can make things truly private by closing over a WeakMap which uses `this` as key. By using a WeakMap, you won't prevent this instance from being garbage collected. The big problem with that is that it requires some boilerplate code and that it isn't very terse. https://jsfiddle.net/rp6n6nv4/ Kinda terrible, right?
1. Yes and no. JavaScript is fundamentally and irrevocably different than those C++ based languages. But JavaScript is evolving supplemental conventions to close that gap. The biggest barrier for developers new to JavaScript is to accept that JavaScript doesn't want to be C++, Java, Python, or whatever. 2. Because you cannot escape OO concepts in C++ like languages, so if those developers are new to JavaScript then OO is new again. 3. No. Eventually developers who develop (primarily) in this language long enough eventually drop the unnecessary boilerplate and slide from OO to functional programming. OO tends to mean more code and extra effort to do the same things, which is nice when learning new things is hard. 4. Because frameworks are an abstraction. Various degrees of abstraction are wonderful, but that amount of abstraction needed varies dramatically by the given task. Frameworks don't account for such variance and instead apply a blanket solution, which tends to be substantial overkill in many cases. Custom abstractions are easy to write, so when I need custom abstractions I will write them as necessary to ease code reading. Beyond that its just extra luggage.
Instead of the way I've tried to do things, how would you design something like this? What I'm trying to achieve is remotely similar to Facebooks "Add service" on a business page. Except the jQuery is to show the user what it will look like once published, as I will have to modify the image, and it may differ to what they've expected.
that's why i just stuck in plain and simple FP , seems like every day OOP gets more weird
I agree and while I abuse a lot arrow functions, I never declare "function objects" with it because of readability problems. I only use it as callbacks, for example to Array.map etc.
But if you don't compress everything into the most terse style you can't show of your l33t ninja hacker skillz :(
I know you've already learnt it by now, but just as an example of how Babel does it: const x = () =&gt; true; const y = x; console.log(x.name, y.name, y()); becomes var x = function x() { return true; }; var y = x; console.log(x.name, y.name, y()); Result: x x true
can you give me a example? 
A similar rule would be to use `const .. = (..) =&gt; ..` if it will save you writing `return ..;` (i.e. if your function body is a single return statement), and `function ..(..) {..}` otherwise.
turns out you can use Object.defineProperty to override the name of a function. It's hacky as all hell, but it works.
IHMO JavaScript is still reaaaaally far away from C++, C# and Java. The latest features are still pretty simple in comparison to what you can achieve in C++ or C#. The gap is still pretty big. Actually, I can't wait to see which features from the 90s they will invent now.
I suggest that you use Cycle.js for the views with Immutable.js and webpack. Immutable data leads to much simpler application development, no defensive copying, and enabling advanced memoization and change detection techniques with simple logic. &gt; Other concerns from the client include ... longevity ... Approximately 10 years I would highly recommend you that you directly uses some new features of ES7 such as await/async all over your code because, for sure they'll still going to be there in 10 years. Also ASP.Net is from the past now you should use some server side rendering with Koa.js.
Looking at their code why do they encode some url slashes as &amp; #x2F; They save 290 bytes if you don't do that? This is not a practice I'm familiar with. 6,395 - a-k-apart.html 6,105 - a-k-apart_replaced-shlashes.html
If anything functional programming is becoming even more common in the JS world because of React, Redux, etc. Those frameworks / libs show the power of designing things via pure functions and how expressive that approach to software engineering can be. It's important to remember that as a real life engineer, it's less about being "all or nothing" or deciding before hand exactly the school of philosophy you're going to use for a project, and more about finding the best tool for the problem you're trying to solve. Sometimes that's a highly OO approach (ORMs, dependency injected services, etc). Sometimes it's highly functional (views-as-pure-functions a la React, flux archs like redux, etc). Javascript is evolving so that lots of very well-proven patterns can be expressed very cleanly, which is great, since there's no "best" approach that most cleanly solves every problem you're likely to run into.
`()=&gt; ({ x })` The code above looks like dirty ascii. The ideal role of arrow functions are small callbacks, with just one parameter if possible to avoid parentheses: `$http.get(url, data =&gt; model.data = data);` (Also: friendly reminder that arrow functions cannot be newed. So in some case it's not just a matter of looks... something to be aware of. Important if you're using a library like Angular which calls new under the hood. The bit below will not work). app.service("data", $http =&gt; { //... your functions here });
For longevity it seems ember has the best track record so far for a large framework. Your other option is to use many small replaceable parts.
In console do this: Number.toString === Object.toString
why dont u use coffeescript or ES6 just a suggestion ;)
I didn't say animations were useless. I said the animations *in the OP* conveyed no information. Turning a button into a graph into a highlight is web dev masturbation.
I was expecting something in the vein of the old "horse_ebooks" account on Twitter.
my point wasn’t that they’re exactly as easy to read. my point was that you are able to read them reasonably fast because the word shape is important enough that it plays a big role. and that this shows how you first see the overall shape and only then the the individual letters. there’s more fun to it, e.g. the way do don’t see that i put in one “the” too much in the previous sentence. &gt; You completely misunderstand how that works great job building a strawman and tearing it down. maybe you should make an effort to read what somebody writes before you judge how well they understand something. --- &gt; My personal thought's are that people hide behind abstractions and conventions because they are code dyslexic does that mean you’re fan of the tiring repetition Go enforces? i use abstractions because it allows you to search breadth-first and only dive deeper once you understood the high level.
&gt; Is Javascript loosing is "Functional" or "Pure Functions" programming paradigms ? JS certainly isn't losing any features.
Aww, in your example nobody ever gets hired :(
and the name is too long in the first place. const maxCartSize = (p) =&gt; p*10 would be perfectly clear as well (i would have used something better than “p” if i had any idea what a “statusPoint” is) i found a good convention somewhere: everything you can derive from context is superfluous. if that function is defined inside of a “Cart” class or function regarding carts, it shouldn’t have “cart” in its name
Generally true, but when you're talking about some large scale application, the number of uses of poorer performance techniques even outside of loops, can add up. In general, you're usually good so long as you don't bog the UI, but once things become significantly complex, it can be very difficult to track. I would *hope* that the easier to write and *native* solutions would've become faster than just writing things in javascript.. but i'm not entirely certain that the engines are built that way. JSC had much faster .map() than V8 did when I tested that a few years ago, but both were still slower than just for() .. and it boggled my mind. 
Of course that will be true, both looks like this: function toString() { [native code] } See also https://tc39.github.io/ecma262/#sec-number.prototype.tostring &gt; The toString function is not generic; it throws a TypeError exception if its this value is not a Number or a Number object. Therefore, it cannot be transferred to other kinds of objects for use as a method.
I wouldn't use Controller (C) as React components already provide solution for that need. Models can be simple objects or store or e.g. MobX observable. 
I agree that the absolute necessity to maintain backwards compatibility leads to warts in the language. It's something we have to live with. There is no rebooting the Internet. The solution I see people moving towards is for JavaScript to become a compilation target. We'll be writing in Elm, Clojure, or what have you and the transpiler will deal with the ugliness.
Sorry, I meant something alone without React. I have to rewrite my app(it barely needs any View-related manipulation, but has too much logic to make it sane with vanilla).
`let` solves a different problem. It's intended to keep variables within the scope of a block (eg `for` loop) rather than the whole function. Private variables are bigger than the scope of functions. They're about classes. And private variables _are not specific to Java_. :)
Man, I sure hope so. I'm experiencing short waves of panic these days when I read up on modern JS.
I'd recommend reading the [overview](http://webassembly.github.io/) and swinging by the binaryen link when you get to it. Should give you an idea of what it is and what the toolchain looks like.
that is another thing, lot of new syntax doesn't have same falvor. usually every language has some unique style... but looking at this ... you go like wtf &gt;import { test } from 'abc'; &gt; &gt;test.bla = { x, y} &gt; &gt;{ &gt; ()=&gt; e+2; &gt; const function what() {} &gt; { &gt; function who() {} &gt; } &gt;} &gt; &gt;a = { &gt; function test() {}, &gt; function nope() {} &gt;} &gt;b = {a: 1} 
[It's in the spec](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-setfunctionname), so maybe unorthodox, but not _that_ hacky :)
Angular 2 seems like it's even starting to enforce immutable code with the way it watches collections now. I'm guessing you can do a deep inspection, but I think it does a pointer comparison by default.
&gt; great job building a strawman and tearing it down. Its not a strawman if it attacks the subject of your comment, and its certainly not strawman because it invalidates your claim.
&gt;and that this shows how you first see the overall shape and only then the the individual letters. there’s more fun to it, e.g. the way do don’t see that i put in one “the” too much in the previous sentence. I did, as well as that you wrote "do" instead of "you". :) 
No idea. I've only supported evergreen browsers the past 3 years. Check caniuse.com
A solution without promises: function wait(asyncs, success, failure) { var count = 0; asyncs.forEach(function(c) { c(function() { count++; if( count === asyncs.length ) success(); }, failure); }); } var ajaxCalls = [...]; wait(ajaxCalls, function() { /* success */ }, function() { /* error */ });
 No problem. I've been looking to implement something similar myself, so I can give you a quick rundown on the differences between your implementation and Flickr's. First off, I'd like to say: I love this. You've done a great job on the UI especially the selection; and your code is very readable so its not like I have to just drop in your implementation as a black box. In Flickr's version you have certain knobs you can toggle: 1. fullWidthBreakoutRowCadence - This lets you insert a fullwidth wide image every N images. Flickr uses it for their album pages. It's also handy for a display with a 'hero' banner style first image. 2. showWidows - should we ommit the last few images from the layout if they can't make up a full row? Useful in two cases: - Infinite scrolling: You can cut off a logical 'page', insert a stretch add, then include the ommited images in the next page. - Album pages preview &amp; summary; you can cut off the last images and stick a 'more' images button there. 3. maxNumRows - exactly what it sounds like; constrains the # of rows delivered to prevent overly long pages when resizing the screen (or letting you use essentially the same code b/w mobile and desktop). 4. You don't actually need image heights/widths; you can just set a target height and give it aspect ratios. This also simplifies changing the layout to target different device sizes. The rest of their code deals with edge cases. Hopefully that helps you decide. For what it's worth, I think its emminently useful. ---- About your code though.... 1. 'srcset' is documented but doesn't appear to be used anywhere; not even the lightbox. 2. I think it'd be useful to let end-users replace the lightbox with their own implementation. Maybe a onOpen() instead of passing customControls to the gallery as a whole. That'd give people the chance to implement things apart from lightboxes to display the full image---for example instead handling the showing of an image preview with an inline block like Google images does it. --- Anyways, I hope this hasn't been too long of a comment. I don't want to sound like it's a rant. :)
&gt; One of these days I'll get better haskell. That's a little ironic: in Haskell, not only can you define functions in whatever order you want, sometimes you *need* to refer both forward and backward in the same file, because of recursive calls between those functions.
So after reading &gt; The toString function is not generic; it throws a TypeError exception if its this value is not a Number or a Number object. Therefore, it cannot be transferred to other kinds of objects for use as a method. you still claim that `Number.toString` is the same as `Object.toString`?
Also works this way in Java.
can’t get them all.
no. i explained why it didn’t in the comment above. first sentence.
&gt; Currently, the proposition value of the beamie project is exactly zero. We respectfully disagree. Beame.io allows establishment of an HTTPS session between two devices without public IP addresses with no prior configuration. &gt; Why? No tutorials, no video guide and no explanations that are easy to understand. We are working on making our materials as understandable as possible. &gt; Stop clickbaiting. Titles like &gt; How to deploy service accessible from the Internet or only from your LAN without network configuration &gt; is absolute bullshit, because you offer a freaking online service for certificates which is exactly what letsencrypt also solves in an easy, understandable, and really offline-usable way. Services like Let's Encrypt have their own value, but we provide more than just a "freaking online service for certificates." The main difference between us and Let's Encrypt is that they require you to have a public IP address on your server which has to be pre-registered in the DNS. We target machines or devices without permanent IP addresses such as devices behind NAT. We offer unique and random domains on a subdomain of our own, therefore we don't provide a meaningful identity. You can assign the meaning yourself. We provide TLS tunneling to run your own HTTPS server on a private LAN and have it still globally accessible. &gt; C'mon guys, everybody knows how to generate offline SSL certificates on a local webserver. The only difference your webservice makes is to offer is a cross-signing browser auto-accepts it effect. And for that, you currently have zero tutorials and zero proposition on how you solve that and how you are different from definitely easier alternatives like letsencrypt. See differentiation above. &gt; If you claim to have LAN integration, how come that your SSL certificates still have no wildcard support? We intentionally do not provide wildcard support. Wilcard certs are usually offered by companies that already charge hundreds of dollars for certs. Our certs will be priced at pennies when we are out of the free beta period. Let's Encrypt also doesn't offer wildcards, by the way. &gt;Why are certificates issued by lfe.com, an online course creation platform? Yes, I think your service is total scam because of the mentioned reasons. LFE was the previous name of our company which got the current batch of certs. When we use up the first batch, we will be issuing ones from Beame.io. We are actually giving those certs away for free to developers that try installing our SDK. Beame.io's certs are publicly trusted, and signed by a major root CA, GlobalSign. We hope you'll try our SDK by creating developer credentials at the GitHub link in the original post. We look forward to your feedback when you do, and of course, we'll be happy to address any of your other concerns. 
I don't see any FP features that JS has but these 3 languages don't.
&gt; A method to me is something that alters the state of the object it resides in. Does that mean Array concat or slice aren't methods?
I'm not sure the question so much is "what is the C?" as much as it should be "why the C?". Largely, React is a move towards functional programming. An application constructed from React components as well as a state provider that is responsible for providing predictable state to those components does not predicate the use of a unilateral relationship between a single model and a view or a single view and a controller or any other combination. While I'm not questioning the usefulness of models, I'm certainly questioning the usefulness of controllers. My first question to anyone who thinks that controllers are still a necessary paradigm in JavaScript is "what are you trying to control that you cannot with a react component with attribute-bound events?" And I certainly think that the traditional concept of a model needs to be revisited to consider the fact that a component should only consume the data it needs to render (which is, I believe, why Facebook developed graphQL). 
thanks! just learning js
thanks!
Excellent writeup. Thanks op!
Plot twist: it is `slow-deps` itself
Every javascript file I write follows the following structure. 1. Variable/Const Declarations at the top 2. Code, i.e. the overall function of the module in the middle 3. Subroutines, or reusable logic (always declared as function declarations) at the bottom. This way there is a clear separation of smaller reusable logic from the logic of the module as a whole. 
I actually hadn't heard much about it until talking with Jafar. It does look pretty interesting. I need to find some time to look at it more. I'd be interested to hear other peoples thoughts or experiences as well.
[State dependent learning](https://www.youtube.com/watch?v=--jbz900gVo)... thats my excuse and I'm sticking to it! 
Yes, this is quite similar. You close-over the things you want to use internally. Since there isn't a closure you could use for this, you have to resort to putting things into a WeakMap. Anyhow, the big benefit of this proposal is that it's terse and declarative. So, your editor could for example show those private fields in this class' outline. It's always beneficial if your tools can tell what all those bits and pieces are.
 typeof new Array() "object" typeof [] "object"
I may be mistaken but I don't believe C++ can do closures as one can do in JS. JS functions have access to the variables defined in the outer scope even after that scope is freed. Closures are a big part of partial application, and/or currying and required for many FP constructs.
hell ya thanks.
If an object is handed to you, you can modify it unless it was frozen. https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze There is also Object.seal and Object.preventExtensions. Note that freezing is only skin-deep. The objects inside that object aren't affected by this. Primitives (number, boolean, string, symbol, undefined, null) are "by value" because they are immutable. E.g. when you append some text to some string, you create a new string. Continuously appending things to a string in a loop is only fast in JS because today's engines have a workaround for that. Otherwise the run time would increase exponentially with the number of iterations.
Choose what you need for current project. Who cares that you use technology that is little dated but fits your architecture and patterns. Also, from my experience, it's easier to replace one library than whole framework. 
I use arrow functions, but still write multiple lines and include a `return`, just for readability. () =&gt; { return "something"; } instead of () =&gt; "something";
Great read, will be keeping an eye on this. Thanks!
&gt; React has long had a struggle with building animations into unmount Isn't that what ReactCSSTransitionGroup is for? &gt; Consequently I often end up writing React that doesn't look so different from jQuery code, where I setup the DOM upfront and then toggle some .fade.in classes to make it appear Again this seems like the exact same thing that ReactCSSTransitionGroup does, unless I am misunderstanding what you are saying. For the few scenarios where CSSTransitionGroup doesn't cut it I can usually use react-motion to handle it.
By the way jsx is kind of deprecated as an extension, I would use .js
I'm not saying we are not going to use any library, why would it be costly?
/r/iamverysmart
I think you're correct! foodObject comes from tempSearchResultsArray and baselineFoodObject comes from searchResultsArray Both are derived from an array sent by the server called searchResults. I had this code and I don't think it does what I thought it does: globalValues.userValues.searchResultsArray = searchResults; globalValues.tempValues.tempSearchResultsArray = searchResults.slice(); //duplicate array Changed it to this and it works fine: globalValues.userValues.searchResultsArray = searchResults; globalValues.tempValues.tempSearchResultsArray = $.extend(true, [], searchResults); EDIT: yup there we go: https://davidwalsh.name/javascript-clone-array deep copy is what I needed, shallow copy is what I did
&gt; I may be mistaken but I don't believe C++ can do closures as one can do in JS. JS functions have access to the variables defined in the outer scope even after that scope is freed. C++ can do that by capturing a reference-counted pointer: auto f() { auto x = make_shared&lt;int&gt;(42); auto closure = [x] () { return *x; }; return closure; } int main() { auto closure = f(); cout &lt;&lt; closure(); // 42 } The magic trick is that whatever variables you want to capture have to be heap allocated and garbage collected. In JavaScript, *everything* is heap allocated and garbage collected so it doesn't look like anything special is happening.
Oh god. You'd use 'l' as a variable name, ever? if (l!=1|l!=l){ print ("that code sucks"); } Get off the bus.
It's evaluating the Angular expression, *not* the result of the expression. The former is hard-coded into the app; the latter is user-provided and stored in the database. The former doesn't need to be sandboxed because it's hard-coded; the latter can be anything because it will never be executed as code! Put another way, an alternate-reality implementation of Angular might accept raw JavaScript code instead of Angular expressions, and compile them with `new Function` instead of parsing. In that case, the markup would look like this: &lt;input ng-model="email"&gt; &lt;span&gt;{{return $scope.email;}}&lt;/span&gt; This is *still* secure! Because the contents of the email variable are *never* executed as code!
Helps you find out why your CI is taking 10 minutes to install dependencies instead of 1...
So does everyone who is ever going to look at your code. Using single letter variables is a fireable offense for people who work for me, with one exception: i. 
&gt; but it's overall a really blunt instrument that defines all children as a single animation happening together. Where jQuery made it easy to chain a bunch of different animations together That's a good point I didn't really consider.
This, I'm an idiot. Number and Object are functions and the "new" toString functions are assigned upon creation through the prototypes. 
Good then that you never will be in a position to fire anyone. 
To be honest I'm pretty sure it's gonna tell me that it's either imagemin's endless building of binaries or protagonist's long ass C compilation
What do you mean when you say "features." Getting stuff done isn't about counting peas, it is about using the right tools. JS has enough to make do, but when you consider its strengths: portability, dev support, readymade support for each and every technology under the sun on npm, readymade async, caching, tooling, debugging, ui frameworks like React, etc. you'll come to a different conclusion as C and Java both will struggle getting anywhere near you weeks later, while you're finished under a weekend. C and Java are great languages that sure can handle lots of tasks that JS can't or isn't designed to handle, especially lowlevel/algorithmical computing. But they also can be blunt instruments for highlevel front- and back-end. Some use-cases in which i would favour JS, other than just web related work If you are using C# to create simple UI driven front-end apps you are stuck in XAML. QT/GTK in C++. JSF in Java. Having had to put up for years with this i'd grab Electron, Node and React in a heartbeat, thank you very much. I'd even faster go JS once this app channels services from the internet. Now writing such a server on the other hand, you are absolutely screwed with C++ being unable to do the simplest of things unless you write them yourself, re-implementing proven concepts on your own. Not that i'm against understanding how things work at byte-level, but who's got time for re-inventing the wheel? Want to communicate with a client? Let's spend a weekend to learn websocket++, a one-mans enterprise and the occasional contributor. Corporate routers block it? Have fun implementing a SocketIO-like server, on your own. The day you're stable we're probably at HTTP5. C# is better but doesn't come close to Node when it comes to available proficiency. Same applies to Java. 
That was it. Thanks so much!
it's my webpack entry file for the tests. in it i require the test files with require.context and run them. i do not need a wildcard just to load one file, given it will always be one file
Except Microsoft Edge.
You are young, in development stage (I mean growing) so it's normal to feel like this. But yes, I think programming and math in general represents a good training for brain no matters the age. I recommend to read about CS in general to be more aware about computers &amp; programming if you feel it attracts you. I started reading CODE by Charles Petzold and I find it an amazing book besides the fact that I learned about some of the stuff from the book in my CS classes I still find this very enjoyable.
Hi /u/timgfx, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index). It might be a better fit in something like /r/programming, because it isn't JS-specific.
Hi /u/timgfx, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
`Array` is a constructor (wikipedia that if you haven't heard of it). `[]` is an _array literal_, and doesn't expose a constructor. The arrays they produce are identical, it's just how the array is created is different. Anywhere that you see `x = []`, you could replace it with `x = new Array()` and everything would work exactly the same. However, if you have: let fromLiteral = [1, 2, 3]; Then to do the same with `Array`, you'd have to do: let fromConstrctor = Array(); fromConstrctor.push(1, 2, 3); And yet... fromLiteral.toString() === fromConstructor.toString(); &gt; true Why would you use one over the other? Pretty much every modern JS style guide advocates to use the array literal, e.g. `[]`, because it's more concise. Lastly, this is very much like `Object`... var fromConstructor = new Object(); x.foo = 1; var fromLiteral = {foo: 1}; // `Object.prototype.toString()` is unhelpful for comparing the actual contents, so use JSON.stringify() JSON.stringify(fromConstructor) === JSON.stringify(fromLiteral); &gt; true TIL: The `new` keyword isn't required for `Array()`, their implementations are identical ([per spec](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-array-constructor), though it's also found in the ECMA-262 3rd Edition). Yet, the same is not true for `Object()`, which instead performs a type conversion ([spec](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-object-constructor), though also in 3rd edition as well).
What did he say?
http://eloquentjavascript.net/ just read this, should give you enough to BS your way through in 3 weeks, assuming you have basic programming skills. 
I know you said no frameworks or big libraries but I've used React in a similar situation to pretty great effect. We just render multiple components to existing elements on the dom and use the React api to define interactivity. MVC, MVVM &amp; Redux don't fit in with a site that is server side rendered (EDIT: I don't mean isomorphic here). If you have all application state managed on the server there is no need for it on the client as well. 
I'm in the same version of chrome. Your results are exactly the same as mine, I just left out the bits that weren't relevant. Yours still shows the name `testFunction`. This behavior is part of the spec for arrow functions, they're supposed to pull their name from the assignment.
Explain what you know so far in regards to coding (any other languages)?
The website is confusing and conflicting. Reading the "Legalese," it says nothing about lazy loading. Rather, ALL files and assets must total below 10kb.
I guess you have not looked into angular2 either. They have lifecycle methods for every components and you can initialize anything in their, no need for angular specific libraries.
HTML / CSS medium familiarity. 
That is really, truly awful.
Tony Alicea's Javascript Understanding the Weird Parts worked great for me.
I wasn't talking about Ng2 but you're right about that.
you're screwed 
Which is why people who know the language recommend always using array literals unless you really NEED to set an array to a specific size.
Kyle Simpson (getify) is a great teacher.
I would agree if OP had a basic foundation in another language. Three weeks is a totally unrealistic time frame to pick up any language for a professional context with zero programming experience. 
Not a chance. Being able to repeat something from a book or lesson and having enough understanding of a language to solve real dev problems are two entirely different things. Not to mention the communication barrier with other developers when talking about the code. I've interviewed dozens of devs, and reviewed hundreds more resumes/portfolios. 3 weeks is not enough to learn JS to put it on a resume, even for the most basic positions. My advice to OP is to learn JS the right way and take your time and be honest with employers. Many will invest in someone capable of learning, but all will resent hiring someone who doesn't live up to their hype. 
Html and css knowledge isn't going to help much... 3 weeks will be enough to know the basics. But it would be pretty easy to see that you only know the basics.
Perfect I'm gonna use this for a scrap mechanic logic gate blueprint editor I started building.
I would also recommend checking out his other talks, they are always good. Definitely should watch his talk on [async javascript](https://www.youtube.com/watch?v=lil4YCCXRYc).
What? How is that different than a string naturally containing a single quote? It's much less likely to result in bugs if that's your concern. Also the only way that's resulting in XSS attacks is if you're eval'ing a `` string or something. Either way, still far less likely to result in issues than normal quoted strings. 
The closest you're going to get is probably http://www.purescript.org
You don't assign named functions to constants, that makes no sense. You'd assign an anonymous function to a constant (`const double = x =&gt; x * 2`) or just declare a named function (`function double(x) { return x * 2;}`).
If you aren't an intermediate developer, then first learn: * the javascript data types * variables * looping constructs * functions * "this" ... if you only know HTML/CSS and have no experience in any programming languages then closures and inheritance are too advanced. Find some examples of validating form fields and make sure you understand how it works! This was all JavaScript was even for in the 90s ;)
I would focus on just conceptually understanding how JS operates. Javascript revolves around objects and arrays, but mostly objects, study those well. Also study for loops, if statements, and functional programming. Understand how the DOM works and how to access it. That should get you a decent start. Be sure to practice what you learn, it's going to be tough if you're completely new to programming.
Well if you want to use Haskell-ish functional programming in JavaScript, you can do that with things like Cycle.js, which uses observables.
Impossible.
&gt; they most certainly become clutter That's you opinion. I prefer to have all my functions follow the same syntax and be runtime-enforced constants. I also like using arrow functions because they force me to not use `this` at all. If I have to pass another value into the function, I can't hackily bind it to `this`, I have to add another parameter. 
`document.cookie` I believe. edit: incorrect usage
Am I doing something wrong? I get [this](http://i.imgur.com/gLdEXzU.png) error
Idk, you see that by your syntax highlighter showing the code parts as code already.
Depends on what you're expected to know. If you're going to be going in as an entry-level developer, you probably don't need to know much, just learn as you need to on the job. If you're expected to hold your own, and develop JS independently, then it depends on other languages you know. If you're coming from an object-oriented language, you just need to know the syntax, how JS simple objects work, and to wrap your mind around how functions get more or less the same treatment as any variable (in most use cases). However, if I read that right, and your experience at this point is HTML/CSS and you're going to be expected to hold your own in 3 weeks, then your only hope is to go through as many beginner tutorials as you can in the next 3 weeks, but know that you may have a tough time on that job.
i would just use this: much easier - https://github.com/js-cookie/js-cookie or you'd have to parse out the cookie string yourself. splitting on `;` then on `=`
Yeah it's document.cookie['foo'] NOT document.cookieS
I actually tried this but it told me the function wasn't defined
because everyone writing JS always has syntax highlighting.
If you want to get cookies without having to open the site you can use chrome.cookies.get({ url: "https://example.org", name: "pfKeyCode" }, cookie =&gt; { console.log("Value of cookie is " + cookie.value); }) You will have to add the "cookies" permission. Check [the documentation](https://developer.chrome.com/extensions/cookies) for more information.
 var cookies = {}; document.cookie.split('; ').map(function(c){ return c.split('=') }) .map(function(c){ cookies[c[0]] = c[1] }); console.log(cookies); //ie: cookies.foo =&gt; foo's value
Forget everything you know, then remember some things, realize that functional programming is everything you have ever wished for, become severely confused about "higher order types" and then you'll know Javascript.
An example: isNaN("a") // true isNaN("0") // false Number.isNaN("a") // false Number.isNaN("0") // false NaN is odd in this case since it doesn't really mean not a number. A string is not a number but under both methods, strings are either not NaN or inconsistently NaN. Number.isNaN = x =&gt; typeof x === 'number' &amp;&amp; isNaN(x) function isNumber(x) { return typeof x === 'number' &amp;&amp; !isNaN(x); }
I have found this to be very helpful on my journey as UI developer [Javascript.info](http://javascript.info/). I started out as java developer than made a turn to UI last year, had very little time before real work started, this helped a lot. It's easy to understand and stresses on pitfalls and differences with other languages. I prefered this over videos because reading (skimming) is faster than skipping something you already know. it is doable in 2-3 weeks time.
can you do: `console.log(document.cookie)` and what do you get?
&gt; Using multiple arguments on .add would break the web Wait, why?
Eloquent Javascript is really great! 👍
You're boned. In three weeks you might be able to learn to mouth a few sounds by rote, but you aren't going to have a clue what the words mean and you *certainly* aren't going to learn to sing or write lyrics yourself... And you're going to last about four seconds in front of an *actual* developer before they suss out that you're bullshitting and don't have a clue. Programming is *hard*, even at a basic level. When you say you're 75% of the things he wants but you only know a bit about HTML and CSS, those "3/4 of things" are maybe 5% of the actual *effort and complexity* of becoming a front-end web dev. It's like saying you're 75% of the way to becoming a professional driver because you know how to open the door, adjust the seats and punch a destination into the GPS. Now you just need that last 25% called "learn to drive a car" *in three weeks* and you're home free! I'm sorry to rain on your parade, but it just doesn't work like that, and the fact you think it does just demonstrates *how totally* you don't understand even the first thing about the subject.
I added a rule to our linter to force using backticks. It's not required strictly speaking, but it helps consistency, and avoids having to change the quotes when adding an interpolation. We used it for a few months now, and nobody has had any issue yet.
In three weeks you aren't going to bullshit a half-way competent developer for more than about ten seconds... especially from a completely cold start (as the OP actually is).
It's probably not an issue, but I'm wondering if the js engine uses more resources to interpret a back tick string because of the possible interpolation...
See my example - using `Set#add` as callback for forEach. forEach passes 3 arguments. `Set#add` ignores all except first. Changing this behaviour would be breaking change. 
Not sure if you're suggesting deprecating single/double quotes for string literals or just discouraging them in favor of always using backticks. Deprecation is a bad idea for backwards compatibility. Discouragement is futile because developers have their own code styles and there is no industry standard for ANYTHING. Just look at the wars we have over spaces/tabs, semicolons, commas, etc. I personally only use the backtick when I'm using it for template strings. I haven't had to write multiline strings yet, but I'm sure I'd prefer it then too. Besides those cases, I stick with single quotes because that's how I've written strings for the last 10 years. Just because ES6 makes single/double quotes unnecessary doesn't mean people are in a rush to stop using them.
I've got no idea how to parse
Thank you very much for the help but I've gotten it to work mixing a couple of the responses here including yours. This time around I remembered to use escape characters ;-;
So I've got it working mixing a couple of the responses here. Turns out in my frustration I forgot escape characters
I used codeschool at first, then some books. Don't read a book from cover to cover - get some sort of overview of the parts of Javascript you want to learn, then (after codeschool) hunt and peck out the parts of the books that cover the stuff you need.
Hey, while I agree with /u/cyex's comment about familiarity &amp; type-ability, I feel I also have a vaguely unique perspective on this problem having actually implemented template strings in TypeScript. If you think about template strings from the tooling perspective, it's actually kind of quirky. Let's say you have an unclosed template string; what does that look like in your editor? Something like this probably: http://imgur.com/nYePokT. Notice that it affects everything after it. The thing is that, kind of like multiline comments, the syntax is a very "destructive" thing. On the other hand, regular strings are extremely isolated. If they don't end at the end of a line, that's usually an error. http://imgur.com/NxbMhAG. Now, does this matter if you're using a good editor with backtick completion? Probably not! But if you ever accidentally erase the closing backtick, it can definitely be annoying.
What I mean is - yes of course, if you just want to render text a huge framework is overkill. That doesn't mean there is any problem with a framework itself.
Hey I'm not saying "don't use angular because their demo app is bloated". I'm saying "couldn't they have picked a better app to build that actually shows the benefits of the framework?". I just did a react quick start and it was a whole lot more fulfilling to build something useful. This one was "copy and paste this code -- congrats you wrote your first angular app!". Useless in all ways and a really poor demonstration of the framework. I'm fine if you like it and want to suggest that it's not all that bad -- but come on you can't say that this quick start is worth anyones time. 
Atom actually yells at me when I use back ticks just for a regular string. So I only use back ticks for the ES6 that functionality.
This is general purpose lib. If your app is smaller than the framework, use different framework.
So, you can complain about the quick start guide being both too complex and too simple to be useful, but that's just to introduce the moving parts and paradigms of the framework. As far as useful apps go, you can look at [the actual tutorial](https://angular.io/docs/ts/latest/tutorial/) for a decent example. Keep in mind that React is *just* the view layer, and Angular 2 is a full-featured framework.
Sidenote: I love how this thread contains all the different naming conventions that people use in different languages!
Without even jQuery experience you should drop the offer gracefully, otherwise you're risking humiliation.
I'm sorry, it's an odd request, I should've specified. Basically I'm trying to solve a puzzle and a clue is hidden somewhere in the code that's linked. I was wondering if there's any weird behavior in the code that I can't see.
Does anyone know how functional Javascript affects callbacks? If FP helps you write cleaner code in general, does it help you avoid callback hell? It it safer to chain functions instead of nesting them? http://cwbuecheler.com/web/tutorials/2013/javascript-callbacks/
[ESLint](http://eslint.org/docs/rules/quotes) has default rules that warn if backticks are used without interpolation.
It surprises me that this hasn't been posted yet, but as an experienced JavaScript developer: you're wasting your own time and that of the guy you met. I don't mean to discourage you, but honestly you cannot expect to learn JavaScript from scratch in three weeks and be at a level where you can use it for any respectable job unless you already have serious experience in at least one other programming language. If you're serious about learning JS and interested in pursuing a career in it, you'll get more opportunities in the future. Web dev is a very popular field and JS developers are always sought after. Take a few months to really familiarise yourself with it in your spare time, solve a lot of challenges on codewars.com or something in those lines, implement a few ideas of your own and see where it takes you. 
what happens if you hover over ".whale" for 18 seconds? 
&gt; hat syntax is a goddamn nightmare to parse logically. I've used probably upwards of 30 different languages all told, in the last 35 years Which languages have you used? It's a pretty standardised syntax for the feature and appears in dozens of other languages, it wasn't something they came up with for ES6. It's just that it's usually seen in functional languages, so if your 30 languages were all imperative, you might've just missed it. Simple addition function, written in various languages: JavaScript: `(x, y) =&gt; x + y` C#: `(x, y) =&gt; x + y` Ruby: `-&gt; (x, y) { x + y }` Elixir: `fn (x, y) -&gt; x + y` Elm: `\x y -&gt; x + y` Haskell: `\x y -&gt; x + y`
&gt; Although I haven't tested that out in a couple of years now at least. `map` and `reduce` are faster than for loops in V8 and SpiderMonkey as of 2015. If you tried it a few years ago then yeah, things have changed a *lot*, which only makes sense -- the optimisations for those things didn't really go in until the standard was finalised. 
For me it's the opposite, the arrow stands out more because I'm used to arrows indicating functions in the other languages I use. So this is something that's clearly varying by personal experience and what you're used to.
In a turkish keyboard you cant type a backtick. I bet its one of the characters first sacrificed when a language has more letters than english (29 for turkish).
Avoid anything that is not `'`, no exceptions! I know what you are thinking, but, no. [Use this instead](http://codepen.io/Linuxdirk/pen/NAmjab?editors=1010).
I don't allow one letter variable names (or most abbreviations) in my codebases. In dynamic languages, they're a huge burden on code clarity.
For the pattern, yeah you are using the pattern correctly. I exclusively use the revealing module pattern 
That's completely idiotic.
Ah yes. Will fix that. A follow up question: the code did not work initially when lines 72-76 were not wrapped in the `defineMaps` function (error: "google" is not defined). I thought the `map` in line 72 gets executed along with the IIFE, why didn't that happen?
It's also in [this weeks humble book bundle](https://www.humblebundle.com/books/joy-of-coding-book-bundle) so you can get it + a load of other coding books cheaply!
 action1(action2(action3())) //or if the operation is chainable action1().action2().action3() Wouldn't the order of execution for the first call be `action3 -&gt; action2 -&gt; action1` and the second one `action1 -&gt; action2 -&gt; action3`
It seems like you're looking for something complicated when something simple will suffice. Why not just: let foo = names.filter(name =&gt; name.length == 4 &amp;&amp; /^j/.test(name)); let bar = names.filter(name =&gt; name.length == 3 &amp;&amp; /^b/.test(name)); If you absolutely must do it in one pass I suppose you can use reduce, but dear god is it ugly: let result = names.reduce((output, name) =&gt; { if(name.length == 4 &amp;&amp; /^j/.test(name)) output[0].push(name); else if(name.length == 3 &amp;&amp; /^b/.test(name)) output[1].push(name); return output; }, [[], []]); Are you really telling me that's any easier to read than the first version? Even a simple straightforward for-each loop is easier to read than that mess. I think you should explain more the context of how this will be used. 
Spock I need to javascript!
I'm sorry you're being downvoted, that's not very helpful. It's a sore subject I guess. If you aren't proficient in at least one other programming language (HTML and CSS being languages which describe data, they don't *do* anything) there's no way this is going to end well. Programming requires a certain way of thinking. Anytime I see someone fail to learn how to code, they are approaching the problem as "What do I need to write to make this work?" - which works okay if it's a problem like changing the background color of a page or adding a drop shadow or whatever, but writing code doesn't work like that. Writing code requires you do really, intuitively understand a couple of things: * How a computer executes procedural code. * Basics like expressions, functions, invocations, literals, scopes, variables,... * All kinds of data structures (I remember when I first started I actually had real trouble understanding arrays, which seems ridiculous to me now) * Control flow Sometimes it even takes people a while to realize that yes, the computer is executing these things one after the other. Even experienced programmers might struggle wrapping their heads around some new concepts when they learn another language. And that's just the beginning. Just because you learned the syntax of a language doesn't mean you can actually *do* anything with it. That's the hard part which pretty much all good programmers solve by *endlessly experimenting*. When I write something new, I can write it fast because 95% of it consists of problems I've solved before, either during work or more likely in personal projects. The remaining 5% will take the longest because it's new stuff I haven't added to my tool belt yet. There are things called "design patterns" which can help you add some new tools before you have to come up with them on your own, but they only really work if they get you an inspiration like "oh that's how I could have solved that problem I had a while ago more elegantly". With 12+ years of experience in different programming languages (not JS by the way), in 3 weeks I could probably understand the syntax and pick up some stuff about how people actually use it (I heard that's quite important in JS). Someone proficient in JS would probably still see I'm new at this. Maybe it's enough to trick some non-technical manager, but any programmer will probably just need to look at your code for 5 seconds before realizing you've only been programming for 3 weeks. TL;DR: JS is a programming language, not a tool you can learn how to use in 3 weeks. If you can be fluent in a foreign language in 3 weeks, you may be the kind of genius to pull this off. Otherwise, don't bother.
You're completely idiotic.
Airbnbs JavaScript Style Guide has a take on this https://github.com/airbnb/javascript#strings--quotes Only use backtick if it's an actual template literal (contains interpolation or newlines). So if you like quotes, back it up with this. Otherwise find another style guide :-)
Just a few reasons why you shouldn't use this method: * Its performance is far worse than just joining the strings * It's harder to understand what is going on at a glance, leading to a higher cognitive load. * It takes longer to write than other options * You shouldn't modify the prototypes of objects you don't own
You can't do this job then. Those are not programing languages.
It sounds like homework
I would be upfront about it. Three weeks to even reach an average status is asking a lot. In three weeks you can definitely be a proficient *beginner*. There are just several things done in Javascript that only make since after you've scratched your head for a while as well as several things that you will likely try to do to make your life easier (i.e. attaching to the global scope) that would just give away the fact you don't understand the impact of your choices. If he likes you, he likes you. If I met someone who said "I didn't fully know Javascript when I met you, but over the past three weeks I've done this, this, and this." I'd be really impressed with their desire and aptitude to learn. If you lie and bs your way through this, you have the potential of destroying a really good relationship. Just doesn't seem worth the tradeoff, but these are my 2 cents.
All of that is correct. But after all it's a good way to provide translation-ready strings with variables.
Optimism.
Seems to be working fine now, cheers.
I have always wondered why people still use cookies. Its an archaic 90s technology. Its a string... kindof, but not really with a horrible API and it stores 4kb. If you have the ability to recommend change where you work use localStorage instead. It stores a different amount by browser but the minimum is 5mb per domain and its a hell of a lot faster to access.
&gt; Unless OP lied about his qualifications, the guy taking an interest in him for this job sounds sketchy. It might just be a clueless small business owner who knows as little about development as the OP does. Or the OP might not have told the guy he doesn't know JS, and is hoping he can just wing it through an interview and learn on the job.
&gt; Javascript as a language isn't hard Learning *Javascript* isn't hard, but learning *programming* is fucking difficult. The OP apparently has no prior programming experience whatsoever, so he's pretty much boned with only three weeks to learn his first programming language to a professional (even junior developer) standard.
Or you just use the pipelines feature of Heroku that's designed for this?
You lied in your interview. You mislead your employer, and *hoped* you could learn on the job before you fucked up enough to get fired. In the end you've managed to fake it until you (apparently) made it, but that doesn't mean you were acting ethically, and it's *absolutely guaranteed* you were writing shitty, awful code for most of that time - even shittier than they were expecting, because you lied to them about your experience to get the job. You were also lucky that it was an internship, so the whole point is to train you up. The OP is apparently talking about a regular job, where it's not. You acted unethically, and got lucky. I'm glad things worked out for you, but I wouldn't *advise* anyone to copy you for either of those reasons.
That is exactly what I mentioned I did not want to do.
Yes, pipelines is fine too. But solution in my article you can use in other platforms as Heroku. And it is a older solution than pipelines, I use it very long and I still love it.
You can edit an existing object's prototype but it's not recommended since it's a very slow process. This is because of the way prototypes are implemented in JS, but in return they work really fast. Also it's never a good idea to edit a library directly since all of your changes will be lost if you want to update it. What you can do is write a plugin for bootstrap that lets you hide tab controls, implement your logic there and use it similarly to this: $(elm).hideTab();
Have you looked into using es6 modules or commonJs, they effectively implement the revealing module pattern but are backed by a spec? Caveat: it would require a module loader such as Webpack / Browserify / Rollup
Something I haven't seen the others ask is can you dedicate the 3 weeks completely or is it more like 3 weeks but I have to walk the dogs, party all night and play candy crush for half of the day ? The right answer depends highly on what % of a day you will dedicate not only the total number of days.
&gt; Pick a front-end framework (Something easy like vue.js or handlebars) What??
&gt; But after all it's a good way to provide translation-ready strings with variables. 1. it's not since there's no translation function being applied 2. the ES committee thought about i18n, ES6 template literals can be tagged with [a user-defined processing function which you can use for i18n](http://jaysoo.ca/2014/03/20/i18n-with-es6-template-strings/)
It's previously used in other template engines and pretty unambiguous.
Yeah, this introduces logic, a different syntax, asynchronicity, programming paradigms. It's been 9 hours. Hope you've got a bit of it under your belt already.
Yeah, I mean *conceptually* equivalent.
Can you update the original? People will run into this in a year and stumble once.
https://hacks.mozilla.org/2015/05/es6-in-depth-template-strings-2/ Fewer collisions. Those 2 characters occur rarely, in conjunction, in strings. 
[Responses in this thread](http://i.imgur.com/zqOs8yr.gifv)
If they're going to re-architect the core, I really, really wish they'd devise a way to express immutable components so that components using props.children can safely use React.PureComponent.
Basically: I go forward from BASIC through dozens of C, C++, and Java-like languages, and include Javascript. Regardless of how often it's used, it's still like suddenly encountering words that are in a RTL language in a LTR text, or entering dozens of calculations in a calculator that are normal, then suddenly you have to enter one in RPN or something. 
Na, I have § character there.
Never mind! I got it... (ALT + ~) but my ~ is in a different place.
Karabiner / Ukelele is your friend :)
Or representing an object (looking at you, Python 2).
If you want to use a Haskell-like language on the web, you should check out [Elm](http://elm-lang.org/). It's great for building web apps in a functional style, the best place to start is [here](http://guide.elm-lang.org/architecture/).
I really like template strings for a quick-and-dirty View framework: function AppView(props) { return ` &lt;h1&gt;My App&lt;/h1&gt; ${ListView({ items: props.items})} `; } function ListView(props) { return ` &lt;ul&gt; ${props.items.map(i =&gt; ` &lt;li&gt;${i}&lt;/li&gt; `).join('')} &lt;/ul&gt; `; } const controller = { el: document.getElementById('app'), render(props) { el.innerHTML = AppView(props) }, state: { items: [] }, setState(state) { this.state = state; this.render(this.state); } }; const actions = { addItem(item) { controller.setState({ items: renderer.state.items.concat(item) }); } }; controller.render({ items: ['a', 'b', 'c'] }); fetch('/item/d') .then(itemD =&gt; actions.addItem(itemD)) It re-renders the entire app on every state-change, and setting up event bindings is a little more work. But for some basic use-cases, it's a really handy low-overhead way to write client side code.
I agree completely that programming is hard, anyone that disagrees is lying!! But I reckon if anyone put their mind to it they could pick up the basics in 3 weeks. It's going to take a lot OP but you should definately try! Even if you don't get this job, learning js will serve you well in any web Dev job.
 // TODO: rename sayHi to sayHiTo const sayHi = (name) =&gt; `Hello, ${name}!` let greeting = sayHi('nawariata') ES6 is a beautiful thing. EDIT: `git commit --amend -m "fix some things" &amp;&amp; git push -f`
hmm. the packager for my employer doesn't understand the syntax. argh. Seems like this is something I should've known about already, being that compatibility goes back to Chrome 41, but oh well. Better late than never. 
Function is a workaround, not a solution. 
The $ was also already used together with regular expressions, like "foobarbarbarbaz" .replace(/(foo)(bar)*(baz)/, "$1 $2 $3") // "foo bar baz" // $1 is first parenthesis, $2 is second etc. 
Especially for prepared statements. Instead of: `sql.execute('SELECT ?', [1])` You can use: function SQL(strings, ...values) { return [strings.join('?'), values] } sql.execute(...SQL`SELECT ${1}`)
Pretty vapid article that doesn't add anything more than a language reference like MDN already provides, and doesn't even mention template literal tags (which is a topic that warrants discussion... like how to best use them, good patterns, etc)
Function is the most natural way to express what you're saying. I find what you're suggesting to be an awkward fit but I'm open to see any examples backing up this statement. If you want to dig deeper into templates, look into [tagged template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals).
That is nice. Note, this doesn't make you safe from sql injection (in case anyone thought it would).
I appreciate the input. I already have a job which sustains me quite nicely. I'm not in any desperation scenario or anything. That being said, if at the end of three weeks I'm not up to snuff I've still spent three weeks learning a coding language - this will still have value to my professional growth. 
done
Thank you! I was entirely honest with the employer. I told him exactly what I've told everyone on this thread - I know only HTML &amp; CSS and that I'd give myself three weeks to try and pick up some JS. Worst case scenario this provides me the motivation to spend three weeks on JS instead of 8-bit hordes (that shit is addicting, yo). 
Where can I get some? :)
Something about how his own framework did all this a decade ago. Didn't provide a link though :)
I work from home. ~3.5 hours a day is spoken for. The rest is up to me to use wisely.
Go on amazon. Buy the most recent 12 books about javascript that are less than 300 pages. Take a week off and read them all. You can read 3-4 books/day. I did this when I started a new job and had underestimated my javascript skills after seeing the codebase.
Worst case scenario, I spent 3 weeks learning JS. Even if I don't get the job, it's a win-win. I have pretty similar hobbies as my coding friends. I figure our brains must be wired similarly and that if they can code, I can pick it up too. 
Whoops. You're right, I misinterpreted your example. That's a really nice use of templates.
Thanks for the encouragement!!
I agree that three weeks is not enough time to "learn" JavaScript, but that's awesome that they're aware of where you're at and have faith that you can learn quickly. Someone else recommended this course in the thread, but here's a link. I've found this to be a pretty darn good course. There are a couple nuanced points I've heard people disagree with, but overall, it's good material. https://www.udemy.com/understand-javascript/learn/v4/
That's fair enough. The title says "I need to learn JS", which is what I responded to. Good luck either way, it's a fun language and the possibilities nowadays are endless. I hope you'll enjoy it :)
If you use TypeScript and target ES5, it'll convert them to regular string joins for you automagically.
Still why not go with a lightweight vdom instead? snabbdom is something like 500 LOC (source, before minification).
What about the console? I do a lot of work in there and it only highlights after submitting. It doesn't highlight as you type.
If you need something like that in serveral places in your code, you could build your own groupBy function (or use the one from https://lodash.com/docs#groupBy) const groupBy = (array, fn) =&gt; array.reduce((result, item) =&gt; { const key = fn(item); if (!result[key]) result[key] = []; result[key].push(item); return result; }, {}); const a = groupBy([1, 2, 3, 4, 5, 6, 7, 8, 9], i =&gt; (i % 2 === 0 ? 'even' : 'odd')); const b = groupBy(["john", "alice", "jane", "bob"], i =&gt; i.length); /* a = { odd: [ 1, 3, 5, 7, 9 ], even: [ 2, 4, 6, 8 ] } b = { '3': [ 'bob' ], '4': [ 'john', 'jane' ], '5': [ 'alice' ] } */
`rm -rf ./my-project`
But... Why? Anywhere that runs gedit can run any of several *much better* editors.
Neither is SQL. I don't see your point.
No conditional logic though.
In Javascript, IE8+: var cookie = document.cookie.replace(/(?:(?:^|.*;\s*)yourKey\s*\=\s*([^;]*).*$)|^.*$/, '$1'); if (! cookie) { document.cookie = 'yourKey=yourValue'; cookie = 'yourValue'; } return cookie;
Not for any great reasons. Mostly just to avoid the mental overhead of understanding how the vdom library works.
Wow man, that was cool :) I'd really appreciate to hear more about it.
even on dvorak it's on the key next to one, it's really hard for me to intuitively press that key, never use it for anything... Also I'm so used to just pressing q for quete marks it's hard to break. But still this is a really good thing to know exists, it has plenty of uses. I'm quilty of writing template files with quotation marks and \n ... like last month previosly. That's going to end now
Eslint 
Sure, you can do conditional logic function ItemView(props) { return ` &lt;li&gt;${ props.isImportant ? `&lt;b&gt;${props.label}&lt;/b&gt;` : `${props.label}` }&lt;/li&gt; `; } // or function ItemView(props) { return ` &lt;li&gt;${ (() =&gt; { if (props.rating &gt; 8) { return `&lt;b&gt;${props.label}&lt;/b&gt;`; } else if (props.rating &gt; 5) { return `&lt;i&gt;${props.label}&lt;/i&gt;`; } return props.label })() }&lt;/li&gt; `; } Pretty similar to how you'd do conditionals in React.
Of course it does. MongoLab provide MongoDB as a service. MongoDB does not use SQL. OP is looking for a DBaaS provider that provides an SQL-based database. What about that doesn't make sense?
What about the syntax seems so unusual or jarring? I guess it's tricky for me to see, because I'm used to it, but `x =&gt; x * 2` isn't more jarring to me than `function(x) { return x * 2 }`. Is it just down to leading with the word function? I guess if you're reading word by word, seeing the word 'function' as soon as possible would help. Personally I find the arrow syntax more readable because I read in chunks rather than one word at a time, and the functions often into a single glance. To me, it's "args, function operator, function body", as natural as "conditional, &lt; or &gt; or !== or ===, conditional" or "n, math operator, n", and going "function(args) {body}" feels a little like RPN itself. Do you know Java well? Java has the same syntax. `(int x, int y) -&gt; x + y` is the same as JavaScript's `(x, y) =&gt; x + y`.
You don't read code in the console. You only write it. If you mean TUI editors: emacs and vim probably invented highlighting or something… And if you mean less: install lesspipe already 
I am astounded that DataLoader (or the underlying pattern in general) is not widespread. I am repeating myself, however the implications of being able to write simple one-to-many fetch operations, without needing to think about optimisation, are far reaching. This coding pattern enables simpler testing, simpler code and simpler caching. I am interested to hear if anyone's been using DataLoader in production and have run into any drawbacks. Furthermore, if anyone know of alternative uses of `process.nextTick` in a similar vein, I'd be very interested to know of them.
Ok so 24 - 3.5 - 8 (you need 8 hours of sleep I don't want to drive anyone to loss of sleep) = 12.5 hours. Out of those be sure to get exercise and etc I don't want to harp on this but every single question of the type I see is in the form of "I have X days to learn Y thing in programming" bugs me because they never specify are they a student that can learn most of the day are they learning after work, it's a huge difference. I'd start with code academy as the others have said, I don't want to sound like a shill but lynda.com has a free trail period in which you can easily do the JavaScript Essential Training by Simon Allardice, so it's choice code academy or lynda for the basics. Next up you need to fill in the gaps about more advanced topics with [eloquent javascript](http://eloquentjavascript.net/) it's free and online skim it since you'd already know some of the starting chapters and round out what you don't know by readying the chapters. For even more advanced stuff try to get your hands on "Professional JavaScript for Web Developers, 3rd Edition". Also check out [this chanel](https://www.youtube.com/user/DevTipsForDesigners/videos) if you have the time.
Nice example. I'd still prefer hyperscript which is more succinct for something like this, along with sanitized text content. I do like template literals for shader scripts though.
SQL being an adjective here, meaning SQL-based. It might not be perfectly correct grammar, but I'm sure you can figure out what he means.
istanbul (or other code coverage tools) is perfectly suited for this https://github.com/dwyl/learn-istanbul
Yeah? why so? I just started learning angular (1.5) and loving every bit of it
Angular is a framework for webapps. You don't need the framework to say "hello world", Javascript/HTML can do that without the framework.
What's the job title of the position? Also, you're getting downvoted because people are miffed [because they believe] that you think you can learn JS, their livelihood/career, in 3 weeks.
That invested me understanding quite a bit. So how would I specify a script to be a background script?
Yeah, that's why I think "Hello World" is a poor first app to be showing Angular noobs. I walked away thinking that all of that work was overkill (my 12 scripts comment). Instead, show me how it can be used to solve real problems.
A Smarter Way to Learn Javascript. The PDF is floating around. The website is really good. Digestable bite sized chunks. http://www.asmarterwaytolearn.com/js/index-of-exercises.html 
That comma though...
Yeah I read that but figured I was misunderstanding because I was having trouble getting things to communicate between scripts
So your job is to increase conversions(sales) from the user. The name for this process is *Conversion Rate Optimization* (CRO). You don't really need JS yourself unless you're expected to modify the code yourself. *However*, there's a lot that goes in that process. You might want to run through concepts like AB testing, multivariate testing, and analytics collections/analysis. Will you become a master in 3 weeks? No, but knowing the basics may be enough depending on who the job is for. Search CRO to understand more about what I'm talking about, it's a pretty big bastard born form webdev and marketing.
The dialog reminds me of those video memes with the two CGI bears talking.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all
Angular 1.x is what I've been using but I'll switch to vuejs over angular 2.x
issue closed
Yes it does. Whether it's an issue for most applications is debatable. We have an adserver that handles nearly 20 billion requests a month and considers small micro-optimizations such as these. Most cruddy apps, probably not important.
That's because of how you have eslint or jshint set up. Atom (and eslint) works just fine with backticks unless you enable a rule that discourages them.
Tree shaking does this to some degree. Beyond that it is actually really difficult to do this definitively in JavaScript (or any dynamically typed language) , consider the following example: function some_func() { } function other_func() { } function callFuncs() { ['SOME', 'OTHER'].forEach((funcNamePrefix) =&gt; { global[funcNamePrefix.toLowerCase() + '_func'](); }) } callFuncs(); Most static analysis would not be able to pick up that `some_func` and `other_func` are being used. You could potentially do this by running the application (as is the case with `istanbul` suggestion). However that's limiting as well, as you would need to figure out way to force your application to walk thru all valid branches without getting into an infinite loop. 
Angular 1.5 is actually pretty good but it started off really hard to use, the code above is the equivalent starting point for Angular 2.
They're idiots for using github as a cdn but the author of the plugin would have to merge the PR into master for the code to run on trumps site.
Confusing the tooling for the language is mistaking the forest for the trees. The term *trend whore* comes to mind.
Technically correct. 
I do agree jQuery is dying. So many of the things people used to use jQuery for, like accessing elements, getting/setting CSS class names, and animation, can now all be done natively in JavaScript. It'd be interesting to see if jQuery evolves to tackle the next wave of challenges facing client side developers.
That's awesome! 
Any example that's actually gonna happen in a real-world app?
I get this visceral reaction when anyone says "jQuery is dead", like I want want to strike out at whoever makes that profane claim. No other library has come close to empowering me as as much as jQuery. It is my excalibur with which I fought back the suffocating darkness of Internet Explorer 6 and I will carry it to my death.
Thanks, that worked perfectly.
The propose would be to hide the tab, if you click on an already opened tab. In my case the tabs are actaully "sliding out" and being shown in an area. But if you want to just hide it back "close it", there is no way to do it. The JS to hide the thing is actaully really basic and easy, it's a few lines of code, but right now it's sitting in my file and I'm intercepting every tab click and running it through my logic before showing it or hiding it in my case. it just might be nice to have this option in the default bootstrap.
The infinite loop? For that I am assuming coverage tool is automated. So in order to know if a piece of code will never be hit, it will need to exhaustively look through all potential app states. Let's say you have code that checks for out of memory error, unless your coverage tool's state enumerator can take into account that, it will almost never hit that line of code. 
Try this: &lt;html&gt; &lt;head&gt; &lt;script&gt; var safeToProceed = true; if (safeToProceed) { alert("you shall pass!"); } else { alert("You shall not pass!"); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; Hello, world! &lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;
HTML != JS html is a markup language that's used to tell browsers what to display, you probably just want a shell markup: &lt;html&gt; &lt;head&gt; &lt;script src="main.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; Save the above as "index.html", and save your own code as "main.js", they should be in the same folder and you should open "index.html" in your browser of choice.
ohhhh so you actually have to write the from a blank html page? (which i already have set up.) the book did not clarify that you had to do that, nor did it mention where in the blank html you're supposed to write it. 
My comment isn't that refuse to attack both, but rather that you cannot tell the difference.
Thanks for the advice, I will read more about Tree shaking. 
If you want any JavaScript to run in a browser, you need to either put it directly inside a &lt;script&gt; tag, like I did for you. Or, you need to reference a .JS file with the &lt;script&gt; tag. Either way, you need &lt;script&gt;&lt;/script&gt;. Try this now: &lt;html&gt; &lt;head&gt; &lt;script src="test.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; Hello, world! &lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; Then, using Notepad++, put the following code inside the text file, save it as test.js, and save it to the same directory as your HTML file. var safeToProceed = true; if (safeToProceed) { alert("you shall pass!"); } else { alert("You shall not pass!"); }
you mean the open and close script tags? yea they are on the same line, it doesn't matter tho
How do linters find dead code? The limits to which I've seen them find dead code is unused variables in the current file. If you have something like class MyModule { constructor() { //.. } someMethod() { //... } } module.exports = MyModule And `someMethod` never gets called by anything, a linter will not detect that, unless I've not used some really spectacular linter that has come out recently.
In case you missed it, this "JS fatigue" meme expired long ago. So tired of this shallow rhetoric.
I agree, the JS and more specifically, the NodeJS ecosystem is just full crazy mode. I installed a couple of Node modules for very basic stuff and ended up with like 100 other dependencies. Madness.
&gt; The languages, libraries, frameworks, build tools, etc are actually extremely easy to use and follow They're really not, though. You can spend a whole bunch of time investing in a particular framework or toolset, and in a month or two it will be outdated and nobody wants it anymore. You have to live on the bleeding edge if you want to get anywhere with JS.
Oh I see - I misunderstood your definition of "dead code" here. Do you mind defining "dead code"? Are you talking about code that's unused throughout the app?
Could you elaborate on how you interop with external JS libraries? I chose typescript for this reason. The integration is so wonderful.
but the fatigue is stronger than ever.
Its still useful. Just a few weeks ago I started a mini project where I needed to do some complex dom traversal and tag replacement where the Document that I'm working on is contained within an Iframe.. within a React based app. So I take the iframe source. Thought I could do pure regex replacements.. maybe.. but it was pretty difficult. Said fuck it. Added jQuery slim as a dependency and used it to parse the iframe source, traverse and replace all the tags I needed as I needed to. It was a piece of cake. React was the icing that instantly updated the iframe and voila. Jam done. 
I don't disagree, but I will say it is very nice being on the bleeding edge, and it doesn't take all that much effort to maintain it once you're there. I think that's the main dichotomy; between those who have gotten to the bleeding edge of the technology and those who have not. If it's just a little, tiny bit every few weeks, it's going to feel like a lot more if you're not already up to speed.
excited for this .. when will part 2 be available?
It's framework fatigue...and agree with this other guy still. Spent a few years trying all of that shit, just to rely purely on js, occasionally jquery, and occasionally other small helper libraries when it makes sense. I think nodejs is cool for async apis hosted on any platform. Angular was my thing through 1x, and a bunch of us are over it now after 2x (or trying to adapt to whatever they're doing this week). It's too much...typescript, transpiling, spending tons of time setting up grunt/ yeoman/ gulp tasks... I've been a c# developer for years, and now that 2015 community is free in lots of cases... I'm finding myself slowly crawling back to letting my IDE do those things for me again. All of that other stuff is neat, and a huge time suck...
jQuery isn't dead, it just needs to stay in small cases it works well in. Manually updating parts of the DOM when you change data gets messy fast. 
Well more and more features inspired by jQuery are being added to JavaScript. A recent example is passing the option once to an event listener for it to detach after being fired once.
It was Mootools for me. Then I had to finally settle for jquery once it was done. Moo should have won.
Yes :) 
It's a good start for refactoring and code coverage. I have been struggling for testing a dead code today +.+
I don't believe you. Or at least I think you don't know what you're doing or what you're looking at.
is this link relevent? http://stackoverflow.com/questions/2933737/when-iterating-over-values-why-does-typeofvalue-return-string-when-value-is
I typed in `javascript for of string` and `javascript for of returns string` what did you type into google so I know how to search for it next time?
 https://www.google.com.au/search?q=Why+does+for...in+return+strings+instead+of+numbers (sorry :) 
But Mootools is the reason that `String.prototype.contains` had to be changed to `String.prototype.includes` :(
medium has some good articles but some real stinkers that keep it away from being a polished collection of articles
yea, you can get around it by forcing it with `Number()` but at that point you could just use `for...of` instead and get better results in JS.
The ecosystem around eg. React is messy as well, and needs to get a lot less messy. I say this as someone that likes React a lot. But there's little denying that it's trading a code mess for a tooling mess.
take a look at ReactTransition which is the low level lifecycle hooks used by ReactCSSTransitionGroup. Your children animations don't have to happen at the same time. Here's one example i created http://codepen.io/jhsu/pen/jrbMXo/ Just a basic thing but you can do a lot more depending on what you want. Of course, react-motion abstracts a lot of it away for you.
Someday I hope to move up north and build my own home. Out of tables.
You're also saying it like someone who hasn't read the article 
As someone who has an unhealthy reliance on the library, I'm curious if you have an example of some of the tricky problems solved with one line jQuery. I'm guess it had something to do with a complicated element selection?
So Angular has been around for over 8 years, and react for 3 years (as far as "common use" goes). This is considered "outdated and nobody wants it anymore"? JavaScript is extremely popular, so you will get a flood of poor content and some good, it's the truth in any scenario. Hell, jQuery is going on 15-years... Are we really still having this conversation? I'm just very surprised that the issue is "people keep building me tools to make my life simpler, but I don't bother to involve myself in that scene and just get upset that there's not some answer automatically presented to me to make my work/life easier".
I think you're just falling into an issue of "someone needs to tell me what to do". Coding is simple, design your ecosystem for readability and performance and you can't go wrong.
Hi @eligloys - units only apply to models. Even though you used "model" as a variable name, it is still a path (new makerjs.paths.Circle). Paths live in models, so here's how to put your path into a model: var model = { paths: { myCircle: new makerjs.paths.Circle(30) } }; model.units = makerjs.unitType.Centimeter; feel free to visit the GitHub issues page and ask any other questions https://github.com/Microsoft/maker.js/issues the community is still pretty small so maybe there aren't many members here on Reddit yet. -Dan
And this is exactly why i seem to never stop loving Sencha ExtJS. Sometimes One-stop-shops just makes life easier. Also. React is cool. 
Remember: why write it in 2 lines of jQuery, when you can write it in 70 lines and 2 files in React.
What's the other one?
Wel we do have some state on the client, but that's more like are certain filters applied, are menu's opened or closed etc. How did you handle rendering a react component on existing DOM rendered by the server, just override it?
And most of the time you end up with the same module installed 2 or 3 times because some modules are enforcing different specific versions of the same dependency. Also, with each dependency installed you are also bringing along README, test cases, examples... I once had a 2 MB html file hanging around in the dependencies. I'm limited in storage and had to cook some script to remove all this trash.
Also, download Atom.io totally free editor made by Github, easy to learn and use but robust enough with plugins to use in the long term as you continue on your programming journey. 
All Array indices are actually strings, as far as the language specification is concerned – even if engines usually don’t treat them that way. That’s because the spec handles Array elements as properties. In other words: Arrays are basically objects, but with a special property `length` (again: engines do optimize according to their nature, but under the hood). The `[]` operator coerces all operands (except symbols) to strings: &gt; var obj = { 'true': 'foo' }; &gt; obj[true] 'foo' That also means that you can access array elements via strings: &gt; var arr = ['a', 'b']; &gt; arr['0'] 'a' The rule is roughly: the string `s` is an Array index if String(s &gt;&gt;&gt; 0) === s (`s&gt;&gt;&gt;0` converts s to a non-negative 32 bit integer.) More info on Array indices: http://speakingjs.com/es5/ch18.html#array_indices If you want to use arbitrary keys (not just strings) in a dictionary-like data structure, take a look at [ES6 Maps](http://exploringjs.com/es6/ch_maps-sets.html): &gt; var m = new Map([[true, 'foo'], ['true', 'bar']]); &gt; m.get(true) 'foo' &gt; m.get('true') 'bar' 
&gt; I get this visceral reaction when anyone says "jQuery is dead" Good, you should. Such claims are usually stupid emotional reactions caused by people getting overly emotionally attached to their favourite tools and irrationally rejecting all others. &gt; like I want want to strike out at whoever makes that profane claim. No other library has come close to empowering me as as much as jQuery. Oh dear. 
Well at the top he said it was a joke. Not a document to explain every new piece of tech in ultra modern Web Development. I was entertained. 
All object properties are strings. That includes array indices, since arrays are objects that just happen to have properties of a certain form. Any value you try to use as a property is implicitly converted to a string first, so if you write `arr[0]` the zero is first turned into a string. 
Id like to see this overlaid on the fast food discussion from pulp fiction 
Hotlinking a script on a github.io site is unethical.
ask /r/nootropics you'll be disappointed 
thanks
Specific use case was that the document I needed to operate on was the document of the iframe.. not the react application I was situated in. The iframe document was being used as a template which had numerous tags that needed replacing. The tags could be inside elements or text elements. ie.. data-key-tmpl="replaceable" data-key="replace-me" or &lt;a data-replaceble=""&gt;replace-me&lt;/a&gt; etc.. rather than worry about DOMParser issues between browsers and other incompatibilities.. I chose to make things easy on myself and went with the tried and tested method. 
So what are your thoughts on jQuery?
I can feel your pain. I tried to replicate Dom ready with pure JS. Trying to get it to work across legacy browsers is a non trivial effort. 
The book is "Javascript for absolute beginners" I had gotten a a few books on C and Python prior to this one, and both of them would just throw terms out without explaining them, or what they do. I'm enjoying this Javascript book though. It explains things pretty well and then let's you write some simple code which later in the book turns into more complex code. Like I said, I'm a noobie when it comes to programming languages and programming in general (just decided to learn no more than a few weeks ago). But I've learned more from this book in 3 days then I have from a month of an intermediate level book on C.
Yeah, it gives off the "MongoDB is web scale" vibe instantly.
[I made a crappy GPU-accelerated digit recognizer with WebGL](https://erkaman.github.io/regl-cnn/src/demo.html). Been working on it for about one and a half week. I also made [this silly thing :\^)](https://erkaman.github.io/smiley/smiley.html)
Stop using RequireJs, that's a shitty and outdated library.
I solve a tooling mess once and rarely have to revisit it. I deal with source messes on a daily basis.
Linting and source control is all fine but usually third party modules cost you most, especially in a non-modular buildsystem. For example, include THREE.js and you have just added 500kb to your project and hardly anything you can do about it. If you use a modern bundler like Webpack2 or Rollup instead, elimination pretty much comes by default. Tree shaking goes a long way and eliminates not only your modules but third party modules as well, stripping them down to a minimum. What you have left in the end is what you actually use. The rest (comments, spaces, unused variables, etc.) is being wiped by your minifier.
Oh man, I nope out of DOM ready so fast. I think it was good because we found better ways to do things, but it was bad because of how long it took to do certain things. I figured supporting legacy browsers would be a nightmare
Thanks for the tip but for know my focus is to find dead code in the source and not in the libs or vendor. But I will keep track of this. :) 
That's the decision I've landed on too, as I'm not quitting React any time soon. But it is important to recognize that that mess is there.
Not really though. The webpack landscape gets better by the day.
Hey.. it even works in some browsers!
I just published my [mental poker API implementation](https://github.com/mental-poker/mental-poker-api-js) I've been working on during the last few weeks. Dropout tolerance is not yet solved, so I'm eagerly waiting for contributions towards the project!
there doesn't seem to be anything here
K
Yeah I actually gave up. I just put jquery and bootstrap in the global scope before calling my webpack bundle. And it has made development soo so much less painful. Now bootstrap just works I don't have to use a react library to talk to bootstrap for me. And adding things like a bootstrap date picker are easy. What caused me to give up was trying to use bootstrap with a material-ui theme and a custom combo box. The CSS transitions became the worst nightmare ever and took like a week to get right. Once I gave up the perfect idea of nothing in global scope that task was easy and I could just use the js provided by those libraries. I still keep most of my resources in webpack. But if a library is easier to use if it's in global scope then I put it in global scope. And bootstrap needs jQuery in global scope.
lies.
Wait why? 
Develop tests for all functionality on the site. Run the tests with a coverage tool like istanbul.
ty
I am pretty excited for the dead code elimination feature I've been hearing about for webpack 2.
In the text post? I see five paragraphs.
Go ahead and try it :)
React vs Angular JavaScript vs Typescript Choose one and go with it.
jQuery is not a framework but an interface for the DOM. I would always prefer jQuery over manual DOM fiddling. jQuery got so much popularity because it is (was?) so hard to write DOM manipulating code that works on all browers. I would say the next logical thing would by browser.js. An interface that works equally good for all browers LOL
Nice. You should work on the UI (can't tell what button is active at least on iPad), but great work.
Oh okay , thanks for feedback!
hey what material ui extension you recommend for bs?
Angular exposes native DOM methods. jQuery can be used, but it is not required.
I think it's important to gain perspective and remember that these tools haven't died out in in a short amount of time. We think they have but that's because we've been heads down working. Browserify is 5+ years old and is a wonderful little tool built in the spirit of composable Unix-y cli tools. Grunt and Gulp were generally wrappers around browserify (so it's always been popular) and replacements for shell scripts and make, so they will come and go and that's ok because shell scripting and make aren't going anywhere. Webpack (and rollup) are replacements for browserify, but that's ok because in the space of those 5+ years Javascript got an official module system (something that Browserify couldn't have anticipated all those years ago) and it's allowing some awesome new build features (hello tree shaking). Languages and tooling ecosystems evolve and some stick around and some don't. Tools like webpack and rollup and browserify _will_ be replaced with a combination of modules in the browser and http2, and that's ok because that will lead to a better experience. The neat thing about it is that all of these patterns build upon prior patterns. So unless you are planning on retiring from coding in the next 10 years, the time and effort you spent making your code more modular and importing and exporting is not wasted, it's time well spent. You are better positioned to use and understand the coming tools than someone who didn't make the effort.
lol.
It just seems like the JS ecosystem has become this new fad. Everyone is rushing to put out new hyped-up packages that reinvent the wheel over and over. That's great, it drives innovation, but it makes for a super chaotic and unstable mess in the meantime. It reminds me of PHP back in the early version 5 days. Everyone was competing to make the next biggest thing with all these new OOPy frameworks. It become a cluttered mess and all the projects were short lived. On top of that, NPM is a really whacky dependency system. In what other language do you create dependency modules for 3-5 lines of code? It's just crazy and unnecessary. It seems like writing modules for NPM is an art of not actually writing any code yourself.
many of the testing tools can be run in a browser (mocha, jasmine, etc) or you can write tests using a headless browser or you can mock any dependencies that cant be run in node if you want the tests to run via node
There doesn't seem to be anything "node" about your setup, since this is all code meant for the browser. That's OK, though, since all the tools you've picked will still work for browser development. To set up Grunt and Babel for your ES6 support, you can find some easy instructions on the [Babel install](https://babeljs.io/docs/setup/#installation) page. Once that is working, and you are able to produce some nice ES5 code from your ES6 sources, you can make a [unit-testing web page](http://mochajs.org/#running-mocha-in-the-browser) based on Mocha. If you want to split your source code into different source files, and bring them together with statements like `otherCode = require(./otherCode.js)`, you are going to need a bundler. I suggest Webpack, although Browserify and Rollup are also reasonable. These tools will take all your source files munch them together into a single big source file, so your unit-testing web page only needs a single `&lt;script&gt;` tag. If you choose to go with Webpack, it can actually [handle the Babel step](http://webpack.github.io/docs/usage.html#transpiling-es2015-using-babel-loader) too. So, you don't actually need Grunt in that case. Just run the "webpack" command to compile your sources, and then open your test page in the browser.
is faster and is good for express changes
One semester of CS was worth the money, wasn't it?
Yet this is basically the only argument I hear when people try to persuade me to stop using jQuery
That's how I percieve current state of front end development from the PoV of someone wanting to write rather simple apps.
Angular refers to Angular 2.
This comment thread just illustrates my point exactly. When people band together, there's a phenomenon commonly known as "group think." This post seems to have offended people and that may be the biggest challenge of the learning curve. I am disappointed and a little hurt. You will notice not a single comment took any courage to try to rebuke my thesis on a technical basis. I am not worried though, because math is not subjective. I would like to help programmers because I find it very sad the way technology is being used. We have so much more potential, but we are also in the "wild-west" of programming, so people in one sense are just happy to see what we do have, as it is so new. CSS, to use a common example, is more of a practice in learning arbitrary rules than fundamental application of theory. It is amazing what we could do with even 5-year old technology that isn't here yet. These points on socio-economics I've talked about are also talked about by many people. In a nutshell, it's one of the fundamental reasons why we have Open-Source Software, isn't it? The fact is, it's important, and to point back to the math again, the US is over 20 trillion dollars in debt and the government is notoriously corrupt. These are actually the main talking points of our Presidential election. Making fun of these issues is something regrettable, and the more akin to the maturity of a 14 year old if anything, although I've known some incredibly mature 14 year olds, so maybe that's not a fair comparison.
Using grunt already, maybe use karma for testing? https://www.npmjs.com/package/grunt-karma
Is this true? I can't tell if your comments are sarcastic. If it is true, then that is impressive and actually illustrates my point I discussed. I'm not sure why you insulted it with sarcasm.
Created my first jQuery plugin today! It's an [autocomplete](https://github.com/Forceh91/js-autocomplete) for inputs.
sarcastic. it isnt. saying id rather rely on event system. jQuery foreva
&gt; I started playing with Rollup after reading an article by u/nolan_lawson Care to link it?
please give me one example where it is necessary to write 70 lines of react and you can do it in 2 lines of jquery. 
Ok. It could be faster if it were integrated into the browser. I wouldn't mind seeing both Jquery selector capabilities and React dom diff integrated in the browser.
agreed. or if jquery somehow adopted a virtual tree.
Lol this article is about jquery, and how overengineered the solutions that replace it are. I don't know what Linux filesystems have to do with JavaScript, and I really don't know what socioeconomics have to do with it, either. It honestly sounds like you're trying to sound smart for the sake of sounding smart. 
A joke article being silly? How rude of them.
This feature it's just enable by default on safari, I only used Linux and windows. 
Great idea! Thanks for advice :)
Depending on how advanced the browser features are you require there is always the option of testing in node and simulating a browser environment with something like [node-browser-environment](https://www.npmjs.com/package/node-browser-environment).
Congrats. Ever checked out jQuery ui's autocomplete?
Ah, this is your standard face roll on the keyboard.
1. It only runs properly in Internet Explorer (up to 8), this browser is the only browser which implements [`Error.prototype.number`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Error#Vendor-specific_extensions). *Edit:* using a deobfuscator may fail because this detail. 2. dcnntuxy is the eval function, just replace with console.log, the returned code is in [this gist](https://gist.github.com/qgustavor/e5d5d78531bb6ed2a7f8a6e337b07bbc). 3. ~~For some reason seems the final part from the code above is missing, so I can't continue.~~ **Edit:** seems markdown formatting messed the code. I checked markdown source-code and updated the gist above with the correct code. ~~From 1 maybe it downloads some Windows malware, also implying people who use old IE will run it.~~ **Edit:** It was made to download a malware, using Internet Explorer Wscript via ActiveX support to run it. It will not work in updated browsers and will not work because the host where it used to download the malware don't exists (at least it don't loaded here).
I haven't no. Not looked into any jQuery UI stuff.
That's the one. Sorry — should have added that. 
Faceroll can be used to write malware? Cool!
Wow, talk about coming late to the party. jQuery is all but dead, and there are about 400,000,000,000 autocomplete plugins out there.
The middleware aspect is interesting.
Yes, I agree on the redux-saga part. Good points here.
There's a difference in how Rollup bundles versus Webpack. For more details read the blog post linked [from this comment](https://www.reddit.com/r/javascript/comments/4yprc5/how_to_bundle_javascript_with_rollup_stepbystep/d6pktvg). Granted, both Browserify and Webpack are planning on doing some of the same improvements, so we may see more convergence in the future.
well yes, cdn src can be put in &lt;body&gt; but I'm asking about independent &lt;svg&gt; with no &lt;body&gt; or &lt;html&gt;
I'm writing an application in React.js because it's a framework that most suits my needs, but the testing ecosystem is extremely scattered and there's no consensus on the *right* way to do testing, or even a right three ways. Your answer isn't really helpful to me.
Previous to jQuery 3 the promise implementation was broken. They wasn't A+ compatible. I've worked on some projects that used Promises where I felt they wasn't required and were used just because Promises were the in thing at the time. I avoid them them unless necessary. I know some people will disagree with this.
No, script is valid inside svg. It even gets some special properties (different scope, I think). * https://developer.mozilla.org/en-US/docs/Web/SVG/Element/script * https://www.w3.org/TR/SVG/script.html * http://stackoverflow.com/a/5862750 Be careful though. I think there are some restrictions on what an svg script can do when the svg is not inlined, for security reasons.
By using useless misdirection. Useless nested function calls and actually omitting a large part of what is needed by jquery is not a valid comparison. Here I wrote a fair comparision which has the same functionality: **React** var React = require('react'); var ReactDOM = require('react-dom'); var Parent = React.createClass({ getInitialState: () =&gt; { name: 'Bob' }, changeName: (e) =&gt; this.setState({name: e.target.value}), render: () =&gt; { return ( &lt;div&gt; &lt;h1&gt; Hey my name is {this.state.name}!&lt;/h1&gt; &lt;select id="selector" onChange={this.changeName}&gt; &lt;option value="Bob"&gt;Bob&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; ); } }); ReactDOM.render(&lt;Parent /&gt;, document.getElementById('app')); **JQuery** ... &lt;script src="jquery.js"&gt;&lt;/script&gt; &lt;script&gt; $(document).ready(() =&gt; { $('#selector').change( () =&gt; { $('.name-span').text( $('option:selected').text() ); }); }); &lt;/script&gt; ... &lt;div&gt; &lt;h1&gt; Hey my name is &lt;span class="name-span"&gt;&lt;/span&gt;&lt;/h1&gt; &lt;select id="selector"&gt; &lt;option&gt;Bob&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; That's 16 lines vs 19 lines. Hardly a huge difference. Also the React example is self-contained while the jquery isn't. React also has a way easier time to add new functionality. Jquery is really only usefull if you want to traverse the dom while in react and not for something like this. Very bad example... 
&lt;script&gt; is valid inside &lt;svg&gt;, I do it all the time. But apparently I can't link cdn in &lt;script&gt; ( &lt;script src="...."&gt;). Looking for help with this. 
I was of the same opinion lol But actually after using Rollup on a couple librarires I realized the 2 solve different problems I wouldn't write an application without Webpack, it's superpowerful, has a shitton of plugins, and works awesome for large projects. It's fault is that there is quite a bit of config and tuning that needs to be done to make it work great. While Rollup the config is much much smaller and is easier to use until you get into CommonJS, node_modules, etc lol That's why for libraries with few or none external deps, Rollup is my number one choice, but anything complex Webpack is Not saying Rollup can't handle complex, I just feel it's easier with Webpack
I believe Tobias has plans to use rollup internally in Webpack after their 2.0 release goes stable.
Hey, so you're the dev of Astral!? I've heard of it before, but now I might give it a shot! Sounds like a great idea. What comes to mind for me is expanding upon it from there too. I'm personally not too big on the concept of tagging, but that depends on the circumstance, and I'm always happy to look out for ideas on social media organization and workflow. I hope to integrate many sources together in someway as a UI.
I once made a poker server/client in PHP. I can say, very deceptively complicated thing to do. Security has to be really tight.
I'm using rollup for libs, webpack for apps, I like it so far 
Well I am a programmer, so I do like to overthink things. and apparently sound smart. lol.
This is just an API on which a (WebSocket-based) protocol and website could be built.
Can you give an example of a use case? What's sticking out to me is all the autocomplete data being stored on the client, instead of recieved incrementally from the server.
You could have just used sizzle for dom traversal and use vanillajs for the rest.
Checkout /r/elm (sorry no link. on mobile)
Elm is an email client. Someone stole the name. 
Stolen or not, I'm still going to try and learn the language :-)
As dwighthouse mentions chrome tools support debugging. In console you can select the service worker frame, then "self" gives access to server worker context object. 
If you like learning from videos, [this](http://courses.knowthen.com/courses/elm-for-beginners) is an excellent resource to get you started. And please subscribe to /r/elm ☺️
Subbed after the previous comment, love some videos, will check it out!
Thanks!
tbh, mentoring a developer costs a lot of time and I think you'll be hard pressed to find a situation like the one you're describing. More often than not it would be more efficient to just finish the work. If you do manage to find a situation like this, awesome! However, I think a more realistic approach is to find some established OSS with good standards and make some pull requests. To me, OS commits are a lot more telling that portfolio pages. Just my 2 cents here. Wish ya luck though!
Pretty awesome game, good work
Awesome!
Will do, but will make it a menu option. Might get round to it tonight.
Good work :) I enjoyed it.
Hey I like the idea of the game :) Definitively I like it! 
Nice approach. Now I'm torn between implementing that everywhere now, or waiting since I'll want to use fibers soon enough instead. 
Haha, someone's been digging around.
Interesting. I'll investigate.
Hyperbolic, but not wrong. New jQuery's main place now is as a stepping stone to migrating away from JQuery (eg I just upgraded a legacy site to jq3, so I could use deferreds, and eventually transition to vanilla promises once I can shim without breaking the hundreds of monkey patched built in prototype overloading this project inherited.) I will say, creating libs as plugins to a framework is a mostly dated approach. Better to focus on building modules instead. 
Stop spending your time focused on the framework. Focus instead on defining the scope of your project: why is this better than just putting grades in a Google Sheet? is your app's strength that it models complex data relationships, that it allows collaboration, that it has a really beautiful interface, that it works well on mobile and sends push notifications, etc.
1. That may be a problem with WebGL I think. Or writing digits that I did not train my network for? 2. I am using [regl](https://github.com/mikolalysenko/regl) for that, and the source code is here [here](https://github.com/Erkaman/smiley)
Yep. Some kind of pathogen evading t-cells etc.. dono, name suggestions welcome.
Yeah just realised I missed a few obvious exploits, will tighten it up a little
I click the play button and nothing happens. I'm using chrome v48
It is. It's a bundler for ES modules that can be plugged for other module types, whereas other bundlers are focusing on CommonJS right now. 
I only bother to unit test service workers. Pass all your messages straight to functions and unit test those functions. There is no reason to test whether message passing works or not. We can safely assume that nodejs will work as advertised. ;) // parse-message.js function parseMessage(message) {} // parent.js let worker = spawn(); worker.on('message', parseMessage); /// parse-message.spec.js expect(parseMessage('message string')).to.equal(some result); The same can be done the other way around for the child process. 
The original specification was written by Choongmin Lee, I've only written a little appendix. The API with the test suite is a proof of concept implementation of the specification in javascript.
so your build script should probably copy over the ./shared directory into ./dist
I've tweaked the score-checking logic, let me know if you have any issues.
Fairly sure someone put a massive username in that was slowing down loading, should be ok now.
We tried days to migrate simple Webpack projects and gave up eventually. npm dependencies will cause problems, despite the plugins. For projects that are purely es6 without dependencies Rollup is perfect. But once you handle a real world project, something that has dependencies, Rollup configs can get wildly verbose. Some examples: [Painfull to get started](https://github.com/rollup/rollup/issues/385) [React in Rollup](https://github.com/rollup/rollup/issues/855)
is there an "easy" mode?
what did you think 'dead code' was?
Not a single word about *faster* image loading.
animals...
WSAD is not super convenient for foreign keyboard layouts. I've got french AZERTY keyboard and it's not bery handy to switch the layout to QUERTY just to play.
Willfix. Should be able to within a few hours when I have a PC to use.
sry did it too, its not fixed
Your comment reminded me of [this hilarious post on the CSGO subreddit](https://m.reddit.com/r/GlobalOffensive/comments/3u96ss/why_does_scream_use_qszd_movement/?ref=readnext) where OP was trying to mimic a professional player by playing with QSZD on a QWERTY keyboard. 
v8 is the javascript engine from chrome. firefox has one called spidermonkey. they also have a rendering engine, a plugin engine, and an input engine that handles mouses keypresses, and keyboard input. if you want to think of it that way how a javascript engine works: it uses a `text parser` to turn the javascript [text] into C-function calls on the fly, the process is called `JIT compilation` just-in-time compilation. so `Math.random()` JS calls v8's `V8::Math::random()` which uses their C libaries' `random()` function. it returns the output as a variable which is just an address to the V8's holding of the C variable the browser the engine gives you a few objects to interact with `window` `document` `console` `screen` `Math` `Array` and more. , these are created when you open a tab by the `init` function. these objects are interfaces ex has properties and methods attached (`window.width window.height`). these objects give you functions and variables to manipulate, like `window.height` and `document.innerHTML = '...'` and `document.createElement`, those are pointers to variables that are translated by the engine. (and then the engine calls `re-render()` to redraw everything when you change `document`) someone took the engine out of chrome (and added the filesystem/networking api that is blocked from the browser for safety reasons) and that is `Node.js`. so you can run this one the command line and access your hardware ex: `fs.readFile('foo.txt')`.
[Image](http://imgs.xkcd.com/comics/standards.png) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 3380 times, representing 2.7502% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d6qiq3q)
why do I need this in the react example? Jquery has nothing like it and it isn't even remotely required for the example.
Fixed.
So can we generalize it, that you can write crap in absolutely any framework, library and/or language? :)
Thank you so much! I will take a look through all the resources!!
Too hard (on iPad)
You mean agar. My wife said I'm not allowed to call it that because"cells don't move like that in agar!" She's a vet..
I haven't tried it at that scale. Maybe u/nolan_lawson has an idea after running the performance tests?
Let me use arrow keys. I ain't left-handed.
+1 to this, arrow keys are the way to go IMO
Yeah it was stupid of me not to include my code and I will remember that for the next time. As I said I'm pretty new to this xD But the methods you listed are perfect and very well explained. Thanks a lot for your help! Edit: I can also tell you that my purpose of doing this is to learn new commands and get some experience of writing code.
I've been doing some work in this space and there are a few things to note: 1.) This is new space and not that common at the moment so expect rough edges 2.) There are a few common approaches / best practices 3.) Depending on your specific use case will direct what / how you test. I've written up a blog post when I was first exploring this here: https://gauntface.com/blog/2015/12/14/unit-testing-service-worker I've written ended up with a few libraries to try and make some of this easier: - To use selenium-webdriver to test actual end-to-end and the service worker API: https://github.com/GoogleChrome/selenium-assistant - Helpers to manage service workers in tests: https://github.com/GoogleChrome/sw-testing-helpers Example projects using these: - SW-Toolbox (a service worker library for caching and managing networks requests): https://github.com/GoogleChrome/sw-toolbox/tree/master/test // WARNING: This is super rough, Mocha in Node -&gt; Mocha in a Web Page -&gt; Mocha in a Service Worker. This is in an old feature branch, so look at with a pinch of salt - Propel (a now deprecate library, but illustrates how running unit tests in the actual ServiceWorkerGlobal context can be useful): https://github.com/GoogleChrome/Propel/tree/worker-get-windows/test/browser-tests/push-worker/get-open-windows - Finally for a more light weight testing of push checkout: https://github.com/web-push-libs/web-push Alternative is to look at Lighthouse which uses the Chrome DevTools debug protocol to control Chrome to force certain behaviour (like check if the page loads offline or not) which is probably the best check for offline support I'm aware of: https://github.com/GoogleChrome/lighthouse Side Note: I need to write this up in a bit more of a cleaner blog post :)
Looks like Rollup recently added support for [incremental builds](https://github.com/rollup/rollup/issues/191#issuecomment-224986002). Worth checking out! Another option (which I have used in the past) is to use browserify+babelify during development, then apply [rollupify](https://github.com/nolanlawson/rollupify) as a transform for production. OTOH I did run a simple `time` measurement for my ["cost of small modules" benchmark](https://github.com/nolanlawson/cost-of-small-modules/blob/0c7c50fe6de1d909199012b53e38a5deb70eb979/bin/build.sh#L25-L35) using the "5000 modules" codebase and got these numbers (2013 macbook air): | bundler | time | | --- | ---- | | browserify | 0m6.643s | | browserify + bundle-collapser | 0m7.915s | | webpack | 0m9.642s | | webpack -p | 1m15.655s | | rollup | 0m6.109s | | closure | 0m18.485s | | rjs | 0m11.067s | | rjs-almond | 0m7.148s | Note that these numbers are for a very unusual codebase (lots of modules, flat hierarchy, one `require()` per module), so take it with a grain of salt. FWIW I would expect Rollup to perform pretty well on larger codebases, since one of the inherent efficiencies of ES6 modules is that you can only do `import`/`export` at the top level, meaning you don't have to traverse the whole AST to find `require`/`module.exports` declarations. **Edit** Added webpack without `-p`. 
Ran the numbers for 1000 modules as well: | bundler | time | | --- | --- | | browserify | 0m1.830s | | browserify + bundle-collapser | 0m1.987s | | webpack | 0m2.268s | | webpack -p | 0m8.010s | | rollup | 0m1.459s | | closure | 0m8.588s | | rjs | 0m1.348s | | rjs-almond | 0m1.814s | Seems like Closure has a pretty flat built-in cost, I'm guessing due to starting up the JVM. Even doing 100 modules takes 0m5.012s. **Edit:** Added webpack without `-p`.
[removed]
Nice talk! FWIW you can also use [rollup-plugin-browserify-transform](https://github.com/lautis/rollup-plugin-browserify-transform) and then any Browserify transform can be used as a Rollup plugin, so you could use e.g. [unreachable-branch-transform](https://github.com/zertosh/unreachable-branch-transform) to completely eliminate that `if (process.env.NODE_ENV !== 'production') { doStuff() }` code. (Note I'm not sure which one is better, just pointing out that you have the option, since I noticed there was still some dead code left over in your example. 😄)
You are re-declaring var i = -1, each time the function runs. So it's always going to run as 0 because you increment it, then reset it. If you make it global, then it never gets reset. 
V8 parses and compiles JavaScript code turning it into native machine code, just like C++. The difference however is, that V8 does not have that much amount of time as C++ does, so it does not optimize code that much. Instead, V8 uses heuristic that counts amount of function calls and most often called functions are further optimized on the fly. So V8 does not waste time on optimizing whole code (as this would heavly increase startup time), only the most executed calls are optimized. Second thing is that V8 within its environemnts (chrome browser, node.js) uses event loop and asynchronous calls pattern which is for now the most performant pattern for web applications. Third thing is that V8 tries to simplify code under the hood. For example, JavaScript objects are actually hashmaps because you can assign any value to them, there are no "schema" for particular object (like a class C++ or Java). But V8 tries to guess that particular object actually has a pattern in it and uses feature called "hidden class" to simplify memory layout used by certain objects. When you create an object let obj = { x: 5 , y: 10 }; and then read "y", typical unoptimized JS engine would perform a binary tree search in hashmap for 'y' key, while V8 will guess that this object has a two ints and instead of using hashmap, it will just put those two ints in memory and read int from [pointer-to-object+4] object block.
Rollup should eliminate any dead branches it finds – if you're using [rollup-plugin-replace](https://github.com/rollup/rollup-plugin-replace) as in the article, for example, you can replace `process.env.NODE_ENV` with `'production'` or `'development'` and it will keep or discard `doStuff()` as appropriate. If there's any stuff left over it's probably due to the [limits of tree-shaking](https://github.com/rollup/rollup/wiki/Troubleshooting#tree-shaking-doesnt-seem-to-be-working)!
Right, in his example it looks like it turns into: ``` if ('production' === 'production') { doStuff() } else { } ``` That empty `else` block is still dangling; I believe `unreachable-branch-transform` can remove those. **Edit:** I just realized Uglify can remove dangling if/elses. No need for extra transforms; carry on! 😅
BTW an important point to make is that tree-shaking isn't the whole story – in the benchmark from my article, there's actually no dead code and therefore nothing to shake! Instead, what makes Rollup faster is what I called "scope-hoisting" (aka "module-inlining"), i.e. the fact that every module shares the same scope instead of being loaded dynamically from separate scopes. This means that Rollup turns multiple modules into what you _would_ have written if you were writing one big module, and you only pay the cost of variable initialization and lookup, rather than the cost of the dynamic module loader that runs whenever `require()` is called.
[removed]
Elaborating on what /u/mmwh917 said as to why this is the case: Variables created with `var` usually have function scope. Meaning they are accessible only in the function they were created in. If a variable is created in the global scope it will be accessible everywhere (inside all functions as well). However, there's an exception to this rule: whenever you're redeclaring global variables in a function (as you did on line 4), JavaScript will change its scope to global. This is called hoisting. That means: even though you declare `i` inside a function it has global scope anyway. You can play around with this by replacing line 4 with `var i = i++`. Just looking at this specific line it seems to do the same exact thing but in this context your code will break because the variable now has function scope instead of global scope. [You Dont Know JS: Scope &amp; Closures](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch1.md) is a free book that explains this very well.
Simple: write bug-free code! I feel that many companies try to rely on this.
TIL Twitter logo is a bird, yet it only chirp instead of fly around.
I quite often have this mind set - "this code is so easy surely my time would be better spent elsewhere?" But you write the test to make sure the code stays the same time and time again. That way when you change the piece of code to fix particular edge case 6 months down the line, with a decent set of tests &amp;amp; test data you can check you haven't broken the other 99% of times you use that same method. 
I think you're going to get a lot of different answers on this. Personally I'm not a TDD fanatic, and sometimes my deadlines are extremely tight. When time is short, *everything* gets prioritized including which features we implement and what we write tests for. There are diminishing returns on testing, so it's a judgement call. Certainly if you're changing a function in a non-trivial way there should be tests for it. If you're modifying a function that doesn't have any tests, then it's probably worth writing tests for it before you make your modifications so you know you haven't broken the contract.
Given my deadlines, at my place I enforce a policy for my team which is like this: * Do write tests that guarantee the requirements of the feature overall * Don't write tests that are too simple to fail In practice this ends up meaning that a lot of functions don't get unit-tested but their usage in broader terms does. Is this ideal? Of course not. Do I work in ideal conditions? Do I f**k. I do have a few additional stipulations though * All bug fixes must have tests that guarantee they can't recur * If you're changing a section of code, start by writing tests that guarantee its existing functionality, with particular regard to the changes you intend to make. 
There are two types of functions, pure (which only rely on your inputs and the solely produce a result) and impure (which make changes outside of the function). Pure functions can be tested using unit tests, while impure functions require integration testing. If you write tests for all your pure functions it does not take long to do, and makes refactoring much easier because you know you are starting from working code. These tests are often straight forward but make sure you have enough to cover all possible inputs. These often do look simple, however once you have a suite of working testing it makes bug fixing easier, because you simply need to create a test to represent the bug and work from there. This, of course, is the ideal, but most of us work in the real world. Small code bases and small teams can get away without much testing, but eventually it will catch up with you. Strong test suites make bug fixing and refactoring much easier. 
Also, Rubocop! 
Thank you for your reply. On #2, I don't mind manually code splitting vendor files. However, if you did it in the way you described, would that mean you have to know, when `import`-ing, which libraries are external and which are not? To pose the question another way, with browserify, I can begin by writing `require('react')`, and later decide to bundle-split react (manually or not) without needing to change any application code. Is this the case with rollup?
only test public functions that have no side effects. no need to test private methods or impure functions with not well specified behavior
Not a bad read but a bit polarizing. I'd tweak the advice very slightly to "you should learn vanilla js even if you use fancy frameworks." I completely agree that knowing how it all works is desirable. It can also be very frustrating when someone writes code and they have no idea what it does. From an engineering perspective: I'd love if everyone had deep technical knowledge on the languages and frameworks they use and, over time, I expect them to gain this knowledge. But why does our profession exist? To build stuff; not to know everything about code. If I get a new dev straight out of college I can't say "we need to make sure you fully learn the ins and outs of JavaScript and raw DOM manipulation before you start contributing." As a developer, it irks me when people don't really know the language they're coding in. As someone who is paid to make sure we're working on things that provide value, I know it's not entirely necessary
Tests I can understand, because they cost time and sometimes one just doesn't have it. It's a cost-benefit question that has to be addressed in each situation. But the linter? Install it in 5 minutes, it'll save you hours in going back to your code to fix that unbalanced paren and many other silly errors. It'll do wonders for the consistency of the code. They can even catch bugs early (unused imports, undefined variables and what not).
Wholly agree. Promotions come from the deeper understanding, paychecks come from the ability to output code that makes it into production
I think this rings true for any framework in any language, not just Javascript. I remember when Ruby on Rails was the darling of the startup world. Everyone was using it and guess what, a lot of people had either no Ruby experience prior or very little, so when things would break, there would be panic The problem with many Javascript frameworks is the abstraction. Angular 1 is a prime example of heavy abstraction, to the point where you would encounter all of these specific issues which were the result of abstraction and debugging was just a nightmare. Then Angular 2 was announced and the abstraction was still there, you just wrote your applications a bit differently. But before SPA frameworks became a staple in front-end development, the same thing could have been said about jQuery. So many developers were learning Javascript through jQuery which is a library, but made doing DOM tasks a lot easier than they actually were with plain old Javascript. It got to the point where if you look at Stack Overflow and some of the most upvoted questions in the Javascript tag, there are countless jQuery solutions and hardly any plain old Javascript ones. I still see developers abusing jQuery out of convenience when 9 out of 10 times the native DOM and Javascript language itself is faster. In the case of Lodash, things are still abstracted, but you get more performance gains out of using it in comparison to jQuery (even in 2016). I think sometimes developers forget that a framework can introduce more problems than it aims to solve. This is why I have been using Aurelia for the last year and a half now. It doesn't abstract away native Javascript, most of what you write is just Javascript. There are a few conventions, but only in the HTML aspect, the code you write itself is just plain old Javascript. I think more frameworks should take this approach, modern Javascript with a transpiler is quite powerful. Having said that, sometimes I just use straight-up Javascript for a basic site that only needs a little Javascript, sometimes adding in a bevy of Javascript dependencies for a simple site just degrades the experience to the point where you start abstracting parts of the framework again to make it more performant, this is what happened with Angular 1 and developers adding in React to address performance shortcomings. Back in 2011 when browser support for Javascript features was not that great (thanks IE) and ES2015 was still years away and in flux, frameworks like Angular and Backbone needed to abstract because the underlying foundations were cracked. In 2016 it makes very little sense to abstract things, yet frameworks like Angular 2 are still doing it and React is even worse with its convention for defining components and Jsx syntax.
&gt;How does one introduce linters and unit tests to a workplace where there are none? We have work to do and it is unfeasible to get bogged down with pull-requests being declined because the lint checks are failing, and rewriting other people's code is obviously not even an option. Start small and focus on new code. You can specify individual files to lint and run tests against. Make a policy of linting and testing all new files, and you won't have a problem of getting people to fix their regressions. Continue to lint and test new code and eventually people will get sick of working with the non linted code and refactor it. At least that's how it's worked everywhere I've worked at. You can also set all of your lint rules to warn, and run it against the entire codebase. Run it on check-in/deploy and show everyone the results. Work on introducing weekly goals that focus on cutting down x number of warnings per week as a team.
&gt; Also, many frameworks are written by extremely experienced people and harp on best practices. I don't really agree with this in the JS ecosystem. Angular, React, and Ember are all very different architectures, that accomplish the same thing in very different ways. If you declare Angular's approach/design/architecture/style as "best practice", then by definition, React cannot be best practice (and vice-verse). As such, if you take to learning JS using Angular as your reference point, you just end up learning Angular-style JS, not necessarily fundamental best practices. &gt; Learning core Ruby was pretty much a waste of time My experience was the opposite with learning Laravel. I had a severe case of NIH, which ironically ended up serving me well at the time. I forced myself to learn not just OOP, but also how to build common architectural tools like IoC containers, routers, an active record ORM, etc. This exposed me to the underlying complexities behind these tools/concepts, and how you use programming fundamentals to solve them in maintainable, testable ways. Only when I realized I was literally re-building what already existed, and what already existed was more feature-complete than what I was writing, did I say "Ok, I get it now. Time to just use the framework". But because I had started from the ground up learning fundamental programming principles and applying those to build common architectural elements of a framework, I had a much more thorough and complete understanding of frameworks in general, and also how to properly augment what they give you out of the box (or build what they don't). That fundamental background also made it MUCH easier to overcome all of the horrible limitations of things like WordPress. Worst case scenario is I can brute force a WP site if I need to: totally skip all of the nonsensical WP API and DBAL, and side-load my own features into WP, saving enormous amounts of time.
Years ago, I was happy to have jQuery around. JavaScript was okay, but the API provided by browsers was lacking and inconsistent. Today, I'm sad that programmers are still clinging on it out of convenience, while there is so much they've missed.
Oh I do use MDN all the time. Only problem is when I am googling, W3schools always comes up first which is generally less than helpful. And don't get me wrong, the people on Stack Overflow are incredibly helpful. The last two questions I have asked were answered and explained in detail so that I could understand them within 3 minutes of my posting the question. I tried to learn JS on my own about 6 months ago, and crashed and burned out quickly. This time, in only one month, I am already halfway through my first JS based web project, and I am writing actual code that does something meaningful. If I didn't have communities like here and people on Stack Overflow willing to help out, I would be learning much more slowly. 
Developer.mozilla.com Click on the text box, type in your search term, then hit enter. We are all willing to help but you gotta push yourself in this field because it moves faster than anyone can keep up. Everyone is behind. Realize the fact that everyone else is behind too, and a lot of the stress will fall away. You're not dumb or incapable by any means. Keep going!
I agree with your professional opinion as well. It all depends on the methodologies of the API, whether abstracted or not. As somebody who in his career has studied the source of jQuery, jQuery UI plug-ins, and 3rd party jQuery modules, I've written in technical detail on these points. Language and libs are not mutually exclusive, and both should be studied by developers at some point :) ~~JavaScript was effectively slandered by many Java devs when it first came out, but~~ JS devs in the last decade have abundantly overcome ~~that~~. {Sorry, Wikipedia.} &gt; [It turns out it's not too shabby after all.](https://www.quora.com/What-does-Steve-Wozniak-think-of-JavaScript) In actually, it's always been the browser standards that were broken. Things are just poorly implemented or flawed, such as AJAX, CSS, 3D CSS, memory management, etc. And traditionally, the struggle has been vendor and backwards compatibility, some vendors not even backwards compatible with themselves. ;) Unfortunately, an unhealthy ecosystem/platform has put a tremendous amount of developers at a disposition. To quote my conclusion on a number of JS libs, not just jQuery: &gt; *Nearly all JS libraries and frameworks re-implement something that the browser should have implemented, and properly, (the key-word,) in the first place. JQuery does it, (and the alternatives,) React does it, Famous does it, even my own do it, and so forth.* This is not the sign of a stable platform, is it? Libraries often are mistrusted as the proper implementation. One example is jQuery. In order to achieve what jQuery did, they had to work around these issues. In doing so, there wasn't a perfect solution. A lot of new features were brought to the table, but not truly in the most optimal way. Again, a lot of that has to do with the limitations faced with the browser. &gt; If the concept behind jQuery [and others like React] were to be made professionally integral into the browser itself, I would commend the idea. That means, though, a lot of work would have to be done in order to optimize the paradigm, couple it with the environment, and structure it for scale. (.querySelector is the perfect start.) The Aurelia library sounds a lot like mine and my work from that standpoint. I put a lot into each and every decision. Would you mind please taking a look at it? &gt; http://js-lib.org or https://xoftware.github.io/js-lib.org/ Just kidding ;) hope you got a kick out of my landing page! The repo is actually here: &gt; https://github.com/xoftware/xoftware.github.io/tree/master/js-lib.org The lib is elegantly called on.js. 
As with all things, the documentation should always be available to use. It's more important to know that they exist and approximately what they are used for so that you can query the documentation should you actually need them.
I feel your sentiment about spending a year learning all the ins and outs. We often say JS, when it's not JS itself that's terribly overwhelming, but the environment it's in. I remember when I first started web dev., I literally spent a steady 6mo-1yr (on top of all the time already spent prior) working overtime to learn all the ins and outs of the platform. I practically memorized every single situation in which the quirky CSS could be used. (So much time wasted on something arbitrary that's not even Computer Science.) But it's not just the front-end. We have to code in partnership for the back-end, which I was also doing at the same time, and creating the design/graphics. All of these have to do with how the JS works in its environment, so it was a good practice, but honestly, I knew I was in a unique position to have the opportunity to do that. I dropped out of college from spending so much time on it! (Yeah.... blame JS!!) Thankfully, I'm glad I did, and it paid off and I started my career successfully from there. :)
This is why I'm scared to apply for jobs. Luckily I know the basics of JS (variables, data types, comparison, arrays, objects etc) but it's all come to a point where I can't keep up with the frameworks anymore. Basic knowledge can only take you so far. EVERY JOB LISTING HAS A FRAMEWORK. It's gotten to the point where I've become kinda desperate for any work . And now I'm working as a cashier, my degree all but useless. 
While I do agree with you 100% on your main point, I wouldn't say React is very abstracted. Defining components can be done in es5 that look like regular old objects, and JSX looks a lot like HTML, so much so I sometimes write out HTML for styling, then I change all of the **class** to **className**
Thank you :)
Nothing compiles well enough to javascript that you don't need to know javascript.
Well, there's an existence proof in Clojurescript that I contend refutes your position there. Clojure has two false values (nil and false), obvious equality, and no operator precedence. So aside from knowing JS function names like setTimeout and parseInt, you need no knowledge of how JS works to write efficient browser code using Clojurescript. I'm sure there are other examples.
readme sucks
Not single-handedly, but I know what you mean and this is very well put. There are so many front-end libs out there, it's like everybody just has to develop their own in order to work with the code. I believe in the follow native standards as closely as possible, which is how I've centered my work and my own libraries/frameworks for that matter. As a senior developer, I would love to help junior devs. That's who I wanted to write that library for in the first place. I haven't been all too successful in influencing people though. The problem has just been out of control for such a long time it's hard to break molds.
You can still find work. My advice would be, if you want to work for somebody else, use your degree to get your foot in the door somewhere where you truly want to work. Just go to some meetups or conferences and tell people you want to work. You can always build up a porfolio, and who knows, maybe you'll start your own firm or be teaching videos online one day!
1. I don't believe JS is actually what's flawed. Here is my best attempt at surmising it lightly: https://www.quora.com/What-does-Steve-Wozniak-think-of-JavaScript 2. Have you checked out ASM/Emscripten. It compiles C to JS. (Last I checked there was performance hit, as expected.) Unreal Engine, for example, has been ported to JS. Actually, to be accurate, it compiles C to machine language, and then passes it through JS to the interpreter in the browser. Not as good as we hoped, but impressive anyhow. Back to point 1, I actually believe one of the problems is people trying to take other language features and push them into ECMAScript specs. JavaScript, in theory, is actually very eloquent, as I described above. I suspect devs from other languages want to turn it more into their own language, but I don't think you can just push any old features into a paradigm, so the implementation has to be very thorough if feasable. What I'd like to see is two things. 1. A new JS that is multi-threaded, giving us either option of very different programming paradigms, standard single-threaded JS or the new one. 2. Diversity of front-end scripting languages, or better yet, the ability to establish our own scripted language core.
JS isn't flawed. Assembly isn't flawed either. But as soon as people figured out multiple languages could be compiled to processor instructions so that people could ignore processor instructions, those languages gained in popularity. JS compilation presents an even bigger opportunity to reliably ignore JS. I think as soon as people start considering ES6/Babel, or other languages invented to improve java\_ like type\_ and coffee\_, other more mature and well researched and understood languages like Scala and Clojure should be considered too. Coffee_ and Type_ haven't been used for anything outside of compiling to java_. Scala and Clojure are powerful, sound, and widely used outside of the browser. The ASM example is also a good one. Compiling C "upwards" to js is awesome. Viewed in that light I don't think ES5/6/7 (or any subset between) stands up against other mature languages for any app that could grow large. The real power of JS is more like the power of the JVM in my view. 
That's a very valuable perspective, and I appreciate you pointing that out. I *would* be, however, curious to see how far JS could be pushed on its intrinsic paradigm. It's fascinating to me, how prototype really works, and it does have a baby-ish feel to it, but there's something to be said about that, that we can study and take away from. We could study those limitations and get a better sense of methodologies/patterns. Lol, compiling upwards is awesome! But my mind goes straight to security. What do you feel about the security involved in this process? We certainly need it to be the top priority for modeling the platform around. And also what you've proposed would seem to require multi-threaded abilities at some point too, and I'm happy with that. :)
&gt;I think this rings true for any framework in any language, not just Javascript. It's a little different with Javascript. It's not a complete platform. Unlike other languages, JS doesn't give you anything out of the box, even basics like a standardized module system. If you attempt to write any sort of non-trivial application with vanilla JS, you'll have to invent one. &gt;In 2016 it makes very little sense to abstract things, yet frameworks like Angular 2 are still doing it and React is even worse with its convention for defining components and Jsx syntax. Because if you're writing a large single-page application, and putting down 100,000 lines of code, vanilla JS + DOM isn't enough. You're going to create ~~unattainable~~ unmaintainable mess. &gt;This is why I have been using Aurelia for the last year and a half now. Oh brother. These frameworks come out every 6 months. React was a darling last year at this time. Now it's 'Aurelia'. &gt;sometimes I just use straight-up Javascript for a basic site that only needs a little Javascript, I agree. A basic site doesn't need much. &gt;this is what happened with Angular 1 and developers adding in React to address performance shortcomings. I think those React performance benchmarks were completely overblown. First because DOM is already friggen fast and highly optimized by native rendering engines. Second because you really needed to do dumb things in non-React world in order to visibility kill your performance compared to React equivalent. Third, React is not immune to dumb code and bad design decisions and in some ways is even worse since you really have to be careful not to deviate from the optimal React path. And finally, every benchmark I've seen was based around some dinky simple use-case - React looked good rendering 50,000 items in a 100 line TODO list app - great, thanks. &gt;frameworks like Angular and Backbone needed to abstract because the underlying foundations were cracked No. They were an attempt to write maintainable code because you couldn't do it with vanilla JS.
Lol. So I was thinking about this and thought what if we start compiling C to JS for node? It'd be like ZRAM, where we started with RAM, then Swap (virtual RAM on Disk), then ZRAM (compressed virtual Swap in RAM.)
you have a degree in CS and are having trouble finding work?
That looks great. By the way, how did you approach learning React? Official documentation, a book, course, etc.? I know there are lots of resources. Edit: For context, I started learning React by doing a great (paid – thanks, work) course by Wes Bos called React for Beginners. A few things changed with ES6 so there are videos added to the end of the course to migrate things.
Author of the blog post here - not sure if I need to preface it, but anything I write is not related to the work that I do at Palantir. I write because I enjoy teaching and helping others get through some of the struggles I had when I initially tried to learn new technologies. I do use the experience that I've gained while writing code at my workplace but aside from that, I never write about anything directly related to my work. Hopefully that makes you feel less awkward or uncomfortable reading the article.
&gt;you are not a Javascript developer because you've been working inside of a framework and technically learning the framework, not the language. So what? Our industry is constantly in flux. Things change rapidly. Look at your case, Aurelia is in and the past darlings, React and Angular are out. Where was Aurelia a year ago? I sincerely believe nothing is wasted and skills are transferable. A talented AS3 developer will be a talented JS developer, with te benefit of experience and perspective that came from working on different platforms. Every language and platform has some good ideas and some bad ideas and you take that experience for the rest of your career. Having said that, there is a class of programmers who use frameworks as crutch. They will learn techniques and never graduate beyond the very shallow understanding of whatever framework or platform they are on. For those guys learning vanilla JS isn't going to do anything. 
&gt;JavaScript was effectively slandered by many Java devs when it first came out, but JS devs in the last decade have abundantly overcome that. What are you talking about?! That's not even remotely close to history. 
To add on to this, try taking a project that you have done in RoR and do it with MERN / MEAN. Seems like react is the hottest framework right now so I would suggest that over angular.
My understanding is that the false representation prototype received was due to its similar syntax, but different functionality from Java. JavaScript is the most historically misunderstood language, largely due to the reasons I've posted and negative propaganda. What is your recollection?
If you're serious about a programming career, don't worry about languages, frameworks or platforms. Pick something, anything, to start and throw a lot of time at it. It really is practice, practice, practice. 
I started learning JS by building a bot for Discord using Node.Js. Granted, I've asked plenty of questions, but I can build apps, use JavaScript for websites, and Use jQuery. I. Fucking. Love. It. When at the end of a project, it's so satisfying watching your own work actually doing things Especially when to comes to making others lives easier.
Too bad we can just use the Devtools to do this now.
Aurelia's performance is great. Like with most things, there is always room to improve. Most of those slow loading issues you speak of are because the apps are not being properly bundled (or at all). The tooling and bundling story in Aurelia has had a turbulent past (it's fine now though), which might explain why some examples are slow. For code examples that link off to Github Pages, generally they are old Jspm demos and are not bundled, so files are being loaded one-by-one. I built that Built With Aurelia site you mention, if you inspect the page you can see it is quite light. There is a loading indicator shown because I am fetching data from Firebase, so you have latency and whatnot to contend with. Some examples of optimised Aurelia applications include; - https://gist.run/ - http://www.arenaoftitans.com/ - https://pokego.run/ (disclaimer: I made this) You can produce a Hello World app using the CLI and because you wouldn't need to include any dependencies like the router, event aggregator, etc, the resulting bundle would be small. Having said that, Hello World style apps in any SPA framework are always going to have come with baggage (loaders, transpiler runtimes, dependencies for internal framework functionality). I don't think using "Hello World" as a basis for evaluating a SPA is the right thing to do, that's why a todo application is generally considered the benchmark for how easy a SPA framework is to setup and use.
Thanks for the thorough reply! I'm going to check out Aurelia (so far I've only skimmed some of the guide, visited your builtwithaurelia.com site, etc). And point taken about todo apps being a better basis for evaluating SPA frameworks. Thanks again.
I still think there's some merit to what I said.... but you gave a great explanation and it sounds right. I think I read that on wikipedia, but it could be wrong.... maybe you should update it! &gt; The irony is that Microsoft accidentally created the industry by unilaterally adding XMLHttpRequest (AJAX) so they could build a web version of Outlook in the late 1990s That's so true! They didn't care about standards and I'll admit sometimes theirs is better, sometimes Mozilla's is, etc. But at the sime time, AJAX is one of the worst implemented features of all time. The reason why every ajax library, like jquery, has to do polling, the memory leakage. Also, IE had memory leakage everywhere else too. I've written libs that polyfill IE 7's lack of AJAX upload capability with the pre-AJAX way of using iframes. :) So, I take it JS is now worth developing in? I actually love the idea of prototype, even though it's obviously limited, but in a good way. The other thing about AJAX being accidental that's so crazy is that it not only made front-end, so to speak, but it also made server-side. JS is evented, which is perfect for user-interface, but happened to work for server-client communication as well, so we ended up with JSON, and then Node.js JS really is a wild thing when you think about it.
That's very cool idea man, so small but still so useful. Don't know if I would use a module for it though. But thanks for adding the idea to my toolbox.
I found this npm library, https://www.npmjs.com/package/mochify. which runs the test in headless browser without the html pages. 
What is "Vanilla JS"? Where does it stop? I am having the problem of either finding too basic tutorials/guides (explaining things that I already know because of programming experience in other languages) or finding people discussing e.g. the different ways of using Promises (where they use several frameworks and patterns in the code that I am not familiar with). I am missing a bridge.
I guess in that case then, if you do ever come back to change the method, you could "find all references" and retro fit some tests that pass, then make your changes, and adjust your tests. I try and have a policy to unit test absolutely everything I possibly can - even for something which seems so trivial I like the piece of mind of spending ~15 minutes writing a couple of simple tests and then it's done. 
I found [this API Guide pair programming session](https://www.youtube.com/watch?v=KSuCYUqY058) with Evan (the creator of Elm) very enlightening. I'm also a beginner and the video just leads the viewer through the whole process of creating the model, update and view parts; including valuable insights on what to use and what to avoid. At least with me, this clicked instantly
Here we go again.
&gt;unattainable You mean unmaintainable?
[removed]
&gt; Aurelia And it's got a new build tool too, for whatever reason. Karma.
What was it doing that confused you?
I both agree and disagree :) You're right in that companies put out job specs saying "Must know Angular!!!" But it makes me cringe. What they need is a good Java script dev who will learn any framework you build on quickly. Specializing in one framework screams of a company who's HR or recruiters have no idea. But it's the way of the world now. 
I'd start with doing a piecemeal upgrade of an existing RoR application to use MongoDB. Then work on upgrading the front-end to a React implementation (don't even worry about Redux for now). Do it piece by piece, then when you're comfortable enough with Mongo and React, start with a simple Express app and plug in what you know.
Lol a degree in CS and can't even keep up with web development? Just build an Aurelia App with Vanilla JS and use that as a showcase to employers. Also, learning CS to be a web developer is not really needed - CS Is for more in-depth programming.
It mention JS but wasn't about JS. There's a difference.
I didn't understand the function argument element within the filter. There are a lot of things I think I understand then as soon as they get more complicated I'm in the weeds. 
Another day, another frontend-dev subreddit has an article whining about frameworks and libraries. Sun goes up, sun goes down.
I have found where your test case is failing. It is failing on fibonacci(79). On fibonacci(78) you are doing fine but after that you are somehow adding 1 to the output. I suppose your algorithm with the carry flag is failing when the number is too large.
No, it doesn't. OAuth lets the end user authenticate and grant permission for your app to access various API's as you already know, though you can't get the token any other way, you have to use the API. A user can't sign in via the regular google log in pages, that's outside the scope of the API :-) 
Alrighty. So I have a button on my web tool right now that looks like this: http://i.imgur.com/zeM2EbH.jpg When I click that button, the auth window pops up, showing my account and all of my Google+ pages as possible options: http://i.imgur.com/cvDJ4Px.jpg That's exactly what I want to happen. If I click on my account, everything is great. If I click on a Google+ page, that's when the exception is thrown. How should I be handling this instead?
Impressive!
cool! I read that book too some weeks ago. Great recommendation!
What is happening with the examples? Thanks, this is one of my favorite works so far - maybe because it will save so many hours and stress. Also one of the most unpopular ones, interestingly. 
My GPU is crappy af, so it struggles. 
That's strange because if I don't `return` the `reject` in the `try/catch` in members function it doesn't get caught in the `.catch` in the second block of code. The code will continue after the `reject`. I test this by changing `JSON.parse(body.substring(9))` to `substring(8)` which makes the JSON invalid. 
I compared these 3 results with wolframs answers: http://www.wolframalpha.com/input/?x=0&amp;y=0&amp;i=fibonacci(80) …and it looks correct 78: 8944394323791464 79: 14472334024676221 80: 23416728348467685
That's not true. If you're doing simple marketing sites then yes cs won't be as helpful. But many web devs are doing what traditionally would be native applications on web eg https://clara.io/
Come on man. [This](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) is the explanation on MDN. &gt; Function to test each element of the array. Invoked with arguments (element, index, array). Return true to keep the element, false otherwise.
This happened to me with Ionic (Angular). It uses whatever default browser. Somehow on fire tablets the ble saving is broken.
Your usage looks fine to me. The only nit-pick I have is this: let self = this Since you're using fat-arrows everywhere, you can replace all usages of `self` with `this` and save yourself the extra noise.
Wasn't it Microsoft not Java. Microsoft copied JavaScript verbatim just to dupe JavaScript. JavaScript had to move to another board which is ECMA now
LOL there's more to Web Development than Wordpress sites.
This is one of the best reads for anyone new to game development in JS. It will give you a good foundation, but fair warning it's a long read :). Highly recommend: https://retrosnob.files.wordpress.com/2014/10/foundation-game-design-with-html5-and-javascript-v413hav-1.pdf
Basically this. Thank you for saving me from writing that much text haha.
This code is complicated by the fact you are not using a promise based http request lib. Use axios or fetch
Not to mention dates, or valid javascript identifiers...
Reject returns anyway so it's redundant 
*re-write FTFY
This, but: open new tab, type "mdn [insert api keyword]"
Callbacks have been the answer to this problem for years. Promises have become a great solution for most generic async problems and there are a few ideas being kicked around now with generators &amp; spawning processes. Also async await seemed promising (hah!) although im not confident it will be stably released or that you should use it ever. I'd go with callbacks or promises. Promises: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise async generators: https://davidwalsh.name/async-generators Async-await compared: https://ponyfoo.com/articles/understanding-javascript-async-await
Try to avoid callbacks because your code can become tangled (google "callback hell"). There is some control flow libraries out there which makes easy to deal with asynchronicity, example using, https://gitub.com/yosbelms/getjs function foo(x, y, z) { //does some things //does some calculations return get.go(function *() { // does some calculations return yield get.go(fucntion *() { // does some calculations // Found what we're looking for! .... return answer }) }) } // execute foo(x, y, z).then(function(answer) { // I got the answer })
Hmm. I don't see anything in those docs about what I'm looking for... Thanks for the links though!
No. It was considered dangerous to allow any object in JS to be iterable (eg. forgetting Symbol.iterator would just give you key enumeration). Use `for([key, value] of Object.entries(myObj))` instead (Object.entries is built-in).
Im kind of a noob at this but im making a bot for discord. So i guess that would be a script... maybe?
On a browser it'd be: function downloadFile(path, cb) { var client = new XMLHttpRequest(); client.open('GET', path); client.onreadystatechange = function processFile() { var DONE = 4; // readyState 4 means the request is done. var OK = 200; // status 200 is a successful return. if (client.readyState === DONE) { if (client.status === OK) { cb(null, client.responseText); } else { cb(client.status, null); console.log('Error: ' + client.status); // An error occurred during the request. } } } client.send(); } downloadFile('https://www.reddit.com/r/pics/random.json', function (error, json) { if (error) return; var posts = JSON.parse(json); var post = posts &amp;&amp; posts[0] &amp;&amp; posts[0].data &amp;&amp; posts[0].data.children &amp;&amp; posts[0].data.children[0] &amp;&amp; posts[0].data.children[0].data; console.log('title', post.title); console.log('thumbnail', post.thumbnail); console.log('url', post.url); });
Are you using NodeJS?
Yes
Still won't happen please, try the code in your browser and then return here.
I simply must agree with this fellow here.
What do you mean? I said in my last comment that you we're right, simply rejecting doesn't stop code execution. http://codepen.io/anon/pen/mEYwZV?editors=1111
I feel like one of the key parts of being a software engineer is being able to learn new things quickly. I was hired at my current job as a C# developer with no web experience, but when we wanted to start a web project, I taught myself how to use JavaScript, Angular (1 &amp; 2), and several other libraries. Don't be afraid of not knowing the specific framework a company is using. Have confidence in your ability to learn new things and you'll be invaluable to whatever company hires you.
In the directory that you want to use the script run this command in your terminal: npm install request --save Then save this code as "getRedditPost.js" var request = require('request'); request('http://www.reddit.com/r/pics/random.json', function (error, response, body) { if (!error &amp;&amp; response.statusCode == 200) { var posts = JSON.parse(body); var post = posts &amp;&amp; posts[0] &amp;&amp; posts[0].data &amp;&amp; posts[0].data.children &amp;&amp; posts[0].data.children[0] &amp;&amp; posts[0].data.children[0].data; console.log('title', post.title); console.log('thumbnail', post.thumbnail); console.log('url', post.url); } }); Finally, you can execute this code in your terminal with the command: node getRedditPost.js This should get you started. You say you're a noob, but you're going to need to learn a ton just to be able to use this little script.
Learn how to configure webpack and get building in whatever you prefer. I prefer React because it lets you do whatever you want and I just like JSX, Express and Mongo will be easy to you as an experienced developer so I'd learn as you go along. Mongoose is pretty helpful with Mongo.
Good article, terrible title.
It depends. I've worked with people who have no idea what a closure is but actually write them all the time. I would say that not understanding bubbling, first class functions, hoisting, or even just lexical scope can be very time expensive. Not understanding these things leads to messy code and just trying stuff until it seems to work. It also leads to what I call scitzo code. Code that has been cut and pasted from stackoverflow so it has so many different styles that it's hard to read. But if a person is good at a framework that abstracts most of the JavaScript away (like angular) then they can get stuff done. Ideally I want someone who is curious and will spend some extra time to figure out why something works rather than just accept it and move on. This curiosity seems to be rare in the JavaScript world though. Maybe because it's really hard to figure out why something like bubbling seems to be working or how. Prototypes might as well be a black box. 
I do believe that you're going to have to be a bit more explanatory.
Really great explanation. Showing things "break" really makes it click when it works.
Douglas Crockford has an interesting talk on the topic. https://www.youtube.com/watch?v=RO1Wnu-xKoY&amp;list=PL7664379246A246CB&amp;index=2
awesome, cant wait for more
https://www.toptal.com/javascript/interview-questions Modify these questions. They all cover fundamental understand of JS, but they're also the first result when you search "JavaScript interview questions"
Here is a detailed explaination: http://eloquentjavascript.net/06_object.html
They are a Jr. Dev with a MS internship under their belt. Not a lot of public work to point to. I am not looking for algorithm question but basic JS stuff and Maybe a unit testing problem.
just say no to code like this. 
thank you
thank you 
inb4 "but HTML5 video lacks [x] feature!"
&gt; Also, learning CS to be a web developer is not really needed - CS Is for more in-depth programming. If you never deal with more than a hundred records I guess it's true that data structures and algorithms don't matter very much; otherwise that stuff has applications in Web dev.
Wasn't Gmail written in some thing where they compiled Java to JS?
This is how I got hired at my job with no experience. I learned enough about Angular to answer questions in the interview but was upfront with them in saying I had no real-world experience with it. Just knowing a little bit about it and showing my passion to learn was enough to get me the job. I built a personal site in mostly jQuery, and they were like, "We don't really use jQuery," and I said, "That's fine. I learned all that within a couple weeks. I'm sure Angular won't be as easy, but it won't take me long to figure it out either." Now, a year later, I'm one of the leading Angular devs and helped spearhead a giant project we were doing in Angular 2. I ended up working for one of the guys that interviewed me, and he told me, "I was hesitant about hiring you, but I'm glad I did!"
Yeah, I was working on an Angular 2 app, and someone couldn't figure out an error she was getting. According to the ONE answer found online, it was a typecasting issue and was supposed to be written as `(&lt;Control&gt; this.myForm.controls['controlName']).updateValue(val);` Unfortunately, we had updated to a new RC, and that was no longer accurate. When using it, it got a different error, so I had to dig into the actual Angular 2 code and realized `&lt;Control&gt;` had been changed to `&lt;FormControl&gt;` It pays to be able to understand the framework's code. 
That's an awesome one!! thanks for the share :-)
Nice
Elm is another example.
The biggest offense is jQuery dom manipulation for things that can now be accomplished with simple CSS. I see so many jQuery animations for things that can be done with css transitions and animations, and the absolute worst is using `next()` in jQuery when you could just use `nthChild()`.
HTML5 video lacks taking control of the user network stack! How can I continue to spam some irc server with HTML5 videos?
You're right, I probably should. I always question myself when I don't use a semicolon, and many times it's natural instinct to put them in (coming from languages where I have to use them), I end up backspacing to delete them. I spent too long using Python. Just went through all my code to add them back.
I really liked this, I like the approach. It's really clear where the usefulness lies, and the logical steps - particularly the parts where something was now "broken" and needed fixing - made it easy to follow.
you will still be able to to send your spam to people in 3rd world countries for a few years.
Are you saying the state in the parent or child component is empty after render? Just for shits and giggles try passing the props down like this instead of using the spread operator: &lt;DisplayGame games={this.state.games} /&gt; And accessing it like this: this.props.games Would be really helpful if you threw your code in something like js bin
Remove the `g` flag from your regular expressions.
When you use the global match flag, the regex becomes stateful. You can read about it on MDN, but it's not behavior that you want in this case. 
&gt; I was wondering if it's possible to just do on the fly with web inspector You can enter any JS in your browser's console and it will be executed in the context of the current web page, so yes, you can certainly modify the page that way. But the changes aren't permanent and will disappear if you reload the page. &gt; should I make use of tamper monkey for such endeavors Tampermonkey and Greasemonkey allow you to write a user script which executes JS in the context of the target page in a similar way as running it in the console, but it's automated so that it happens each time the page is loaded. If your alterations can be done with CSS, then you can also write a user style with Stylish, which lets you inject CSS in an analogous way. You can also write a full-blown browser extension, which gives you added capabilities, such as tighter integration with the browser and extra privileges not normally available to user scripts. For simple tasks that's overkill and a userscript is all that's needed. &gt; Is it possible to accidentally mess with someone else's experience with a given web page? Not unless you get them to install the userscript/extension that you wrote. 
This looks awesome. Interesting to see they are also using good ol' battle-tested RequireJS as well.
Literally walking through the thought process really helped me understand. Subscribed!
Yup, you get a new `this` every time you use `function`, whereas `this` retains its value when using `=&gt;`. Saving keystrokes is nice, but maintaining `this` is even nicer!
https://www.codewars.com has many exercises on several languages, including Javascript, sorted by difficulty and topics, and has a way to test solutions.
Have a smartphone? Use an online service like codepen. 
More like Google shooting its own browser in the foot.
They'll have to move to canvas, I suppose. Maybe somebody's writing an ActionScript/Flash to JS/Canvas transpiler.
Here's what was happening: The child component (DisplayGame) was being rendered before the Ajax call filled the userData state with the requested JSON. So the child component was trying to access data that didn't exist yet, producing a JS error. So I just added a conditional in the parent component (App) that says if userData is empty, do not render anything. This solved my issue although I do not think it is the best solution. 
This is a great explanation. I would like to add that this line isn't necessary in ES6: function foo (...args) { console.assert(Array.isArray(args)) console.log(...args) } foo(1, 2, 3)
Also, be aware: leaking, modifying, or even mentioning the keyword 'arguments' in a function can cause jit js compilers to deoptimize the function. You have to be very careful to avoid this: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments Also, in my tests, if you define a callback inside a function, where the outer function contains the keyword 'arguments', even if you do nothing with it, the callback function will generate an extra closure.
I'm a big fan of [repl.it](http://repl.it) for interpreted (and some compiled!) languages. You'll be rather limited in what you can do, but I use it frequently when I don't have my handy python interpreter installed.
I wonder if arguments in JavaScript was made an Array-like Object because there was thought about maybe doing: function( bacon="true", lettuce="true", tomato="true") { return arguments[0] &amp;&amp; arguments.lettuce &amp;&amp; arguments["tomato"] } I mean the arguments array/object and parameter defaulting, not the sandwich.
Just a typo, try Millimeter with 2 L's
Will it be around in six months?
After, or even alongside Codecademy, you can also check out https://www.freecodecamp.com - they also allow you to practise programming in their browser, and also encourage using CodePen for your projects.
That was a very well done video. I learned a lot about webpack. But I vehemently disagree with the "optimization" to make Snap SVG a first-party JS library. Loading JS libraries from their CDN is good for so many reasons: * The D in CDN, which means that it's globally distributed. Your site may or may not be. * Cache granularity. If you make a change to your first-party JS, the bundle that includes this SVG library will be updated and not match the old cached version. Keeping them in separate JS binaries means that one can change but the other can still be pulled from cache. There is another angle to this which is that users may already have this library's JS in their cache, even if they've never been to your site before. This is common for things like CDN-hosted jQuery or popular web fonts. So doing this actually helps speed up other sites too! * Content updates. Let's say there's a bug or at worst a security vulnerability in the third-party JS library. You would need to update the version from npm and redeploy your site. If you are pulling from the CDN, they worry about pushing updates, so you get the patched version automatically. The biggest disadvantage is the additional DNS/SSL/TCP cost to load from a separate domain. However, DNS and SSL are cacheable as well, so this cost is only incurred once in a while. Another gotcha is that third party scripts can be a source of SPOF. If the CDN goes down, the request will time out and your site would be left hanging. There are ways to mitigate this.
That's because it's not a distance, it's the number of neighbour mines: https://en.wikipedia.org/wiki/Minesweeper_(video_game) 😄
I mean what Brendan Eich was thinking when he created JS. (You're talking about now, with ES6.)
[Markdown.it](https://github.com/markdown-it/markdown-it) and [dillinger](https://github.com/joemccann/dillinger) come to mind.
Thanks. I'll check it out!
Array has always used Object as its prototype. You have always been able to do that.
Oh, yeah in that sense. I thought you were referring to something in ES6 I didn't kno because of `let`. You *can* do that, but it should never be done in production, unless every iteration uses `for(var i=args.length;--i;)` and not `for(i in args)` EDIT: Actually, if it's specifically an arguments array, you're likely not to iterate over it ever, so you could probably just do arguments.xyz=arguments[0]; But it's still redundant, unless you have a function factory or something that does it for you automatically.
looks like _everything_ is commented
Most stuff in web land isn't around for very long... it's usually soon usurped by some random new upstart framework. Rough case in point: Scriptaculous -&gt; Prototype/Mootools -&gt; jQuery -&gt; Underscore -&gt; LodashAngularReactjsRamda -&gt; ??
+/u/CompileBot Javascript var bottles; for (counter = 99; counter &gt;= 1; counter = counter - 1) { if (counter == 1) { bottles = 'bottle'; } else { bottles = 'bottles'; } print(counter + " " + bottles + " of beer on the wall."); if (counter &lt; 99) { print(""); print(counter + " " + bottles + " of beer on the wall."); } print(counter + " " + bottles + " of beer."); print("Take one down."); print("Pass it around."); if (counter == 1) { print("No bottles of beer on the wall."); } }
Output: 99 bottles of beer on the wall. 99 bottles of beer. Take one down. Pass it around. 98 bottles of beer on the wall. 98 bottles of beer on the wall. 98 bottles of beer. Take one down. Pass it around. 97 bottles of beer on the wall. 97 bottles of beer on the wall. 97 bottles of beer. Take one down. Pass it around. 96 bottles of beer on the wall. 96 bottles of beer on the wall. 96 bottles of beer. Take one down. Pass it around. 95 bottles of beer on the wall. 95 bottles of beer on the wall. 95 bottles of beer. Take one down. Pass it around. 94 bottles of beer on the wall. 94 bottles of beer on the wall. 94 bottles of beer. Take one down. Pass it around. 93 bottles of beer on the wall. 93 bottles of beer on the wall. 93 bottles of beer. Take one down. Pass it around. 92 bottles of beer on the wall. 92 bottles of beer on the wall. 92 bottles of beer. Take one down. Pass it around. 91 bottles of beer on the wall. 91 bottles of beer on the wall. 91 bottles of beer. Take one down. ... [^source](http://ideone.com/6xz9zR) ^| [^info](http://www.reddit.com/r/CompileBot/wiki) ^| [^git](https://github.com/renfredxh/compilebot) ^| [^report](http://www.reddit.com/message/compose?to=compilebot&amp;subject=Report%20Abuse&amp;message=--report%20https%3A//www.reddit.com/r/javascript/comments/4z2quy/how_to_learn_to_code_without_a_personal_computer/d6sz2mt%20Include%20your%20reason%20for%20reporting%20here.) 
Haven't they been saying that Flash Is Dead for years? 
Why would you do that when JS does it for you?
and... what happens with video chats? Flash was a good candidate to use for that (on desktop browsers) since it can access to the microphone and camera devices. Some modern browsers can also do that without flash, but IE and Safari can't. All websites that has a video chat use flash on desktop browsers. They only use HLS and other stuff when you are on mobile devices. I don't know how they will solve that since WebRTC is not still ready for all current browsers.
and also video chat websites which are all of them built on flash due to browser compatibility. IE and Safari cannot access to camera/microphone without flash.
eslint can do some formatting: eslint --fix some-script.js 
yea. i doubt it will die off until people going forward abandon flash, but all those old sites are still going to use flash.
I completely agree!
i will try this
I feel like half the articles I read about react are subtly (or not so subtly) telling me what I *must* be doing wrong. 
You get adaptive bitrate switching with html5 video for HLS streams at least (haven't worked with other formats).
Sorry, but I still don't get what you mean 🤔
..if you compare it to i.e.: https://32lyrics.files.wordpress.com/2014/02/minesweeper.jpg
[What about making a flash VM/interpreter in javascript?](https://github.com/mozilla/shumway)
This is a repost. [Original reddit thread]( https://www.reddit.com/r/javascript/comments/4hgu2i/cyclejs_aurelia_mithrill_and_the_others_trending/) 
For not-too-deep stuff for the front-end maybe try https://codepen.io which has support for simple JS/HTML/CSS code that will be combined and shown.
Wow, scriptaculus. Deep cut right there. Oh the memories...
&gt; Is that a joke? No joke. I've seen far too many useless GitHub homepages that I refuse to spend any time on them. As soon as I saw it was GitHub, I closed the page. Somebody who actually makes a real website in a readme on GitHub? That's a first. For me it is.
I've used both. Although there's not much in between them I recommend VSC over Brackets because Microsoft has experience in developing solid editors. Going forward I trust Microsoft over Adobe for not abandoning their editor. Also as someone said Atom is also a perfectly good open source editor and has significantly larger user base with decent amount of addons.
i do agree with the sources you stated, but even with semicolons, you still need to think about ASI, it does not absolve you from it cause ASI cannot be turned off. So then we are just back again to it being a preference.
I think we've already seen these. I remember reading about one a couple years ago. I don't remember the name though.
There isn't much technical details in this post, so it's not clear to me what this library provides. Other questions... * How do you communicate between services? * Transactions between services? * Log aggregation &amp; monitoring?
Even Adobe does.
There is this incredible thing where people make packages and then publish them on GitHub. GitHub has readme pages and also static HTML pages. Some people take advantage of these features, and some do not. To find out which category a package falls into, simply click the link and use your eyeballs to verify. If you're over here making arguments like this, your time isn't that precious. Reading isn't that hard. Feel cleansed as your questionably assembled prejudices melt away before you.
There are some "magic solutions" like this that do work on a few simple examples. Not worth the effort though. Source: was a flash developer for 8 years, JavaScript developer for longer. 
IF you have access to the file system or can see/run programs from a thumb drive on those comps you can use the following strategy. You could install Notepad++, visual studio code, or other light weight code editors as a portable program onto your portable drive (thumb, usb hard drive, etc), which will then run from the portable drive without installing to the host computer (portable install). You can store all your files on said portable drive, or another, whatever. Then use the built in machine's browser, or your own portable install onto the thumb drive as well. This lets you have a portable development environment that you should be able to use on any computer that lets you access your thumb drive from usb, and lets you run programs from it. Info I found on making visual studio code portable. https://github.com/garethflowers/vscode-portable
Oh. I sit corrected. Just assumed because it was a Microsoft product. EDIT: though all thought of Microsoft supporting products better and longer than adobe should be ignored for the mac version of said product. 
Just googled it. Thats pretty neat, I'll have to download the code at some point and see how it does things. Thats a whole system, what i put together is a simple implementation of the ui only.
This is the best Webpack intro I've seen.
It's an electron app... same codebase!
I actually dislike coffeescript. I'm very against transpiler type languages. Why write in a language that gets translated into another language like JS. Just write in JS and save yourself the extra step and that level of abstraction. I've been coding JS since netscape navigator introduced it so many moons ago. Its the one lang I can say I know almost inside and out. ES6 on the other hand does have a lot of support now a days in Firefox and Chrome, by the looks of it even edge supports it. Since I have to support IE 11 at work I've always been stuck with core JS and so I just built this thing with what I'm used to. But since FF and chrome support it now, I wouldn't mind redoing it one bored day in ES6 as a nice learning experience. See what you just did, you just introduced another itch I'll need to scratch. Shame on you, bad commenter :) 
sweet. I'll love to see what you do with it. Really the whole point of posting it and making this stuff open source, so I can see what other devs like you do with it :)
I'm excited to see the results of this!
I'm currently in love with vscode, can highly recommend :)
This won't help with HTML and CSS as immediately, but the browsers provide a solution for learning JavaScript. They come with tiny code editors. Here is how you access them: Developer tools/Inspector/Console is opened in Windows using the F12 key. On OSX you can open these with cmd+option+i. Open this tool and follow the additional instructions: **Firefox** Firefox has a mini-IDE called Scratchpad. To access this click on Firefox's tools icon, which is typically a hamburger (three horizontal line) icon. Inside there click the "Developer" icon and then choose "Scratchpad". **Firefox with Firebug** When you open Firebug's console it has a feature hidden behind a button to convert the input area from a line to a text editor. The appearance of this button has changed over the years, but in my OSX it is a right facing triangle with a tooltip that says "Show Command Editor". **Chrome** Chrome's Developer Tools now has a similar feature to Firebug's Command Editor, but its harder to get to. Open Developer Tools and go to the "Sources" tab. From there find a subtab named "Snippets". Right click in the open area in Snippets to create a new snippet. Experiment with some code and click the right facing triangle icon to run it. Using those tools you can experiment with any JavaScript the browser supports as well as the DOM against the current page content. If you have questions about how a certain feature or method works I find it is often faster to experiment directly in the browser than to look up the documentation. I suspect Edge has a similar feature and I remember Opera having a similar feature, but I don't have those browsers in front of me.
Atom has a bunch of useful plugins and easy to use package manager. I switch between atom and vim, when I am editing my code. Atom has a better syntax highlighting.
Considering that we are living in a somewhat privacy aware society, I don't expect that to be a problem.
Adapt or die. Sadly this is the case with a lot of technologies. With canvas and webgl there are a lot of available ways to create high performance HTML 5 games.
Chrome and Firefox will be required for those features until MS and Apple get their ass in gear.
Ok, put Scriptaculous on your resume and see who hires you. Folks are free to disagree in the form of downvotes, but framework churn is real, and I'd like to hear arguments against that being the case. A downvote isn't an argument.
Did I miss something? It asked me how satisfied I was with front-end solution, stack, api layer, etc. but never asked what I'm currently using. That seems like a crucial bit of data to include.
Yes, but DASH is the only cross platform solution and it is barely supported by anyone. https://developer.jwplayer.com/articles/html5-report/#adaptive-streaming
Exactly, you could at least disable all plugins which would include flash. With html5 media that is not included, so if the page autoplays then you're watching their video.
[Get MAC address[es].](https://git.io/get-mac-address)
All you did is repeat what i said and called me a dumbass. With flash you can disable plugins and whitelist/blacklist sites or extensions depending on what browser you're using. With html5 media there is no option for the end user to disable the autoplay, so if the site enables autoplay, by golly, you're watching the media they want you to watch.
It was a blissful experience using my smartphone web browser. Probably wouldn't have sat through it if it wasn't for the neatness of the survey. 
If anyone has any questions regarding the release feel free to hop on our [Gitter](https://gitter.im/marionettejs/backbone.marionette) or ask questions here :)
I agree :)
I wasn't able to submit my form. I went back through and double but checked but it kept saying I had missed a question.
I love that the top answer is "neither"
maybe he's looking for "x% of people are satisfied at the moment" rather than "x% of people are using framework y at the moment"
I've used atom, sublime text and Vscode. I found vscode has amazing intellisense and with a few addons, it can be made even better. The others don't come close. Atom becomes very sluggish when you have a lot of addons enabled, sublime is super fast but not very actively maintained I guess. Bracket has a lot of ground to cover
~~The main problem with JS is people want to morph the web development life cycle into something they have been used to with the likes of C/C++, Java, C#, and other languages that have the convenience of not being distributed over many computers and interconnected by unreliable wires or waves.~~
It uses typeform, somebody originally spent hours building typeform sure, but this survey wouldn't have taken long to put together at all.
There are plenty of keyframe dev tools for HTML 5 already. I like to use [Hype](http://tumult.com/hype/), but other tools exist such as [Adobe Edge](https://www.adobe.com/products/edge-animate.html) As for downvotes, who cares, some people just downvote because they don't want to hear opinions contrary to their personal beliefs. I'll never understand how anyone can be a tech enthusiast and not be a fan of everything. This field is so full of great tools, why limit your toolbox to just hammer and nails. 
&gt; It's highly robust since it's been around for eons. I fail to see causality here. 
Lol, yeah I know I have ADHD so I have a strong compulsion to add as many bells and whistles as possible. I like to think of it as the [Wild Wacky Action Bike](https://youtu.be/LtoZf_KfKLI) of Apps. 
Oh sorry for the late reply, what I did was I just watched a few videos on youtube [here](https://www.youtube.com/watch?v=MhkGQAoc7bc&amp;list=PLoYCgNOIyGABj2GQSlDRjgvXtqfDxKm5b). And that's about it, but I will say that going in I was already well aware of functional programming and much of the concepts React uses, having used similar solution in my Vanilla JS apps. A fair warning before watching any youtube tutorials, you may encounter a WIX ad that will blow your ear drums out. 
Both of them have their pro's and cons. VS Code is faster than Brackets, has better search overall imho and has a built in terminal (awesome). Brackets has more features out of the box for front end development, if I know I'm building a static site/template from scratch I can jump from html to css and back very easily and it comes with a preview meaning I don't have to spin up a server myself. Overall I'd say that if you focus only on js or are a node developer go with VS Code if do everithing front end side (html+css+js) go with Brackets. To be honest I have them both plus Sublime and Atom on my work and my home PC's I wouldn't say to spend much time on this decision just pick one and start coding!!
oops wrong argument I made there. What I wanted to say was: JS has a lot more kinks than other languages (except probably php)
I don't doubt it is proven and works for a lot of high profile companies. And saying FB uses it is quite different from saying "old = good"; and I just do not understand how the fact that something is old means the thing is robust. Old and still popular might, just not old alone.
[There were portions of the survey that had spaces for you to fill out "other" stacks, api layers, etc...](http://i.imgur.com/7cdWTdd.png)
Thanks everyone! this is all very helpful.
I always hear this, but since I've never used Mongo, I'm not really sure why it sucks besides not supporting transactions. Any insight? Also, if you feel like answering, can you recommend any ORMs to use on node.js with Postgres?
Thanks for the direction - I'll give this a try to see if I can get it working. Will report results.
RethinkDB for anything NoSQL
I wouldn't worry about the top 500 popular classic games not being available as html5 if I were you. except for the more development heavy ones like fire boy and water girl, or kingdom rush
have your function increment some variable, and read that variable so something like var counter = 0 function rng() { // your rng code counter++; } 
Press the box that pops up and that takes you to it. 
Here's what I recommend. Instead of simply calling $(selector).change() bind it to something static wrapper like: $(wrapper).on('change', 'dropdownselector', function() {}) Also inside the success function, instead of finding the same element again, use something like $(self).find(). Before the api call assign self = this Typing from mobile. 
I've found that most dev jobs (outside of places like Google, Facebook, etc) are mostly culture fits more than knowledge fits. If they think you will fit in well, and you will learn quickly, they will usually give you a shot. Obviously, this isn't always the case. There are some places that are so swamped with work that they don't have time to train, but there's one thing that nobody can ever teach, and that's passion. If you show you are truly passionate, people will be much more inclined to hire you.
It only seems to obfuscate the animation: if (qwerty) { // do nothing } else { // some bullshit that will eval to true/false if (Z++, Z &gt;= 7 &amp;&amp; (qwerty = !qwerty, $(".whale").css(...).fadeIn(300, function() { // animate setTimeout(d, 1e3)... }))) { Z = 1; } }
Oofa my company is still @1.8.8 -_-
This is the only correct answer. Use the correct type of database for your particular use case. Now, if your question was, "What is your preferred relational database?" then I would answer with PostgreSQL. 
What kind of pricing are you expecting?
Pricing will be comparable to other telephony API's for connectivity, with additional per-hour cost for conversational analysis tasks. For now, the hosted API here is a free evaluation. As an API user, you can either use the REST API or build permanent hosted scripts in javascript (ie, you want to setup a call system for a business).
Time to get a better computer.
I believe it will have a smallish effect on Chrome, like a drop in use of a few percentage points, in particular among web browser gamers. HTML5 is no where near Flash in gaming. There may also be a chilling effect slowing or stopping adoption. Most people have more than one browser installed (I have four), and switching primary browsers can come down to one or a few nitpicking things.
my 2 cents -- mongo DB gives you all the downsides of a NoSQL database, with zero real benefits. It's just a basic document store. There are lots of other specialized NoSQL databases out there that are optimized and built with specific purposes in mind, that would be far better. Relational databases are still king in my opinion for storing your data in most cases. If you need some hyper-tuned specific stuff, then start looking at some NoSQL stuff to start augmenting your existing RDB store. I highly recommend using [sequelize](http://docs.sequelizejs.com/en/v3/) with postgres (or any other RDB dialect it supports). It's not perfect, and sometimes its a bit difficult to get it to what you want, but it's better than nothing and might have you completely covered in most basic CRUD use cases. I've used v3 quite a bit, but if you are starting a new project check out the v4 branch that I believe is supporting ES6 classes now.
http://codepen.io/anon/pen/dXEALX https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval
Done!
Why use jest?? It's slow as hell.
Uh oh, I think we're in a recursive loop...
It is good to point out that it can lead to issues, but on the flipside we have removed babel from a few Node applications after upgrading to Node 6 (which has better ES6 support) without issue
And how big is the PC-based Flash gaming market?
Call it touchform.
i'll keep using safari until chrome stops destroying my battery
my apologies i will post it there thank you! 
I am simply measuring the SVG output image on my screen and expecting it to be in exact dimensions. Apparently that needs calibration. So, if I get the output as DXF and use it for laser cutting or CNC, do I still need to do some callibrations or anything?
it's cool it's been resolved on stackoverflow.
I didn't want anyone to write my code for me so I didn't post any
The form is problematic for me too, using safari on iPhone 6 running iOS 9.3. Each question was covered by the header and trying to scroll up to read them results in the form automatically scrolling backwards to the previous question. After this happening for the first 4 questions in a row I quit. 
Survey author here. Earlier versions of the survey did have both ("what have you used"/"what are you using now") but I had a lot of reports of the survey being too long so I had to cut out some of the possible answers. My thinking was that the most interesting bit of data would be knowing what people used, and enjoyed using; rather than just knowing what's popular right now. In other words I'm sure a lot of people are still using, say, Angular, but would they use it again on new projects? That's what I wanted to capture. If I do this again I might develop a custom survey UI that gives me more granularity without making the survey even longer. 
No Visual Studio Code option as an editor? 
another problem is general lack of awareness, I mean server side rendering is ok, but there are a lot of ways to do SSO that are not nearly as intrusive (i.e. write your own robot that drives the browser to create the snapshot, and serve up the static version when the caller is a robot), so having to muck up your entire development toolchain and mentality is completely unnecessary. I mean progressive rendering is the new buzzword, but it is just another hack that inverts the whole development cycle. So you will get answers like it is a "must have" from people who don't know any better, and it really isn't. SSO is a must have, reasonable page loads are a must have, lots of ways to go about that with varying degrees of intrusiveness.
I don't really care how big it is relative to HTML games. I'm more interested in knowing how big it is, period. You can't tell how much Chrome stands to lose if you're only talking relative numbers rather than absolute.
Looks very nice, demo viewport leaks from edges of the screen Edit, on a one plus two device
"quick" 
SQL Server
which do I prefer? append-only content-addressable databases. which one is easiest to learn and use? leveldb
Don't be pedantic, you know what he meant. Not that I like MySQL at all but it has proven itself over time. 
There is no contest: Visual Studio Code is incredible. For a free IDE, it is absolutely incredible what Microsoft have done. I am a Webstorm user, but find myself sometimes just opening VSCode because it is fast. I am considering not even renewing my Webstorm subscription and just switching to VSCode, it keeps on getting better with every release and it is updated frequently.
If you are trying to read raw keypresses from the command-line, then you should look into the built-in Node [readline](https://nodejs.org/api/readline.html) module. It has a special raw mode for doing this: var readline = require('readline'); readline.emitKeypressEvents(process.stdin); process.stdin.setRawMode(true); process.stdin.on('keypress', function (ch, key) { console.log(key); }); However, note that doing this prevents Ctrl-C (SIGINT) from working normally, so you'll have to catch that (`key &amp;&amp; key.ctrl &amp;&amp; key.name == 'c'`) and then exit yourself.
Do you mean like this: { name: String } ...? I agree that the strings are no good.
Let's face it, if you want to work in Corporate America, you are going to be using SQL Server. Virtually every third party piece of software your company uses is written to SQL Server. Open Source is largely relegated to Open Source applications, and even many of those target SQL Server because the devs know they have to target it to get a foot in the door in your typical F500 business. 
He can't due to his contract. That tool is property of the startup, sorry. 
Why does it need to be SVG? Could you simply do all css numbers with webkit blur?
Thanks. Maybe roulette elements could be replaced with normal text node after animation ends.
Does this db persist even in the session gets killed. With refreshing for instance. If it does could you link how you approached this?
I try to keep myself pretty informed on the js world and was quite surprised I never heard about half the stuff asked in the survey.
come on, we are used to grand promises in the js world ;)
Haha. Thanks for the heads up. Cool, I haven't seen those videos yet so I'll give them a go.
Thanks! Will fix it. I am using it in react project with ease but maybe exporting such component is a good idea too.
Hi, thanks for sharing. You should however think about another name as Odoo is already taken by a well known OpenSource ERP project.
FYI the `arguments` example throws a ReferenceError, because if you run the attached ES5 code it doesn't have a function scope. Babel prints {"0": {}}, because it ran in an IIFE like example below. (function () { "use strict"; var _arguments = arguments; var global = 0 || window; global.arguments = 2; var f = function f() { return _arguments; }; console.log(f()); }({})) If you put the original example into an IIFE it will print different values as well (function() { const global = 0 || window; global.arguments = 2; const f = () =&gt; arguments; console.log(f()); // will print [1,2,3] not 2 }(1,2,3))
Paid, is the reactforbeginners.com course of @wesbos, free, I'd like to find one.
&gt; The State Of JavaScript Unless you are Node.js developer, then you are responding to meaningless questions about front-end.
i just chose “won’t use it again” for things i don’t like – i interpreted it the questions as prefixed with “in an optimal world where we all are free to choose our tools”
Yeah, name will be changed. Next time i should use neural network repository name genrator .
I'll give you a tip about udemy: sign up and then search for react courses, go over the courses - enter each one and look at the description but don't buy it. wait 1-2 days and you'll get 20% discount for that courses, look inside again but don't buy. wait 1-2 more days and you'll get 50% off. this is the maximum for new buyers, after i bought some courses using this technique i received up to 90% 
Some sort of SQL database. Maybe MariaDB because it fits my needs and I know my way around.
Glad you like it!
Hm, yeah you are right.
What are you guys using for live transcription? Any details on accuracy?
That is really cool. I'd recommend a way to stop the animations, because it can feel a bit busy.
[React for Beginners](https://reactforbeginners.com/) by Wes Bos is highly praised, but according to his Twitter, he's in the process of updating it to the latest best practices. You might either ping him on Twitter or through email and ask him when he plans to release it and if the current one will do for now.
both payed and one free: https://egghead.io/courses, this coupled with this book https://www.fullstackreact.com/ have made wonders to help me understand react. And even if it feels a little obvious , the official documentation: https://facebook.github.io/react/docs/getting-started.html. They have in-depth guides and they make a really good introduction to all the parts that make react.
Yep. that was a pretty good one, though it felt rather slow.
I would really love if this project was compatible with Google Cloud Functions. Your setup is really close as it is right now: https://cloud.google.com/functions/docs/writing/http I'd love sort of an open source alternative to google cloud functions for testing, development, exit strategy, etc.
Reading the framework's documentation is often worth it, especially in the long run. So for free, I'd say: https://facebook.github.io/react/docs/getting-started.html
Good point, I will make two versions, one without animations since most developers don't find CSS animations to be impressive. And then the animated version for non technical people. Anyways thanks for the heads up.
I realized that shortly after publishing. Thanks for the comment. I might update that section later.
Actually I just saw CodeAcademy has a "preview". Their Angular lesson is great so I could see them doing well with React too.
Last time I checked, Spotify had built-in lyrics,and they aren't Niantic to remove good features.
Is this in... Chinese? Sorry, I'm not familiar with the character sets!
A 9kb gift!
http://stackoverflow.com/questions/39111392/creating-n-number-of-buttons-or-variable-number-of-buttons-in-javascript/39111538?noredirect=1#comment65570526_39111538
Spotify did remove the lyrics functionality a few months back tho
Leave the comments, look at the code
Yes this mediocre system is used by Facebook amongst others because its so terrible. https://www.facebook.com/MySQLatFacebook/
Wait what. Wtf o_o
Objects are mutable. var first = {hello: "hello"}; var second = first; second.hello = "mutable"; alert(first.hello); ///outputs mutable It's not being passed as a reference at all. It's literally passing the object. Second, I think you have multiple issues in your reverselist. So I'm not even sure what you are trying to do. Third, you have a higher order function at your disposal. '.reverse()' **EDIT** I always get these mixed up. Yes objects are passed by reference, but the original object is mutable, and the variables point to the same object. I apologize.
just start building something, preferably something you could easily build in RoR, read and watch some tutorials about the things you cant quite figure out on your own, but hands down, there is no better way to learn a stack than to build something with it.
Sure.
Yes, packages won't be tree-shaken until they are converted to es2015 module syntax If you find something that increases the output by a big amount i would report it to the Webpack team
wow, so javaphobic that a slow build and complete rewrite would be preferable. Sad really.
maybe you can give RollUp a try (for tree-shaking): https://code.lengstorf.com/learn-rollup-js/
I think you misspelled Oracle ;-) Maybe it's a regional thing, but where I live all of the Fortune 500 companies I've done business with are using Oracle. Though recently I've noticed a move toward PostgreSQL, at least at the department level within the larger company. I'm wondering if younger employees, who are possibly more comfortable with open source software, are starting to introduce it into large organizations.
Thanks! Do you recommend any hard-copy books as well? Sorry for late reply, had a crazy week.
It's okay. I had one hardcopy book and that was the definitive guide. I think it was overkill and didn't help me learn much at all. "Javascript The Good Parts" might be better. You also have to remember that Javascript has went through about 5 major transformation phases, so something as simple as function foo() { alert('Hello world') } var hello = function() { alert('Hello world') } hello(); foo(); ///these do the same thing, but they work a lot differently on the back-end can be quite daunting at first. It's like learning a set of rules that work, but then later finding exceptions to those rules because of a future implementation of syntax or even an older implementation. Heck here are 3 more ways to alert hello world. (function() { alert("Hello World"); }(); let hello2 = function() { alert("Hello World"); } hello3(); const hello2 = function() { alert("Hello World"); } hello3(); Good Luck! 
There's a new loaderOptions plugin that you need to use in production builds. It caught me off guard for a day or two as well.
Rollup may suffer a similar problem. The reason that es6 modules are required in order to get tree shaking is due to the fact that `import` `export` offers static modules. With commonJS, you can conditionally `require` and `module.export` items, so a build tool couldn't say for certain whether a package was really needed. For (a contrived) example, imagine that you only imported a certain file if the day of the week was Tuesday: let message = require('./message'); if (dayOfTheWeek === 'Tuesday') { message = require('./tuesdayMessage'); } console.log(message); The bundler would have no idea whether or not to bundle `tuesdayMessage`. But because es6 imports are static (and hoisted), there aren't any runtime surprises so the tree shaker knows what to include.
Yup. Take a look at analytics.gov which is built with a library called d3.js
"Wow so Javascript phobic would write a whole new compiler for adding typing to the language." I think this was done in the jest of irony.
Poor contract.. Cant you talk with your boss about that or something? Making something open source isnt a stupid idea at all, he could get support for it and all that and that would also help the start up, when the programm he uses there runs better.
rayshin qucikly changed my code... i am sorry for reason that i changed my pen after i posted question.... yes, i noticed problem with last element.. thanks kevin
not really with same set of features but https://bevacqua.github.io/dragula/ is a must for drag and drop.
Looks like they just compiled it with GWT. It's not a rewrite.
Missing `this.firstNode = node` after the loop?
its easy if they have an api, if not dunno.
&gt; that all modern browsers support it For development, Chrome &amp; Firefox are the best; and they got ES6 almost complete for some time. Repeating myself again: Once the time has come to deploy for the general public, just use Babel. There's absolutely no excuse to not jump right in ES6 right now; especially when we already know OOP! 
Awesome!
Since the claim is that the API is "really simple and straightforward" I'll ask: What does the "default" method do? Does this mean it starts at the "default", which is 0, then goes to the number you specify? Or is it the default animation and 0 is always the default number to start at. 
Could I ask what you're looking for? I've used dragula a bunch, as /u/kapouer suggested, but I found that beyond simple things, I had to tear it apart pretty well and ended up rewriting some good chunks of it. It's a little bit of a mess now :S Are you looking for something simple, grid-layout, or something with granular control and several events that you can tie into?
This could be confusing. Default is the side effect of umd exporting format in webpack (yoe can use it with commonjs, es6 and global env). To clean that I move from webpack to rollup and babel build process.
For smaller projects it runs faster and doesn’t introduce a Java dependency.
It's not about being Java-phobic. It's about reducing dependencies. If I can onboard a new dev and all they have to install is Node, and they don't need Python/Java/Ruby/etc. that is a win for onboarding. Particularly for onboarding a junior developer. And while a senior dev probably already has all 4 of those plus other languages, SKDs, etc. installed, most of the things you can do to simplify your app and process is a win.
Update - I wasn't able to muster any way to follow suggestions, so I hacked together something that's admittedly over engineered and shit. But I do really appreciate the two that provided suggestions.
Or you know... read the redux FAQ and it basically tells you this: http://redux.js.org/docs/FAQ.html#react-multiple-components
I don't know that all the bugs are a win though, a layer of gwt (which must be only able to handle file piping), vs sudo apt-get install default-jdk I mean, this just seems over the top, compared to all the dev hoops already in place for JS. Can't JS build tools determine platform and suggest tools to install as needed?
I like it!
He considers it to be too Object-Oriented. He's all-in on Reactive-style programming, which is why he wrote Cycle.js (a JS framework buitl around RxJS-type dataflow).
I think you underestimate the quality of the GWT compilation. It's a very mature piece of software. 
:/ I've used GWT, it was meant for a browser, not a filesystem/app (because we have stuff like java for that!) http://www.gwtproject.org/javadoc/latest/index.html
GWT existed long before Node, but it does the job just fine. Consider yourself brought up to speed. 
Actually, you are right. Hell, my own company has at least one Oracle database server. 8 or 9 SQL Servers, but we do have Oracle too.
You are using the word "speed" ironically perhaps? write something in java, with somewhat intensive file IO, port it to node, watch it break, patch furiously, and run slowly, because java bad? (phobia) And somehow this is a "win"? Nope, it is still a phobia (aka "win") to even consider it. Heck Node is just java or any other language phobia with massive wasted efforts behind it.
Your test cases are pretty incomplete since you're only testing good expressions some of the most interesting tests come from parsing bad expressions and validating the correct error is raised. I haven't looked at your code but implicit multiplication can have interesting effects with operator precedence such that in a parser I wrote it needed to have a different precedence than normal multiplication. If you pair implicit multiplication with a circumfix operator like `|•|` for absolute values you also end up with ambiguous expressions like `|•|•|•|`: Is it `abs(• * abs(•) * •)` or is it `abs(•) * • * abs(•)`? Just a note since you aren't afflicted with that today. Your notation of `sincos3` meaning `sin(cos(3))` paired with the ability to add new functions is, though. What if I add two functions `sinc` and `os`? Which meaning do you take?
just had to figure out why ng wasn't working, ran new, waited for 10 frigging minutes, 53451 FILES!!! got an app that displays "app works!" though (after taking several seconds to load)... why would you wish more npm on anyone?!? Whatever you are encouraging/enabling, it is wrong.
Surely in this example, only the V8 engine that's used in the car module should get built into the production code bundle if tree shaking was working correctly? [Screenshot](http://i.imgur.com/OWEgmKD.jpg)
Hi /u/josh_carterpdx, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `brightwork.io`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [blog.brightwork.io](/search?q=%28and+site%3A%27blog.brightwork.io%27+author%3A%27josh_carterpdx%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|5|31% [brightwork.io](/search?q=%28and+site%3A%27brightwork.io%27+author%3A%27josh_carterpdx%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|5|31% [signup.brightwork.io](/search?q=%28and+site%3A%27signup.brightwork.io%27+author%3A%27josh_carterpdx%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|5|31% [github.com](/search?q=%28and+site%3A%27github.com%27+author%3A%27josh_carterpdx%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|1|6%
If I understand correctly, this package will compile JavaScript to JavaScript where the main benefits would be eliminating dead code and making JS applications more efficient. If that's the case, then how does this differ from module bundlers like Rollup and Webpack 2.0 that are incorporating features like tree-shaking? Genuinely interested to learn more!
What's the "best practice" way to solve this issue currently? I like using ES6 classes for React components but as the author says, manually binding each function is annoying.
Check out: https://github.com/keen/dashboards and https://github.com/keen/keen-dataviz.js Their examples use their service but it should be easy enough to use whatever data. Otherwise there are lots of services that let you plug whatever data easily into them to create dashboards such as https://www.geckoboard.com/
You are right, it is mentioned in the Known issues section of the readme. It also points to the 2 tickets where discussion is going on about it.
Can you please elaborate? How do you see this in the Firefox console?
&gt; It will eliminate dead code not used by other modules if they have ES2015 module format. 
I'd suggest trying this outwith the Notepad++ console for just now. Launch a standalone bash prompt or command line instance and launch Node there. That will help determine if it's N++ getting in the way or not and might give you some error messages if there's something actually wrong with the Node installation. 
The architecture you're describing focuses on having a separate backend and frontend. While this is a great structure for a lot of applications, it is not the only way to do things. One alternative that would fit your project goal is to just render the pages of the website server-side, from Django. This way, you can focus on learning just one stack instead of two. I looked around the Django website a bit and I see it can even generate admin interfaces for you - this might be a good place to start: https://docs.djangoproject.com/en/1.10/intro/tutorial02/ 
Cool, I like Closure. I think this is a win for open source developers who also prefer Closure but ship their projects with something else for compatibility/ease of use. Aint nobody want to make a JS library depend on Java if they can help it.
I'm curious to compare how small of a bundle closure makes vs webpack + uglify. I imagine I'll be running some tests to-that-end in the next few months. From what I've heard, closure is also pretty aggressive with symbol renaming. If you run your whole app through closure, it can replace `doSomethingWithTheseParameters(parameterA, andThenParameterB)` with `a(b,c)`. Since every call site is run through closure, it can trust that every single instance of `doSomethingWithTheseParameters` has been replaced with `a`, obfuscating and minifying the codebase. Closure also enforces JSDoc types, throwing errors if a function is called with incompatible parameters.
Answering myself after a quick google... https://www.peterbe.com/plog/advanced-closure-compiler-vs-uglifyjs2 The comments are interesting...
&gt; Moin watches your service directory and reloads your Module when something was changed. So if I started SQL transaction it'll get nuked due to process restart? Or will callback for some query get changed at random time? What if, when callback is executing, "module is reloaded"?
The only things that are getting canceled automatically are timers(setTimeout, setImmediate, setInterval). For other things that could still be running(like an open http server) this function can be used: moin.registerUnloadHandler(()=&gt;{server.close()}); A change in one service only unloads this specific service. Other services stay untouched and keep running without downtime.
Have you tried [this](http://vanilla-js.com/)?
Wat ain't no framework I ever heard of, do you write frontend in wat? 
I am asking what "module reload" is. From what you say, it appears that it is process restart, with some cleanup functions. Some of them are registered manually, some are automatic. I don't really see how this is better than manual `restart node-app`. Let's say I have a following flow: 1. `runSql('begin; delete from jobs limit 1 returning *');`; 2. `process(job, callback)`; 3. `callback` runs, which is `err =&gt; runSql(err ? 'rollback' : 'commit');`. Let's say I pushed a trivial change adding forgotten semicolon. Now my "module is reloaded" between steps 2 and 3. What happens? (I assume that process is restarted, DB connection drops, SQL transaction is rolled back.)
The callback would be called as it should be. The reloading just unbinds the service from the system. So every event which is listened on by your service is then "delivered" to the newly loaded service. But every callback still bound after unloading is still processed. As a service developer you have to ensure that you stop every i/o activity when the service is unloaded. I just added the ability to return a Promise in *moin.registerUnloadHandler*. The *service-loader* waits for the promise to be resolved before the service can be loaded again. In your case you could hold the reload process until all of your transactions have been processed.
What a dumbass comparison. This is why you have shitty tools and shitty processes.
Pick a stance already. You keep meandering between claiming that you cannot compare what FB, Google, Twitter and other firms using MySQL for and then claim it's mediocre and crap. I think you frankly have no idea what you are talking about therefore. Each Relation database has inherent advantages and disadvantages, the question asked which was the easiest to learn and understand.
X-Post referenced from /r/webdev by /u/feketegy [If you use Slack, come join to this web development channel](https://www.reddit.com/r/webdev/comments/4zhpu6/if_you_use_slack_come_join_to_this_web/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
So the idea here is that your code: - unbinds instances, waits for them to perform cleanup; - during downtime, it buffers request to the service; - restarts service after cleanup is done, sends it all the buffered requests. 
&gt; It is always off by .01 - .03 no matter what the times are. That is expected, since you remove precision by discarding 1 digit from milliseconds (`milliseconds / 10 | 0`) for individual times. However, your total time includes those discarded digits. To resolve, try one of the following: - *easiest* would be to not truncate milliseconds, or truncate it inside `times` array instead of formatting function; - *sligtly more effort* is to sum up formatted times instead (so total is `sum(truncated)` instead of `truncate(sum(originals))`; - *if you like pulling you hair out*, try rounding your centiseconds correctly.
I do not know whether our app requires such set of features. Is there any how I can start locally and then work my up so that I can convince the boss to purchase the service?
Events are not buffered, but it would be possible to write a module, which handles the re-sending of events until a handler is present which can process the request. The emitter is informed of the handlers which have processed the event as well as their return values and errors.
Dude nobody gives a shit. Also, it was one click and a check with the eyeballs. Way less effort than you've put into making a fool of yourself in front of me
Sooo... Is this online ide like cloud9? Or webpackbin?
Events should be done using a scale able queue like kafka. Bouncing all my services because I added a completely non-related service is unexceptable
&gt;Bouncing all my services because I added a completely non-related service is unexceptable What do you mean with that? Adding or even deleting a service does not stop the other services or their communication between each other. For the event system i chose a self written approach because i wanted events to be filtered by a Key-Value filter rule which can also check for dynamic values(e.g. *x&gt;0*). A robust messaging queue makes sense when you connect many Moin-instances with each other. The current communication between nodes is done with socket.io, but it is not a big deal to write a module which handles the interchanging over another protocol(like kafka, rabbitmq, redis). 
This is a recording of a webinar I gave yesterday about ES6 &amp; Typescript (From chapter 2 of my Upcoming Angular2 Course + E-Book see https://www.kickstarter.com/projects/366973035/angular2-from-zero-to-hero-online-course-and-ebook/description) You can find all the code written in the video in this gist: https://gist.github.com/jawache/f4e54b8540ed2674d34629047959a6ab
Any users who transitioned from React to Vue.js. What is your takeaway?
&gt; easiest to learn and understand. And implied not broken by default. MySQL does truncate silently, does magic conversions, has a ton of issues that will hurt you down the line. Now OP is going to invest time in learning something that is known to be shitty and feel validated because some people don't keep up. It is like that guy somewhere in this thread that started with Mongo because it was recommended and painfully had to find out it is shit as well.
Easy to miss link to blank start: http://alpha.trycarbide.com/new
So it's anaconda for JS basically?
It's another framework
We use it. Love it. Really easy to pick up, even for newer devs. It works best for those that don't prefer to write in JSX (though Vue 2.x) is slated to support it. It's also got a big backing in China with Alibaba adopting it.
Author here. Thanks to OP for posting this, but could a mod fix the title maybe?
"There are only two kinds of languages: the ones people complain about and the ones nobody uses" --- I'd say that you should go for JS. Most of the negative aspects of it has been fixed with ES6 and the language will just become better and better. If there's something you feel lacking about it (ex. type safety), you can just use TypeScript or some other superset and compile it down to plain-old JS. There's really no other alterative for the web until WebAssembly gets around, and that's in long time. 
Doesn't publishing preliminary data invalidate future responses?
JavaScript is the scripting language that web browsers natively understand. Everything else requires either some server-side rendering magic (which will output JavaScript), or weird transpiling nonsense. In my experience, most of the JavaScript doomsayers out there are either obsessed with always using the newest, shiniest toys OR they are giant fanboys of [SOME OTHER LANGUAGE] and want to validate not knowing JavaScript very well. JavaScript has some major flaws, but so does every other language! If you get good at JS I think you'll find it's incredibly powerful, fun to develop, and somewhat future-proof. For more encouragement, I would recommend Crockford's "JavaScript: the Good Parts"!
&gt;promise in your map function for this to work correctly I think you are right, but for some reasons, it works with Q. (I means Q.all resolves without having a return in the map, but having a return is a good practice for promises anyway). &gt;then you should use something like bluebird's Promise.reflect (settle all) I'll have a look at this method ! Thank you 
To be fair, most of the JavaScript landscape nowadays requires transpiling. 
&gt; It works best for those that don't prefer to write in JSX Is that all? I really like JSX so I guess it's not for me?
How important is it to always return a promise ? What happen if you don't ? It just never resolves ? Its not always necessary. Ask yourself 2 questions: 1) Is my function async? 2) If it is async: Do I want my async function to complete before the next `then` block executes? If you answer yes to both questions, return a promise. What happened if this is not returning a promise ? If it's just returning a value ? The next `then` block will run with the returned value as its parameter.
Let me get this straight. You say someone was being negative? On the INTERNET?! 1. Most popular language 2. Most pervasive language 3. Only language yet that is both "write once, run anywhere" and is already installed 4. Popularizer of functional programming 5. Relatively small, feasible to master all of it
JS is a great language to program in for a couple of reasons: * **No build process required.** You just run the program and it just runs. If you want to introduce a build process for additional tooling you can, but this absolutely isn't required. Personally, I don't like build steps because that is seconds/minutes/hours of my life that is wasted. * **OOP is optional.** You are not required to write the extra boilerplate to force inheritance and other OOP concepts. This means you are free to avoid things like *new*, *this*, *Object.create*, *bind*, *apply*, *call*. As somebody new to JavaScript I **strongly** suggest you avoid inheritance so that you learn to embrace the language for what it is. After several months of writing applications in this language then jump into inheritance if you want to. * **JavaScript runs almost anywhere.** It runs natively in the browser. It runs natively on the Windows command line (kind of) with WSH. It runs on the command line natively everywhere if Node.js is install. You can also write native desktop applications in JavaScript provided a shell like Electron or NW.js. * **JavaScript is fast.** Provided a single CPU and single core JavaScript is just as fast as Java. * **JavaScript has native lambda scope.** This means you have the power of closure all the time. It is always on and not hidden behind any convention. What awful things were you hearing?
What do you mean by this? Sure, transpiling can improve upon JS, but when/where is it required?
Today Javascript is the lingua franca (ie. common tongue) of the programming world. In the past C or Java held that crown, but now JS is the very clear winner. As the last Stack Overflow dev survey concluded (http://stackoverflow.com/research/developer-survey-2016): &gt;JavaScript is the most commonly used programming language on earth. Even Back-End developers are more likely to use it than any other language. JS got 85.3%. Compare that to the next most popular choice, C#, which got 37.3%. Checkout Github and see the same thing (https://github.com/blog/2047-language-trends-on-github). Or look at RedMonk's extrapolation of data from both sites: same thing (http://redmonk.com/sogrady/2016/02/19/language-rankings-1-16/). There's two primary reasons for this, and both of them are why you should learn Javascript: A) it's the only language (modulo JS-layered languages like Dart or CoffeeScript) that you can use to program web pages with. Do you think you will ever want to make a web page with client-side logic sometime in your career? Then you want to learn Javascript. B) The language itself, as well as it's community and ecosystem, is awesome. This post is long enough without getting in to the details, but as a programmer who spent five years on the back-end doing Java, Ruby, and Python, and then switched to Javascript for the past five years, I would never go back. Java (being a static language) has better tooling, so your IDE can refactor smarter, and Python still has several features I wish JS had, like meaningful white-space. But overall I consider Javascript a better language, and a more enjoyable one to program in, than any of those three. I highly doubt you will regret learning Javascript. In fact, quite to the contrary, I'd give decent odds that once you do, you won't want to go back to your old language ;)
javascript is ok, its a programming language with its own quirks. some of them are harmless, others are like "WTF was THAT son of a bitch thinking?" "use strict" is your friend. i cannot emphasize HOW important this is. there are a gigantic amount of libraries, frameworks and collective wisdom available on the 'net to help.
Fair enough. I mostly use Typescript nowadays so your last point is a bit moot in that case. 
Flash is dead dead.
Ruby, Python (and probably a fair chunk more) come pre-installed on a good chunk of machines... At least as many as have a non-browser JS interpreter, I'd wager. 
Sometimes I read through stuff at [Rosetta Code](http://rosettacode.org/wiki/Rosetta_Code) especially when learning new languages.
After I started using Vue.js I met someone on Tinder.
You mean _[Adobe Animate CC](http://www.adobe.com/products/animate.html)_