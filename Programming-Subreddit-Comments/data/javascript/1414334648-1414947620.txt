Some statistics from the text: Keyword | times | ----------|------:| AtScript | 21 Dart | 11 ES5 | 10 ES6 | 9 JavaScript | 7 TypeScript | 6 Java | 2 Basic | 0 C/C++/C# | 0 Go | 0 Haskell | 0 Lisp | 0 Objective-C | 0 Pascal | 0 Perl | 0 PHP | 0 Python | 0 Ruby | 0 Rust | 0 Scheme | 0 Swift | 0 (Languages from TIOBE index + Go and Rust). Don't worry it's just Google's second attempt to ~~kill~~ modernize JavaScript with another Jabba clone.
Slightly offtopic, but let me kindly suggest that you formulate your job offer and the communication around it in a way that does not make it sound like you're excluding half of the world's population up front. I suppose it is not meant that way, but using 'he', 'him', 'his' sounds like you are specifically looking for a man for this position, which wouldn't make a lot of sense in my opinion. Fortunately it is very easy in english compared to some other languages to formulate in an inclusive way - just use 'they', 'them', 'their' instead. Afaik that is gramatically correct even by very strict measures. Thank you and good luck with your recruiting. On the topic, I agree with what most of the posters here said - confronting candidates with quiz questions will only help you find people who are good at solving quiz questions, with very little correlation to how they will perform under actual working conditions. Nothing beats actually working together to find out how someone fits in. One's motivation, willingness to learn and ability to cooperate with other people in the company is much more important for success than already existing programming knowledge, and harder to find out with automated quiz questions. 
As it happens, I wrote one for my current project. I'll put it in a Gist and share it sometime.
How do you even know the code you get is theirs? Seems pretty simple to grab nice code online somewhere and submit it. I find just talking to be works much better, have a technical discussion it's not hard to figure out if someone is full of shit or not, code samples don't prove anything. 
I think if you gave them the ToDo checklist test, and they went immediately to jQuery, you probably wouldn't want them as a JS developer. On the other hand if they went to ToDo MVC and copied one of the examples and finished in under a minute, you might.
Less off putting than white boarding IMHO
As someone looking for a job I would say the best tests are the ones that give you a project to do (normally a simple game or application). You say like choose 1/2 of these options, and then you have 1/2 days to do it.
Typescript's problem is that it isn't a gradual solution. Here's what I would like to see: //this function does something Stupid with a hard-coded string function blah(func, somethingElse) { "use strict"; "type (string, number --&gt; string), [number] --&gt; [string]"; "vtype needNumType is integer"; var needNumType; return somethingElse.map(func.bind(this, "blah")); } It keeps compatibility with older browsers and allows it to be handled in different ways (eg. throw error or just fallback)
Agree on both your points: I normally try to be gender neutral, but sometimes it slips. Secondly, I'm mostly contrary to math tests, but for this specific position I get a lot of people saying they know js only to discover they know jquery. So having some way of quickly filtering people would be great, hence this post.
I have tried .NET MVC twice and didn't care for it either time. I really don't like any technology that requires Windows but at least mono works mostly now for doing .Net MVC stuff. You are doing yourself a disservice not checking out other options for your back end stack.
2 separate code problems is a good idea. It lets you look for patterns in their solutions which gives insight into coding style. Plus you can choose 2 varied problems to get a broader perspective of their current skill level. Keep in mind a good dev may not yet have the desired level of skill, but can get there very quickly.
Also, I try to hire through user groups -- they're a great place to find people who are passionate about coding and at least moderately social enough to work well on a team. 
My process: 1) obtain code sample. Judge experience based on this. 2) Only ask two code questions during the interview, neither is really about them solving code problems. One of them is extremely basic, to make sure that their code sample was theirs. The other code question is very difficult, and the call isn't if they can solve it or not (they usually can't) it is to see how they handle pressure. Edit: Good interview questions are rarely what they seem on face value. It's more about the question behind the question.
Sit down and pair program with them. You'll learn about what they catch, how their process works, and how they'd work with you and the team. It's definitely the way to go interview wise in my opinions.
I think we can pretty much agree that sometimes js can be a double-edged sword. 
that would make sense.
wouldn't that be very off putting during an interview? how would you expect it to work?
Cool, edit appreciated.
definitely true :) as to quiz questions, trick questions, or even pressure questions... I personally do terribly in those types of interviews, so I've learned to just say thanks and bye; it saves everyone time. 
I think the latter question is also a good way to see if they ask questions when they get stuck. Which is good because you dont want someone guessing business logic or other logic when they are building features introducing bugs, technical debt and unmaintainable code.
I'm not sure if you can say that ECMAScript is the same thing as JavaScript. There are other languages that implement the ECMAScript standard such as ActionScript. 
That's the same for me. So I don't really know where to stand in regards to the suggestion some made of using paired-programming as part of the interview process... 
ECMAScript, JScript, and JavaScript should work exactly the same and be the same language. ActionScript should be a superset of ECMAScript, so it's not the same thing as it would contain features that ECMAScript doesn't have. Correct me if I'm wrong, though. I wouldn't bet my life on these statements.
I don't know how it is where you are, but in Atlanta, there are a ton of unfilled tech and development jobs. Developers get their pick of the jobs. Some people don't code in their free time. Demanding code samples is a good way to get great developers to ignore you. If you want to test someone's skills, my recommendation is to have a technical pre-screen call with about 10 questions. Specific things relevant to your job. Some useful things in general. Whatever. If they pass this, bring them in for an interview. Have a conversation about topics. If you want to see their skills, have them write some simple code.
Like other people said, I don't think a test is the right way to go about it. More like a programming exercise. Come up with a short but unique spec that involves the technologies and process you use (for front-end developer, maybe give them a PSD if that is part of it), make sure the programmers on your team can code it within a day or two, give the candidate a day or two to code it. If you want someone who knows certain programming techniques or can deploy code or use git, make that part of the spec for the exercise. You could make it a shorter, simpler spec aimed at a few hours, if you want a wider pool of candidates, since some people don't have time to spend a whole day applying for a job. Although you can get into trouble if you make it too simple. The rest of the stuff you add to the selection process is probably gravy.
console.log('%c Isn\'t this a pleasant surprise.', 'background: #F55641; color: #fff; font: 20px/50px arial; padding: 10px 20px');console.log('%c ', 'font-size: 100px; background: url(http://cdn.nyanit.com/nyan2.gif)'); In case you're too lazy to type it all out.
whiteboard interviews are only as effective as the person giving them. It's less about how much you know, and more about how well you can communicate your thought process for solving problems. The informal discussion of topics, code samples, and take home exercise should go along with a whiteboard interview as I think the two formats test for different skill sets. I think a lot of people giving whiteboard interviews don't know how to give them, or what they should really be looking for with them. pair coding or code critique will fill the same role as a whiteboard interview IMHO, but I think the effectiveness of any of those interview styles relies heavily on the person giving the interview and not the person receiving it.
Using the prototype way we are creating a a whole inheritance chain (as /u/kogsworth pointed out), we also have our root abc() function that can do things. With the second way, you are just accessing functions in an object, so while its handy to create a self contained object that way, you do lose the benefit of building a whole prototype chain.
I've been working for about nine years and “whiteboarding” during an interview is tough for me. I don't write code on a whiteboard, I do it on a computer. I'll test ideas out on a console or JSBin. I use a whiteboard to list tasks I need to accomplish. Asking a candidate to do any coding on a whiteboard to me seems like a foolish test. So avoid it because it doesn't reflect any real world scenario. One of the best tests I had was a take home test. I figured out that the problem could only be solved by implementing a K-d tree. I'm not any good with algorithms so I found some examples of implementing a K-d tree in Java and Python. I told the hiring manager that the solution involved a K-d tree but that I wasn't familiar enough with creating the data structure on my own and had to rely on some open source solutions. He responded that the test was to see if I would rely on existing code to solve the problem instead of trying to write all the code from scratch. He didn't want someone who would write everything if there was already a reliable solution available. So I was hired. 
Is ActionScript still used today? What for, mainly?
This is a really nice, very comprehensive article. I just want to point out one thing: &gt; Self was designed for performance. It took Smalltalk, and removed classes to make it faster. This is the opposite of the truth. Self was actually much *harder* to optimize. They removed classes because they were trying to make the simplest, "purest" object-oriented language they could come up with. Self is a simpler model in many ways than Smalltalk. However, the result is that objects are very fluid and unstructured. That confounded many of the optimizations that common at the time which presumed classes, a fairly fixed set of fields in each object, and a relatively unchanging inheritance hierarchy. Self discards all of those. To make Self faster, a number of novel optimization techniques were created. Those techniques eventually made their way to JS when Lars Bak and company (who also worked on Self!) wrote V8 and then the other JS implementations followed suit.
&gt;lexical clojure oh god
Flash 9+. That's all it was ever used for as far as I know.
There is a difference between knowing JavaScript and knowing the DOM. I'm pretty good with JS myself, but I'm mediocre with things like CSS selectors and DOM manipulation. That doesn't mean I can't do it, but rather I have to look things up from time to time - they don't stay in memory. I think the best way to see if someone knows JS is to take a code kata that has nothing to do with the DOM and sit at a computer with them. One example is this: http://content.codersdojo.org/code-kata-catalogue/bowling-game/
Pair programming is my favorite kind of interview, personally, because it lets me know how much my potential coworker cares about software craftsmanship.
Yea, Flash is done. But not because AS3 or the tools are bad.
Thanks! That was from Crockford's talk, have to read more about it I guess :-)
good point, thank you
Seems fair enough. I haven't really done any analysis myself mainly because the react and flux make it easier for me to form a unidirectional mental model of my app. Personally, I find that *very* useful and natural. Since I am the only dev (startup) I just went with it. Let me try and get some numbers in asap. 
Give the candidate a piece of actual functionality to work on. Have him work at your office if possible. This should help you judge both the candidate's skills as well as how the candidate is around your current team. 
An interview isn't a one way street, you're interviewing one another. This gives both of you a chance to see how your workflow is, what you're thinking, what's important in the code you're writing, etc. That being said, you don't go "SURPRISE, we're pair programming!". You let them know ahead of time and that it's part of your interview process. Just sit down for a good bit and push some features out.
&gt; I find the way javascript works to be faster It's definitely faster to write the first time if the code has all been written by you. But as your code base gets larger and more folks are working on it, I think the speed fact do goes the other way. Strong typing allows for truly time-saving tools like property/method discovery and in-IDE documentation that I've found to be indispensable in a large code base with many maintainers.
Thanks people for your valuable comments... once again Thanks a lot. :-) hope a people like us will make the world a better place."Aaron" http://www.biography.com/news/aaron-swartz-internets-own-boy-interview
I love knockout, because it's small and does one thing, and one thing well (and predictably). Since it ONLY does databinding, you have to include some other frameworks for handling models/doing routing (I actually usually use vanilla javascript classes, and director.js), but for small projects, you don't always need the heaviness of other frameworks
Meteor does this by running the same code on the client and the server, so you get the speed of client side js with the security of server code. See: https://meteorhacks.com/introduction-to-latency-compensation.html
Okay, is there a specific function I need to use? 
Why ask about currying? It's not a feature of the language, and it is something that people can learn in just a few minutes. I don't see a reason to require that they know what it is. I suggest asking about closures. That is a very important concept in JavaScript and you probably want to make sure the candidate has a good grasp on it.
'He' is gender neutral. And even if it weren't, you're hardly limiting yourself to half the population. Considering over 80% of developers are men, it's hardly half.
I have a lot of respect for Crockford, but he has very strong opinions and reality on occasion gets bent a bit in their presence. 
This. I still miss the days of programming AS3. It was a fine and powerful language. Don't get me wrong, I don't miss Flash, just AS3. It seems like all the JS pre-compilers (TypeScript, etc) are just trying to reintroduce it's characteristics. Not sure why ES4 never made much waves outside of Adobe.
Never-mind I got it. Thanks for you help! End Result : &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;script&gt; var a = Math.floor((Math.random() * 100) + 1); var b = Math.floor((Math.random() * 100) + 1); var c = Math.floor((Math.random() * 100) + 1); d = (a+b+c) / 3; document.write(d) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 
Hahaha got it! Didn't know he had a reality distortion field like Steve Jobs :-)
Hahahah! :-)
&gt;I really don't like any technology that requires Windows That's changing very quickly. In fact, the ASP.NET vNext stuff is very similar to Node, runs on *nix environments and doesn't need Visual Studio. You can use any editor and they have command line tools to run. Hell you don't even need a build step anymore, that happens on initial run when in development mode. It's really a game changer. Not trying to say you should give it another shot, just saying the options in the MS world are getting better. All of ASP.NET MVC is open source on github and I'm just spreading the word.
TS is indeed very similar. Its type annotations just look like ES4/AS3. Dart's type stuff looks a bit different. However, it also comes with sane scoping (block scope, lexically scoped `this`).
yup, good point.
I think the best way to interview a candidate is to ask them to talk about how they built the project they are most passionate about. 
wasn't planning to do "whiteboarding" :) don't worry. And I'm not going to do math tests as well since I presume something more specific on the actual job could give me a better idea of how the person is used to work and analyse a problem. and you can make it a bit less boring or irrelevant to the actual interview.
Tabs and spaces, I had a dev give me a code sample with tabs and spaces mixed, so either he is using 2 different editors for a simple task, or he copied code from the internet :P Personally I have my IDE set up to convert all tabs to spaces on save :)
Yes, that's the main problem, "it's here to stay" and from time to time a new hack on top of it emerges to help developers building stuff instead of dealing with language oddities. I would prefer to fix it instead of building patches around it.
I'd recommend pushing the limits of their technical knowledge about the language. Start off easy, with scope, this, callbacks, prototypes, etc., then work your way up to asking them stuff along the lines of how closures are possible. Ask them to draw up a diagram of the stack frames, etc. See how much they ACTUALLY know. I usually keep digging until I find the extent of their knowledge. Then, for the practical section, I like giving out a take-home project, usually something related to the company's product.
You're right on the money. On the same topic, for technical pre-screen questions over the phone I generally avoid trivia questions (questions they can google), and ask open ended questions instead. Can they explain what they would do if x happened or what they would do it they came across y? This lets me know their thought process and how well they can communicate. 
...I need to start checking the comments for stuff like this first.
I totally agree, however I am waiting to see if this is really the new path that MS will stick to. This is not the first time they have tried to be more open only to abandon or change directions with the project. Well see what happens with the asp vnext stack in a year or so.
Ughhh. Sounds a lot like Cold Fusion. Just...so...terrible.
Log the pages? Why?
I've found that this stuff can improve with practice. That said, it's incredibly frustrating when they praise you and your technical skills, but you don't get the job anyways for stupid reasons.
well a scale won't hurt nor asking about eating habits if your looking for someone midweight. Heavyweights do tend to be a higher risk with insurance companies I'd assume. All jokes aside though, I have to go through these "tests" often in my line of work and let me tell you, I along with EVERY developer I know absolutely hates these pointless tests. Most developers juggle between a few different languages and frameworks and rely on documentation for the syntax differences. Knowing how to Program (or the logic flow of a program and paradigms to achieve a task) and knowing the syntax of a particular language 100% usually dont go hand in hand at the mid-level or junior-level positions. Instead of having the developer take a test I'd recommend that he/she send you samples of code that they've created. And just incase they just send over any old code they found online. Ask them to explain why they did something in that particular fashion. (e.g. why did you use a function here?, why did you instantiate this object there? how did you create an interface to object xyz?). Of course before you give anyone a "test" you yourself should be well versed in whatever you're going to have them test in. One of my biggest pet peeves is having a "manager" test me, and then not even know why I passed a test (only relying on the score card given by the website or the answer keys). tl;dr If you dont know javascript, dont send them a test. If you do have them send you sample code and you review it yourself. If that is their code, is that code you'd want to see in your production app?
Fantastic!
I don't know all of your requirements, but looking through your code it seems like you're attempting to reinvent the wheel a bit. Backbone + Require will do everything you need for client side, even in a multi-page setup. For example, you can set up your Backbone router to listen for specific routes and serve up the code necessary for that page. 
First off, most programming languages have similarities such as classes, functions, loops, if statements etc. What really changes is mainly the syntax and a few quirks here or there. Any good developer with access to the language documentation or a cheatsheet can figure out quickly what they need to do without spending hours googling. My point is, C# isn't that much different than Javascript ignoring the fact that one is serverside (C#) and the other primarily clientside (javascript, although nodejs is serverside as well). If you are looking to "code apps for google play" keep in mind that most experienced people will probably wont be too interested in "code[ing] together some crap like apps in their free time" It looks like you're target audience are probably at your level. Someone just starting. Though Starting out is when you should but the most emphasis in learning. Forming a team of 2-4 people will be very difficult because in my opinion no professional will waste time coding crap apps. If you have ideas for something fantastic then you should probably start out with an open source project (so others interested can contribute code) and throw it on github or similar sites. Just keep in mind, if you dont have faith in your products - other won't either - ESPECIALLY when working for free. Others can get a better sense of accomplishment by completing something on their own that they are proud of as opposed to some "crap app". Additionally, coding one app per month is a bit of a stretch. Though possible (if its literally a crap app) any decent app that wont get rejected from the google play store (or will get at least downloaded once) would or at least should take longer than a month. (Just properly planning the app should take no less than a month). tl;dr Good Luck, but dont hold your breath.
fyi, we're working on adding subtests to the table, so you'll be able to see what's implemented partially (e.g. things like arrow functions which are currently lacking proper `this` binding in Chrome, etc.)
&gt; I'm not sure if you can say that ECMAScript is the same thing as JavaScript. They are not the same thing. JavaScript in technical terms refers to precisely the version of ECMAScript that is implemented by the Mozilla foundation. ECMAScript is the standard, JavaScript is an implementation. Language being what it is, however, means that everyone just calls it Javascript anyway. Like how everyone calls tissues "Kleenex".
I love to see a candidate's code, but many developers that I have interviewed do not have github pages. What I do is send the candidate a simple task to complete: create a "TODO" list app from scratch with some basic but very clear requirements (add items to a list, check off as done). You may use any framework/library you like. Send the completed test back within 24 hours. This does a number of things for me: - lets me see the candidate's code (duh) - gives me an idea of how they think and keep things organized - shows me whether they're capable of creating things from the ground up - gives me something to talk to during the interview Once I review their submission I give a yes or no. If it's a yes, we bring them in for an in person interview. I ask some questions: - What did you think of the test? How hard was it? Were you able to showcase your abilities? - What did you use as a reference when coding this? Why does the code look so similar to TodoMVC? (I had a candidate deny that he lifted the code from there once. It's fine to use as a ref. Just don't lie to me.) - Explain to me your strategy and organization After those and some other follow up questions I put a laptop in front of them with their code and have them write some new feature(s). I ask "how hard will it be to do this? How long will it take? What do you need to watch out for?" Hearing devs think out loud gives me insight to how they think and how they will do on their own. MOST IMPORTANT: look for a dev that is smart. A smart candidate might know less things than another candidate, but I will always pick the smart candidate over the knowledgable one. No one knows everything they need to know for a given position. The smart ones will get there fastest.
Please stop doing "self = this" :)
The #1 thing you're missing is comments, or functions that express intent. Your code is a whole lot of "how it's done", and no "what we're doing". Including the latter makes it easier to tell when you're doing it wrong. The same applies to variable names: "correct" is not descriptive enough. Also, embedded HTML isn't an excuse to have a 320-character line of code. At the very least split it into multiple lines, concatenated with `+`. Others would tell you to use templates or a DOM constructor, which is a good idea, but just splitting it into multiple lines and adding HTML-like indentation will make that much lower priority.
I am certainly willing to consider your advice, most especially as it seems to be important to you. Would you be willing to elaborate as to why? *Edited to add*: My purpose it to provide the execution context of the outer function to any "inner" function defined within it, through a closure. The code you are complaining about is a nonsense example provided for illustration, so unless you have a strong justification for your request and something interesting to teach me, I will admit to a degree of annoyance.
**console.doge** console.__dogimg = "http://i.imgur.com/rYY0K8i.jpg"; console.__dogcss = "font-size:100px;line-height:100px;height:100px;width:100px;background-image:url('"+console.__dogimg+"');background-size:contain;background-repeat:no-repeat"; console.__dogcss2 = "font:14pt 'Comic Sans MS','Comic Sans';color:rgb"; console.__dogrnd = function() { return (Math.random()*256&lt;&lt;0); }; console.doge = function() { if(arguments.length &gt; 0) { for(var i = 0; i &lt; arguments.length; i++) { if(typeof arguments[i] === 'object') console.log(arguments[i]); else { console.log( "%c"+arguments[i].toString(), console.__dogcss2+"("+console.__dogrnd()+","+console.__dogrnd()+","+console.__dogrnd()+")" ); } } } else { console.log("%c ", console.__dogcss) } } function () { if(arguments.length &gt; 0) { for(var i = 0; i &lt; arguments.length; i++) { if(typeof arguments[i] === 'object') console.log(arguments[i]); else { console.log( "%c"+arguments[i].toString(), console.__dogcss2+"("+console.__dogrnd()+","+console.__dogrnd()+","+console.__dogrnd()+")" ); } } } else { console.log("%c ", console.__dogcss) } }
Our company really likes Knockout. One of the best things about KO is its very un-opinionated, and doesn't take over a project. If you want to use it for only one or two bits, you can. And if you want to use it for an entire app, you can. Also, you can teach the basics of it to a dev in literally 20 minutes or less. I've recently been prototyping an app with Durandal (framework built on KO, JQuery and RequireJS), and have been having a blast. Durandal v Angular seems to be a better comparison than Ang v KO, and there are heaps of articles out there comparing the two.
Separately, if you're struggling to debug, give this bookmarklet a try. It lets you select a piece of dom, and it'll spit out the binding context to console for debugging. Pretty nifty. It does (needlessly) rely on JQuery too, because I'm lazy and all of the projects I've needed it for have had JQuery. javascript:(function(){$("body").on("mousemove.getkocontext",%20function(event){if(window.highlightTarget){window.highlightTarget.css("box-shadow",window.highlightTargetOriginal);}window.highlightTarget%20=%20$(event.target);window.highlightTargetOriginal=window.highlightTarget.css("box-shadow");window.highlightTarget.css("box-shadow","0px%200px%200px%202px%20#BADA55");});$("body").on("click.getkocontext",function(event){$("body").off(".getkocontext");if(window.highlightTarget){window.highlightTarget.css('box-shadow',window.highlightTargetOriginal);window.koContext=ko.contextFor(window.highlightTarget[0]);delete%20window["hightlightTarget"];delete%20window["hightTargetOriginal"];console.log("KO%20Context:",window.koContext);}})}())
Depending on what sort of level of coding ability you are looking for, I once interviewed for a Junior positions and they asked me to write a script that would find the missing number in the following pattern and insert it in its correct location on the list '1, 4, 7, 13, 16' they also added that they should be able to change the patter and it still worked and it had to work with negative numbers as well.... maybe a problem like that could help? 
Is passing arguments into a callback advanced or overly clever for you? Currying comes up quite a bit in Javascript.
Code School does have a more advanced jQuery course that you could tackle. It's paywalled, but if you follow this link, you can get two days of full access for free. I was able to complete both the NodeJS and JavaScript best practices courses in two days time. https://www.codeschool.com/hall_passes/213f3fedb6b9/claim_shared As for how I learned jQuery and Ajax, I slowly added dynamism to an existing Rails app. But it would definitely be easier to try and build something on CodePen. You can import jQuery right into CodePen and build forms and other content there.
"Some people don't code in their free time. [snip] ..great developers.." Honestly? With a subject as both deep and wide as programming, you *cannot* be very good unless you have some passion for what you do, in which case you program because you love it, not to get payed. With all the things happening on the web these days, you'd be utterly and hopelessly outdated if you didn't spend some of your free time programming "just 'cause, I need to try this stuff out".
don't ask trivia questions about Javascript language syntax or standard library functions. Those questions are useless. All you'd be doing is testing whether someone is good at remembering details under pressure, which is not really part of the job. Ask questions about the development process. How do you tackle a new problem? What kind of design patterns do you use, and under what circumstances would you not use that pattern? How do you know your code meets the project requirements, i.e. how do you test it? etc. Those are important questions. Whether or not the dude can give you a good definition of currying or not is totally besides the point. 
in the browser... self === window, if someone is using self to reference the window object for whatever reason, within the scope of your function, self will not be what they think it is, therefore a potential area for bugs. Best to use _this/that/_self or use Function.prototype.bind/call/apply to eliminate the use of needing to cache "this" altogether 
Actually, first learn css selectors. Then just hit up the jquery site documentation.
Real answer is no, but you could make it very difficult. Simply minifying your code and wrapping all of it, including libraries, in (function(){ })(); would eliminate a lot of tampering. This would force Firebug haxors to use breakpoints.
What if they work exclusively with proprietary code for tools that are used internally, e.g. a bank? Just because you are in a situation where you can produce some code to show, not everyone can.
That's cool but if you have shadow DOM etc., why do you need or want Angular at all? Don't get me wrong, I have used Angular in several projects, and its my first choice, if I can't use Polymer.. but it seems like most cases where you know you have shadow DOM, and want to use it, you would want to use Polymer.
I'd suggest something like a combo of [jQuery](http://jquery.com/) and [jQueryUI](http://jqueryui.com/), at least to start with. That'll make prototyping way easier. To break down your features: &gt; In the text input field, the text title is written. *No special functionality* &gt; The split text field should split a text into a new textbox, where the cursor is placed. Take a look at [this GitHub plugin](https://github.com/dwieeb/jquery-textrange) &gt; For mergin two textboxes I think hovering over another textbox is the most convenient way I'm confused about how you'd imagine the UI for this, but it'd just be a matter of pasting in text and removing one of the widgets. If I could suggest something here, I'd say something like using jQueryUI's sortable, and allow the user to drag (via the mergin "handle"), changing the color on drag and dropping onto the mergin target? &gt; the up/down buttons should move a text box 1 field up and one field down See this [StackOverflow question](http://stackoverflow.com/questions/2951941/jquery-sortable-move-up-down-button) (the second comment, with a link to a jsfiddle). &gt; The big + button adds another text box Should be as simple as using [clone](http://api.jquery.com/clone/) (or just creating a new widget each time). I'd put it all into a jQuery plugin, then you can extend all you want and have it all like a widget. If you do it that way, you can also do the new creates all in there as well.
I know a student at MIT that's working on a project about integrating secure TPMs (like ApplePay) with the browser to securely sign code. So if this works out maybe it would someday be possible. On the other hand, this might be a really bad thing because then websites could for example not show you content if you use adblock.
Not to offend, but to me, someone who doesn't code in their free time isn't that passionate. In my opinion, Passion &gt; Skill. edit: Great, downvotes from coders that are getting offended by my comment. Try conversing about it. Downvotes are for things that don't add to the conversation at all. Also, if you don't code at all in your free time, why the hell did you become a coder?
The article suggests that Prototypes in JavaScript are "widely misunderstood" - I'm not sure that's really been the case for a good part of a decade, given Javascripts ubiquity? Do people tend to find that's still the case? 
It's not passion when it's a requirement to get a job. It's a terrible precedent. I love coding, it's why I do it. Sometimes I do a bit in my free time. I do not want my professional job to hinge on my personal projects. 
If it's not recent code, you're judging them on code that could be years out of date, so it's meaningless. Technical screening is to insure they have some skills. If they can google a problem, they have the skills to find out rote answers. The actual conversation in the interview is when you're supposed to gauge more than that.
That's patently false, and a ridiculous stance. I code 8 hours a day for a living. Then I come home and relax and enjoy time off from my work. I'm not "utterly and hopelessly outdated".
I hate that your being down voted because people disagree with you. I disagree with you. I have worked online for several years. What you are saying - is that an employer should never, ever, expect an employee to learn something on the job. They should come in with knowledge, and only learn new things off the job. Am I correct? I'm passionate about development. It was a hobby, turned job, and my current role has returned it to "more hobby, than day job." I code more now that I'm not tied down by my day job, coding eight hours (or more) while also investigating new technologies or methodologies - during work hours. I've got some projects i am getting ready to push to github, because they're the first code I have worked on in a long time that hasn't been tied to a client or a closed system. I haven't stopped learning - but to think that "your off hours must be devoted to code" is wrong, and dangerous. 
http://jquery.com
Ah, right. I remember something about that now, and I can see that that might be a good reason to not use 'self' when developing in javascript as part of a team. I mean, if we were working on the same project, it's certainly no skin off my nose. You could feel free to ask me not to use it. That said, I did a bit of research to make sure there wasn't a *really, really* good reason for this --- like it being an ECMAScript reserved word for the global execution context, for instance --- and it appears that, actually, "[window.self returns an object reference to the window object.](https://developer.mozilla.org/en-US/docs/Web/API/Window.self)" So 'self' has the property of being a global object only by virtue of being a property that is a reference to itself posessed by every window object; and, in the browser, there will always be *a* "self" that belongs to the global execution context, although any given window is not necessarily a *global* global execution context, and this is the reason that it has a self property to begin with. So in the future I hope that you will ask those people to please stop assuming that "self = window.self" : )
Only works in Chrome. Let me know when it is supported in Node
I'm a fan of reverse engineering, seeing how something else works helps me figure out new things to try. To that end, I always recommend getting a basic understanding of the DOM (selectors primarily, as noted in another comment). Then find a relatively simple plugin - try Github - and step through it to see how affects the DOM. Once you have that sorted you can work your way through the actual javascript methods in the jQuery framework, helping you learn vanilla javascript as well. 
Yeah, article needs some proof reading. Trouble with plurals as well.
Having recently interviewed for and accepted a senior level position, and having also interviewed candidates for my previous employer, this is fresh on my mind. I find the most informative parts on both sides of the table have been conversations around preferences and practices. What frameworks they've used, and what their pros and cons are. You'll learn a lot about the candidate's experience and flexibility. In terms of technical questions, I think the best I've been asked were about variable scoping. There's lots of gotchas around them, especially if you start throwing in "use strict". I was also asked to implement a version of Promises/A+. That might be a bit advanced depending on the position, but if you approached it collaboratively as several other commenters have suggested (and I also like) it could be a really good exercise. Also definitely give the candidate the option to do coding in a medium they are comfortable. I've done phone interviews with collabedit, and while I can code on a whiteboard, I'm much faster (and legible) when typing. Edit because I remembered things.
I built something really similar to this using Object.observe ([here](http://dmamills.github.io/tiny-bind/)) earlier this week. It's not nearly as deep though as OPs however
Give browserify or [component(1)](https://github.com/component/component) a shot as well. Lots of reusable components and simpler dependency management. 
I liked clock one..... :-) Thanks for sharing link
At the end of the day the answer is no. Validation on the client side should only be used to prevent a server visit to tell the user they made a mistake. If you are worried about a user entering malicious data then you should always validate and clean on the server side, even if you did the same thing already on the client. However, it is an interesting idea you've raised. In thinking about what you could do to see if your code was being messed with I came up with a harebrained plan. Lets say you have a function called validateForm. function validateForm(){ //validate code } The text of that function can obtained by calling toString(). validateForm.toString(); Now you need to hash the string to come up with a value. [This hash function is really fast.](http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/) Let's try that. So you know ahead of time what the hash will be of your validation function. Now when you validate your form also calculate the hash of the validate function. If it matches the known value then it has not been tampered with. You would have to protect the known hash in a closure or make an ajax call to get it on the server. Bottom line is...don't do this.
https://www.npmjs.org/package/cli-color
This === "ideal";
This === "reality";
The effect you've created where the GitHub icon changes from white to orange is extremely neat!
See I think this is inefficient and doing it the other way around is not only quicker but more productive. Learning how to use jQuery by codecademy or just playing with it means you start developing skills and start to learn how its meant to be used, etc etc. Then once you get an okay grasp on it, you will have picked up another knowledge (of JS as well) to be able to actually look underneath the hood and see whats going on. If you were to dive into jQuery's source code it would be very difficult to understand right off the bat, especially when you didn't really know exactly what everything was for etc. EDIT: Like learning to drive a car. At first you simply do a bit of study (just like you would read codecademny/follow tutorials) and then you actually start driving. You first concentrate on getting from point A to point B without killing anyone. Once you have gotten used to that you can start to understand more how a car works, how the traffic works, how other people drive etc. These final nuances are what makes people great drivers. Doing it this way starts building your applicable skills right away, and then allows you to hone in on areas you need help with. If you learnt to drive a car the other way around all the knowledge you had would seem inapplicable as you don't know what driving a car is like. You'd get into the car and feel totally lost. Obviously this is simply my opinion.
I think it's worth to mention that Shadow DOM, Polymer/Web Components and Angular are very different things that try to solve different problems. Angular is a framework. And it will always be. Whereas Angular gives you services and a runtime to build your apps on top, Web Components (no matter if native or on top of Polymer) are for component development. Single components that you can just grab from somewhere and put into your app. An interesting point is, that Angular 2.0 will be component based. So there'll be no controllers, scope or ng-models anymore. Everything will be a component that can use Web Components technologies like Shadow DOM and Custom Elements. So to answer you question, why one would use Angular at all if there's Shadow DOM, you can't really compare these two things. Shadow DOM gives you style and DOM Tree encapsulation which is great. It's not necessarily needed for all components, but it's indeed a great feature. Angular components can build on top of that. Also just imagine the case where somebody built a very nice web component that you want to use in your Angular app. You don't have to care about the fact that it's not a directive. You can just grab the component and use it, because you don't want to reinvent the wheel. I hope this answers your questions, otherwise let me know your ping Camen or me on twitter!
Dude. No. At this point in the js world, pulling something like this is like rolling up to a car show filled with the hottest exotic cars everywhere and proclaiming that the Lambo Aventador is just "too much structure" and that everyone should be checking out your 1976 Yugo with duct taped vertically opening doors made out of ping pong tables.
I might not have been spesific enough in my short reply. Of course one should be able to learn on the job. Your current employer has no right to lessen your value in the eyes of future emoployers, and should logically want you to do the best work you can do. Still, no workplace is going to be happy about me spending time writing a WebSocket-server class in php with support for all the major drafts. There is just very little value there. Likewise, my home automation system (node.js on a RasPi+Tellstick Duo) has taught me a few things about socket.io, Rest, lightweight schemaless databases, and front-end patterns. None of which apply much to my job, apart from keeping the "programming circuitry" maintained. The point isn't that you can't be a decent programmer doing 8 hours of payed programming per day. The point is wholly pedantic, and hinges on the use of the term "great programmers". If you aren't drawn to program something, just to try it out, to see how it could be done or what it'd look like... ..then sorry, you're at best a *decent* programmer who produces because someone inputs money, while others like myself learn and output because.. well, I'd go crazy if I couldn't. :P Edit: not saying I'm great or anothing, just that your programmer-who-only-codes-at-work seems like the few candidates I've met who had their first encounter with programming in software engineering school. These people are *never* very good compared to people who felt like they were wielding magic in that blue-and-white QBASIC-prompt back when they were 10-12 years old. :P
Good point. I've been in that situation too but there's bound to be a fragment of code that they can produce. Or you can task them on building you something.
I won't use it purely because of future maintainability by other developers. Plus it reads like shit. 
It would be silly to provide outdated code. If they submit that then there is already a problem. Its true that a coder has to have the ability to research a problem with google but there have also been cases where a developer strings code together via copy/paste and they dont ever know WHY something works. You're right the call for technical screening can help in that situation but I suppose there is no easy answer.
well, things are a bit different... a client is a representation of a certain part of the systems state; sure, you can set 99999 as your gold in a browser ( a thing you can do also on classic desktop games ) but the server will validate that it's incorrect and handle it in whatever way it sees fit
Right, but that means the server is running an instance of the game as well (or at least part of it). How can possibly do that in a non-blocking way? Or do you run a new game instance as a separate process every time a user starts a game?
Nobody ever said you had to code every day, but if you don't code on your own time at all, coding isn't your passion, your daughter is. How is it that I implied you have to work beyond hours? This is about code not done for your your employer. 
So you code in your free time ("sometimes")... That is all I'm talking about. You don't have to be TJ Hollowaychuk, but someone that doesn't code at all in their free time isn't passionate about coding. 
I took course on codecademy.com, it's pretty basic, but, hey, at least they teach you in an understandable way!
just make a variable so you can call that instead of all the properties.
Sounds like you're looking for CSP: http://www.html5rocks.com/en/tutorials/security/content-security-policy/ The spec allows you to define a hash on an online script tag, preventing execution if it is tampered with. I haven't tried it, and only know of this from developing a chrome extension. CSP spec draft is here: https://w3c.github.io/webappsec/specs/content-security-policy/
Well designed games consider gold sensitive data and don't allow the user to change the value on the client. Setting the value would be done server side. If it was done client side, the server would have to look at the previous user action to see if the gold value matches a known possibility for the user's last action.
One way to get some experience and exposure is to contribute to open source projects, you'll find tons of those in the web programming world. Pick some frameworks or tools to learn on Github (anything that interests you) then have a look at their Issues tracker and fix something, or make an addition of your own. Then send pull request to the original author. You won't make money this way but at least you'll start building a portfolio that you can show potential clients or employers later. If you don't invest time into a post secondary education you need to make up that deficit somewhere else, either in knowing the right people to land jobs or building an impressive portfolio of your work. Or you could get lucky and become internet-famous for creating some tool, library or framework that ends up becoming very popular, but that's a pretty risky strategy.
Personally I'm fine with writing JS, and I vastly prefer C-style syntax languages anyway. So for me CS is just an unnecessary abstraction.
But if all the processing is done in the server, surely that would start blocking - especially if you're doing n^2 collision checks. Let's assume I'm using node here so I want to avoid this
Hey, thanks for your time writing your post! Pretty nice idea about contribution to Open Source projects, I really haven't thought about it. As for now, lacking experience, it is the best option to gain some strong knowledge base. Thank you!
I learned it by looking up whatever i needed when i needed it and things stuck. However as new people have come in to the company, we have been sending them to http://try.jquery.com/ which seems to to a good job explaining the basics.
The irony being that ES6 has clearly been heavily influenced by Coffeescript. Personally, I just like it's function shorthand and splat args, (had to start using it at work). I really dislike the class construct because it promotes use of inheritance patterns. I'm generally anti transpilers, I believe they Balkanise the language, but in the long term they can change it's direction. My advice, only use CS if you have to, it comes with too much interop cost when you factor in build tools like Gulp
Eh - I'm working on a project with 250k+ lines of javascript and a distributed team of 45 on 3 continents. With good coding standards, docs, and unit tests - we've not had trouble. 
&gt; Everyone's suggestions so far are totally backwards IMHO. I'm not sure they're *backwards*. It's more like they're just different from what you would do. Or, in some cases, different ways of saying the same thing. As I noted above, you and I are essentially recommending the same thing, we just worded it differently.
You might have some site and load-order issues. I got this in the console and it didn't work. A reload gave me similar errors, but it did work: Failed to load resource: net::ERR_CONNECTION_CLOSED https://cdn.rawgit.com/kimmobrunfeldt/progressbar.js/0.5.2/dist/progressbar.js Uncaught TypeError: Cannot set property 'cssText' of null jquery.min.js:14 Uncaught ReferenceError: $ is not defined common.js:37 Uncaught ReferenceError: $ is not defined content.js:125 Uncaught ReferenceError: ProgressBar is not defined 
Everyone complains about classes missing. ES6 introduces classes but that's a pity I think. Prototypes are great.
ES6 will take a few years before we can start using though, right? You reckon 3-5 years?
Turns out I was parsing the JSON in the event itself before the data was being passed to the JS, so I was trying to parse JSON that was already parsed :p Now I just have to figure out why when I close the server I'm getting a "Completed 401 Unauthorized in xxxms" I am calling eventSource.close after my call? Not sure why the connection is continuing to stay open...
Good idea, but you can still fake an request outside the browser, which makes this still exploitable. 
I have a pretty good understanding of how Prototypes work technically, but haven't really seen much of a use case beyond simulating inheritance in the rare occasion I feel like throwing OO at a problem. Are there better examples of how Prototypes can be used to do things that a) I'd actually want to do (Not just a cool trick) b) Are not just simulating class based inheritance? (Genuine question, not having a dig)
&gt; even if it was code work completed in school That was 10 years ago for me. So not really relevant, and my skills kind of progressed since then... &gt;And as far as asking Technical questions, that is a great idea but with a quick typer on a cell phone and a laptop, can simply google everything while they buy time with patter Only if you're asking for definitions / rote knowledge (don't do this). Ask questions that require understanding.
You're saying it's not a problem because everyone is bound to have something, maybe something they did in school. I'm saying that might be horribly out of date. Keep in mind, some people graduated from school a long time ago (and some never did, at that!)
Yeah, I've had this. We won't hire you because you aren't interested in learning ruby. That from a company who didn't use ruby, and weren't planning to. Then companies turn round and complain that it's really hard to find any developers and it takes months to hire one decent mid / senior level dev.
Believe it or not, there is a concept in English called the generic he. Feminists will rewrite history, of course. Is history offensive? Herstory?
ASP.NET has a technique called an [anti-forgery token](http://msdn.microsoft.com/en-us/library/dd470175.aspx) that gets generated by the server and must be sent back with a form to confirm that the request is from the same client. Using this with a client that can only make a request for a token after authentication + using SSL, while not entirely secure, would be a great start.
Pressing ESC in the developer tools bring up the console with extra tabs, one of them "Emulation".
&gt; `abc.prototype.foo = function(){//bar}` That can't be right. You can write: function FooFighters () { // ... } FooFighters.prototype.foo = function(){//bar} var abc = new FooFighters() And you can write: var abc = {}; abc.foo = function(){//bar} Or even: var abc = { foo: function(){//bar} }; But binding a property called `prototype` to an object does nothing special for that object.
He was very clear about it being personal preference. And did a good job to explain a little further, even if it doesn't give a "clear" reason why it still is a well typed response. Yours was lacking in content, but stronger in bias.
&gt; it's function shorthand Heh. No, that's not something CS invented. C#, for example, had fat arrow functions since 2007 (C# 3.0). CS appeared in December 2009.
There is Traceur for that. Also, there are certain environments where that kind of thing isn't a real issue. E.g. Node or Firefox OS.
No. There are dozens of languages which use C-like syntax. Most of them are quite different from C.
You're doing it wrong. There are almost no cases where you should do a page reload. If you want to execute code when the user does something, use [events](https://developer.mozilla.org/en/docs/Web/API/Event). If you want to execute code after some time has passed, without any user interaction, use [setTimeOut](https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers.setTimeout). Let's say you have a function that evaluates an answer: function evaluate(answer) { if (answer === 'A') { alert('Right!'); } else { alert('Wrong...'); } } you can now create a button which runs evaluate when it is clicked: var btnA = $('&lt;button/&gt;', { text: 'Answer A', click: function () { evaluate('A') } }); then we can add it to our document: $("body").append(btnA); [Example](http://jsfiddle.net/dxvmdL9q/) This is probably what you want.
He was talking about liking it, not about whether it was original to the language. 
&gt;wouldn't that be very off putting during an interview No, why? We get candidates to do this.
just asking :) never had an interview myself where I had to do paired programming, but I know from experience that in certain situation paired programming can't be used, or it's not particularly effective, because of the combination of people and tasks to be done. Thanks.
&gt;Come up with a short but unique spec that involves the technologies and process you use (for front-end developer, maybe give them a PSD if that is part of it), make sure the programmers on your team can code it within a day or two, give the candidate a day or two to code it. Last time I was looking for work I had two weeks off work to job hunt. During that time I interviewed with 8 companies in 1.5 weeks before I decided I wasn't accepting anymore interviews. If each company set me a 2 day task to do that would be 16 days of work. For this reason I would not accept any test that would take this long. It's really up to the interviewer to devise a test that will tell them what they want but can be completed in a more reasonable timeframe.
Chrome auto update. 
&gt; I think if you gave them the ToDo checklist test, and they went immediately to jQuery, you probably wouldn't want them as a JS developer. Why? 
Niiice, thank you for the info.
Thanks for the link!
If I borrow a book from you, do we need to argue about whether you borrowed it from someone else? The fact is, fat arrows existed before CoffeeScript. The fact also is, demand for fat arrows in JavaScript was minimal at best until CoffeeScript became popular and people noticed that concise syntax and fixing broken `this` semantics made function-oriented programming in JavaScript far more useful. It's clear that the lineage for fat arrows passed from other languages *through* CoffeeScript.
It won't make you forget JavaScript syntax... but it might make you never want to write JavaScript syntax again. ;) I've been coding mainly in CS for a little over a year, and I've found the biggest gain is in the readability of my code. I didn't realize how tedious it was scanning through a file with a dozen `MyObj.prototype.someFunction = function someFunction () { ... }` constructs. That's a lot of text to scan, when the only useful bits are the object name and the function name. Multiply that by your whole module, and it's pretty cumbersome. CoffeeScript takes that extra cruft away and lets you see just the parts of the code you need to see. For me, this translates to legitimate productivity. I can (and do) still write vanilla JS when the need arises. CS hasn't ruined that for me. But I find that, even in small projects, the brief hassle of "npm install gulp-coffee" is a big time saver in the end.
Got a citation for that? It's not like C# is an exotic language. I'd also argue that everyone who works on languages with C-like syntax always looks at other popular C-like languages such as C#. I wanted fat arrow functions in JS because they are convenient. Not because CS has something like that, too.
Did you read my whole message, like the part where I said not everyone has that much time?
Using physical objects to talk about borrowing ideas has precedent in ou rindustry :-) &gt; "Well, Steve, I think there's more than one way of looking at it. I think it's more like we both had this rich neighbor named Xerox and I broke into his house to steal the TV set and found out that you had already stolen it." --http://www.folklore.org/StoryView.py?story=A_Rich_Neighbor_Named_Xerox.txt
I know the following other languages with C-like syntax: * Java * Objective C * C++ * C# None of these has the same local variable scope handling, the global-by-default variables, the weird way *this* behaves, the 5 ways to call a function, or the closure/function equivalency. Note that I'm not saying that these are bad features (especially the last one), but they're different from all other languages that use the C syntax. People coming from other programming languages think that it's easy to just start using JavaScript, and they run into all of these issues. I've seen the reverse as well, people coming from JavaScript trying to write C.
It doesn't do nothing for you, its just another way of building a prototype chain. It does let you add methods to existing objects, which can be useful, and it can be used to mimic classic OO classes and class declaration (a.prototype.b vs class a { b(){} }). You still can't declare function abc.foo(){ //bar } which is what the issue is.
So, are you saying that Java is just like C? C doesn't even have a `this` keyword. The problem is that JavaScript has some weird quirks. The problem isn't that it's using a familiar syntax. If you are, for example, coming from C# to Dart, you won't have any problems whatsoever.
Don't you mean: "Having Java-like syntax without Java-like semantics is very confusing, especially to newcomers." 8-) 
Initially Coffe script looks like a good idea __but__ the main problem I found when I tried to use it is that virtually all the examples on the web are on javascript so you have to manually convert them.
Sounds very much like what I'm after. I'll definitely give knockout another look. I'd like to keep it as simple as possible, and not introduce new technologies unless the win is totally obvious.
As someone who had no official education in software development, who landed a job interview by describing a few (useless but fun and complex) projects I had done, and who got the job by displaying a firm *"I'm good at what I do, and if need be, I'll damn well learn and learn fast."*-attitude and asking for and completing about an evenings worth of code-"homework" to prove I knew my stuff... A potential employer doesn't need to see huge complex projects that you've created or managed. They need to see how you write code, and how you solve problems. A Junior Developer should be able to show a few snippets of code demonstrating a basic understanding of programming. Anyone beyond that ought to have at least a few decent-size projects to refer to. After all, anyone can bullshit their way to a good impression and a decent job. Doesn't mean you have the mindset or the skills for programming.
I'll give it a look. We have a pretty reliable css architecture though, with inuit.css and BEM, so it's the javascript I'm after. What does browserify give me over requireJS?
I guess you're right. I'd like to keep it as simple as possible though, and not introduce new technologies unless the win is totally obvious. Are there any standardized multipage architecture solutions using backbone that you know of? What I don't want is loads of SPA logic that I just don't need. I don't want to code around a framework -- that's just not right.
From your example, only C++ and Objective C build on C semantics. Java and C# change the base semantics significantly. And that is not counting all of the other, so far unmentioned, languages which also derive from C's syntax. 
A minor problem. there are plenty of solid converters out there.
I thought I understood the concept of neural networks until I read this article...
I think we will see ES6 in the evergreen browsers within 2 years. 
What changes in Java/C# do you have in mind there?
With a new responsive design
Take an idea, implement it until you get another idea :-) To get money you can either 1) implement an idea and see if there is an interest. Google "MVP and Lean start-up". Or 2) Go to a forum / community where people are recruiting web devs for small jobs.
&gt;Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems.
You won't be able to evaluate it effectively based on a glance or other peoples opinions. I initially dismissed it. The gains at first did not seem worthwhile to justify learning a new language, and the code not a whole lot more readable because I just didn't know CoffeeScript. I had to learn it in order to modify a popular Node.js module. Now, a few weeks later when I was actually familiar with the syntax, it was a completely different story. I found it much easier to read and write CoffeeScript without all of the extra cruft from JavaScript. That was a few years ago that I switched to CoffeeScript. Then maybe six or eight months after that I switched to ToffeeScript, which is an even bigger gain. Syntax matters.
There may be that concept of generic 'he', but it seems to be of no relevance at all anymore. The risk of getting misunderstood as being meant non-inclusive is just too high.
I beg to differ. You cannot set the prototype of an ordinary object with the syntax `a.prototype.b`. I tried it just now in Node to show you what happens: a = {} a.prototype.foo = function () { return "SNAFU"; } //=&gt; TypeError: Cannot set property 'foo' of undefined You can use `Object.getPrototypeOf(a).foo = function () { return "SNAFU"; }`, but you are treading on dangerous ground, as you have just defined `.foo` for all objects sharing the same prototype. In this case, every object, everywhere. For example, we've just added the `.foo` method to all strings: "foo".foo() //=&gt; 'SNAFU' I really think you are thinking of the `.prototype` property of constructor functions, but the way you are expressing this thought is deeply misleading.
there is nothing wrong with using eval here it makes it much easier than trying your return next + previuos
If you like using your own properties on functions, and using them in the function body, I wrote a Sweet.js macro to write the function declaratively with an extension of the object literal syntax: https://npmjs.org/package/fn-obj-literal
&gt; Atom is written in coffeescript Ahem... "and some companies like github use it extensively" &gt; it's now part of ruby on rails It's not "part of" rails. Rails simply uses it as a default type and offers a transpiler. And it's been available in rails for years, so "it's now" doesn't really make sense. &gt; I have no idea how you could make a distinction that it offers "no real benefit" - you really do need to have some kind of justification for saying something like that CoffeeScript doesn't add anything to the language except shortcuts, and shortcuts aren't enough to justify a switch from a widely used language. Someone will, at some point, come along with a syntax that the general community prefers more than CoffeeScript, and CoffeeScript will evaporate. If you're talking about saving typing, code-snippets in SublimeText are roughly the same thing. If you're talking about increasing readability, I prefer looking at JavaScript over CoffeeScript since it's less ambiguous. That's not to say that shortcuts aren't _useful_, quite the opposite. I just don't like the idea of having them be the basis of a transpiled language. I don't really like TypeScript either, but at least it offers a real benefit over plain JS (I just don't think that benefit is large enough to justify a transpiler either) CoffeeScript also _removes_ certain language features, like being able to control your own variable scope. Transpiled languages, pre-compilers, etc have their place, but there needs to be sufficient benefit to overcome the costs. CSS pre-compilers add _tons_ of features to the language. They add variables, functions, loops, etc and make it more like an actual programming language. CoffeeScript doesn't _add_ anything at all. Plus, I don't _have to_ justify myself. I said it's mostly personal preference. If you like it, great use it. But be aware that there is a decent chance that it won't be around in 5 years except for legacy support. If you're okay with that and you like the syntax, the more power to you. It's like saying "I prefer jQuery over Prototype", there is no wrong answer. They're both tools, they both have their place, and they'll both be completely obsolete at one point or another.
Probably, though in my defense I never explicitly stated that `.prototype` can be used on object literals, just that it can extend objects though I suppose I should have said something to the effect of "extend defined classes/functions" which is true.
You can start using most of it today using transpilers. And once browsers catch up, the transpiler step goes away and the code doesn't change.
I agree that CoffeeScript is personal preference to a large extent and not without its warts, but it's still valuable even with ES6. 1. Less visual noise. We should all be properly indenting our code, so braces/brackets/parens/semis are often superfluous. Yes, there will be edge cases, but they're usually easy to get around. This one is the most personal, but I feel that less visual noise is objectively better. Note, I do use parens to break up nested function calls: `foo bar(baz, buzz, fizz(bazBuzz))`. I find readability is better. 1. Existential operator that soaks up nulls along a chain: `zip = lottery.drawWinner?().address?.zipcode` In JS, you have to check for `drawWinner`, then call it, then check the result for `address` before finally getting `zipcode`. It's tedious, and I feel like an animal every time I have to do it: `zip = typeof lottery.drawWinner === "function" ? (_ref = lottery.drawWinner().address) != null ? _ref.zipcode : void 0 : void 0;` 3. Better [loop constructs](http://coffeescript.org/#loops) for both arrays and objects. I tend to use Lo-Dash/Underscore and favour `forEach/map/filter/etc`, but to each their own. Oh, and CS has us covered with `hasOwnProperty` checks by using the `own` keyword when iterating over objects: `for own key, val of object` 1. Thin arrow *and* fat arrow. Handy to be able to determine the value of `this` when defining a function. 1. Guard rails like automatic `var` insertion, strictly strict comparison (no `==` to bite you), automatically wrapping files in an IIFE, etc. Most of these can be taken care of with a linter, but easier to not even worry about them in the first place. If CoffeeScript can target and leverage the features of ES6, then I think we have the best of both worlds. I've introduced a number of devs to CS, and they've all been able to get up to speed quickly because by and large, CS is just JS with a different syntax. The semantics are 1:1. Debugging is very usable with source maps. Sometimes I get an odd jump with breakpoints in Dev Tools, but I assume that's a bug that will get ironed out. As others have mentioned, if CS dies off just take the generated code and run with that.
Even better if you have an android phone is to use chrome dev tools while the webpage is open on an actual device. 1. Plug your phone in via USB and open a webpage in mobile chrome 2. Desktop chrome menu -&gt; More tools -&gt; Inspect devices 3. In the opened window, select the webpage tab that you have have open on your phone. ios may be possible but I haven't checked.
 PNelOP_History Is probably not the best name for a library global namespace.
Just wanted to add some quick context. This is designed as a compact (and semi-ordered) list of resources for anyone just starting out trying to learn Javascript. The idea was not to include *everything* as that can get really confusing but to include a lot of useful things to take you from knowing absolutely nothing to be being a competent practitioner. I tried to include totally free resources when available. I would love some feedback. As always with stuff like this there is probably some obvious stuff that has been left out, and some stuff that could be better described. Anything you guys could add would be really, really appreciated. Final note: The list focuses on Vanilla JS because otherwise it gets sort of unwieldy. Thanks so much!
If you compare C# and Java to C... They don't have goto or trigraphs, for example. There aren't pointers. Only C# has structs, but they are used differently. In C, square brackets are just syntactic sugar. foo[3] is exactly the same as \*(foo + 3). As a result, you can also write 3[foo], because that desugars to \*(3 + foo). C had function pointers. So, you could actually pass functions around. There isn't such a thing as file scope. You can't have top-level functions. Well, I haven't really used C since the late 90s, but it really is a quite different language which offers very little in terms of structure. Also, C is not necessarily the first C-like language someone learns. Nowadays, it's probably Java for most people.
Inverted mouse is for flying a plane.
it seems to be a very easy way of implementing responses to user interaction in your web designs...
`let` and `const` are there. Anyhow, the point was that you won't necessarily have to wait until old version of IE have died off. There are environments where you'll be able to use the new ES6 features much sooner. Node is one of them.
Not that it really makes any difference, but I'll wager that CS inspired the ES6 sugar rather than C#, since the former has more exposure within the JS community. I'd also suggest the query selector DOM api borrows heavily from jQuery. It's not really relevant, the OP is interested in the value of the syntax, not it's origin. The point I was trying to make is that altJS dialects and libraries of today can and do affect the direction of the language, much like slang eventually finds it's way into the dictionary. CS has some good parts, some less so. It's worth giving it a whirl, simply because you're a programmer if nothing else. I suggest you become sure footed with vanilla first, certainly with regards to scope and closure, before trying it out.
It certainly made non-male candidates feel unwelcome.
I like Javascript. I learned Javascript. I write Javascript.
It made hypersensitive people feel unwelcome, and people that are so hypersensitive a pronoun have them that feeling probably aren't fit for most work environments anyway.
&gt; I'll wager that CS inspired the ES6 sugar rather than C#, since the former has more exposure within the JS community. Well, sure, if you consider people who write CS to be a part of the JS community. If you go with that kind of definition, it becomes automatically true. &gt;The point I was trying to make is that altJS dialects and libraries of today can and do affect the direction of the language Yes, that's certainly the case. TS and AtS will help shaping ES7. In AtS case, it's even kinda on the roadmap. TS, AtS, and ES7 will hopefully converge at some point. That's the big idea, basically. &gt; It's worth giving it a whirl, simply because you're a programmer if nothing else. Nah, trying it just because it exists isn't a very good reason. From my point of view, CS isn't worth it because it doesn't improve the tooling. That's the primary problem most people have with JS; It scales very poorly. CS doesn't address this. TS/AtS and Dart, however, do exactly address this particular issue. That's why they are (again, from my point of view) far more interesting.
Please stop, we get it, boo CS. You're boring us, learn not to be boring if you're going to be so fucking verbose.
I think that the drawback he underline are for bad code style like hundreds of lines functions.
Apparently you are hypersensitive too if it bothers you that much.
Now you're grasping at straws and attacking me personally. Thanks for the worthwhile discussion!
Reddit uses a threaded commenting system. If you aren't interested in a particular branch, you can simply skip it. Just click the "[-]" pseudo icon on the left to collapse it.
That's definitely good practice for form submission, but still assumes you trust the client. What it seems you can't do (which is a shame) is offload work from the server to the client, to make your server more resistant to flooding/traffic spikes/ddos. But all these issues assume the client is in some way malicious. I was wondering if there was any way at all that you could let the server automatically reject any request that didn't come from un-tampered JS code. It looks like no.
is the memory model part of a language's semantics?
Easier isn't the same thing as better, and it certainly isn't easier to read, even if it easier to write. There is an explicit, language supported, standards defined way of doing this on an array, I cannot fathom why you'd hack in an eval instead of using the actual language. Eval should really only be used when you have a string to evaluate, that you are positive you can trust, without any other possible means of parsing it, and even then I'd find another way... The code is already in a parseable format, making it non-parseable just to throw it at eval is silly. There are tons of ways you could write this code without eval, if for no other reason than performance. Here is another native means of doing so: var total = 0; numbers.forEach(function (number) { return total + number; }); alert('' + total);
Do you know other useful resources?
&gt;Here, the block is an if block, but let merely being inside it means that the block also becomes a scope. Otherwise, if let was not there, the { .. } block is not a scope. So, a function which doesn't contain any `var` statements doesn't create a scope? That's a mildly bizarre way to look at it. Those blocks are always there. With block scope, a variable belongs to the innermost block which encloses its declaration (the part below that statement, to be precise). With function scope, a variable belongs to the innermost function which encloses its declaration. That's all there is to it. There is no mental tax. Your IDE will tell you if you try to use some variable outside of its scope. Your IDE should also offer autocomplete for the variables which are defined at that particular line. &gt; ReferenceError Your IDE should point that out right away. &gt; [more like that] IDE. &gt;Some prominent members of the JS community and the TC39 committee like to say, "let is the new var." It is. Once there is `let`, there is no point in using `var`. &gt;In fact, some have literally suggested (hopefully in jest!?) to just do a global find-n-replace of var for let. This will work perfectly fine if you did all of your declarations at the top of the innermost function. I always did that, because this way the code reflects how it actually works.
Regular expressions have fairly strict syntax compared to JavaScript. Even if you're super-familiar with regular expressions, it's always useful to have a regex syntax cheat sheet handy as a reference while building any complex expression.
The compile to JS area is quite big these days. CoffeeScript is widely used and i would recommend to try it out. But as i have investigated more on the matter i have found LiveScript to be a better alternative to CoffeeScript. It focuses more on the funtional side, but offers OOP constructs as well. 
absolutely. 
My expectation is that I'd spend as much time (or more) adjusting the generated code to my liking as I would making it from scratch. I might consider making some generator script if I was setting up projects frequently, but creating a "please everyone" solution would be somewhere between very hard and impossible.
TPM won't help at all. It allows running code securely but the answer still needs to go back through the insecure software stack of the browser and whatever web client. The signing software itself could also be modified before going to the TPM. If you don't control the entire stack, you cannot trust it. There are no exceptions.
on the chrome dev tools, right next to the elements tab there's a mobile phone looking thing, click that and it will appear and dis-appear.
Yeah, basically what everyone else said. Operating under the assumption that your code is running in an arbitrary, hostile environment is an elementary characteristic of client code. Never trust the end user! If you're concerned about a certain set of actions with your app you could always require secondary authentication -- make the user re-validate with their password -- before submitting the request. Off the top of my head I know Github and Stripe do this for more essential operations.
That seems much more complicated and how am I hacking the eval? i just found a clever way to add the objects of an array together. 
You either offload the calculations to another process or you use a language/platform that's better suited for multithreading like JVM, Go, C++, etc. There's no magic here.
[These](http://www.metafilter.com/141549/Graphical-views-of-artificial-neural-networks) might be articles of interest.
It's a bit long, has _ character.. most of my projects include the entire PNelOP library and .History is an object within PNelOP or $P.History as i use it in my work. Good suggestion, Maybe i should change the variable to something shorter / easier?
If you put transpiled javascript in your public repository and I made edits to it and sent you a pull request - would you accept it ? 
Hmm... the function that appends to elements with .appendplz could also remove .appendplz once it has appended something to an element. Then you could simply add a bit to the function that supplies the 20 new posts: It should get all elements with .appendplz and run your append function for each item of the array. Alternatively, why not append what you need to the 20 new items before adding them to the site?
Removing the class is an idea I hadn't thought of, thanks! As for the method that gets the new posts, I don't have access to that, and I need to extend this UI the quick and dirty way. I think removing the class after appending, then an on click of the "show more posts" button that gets the new .appendplz items and runs the append/remove class function again might be the way to go. 
purescript, or elm?
I would question how that ever passed UAT. 1M checkboxes is horrific UX design.
For anyone wondering, you drag and drop music files into that dashed div. Looks good OP.
Nice! If you need any Backbone\Require pointers PM whenever :)
yeah because i can transpile from javascript to coffeescript just as easily
AngularJS is pretty much made to do what you're after. However, you're right when you say it's heavy. The learning curve is a bit steep.
Could you (or somebody else) give an example? I'm familiar with a lot of the things he recommends and how they can sometimes be impractical, but I'm not aware of times he's been misleading.
OMG.. Infinite ways... NEVER ENDING LIST??
Not particularly but there are excellent utils out there like underscore/lodash to help with common operations on collections and arrays. These have methods like _.last as well as many other options to help you write more functional code and to simplify working with your data(Ramda is even better in the functional regard imo, but underscore and lodash are ubiquitous) . Extremely valuable to learn these, regardless of what other tools and frameworks you are using, in my opinion. 
That's.... kind of the question I was asking. 
I wrote a post a while back: [CoffeeScript has the Ideal Syntax for Configurations](http://tbranyen.com/post/coffeescript-has-the-ideal-syntax-for-configurations). I stand by the recommendation, as I believe its made me significantly more productive with Grunt. It's actually a great deterrent from writing custom code inside my tasks.
The article you linked was someone having issues for the exact same problem/ignorance this original post was caused by... Should vendors deal well with properties the version cannot understand? Yes. Does that absolve you of your responsibility to prefix (and preferably use a tool to get it right for you)? Nope. This is a developer with an app __in production__ that was clearly never tested on the device it failed on (and most likely he didn't care to target it, or there would've been a webkit prefixed version of the property and it would've been fine). There is noting I can do about that. As for jquery, again, as in all of your examples, most of the failing of this *community accepted solution* (for which you can track cross platform bugs it has dealt with for the last decade very easily), are user error, just as it was in this post. 
I write pure javascript for work and coffeescript for fun. I like the quickness of writing coffeescript, personally, but i don't get worked up over it. Switching back and forth is a little tricky early in early mornings :) I also tend to write it with what it's transpiling to in mind, the same way I would with less or sass for css.
Not that I know of. I've found it annoying too. If you want to get the last value *and remove it from the array*, then `myarray.pop()` is what you're looking for. You can then undo it with `myarray.push(x)`. The standard term for "get the last item and don't remove it" is "peek", which would have been `myarray.peek()` if JavaScript had implemented it. Implementing it on `Array.prototype` yourself is, of course, verboten, but you might want to make a helper function `peek` that takes an `Array`.
or even better don't do something unusual that distracts visitors from the original reason they visited your site
One example: He gave a talk not too long ago about a really cool parsing technique I happen to be a huge fan of. Swell talk. However, in that talk, he says the technique never took off until JavaScript came along because you really can't implement it in anything but a prototype-based language. And that last part is utter bullshit. I've implemented it myself in Java, C++, C#, hell, *C*, and probably a few other languages I'm forgetting. I personally find Crockford's implementation to be the least readable, least comprehensible way of doing it. 
I can't wait until he learns haskell. /s
Dart has a "last" getter for that. Unfortunately, JavaScript doesn't have something like that. You could also write `myArray.slice(-1)[0]`, but that doesn't really improve anything. `myArray[myArray.length - 1]` is already the best way to do it. If you editor supports snippets with named tabstops, you could just make one like this: [[%tabstop1:array]][[[%tabstop1:array]].length - 1] [Syntax may differ. Refer to the documentation.] That way you'd only have write the name of that snippet (e.g. "last"), hit some shortcut, and then type the name of the array. Snippets and macros can be pretty handy.
This. Or if you don't need anything else in these libraries you can always just write a helper function that takes in an array and gets the last member.
I use CoffeeScript, I like it a lot. I also use normal JavaScript, I like it less, but I don't hate it. I find that my code is cleaner without `{}` and `function` everywhere. Plus, abstracting JS "classes" is a huge win, because I don't want to think about that mess.
I've been using Coffeescript extensively on a fairly large project. My primary reason for using it is the syntax is much more conducive to functional programming than pure Javascript, which is horrible at it. Arrow functions, partial application, comprehensions, de-structuring as a primitive form of pattern matching - all extremely useful features that make writing FP code much easier in places that Javascript made extremely painful. The syntax also feels slightly inspired by ML, which I quite like. However as you point out, ES6 catches up to Coffeescript on many of these important things, and macro tools such as sweet.js allow us to fill in the gaps in others - and even throws a few nice things in to sweeten the deal (monadic do-notation, for example). Overall I still consider Coffeescript to have been the right technical choice at the time we started our current project, but the ecosystem is improving at an exponential pace and as a language it's quickly losing relevancy. While once it was the only viable AltJS language, there's now dozens. If I was to start a project today, i'd either just use ES6 with a transpiler, or Purescript if I wanted static typing.
Track the current round and number of attempts in variables. Have a presentCurrentRound() method that resets the stage and presents the current round (or the results stage if currentRound &gt; maxRounds) On correct answer: numberOfAttempts = 0; currentRound++; score++, presentCurrentRound(); On incorrect answer: numberOfAttempts ++; if(numberOfAttempts &gt; maxAttempts){ numberOfAttempts = 0; currentRound ++; } presentCurrentRound();
If you're arguing about who invented them, C# was quite late to that party. There's a long list of languages with support for them well before C#. Technically, Alonzo Church invented them in 1936.
&gt; If you're arguing about who invented them "for example"
Sshhhh. This is /r/javascript. If you offer any hints that there are better languages out there, the neckbeards will get offended and downvote you into oblivion. 
Thanks. But what parsing technique or talk was that?
cool but useless! -css
Buy JavaScript: The good parts and skim through it. In the first few chapters, it'll have all you need. http://shop.oreilly.com/product/9780596517748.do 
Webstorm and unit tests work well. You also have to design Apis for reusable components such that they are maintainable and backward compatible. That's one of the arguments against using long parameter lists instead of configuration objects. The unit tests garuantee the code is working as it should after the change - and those are run at every deployment. Functional automated tests are also in place for contexts where the unit test coverage is poor. Compile time checks for type safety are not really all that important if your code is well structured. Additionally - we all attempt to take a very functional approach to things so most of our code is very modular and side effect free. 
Sure, sometimes extra characters help disambiguate, and that map example is nice. What about the same for iterating over an array? ES6 has a fat arrow which changes the value of `this`. There's no equivalent thin arrow and we still have to write `function()...`. AFAIK, ES6 doesn't eschew file concatenation, it just provides a built-in module system. Agreed that we should all be using some sort of module system or bundler, but not everyone does/will.
This great, but are there any tutorials for this? Reading it is one thing, but in practice it's much easier to get the concept once you can make something work with it...
Yes, but that is bad practice. Others may do the same thing and implement their extensions differently, and now you have code that expects two different implementations.
not tutorials, but this might help: demos: https://github.com/cazala/synaptic#demos examples: https://github.com/cazala/synaptic#examples documentation: https://github.com/cazala/synaptic#documentation source code: https://github.com/cazala/synaptic/blob/master/lib/synaptic.js
Yeoman?
Halloween is only once a year :)
great articles indeed, specially the one about topology. thank you (:
Please read up on reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. **Consider this your only warning.** If you continue to post _only_ your site, we'll be forced to take action. Thanks for your understanding.
node -e "while(1){process.stdout.write('\x1b[38;5;'+~~(256*Math.random())+'mYou can do fun things with colors in node though! ')}"
Very interesting! Wondering if it works well with primus.
At Tagged, we just open-sourced our local storage module. Key features include: - namespaced by default - cookie fallback - no dependencies other than Angular - fully unit tested **Why u no use `ngCookies`?** `ngCookies` does not offer the ability to set expiration, meaning that any cookies stored by it would be deleted when the browser is closed. To mimic `localStorage`, `taggedClientStorage` sets an expiration of one year when it falls back to cookies. **Why u no use (some other library)??** We were definitely impressed with other solutions like https://github.com/grevory/angular-local-storage but we needed a more persistent cookie fallback. Plus it was fun to build, so why not? Thanks, and I hope some of you find this useful!
Okay, I see two things here. 1. [es5 15.10.1](http://es5.github.io/#x15.10.1) gives a grammar for regular expression literals and implies that an error *should* occur if a regexp literal does not accord to that grammar. 2. [es5 15.10.2.2](http://es5.github.io/#x15.10.2.2) has a 'note' which encourages the replacement of the algorithm given with more efficient ones, but goes on to either explain the motivation or lay out rules of the specification (it's unclear which): &gt; The algorithms in 15.10.2 are designed so that compiling a pattern may throw a SyntaxError exception; on the other hand, once the pattern is successfully compiled, applying its result internal procedure to find a match in a String cannot throw an exception (except for any host-defined exceptions that can occur anywhere such as out-of-memory). You'll notice the word "may", I'm not sure how to read that: as in, "that might happen," or "this is an optional part of the specification." If we can find an instance where the use of an ungrammatical regular expression literal fails to produce a syntax error, then on the face of it, the browsers are not ECMAScript compliant in this regard. This is shocking enough that there is probably another explanation, so a search for existing answers might be in order before proceeding. However, I plan to play with this and try to produce a silent grammar-breaking example when I get a chance; if you can produce an example, please reply &amp; I'll verify it. I would be happy to use this thread to help you write up a more general submission / question that you could then submit either to r/javascript or stackoverflow. ----- **edited to add:** okay, it might be sort of like shooting fish in a barrel, I think. From my reading of the grammar, assume the simplest case: a *Pattern* that is a *Disjunction* that is an *Alternative* that is a "Alternative Term =&gt; [Empty] *Term*" that is an *Atom* that is a *Pattern-Character* that is the numeral 1. So far so good, right? Except that a pattern character can be any source character except one of several brackets. If the pattern is '1{', then either '{' is illegally a pattern character, or '{' is the beginning of the quantifier prefix for a quantifier of '1', and the regular expression ends unexpectedly. 
nice. will check it out, looks quite useful. 
Why is this solution controversial? And why is the controversial option better than simply assigning a function value to Array.prototype.peek?
var text="brandon is an amazing/ brandon wooo."; var myName="brandon"; var hits= []; for (i = 0; i &lt; text.length; i++){ } if (text[i] === "b"){ }
Need help again guys I'm on Search text for your name. Kind of lost where they want me to head. It explains everything for the second for statement but i have no clue what they want. any explanations are very welcome. I am having a conflicting feeling with Code academy due to the structure. I feel like life i don't enter things exactly like how they want its wrong. Also i don't feel like I'm learning too much. Any advice on really learning JS would be helpful. Trying to spend most of the next two weeks on completing the JS section here. I would like to complete my application to Hackreactor. 
Extending base objects can cause conflicts with libraries or other code. It's not really a problem if it's all your code, but if you're on a team or making a library you need to explicitly warn people using your code about things like that.
It's considered wrong to extend native prototypes. Some (including myself) will argue that it's ok if you know what the ramifications are. Nicholas C. Zakas wrote an article that covers the topic pretty well, [Maintainable JavaScript: Don’t modify objects you don’t own](http://www.nczonline.net/blog/2010/03/02/maintainable-javascript-dont-modify-objects-you-down-own/). **TLDR**: Dependability, incompatibility, What if everyone did it? Object.defineProperty is better because it doesn't break `for..in`. Most people don't use `for..in` on Arrays, but using the `Array.prototype.peek = function ()` version includes that in the loop. Try it for yourself: Array.prototype.peek = function () { if (this.length &gt; 0) return this[this.length - 1]; }; for (var x in [0, 1, 2]) { console.log(x); } // 0, 1, 2, "peek"
&gt;Object.defineProperty is better because it doesn't break for..in. Most people don't use for..in on Arrays, but using the Array.prototype.peek = function () version includes that in the loop. Ahhhh!
When it comes to javascript usually there's a ton of ways to do the same thing. The "right" method generally depends on a couple factors. The community critiquing your code will have something to say about your methods as some groups are trying to standardize javascript. Some groups want to see the most appropriate design pattern implemented for the job. The other factor is what method is faster. I prefer to code around the second factor as proper design patterns and structure that are considerably slower are not worth it in the long run. I'm too lazy to look at the code or test it at the moment but here's a tool for simple test case generation and execution: http://jsperf.com
Thanks for the advice!
Often times things like this are matters of opinion, but in this case performance and readability come into play (though they are often at odds with one another). I'd reject all of these because they traverse loops twice (although the second loop is always shorter because it's filtered, it's still traversing stuff it already looked at previously in the first loop). Also, map and filter are really useful, but they come with the tradeoff of having to setup function contexts every single time in the loop. My intuition is that a simple for loop is going to be the fastest: function getShortMessages(messages) { var shortMessages = []; for(var n=0, len=messages.length; n&lt;len; n++) { if(messages[n].message.length &lt; 50) shortMessages.push(messages[n].message); } return shortMessages; } EDIT: Made a [jsperf](http://jsperf.com/return-short-messages/4) that shows that the differences are pretty dramatic.
Definitely agree with doing the filter and map manually in a single loop and building an array of short messages. Though I doubt the tradeoff will be very big with sub-thousand-item arrays. If you know you're dealing with smaller arrays then I'd go with whatever is most readable to you.
Well, if you focus on performance, none of those are: a. too different from each other, b. too good. All three scan the array twice. So if performance is your goal, you have to forget filtering and mapping and just go with a simple `for` loop, which is about 8 times faster than those, according to a [quick jsperf test](http://jsperf.com/reducing). But of course you lose all your hip functional coolness ;) Alternatively, you could use 1 `reduce` operation instead of mapping and filtering and you'd get 4 times the speed (so twice slower than the `for` loop). You get half the performance and get to keep some of your coolness points. Or you could go for readability. I don't think I'd ever go with method 1. Then method 2 vs method 3, I think it would be a case of reuse. Am I going to reuse those particular filters or is it just a one time thing? (But I wouldn't indent/arrange method 2 that way; it's clearly *wrong*.)
I think loops are pretty awful, and I would suggest avoiding them as much as possible. They make building higher abstractions more difficult, and they are not very expressive. `map` and `filter` convey information, while loops don't. The argument on performance is true, and loud, but of little relevance in the real world. There are [voices](https://www.youtube.com/watch?v=0wgDGTgOPds) that [support](https://www.youtube.com/watch?v=bo36MrBfTk4#t=1289) my argument. For me, writing better code is about building reusable abstractions, and loops prevent me from doing that.
Your dropbox copy is not able to find https://dl.dropboxusercontent.com/data/commands.json ... for hopefully obvious reasons... Check scripts/main-built.js Specifically, the area aroud: Command.Collection = Backbone.Collection.extend({ model: Command.Model, url: '/data/commands.json', The url may need to be changed. 
It's a paid-for licence and a little pricey, but have you checked out http://jvectormap.com/ ?
yeah, ive checked that one out, but not exactly what i am looking for.
Yes, loops are as fundamental as recursion. But you didn't address my point really, which is that loops limit the ability to build higher abstractions, making code harder to maintain. Null is also pretty fundamental to programming, but that doesn't necessarily mean it is a good idea.
My head hurts
The first two are just as tightly coupled as a loop, and the intent is obfuscated to boot. The third is a good building block for some approaches to abstraction, but unless you already know what you will need in the future, it won't necessarily save much/any work. 
Wow- this comment taught me a lot!
You should put your functions declarations in the setup, not in the test itself :)
http://i.imgur.com/UqKe0nz.gif
Well sure, but i already thought of a Templates folder where you can customize the files it generates. So a controller-template, style-template and so on. Then it will use your project name and all kinds of other stuff required for getting it to work. But i agree, most generators aren't really that flexible and they really should be.
That was kinda my point too: not an expert myself and would require more hands to get it working i think. Plus maybe there was something i overlooked?
So, you'd choose performance over readability? Also, most languages have a feature called "lazy evaluation" (either through libraries or backed into the language) which would render the "loops twice" point moot. Not sure why this hasn't made it into mainstream JavaScript yet. &gt; Also, map and filter are really useful, but they come with the tradeoff of having to setup function contexts every single time in the loop. A JavaScript compiler could theoretically optimize it for simple cases like this (no closure required, function dependents only on argument). Not sure why that's not being done.
They seem coupled but as you keep going you start to see some patterns that can be abstracted, so maybe, if this is a common operation on similar data structures (collections), then I can think of a possible abstraction that applies to these transformations: **Edit:** Here's a demo http://jsbin.com/pegakotoso/1/edit?js,output //:: k: String -&gt; (a -&gt; Bool) -&gt; [{k: a}] -&gt; [a] var filterWhere = curry((k, p, xs) =&gt; { var trans = compose(filter(p), map(x =&gt; x[k])) return trans(xs) }) var getShortMessages = filterWhere('message', x =&gt; x.length &lt; 50) // Example var messages = [ {message: 'Lorem ipsum dolor sit amet'}, {message: 'Lorem ipsum dolor sit amet, consectetur'}, {message: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod'} ] var result = getShortMessages(messages) console.log(result) // ['Lorem ipsum dolor sit amet', // 'Lorem ipsum dolor sit amet, consectetur' // ]
They are all wrong on purpose. Because they are wrong, the third choice is the least wrong. It separates the intent from the implementation the most cleanly, because it first specifies the algorithm by breaking the intent into simple composable semantic pieces, each of which encapsulates its implementation. This makes it the easiest to fix. However, for this reason, the third choice is wrong in a way that the first and second are not. In each case, the algorithm used for the implementation is flawed. What is unique to the third choice is that it risks confusion between the intent and the implementation. In the other cases, the semantic portion of the code, the intent (as expressed in the function name) is merely "get short messages", which on our level of knowledge is immutably correct. This is lost in the third choice due to the semanticization of the algorithm. Of the three options, the first comes the closest to illustrating the sort of tiered separations of intent that it would be preferable for the third option to have, but it also illustrates that the semantics of variable naming cannot be used to identify a process as distinct from a result. Were all the choices 'right', the second choice would be preferable, as it allows one to recognize the familiar in the implementation, while taking care of it quickly and succinctly. It would be the most comfortable to see within the same context in which 'getShortMessages' is actually being used.
I think you made up all that wizardry.
Well, that is one way of saying: var filterWhere = k =&gt; p =&gt; xs =&gt; { return xs.map(x =&gt; x[k]).filter(p) } But I wanted to make the transformations by composition of functions more explicit to demonstrate my point in this thread. Note that it is not exactly the same to use `curry` on your functions than to do it manually, because `curry` will still let you pass more than one argument at a time, so it is more flexible in practice.
Just write a last() function and relax. 
try BakeJS var Bake = require('bake'); Bake.breakfast({ connection: { name: 'loopback', adaptor: 'loopback' }, cook: function() { make_sandwiches(2); } }).start(); 
Due to my mechanical skill being none i would kindly ask someone if they could help me fix my car. just the engine e.g. i turn the key and the engine turns on and i can drive around obs only the engine to work no need for a tire change
[Here you go!](http://lmgtfy.com/?q=I'm+stupid,+lazy,+and+complacent.+Write+code+for+me,+monkeys.) Hope this helps! :)
Would you really write unit test for this simple method? Would you write unit tests for all those three functions in example #3? As you can figure I'm not to fond of unit tests but also very curios how you think about this situation. In my opinion there needs to be more complex logic before I write unit tests.
I made a JSFiddle. http://jsfiddle.net/1d4ksc1a/4/
but you end up using a function call which is expensive, and you create a new array
Thank you :D 
Nifty way of doing it.
I'd go for method 3, though I'd write the functions differently (ex. currying a function that can return undefined is not a good idea). I'm talking about the overall approach here. My reasoning (and some of this is subjective I know): * If this isn't being called hundreds of times a second then performance takes a backseat to readability, maintainability and re-usability. I'll gladly sacrifice a few cycles per second to improve any of those things. Of course none of those are mutually exclusive, you can rewrite the code in Method 3 to be a lot faster than what's written in the OP without losing any readability. * Each function is short, has a descriptive name and is easy to understand at a glance. When you're working alone maybe this isn't so important, but when you're working on code with 10 other people contributing it makes the whole process *much* easier. See [Clean Code](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/) * You can easily reuse parts of the algorithm in Method 3 (eg. isShortMessage could be part of an if statement somewhere). The other 2 methods solve one problem and one problem only. If you suddenly find you need a function like isShortMessage somewhere you're either left duplicating code or rewriting those functions to make them more generic. * Method 3 is easier to debug. This is a pretty minor point and it's somewhat nullified by the function currying at the end, but it's something to think about. 
You are calling this guy lazy?
Remarkable demo :)
 function getShortMessages(messages) { return [ for (u of messages) if (u.message.length &lt; 50) u.message ]; } :)
You don't have to tamper with the prototype if you don't want to, just add a method to the array you're working with and be done with it: as a `last` method: var sample=[1,2,3,4]; sample.last=function(){return this[this.length-1];}; sample.last(); // ==4 or alternatively as a `last` get property: Object.defineProperty( sample, "last", { get:function(){return this[this.length-1];}, } ); sample.last; // ==4
I haven't tested it, but I don't see why not—the middleware calls next() and supports stacking. If you want specific info about the session data for each socket, you can attach it with the socket#monitor() method that monitor.io creates.
Thank you. OK, next: When is Object.defineProperty first available? What version of Javascript? I could just google this, I guess, but you seem to be so good at explaining. 
The latest script at http://lihimsidhe.com/web_systems_and_services_1/javascript2.html looks like it'll do the job (well the greetings say the wrong time of the day, but that's the easy fix)... except when the current time is 12:00-12:59, or 18:00-18:59 when it will print nothing. But if points 3, 4 and 5 are to be taken literally, this fits the bill. I suspect however, what points 3, 4 and 5 should say is: 1. as is 2. as is 3. Prints "Good Morning" if the hour is greater than or equal to 0, and less than 12 4. Prints "Good afternoon" if the hour is greater than or equal to 12, and less than 18 5. Prints "Good Night" if the hour is greater than or equal to 18, and less than 24. This would not leave gaps (and is more akin to the accepted tradition of 12am through to 11:59am being morning, 12pm through to 5:59pm being afternoon, and 6pm through to midnight being night time).
Could you describe how you handle the rendering of so many items of arbitrary size? Are you using some form of virtualization with a large mostly empty div for system scroll? Or something else? 
how will you access them? do you have a way of knowing the file location?
&gt;&gt;"Plus, I don't have to justify myself Of course you have to justify yourself. Of what use to anyone is an unjustified opinion? The point of sharing is to add something other than "personal preference". Who should care what your preference is, if it's not justified in some way? It's the definition of useless. &gt;&gt; Coffeescript doesn't add anything at all I'm sorry, this is a plain stupid statement. Objectively stupid statement. When did you last check what coffeescript's features are? This is not about coffeescript being great, it's about not being as useless as your personal preference is leading you to believe.. &gt;&gt; But be aware that there is a decent chance that it won't be around in 5 years except for legacy support. Pointless speculation, delivered as fact. Don't tell me... it's a gut feel? At this point, I'm just frustrated with this kind of logic. You say absolutely nothing based in reason, vomit over various topics with a "feeling" about how it doesn't offer anything (likely having not even used it) and then you tell me you don't need to justify yourself... Brilliant.
not sure why anyone would downvote this. Looks like a good resource for beginners, and I dig the simple index layout. Nice work /u/hmkcode
Looks like a very concise cheat sheet for jquery coding.
What good is a well-typed response without any clear reason? seriously? This was exactly my point.
Nothing gets me going like a nicely formatted JSON object. This just grinds gears. 
Uh, the filter callback returns a boolean. .filter(function(message){ return message.message.length&lt;50 })
maybe you should start by trying to identify what your "glue" is and what exactly makes "their" code testable and maintainable etc. It feels like you're only seeing the problem, but aren't actually trying to fix it be getting more knowledgeable (for example)
It was added in ES5 and is supported across the board for modern browsers (IE9+): http://kangax.github.io/compat-table/es5/ IE8 only partially supports it, as you can only use it on DOM objects... go. figure.
I think he was trying to contrast the imperative nature of writing something within, say, a for loop against the seemingly more declarative map/reduce/recursive approaches which in turn make writing code that doesn't mutate state much easier, which in turn (bear with me here) make function composition seem easier as you can trust the code you are composing with to not leave your application in a mangled state. Again, all of the above is subject to actual implementations of said methods. It's as easy to write a shit map predicate which behaves differently based on some internal state as it is to write weird/magical functions that do all kinds of internal magic within loops using some internal state. Just my $0.02. 
learn design patterns. 
My issue is that I want to be more knowledgeable but I don't know where to start.
(vs implementation details)
&gt; How do I change from a decent JavaScript programmer to a great JavaScript programmer? Drop Javascript. Ahem, no, I don't mean that. I mean, drop it from your perspective on the problem. Change the question to: &gt; How do I change from a decent programmer to a great programmer? What you need to learn goes beyond Javascript. It's a way of thinking, of approaching, analysing, managing and solving problems. You need to learn about those things. How to analyse a problem, how to divide it in parts, how to structure the relationships between those parts, how to think about the problem at different levels, as a whole and as each of those parts, how to abstract and how to simplify and a lot more. You will find more useful information about those topics if you don't tie them down to a particular language.
Learning Javascript frameworks such as Angular or Backbone will help you here. Both frameworks encourage you to structure your application according to popular design patterns like MVC, go through the official tutorials and look at examples while actually thinking about how and why the applications are being structured and built in the way they are. One article which really helped me is Brain Ford's post about structuring large-scale AngularJs Apps: http://briantford.com/blog/huuuuuge-angular-apps This should hopefully be enough to get you started.
Can you remember how long ago it was? Can you remember any distinguishing words such as '2.5D' that appeared in its text?
2 things: 1) Inside your question are statements that answer your question (my code just kinda looks thrown together/I want to be able to conceive of a large scale app) I would focus on those immediately, since they seem to be the easiest answer to your problem. 2) It sounds like your question is really about peak performance, and learning curves. There's a ton of good books out there such as the art of learning, and some of the Tim Ferriss stuff. I would actually read up on athletic peak performance too as a parallel. Specific to programming: Surround yourself with people that are better than you (and figure out how they are better than you and beat them at it), Read up on design patterns, Start doing time trials to speed up your process (Leads to an understanding of the short cuts you take), Take on projects that force you to be better than you are at specific activities, figure out what you are missing in your body of knowledge and tackle each concept to mastery, Take on students (teaching creates principle based knowledge), Find a project competitor (open source project) and make a better project than them, Study creativity, learn another programming language &amp; translate things that are in javascript over to that language with as little loss as possible, Help out another open source project, write articles that document specific skills (since we all learn by reading those articles), focus on perfecting small chunks of code or modular code, take on projects where you spend double the time to make sure that the code is as beautiful as possible, go and master something unrelated that you could plateau at, break through the plateau, and learn from the experience, start tracking your activities on a project and figure out ways to make yourself more efficient with commonly repeated items, and lastly =&gt; read everything that you can get your hands on related to what you want to learn. Keep reading until you can only find one or two nuggets of new stuff in well written books, read until you find errors that people wouldn't find... read until you know what the best books/ articles are and can explain why they are the best. hope this helps
If you're not unit testing yet, that'd be a great way to improve. Focus on testing first (TDD), that way your code will be testable. And if your code is easily testable, it most likely will be well structured with clearly defined interfaces.
Browser vendors may choose how to handle DOM calculations like `offsetWidth`, and I believe it comes down to eager loading vs lazy loading. If you're trying to optimize for browser performance, then eager loading by recalculating all the calculated properties each time something might change may be too slow. Lazy loading, or calculating on first access, might be overall better for performance, which is my guess as to what browser vendors chose to do. With that said, lazy loading `offsetWidth` might not be as simple as fetching a previously stored value. If there are DOM operations scheduled to happen, the DOM must be repainted before returning the value. For example, if you set `myElement.css.width = '100px';` and then ask for `myElement.offsetWidth`, a repaint will be necessary to return the correct value of `100`.
your comment made me feel like i was sitting at a table with a Sicilian in a battle of wits.
Yup!
Hi, We didn't do anything concerning the rendering of the items, we let the browser do the job.
the better part to me is that you could just as easily go `{ foo }` to `{ foo: foo }` if people were writing in ES6 and then "converting" to ES5 (I don't really see that as compiling...)
I (and I believe many others) subscribe to /r/javascript to learn more about a language we use in our daily employment. Please don't pollute this resource with image spam. OP, I'd really appreciate if you removed this and put it in /r/programmerhumor instead.
Once I make something that works go through and clean up the code. I started to do this and as I do it more I notice my.self writing cleaner code from the beginning. 
184k results, hilarious! 
Lighten up, it's just a bit of geek humor. Gave me a chuckle in my otherwise busy day at work. 
This is exactly the thing I needed for my own blog system :)
I fully support geek humor, that's why I'm subscribed to /r/programmerhumor. But this is my serious javascript sub, and I think there are others who feel similarly.
This hammer argument is pretty weak. I can make the same argument with `goto`, as Crockford does -- "It's an essential feature, I have to have it, it is how I express myself [...] It took out a generation to figure out that `goto` is a bad idea" -- My thoughts. 
You reminded me of a talk at JSConf 2013 that really sticked to me. Have a look: https://www.youtube.com/watch?v=v0TFmdO4ZP0
learn to harness the power of npm!
Try to learn another Oop language. I became so much better at javascript after learning java. 
Read *Code Complete* - it will teach you the programming concepts that will shift your perspective while you code so that you end up writing well structured and clear code. Was a life changing book for me, and I'd recommend to anyone that has at least a year of programming under their belt. 
Learn about the fundamentals of the language. Do you really know what prototype does? Variable hoisting? Methods vs. properties vs. variables? Host objects?
Thanks! Are there any good resources that will help me in this? 
Is a sacrifice that I am willing to make.
Another good thing to do is to learn more languages, especially languages with different paradigms. E.g. spend some time with Java, C/C++ or something like Clojure. This will greatly improve your general understanding of programming principles, which will help you to write better programs in any language. 
I enjoyed the pic, stop being a twat
I'll let votes decide if there are people who agree with me. I've seen subs that I relied on for information become flooded with images because they're so easy to upvote while scrolling down the front page.
Sure, there are a whole bunch of tools for this available, Traceur, `esnext` or many others. I believe the specific term is 'transpiling', using a [source-to-source compiler, transcompiler, or transpiler](https://en.wikipedia.org/wiki/Source-to-source_compiler), as a subset of compilers in general.
THIS -- patience and practice.
Best thing I've found is to have co-workers who are smarter than me. I've worked with the cliched "rockstars" (guys you read books from and see at conferences) and you can really up your game in that situation.
Really? I have the exact opposite opinion. (I actually think it's worse than jStat, which is pretty bad.)
I'd say to look into open source projects. You can get a feel of how it is working on that large scale app, and you can see how other people do their code. For cleaner code I suggest codewars.com. After you complete a challenge you get to see how other people do it, many of the results are mind blowing
Get your code reviewed on http://codereview.stackexchange.com/ . You'll get critiques from other programmers about what can be improved with your code.
What are some examples of things you don't like?
Write, read (what you just wrote and others' code), refactor, rinse repeat.
+1 to this. Would also make sense to use some better module loader, some which supports actual commonJS module syntax, like [SystemJS](https://github.com/systemjs/systemjs)
I recently felt like I had plateaued in my Python programming skills. What I did about it was to start Free Coding daily. I started a github repo and try to commit to it with a new script every day. https://github.com/mfwarren/FreeCoding it's been a good driver for me to dig into corners of the language that I don't often get to use. Starting from a blank file each day gives you the chance to create a useful command-line script, or implement basic algorithms and abstract data types, play with a new library, or just test your knowledge. 
That's intentional - the function you write for filter expects a boolean to be returned: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
it is steeper than Backbones, but in my experience orientation in Angular app codebase is much easier and quicker compared to Backbone. So investing time into learning the framework pays off.
I'd suggest to work on analyzing and designing before coding. Analysis is about breaking down the problem (the use cases the software needs to fill). Design is about building a solution out of components, assigning responsibilities to those components and identifying their relationships. My rule of thumb is: if what I'm about to code is complex enough that I have no idea how I'll piece it together, I'm not ready to code yet. A whiteboard or a sketch pad and basic diagram drawing skills are really useful. The point isn't to draw a blue print, it's to sketch out ideas about how to articulate your components and to gain insight on the hard parts through visualization. The challenge is structural (how many classes? whose method is this? composition or inheritance?) and dynamic (A calls C, which calls B, which asynchronously calls X… is this optimal?). I've really enjoyed [Larman's book](http://www.amazon.com/Applying-UML-Patterns-Introduction-Object-Oriented/dp/0131489062) on Object-Oriented Analysis and Design. The title sounds much more narrow than the actual subject matter.
There are about a dozen great, classic books to help in improving your programming chops. Some good ones to start with: * The Pragmatic Programmer (Hunt &amp; Thomas) * Design Patterns (Gamma et al.) * Coders at Work (Seibel) * Elements of Programming Style (Kernighan &amp; Plauger) * Enterprise Design Patterns (Fowler) * Refactoring (Fowler) * Structure and Interpretation of Computer Programs (Abelson, Sussman &amp; Sussman)
Find an active IRC channel and help people with their issues. You'll be exposed to all kinds of things you'd never seek out on your own. And in doing so you'll develops you're communication skills as well.
If you want to stick with Javascript, but want to learn how to structure things, then you should look into [Javascript Design Patterns](http://addyosmani.com/resources/essentialjsdesignpatterns/book/). It was an eye opener for me.
[The C Programming Language](http://www.amazon.com/The-Programming-Language-2nd-Edition/dp/0131103628) is a good one too. Although it's specific to learning C, reading through it and doing all the exercises is something every programmer should do at least once. Also, [Code Complete 2](http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1414526669&amp;sr=1-1&amp;keywords=code+complete+2).
Thank you! This book looks awesome, I can't wait to sink my teeth in it.
I've been playing around with React lately and I must admin that I like the approach it takes. Angular and Ember complicate things a lot. This is nice. The only thing I don't like it having HTML inside of the render blocks in Components (or now Elements). I guess that's because it's been drilled into us that mixing JS and markup is a bad thing.
It has also been tailored to be easily testable. I agree, the learning curve definitely pays off.
so i agree that there are some coding best practices that you should use regardless of language, like separation of concerns, continuous testing and all of that. but none of that addresses the question i have for you - obviously if you have a good testing suite, then if a refactor fails, it will be caught by unit tests; but is that really how you do it? i.e.: * global search for the method name * manually determine from each match whether it's the method you're looking for, or just a method with the same name * manually remove a parameter/parameter property from all the invocations * run your unit tests * see if/where you accidentally refactored the wrong method invocations * run your unit tests * etc? 
FWIW: I've been using Ember for the last ~1.5 years and its far and away the best javascript framework experience I've had. I heard Yahuda Katz give a talk about ember's future recently, and I only heard good things for the framework. They're adopting concepts from React like eliminating controllers and rendering through shadow dom, both of which are fairly big and exciting. Its a great time to learn and use Ember.
Using JSX is optional in react. It simply makes things a bit more readable for some people.
Please read up on reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. **Consider this your only warning.** If you continue to post _only_ your site, we'll be forced to take action. Thanks for your understanding.
Please read up on reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. **Consider this your only warning.** If you continue to post _only_ your site, we'll be forced to take action. Thanks for your understanding.
I can highly recommend Ractive! It's a bit easier to get into than React, and it can handle a surprising amount of complexity. I've combined it with Reflux.js and a few microlibraries (for routing, etc.) and it works like a dream.
The comparison to "goto considered harmful" is apples to oranges, no one makes the claim that goto "limits the ability to build higher abstractions", in fact, the argument is based on goto being a necessary operation that should ONLY be used to build higher abstractions. Loops are an essential part of structured programming. They are a building block for higher abstractions. You can't implement map or filter or any other kind of collection without some kind of "for each item" operation.
AngularJS was developed internally at Google for the purposes of refining Google's frontend, and all of Google's concerns about AngularJS are very likely going to be how best it will suit their needs first. If the community is dissatisfied with how they have been treated/cut out of the process by Google, then they should be forking the code to make a community-friendly version, that works better for everybody else's needs. After all, that's part of how open source software works, and why it's a successful model overall.
Sure, that's reasonable. Loops don't have to mutate state though. In this case, the loop is the 'lower order' operation that lets us combine both filter and map operations into one pass on the collection, which improves efficiency and reduces intermediate data. Sure, we could build a higher level 'map and filter' function and then use it to solve this problem efficiently. But you can't implement the combined function using only map and filter, you need the more basic operation to build with.
Here's a nice pattern which helps me. for (var k in object) { object[k](arguments); } There are variations on this which can be done, but the basics are this; you create object which has methods. You can create any number of methods here and they will be looped through in the for loop. What is good about this? You can create the methods in other files: object.method.js and this leads to some disambiguation of code and increases organization. This is one tip of many. Using objects and methods in general is good practice and will get you to start thinking in a more 'modular' way.
&gt; You can't implement map or filter or any other kind of collection without some kind of "for each item" operation. Sure you can: var map = (f, [x, ...xs]) =&gt; { if (x == null) return [] return [f(x)].concat(map(f, xs)) } var filter = (p, [x, ...xs]) =&gt; { if (x == null) return [] if (p(x)) return [x].concat(filter(p, xs)) return filter(p, xs) } It just happens to not be very efficient in JS because we don't have TCO yet; once we get it you can convert non-tail calls to use an accumulator. Proper tail calls in practice means that you don't need loops anymore. You're still missing my point though. We are not discussing whether loops are valid buildings of abstraction or not, but whether there are better building blocks, and I say yes, there are. My point is that thinking of loops is "considered harmful", because you are limiting your abstractions to merely series of steps; you can't do equational reasoning with loops.
I'm happy to be wrong on this, good use of rtfm!
&gt; But you can't implement the combined function using only map and filter, you need the more basic operation to build with You do need I'd say a more "general operation", but that doesn't mean loops. Take a look at Clojure's [transducers](http://clojure.org/transducers) and [related](https://github.com/cognitect-labs/transducers-js) JS [libraries](https://github.com/jlongster/transducers.js). They abstract these transformations over any type of collection, and does what you just mentioned: &gt; operation that lets us combine both filter and map operations into one pass on the collection, which improves efficiency and reduces intermediate data. *Edit:* Add links
That was great, thanks for sharing! 
Loops usually increment/decrement counters. That is subtle internal state manipulation. Usually, loops have to maintain some state that is accessible in each iteration and affects the next iteration (the counter used by the for loop is an example). Map/reduce in javascript have state that they use too (the element, index and some array of your choosing are available to the fn you specify) but the state from one iteration doesn't affect another. This is quite useful. Don't get me wrong, each of these methods have their own uses. If I was writing performant code where memory was a constraint (as an example), I would most likely go with a for loop. But if I was writing basic units of a larger abstraction where I was keen on keeping my state largely immutable or if I was trying to do SIMD like data crunching, I would go with map/reduce (or their parallel variants even). Also, OPs usage of map is superfluous. For his/her needs, a filter suffices. Instead of returning "message" that matches the predicate, "message.message" can be returned from filter itself thus removing the need for the map (which doesn't really make sense, but then again I just glanced over the code and might have missed something). 
aka Appjet v2 ;)
React works best if you embrace it fully. I find it very refreshing to have everything concentrated in the code, makes things very easy to manage, and removing all that data-binding template dom cruft cleans up everything so much. I'm now looking into morearty, immutable.js etc) for immutable data, I have high hopes for that too.
I find myself plateauing at times too. It helps to look at what others are doing and decide you have some learning to do. I recently started a new job and am surrounded by the best coworkers of my career. It's unbelievable how this sort of thing can spur you to improve so quickly. Same deal with conferences. You should always be taking something home from conferences, something besides memories of getting drunk with people. Dig into stuff you don't understand yet - for example, by my estimation more than 80% of JS developers do not actually know the types in Javascript. You might argue that if that many people don't know it, it's not important. True enough, but like, read the spec of the language you use every day. Just read it! Do you know how the event loop works? The thing that runs all of your code that you write? http://vimeo.com/96425312 Things like this help -- a good test-driven assessment of JS knowledge: https://github.com/rmurphey/js-assessment Dig into what you don't know, or what you sorta know but can't completely 100% explain backwards and forwards. Do you know the difference between a function statement and a function expression? Can you explain hoisting? Do you have closures down cold? etc Look at general (ie not exclusive to JS) programming practices. Learning functional programming made me better, and there are tons of books and resources for learning that stuff nowadays. Javascript Allonge is one. Learn to write testable code. Testing is its own world within software development. Once your tests are working, refactor the shit out of your code until its awesome *and* you know that it works. I promise that there is a lot you don't know yet. Because that is true for everyone, even the people you think are so awesome. I promise. It's important to learn, and never stop learning, and never lose the desire to learn -- but it's also important to realize that the people you think are so smart have just been doing this awhile, and there's nothing really that special about them. Just time + effort. Nobody knows what they're doing. Nobody.
TCO usually converts tail call recursions into a flat loop which is (at times) even unrolled quite a bit. This is why TCO-ed code doesn't overflow your stack and runs in one frame (unless each iteration calls other fns and cause frame allocations for em). Just FYI. 
Both are equally important. They are just different strategies of handling a problem that requires things to be done iteratively (think math, not cs). At times problems are easier to represent recursively (Fibonacci series for ex) and at times its easier to represent a problem as a step by step iteration (for ex. an algorithm with 4 different steps at the end of which you get a result). 
You probably pressed the phone icon next to the loupe icon http://i.imgur.com/nC3DFcf.png
In my experience (&gt; 25 years programming) it will also make you appreciate what JavaScript is, what it does for you, and how it solves problems unlike others.
Usually while I'm learning new things, it helps me a lot to look at other people's projects and code (hopefully code you can trust has been written well). You can pick up a lot of basics and common practices by learning how other people approach a problem. Just go through and make sure you know how it works, inside and out. And when you feel comfortable with the syntax, start working on personal projects and learn from api and other resources as you need it.
I'm aware of how it works, but the functions above are not tail recursive, so you'd have to convert them to use accumulators. In any case, we can always use trampolines, but it is [not ideal](http://www.reddit.com/r/javascript/comments/2jlp7r/recursion_in_javascript/cld5z6v). I reckon some smart compilers should be able optimize such non-tail calls too. No JS environment implements TCO yet today sadly.
This? http://codecanyon.net/item/jquery-interactive-svg-map-plugin/full_screen_preview/1694201
Excellent list, I would perhaps go with less design pattern books (most of those aren't directly applicable to languages with first class methods and functions) and add *[How to design programs][1]* as a perhaps more approachable and practical replacement or complement to SICP. (How to design programs is truly amazing) [1]: http://htdp.org/2003-09-26/Book/
His use of map is not superfluous. You cannot return a different value with Array.prototype.filter than the thing you are filtering. The callback either returns truthy (keep this item) or falsy (do not keep this item). You'll see on line 4 of Method 1 they "return message.message;" just as you described which if it's an empty string, undefined, or null will be falsy and not be kept in the resulting filtered_messages. But, the call to map is still necessary to get a list of different objects than the ones that were originally filtered.
Definitely look into learning the fundamental algorithms and data structures; saves you a whole heap of reinventing the wheel!
The front page of www.meteor.com has 6 videos about featured production apps (aka "large apps")
Forking is not always a good option. There is a lot of options between an open source project that is not involving the community and the community forking. People still trust Google to deliver which means Google can get a pass for behaving in ways other companies would not which is what OP is saying. This is just a call for greater community involvement and transparency which is fair enough.
My assumption is you may be fairly new to programming since you tagged this as *JavaScript*... if not forgive me and maybe ignore what I have to say. **References** have been around since the stone-ages of programming (i.e. Lisp/Fortran). Even before those languages, you could "reference" memory addresses in Assembly code. Even languages that do not support references, usually have some implicit use of them. So it's not just JavaScript. It's one of the fundamental concepts of computer science. A reference is distinct from the data itself. It is a link that gives a program access to a particular piece of data in memory. When you say: var a = {val: true}; var b = a; `b` was assigned the *reference* which is `a`, not the *value* of `a`. So, if you delete `a`, `b` will still point to the object in memory which is `{val: true}`. The same is true with properties on objects. var a = {val: true}; var b = {}; b.val = a.val; delete a.val; console.log(b.val); // true On line 3, I assign `b.val` to the reference which is `a.val`. They both point to the same piece of memory. If you deleted `a.val`, `b.val` will still point to `true`.
I'm dumb sorry. I did watch the initial vid at least
1) Learn the common design patterns. Great code isn't written by genius programmers. Great code is written by people who know the patterns and when to use them. Good design patterns are language agnostic, but [here's](http://addyosmani.com/resources/essentialjsdesignpatterns/book/) a great JavaScript design pattern book since that will be most familiar. 2) write code that is part of a large code base. It's worlds different than medium and small projects. 3) read [JavaScript Allonge]( https://leanpub.com/javascript-allonge/read) [Edit] I haven't read this one yet, but it's the companion to JavaScript Allonge, and the author is amazing, so I can also recommend [JavaScript Spressore]( https://leanpub.com/javascript-spessore/read)
Lol its down right now http://www.downforeveryoneorjustme.com/Meteor.org
I was heavily downvoted recently for pointing out that I hadn't seen much hype for a while about meteor ...despite being a fan of the project. Yet, 6 hours into this post and there are like 5 comments here. 
Yes, positioning elements on the page is a common and easily accomplished task in javascript. I can't really provide more input though without more information.
I just read it the jquery codebase last week and thought it's modularity was wonderful. 
Dude, you can't say that, /u/recompileorg said it is one of the worst codebases.
Really excited to try this out. Have played with it a lot recently, and I am really optimist about what can be done with Meteor.
&gt; I guess that's because it's been drilled into us that mixing JS and markup is a bad thing. I'd like to hear someone say that after working on any of the large shitty selector-based projects I've been employed to work on. You'd have to implement a trivial change, see exactly the line of HTML that needs to be changed, ...but then credentialize in every nook of the JS files to ensure you're not stepping on the feet of some code. Like breaking a sibling selector on line #1,544.
Pretty much. Hasn't bit us yet. 
It's meteor.com, not .org
I'm dumb again. ... it has been a shit day if that's any valid excuse lol
In method 3, he maps first then filters... if the messages list is 1000's of items long, and there are 3 short messages, you're gonna be iterating over them all twice... It makes more sense to filter then map unless a specific case calls for me to map first but here, the map is just pulling a message out of the item to be returned so no need to do it beforehand. 
/r/learnprogramming might be a more appropriate sub to post this in the future. anyways, it's impossible to tell what you're supposed to do without the instructions from the lesson 
Ill move my post to learning programing form now on. Below are the instructions for the lesson. Your second "for" loop Okay! Last loopy step: add another for loop, this time inside the body of your if statement (between the if's {}s). This loop will make sure each character of your name gets pushed to the final array. The if statement says: "If we find the first letter of the name, start the second for loop!" This loop says: "I'm going to add characters to the array until I hit the length of the user's name." So if your name is 11 letters long, your loop should add 11 characters to hits if it ever sees the first letter of myName in text. For your second for loop, keep the following in mind: First, you'll want to set your second loop's iterator to start at the first one, so it picks up where that one left off. If your first loop starts with for(var i = 0; // rest of loop setup your second should be something like for(var j = i; // rest of loop setup Second, think hard about when your loop should stop. Check the Hint if you get stuck! Finally, in the body of your loop, have your program use the .push() method of hits. Just like strings and arrays have a .length method, arrays have a .push() method that adds the thing between parentheses to the end of the array. For example, newArray = []; newArray.push('hello'); newArray[0]; // equals 'hello' Instructions Okay! Go ahead and add that second for loop inside the body of your if statement. 
I am equally outraged
This doesn't sound like a good reason not to fork. It sounds like you just want people to trust in Google, something that I'm sure the GWT community would agree with.
Agreed. This is the case with all of the open source projects I can remember Google backing, except Chrome, which was more about increasing modernization rates because ie and ff were lagging. It's just like Go - if it's useful to Google, it will happen, otherwise, deal with it. 
You can set up a listener for a "request file" event, and then have the client send the name of the file in the event data. For example: Server: Socket.on('request file', function(data) { fs.readFile(data.name, function(err, data) { if(err) throw err; allSensors = data.toString().split("\n"); Socket.emit('receive file', allSensors); }); }); Client: Socket.on('receive file', function(data) { // save data as file here }); Socket.emit('request file', {name: 'fileNameFromList'});
Oh nice, I haven't run across this one yet. Thank you! 
Js is available at github @ https://github.com/pricelessbrewing/Pricelessbrewing.github.io/blob/master/Calc/PricelessCalc-Imperial.js I need to take lines 52 and 54 out of comments. Need to make math.pow(base,exponent) work, in whatever syntax is required. I could always do longhand, for example 10^-6 would be .000001 but that would get messy fast
Thanks for that link to that svg + famous.js example, that blew my mind and just clinched my interest in famous.js!!!
Yup that's all I was asking, I even said I'm probably just using the wrong syntax or something silly. My usual problems are punctuation and capitalization. Hopefully that'll work, I'll try it in the morning. 
Also, you **can** use this notation `4.13643e-16` for float literals. [try it in your console](http://i.imgur.com/AIybr7D.png)
I tried it earlier in firefox web console, it said something like e was not defined. 
I haven't seen anyone mention this yet, but if you're looking to truly understand the JavaScript language, then try writing a JavaScript interpreter for yourself. You'll gain a deep understanding of the language, which will give you a new perspective on any subsequent JS projects.
You "make the button auto click"? You're still doing it wrong, but slightly less wrong than before I guess...
you probably had a space before it
Try this ....a detailed tutorial on Javascript Array http://www.corelangs.com/js/basics/arrays.html Kerry
Does anyone have any thoughts on angularjs vs meteor?
Sure, people would benefit, but i think it might be a bit too much work for one (especially since i already have a job). But i've proposed to the Yeoman project a way to easily create your own scaffolding. Not sure how that will end, but still something that might be easier than to get going from the start. I do feel there are still things missing for getting your project up and running quickly, but i'm not sure if i'm the right guy to get this going. Mostly because i'm not very deep into Node (more the modules that are used on top of it).
1.0 is released!!!
 /*jshint multistr:true */ // Declare variables var text = "For the help, iLel"; var myName = "iLel"; var hits = []; for (var i = 0; i &lt; text.length; i++) { // This searches the text letter by letter if (text[i] === "i") { // If the index(i) of text is the letter i for (var j = i; j &lt; (myName.length + i); j++) { // Loop through the letters of myName if myName is found hits.push(text[j]); // Add those letters to the array // console.log(text[j]); This shows you what it does } } }
If you were to accept to do this for my website, what would be your fee? :D It's easy, I understand that, but it is not working for me. I have no idea what I'm doing wrong. I would pay if necessary. 
You just need to calculate the offset and scroll the page/container appropriately or move the image to the center. Generally speaking, to center an element in a container, the formula you want is.. element.top = (parent.height - element.height) / 2 element.left = (parent.width - element.width) / 2 If you want to move the viewport instead it'd be: viewport.top = element.top - (viewport.height - element.height) / 2 viewport.width = element.left - (viewport.width - element.width) / 2 EDIT: Added viewport math.
Do you want to learn Java or Javascript? These are completely different languages..
Javascript. Sorry for my mistake.
It's hard to fairly compare the two. Angular is a client side framework. If you have an existing server side application with a REST API, then you would want to use Angular or another client side framework to add dynamic client functionality. Meteor is a full stack framework. It is a fully integrated solution, encompassing both server and client. You could use Angular instead of Meteor's built-in client templating system, but that's a bit more convoluted in my opinion. Meteor works just fine out of the box. The Template&lt;--Helper&lt;--Data&lt;--Event component system just makes sense. It's declarative, doesn't require mixing of application logic into HTML attributes like Angular, and just makes it easy to reason about your application. It's also very easy to learn, unlike Angular, but less flexible when it comes to your server framework (obviously) and database (right now MongoDB is the only officially supported DB, with postgres and redis seeming to be on the eventual horizon).
Removed, please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
You can do this in node.js however this seems suspiciously like a 'do my homework for me' kind of question.
If you want to have normal file-access etc you need a server-side Javascript platform like [node.js](http://nodejs.org/). You can find a lot of simple programs for that to learn from, e.g. [nodebeginner](http://www.nodebeginner.org/).
It's not, because i have my script doing that thing but made in autoit, i just want to see differences in implementation in javascript. Then i could start learning about it using this one as example.
Alright, well it's actually very complex to do (from scratch). You're better off starting with something a lot simpler.
Well, maybe you are right, but for now i started with creating files using node.js - it's really simple and intuitive, i think i can learn things pretty quickly.
Why not just use [jsfiddle.net](http://jsfiddle.net/)?
They are confusing HTML5 and JavaScript.
Take a look at this: http://stackoverflow.com/questions/11692835/overwrite-a-line-in-a-file-using-node-js
In your case, by your own admission you are confident enough to take on anything. IMHO, what I think you are missing is an understanding of patterns. Learn patterns, next time you have an assignment think what patterns could be applied and implement them. Please don't discount what I'm saying, take a look at some JavaScript patterns books (there are plenty of them). You'll start to understand the common problems they were invented to solve thus, overnight giving you the insight to produce code that others look at and recognise as good coding practice, more maintainable and structured; in short to quote you "code that creates a coherent structure of the entire codebase instead of just implementing stuff." Good luck! :D 
By example... Fizz Buzz in one line. fizzbuzz = (['fizz' unless i%3] + ['buzz' unless i%5] or i for i in [1..100])
Use _this = this instead. every company that has a javascript guide says this is bad pracice because you can attach methods and properties to the window. Which will always work but window is the last lookup in the scope chain. Also kyle simpson covers this in his "new rules" video. Airbnb lists it as a bad practice. Coffeescript does _this = this as well. Its going back to avoidance of global pollution. Im not saying you cant do lexical scoping/tokenizing thats what every javascript compiler/engine already does for you behind the scenes. Self = this is almost like doing num = Number or Object = {};person = Object. On another note you can use .bind, .call, or .apply in this scenario.
I'm pretty sure you'd like Blub if you tried it.
After this thread I wrote an article on the subject: http://www.reddit.com/r/javascript/comments/2knvod/understanding_react_and_reimplementing_it_from/ Thanks to all the redditors in this thread for the precious comments, resources and links.
* cssdeck.com * codepen.io * jsfiddle.net * jsbin.com * ... I could go on and on and on .... 
I've seen this argument made a lot, and let's be honest, any sane developer will want to use JSX. Even though it's optional, you'll be shooting yourself in the foot if you avoid it. Anyone concerned with 'mixing' HTML with JS should look into webpack or browserify when developing react applications.
The LiveScript extension to object literals is quite interesting, makes writing arrays of objects extraordinarily terse. someBooks = [ * title: "The Trial" author: "Franz Kafka" * title: "(On Lisp)" author: "Paul Graham" * title: "The Electric Kool-Aid Acid Test" author: "Tom Wolfe" * title: "Island" author: "Aldous Huxley" * title: "Gravity's Rainbow" author: "Thomas Pynchon" * title: "Ulysses" author: "James Joyce" * title: "Heart of Darkness" author: "Joseph Conrad" ] It's a bit of a shame that LiveScript didn't get the popularity of CoffeeScript, as it has some excellent additions. 
Learning new languages will sometimes also make you better at the ones you already know.
HTML5 is the buzzword everyone uses now. I just wish there was more discussion on this. I want to see if it's legit. If it is I am so funding it. There has been a rash of abandoned projects lately.
Sure, I get it, but even lazy.js has an each function, which is just a loop. I'm not saying loops are the only thing you can ever use, just that their existence in a language doesn't limit you ability to express anything.
This is the advice I was looking for. Use the same patterns _for real_ in several different implementations. Learn many frameworks. In many languages. Clean up code. Setup projects from scratch. Always ask if the setup makes sense, is it easy to understand where stuff should end up? I.e. Work hard and try hard all the time.
A lot of people have mentioned that you should learn design patterns. Don't. The people I've seen who dive deep into design patterns start littering their code and interfaces with jargon-heavy java-esque design pattern speak and their code suffers for it. Instead, learn to think in modules. Use tiny packages from [npm](https://npmjs.org) and skim the source code of each package you use for new ideas. Start to organize your code into small self-contained logical groups and then publish those components to npm where it makes sense. When you hit bugs or limitations in other libraries, send a pull request. Work through some of the workshops on http://nodeschool.io/
To put it very broadly, Meteor is your front, middle and data access layer all-in-one solution, all in javascript (but you can use other reactive frameworks for the front-end part if you don't want Meteor's templating library). Currently it is NOT database agnostic and relies on MongoDB to talk to its "Collections" - data access objects. Angular is your front-end that can plug into X and Y for your middle tier, which can be anything (.NET, flask, express, et al). Your database can also be anything. 
I'd say it's possible within a certain scope. Off the top of my head, I remember an exam question that was basically: "Write a Singleton class in language X". You can do the same with observer, factory, etc.
If the file is small: var fs = require('fs'); fs.readFile('data.txt', 'utf8', function (err, src) { var lines = src.split('\n'); lines[2] = 'whatever'; fs.writeFile('data.txt', lines.join('\n')); }); if the file is bigger, use streams to avoid buffering the entire file into memory. Then you'll want to write to a temporary file location and rename the temp file over the original file in case the script fails somewhere and leaves a mess: var fs = require('fs'); var through = require('through2'); var split = require('split'); var temp = fs.createWriteStream('.data.txt.temp'); temp.on('finish', function () { fs.rename('.data.txt.temp', 'data.txt'); }); var lineNum = 0; fs.createReadStream('data.txt') .pipe(split()) .pipe(through(function (buf, enc, next) { if (lineNum === 3) { this.push('whatever\n'); } else this.push(buf.toString('utf8') + '\n'); lineNum ++; next(); })) .pipe(temp) ; but this problem [actually sounds like](http://www.perlmonks.org/?node_id=542341) you want to persist, modify, and query some data to disk in a nice way. This is what databases are very good for, not text files. Populating a database from a textfile is very simple. Suppose we've got some data: 1234: aaaaaa e29q: bbbbbb 2f29: x9223x z57c: def123 now we can populate a database, in this case leveldb, using the first column as a key and the second as a value: var fs = require('fs'); var through = require('through2'); var split = require('split'); var db = require('level')('./data.db'); fs.createReadStream('data.txt') .pipe(split()) .pipe(through(function (buf, enc, next) { var m = /^([^:]+):\s*(.+)/.exec(buf.toString('utf8')); if (m) { var key = m[1], value = m[2]; db.put(key, value, next); } })) ; Now to print an individual key: var db = require('level')('./data.db'); db.get('e29q', function (err, value) { console.log(value) }); or to change an individual key: var db = require('level')('./data.db'); db.put('e29q', 'NEW VALUE'); and to stream out all the records, similarly to the original text file: var through = require('through2'); var db = require('level')('./data.db'); var r = db.createReadStream(); r.pipe(through.obj(function (row, enc, next) { console.log(row.key + ': ' + row.value); next(); })); and finally: $ node file.js 1234: aaaaaa 2f29: x9223x e29q: NEW VALUE z57c: def123 now instead of modifying the text file each time with individual scans, you can update the database with `db.put()` instead. This will be much more maintainable and scalable longer-term because you can perform operations on the data without scanning the entire input file every single time. Learn more: * leveldb: https://github.com/rvagg/levelmeup * streams: https://github.com/substack/stream-adventure * more workshops on http://nodeschool.io/
Let expressions have been used in functional languages for decades and we know how to use them correctly with functional scope. Consider scheme: (lambda (x) (+ x y)) ((lambda (x) (+ x y)) 5) ;;x now has a local "block scope" via self-executing lambda (let ((x 5)) (+ x y)) ;;syntactic sugar for the above function We can do exactly this in javascript: function (x) { return x + y; } (function (x) { return x + y; }(5)) //self-executing lambda let (x = 5) { return x + y; } //syntactic sugar This importantly prevents problems where a let somewhere at the bottom of a loop makes the entire block change scope. This may not be problematic in one or two person shops, but is a major issue when attemping to fix another person's code in a shop with 20+ js developers.
Really great comment. I mastered the JavaScript language years ago, and for a while I naively thought that made me a great JavaScript programmer. But then I started learning a lot again, and all of it has to do with principles detached from any language (though, often, the principles are championed by one language or another).
&gt; I've gotten to the point that I'm confident that I can implement almost anything -- given an infinite amount of time. Congratulations, you're a monkey. (... sorry, I tried to stop, I couldn't.)
You are great, thanks, i managed to do it alone (file is small) but this will help me to develop it further! Thanks alot!
I really wish Facebook would have chosen a different name for their UI framework. Whenever I see a post about "react", I have to take the time and distinguish if it's talking about the UI framework or reactive programming...
The angular team lost their fucking minds. Shit like this feeds into people's notion of js developers being immature and undisciplined. You can't just put an entire large thriving community on an island and then tell them there's no way to migrate off.
[Blaze UI](https://www.meteor.com/blaze) would be what's equivalent to Angular in Meteor. The Meteor guys themselves describe it as "reactive jQuery". It's simpler than Angular but not necessarily less powerful.
Happy to release it. Looking forward to your feedback. There is also angular-swing, https://github.com/gajus/angular-swing.
&gt; There are some breaking changes that are planned to be shipped with this new version of AngularJS, including **removing controllers, directives, and scope** Half-serious here: what's left then? I started investing a lot more time learning Angular recently because I imagined I would do a lot more in the future. Assuming this is true, why the fuck would I continue?
Got the powers working, thanks :)
As EcmaScript and HTML specifications change, so should frameworks. Any well-written code will continue to work- neither specifications are introducing backwards-breaking changes. Frameworks, on the other hand, should be willing to do so, otherwise innovation will be stifled. That is why (in my humble opinion) all the hubbub over the Angular 2.0 breaking changes is a bunch of nonsense.
Please read up on reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. **Consider this your only warning.** If you continue to post _only_ your site, we'll be forced to take action. Thanks for your understanding.
Please read up on reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. **Consider this your only warning.** If you continue to post _only_ your site, we'll be forced to take action. Thanks for your understanding.
Please read up on reddit's rules @ http://reddit.com/rules, specifically point #1 of rule #1. Our [guidelines](http://www.reddit.com/r/javascript/wiki/index) also have more information regarding promotion &amp; self-promotion. **Consider this your only warning.** If you continue to post _only_ your site, we'll be forced to take action. Thanks for your understanding.
Angular 2.0 is something you'd see when a separate group thinks they can do better. Google themselves decided to make a huge division in it's own framework with all these changes. I don't believe Angular 2.0 will ever be a thing. Angular 1.x will be too mature. Switching over to 2.0 will be a huge downgrade. 
Okay. Sorry about that. Won't happen again. I'll put together an informative blog post in the future describing the functionality of the site in more detail. Until then, the entire site is self-documenting and full of live runnable / editable / fork-able examples. If anyone has any questions about the architecture or design choices of the project please feel free to ask.
The problem is, it's advertising for a paid service. You should take out a reddit ad if you wish to advertise a paid service.
Okay, that sounds like a good idea. I will take out an ad. This is actually also an open-source project, so it's not just a paid service. We just launched the live site today, but there are links to our Github where users can setup their own private instances locally.
Open-source projects are welcome here, but I couldn't find an obvious link to the github repo -- I think [this](https://github.com/bigcompany/hook.io) is it -- although on that readme it says: "Soon, the source code that runs the live hook.io site will be open-sourced", and looking at that repo I'm not seeing anything substantial. Where is the open-source part of the project?
So far, I have open-sourced all of the sub dependencies used to create this project. I would recommend checking out these to start: [big](http://github.com/bigcompany/big) [resource](http://github.com/bigcompany/resource) [mesh](http://github.com/bigcompany/mesh) [mschema](http://github.com/mschema/mschema) The core of hook.io itself will be open-sourced soon. Perhaps a week? If anyone is interested in getting early contribution access feel free to PM me. 
Works in Firefox, too. (version 33, at least). Does not work in IE 9.
I wouldn't get too invested in a particular framework. Just make sure you have a good grasp of the basic data structures, algorithms, and native browser APIs. If you use [a package manager](https://npmjs.org), many of the features of frameworks can be obtained piecemeal from tiny packages for each feature which can help with avoiding the all-in commitment that frameworks tend to entail.
I think i am getting your point. Nonetheless, i think "High-level languages: HTML5 [...]" or "HTML5 or Python programming" are just wrong. You simply can't call HTML5 a programming language and speak of HTML5 programming. That's just wrong. But HTML5 as a buzzword should definitely be discussed. From my point of view it almost stands for modern web applications in general. And it surely is important regarding the possibilities of web apps. But it is not really the building block. There are plenty of technological trends in the web sector (Node.js for instance), which are totally important and definitely more interesting than just a renewed markup language.
I think the most common problem I've run into in doing this is CORS. once you solve that problem it's pretty strait forward. 
First angular 2 with breaking API, now this. What day is today, "break my favorite JS library"? Just kidding, this is probably good news. Really looking forward into some info on new API.
They seem to be going the other way around, and merging back the 1.x and 2.x branches into 3.x (vanilla and compat)
I think the migration from Rails 2 to Rails 3 was similarly painful and yet Rails 3 is here. Old apps can safely stay on 1.x
Moving to a new major version for versioning's sake seems a bit silly to me, but whatever.
Using an adjective in the name of the recommended version seems like an odd choice to me. If they think that people should use jQuery Compat, why not keep that as jQuery and name the jQuery Slim or something else to denote that it doesn't support every browser. My only guess would be that they really prefer the old-browser incompatible version, but recommend jQuery Compat to prevent people who don't know the difference from complaining when jQuery doesn't work "on the Internet Explorer".
Thank fuck. Good to see a big player take semver so seriously!
I don't see how they could have solved everything they're solving now by remaining on the current version system.
There shouldn't be much that breaks with jQuery 3.0, it's not a complete rewrite like Angular 2.0. The only reason for the big number change is that the now-worshipped semver says thou must increment the major version for any breaking change.
Yeah, I guess I misunderstood the post at first.
This is a good bikeshedding topic. Note that replies on the blog are all focused around this. Be sure to add your voice.
Thanks for the heads up. I'm not familiar with it yet, but it looks very promising. There is no Windows installation support yet and our shop is 99% Windows, so I'll just have to wait. 
Nice article, you explain these concepts very clearly.
So your complaint is that people are discussing version naming issues on your post about version naming?
I didn't say it was a complaint, it would just be easier to have all the feedback in one place.
I built http://www.photozzap.com using Firebase. I started out with ejabberd (XMPP) + BOSH, but converted everything to firebase when I realized how much smaller my codebase would be. I have a small nodejs backend to perform maintenance (delete images after a certain time, etc) but it doesn't play a role in serving pages to users. Overall I'm extremely happy. My code using Firebase + angular is extremely lean. The only downside is being tied to a proprietary platform, personally I don't mind given how well it works. 
So... A lesson in semantic versioning but not a word about what the v3 will change? How disappointing!
How soon is Angular 2 releasing? I'm looking for work at the moment as was about to pick up Angular and now I'm undecided on which version to learn.
No one knows, but people suspect 12 months. There is nothing to learn atm as no one really knows what 2.0 will look like. 
What?!? A whole new major version without a new programming language? I thought that's how it was done...
*gushes*
I'm not aware of any way to detect if an app is installed from a page. Not that there isn't, I just don't know how. Past that, it's pretty easy. http://fokkezb.nl/2013/09/20/url-schemes-for-ios-and-android-2/ covers both platforms.
Hmm, I'm not sure I understand your broad goals, but if you're looking for a JS lib that parses JS, then [esprima](http://esprima.org/demo/parse.html) is the tool for you. It even has [a version that parses most of the ES6 syntax](http://esprima.googlecode.com/git-history/harmony/demo/parse.html), if you want to use that.
The same way it distinguishes between `function` as a declaration and `function` as an expression. For example: function foo() { console.log('from foo'); } var x = function bar() { console.log('from bar'); }; foo(); // logs "from foo" bar(); // Error: bar is not defined In the code above, `function foo` is a function declaration while `function bar` is a function expression. In the function declaration, the name of the function can be accessed from outside the function, while in the function expression the name can only be accessed from inside. If the parser hits a stray `{` with no reason to believe it's an expression, it'll always assume it's a block statement, not an object literal expression. But if you give it a reason that it *can't* be a statement, then it'll treat it like an expression. // block statements: { } foo: { } // object literal expressions: ({ }); ~{ }; !{ }; +{ }; var x = { }; Basically, there needs to be something that comes before the opening `{` that tells the parser that the `{` *must* be an expression. That's why the following won't work for destructuring in ES6. { foo, bar } = zap(); The parser will think you're trying to set a block statement equal to `zap()` which doesn't make any sense, so you'll get a syntax error. Instead you have to tell the parser `{` should be treated as an expression: let { foo, bar } = zap(); // or ({ foo, bar }) = zap(); 
The volume of comments about compat vs compact is depressing.
First one is clever.. and isn't even javascript! obviously, you can actually have more than two choices there. it just depends how you anchor stuff. People can cheat/look at the whole story by simply viewing source :) Second one is actually javascript and a JSON configuration file. It's really complicated and it's a tad more complicated to do. It can be written better (OOP instead, for example).. If you want pure simplicity go for the first one. If you want to be relevant in this subreddit, and do javascript to do stuff... well go for the second one..
I think it has its place for sure. As someone fairly new to using JavaScript as my primary language at work, it's fairly difficult at times to utilize my IDE when it can't tell what's going on. With that said however, there's obviously a lot of flexibility currently that has to be carefully maintained.
Semver... where version numbers mean next to nothing in terms of project development. The first thing I thought with this headline was "wow, I wonder all the new features in 3.0" then I realized: "oh, semver". 
Still worth screwing around with the basics, pretty trivial to make a light reddit clone or something.
https://github.com/ariya/kinetic There's a few examples here which should help you out 
I have experience with C#, C, C++, and many others. Javascript is none of those and people shouldn't try to adapt javascript to be more like other languages. Javascript is great because it is so simple and so flexible. It requires no boilerplate. It was created in a short time, on a deadline, which didn't allow for feature creep - *and that's a good thing*. The current fad to abstract javascript with other languages or make javascript like other languages (ES6) doesn't say much about the problems with javascript, but it says something about people's unwillingness to learn it. Switching from C#/.NET to Javascript/Nodejs has been a huge win for us. Personally I'll be sticking with "plain old javascript" for quite a while it seems. 
Types will likely come to javascript, but only after this whole TypeScript/AtScript/etc. experiment is sorted. Optional type annotations are pretty useful for those who want them.
Hmm, but isn't part of the issue that JS is being used far more extensively, and for much larger projects, than Eich would have guessed in 1995? That is: if Eich had been told in 1995 that almost 20 years hence, JS would still be the primary programming language for Web development, and would be used for Web-based apps with many millions of users, do you think he'd say "Well, that won't change my design decisions much"? 
I used to work on JavaScript projects at Google, and the typechecking tool we use for almost everything (the [Closure Compiler](https://github.com/google/closure-compiler)) was a huge help. Maybe some people can write lots and lots of code without a compiler looking over their shoulder making sure they don't do something silly. But for me, it seems I can only get to about 10 or 20 lines before I do something dumb, and if I'm in a language without a compiler (like Python), I immediately think "Ugh, why didn't the compiler catch that for me?!" The more people you have working on your project (or the libraries it uses), the more important this is. Now I work on the Closure Compiler itself. It's awesome to see that the idea of adding some sort of typechecking to JavaScript is really catching on nowadays! For smaller projects, maybe it's not worth it, but for large apps and large teams, it definitely is. Though perhaps I'm biased now :)
Optional strict typing would be perfect, preferably with 'use strict'; Keep it dynamic typing for approachability, Allow strict typing for performance.
I am a heavy user of the closure compiler and what separates it from cross compilers with type safety and optionally typed source to source compilers like Typescript is * the type system in closure is defined with complex javascript types in mind. * proper implementation of generics * proper understanding of struct and dictionary types * tree shaking * the ability to write your own compiler plugins - massive boon for us, we delete deltemplates on lower priorities - drop bindings registered from compiled soy templates which are unused, we moved i8nl from soy to js with a custom plugin by just picking up goog.getMsg and a few more I cannot even think of now * the conformance framework which we have started exploring but seems incredibly powerful * when used in conjunction with the closure library and registerDisposable the ability to detect memory leaks * the ability to run your code without compiling for dev mode - which is a design principle in closure The more hackish members of our teams dislike it, but we have rolled out a whole product line of reskinnable, internationalisable, tiny apps which initially render on the server. It honestly is the best thing since slice bread in this space. The type system is beautiful given what it has to work with. I know google can't be arsed promoting it, they just write their own products in it, the documentation is scarce, but all the code is clear, well tested (library + compiler) and a joy to work with.
Absolutely, yes. I'm convinced that people don't like static type systems purely because they haven't used ML-family languages. Static typing doesn't have to overbearing, and it would be very possible to implement static type checking over much of Javascript *almost* as it stands today, with just a few tweaks. Little or no type annotations needed. You'd be able to just keep writing your code as you do today, and it would feel dynamic. But you could throw a static analysis tool over it and catch a lot of bugs. From my personal experience, I can develop stable, production-ready bug-free code in Scala several times faster than I can in Javascript, mostly because of the powerful type system. Going back to Javascript and giving up type-driven development feels painful in comparison.
I agree. People who say they don't need a type system aren't writing libraries that others can use, or hopefully place assertions *everywhere*, because you want to catch those as early as possible. I've been bitten by exceptions with vague stack traces (due to callbacks) and silent errors too often. Typing adds so much value and stability to code that it would be very sad if it wasn't added. Hopefully it'll be added in the form of optional typing with type inferencing in place, so that existing applications can gradually add type information where applicable.
I'd prefer a "basic" version and an "add-on" version, the latter just with *additions* for compatibility with old browsers, so you should *load both* on those browsers.
*sigh* complain about build tools. Only really complaining about a linter.
Yes, but... I have years of professional experience in Java and JavaScript, and quite a lot of experience in Python, which has been my favourite language. The spectrum of static vs dynamic typing has Java at one end and JavaScript and Python at the other end. In Java you feel like the type system in the boss and you are working for it. It is verbose and clumsy and overkill for small programs, but it is also invaluable for navigating and understanding and modifying medium to large code bases. Python on the other hand makes smaller programs very fast to develop but the problems occur when your code bases gets larger and it is no longer clear what the different expected argument types are for things. Yes, you can document the types, but you have to check and enforce them manually. I had also played with OCaml too, and for quite some time I had the strong suspicion that the sweet spot for static vs dynamic typing is somewhere between Java and Python, i.e. optional static typing plus type inference. After using TypeScript the last few months, I have to say that it is indeed the best of both worlds. I get to choose when and how much type information I want the compiler to check for me. The optional nature plus the inference gives huge benefits for much lower cost than heavy Java. I'm free to get things going in a project and then when I have a clearer idea of the types involved, I can document them in code and have the compiler check them. Things like working code completion, being able to navigate the code easily, and getting immediate feed back in my code editor, are also huge wins. I think TypeScript is becoming my new favourite language, and that is considering the JS base it builds on which isn't nearly as nice a language as Python. Keep in mind that TypeScript shines when project become bigger. You are not going to see much benefit if all you have is a couple of little JS scripts stuck on some web page. So yes. I embrace static typing provided it is optional and also has type inference. I'm curious to see how officially sanctioned support for type annotations on functions will work out for Python though. ( https://mail.python.org/pipermail/python-ideas/2014-August/028618.html ) 
This is a very common, and completely incorrect misunderstanding about Javascript. Javascript has a perfectly valid types, and they can be inferred and checked at compile time for a majority well-formed code. There's tweaks to the language that would need to be made to really do it properly, but it's not far off today. There's certainly things you can do in Javascript that inherently cannot be type checked. But you can typecheck a lot more than you would think, and fall back to runtime type checking for the edge cases. In terms of existing compile-to-js languages that you can use in production *today*, Purescript is a pretty good example of structural typing at work, and Opa - although I haven't used it personally - appears to do a good job as well. Java is not a particularly good language to use as an example of static typing. It alone is probably responsible for an entire generation of programmers completely misunderstanding what a good type system can be. tl;dr If your understanding of static typing is "Java", then you're really missing out on some really powerful tooling.
the whole point of these build tools is that you don't have to tab to your terminal window, stop your server, run 5 commands and start your server again, tab to your browser and hit refresh every time you save a file. 
That can all easily be done without those build tools though. And most of the build tools just wrap the actual tools to do these things.
You've missed the point of the article. The linter is just an example which illustrates his/her point. 
Typescript does not support the same types as closure (yet), their roadmap (which I read this week) will likely bring it on par. Things like union and tuple types have been available for a long time. All this said, I think Typescript is a great project, but for me until I can extend the compiler and have tree shaking it is not ideal. This said, one of our teams at work use angular (and are .net based) and I am going to introduce the Typescript compiler into their process over the next 2 months. Resources like optionally typed also gives me warm and fuzzy feelings and I am glad MS embarked on this project. have a read through https://developers.google.com/closure/compiler/docs/js-for-compiler if you are interested. IntelliJ has great support for the closure annotations, refactoring is a fair bit behind where most JVM languages are in terms of support, but fairly decent. in the refactoring space check out the refaster tool google published, here is a doc describing it https://docs.google.com/document/d/14-rsX1-VoTN2lpFalbwr4_yupxXYW-qNYn2XGVvhLwE/view#heading=h.v5znd73iml8n
Right, but build tools mean you can run just one command and then not have to worry about running one of several different commands. For example, I run a grunt command which watches for changes to files in my project. When a file's changed, if it's a sass file then my sass files are compiled into CSS, a source map is created and my page is automatically refreshed. If it's a js file, then my files are linted and concatenated and my page is refreshed. In both of these cases, I don't have to change to my terminal and run a couple of commands - I've written my config gruntfile once at the start of the project then don't have to worry about it for the rest of the project. I find this saves me a huge amount of time, which is why I use build systems in my workflow.
Check out a job recruitment site and see what javascript skills recruiters are looking for in your area. Data binding frameworks such as Angular.js or Knockout.js are in high demand right now and you will gain a lot of vanilla javascript knowledge by using them. (ex. callbacks, closures, structuring js apps) Besides data binding, I would recommend knowing json very well. In particular, knowing web services and how to pull that json data in via ajax. Lastly, don't stop learning jQuery. It is arguably the most important skill to have in a front-end business environment because most front end systems, even if they are not js projects, use jQuery in some manner to hack and slash their way into a usable product.
Next steps for frontend development: * Learn the DOM (e.g. via [MDN](https://developer.mozilla.org/en-US/) or “[Dom Enlightenment](http://www.domenlightenment.com/)”) * Work with the DOM for a while, then do take a look at frameworks (they’ll broaden your mind w.r.t. to patterns and techniques): e.g. Ember.js, AngularJS, React, Polymer, Backbone.js Resources: * If you need more resources then there is a list (free online books etc.) that I have created: http://speakingjs.com/es5/ch33.html * Twitter is highly recommended for getting to know the community.
You don't *have* to use plugin wrappers for every tool you want to use, they just make it more convenient if you don't care (or don't need to care) about the underlying details or about using the latest and greatest version of the tool as soon as it's released. It's just another bunch of wrapper code you don't need to write yourself in that case. Otherwise, you can always drop down to the tool directly, at the cost of writing more code yourself. I've inlined JSX transpiling before because gulp-react hadn't been updated yet. I've dropped down to using browserify directly now that I'm using it for builds with very specific requirements. (I don't know how easy that is to do with Grunt because just looking at it gives me Ant flashbacks). The plugins made it easy to get started in the first place and it wasn't all that onerous to drop down to the next level when necessary. For me, the biggest benefit of gulp is setting up (cross-platform) watches with chains of tasks which run automatically on every change. On every change I want to transpile JSX, lint the entire codebase and bundle it all up with browserify. I'll use gulp-jshint because I don't really care which version I'm on, but I'll use browserify directly because I want to set up bundling with externals just right for my project. I also want browserify to beep twice when I break the build and beep once when I fix the build, which is easy to do with some variables and stream events. I also want to re-run the same task with different flags for production builds, templating index.html differently for .js or .min.js and including the version number in the footer, or create a distribution version of a library which includes the version number from package.json in the filename and the header comment. I have no doubt this can be done with npm scripts or make, but when there's any logic or variables involved and a pre-baked plugin makes the guts of the task a single function call, and I can easily have stuff redone on every change, I'll still reach for the build tool. The fiddly details of having to learn how to stop browserify dying on error, and when you need to use `streamify()`, `source()`, `plumber()` et al. with certain plugins for various reasons are initially painful, but once you've climbed the hump, the result is worth it IMO. As for numbers of dependencies, if it's in `devDependencies`, I really don't care, Travis doesn't care, people who aren't contributing don't have to care.
The point made at the end of the post is about using npm to manage these - because its a simpler tool to use, and doesn't introduce loads more dependencies into your project. The point of the article isn't so much that you can string together Bash commands and stop using Grunt, its that Grunt/Gulp/et al are a headache compared to simpler tools - such as npm
pointless
&gt; typeof a === "object" Yeah, you're sorta missing the point there. &gt; Then your point is moot. Because the only thing JS will ever be able to do is runtime typechecking.I'm a JS developper , I dont want to hear about language X,Y,Z that have this or that feature that compiles down to javascript.It's not javascript. I'm not telling you to stop using Javascript. I'm telling you that Javascript can have static type safety without you having to go through the laborious effort of learning anything new. You literally can do exactly what you do today, without changing a thing. Nothing will change for you, except you will be able to press a button in your IDE and it will highlight some bugs that you might not have noticed. &gt; Not going to answer everything but we arent talking about haskell,browserify or any precompilation pipeline,we are talking about ECMASCRIPT current or its implementation , javascript.And you cant create types in javascript,period.Why do you think they introduced typed arrays? because there is no way to create types in userland right now. Have you ever used a lint tool? It's optional right?. You can run it if desired to check your code for common errors, and ignore it if you don't want to use it. You don't need a compiler to use static type checking. Just think of it as a third party linting tool that you can run over your code if you really want to.
Note: you don’t have to change your source code to profit from a static type checker such as Facebook Flow – the simplest way of using it is to check for consistency. I already occasionally document types of parameters in my ES5 source code. That is information that type checkers can use to do a better job. Nothing else has to change. Type annotations are optional, which is different from Java, C# etc. forcing you to type much of your code.
Thanks for the links and info. 
Check out TypeScript: it’s pretty good at typing most of JavaScript (and continually getting more features). Its type information only exists at compile time.
&gt; Yes you can. &gt; &gt; var a = { name : "Bob" } &gt; var b = { name : "Fred" } &gt; var c = { name : "John", age: 31 } &gt; &gt; a and b are of type { name :: String }. c is of type { name :: String, age :: Int }, which is a subtype of { name :: String }. You probably know this zoomzoom83, but it is worth mentioning that V8 tracks this kind of type information and has it own "virtual types" internally which it attaches to JS objects to aid in producing fast JIT code. V8 can see that a and b are the same types and then send those objects down the same fast optimised compiled code path. 
Yes. A million times yes. Static typing does a handful of very good things, as has been proven out by numerous other languages: * Terseness. In order to make my code robust, I *must* resort to things like lodash's _.isObject or _.isString, in order to handle programmer mistakes. This bloats code tremendously. In contrast, just slapping types on function arguments is super-concise. * Better analysis. Static typing in function signatures makes static analysis actually useful. We can go beyond accidentally checking the existence of identifiers, and verify arguments and parameters. * Faster coding. You have a stronger ally in the JS compiler now. It'll find more mistakes, faster, than you can by reading or using jslint with vanilla JS. I'll add that if anyone says that this means they'll have to do more typing, odds are, they aren't doing enough to verify the types of the values in their code, and are relying heavily on truthy/falsy and implicit conversions. Most of the time, this works okay, except when it doesn't. The downsides are having to adjust to the new grammar, and the enormous wealth of code out there now that *isn't* typesafe. Wanting a top-to-bottom typesafe JS stack in manstream development will take years to accomplish, and is about as realistic as wanting the same for Python.
Because webdevs are stupid. There I said it. Remember tabs vs spaces?
I suspected this might be the case, although I wasn't sure. It's good to see this type of inference is already being used for optimisation.
&gt; I'm not , you are calling something a type which isnt a type in javascript. I'm calling something a type because it's a type. There's no ambiguity here. &gt; JS linters arent a javascript language feature.They are third party tools.We are talking about Javascript here,not tools,libraries,not third party languages. You are correct. But you are also missing the point. The point was not that you'd need a third party tool, the point was that type safety could be added without significant changes to the language. &gt; No it cannot,unless you rewrite the language from scratch and make it look like Java No. You can have fairly good static type safety in Javascript, pretty much as it exists today, with a few tweaks to improve it.
Something wrong with underscore.string
No, with semver, version numbers actually _do_ mean something.
- Expand on your general programming skills. Learn OOP principles and how you can practice them in JS. Learn about simple data structures (queues/stacks, linked lists, node trees etc) and implement them in JS. - Come up with a project idea and use a library/framework to realize it. A D3.js graphic that gets its data from an external service. An AngularJS text game. Just try come up with a fun project that won't take too long to create. - Learn some back-end skills. Write a simple application which reads from and persists to a database and create a user interface for it. Create a web service that you can pull JSON-formatted data from via Ajax.
OK! Sorry did not know about this rule. Actually, I did post another link of my website but before reading this comment. Sorry!
You would rather have this be jQuery v64?
The problem is not the language but the developers writing bad code. I've worked with people thinking they are great but producing bloated unmaintainable code. The problem is how to force the people write good code. Static typing does not help especially in the web world where everything is dynamic. I used to code in C# and the code base of the project was full with spaghetti code. Moving to the Node.js world, where simplicity and modularity are the standard, was eye opening for me. So static typing cannot replace good documentation, code modularity, discipline, and team communication.
To computers. To humans they mean: this is a breaking change or this is a non-breaking change. See Ashkena's rant about it on the lodash repo.
Yes. To my experience, types were added to Ecmascript almost perfectly with ActionScript 3. Programming it was a dream. If Javascript could follow that route, I'd be happy.
I'd like to see your npm solution to compare it. Please post the followup when its done. I'm no grunt fanboy, but I just don't see the ease in your npm solution yet. It might be fine for a single build release, but it doesn't seem suited for file watching and stringing together 2-3 tasks on each save (x200 times a day). I see grunt plugins being build on top of 3 or 4 other tools as a potential plus—they did the work to wire them together so I don't need to. Something like file revving and usemin, for example, probably use a bunch of separate things that I don't want to touch.
&gt;The spectrum of static vs dynamic typing has Java at one end and JavaScript and Python at the other end. &gt;I had also played with OCaml too Where would you place OCaml on the spectrum between Java and Python? I suspect that there is no good place for it, because modern static type systems like those found in ML languages (let alone Haskell or dependently typed systems) are qualitatively different from anything found on this hypothetical spectrum.
Yeah, I got excited for a moment.
One man's dream is another man's nightmare... AS3 is basically Java. 
Types in comments are a little ugly, yes, but it means your code can run uncompiled while you're developing it. That won't happen for TypeScript and similar until the type syntax makes its way into the spec and into browsers. You can also leave out the type comments entirely, and in many cases the compiler will infer the types automatically.
It took me a few minutes to figure out i had to press the left and right arrow keys to do anything. 
To counter those points: * Gulp does claim to offer the leaner approach - but I feel like having the Gulpfile, and having to learn the Orchestrator/Vinyl-FS libraries is already too much work. Gulp aligns with what I'm saying because it replicates the functionality of Bash (streaming through unix pipes) - not the other way around. * Yes, windows compatibility isn't great - however not all Grunt/Gulp plugins are compatible with Windows. On the other hand installing Cygwin and using npm through bash on Windows works pretty flawlessly. I have used npm with Windows, and while it is certainly harder it is far from impossible. * I'd argue that once you include all of the above tools in any project, you start to hit complexity barriers - this is true of Make/Grunt/Gulp/npm/&lt;insert tool here&gt; - more stuff makes it more complex. As a random example, I'm not sure [jQuery's Gruntfile](https://github.com/jquery/jquery/blob/master/Gruntfile.js) is any less complex than npm equivalent would be (npm would certainly be less lines of code). 
If you [follow me on twitter](https://twitter.com/keithamus) I'll be posting the follow-up article in a week or so :)
I like your optimism
Not sure I can agree with that... though I see where you're coming from. Oddly enough I have had to dip into a few Java projects at work and I do find the language a nightmare.
I don't think I did miss the point, the article misses the point that most peoples tasks are multi-step processes and not single action tasks like lint.
None, by yesterday, they are all obsoleted.
Relevant quote: &gt; Despite the big version number jump, we don’t anticipate a lot of migration issues for most current jQuery code. We’re just being good semver citizens with this version bump. So it doesn't explicitly state that nothing big is changing, but it sure sounds like it.
What do cabs have to do with spaces?
That's just the thing, they're doing it for versioning's sake, not yours. Semver has always been about versioning, not perception.
Note that this is NOT the HTML5 standard anyone actually cares for. The standard web developers should care for is the WHATWG standard, now called the HTML living standard. It used to be called HTML 5 but it was renamed. The living standard however is what browsers (Firefox and Chrome, unsure about IE) are attempting to follow. See https://html.spec.whatwg.org/multipage/introduction.html#is-this-html5 The two standards have the same doctype and are not compatible. This may result in some amusement in the future.
You could always use something like: &lt;script&gt; document.write('&lt;script src=' + ('__proto__' in {} ? 'jquery.new': 'jquery.compat') + '.js&gt;&lt;\/script&gt;') &lt;/script&gt; This will load the compat version for older browsers and the lighter version for newer. 
[Here is the rant](https://gist.github.com/jashkenas/cbd2b088e20279ae2c8e), although it's not very good and doesn't suggest a good alternative. 
It's not completed at all...
Atleast now they declared it complete.
&gt; The current fad to abstract javascript with other languages or make javascript like other languages (ES6) doesn't say much about the problems with javascript, but it says something about people's unwillingness to learn it. Current? This started over 8 years ago with GWT. The Closure compiler is about 5 years old. It also sounds like you never used a language with good tooling. Knowing how to use JavaScript doesn't make its scaling and tooling issues disappear. With JavaScript, it's needlessly difficult to write larger applications with 1+ developers. Note that I said "difficult", not "impossible". You can of course write rather large applications in plain JavaScript, but you'll waste some time and money (and sanity points) in the process.
Hey! I'm not really sure about good angularjs books, but I'd highly suggest [egghead.io](https://egghead.io/technologies/angularjs?order=ASC) for their videos. The first ~50 or so videos are free and about 5 minutes long. It starts from the very beginning then gets into the more complicated bits. The videos are a little dated, but the core concepts are still there. Everyone is seemingly up in arms about angular 2.0 coming out at the end of 2015. Version 2 will break compatibility with versions 1.x and will not have an upgrade path. After that support for 1.x will go on for about 2 years... so the current framework is on a limited lifetime (as it stands)
+1 for the citation
After having used optional typing for a while, I'd say that it's clearly the best option for scripting languages. The type annotations act as basic documentation and they make your tools *drastically* smarter. Since you only have to put annotations on the "surface area" (fields, arguments, return types, etc) to get all the typing benefits, it's a very appealing trade-off. Inside your functions, types can be generally inferred, because all those values you are dealing with are either literals or return values from annotated functions. Furthermore, I really hate writing those overly verbose doc comments. ES5: /** * @param {Number} x * @param {Number} y * @returns Boolean */ Rectangle.prototype.cointains = function (x, y) { ... }; ES6: /** * @param {Number} x * @param {Number} y * @returns Boolean */ contains (x, y) { ... } Dart: bool contains (num x, num y) { ... } TS/AtS: contains (x: number, y: number): boolean { ... } Those type annotations are something I happily write, because I *instantaneously* benefit from them. Doc comments, on the other hand, are a real drag. They are extremely annoying to write. Even this short hello-world-ish example was a real chore. To make matters worse, their usefulness is fairly limited. They aren't standardized (or part of the language) and the tooling support is correspondingly poor.
Well, I guess it's nice to have that chapter kinda semi closed. It changes absolutely nothing, but still.
&gt; The two standards have the same doctype and are not compatible. This may result in some amusement in the future. What? My understanding is that the W3C version is, as all their recent HTML drafts, a snapshot of the WHATWG living standard.
OK. The semicolon doesn't really seem like the issue with this code to me, though.
Mission Accomplished!
Understand your tools and their alternatives. Make your decisions appropriately.
It's gotta be something. If not Grunt or Gulp, then browserify or make or whatever. And yes, browserify is a build tool. Also: npm scripts may be less capable than you think. For one thing it's difficult to pass arguments to them, for another, if you use pipes or output redirection or other UNIXy things and your team is cross platform, you're gonna have a bad time. I agree there are problems with Grunt and Gulp, but there are also advantages to things specifically intended for the task of building JS projects. Using npm scripts is awesome while it works for everything you need, and then when it doesn't -- you're boned.
That's been there for a very long while (unless I'm seriously mis-remembering, which admittedly is a possibility) and I've yet to see any mention of incompatibilities anywhere. Okay, on browsing their site on archive.org, the general mention has been there pretty much forever, but up until sometime 2012 instead of "some minor some major" it had a section 1.2.1 of differences, mostly different wording and metadata related things, kinda weird to completely remove it.
The only time synchronous XHRs should ever be used is when they're executing in the context of a Web Worker. The only exception to this rule is if you're trying to play audio/video on a mobile device and you need to perform an XHR to get a single-use URL to load/play. This is because most mobile devices need direct, physical, and synchronous interaction from the user to play audio/video. Unless your situation is one of those two then there is **absolutely no excuse to ever use synchronous XMLHttpRequests**.
You should use third party libraries. Almost every legit web frontend uses jQuery or bootstrap, or if not then at least considered them as options. Think of something you would have fun working on, a game, a web app, a server based website with node.js, and just grind away at it. That's how everyone learns to make things.
I wish you'd just learn how ASI works.
You just learnt the only other rule that tends to matter in practice. You already know the one about `return`.
We should do a third standar to solve the problem
ASI is awesome, and now you know one of the two ways it breaks. Don't do: return something That's the other and that's it.
Programming languages don't exist in vacuum. The environment plays a very important role. Java, for example, had excellent tools and excellent documentation. That's what helped making it this popular. If your machine is able to assist you with your work, there's a lot less friction. &gt;There is no evidence to prove this is true. So, can you disprove it? I'm obviously talking about my own experience. If your tools are smarter, things are easier. Things which would usually require me to check the documentation can be easily discovered right within the IDE. If some refactoring or some library upgrade caused some function's signature to change, the IDE will tell me if something broke as a result. You can also auto-complete a lot more if your IDE knows what kind of objects you're dealing with. Compared to JavaScript, Dart made me a lot more productive. Working with third party code is also a lot nicer. Maybe you should actually try TypeScript or Dart.
 Maybe we should create one universal standard! http://xkcd.com/927/
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=927#Explanation) **Stats:** This comic has been referenced 963 times, representing 2.4790% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_clomhnu)
Looks like gulp is rapidly catching up. I only familiarized myself with grunt not too long ago and haven't really tried gulp, but might have to give it a shot soon
 function createFunc (x) { function A () { console.log('a'); } function B () { console.log('b'); } function C () { console.log('c'); } return function () { switch (x) { case 0: A(); B(); C(); break; case 1: A(); B(); break; case 2: B(); C(); break; } }; } Not sure if I understood that right though.
I'm not sure if this is a good thing. I can think of a few 'negative' ways of reading this news: 1. A lot of packages are doing similar things, but without their authors combining efforts. We aren't coordinating ourselves as a community, and our software is suffering as a result. We are suffering from 'not invented here' syndrome. 2. A lot of packages are actually doing different things, but dealing with trivial or niche requirements. They are basically just people turning functions they write for projects into modules. A fragmented ecosystem is leaving developers having to reinvent many small wheels for their particular platforms. Alternatively, many of the packages are simply snippets, which means they could be either trivial or non-reusable. 3. Authors are publishing libraries without performing due diligence. They are not waiting until their libraries are used by others and have been battle-tested before they commit them to the community. They are not writing software that is flexible and robust enough to quell any need for other developers to write further software. 4. Old packages are not being removed. There is no incentive to de-commit. This could be a threat in the very long term.
It looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you shouldn't only be submitting your own site. Thanks for your consideration!
So the value of X being persisted would be an example of Javascript closures at work, right? No wonder I had trouble figuring this out.
It looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you shouldn't only be submitting your own site. Thanks for your consideration!
That's actually not true. Angular 2 is at least a year out. And Angular 1.x will continue to be supported for at least a year after that.
With good type inference, you don't even need optional type checking. The type-checker can infer types in most cases, and you only need a few annotations for the edge cases.
If you want to try the API, here is the current polyfill: https://github.com/johnmccutchan/ecmascript_simd
The video goes into why they didn't use an existing solution like TypeScript. Flow has type inference, more features, and "scales better." [This blog post](http://www.2ality.com/2014/10/typed-javascript.html) has a good overview of TypeScript/AtScript/Flow.
Like Bush in Iraq.
I really like code over configuration in this case. I'm relatively new in JavaScript world and was forced to make the hard choice recently but I'm really glad to have chosen gulp.
Can't wait for HTML6!
Programmers are inherently lazy. ;) embrace it. When I realized I could achieve less visual clutter, less jshint noise, and less keystrokes per line, ASI seemed like the obvious choice. Thinking about the rule is no harder than "do I need a curly brace for this if statement" or whatever else. 
Have you? Typescript is around, it compiles down to javascript and type checks. For performance you can express int32's by using ( number | 0 ). Booleans also exist. Int32/Int64/Unsigned/etc arrays are supported in all major browsers/node (usual disclaimer, internet explorer 10+ only.... ugh ..). It's not "Would" but rather, "Why aren't" imho.
Are you guys still picking Angular given the news re: Angular 2.0?
&gt; Multiple standards destroy the meaning of the word "standard". It does, but why single out the live one? Rolling release sounds like an interesting approach to web.
&gt; To humans they mean: this is a breaking change or this is a non-breaking change. That's exactly what it means to computers, too. There is no way to standardise non-semantic versioning. ie a developer has to decide randomly what a major release might be, what features to include etc. When you see a non-semantic new major version, you still have no idea whats in it. How is it helpful? Going from 2.0.0 to 3.0.0 means nothing at all. All you know is that there is added functionality. Using semantic versioning and going from 2.0.0 to 3.0.0 you know more information about the project. You know there is added functionality AND you know its not backwards compatible to 2.0.0. With other combinations of upgrading from some version to another, in every case, semantic versioning gives more info that not. I agree, its not a perfect system, and it would be great if we could distill all the upgrade information in 3 numbers, but its not possible. We have to settle with something which can be defined (semver) without exception. Now, don't be lazy and read the release notes.
Not only that, but this move is designed to STOP any confusion with breaking changes in the future! Great news!
use querySelectorAll to return an array of paths then iterate around them doing what you were doing var paths = document.querySelectorAll('.squiggle-animated path'); for(var i in paths) { var path = paths[i]; var length = path.getTotalLength(); // Clear any previous transition path.style.transition = path.style.WebkitTransition = 'none'; // Set up the starting positions path.style.strokeDasharray = length + ' ' + length; path.style.strokeDashoffset = length; // Trigger a layout so styles are calculated &amp; the browser // picks up the starting position before animating path.getBoundingClientRect(); // Define our transition path.style.transition = path.style.WebkitTransition = 'stroke-dashoffset 3s ease-in-out'; // Go! path.style.strokeDashoffset = '0'; }
&gt; the tooling support is correspondingly poor. I just cannot agree with this statement, in IntelliJ the tooling support for doc type annotations are great today. completion, suggestion, i am sure visual studio is the same. if your tool of choice does not support it, speak to your vendor.
&gt; in IntelliJ the tooling support for doc type annotations are great today For which flavor of doc comments? The popular ones are JSDoc, Closure, and YUI. As I said, this isn't standardized. Anyhow, VS will auto-complete "contains" for an instance of Rectangle and it will show the comment (_any comment_) as-is in a call-tip, but that's it. I can pass a string and it won't complain about it. It's unaware that "contains" returns a boolean. Brackets 0.44 (latest) is even worse. It ac's "contains", but that's all it does. Yea, this is poor. **Edit:** Have you tried Dart or TypeScript?
I use closure heavily and wrote a simply groovy script which runs the closure compiler over whatever application I am working on every couple of seconds to get my static feedback. IntelliJ gives me completion, understands my function signatures, can infer types down the line, pretty sophisticated things really. Nothing against typescript (and I have played with it a lot, and I am making our angular team at work use it, I am FIRMLY in the camp of static typing), but it is inferior to the closure compiler in several ways still. Dart is decent, had a solid play with it and wrote a mini product, the tooling is nice, feels a bit like coding actionscript 3, but the js output is a joke so it is pretty unusable on any app where speed and size is important.
The only thing I would change about your response is to do a [].forEach.call(path, iteratorFunction) or for(var i = 0, len = paths.length; i &lt; len; i++) because of performance and accidental iteration on not node items. When you do the for...in, it will hit all of the nodes plus the native functions (which are length and item). It would then result in a js error. EDIT: Also, for clarification, querySelectorAll (and all other element selection functions) do not return arrays. They return what is called a NodeList. The importance of this is that a NodeList behaves differently than an array. It has less available function (hence my suggestion of using the [].forEach.call to use the native array forEach feature). Here is a link explaining more about [NodeLists](https://developer.mozilla.org/en-US/docs/Web/API/NodeList) if you are interested.
You're right, I forgot about the hasOwnProperty check. Any reason why you'd do [].forEach(paths, iteratorFunction) Over paths.forEach(iteratorFunction ) I've never liked the syntax of the first version, it seems unnecessary but I'd like to know if there's a benefit that's not guarding against paths being null/undefined as I'm pretty sure document.querySelectorAll() returns an empty array. (on my phone so can't check) 
Who the fuck wants to declare types over and over? I just toy around with a few languages but that shit sucks ass. I like javascript over java for that alone. Array blah = new Array(); It's a fucking array, how many times do I have to tell you it's a fucking array. Might as well do this, does this make everyone happy? Array, Array, Array blah is Array ok Array getit Array= new Array(), yeah Array() uh huh Array(); From a newbies perspective it just seems dumb as hell and totally pointless.
It is because it doesn't return an Array, it returns a NodeList. NodeLists don't have a forEach function, which is why you have to do the [].forEach.call(paths, iterator). I wish it was possible to paths.forEach, but alas :'(
Doh! Totally missed that! console.log(paths) **quick glance, "looks like an array... Its obviously an array" Rookie mistake. I'll try harder next time! 
Yeah I understand if you use reflection the tree shaking won't work. When I meant fast I actually meant perceived speed. So for the record I use the full closure stack, * this is the compiler, * the library (so tree shaking happens all the way down in our code), * the soy template system (so templates get compiled into JS, which then get compiled into your app) and it we also pre-render the initial content on the server (airbnb call it isomorphic rendering, but that just sounds wanky to me) * gss compiler (so all our css is renamed, the renaming map is passed into the compiler) So our aim is to get the byte count down as low as possible and get content in front of the user of our application as fast as possible and inline with these aims closure is superior to anything else out there. Obviously the compiler inlines functions along the way, creates less output and this has another speed improvement implication and this is what you were talking about, its less hard on the CPU, but rarely do I think this is as important. the biggest impact there is algo design, so O(n^2) vs O(2n). I know that a some people from the closure team are working on the dart to js compilation and I have to say I do think Dart is pretty awesome and I hope the project succeeds and gains more traction - the same with Typescript - these tools make me happy, I like clean, well written, well architected applications and static analysis is essential for this IMO (and proven over years and years of research in the field). Sorry, writing an essay now, back to the original point. Intellij has good tooling using the closure annotation system, with the compiler I get sophisticated type information and analysis and if you have the same design considerations I worked with when picking closure, small, fast, i8nl, pre-rendering then using closure will also seem like the logical choice. I would however use Dart gladly for internal apps, where these considerations are not critical and or I can tell all the user to use chromium. 
99% most employers wont hire her because of that! its the first thing that stuck with me, even if its a joke... its the wrong attitude to have! 
Egghead.io is currently marked in my browser marks! Thanks so much guys ;)
Yep, because Angular 1.3 should be maintained, as said in the [latest Angular post](http://angularjs.blogspot.fr/2014/10/ng-europe-angular-13-and-beyond.html): &gt; If you are building web applications today, this is the version you should use. This is the tried and true version that we really believe in. With over 1600 apps at Google built with Angular 1.x, we are committed to supporting it as the first class AngularJS version for a long time to come.
Two videos are being played simoltaneously, just open development console of your browser. You only have to show the appropriate container, depending on the event. KISS principle, I like it.
Java is a really bad example of static typing. It's incredibly verbose. Statically typed languages don't have to look like that, fortunately. In ML-family languages, you can define an array like so. val blah = [1,2,3,4,5] No type annotations, no repeating yourself, no fucking around. But it's fully statically type checked at compile time. Want to create a record? val bob = { name = "Bob" } Bam. Done. Type inference to the rescue. No type annotations to be seen, but it's fully type checked by the compiler - at compile time. tl;dr You can have your cake and eat it.
 var models = [7, 5, 3]; var foo = {models: models}; That's what you can do. You can't get ahold of the name of an identifier. As far as JavaScript is concerned, the name of some identifier only exists on your side. By the way, minifiers typically rename local identifiers. So, the example above could turn into something like this: var q = [7, 5, 3]; var r = {models: q};
OT: is there a way to set dinamically the name of a function? Say I have this function factory: function factory() { return function fn() {}; } var f = factory(); f.name; // =&gt; 'fn' I'd like to have function factory(name) { return ???; } var f = factory('myname'); f.name; // =&gt; 'myname' EDIT: sorry for my poor example, there is a requisite: non using eval or Function
TypeScript also has type inference but looking a the video it appears that the Facebook team want to do much more aggressive type inference which also scans across multiple source modules (which would necessitate the use of a dedicated server to do the work in the background). I'm just glad to see that there is some approaching a consensus regarding the syntax and what it means. I hope TypeScript quickly adopts better support for non-nullability and brings it closer into line with Flow. 
I am wondering the same. I like the resolve in principle, it makes sense. But freezing the view until the resolve completes seems *bad*.
Thank you!! That's a great solution you're amazing dude!
Thanks for your time, querySelectorAll is definitely the way to go.
I would like to see an example of how he would handle it.
It's easy enough to make bold claims, but I'd prefer some concrete examples to back up his article. Don't just allude to bad things happening, tell us *why*, and then give us examples of how your solution is better. It's not that I disagree, I just think this article was a lot of fluff repeating common knowledge. I definitely agree on his opinion about inheritance. Even in my Java developer days, deep inheritance was frowned apon and "Composition over Inheritance" was an oft-repeated mantra. I have different thoughts about factory methods. I hate factory methods. They can be more flexible in many cases, but the majority of the time YAGNI. It feels like over engineering. Happy to change my opinion on this though if presented with a reasonable argument. I do like the library he referenced - Stampit. I'm a big fan of mixin inheritance, and it's nice to be able to use this in Javascript as well. Appears much cleaner than my current homebrew solution. I'd like to throw some caution out - just because you don't use the 'class' keyword doesn't mean you aren't actually doing exactly the same thing. It's important to be careful not to replicate the same mistakes when using prototypes. It's still inheritance. It's also especially important not to fall into the same trap that ruins most OO code - shared mutability. Data objects should be immutable.
Posted something similar on the article, but want to ask r/javascript too - do you have any examples of large or complex open-source codebases which eschew constructors, `this` et al while making heavy reuse of existing code? I ported a forms library as directly as possible from Python and [it has a big old inheritance hierarchy](https://gist.github.com/insin/c3eb704771cb24bb835e) which makes use of constructors, constructor borrowing, `this`, storing "class-wide" stuff on prototype objects, mixins and multiple constructor calling in some places for fake multiple inheritance. calling methods on "parent" constructors and probably more! What's the concrete approach to creating these kinds of components without constructors? I use all the tools JavaScript has in the box as-and-when and usually start from a simple module-as-object basis, or factory functions for constructor-like logic returning objects containing functions which close over state, but I tend to reach for or convert to constructors when I think I've identified solid "is-a" cases for reuse. What does the alternative look like when you scale it up?
I'm keen to see this too. Factory methods are almost universally considered a bad idea in most ecosystems I've worked with. They have their place, but certainly not as a normal way of constructing data types. At the very least, they add a layer of abstraction and ambiguity about how to construct an object. Rather than there being a standard convention, you now have to figure out how each library expects to be constructed.
https://github.com/ericelliott/stampit That's his repo that he mentioned in the article.
It takes the URL in the address bar, and removes all the text after "whatever". "whatever" is removed too.
Thank you! I really appreciate your help in explaining it.
I agree. My current coding style is based on two pillars too: 1. Immutable objects as data 2. pure functions for transformations The objects are defined exclusively by composition, never by inheritance. I use constructors to instantiate those objects only for convenience: 1) I exploit the constructor to store some meta info that I can use later for mixins var Person = struct({ name: Str, // means string surname: Str }); console.log(Person.meta.props); // =&gt; {name: Str, surname: Str} 2) instanceof: with immutable data structures allows super fast checks for changes 3) prototype: sometimes it's handy if a function requires an instance // person is an instance of Person function getFullName(person) { return person.name + ' ' + person.surname; } becomes Person.prototype.getFullName = function () { return this.name + ' ' + this.surname; }; p.s. reference https://github.com/gcanti/tcomb
This looks fantastic. I've been saying for a long time that Javascript *could* be statically typed with minimal changes to the language, it's nice to see somebody managed to pull it off. This brings it a long way forward in competing with ML-family languages in ability to maintain large codebases. With some of the other changes coming in ES6, Javascript is actually starting to shape up.
I agree with the article 100%. Having worked for many years on several, large Java and C# codebases, I can report that inheritance is the devil. It "makes sense" and seems useful in small codelines, so I can see why the people who came up with it thought it was a good idea. However, in the wild, very smart people do very dumb things with it. The whole thing ends up wasting everyone's time. I've been dreading all this OO crap that's going to be put into the language. Now that it's the language of choice for everything, everyone wants to add their baggage. Just say no!
I suppose you know that an editor can generate jsDoc comments. Writing them by hand is not very productive. And I'm surprised to find that you would happily write a type annotation but you wouldn't leave a comment what a parameter does. For example what do x and y stand for in your code samples? I cannot guess by their type.
&gt; 2) instanceof: with immutable data structures allows super fast checks for changes if you data structures are immutable, why would there be any changes (and why would you check for them)?
In my opinion the problems with (single) inheritance are: - taxonomy - doesn't play well with orthogonal features Taxonomy. You spend your valuable time to build a taxonomy like you were playing to be the god of the world, but it's a wishful thinking, the world is more complex. Look what's happened to [Carl Linnaeus](http://en.wikipedia.org/wiki/Carl_Linnaeus). Yes, an amazing work, but then you end up with a family containing only the poor platypus, since you don't know where to put this weird animal. Orthogonal features. Inheritance induces a tree, an handy but too strong structure. DAGs are more flexible. If you have 2 orthogonal features (A, B) and each feature has 2 kinds, with single inheritance you end up with all the flattened combinations: (A1, B1), (A1, B2), (A2, B1), (A2, B2); while with composition you can describe this case in a compact form.
Interesting read, but inline examples of right and wrong would be way more compelling to the JavaScript novice which seems like his target audience
And mutating an object is faster than cloning new objects with every desired change
See http://www.reddit.com/r/javascript/comments/2kv9hc/the_two_pillars_of_javascript/clp30ja. It's the reason why I'm interested in `Object.observe` EDIT: the general idea is something like [om](https://github.com/swannodette/om) with a single mutable point that represents the application state
Immutable data structures are a lot faster than you'd think. Done properly, they reuse most of the original object and often only need to tweak a few pointers. The overhead can be as small as a few percent. (Although not in Javascript). Regardless, if you were doing a lot of writes, you'd work with a mutable structure until you're finish and then return an immutable/frozen version. The idea is to avoid breaking encapsulation by sharing mutable state outside module boundaries, which is a major source of bugs in typical OO code. In a read-heavy workflow, immutable structures are almost always significantly faster, since you can avoid having to copy the object and instead pass around projections off the original. 
Done properly by who? The language or the programmer? It seems you mean the language. My comment was respect to the article (JavaScript). I found your response useful though. Does your last paragraph apply to JavaScript?
Looks like this is just a ploy to get people to sign up via refcode. Setting up a webserver is trivial.
If you're using immutable data structures to maintain state, then a change in state is effectively done by creating a new object entirely and replacing the old one. (This is a lot faster than people intuitively thing) In that sense you're not checking for changes to the object itself, your checking for a new version of the object. If you're using immutable objects, then you can take a shortcut when checking for changes and simply do a referential equality check - effectively just comparing two pointers, which is very, very fast. Depending on the use-case, working with immutable structures like this can be substantially faster than working with normal mutable values, where you'd have to do a deeper dirty check. Regardless of any performance implications, the primary reason for doing this has more to do with avoiding shared mutable state. If you don't share anything mutable across module boundaries, then you an eliminate a whole class of common bugs with minimal effort.
It was an awesome language. The proprietary aspects of it really turned a lot of people off I think. Also, the fact that much of the code was generated in an IDE as opposed to something like vim... It's given rise to the awesome Haxe language, which compiles to numerous platforms.
Traditionally minor updates were 0.x.0 and patches were 0.0.x. Until semver becomes the standard, I'm still going to naturally assume a 2.0 to a 3.0 has major changes... but this doesn't, it's just some fixes and easily migrateable code that isn't backwards compatible - that used to be a patch or minor release so there's no question it's more vague on the amount of material being released since it boils it down into these binary compatible vs not compatible options. I guess for the reason of auto updating new releases that *only* are backwards compatible (i.e not a major version number) semver becomes useful, but I personally never felt the need for this since most of those seemed to fall under new patches with the assumption that minor releases might lose compatibility (or at least throw some warnings that you're using future deprecated methods). You're right there isn't really a good solution to please everyone but I really cringe at the thought libraries starting to have to give themselves subnames (jQuery Giraffe) just so they can refer to the major versions that have considerable added content or syntax changes like Angular 1 to 2 which under semver might be Angular 17.0.0
&gt; What makes a type so different to a class? And more importantly: why are subclasses a big no-no, but subtypes are ok? In my opinion, defining a prototype *is* creating a class. There are substantial differences in mechanism between Prototypes and Java, but it's still fundamentally the same design pattern, with the same risk of creating unmanageable deep inheritance hierarchies. (You can of course also use prototypes for things that don't resemble inheritance as well). In that sense, Prototypes are Classes, and Classes are Types. (But not all Types are classes). My personal philosophy is that you should never inherit from a concrete type. Only abstract types or (ideally) interfaces. Data classes should be as simple as possible, ideally just ADTs. Shared behaviour should be implemented ideally via ad-hoc polymorphism, or Mixins as a last resort. I agree with your impression of Haskell and OCaml. Stripping everything back to ADTs and Functions makes the world so much simpler. 
Function constructor and prototypes are a good way to "inherit" and create "classes" but you don't need to rely on `new`. More info [here](https://github.com/mattdesl/module-best-practices#constructor-best-practices).
For that kind of thing it's much easier to use a [component approach](http://gameprogrammingpatterns.com/component.html). If you have 50 types of monsters that are the same but with slight differences, you don't want to make 50 different classes for them, you can just build them from components at runtime. This also allows you to have your monster/character definitions in a database or in a json file. Edit: I know it's not directly related to your question, but sometimes composition is better than inheritance :)
The main purpose of the `!` is to save a character, not to combat ASI issues. (function () { /* ... */ })(); !function () { /* ... */ }(); http://stackoverflow.com/questions/3755606/what-does-the-exclamation-mark-do-before-the-function
That's a real simple answer and it's a real eye opener for me. Will definitely read that article. Thanks!
I’m in favor of using `new` and constructors: * It is the most commonly used style of OOP in JavaScript. That means that more people understand your code more easily and that it is a better fit for more code bases. * ECMAScript 6 classes are internally translated to something similar. * JS engines optimize this pattern. There are two easy fixes for perceived weaknesses of constructors: * You can protect yourself against forgetting `new` by writing your code in strict mode. Then, if you forget `new`, `this` is set to `undefined` and you get an exception if you access a property. * Normally constructors return direct instances of themselves. You can get around that by returning an object (e.g. an instance of a sub-constructor). In Java, you’d need a static factory method to get this kind of flexibility. FWIW, I’m explaining this in more detail here: http://speakingjs.com/es5/ch17.html#constructor_tips
That article was rather insightful - I think I learned more about Set theory from that than several years of high-school, university, and Haskell tinkering combined. Thank you.
Completely agree. I'm assuming less than 10% are useable/useful to the general public. Its the double-edged sword of JS and open-source development. Why argue with a repo maintainer when you can just make your own that works exactly how you want? I think the all the different varieties of JS writing styles/dependencies/ (is it jQuery-esque, functional, commas var? semicolons, coffeescript, etc) and people's diehard passion for them become a huge burden. Also npm does not have a node version support field, although I'm not sure that matters too much anymore. If a breaking change is introduced, that will be important.
Especially considering DigitalOcean has a plethora of their own step by step tutorials, including [this Node one](https://www.digitalocean.com/community/tutorials/how-to-install-node-js-on-an-ubuntu-14-04-server).
Very informative, thanks for taking the time. Any good references (books) on modern JavaScript internals? Edit: also, how does the shared memory model work as it pertains to immutable treatment of objects? Perhaps the set of shared data is kept separate from data unique to each instance, with a trend toward 0 shared memory in the object pool in direct proportion to the uniqueness of every instance? The set of shared memory changes when a new prototype or instance is created?
Type inference works ok in classical OO languages. It can give you reasonable code completion for custom types. Type inference is trash for custom objects in javascript. I really miss reasonable code completion and refactoring support.
&gt; Any good references (books) on modern JavaScript internals? In all honesty I'm not really a Javascript expert - I use the language because it's hard to avoid, but I'm somewhat a vocal critic of it. Others can possibly give better references than myself. That being said, if you're interested in learning about immutable data structures (and functional programming in general), I strongly recommend learning both Clojure and Haskell. Doing so has taught me a lot of things, and made me rethink pretty much everything I thought I new about programming. (YMMV). 
I do! I do! * Where is the best place to start with games on node-webkit? * How do you protect your source (if you do)? * Can you combine it all into a single binary? * What framework did you use for the game (if any)? EDIT: * What did you use to port it to mobile? * Do you have to code extra for the game to be responsive to the portable sizes? * Can I give you 50% of my games profit in exchange for guidance on how to code the damn thing?
Classical OO languages are a terrible example of a good type system. If you think "Java" when somebody says "Static Typing", then you're missing out on *decades* of advancement in type systems. ML-family languages have had supernaturally good type inference for a long time. People use these languages in production on a day to day basis. SML and Purescript (among others) both implement anonymous structural types that effectively do "Duck typing" at compile time. i.e. val bob = { name = "Bob" } Even more relevant - Facebook have also recently announced the tool "Flow", that implements a very comprehensive type system on top of normal Javascript. It can infer structural types, and perform flow-typing. At "compile" time, not runtime. https://www.youtube.com/watch?v=M8x0bc81smU#t=2257 tl;dr Most well structured Javascript code can be inferred and type checked. 
Break it down into a set of instructions, and it becomes easier to understand: // window.location is the address bar, and window.location.href is a string representation of the URL contained in that bar var href = window.location.href; var lowercase_href = href.toLowerCase(); var location_of_whatever_in_lowercase_href = lowercase_href.indexOf("whatever"); var RELATIVEPATH = href.substring(0, location_of_whatever_in_lowercase_href); Excuse the _'s, but it makes it easier to read. As /u/mahoua points out, it looks for the text 'whatever' regardless of whether that is upper or lower case (or any mixture of both), and strips this and everything after it, from the URL, and returns you in RELATIVEPATH, a string of the URL up to but not including 'whatever'. I should point out, that if 'whatever' cannot be found in the URL, then you get unexpected results.
Angular style directives would be nice. Not sure how this could be implemented though.
If it is so easy to infer javascript types why does code completion and refactoring suck so much. 
that was not helpful at all just do what?
Because nobody's done a good implementation yet. Facebook Flow would be the first that I know of. 
From reading the article and your post, I have to wonder, just how large are the inheritance trees that you (collectively) are dealing with? I'd be very worried if I saw one more than three levels deep. (I'd also be sitting up and paying close attention to something if it reaches even three levels.)
More about this on:[The Two Pillars of JavaScript Pt 1: How to Escape the 7th Circle of Hell](https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3)
HURRAY! &lt;/s&gt;
&gt; **Constructors violate the open/closed principle because** they couple all callers to the details of how your object gets instantiated. Making an HTML5 game? Want to change from new object instances to use object pools so you can recycle objects and stop the garbage collector from trashing your frame rate? Too bad. You’ll either break all the callers, or you’ll end up with a hobbled factory function. Dart has [factory constructors](https://www.dartlang.org/docs/dart-up-and-running/ch02.html#factory-constructors) to address this issue. If you decide at a later point to change a regular constructor into a factory, the call-sites don't change. &gt; The `class` keyword will probably be the most harmful feature in JavaScript. Nah, having one official way to do classes/inheritance, which is understood by your tools, is a good thing. Right now, every library and framework does its own thing. &gt;Try adding .1 + .2 in your browser console, for instance. That's how IEEE 754 floating point works. This isn't a JavaScript specific quirk.
Forgetting to call with new is pretty easy to fix, you just check if this is an instance of the constructor. Anyway this looks fine to me except both Player and Monster should have their prototypes from Object.create(Entity.prototype). But I wouldn't call this "using new to implement inheritance", to me that would refer to setting the subclass's prototype to a new instance of the base class, as opposed to using Object.create. So in this example, that would be "Player.prototype = new Entity(...)". That practice is not great IMO, because you either end up calling the base class constructor at an awkward time, or calling it twice, once for the subclass prototype and once for the new instance of the subclass.
Assuming you have a load_json function that takes a file *and* a callback (which you call inside of the anonymous function, with a parameter such response (or data)): var myData; load_json('myJson.json', function(data) { myData = data; }); However I think this could lead to problems if you try to access myData before load_json has finished (such as on a slow network). I'm not sure if there is a way to synchronously load a json file (i.e. block all execution until the file is finished loading).
Coming up with new contrived ways to create objects feels pretty horrible imo. There are plenty of great patterns you can use in Javascript that don't require coming up with novel ways of instantiating objects. Composition instead of inheritance lets you avoid nasty nesting and taxonomies, dependency injection/inversion lets you avoid tightly coupling object creation and usage (and avoid using 'new' in your domain code if that is your arbitrary success criteria). Creating a niche object style also seems so counterproductive to one of the great advantages of JS-- having a massive library of small, modular functionality available on npm. Kinda hard not to feel like this is sorta just JS hipster BS.
okay, time to learn. thanks.
Flow is just facebook's version of typescript that has vastly better inference. It is still Optionally annotated. I can't tell if you are arguing for or against type annotations. **Facebook flow is not javascript.** 
I think arguments to not use this and constructor functions would be: -&gt; it can be harmful if you forget 'new' (but you can write your constructors in a way that would avoid that pitfall) -&gt; it hides the prototypal nature of javascript, and as such is misleading for people coming from class-based languages. With this style you can easily confuse javascript for what it's not and shoot yourself in the foot. -&gt; other corollary to point 2: instead of trying to use at their best the features that js offers, people tend to try to get back what they have in other languages, and bloat their code with libraries and boilerplate to this intend. With module pattern, closures, function as first-class objects and simple prototypal inheritance, one can learn a whole new style of coding, and being exposed to different things is in general beneficial. It's difficult to answer the question of whether 'new'/constructors are 'good' or 'bad', because it's really a matter of development philosophy, with influential people on both sides. In my opinion, the most important first is to understand what happens exactly when you call new on a constructor, what inherits of what, how prototype chain is set up, how you can use higher-order function, etc. Then, I think trying several alternatives can only benefit a developer. And only after having tried the alternatives you can see with what you're the most comfortable. In term of code, the same as you done without function / new could be something like that: //Entity object which will be used as prototype for Player and Monster var Entity = { init: function(startX, startY){ this.health = 100; this.position = { X: startX, Y: startY }; }, move: function(dx, dy){ this.position.X += dx; this.position.Y += dy; } }; //Player object that will be used as prototype for each player var Player = Object.create(Entity); //sets Entity as prototype of Player //overriding of init method to extend it Player.init = function(startX, startY){ Entity.init.call(this, startX, startY); this.inventory = []; }; //Monster object that will be used as prototype for each monster var Monster= Object.create(Entity); //sets Entity as prototype of Monster //overriding of init method to extend it Monster.init = function(startX, startY){ Entity.init.call(this, startX, startY); this.state = "Idle"; }; var badGuy = Object.create(Monster); badGuy.init(1024, 0); var player = Object.create(Player); player.init(768, 859); This will almost behave like what you provided. Difference will be the state of the prototype chain: in your version, Entity.prototype is prototype of Monster, and Monster.prototype is prototype of badGuy. In this version, Entity is directly prototype of Monster, and Monster is directly prototype of badGuy. In the same vein, your first version would allow to test badGuy instanceof Monster, it's not the case with the version without new (because their is no notion of constructor function instance at all). Please note that people working directly with Object.create() often use factory functions or helpers to facilitate further their objects construction (often in order to facilitate the object intantiation part and get rid of the ugly overloaded and manually called init) Please also note that with your example of a game, in a real-life code sample we would probably make a module specialized in entity spawning, managing an object pool (better performance). Hope I have been helping. ;)
Sure. I'm just saying it's not a very good reason not to use constructors, though there are other good ones.
 function factory(name){ return (new Function("return "+name+"(){}"))(); } var f = factory("myname"); f.name; // =&gt; 'myname'
Because there is only *one* number type in Javacript, the Double. Having one type of number is a Good Thing, but Eich chose the wrong type.
I'm using essentially the same techniques he's highlighting and an enjoying it very much. However, here's where I start to draw the line: | People get attached to their programming style as if their coding style is how they express themselves. Nonsense. | What you make with your code is how you express yourself. As if his opinion matters as to how people believe they express themselves. Thats up to the person. I am really starting to hate otherwise intelligent articles advocating the benefits of a particular technology eventually turning into pushy declarations of how and why you MUST do this thing. Kyle Simpson, mentioned in the article, is incredibly guilty of this, and it really personifies the JS/Node hipster bullshit I have to apologize for whenever I'm talking with non-JS coders. There are some great advantages of Javascript, and you should be inviting people to come see them and show off the ease at which you can maintain them, not browbeat people who are already skeptical of your techniques trying to make them feel like shit for doing what has worked for them in the past.
This is fantastic!
Congratulations Rezoner. When I first decided to dip my toes into the pool of javascript game programming some of your articles were the most effective jumping-off points. I've been loosely following your progress on and off through reddit/twitter and it's cool that your stuff keeps moving forward. Consider posting some revenue and other statistical data if you are so inclined. That stuff is also very interesting.
That is pretty much how I usually do it in my projects. I like using this style to cache the config object and have a namespace for it so I can reach it everywhere. Something like: window.MyProject = window.MyProject || {}; MyProject.getConfig = (function() { var _CONFIG; function _createConfig() { var APP_TITLE = 'Application Title'; var APP_VER = '9-30.2014'; _CONFIG = { version: function () { return APP_TITLE.concat(' ' + APP_VER); } }; } return function() { if ( !_CONFIG ) { createConfig(); } return _CONFIG; }; })(); // In some js file console.log(MyProject.getConfig().version());
Please include an example of watch in your article. It's a very useful feature and I don't think I saw an example of npm scripts that does that.
What is his point exactly? You shouldn't use the new operator? And you shouldn't be attached to your style of coding? Well I like to put the first curly bracket directly after the function declaration and not in a new line after it.
I agree. I and a few coworkers who I'd like to think are pretty sensitive toward this sort of thing just agreed on a base class for UI components. Things inherit from it, but that's pretty much where it stops in terms of inheritence. After that it's all composition. Not by fiat, but just for me I don't see much value in big deep inheritance trees. But a limited amount of inheritance makes sense to me, at least in certain domains.
I do this via a JSON file (well JS actually since I don't like JSON syntax as much): 'use strict'; module.exports = { environments : { kue : { port : 3296 , server_port : 3000 , server_name : 'XPlayer Queue' } , cassandra : { host : '127.0.0.1' , port : 9160 } , redis : { host : '127.0.0.1' , port : 6379 } , cdn : { pull : [ 'w1.w.#{domain}', 'w2.w.#{domain}', 'w3.w.#{domain}', 'w4.w.#{domain}', 'w5.w.#{domain}' ] , push : [ 'f1.f.#{domain}', 'f2.f.#{domain}', 'f3.f.#{domain}', 'f4.f.#{domain}', 'f5.f.#{domain}' ] } , localCdn : { pull : [ 'w.#{domain}' ] , push : [ 'f.#{domain}' ] } , pushZoneSettings : { ftp_host : '--private key removed--' , ftp_username : '--private key removed--' , ftp_password : '--private key removed--' } , libraries : { jQuery : '//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js' , react : '//fb.me/react-with-addons-0.11.1.min.js' } , localLibraries : { jQuery : '/js/jquery-2.1.0.js' , react : '/js/react.js' } , rip_hosts : require( './rip_hosts.js' ) , web_server : { task : 'web_server' , includes : [ 'cdn', 'libraries' ] , startPort : 12567 , csrfMaxAgeMs : 1000 * 60 * 60 * 24 * 30 // 30 days , csrfHashAlg : 'sha256' , apiHostName : '(^|.)api.*' , payHostName : '(^|.)payment.*' , folders : { frontend : './frontend' , css : './frontend/css' , js : './frontend/js' } , jsonSpaces : 0 } , local_web_server : { includes : { __local: 'web_server', cdn: 'localCdn', libraries: 'localLibraries' } , jsonSpaces : 4 , dev : true , folders : [ './lib/tests' ] } , encode_server : { task : 'encode_server' , includes : [ 'kue', 'cassandra', 'redis' ] , video_extensions : '3g2,3gp,aepx,ale,asf,asx,avi,avp,avs,bdm,bik,bsf,camproj,cpi,divx,dmsm,dream,dvdmedia,dvr-ms,dzm,dzp,edl,f4v,fbr,fcproject,flv,hdmov,imovieproj,m2p,m2ts,mkv,mod,moi,mov,mpeg,mpg,mts,mxf,ogv,pds,prproj,psh,r3d,rcproject,rm,rmvb,scm,smil,sqz,srt,stx,swf,swi,tix,trp,ts,veg,vf,vob,vro,webm,wlmp,wmv,wtv,xvid,yuv' , folders : { encoding : './server/encode_cache' } , video_sizes : [ 6400, 4096, 2800, 1920, 1280, 960, 640, 480, 320, 160, 80 ] , audio_kbps : [ 320, 320, 320, 192, 192, 128, 96, 96, 64, 32, 0 ] , thumb_sizes : [ 900, 300, 200 ] , strip_borders : true , max_bpp : 'Math.pow( ( {{width}} * {{height}} ) / ( 1280 * 640 ), 0.75 ) * ( {{framerate}} / 25 ) * .05' , bpp : 'Math.pow( ( {{new_width}} * {{new_height}} ) / ( {{old_width}} * {{old_height}} ), 0.75 ) * {{old_bpp}}' , video_formats : [ { video : 'h264' , audio : 'aac' , ext : 'mp4' }, { video : 'h265' , audio : 'aac' , ext : 'h265.mp4' }, { video : 'VP8' , audio : 'ogg' , ext : 'webm' } ] , encode_full : true , encode_keyframes : true , rip_subtitles : true , rip_stills : 50 } , local_videos : { includes : { __local: 'encode_server', kue: 'kue', cassandra: 'cassandra', redis: 'redis' } , folders : { encoding : '/Users/mark/Downloads/Videos/encoding' , watch : '/Users/mark/Downloads/Videos' } , power_mode : 'AC' , 'kue:server_name' : 'Video Encoding Queue' , video_sizes : [ 6400, 640 ] , audio_kbps : [ 640, 300 ] , max_bpp : 'Math.pow( ( #{width} * #{height} ) / ( 1280 * 640 ), 0.75 ) * ( #{framerate} / 25 ) * .1' , thumb_sizes : false , video_formats : [ { video : 'h264' , audio : 'aac' , ext : 'm4v' } ] , encode_keyframes : false , rip_subtitles : false , rip_stills : 0 } } }; Then I have a script that reads this and processes various pieces of it: 'use strict'; var path = require( 'path' ) , nconf = require( 'nconf' ) , Promise = require( 'bluebird' ) , configPromise ; // require all pre-init files require( 'require-all' )({ dirname : path.join( __dirname, 'setup' ) , filter : /^0_.*\.js$/i }); nconf .argv () .env () .defaults( require( './config.js' ) ) .use ( 'memory' ) ; module.exports = { setEnv : function( env ){ nconf.set( 'env' , nconf.get( 'environments:' + env ) ); nconf.set( 'env:name', env ); var includes = nconf.get( 'env:includes' ) , folders = nconf.get( 'env:folders' ) ; if( includes ){ if( {}.toString.call( includes ) === '[object Array]' ){ var incs = {}; includes.forEach( function( val ){ incs[ val ] = val; } ); includes = incs; } Object.keys( includes ).forEach( function( incName ){ var incPath = includes[ incName ] , incData = nconf.get( 'environments:' + incPath ); Object.keys( incData ).forEach( function( key ){ var keyNm = ( incName.indexOf( '__local' === 0 ) ) ? 'env:%s' .sprintf( key ) : 'env:%s:%s'.sprintf( incName, key ) ; if( nconf.get( keyNm ) == null ){ nconf.set( keyNm, incData[ key ] ); } }); } ); } if( folders ){ if( folders instanceof Array ){ folders = folders.map( function( folder ){ return path.resolve( folder.indexOf( './' ) ? __dirname + '/../' : '/' , folder ); } ); }else{ Object.keys( folders ).forEach( function( key ){ folders[ key ] = path.resolve( folders[ key ].indexOf( './' ) ? __dirname + '/../' : '/', folders[ key ] ); } ); } } var subModules = require( 'require-all' )( path.join( __dirname, 'setup' ) ); configPromise = Promise.all( Object .keys( subModules ) .map ( function( key ){ return subModules[ key ]; } ) ).then( function(){ module.exports.conf = nconf; return Promise.resolve( nconf ); } ); nconf.setEnv = rejectSetEnv; return configPromise; } , then : function(){ if( !configPromise ){ throw new Error( 'Please set the config environment before calling config::then' ); } return configPromise.then.apply( configPromise, arguments ); } , hasTask : function(){ var task = nconf.get( 'env:task' ); for( var i=0, l=arguments.length; i&lt;l; i++ ){ if( arguments[i] === task ){ return true; } } return false; } }; function rejectSetEnv(){ throw new Error( 'config::setEnv can only be called once' ); } I do the same thing in client-side JS via browserify
I think this is kind of in a gray area whether this is appropriate, because there is no source to inspect and you're basically just promoting your non-free product. _However_, your [submission history](http://www.reddit.com/r/javascript/search?q=author%3A%27rezoner%27&amp;restrict_sr=on&amp;sort=new) for /r/javascript is commendable, and you're actually a real redditor (you make and respond to comments), so I think we can let this go. For what it's worth, if you wish to post another game in the future, I think it'd be more palatable if you included a simple write-up about the project when you post; just a paragraph of two covering libs/techs used, surprisingly hard and easy facets of the coding, etc.
more like "rape my ears" amiright. 
DEC64
Good stuff. Schemas are really underused and can be useful for so many things. Can mschema be translated back to json-schema?
This is awesome. I lol'd pretty hard at "Scrum Master stay off my back". 
That's a gross oversimplification. If you were to put "anything you'd put in a prototype" as part of the constructor, a new instance of every bit of code in there would be created for each new object. If you've created thousands of instances of your "class," that means any methods that *would* normally hang off the prototype, and be "shared" between instances, are now duplicated in memory.
so Windows is ill? :o
to me, jQuery Slim is a minified jQuery, some fat, some slim, some obesity...
Flow is something fundamentally different than typescript. It's a type checker that can run on effectively unmodified Javascript. You may need to add an occasional type annotation to clarify something if `flow` gets it wrong, but for the most part you can throw an existing Javascript codebase at it and it will typecheck the entire thing without modification. Obviously not everything Javascript can do can be typechecked. But as described in the video, they get pretty damned close with the occasional dynamic escape hatch as needed. The implication is that you *can* type check normal well structured Javascript code. If you're really not understanding the fundamental difference between what Flow does and Typescript, then have a look at an ML-family language such as F# or OCaml. You could write a million-line codebase and not put in a single type-annotation, but it is still 100% type-checked by the compile. There is no optional typing. &gt; I can't tell if you are arguing for or against type annotations. I like to put type annotations in my code. But the point I'm trying to convey to Javascript developers, who seem so strongly against static-typing because it's slightly more verbose, is that you can *have your cake and eat it*. You can have static typing *without* type annotations. In Javascript. /This is entirely based on the video, presenting an implementation of a type-system for Javascript similar to something I've been pondering about on paper for a while, but Facebook well and truly beat me to a much better working implementation. 
Is just checkin `__proto__` existence is enough? I thought we should check how ancient a browser is.
Single inheritance was an answer to C++'s multiple inheritance. Having worked in C++, Java, and C#, I'd say single inheritance has the lowest maintenance cost because it doesn't give the developer enough rope to hang themselves. I'd point to Spring, which takes it a step further by trying to bake it in and hide the inheritance from the casual application developer. Chances are, there's already a class that has everything you'd want to inherit. With Javascript, thankfully prototypical inheritance is so convoluted an idea to most folks, they don't mess with it. POJO, baby! Are you trying to imply that it's more expensive to hire a JS developer? Tell me more!
browser like doing that
What do spades have to do with tabs?
A family of languages that implement a lot of advanced type-system features. OCaml, SML, F#, Haskell are some relevant modern implementations. Scala also kind-of falls into this category, and could be considered a bastard love-child of ML and Java. These languages tend to be considered niche, however they are extremely influential and are driving the design of a lot of modern languages. 
TIL. DEC64 is definitely cool, but there are downsides to consider. It might screw with Emscripten, typed arrays, SIMD, etc. Sure, a universal number type is a Good Thing, but there isn't a hierarchically best choice.
It seems to work fine for older versions of IE. I know in older versions of Firefox i.e 3x it fails, but I've not seen anyone in my logs using it in a long time. It's the same code I use for jquery/zepto
Thank you for making the effort to show how my code would be represented in the Crockford method. You do actually make a fair point about losing function scope, because afaik my method doesn't allow for private variables. That said I'm still not sold on the method duplication...
This is a sharp and wonderfully entertaining implementation of a super dumb idea! Love it.
I suppose what I mean is that I *instantiate* my classes using new, which in turn means that I can set the constructor prototypes using Object.create() and the modify them. But you're right that I forgot to do this, thanks! I've edited the code.
This article considered harmful. It promotes writing slow code, almost impossible to be optimized by modern JITs. &gt;You never need classes in JavaScript, and I have never seen a situation where class is a better approach than the alternatives. Classes promotes less memory consumption, code reusability, support for hidden class (leading to many optimisations). Decorators should be used with prototypes, not instances.
&gt; Single inheritance was an answer to C++'s multiple inheritance. This is not correct. As a concept, single inheritance necessarily preceded multiple inheritance. The hotly debated topic in the late 90's showed that multiple inheritance was about as expensive as refactoring for new paradigms, in the long run (of course, ironically, no actual studies to back this up...meaning it's subjective based on personal experience). It took almost 2 decades, but languages have grown out of the concept of a single inheritance tree. JS doesn't do much to change that (relying on mixins and composition alongside prototypical chains). &gt; Are you trying to imply that it's more expensive to hire a JS developer? Tell me more! If you're going to lump all JS developers in the same breath, you've already made up your mind. It doesn't change the fact that single inheritance is workable, but less than optimal.
whoa man, those libraries are awesome. I actually have a question about canvasquery. I noticed the cq.blend method. If i recall canvas can only use a single blend mode per canvas, so does that mean you use a different canvas for each layer, or are they seperate offscreen-canvases that are then merged onto a final one? Or did you write your own form of blending? I'm really curious to the implementation behind it.. 
this article didn't get much traction here, but I am eagerly awaiting the other parts of this article. keep up good work.
Untrue, you can redeem it at any time if you send them a message (and you only have to do this if you're previously received some form of promotional credit). I got my credits applied!
I've been posting it after getting it on Google play store.
Is facebook using this in production? With react/flux? 
How does it compare to mori?
You're right, of course, but single inheritance only predates multiple inheritance by about 2.4 billion years. I mean, it took them longer than that to develop Duke Nukem Forever.
A few teams are rewriting stuff with it and testing internally, but I don't think anything uses it in production yet. On my team we're not using immutable-js yet, we're just using Object.freeze at the moment. Some of the data structures in immutable-js look really handy though. Immutable objects work really well with React since it allows shallow comparisons, and means you can do a shallow comparison of your props in `shouldComponentUpdate` to only re-render when things actually change 
you might be reading too much into his tone. It's definitely worth being civil to people, but it's annoying picking up after people who are coding in a style that is only maintainable with heavy tooling. Since JavaScript give you a huge amount of rope with which to hang yourself, and does not have much tooling, sometimes best practices need to be passed down with unambiguous statements.
You're right. Your IDE should be the one doing the checking for you. I don't worry at all.
k. Thanks. I was just thinking if there's a way to strictly follow the DRY rule.
Could you please give me more details on your browser. 
I think the problem is not in you, but in her.. I clicked it a few times and nothing happened. What's a senseless bitch:/
Thanks for trying:)
Eric really, *really* dislikes inheritance and the "new" keyword. He has a library called "Stampit" that he promotes as an alternative approach to design. This essay is more of the same. He tends to overstate the situation and use straw-man arguments. I don't have time right now to go into more detail, but he and I had a long conversation about this after I posted a video about how OOP works in JS. It's here: https://plus.google.com/+Binpress/posts/ZjnpNGnw7EP 
After I click it several times it starts. I'm not sure what to do then though, it just says game over. I tried clicking on the falling stuff but to no avail.
It's to match es6 semantics. You'll get the same results with a native `Map`, which helps with interop between implementations.
You can do something like that with a user script (Firefox: Greasemonkey). Another option is Selenium WebDriver. It's used for doing end-to-end tests. Basically, it lets you control a browser via Python, JS, Dart, or whatever. Click here, enter this, tick this checkbox, upload this file, etc... that kind of thing. Similar but quite different: PhantomJS. It's a headless browser with a JavaScript API. Another option is to skip the browser completely. Just send the request and check what you get back.
its a little confusing that you have to click on the text and not the entire screen
Firefox 28 for Linux Mint 32-bit
Here's a ground floor to build off of. Add a new bookmark (in any browser), and set the following as the URL for it: `javascript:(function(){alert('Hello world!')})();` Now any time you click that bookmark, you will get an alert window popping up. This is analogous to going to the browser's console and just typing `alert('Hello world!')` From there, you can replace the alert() with, y'know, purposeful code. Rather than emulating keypresses, you can directly manipulate the fields. Instead of looking at it like, "I need to tab 8 times to get to this element" and "I need to paste this value into it", you could look at it like "I need to select this element, and put a pre-defined value in there". As an example on Reddit, you could do the following as a bookmark: `javascript:(function(){document.getElementsByName('text')[0].value='Javascript sure is cool!'; })();` And if you clicked that while on a page with a comment box, it'd put that text into the comment box. and if you wanted to submit such a comment, then you can add a line for clicking the "Save" button: `javascript:(function(){document.getElementsByName('text')[0].value='Javascript sure is cool!'; document.getElementsByClassName('save')[0].click()})();` I don't know much about timeouts, but I do know that you can include them inside of those scripts. If you're not familiar with what this "document.getElementsByWhatever" stuff, that is called the Document Object Model (or DOM). That stuff takes a while to wrap your head around, but there are resources out there. I can give a brief intro if you'd like. (Also, feel free to write those scripts across multiple lines. You can copy and paste into the browser, and it should properly handle collapsing it down)
&gt; entity.move = function(dx, dy){ &gt; ... &gt; } Isn't every time you create a new instance of Entity, a new function object is also created?
I hate prototyped languages - they feel like deformed class languages, mixing everything up together. Yach.
Prototyped languages are nasty! They're the read headed stepchild of classes.
Much as he might dislike it, he's still using it. His library uses prototypal inheritance and at some point you *have* to use `new` in order to use it. And it's right there in the (private) `create` method in his library, along with the adding methods to a prototype (hidden behind a `require`d module). I think his point is that as so many people just don't get how prototypal inheritance works as they are stuck in classical inheritance mode, writing this library - which also has the benefits of easy object composition - enables it to be done properly every time. Whether that is a Good Thing™, or just shields from ignorance and arrogance is an exercise left to the reader... All this "write code against an interface" malarkey conveniently ignores the fact that at some point that interface itself will need to be written. As it isn't interfaces all the way down, you'll have to use "oldskool" methods of coding them as they are the only way to do so.
Thanks for the feedback! :-)
Perhaps my understanding of Javascript is a little outdated, but isn't that going to create a new function with a closure for every instance of Entity? Wouldn't this have profound implications on memory use and the JITs ability to optimise it? More importantly, what benefit to you get from using this pattern instead of using `new`?
Have you looked at [moreartyjs](https://github.com/moreartyjs/moreartyjs)? It is a layer between immutable.js and React that takes care of state management and stuff like `shouldComponentUpdate`. I'm planning to doing a project with it soon and wonder if it is as good as I hope.
The point was not to get bogged down in implementation details, but to create a high-level rant intended to get people thinking about and discussing the topic in more depth. Apparently, it worked. Google "classical inheritance harmful" and you'll find articles with plenty of code examples. Here's a nice quote: &gt; I once attended a Java user group meeting where James Gosling (Java's inventor) was the featured speaker. During the memorable Q&amp;A session, someone asked him: "If you could do Java over again, what would you change?" "I'd leave out classes," he replied. After the laughter died down, he explained that the real problem wasn't classes per se, but rather implementation inheritance (the extends relationship). Interface inheritance (the implements relationship) is preferable. You should avoid implementation inheritance whenever possible. Link (with code samples):http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html A nice list of quotes and links on the topic by software luminaries: http://harmful.cat-v.org/software/OO_programming/
I've been following Meteor since about December 2012. My shop now has three major Meteor apps in production and a few smaller ones. So I've been able to learn the framework pretty thoroughly by doing real work with it. The reasons we feel more productive with Meteor include: * It has a zero configuration build chain that handles compilation and bundling of all files for both client and server, and automates hot code pushes for JS/HTML changes and live injection for CSS changes. * The package system makes it easy to create reusable components that may include both server and client code and rely on various dependencies, which are automatically exposed as fake "globals" only to the packages that depend on them. There are built in patterns for creating file-scope variables, package-scope variables, and exported variables (which again are only exposed to other packages that actually depend on them). No need to wrap every file in an IIFE for scoping; it's handled for you. * The best example of this kind of component is the drop-in user accounts system that supports both the Secure Remote Password protocol for local accounts and various OAuth login services like Facebook and Twitter. You can add a full-featured asynchronous password/oauth login/register UI component to a template with one line, or easily build your own. * There's nothing to glue together, no REST endpoints to hook up. DDP makes things really simple. Just publish data on the server, subscribe to data on the client, and add allow/deny rules for validation. Now every client and server instance automatically has up-to-date data all the time, and clients can use an isomorphic database API to safely/securely interact with data. * It has several isomorphic APIs with latency compensation such as the database API, so that the client code can be written to simulate server code and anticipate the result before it receives the actual server response. This makes the UI feel extremely snappy and reduces code duplication (such as data validation code). * We find that the UI code is simpler to learn than Angular. There is no mandatory mixing of logic into HTML attributes. Everything uses a declarative syntax, and the Template-Helper-Event system is very easy to reason about without using any obscure terminology. * It has built in support for simplifying using PhoneGap/Cordova with your app, which is necessary for many of our clients. As far as learning resources, for the next 5 days you can get the first 8 chapters of the [Discover Meteor](https://book.discovermeteor.com/starter) book for free. You just have to create a Meteor Developers account. If you don't want a free book, you should at least check out the [tutorial on Meteor.com](https://www.meteor.com/try). If you want, you can complete the whole tutorial (except Step 7) on [Nitrous.io](https://www.nitrous.io/), so you don't even have to install Meteor on your computer.
I haven't checked both of em but i've got the same feeling. Just wondering what others think about this...
I do something pretty risky but it has been working on so far. Even though I have a full time job, I take small freelance contract, where I choose something that I have never used before. It feels like when there's a client (and money) on my ass, my brain works so much better. I learned Angular, Backbone, Ember, Knockout and React this way. Just make sure you're not overwhelmed. Do small stuff. For example, don't try to learn a new backend language + new frontend framework. I did that once, bad bad idea. 
Make JS your hobby. At least for some months. Dive into the full MEAN stack. Build some meaningful hobby projects. For instance, an API with Node.js and MongoDB. Put a single page app on top of it with Angular. Dive into gulp, browserify, mocha, sass/compass and see what it can do. If you come from the LAMP stack like me, just start out by going to the Node.js website, install Node.js and run the sample code on their frontpage. I did - and I just sat there for several minutes looking at the "Hello world!" in the browser. A full backend server stack in a simple, one-time, zero-configuration, cross-platform installation and *6 lines of code*. Six. Lines. It will take you days on days of configuration and getting to learn the paradigms of those but it is the best decision I've made in recent times. Sure, the JS community is fragmented between so many tools and paradigms that it can be hard to keep up but my god is it fun to work with and you can get so much done with very little code. I'd love to move to working with it full time at some point. EDIT: Also, pay for some of the premium sites with tutorials. The quality is quite high. That accelerated me a ton.
Standards are great. We already had one: Object literal support, and the fact that any function can build and return an object. It's the inevitable proliferation of the extend keyword that will do the damage.
of course `;` is important. That's why we have them.
ng-book.com
If you've written much JS at all, you've already seen many examples of classical inheritance alternatives in the wild. Maybe you just don't think of them that way. See jQuery, for example: Every jQuery selection returns an instance of the jQuery object, with all the .fn plugins attached. Every app that uses jQuery is making heavy use of prototype delegation and concatenative inheritance. jQuery isn't my favorite example though, because .fn is basically a global namespace playground, but it's on about 50% of all websites, and is by far the most widely used JavaScript library. So almost everybody who writes JavaScript is using concatenative and delegate prototypes pretty heavily, whether they know it or not. That's the beauty of prototypal OO, though, you don't have to know anything about it to be productive with it. Try teaching somebody how to emulate classes with prototypes, though, and they get confused. Ask them to inherit from multiple class sources, and they get even more confused. ;) Speaking of jQuery, $.extend() and underscore's popular _.extend() are both implementations of concatenative inheritance, both in very wide use by just about every large JS app ever made. Want to see this in the wild? view source on most popular web apps: Twitter, Adobe Creative Cloud, etc.. You'll find copious references to $.extend() or _.extend(). Other large apps make heavy use of small modules and/or components as alternatives to classical object inheritance as a code reuse mechanism. For instance, view source on Facebook and you'll find dozens of files which are essentially independent UI components with their own JS and CSS files. In reality, most JS apps mix many code reuse patterns, including inheritance and classical extends (because many lib authors export constructors and some provide a classical extend mechanism).
To be honest, I don't really see it as a fundamental difference. Inheritance using prototypes is just as likely to paint you into a corner as inheritance using classes. Whether I was using Java or Javascript, best practice is to avoid inheritance in most cases. The underlying mechanism is different, but it's still the same code-smell regardless. Neither language feels particularly strongly orientated towards discouraging you from doing this. I fully admit that I have less an understanding of the internals of Javascript than I do other languages, so am happy to have my opinion changed - but so far I've yet to see any real conceptual difference between Java and Javascript inheritance from the point of view of ending up in a twisted mess of inheritance. I'm well aware that the underlying models are *completely different* and can behave quite differently in certain circumstances, especially at runtime, but once you boil the implementation details away I just don't see the difference in terms of painting yourself into a corner. Bad design is bad design in both cases. &gt; and you employ concatenative inheritance instead of extend ("is-a" relationship inheritance). I agree this is a better solution when code reuse is required, but this is hardly unique to Javascript. (I'd go so far as to say it's discouraged by Javascript and requires library support to do it properly, when compared to, say, Python, Ruby, or Scala). &gt; Prototypes in JS have more in common with what happens under the hood of pure functional languages than they do with classes in Java I see very little resemblance between prototypical inheritance and any form of polymorphism in, say, Haskell, SML, or OCaml. In Haskell, Id use typeclasses if I needed ad-hoc polymorphism. In OCaml, if you squint really hard, module functors could be thought of as something that vaguely resembles prototypes, but not really. This comment is not intended to be argumentative. I'm happy to change my opinion - I just need more than opinion to convince me.
The most important argument in favor of constructors is possibility to enforce usage of hidden classes. Hidden class is type of optimisation performed by modern JS engines. Objects without changing keys can be optimised to O(1) access to their properties. More - objects with the same hidden class can be stored in array without almost any meta data (no memory overhead) as pure, nonboxed pointers.
With good reason. I've seen the complexities of class inheritance plague many real-world projects, and nearly cause the collapse of a company because they couldn't ship a product fast enough due to rewrites because they couldn't get the taxonomy design right. The only other time I've seen anything so destructive to programming projects was over use of GOTO statements.
I will try and add some simple instructions. Thanks for commenting!
I actually just put this in a React app last week that's already live and going to be used for a few more days. I haven't gotten around to testing it too much, but it seems to be working fine. Undo/Redo in 3 lines (each) of code!! I think it's a pretty substantial step forward with JS data structures, but what's the deal the documentation? It's so esoteric - typescript, es6?? 
1. (a) All methods of object instantiation and property access in JavaScript are extremely fast -- on the order of 100,000+ ops/sec on the slowest computers available for purchase in the stores today. A small fraction of the time spent in your program is in JS, and a very tiny fraction of that time is spent instantiating objects. (b) There's no reason hidden classes can't be implemented for Object.create. I expect perf differentials to change on this point. (c) You're optimizing the wrong things. The real perf killers are network &amp; other I/O operations, and (for animation and realtime applications), the GC. The fix for the GC is static memory JavaScript (object pools -- one of the reasons I recommend that you avoid constructors, so switching to object pools is less awkward when required). 2. (a) Memory consumption profiles are not different. When you use delegate prototypes, methods are shared on the prototype, exactly the same way they are when you assign methods to a constructor prototype and invoke it with `new`. (b) hidden classes addressed above. Micro-optimization, optimizing the wrong thing, likely to change as engines evolve. (c) I don't know about you, but my laptop has 16GB RAM. My mobile phone has 1GB RAM / 16 GB of fast internal flash storage if paging is required. Memory isn't the constraint it used to be -- even on mobile. If you do find that memory becomes an issue, You're STILL optimizing the wrong things. Target your graphical assets first. You might trim 1k here or there with objects, but you could trim 500x that much by optimizing your images / fonts / css better. 
&gt; But that has nothing at all to do with javascript or it's design. Try it python and you'll get the same result. This is actually because there is not true way to represent 0.1 in floating point binary form. That's a design choice like any other, with tradeoffs, and problems to negotiate. If you were interviewing for a job, and the interviewer pulled this out ouf a hat and said, "How would you design a language so that `.1 + .2 === .3?`, I'm sure you could trot out two or three different ways to make that work properly.
[Mori](https://github.com/swannodette/mori) is a port of ClojureScript's immutable data structures to JavaScript, so yes, it can certainly be done in the library. Mori is amazingly fast, often much much faster than using mutable data structures.
Yes, I was. 
Thanks! Yes, mschema can easily be converted to json-schema. A subset of json-schema can also be converted to mschema. I found that building tools around json-schema was difficult due to the complexity of the document. With mschema, it's much easy to introspect schemas in order to reflect interfaces.
If you don't mind sharing, how many concurrent users do you get and what are your system specs (per app if they're different?) I've also got a production meteor app but I'm not sure if I should beef up the vms or not. 
Hello, thanks. There are few comments but many visits, so I guess it has been appreciated.
Very useful thanks
src: https://news.ycombinator.com/item?id=8539675
Yeah. I'm not doing that anymore. I only resolve what really needs to be resolved e.g. user authentication. I encapsulate other data based parts of the app in directives now each with their own controller. So for example &lt;product-list&gt;&lt;/product-list&gt; is a directive that has a controller assigned which loads the data for that directive. This is great because the directive now can have its own loading animation and it's all nicely self contained. Check this: http://teropa.info/blog/2014/10/24/how-ive-improved-my-angular-apps-by-banning-ng-controller.html
Wow, thank you for the reply. I had never heard of DOM before. I looked up DOM and found [this site](http://www.w3schools.com/js/js_htmldom.asp) which was pretty detailed about it. So I figured out that the text field has a `name` and a `value id` but they both change every time the form is submitted. The page never changes but it loads a new form and the `name` and `value id` are slightly different. I don't know if that changes everything. The code of the text box looks like this: &lt;input type="TEXT" name="v12287w6" size="9" maxlength="6" value id="inputv12287w6"&gt; I couldn't find anything to getElementsByType. I tried to do TagName('input') but it didn't work; it'll get the cursor inside of the text box but doesn't input anything. I tried putting your code `javascript:(function(){document.getElementsByName('text')[0].value='Javascript sure is cool!'; })();` and replacing 'text' with 'v12287w20' and 'Javascript sure is cool!' with '395563' but it didn't work. It shows an error in the console: Uncaught TypeError: Cannot set property 'value' of undefined VM2626:1 (anonymous function) VM2626:1 (anonymous function) VM2626:1 Same thing happens with 'SUMBIT' boxes, except just the *name* changes: &lt;input type="SUBMIT" name="v216220w3" value="Add course to schedule"&gt; I don't know if there's a way to getElementsByValue but I didn't see any. As for the `setTimeout()`, I [found this](http://jsfiddle.net/9LZQp/) which shows the code format and shows it working. What I have so far: javascript:( setTimeout(function() {document.getElementsByName('v85035w0')[0].value='395563'; document.getElementsByName('v153668w0')[0].click()},2000); setTimeout(function() {document.getElementsByName('v216220w4')[0].click()},4000)); EDIT:Even if I don't get this, javascript is extremely interesting and I might actually take time to learn it.
Too bad everything you learn will be useless when 2.0 comes out.
User authentication? Anyhow, I'll have to look into that idea.. I am already using directives for a lot of things and even lists/items (e.g. app-comments, app-comments-item), but not for main page content.. e.g. I have a view which is only a huge list and I am currently using resolve to load the data before displaying the view.. however the waiting time is noticeable, which sucks :)
&gt; Which will stand the test of time? Vanilla javascript. Frameworks are evil &gt;:( 
What do you mean by intersection exactly? Collisions between those basic shapes should be fairly straight forward. For that many shapes you will probably just want to drop down and use the canvas API directly. If performance is not suitable you can use PixiJS for its webgl backend, although you will lose anti-aliasing. 
Thanks for your reply, I'll check PixiJS. In intersection I mean intersection between two item. i.e if one object (like rectangle) intersects the other object (like triangle)
While I mostly agree, javascript and its implementations have long favored a very specific style of using the prototype model to have constructor functions + member functions its prototype property... which effectively feels like classes. ES6 (the upcoming Javascript spec) reifies that pattern via new syntax sugar, in fact.
Same thing. Chrome 37, mac
I loved AngularJS when it first came out, and have been using it for over a year and a half now - but just this week I switched to React because angular just isn't good when it comes to more than 2000 scope watchers (which is very easy to do). Angular is also in desperate need of something similar to React's [shouldComponentUpdate](http://facebook.github.io/react/docs/component-specs.html#updating-shouldcomponentupdate) feature which at the moment seems tedious without hacking into Angular's abstraction layer *($50 BOUNTY FOR A DIRECTIVE WITH AN ATTRIBUTE THAT TOGGLES WATCHERS NICELY!!!!1)*. I originally decided to make my switch to React after my frustration of a creating a fast multi-selectable `ng-repeat` list (about 200 items), my problem was this `ng-repeat` was creating ~10K watchers and bringing my whole apps user input responsiveness to the shitter. I couldn't use solutions like the [bindonce](https://github.com/Pasvaz/bindonce) directive because I needed two-way data binding, and I couldn't find a virtual scrolling directive that disabled watchers of hidden elements. React can handle a 5k data-binded components without fault. I recommend you try React on future projects, I wish I did. Got to get back to porting my Angular apps to React, latez. /rant Learn fast: https://egghead.io/technologies/react EDIT: spelling and grandma
Why the downvotes?! this is unfortunately very correct
I thought it was going to be an inflammatory post saying it's really easy now because you should chose not to use it. It was a pleasant surprise! 
From wikipedia: The WHATWG was formed in response to the slow development of World Wide Web Consortium (W3C) Web standards and W3C's decision to abandon HTML in favor of XML-based technologies. The WHATWG mailing list was announced on 4 June 2004,[4] two days after the initiatives of a joint Opera–Mozilla position paper[5] had been voted down by the W3C members at the W3C Workshop on Web Applications and Compound Documents.[6] On 10 April 2007, the Mozilla Foundation, Apple, and Opera Software proposed[7] that the new HTML working group of the W3C adopt the WHATWG’s HTML5 as the starting point of its work and name its future deliverable as "HTML5". On 9 May 2007, the new HTML working group resolved to do that.[8] 2 competing standards is bad until the "controlling body" gets it wrong. http://en.wikipedia.org/wiki/WHATWG
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**WHATWG**](https://en.wikipedia.org/wiki/WHATWG): [](#sfw) --- &gt;The __Web Hypertext Application Technology Working Group__ (__WHATWG__) is a community of people interested in evolving [HTML](https://en.wikipedia.org/wiki/HTML) and related technologies. The WHATWG was founded by individuals from [Apple](https://en.wikipedia.org/wiki/Apple_Inc.), the [Mozilla Foundation](https://en.wikipedia.org/wiki/Mozilla_Foundation) and [Opera Software](https://en.wikipedia.org/wiki/Opera_Software) in 2004. Since then, the editor of the WHATWG specifications, [Ian Hickson](https://en.wikipedia.org/wiki/Ian_Hickson), has moved to [Google](https://en.wikipedia.org/wiki/Google). Chris Wilson of [Microsoft](https://en.wikipedia.org/wiki/Microsoft) was invited but did not join, citing the lack of a patent policy to ensure all specifications can be implemented on a royalty-free basis. &gt;==== &gt;[**Image**](https://i.imgur.com/82vD5Wm.png) [^(i)](https://commons.wikimedia.org/wiki/File:WHATWG_logo.svg) --- ^Interesting: [^HTML5](https://en.wikipedia.org/wiki/HTML5) ^| [^Comparison ^of ^layout ^engines ^\(HTML5)](https://en.wikipedia.org/wiki/Comparison_of_layout_engines_\(HTML5\)) ^| [^HTML](https://en.wikipedia.org/wiki/HTML) ^| [^Microdata ^\(HTML)](https://en.wikipedia.org/wiki/Microdata_\(HTML\)) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+clq4reu) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+clq4reu)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
This is some hefty signal processing that would also need to account for interfering noise, harmonics of the strings/harmonic profile of whatever instrument it is, etc... If you are trying to write melodyne in JS, your life is gonna suck... i'd recommend structuring your app so that it's not the user's browser JS running the analysis, rather you stream the audio to your server and run a compiled native binary to analyze it, it might be more achievable. Your google-fu should help you find programs which can get you closer to what you're thinking of.
Frameworks are not only about keeping you from making mistakes, you can make just as many mistakes with a framework. Frameworks are about development speed and maintainability. I went through vanilla javascript =&gt; jquery =&gt; backbone =&gt; angular and now learning react. Each step allowed me to make bigger and still maintainable codebases. Jquery makes html manipulation and ajax easy, Backbone gives a structure for an app, Angular is backbone on steroids with DI, directives, data-binding and other goodies. React looks to be a next step with its Flux architecture and virtual dom. (Edit: Still, I could be completely wrong about React) I have eaten enough spaghetti jquery and I refuse to move back. I just can't imagine working effectively without a framework. tl;dr Frameworks remove complexity and actually allow you to solve real problems.
For intersection there are lots of small modules you might be able to take advantage of, e.g. https://www.npmjs.org/package/triangle-circle-collision
That would suggest that there will be no migration path, that 1.3 will no longer be around come 2.0, and that the concepts are completely different - none of which is true. Your comment is a gross oversimplification of the issue.
Yeah, it you have a bunch of things of the same type, it makes sense to pull the repeated code up into a base class. Probably the biggest issue is that composition is a harder concept to grasp and so awkward inheritance structures get build that shouldn't have existed in the first place.
Plus 2.0 is like a year out, and 1.3 will be supported for another 1.5-2 years... So who knows what new/better/different technologies will be out by then anyway. Learning different tools is never bad
None of these things are specific to Angular, so the point stands: why learn 1.x vs another framework like backbone? What do you get out of picking a soon-to-be-deprecated framework?
I wrote a web game called [Nevergrind](http://www.nevergrind.com) that has over 75k lines of code using no frameworks. No bootstrap. No angular. No backbone. None of that shit. I do use JQuery and [Greensock](http://www.greensock.com). That's about it. I couldn't agree more. 
Is this good enough? https://github.com/cwilso/pitchdetect Demo: https://webaudiodemos.appspot.com/pitchdetect/index.html
It's not. Angular 2 is expected to be released at the end of next year. Angular 1.3 will be supported for 1.5 to 2 years after that. Source: http://www.infoq.com/news/2014/10/angular-2-atscript Given how different 1 and 2 are upgrading to 2 will take time. And that's if they upgrade at all. Given how strange 2 is looking I wouldn't be surprised if a 1.3 fork took over.
&gt; With time they'd develop their own little framework that suits their creative style anyway. That would offer them complete control over every aspect of the project, with no real downsides (someone correct me if you think I'm wrong). The issue is having a framework that other developers can pick up quickly. If you are a solo developer, you can do whatever you want. If you work on a team, you have to pick the tools that save the team collective time. Frameworks tend to do that by reducing the amount of training time a new teammate requires. It is also beneficial because you have the option of hiring people that already know the tools you are using instead of having to completely train someone on your custom framework.
Totally agree. Most of those frameworks are suited for large single page applications. But for traditional multi-page sites they become a bit bloated. We have built some big sites at work using our own framework (150 lines of code). It covers the most important part of a framework in my view, encapsulation of Javascript and views. And has some extras for events and ajax. Makes us very productive and there is no spaghetti.
You call it nevergrind, but it seems like the whole game is grinding...
Just use whatever works for your project at the time.
Things that backbone will never give you? Backbone maybe is not deprecated. But it sure as hell is morally obsolete. 
Meteor had scaling issues from the start because it used periodic polling rather than oplog to keep server data synchronized. Now every server instance can use oplog tailing if you enable MongoDB replica sets. Additionally, since the meteor server only needs to actually send *data*, not HTML or the client JS bundle, it is easy to use CloudFlare or another caching layer to serve all your static assets. This means the meteor server doesn't have to worry about sending big files, just incremental data updates. Thus, the main scaling issue becomes the requirement to use MongoDB and choosing how much data you publish. A redis database driver is currently in the works, and Postgres seems likely next. Here's some more info on scaling meteor: https://www.discovermeteor.com/blog/scaling-meteor-the-challenges-of-realtime-apps/ 
I'd never seen greensock. Pretty cool.
Not sure why asking a question gets downvoted here.
native map? I've tried this in node and the browser and it simply doesn't work. I don't know what you're talking about.
This is spot on. The only point I'd add is that you can google how to work with a known framework. If it was built in-house, and there is no documentation, good luck. On the other hand, if the team is really good at documenting everything, actually writing unit and integration tests, it could *potentially* be easier than figuring out a framework. But this is not likely, since most developers don't write tests or documentation.
I only tried tutsplus and it had huge value for money. Honestly, if you do programming for a living, you should just try a handful of them for a couple of months. It might be like $10 per site for a couple of months but really, you'll learn much faster. Tutsplus have really good database tutorials for both mongo, redis, postgres etc. They also have really good basic JS tutorials that I highly recommend to get a basic JS skills without frameworks. Especially since with angular, you want to get rid of jQuery and just use a handful of native methods when necessary. They also have a couple of Node.js tutorials and just released one about testing with mocha, sinon and chai that are all tools I already love and use. Definitely start with testing early, it makes programming JS so much more fun. For angular they also have a handful of tuts but you could go to egghead.io instead for that.
I guess you didn't notice that you're constantly doing a quest, but ok.
Agree except the React. I don't think you can say React is next step. For you maybe, but for typical Angular devleoper, Angular 2.0 will be the next step.
Unequivocably agree with everything you said. The problem lies in people always looking for shortcuts instead of learning how things work. A framework can be OK if you have one web site for one company and you code for that which was laid out from the beginning. Using frameworks for everything means you're using someone else's code and you shoehorn everything into that. It's a shortcut to doing necessary work. Not doing the work means not learning. Mistakes are a good thing. You learn from those, too. We see these shortcuts in many ways nowadays, not just programming, and that's not a good thing.
Remove the parentheses around your code. In JavaScript, the parentheses can be used to evaluate a single expression first. However, you're surrounding multiple expressions with parentheses, which is why the semicolon is unexpected. If you really wanted to, you could use [commas](http://javascriptweblog.wordpress.com/2011/04/04/the-javascript-comma-operator/) instead of semicolons and keep the parentheses, but it's unnecessary. As for making the code loop indefinitely, you could do something like this: javascript: function submitForm(){ document.body.querySelector('input[type="TEXT"]')[0].value='395563'; document.body.querySelector('input[value="Add course to schedule"]')[0].click(); setTimeout(function(){ document.body.querySelector('input[value="Cancel"]')[0].click(); setTimeout(submitForm, 2000); }, 4000); } submitForm(); When the code is first run, submitForm will be called, which will fill in the class number and click the button to add the course. submitForm also sets up a timeout to click the cancel button in four seconds. That timeout in turn sets up another timeout to run two seconds after it runs. Two seconds later, the second timeout will fire and call submitForm, which repeats the process all over again.
&gt; I’m quite found of the language and have sympathy for its quirks, but it’s just missing something to be productive once your code becomes more that half a dozen of classes. Stopped reading there.
You might be right. I don't have enough real world experience with React to be sure if Flux and virtual dom are good ideas. It will be interesting to see what people are going to choose when Angular 2.0 comes out.
NIH Syndrome kills projects of all types.
I agree with your tl;dr, but I think a big part of why you find they remove complexity is because you've gone through the learning curve, starting at learning vanilla javascript. Devs who learn vanilla JS and continue to update their skills invariably write far better jQuery code than those who started with jQuery and never bothered to learn the fundamentals. I see quite a few devs who can't even do things as fundamental as a for loop, or understand how an object is constructed in javascript, because their whole approach to development is to ask 'is there a jQuery function or library to solve this problem?'. Their code turns to garbage very quickly. Angular is excellent - it's a well-architected library, and if you have strong js fundamentals it's very useful. If you blunder through it without even the basic knowledge of what a callback function is, and your code is just a bunch of hacked up copypasta, angular will be a burden on the next developer who has to look at your code.
The `new` you point out is a partial polyfill of `Object.create()`, which is now native to JavaScript, but wasn't implemented in all the popular browsers I had to support when I wrote the lib (It's an ES5 feature). Also, it's used to hook up a single prototype (inherit directly from another object), not to emulate class inheritance. There's a big difference. Also note that I don't export the constructor, which means that all callers are shielded from instantiation details. And none of the inheritance the lib enables forces you to code to the implementation details of the prototype objects, which is quite different from how classical inheritance is typically done in JS, which often exposes super mechanisms, etc... When you're writing the interface, you're not coding to the implementation from callers and descendent classes, which means that changes to the implementation details are encapsulated in one place (provided that the new implementation respects the contract and remains correct). In other words, code that uses Stampit is not at risk of any of the dangers I expressed in "The Two Pillars of JavaScript."
I could give a shit less about an MVC JavaScript framework. For most of the work that I do JavaScript is just icing on the cake. If you were building an SPA, all of these things are dandy to think about. But for now, I'm just going to build what I need with the smallest tools possible.
Even if you don't use a third party framework, you usually end up making your own framework to abstract away commonly reused things and speed up development time and reduce bugs.
Here's a fiddle that illustrates the best way I know to render calls from a JSON-P endpoint: http://jsfiddle.net/du5mmxLw/ This example passes the top-story RSS feed from Hacker News through YQL, which wraps it in a callback and hands it back to the page. (YQL and Pipes are both fine ways to roll your own JSON-P endpoints.) It's a bit more robust than necessary; while the usual example of a dedicated callback for a hard-coded API request will work, what most people want to build is a way to send and receive multiple callbacks to several different API endpoints, and to have some idea about which result goes with which callback. To handle this sort of thing I like to build an array of callbacks, push one for each remote call, and include the array index as part of the callback. When a callback arrives: foo.bar[4] ... the array index 4 is available inside, like this: foo.bar[n] = function () { // n is the callback's array index console.log("This is callback number " + n); }; If you're doing something like typeahead search or lazy loading, callbacks may arrive out of order. If you've already rendered callback 6 and callback 2 shows up, you want to drop it on the floor. To see a much more complicated example of this sort of thing in action, look at the source for Pinterest's third-party widget suite, on GitHub here: https://github.com/pinterest/widgets/
"Creating a niche object style also seems so counterproductive to one of the great advantages of JS-- having a massive library of small, modular functionality available on npm." Exported stamps work just like any other exported function that returns a new object. Stampit() itself is available on npm, and I have used it in several libraries which are also available on npm, as have other npm contributors. Stamps just supply a little automated sugar for painless composition. It removes the need for developers to think about the implementation details of composition, factory functions, etc... “Simplicity is about subtracting the obvious and adding the meaningful.” ~ John Maeda 
With larger projects and team, frameworks are absolutely necessary. Even ones you build internally. At my job we write dozens of small well-tested/well-documented libs that we use all over our main codebase. For smaller projects, I of course don't want to bloat them with a ton of unnecessary tools. However at the same time, small projects are a great place to try out new tools and develop opinions about them that will help you in making decisions for your larger projects.
Thanks for the info! A little bit of background on what I'm going after: I recently graduated with a Software Engineering degree and unfortunately most of the curriculum at my school centered around Java programming. I'm just starting to get my feet wet with JavaScript but I'm finding it difficult to pick up ALL the knowledge required to get into web programming. I'm looking to do some hobby projects that use pure JavaScript (MEAN stack or similar) but I'm concerned that I'll be missing key information somewhere on things like proper architecture and security. For example I'd hate it if I wrote a RESTful web service in something like node, only to find out that it can be exploited easily. I guess I'm looking for a tutorial or group of tutorials that not only teach you the technology, but also make sure that you don't shoot yourself in the foot by teaching you best practices in addition to the basics.
Okay, that all makes sense. When I put the script into the console, it says "&gt;Uncaught &gt;TypeError: Cannot set property 'value' of undefined. I did it in Chrome and in Internet Explorer and they both said the same thing. I tried changing `.value='395563'` to `.value="395563"` but that didn't do anything. I looked on Google but I couldn't really find anything. If I delete that line then I get the error: "&gt;Uncaught &gt;TypeError: Cannot read property '0' of null"
You're trying to make up a story to prove your point but it doesn't make sense. Frameworks are developed to save people who can't write the code or don't want to take the time. But such frameworks are either limiting to some extent and larger than necessary. If one is good enough to write such a thing, they have all the knowledge in their hand. It makes no sense for them to restrict themselves to such things. Foolish in fact.
A grinding quest. Making a goal of grinding doesn't change the act of grinding. I'm not trying to denigrate the game, I was just pointing out some irony in the name. If it were EverGrind or GrindQuest then it would be more applicable.
Sorry for the inconvenience. The problem is that `querySelector` only returns the **first** element it finds, not an array. So trying to get the first element of a non-array returns undefined. Try running `document.body.querySelector('input[type="TEXT"]')` without a subscript and see if that returns the element you want. If not, use `document.body.querySelectorAll`, which will return an array of all elements that match the selector. Note that you have to change this for the add course/cancel buttons too. For your second error, the `querySelector` for the add course/cancel button is returning null because it can't find the element. I'm not sure what is causing the error, because everything seems to be spelled correctly. Check for any typing errors and see if the value property is really set to `"Add course to schedule"` or `"Cancel"`. You can also try using a different property to get the element, such as the type of the element, since that shouldn't change like the name/id. Hope this fixes your problem.
Maps are an important data structure in programming: http://en.wikipedia.org/wiki/Map_(computer_science) _"But we already have `{}` objects, which can operate as key-value stores just fine!"_ you may say. Which is mostly true. However, the answer to your question is found in your link: &gt; ##Objects and maps compared The rationale is the first paragraph: &gt; `Objects` are similar to `Maps` in that both let you set keys to values, retrieve those values, delete keys, and detect whether something is stored at a key. Because of this, `Objects` have been used as `Maps` historically; however, there are important differences between `Objects` and `Maps` that make using a `Map` better. The differences between a `{}` and a `Map` are next: &gt; * An `Object` has a prototype, so there are default keys in the map. However, this can be bypassed using `map = Object.create(null)`. &gt; * The keys of an `Object` are `Strings`, where they can be any value for a `Map`. &gt; * You can get the size of a `Map` easily while you have to manually keep track of size for an `Object`. And some pointers about when each would be applicable last: &gt; Use maps over objects when keys are unknown until run time, and when all keys are the same type and all values are the same type. &gt; Use objects when there is logic that operates on individual elements. edit: A practical example... var o1 = {key: "foo"}, o2 = {key: "bar"}, map = {}; map[o1] = o1; map[o2] = o2; Since `{}` objects only work with string keys, both of the above objects will be set in `map` using the `Object.prototype.toString`, which comes out to `[object Object]` for both. Thus, you end up with only 1 object in your `map` -- the last one, `o2`. So it looks like this: {[object Object]: Object} But with `Map` you get: var o1 = {key: "foo"}, o2 = {key: "bar"}, map = new Map; map.set(o1, o1); map.set(o2, o2); Which contains both objects, and looks like this: {Object {key: "foo"} =&gt; Object {key: "foo"}, Object {key: "bar"} =&gt; Object {key: "bar"}}
&gt; Frameworks are developed to save people who can't write the code or don't want to take the time. That's one reason, for some. But the main one is to provide a centralized solution to a common problem, so that bugs get fixed in everybody's copy, improvements benefit everybody, and we don't waste tremendous amounts of time re-solving the same problems. Another is to help you keep your code about your app and not the implementation details. Another is to convey a new philosophy - not a philosophy you would know if you were "good enough", but the author's own invention. &gt; But such frameworks are either limiting to some extent and larger than necessary. No code is perfect. But if we collaborate on the solution, we can get closer and closer. &gt; You're trying to make up a story to prove your point but it doesn't make sense. [...] Foolish in fact. Let's keep this about frameworks, OK?
Addy Osmani did a good piece on this: http://addyosmani.com/largescalejavascript/
In the interest of discussion, care to elaborate?
Ember's the obvious one, IMHO: [emberjs.com](http://emberjs.com/) Depends on what you're looking to do exactly - some of the best parts of Ember come from Ember Data, its persistence library. Our project is pretty data intensive so it comes in handy. On the other hand, if what you're looking to do is multi-user, [meteor.js](https://www.meteor.com/) might be more up your alley. 
I put `document.body.querySelector('input[type="TEXT"]')` and it returned a different text box but I got rid of it since it doesn't change when the form is sent but I did it again and it returned `null`. I saw that there is another document in the html document. I'm not sure if that has anything to do with it. [Here's the elements to the text area.](https://imgur.com/a/gDRfQ) And[ here's the elements of the other two.](https://imgur.com/a/E6lhl)
So do frameworks in complex problem domains where something like Service-Orientation makes more sense. It's about using the right tool for the job.
It really comes down to the complexity of your problem domain. Simple projects benefit from the speed at which frameworks can get them to market, while complex projects benefit from more flexibility. There's a great methodology called Service-Orientation which is a way of writing software in a way which can incorporate many frameworks if you wanted. It's much more useful in complex situations because you can create a "framework" of sorts which is centric to your application while also leveraging the power of well-integrated 3rd-party libraries. I would not build a complex application with a framework. I would not build a simple application without one.
my rule for development, right tool for the job. Having opinions just for ego or dogma doesn't make sense. Can you imagine a mechanic ranting about no one should use metric sockets? If a car needs metric sockets then use them. I will use any tool that is the right answer for the job not bring prejudices into my decision if I can avoid it.
There is no difference. They do exactly the same thing. Modern code generally uses the `{}` object literal notation because it's simpler and cleaner. The object literal also lets you initialize object properties at the same time. For example, instead of doing this: var obj = new Object; obj.foo = 'bar'; obj.num = 42; You can do: var obj = { foo: 'bar', num: 42 }; 
AngularJS will live on for a long time. Lots of companies have been building applications with it so I doubt it really goes away at all. Many of the concepts will still apply even in 2.0. 
In terms of syntax, you can think of `var myObject = {}` as a JavaScript shorthand of `var myObject = new Object()`, as `var myObject = {}` was not available to other C-like languages until recently. However, overtime, people have realized for the sake of readability and VM/compiler performance, `var myObject = {}` is superior in almost every way. So now there is almost no reason to use `new Object()` 
Thanks! I think I was overthinking it and got confused. 
&gt;No developer wants to take over a project wherein the original developer wrote everything from scratch *Every* shop has their own conventions, set of frameworks, in-house modules, and code. Being the author of a project means you're inherently familiar with it, and *anyone* who inherits it will need to go through a learning curve. And let's be fair, here, in-house frameworks are not inherently bad. Maybe that framework wires together extremely complex pieces which you'd have to handle by-hand otherwise, and maybe it doesn't use Backbone as it's foundation. Does that really matter to you? If the tool works, use it. If you need a tool and you can't find one that really fits; make one.
Thanks for the explanation! I figured out why I got confused. Something to do with complex objects not being created for booleans, numbers and strings until a method is called on them. 
So what happens when the data changes? Do I just re-render the whole thing and replace the old DOM? I couldn't find explanation regarding that on the site...
There is a difference for primatives however. var x = new String('hi'); And var x = 'hi'; Behave slightly differently (often a non-issue) but try this as an example: (typeof new String('hi') === typeof 'hi') === false 
Nope - paperclip will automatically change only the parts it needs to. Here's an example of paperclip updating 1000 items: http://requirebin.com/?gist=425cdb646205bb819477 I'll add a note of this on the home page.
+1
By the way, if anyone knows more that would be worth adding, I'd love to hear some. I'm also interested in even more verbose methods of some of them. 
**Edit: I misspoke in this comment. It is irrelevant to the topic raised. Sorry.** ~~One reason I think they will be good; very quick and code-efficient:~~ var numbers = [1, 4, 9], roots = numbers.map(Math.sqrt);
I "gained the knowledge" while writing apps before JavaScript mvc was a thing and that was my point. What I learned during that time (as clearly did the rest of the community) was that jquery by itself is insufficient for structuring complex applications and a maintainable manner. The modern frameworks are just implementations of architectural patterns the community was already hand rolling their own versions of. If you believe jquery or vanilla is sufficient for complex apps (and this is the reality in every programming environment which is why every language has frameworks) you either a) have not built complex enough apps to warrant the use of a framework b) do not care about maintainability, or c) a delusional masochist who truly believes their hand rolled solution is superior to the frameworks with solid test suites that are also tested through thousands of developers using them on real world production apps. If it's not clear by now, I find this rather improbable :)
There are minifiers. There is no point in omitting spaces/parens/semicolons and using single-character identifiers. For generating a random boolean, you can just write: Math.random() &lt; 0.5 &gt;a new array that has been sorted into a random order You mean "shuffled". Use [Fisher-Yates](http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle) for that.
So... minify your code by hand?
Not really. It uses tricks and shorthands to reduce code beyond just minification. And it does say at the top that it's mostly an art project.
typeof says every non-primitive, non-function value is "object". e.g. typeof document.body typeof new Date() typeof [1,2,3] typeof /foo/
Gee I hope we get to have this circle jerk every time something angular related is posted from now on.
This. If someone committed this style of code I wouldn't be a happy person. Code is for humans to read.
Fisher-Yates is an in-place shuffle algorithm. Your algorithm, on the other hand, creates 2 new arrays and then you rip out randomly chosen pieces from one and push them into the other. The effect is the same, but manipulating arrays like that is somewhat expensive. Fisher-Yates looks somewhat like this: function shuffle (array) { var i, temp, pick, a; a = array.slice(0); for (i = a.length - 1; i &gt; 0; --i) { pick = ~~(Math.random() * (i + 1)); temp = a[pick]; a[pick] = a[i]; a[i] = temp; } return a; } The only difference compared to the "classic" version of that algorithm is that it creates a clone of that array at the beginning and then it works with that clone instead of the original one.
That's `Array.prototype.map` which is different than the `Map` global object.
I appreciate your taking the time to help me gain an understanding of the instructions. Thank you very much!
Not to sound like a dick, but you sound like someone who has never written anything complex. Lets take a simple example. You're writing a page that gets some data from the server then displays it on a page. Cool. Do a quick $.ajax, update the html and everything is works. Then another element uses that data. Then another. Then it has to refresh. Then you rely on 3 ajax calls to get all your data before you can do anything. Next thing you know your simple little ajax request is touching 5, 10, 15 different parts of the page. Suddenly you are like "fuck! I wish there was a way to just have the elements on the page react to changes in data so that I didn't have to individually manage each element when things update". You do some googling. Lo and behold some guys at Microsoft came up with this whole design pattern called MVVM. It makes perfect sense! You have a data model and through data binding the UI updates based on that model! Brilliant. Lets implement that whole thing... wait... how the fuck do I do that?! You do some more googling. Turns out theres a whole bunch of libraries that people have written that does exactly that. You mean I don't have to write a whole MVVM library (aka not solving my business problem) to gain all those sweet benefits? Awesome. You use libraries because people smarter than you have dedicated way more time doing it better. If you are working for a company that expects you to solve a business problem, your time is better spent doing that. 
The only difference I can think of is that Object can be overwritten, which would make using {} a safer bet than new Object().
I went back in and attempted this method as well, but because of the way javascript handles objects by reference, "temp = a[pick]" won't work on a deep object array, and I'm finding the most succinct object cloning is JSON.parse(JSON.stringify(a[pick])) and that is quite verbose as vanilla javascript goes. The smallest I could get this code example would be this &gt; function fy(a){for(var i=0,l=a.length,j,t;i&lt;l;i++){j=~~(Math.random()*(l-i))+i;t=JSON.parse(JSON.stringify(a[i]));a[i]=a[j];a[j]=t;}} and like you said, this one doesn't even duplicate the array. I'm interested in it, but it looks like the pick and pluck method is currently the shortest. I might add this as an alternative, though.
Is there a particular reason why this is an issue?
&gt; "temp = a[pick]" won't work on a deep object array It works just fine. It just doesn't create clones in the process. If you want to deep-copy some object, do that with a separate function.
HM! What in the hell? You're right. Is it... is it only when passed through an argument array that objects pass by reference? I always assumed any variable rename of an object was a reference. TIL. Welp, consider that one updated as well. Thanks! [edit] Actually, when you add in the array duplication, it still ends up being longer than the other method.
To be honest, I pretty much agree with most of your points at a high level. My gripe with this article is pretty much that it takes a bunch of well known best practices that the industry has been aware of for a very long time and makes it sound like Javascript is somehow a pioneer in this space, taking credit for bringing to the mainstream when these things are already somewhat normal. Definitely, Java got inheritance wrong. But the idea that one language is somehow representative of class-based inheritance as a whole is misguided. Javascript also got inheritance wrong, it's just that prototypes are flexible enough to use differently. (My issue with this is that *everybody* invents their own way of doing it). I can definitely get behind further education to encourage new developers to not fall into the trap of mis-using inheritance, but I'm also very concerned that articles this like this confuse a lot of people into the real relationship between prototypes and classes, the benefits and drawbacks of both approaches, that 'classes' are somehow inherently less capable of performing composition than prototypes, and that Javascript is the only viable choice as a solution to this issue. It almost certainly wasn't your intent to portray it in this way. But I do feel quite strongly about the issue, since I'm constantly coming into contact with Javascript developers that have fallen into the pit of actively and intentionally avoiding learning any other language. Articles like this just further cultivate the 'cult of javascript' and discourage even more developers from branching out and learning new things. As an industry, we're building software incorrectly. We're not *engineering* solid software, we're hacking together things that work on faith. Almost ever piece of software in existence comes with a license agreement that explicitly denies any warranty. Until we can get to the point where the software we're building has proven guarantees, we're not engineering. Without totality checking, we're just hacking things together and hoping for the best. The solution to this doesn't exist yet, but the languages moving in the right direction are things like Rust, Scala, Haskell, and Idris. Javascript most certainly has some great ideas, but it doesn't provide anywhere near enough safety. It's certainly great as a scripting language, and is a great language for smaller codebases, but it's not engineering. tl;dr Javascript has created a generation of "expert beginners" with their head in the sand, and this kind of article just further propagates the problem. It's not that Javascript is specifically a bad language, but it's not particularly good either, and the industry as a whole can, and needs to, do better. 
## ___LEARN TO THINK FOR YOURSELVES___ &gt; According to google ... According to Steven ... yada, yada. 5 years ago `ary[ ary.length ]` was faster than `ary.push`, fine. It took me 30 seconds to test it _today_: http://jsperf.com/array-push-vs-index-push Guess what? This entire article is wrong. What a waste of time. [edit] this concept apparently has some merit on mobile devices, if performance there is critical to you. Good to know, but the article doesn't point this out and is still useless regurgitation garbage.
Code review time! function(number,exponent){ return String(number + Math.pow(10, exponent)).substring(1); } Don't use actual math to do this as it caps your numbers at like 10 zeros and then you'll get numbers ending in `E+15` or whatnot. `new Array( exponent - number.toString().length + 1 ).join( '0' )` function(max){ return Math.floor(Math.random() * max); } Careful with bitwise ops in JS converting to 32-bit unsigned ints. &gt; Return any of the random values based on arguments provided. If no arguments are sent, a random boolean is returned. If 1 argument is sent, a random number from 0 to 1 less than the argument is returned. If 2 arguments are sent, a random number from the minimum to the maximum is returned. Um... please no? Overloading functions for no reason? If you want a random boolean, call a function to return a random boolean. If you want a function to return a random number or a range, call those. function(num,decimal){ if(decimal === undefined) { decimal = 2; } return String('$' + n.toFixed(decimal)).replace(/\B(?=(?=\d*\.)(\d{3})+(?!\d))/g,','); } please don't use `undefined` like this (it can be overridden, just a safety thing). I use `void[]` Randomize array: Depending on the size of your array, and the _purpose_ of randomizing it (e.g. is this something that runs on 100 element arrays once in a while or is it randomizing 1,000,000 elements/sec?), this is faster to type: ary.sort( function(){ return Math.random - .5; } ); This next one is seriously painful... function(){ var timeDifference = arguments.callee; if(!timeDifference.time) { timeDifference.time = new Date(); } else { timeDifference.result = new Date() - timeDifference.time; timeDifference.time = 0; return timeDifference.result; } } setting a property on a function you don't control that will break with any type of recursion or nested calls to the same function using arguments.callee which will break in strict mode... ... Just create a variable function(template,data){ for(var key in data){ template=template.replace(RegExp('\{\{'+key+'}}','g'),data[key]); } return template; } please add `hasOwnProperty` checks
You know, in a previous version of the page I had names on all the functions, and that worked and seemed a lot better. I did not realize that arguments.callee was deprecated. It seems a waste.
Tested it on firefox and the array [ i ] method is fastest.
Concise - giving a **lot of information clearly** and in a few words Obfuscate - make obscure, **unclear, or unintelligible** The short versions of your code samples aren't concise, you just removed the human readable meaning which trashes any clarity it once had. That is a maintenance nightmare and a horrible, horrible practice to get into. If you ever have to write code that will be seen by anyone else but you, don't ever, ever do that. 
Did you read Steven Hall's test? I'm using the method that doesn't require a lookup. Please try to be informed before making bold claims about validity.
In about a hundred quick tests, that sorting algorithm ALWAYS produced the same first element, and the second item only had two options. Not sure why that was, but it doesn't seem to be doing what you think it's doing. At least it's horrible as a shuffle. I'm currently moving through what you've written and testing and agreeing or disagreeing. :)
Try playing with stamps, and you'll feel some radical differences from classical inheritance pretty quickly. http://ericleads.com/2014/02/prototypal-inheritance-with-stamps/ As for the resemblance between JS and functional languages, I'm referring to the referential relationship between the new object and its prototype, and comparing it to what happens under the hood in pure functional languages when you copy data for mutational purposes. As you well know, the original data is not modified, instead, a copy of the whole data set is made. Except under the hood, it's not really copying every element. Instead, the new object references the same values in memory as the source data set, and only references different data for the changed members. This is very much how the delegate prototype works in JavaScript -- only it's typically used for methods rather than data. As I mentioned before, prototypes in JavaScript are rarely used to create inheritance trees, and more often used for flyweight object support -- all instances sharing methods on a single prototype object. That is what is going on every time you see code like MyObject.prototype.myMethod = function () { /* do something */ }
The modified jsperf test is yours, correct? If not, I apologize as I'm not certain what you're actually testing and code would be helpful. If it is, it's an _invalid test_. [edit] The timestamp on the jsperf and your comment are within a minute, so I'm going to make the fairly safe assumption it's yours. The test is invalid, as it's _not doing the same thing_. Did _you_ read that guy's blog post? _Nowhere_ does he just set `[i]`, and even if he does somewhere else (or I'm blind) it's useless outside of the _very narrow_ use case of filling a single array. Please try and be informed yourself before acting all high and arrogant. [edit 2] Not so certain the modified code is yours. It says tested in Chrome and the extra snippet is _slower_. So you're either incredibly pointless to even talk to or I'd like to actually know what you're talking about so this discussion has merit :)
Whoops! ary.sort( function(){ return Math.random &lt; .5; } ); should be ary.sort( function(){ return Math.random - .5; } ); Fixed the original post.
&gt; that 'classes' are somehow inherently less capable of performing composition than prototypes, and that Javascript is the only viable choice as a solution to this issue. Languages which do not support dynamic object extension certainly require the user to jump through more hoops to do various forms of composition, mixins, etc... Java is certainly less convenient, and somewhat less capable in this regard. &gt; It almost certainly wasn't your intent to portray it in this way. It was my intent to point out that JavaScript's dynamic object extension and prototype delegation make it a much more convenient language for flexible OO than languages which behave more like Java. I believe those facts are on pretty solid footing. I know how to do many similar things in Java, but I typically would need to crack open the GoF "Design Patterns" to remind myself of the twisted paths you need to take to get there. Particularly telling -- as soon as I started using JavaScript, all of that complication fell away, and I stopped referring to design pattern books on a regular basis. I simply didn't need them anymore -- and that was before I had a really good grasp of OO in JavaScript. In short, JS naturally lends itself to more successful OO patterns, and it's actually more painful to try to fit classes and their restrictive complications into it than it is to pretend classes never existed and code more productively by default. This has mainly to do with JavaScript's object literals and dynamic object extension capabilities -- you get productive code reuse patterns naturally, without investing much thought or effort into it. It's a pit of success, rather than a bit of failure. &gt; Javascript most certainly has some great ideas, but it doesn't provide anywhere near enough safety. I won't argue that point. I wish it had immutability by default, for instance. Dynamic object extension should be an explicit method call, and users should be taught that there should be a single source of truth for data. The language could make this more explicit, as is the case in languages like Haskell. &gt; this kind of article just further propagates the problem. I disagree. A lot of JavaScript developers think that building big class hierarchies is a good idea. This article (and my Fluent talk, "Classical Inheritance is Obsolete," and writing from authors such as Douglas Crockford and Kyle Simpson) has changed a lot of minds about that, and helped a lot of people avoid very big mistakes. &gt; Javascript is specifically a bad language, but it's not particularly good either... There's a lot I'm not particularly fond of in JavaScript, but the pillars of objects without classes and lambdas with closure have definitely reached more people through JavaScript than they did through any other language. JavaScript isn't the best functional programming language, but it's the most popular by a long shot. JavaScript doesn't have the best support for prototypes (mostly because it goes out of its way to hide it), but it's the most popular by a long shot. Many programmers who now use both paradigms productively may never have learned about them if it weren't for JavaScript. And contrary to your assertion that articles like mine discourage people from learning other language: I believe they point out that there are other programming paradigms to explore. I frequently encourage people to explore them, not only to see what else is out there, but to think differently about how to do things in their primary language of choice. Lots of great JavaScript innovations were inspired by techniques that were pioneered in other languages, including both prototypal OO and lambdas.
http://www.scottlogic.com/blog/2010/10/15/javascript-array-performance.html
You realize the suggestions on some of them, like the leading zeros, are because your code breaks, not because it creates shorter snippets? What good is shorter code if it doesn't work?
Yeah, what of it? I just noticed the `[i]` in his list of tests (my bad, I was reading the code mostly, and it's not there). It doesn't negate the facts that: - it's testing a different use case. Even he states this!! - it's ___slower___! I mean, what the hell... Even if it is a tiny bit faster in some browsers, so what?? It's not faster overall - you didn't bother to test any of this yourself. You're just regurgitating blog posts from 2010 - you don't even know what browser you tested it in. Jsperf said it was only tested in chrome when I first look (though I'll give you some benefit of the doubt here and assume the FF test didn't save for some reason)
Do users of jQuery dig through the code to figure out how to construct a jQuery selection? No, they simply type `var foo = $('div')` and there's a new jQuery object with all the divs and all the shared prototype methods available. Do users of Express dig through the code to figure out how to instantiate an express app? No, they simply type `var app = express();`, and like magic, there is an instance of Express. Frameworks which require `new` on the other hand may or may not wire up the Constructor.prototype, they may or may not work appropriately when you try to invoke them with `.call()` or `.apply()`, they may explode and/or completely fail to work if you forget `new`. They may pretend everything is okay if you forget `new`, pollute the global namespace, and introduce bugs because instances aren't instance-safe. Yeah, you can look at the sourcecode and figure out which of these situations a constructor is going to be vulnerable to. *Or you can call a simple function and get an object back.*
Why would I choose this over the built in template engine of angular, or Twitters Hogan engine? What I'm asking is, when and why do you think developers should use this?
See my original post for answers to all of those points.
[NodeBB](//Github.com/nodebb/nodebb) uses no framework, and we're getting a good number of contributors coming from PRs, themes, and plugins. A couple people have asked why we don't use a frontend or backend framework, but I personally find that it introduces a level of abstraction that isn't necessary. Potential contributors unfamiliar with *X* framework will not put in the effort to learn it just to contribute, and even worse, having to actively *deny* pull requests because they don't adhere to "the *X* way" would be a lose-lose situation. I find I have a deeper understanding of the codebase, and the language is applicable to all, it's just Javascript. 
&gt; Languages which do not support dynamic object extension certainly require the user to jump through more hoops to do various forms of composition, mixins, etc... Java is certainly less convenient, and somewhat less capable in this regard. Not going to disagree about Java, but I'm not seeing a huge difference between mixins via prototypes and the equivalent implementations in say, Scala, Ruby, or Python. There's certainly no hoops to jump through in the above. Perhaps we're simply thinking from different angles - do you have a good example of something I could do easier with Javascript prototype mixins than I could in a language with native mixins? It might help me understand better. Runtime metaprogramming is the only advantage I can really see, something which I'm fundamentally against except in extreme edge cases. ("The code has no obvious defects" vs "The code obviously has no defects". Metaprogramming falls into the former category). If it helps, I'm coming at this from primarily from the point of view of Scala and Haskell. The former has very good built in mixins as an innate part of the language, and the latter just doesn't need them in the first place. In both cases, it's seamless and trivial to use native parts of the language for this kind of code reuse, and is something naturally encouraged by the language rather than being tacked on via libraries. &gt; Particularly telling -- as soon as I started using JavaScript, all of that complication fell away, and I stopped referring to design pattern books on a regular basis. I simply didn't need them anymore -- and that was before I had a really good grasp of OO in JavaScript. Did you ever truly really need the book though? The patterns described in the GoF book are somewhat emergent phenomena. I'd already used most of them without knowing the name well before I ever picked up a copy, and it seems like most developers I've worked with feel the same. Even back in my Java days, the book was just a nice addition to my bookshelf, not a reference I used often. I had a slightly similar revelation when I first used Haskell (Everything was just so much simpler), and these days I'm a religious advocate for ML-family languages, which for the most part completely eliminate the need for OO in the first place. (If this gives you any indication of why I see both prototypical and class based inheritance as different implementations of fundamentally the same mistake). &gt; There's a lot I'm not particularly fond of in JavaScript, but the pillars of objects without classes and lambdas with closure have definitely reached more people through JavaScript than they did through any other language. That's a good point. I'm just concerned that it'll stop there, rather than people looking deeper. &gt; And contrary to your assertion that articles like mine discourage people from learning other language: I believe they point out that there are other programming paradigms to explore. I do hope that this is the case. Perhaps I'm just being overly paranoid, but I am very concerned about the state of the industry at the moment, specifically around the the number of developers I meet that *do* take articles like this as further proof that Javascript is the only language they'll ever need to learn, rather than taking it onboard as part of the processing of understanding PLT in general. I've quite literally had multiple job-interview candidates tell me they have no intention of ever learning any other language, since they considered Javascript to be the only one anyone would ever need. This is very concerning to me, and it's a lot more common now than it was even a few years ago. In the end - I support the principles of the message your trying to convey, and the fact that you're getting out there and doing it. I'm concerned that the message is being misinterpreted.
You misunderstand me ;-). I'm not knocking what you've done, I actually applaud it. I've never liked the constant forcing of classical inheritance on JavaScript by those who think it is the Right Way To Do Things™ (read: *only*) because I think prototypal inheritance and easy composition is frigging awesome and one of the best things about JavaScript. What irks is the mindset of classic OOP programmers that think anything that deviates from that is an abomination and is to be derided (ironically, that means they don't actually understand what OO is, only their subset of understanding). I've seen it for the last 20 years and I'm fed up with it. I could turn it around on them - a bit like your use of the gorilla and jungle when all you want is a banana analogy - by closed-mindedly decrying the lack of prototypal inheritance in *their* language, but that just lowers me to their level. What also irks is that we have to continually jump through hoops to keep them happy. Their way is their way. This happens to be a different way, and they aren't the arbiters of truth, just zealots. That notwithstanding, doing prototypal inheritance right is harder than it should be, but only because it is different enough from classic OO which is what people are first exposed to and thus confuses them. This confusion manifests as it being "wrong" and therefore in need of "fixing". So, again I say I applaud your efforts; the library helps all, not just the classical people.
&gt; Or you can call a simple function and get an object back. Where I disagree is that *knowing* to just call it as a function is simpler. If I see a type called 'Person', the instinct will be to call 'new Person()', not 'makeMeAPerson()'. If you're deviating from convention, I've just introduced a runtime bug. Certainly, in languages where this is the norm it works well. Scala uses `object::apply` as a way of doing this idiomatically and it works well. There's little ambiguity on how to construct a value of a type, and the compiler makes it impossible to get this wrong. But with Javascript, if I import your library, I have to then figure out whether I'm supposed to use `new` or not, and if I get it wrong it's going to fail in undefined ways. There's also nothing special about the factory function, so it's difficult to sift through someone elses code and figure out what you expect me to use to construct things with if it's not explicitly documented. (And how many Javascript libraries are properly documented?) &gt; Frameworks which require new on the other hand may or may not wire up the Constructor.prototype, they may or may not work appropriately when you try to invoke them with .call() or .apply(), they may explode and/or completely fail to work if you forget new. They may pretend everything is okay if you forget new, pollute the global namespace, and introduce bugs because instances aren't instance-safe. It works the other way around too though. If I use `new` when I'm not supposed to, it won't work properly either. Whereas if there's one standard way of doing it that everyone uses, there's no mistake to make. The fact that you can call a constructor the wrong way in Javascript is a flaw in the language itself, not the concept of constructors, and the best way forward is for everyone to always use the same convention. (I'd support Person.create as a better way of doing things, so long as it was the normal way of doing things)
I figured the key thing might be speed, since most template engines have a hard time rendering large lists of items. Paperclip can render around 50k items per ~1s on my laptop in certain cases. There are a number of other differences, here's a list: 1. Decoupled from the DOM. Custom rendering engine is possible (SVG, canvas, etc). 2. No strange DOM manipulations / quirks. (metamorph tags, ngCloak, etc.) 3. Interoperable with other libraries. 4. Rendered views are manipulable - paperclip won't overwrite any changes. 5. Explicit data bindings (1-way, 2-way, or unbound). 6. Templates can be rendered in Node, and in the browser. 
At a first glance this seems to be solving the same problem as react. Could you do a brief comparison?
Since you asked for feedback... IMHO there are two valid paths to building a template engine: 1. Just embed the language your developers are using ( ejs/jst, erb, plain PHP templates, etc. ). 2. Build the DOM tree with functions that create elements ( React+JSX is a modern, evolved example of that ). The wildly popular third path: invent a new language for templating – is a [footgun](http://www.urbandictionary.com/define.php?term=footgun&amp;defid=7493319). There will be pressure to add more and more features to the language until it becomes Turing complete. Somewhere before that point the language becomes too complicated and someone else decides to invent a new templating engine... A good indicator of the third path is when the templating engine adds loops, if/else or similar. You may not like my opinion, but I hope it may help you understand the roots of your problems in the future.
*Here's the Urban Dictionary definition of* [***footgun***](http://www.urbandictionary.com/define.php?term=footgun) : --- &gt;A podiatric penetration purposed pistol. A gun which is apparently designed for shooting yourself in the foot. --- _My favorite footgun: [C++](http://www.urbandictionary.com/define.php?term=C%2B%2B)_ _Your favorite footgun: icon fonts_ _Everyone's favorite footgun: [representative democracy](http://www.urbandictionary.com/define.php?term=representative+democracy)_ --- [^(about)](http://www.reddit.com/r/autourbanbot/wiki/index) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autourbanbot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/javascript/comments/2l0x58/built_a_fast_template_engine_for_the_dom_looking/clqogcx) ^| ^(**Summon**: urbanbot, what is something?)
My solution to this question was React + Flux. For the Flux implementation I went with ReFlux.
I use OOP but rarely use inheritance. It's long been considered that composition is superior to inheritance for code reuse and flexibility. &gt;because they couldn't get the taxonomy design right You don't seem to give examples, so it's hard to say if the people who ended up in this mess were just bad at OOP.
No problem. Definitely start with the basics: HTML and CSS. This is basically just coding and not programming. Quite easy if you already know actual programming. But important because sometimes I see good JS programmers do incredibly complex things with JS that could be done with a single line of CSS. Also, HTML and CSS are necessary no matter which stack you choose. After that, spend some time learning JS. Tutsplus has an excellent series of basic JS tutorials. Note that there are quite a lot of differences from Java as JS is a prototypical language and is quite special compared to most other programming languages. I recommend you [read this](http://java.dzone.com/articles/javascript-java-developers-0), especially the part about inheritance. It is quite important that you get yourself out of the classical OOP paradigm and learn why JS works like it does. For instance, we don't have tree of classes that inherit from each other. We just have a whole bunch of scattered prototypes that can pick and choose methods and properties from each other. Even on the fly. This makes testing a lot more easy and fun. Don't get into frameworks in the beginning. We already have an abundance of "JS-programmers" who only know jQuery. It becomes a problem once you want to jump to other things such as Node.js or angular. Once you have a nice grasp of basic JS, you can move on to other things such as Node.js, jQuery, angular etc. Also the associated tools such as gulp and testing frameworks. This is just my opinion but I honestly think you should just skip over jQuery and go directly Making a RESTful web service is a great idea - I honestly think this is where most companies should be heading. A central API can be used for both websites, apps, internal tools etc. It means that you can develop a new website or app in parallel with your old one, without doing any work at all to the back-end. You can look into frameworks such as Hapi or restify. They are both pretty awesome and centered around building APIs - including the security concerns. Note that you can built one with both LAMP or Node.js but I think Node.js is by far the best at this. The good thing about building an API first is that you can learn front-end afterwards, once you know where to get your data. You can then build websites on top of the API using angular, backbone, knockout, ember or whatever you want to try out - without having to think about the back-end. Heck, you could even build an Android app on top of it if you come from Java. :) EDIT: I forgot the most important point. Once you know the basics, don't do everything from the bottom yourself. Many of the frameworks and NPM modules out there are actually very, very good and stable. Always shop around among those before building something yourself. Or find something that does 90% of what you want to do, then contribute the last 10% to the project yourself. Github is an awesome place. :)
You advertise on speed, do you also have benchmarks comparing this to other popular template engines?
Are there any js related errors in console? It seems that there is some "return false" on these items to make some custom behavior of click (maybe ajax load etc.). If you put "return false" to an object, it will be open normally if you click on "Open in a new Tab". 
How do you structure a React app? Do you still build an app around React, or do you solely rely on React components? For example, doing AJAX request to fetch data inside a React component feels wrong to me, but they even do it in the official React tutorial.
I awlays thought backbone was a library not a framework, whereas ember / angular et all are frameworks.
Program snake with them :) http://vimrcfu.com/snake Maybe make it a multiplayer version or something like that. 
You're taking a bit of flack for saying this, but you raise an important point. I'm currently learning angular, and I'm almost finished doing my first SPA using it (non commercial pet project). Part of the reason for this is because I intend to become a contractor (I'm salaried atm) in a years time and want a JS framework in my skillset. I am now rethinking angular because I think my angular 1.0 skills won't be worth much in a years time. In addition to this I currently work for an ecommerce firm. It's possible that one day we will rewrite our web based management / reporting software in SPA form. If I were asked to recommend a tech stack, I would have included angular in there. Since reading about 2.0 I can no longer make that recommendation. Without a good v1 -&gt; v2 migration path that choice would lead us to being stuck on an old technology, or doing yet another rewrite to keep up to date. I'd roughy guesstimate the cost of upgrading to v2 if we had our management system in angular would be around 100k. Even if we waited to v2 to come out before going down the SPA route I couldn't recommend it, since I'd be worried v3 would again mean a complete rewrite.
Can you elaborate a bit on the Flux architecture?
This seems to be very similar to [Blaze](http://meteor.github.io/blaze/). Do you have any performance comparisons?
Fabric.js
Frameworks aren't meant to be a reason to avoid learning the language, in my opinion. Some beginners might try to use them that way... Experienced developers use frameworks to save time (money). Everything is a tool, and the best tools for you are the ones that help you get the job done easier. OP asked if frameworks are "necessary", but the answer to that depends on the context. An experienced enough developer or team, given enough time, can make anything without using a third party framework. This usually results in a some form of reusable code base that could eventually be called a framework, albeit with a very small developer community and possibly zero documentation. But for applications where time-to-market is the difference between success and failure, using an existing solid foundation and being able to focus on the actual application logic can be seen as a necessity, especially when you can hire developers who are already familiar with the tools your team uses.
You can do it in the component, but you should do it in flux actions.
Came here hoping for a jsperf, wasn't disappointed. Thanks.
I find it hilarious when anyone praises frameworks because "hand rolled" solutions are inferior while ignoring the fact that frameworks are hand rolled solutions. As I said elsewhere, such things are shortcuts for people who don't know how or don't want to take the time. 
In the end only you can decide what appeals most to you. I like Meteor a lot because its easy and fast to develop in as well as a fresh rethink of how webdev can be done. They just released a 1.0 version. Check out this short tutorial to wet your apetite: https://www.meteor.com/install
Why would I use this over modern approaches to view generation like React?
This question is just too big. If you've never used an MV* framework, I'd recommend cutting your teeth on Backbone, but be aware that you will need to solve a lot of mid/long term problems yourself (unless using a BB framework like Marionette). Angular is a funny one, it's got some great bits, but it uses a unique system that doesn't play well with other libraries. Haven't used Ember, but hear good things lately. Personally more interested in frameworks that use React for their rendering pipeline as it takes care of some nasty issues Iike layout management
Can you elaborate on the flux actions?
The MEAN stack (MongoDB, Express, AngularJS, and Node.js) is worthy of consideration. **MEAN Web Development** by Amos Haviv (the creator of mean.io and mean.js) is a great book on this subject, including proper MVC architecture. [**Getting MEAN with Mongo, Express, Angular, and Node**](http://www.manning.com/sholmes/) by Simon Holmes is another excellent book (and has a fantastic visual description of MVC architecture). The Getting MEAN book is a work-in-process though. The Angular chapter has not been released yet. Still, I highly recommend it (although if you get it, check the forum for the book for errata). **Single Page Web Applications: JavaScript end-to-end** by Michael Mikowski and Josh Powell is also an excellent book about single page applications. It doesn't use Angular, but the way they structure their projects and lay out the namespace is very well thought out.
[Here](http://ionicframework.com/blog/collection-repeat/) is one novel solution to that problem.
&gt; No offence No offence taken. I've had a look at __CommonJS__ http://requirejs.org/docs/api.html#define It allows you to scope your objects and define requirements but I still couldn't understand if that's all it does or not. I went ahead and searched for tutorials but with very little luck. Webpack is just for loading dependencies when its needed to speed page startup time, this is not by any mean an alternative to jscomponent. edit: markdown styling
Take a look at npm and browserify. There are tens of thousands of really excellent reusable modules for frontend and backend, and more every day. This has been going on for years now, and the patterns and tools around it have become fairly stable. https://github.com/mattdesl/module-best-practices
That makes my chest feel uneasy...
hmm that might be hard to pull off in 6 minutes, and with short notice 
`alert` and `confirm` are blocking functions. They're not implemented in JS but instead wrap lower-level code that presents the dialog and blocks until it receives user input. Conceptually it could just be a simple `while` loop that waits for a click to happen.
Another vote for Meteor. There's nothing wrong with the MEAN stack, or any Express stack for that matter. But if you're going with MongoDB anyway, Meteor will save you a lot of time. Simply configuring a build chain for the MEAN stack is a topic that could fill multiple books. In Meteor you have a preconfigured build chain for both client and server code that watches, compiles, and bundles files automatically and then hot reloads clients for HTML/JS changes or live injects styles into running apps for CSS changes. You don't have to worry about hooking up REST endpoints, which is another topic that could fill tomes. Meteor eschews REST and uses a WebSockets pubsub framework called DDP. Simply put, you write publish functions on the server, subscribe to those publish functions on the client, and set allow/deny rules. Now, all clients are automatically kept up-to-date in realtime with all the data they need, and the client code can use the isomorphic database API to interact with a simulated local subset of the database while it waits for server responses to the actual database requests. This means Meteor gives you isomorphism and latency compensation out of the box - write your code once, it gets run on both the client and the server, and the requesting client UI feels as if there is a zero latency connection to the remote database. The UI system is clean (no special HTML attributes required), declarative, and easy to reason about. There is no obscure terminology to learn; just Templates, Helpers, and Events. You get a fully configured asynchronous SRP + OAuth authentication system and UI that you can drop in with a couple lines of code. And the package system makes it easy to create your own components like this, containing both server and client code, using explicit dependencies which the build system uses to automatically expose only the APIs necessary for individual parts of your application. Essentially, you can focus more on your application-specific logic than your application's build chain, data synchronization, authentication flow, and DOM manipulation (aka glue code, glue code, glue code, and glue code).
Ugh, I'm an idiot. Thanks.
&gt; browserify Does all these libraries you mentioned uses node.js ? Edit: Correction "libraries" instead of "modules"
Sounds a bit far fetched. And yes, I've never worked on anything complex. If by complex you mean a big ass project with 20k+ lines of custom written javascript
/thread
I'd probably try to show how a math problem they do using formulas can also be solved more intuitively graphically/numerically/"with programming" (I'm thinking of integration now, but I'm sure there are better ideas. Or maybe visit Khan Academy, find an interesting math/finance episode and try to write a program for showing what Sal is explaining.
I really like and recommend angular. There's too much time before 2.0 to worry about it. 1.x well still be viable for a long time before you have to switch. Plus you know there is a great team behind it.
Well, this is a loaded question. But I'll share with you [how I decided](http://i.imgur.com/qhVBRO5.png) which framework would be most worth my time to learn. Its important to note that I had to limit by category to get a decent filter for Meteor. If you go to [the actual page](https://www.google.com/trends/explore#cat=0-5-31&amp;q=Angular%2C%20ember%2C%20%2Fm%2F0t545zt&amp;date=1%2F2011%2037m&amp;cmpt=q) you can look at 'related searches' for each term and verify that all the terms are correctly limited. I'm not saying this is the definitive answer, each job has its own tools that fit best, but it did have a major impact on my decision. 
It's actually not that far-fetched a scenario. A better measure of complexity would be the actual functionality of the code, not the number of lines. For example, using a framework, I could potentially develop the same application as you with much less code. Which is more complex?
Frameworks are tools. Just as carpenters have a variety of hammers, nails, and wood to work with, developers have a variety of languages and frameworks. Backbone sits atop jQuery. jQuery sits atop JavaScript. JavaScript sits atop machine code (more or less). You are simply opting to stop at the middle tier, which is fine if it works for you. Others of us find that the limitations of the frameworks are outweighed by the benefits.
These libraries are fine, but as it stands I find them un-useful. The amount of effort it takes to switch between these algorithms (hell they are different libraries), is too much. Machine learning is more about the data, not the algorithm. You'll often have to try different algorithms to find which one performs best. And the tuning of that algorithm can take days to get a good model. Not to mention none of these take advantage of any sort of parallelization... This is why numpy is a great functional python library. One thing JavaScript is missing that would make this feat much easier to accomplish is a good matrix math library. Representing matrices with arrays is hard... There is [ndarray.js](https://github.com/mikolalysenko/ndarray), but the code is pretty cluttered and none of the libraries you mentioned actually use it... Pretty safe to say, if your doing MachineLearning atm, I would stick with Java (Mahout/Encog), Python (Numpy/Scipy), or a functional language geared toward matrix operations (R, Matlab).
Most of the modules on npm are not specific to Node/Browserify/Webpack. They are just a standard JavaScript and CommonJS, so they can be bundled and used in a variety of environments and with a variety of tools. Examples: - [matrix math](https://www.npmjs.org/package/gl-mat4) - [bezier interpolation](https://www.npmjs.org/package/bezier) and [adaptive curves](https://www.npmjs.org/package/adaptive-bezier-curve) - [color quantization](https://www.npmjs.org/package/quantize) / image palette generator - [xtend](https://www.npmjs.org/package/xtend) for extending objects - [inherits](https://www.npmjs.org/package/inherits) to inheriting prototypes - [events](https://www.npmjs.org/package/events) for a standard event handler - [debounce](https://www.npmjs.org/package/debounce), [domready](https://www.npmjs.org/package/domready), [and tons of other useful browser modules](https://github.com/npm-dom/) The list goes on: - https://github.com/sindresorhus/awesome-nodejs - https://github.com/hughsk/game-modules/wiki/Modules
&gt; But does a good developer really need something to give him direction? What's wrong with having your own architecture and style? Big sites are developed by teams, not individual developers.
ah, the sweet words of someone who just lost an argument on the internet.
6 minutes is such a short time, show pre-existing examples, I suggest pixijs, http://www.pixijs.com/examples/.
Exactly how stupid are you?? The test case you added in jsfiddle is _the slowest of the three_, and you apparently are too incompetent to realize that nothing you have ever said addresses ANY of the points in my prior post. Instead of addressing them, you act like you already did, wtf?!? You didn't answer a single point, ANYWHERE! I'm calling you an idiot because you're too stupid or incompetent to realize that. Articles like this are _worse than useless_, as someone is going to believe it and start producing code with it for absolutely no reason. You have false conclusions, nothing to back them up, I mean what the hell?!?!? The _only_ plus side from this whole situation is that writing code like `ary[ ary.length ]` isn't going to have much of a negative effect on anything.
Careful with meteor if you don't want to use MongoDB
Does anybody know where I can find out what Crockford does in terms of stateless JS?
http://i.imgur.com/5cdz04w.png
For sure. I'd like to add support for Backbone, Ember, Angular, along with other frameworks. 
*ROFL* Okay, let's see if I can put this in terms you _might_ be able to understand. If you respond again without actually reading or understanding what I'm writing, I'm just blocking you. - Your test case _is invalid_, as I've pointed out multiple times now. It's testing _something different_. Honestly, I'd expect it to be the fastest case and I can easily make it much faster, but that's irrelevant since the use case is _significantly less useful_ than "push". We're talking about replacing "push" here, you can't just say "Oh, well I don't want to do that. I'd rather do this other specific thing, look, it's faster!" In short, it's like I'm saying "Let's race around the block. First one back here wins". Instead, you run around a car, get back to the same point and yell "I WIN!" -- See why I think you're an idiot? - I already conceded that you might be able to find specific browsers, namely _older_ browsers that might run your code faster. http://imgur.com/a/oCA2t Your code is _4% slower_ in the newest version of FF, _24% slower_ in chrome, _9% slower in Safari_, etc. Not only does a 3% difference not matter much (it also negates the 4% faster in FF 31), but averaging this out over all the browsers makes it the slowest. Your argument is "Well it's 4% faster in _my_ browser, who cares that it's slower in the others?" Durrrrrr.... - You're an idiot for thinking a 4% difference matters - You're an idiot for not actually testing any of this before writing an article - You're an idiot for picking out _one point_ of 4 that you think you have merrit in (you don't), saying "I've addressed all your points" and ignoring the other 3 You know what? I'm done. If you write another article, be sure to actually do some research, as if you put out shit like this not only will I continue to tear it down as the less than worthless crap that it is. That being said, I genuinely hope you do learn to write valid articles and accept valid criticism. Your intent is decent, the execution was just off :)
I do have a few benchmarks I used while developing the template engine. I'll a few of them to the /perf page.
Thanks for the feedback. I figured that people would want certain features that might convolute the library, so I made paperclip module-based so you can add anything you want (everything in paperclip is a module). For example, here's a plugin for re-usable components: http://requirebin.com/?gist=858e3b7928eea5e1bed6
Write down what you expect from a framework. Then check out what framework meets your expectations best and go with it. Develop a small app with that framework or do the beginners tutorial so you can see how it feels to develop with that framework, that way you can facilitate your decision. I'm gonna make the prediction that web components are the future so having a look at React and Polymer won't hurt. Angular and Ember are pretty sophisticated and can do a lot for you which in turn can be overwhelming. If you don't like the boundaries of a fully fledged framework have a look at Backbone. More all-round solutions that include the server as well would be Meteor and the MEAN stack (not a framework but worth mentioning). Hope it helps.