Anyone used both NS and ReactNative? How do they compare, and do they solve the same problem? 
I'll be honest, I don't understand the appeal of Elm. Sure, the performance is great. Sure the fact that you can avoid run time exceptions is cool. What I can't get over is the fact that once again, we're trying to avoid writing JavaScript. Take these two todo list examples: Vanilla ES6 (Codes split between files - here's the controller for example): https://github.com/tastejs/todomvc/blob/gh-pages/examples/vanilla-es6/src/controller.js vs. Elm: https://github.com/evancz/elm-todomvc/blob/master/Todo.elm Because JavaScript's so pervasive. I can share the first example with other people on my team, and without having to teach them the intricacies of another language. I can be fairly certain that they'll manage to work with it. Anyways, each to their own I guess. I know I'll be sticking to JavaScript. * Fixed dup link.
This trips me up all the time
The nesting rule is one element per line, one indentation to represent an element being inside another. Elements at the same level of indentation are siblings. If you have elm-format installed, your code will automatically be reformatted to adhere to this rule every time you save, you can just write one long line however you want, not think about indentation, and hit save to format everything whenever you want. div [] [ h1 [] [ text "A List of Songs" ] , div [] [ text "Tracklist" , ul [] [ li [] [ text "Boys Don't Cry" ] , li [] [ text "Video Games" ] , li [] [ text "Black Celebration" ] , li [] [ text "Trouble Comes Running" ] ] ] , footer [] [ text "Copyright 1988" ] ] Each HTML element is a function that takes two arguments: a list of its HTML attributes, and a list of its child elements. This means that instead of manually specifying child elements, you can call eg `List.map` on some existing piece of data as the second argument.
All programmers dream of electric bugs
That seems really useful - nice work! Not sure if this was intended or not, but there is another library that is similarly named and exists in a similar space (CSS generation) https://github.com/stylus/stylus.
https://www.chromestatus.com/feature/5365692190687232 That link also links to Firefox, Edge, and Safari implementations. The gist of it is that it's a complex feature that's as actively being worked on by all major browsers. There's been some small hangups in the loader API that have resulted in some proposed changes and PRs, but all around progress has been moving along. 
I love it, and I'm someone who was very opposed to the whole "hot new thing" craze in the JS world. I think Elm actually solves a lot of that. You have to learn a new language, yes. But once you learn it, you find that so much of the extra stuff you always used alongside JS has now become unnecessary. Building anything remotely complex in the JS world you wind up having JS, a transpiler for your ES6, polyfills, a build system, a framework and/or UI toolkit, etc. With Elm, you've got *another* new thing to learn... but that thing renders all that other stuff unnecessary. I build complex things in Elm, just plain old Elm, no framework, no toolkits, no polyfills, no build system. No configuring Webpack or any of that. Yet I get all the features those things gave me, in a more powerful and simplified form, and as a bonus it's much lighter-weight, runs faster for my users, is more maintainable and much easier to debug. Probably the biggest plus, though, is that it makes it much easier for me to dive into other people's work and vice versa. In JS, it was always a challenge to start reading someone else's code and start mapping out the structure of the program in your head, what all the different parts are doing, where data comes from and what's transforming it. Elm feels much more straightforward and consistent, I can take any individual chunk of code and start working on it not needing to think about the application's overall structure, and when I *do* want to work out the application's overall structure it's much easier to trace through it and understand how all the parts are clicking together. I would really recommend it. Even if you don't get to use it at work, it'll teach you some new programming techniques and solid ways to structure and approach complex things in a simple way. And if you do get to use it, it'll save you so much time and clear away a lot of the messiness and fiddly cruft you associate with your work. I totally understand the criticisms of introducing new tool/language after new tool/language, but in this case, the pros greatly outweigh that con.
Can you explain that further? C# has Func and Action types that are pretty easy to use. Edit: it's actually had "() =&gt;" syntax for years, while JavaScript only recently got it.
You'll have to learn some PHP in order to implement Stripe's API. The good news is they have great documentation. I bet there are some YouTube videos out there that will help you along. 
Wrote a small jsFiddle profile browser (for public fiddles) with compact view, record limiting and search ability. No registration required and it's available as a fiddle. fiddleBrowser: https://jsfiddle.net/Belar/a0jbdsyt/show/
You need to pass the whole function to the event handler, not just execute it to get the return value.
I have a feeling that you are leaving out part of the question or setup. Does this specifically have to do with assigning functions declaratively in HTML only? In which case, this would be true. But certainly, you can assign functions (whether anonymous or not) to DOM elements declaratively in script context. &lt;script&gt; var foo = function () {}; &lt;/script&gt; &lt;!-- This is very declarative, but it won't work --&gt; &lt;div id="link" onclick="foo"&gt;click&lt;/div&gt; &lt;script&gt; // But after this, it will work... var el = document.querySelector('div#link'); el.onclick=foo; &lt;/script&gt; Do you think this is what is meant by the question? 
Not using either, but - they solve the same problem. NS is for Angular 2 and RN is for, wait for it, React.
You have 2 identical links es and elm.
It's really that C# doesn't let you treat methods the same as variables. You can define a delegate parameter and accomplish something similar, but JavaScript's implementation function passing is cleaner. The reason being is that JS treats functions as first class objects. C# with lambdas work for less reused functions, but delegates require that the function signature be clearly defined. Function&lt;&gt; wrapper is actually nice, but not as dynamic as JavaScript (you can't just pass it to "object"). Below is a sample that does about the best you can do IMO with function passing in C#... public decimal Multiply(decimal value1, decimal value2) { return value1 * value2; } public decimal Calculate(Func&lt;decimal, decimal, decimal&gt; operation, decimal value1, decimal value2) { return operation(value1, value2); } public decimal Test(decimal value1, decimal value2) { return Calculate(Multiply, value1, value2); }
I am interested in hearing NativeScript stories as well. Especially any where the technology backed you into a corner you couldn't get out of, as is the eventual case with many of these abstractions.
Just providing bindings was already solved by cordova etc. React Native (at least) is much more.
Cordova's approach is to provide x-platform, web-like APIs for mobile features. NativeScript is more like Xamarin: allow you to access the whole Android and iOS API surface in a non-x-platform way. React Native is similar to NativeScript in this regard, but only binds the APIs that have been explicitly exposed.
Once all languages can compile to wasm bytecode it won't matter what language you use. That's the future. 
What?
Exactly, similar to how TypeScript by default emits AMD-wrapped CJS modules: class Thing {} export default Thing becomes: define(["require", "exports"], function (require, exports) { "use strict"; var Thing = (function () { function Thing() { } return Thing; }()); Object.defineProperty(exports, "__esModule", { value: true }); exports.default = Thing; });
ReactNative was intended to build different UI experiences for iOS and Android it didn't embrace a single UI to rule them all. This is slowly changing but NativeScript was designed up front for that, so they have better cross plateform UI coverage with that. However, the biggest factor to take in is NativeScript and consumer mobile applications are far and few. It's mostly pitched as a replacement for enterprise / business to business type of application where time to produce is far more important than that of the overall application experience. It's not to say NativeScript cannot do it, but when you are able to write raw Android / IOS code specifically in JavaScript and not have to drop down to Swift / Java and then bridge the code, you start to see the benefits. ReactNative, you then get stuck building JS Bridges (Native Modules). I used Titanium when it did the same approach with giving raw access to Android and iOS classes, with random crashes and zero reporting, so NativeScript makes me a little worried when it comes to that but I don't have enough experience to have run into those same issues as before. Titanium created Kroll, which at the time was just too big of a feature, bridging not just JavaScript to Java or Objective-C, but every popular language to each other as well. You can see Kroll here: https://github.com/appcelerator/kroll/ and it looks like NativeScript is just focusing on JavaScript interop with Java and iOS languages, so it's a much smaller area to focus on.
One thing you can do yourself is try to use systemjs. It's implemented as close to the ES6 module loader spec as possible-so if you hit any roadblocks, you can create an issue in the loader spec repo.
@GeneralYouri thanks for the comments ;)
We'd be getting ahead of our skis a little bit to throw IIFEs out just now - in the absence of "let" which you don't get until ES6 is everywhere, they are still one of the more concise approaches to keeping data bound to function execution.
Sounds like you have limited time in your hands, I like the approach you took to come get some help on Reddit. I'm currently taking a JavaScript class and I'll just share some resources that I think could help you. They are some of the most emphasized resources by my professor: Codpen.io www.w3schools.com www.freecodercamp.com These are the top three resources there are many more like on YouTube I would recommend videos from code academy channel they have a really good fundamentals of JavaScript and JavaScript for beginners. Good luck in your future endeavors I hope the few resources listed above will be of great use in your journey. 
You want 'return firstname + " " + lastname'
How does NativeScript compare to Xamarin (C#) ?
You are missing curly bracket (}) at the end of the for loop in `list()` function. Also, you haven't defined `i` variable, you should have `for (var i; ...)`. Here: http://codepen.io/Paulooze/pen/PbKBQL?editors=0011
Neat. There's also a chunk of work going on to transition moment over to use immutable data
Seems really wierd that the size of the final bundle would differ that much. Are you sure you replaced `process.env.NODE_ENV` with `production` in the Webpack build so all that debug code in React was removed?
I have a co-worker that does literally everything in IIFE's and I really think it hurts the readability + maintainability of it compared to regular ES6 block scopes. Sure, IIFE's are fine if you aren't using Babel or anything of the sort. But at the point I'd question your lack of Babel use as opposed to your IIFE use.
How is it better than toLocaleString?
thanks man! i am already usinga canvas for the movement of my main char (santa) the only really difficult parts ahead of me are the spawning/hitboxes. i will check the frameworks out and hope i can find something.
What would js adopt other than typings? 
Shit, your right. Fixed.
Works for me. [JSBin Example](http://jsbin.com/xamacuyohu/edit?js,console)
I just try yourcode in https://jsfiddle.net/ and it worked. Is this the exercise or are you experimenting ?
Not to mention writing multiple variable declarations is perfectly normal and often considered good practise, for debugging and readability reasons.
It's the exercise, it says there's something wrong but it won't tell me. I guess it's bugged.
Wouldn't it make more sense to get these messages at compile time? Messages which only appear if a particular path is taken through the application are easy to miss.
Text inside code editor is considered plain text. That is different than you matching html tags with regex. 
Agreed, it's a bit pointless. Not to mention there are plenty of generic caching (or memoizing) libraries out there, why on earth write one so specific??
This seems like it was written by someone learning javascript-- this is definitely not production ready. 
At this point it's not really clear if Wasm will become a viable (or most suitable) compile target for every language. Also, the workflow of TypeScript and Dart is quite neat. Topping that won't be easy. We'll certainly start using Wasm modules in the future, but we'll continue to do the scripting with scripting languages which let us iterate quickly.
Wouldn't it be simpler to just support RAML?
I don't mind.
This util was born from a real-life project. We had a schedule, a couple of people and tasks assigned to them. Initially, application data handling/rendering process was taken about 12-14 seconds with 200 people and about 3000 tasks. Pagination and other things to split large data were unacceptable - all people/tasks should be loaded at once. The schedule represented calendar days (initially 90 days range) on the x-axis and people on the y-axis. Many tasks were the same date as start/end. First, by caching moment we have accelerated request data handling - all moment's processing was called only once on each date. So, secondary, it just takes value from the cache and clones it (if we wanted to change it in future). Afterward we have rewritten application with canvas. So, while scrolling we had to control which dates are covering screen to draw only tasks we needed. Although we have to control our cursor position and display the small popup with the current date. All these date manipulations became much faster after we had started to use cached values instead of parsing date every time. For now app loads in 1.5 seconds. It has 60 fps no matter how much tasks and people are loaded (thanks to canvas, but not without moment caching). 
It would be a problem if you had an app that needed to parse 100,000 timestrings in &lt; 1s. If you don't need it, don't use it. Some people may end up needing this. A small number of people? Sure. But just because you're apps wouldn't benefit does not mean someone elses would not either.
Yeah but for some languages events and callbacks would be much more idiomatic, so I doubt people will be writing Ruby for front end code. My bet is we will have a typescript like language, to compile to wasm 
I agree, I unfortunetly have to use RoR and man of man is that framework illustrate the failings of OO design in grand and disastrous fashion! In rails everything happens somewhere else, and it's such a pain tracking down changes in state as some input travels through hundreds of functions. 
Isn't ES6 pretty much everywhere? Well at least `let`.
Yeah, that's true. I think I should clarify my point: TS adopts JS specifications and not the other way around because an untyped language is not going to adopt static typing.
You're approaching the problem from a slightly weird angle, which is causing a bug. A simpler solution to this problem would be a single loop, which checks if the number is valid, and adds it to the output: let output = 0 for (numbers from 0 to 1000) if (the number is divisible by 3 or 5) add it to the output You're looping through to 1000 twice, once for 3 and once for 5, which does effectively let you get all the multiples of those numbers. However it means that you will add together numbers that match both conditions twice. I.e in the first loop you will encounter 15 (3 x 5), and in the second loop you will also encounter 15 (5 x 3). So your result will be larger by the amount of intersections for these two numbers. A similar loop will tell us that the sum of all numbers below 1000 that are divisible by both 3 and 5 is 33165. Sure enough, subtracting that from the number you got (266333) gives us the actual solution (233168) If you want to implement the correct solution yourself, look into the remainder operator (i % 3 === 0 establishes that a number is divisible by 3)
Ruby goes above and beyond. Don't even get me started about "method_missing".
I had to do something similar and also ran into issues no matter which codec i used for the video. The only way i know to do this, reliably, is by loading a bunch of low-res images into memory and scrub through them on a `&lt;canvas&gt;` element. Then, whenever the scrolling stops, switch out the low-res image with a high-res one. I built a little JS class that used GSAP for controlling the timing, but I can't find it now. Let me know if you want to proceed in this direction and need more info.
Sounds like the backup plan I had in mind :) If you have a demo or anything, that would be great! I'm a bit fed up as Apple clearly have worked out a way that works, but I won't be able to control the codecs of the video material, so resorting to a preloaded image sequence sounds like a good idea. By the way, did you try and see if storing the video in a blob makes any difference? Cheers
The problem covers somewhere in your routing actions. It might be wrong `Link`'s `to` property or wrong path while calling `this.context.router.push`. Search for smth like `&lt;Location to="//playerOne"}&gt; ` and replace it with just `to="playerOne"`.
TypeScript offers a pretty nice escape hatch - you can compile to ES6 and strip out the type annotations. So you don't have to worry about your codebase becoming obsolete. As for popularity, [this is interesting](https://www.google.com/trends/explore?date=all&amp;q=typescript,es6). WASM is a long way off, and even when it's ready, I'm not sure how well a compile-to-WASM language will interop with the ever-growing npm ecosystem.
Part 1, if you're interested, on cross-domain messaging: https://medium.com/@bluepnume/introducing-post-robot-smart-cross-domain-messaging-from-paypal-bebf27c8619e#.99t22l1ay
All the components follow [Ant Design specification](https://ant.design/docs/spec/introduce?locale=en-US), so they look so similar. And both of the specification and components are maintained by the same team.
Yep, they don't support a11y now, for `antd` is build for dashboard and so on. But we are working on it. The future version may support a11y, but not now...
I'd like to see an example of people actually printing deprecation messages in production. It makes more sense to print it in staging or development. Production should be sacred, silly extraneous things like deprecation messages do not add value to the application so they should be squelched.
No I'm talking about how it's so similar to [this](http://element.eleme.io/#/en-US/component/layout). The other library that I saw was similar was the iview project but they seem to directly link to the Ant design page so I'll assume that was intentional
state as opposed to.... state? 
Someone told me to always stick with the existing plugin and never roll your own. Jquery validate is gonna be maintained for some time, you'll basically have people doing your work for you, by maintaining it. I'd advise that unless there's performance issues, don't do it yourself... That being said, you could probably setup something that looks for any change in the form field (or even just when the field stops being focused), and then performs a regex to look for something with letters, then an @, then more letters, then a dot and then more letters. Could be an annoying regex to figure out, but I can't think of any reasons why that wouldn't work. Just disable the submit button and show an error message under the field when it doesn't pass.
Oh, and for requiring fields, you can do that with HTML on the field (just add "required"), or with JS I guess check that the length of the input value isn't 0.
server side.
Your article is useless this issue was solved a long time ago enabling hotswap by using watchify.
It's almost certainly because of one of these reasons: - Your videos are being scaled. The source video is much larger than the size that it ends up on the page at, and the scaling factor is not a nice even number (e.g., 2x, 3x, etc.). I imagine (though I haven't dug into the source) that Apple's video element matches the screen's pixel density. The network requests have `2x` in the URL, which suggests that they're dynamically choosing URLs based on pixel density. - Your videos are not fully loaded. Open the Network tab and look at the network requests for the videos. As you scroll, they load more. The browser intentionally tries not to load the whole media file because it's unlikely (in the general case) that the user will watch the video, let alone to the end. Apple loads the videos with XHRs so that they can load them completely and in piecemeal: notice that the MP4s that they load are only partial content. They concatenate them together behind the scenes as the videos load, meaning your scrolling doesn't get borked if the whole video hasn't arrived. - I don't have evidence to support it, but I'd bet they're using [passive event listeners](https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md). That will prevent your scroll event from blocking page scrolling. 
Looks to be WebGL. If you visit the site in firefox and open the Shader Editor, you can see the GLSL scripts. If you hover over "Program 0" on the left, you'll be able to see that it's made of simple transparent polygons with cloud textures moving toward the camera.
I'm not sure I understand how hotswap solves the question I was trying to answer. Can you share a link?
yavascript
`do` blocks are in the strawman stage in TC39 right now, I think.
I knew Element and iview. Actually, `antd` is published earlier than both of them, and they are inspired by `antd`.
Dont trust this guy, we also validate forms on client side. 
[removed]
Depending of design, either a pop-up or some message that shows below the field with some attention grabbing (ie just style input:invalid with CSS to highlight broken field)
possible, thanks :) 
A bit of backstory: I wanted a javascript library that implemented LDO or tf-idf to extract tags from text, I couldn't fine one (that wasn't slow, written 6 years ago and had Jquery as a dependency) so I wrote my own. It currently uses tf-idf, since that's the algorithm I felt comfortable with and I could just write it overnight, if its good enough for ES its good enough for me. Currently I wouldn't consider it complete, but I hope to keep the API the same and just add various improvements and new settings/options. If you wish to use the library without delving it to deep you can do so with exactly one line of code and in some cases it might generate satisfactory results. Note: This is not a replacement for a back-end tagging system but rather meant as a "helper" or an alternatives for projects that need some forms of tagging but aren't big or profitable enough to warrant using some fancy search-engine database.
http://izitoast.marcelodolce.com This subreddit is an amazing place. 
In your Insert function, try using `index` instead of `i`, when checking `titles[i]`. See what will come out. Also, You should consider reading about Scope in JavaScript.
Hi, There is already an issue for that. :-) https://github.com/gajus/babel-plugin-log-deprecated/issues
Maybe you can try https://github.com/react-component It's maintained by `antd` team, too.
As usual, in javascript there are many tools for each thing. I have used Mocha in several projects and it's enough for most of things.
[removed]
The main insight from my post is even put in my comment: A1 shows 4 apps on a small webpage that you can run and become immediately productive. A2 page is 100% marketing fluff. The web is not exactly full of reports of beginners feeling productivity boost from jumping to A2. Instead you pay attention to technical details such as `import` etc, these things change with time and the article is somewhat old by now. However the main point of it, that **A2 shows much less love than A1**, at least to beginners, is as valid as ever. Just read it at the end -- **the beauty of instant gratification of A1 feels lost**. This how A1 got the traction it got and I don't see any way or reason how A2 can get attention from the same people. In any case, to folks using A2 --- good luck to you! About native template specs, in the golden age of A1, there were many talks speculating that it created new syntax of the future that may well become native. That was an important point to make the syntax HTML-compliant. Then in just few years, people moved talking from the "HTML syntax of the future" to "A1 proprietary syntax". One thing you are totally right - it is definitely not for me, even if I am not a beginner anymore but I liked the experience A1 gave me as beginner, and I don't believe A2 can replicate it. Thanks for the links, where I still don't see a clear size summary. I mean a short simple table containing numbers, not a 30 pages technical guide with 20 new packages and long configuration files? How hard is it to put a concrete number for their size, at least of an example app, like other frameworks do? 
Keep in mind that React and Redux are frontend libraries. You still need to have a server application that talks to the db if you use them. You can use JSON API or GraphQL, etc to construct a bridge between frontend and backend. You said that you're newbie, which means that you probably don't need React yet, even more so Redux. Stick to Express for now. 
We use it in production, this is the closest to a complete UI kit i've come across. There are so many useful controls, all are configurable, it's light, modular and styling/overriding is easy. Each component exposes style and className overrides. I like that it doesn't follow the straight-jacked slot-based approach where a certain component can only accept this and that sub component or it falls appart.
Sorry I don't have it here. It's on some hard drive I don't have access to currently, but here's a quick walkthrough of what I did. 1. Use a load queue from [preload.js](http://www.createjs.com/preloadjs) to easily load the and manage the low-res images. This also lets me create a preloader graphic with little effort. 2. Use [GSAP](https://greensock.com/) to scrub through the images. For instance if the users scroll position is 50% down the page, then we need to scrub through half of the images. Here's a simplified version of my script: var tweenObj = { frame: 0 } var totalFrames = 550; function drawCanvas() { // Draw image on canvas. Current frame is `tweenObj.frame` } // Percent is a float from 0-1, not 0-100. function scrubTo(percent) { TweenLite.to(tweenObj, 0.5, { frame: totalFrames * percent, onUpdate: drawCanvas, roundProps: ['frame'] }) } Then, on scroll, I simply run `scrubTo(0.5);` The ImageLoader from preloadJS gives you something called a blob which can be directly drawn onto a canvas using `drawImage(blob, *width*, *height*)` The reason for using GSAP is that it makes it easy to add easing to the scrubbing motion, automatically puts everything in a requestAnimationFrame for smoother UI and makes it really easy to deal with onUpdate and onComplete callbacks.
I prefer parsley js
I load the high-res when needed. Loading all of the high res images would take up a lot of memory and likely crash iOS. I did something along the lines of ... function drawCanvas() { // Draw image on canvas. Current frame is `tweenObj.frame` } function hideHighRes() { highResContainer.style.opacity = 0; highResContainer.innerHTML = ''; } function loadHighRes() { var queue = new createjs.LoadQueue(false); queue.on("fileload", renderHighRes); queue.loadFile('path/to/highres/' + tweenObj.frame + '.png'); } function renderHighRes(e) { highResContainer.appendChild(e.result); TweenLite.to(container, 1, { opacity: 1 }); } // Percent is a float from 0-1, not 0-100. function scrubTo(percent) { TweenLite.to(tweenObj, 0.5, { frame: totalFrames * percent, onStart: hideHighRes, onUpdate: drawCanvas, onComplete: loadHighRes roundProps: ['frame'] }) }
Your question is mainly about redux, since essentially you're asking about state and data management. So I'll skip React. Redux is used to store subsets of your database content, as well as local application state (eg. which modal is open). There are a bunch of ways to sync updates to your redux store with updates to your API (and database). A common one is to use middleware - whenever an action is dispatched, it also sends a server request. You may be thinking that this seems like a lot of trouble for no real benefit, and in this instance, you'd be right! Redux works best IMO for apps where your core data is rendered in several different places. Eg for Facebook, it's nice to have a single representation of a given user, and to be able to pull from that data whenever you need to render a user avatar. If your site is entirely static (no updates to the page happen without making a server request and regenerating the HTML), you absolutely do not need redux. 
That's awesome, thank you for sharing!
That's the promise of [web components](https://en.wikipedia.org/wiki/Web_Components). Soooon.
This is a really cool idea! I haven't had a chance to really look at it yet, but how does it generate the info? Is it done statically or dynamically? If I generate a function at runtime and then console.log inside it will it pick that up?
Ohh yes, I've used watchify in the the past. I didn't realize it did that caching, but I've chosen to use chokidar for watching files instead of the watchify layer because I've run into the same problems that are outlined in these issues. https://github.com/substack/watchify/issues/324 https://github.com/substack/watchify/issues/325 It's awesome that watchify does this caching, but I think there are some other unsolved issues that cause it to run slowly over time. Maybe at some point I'll try to solve those problems and re-add it :)
"Computer chose 3". Apparently "3" beats paper.
I actually found the class I created. Here you go: https://gist.github.com/Ahrengot/76762bc8931d9b06dbef54ca517b7a07 The event emitter is something you can just remove if you don't need it. I used it because I had some nav stuff that was updating when the animation updated. If you need events this is the emitter I'm importing in the snippet above: https://gist.github.com/Ahrengot/9068aa3e8794dd18dade22f7fb233c34
you can use Redux with NativeScript. See this sample code - https://github.com/vakrilov/ng2-redux-nativescript
The following ideas are from my limited experience with playing around with server rendered Vue.js and Cycle.js test apps, and lots of reading. Hopefully it's helpful and accurate. I encourage others to correct any misinformation! You can combine the 'rendering/assets' server with the 'api/data' server if you want, or split them up. If they're combined, it would be tempting to let the 'client-side' code which is being server-rendered call the data fetching code directly, rather than making it do a HTTP request and wasting extra milliseconds. If you split them up, you'll need to run the individual servers behind a reverse proxy (like nginx). The reverse proxy is what you'd point your domain name to, exposed over port 80 or 443 to the outside world. You give it rules about which of your server apps should receive which request. Your browser JS would then do all of its data fetching using your public domain name, and the server-side stuff could do its requesting on a 'localhost:8000' type of address. Alternatively, you could use subdomains (like https://api.yourdomain.com) which point to the individual services. You'll need to setup CORS, but it's not a big deal.
Some of them look good although we've gone down the [React Bootstrap](https://react-bootstrap.github.io/components.html) path for the majority of things, along with minor plugins for datepicker etc. I'm not sure whether I prefer your `Form.Input` api or RB's FormControl api (or their earlier API....). There's some good stuff like 'Steps' though. We don't use webpack though so adoption cost might be high (I've not had to use it yet).
Also check out [Commitizen](https://github.com/commitizen/cz-cli), which is a wizard that guides you through the commit and produces the formatted commit automatically. From the parent's linked page: &gt; The commit message formatting can be added using a typical git workflow or through the use of a CLI wizard (Commitizen). To use the wizard, run npm run commit in your terminal after staging your changes in git.
&gt; TS adopts JS specifications and not the other way around JS isn't improved in a vacuum. The TC39 people do of course consider what other languages are doing. E.g. C# had arrow functions much earlier and for-loop iteration scope is a feature which was copied from Dart. &gt; an untyped language is not going to adopt static typing There were types in the ES4 draft (aka AS3). Also, the type annotations in TS are optional.
Hmm, I think Web Components have a different purpose from React components, and thus that both will be used together. I see Web Components as the materialisation of [these ideals](https://extensiblewebmanifesto.org/), in other words, for them to be used to create components like sliders and what not. So just like React components are still used in combination with native `&lt;select&gt;`s and the like, it will also be used in combination with Web Components. And those will be things like what's currently included in `antd` (as far as I can see, haven't looked into it deeply). And I think it can pretty much do all those things. Unfortunately I can't find it anymore, but I recall seeing a blog post by someone POC'ing a native browser implementation of virtual DOM. That was fun.
This will be very useful to me in the near future. I'm currently refactoring a code base to make use of Typescript and imports. I currently compile the TS files to use requirejs as that's what some modules were already using. I'm not sure if requirejs is the best option, though. If I'm correct I can simply compile my TS using a different compiler setting. That would allow me to use a different module system while leaving the TS code intact.
Wow this is incredible. I've been using material UI for my applications But found it was missing alot of good desktop components such as treeviews. The anchor thing is amazing. Popconfirm super useful. backtop is nice for long list. I implemented something similar to steps in my app but this one is much nicer. 
That's not a goal of WASM, and it is not being developed for that purpose. You might be able to hack something together, but it's not the reason for WASM. WASM is meant to write CPU-intensive modules in which will be called from JS. So you might write a big chunk of your "business logic" in something else and compile it to WASM, you'll still be calling that from js (or something that compiles to JS). You will most likely never have 100% WASM codebases.
What if you already provided 2 arguments to console.x ?
Since the code comes with source map you can open Developer tools and under Sources -&gt; source/fog.js you can see full source for fog effect. As /u/spacejack2114 said they use webgl, more specifically three.js
need more info. what are you stuck on? making the ajax call? handling the response?
You have two if statements checking the value of i from the prompt. The first one goes into the else as James doesn't equal james and then goes into the second if statement and hits the i=='James'.
The order of your operations is what is causing it to display no access then welcome James. So... 1) When you put in 'james', your function runs through the first if statement, finds that it equals 'james' then displays the alert. It never gets to the no access because 'james' evaluates to true. The second if statement evaluates to false because the J isn't capitalized so the second welcome message doesn't show up. 2) When you put in 'James', your function runs through the first if statement, evaluates to false, then hits the else statement and displays 'no access'. It then falls into the next if statement where it evaluates and discovers 'James' is true then runs your welcome alert message. To resolve this issue using just if and else, you'll want to throw in an else if statement to evaluate for the capitalized 'James' before your if statement hits the else condition: function y() { var i = prompt("what is your name"); if (i == 'james') { alert("welcome James"); } else if (i == 'James') { alert("welcome James"); } else { alert("no access"); } } 
Smellmo is right. Just to walk through some example of how to do this: function y() { var i = prompt("what is your name"); if (i === 'james') { // check for james alert("welcome james"); } else if (i === 'James') { // check for James alert("welcome James"); } else { // neither james nor James, access denied alert("no access"); } } Is the basic (long way to do this). How I would do it though is like: function y() { var i = prompt("what is your name"); if (i.toLowerCase() === 'james') { // check for james alert("welcome james"); } else { // neither james nor James nor JaMeS or any other combo, access denied alert("no access"); } } Notice that I did not change var i to lowercase on the prompt as this would loose the actual input details (which characters were uppercase) the user gave which you might want to know later. One other way: function y() { var i = prompt("what is your name"); if (i === 'james' || i === 'James') { // check for james and James using or operator alert("welcome james"); } else { // neither james nor James, access denied alert("no access"); } } 
Looks great. I'd love to see some real world examples of the source and compiled results.
Welcome to the untyped World! You are returning a string namely "starting.url" inside reduce - therefore the next iteration starting will be a string and not a boxart object with width and height. You should always return a value of the same type as the initial value when using reduce.
The parameter is being prepended. You can have as many arguments as you need. :-)
The update logic for EachBlocks is a bit [simplistic](https://github.com/sveltejs/svelte/blob/master/compiler/generate/visitors/EachBlock.js#L31-L48) (meaning it doesn't support keyed sorting), but it's an interesting project nonetheless. 
This is a good point that I hadn't thought of. I tried peeking at the [EachBlock example](https://svelte.technology/repl/?shareable=JTdCJTIyc291cmNlJTIyJTNBJTIyJTNDZGl2JTIwY2xhc3MlM0QnZ3JpZCclM0UlNUNuJTIwJTIwJTdCJTdCJTIzZWFjaCUyMHJvd3MlMjBhcyUyMHJvdyUyQyUyMHklN0QlN0QlNUNuJTIwJTIwJTIwJTIwJTNDZGl2JTIwY2xhc3MlM0Qncm93JyUzRSU1Q24lMjAlMjAlMjAlMjAlMjAlMjAlN0IlN0IlMjNlYWNoJTIwY29sdW1ucyUyMGFzJTIwY29sdW1uJTJDJTIweCU3RCU3RCU1Q24lMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0Njb2RlJTIwY2xhc3MlM0QnY2VsbCclM0UlNUNuJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTdCJTdCeCUyMCUyQiUyMDElN0QlN0QlMkMlN0IlN0J5JTIwJTJCJTIwMSU3RCU3RCUzQSU1Q24lMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlMjAlM0NzdHJvbmclM0UlN0IlN0Jyb3clNUJjb2x1bW4lNUQlN0QlN0QlM0MlMkZzdHJvbmclM0UlNUNuJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTIwJTNDJTJGY29kZSUzRSU1Q24lMjAlMjAlMjAlMjAlMjAlMjAlN0IlN0IlMkZlYWNoJTdEJTdEJTVDbiUyMCUyMCUyMCUyMCUzQyUyRmRpdiUzRSU1Q24lMjAlMjAlN0IlN0IlMkZlYWNoJTdEJTdEJTVDbiUzQyUyRmRpdiUzRSUyMiUyQyUyMmRhdGElMjIlM0ElN0IlMjJjb2x1bW5zJTIyJTNBJTVCJTIyZm9vJTIyJTJDJTIyYmFyJTIyJTJDJTIyYmF6JTIyJTVEJTJDJTIycm93cyUyMiUzQSU1QiU3QiUyMmZvbyUyMiUzQSUyMmElMjIlMkMlMjJiYXIlMjIlM0ElMjJiJTIyJTJDJTIyYmF6JTIyJTNBJTIyYyUyMiU3RCUyQyU3QiUyMmZvbyUyMiUzQSUyMmQlMjIlMkMlMjJiYXIlMjIlM0ElMjJlJTIyJTJDJTIyYmF6JTIyJTNBJTIyZiUyMiU3RCUyQyU3QiUyMmZvbyUyMiUzQSUyMmclMjIlMkMlMjJiYXIlMjIlM0ElMjJoJTIyJTJDJTIyYmF6JTIyJTNBJTIyaSUyMiU3RCU1RCU3RCUyQyUyMmdpc3QlMjIlM0FudWxsJTdE) and it came out at 7.5kb uncompressed. Copying and pasting the loop a few times makes that grow fairly quickly. Four copies of that example code is enough to make it grow over 22kb. For comparison, the `render` method in Mithril.js is about 21kb uncompressed. I imagine you would only need another 20 or 30 times more code to reach the size of React (~140kb). The one thing this project has going for it is that the generated code does appear to be highly repetitive, so it can probably gzip much better than a library.
No. I shouldn't have to modify an organization's code to learn about their product/offerings.
&gt; the browser at the other end (especially on mobile) has to parse/JIT/run all of that JS Yeah, that's true too. FWIW, I was actually doing some measurements on this just last night and it turned out it takes around 50-60ms to parse React (in Chrome on my desktop computer). As it turns out, that is enough time to paint upwards of 1000+ elements from a blank page state. I'm a bit worried that parsing the generated vanilla js might take even longer for a sufficiently non-trivial project. I also just noticed that the generated code here doesn't attempt to avoid the DOM at all. If there's a 30-row table with 5 dynamic rows in each, it'll happily assign to the DOM 150 times per update even if there's only one change in the data each time... 
Since you're creating `Job` within the function you can drop `Job.cache.config` and just reference `configure directly. It's in the environment of `Job`. Otherwise what you're doing is fine.
I am not returning a string. I am returning an object's key value. The join method converts that to a string. 
Webpack or gulp, personally rollup ATM. 
https://jsbin.com/yecusatiji/edit?css,console,output Here is my Jsbin. and i need to do like this, https://milosjo.github.io/nasa_project/ 
Have practiced with React for a couple of months now, at least, and also reading up on Redux (seems easier to understand getting in than Flux). &gt;(If you've been unemployed for two years, that's another reason for rejections, sadly.) This is somewhat true as well. More accurate to say I haven't been *gainfully* employed for two years, since I do get some short-term part-time jobs from my past employer occasionally. However, if more time spend unemployed begets greater chances of staying unemployed, that makes me wonder why isn't there any homeostasis in place in order to keep everyone's employment at an equilibrium. But this is a problem on a greater scale that is not limited to web development.
Yeah I did some C a little while back and was like, "wtf I can pass around functions? Why can't Java do this ffs?"
This looks a lot like "memoization", which is a valid pattern.
Worst. UX. Ever.
What's the benefit? Why use this over React/Vue/Angular2? Genuinely curious. The website isn't available at the moment.
I think `constructor` is a misnomer. Constructors are meant to return object instances when used with `new`. This is factory function creating function objects. Similarly, as an instance, not a constructor, `Job` should be lowercase. And as Meefims said, you can drop the `Job.cache` and simply reference `config` directly since its captured as a local variable in the factory function scope becoming a closure variable for the function instance and its methods created within. Is this valid? Yes. Is it something you should be doing? I would say, as an opinion, no. Generally you don't see functions used as objects this way. It doesn't technically add anything other than being a different way to approach what classes do already (other than allowing you to omit access to single method in favor of calling the instance directly?). This means extra time spent by others to understand this approach and mull over why it was done in favor of the more standard way to begin with. The object instance should represent what the object _is_ and its methods what it _does_. When you start merging these concepts (an _is_ that also _does_), it can get a little confusing.
The website is coming within the next week, you can see the design we're going with here if you're interested – https://twitter.com/trueadm/status/802675565421625344. On it's main benefit? Well Inferno is like an "improved" React in many ways, it offers the same API, removes some ugly bits (but they are still accessible via `inferno-compat`), adds some new features that React doesn't have and most importantly – offers drastically better performance and size. I'm not going to be as bold as the original poster and say it's the fastest UI library around, but in both benchmarks and real-world usage, it's definitely a lot quicker than React/Vue/Angular2. Performance is a key metric for Inferno, as I want to push mobile usage – as in my opinion, most library/framework authors simply aren't doing enough in that space. I've felt that performance has been pushed aside in the last few years because developers have been working on high-end MacBooks etc and have said "well it works fine for me". The realism is that this is definitely not the case for the vast majority of people out there. Note: I'm the author and thank you for all those who are interested in trying out Inferno. Jump on our Slack if you have questions of any kind :) https://inferno-slack.herokuapp.com/
Likely not a replacement/alternative for the filtering problem you are referring to, but a relevant method of getting more information and full interactive callstacks nicely into your console: function loggingFn() { console.groupCollapsed.apply(console, arguments); var stack = new Error().stack.split('\n'); for(var i = 2; i &lt; stack.length; i ++) { console.log('%c' + stack[i].trim().substring(3), 'padding-left: 10px; color: #777'); } console.groupEnd(); };
Is there a live sample (not a benchmark) that demonstrates a noticeable performance gain for inferno vs react? The only scenario where I've observed a noticeable slowdown on my phone was a long complex list; and I work on large scale react apps for a living.
Is it really returning instances? If we remove the return from `Job`, calling `new` on Job will produce an actual instance that still can access the config on its static context. Seems like the factory is producing multiple static classes -- they aren't newable so are truly static classes, not instances.
I don't think you really made a strong case here. You aren't even arguing against starter projects. You're arguing against using Redux initially by advocating a "start simple" methodology. That's not a hard rule to live by. If you're hacking something together just to learn it, sure. If you're building an application based off a set of requirements it's likely that you can make the decision on whether or not to use Redux before you even create a repo. You also don't address the actual reason most people are using a starter project which is to avoid the development environment setup and configuration of all of the other tools in the chain. React+Redux is incredibly easy to standup by hand. It's when you want to add Babel, ESLint, Webpack+Loaders, Karma+Mocha+Chai, Express, Node Environment configuration, npm scripts, etc. that you really get to the core of why so many people want a starter project. Anecdotally, had my team not used a starter kit we wouldn't have been aware (at the time) of Webpack's interesting code splitting features or the various patterns for handling SCSS in React applications or what some best practices are with regarding to chaining these tools. Vue.js is a popular view-only modern framework like React and the creator even made a vue-cli project that generates a starter project for you based on some inputs about linting, testing, and so on. I think the React team is working on something like this now. Starter projects are great for a number of reasons and can help you get to the part of your application that actually interests you rather than miring you in dev ops tasks that have very little to do with your idea. People just need to be cognizant of what they're using by fully reviewing and understanding the contents and tools of the starter projects.
Take another look at the expected and received outputs, your _is_ different (You aren't supplying the boxart for the first item). Here's how I solved it: return movieLists. // We want every video from every list, so map those an concat the arrays concatMap(list =&gt; { // We have to map every list's videos to the values we want // ie. { id, title, boxart } return list.videos.concatMap(video =&gt; { // We need to grab the valid boxart using reduce return video.boxarts.reduce( (smallest, current) =&gt; // Check the size smallest.width * smallest.height &lt; current.width * current.height // Largest was smaller still, so return that ? smallest // Otherwise, current was smaller so return that instead : current ) // Now map the valid boxart to the object we want .map(boxart =&gt; ({ id: video.id, title: video.title, boxart: boxart.url})) }) })
This is true. No point learning redux if you've not nailed down the basics. It's like learning how to edit a video without having recording one first. 
you can create a function that returns a query let dynamicQuery = (type, fields) =&gt; ` query Dynamic { ${type} { ${fields.join()} } }`
ehhh depends how the code is written in terms of being optimize. Run some test and see for yourself. But objects in terms of java(script) tends to be slower do to and object having to loading other forms of code that arent necessary when you can just load a datatype that is a "STRING"
A bit more info: [This is the implementation I am using](https://github.com/wwwtyro/perlin.js/blob/master/perlin.js), and this is the code I'm using it with: var rand = Math.random() var perlin = new SimplexNoise({random: function(){return rand;}}) var scale = .03 this.levelString = ""; var width = 4 * 16 * 2; var height = 4 * 16 * 2; this.level = []; for (var i = 0; i &lt; height; i++) { this.level.push([]) for (var j = 0; j &lt; width; j++) { var val = perlin.noise(i * scale, j * scale, 0) this.level[i].push(val) } }
Using comments. Use github or some form of resp. To contain the code in a server like fashion and if your working with a team.. Have meeting to dicuss the code and the goals of the project to better under stand each chunk of code.. Control CONTROL CONTROL AND CONTROL... stay contant at that principle and you'll be a the best manager ever.
&gt; In that case I'm not sure what you meant by this: When working with classic APIs there is a greater need of maintaining global state which is where Redux comes in. With Firebase you are constantly connected to the DB and changes are pushed automatically to your code, so the need of having global state is greatly reduced.
Hi /u/Nbm435, we're not simply going to do your assignment for you; please attempt the problem and show us the result, and then ask specific questions. Thanks!
I see no downsides to this, except the obvious - it's less well known. Not sure why FB hasn't hired the dev and incorporated the ideas. Smart work like this should be rewarded. If and when React Fiber comes out, the performance gap may narrow but that's not the only aspect. The source code by itself is a great thing thing to study and learn from.
This reminds me of https://github.com/monkberry/monkberry The compilation and update strategies are pretty similar. 
I actually kind of love that convention, but I think a lot of that is because I don't use JSX. JS object syntax is a really natural way to represent a DOM (virtual or otherwise) tree. When you're saying `ce(Form.Item, ` instead of `&lt;Form.Item`, it reads more logically because it's clearly saying 'create an element based on the class Form.Item', not 'create an element named Form.Item'.
Awesome. I'll see if that cleans up the code a bit. Thanks,
I think you're right. I have a Task class that looks a lot like this. It's a lot more readable than my current job code. I may have to wrap the job in a class for readability. Thanks,
Rewrote an old web app of mine over the weekend using Vue. It's a simple way to create a playlist of SoundCloud tracks that you can loop. https://constantune.com
Will do. Seriously impressed with the docs and demo components, beautiful work!
Don't need to save `setTimeout`'s return value; just calling it does the work we're interested in. Your `holdUp` variable is saving whatever the `setTimeout` function call is returning. But whether or not we save that return value, the function will be executed after the timeout. They (the return value &amp; the timeout-ed function execution) are different things. So you'll see the desired behavior with either `var holdUp = setTimeout(x, 1000);` (note that you aren't actually doing anything with `holdUp` after this line) or `setTimeout(x, 1000);`
Why does `Job` need to extend `Function`? class Job{ constructor(param1) { this.param = param1; } } const job = new Job('param1'); console.log(job);
Initial commit was mid-Nov. I'm guessing it needs some more inbound links to get ranked higher.
&gt; setTimeout sets a timer which executes a function or specified piece of code once after the timer expires. &gt; https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout Your code: console.log('line one'); var x = function(){ console.log('line two')}; var holdUp = setTimeout(x, 1000); console.log('line three'); And this: console.log('line one'); setTimeout(function(){ console.log('line two')}, 1000); console.log('line three'); are same. holdUp, the value returned by setTimeout, is a timer id. Use it with clearTimeout to cancel the timer. console.log('line one'); var x = function(){ console.log('line two')}; var holdUp = setTimeout(x, 1000); console.log('line three'); clearTimeout(holdUp); Copy paste each to chrome console to see in action. 
Are this similar or different, the same name are confusing. https://github.com/mattbegent/svelte
The setTimeout is executed normally even though you put an equals before it. It might seem a little weird with the setTimeout example, but for most things it makes perfect sense. var y = Math.random(); // You'd expect the function to be run here right? For the program to do what you were expecting, you could do this. console.log('line one'); var x = function(){ console.log('line two') }; var holdUp = function() { setTimeout(x, 1000); }; console.log('line three'); output: =&gt; line one =&gt; line three 
Clicked to help out a noob. Left thinking it really does look like malicious code.
Most likely some sloppy or vulnerability Javascript code will be hard to debug or break. Rollup is a nice tool http://rollupjs.org/
Are you calling scale before or after drawImage? You need to use it before.
&gt; So setting a function behind a variable does not prevent that function from running? Correct. setTimeout line returns back the id of the timeout function call. The callback function will be added to the event loop and executed on the appropriate time given. What the return value is useful for, is if you wanted to remove the timeout call **before** it has ran (aka clearTimeout(holdUp)).
Really difficult to tell what this is doing - it's created by one or more JS devs that appear to be highly experienced in browser exploits. I see references that are checking if the browser is Firefox, and references to Windows' kernel32.dll. [Maybe it's for an exploit similar to this?](https://www.exploit-db.com/docs/17914.pdf) Anyways, the code is creating a [service worker](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers). It's then doing something with the likely malicious payload (`var thecode` at the top of the script) and the memory/kernel32 function - possibly attempting to hide the majority of what the script is doing to the user by displaying some sort of game/animation to the user (hence the animation), though just a hunch. When it's done, it clears the malicious script from the DOM, as seen at line 75. Don't run the code.
If you are sending from a backend somewhere maybe the issue is the Content-Type header? If it's application/json vs text/plain. 
I'd be very interested to see the differences between this and React. Also it may be faster than React, but until people start perceiving React as "slow", I don't see myself and others switching from a robust, well documented, large company backed project to this. Code quality isn't everything. Then again, I may not be the target audience. I do applaud the effort though, hopefully the React team can incorporate some seemingly good ideas from this. 
Off topic but can someone here who is well versed with Angular 2 and React sell me opinionatedly on why React over Angular 2? I've never used React but I'm hesitant to invest time in it if I'm going to discover later on that I haven't benefitted much over ng2. 
&gt; So setting a function behind a variable does not prevent that function from running? You need to distinguish between defining a function, or running a function. In JS, a function is a first class object. That is, not only can a function/method be defined, but can also be stored in a variable, and used through that variable. An example .. ``` function f() { console.log('test'); } var a = f; var b = f; ``` I'm also defining the function here at first by using a function declaration. I'm giving the function a name within the declaration too - the name "f" - and after that there will be a variable f which holds our function. The function f will also be hoisted to the top of whatever scope we're in.. not big need to worry too much about hoisting while learning though. You can look it up later. After the function is declared and assigned to f, I then make two new variables, `a` &amp; `b`, and assign the function to them as well. This is just the same as if I'd assigned an object to them instead. ``` var f = { name: 'world' }; a = f; b = f; ``` Somewhere in memory is the object, and I now have three variables, all of this point to the one object in memory. Somewhere in memory is the function (from example above), and all three variable point to the same function. I haven't run the function at all yet! The function will only run when its actually used like a function.. eg. ``` var f = function() { console.log('test'); }; var a = f; a(); // calling the function a ``` With your `setTimeout` .. setTimeout is called and run straight away, and will return a value straight away. Like the other example go into, it doesn't return a function, it returns a "token" (not really, it's just an integer ID, IIRC) which can be passed to `clearTimeout` to stop the timeout running should you want to cancel it. `setTimeout` is a good example of how you can pass functions around like variable. You're passing a function to setTimeout which you would like to run after ~1000ms (not spot on, cause browser doesn't guarantee that). 
In Angular 1 &amp; 2 templates are strings (or separate html files) that contains snippets of a proprietary scripting language. It makes Angular slow, bloated and harder to learn. In react and inferno there are no templates, only javascript. JSX (used by both inferno and react) only makes it possible to write inline HTML in javascript. Makes react much simpler &amp; smaller, and developers only need to learn javascript not angular directives.
How does this compare in speed to Riot? I'm writing this from my phone, so I can't verify, but the size of the libraries are quite similar, though their APIs are very different.
I did begin by saying I'm a happiness is a boring stack kind of guy, so when I started this project, I went with the stuff I knew that works 100%. I also was previously working with C# and JS for the last several years. Haven't kept 100% current with all web stuff. :)
Would recommend posting this in the hacking subreddit if you want to know the finer points.
On the other hand, with that kind of a background, it shouldn't be too hard to learn some modern stack pretty fast. True, you're not gonna be able to produce new software at full speed right away like people with that knowledge already, but, anyway, the most important skill is the skill of programming, not the frameworks.
Great ! Thanks :)
Before...
[I'm not sure the typing works as intended...](http://imgur.com/a/nDIzV)
1. [learn about scope](https://www.reddit.com/r/javascript/comments/5c8209/need_help_wrapping_my_head_around_javascript/d9ul7i9/) 2. Avoid immediately jumping into inheritance. 3. Start writing an original application. Don't immediately jump into build tasks, frameworks, or other soul sucking insanity. The idea is to actually learn the language and expose the challenges in actually writing to the language early. Don't think you can mitigate this with a bunch of third party software or tools and still think you will magically figure it out later (because you won't).
I really enjoyed the article and I strongly approve of using 'real-life' code snippets instead of the contrived examples you normally find in these sorts of articles. Only thing that jumps out is that you're always using `let` when you could (arguably *should*) be using `const`. Could just be your code style, but I always feel more comfortable with `const`!
Riot is unfortunately quite slow. 3.0 is a bit faster, but still quite far behind the fastest ones. Here's one (very simple) benchmark: https://pakastin.fi/perf/
okay, i appreciate the response.So it seems i need to grab the concepts firsts(read books) then dive in vanilla js? Is this what you are trying to say /u/achen2345?
&gt; That said, React and Inferno make a number of different tradeoffs. Tradeoffs? The only downside of inferno is that it lacks event normalization. This could be added if someone actually took the time and published an npm module for that. I think someone eventually will. Should be doable quite fast if you extract the code from react or preact.
Ahead-of-time compilation in ng2: precompile your shit and shake your trees so you've got a bundle of executable code ready to load and render.
I'm a .Net dev in a similar boat. I started with Douglas Crockford's Javascript: The Good Parts. It's a concise and powerful introduction to the language for experienced devs. It's a quick read and (for me) a great place to start.
https://jsbin.com/xalemosepa/edit?html,css,js,console,output
learn vanilla before frameworks
A quick google search will turn up a PDF of it. I'm almost certain that it's a legit, free copy, but I'm not positive. You can get a used, physical copy for $9: https://www.amazon.com/gp/offer-listing/0596517742/ref=dp_olp_used?ie=UTF8&amp;condition=used
[removed]
I don't know of any good hacking subreddits (maybe /r/hacking). But I'll wait until Mozilla has a look at it first before spreading it out more. Don't want to give publicity to something that could cause undue harm or just be a load of crap. Again I'm a noob to the JavaScript field. I was thinking this guy was just pulling my leg by making some fancy spaghetti code (maybe using a program I don't know of to do it). But I was wondering so I posted it here. Seemed like a fitting place for people to tell me if it was bullshit or not.
That's a good point-react without babel and JSX is not so nice. Doable, but I'd probably go with vue too If I couldn't plug in Babel. There is another solution to this-systemjs. That module loader has babel embedded and runs transpilation inside the browser. Although that would be much slower than just using vue from a CDN for example.
battle? LOL both are of course handling the same goal but in terms of how the library's are written... just depends which one uses memory more efficiently and keeps constant speed. So do some test for you self. I would say vue due to load times between dom and the webpage using only 16kb of memory on loads
I found out my co-ordinates where off when I applied the negative scale to the 2D context... It's working now! Thanks for the offer though! =D
Yeah of course. just have fun making wrappers for other api's to read your api. or if you a wizard hard code that stuff
but if the album hasnt been released yet, there isnt an id available :-S
&gt; It makes Angular slow, bloated and harder to learn. This is a pretty bold statement. 1) The A2 benchmarks I've seen do not leave the impression that it is "slow" 2) I have a hard time believing that the common directives (proprietary scripting language) bloat A2. Perhaps the compiler, but that is easily solved with precompilation (AOT). 3) Harder to learn is very subjective.... how hard is something like `*ngFor = "let item of items" ` to understand? 
Probably, I do it with the compiler-cli.
hm looks like its not an out of the box feature with spotify. they built it custom. Most likely stores your username and password in their db and then when the album is released they have a script that automatically logs into your account and adds the album to a playlist here is the js file: http://presave.kls.io/static/js/preorder.js
&gt; [mb]?(tr)?illion Good thing it'll still work when we transition to using mtrillion and btrillion! I think what you probably wanted instead was `\b(m|b|tr)?illion\b` (word boundary optional)
Re: 3 ngFor isn't that hard to learn, but it does add surface area and therefore makes the framework harder to learn, or at least, means that there is more you have to learn. That's the beauty of React's HTML in js approach, you can just use the same js functions that you already know and use elsewhere in your code, and can continue to use if you stop using react. I've also found it hard to debug an ngFor in the past when I was doing things wrong, which also made learning harder for me.
/r/asknetsec could help.
A lot of people brought this up to the author of Inferno on their Slack channel last week. We also had issues with `inferno-compat` and using mixins of a third-party component we use but the problems have been fixed since. If you have issues, you should raise bugs like I did and they are pretty good at getting them resolved.
Inferno doesn't have synthetic events or React Native support. It also splits out things like createClass, createElement, stateful components etc into separate packages/modules so you can pick and choose what bits you want rather than have a bloated core with everything in there. I also read on Twitter that the React team are using many of Inferno's ideas in React Fiber to improve performance.
Vue is mentioned a lot lately but have you looked at Riotjs. Its templating like Vue but with a simplier non v-* everything Its the simplest framework for display i've ever seen. Here is a full roundup **Markup api** * If/show for conditionnal (mount/display) * each for loops Data is injected with **{}** like **&lt;p&gt;{text}&lt;/p&gt;** **Component lifeCycle** * Mount * ShouldUpdate * Update * Updated * unmount props are accessible through **instance.opts** like **this.opts.myProps!** There you go! The state management is entirely up to you, lately i use mobX i like it better than redux because of declared Stores as class feels more like home and not writing reducer/selectors/actions for everything i want to do while keeping better organisation(imo) That's it, no proprietary set of functions nobody knows about. No need to constantly keep the API open on the side at all time. Riotjs allows you to get back to working !
no, i move to [elm](http://elm-lang.org)
Factory functions: each instance has its own function, taking up it's own memory and closure. Prototype: each instance refers to the same function, which is only declared once on the prototype then inherited by reference.
What makes me hesitant to switch is React has an absolutely awesome amount of libraries out there for it. Need a date picker? Just find one you like. Same song and dance for many little things I don't want to always make, mostly UI wise.
I believe you should add one `return` in that last if where the `getVIdeoIds` is called. And append `.then(resolve, reject)`. Hope this help, but i may be wrong - didn't invest too much to think.
You aren't dealing with the promise resolution from you recursive call to getVideoIds. getUploadId(ytChannelName) .then(id =&gt; { getVideoIds(id) .then(ids =&gt; { console.log(ids); }) }) var getVideoIds = (uploadId, nextPage) =&gt; { var nextPage = nextPage || ''; var videoIds = []; return new Promise((resolve, reject) =&gt; { youtube.playlistItems.list({ key: secret.api, playlistId: uploadId, part: 'snippet', pageToken: nextPage, maxResults: '50' }, function (err, result) { if (err) { return reject(err); } // Save ids of videos to variable result.items.forEach((element, index) =&gt; { videoIds.push(element.snippet.resourceId.videoId); }); // If there's another page get that also if (result.nextPageToken) { getVideoIds(uploadId, result.nextPageToken).then(ids =&gt; { videoIds.push(ids); }); } console.log(videoIds.length); return resolve(videoIds); }); }); } 
&gt; Not sure why FB hasn't hired the dev and incorporated the ideas. Smart work like this should be rewarded. So everybody has to work for the fucking facebook? What if someone consider it to be like a cancer that should be destroyed instead?
I think elm looks nice, but I don't want to end up with another coffeescript maintainability nightmare.
That blog post is 9 months old - I'm guessing these issues are related to Vue 1, since Vue 2 came out a shy month ago. Might be relevant for 2 also.
It's not a blog post, it's part of the API. In Vue 2 you'll find it here: https://vuejs.org/v2/guide/reactivity.html#Change-Detection-Caveats and here https://vuejs.org/v2/guide/list.html#Caveats These are Javascript limitations. You can't easily observe objects browser-crossplatform and all libs attempting to will run into the same problems.
There is something wrong with your "pseudoclassical" example. You shouldn't put an instance of Mammal as Cat's function prototype object, you should link Cat's prototype (Object.setPrototypeOf) to Mammal's prototype. Check out ES6 classes and what they are syntactic sugar for.
Nah man, haven't you heard? Making a sweet JS library totes means they aren't evil! 
Well, what do you find interesting? What are your goals?
I think, you can create an automatization helper. It can be make something easier than the previous situation.
True! Ok, i put that resolve into an else statement if (result.nextPageToken) { //console.log(result); getVideoIds(uploadId, result.nextPageToken, videoIds); } else { console.log(videoIds.length); return resolve(videoIds); } Now i takes it's time and logs the correct number of ids at the end. Thanks! But it seems that the 'console.log(ids);' is never reached now like the first promise is never resolved. edit: OK, got it. Needed that resolve, reject from /u/alsiola if (result.nextPageToken) { //console.log(result); getVideoIds(uploadId, result.nextPageToken, videoIds).then(resolve, reject); } else { console.log(videoIds.length); return resolve(videoIds); } This is working as i wanted it to. Thanks to all of you! Have a nice day... edit: i meant /u/tunnckoCore
Apples and Oranges. As far as I am aware, Angular is a full end to end framework with lots built in. Vue is a view layer like React. That is all. Angular can do what Vue does and much more. Just use the proper tool for the job. 300kb can be the tradeoff you're willing to make if you need everything Angular is doing. You could easily get up to the same size with Vue once you start importing other libraries etc. 
Automation for what?
My interests lie in anything that can benefit others but my preferences are to make something unique. When I say interesting, I mean what interests you. My goal is mainly to gain more experience and contribute to creating something open source that benefits someone other than myself.
Maybe you could automate the generation of ideas for npm modules?
Hello everyone. I'm the author of the project, my goal is to provide a simple and easy to use photo gallery component that works with any kind of photos just by passing them as an array of objects. The project is still in development. Feel free to ask me any question either here or on Github. Pull requests are welcome!
https://github.com/facebook/flow/issues/869 really cramped my style when I tried to adopt Flow and one of the npm modules I was using also used Flow. It'd be great if shipping a module with Flow types didn't cause "downstream" problems.
Please don't. You are getting the process backwards.
You should make something that fills a niche and that you would personally use. I'm a UI designer and I recently decided to make a series of micro libraries to cover some common functionality and use cases i have in many of my projects. This is something that I will use on a daily basis and because of that it will keep growing and advancing and I'll have a good insight on how the developer experience working with it is. 
I completely forgot about that. It would in this case where the API is in a fixed location. CDOP doesn't work if you need to access a random or moving target.
If you don't have an idea for something you *personally* need and/or are passionate about, I wouldn't suggest working on a random idea suggested to you by an Internet stranger. That's just a recipe for creating yet another unmaintained npm package. If you just want more experience and want to contribute, I'd suggest finding an open-source project on Github that you use/enjoy and work on issues. It might not be glamorous, but it's a great way to get your name out there and maintainers are usually happy for the help.
Imposing on-browser transpilation on your users of wrong. Don't even think about it
You might also want to take an hour to evaluate [Ractive](http://www.ractivejs.org/). (The website hasn't been updated recently, but the [library itself](https://github.com/ractivejs/ractive) is under active development, and I've been very happy with the latest version. I took a long time to pick the right UI library for my company, and so far I've been very pleased that I chose Ractive. It's probably closest in design philosophy to Vue, but the way it does data binding seems much more intuitive to me.
That's a question I think you should post in both /r/reactjs and /r/angularjs (or /r/Angular2 or /r/angular). Chances are much better to get a decent reply there :)
Template conditionals are code, very limited code without convention, that is. &lt;li v-for="item in items"&gt; {{ item.message }} &lt;/li&gt; Expressions are code as well: &lt;div id="example"&gt; {{ message.split('').reverse().join('') }} &lt;/div&gt; As for React mixing code, you don't need to. In fact you often wouldn't at all. Computed props are a work-around for having no classes. If you had classes, you wouldn't use computed props. You could easily do computed props in React, but why? You'll also find that a Vue component can be fragmented due to its logic being sprinkled about. A component in React is a flow of information leading to a concise result. VUE &lt;template&gt; &lt;div class="example"&gt; &lt;p&gt;Original message: "{{ message }}"&lt;/p&gt; &lt;p&gt;Computed reversed message: "{{ reversedMessage }}"&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; .example { background-color: red; } &lt;/style&gt; &lt;script&gt; module.exports = { data: fuction() { return { message: "hello" } }, computed: { reversedMessage: function () { return this.message.split('').reverse().join('') } } } &lt;/script&gt; REACT @stylesheet` .example { background-color: red; }` class MyComponent extends React.Component { state = { message = "hello" }; render() { const reversedMessage = this.state.message.split('').reverse().join(''); return ( &lt;div className={this.props.classes.example}&gt; &lt;p&gt;Original message: "{this.state.message}"&lt;/p&gt; &lt;p&gt;Computed reversed message: "{reversedMessage}"&lt;/p&gt; &lt;/div&gt; ) } } Or stateless ... const MyComponent = ({ message }) =&gt; ( &lt;div style={{ backgroundColor: 'red' }}&gt; &lt;p&gt;Original message: "{message}"&lt;/p&gt; &lt;p&gt;Computed reversed message: "{message.split('').reverse().join('')}"&lt;/p&gt; &lt;/div&gt; )
He did include all the add-ons on the Vue side though, so this looks fairly apples to apples (or at least apples to pears). "Can do a lot more" is kinda loaded too. An app only does what it was designed to do, any framework features that the app isn't using is bloat.
No... the fastest JavaScript library would be no library at all. The **real** question is what does your library **do** for me? Only after that and after there are other competing libraries that do the same thing does performance and/or size matter.
This is a really interesting approach, thanks.
/r/netsec 
You can use jsx with vue
At which point you are writing React, maybe with questionable benefit, while being cut-off from its eco-system. It's similar then to Inferno, Preact and some others, but they do offer compat libs so that you're not stuck in *their* eco-systems. 
I don't consider "added to the spec" a valid argument, neither is linking to a code base of your own. Each file could have a export with a proper name to start with, and you could group functions that belong together in files, a codebase that spreads thin like that are tiring to navigate. You're just spreading your functions over files, and to see what each function does you need to navigate back and forth + most of the functions only get imported once, where you need them, so it makes little sense to prematurely move them to a seperate file. This solution doesn't promote testability "more" than normal named exports do, so I think that's also a moot point. PS: I see now why you are so defensive, it's your own plugin. Eh. 
I think what you mean is a Javascript library. NPM is irrelevant, especially in this brave, new Yarn-based world. As other's have said, trying to write a solution to a problem you personally don't actually have is a bit silly.
Some guy? What? 
Does it work with promises correctly?
It really is quite slow. That is seriously disappointing. I found the format/syntax of Riot compelling, but performance like this will keep me from ever using it for something significant. Edit: I am curious how this test works, because I am not getting any where near the times suggested by the first page of your performance test. For example, my React 0.15 time for reversing is around ~500ms, ~80ms. What other factors play into this?
Chances are you'll never be in a situation where it's measurable without diving into your call stack performance measures, let alone notice anything. 
I'm so sorry. I don't code professionally (or have friends that code) so I never have to communicate these things. Add in the fact that I'm not a strong communicator, and you get my messy thoughts everywhere. Using your suggestion I created a GitHub repo with a simple implementation. I edited my question with more information too. The repo: https://github.com/gruberjl/job. Do you have a moment to take a look? I've been using the word 'state' poorly. They're two parts of the 'state'. 1. Configuration: The config is passed into the job. The job constructor may add some default values, but the configuration will not change after the initialization. 2. I cache validators and results so the job won't continue to perform the same work over and over again. In the repo, I have a `Job` class (./job.class.js). Each instance of a job will have a `cache` object. The cache object would contain both the configuration information, as well as, any other information the instance may need. The cache object on an instance is a standard pattern I started using since es2015. I call everything inside 'state'. Would you consider the configuration 'state'? Should I keep it in a different location away from the other 'cached' information?
&gt; Templates are a regression to free composing and object oriented components One of the best things about React is being able to debug everything easily since it's all just JavaScript in the end and sourcemaps work out great. Developers inexperienced with the platform can just set breakpoints, step through code, even step into library internals to get a feel for how everything is working. Debugging templates is much trickier. When things go wrong, you can't inspect their behavior with the same depth as React / JSX components.
I did, for one reason, buddy: future-Futureproofproof.
If you're an individual developer, working solo just to pick up newer frameworks, I strongly recommend you give each one a try. I don't find the TODO list a particularly useful usecase to implement - in the sense that given the very limited scope of the widget, it isn't too revealing about how the framework will assist you in scaling your code-base's complexity once it starts to get large-ish. Instead, I have had a pretty serious weather dashboard application for a long time (talks to OWM api), and it allows a large number of customizations, has heavy amounts of animations and plentiful widget instances - and I re-build this in each newer framework. Takes me about 6-7 days now, since the styles and skeleton templates are all reusable, and also since I'm new to the framework being tried out and gaining fluency slowly. Beyond populism, the fad and hype, conflicts-of-interest, bias and everything in between, I've found this to be the only way to form a valid opinion - and to clarify, it's NOT an opinion on the merits of the framework itself, but whether or not my way of thinking and my mental capacity matches with how the framework lays out the conventions, and whether I will be productive in it. With 20 years of JS experience, I'm sure you will be a lot more opinionated than a modern day, 2 to 3 years experienced *"badass rockstar tech node.js developer doing isomorphic universally rendered apps with async secret sauce"* (ref: https://www.youtube.com/watch?v=bzkRVzciAZg). You'll have a very strong mental mapping of how the data should be structured, how it should be weaved into a renderer / templates etc., perhaps MVC will be more appealing or less, or perhaps a one way data flow will be very natural. Trying out the top candidates right now, for someone with your experience, should take no more than 2-3 weeks. Perhaps you already have a jQuery heavy widgety SPA-ish page which you can isolate easily and try to rebuild with each one of those? If I had to guess, Angular 2 will take you the longest to get going (and perhaps even implementing), whereas Vue and React will be a lot quicker (as will Angular 1). 
Will do. For the record though that's a straight quote from "The Good Parts."
async + recursive calls is a good use case for coroutines/generators/async functions. while (someCondition()) { videos = await getMoreVideos(); } return videos;
While I like Vue, in my work environment it is still too small (community/vendor support wise), so we don't use it. Mainly issues where we do a lot of AB testing, provide different metrics, etc. Any time we introduce new technology on the front end, it drastically impacts all the standards our various marketing/testing groups work with (and the vendor tools they utilize), so it makes introducing smaller types of technology difficult. This also in-turn means our front end has to spend time building proof of concept that it won't break any other design structures/etc.
Fortunately for you JavaScript regex has no support for internationalization. This means the `\w` grouping is equivalent to `[A-Za-z0-9_]` and the `\W` grouping any character not matching `\w`. So if every word character must be not touching another word character: if ( (/\w\W/).test(myString) === true &amp;&amp; (/\W\w/).test(myString) === true &amp;&amp; (/\w\w/).test(myString) === false ) { That one accounts for if the string does or does not start with a word character and/or end with or without a word character. It does not account for white space. I am going to presume by *symbol* you mean every character that isn't a word character and isn't a white space character. The grouping for white space is `/s` and its opposite is `/S`. if ( (/\w\W/).test(myString) === true &amp;&amp; (/\W\w/).test(myString) === true &amp;&amp; (/\w\S/).test(myString) === true &amp;&amp; (/\S\w/).test(myString) === true &amp;&amp; (/\w\w/).test(myString) === false &amp;&amp; (/\w\s/).test(myString) === false &amp;&amp; (/\s\w/).test(myString) === false &amp;&amp; ) { That is the most precise way to go about this, but its pretty bulky. I challenge you to make this more compact by trying to combine some of those expressions together.
I added some more information in the question to clear up the confusion. Simply semantics. I could use a class. https://github.com/gruberjl/job/blob/master/index.js#L58-L67 // This is an example showcasing why I want to have a function vs object. const resource = { // If a job was a function I could do this addFunction, // Job is an object so I have to wrap it up (unless someone knows something I don't) add(...params) { return add.run(...params) } }
Sigh, these are terribly misleading arguments. (Note: not objecting the "middleground" part, but about gotchas/hard to reason about arguments) First, React has its own [gotchas](https://medium.com/@mweststrate/3-reasons-why-i-stopped-using-react-setstate-ab73fc67a42e#.hbwd0477n) and [dirty corners](https://facebook.github.io/react/docs/context.html). There are also a number of "JSX gotchas" which you don't run into in templates. Every framework has its inner intricacies when you actually use it at non-trivial scale. The fact that we are prominently documenting about the limitations and caveats is because we'd rather be upfront so that you don't have to hunt for it in 3rd party blog posts yourself. And no, the caveats you linked to are not that hard to reason about: * the reactivity problem is [thoroughly explained](https://vuejs.org/v2/guide/reactivity.html) in the docs, if you know how JavaScript works, then it's not something fundamentally confusing. * React DOM updates are async as well due to `setState` batching. * `data()` needs to be a function for the same reason `getInititialState()` is a function. * the camelCase vs kebab-case issue is non-existent when you use default build tool setups in Vue 2. On the other hand, a React app can also get terribly complex if you just resort to nested props callback passing without the help of a flux-like library in the mix. At that stage, if you want to talk about "easy to reason about", it would only be fair to compare React + Redux vs. Vue + [Vuex](http://vuex.vuejs.org/en/intro.html), where both sides are using established best practices for large scale state management. Linking to year-old issues and outdated blog posts as if they make Vue fundamentally flawed just makes me feel like you are intentionally painting a bad picture for Vue due to your personal preference. Vue 2 supports both templates AND render functions, because we believe templates offer better readability for pure-presentational components and render functions offer composition flexibility for logical components. You can even use [JSX](https://github.com/vuejs/babel-plugin-transform-vue-jsx) if that's what you prefer. The bottom line is you will **not** lose out on the pure-js composition power when you need it. Vue's default API does not assume a transpiler nor ES6 environment, because it can be used and many people do use it without any build tools - which is why we do not offer ES6 class based API out of the box. This is similar to `React.createClass`. If you prefer class syntax, [vue-class-component](https://github.com/vuejs/vue-class-component/) offers that via Babel or TypeScript. Back to OP's original topic though, I'm not arguing that you should switch from React to Vue, especially if you are already heavily invested in the React ecosystem. [There are some subjective reasons (eg. template vs. JSX) and some objective ones (e.g. smaller size, better perf)](https://vuejs.org/v2/guide/comparison.html), but ultimately it has to do with how deeply you have invested in React. It would be another topic if this were about choosing a new tech with no prior investment.
Perhaps "can offer a lot more" (in terms of features) would be a better use of words. I'm not arguing for either *thing*, I just the think the tired comparison is always flawed from the start, just like the React Vs Angular debates too. In any case, I think in web development, sometimes we focus just a little *too* much on file size alone. There are a lot more points to weigh in like runtime performance etc. You can have a tiny 7KB library, but what's the point if it runs slow or crashes your browser? Choose the right tool for the job. Angular may be bigger, but you may need it one day over Vue and vice-versa. And on top of all this, there are many tools to help reduce filesize now, like Gzip, minification, modularisation, tree-shaking etc. A good build step should a crucial part of the process, as we can't rely on the framework to do it all for us in the first place. 
&gt; And a React app can also get terribly complex if you just resort to nested props callback passing without the help of a flux-like library in the mix This fucking killed me when I tried to learn React. I was struggling with all my props and callbacks. When I asked Stackoverflow, they just told me to use Redux. Turns out, you need Redux/Flux like 90% of the time if you want to do anything besides a practice TodoMVC.
Object.keys() The Object.keys() method returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well). https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys 
Why does the width of the Theater__stage element change after a transition even if the dimensions of the image don't?
The truth is that my css skills are still low and I'm learning how everything works so to answer to your question "It's not intended but I'm working on it"
i will go over it, thanks for the link.
No they don't have to, but the option would be nice I'm sure. Same thing happened to Dan.
Give them a few spins.. I measured the times with a 2015 MBP 13" retina + latest Chrome for Mac.
huh, i had no idea you could color console.log's like that. neat! some things to consider when debugging: 1. if you're using a browser you might be looking at the final array- not the array it *was* when it ran. Console just links to the final version, it's not a copy/image. 1. is your code running asynchronously? I find incrementing a character (a-z) is more helpful than reading off the value of i (0-9). That way when you see x-&gt;y you know you're looking at accurate chronological data. 3-&gt;4 may be misleading when 3 and 4 are different i loop values. that said, I don't see what's wrong with the permutation function. it seems to be a little repetitive, but that might just be the glut of console.log's. 
There's some mentions of rop chain and popping EAX off of the call stack, which is some assembly hackery nonsense - it's definitely malicious.
If you want to know what it's doing you might want to read about ROP chains and heap spraying. Might be exploiting use after free vulnerability. I've only skimmed through it but it's not particularly trying to hide what it's doing.
Hi, thank you for your feddback. Can you elaborate on the aspect of how using named functions instead of arrow functions aid navigation of the code base. My experience is that most navigation in a code base happens by searching for file names. Maybe you navigate the code base using different search criteria. I'd like to know.
Yep, keyed updates are still a TODO – we have an open issue for it https://github.com/sveltejs/svelte/issues/33
Thanks for the interesting feedback! I'll fix the Smalltalk thing :)
Coffeescript was terrible because it could be very ambiguous visually. Elm (haskell really) doesn't have that issue. Elm missing features like typeclasses, too much focus on 'beginners', or having almost zero docs about how to scale beyond hello world are different issues.
Vue *feels* more complex then react because react is in essence a single simple building block (a component) which everything is built with. Now that doesn't actually eliminate complexity but just moves it to the ecosystem and the build system, but it does make it feel like react isn't actually there because it's just components all the way down and the thing you're confused about is redux or saga or react-router but that's your fault because you chose that dependency. But at the end of the day if Vue allows you to do anything it's just react with a larger surface area and more methods you're not familiar with but your coworker uses. Saying it was a middle ground between angular/ember and react isn't an insult, it's a fine place to be but it is a hard place to maintain because you're not the best at anything and most medium framework can be tricky to brag about. 
Thank you!
Interesting, thanks! I think I like the *… class* better because as you said, it's a blueprint for (the layout of) all objects sharing this *hidden class*. Just like Java/C#/C++ compile-time classes, they cannot be modified at runtime.
This got a bit wordy, you probably don't have time for it all. The 'implementing job with functional programming' section is the part I'd love your input on. # Understanding state Regarding the configuration: You're correct. It only needs to be read publicly for automatic documenting of the job. It shouldn't be edited after the job's constructor completes. I could freeze it, or use an immutable. If I'm using a class, I would have the `set config` throw an error. Regarding the state: it doesn't need to be public. I may have been using the word state incorrectly. The only information (other than the config) is a cache. It actually ends up being similar to the memoize pattern. If I execute the `add(1, 5) == 6` then I would store a map that ends up looking like: `map.set([1,5], 6)`. Instead of revalidating the parameters, running the worker, and then validating the output, I would pull the results from the cache. Would you consider a cache to be 'state'? If the function is pure, I guess all calls to the job could use the same cache, which means I wouldn't need an instance of the function. # Understanding functional programming I don't think I fully understand 'functional programming'. Functional programming works hand in hand with (Facebook's Immutable)[https://facebook.github.io/immutable-js/] right? I've never tried to use it, I have difficulty grasping the idea. I don't see how someone could keep the information straight. Here's an example from the immutable website. import Immutable = require('immutable'); var map1: Immutable.Map&lt;string, number&gt;; map1 = Immutable.Map({a:1, b:2, c:3}); var map2 = map1.set('b', 50); map1.get('b'); // 2 map2.get('b'); // 50 1. Would this be functional programming? 2. Now I have my information in two separate locations. Wouldn't it be better to modify the original? 3. Wouldn't performance go down the drain if you keep recreating an object? 4. Is this the opposite of a connect based system such as [Express Js](https://expressjs.com/) who passes two objects around? 5. If I was running 2 async functions simultaneously, wouldn't I now have 3 objects and a huge mess trying to get them back into one object? # implementing job with functional programming I tried writing it using what I think is 'composite' 'functional' programming haha. I added it to the [dev branch in the repo](https://github.com/gruberjl/job/tree/dev): [implementation](https://github.com/gruberjl/job/blob/dev/lib/job.fp.js) [using](https://github.com/gruberjl/job/blob/dev/index.fp.js) Here is the code I think you'll find useful: const validate = (schema, data1) =&gt; { const data = copy(data1) const validator = ajv.compile(schema) if (!validator(data)) throw new TypeError(`data is not valid: ${JSON.stringify(validator.errors)}`) return data } module.exports = (configuration) =&gt; { const config = validate(jobSchema, configuration) return (...parameters) =&gt; validate(config.response, config.worker(...validate(config.parameters, parameters))) } Here is what I ran into: ## Error handling The first thing I ran into was a bug (caused by me). Using this approach, I had difficulty tracking the problem. I had so much going on in one giant line that the error stack wasn't helpful. The error was caused by a typo in the `copy` function (which performs a deep copy of an object). It had nothing to do with the composite build, but I was unable to track the error because I had one giant line performing the build. ## Readability I found this approach difficult to read. Particularly [the wrapping](https://github.com/gruberjl/job/blob/dev/lib/job.fp.js#L30) `return (...parameters) =&gt; validate(config.response, config.worker(...validate(config.parameters, parameters)))` ## Writing It was fantastic to write. I don't think I've ever done so much in so few characters. I ended up writing it out, then finding I didn't need chunks of code, I could simply keep on wrapping, it was a blast. I ended up doing less wrapping because I had such difficulty reading it and tracking the bug. Here is my super wrapping line: `module.exports = (configuration) =&gt; (...parameters) =&gt; validate(validate(jobSchema, configuration).response, validate(jobSchema, configuration).worker(...validate(validate(jobSchema, configuration).parameters, parameters)))`. It was fun to write :) For readability, I broke it into [this](https://github.com/gruberjl/job/blob/dev/lib/job.fp.js#L27-L31). ## Summary I loved the approach. With caching, it could be fantastic. But: 1. Do you have a style guide for readability? (you mentioned 'functional tools' above) 2. How do you perform things in async with immutability?
I sent you a pull request that fixes the width issue.
/u/disabledlocalization and /u/slmyers are absolutely correct. As far as game development, really only hobby sized games are currently made in javascript in my experience. If you are wanting to work at a big game studio they are most likely using C++. To reinforce though, no need to worry about it when starting out. Javascript will work fine for learning programming and you can learn C++ later if you feel like it.
How is this down voted? Blows my mind.
Good thing templates are optional then.
Probably because it doesn't resonate well with those who hold a different opinion and were hoping to hear otherwise.
Good code should speak for itself. Strong function names give context to what the function does or what the function should do. Using a file name to imply the function name is not awful by any means, but the problem is that it relies on the meta-code rather than the code itself. This has several negative implications: - First, new developers that aren't aware of this naming structure will most likely get tripped up. - Second, it requires more mental energy to read the code. You have to look for the function's name, rather than it just being a natural part of the content. - Third, better errors without having to use a third party library. These are all pretty small points and I'll say it again: it not that big of a deal. It's much more important to be consistent throughout your own code base. But what's the positive for arrow function exports? Several keystrokes? It doesn't seem worth it to me. Some other minor points: - Not naming functions disables mass-search-by-text to locate the function you are looking for. - Non-default exports require names, introducing inconsistencies amongst default arrow functions.
Also, most substantial games that use the JS runtime are actually coded in C++ and then converted to JS via Emscripten, which means that your C++ skills will be more important.
Not sure why you're being so aggressive. The weight of pros/cons is literally what you just told me. Whatever pros Vue had was not worth it for the list of cons you **just** listed. I've worked on projects with contractual obligations that would result in a publicly traded company getting "fined" if they did not meet those obligations. This required most of the engineering department, which was composed of multiple different products to work on it for at least 6 months iirc. The feature I was working on included integrating with 2 other features with 1 of those across products and both with their own set of dependencies. So I don't know what you consider **very** large, but a 3k person or so company with over $500mm revenue seems to not be small. I haven't used Vue. I've only used React.
&gt;Close to 3,500 man-hours worth of development in React would have to be re-invested.(...) &gt;We would have to defer new feature implementations and tell our clients to "please wait for a year-ish(...) &gt; Have you ever worked on a very large scale project with tight deadlines, in team of ~30 devs (front-end and server side developers), racing against a backlog of features which management is pressuring you to deliver as fast as possible? Your figures don't add up. 3,500 man hours across a team of 30 is not 'a year-ish', it's 3 weeks (assuming everybody works a standard 9-5 40-hour week).
"simple" &gt; ModuleNotFoundError: Module not found: Error: Cannot resolve module 'inferno-compat/lib/ReactCSSTransitionGroup' in /home/tbranyen/netflix/some-rad-app/node_modules/react-addons-css-transition-group None of this stuff is simple and simply swapping out entirely different projects with an alias seems ripe for trouble and headaches.
Hmm, we have large scale projects that effortlessly switch out, though we use react-lite. I have personal projects on inferno in production but they're less complex.
Sorry if that sounded aggressive. Let me know which parts and I'll delete it. I probably read too much into your question.
It doesn't work :/
before React I worked on AngularJS applications, among others. 
A lot of games made in JavaScript will use `canvas`, and drawing to it is all JavaScript. You can make your entire game without ever writing a single line of html. codepen.io is both a great place to make your game and get inspiration from other pens
The amount JS can do will only continue to increase so it's really a great time to learn it, in terms of games you have web assembly which could be huge, especially future iterations. In terms of software development you have a whole range of options, you can go backend JS with node, pure front end with vanilla JS or full stack JS, from DB to client you can have a full javascript stack nowadays and it's becoming increasingly common!
&gt; I'm actually amused and wondering if you're asking this question out of genuine curiosity, or as a means to counter my claim because you feel that the switch is always worth it. So my question is: Have you ever worked on a very large scale project with tight deadlines, in team of ~30 devs (front-end and server side developers), racing against a backlog of features which management is pressuring you to deliver as fast as possible? Adds nothing really to the post &gt; Without sounding presumptuous, I think probably not, otherwise you wouldn't be asking this question. I didn't answer in the capacity of a lone developer reading stuff on medium and suffering from the Dunning-Kruger effect. And these sentences don't add anything either.
You can return while calling a function to terminate the parent function early so there's no need for an else block if (result.nextPageToken) { return getVideoIds(uploadId, result.nextPageToken, videoIds).then(resolve, reject); } console.log(videoIds.length); return resolve(videoIds);
React is easy. Just look at the docs, they are good enough. If you understand JavaScript and have been programming for 20yrs, it shouldn't be much of a stretch. You should be good in a few days. It's incredibly straightforward and just has a few gotchas that are minor hurdles. If you need a bit more help, [CodeSchool](https://www.codeschool.com/courses/powering-up-with-react) is amazing as always. Learning data flow and getting your brain to work that way might be a bit tougher. [This Redux series by Dan Abramov](https://egghead.io/lessons/javascript-redux-the-single-immutable-state-tree) is pretty good, but not entirely free. Their docs are pretty good too. Redux itself is pretty easy too, but has some boilerplate, and takes a little brain rewiring. (for me it did, at least)
For learning to develop games? Yes, of course. For actually developing professional games? Not so much, but by that point you won't care what language you happen to be using at the moment. That said, I wholeheartedly recommend that you start with C (see Harvard's CS50), because games are *very* performance-dependent and you need to understand how memory management actually works before using languages that do it for you.
Thanks for the reply! I'm actually not looking for something professional in terms of game development, just something I can fiddle with while learning coding (like coding basic games for practice, if you know what I mean.) In terms of industry, I haven't decided yet, but I want to get a 'feel' for what it takes before I decide. As I said though, I'm a huge noob so I wasn't sure if JS had some huge limitation that I wasn't aware of (only works with HTML/ on webpages, etc.)
If you look at most of the results they are very green. Very few people add 1000 rows to a 10 000 rows table without any form of authentification. I run a realtime, live webRTC app with whiteboard, imports, uploads, documents navigator with 60fps with this riot 2.6.1. Riot 3 got out and is a lot faster on theses specific loops. Should upgrade soon but its not my case and the only reason i'm doing it is for es6 goodness in tags. 
I second the suggestion for C as a first language, or even strict ANSI C. Game programming tends to happen in very formal, strictly typed languages, and JavaScript is loosely typed and very informal. Although it is easy to start in, you might be better served by ingraining the habits C can teach from day 1.
Does Vue have a drag and drop library like React-dnd?
Not to be contrarian in a JavaScript subreddit, but I think Python is probably a better language to learn first. JavaScript in the web browser has major limitations around its ability to write files and run code on a user's machine. This is because the web implements some (very important) security constraints to limit what a bad actor can do to someone browsing the web. Don't get me wrong, I like JavaScript a lot because it's important. It was my first programming language and I picked it up because I needed to do some web development. I like Python because it's more powerful and a hell of a lot more fun to write and I frankly wished I had started there. 
(1) Yes, and in the conjunction or intermediate table the PK can be a compound key of the PKs (4) i think React/Redux are fantastic and offer the best JS framework. There are lots of starter kits out there that will basically architect the project for you. See http://andrewhfarmer.com/starter-project/ for a searchable list. (5) Yes, from what little i know about this subject, JWTs make session management obsolete
IMO making browser games is super easy. Especially for creating the UI, something that is often a big pain with other technology stacks. Loading assets asynchronously be default, having png, jpg, mp3, ogg and video decoders built-in, the lack of boilerplate involved in setting up a canvas, availability of libraries like three.js, pixi.js, howler.js all help to reduce a ton of friction you might have otherwise. Plus it will run literally anywhere and you can package it up as an Electron or Cordova app.
As others have said, developing games is very hard to manage as a new developer in terms of scale and functionality. Still, if you interested: Check out Babylon.js - I believe it is still the leading game engine library for javascript. It's a lot of fun to work with just as a learning tool of complex concepts. Goodluck! 
There's a threshold at which your payload is just too much a cost for mobile development, and starting at 300kb of Javascript is giving up on mobile before you've started. 
This is what I would do, if i just cared if it was true/false and not where the actual error is. * as said elsewhere, check to see if the string starts and ends with '+' '+aaaa+'[0] === '+' true * then split everything on the +, and find things that are not length 1 'a++bcccc+c'.split('+').filter(item =&gt; item.length != 1) [ '', 'bcccc' ] then if the length of that is !0 'a++bcccc+c'.split('+').filter(item =&gt; item.length != 1).length != 0 true or 'a+b+c'.split('+').filter(item =&gt; item.length != 1).length != 0 false 
But angular 2 has a cli as well. Getting started is just ng new $projectname. And starting it up is just ng serve. How is that any harder than the vue cli?
My team released our first OSS project + npm package! Node.js object constructors + example data generator based on Joi schema: http://blog.eng.xogrp.com/post/153784367849/introducing-felicity https://github.com/xogroup/felicity
&gt;You can have a tiny 7KB library, but what's the point if it runs slow or crashes your browser? Have you timed how long it takes 300kb of gzipped Javascript to parse and run on a two year old mobile device? There is one and only one advantage to Angular 2, and it is a real one: it creates a career skill that makes Angular 2 developers usefully interchangeable, able to join existing projects and quickly contribute. These are real features that shouldn't be undervalued. But the 300kb build is done with the prepackaged build step; it's pretty much as good as it can get, and it's pretty much what everyone is going to use. And it's going to be disgustingly slow to download, parse, and execute if you _really_ care about mobile performance. Which, let's face it, almost no one does: we treat our users like crap, our webpages are bloated and inefficient, and sorry, I'm segueing into a rant unrelated to Angular 2. 
Not only that, but the Create React App package makes it simple to get started if you're just learning, essentially cutting out the webpack and babel configuration.
The Stephen Grider course on Udemy is top-notch and really thorough. I'd highly recommend it.
[removed]
If you're interested in TDD tutorials, you can find some nice ones here: https://semaphoreci.com/community/tags/react
JSX doesn't need conditional blocks because JavaScript has conditionals. JSX doesn't need a for each construct since JavaScript has a for each. JSX can easily be statically analyzed. It's just JavaScript. You can get the AST. Or you can just import the object and use the standard JavaScript equals. We are coming at the same problem from completely different view points. You don't see the value of JSX and think two way binding can be sane. We should just agree to disagree. I like you idea hope to see a JSX version of your idea in the future from somebody else
I don't know but author of React-dnd (Dan Abramov, the same person who created Redux) is quite reasonable programmer so when he was doing his library, he kept drag'n'drop logic separate from React (and even from HTML), and it's possible to use just core d'n'd logic, without React : https://github.com/gaearon/dnd-core I didn't use it yet directly, but it seems to be technically possible to wire up this to Vue one way or another (if somebody didn't made it already). 
Vue has some drag and drop stuff. https://github.com/vuejs/awesome-vue
I would actually suggest you start learning Unity and C#. A lot of opportunities in this space right now
Googling "Can I code games with JavaScript" gives about a hundred fucking pages of results so...
egghead.io and pluralsight 
I have no idea why I didn't google that. I googled things like "JavaScript uses" and "JavaScript possible applications"
What do you mean? A promise would simply create an anonymous function in the call chain. All other functions would be visible.
Thank you for your thoughtful reply. &gt; These are all pretty small points and I'll say it again: it not that big of a deal. It's much more important to be consistent throughout your own code base. But what's the positive for arrow function exports? Several keystrokes? It doesn't seem worth it to me. Glad you asked. In theory, arrow functions allow better for safer and more efficient memory handling, since they do not have a context. However, this is a minor point and one that I am following instinctively; I have never fact-checked the implications. The other reason I prefer to use anonymous functions is that it reduces code duplication – needing to declare the function name once in the file name and once in the export expression. &gt; Not naming functions disables mass-search-by-text to locate the function you are looking for. Good point. I have run into this annoyance on several occasions. Its mostly a habit thing though – I have now developed a habit for using the file name search when searching for declaration and using in-file search when searching for use. Very thoughtful. Thank you!
Stop using JWT for sessions! http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/
Dart is a programming language that can compile to JavaScript, and can be used to write Angular programs. Angular.js 2 (and 1) is a framework designed to make writing large web applications easier. Angular can be used in JavaScript, Dart, and TypeScript, as it is a framework, not a language.
By the same token, don't worry too much about what language you learn at first. By the time you're competent, learning languages won't be a limiting factor.
Hey look, actual answers. Also 2:1 this was produced by the US government to crack the tor bundle. Probably outsourced tho as it seems too damn competent.
'return await' is always wrong and it discredits the rest of the article. An 'async' context function will always return a promise. Return await will return the promise resolved to the value of the already resolved promise. It serves no purpose, declaratively or otherwise, just return the promise like usual.
Something something pineapple pen.
Shouldn't take two weeks to learn lol. With 20 years of software experience (including frontend) you will be up and running within an hour or two.
Yeh, i know promises aren't recursive per se but i wanted to use promises in a recursive manner... :)
Are you new to JavaScript or new to programming? Functions are not something isolated to JavaScript. They are a fundamental programming feature and essential in any code (I'm not even sure you can write a working program without them). 
Functions are like little machines that (usually) have inputs and outputs. Imagine you have a bakery and you need to bake some bread. You have inputs: water, flour, yeast, and salt, and an output: a baked loaf of bread. You have the recipe for baking bread, but it gets tedious to make it yourself every time and you have pastries and other things you also need to make. So, you hire a person, who, like a function, can perform a task based on a repeatable set of instructions. Instead of baking the bread yourself, you say, 'Frank, bake me some bread. This time use organic flour and some sea salt.' Frank takes those ingredients (inputs) and later, voila, you have your bread (output). Every line of code you write is an instruction to do something. You write each line, like a recipe, describing what should happen step-by-step. But, like running the bakery, you can't write out everything from scratch each time, and you can't even know ahead of time what you might need to do or how many times you need to do it. You need some way to easily repeat things. You encapsulate repeatable things in recipes and hand those off to employees (or a machine) to execute and give you the finished product. In code, functions are one of the most foundational and most powerful tools you have to achieve that. Imagine you're writing a chess program. You need a way to move a piece to the left. Every time you need to do that, you could take their current position, subtract some number from the column, check if it's off the board, and then move them there. Or, you could write it once: var moveLeft = function(startPosition, spacesToMove) { var row = startPosition[0]; var column = startPosition[1]; var newColumn = column - spacesToMove; if (newColumn &lt; 0) { throw new Error('You can't move a piece off the board!'); } return [row, newColumn]; }; This code is intentionally a bit verbose so it's clear (I hope), and this isn't how you'd write it if you were making a chess program, but it should illustrate a couple things. 1.) You now have a nice, semantic way to move a piece left ('Rook, move left!'). Let's say the coordinates are an array of two numbers, row and column: `[4,4]`. Now, if you want to move left 3 spaces, you invoke your function `moveLeft([4,4], 3);` and it will give you back `[4,1]` 2.) If you made an error in how moveLeft works, *you only have to correct your mistake in one place.* This is an extremely important point, and I'm sorry to bury is down here. If you got confused or maybe changed your mind about how the board is constructed, and now going 'left' means you write `var newColumn = column + spacesToMove;` You only have to refactor that in one place. If you had this re-written all over the place, you'd have to find and change it in all those places. 3.) Related to 2, you don't have to write this again! You just get to use your function whenever you need to. There are other advantages, but I'm quite tired and it's time for bed. I'm sure someone else will fill in some gaps here. Hope this was of some use to you. 
O! I'll give it a go, thanks.
Very useful! thanks for the explanation.
I'd recommend dropping by the Inferno Slack where the users of Inferno can provide URLs to their apps/websites using Inferno. They can also explain the performance benefits they've seen first-hand.
Edited.
I did list the cons in my comment, but strictly from a large project + matured code-base perspective. Also, edited according to what the OP (questioner) pointed out.
My guess is that only used function definitions are included in the build. Usually you include a file with the library and your application assumes said library was included before. 
It seems everything produced by the build is standard library-independant javascript. So a simplified version of their REPL-example, ``` &lt;h1&gt;Hello {{name}}!&lt;/h1&gt; ``` becomes function renderMainFragment ( root, component, target ) { var h1 = document.createElement( 'h1' ); var text = document.createTextNode( "Hello " ); h1.appendChild( text ); var text1 = document.createTextNode( root.name ); h1.appendChild( text1 ); var text2 = document.createTextNode( "!" ); h1.appendChild( text2 ); target.appendChild( h1 ) return { update: function ( changed, root ) { text1.data = root.name; }, teardown: function ( detach ) { if ( detach ) h1.parentNode.removeChild( h1 ); text.parentNode.removeChild( text ); text2.parentNode.removeChild( text2 ); } }; } There is a single ~100-line `SvelteComponent`-function with state- and update-logic also inlined in the build, but this is probably only included once. Presumably what they mean is that there is nothing but this.
Would something like this work? str.match(/\+\w\+/g).length === str.match(/\w/g).length
Cleaned up further: https://gist.github.com/kristovatlas/e03be5f10e48801aec88b0e23f00a3d7
Maybe the implementation is bugged... Not sure it's of any help, but this is a typescript implementation that works : https://github.com/jice-nospam/yendor.ts/blob/master/src/fwk/yendor/noise.ts You can check the result here : http://roguecentral.org/doryen/yendor.ts/bench/index.html (click on noise, then press space to switch to 2D/3D)
well as far as it is now, I have it like this, but all the logic stuff happens inside the route files. If I keep it like this it feels dirty and not really organised. 
For medium-to-large frameworks a key consideration when deciding between otherwise similar options is long term support, both in terms of continue development but also in stability (you don't want to have to change your codebase every month as new releases change the API, nor do you want to deal with someone else's bugs). You don't want to end up maintaining, even partly, the framework itself. For smaller libraries, the decision between importing someone else's and writing your own is *could I maintain it, or write from scratch, if I had to*? If not, then chose something else or go DIY. This essentially comes down to code quality and community support. What something does is not the only thing to think about.
The idea is that instead of including a canonical runtime library, it generates the equivalent "vanilla js" code See also: [previous discussion](https://www.reddit.com/r/javascript/comments/5fcwhz/svelte_the_magical_disappearing_ui_framework/)
What kind of computer are you seeing such long build times on? I've noticed slowness like that on my work computer, but I like to blame it on Symantec Antivirus. At home, my babel/webpack builds are nearly instant (including hot reload). I'm not running a test suite, though, so perhaps that's affecting your builds. As for npm being slow, that's certainly a thing. Particularly if you're behind a corporate proxy. You could consider trying `yarn`, which is an alternative package manager that streamlines the download process quite a bit.
Honestly most of these problems are alien to me. Might just be that I have the "perfect setup," though. The only issue I've run headfirst into is the source maps + DevTools combo being super wtfy in terms of how breakpoints and in-scope variables are. Fortunately, most of the time I'm using React/Redux or Vue/Vuex, so its super obvious what went wrong and why just by looking at the aberrant behavior.
Single quotes are everyone's fav right now, but as ES6/7 get more popular / mainstream, backticks will be the de facto standard for strings with variables inside of them
Intersting reading : http://bytearcher.com/articles/single-or-double-quotes-strings-javascript/
I coped by moving carreer; doing python on backend now; python 3 and Django are pretty glorious way to make money.
I'll stick with single quotes because it's valid in all languages I use and I don't need to rethink using strings.
But REPL is not a real world example. I mean an actual app beyond Todo app. Even if it's small.
Simplest. Yes why not this?
If any single property between the start and end of the object chain is undefined, you will get an error. [Fiddle here](https://jsfiddle.net/n37unfeh/). 
Do you know the (simple) algorithm needed to solve your problem?
Math.pow(2, dayNo - 1) and a big fancy, responsive web UI. On a slightly more serious note, don't count on reddit to do your school assigments.
But pruning is a feature planned for Webpack and already present in Rollup. And any new JS build system is going to have pruning.
Power of two ? [1, 2, 4, 8, 16, 32, 64, ...] ? So in js : `Math.pow(2, DayN-1)`
It's explained on the svelte page.
Look at [react-starter-kit](https://github.com/kriasoft/react-starter-kit) for a good example of a node/express/react application structure.
&gt;all pretty standard No it's not. My company uses none of those. &gt;my daily productivity plummeted. Honestly, I feel like x86 Assembly must have a friendlier set of developer tools. Absolutely it did. I could have told you it would. &gt;Is this...normal? Yep. Absolutely! &gt;How do you cope it? Don't use any of that crap. &gt;How is this clusterfuck touted as a state of the art in Javascript? People don't have a foundation of knowledge and, therefore, rely on other people's tools touted on reddit instead of in-depth knowledge of how to program.
You can bail out of Typescript by compiling your TS files to ES2xxx. It's true there's obviously a lot of ex C# devs using TypeScript, but I don't find that to be much of a problem personally. On the Gitter channel I frequently see recommendations to think in a more JS-like way rather than trying to use TS like C#. The difference I see between them is it seems that Facebook is building a tool for their own internal purposes and sharing it with the community, while MS is building a tool to win over all developers. I would not have chosen TS it if weren't equally well-supported on MacOS, or if it required an MS IDE.
This is actually a fairly standard stack. Doesn't mean everyone is using it obviously. Also, it's more than manageable if you actually take the time to understand how all of your tools work. This goes for everything in tech. I don't agree with your mentality of building such things with grit and elbow grease. Why reinvent the wheel when there is a strong, open source version available to you? If you get it right, it can be a great experience, but that requires a depth of knowledge of the language and tooling that few have the patience to develop. This isn't to say that the tooling is perfect, it definitely has its quirks, but by focusing attention on tools like webpack, we drive the community towards a more standard approach to development. On mobile otherwise I would go on =)
That was definitely a rant, but it was at least coherently written, so I'm going to try to give it a straightforward response. In order: **Dependencies**: Yes, a stack like that does involve a noticeable number of transitive dependencies. There's several reasons for that. One is that the Javascript world, for better or for worse, usually tries to break things into small modules. For example, Babel went from being a single tool that had all the parsing and transformation logic built in, to a plugin-based system that has one plugin for each individual bit of syntax that can be transformed. Another thing to keep in mind is that those tools constitute an entire compiler toolchain. If I was trying to compile, say, a Qt application on a Linux system, half of the headers and libraries would have been preinstalled on the system, as well as GCC. The Qt develop package may or may not be preinstalled, but would also constitute a pretty hefty chunk of dependencies. With Javascript, you're basically pulling down an entire compiler+linker+libraries chain for each project, which is both good and bad. Also, `yarn` can definitely help with project installation times. It has a more organized approach to downloading dependencies, caches downloaded packages on your machine to speed up later reinstalls, and can also be configured with an [offline mirror option](https://yarnpkg.com/blog/2016/11/24/offline-mirror) to save a project's dependencies for committing into the repo. **Build times**: are you referring to the time needed to do a complete production build from scratch, the time needed to start up a Webpack dev server, or the time needed to do an incremental build? There are definitely ways to improve the build time for Webpack. This can include pre-bundling vendor libraries, configuring Babel to only transpile syntax features not yet fully supported by modern browsers, etc. I have a list of [Webpack build optimization articles](https://github.com/markerikson/react-redux-links/blob/master/webpack-advanced-techniques.md#build-optimization) in my [React/Redux links list](https://github.com/markerikson/react-redux-links) that can help with that. **Hot reloading**: I'm curious - what are you comparing the "5 seconds" to? My previous app, which was built in GWT, took multiple minutes to recompile in dev mode, and every change required me to log out, edit and save, log back in, and wait for the recompile. While hot reloading certainly isn't absolutely perfect, the fact that it exists at all is a huge improvement in dev experience. Also, if you look at the browser console, it should be reporting when a recompile was detected, which files were affected by the reload, and whether a full reload is needed or not. I'm also curious how you have hot reloading set up. There's two main approaches: "plain" HMR, which simply uses the `module.hot` API to reload your entire component tree from the root component, and tools like React-Hot-Loader, which try to transform your components during compilation and wrap them with `module.hot` calls to do more targeted reloading. RHL mostly works, but still has a number of edge cases, which is why I'm just using "plain" HMR in my own app. I definitely do have to do full reloads sometimes, but being able to do hot reloading for a major percentage of my edits is absolutely a time saver. **Syntax errors**: I definitely have no idea what you're talking about here, and haven't seen anything like that. Webpack should normally display compilation errors in the console, and it's possible to set up error display in the browser as well. **3rd party libs**: Yeah, got nothing there. Sinon just seems to be kinda screwy. Does seem like there's workarounds, though. **Source maps**: Webpack supports a variety of different configuration options for source maps. I'm still not entirely clear on what all the differences in config options mean in practice, but I've seen a few articles that try to compare behavior and performance (see [1](http://cheng.logdown.com/posts/2016/03/25/679045), [2](https://blog.rthand.com/post/2016/11/29/webpack-s-cheap-module-eval-source-map-requires-a-plugin.aspx), [3](http://survivejs.com/webpack/developing-with-webpack/enabling-sourcemaps/), and [4](https://hashnode.com/post/webpack-devtool-options-when-to-use-what-cimnzd98t006h7o53lt3mb7us) ). I personally am using `devtool : '#cheap-module-inline-source-map'` in my own app and it's working well for me, although a dev I respect recently suggested that for development you should just use `devtool: 'eval'`. I have admittedly seen the "freeze while parsing the main bundle" behavior before. **Expressions**: Hmm. Yeah, Babel certainly transpiles things, but I'm not sure what "inspecting" you're doing that's a problem. If I look at the variables list in the DevTools sidebar, it shows me the original names. **Tests**: What kind of test setup are you using, and why/how are you running them in the browser that way? I admittedly am still kinda weak in the testing department, but I have my project configured to run unit tests offline under Node using Mocha and the `mocha-webpack` tool. **REPL**: I'm not sure why you would want to "get a reference to a particular module". What are you trying to do there? **Redux DevTools**: Okay, here I'm going to have to _completely_ disagree with you. The Redux DevTools are ***amazing***, and I use them on a moment-to-moment basis. I use them to view the current contents of my state, see the contents of actions, see how my state changed, and jump back and forth between the last few states to compare behavior. I'm not sure if you haven't grasped the value yet, or what your specific complaint about them is, but they are ***incredibly*** useful. **"Easy to reason about"**: Okay, yeah, the phrase is probably over-used, but there _is_ a fair amount of truth to it. With React, a problem with the UI _should_ generally be fixable by looking at the data used to render the UI, and tracing the dataflow backwards. Similarly, with Redux, a bad state _should_ be understandable by looking at the sequence of dispatched actions and the reducer logic. Also, because React and Redux force me to be much more explicit about managing my state, I've found myself thinking much more carefully about exactly what data I need to manipulate, why I'm changing it, and how it needs to change. As a result, I've had numerous occasions where I laid out the code for a given feature, and it Just Worked (TM) because I had to actually think through what I was doing rather than just slapping code together, and because React and Redux made the flow of that data predictable. **Final thoughts**: Yeah, there's definitely still a number of pain points with the toolchains, but for me overall it's a huge improvement over previous setups I've worked with. I'm definitely curious what sort of prior apps and setups you've worked with, and what you're comparing this to. As a last item, I'll re-paste the link to my [React/Redux links list](https://github.com/markerikson/react-redux-links), which has links to lots of tutorials and articles on React, Redux, and related topics. That includes articles on things like optimizing Webpack builds, good test setups, and React/Redux app architecture. Maybe something in that list will be helpful for you and your team.
They sold me by putting security up top before anything else.
&gt; Browsers haven't even figured out how to only use cached stuff when the online resource is not newer There are only two hard problems in computer science: Naming things, cache invalidation, and off-by-one errors.
I love that the SPAM picture is there 3 times.
&gt; Why reinvent the wheel when there is a strong, open source version available to you? Who reinvents the wheel every time a new project comes along? Our tools were developed years ago, long before anything on that list came along, and are tried, true and tested; fitting better with our organization than anything else. &gt;requires a depth of knowledge of the language and tooling that few have the patience to develop. That's exactly the problem I pointed out. People lack the foundation of knowledge. &gt;by focusing attention on tools like webpack, we drive the community towards a more standard approach to development. So you need to use webpack to have a more standard approach? No. And this is the common reddit-type fallacy I also mention. 
Try Ember.
Math.max(...numbers)
The fact the token is sent in clear text in the url is a no-go. The fact there is an option to send username and password in clear text is absolutely crazy. Also, to create the token they do a call to their APIs passing the user and the password in the url. No fucking way.
No one needs it. But it certainly improves the user experience on bad connections if the entire UI doesn't disappear for big chunks of time every time you click on something. 
Use javascript to add/remove classes to change the CSS. That way you won't have to modify CSS rules.
Couldn't you load someone's page that uses this library, find their token in the code, and then go to the js console and send a bunch of emails as them?
Web front end technology is reinventing every ui innovation since Xerox PARC. Still waiting for RAD-Web IDEs. :)
Have you ever tried another language? My maven (java/scala) build times can be 10 minutes for a full rebuild after I make a change, and that's just compile time. Then you have to run jetty to actually spin up the application (rest api in this case) which is another minute or two. Not saying it's okay just saying long compile times are not just js or web pack and usually is determined by the size and scope of the application. No language is magically fast at 200k lines of code. Sounds like you moved from a small company to a large one and are now dealing with what it means to work in the same repo as 30 other devs.
My experience is that there is too little overlap between frameworks-of-the-week that there isn't lasting benefit. Bad development habits are more likely the reward you receive from using poor frameworks.
Cause they usually don't settle on worse tools
Offline ?
I come from Python and I worked on large AngularJs projects for a top 500 company and this was pretty much my overall experience. Yes it was slow, painful to debug and my general feeling was that is was like building a sandcastle on moving sands. Normally I would attribute this kind of things to my lack of knowledge about JS, but at the time I worked with a large established team of JS developers. And these were quite competent developers, but the development tool chain always felt klunky or out of date however hard they tried to make it lean and usable. Personally I started to hate the JS ecosystem for its lack of cohesion. It's sad because there's a *lot* of good things to JS, but the second you make a commitment to a stack or a module, it's outdated or surpassed weeks later. I'm also all in for separation of concerns, but I think that the JS community is pushing the atomicity of the dependencies to another level.. with which flirts with insanity. I think the lack of standard library is partly to blame for this. \* Edit: OK, hate JavaScript was maybe a bit too much. I do like JavaScript, it's a wonderful language. But for large projects, not my cup of tea.
jQuery has functions addClass and removeClass. You can create a new class which will apply the styles for overriding what is in your CSS file and apply this class to your elements with addClass. Example: `$('#myDiv').addClass('new-class');` To remove: `$('#myDiv').removeClass('new-class');` 
Thats only partly true. I worked for a company that used angular / Node, now I work using react-redux and ruby. I would have considered myself fairly seasoned with angular and JS, but moving to react (specifically redux, sagas etc) proved to be a HUGE headache. The level of complexity and hardship moving from one framework to another has been such a headache due to the huge amount of dependant technologies. Not only are the libraries getting out of hand, but so are the paradigms... You have OOP, functional, reactive. And on top of THAT you are moving from ES2015 to 2016 to 2017. JS as it is, is a beautiful thing, but can become a mess FAST.
A lot of people use single quotes, but I come from a C++/Java background so I usually do double quotes for strings and single quotes for individual characters, and also backticks for ES6 template strings.
Thanks for your list!
Browser cache already solved that problem years ago. Today you should use an SPA only if you are building a Googledoc-like application on the browser. Imho. 
Yea, coding is very subjective and relative to its current use, timelines, etc.
K.I.S.S: Keep It Stupidly Simple
Not one of the 4 listed disadvantages are actually valid concerns :/ &gt; Disadvantages of Promises &gt; &gt; Can only operate on a single value at a time (Arrays and/or Promise.all helps you work around this, though) &gt; &gt; Execution begins immediately when the Promise is created. &gt; &gt; Possible performance issues. Due to the runtime overhead of monitoring the state of a Promise, they are slower than callbacks (although this might improve as more JS engines start supporting them natively). &gt; &gt; Not available on all JS engines. In older engines, they have to be polyfilled. \#2 is flat out wrong, #3 is premature optimization, #1 &amp; 4 are irrelevant. Using promises or not is more about code style and general ease of maintenance than anything else and _that_ should be the concern when making the decision to use them, not this nonsense.
Some benchmarks and comparisons were shown in EmberConf 2016's [keynote](https://youtu.be/OInJBwS8VDQ?t=48m10s). Uptime Box, a benchmark to stress component creation, shows the following results: * React: 20 FPS * Ember + Glimmer 2: 40 FPS * Glimmer 2: 60+ FPS As you can see Ember is already twice as fast as React, there's even more room for further optimizations. Ember will eventually move to the object model of Glimmer 2. So in the near future, Ember will hit 60+ FPS.
You can't use it on the server side, at least I don't think you can. Elm is still new and you will probably find missing pieces that you will have to work around. But you can use it in combination with other technologies. I don't have a lot of in depth knowledge about it, but I know some projects use both Elm and React. I would think some websites could get away with using only Elm on the frontend if they are willing to just not create features that Elm is not good for. The benefits of doing that might outweigh the costs as it should greatly simplify development and reduce bugs. But this is largely just me speculating about stuff I don't have in depth knowledge about, based on the knowledge and experience that I do have.
Because callbacks are so lovely. LOL.
`#2` is by design with promises. If you have a promise, its either pending, resolved, or rejected. There is no has-not-yet-started state. Though I guess you could argue this as not necessarily being a disadvantage.
I've been trying to enter this space too, coming from .NET. There are some things I like, some things I don't. Part of the problem is that the tooling is still getting sorted out. You bring up webpack. That used to be a simple straight forward tool that would merge all of your JS files into a single one. That's pretty usefull. But then you also had gulp, and bower. Bower being a package manager for client side scripting (bower install angular, which tells npm to grab angular), gulp being your client side task runner. Serve this page, run this task, etc. On top of that, there is all the tooling you have to figure out, and debugging can be a pain. Should you use the chrome debugger, the Node debugger, etc. And it's all changing all the time. It's getting better though. I think. 
6. Harder to learn than its competition!
Application secret management (keys, tokens, credentials that sort of thing) has always been a pain in the ass, so we built an open-source command-line tool called [Torus](https://www.torus.sh). Today we introduced a new feature: Machines. While Torus solved the problem of sharing secrets with team members and across services, it was designed to be used in your local development environment. You sign-in, store secrets (which are encrypted on the client) and then use Torus to run your application. Under the hood is a machine is basically a user - except with tailored to staging and production environments. Would love to know how you're managing application secrets today?
&gt; That's a clear use case then where investing in building your own tool is absolutely worth it since the current solutions would simply not work. Re-inventing the wheel is when you simply attempt to reproduce some current tool/plugin/etc, but are only reintroducing the exact same functioning processes/end result. That is clearly a different definition than most people throw around on here. If you ever propose not using a framework (for anything) the response is always *but but but you're reinventing wheel* regardless of constraints or use case. Honestly, I really think the phrase *reinventing the wheel* is bullshit posturing people throw around when convenient and the goal is simply some baseless qualifier for whining. At that point they can conveniently fit the definition of the term to the context of the whining, which does happen frequently. Usually when I hear *but but but you're reinventing the wheel* I want to reach my hands through the monitor until I strangle the person to death and then skull fuck their kitten simply out of spite. When I hear this during a job interview I will happily nod, but that resume just jumped to the bottom of the pile.
Checked out the tutorial and the very first link they have is to the final product - which is a Codepen that doesn't work: https://s.codepen.io/ericnakagawa/debug/ALxakj 
I'd genuinely like to hear the story about this change. Would you mind to share with us?
way to misunderstand the issues at hand
I'm not going to lie it takes time to understand the whole thing. But once everything it's configured nicely it's fun to work with. The problem comes when a team tries to adopt it while they are learning and there is no expert helping them along the way. They obviously don't set up things properly and end up with a semi-working build like yours. It happened to me in my last job. Now, I'm working on a new project and I took the time to setup things properly and coach my fellow team mates and it has been pleasant experience so far. 
&gt; it'll happily assign to the DOM 150 times per update even if there's only one change in the data each time... Currently. Right now we're focusing on basic functionality and getting the API right. There's plenty of time for optimising performance and shrinking the generated code down further. But right now, even without any of those optimisations, Svelte is already much faster than the vast majority of frameworks (Inferno being the notable exception). Benchmarks coming soon!
I agree that JavaScript is still lacking a lot of advanced programming environments and tools that other programming languages have had long time ago, since the times of Borland C, Visual Basic, Delphi, or even before. But at the same time, the good thing about JavaScript is that is very *organic*. Tools and frameworks come and go. Here, hoping to have your tools chosen for you is no longer an option. Now the job of the developer is also finding and using the appropriate tools and libraries. If all these new webpack/redux/whatever tools doesn't fit you, you are free not to use them, maybe they were written to solve problems that you don't have. That is the beauty of the JS ecosystem. Many libraries are first coded for solving one specific problem and then shared for others to use in case they have the same problem. In the old days, everyone would code their own solution in his own way, and keep it to themselves, but that is no longer needed. And finally, what if these libraries/tools allow you to do things that you couldn't do before?, what if these libraries or tools use concepts that could totally change the way you program for the better in ways that you can't even grasp now?
When it's created it might be in `pending` state but it doesn't mean it already started executing. Depending on the implementation they might be scheduled for the next tick.
I wish I was back in 2008. Is this the way life's meant to be?
Haha. There's tons of solutions that can be implemented for any scenario/environment/etc. Frameworks are simply great for business continuity, large scale projects, etc =&gt; They're hardly necessary for your own personal development/etc. It's all relative and anyone that hammers others for their own development choices relative to their own workspace/projects, probably don't have a solid understanding of these technologies in the first place.
I think one of the problems is that sometimes we just need vanilla js to solve a problem but people add react/redux/webpack that increase the complexity. Even Dan Abramov said that "you might not need redux " https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367 the same with other frameworks and tools
&gt; One of the best features of Javascript was an interactive REPL console in the browser. But that's so 2014! With Webpack/Babel, it's just not possible to get a reference to a particular module from Dev Tools Console. By design. Because best practices, man! For this I use the webpack [expose-loader](https://github.com/webpack/expose-loader). Then you can do `require("expose?foo!path/to/foo")` and then `foo` will be available in the dev tools. You can either just stick this inline when you're trying to debug a problem, or else you can have a dedicated section of the code for doing this: if(__DEV__) { //Use the webpack.DefinePlugin to define this and this will get compiled away require("expose?_!lodash"); require("expose?$!jQuery"); require("expose?ko!knockout"); require("expose?someService!path/to/service"); } 
If he abandoned hapi, he would obviously give control to someone else. As it appears, there are other developers that could do it (as there are lots of PR's coming in).
I lived in those days and it's def getting close to there.
That code doesn't look all that different from what ng2 aot compiler creates ;)
This is one of the reasons I went with DoneJS in our organization. I don't want to have to worry about the Framework. Let someone else handle that for me. Live Reload works well and it's instant. Testing also sorted etc. Huge time saver. But yeah, it's not popular and a lot of people havn't heard about it. 
Depends what you're building, I guess.
I'm sure there's a huge community and ecosystem of prewritten goodies for Elm too! /eyeroll
For now. You're missing out while the world moves more and more towards JS (which is inevitable on the front end anyways). What will you do when Python+Django gets more alienated and your JS skills are more out of date? 
if (x &gt;= 0 &amp;&amp; x &lt;= 4) etc
How do I cope? I remember what it was like writing Javascript [in] 1997. And 2007. And even 2010.
Angular 1 was shit, though
Is there anyway to enter it within the "rules" ?
From a quick google I believe 'range:[0,4]' is what you're after so gpa (or whatever the field is called): { range:[0,4] },
Ya I finally found it. I tried Google and tried RangeLength, but I realized that wouldn't make sense. So I took out the "length" and it worked.
There was a place I worked at where it would sometimes take 10 minutes (minimum of 2) to reload every time you wanted to test a change. That was with ~24gb RAM in the machine. Also, you would have to set up an auto-refresher to keep you logged in because they didn't want to let your login session persist for more than 15 minutes, and if your session timed out, reloading would take _even longer_. Soul=crushed
WTF? Calm down and grow up.
Yeah. I have to agree. This all sounds very whiny to me. I lived in the days of jQuery blob pages, with all the dependencies coming in separate files and the only way to really know what was going on when was crafty print statements or some hokey floating div console. Javascript development pre-node/webpack/grunt/gulp was a nightmarish experience. There is a reason why so much work was put into server side rendering via ASP/MVC/JSP/RoR/Flask applications, javascript was nowhere near able to handle it and anyone that tried to do it ended up with some really unwieldy source files to maintain. The javascript ecosystem is far from perfect, but it is WAY better than it used to be. Now, you almost never have to think "Will this work on IE", it just does.
Scala is unfortunately sort of smart in that regard, between SBT and zinc you can incrementally compile. Intellij also does some hot reloading of classes so in most cases you don't even need to build. I would say my average build time is around 2-3 min. But when some large changes get pushed out, yeah, looking at a coffee run at least. There's also this gem: http://zeroturnaround.com/software/jrebel/ I would assume wepack has the ability to incrementally compile but have not looked into it.
Mind your own business
Sounds like normal growing pains from switching stacks really. It also sounds like something is very, very wrong with your Webpack setup. It shouldn't be nearly as long to build your app and hot-reload should be lightening fast as well. Errors are generally pretty useful, although I will admit debugging has been more of a PITA after we switched (although I'm guessing there is something I am doing incorrectly). 
When you start out learning to program (first 5-10 years) it's easy to fall into the trap of false attribution when it comes to deciding what the cause is for oneself to adopt new/better practices and improve at one's trade. To become a really good programmer, you need to learn a lot of different languages, frameworks, platforms, etc and survive a lot of trends and legacy code and what not. It's hard to see until you're actually there.
Sounds like you have a bad Webpack setup. If you get a better understanding of how Webpack works you'll be able to configure it for near instantaneous hot reloading and proper sourcemaps.
I do. You were the one telling me (I share 100% the opinions of /u/marosubanec) to take up another programming language because I don't use "modern" tools.
I learned all this by sheer brute force of will. Is it hard? Yes. Did I pull my hair out? Yes. Am I better developer for it? Absolutely.
tooling is for sure better. no question. you can find a tool to do almost anything. however, there's a lot of hype. and there's a lot of people out there that will just see a cool sales page for a new shiny node module (yes, i'm calling them what they are, even though there's no purchase involved), and will just start installing everything. the barrier to entry for adopting a new module is so low, it's just one npm install away, it makes it so if you are not practicing due diligence and vetting what you install, and being very picky about what you need, you will very easily end up in bloat land. most of the modules and stuff out there can be very useful. however it depends a lot on what you're doing and you should be picky about what you install. it's like when going to the dollar store. you can just about walk out with two bags full of things you think you might one day use or they might be useful, but likely it'll just end up in your recycle bin or worse, in your storage.
What kind of application needs this kind of stack? I'm writing an electon desktop client app, lots of screens and functions, and the most complex thing I use is angular 1.x.
We have 150k LOC in the front-end. Webpack needs minutes to build that. I read the whole documentation and applied whatever I found. Maybe I missed something. But it is frustrating. 
For the longest time I have been wondering whether the js community at large would reach a tipping point in questioning if investing so much time adding compilation on top of an interpreted scripting language is really worth it. Are we there yet? It seems to me that javascript shouldn't be THE language of the web because it clearly doesn't serve the needs of developers. Even with all that future iterations of ECMA promise, where is it all going? To a future where you still have compilation steps for large scale apps? If compilation is necessary, how strong is the case for a compiled language? Is web assembly an answer? I am not a seasoned web dev by any means, so I just wonder about these things because I don't want to go into the quagmire of learning all these build tools when I can honestly still write reasonable sized apps in javascript with some dependencies and tests. **tl;dr:** Possibly unenlightened dude wonders if compiling an interpreted language into an interpreted language is necessary and how can we stop it?
Are you talking about some specific non-spec implementation of promises? Promise logic does indeed run immediately. var x; var p = new Promise(res =&gt; { x = 10 setTimeout(res, 1000) }) console.log(x) // logs 10, not undefined.
A step forward though, don't you think?
You're going to shoot yourself in the foot a bit with this attitude imo, es6 makes some things so much easier. And debugging in react/redux is easy as fuck.
I think you probably don't have a handle on the tools you're using which is fair because it's a lot of tools to pick up at once. Once your team fully understands the stack you'll probably be happier.
A snarky, antagonistic, and hugely generalized post by someone personally offended by another's opinions and experiences. _Of course_ this is something we'd see in /r/javascript. Some things are better, some things aren't. There's no need to be dramatic about it.
I gigg'd
Heh. No, I've never touched Angular whatsoever. I've glanced at a few of the blog posts on Angular 2 just enough to get a vague feel for some bits of how it works, but that's it. As for Angular vs React, well, I'm pretty biased, and you can probably guess what my answer is :) Ultimately either framework will let you build just about anything. I happen to like the principles and practices that the React community generally agrees on: apply Functional Programming principles (but with pragmatism), UI is an output of state, one-way data flow, and you pick and choose the tools and pieces you need for your own application. That said, I actually did a presentation a couple months ago that gave an overview of the tools, technologies, and concepts involved in modern web development (slides at [The (R)Evolution of Web Development](http://blog.isquaredsoftware.com/2016/10/presentation-modern-web-dev-overview/) ). Afterwards, someone asked me for a comparison between Angular 2 and React. I just dug out my response, which I'll paste here: &gt; I'm very intimately familiar with how React works and its strengths and weaknesses, but haven't specifically researched that much into the Angular world. Per the comments in my slides, in general Angular is more of a "full-stack" framework (at least on the client) in that it comes with prescribed app structure, a router, HTTP handling, etc. Angular 2 itself is written in TypeScript, and while you certainly _can_ write your own Angular 2 app in "plain" JS, I assume the majority of the examples and actual apps will be written in TypeScript. React, on the other hand, is more of a "pick-and-choose" approach, where you would pull in additional pieces (HTTP library, router, state management) and assemble them to fit your needs. This is both a strength and a weakness. The majority of the React community uses ES6, but again you _can_ write your own app in whatever language you want, and there's definitely people using TypeScript with React. I also did a quick search for comparisons between Angular 2 and React, and here's the links I came up with (just stuff that looked like it was decently informative): - https://medium.freecodecamp.com/angular-2-versus-react-there-will-be-blood-66595faafd51 - https://gorillalogic.com/blog/angular-2-vs-react/ - http://blog.debugme.eu/react-vs-angular2/ - http://tutorials.pluralsight.com/front-end-javascript/angular-vs-react-a-side-by-side-comparison - https://daveceddia.com/why-react-why-not-angular2/ - http://react-etc.net/entry/choosing-between-angular-2-and-react-js-midway-through-2016 - http://blog.backand.com/angular-2-vs-react/ - http://merrickchristensen.com/articles/react-vs-angular-2.html - https://medium.com/javascript-scene/angular-2-vs-react-the-ultimate-dance-off-60e7dfbc379c You may also want to read through some of the articles in the [React/Redux Pros, Cons, and Discussion](https://github.com/markerikson/react-redux-links/blob/master/pros-cons-discussion.md) page in my links list. Overall, I can tell you that using React and Redux has made me a _much_ better developer, and that capabilities like Webpack's Hot Module Reloading and Redux's time travel debugging have made my development experience _way_ better than it used to be. Hopefully that helps! **edit** And one more follow-up link - a pretty well-written rant against Angular 2: https://meebleforp.com/blog/36/angular-2-is-terrible . If nothing else, amusing to read.
Without a doubt. Still an opinionated abstraction though, that is not a good solution to 100% of the problems.
I have absolutely no problems with an abstraction being opinionated. And if you find ANY abstractions, in any language, that is good for 100% of problems let me know.
So what are you doing here?
Stop being so dramatic.
Yeah, the Webpack DevServer (which internally uses the webpack-dev-middleware plugin) will watch files on disk and incrementally recompile whatever actually changed. Incremental builds are plenty fast. Pasting from my current dev server console: webpack building... webpack built 4e2fd1a32e44c9c6ffbd in 1950ms Hash: 4e2fd1a32e44c9c6ffbd Time: 1950ms Takes time from there to push the changes up to the listener in the client and reload things, but even though that got a lot slower after I did some codebase rearchitecting, it's still only like 20 seconds. (It _was_ like 4-5 seconds _total_, but my rearchitecting seems to have entangled dependencies a bit more than they used to be because I'm using index.js files to re-export things from folders. Still trying to sort that out.) In any case, a 20-second reload time keeping all of my app state intact is still way better than a several-minute complete app recompile, plus having to log out and back in.
Just commented up-thread on my reload times: https://www.reddit.com/r/javascript/comments/5fphiw/modern_js_developer_workflow_makes_me_sad/damrzqv/ . Definitely saw an increase in hot-reload time after I restructured my codebase, but haven't had time to sit down and fully figure out how to fix that.
The one thing I cannot stand is when I develop large application build of several components. One project I am developing uses 4 webpack configurations, so before I start to write a single line of code, I must open 6 terminals with 2x webpack watch, 2x webpack dev server and 2x nodemon for two application layers. Is there a way to simplify this process? Perhaps there is some tool that allows me to save configuration and make that "bootstrap" process before starting developing quicker by just launching single thing?
Maybe the new ecosystems make life worse for people who treat programming like impulse shopping, but for those of us who actually do enjoy the craftsmanship aspect of it, things have never been better. If you actually take the time to learn what webpack is doing (which really doesn't take long) you get access to a ton of tools that make life easier and allow you to build bigger and more complex things. I think you're wearing rose colored glasses if you somehow think that spending a day debugging obtuse errors from IE6 was better or more productive than tinkering with your dev environment. 
Other person gave their opinion (in a fairly antagonistic, combative way). This person is also giving their opinion (also in a rather antagonistic, combative way), because they disagree with the contents of the first person's post. You're the one who seems offended by someone sharing their opinion, here.
I feel like the overarching tone of the article is frustration over having to "change with the times" That being said I agree with what you said.
I do this frequently for troubleshooting something. For example, if I'm using lodash in my app I might want to play around with a specific method in the library without having set a breakpoint somewhere where that module is available. All I'm doing is setting "window._ = require('lodash');" in a file when I'm in dev mode (say in my main app.js file, for example). That way I can play with those things while doing development but I'm not leaving them around in production.
You haven't written anything sufficiently complex yet.
Most of the tools you're presumably blaming (Babel, Webpack, React Hot Loader, Redux, Redux DevTools) are actually maintained by volunteers in their free time. I’m sure their state could be better if even 5% of the people complaining about them took time to contribute, whether with bug fixes, triaging, writing documentation and blog articles, helping beginners in issues, creating examples, and funding (yes, some of these projects, like [webpack](https://opencollective.com/webpack), actually accept money donations). If you're speaking about React, it doesn't need a single tool, you can just drop a &lt;script&gt; on the page and write ES5 code if that's your preference. That said I appreciate your fine point and will consider sharing less of my work with the community.
Yeah, the op's experience is exactly the opposite of mine. We have a fairly large single page app, and it still kicks the shit out of any of our Java apps as far as compile/start-up times. I have no idea what kind of apps they have for the backend (micro-services maybe ;P) but before our single page app I worked in Grails and Java and I don't miss it one bit.
I said it could. It actually makes sense that it runs immediately. Anyway in a Promise you usually just call a real async action, like a database action and return the promise immediately. The fact that it runs immediately should be irrelevant for the performance of an application. The body of a promise should do minimal work or schedule any extensive operation for the next tick if necessary.
\#1 isn't just irrelevant, it's downright silly. --- \#2 I really don't understand. If you've got a Promise-returning function, then the execution begins when you call the function, just like the execution begins when you call the callback-using function. They're no different in that regard. Maybe in a few cases you can eliminate a single wrapper function by using callbacks. --- And, yeah #3 is generally going to be very premature optimization: given that the entire point of Promises and callbacks are for asynchronous operations, (like an AJAX call), the small overhead of Promises is going to be incredibly negligible, in the vast majority of cases. --- \#4 is relevant in some cases: if you're writing a library that needs to support old browsers, you really should do your best to keep your size down and not just drop in large dependencies, willy-nilly. That being said, there are some pretty tiny Promise libraries that can be dropped in, instead. 
I am not a fanboy, but I prefer them to Promises. Nesting is not a problem if you break out callbacks as named functions, and partial application and factory-like container functions solve the problems with required closure variables.
o/ Love callbacks. Still not sure why wrapping callbacks in promises makes them more readable. If you have anonymous functions, you're still dealing with a pyramid of doom, except that now it's flat. Big whoop. ``` callAPI(parseParams(setData(doThings)))) ``` Is roughly the same as ``` callAPI .then(parseParams) .then(setData) .then(doThings) ``` In my experience promises don't even solve the `this` problem unless you're using fat arrows and/or bound functions. You can do that with callbacks as well. ¯\\\_(ツ)_/¯ 
The problem isn't vanilla JS + frameworks. The problem is a framework + some plugin, which works until another component updates, causing a partially broken project. Comment out the code, use a different plugin, and now you have code rot. Multiply across a few developers and a few years, and your project has become an unmanageable mess. Time to start all over again with a new framework, and lose all of the knowledge of that particular stack you've gained in the past few years. These are issues you don't have in a more mature stack like .net or C++ or Java or even PHP.
I'm working hard on it, I can assure you that :) I'll get this added ASAP
My rule is if it ever gets reassigned use let, otherwise const. Makes it clear that this value gets reassigned later on 
I find myself in a similar category. I loved developing with PHP and or plain HTML / JavaScript cause I just hit reload to see my changes... I can accept that server side stack like Java takes time to compile (I don't like it but I get it) but it kills me that a "pure JS" stack now is suddenly not an instantaneous reload... it seems one of the biggest wins of JavaScript was lost... ditto for debugging where the source in the browser matches my source code 1:1
Antagonistic? Combative? Go outside more
2 years, less than a year in product.
That will land in the next release tomorrow :) thanks for the help!
Also you can checkout HappyPack which does spawns for the parallel loader api for webpack. Useful.
We will still be around with webpack. 800% growth a year from now, and we have no plans on stopping :)
Well I'll speak for webpack and say that I evangelize because communication and representing apparently very trollworthy users like yourself is still vital to the success of a project. So if you got great ideas, throw them on the table so we can make webpack better. Otherwise, if your just looking to vent for the sake venting, continue, and we'll keep trying to make it better anyways &lt;3. In the end bundling is vital to performance.
Hey feel free to reach out on our github, there is some linear size to length for initial builds but let's work together to figure out some better build speed options for ya.
&gt; I think you're wearing rose colored glasses Maybe. Personally I did feel more productive debugging obtuse errors back then than I do tinkering w/ dev environments now. Don't get me wrong, tinkering w/ dev ergonomics *can* be fun, but I feel that all that tinkering detracts from actually doing meaningful work. But to each their own. re: Webpack - it itself isn't bad, and I can make it do what I need just fine. The problem is what I said earlier, of someone in your team going to town with random plugins on top of a random boilerplate when the deadline is in a month, and then nobody has time to continue arguing why that was a bad idea, nor time to fix the source maps, or figure out why HMR is being dog slow or why some other thing is broken in some annoying but not completely showstopper way
We have a new docs page for webpack webpack.js.org try and check out our two guides on HMR! If they don't help you then we are doing it wrong.
React isn't a framework, it's a library :)
Learn the language, learn the concepts, learn the tools. Once you learn about promises, coroutines and async functions, you don't want to go back! Read this: https://medium.com/@rdsubhas/es6-from-callbacks-to-promises-to-generators-87f1c0cd8f2e#.ipy9llu8q
Just goes to prove, if you want an answer, don't ask for it since you'll be ignored. Instead, confidently say that there is no solution, so people go to tremendous lengths to prove you wrong.
I suppose the author means working close to the bleeding edge (as in, using ES 6 features that are not supported in all browsers yet). "Close to the metal" usually means working with low-level tools and abstractions, and tending to interact more directly with the operating system and hardware. (Unlike JavaScript which is a high-level language) 
Your example is inaccurate, callbacks do not compose like that. You wanted something closer to this: callAPI(apiArgs, (apiErr, apiRes) =&gt; { if(apiErr) { return dealWithFailure(apiErr) } parseParams(apiRes, (parseErr, parseRes) =&gt; { if(parseErr) { return dealWithFailure(parseErr) } setData(parseRes, (dataErr, dataRes) =&gt; { if(dataErr) { return dealWithFailure(dataErr) } doThings(dataRes) }) }) }) vs: callAPI(apiArgs) .then(parseParams) .then(setData) .then(doThings, dealWithFailure) These are roughly equivalent, but the callback style is still less composable and requires more specific error handling code if you actually wanted to deal with the errors
10 minutes in any java build is a huge problem somewhere in your module or your using gradle. i was running a mixed scalajs and scala build on sbt incremental and annoyes it was taking 10 secs like 2 years ago. also, being statically analyzed java rebuilds arent needed as frequently.
agree with his assessment. live reload with babel transforms on shitty dual core pcs is less than 2 seconds.
I mean you can use vue.js as a library without the whole build environment, you lose out on some of the modern javascript stuff but you don't have to deal with the node ecosystem. &gt; "how do you build a SPA with Django?" If that was the question, vue.js as a REST client.
Anyone feel that opposite? I'm loving react and webpack. Its a steep learning curve to get started with it, but honestly it gives you incredible development speed and hot reloading is a godsend. My one complaint is that there is no focus right now in the community. I'd love some more concrete direction from industry leaders on which frameworks could be considered 'necessary learning'. But really it doesn't take that long to get up to speed on a new one, but I'd love to be able to spend time mastering it before everyone just moves to another. 
Not to turn this into a "my framework is the best framework" war but ember-cli does everything your list of tools does (add in lodash etc), but in a single swoop. Developing ember is a joy. Come at me bros.
[removed]
Exactly learning react is easier if you have experience in angular js /s
Find a new job. Whoever came up with that stack is a drooling idiot.
I'd go with epoch time if I were you. There shouldn't really be any time that you'd need to store the original timezone.
Squeaky wheel gets the grease! Thanks for this.
Not really. Most of the time you don't need reassignment, and where you do, you know. For instance, if I have a few transforms on a string and I want to add one more, I shouldn't really be reassigning the original value, as it means a different thing. `const` also makes it easy for minifiers to inline your function calls. Example: function makeToken(str) { const str = 'Whatever. Hello, world! blah blah'; const lowercase = str.toLowerCase(); const token = lowercase.replace(/[ ,!.]+/g, '-'); const escaped = escape(token); return escaped; } Can be minified directly into function m(s) { return escape(s.toLowerCase().replace(/[ ,!.]+/g, '-')); } And also shows the exact steps more clearly than something like this: function makeToken(str) { let str = 'Whatever. Hello, world! blah blah'; str = str.toLowerCase(); str = lowercase.replace(/[ ,!.]+/g, '-'); str = escape(token); return str; }
Lol, what? They only differ in semantics -- repeating function takes a collection as an argument mapping a transform on a particular property - repeat(user =&gt; pipe(get(user, 'name'), lowercase)(user), users) 
callbacks are fine, recursive callbacks are too easy for n00bs to use.
JavaScript is an imperative language, HTML/Handlebars a declarative one.
I get the struggle with setting up tools sometimes. But the current versions of the tools you name are now pretty stable. I don't know what versions you use. Honestly, I don't use hot reloading in most projects either. That one can still be buggy. Source maps always work well for me, you know webpack has different options for that? Don't have problems with slow tests, I run them natively in node (so not phantom or real browsers) and they are fast and reliable. Webpack also has some caching options, for instance you can extract your vendor code into a vendor bundle, that one will never rebuild because they don't change mostly during development. So I had some of your struggles a year ago but not anymore! Realize that React DOES solve a problem that is really hard to solve without a library and that is rendering DOM declarative. There's a pretty clever algorith needed to do that performantly. That is something that will make it possible to render client side without al the DOM manipulation hassle.
tl;dr Don’t Quit. It’s Worth It. Doesn't give any tips how to master javascript. Just motivational stuff.
Is your babel being configured to compile all of your node_modules? That's a common mistake that causes build times to increase a lot.
Basically it takes all of the unminifiable member accesses in a scope (preferably top-level iife), hosts the name into a string variable at the top of the scope, and replaces the member references with a bracketed access with the string var. I couldn't find anything else that did anything similar, though my google-fu may be weak. Is this a terrible idea? Here's a short contrived example: ```js (function(){ document.body.appendChild(document.createElement('div')); })(); ``` becomes ```js (function(){ var a='appendChild';var b ='createElement'; document.body[a](document[b]('div')); })(); ``` It does do a sanity check to make sure it will actually save space before hoisting a property, so the example wouldn't be touched unless there were a few more `appendChild` and `createElement` calls peppered in there. It seems like this would be preferable to prop mangling provided by uglify?
[removed]
To continue on this, I usually split new line before the dot `.` return foo .bar .quz() to avoid crazy long rows
Hey thanks for this! similarly someone suggested app.use('/', function(req,res) { res.send('ok') }); So it stops the Cannot GET / which makes me think it's fixed, but how do I log a test message via CURL? Console.log won't work and the res.send string doesn't show up when I call the port via CURL. I really appreciate your help!! 
Also local host is not public. Use 0.0.0.0:3000
Came here to say the same. Been using ASP.NET UI components for a decade. Not blaming anyone for not knowing what came before, but it's erroneous to say the last few years of JavaScript have changed the way we think about componentization. 
I tend to compose instead of binding, has the advantage of being able to pass additional arguments as well. 
I recently started playing with Polymer a bit, and then thing I love the most is _zero build steps_. Seriously. Nothing to compile whatsoever. Granted you need to vulcanize things before deployment, but for dev, just reload the page. :)
I'm curious what type of task runner setups you're using, I imagine gulp? My coworker went ahead and made a concept site to start rapid deployment with, and i just want to clean it up and add at least some task runners to it because he currently has none. Coming from grunt and all its deprecated plugins I'm having a hard time finding working gulp configurations. Also the angular-cli is still in beta. 
OP here I am sorry if my post sounded like bashing Webpack. It's a very interesting piece of technology and you guys are doing a wonderful job. I mean it. The infuriating aspect is the cool kids and fanboys who either * advocate something they have minimal experience with, or * are deeply familiar with its shortcomings, yet never mention them
exactly my story, too. I loved working with RequireJS, ES5 and a simple usage of React. Fast, predictable and robust. If my build broke, it was my fault. With Babel/Redux, I am no longer in control; so I moved to server-side, where I am not at a mercy of immature tools and 3rd party transitive dependencies.
Wow, I didn't even think of that. I'll just introduce a quick check for a grid of 5's
Whoa whoa whoa, fat arrows can bind on a class? I thought that didn't work because at the time of definition there is no instance to bind to. This changes everything.
The thing is...what you recommend is indeed the way we did our job 2 years ago. We did develop UIs that our customers loved, on time and on budget. Since then, UI side of our company has been overrun by hipsters and cool kids more interested in the newest tech blog post than in solving real customers' needs. 2-3 grumpy old experienced developers can't outshout 20 cool kids pitching about "developing in future stack now", on "_npm_ and Github, the biggest and the fastest growing community".
You should take a look about Screen properties : https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation
ahhh, that's right thanks.
I've tried but it affects build performance and also it doesnt really fixes issue because I need some of configurations to be 'watched', and some turned with webpack-dev-server. Also I need two instances of nodemon's. I could make an .sh script that launches everything in background, but I sometimes need to look at console or restart one of these processes. So I am stick with everyday boilerplate involving launching 6 terminals... I was even thinking about writing a tool that parses some configuration file and launches several different command line tools in some UI interface at once, allowing to check console, restart processes and so on. But I dont have time to do it now unfortunately :(
This sounds like a case of "do your own homework". If you have specific questions, ask away, but don't expect us to write your app for you. In the end, you need to learn how to do this yourself.
javascript/typescript developer here. So all this post to say javascript is better nowadays than is was before, which is definitely not the subject of the post you're referring to. javascript won't be an issue anymore when developers who have been using it for 20 years stop being aggressive at struggling newcomers. Yes, there are issues that must be addressed. However nice is nowadays javascript development compared to what it was 10 years ago, it's still not good enough for people coming for more mature and integrated environments like Java or .Net. For example, there's still a huge gap in debugging experience between javascript and Java/.net, whatever toolchain you're using. Don't get me wrong, awesome things are emerging from javascript technologies, but if you go bazooka as soon as someone relates their issues, you're not helping.
except.. &gt; callAPI(parseParams(setData(doThings)))) ..there's only one callback in this, doThings. other than that, you aren't passing functions around, you're just chaining function calls. ofc promises aren't needed for that.
Ember is insanely good for a lot of reasons, but not as trendy as react so way less people are using it, it's pretty depressing
How much is the savings after gzip? This is pretty much what gzip and most compression algorithms do, after all: they hoist common byte sequences to the top, and the rest of the compressed file contains pointers to those sequences. 
It is almost 2017 and the node based tooling is still no where near as easy to use as the old server side asset pipelines such as Sprockets and ASP.NET Bundling.
Closure compiler does not do this because it does not reliably decrease gzip size. 
I really wish what you said would be true. We have had truly skilled JS devs trying to optimize out Webpack setup, only to shave off few seconds on a clean build or ~100ms on incremental builds. Based on open Github issues, [there](https://github.com/webpack/webpack/issues/1574) are [other people](https://github.com/webpack/webpack/issues/1905) with [exactly the same experience](https://github.com/angular-fullstack/generator-angular-fullstack/issues/2342).
This isn't necessarily an ideal way to do it, but I'll give my reasoning in case it helps you get a different perspective. You write a function to validate a set of 9 numbers, immediately returning false if any unexpected number is encountered in the set. This way we don't need to verify sum or check for duplicates. const validateSet = (set) =&gt; { const expected = [1,2,3,4,5,6,7,8,9]; return set.every((value) =&gt; { const matchIndex = expected.indexOf(value); return (matchIndex !== -1) ? delete expected[matchIndex] : false; }); } Since we get rows in the initial data for free, let's just validate them straight away. if (!board.every(validateSet)) return invalidMessage; Already 1/3 of the way there! Now this task is a matter of transforming our initial data in the form of rows into two different 9x9 sets - portraying columns and regions and running the same validation on them as well. To avoid repeating a bunch of code, let's make a helper function to facilitate creating those new sets. const mapToGrid = (func) =&gt; { return new Array(9).fill(null).map((row, rowIndex) =&gt; new Array(9).fill(null).map((col, colIndex) =&gt; func(rowIndex, colIndex) ) ) } So this function will construct a new two-dimensional array and call whatever function we give it with the current row and column index to get the value for each item. Transforming to columns is trivial const columns = mapToGrid((x, y) =&gt; board[y][x]); if(!columns.every(validateSet)) return invalidMessage; Transforming to regions requires some math const regions = mapToGrid((x, y) =&gt; (board [Math.floor(y / 3) + x % 3 * 3] [Math.floor(x / 3) * 3 + y % 3] ) ); if(!regions.every(validateSet)) return invalidMessage; I'm not very good at math so this is probably far from ideal way to calculate the positions, but at least it seems to work. Now we are done. return validMessage;
To be honest, I'd have totally agreed with you a few months ago. I shared your frustration, but honestly, it really just came down to build time. It's difficult to work with a high build time. It's frustrating, slow, and unproductive. If you can, I'd dedicate some time to improving your stack's build time. There's certainly a number of options you can look into to avoid re-compiling all of your dependencies on every new build. My guess is the people who have zero issues run very dependency light, but my experience is a project that has grown dramatically will definitely grind to a halt with babel/webpack over time. Transpiling thousands of files is not instant. This was the plugin I looked into, which essentially solved the issue for me. https://github.com/mzgoddard/hard-source-webpack-plugin If that doesn't work for you for whatever reason, there's the DLLPlugin and the DLLReference plugin to look into, just find something that works for you. It is definitely a solvable problem. This may be a bit overly dramatic, but **everyday you don't solve your build time issue, you can consider as throwing another 2 hours down the drain.** Once you solve the build time issue, I think the other complaints will seem like minor things you can live with.
Yeah, something is seriously wrong with OPs setup. Nothing he wrote even remotely resonates with my experience with build tools.
It's hard to tell what's going on in your code, suffice to say it's way more complicated than it needs to be. If you break the problem into components, you're basically determining that 9 sets of numbers for each of the (rows, columns, squares) all contain each of the digits 1-9. A straight-forward way to approach this would be with a function that determines whether an array contains the numbers 1-9, and functions that return an array of the nth row, cell or square. Then you can compose these functions to determine if the whole sudo is valid. function isValidSudo(sudo) { for(var i=0; i&lt;9; i++) { var validRow = isValid(getRow(i)); var validCol = isValid(getCol(i)); var validSqr = isValid(getSqr(i)); if(!validRow || !validCol || !validSqr) { return false; } } return true; } function isValid(arr) { // returns true if array contains exactly digits 1-9 } function getRow(n) { // returns the n-th row } function getCol(n) { // returns the n-th column } function getSqr(n) { // returns the n-th square }
&gt; whinging newcomers who fill medium and hacker news with articles on how it is all wrong and terrible Again, you're dismissing the issue instead of trying to understand why they're feeling it's all wrong and terrible. I like javascript and I love typescript but I'm not blind to the point I can't understand their point. &gt; how can Java be "more mature" when it's roughly the same age as JS? I'm speaking about the development environment, not the language. eclipse and visual studio are more mature than webstorm + chrome.
&gt; I shared your frustration, but honestly, it really just came down to build time Isn't JavaScript an interpreted, dynamic scripting language? Why does it have build time?
What is the result of all this? Are you building single-page-apps? How much Javascript do you end up sending to the browser? It could be that the best answer to your problems is to throw all this bullshit out and go back to basics. Send HTML and CSS to the browser, and treat Javascript as an optional enhancement.
Oh god, you just made my flashback through my entire career. What a nightmare! Thank god we live in the modern age.
The problem is multi-faceted. * older technology * centrally managed * Backbone.js * partial server side HTML generation intermixed with Handlebars logic for partial client-side rendering * MVC * and the list goes on... None of those, however, explain why its soooooo damn slow (to execute) and so very unreliable. I really blame things like build tasks, layers of abstractions, and multiple rendering/template steps. Its so utterly painful. To really add an additional slap in the face my own personal software does more with far fewer resources and executes more than 10x faster even though this is one of the largest .coms. At some point in the future I feel we are going to need 1tb of ram and quad-SLI GPUs to pull up the homepage. I haven't even mentioned developer speed. Because of the layers of abstractions and the complete lack of control to modify a segment of code without breaking something else (insufficient separation of concerns) a 10 minute UI tasks is actually a 1-2 week effort. It is really taking 2 weeks time to get a new form of pricing data into a single area of a single page. On the other hand, in a 48 hour hackday, I was able to create a tool with an original GUI, node service and curl implementation, and render a variety of results into a new and original service up time dashboard. I really believe the sole purpose of a tech stack is to flatten a bell curve. The stack is designed for first impression popular appeal. The few developers who are horrible under qualified and can't do their jobs can now contribute. On the other hand the few rock stars are now moving through slim cranking out tiny changes in very slow time.
Look up compiling into multiple bundles for your dev config. One for stack dependencies, one for your application. When using the dev server my fairly large applications compile in seconds whenever I save a file.
I continued my study and saw this played out in practice. I'm not sure why "The Good Parts" uses the text I copied, but you are most certainly correct. The desired behavior comes from setting "my" prototype = "my parent's" prototype. I saw this in practice when deriving a custom error from Error(). When I tested to see if my custom error was an instance of Error it kept failing. Only when I set my custom error's prototype = error's prototype did it work. Thank you for your contribution.
I use golang to balance it out.
The problem with using `removeChild()` directly within a loop is that you're modifying the same thing you are iterating over. You might have 20 rows to begin with, but if you remove the fifth one (for example) then the sixth one immediately becomes the new fifth, and you will inadvertently skip it. You will also throw an error when you try to access the 20th, because there are now fewer than 20 elements. There are two immediate options. Perhaps the simplest is to just iterate over the rows *backwards*, so that whenever you remove a row, it will not affect subsequent iterations because the index of the preceding elements won't change. The other option, and probably the more robust one, is to do as you mentioned and to save the elements in an array first, so you don't have to care about their index in the actual DOM changing as you modify them. The code would look something like this: var savedTableRows = []; for (var i = 0; i &lt; docTableRows.length; i++) { savedTableRows.push(docTableRows [i]); } savedTableRows.forEach(function(row){ var typeColumn = row.getElementsByTagName("td")[1]; if (typeColumn) { var contents = typeColumn.innerHTML.toUpperCase().replace(" ","%20"); if (contents.indexOf(typeFilter) &gt; -1) { row.parentNode.removeChild(row); } } }); 
There's not much difference in the gzipped versions. It's usually about 30b difference in either direction from what I've seen.
And I've had C++ code bases that took literally hours. But that really shouldn't be the yardstick here. Compare it to interpreted languages, where setup times are usually quite quick. PHP is basically sold on this principle alone. And 200k lines would've been no issue for Turbo Pascal on my ancient 286. 
Because he hasn't learned how to use the modern tooling.
I was working on a project where I needed a js plugin for weather. Found a really cool one called Simple Weather, but I wasn't using jQuery so didn't want to add unnecessary dependencies. I went ahead and forked it, removed the jQuery dependency, and added the ability to use the Weather Underground API in addition to the Yahoo API. Simple project, but maybe someone will find it useful. **Really Simple Weather** https://a12k.io/reallysimpleweather 
&gt; Webpack sounds really sketchy to me. Well then, that settles it. It "sounds really sketchy". Have you ever _used it_ ? It's amazing how many developers are dishing terrible advice in this thread because they're unable/unwilling to keep up.
It should be noted that Angular [with AOT](https://angular.io/docs/ts/latest/cookbook/aot-compiler.html) does almost the same. It still includes a small runtime, I think, but should be highly performant. Between that and this, the performance difference should be negligible. But then again, if we prefer working on code that should be compiled, I would seriously consider looking [at Elm](http://elm-lang.org/).
I've read your article but I'm still a bit confused. Would you mind explaining a little bit more exactly why one would choose this framework over another? To me, it seems like this framework doesn't have any major benefits over existing, tried-and-tested frameworks. Also it seems a bit contradictory to say this as a problem with frameworks: &gt; At best, frameworks move the complexity around, away from code that you had to write and into code you didn't. And then say this about Svelte: &gt; It's basically as fast as vanilla JS, which makes sense because it is vanilla JS – just vanilla JS that you didn't have to write. I was under the impression that all frameworks are vanilla JS. This is my opinion now but I'd think you're right in saying that most people choose frameworks to help them structure and ultimately reason about their code in an efficient way. If you are larger than a 1-3 person dev team, you're going to need some kind of structure regardless of code complexity; it just makes coding faster, easier, less need for refactoring, and less error prone. You're quoted as saying it's faster than a few but slower than Inferno: &gt; It's faster than React. It's faster than Vue. It's faster than Angular, or Ember, or Ractive, or Preact, or Riot, or Mithril. It's competitive with Inferno, which is probably the fastest UI framework in the world, for now, because Dominic Gannaway is a wizard. (Svelte is slower at removing elements. We're working on it.) I'd think that if one truly needed speed then one would go straight for Inferno. Otherwise, one would choose something that has been on the market for a while that has an ecosystem and has been tried and tested. I don't mean to put any of your work down. I think building new things and looking at problems from different perspectives is definitely the correct direction to move in. My post here is simply bearing curiosity.
It's not the tools I am blaming. It's the bloggers and hipsters, shouting from the roottops, that such a stack should be used is ready for production use.
The big selling point (I think) is that there's no runtime library involved. Everything happens at build time and all generated code has no runtime dependency. 
Nice solution! This is the exact reason why the "Best possible FOR LOOP" starts at the bottom and continues up. It also makes methods like pop() way more useful when filtering an array.
So does this mean (once it's all finalized) that we can no longer be tethered to a specific version of V8? Like, if we wanted, we could download a "modified" version of the JavaScript engine Node uses to support ES6 natively? This would of course prevent us from having to pull in Babel. Am I understanding this correctly?
All JS frameworks are vanilla javascript. All the code you write is ultimately vanilla JS. This is a weird point in the article, because this framework requires a build step, therefore it's no more or less "vanilla" than something like JSX or React.
not just Inferno, also domvm and dio.js are faster even than Inferno.
About the test - you misunderstood my point. It's not them being slow. It's them being too fast. They are already over before Chrome loads sourcemaps, effectively dooming you to debug the transpiled code.
I dont suppose there's an already built mac app?
Yes, a SPA. Bundle size is another thing that makes me sad... Unfortunately, none of that was my decision, I am stuck with the stack described in the OP.
No, that's not it. There isn't really that much to know about React, Redux or ES6/7, unless you go to esoteric usage of generators in _redux-sagas_ and things like that. Previous stack: RequireJS, React, Flux...roughly the same features, none of the problems above. I just can't see how is the "modern" JS an improvement.
I think it's a great idea, but how will debugging work? The HTML files arent 1:1 and there would be a very interesting source map. But if it's expected for the developer to understand the compiled output when debugging, maybe the problem is solved?
Exactly, ember tooling is nothing like what OP described.
Thanks for a load of good advice and explanations. I actually did move to server-side, but still peek at our front-end at times. However, even with all that you have written above, I doubt anyone would adopt such a stack if *his/her* money were at stake. We spend couple of months researching which NoSQL DB to use for our intensive data-processing, weeks of discussions whether to use Oracle Java or OpenJDK or Azul. The front-end stack? One guy's decision.
Try to get your bosses to watch these: https://www.youtube.com/watch?v=4bZvq3nodf4 https://www.youtube.com/watch?v=RWLzUnESylc
Too bad Elm can't run server-side for building universal web apps.
Stop using frameworks...by using my framework.
Good point. I personally never got on the "keep all your dependencies external" hype train. Grab our Java source and all the JARs it depends on comes with it from SVN. Grab the client code and all the JS it depends on comes with it from SVN. You get a complete, known, validated and ready to build package. When something needs to be updated we do it manually. You know what? It's not an especially big hassle and I've never had a build fail due to a dependency update unless I was actually updating it at the time. It's what's known as a repeatable build process and it seems like many people don't understand the importance of that notion nowadays. 
How was that frontend hackathon? Awesome! We almost installed and configured webpack and babel
Looks like sourcemaps are being worked on: https://github.com/sveltejs/svelte/issues/60
Yeah, that's true.
Close to the mental.
On what IRC network?
Until now, my biggest pet peeves have been: 1) The sheer size of an ember app when using "ember new ..." (100MB) 2) Lack of stable plugins with solid documentation - good example would be angular-material vs. ember-paper Nevertheless, with emblem for templating, I definitely enjoyed myself tinkering with this framework so far!
To anyone interested about the details of this, I recommend watching this: https://www.youtube.com/watch?v=ImwrezYhw4w (check out the whole channel while you're at it, it's amazing for those interested in JavaScript).
Isn't it based on [µWS](https://github.com/uWebSockets/uWebSockets)? Can anyone tell how it's compared to SocketCluster?
Amen.
HotMetaL (Pro): https://en.wikipedia.org/wiki/HoTMetaL :)
yes! thank you, awesome that it's a vanilla js file too :) i'm not so good with jQuery
SocketCluster is purely for the realtime server &lt;-&gt; frontend client communication. It's actually quite awesome at that. Deepstream's benefit comes from you building an entire project from the ground up using their data layer, and having collaborative, two-way realtime updates. This was a huge problem for me, because I just needed a realtime push update mechanism for an existing project. For me, I'm currently using SocketCluster because it fits onto the rest of my project easily. If I was starting a new collaborative realtime project, then I would definitely consider Deepstream. But for now I can't have a separate data layer on top of my existing data layer, especially when my data is in sql, and their layer is inherently no-sql.
This can be very easy. We run our unit test in node which allows us to drop into the debugger by adding `debugger` and running mocha with the `debug` flag. I've got this set up so that I have one hot-key to run the spec and another hotkey to run the spec in debug mode.
&gt; Yea cause the new tools are so much better /s After having spent considerable, professional time in both the "old" and "new" worlds of tooling, my personal opinion is that, yes, the new tools are much better. I would wager a significant amount you haven't spent any considerable time with the new tooling working to completion on a project. Apologies if I'm wrong.
Nice. A deployable container would be cool too.
To what end? Why not just let the downvote button do it's job? Seems like the last thing mods should be getting involved in is censorship over silly things like "incorrectly" posting XKCD comics.
OK, I guess I could have used "the frontline", where the action is, i.e. the users
It's actually more of a code generator than a framework
You can force consistency of code in multiple different ways outside of a framework.
going for that. Thanks!
Surely merge requests should be your means of enforcing project standards?
You might need to search for a quoted string. Try: var stringToSearchFor = '"Burncoat High"' (there's now single quotes (`'`) around the double quotes (`"`))
Socket.io keeps working as normal, with fallbacks and all, you just replace the websocket engine for µWS instead of engine.io which is socket.io's default one.
Thank you, but it did not work. I'll keep playing around with it. Thanks again
&gt; http://codepen.io/jefvk/pen/qqpbOP I'm not say you can't do it. Just that generally there needs to be a very, very good reason to do so. But I guess it is mixed in terms of using it or not: https://www.sitepoint.com/scrolljacking-accessibility/ I happen to be in the camp of "do not override default browser UX/behavior".
Well, there's been a lot of good discussion around why "just let downvotes do their job" often leads to substandard content and communities -- usually central to the discussion, is the impact that low-effort content has had on default subreddits. In short, the argument is, that low-effort content that is easy to consume (such as image macros, memes, etc) often beats out quality content just because people see it, get a chuckle, and upvote it. Meanwhile, someone spends 15mins writing a quality reply, and more people than not skip over it for lack of a "tldr". The end effect is that memes end up drowning out original thought and content, while typically not adding anything to the discussion. There is plenty more about this subject in subs like /r/TheoryOfReddit and such. Memes have long been banned here, but XKCD isn't considered a meme by automod. I have no objection to XKCD references here (I love XKCD, personally), but at least for this particular comic (#927), it's thrown around as a meme in the sense that it's usually invoked simply to get a quick chuckle and/or upvotes. With all that said (sorry, just downed my afternoon coffee), I probably over-reacted initially. This isn't really that big of a problem....at least not yet :) So for now, I'm going to leave well enough alone. Thanks for the feedback though, I appreciate it.
I replied [here](https://www.reddit.com/r/javascript/comments/5fwgzg/frameworks_without_the_framework_why_didnt_we/dao2caz/); thanks for the input!
This article is terrible
Dahuhwhatnow? var text = "Hello and how are you?", text1 = "I want a Burncoat High today.", text2 = "I just want a Burncoat." function searchText (textToSearch, text) { return textToSearch.search(text) &gt; -1 } console.log(searchText(text, "Burncoat High")); //false console.log(searchText(text1, "Burncoat High")); //true console.log(searchText(text2, "Burncoat High")); //false console.log(searchText(text, "Burncoat")); //false console.log(searchText(text1, "Burncoat")); //true console.log(searchText(text2, "Burncoat")); //true *and you can save `"Burncoat High"` and `"Burncoat"` to variables and pass them to the function calls... you'll get the same results.
Thank you very much
you can use a utillity called `forever` to run it, just do: ``` $ npm install forever -g ``` Then cd to your project folder and run: ``` $ forever start app.js ``` Then you can get the process id with ``` forever list ``` and use it to restart and stop the service... Read more here: https://github.com/foreverjs/forever I you like choice, `pm2` is a awesome alternative: http://pm2.keymetrics.io/ Also, do not, under any circumstance run nodejs under the root user. the internet is flooded with reasons why you should not run nodejs under root so i will not repeat them here. Feel free to ask if you have any further questions
Normally you use a selector to inject the state into your component, and refer directly to the state. That way when the state changes, the `connect` function from redux react will trigger a rerender of your component without you having to worry. It took me a while to get that concept as I couldn't see how to subscribe to changes, but now that I know this is how it works I'm not actually sure why you'd ever need this library, I actually think it'd might be kind of an anti pattern...
The problem with npm is that shrinkwrap is not the default thing
Very welcome!
I believe that the [micro-performance issues with directly using `arguments`](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments) are 1. passing it into another function 2. returning it from a function 3. reassigning any of its elements (same reason as reassigning a named argument) but not so much accessing its elements, as in the example of ["fn-args.js"](https://gist.github.com/maierfelix/57f76bd2166f32a45bab4acd504f21a8#file-fn_args-js), which shows `arguments[0]` and `arguments[1]` being accessed, and multiplied together, but never reassigned: https://medium.com/@xilefmai/efficient-javascript-14a11651d563#4d3d Maybe the issue is that in some engines, the `arguments` object isn't even created, so long as it is never referred to.
FWIW, there's a number of similar libs out there as well, with varying subscription approaches and tradeoffs. I have them listed in the [Store#Store Change Subscriptions](https://github.com/markerikson/redux-ecosystem-links/blob/master/store.md#store-change-subscriptions) section of my [Redux addons catalog](https://github.com/markerikson/redux-ecosystem-links).
This is the most confusing thing I've ever read on reddit. You posted a tangential meme and were downvoted. Mod explained that he thought your post was inappropriate, but didn't use his power to remove it. And you reply with a sincere apology acknowledging that you made an error and promising to do better next time. I... I'm so confused and scared right now. Somebody please hold me.
Yes—just like that. Except it happens by default on every application. And it includes dev dependencies by default. And it is _meant_ for applications which consume libraries, not primarily for libraries to ensure safety in production. The fact that yarn does this means that in a few months most active libraries and applications will have lock files without much effort, and that's a good thing. 
Well, did you look into preact? 3kb gzipped. Using it right now, and it's transparent, fast, react-api-compatible. Don't think svelte will be more understandable and comfortable to use than that. edit: also inferno is too, small
It also don't work that well. Yarn took a hard look at shrinkwrap and made something that actually locked down all transitive deps.
1. Remove the space in your onchange between 'triggerBacon' and the parenteses. 2. Your Ids that you're trying to get don't match the Ids on the select dropdowns. 3. Extra { on line 42.
Hi /u/austin_emmons1124, this post was removed because /r/javascript is not a job board.
Agreed, if I want to speed something up, I'm looking at: 1. quantity and efficiency of IO (i.e. networking, db queries, etc.) 2. data structures and algorithms, caching of re-used values 3. memory allocation, especially within inner loops The author must be working on very different code than I am, Given a program written without consideration to performance, I'd expect to get 10-1000x improvement by profiling and going thru the list above. I'd expect low single digit %age improvement from doing the stuff on this list.
No, not closures, how does it compare to simple functions that have no side effects or state, just input and output?
&gt; Well, except one thing, which is vendor namespaces for each package. Definitely agree - I feel like this is one of the main issues with npm.
Something else: const add = (x, y) =&gt; x + y; const sum = add(2, 2); That is to say, pure, no-side effect functions that operate on pure data.
Yeah wtf. I'm not a JS dev* and I was getting confused as to why you'd want to commit a lock file. Turns out it's not actually a lock file.
Yeah, that's what I did. // setup function makeAverageCounter() { return { sum: 0, numbersCount: 0 }; } function averageCounter_add(averageCounter, number) { averageCounter.sum += number; averageCounter.numbersCount += 1; } function averageCounter_get(averageCounter) { return averageCounter.sum / averageCounter.numbersCount; } // free functions test var counter = makeAverageCounter(); for (var i = 0; i &lt;= testCount; ++i) { averageCounter_add(counter, i); } if (averageCounter_get(counter) !== expectedAverage) throw new Error('Math is wrong'); EDIT: Though these are simple functions, they do have side-effects on their first argument. I guess I'll make another test. ;-) EDIT: Now includes pure simple functions. It brought performance back down again. https://jsperf.com/new-object-or-function-call-5 /u/dwighthouse
"lockfile" is the same term used by other dependency management systems such as Composer (https://getcomposer.org/doc/01-basic-usage.md#composer-lock-the-lock-file)
npm packages can be scoped for free, it's just not widely used. But it looks like it's changing, they're using scopes for Angular 2 for example
Yes. LIKE that, except not completely broken. Which `npm shrinkwrap` is, in many ways. (For example: Create a shrinkwrap on a Macbook for any project using Babel, among many other libraries. Then try to build the project on a linux CI server. Result: Totally broken with no workarounds or options you can set to fix it. There's some other related issues but that's the obvious one you're most likely to run across. Core issue is that shrinkwrap just doesn't work with optional dependencies.)
You're a superhero. Thanks so much for sharing this. I completely understand it now. :)
I had issues with it :(
Your type() function is not returning anything (and neither is alert()). This is what your code is doing: alert(alert(jQuery.type(obj))); Change your type function to return instead of alert: return jQuery.type(obj);
Well, I'm not going to say PHP devs are bad at naming things (the same community that brings us names like parse_str for a global function that parses URL query strings or the inscrutably named gzgetss), but we don't need to repeat their mistakes. 
like Gemfile.lock, composer.lock and Cargo.lock? The JS package managers have lived in the dark ages. Long live yarn!
Interesting, been worried about scaling socket.io. Had trouble with getting it to run on multiple cores. Seems uWS has it built-in. Is this preferred to socket.io now?
True. But I wonder how many lines of code a similarly trivial loop would be in the comparable frameworks
It's locking your dependencies. 
Thanks for that. `html` still has the same problem. `changeMe` is an object, but I still get the same property error. `TypeError: Cannot read property 'lastChild' of null(…)`
It's not locking them in the sense that it [normally means in computer science](https://en.wikipedia.org/wiki/Lock_\(computer_science\)) though. Unlike the [older meaning](https://en.wikipedia.org/wiki/File_locking#Lock_files) where it makes more sense. People can use whatever names they want I guess, but they're polluting Google results and creating conflicts with other uses when they use the name of an existing concept for a completely different purpose. Especially in a case like this where you definitely don't want to commit lock files that are actually used for resource locking. 
We did use Services in this project, but only to the extend which that tutorial covered. The person who wrote the Service initially I think did not fully understand how the code needs to be split between Component and Service, so the service became a thin API wrapper. In fact, when I came on board the project I thought for a very long time that Services were suppose to be stateless. That I think is a problem with many parts of the Angular 2 documentation - their examples are *really* trivial, and their only example of data flow between components is done using property binding. 
Have a look at my library, onfontready. It supports all the way back to IE6, and it's well under 500 bytes when gzipped. https://github.com/dwighthouse/onfontready
This definitely isn't helpful to the OP, but I was curious as to what the shortest way to do this is, if you're an asshole. I came up with this: const myAssociativeArray = myArray.reduce((a,v)=&gt;delete(a[v.id]=v).id&amp;&amp;a,{}); 
Seems ironic that our build server is down right now because of Yarn breaking after one if it's own dependencies changed https://github.com/yarnpkg/yarn/issues/2072 Can't lock down global npm installed versions of yarn, either.
I had to stop using Yarn because of an issue where having `@types/...` packages in my package.json and doing a `yarn install/upgrade/add/etc.` would cause it to nuke my `node_modules/.bin` and `node_modules/@types` folders and produce an error. I'd have to do an extra `yarn install` to get them back.
I noticed this is your first time posting here, and your account is new. If this is your first experience on reddit, I'm sorry for calling you out, and I hope you stick around. If not (and this isn't your first account), well, you should know better, but stick around anyway :) Either way, no harm done. 
yeah, the URL responds with valid json
That is not something that I have any desire to do. Whether something is a meme or not is fairly objective (though not fully, obviously), whereas deciding whether a comment is contributing or not is a lot more subjective. I only considered taking action here because this particular XKCD has probably been posted more than any other in this sub, often out-of-context (e.g. inaccurately).
Nice, signed or unsigned? Also do you know any other tricks? Such as turning a signed to unsigned?
For installing Yarn itself, it's recommended to install it through one of the main installation methods available (Debian/Ubuntu package, Windows installer, Homebrew, or the installation script). Installing via npm is not recommended except in environments where there is no other choice. Additionally, in a CI environment, it's recommended to explicitly install a particular version of Yarn. This is documented at https://yarnpkg.com/en/docs/install-ci#circle-tab
NetworkError: failed to execute 'send' on XMLHTTPRequest failed to load on gfish2... .json
Haha, you know what I had to stop myself from using ES6 because I'm so used to using it. I really like your code golf'd solution.
It's easier to understand Svelte. The reason for performance is IIFE. https://github.com/krausest/js-framework-benchmark Run test: Create 1,000 rows took 260 ms on Preact vs 60 ms on Svelte Create 10,000 rows took 8000+ ms (8 secs) on Preact vs 650 ms on Svelte 18KB on Preact after minified vs 9.7KB on Svelte after minified While it's not a real world test, the amount of waiting time to render is unacceptable on Preact. Svelte is slightly faster than Vanillajs and Vanillajs-keyed. If I need further tweak, I could modified code in Svelte than other framework easily. It still being working to make workflow more organize and even less code duplication.
Two reasons why you might still see it. 1) The variable "domReference" still exists. You'll need to do `domReference = null` to remove that extra reference. 2) Garbage collection doesn't always happen instantly. In the Chrome console, you can go to the Timeline tab and click the garbage can (Collect garbage).
As I understand it, publicly-accessible packages in a single-user scope are free. Non-publicly-accessible packages in a single-user scope require a paid plan. This is similar to GitHub with open-source repositories. Unlike GitHub on which you can create an "organization" for free as long as its repos are open-source, there is no free plan for organizations on npm. (Minimum $14/month).
I think that's too broad a definition of what a mutex is for. It doesn't necessarily enforce determinacy in itself. Given a program which has two threads that both try to do a thing with the same resource it only prevents them from doing it at the same time, but not what order they do it in, you can still get indeterminate behaviour. 
https://jsfiddle.net/y6g1rb9o/1/ see if this helps ya
My attempt -- A little longer, but maybe a little more declarative :) const myAssociativeArray = myArray.reduce((a, {title,text,id})=&gt;(a[id]={title,text})&amp;&amp;a,{});
Not widely used though, and not the default way of doing things. With Composer/Packagist, **every** package is namespaced, there's no global namespace like with npm. 
I agree, but this is fairly new, so maybe we will see more and more packages transition to it.
Someone spotted the rotation function keeps rotating a previously rotated image... the canvas got HUUUUUGE! I've re-written it OO, and used a "production line" of 5 back buffers to prevent the canvases getting resized, or cleared (just redrawn over with a new image on the same stage of the processing - so there's no old frames peaking out)... the performance is much better, I don't think there's any memory leaks, and it's much more useable. Thanks for taking a look! If there's any other issues you spot let me know - I want to sharpen my JS.
I found two issues: One was an inputted rotated canvas getting rotated again and increasing in size each frame a "logical" "memory leak"! I think the other was constant resizing of canvases, and creation and destruction of them. I made 5 canvas buffers for a "production line" of image processing, and because they now stay the same size, and are consistent in memory, I found the performance much better, and no more crashes.
Typescript 2 is pretty great but my issues with angular 2 stem much more from it trying to replace standards. Like why is there a module system in there? That's what es6 should be doing. Also I'm a firm believer that typescript or flowtype will one day become a web standard. 
Haha bc it would be 2 easy for the question
So make a better question :)
I found the lack of good documentation the most debilitating. Also TypeScript, what the hell is that?! If you want to force TypeScript on me, at least tell me how it works. Don't just say "use typescript" and not provide helpful tips. The dropdown to change the language to JavaScript just ends up telling you that there is insufficient JavaScript documentation, and they will show you TypeScript instead.
You're absolutely right, for some reason I thought we were in r/react so I kept my answer brief. Great explanation!
TypeScript is pretty well documented, I don't see why the Angular team would have to do that all over again?
Great article, I'm expecting to see more of these as time goes on. Angular is just the complete opposite of where we should be going with software... modelling real-world scenarios accurately and robustly is complex enough without our languages &amp; frameworks adding extra needless shit into the mix. That HTML snippet gave me a migraine.
Yes. Your concern may have been valid a whole bunch of years ago when Bundler was written, but it is definitely established terminology at this point.
The target market for Angular was big enterprise teams/applications, developers used to big frameworks with deep class hierarchies, concepts like factories/services, lots of patterns, dependency injection etc etc. Its a very very different beast from any other JS framework. The promise was you would build apps with the same design principles/practices and teams as a big Java/ASP.NET app. Unfortunately the implementation was not that well engineered and people ran into issues, esp performance. The state of the web had also changed a lot. So the team decided to rewrite most of it, which is why backcompat had to go. With Angular2, the design goals and target remains the same, and you still have a lot of new concepts to learn. The advantage is once your team is up to speed it can be very productive. Typescript, RxJS, or the option with AngularDart are all great design choices. Not liking Observables isn't a valid criticism. The fact that you need to learn things like factories/DI is. Angular is meant for big teams, its definitely not as flexible as competing frameworks. Also the long term commitment is a valid concern.
I call that 'commitment to framework' and I highly encourage it. Our tech stack is mostly React, but similar principal, if it touches the DOM, use your dedicated view library. When I said 'reinvent the wheel' I meant building out an entire tooling ecosystem like WebPack or Gulp.
You seem pretty aggressive, not sure i would *want* to work for you...
I mean keeping your dep versions in your package.json static. Updating deps should be an intentional, human-guided process. There's no need for shrinkwrap or any of that shit...
Very much, this.
`getElementById` works only for dom element which have an id. You should consider using `querySelector` it take CSS selector as input, so you can be more efficient. (than juggle with `getElementById`, `getElementsByTagName`, `getElementsByClassName`, etc..). So, look at this http://jsbin.com/metamidawo/edit?html,js,output
Yes, but the difficulty shouldn't be coming from our tools - it should be that we're evolving to tackle more difficult problems. Otherwise, all we are as programmers are people who are good at learning frameworks rather that people who are good at solving real-world problems with technology
Its better written than 99% of stuff I've worked with tbh, though I freelance and work with bad developers. I'm pretty sure the crash from creating elements over and over was a bug with chrome and not really your fault, though it's still not the optimal way to do things.
i never try coffeescript so i dont know what the meaning of coffeescript maintainability nightmare, but if think about code maintainability, that is my biggest reason on moved to elm.
Two frameworks/solutions I absolutely hate with a passion are Angular and Polymer. They solve nothing that others don't solve better. I'm currently in love with React for its incredibly vanilla JS approach to things, and JSX removing the restricting Hell of Handlebars. It's so bloody simple and efficient. I'd use Vue, but that's another shitload of boilerplate crap you need (caveat: "but you can also do it like React does it!" - I know) to learn: ### Look at this shit: &lt;textarea :value="input" @input="update"&gt;&lt;/textarea&gt; &lt;div v-html="compiledMarkdown"&gt;&lt;/div&gt; ### Or in React: &lt;textarea value={myValueVariable} /&gt; No weird `v-html` and `@input` and `:value` attributes to figure out. Just a value property that contains a variable. That's it. React does the rest. Angular 1 and 2 are just... things that Java back-end devs seem to enjoy for some reason. The big problem is that javascript has an elegant way about it, it being simple, mostly. And frameworks like Angular remove all the simplicities and make things unnecessarily complicated again. End result: nothing new solved; Backbone could do that what, 10 years ago already. Hell I think most websites developed in Angular could do with jQuery UI + Boostrap and be way more easy to maintain. I jest. But I'd be pretty sure I could ng-make ng-a ng-point ng-for ng-it ng-in ng-most ng-projects. &lt;/rant&gt;
It's in the ES2015 specification, a shorthand for declaring object properties. It's the equivalent of writing var aObj = {a: a}
Because it's redundant to write `{ calculatedValue: calculatedValue }` repeatedly and continuously.
The main perf difference is because your closure implementation is re-creating every method on every instance. Do it faster like this: function Averager() { return { sum: 0, parts: 0, add: averagerAdd, get: averagerGet, }; } function averagerAdd(number) { this.sum += number; this.parts += 1; } function averagerGet() { return this.sum / this.parts; } That'll also cause `instance.add` and `instance.get` - not invoking them, just looking up the value of the property - to be very slightly faster, because the property lookup algorithm will find the result on `instance` and not proceed to `instance.__proto__`. That said, I'm not sure this style is ever the best approach. If the perf penalty of using `class` or similar is noticeable, then you probably shouldn't be using an object oriented style at all, but just functions or even lower level.
An article like that should substantiate more both *why* those things might make code more efficient and give proper benchmarked examples. &gt; avoid working with negative numbers I'm calling bull on that, and doubting that the rest of it is correct, without seeing benchmarks. &gt; avoid working with [...] doubles with many decimal places. Yes, but still not quite. If you use any decimal places the compile will end up using a floating point type instead of an integer. How many decimal places doesn't matter. It used to be that JS used doubles for *everything* (I assume modern browser/other engines try to be a bit more intelligent about the matter?) so you couldn't rely on integer values larger than 52-bit (because IEEE 754 doubles use a 52-bit fraction and 11-bit exponent).
&gt; Observables offers little tangible improvements over Promises when used for Ajax requests I thought that one improvement was cancellability. That's the exact example used in [this video from Netflix UI Engineering](https://www.youtube.com/watch?v=FAZJsxcykPs).
What's the point? External code can still access `[_sum]` and `[_count]`, it's just a little bit more difficult. If we're forced to settle for only conveying that properties should be private, rather than actually making them private, then simple underscore prefixes are a better choice: less syntax noise, fewer lines of code, and faster.
OK. But write for example function a(myString) { // do stuff let obj = { myString }; // do stuff with obj, e.g. pass it to other methods } then change the name of the parameter and you'll have a nice time to find consequential errors (also when you change both occurences of `myString`).
I agree with almost all the points that the author made. We also started with angular2 here and now switched to React. The biggest reason is what the article actually says: the developer experience sucks for angular2. It is horrible. It is slow, verbose and bloated.
It would be nice if we could also acknowledge that SPAs in general are a tragic mistake that we keep making over and over again. This particular framework is bad, but the entire premise of this and every other framework is bad too. The biggest web-browsing platform is now mobile, and it has been since 2014. SPAs are completely inappropriate for the mobile web because the median mobile device that is in use today has utterly terrible processing power and mobile networks are slow and only getting slower as time goes on. Yet despite these very real limitations, we seem to think its approprirate to send 3mb of bundled Javascript, and then expect the client's CPU to process it all. Just... just send HTML and CSS to the client, and then treat Javascript as an enhancement.
Just wait until you want to write tests, it is even worse.
I dislike Angular 2 (and hate Angular 1 - it is the number one reason why my 2-year project ended up being in the garbage bin), but I disagree with the author. 1. In my opinion, Angular choosing Rx is one of the few good decisions they've made. Not only are promises just a poor man's observables, but they also don't translate well into other languages. It seems that the author hasn't worked with any ecosystems other than the one that surrounds JS. 2. TypeScript. A lot of problems with TypeScript stem from its interoperability and compatibility with JavaScript. Also, Angular forcing TypeScript on everyone is a *very* good thing. There's absolutely zero reason to write pure JavaScript in this day and age, and Flow doesn't seem to be picking up steam.
/u/scottomaton with the assist: mongoose.connect('mongodb://admin:admin123@127.0.0.1:27017/food?authSource=admin');
React has the same. It even goes further because to my knowledge Vues components aren't self contained and depend on loaders. Csjs gets compiled by Babel, you apply any postCSS transform you like, or several. That means the components you ship are **scoped**, prefixed, sass/less/cssnext applied, etc. Otherwise it has the same editor support as Vues SFC (syntax, completion). This is how it looks: import React from 'react'; import csjs from 'react-csjs'; @csjs` .section { display: flex; &amp;:nth-of-type(even) { text-align: right; } &amp;:nth-of-type(odd) { text-align: left; } &amp; h3:hover { color: blue; } } @media (max-device-width: 1224px) { .section { padding: 0 5%; &amp; h3 { font-size: 2em; } } }` export default class Section extends React.Component { render() { let { classes, children, title } = this.props; return ( &lt;section className={classes.section}&gt; &lt;h3&gt;{title}&lt;/h3&gt; {children} &lt;/section&gt; ) } } And this is what you do to use it, no loaders, no postprocessing, classes are scoped. It comes ready-made: npm install componentscollection --save import { Section } from 'componentscollection'; &lt;Section title="hello"&gt; &lt;span&gt;world&lt;/span&gt; &lt;/Section&gt;
*some people. Which is pretty much this whole thread in a nutshell. /r/JavaScript is pretty anti-Angular, and that's fine, even if it is ultimately moot as many companies should be considering their technology on a case by case basis. Given my limited experience in Enterprise work as much as it sucks to have to inherit an old code base with terrible design etc, it's saved by being made on a framework that is well documented and understood (at this time). This saves me a significant amount of time when attempting to solve problems or to fix previous poor implementations, and the same is starting to happen for Angular 1 apps. In short, people complain, but it's different strokes for different companies.
I once tried snowboarding for a day. It was terrible: - I spent more time on my arse than standing up. - Said arse ended up badly bruised. - Every time I fell over, snow went up my sleeves and inside my collar. Suffice it to say, snowboarding is a horrible idea for a pastime, and I'll never be subjecting myself to that again! --- The problem with this article is that the author has only worked with the Angular 2 ecosystem for a couple of weeks. This is simply not enough time to learn how to use it well. This is demonstrated by a number of points which he makes which betray a lack of understanding of the choices made by the Angular authors, such as rxjs, TypeScript and dependency injection. He is of course entitled to this impression of Angular, just as I am to my impression of snowboarding. My issue is that many people will read this and then they will make a decision or form an opinion about the technology. I remember some months ago an anti-TypeScript rant article was posted here. It was similar in that the author had only spent a couple of weeks with the language at the time of writing; and it also contained many misconceptions and frustrations caused by a lack of understanding. That author is now a full-on TypeScript fan now, after he subsequently gave enough time to appreciate the trade-offs involved. --- For what it's worth, I am a happy Angular 2 dev and I am working on 2 large-scale apps at the moment. Here's what I think: - I would never even consider writing a large JS app now without TypeScript (or something similar like Flow). - Rxjs has transformed the way I write and think about code. It is true that it can be complex, and I still spend too much time trying to figure out how to do certain more advanced things with it. But the investment feels worth it. - Dependency injection is invaluable when it comes to testing. If you don't write tests, then it might seem like pointless complexity. 
&gt; observables are bad because he doesn't understand them No, I said that Observables do not fit the semantics of HTTP requests. All documentations on Observables operate on the assumption that an Observable is like a pipe, and you can get an infinite stream of asynchronous values from it. An HTTP request will only ever give you one value, so writing things like `request.map` feels wrong. Rx.JS works much better when you bind it to something like say, a WS stream or user input events. &gt; blatantly lies when he says components need separate CSS and HTML files I mentioned that you can do that in Angular, but we used SCSS to control variables like color and fonts, so it was a no-go for anything larger than trivial components. 
I have not used angular2 yet, so it might overall be a great framework, but I totally agree that angular2 is still beta as long as it's built on an unstable stack, that it shouldn't target typescript as primary language and that the template is badly designed. With the case sensitivity part, they tried to remove the confusing mapping of a directive name to an html attribute, but replaced with it a confusing html syntax. It's a shame; I though using a selector to define which element a directive should apply to was fine and solved that issue. Transpiler are fine for libraries, but they are a pain for front end development; I am quite happy to use babel with webpack or jspm for new project because I am hoping we can progressively remove those built process (until deployment) as browser catch up with new ES feature; we are just missing module support for full ES6 support. But if frameworks like angular2 don't target primarily ES*, we will be stuck with transpiler forever.
We're at ES7 now, which is functionally ahead of TS. If you browse through [this list](https://github.com/facebook/react/wiki/Sites-Using-React), TS probably would only be able to transpile a very small amount of it, unless it goes through an additional Babel pass. How is it a good thing getting your JS served from a tiny subdivision of Microsoft with severe limitations, while the rest of the world uses Babel, which reflects TC9. TS couldn't even use Redux (spread) or async/await, what kind of "good thing" is that to be constantly stuck in the past? Same applies to Flow. It has been demonstrated to check types that TS couldn't. It's fast, integrated and modular. It doesn't get between you and the code, which TS does.
Personally, my problem with that is that this whole business of sending your design along with the data is just so ridiculously, facepalmingly, moronically stupid. Yeah, I know, client/server is dead. We need to have a different design "philosophy" for every. Single. Page. Ever. We need 20 million different kinds of lists and buttons and dropdowns, because every single one of us is so special, and our content needs special treatment. Duh. Yeah I know I know. I live in the real world too, and your argument is perfectly solid. But still... it's sad, you know.
Wow, that high.... damn. I feel this is a bit better written: http://codepen.io/SarahC/pen/YpYNLQ Less voodoo code (caused by my panic when it crashed), and a tiny bit more structure...
When you click the start animation button at the top of the page, you get the video playing *as well* ?! Oke... this is interesting.
As someone who has been job hunting recently, that was a major concern for me. Almost every Javascript related job wanted Angular experience. I ended up taking some Udemy courses and built a small site using Angular in order to finally get a job. Oftentimes you have to learn the new "it" thing just to get/keep a job.
Here: var imgsrcs = []; //insert image files here, in the order you wish the tds to show. Remember to include "" around the files, and use the WHOLE FILE NAME ("img.png" instead of "img") var imgs = []; for (var ln = 0; ln &lt; imgsrcs.length; ln++) { var img = document.createElement("img").src=imgsrcs[ln]; imgs.push(img); } var td = document.querySelectorAll("td"); for (var ln = 0; ln &lt; td.length; ln++) { td[ln].src = imgs[ln]; } Typed up quickly, so I don't know if it would work, and could possibly use objects instead of arrays to match the tds with the images better - however, this is a good piece of code to base off.
Did you have zero experience with Angular or just hadn't worked with Angular 2 before? The "dilemma" I'm having is that I've been working with Angular 1 &amp; 2 for a few years now, however I got a better offer at a company that uses Aurelia. I don't know whether that time away from Angular wouldn't end up hurting me down the road.
rock on!
It's more of a case where I got the Angular job, but the stuff that we were working on was really boring (very basic CRUD admin UIs). The work at the Aurelia company is more exciting. 
Thanks!
Transpilation is an unnecessary word because it IS compilation.
First of all, you probably gave me the wrong link. Secondly, out of all the features some ECMAScript standard could introduce, none can even begin to match the safety net a typed language offers. Thirdly, who cares about an additional pass? And while I am against both Microsoft and Facebook, experience has taught me that overlooking a superior technology (in my case, it was React, which was in its infancy back then, but it was still superior to Angular 1 and Vue) because I don't like the company behind it is a big mistake. Babel is *not* a good standard for anything. Following the herd and sticking to popular shit like Angular 1, ES, Mongo, Node in production, Redux, etc... can seriously harm your project and your sanity. As for Flow, last time I checked its editor support was lacking, which makes it a no-go. Not everyone's writing TodoMVC, and a proper editor is a requirement if you are writing something complex.
[Image](http://imgs.xkcd.com/comics/standards.png) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 3894 times, representing 2.8216% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_dap2rgt)
Did anyone else laugh at this statement? "When I was introduced to Angular 2 I hoped it would be an elegant framework that is on par with projects like Laravel and Django." 
&gt; Rx.JS works much better when you bind it to something like say, a WS stream or user input events. It works the same. Not really bothered about the circlejerk/downvotes, that statement is a bit silly let's be fair.. There is validity in lots of stuff op has mentioned but the other guy is right, there is some plain silly in there too.
You're over thinking it massively. Take the better job. A SPA framework is a SPA framework is a SPA framework. Any tech lead at a company that doesn't recognise that probably isn't worth working for. Why/how did you get offered a job with Aurelia if knowing the framework is that important? And if Angular2 does turn out to be some arcane thing that you can't understand unless you already understand it, it will die before you have to look for a new job anyway.
I kind of get the sense that everyone has given up waiting for ES6 to be fully implemented and have just decided to do it themselves. 3 or 4 of years back everyone was saying "ES6 is coming! soon you will be able to do all this stuff!". By now everyone is sick of waiting and are turning to things like typescript, angular etc to to the things they've been waiting years for (promises, modules, web components etc). The travesty (imo) is that the browser makers couldn't pull their finger out and implement this stuff in a consistent and timely manner.
Groovy. I love it when little snippets like this are put to practical use. I like bookmarklets and user scripts a lot too. Never written a Chrome extension, but it looks simple enough. Just add a manifest.json and some icons I guess?
its not even hard bro... at least tell me where to begin. i've attempted to answer it and i dont even know where to start.. so where do i start?
Dude u are one week late. I just converted a websites from joomla to our own framework and did this slug thing in php.
Recruiters are programmed to include Angular in job descriptions. I had to ask 3 times to have Angular removed from a job description I was recently trying to fill. Five years ago, it was jQuery. Soon there will be some other big thing that everyone thinks is critical to their career. It's not critical. Stop making technical decisions based on what hot library you think is going to improve your resume.
More developers know javascript compared to coffeescript, so the developer pool is limited. Same with elm, same with Dart, and even typescript to a lesser degree. 
Yeah, even the icons are optional, I think. Can't remember if Chrome Web Store demands them for publishing, but it probably doesn't. I'd suggest to get started from here, Google has an awesome documentation for extensions: https://developer.chrome.com/extensions/getstarted
What's your opinion on his complaints about the documentation?
Yeah, but having a generic _require(moduleName)_ function seems all but impossible. (There are some Stack Overflow hints)[http://stackoverflow.com/questions/29223071/how-do-i-require-from-the-console-using-webpack], yet I couldn't get them working. Webpack doesn't want to load modules based on JS variables, only hard-coded strings allowed.
Just wanted to point out, if you look at the code, I'm using some DOM4 methods, such as `.append()` and `.remove()` to work with DOM nodes. If you didn't hear of those yet, you might want to start using them now. Really handy. And the polyfills for old browsers have been available for a long time now.
Ooo! Excellent! Thank you for taking so much time to look. &gt;The browsers have proper canvas debugging tools, They do?!
&gt; This is a real concern for me. Everyone wants React or Angular developers, even though I consider both to be quite flawed. Same here. I tend to put a lot of thought into what I learn next to make sure I don't sink lots of time and effort learning something that's not going to keep me hireable.
You managed to totally miss the point, and used it to enforce your point of view on your twitter echo chamber, rallying your followers. Thanks for the (undeserved) visibility you gave me, by the way. Just a couple of points (where my usage of "you" is just a placeholder. Nothing personal agains you, Dan. I think you are a nice and smart person that unfortunately is being eaten by an entity that you still don't understand completely): - I have zero interest in contributing to your projects. For free or not. With code or money (that I don't have). - I am not going to ever use React or anything with the Facebook brand on top of it. It is both a political and a technological statement. - If you don't get the political meaning, it is not my job to convince you. Everyone is free to have their ideas, but they should consider the implications that their job has besides the technological aspect. - When you are employed, your free time is your employer's property. - I think that open source is the degeneration of free software. - I think that NPM Inc is evil and bad for the ecosystem. Azer was one of the few that manage to do the right thing. Almost nobody understood what he wanted to say with his statement, and focused on the insignificant part of it. - The economy you are part of is completely fucked-up and not sustainable. - Do whatever you want. Share everything you do. Show the typeface you bought and the editor colors you find nice. Make videos. Speak at conferences. Whatever. I don't care. That being said, thank you for taking the time to respond to my message, and keep doing what you enjoy the most. Everything else is trifting.
Not to mention that Observables are streams in an of themselves. Promises can only resolve once, another limitation. The observable represents the (often) more natural event stream.
Fair point. [Measured](https://github.com/anvaka/playground/blob/75e2a9a98ca5060fe13b498d20135307f2ca4cb7/object-vs-closure/index.js#L47-L64) with reusable functions. Still much slower than regular objects: average counter Object x 252,272 ops/sec ±1.47% (83 runs sampled) average counter Object with private symbols x 249,925 ops/sec ±1.19% (81 runs sampled) average counter function x 46,006 ops/sec ±1.48% (82 runs sampled) average counter reused function x 51,960 ops/sec ±1.45% (83 runs sampled)
&gt;It even goes further because to my knowledge Vues components aren't self contained and depend on loaders. You are joking, right? Loaders are plugins for webpack while csjs requires plugins for babel. It is the same thing. &gt;you apply any postCSS transform you like, or several. Same with vue. The actual difference between vue and react style is that vue sfc is an html file while react's jsx is JavaScript. Rest of the differences came from that. Also please keep in mind that vue-loader and vueify are the *only* build tools written by vue team. Rest, of the plugins used, are written for browserify/webpack. On other hand, react's css in js are custom made for react and are not of much use elsewhere. 
What's this for btw? Some coding challenge site? Looks interesting
Hallo. Thanks for painting me as a "venting troll". About the rest of your message, I don't think that bundling is vital to performance in the majority of the cases. Instead, I think that it is something that just adds a huge amount of complexity, and that break the linearity of the "view source" that makes the web a very nice platform to study other people's code and learn from it. The modern pipeline is so complex that un untrained eye gets lost into implementation details that leaks to the surface. Anyway, thanks for the offer, but I have no interest in contributing to your project. My personal projects are already piling up (since I think quicker than I can manage to create), and I prefer to spend my life trying to give a form to my ideas instead of working on other people's ones.
I like that you built this but don't like the questions. Nobody does bitwise math in their head, it's all but useless. Better questions would be things like "how do you check if the 6th bit is on?"
Woa, this just gave me an idea... Maybe instead of using the Asana API, which just seems like too much work, I could just make a chrome extension that interacts with their pages. I could make an expand all button or something that shows all comments under a task and fully expands all the text for each comment instead of having to manually re-click all those links every 10 minutes and having a love-hate relationship with Asana...
I've yet to see a React solution that's nearly as well composed, neat and "normal" as Vue's. If you have one I'd love to see it.
Here's how I'd do it: const users = ['randy', 'stan', 'sharon', 'kelly'] let groups = [[], []] users.forEach((user, index) =&gt; { groups[index % 2].push(user) })
Thanks! I'm gonna try it out with my typescript projects right now! 
Any recommendations for most in-demand frameworks? Angular and React are pretty obvious but anything else? I like VUE, what little I've used of it, but doesn't seem to be much work for it. Ember 2 was not easy to jump into and learn, when I tried 7 months ago.
Disclosure: self-post
I run into this issue constantly at work because of an optional dependency of `chokidar`. Shrinkwrap almost causes more harm than good.
&gt; value == '[object Object]' Except that fails if I override the `toString` method in my object.
Did you choose that color or use some kind of bitwise algorithm to generate it?
Async chunk loading
Don't blame the language when you use it poorly
The React component is self contained. On the publishing side, your side that is, you need Babel of course. Your components get transformed and ship fully-transformed. The end-user doesn't worry about a thing. No loaders, no Sass, no configs. Just npm install and an import statement.
Why exactly do you recommend that in this case? What other value that would evaluate to "Fresno State."
Which is dumb because you shouldn't override properties/functions you don't own.
&gt; What's the point? External code can still access [_sum] and [_count], it's just a little bit more difficult. Well... that's going to be true in a lot of languages. PHP has a private access modifier, but you can still access those members using reflection. C++ has a private access modifier, but you can still access those members using reinterpret_cast.
&gt; The main perf difference is because your closure implementation is re-creating every method on every instance. Do it faster like this: In another reply, it seemed important to you that private data be enforceably private, so I just want to make sure everyone's aware that this alternate solution sacrifices that. You'll be back to underscore conventions for privacy. &gt; If the perf penalty of using class or similar is noticeable, then you probably shouldn't be using an object oriented style at all, but just functions or even lower level. On the contrary, classes were the fastest in Chrome. Faster even than plain functions. We shouldn't rely on our intuition of what will be faster, because v8 is so heavily optimized that our intuition is often wrong. Always measure.
No, we're not at ES7, that version of the langage never existed in the first place. Right now, we have ES2016 as the official current version and the next version is ES2017, which already has a couple of features slated in (like async functions). Typescript supports everything in ES2017 while compiling to ES2015 (or ES6), and chose not to transpile some "minor" stuff further down because it would either cause a significant runtime overhead (proper iterators with for..of, proper classes) or an impossibility of making it work in all cases (generators). And a lot of the newer stuff is there too. I dare you to name me one useful feature that typescript 2.1 doesn't support and compile to ES5 at least partially for 80% of use cases. (that means you can't say generators, because most of their use cases are to handle async functions, which is supported)
The JSX transform itself would look like: cats.map( cat =&gt; { return React.createElement("li", {}, [ React.createElement("a", { target: "_blank", href: cat.video }, [ cat.name ]) ); }); Then you'd have to include whatever's needed to get React.createElement to work. I doubt that would be less than 200 lines of code
Is there any official information on this? i.e. a link to an official announcement, release notes, Google code issue, PR, etc. I cannot find a single source other than this gif on Twitter.
ES7 is fully rattified and implement in most browsers. Babel fills the gaps. Minor stuff like async/await had you use promise chains for the last two years, or spread had you miss out on Redux or use verbose Object.Assigns. I already had a huge list of sites you wouldn't be able to transpile. Pretty much everything that uses React probably has modern ES7 in it.
I had just woken up and was pooping. Point was you can one liner it, and still could with assign. 
André's critique is focused on the article's statements about TypeScript and RxJS.
&gt; You can install the Debian Yarn package without installing the system Node.js package by using the --no-install-recommends flag: Thanks! I think that should definitely be documented -- I was reading a Github issue on the Yarn repo and it didn't mention this possibility at all. Didn't realize that the nodejs package wasn't a hard dependency for the yarn package to work.
Yeah. It's a "recommended" package so Yarn works out-of-the-box on a computer that doesn't already have Node.js installed, as people that use Yarn may not actually care about Node.js (eg. if they're just using it to download frontend dependencies). Feel free to submit a pull request for the site if you like! The site's on GitHub at https://github.com/yarnpkg/website :)
In this case, nothing, but habits are created by repetition
&gt; What's the point? External code can still access [_sum] and [_count] Sure, one could do something like `const _sum = Object.getOwnPropertySymbols(averageInstance).filter(x =&gt; x.toString() === "Symbol(hi)");` and then be able to get at averageInstance[_sum], but nobody's going to do that accidentally, and it should be pretty clear to anyone doing it that they are intentionally bypassing public API to get at internal state. Trying to stop someone who's that dedicated to shooting themselves in the foot is a pretty fruitless endeavor in almost all programming environments. Plus, in addition to their privacy-like benefits, Symbol-keyed properties stay out of iterations and stuff like JSON.stringify() and Object.assign() automatically, and all of this stuff works on object literals (`obj = {[someSymbol]: 1, whatevs: 2}`) in addition to ES6 classes / retro-js constructor functions.
Well Angular uses TypeScript to the max, I can see how newbies would struggle with TypeScript if this is their first exposure. I love TypeScript and use it at any chance I get but my code hardly looks like Angular ts files
&gt; eventually Well, when we *eventually* get WebAssembly we may not even be using JS/JS supersets anymore.
&gt; [People] open issues in my library because I don't have type defs due to me not giving a shit about one way or the other about TypeScript You should document the types of your API either way. Secondly, d.ts files are useful for JS devs, too. You can still load them and get auto-complete, call-tips, and some type inference.
We did think of this sooner. This is almost a burned down jQuery, and I'm really really not a fan of it. Basically seems like small wrapper functions around the standard DOM stuff -- this is like "jQuery lite" or similar. Looking at the implementation of things, it doesn't really add anything to your software other than a dependency on more non-standard code.
That's because its not in any of my code.
It's perfectly fine to shadow prototype methods on objects you *do* own; /u/r2d2_21 wasn't talking about overwriting `Object.prototype.toString` or something like that, but rather defining something like `MyClass.prototype.toString` or even adding a special `.toString` method to a particular object.
&gt; You should document the types of your API either way. I do, the type is just object usually which doesn't really help type script people &gt; Secondly, d.ts files are useful for JS devs, too. You can still load them and get auto-complete, call-tips, and some type inference. ok I'm all for adding one to definitely typed, I'll even ping you before I update my lib with a breaking change, they just aren't part of my work flow or the workflow of most JavaScript Devs and TypeScript is nowhere near the critical mass needed to make me care proactively about it.
No, I don't think that everybody should convege on X. If someone thinks that X is FUBAR, or if they just happen to have different opinions on whatever matter they consider important, it makes zero sense to contribute to X and spend time trying to improve it (for some definition of improvement, that could possibly also be to just delete 100% of the code and start from scratch). You should also consider that since Rich Harris already wrote buble (instead of working on babel) and rollup (instead of working on webpack), probably he prefers to work on his own ideas. There is absolutely nothing wrong about that.
FYI -- JS doesn't really do bitwise math. I has to convert everything to a float and back. So, while bitwise math is fast in C, it's not fast in JS. Just something to keep in mind.
Good read. It is amazing how often you hear people talking about features that "will be in ES7" oblivious to the fact that it's already been published.
You don't use lodash because you disagree with a couple of the implementation details? That seems odd to me.
Cresting a new object everytime is really what you are supposed to do in order to maintain immutability 
Thanks for pointing out, I sent you PR with redux-subsriber link :) - https://github.com/markerikson/redux-ecosystem-links/pull/29 
Thanks!
Actually working on another round of updates for the list right now, and already had that bookmarked and just added it. I'll close the PR, but it'll go up as part of this update.
Thanks! This was perfect. He has another question. Hopefully I can format this on my phone without totally screwing it up. Use jQuery to fetch to fetch the ids and build the info associated with the ids – in HTML using this associative array below. I need JavaScript to build (with htmlString) &lt;p title=”title 1”&gt;Text 1&lt;/p&gt; in my html from this : &lt;p data-id="100"&gt;loading...&lt;/p&gt; jQuery(document).ready(function() { var array = [ {id: 100, title:"Title 1", text:"Text 1"}, {id: 200, title:"Title 2", text:"Text 2"}, {id: 300, title:"Title 3", text:"Text 3"} ]; var assocArray = []; for (var i = 0; i &lt; array.length; i++) { var item = array[i]; assocArray[item.id] = { title: item.title, text: item.text }; }
Do you really think all the community at large is going to be dropping a high level JS supersets and start writing C++? I mean I know I will, but most likely scenario is people will be just using something like TypeScript to compile to WebAssembly code like React Native does for Objective C today. Anyways yes JS will die, but the spiritual successor will be very ESNextish in style. Like Doom to Quake. 
My opinions and the stack that I built around them [vdux](https://github.com/vdux/vdux): * React-style components * Actions/reducers rather than setState * All state stored in a single, immutable state atom. * All state is component local. I.e. The opposite philosophy of redux. You keep your state in a single atom, but each component receives a scoped slice of it. There is no global state. * Mediate all side-effects through redux-style middleware. * Fractal architecture. Everything is components all the way down. There is no code other than component code. Components have their own middleware stacks. * Allow context, but don't allow layering of contexts. The root component defines one context for the whole app. * All CSS should be in JS, and specified in in the props of the components. No stylesheets (with the exception of inherently global stuff, like font definitions). Things like hover, focus, media queries, etc. can be emulated. The way I do this is by having a CSSContainer component that accepts props like 'hoverProps', 'focusProps', etc... That overwrite the normal style properties when in that state. * Use require/import for everything, including assets. Configure webpack/browserify to let you require('./logo.png'), etc.. * Use higher-order components wherever possible for effectful/intelligent things like data fetching. i.e. [Dan Abramov's Container/Presentational components](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.yhtcgz9ah) pattern. 
Can anyone vouch for the quality and completeness of their docs? Or is it a hobbyist-grade mess like socket.io?
Ah, thanks a lot!
Paul irish highlights some of these things in a talk at the recent chrome dev summit. https://www.youtube.com/watch?v=HF1luRD4Qmk
The error message will include a description of where that code is. I would start there.
This "tip" is found on the landing page for the Typescript site. It's not exactly some hidden gem of information.
The thing I like most about writing chrome extensions is that you can use all the latest web standards without worrying 🤓
Yeah. At my work we tried working around it a number of ways; eventually ended up using `lockdown`, which mostly works but is a bit fragile because it's implemented via a pre-install script and builds on `shrinkwrap`. Uber had a reimplementaion of `shrinkwrap` which seemed to work better for a while, but they didn't update it for NPM v3. Really, the ecosystem was crying out for a full rewrite of NPM that abandoned their legacy cruft. Which `yarn` is. 
&gt; start writing C++ Haha I hope not! But I guess it's gonna fragment the community even more.
Good point. I have noticed multipage apps have often become pretty indistinguishable from SPAs nowadays too (speed wise), just due to browsers and sites getting speedier.
That simply isn't true. JS runtimes use native integers whenever possible.
I love using typescript with React and Redux. The type-def acquisition story has also gotten significantly better with Typescript 2.0. Other recent quality of life improvements include async/await, union types, wildcards in module names, and UMD output are great additions too. For those that aren't aware of how type-def acquisition used to work / works now: Before, if you imported a library such as react, `import * as React from 'react'` and the library didn't come with its own type-definitions, you would have to either manually declare something from it, import it using `const React = require('react'), or download a type-definition from somewhere using a tool such as Typings or TSD, and make sure your project was setup properly to read these types everywhere. Now you can just type in your console `npm install @types/react' and it will install the types into your node-modules and everything should work. VSCode recently added a feature as well to automatically acquire these typings in the background for enhanced autocompletion in javascript projects.
Woah awesome. What might this be useful for? 
I personally use `clang` and it is far from being mediocre. I think having options is a good thing.
What about nested menus possibly if the settings were turned down a bit? Automatically opening a menu when it looks like the user is going to hover over it?
I've used bitwise operators for device drivers and in the kernel where you actually want to flip bits on a piece of hardware. But, that doesn't apply to JS. The only other application I've used them for is when you do want to get tricky to do a mathematical operation really fast. In C, you do get the speedup because the bitwise operators are fast. But, as you point out, bitwise operators are not fast in JS. This is because the language doesn't support integers.
I mean that JS runtimes will detect when you are using numbers as integers and specialize the machine code for it.
I realised that addin `console.log(i);` into `window["proj" + i].onmousedown = function ()` results in print of `7` upon click of any of the &lt;p&gt; elements.
I have a question about the code posted with the unordered list and list items. Why not just put all of that information and all of those methods in a service and then require it in with one line of code at the top of every component file that needs it?
The language and the js engines supports integers (from TypedArrays to the internal usage of small integers), and you can find plenty of good uses of bitwise math in javascript code. I could not live without. &gt; But, as you point out, bitwise operators are not fast in JS I wanted to state the opposite. They are sometimes faster, and never slower (if we don't have a bug in the engine). By the way it is not about speed (otherwise you would not be using javascript at all) and it is quite pointless to compare them to their non-bitwise counterparts. They are just different operators that serve different purposes.
Thank you. That worked well. However, I didn't exactly get what happened here. What changed when I added an extra function and what is this `(i)` at the end of the function. Moreover, how did `i` reach to the value of `7`?
It is absolutely an implementation detail, just as the comparisons (not just `==` versus `===`) in lodash leave the door open for obscure and hard-to-debug bugs.
author here - I abstracted this out of a project where expensive DB queries would need to run based on different user interactions. by being able to fire off the queries a little earlier the page feels a lot snappier. Prefetching different resources is a good case, if you target all &lt;a&gt; tags on a page, for example. Hopefully other people find it useful for a variety of things.
Too many characters have been spent explaining this behaviour. The first link I can find to avoid repeating it again is https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch3.md
yep, a clueless php developer with a worthless opinion
 function asciify(str) { var az = 'abcdefghijklmnopqrstuvwxyz'.split(''); return str.toLowerCase().split('').map(function (e) { return az.indexOf(e) + 97; }).join(); } * Edit: forgot to lowercase str, and join() the return value.
All the JS engines have a JIT, so code that is run a lot will be optimized.
No, you won't be able to debug within expressions... this feature is meant to solve the issue of not being able to set breakpoints in single-line function callbacks and lambda expressions. e.g. fetch(url).then((res) =&gt; res.json()).then((jsonResult) =&gt; console.log(jsonResult.foo.bar)) or: document.addEventListener('resize', function onResize () { /* can't debug here */}) document.addEventListener('resize', function onResize () { /* can debug here... */ })
More like a good way to learn how to convert decimal to binary and back. Nobody cares about doing bitwise operators on decimal, you learn them in binary where they matter.
Some of our guys use only the key to name their branches, but it gets a little bit hard to navigate between local branches when they all are named by keys. But it turns out that you can select both key and summary with one selection, slugify it and get both of them in your branch name. It has both advantages of searching by key and human readable summary for easier navigation.
too bad, that would be much more exciting. but this is good too :)
nicely done. I like the design. Do you have experience with design stuff? 
&gt; I'm wondering, why the famous library Lodash (or underscore) tries to avoid the usage of the `typeof` operator. It doesn't. &gt; Now lodash uses it for strings (typeof value == 'string', but why == here?) Because the result of typeof is always a string so `==` will do. In your other boolean example it's checking a user provided value which could be anything. &gt; Instead they use (a deeply nested, have a look here and here) version of `toString` The helper is abstracted a bit to enable parts of it to be removed by [lodash-webpack-plugin](https://github.com/lodash/lodash-webpack-plugin). &gt; which can be found here besides other so called tags. More info on `ToString` tags [here](http://www.ecma-international.org/ecma-262/7.0/#sec-well-known-symbols). &gt; I'd think, that you can overload (or actually replace) the `toString` method quite easily, but you cannot overload the typeof operator. Grabbing a reference to `Object.prototype.toString` is a common way to check the `ToStringTag` of a value. See the [Object.prototype.toString spec](http://www.ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring).
Actually, the AJAX was spot on. Found the issue. The PHP response was not formatted properly causing the error.
I think about this a lot myself. In this case, I think it's better to say "delegation" instead of "composition", but they're both valid terms to use here. It's hard to pick between both because there are pros and cons to both approaches. [Here's an example of what a `Player` class would look like in a game, using both approaches.](https://gist.github.com/just-nobody/9d71f26cbf7dc21f80a422efa5aa4ddd) The main difference here seems to be convenience versus maintainability. Inheritance-style code is quicker and easier to write, but delegation-style code is more flexible, and easier to reason about, not having to go through trees of inheritance to debug code. Delegation also avoids [the diamond problem](https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem) commonly cited when talking about inheritance. Mixins make a good way of combining lots of functionality flexibly into a single object, but naming collisions are hard to avoid unless you're the only one involved in a project and remember what every method is called, but even then, you might make a mistake at some point and give two different mixins an `update` method. Then there's the issue of resolution: if two `update` methods get mixed in, which get called, and in what order? This is probably the main reason why functional code and data-oriented code seems to be the thing people are talking about nowadays. Any approach using OOP seems to run into some sort of architecture issue. It then begs the question as to why we even still stick with classes. My best guess is that they just feel nice to work with. It's easy to model a thing in your program as an instantiated object with properties and methods. Classes just feel _nice_. Inheritance feels _nice_. Data-oriented code isn't as easy or fun to work with, and composition has it's own aforementioned issues as well. At the end of the day, I'd suppose it just depends on how you're most productive, and if that happens to be with inheritance, so be it. Our goal as programmers is to solve problems, and as long as we're doing that, maybe a hierarchal refactor every five years or so isn't so bad. Gives us a job, if anything. Yet I still wish there were an elegant way to keep OOP, while throwing inheritance out of the window entirely. It's at this point that I'm sure we can all agree that we'd be better off without it. Ideas?
It depends exactly what the js looks like, but yes the generated code can be pretty tight. In case of overflow, there are overflow checks (hoisted outside the loop where possible).
In the past, I've simply extended the `Error` object to have a numeric status value. Then, when I catch the error (in a promise chain, for example), I can specify which error status code I want to be used in the response. The ES5 version is a bit verbose, in ES6 it is easier to follow and incredibly concise. class APIException extends Error { constructor(message = 'An error occurred', status = 400) { super(message); this.status = status; } } Promise.reject(new APIException('You need to be logged in to do that', 401)) .catch(err =&gt; { console.log(err.message, err.status); console.log(err.stack) }) 
Bwahhaha
Congratulations, you have "woken up" ;-) This topic is a slippery slope. Eventually, you'll realise that even classes aren't really needed either. OOP isn't needed! Moving from C# to JavaScript is a great opportunity to focus on functional programming. JavaScript, unlike C#/Java, is a language that makes it feasible to work with pure data structures, because JavaScript has object literals (JSON notation). &gt; My best guess is that they just feel nice to work with. It's easy to model a thing in your program as an instantiated object with properties and methods. Classes just feel nice. Inheritance feels nice. Data-oriented code isn't as easy or fun to work with No, they don't feel nice. They feel familiar, because we have written a lot of object oriented code. Once you have a look at the alternative, you will never want to go back.
Hi /u/portagul, to do this in JS would break reddit, and I think is against the ToS. You did see that the top post had list of every question and answer, right?
Interesting I have no idea why that is happening. Is it how math is being handled by JS?
Factories/DI are a much bigger abstraction and mindset. Like you said, if you code enterprise in Java you probably know this. Most JS/fullstack devs most likely won't. They are also a lot less useful abstratction in general. In the same way that inheritance is less useful abstraction than composition because it requires an OOP language and designs. Streams/observables are everywhere, which is why RxJs/Bacon etc are very useful if you use them to the full extent. Its a bit like promises. Its something that applicable in a number of areas as well such as Node streams. IMO its one of the better decisions made by the Angular team.
&gt; No, they don't feel nice. They feel familiar, because we have written a lot of object oriented code. Once you have a look at the alternative, you will never want to go back. I've looked at the alternative, tried using it in practice, and end up going back to classes anyway, just because of familiarity like you said. It gets the job done without much thought. Still ends up feeling dirty, though. Maybe that's just me. I like OOP, it's just inheritance that's biting me in the ass.
&gt; I've looked at the alternative, tried using it in practice, and end up going back to classes anyway, just because of familiarity like you said. Please do elaborate! What were your experiences?
It's a floating point number. Same happens with 0.1 + 0.2. http://www.saintsatplay.com/blog/2014/08/handling-floating-point-numbers-in-javascript
Ill read up, thank you
Inheritance isn't a property of OOP; it's a property of type systems. OOP is about merging data and behavior (or more generally, message passing between isolated units or processes). Composition and encapsulating can absolutely happen without classes or even prototypes at all. However, doing so just because isn't really beneficial. Use what makes sense. That is where the mantra "composition over inheritance" comes from. It's good advice, but I also hate it, because it sends the wrong message. Use inheritance when describing a taxonomy, use composition when describing relationships.
Just fyi, you can just hit the pretty print button and then place the break point in the formatted code page, even stays on refresh... at least when code isn't changed. But seriously inline break points can be pretty fantastic
&gt; It then begs the question as to why we even still stick with classes. Classes allow you to model types and types fit well within functional programming because a function's domain is fundamentally about what types it accepts. Inheritance is, again, about types with the lower classes being more specific. The problem I see with inheritance is that many people see it as a method of code reuse rather than a method of specifying a particular relationship between certain classes of objects. More often than not that relationship isn't actually present and so inheritance is the wrong tool for the job. Classes are fine, inheritance is fine, functions are fine. They're all tools to use and after so many years of OOP enough people have seen the problems of misuse that there is a reactionary movement away from it. However, the reasons I often hear are less to do with picking the right tool and more emotional recoiling from the paradigm.
I just tried this on iPhone... since the demo doesn't seem to work I'm guessing this tracks how close the mouse cursor is to links?
TL;DR
JS doesn't have integers so I can't even imagine the witchcraft used to do bitwise operations. Any common uses for doing this that doesn't have a reasonable alternative?
Personally, pure data structures sounds like a terrible idea to me. Let's take, for example, a date pure data structure. struct Date { year, month, day } There are obviously rules that make a date valid or not. Is it valid for day to be 29? Maybe. Depends on the month. If every corner of your program directly interacted with and manipulated this pure data structure, then eventually someone's going to screw up and produce an invalid date. It would be better if we had a small number of functions that are the only ones allowed to directly interact with and manipulate the data, and every corner of your program would instead interact with the data only indirectly through one of those privileged functions that ensure the data remains valid. Next, it would be nice if we could express directly in the language the relationship between the data and the privileged functions. Some... punctuation... we could put around both the data and the privileged functions that operate on that data. Like a pair of braces. And when you do that... that's a class.
&gt; These two pieces of code are the exact same thing. That's what I'm saying. The object-based approach was just more comfortable to me, is all. &gt; It's not a great example to demonstrate the difference between these two paradigms It was just meant as a minimal example, so no, it's not the greatest. &gt; the second example makes it clear that draw should not be a method of game: it should be a method of player since it only operates on a player and not a game. That's only if the player is the only thing that exists in the game. What about enemies, level blocks, powerups and such? The player would be its own class in a real-world example, though the game would still have a draw method - for drawing the player.
Or you could create a new github issue for their project entitled "feature request: please stop sucking". Or if you really want to make an impact, politely make a feature request for something that sounds like a really good idea, but you know is actually feature bloat. But don't create fake bug reports, that's just messed up.
[removed]
I know you can't speak for TC39, but can you provide some insight into how you think things like `import Foo, {bar} from './foo'`could work out? I know that there is pretty strong pushback from the Node side on a technical level, but anyone doing React these days have this in their muscle memory already. It seems like FB has simply forked JS and gambled that the community will see everything their way. 
Well, Facebook is not responsible for Babel even though both Seb and I work there now (neither of us work on it there, no one does officially). People keep trying to blame Fb for things it had no role in and we just have to shrug. The community was already doing this long before Babel existed. I think the earliest major example was actually Ember. The problem here is not that we did this in the community. The problem is that the TC39 committee designed syntax without specifying behavior and without communicating with people who could figure that behavior out. It's compiled code so ultimately it's not an additional burden for any maintainer of Node or TC39. We can easily migrate the community to something new, we have paths forward for breaking changes and we've handled this before. The tc39 was freaking out a bit more than they needed to because they were making assumptions about the Babel community before I was there.
James Brown is the man at work.
Short, sweet and to the point. This is a blog post I can spam to everyone. 
His question looks like a homework question. OP should probably figure it out from reading docs and thinking. Why do I think that? pretty sure all the p tags are in the Dom to start. See how they have ids? 
+1
I don't know if I would trust this guy OP... How do we know he's saying the truth?
Thanks for that. And my apologies for my tone. I think I tried Traceur only once and my knowledge of emerging language features were only from what I read. Until Babel, I never really had a reason to actually use new features and ~~Reach~~ React has been pretty amazing in pushing me to learn and adopt fast. And this article puts to words the uneasy feeling I've been having lately looking back at my recent work and seeing how much of it sits at Stage 1. Interestingly, Yehuda Katz just published [TC39: A Process Sketch, Stages 0 and 1](https://thefeedbackloop.xyz/tc39-a-process-sketch-stages-0-and-1/).
Awesome! Glad to hear it worked out. I felt the same way when I found it. =) Waiting minutes for a compile really wears you down after a while, hope this makes it more enjoyable again.
Yea it isn't perfect at all, I haven't worked out bugs or anything. Thanks !
Only 119 comment karma? I don't think he likes to babel on about much on reddit. Unlike some people.
It could be called .... Webception !!
Why not open an issue instead?
The reasoning behind why we don't automate everything is because we strive to be open enough for it to work on any stack or every setup. There are a lot special.snowflakes and you'd be surprised at the point of defaults we already set. But yes we'd love to see a github issue proposing something :) 
No apology necessary. We really always want candid responses (it's how we've grown from just being a side project fr one guy in Germany for fun). Regardless, we expect people hold us accountable. 
In the case of detecting functions in a perfect world Lodash would just use `typeof x == 'function'`, but because of buggy implementations its externally `_.isFunction` must be a bit more robust. Lodash doesn't use a given value's `toString` method. It uses a reference to `Object.prototype.toString`. See [comments/5g2kc4](https://www.reddit.com/r/javascript/comments/5g2kc4/why_does_lodash_avoid_the_usage_of_typeof/dapyaod/). 
For people willing to try something new, Cx is a commercial framework for large-scale applications JS applications offering the best features of Angular and React: declarative data-binding, controllers, JSX, centralized state management, etc. http://cx.codaxy.com/v/master/docs/concepts/data-binding 
Did you not see that "not just `==` versus `===`" part of my comment? P.S. If you look through my comment history, you'll find that I once argued what your comment states.
I like how Ember is still around seemingly unnoticed by everyone, and absorbing features from other frameworks in the middle of the JavaScript frameworks wars.
Read the entirety of OP's comment.
Sorry i made a mistake, polymorphism is something completely different. I think its "type casting in javascript" you would want to google on this subject.
Voronoi is so cool
ok so your switch statement is switch (moonPhase === 'full') { your expression "(moonPhase === 'full')" evaluates to 'true' but your case statements are looking for case 'full': case 'mostly full': case 'mostly new': **but none of the cases are "true"** so it goes to default path. you could do.. switch (moonPhase) { ... etc 
I think that the kind of architecture you need depends on the kind of application you are going to write. It also depends very much on where the application is implemented. If the application is mainly implemented on the backend the type of front end will be very different from an application which is entirely implemented on the front end. If you are writing supportive JS in an application mostly implemented on the back end, you will want to be close to the metal, close to the browser and not too much abstraction. If you are writing the entire application as a single page app, you will want abstraction from the browser. The more data heavy and complex an application is the more you will want abstractions, such as models, views and controllers. A central state management system is going to be essential in order to keep control. My main history is in writing data heavy single page apps using SproutCore. If you going to look at it, you'll notice that it resembles Ember quite a bit, which is because Ember started out as a kind of SproutCore light. SproutCore is a Cocoa like MVC framework, written in a classical OO way, supporting key value observing, data bindings, localisation, view layers and loads more. It features almost everything you'll need for a complex single page app, including a state chart system, which plays the role of the central application controller. What I have noticed in recent years is the influence of functional programming paradigms. Very often however, the actual advantages seem questionable. For me it is unclear how composition differs from using mixins for example. Slowly the thinking about state is also moving. I find it difficult to see how a distributed application state would be better than a centralized application state. Of course it is not necessary to have a view state mixed up inside an application state, except when it is essential to the application state. Also, a lot of situations require writing glue code where you would rather write application code. Also, I have trouble seeing certain advantages of the ES6 import and export. While I understand their purpose very well, I have seen a lot of code which consists of 75% imports and 25% code + exports. I find that difficult to read, as well as difficult to reason about. Also, this brings along a tendency to split up project in a huge amount of files, which makes tracking how things work also very complex.
Presumably the instructor wants capital letters converted correctly as well. Your method can be altered to handle this. Otherwise, your comment is the correct way to answer the question. function asciify(str) { var az = 'abcdefghijklmnopqrstuvwxyz'; az = az.concat(az.toUpperCase()).split(''); return str.split('').map(function (e) { var idx = az.indexOf(e); return idx &gt; 26 ? idx + 39 // 65 ('A') - 26 to add the correct value to the index : idx + 97; // 97 ('a') }).join(); }
Is this based off a tutorial or did you create everything from scratch?
Depends on your preferences. That solution is an arbitrary syntax that gets disassembled by babel extract loaders and template parsers. It is neither normal JS nor HTML. JSX aside a React component in itself is nomal JS/ES6 and 7, a real object/class you handle as you would everything else. https://www.reddit.com/r/javascript/comments/5fi07s/have_you_moved_from_react_to_vue_if_so_why/dako5ut/
 Created unbeatable Tic Tac Toe game. http://tictactoe.mybluemix.net/
I was thinking about prefetching but don't you think this strategy is really aggressive with a pretty high margin of error. Compare your method to just putting a a ~20 px prefetching radius around each link that points to an asset heavy page. Why do you think your method is more accurate or effective than that approach? Especially if you have a cluster of links that are close together. Would your strategy potentially kick off a huge waterfall of unnecessary requests in that scenario? I'm asking because I think this concept is really cool and asset prefetching is really important especially in the context of SPAs and PWAs. How did this strategy work out for you in practice?
Thank you! No, i don't have any experience, i did it spontaneously eheh.
I feel like I've been waiting forever for full ES6 support. Can we just focus everything on that and then re-evaluate once that's done? I love Javascript but damn has it been a roller coaster these last few years... is Angular 2 ever going to release and is it even going to be any good? How many parts of it have been scrapped and rewritten multiple times? Sucks when you wanna stay current with in-demand technologies but there's a new better framework everyday.
Great idea. I feel like this would be the difference that would allow many to take JavaScript seriously. I am assuming you would make types optional and thus allow all existing JS code to run fine?
We need something else entirely. A combination between structs and classes that gives us the best of both worlds, and removes the worst of both worlds. You should be able to do this: def date = Date { year = 2016, month = 12, day = 1 } and then date would be immutable. You can do that in JavaScript with object literals, except the object will be dynamically typed (and mutable). You can do it with classes in Java/C#, but the amount of boilerplate you have to write is just unbearable. You can do it in Scala with case classes and named parameters, which is much better. But even if you were to make a constructor with input validation, that's rarely where validation will occur; one could instead have a function makeDate(day = 1, month = 2, year = 3) which returns either an error or a date. And then, make selectors: toString(Date { year = 2016, month = 4, day = 5 }). These will be very easy to unit test. Though your point of having a constructor that does validation is good; it's a way to force validation within the language. What we need to get rid of from classes, is the ability to mutate properties, and the ability to perform side effects like network calls, mutating other objects' state, writing to/reading from disk etc.
Parallax scrolling - not even once
I would say a more classical approach to inheritance, but I'm not sure that will happen. SO MUCH is tied to prototypical inheritance. I really feel the current ES6 class simply being sugar over prototypes to be misleading. However it would probably destroy backwards compatibility and that is a very dangerous bridge to cross.
Safari
Thats a nice trap i havent thought of, the reason why often just using a library is the way to go. Thanks for the heads up. 
aka why code don't write himself ?
You see this EVERYWHERE on reddit. A tool for a tool for a tool (used mainly by tools).
I haven't tried Dart yet but I use TS on a daily basis. If TS adds wasm as a compilation target, that was would be amazing!
&gt;One benefit is the potential performance gain that can come from the superior execution speed of plain JavaScript over jQuery, as reported in many benchmarks. Eh, wait. Isn't Bootstrap mainly used for dialog boxes? What does "performance" of jQuery matter then? Any initialisation code in jQuery runs in milliseconds.
Good on mobile too (iPhone 6). Great job!
Exactly. My comment was pretty blunt but what's there to say about this article? It doesn't actually make any point or argument or give any insight. It's a low effort shitpost. I wish it was at least amusing.
I assume you mean type-hinting / errors when passing in the wrong type? 
That's a good point and a probably a next feature :)
That is valid HTML 
I noticed this a lot doing the sololearn python track. I'm entirely self taught programming so getting question like "what will this maths do" I'm like, that's why I'd write the code... I also noticed the answers a code path question would be the one the easiest math is in. 
 A new operator: ||= As in: let a ||= 5; // let a = a || 5;
There's no Java in yout code. Java is to JavaScript as car is to carpet.
Backwards compatability. Too much existing code expects a fixed `Object.prototype`, so they worry they'll break that code if they add new methods. Typical W3C: irrational fear of breaking changes that affect less than 0.01% of sites means the other 99.99% of us have to suffer forever.
I think you're on to something, OP
When did it officially release? I remember doing tutorials at the end of summer and it was still in beta. Is it worth learning over VUE or React?
There isn't even any JavaScript in that.
Ok, so this was pretty stupid. I followed your second advice in your last comment, and in the console I found the problem, looked it up around google and found the answer. The problem was that I wasn't using any API key, so Google would not let my site show their maps. Thanks a lot for you help :D 
It's coming up as a link to the Twitter page rather than just loading the Twitter page up as a module.
I mean I'm all for syntactic sugar but this is barely an improvement.. `a || 5` is not hard to write at all. At a certain point you're just creating useless noise by adding more syntax like this. 
1) The lack of named parameters is a problem: new DateTime(2016, 12, 1); Is this 12. January or 1. December? There are also structs/data types/classes where you have more than 3 variables grouped together - it's impossible to keep track of which argument is which, without named parameters. The problem is not so much that you can make instances immutable, the problem is that no one is stopping you from making them mutable. Say you have a type system, like in Java. If you declare a variable to be of type Integer, than that information has little value if somebody later on can recast it to a String (like in a dynamic language). If it's an Integer on line 200 you have no way of knowing whether it's still an Integer on line 500. The same, if you have a mutable Date object on line 140, you should be able to assume that it's the same date on line 400. (Line numbers exaggerated)
I'm trying to upload it on my app. 
Basic understanding of the environment you are working in will greatly improve your success rate and even how to formulate legitimate questions. Your post here is like asking a farmer if a horse can produce enough milk for your cheese factory while showing him a goat.
Fast, native deep equality checking. Where it would verify that the structure and primitive values are the same between two objects, but in a more efficient manner than something like lodash's `_.deepEqual()`.
Thank you so much for taking the time. I see now I was trying to fix issues with imperative programming that are non-issues with functional programming. Looks like I'll be moving in that direction.
What does this mean? 
look at kotatsu, it's got pretty great defaults (it's a thin wrapper over webpack)
Function.prototype.partial is basically Function.prototype.bind without the first argument Object.prototype.map (literally) would probably never be accepted since it's very possible for code in the wild to do `{map: something}`. It likely would end up with another name.
I honesty don't know anymore with these performance wars... Even phones these days have processing powers and caching powers of slightly older PCS. Does it really matter if your application loads jquery? Seems like any problems that do arise are in the actual code of the app rather than what depencies you're using. 
Kinda ironic how types died w/ ES4
&gt; The lack of named parameters is a problem The Duration constructor used them. By the way, it also overrides operators. So, you can easily do some math with Duration instances: var clockedIn = new Duration(hours: 8); var smoking = new Duration(minutes: 5); var pooping = new Duration(minutes: 10); var lunch = new Duration(minutes: 30); var actualWork = clockedIn - smoking * 4 - pooping - lunch; print(actualWork); // 7:00:00.000000 You can do that with structs. &gt; new DateTime(2016, 12, 1); Is this 12. January or 1. December? Hover it and you'll be told. As you write it you'll be also told. It's of course year &gt; month &gt; day. The month also goes from 1-12 instead of 0-11. With JS things are more surprising: &gt; new Date(2016, 12, 1) Sun Jan 01 2017 00:00:00 GMT+0100 (CET) &gt; new Date(2016, 11, 1) Thu Dec 01 2016 00:00:00 GMT+0100 (CET) The entire signature looks like this: DateTime(int year, [ int month = 1, int day = 1, int hour = 0, int minute = 0, int second = 0, int millisecond = 0, int microsecond = 0 ]) You can also pass a string to DateTime.parse. From the docs: DateTime moonLanding = DateTime.parse("1969-07-20 20:18:00"); Simple enough, right?
Here (on google play store as well): OxBible https://appsto.re/gb/C8hvfb.i I am tying to add The @oufcofficial twitter feed in the updates section as a HTML section. The website I use to make the app doesn't read the first code that I put on this question. I'm not very familiar with HTML. it does read the face book &lt;iframe&gt; code but I would like Twitter instead if possible. Thanks for your interest in helping me so far!
Nice presentation. You spoke very accentuated which helped understanding your points. However, imo, you talked too fast. I would have prefered less examples but more time for each example. Additionally you did look at the screen most of the time instead of speaking directly to the audience. All in all still a good performance!
Whoops, that should have been something more like: function(options) { let {a} = options; a ||= 5; // a = a || 5; } 
It wouldn't hurt anything to have it, it matches the existing `+=`/`-=`, and there's a common use case for it (setting default values). Plus, while `a ||= 5` seems trivial, when you have `significantlyLongerVariable = significantlyLongerVariable || some OtherLongerVariable;` the brevity of only having to repeat `significantlyLongerVariable` once would be nice.
I guess.. Though the common use case you mention is already basically satisfied with default params: `function doStuff(a = 5) { ... }`
TL;DR: "You should use my library instead, because it passes the tests I cherrypicked. It's a subset of React that stubs out a bunch of stuff, so it's not a true drop-in replacement for React, and it's bigger and slower than the other two, but it's still a better choice because I said so."
&gt; The conversion should work for any English lower case word. So it's probably not necessary to do any upperCase/lowerCase conversion at all. I read that as "it's okay if this thing breaks if you give it anything other than lowercase letters".
Dart has something similar with the `??=` operator. It's a nice addition.
Doesn't JS have types? I use [typeof](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof) and [assert](https://nodejs.org/api/assert.html) (works in the browser with [browserify](https://github.com/substack/node-browserify)) to do type assertions. i.e.: // greetings.js const assert = require('assert') function greetings (name) { assert.equal(typeof name, 'string', 'greetings: name should be a string') return `GREETINGS ${name.toUpperCase()}!` } module.exports = greetngs for optimizations one can use [unassertify](https://github.com/twada/unassertify) to remove assert statements from production bundles.
&gt; However, imo, you talked too fast. Exactly. Give the audience some time to think from time to time, not too long, but 2-5 seconds breaks from time to time where it fits. It's pretty much like the difference between a long text with paragraphing and without. But I should add that apart from that it was great!
&gt; imo, you talked too fast I always feel like presenters talk too slowly, I end up watching most tutorials and talks through youtube at 1.5x. This was a really nice pace for me heh. 
That, and perhaps framework specific stuff, such as Laravel's CLI tools, react-create-app, and vue-cli
You may like `Object.entries` https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/entries Object.entries(ob).map(([key, val]) =&gt; ... ) *shrug* baby steps
Pretty sure that doesn't (and shouldn't) work. `a` will be undefined if it does not exist in the `options` object, and the fallback will not even be evaluated.
It's not such a trap, now that I think about it; it's arguable that customizing an object's `toString` method makes it no longer "plain". Oh, another customization you can do in ES6+, to modify the output of `Object.prototype.toString` when called on your custom object, is to set the `[Symbol.toStringTag]` property: var cust = {}; cust[Symbol.toStringTag] = 'Custom'; console.log(Object.prototype.toString.call(cust)); //=&gt; logs "[object Custom]"
Yeah that sounds like the most likely option, if they ever decided to add this feature
how will the arrow function help? that just makes fewer characters typed, it doesn't change the fact that 'this' means something different. Your first piece of advice makes sense, the second one is just syntactic sugar for an unrelated piece of the code, to type fewer characters.
The W3C doesn't handle the JS standard, Ecma International does.
Ecma International's TC39 actually does document a bunch of stuff required for backwards compatibility on the Web, and puts it into a special Appendix B; also, its Stage system for proposed features is intended to allow for coordination between what vendors can reliably implement and what ends up in the standard.
The only browsers that support the [`import` statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Browser_compatibility) natively are Edge (behind the "experimental JavaScript" flag) and apparently version 36 of Chrome for Android and the Android WebView.
I suppose Markov chains... meh
You are very wrong about arrow functions. They don't bind `this`, that hence maintain the value bound in the parent scope.
By the way I was wrong in another part... and if you can avoid calling me "bro" I would appreciate, thanks.
Really what you should be asking for is immutable objects, which would make a single `===` also be a deep equals
That did cross my mind, in that regard lodash fp could have a isCustomObject method that takes a name and returns another method to test a value. const isDogObject = isCustomObject('dog') const dogIsDog = isDogObject(dog) // true Perhaps it does already. 
Here's an honest answer to that request (I'm on the Flow team and have recently started participating in TC39) Adding a static type system (at this point) would likely be a mistake. The problem with adding something to the spec is that it can never change, and there's still lots of changes being made to Flow (and TypeScript). Also, almost every change you add to a type system is a breaking change in some way: either you are adding a error that didn't exist before, or you are removing one that did. There's the potential to standardize syntax, but even that's up for debate. For example, there's the question if ?maybe types are a good idea in JS because it means "T | null | void" but 99% of the time people mean "T | null" or "T | void", rarely both, and having ?maybe types just means you have to always check both. There's a lot of research and evolution here, so it's hard to argue that we should do anything in standards yet. In the meantime, the TC39 seems to embrace types and avoids adding syntax that clashes with developing type systems.
My mistake. But the point is, the folks in charge prioritize not breaking old sites while also refusing to add any kind of language version "switch" (which would prevent old sites from being broken by language improvements), so we're all stuck with an inferior language.
I disagree. His pace was great for the amount of details covered. 
ES6 was a massive release after like 5 years, the process has shifted to a moving train model where only a couple of features are released on a more frequent schedule.
We're half way there with object destructuring, just gotta throw it into a switch or something.
&gt; Inheritance isn't a property of OOP; it's a property of type systems. This. Often, when people talk about inheritance, they actually mean generalisation.
Check out Brendan Eich's proposal from the latest TC39 meeting https://mobile.twitter.com/BrendanEich/status/804121369910734849
Is there some reference to the buggy implementation of typeof, because that sounds really shaky if true. 
[RxDB](https://github.com/pubkey/rxdb) looks amazing. Can't wait to try it out. 
Calm down bro
Sound like he wants something like threads in javascript.
This was my first time hearing about flow and I liked your presentation a lot. I don't agree with the other comments about you speaking too fast, if you were difficult to understand I could see that being an issue. But you clearly went through the presentation a few times beforehand and didn't stutter or stammer, no weird pauses or umms and ahhhs. Atom looks cool too. Every time I try it I get frustrated and go back to my OG, textmate. Types would be so useful in JS, I just see a way for them to do it without breaking too much code. 
See [here](https://github.com/lodash/lodash/blob/master/lodash.js#L11667). That comment has been updated from release to release. Historically host objects in IE have problems with this too. Recently though, Safari has had worse luck. For example, in PhantomJS v1 `typeof` a regexp is `"function"`. The problem can also pop up in things that used to be DOM-land but have moved to ECMAScript, like typed arrays.
Thanks, /u/needed_an_account. When I compare this presentation to one of my [screencasts](https://www.youtube.com/c/codecast), I do think I speak faster normal but yeah, I did practice a few times beforehand. Atom's my favourite editor after Vim 😉 Just out of curiosity, what frustrates you about it?
(From the top of my head) I want: * less syntactic sugar, * everything optional to become mandatory (the radix in `parseInt()`, semicolons, braces, etc.), * a "standard library" that (at least) matches what you can find in Ruby or other languages, * more time between specs.
Hey Reg, loved the post! For funsies, I thought I’d give some motivation for why red-blooded, blue-collar, industry programmers, like me, might care about this. If you write in declarative patterns like unfold/fold, it’s much easier to read and maintain once you’re familiar (much like map/forEach &gt; for loop). We have some properties about cata/ana morphisms. One is that we can fuse two catamorphisms into 1 iteration if they both return the same type e.g. map(f).map(g) = map(f . g) Another cool property is we can fuse cata/ana into 1 (removing the intermediate data structure) with a hylomorphism. In our case: foldWith(f)(unfoldWith(g)(x)) = hyloWith(f, g)(x) // example hylo function hyloWith(cata, ana) { return function hylo (value) { let { next: n, element:acc, done } = ana(value); let { next, element } = ana(n); // not a monoid while (!done) { acc = cata(acc, element); ({ next, element, done } = ana(next)); } return acc } } // unbaked unfold for flexibility const downToOne = (n) =&gt; n &gt; 0 ? { element: n, next: n - 1 } : { done: true } // unbaked fold for flexibility const product = (acc, n) =&gt; acc * n // these are equal according to ana followed by cata: const res1 = foldWith(product)(unfoldWith(downToOne)(5)) const res2 = hyloWith(product, downToOne)(5) console.log(res1 == res2) I should mention we don't enforce an empty element here ([monoid spec](https://github.com/fantasyland/fantasy-land#empty-method)) so there's a bit of awkwardness trying to pair the first two elements while folding. If we did so, we'd always have a return value and wouldn't blow up on empty structures.
I'm finding that I actually prefer gradual typing over baking types into the language (a big reason being the one you mention, in terms of being able to iterate on the type system almost independently of the underlying language)
I've dabbled with session storage (same as local but expires when the tab is closed) and I used string manipulation to have multiple values for a session I'd, so for example (storageID, item1*item2*item3) and use split to get the array out. Reason I did this because storage requires a string and I was storing an object so stringified it for storage 
`let` me tell you a little something about that...
I recommend using IRC. There is a huge support community for not just javascript but everything else as well. #javascript on the freenode network. (Currently over 1200 users in chat)
Some suggestions to make the code a bit more readable. Rather than using `document.getElementById` and similar long methods, you can use `document.querySelector` and/or `document.querySelectorAll`[1], [2] with css-style selectors. To make things even shorter, you can wrap these up in your own short one-letter function: function q(sel) { return document.querySelector(sel); } var birthday = q('#birthday'); Generally, `innerHTML` is not a good idea unless you want to insert actual html (this is dangerous because if you populate it with external content, an attacker can inject a script into your page). Instead use `birthday.textContent = ...` which will be safely inserted by the browser. Date formating is a bit painful in javascript. I recommend using a small helper library for this that will make your code much easier to read/understand/maintain. Check out [3], [4]. [1] https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector [2] https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll [3] http://stevenlevithan.com/assets/misc/date.format.js [4] http://blog.stevenlevithan.com/archives/date-time-format
I'm not a big fan framework specific CLI's. Why should you have to learn a new CLI for every framework you use? 
Hey man thanks for helping. I actually always use querySelector i dont know why i used getElementBy there. Thanks for the suggestions i will take a look. 
/u/rauschma explained why JS is not versioned this way, about two years ago: http://www.2ality.com/2014/12/one-javascript.html Also, Firefox (and Netscape before that) supported versioning in the [`type` attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-type) of a `script` element, but it didn't work out so well.
This type of thinking is the reason why Donald Trump won
That is beyond ridiculous. Trump didn't win because someone called someone 'bro' on the internet. You're saying things that are beyond absurd right now, /u/drunkenfaggot
It'd be a lot easier for us to help you if you post the code online. Here are a few places that let you host it for free: * [Codepen](http://codepen.io/pen/) * [JSFiddle](http://jsfiddle.net/) You should also include any required HTML (which I can see is missing in your original post).
http://codepen.io/alboz/pen/ObQvpg here is the codepen link
You are interacting with people from all over the world, with very diverse cultures, sexual orientation, age, and beliefs. It should be in the interest of everybody to find a common ground where it is possible to avoid this kind of discussions about something that is of very little value in the context of javascript programming. While not offended at all by the term "bro" (that I know exactly be a friendly term to connote the membership in a group of young males), as a 40 years old european cis male I would prefer to not be called with that term. And I would love to keep all this personal details about me untold, since unrelated to the reason I am here reading and writing (mostly) about programming. In the end it is just a matter of simple common sense, and good manner. I don't think to have asked the moon. Remember that the internet is not an american of english property, and while I understand and accept that the dominant language is english, I don't accept that also the dominant culture has to be the american one (I found english people to be usually more polite). If you really want to keep calling me "bro", keep doing it. I really don't care (apart the time lost reading and writing those messages, that is unfortunately gone). If instead you can manage to step down from your superior "bro" american culture for a moment and respect me as an internet citizen, I would say "thank you", and happily get back to my duties. Have a nice day, night, or whatever it is now where you are, "bro".
I'm more encouraged than ever to say 'bro' now. People choose to get offended by whatever they want. Some things are *truly* offensive, like racial slurs and deliberate personal attacks -- this isn't like that at all. This is totally your choice to make it an issue, and I don't give a shit. It's stupid. It's a stupid thing to be upset about. And I'm going to keep saying it. You can't just arbitrarily make up things to be offended by, I don't care about that stupid game. I'm not playing it. For what it's worth, I interact with plenty of adult Europeans daily who enjoy the camaraderie of being called 'bro' and 'brother' and engage in that culture with me. So you've got a very niche reason to be offended right now.
Where do I chuck my HTML? No client/public folder I'm also not a huge fan of mixing in PUG/Jade with what should be a MEAN stack.
I guess you mean the other two even failed the tests I cherrypicked, didn't focus on keeping consistent with React, missed more stuff in React, and claimed they can be a drop-in replacemenent for React.
Probably a controversial one, but the ability to affect the Garbage Collector in some way. Even something as simple as being able to explicitly prompt it, or prevent it, would open up a lot of doors for performant realtime applications/games.
That must be why companies like Facebook, Google and Microsoft create, use and develop things like flow. They are just Java guys that can't understand Javascript.
I have been working for the last several years on a very large single page app. A few principles underlie my thinking: * Functional is better. Functional code is easier to reason about and ensure the correctness of. * Managing state is the core problem of UI programming. * State is most readily reasoned about functionally, using reducers and actions. * View/Style/Logic (i.e. html/css/javascript) are leaky abstractions. The separation they provide is an impediment to developing modern SPAs. They unnecessarily fragment your code and create impedance mismatches between the scoping, reference and dynamism rules of each different language. * Unifying everything underneath js/require allows you to properly modularize your assets. There is no reason to have an 'assets' folder that you cram all your images in. If you use a banner image, store that with your banner component. 
It's not exactly a big challenge to slap a bunch of words together and then change subject in the middle of the sentence...
Sorry perhaps I wasn't clear. I'm using inline styles for everything, like this: function Panel ({props, children}) { return ( &lt;div padding='50px' color={props.color}&gt; {children} &lt;/div&gt; ) } Or to implement it in a more general way (which is how I usually do it in practice): function Panel ({props, children}) { return ( &lt;div padding='50px' {...props}&gt; {children} &lt;/div&gt; ) } In either case, you'd simply render it like this: &lt;Panel color='blue' /&gt;
It'd be way more honest if you ran the entire react test suite for all libraries. One could conveniently cherrypick only the tests that Inferno pass or only Preact pass, but because that means leaving out inconvenient truths, the entire exercise is meaningless. By cherrypicking you can make the "data" look favorable to whoever you want and that isn't very scientific. If it's easy to spot holes in the objectivity of your methodology just from a cursory read of your post, that can damage your credibility. Just saying.
But it should be the secret AI shared only among software engineers. Nobody should know. We would organize a very clandestine society, VCS, for this purpose, and call him Grit. So it would be easy to talk about keeping everything concealed.
Shit, you did a better job speaking about Flow than I do... and it's my job to talk about Flow.
This is hilarious but...agonizingly slow. 
Sampling survey：imagine there are 1000 tests in React, we randomly pick the 100 tests, run them with library A, B, C, and the results are 80 passed, 70 passed, 60 passed, can we say that A is better than other two? Sampling survey：imagine there are 300 tests about public API in React, we try the best to pick all the tests and now pick the 173 explicitly, run them with library A, B, C, and the results are 173 passed, 87 passed, n( n &lt; 87) passed, can we say that A is better than other two?
Didn't read it. But still no. There's no "best". There is best for me, my team, and this project. 
I agree with you. 
Nailed it, have to add some logic to check the month/day it currently is and the month/day the users birthday is on.
`map` is not an iterator, it's a transformer. I'd expect `Object.map` to return an `Object`, `Date.map` to return a `Date`, `Promise.map` to return a `Promise` and so on. Iterator makes no sense for anything other than collections. Ultimately, something like Fantasy-land (but more usable and more accessible) across the board would be neat. For iteration, `for of` fits the bill, but it'd be useful to have an expression version of it.
Having worked on JavaScriptCore for years, and the TC39 committee i can tell you that these "minor" issues you talk about are not minor. I've encountered issues where changing the whitespace formatting of function.toString() broke multiple major sites. There was a period where having a 4 in the UA string broke the majority of complex sites (userAgent.indexOf("4") &gt; 0 means you're netscape 4, right?). Sites /are/ broken by 'let' -- that came up in webkit nightlies which don't have massive real world usage. There were a bunch of changes to the Object, Math, and String prototypes that broke at various points: jquery, dojo, yui, moo tools, prototype, ... Those libraries are also the reason why Arguments cannot even have the Array prototype, let alone be an array. As far as versioning: just strict mode has caused myriad issues due to things the most basic things (say source concatenation), as well as other issues due to interacting semantics between strict and non-strict code. More versions would exacerbate this.
Frankly, I would split this up into bite sized chunks. To much at once is a recipe for frustration. Start by simply opening a browser, hit f12 and pull up a beginning tutorial on Javascript, using your console as a REPL. Once you're confident with the language with core programming ideas, what looking at IDEs and seeing what they can provide you to simplify your programming experience. Unity is its own ball of wax, so it is helpful to have a strong command of the language going in so you aren't struggling with a language and a framework at the same time. Keep in mind that even if you aren't able to start with unity, you can still write games. Check out games like "rogue-likes" or even Zork. These are games which can help you understand the foundations of game design as you apply language learning. You can actually make games like these without any framework at all. Anyway, good luck on your journey! Keep us posted on your progress. 
Yeah this is the answer, it runs in a separate process and isn't written in Javascript like the rest of the Discord web app.
The article is just words with few arguments to support what you're saying. &gt; Nevertheless, jQuery still makes it much easier to build dynamic websites than using vanilla Javascript Makes it easier how? I would actually be interested in reading someone's opinion on what value jquery's imperative approach provides today (not to say that it doesn't), but unfortunately you don't expand on that statement. &gt; Facebook uses traditional Flux, probably for legacy reasons. Wow, that's a bold statement. Poor facebook. &gt; [...talking about redux...] This simple idea leads to many benefits over traditional Flux: running on the server How does flux prevent you from using it on the server and redux doesn't? There's even a whole talk about ["full-stack flux"](https://www.youtube.com/watch?v=KtmjkCuV-EU) &gt; MobX is more flexible than Redux ...And you don't even mention that it's a totally different paradigm from redux. Basically, the article looks like you're giving a non-technical review of the front-end world to someone who's just superficially interested, maybe to a friend who does backend.
[Brunch](http://brunch.io) does this, actually. I prefer it over Webpack for its overall hassle-free configuration.
nope didnt think about it i just copy pasted all those select element from a generator 
I have found that when posting on StackOverflow, you need to make your question easy to read and as simple as possible to understand If it's too complicated then people will just leave it. Also try to recreate your problem on jsFiddle or CodePen to show an example of your code working. This way people can edit your code and provide a solution
Would you mind explaining why you don't want more syntactic sugar? Personally I feel that any language feature which allows me to write code that is easier to read and parse for humans are a welcome addition to any language.
Thanks for the tip!!
Words are easier to read and understand than symbols. I'll take function expressions over arrow functions any time.
That is the ultimate compliment! Thanks 😊!