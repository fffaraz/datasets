Each new level you reach adds one new bit to the possibilities. That's why you can reach numbers like 18xxx. I'm quite new to bitwise operators myself, so this feedback is great. How would a combined operator look like? 
Hey Gacnt, I assume what you mean is draw an overlay on a full screen application / game? If so, I've done it several times before. What you're looking for is called 'hooking' DirectX/OpenGL. The idea is you intercept calls to key DirectX/OpenGL functions (EndScene was the DX9 function if I recall), run your code, then resume the normal flow of execution by returning to the function you intercepted. You do not need to write this code in C/C++, however, some portion of the code base needs to interact with OS level features. In my projects I only wrote a small portion in C++ (to bootstrap the Common Language Runtime (CLR) inside remote processes) and the rest of it was written in C#. I think it might be easier to stick with C/C++ though. Cheers
Damn now you've really made me curious... Is there any drawbacks to inline styling as far as performance goes? 
64bit is coming
This looks pretty interesting, is this your work? I think the readme needs to be more descriptive, is it for distribution, encryption/security or both? 
ADT, pattern matching, non-nullable types.
Thanks kindly, so would I need to write all aspects in a different language or could I use Cpp to make my Electron app appear over the game / program 
I also pushed images for raspbian to docker hub, if you want to use it on a raspberry pi.
The documentation will be kept up to date when something changes. However, some information are a little bit spread over multiple pages. If something is not clear enough, you can always ask on SO or in the slack channel. 
Sorry it's being slow for you. Was it the initial load or the generator?
I guess it's kinda bad for countries with really shitty mobile connections. Aside from that you're right. 
Is that a good thing really? I get the sentiment about converging to one language, but please God don't make that one language JS. 
Out of curiosity, where would you use lazy protocols in real life? I understand their benefits and all but I never came across a situation where I felt i needed them
Hmm... looks like, even if some could not be written in javascript, it still will.
Still need to write the readme. the folder mounts are `/usr/local/deepstream/conf`, `/usr/local/deepstream/lib` and `/usr/local/deepstream/var`. its best you use the original config file from the container as base config. you can easily grab it `docker run --rm -it deepstreamio/deepstream.io-raspbian:2.0.1 cat conf/config.yml`
That isn't going to prevent people from doing stupid things to make it run incredibly slow. This (any) performance boost can only be realized if you write proper code. Sending a 2mb backbone model with a bunch of unnecessary fragmented events across the wire will continue to execute slowly regardless of awesome performance updates.
Another way around this is to not use anonymous functions: var board; //2D array that is filled on setTerrain() var Game = function Game() { this.playerOneTeam = new Array(); this.PlayerTwoTeam = new Array(); this.queryBoard = function queryBoard(x, y) { alert("hello"); alert(board[x][y].terrain); } this.gameLoop = function gameLoop() { $(document).on("click", "td", function() { //Pass cell coordinates to a function as type long, not jQuery objects var x = this.cellIndex; var y = this.parentNode.rowIndex; alert("hello"); queryBoard(x,y); //alert(x + " " + y + " " +board[x][y].terrain); }); } } var game = new Game(); game.setTerrain(0, 0, "land"); game.redraw(); game.gameLoop(); I'd definitely read up on Javascript function scoping, as mention by /u/mikrosystheme . MDN has a [good entry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) on `this`and there are plenty of talks about it on Youtube.
Goodness you're totally right laziness ftw! That means hyloWith can be defined, without losing any performance as simply: const hyloWith = (cata, ana) =&gt; x =&gt; foldWith(cata)(unfoldWith(ana)(x)) Thanks for the great post!
Not sure what you think would be a better option. Every language has shitty parts to it.
You're correct the JavaScript interpreter doesn't need to transpile es6 to es5, as it just interprets the code it's given. People only do that to support browsers that don't have es6 support. There part where they were talking about transpilation I think they were just saying that their implementation of certain features had been slower than the es5 code that transpilers were outputting for those same features. Unless you meant the part where they were talking about compiling, in which case, didn't know that either. It's really cool that it runs the interpreted version first, and then compiles the pieces it determines it's worth it for.
When looking on ES2015 graph performance, how we can get insight about ES6 performance? And "ES6 will be faster" means: faster than before or faster than not ES6? I mean, thank you for the news, but title is confusing. It should be something like "new v8 version is much faster then previous" or more details about ES6...
Still hope to see fast native promises (and async/await) one day. For now, Bluebird is just ridiculously faster
Thanks. Great explanation.
thanks
Have you used all the major frameworks for at least one major project each?
Native promises are much faster now in V8. If you have test cases that shows otherwise, I'm happy to look at it.
Something with at least optional types would be nice.
But that requires people understanding floating point, which they clearly don't want to. We should make it another thing: typeof NaN === "totes not a number" :-D 
To be clear, they're not strings :D I think the bigger issue is shared state threads vs. message passing in general.
http://www.regular-expressions.info/quickstart.html has everything you need.
What do you mean by class properties? &gt;&gt;&gt; class Foo { ... static get prop() { return 5 } ... } class Foo { static get prop() { return 5 } } &gt;&gt;&gt; Foo.prop 5 &gt;&gt;&gt; Or do you want to be able to have simple non-accessor based syntax? (There are good reasons/trade-offs for purely accessor based syntax) 
Well more kudos for building this then! if(num &amp; (1 &lt;&lt; 5)) { it's a very common technique for storing lots of booleans. It's called a bitmask if you're curious
Yes, JS is Turing-complete in application - so is "NAND". Both still suck as being your convergence target, which is kinda the point: &gt; get the sentiment about converging to one language, but please God don't make that one language JS.
Bluebird maintains benchmarks, as does creed. At least the current versions of Promises in node are much slower than something like bluebird. https://github.com/briancavalier/creed/blob/master/perf/README.md
I have been looking at the bluebird benchmark. The bluebird benchmark uses non-spec APIs (like promisify), so it's not really comparable. Also bluebird isn't ES6 spec compliant which V8 has to be. But nonetheless, bluebird is still slightly faster, not "ridiculously faster" like OP suggests. Also, there is still work being done on native promises, so it will be getting faster.
I find the main changes are actually in ES2015 rather than TypeScript which just gives some nice shortcuts and of course types. I'd probably just refer to [Todd Motto's styleguide](https://github.com/toddmotto/angular-styleguide) and utilize Typescript where you can. 
Will it support Windows?
https://tc39.github.io/proposal-class-public-fields/ https://tc39.github.io/proposal-private-fields/
Really dig this. Love the docs. We'll done! 
Where does Bluebird break the ES6 spec?
im subbed to a bunch of car subs as well as this one and the title got me all confused for a second 
I dont know if it is a good thing. I was loosely referring to https://blog.codinghorror.com/the-principle-of-least-power/ But at least Javascript has relatively low entry point. ;-)
Theoretically, yes it is a bit slower. However, in practice I have never encountered that to be a problem. We have a very large SPA, and we do 100% of our styling this way. If I had to guess, i'd say it makes things maybe 5% slower than they would otherwise be. But since vdux is a very highly performant vdom system to begin with, this never becomes an issue. Another neat advantage of this approach is that dynamic styling is no longer a different type of thing. If you want to programmatically change a style in response to some event, it's just the same as regular styling. Styles are just data and variables like everything else.
Its amazing how far we've come with a language 'designed' as a weekend hack. Imagine if this much effort had been spent on any other language, the state of computing would be so much further.
But, TypeScript compiles into JS, doesn't it?
React isn't a framework, its just a view library. Redux/Mobx etc are even less, they just manage state. Angular/Ember are proper examples of a framework. If that's your site, it has nice content.
Regexr.com allows you to check your pattern and matches in real time.
Optional type system has nothing to do with what it compiles to
I created a multiplayer version! http://ox.mybluemix.net 
Problem is, too many "serious" languages are bureaucratic as fuck. They did spend that much effort on Java but no one likes it regardless because it is verbose as hell. What is needed is a well designed language that is not verbose. Kotlin is one on JVM that comes to mind, too bad it is not better known.
Thank you much appreciated
Thanks for that, I think that's all I need right there!
Java is not really a good example though. There are many modern languages which have been designed after lots of research into best practices and support modern techniques for concurrency etc, not the mess we have in JS/Node - e.g. Dart, Go, Clojure, Erlang etc etc. JS has nothing special except the fact that by an accident it has become popular and runs everywhere - that doesn't make it a good choice. Of course now we are forcing all sort of features into JS it was never designed for - async/await, types coming soon, etc. All of which are first class features in a proper language. 
I think that there are some plans for concurrency, but you'll have to ask someone else. As for semicolons, it is rare thing that you need multiple statements per line, so using new line is more natural thing.
I think its fine, at least whitespace is allowed unlike python. And what bugs me about JS is ; are optional so you'll see some people mix styles which is just crazy.
Say you receive some JSON from your server, with an `user` object. After several months, you decide to add a property to the `user` object. Dynamic typing allows you to utilise this new property where it's needed, as opposed to updating every single user-related view etc with new type definitions. I can't speak for anybody else, but the amount of time I've spent maintaining types (in classical languages) due to small changes like this far exceeds the amount of time I've spent finding type-related bugs.
For custom types (like a `user`), you'd typically have a global interface, so you should only have to update it in one place. If you're rewriting your types every time you use a class instance or common object/entity, then you're doing it wrong.
I thought the `.onreadystatechange` handler was usually set *before* calling the `.send` method.
Generator. 
I often hear people ask for optional types, but I also wonder how this would work in practice. JS's dynamic nature makes it amazingly easy to polyfill and lazily link things together. For a web that progressively moves forward, I'm not sure how static types would really play in. I would love to hear thoughts about this :)
I use flexbox for anything better than IE9. There are only a few things that the latest browser's have issue with, but I've never run into those problems. On the Angular 2 side, you can always use JavaScript. It doesn't have to use typescript. In fact, I like JavaScript better because I don't have to switch language contexts between nodejs and angular code, but that's just my opinion.
1996 called it wants its OH NEVERMIND
What are you trying to say? I really don't get it.
Just do the second part of this suggestion and you'll be fine. 
I worked in sales for 6 years, taught myself to code and turned that into a job about last year. I'm not gonna lie, it was tough to get interviews because my work experience was all sales, but I got a few and of course eventually a job. I just made a bunch of projects myself- a chat app, a little home run derby game using JQuery, etc etc etc. I put them on GitHub and my resume just talked about them and gave links.
On your network tab, inspect the network request. It will show you the payload being sent. It is impossible to tell from the screen shot you provided if the payload is being sent or not. If it is, then something in the PHP code is dropping it.
Looks like a combination of JS Waypoints and Parallax applied to certain elements/letters/etc
To add an anecdotal account to this: I recently entered the field. I've gone through two technical interviews in the last year (internship at one place then hired as an engineer at another). During both interviews, people asked me about the first project I ever did on my own and put up on github despite it not technically being the most impressive thing on there (which I thought was interesting).
This a million billion times over. I cannot stress how important it is to learn vanilla JavaScript. I've interviewed so many developers that consider themselves front-end devs, but fall flat on their face when I ask what the differences are between const, let, and var. Most front-end devs I've run across are simply good at plugging libraries together without understanding the fundamentals behind the libraries.
Hi /u/Nyl000, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
A good way is to get detection in the backend. Simple redirect to a mobile or desktop site (with link to desktop site) and you're good to go.
+1 for nodes :) 
Angular 2 is playing catch-up with Vue. It is great for enterprise teams, not so great for solo developers or small OSS teams. 
Personally, I recommend the bootcamp route (Dev Bootcamp). Best decision of my life: http://hi.devbootcamp.com. I found a high paying job in weeks with a startup in the bay area and have been learning non-stop (highly recommend startups if you want to keep learning rapidly).
To get your foot in the door, do some projects that use React for all the front end. Follow one of the tutorials to do say Todo MVC and then use that knowledge to make something new. Once you have that going, watch the free egghead series on Redux and try using that in your new app (might be best to start over from scratch or do a different app). Try using NodeJS as your backend. Even if you don't end up on a project that uses it, it's good experience. Make sure you use webpack and ES6. Find a boiler plate and use that if you need to go get started. Don't spend days trying to figure out webpack or any other piece, it's easier to start off cheating and it'll become clearer over time or you can go back and revisit it. A lot of people seem to get bogged down in the details. It's much better to focus on the overall picture and keep taking slices through it. Which means sometimes just deleting and starting over again (a lot of people are afraid to do that but they shouldn't be). This is what you should do if you want to get in the door. Also, you don't have to do everything from scratch. Try using React components you find on npmjs.org. Try using a bigger project of components -- React-Bootstrap is a good one to try because later on, you can take a look at how they do component composition. They also take on new contributors so it's a good project to practice your skills on (including how to be an open source contributor, etc).
To me, JS is a guilty pleasure. It's fun to code because the language is so lacking, unopinionated and dynamic that people have devised all sorts of interesting ways to overcome it's shortfalls. Put together with clunky DOM APIs, it's like the wild west of code. A perfect incubator for patterns. But if we are talking about the future of programming, it probably shouldn't be the leading star.
where do startups look for new hires?
[You Don't Know Javascript](https://github.com/getify/You-Dont-Know-JS) can help a lot. It goes into why things are the way they are and how it can differ from other common languages. As for react/angular learning, make sure you use the John Papa style guide for Angular and the Stephen Grider course of React on Udemy.com is one of the best. Make sure you commit your learning examples to github, and get a portfolio site up and running.
having not worked in a team, i have trouble imagining how developing HTML as the viewer of mvc would impede any of the other components (db and control).
hadn't heard of angellist, thanks!
In the last part of the castSpell function, call $('#gametable td').off('click') to unbind the click handler. Alternatively you can attach the handler initially using the '.one' method, which will automatically unbind the handler after it has been executed once.
If you want to write something close to vanilla JS, the last framework Id expect someone to mention would be angular 1. Something like Aurelia allows you to write pure es6 classes, no need to learn Angular's cryptic microsyntax. Do I need an isolate scope here? Does this go in the link or the controller? Shit, I added some $watch and my digest cycle just took a shit. Also, it's dependency injection solution solves a non-issue, we already have require(). The list goes on. Don't get me wrong, angular is powerful and worth learning, but it isn't vanilla JS. 
&gt;That comment has been updated from release to release. I've seen this comment, too, but it is not very telling, isn't it? Do you know more about what they're referencing to? &gt;For example, in PhantomJS v1 typeof a regexp is "function". This is so weird. PhantomJS has used V8 (for v1)? 
We don't do that 'full stack' nonsense; server-side and front-end are so different so we have other people to wrangle with JS/CSS. 
It kinda happened, started at the company as technical front-end, some changes in workforce left a gap in the python group and I rolled into it and got hooked on python. It is extremely expressive and productive, especially with django. I still dabble in node.js but is is painful and annoying for anything substantial. 
Usually a salt is autogenerated and then stored in plain text on the hash, which the hashing algorithm then uses automatically - you don't normally need to provide it yourself. Often you'll see hashes with sections separated by forward slashes or colons, which might be in the form of: `hash_algorithm:n_iterations:salt:resulting_hash`. If you were previously given the option to provide your own salt, hopefully that was in addition to the automatically generated salt the library already provided. You may be able to provide your own additional salt in the bcryptjs config somewhere. The purpose of salting hashes is to prevent rainbow-table attacks (where the attacker has a big list of hashed strings and simply performs a lookup on your hash), and even stored in plain text on the hash it still fulfils this goal. Salting doesn't make the encryption method itself any more or less secure - in fact, using the same salt on each hash makes it much less secure, because then the attacker only needs to produce a single rainbow table with your provided salt for your hashes to be vulnerable again.
Took me four years to get my first Dev job after finishing uni - went to many interviews and eventually turned job hunting into a routine (was making myself send at least ten applications off a week, so by the time I got a job I knew i was into triple figures in terms of what applying). It turned around for me when I stopped *reading* and started *doing*. Here is the approach I would take if I were you; * Become confident in js * pick a framework out of angular, react and vue * build a todo list app using that framework (put it in your github) * once thats done, pick a cool api or two from programmable web. Nasa have a good one. * Build a web app around that api * put it in your github At this point I think you will be able to walk into any junior js job you want. 
I definitely agree with 3 - that's not just a consultancy problem but a general "smart people" problem. Smart people like to sound and look smart. This often seems to be more important to them than doing things right. I would hope 1 and 2 aren't true but sadly I'm sure they are. I have little experience of consulting though.
wrong sub
which frameworks?
I made some tools for triangulating shapefiles and geojson: * https://www.npmjs.com/package/earth-mesh * https://www.npmjs.com/package/pack-mesh With these tools, I made some webgl globe demos and wrote a tutorial: * https://substack.neocities.org/earth/mix0.html * https://substack.neocities.org/tutorial/vglobe/
Learn everything about computing, programming, algorithms, systems. Move on to HTML, vanilla JS, study browser internals. Then study jQuery, then Backbone, then Angular 1. It's not enough to know events, callbacks, attributes, whatever. Frameworks are fleeting, but the fundamentals are all the same. There's a reason why everyone is moving to modular components. Plus you'll be able to destroy every interview you get. Don't stop coding.
Anyone have any opinion on how this compares with momentjs?
Aaah cool! That seems useful. I'll try to find time to build it into the test
Good job, mate! You really had a flow while talking about flow.
Ng2, React and Vue.js. Maybe one of the drop-in replacements for react will also gain more traction
&gt;a more complex structure containing the type of the object I am not sure the given example of `5 -&gt; [ 5, 4, 3, 2, 1 ]` really reflects the usefulness of this concept. Aren't there some interesting real life examples like containers encapsulating the original object with some UI-related meta-data added? That wold look exactly like more complex structure containing the old one and would possibly make a more convincing case?
Aurelia, IMO
I would place my bet on [Angular 2](https://angular.io/) you can also start an [Ionic Framework](https://ionicframework.com) app project, as the are build on top of Angular 2.
Be careful with this though. Your interviewers can see all your code and if it's crap/dodgy it will work against you. Supporting anecdote: In a recent interview for a junior dev at my company, it was noticed beforehand that one of the GIT projects contained folders named "Dave's Project" and "John's Project". In the interview we asked him "Why do you have these folders in your project?". Interviewees face looked horrified, they stumbled out the sentence "I didn't realise I had checked that in..." and proceeded to fabricate an excuse about how his friends had asked him to review his code. Of course we all knew the truth that he had been "borrowing" work from friends and passing it off as his own.
This is important to me. 
Don't waste your time in the beginning learning jQuery. People are moving away from it. Learn Angular 2 and React. Make some project at home. Do you have anything you want to try doing? Maybe get a friend to join in.
I don't see React going down, looking at the whole ecosystem, it will take a while to move away from it, and Fiber is getting released in 2017 which is a big milestone for React. Preact also gets a lot of attention in the React community. As an alternative to React, Vue.js looks nice. Although it's hard to see if there will be new libraries and concepts in 2017.
What are your friends goals? Is he trying to get a job or is it just a hobby? What kind of job does he want? Is it a case of any will do or does he want to work with cutting edge or flavour of the month technologies?
I was thinking the exact same thing
I rate the whole view layer with state management paradigm won't be going anywhere any time soon. React is still the most versatile view layer with redux being the go-to for state management. Having said that, cycle.js also looks really promising, and I'd suggest checking that out too.
No, I tryied but doesn't work anymore :(
Is it hosted anywhere? EDIT: If not, since it's client-side only, you could host it on [github pages](https://pages.github.com/). If you're not familiar with gh-pages, it's super easy to set up and has _mean_ delivery time. Of course it's also totally free :) EDIT2: Are you serious? This is awesome! Well done, yo. Also TIL about Mr. Woodnote, this song is BAAF.
Where would you recommend to learn the basics?
Hey, it works for me. This is the file I'm using: &lt;html&gt; &lt;head&gt; &lt;script type="text/javascript" src="http://spin.js.org/spin.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var spinner = new Spinner().spin(); document.querySelector('body').appendChild(spinner.el) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Save that as `spinner.html` and then double click it, or somehow open it with your browser. If that works for you, you can work backwards to get it working in your app.
Apparently it's more functional than moment.js. It's just a set of functions that work on a standard date object, while moment.js has its own wrapper.
If you're remotely comfortable with JS or coding, then something like https://nodeschool.io is probably best.
Kyle Simpson's book series *"You Don't Know JavaScript"* is pretty great and will give you a solid understanding of the basics. Personally, I much prefer reading **[printed books](https://www.amazon.com/s/ref=nb_sb_noss?url=search-alias%3Dstripbooks&amp;field-keywords=kyle+simpson+you+don%27t+know+javascript&amp;rh=n%3A283155%2Ck%3Akyle+simpson+you+don%27t+know+javascript)** to get away from the computer screen for a while, but you can also read **[the books on GitHub](https://github.com/getify/You-Dont-Know-JS)** for free. My only criticism of the series is that, at times, the author reads a little opinionated and passionate, which is kinda silly when studying technical books on code, but it's easy enough to ignore.
I recently ran into this and added a preinstall script that looks like this: 'use strict'; // Detect if run by NPM and fail if (process.env.npm_lifecycle_script) { console.log(` This project recently transitioned to using yarn (https://yarnpkg.com/) for package management instead of npm. The build servers use yarn, so developers should too. Basics: $ see yarnpkg.com for installation of yarn $ yarn install To install a new package (also adds to package.json): $ yarn add [packagename] To upgrade a package: $ yarn upgrade [packagename] For more help, see https://yarnpkg.com/en/docs/usage. Reasons for this change: - yarn uses a dependency lockfile by default, allowing for a fully reproducible build - yarn is faster to install dependencies from scratch - yarn has more secure checksum matching, ensuring package contents are consistent `); process.exit(1); } 
While not exactly what you're after it could be worth checking out https://polyfill.io/ and their code. They have a list of browsers against features here: https://polyfill.io/v2/docs/features/. You can see the data they have for each feature on GitHub: https://github.com/Financial-Times/polyfill-service/blob/master/polyfills/Number/isInteger/config.json I'd imagine you could combine this with a parser like Acorn and get something running. Not sure if there's anything that does this out of the box though. As an aside, polyfill.io is a great service that almost means you don't need to think about polyfills.
I recommend reading "JavaScript the good parts" by Douglas Crockford. Although that will not introduce you to ES6. Also make sure you know what ES6 compiles to when using babel is useful for understanding them. Not all, but a lot of stuff in ES6 is just syntactic sugar.
Awesome! Couldn't find it while desperately comparing the libraries. Do you have any intention for a similar library four purely manipulating + applying durations? Concepts of "1 week" is nice but things get spicy when you have to crash against a calendar (straight milliseconds won't work) like for months/quarters. 
I can confirm, this is industry standard for password hash storage.
No plans for a separate library for durations right now, but it can be a part of date-fns. We discussed it a long time ago but hadn't decided on API. How do you imagine the perfect API for durations? If you can, please create an issue about that here: https://github.com/date-fns/date-fns/issues It will receive more attention there, and if it is an anticipated feature, we will take it into development sooner Edit: created an issue https://github.com/date-fns/date-fns/issues/284 Please post your suggestions for the API
nuh uh!
Maybe I'm missing something, but on my local instance of yarn, if I have something specified in my package.json that isn't in my yarn.lock, just running yarn is enough to install it, even if it wasn't in the yarn.lock (and then the yarn.lock is updated)
This was excellent help. I flipped the filtering, as this was taking out the match rather than retaining it but otherwise I've done some extra reading to fill in my knowledge gaps and can see what this is doing. Very much appreciated. 
https://nodejs.org/api/process.html#process_event_unhandledrejection ?
With such a stack, you can give up with your performance tools. If you touch something, it will break something else. There is only one solution: resign and look for a better company.
I like it! Keeping everything as a `Date` is definitely the way to go, and one of the big things that makes me question it every time I think to use momentjs. Moment's a great lib, so long as you're interested in managing your Dates like strings, but `Date`, and especially [`Intl.DateTimeFormat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat) make it far nicer to use unwrapped objects. I will point out that, while you describe it as "lodash for dates", like lodash a lot of this can be done quite simply using pure `Date` objects and es6+ syntax. e.g. the example in your README.md: const dates = [new Date(1995, 6, 2), new Date(1987, 1, 11), new Date(1989, 6, 10)] dates.sort(dateFns.compareAsc) Could be easily replaced by dates.sort((a, b) =&gt; a - b); Since Date implies a `getTime()` here, so you'll get an int in the results. I do think that we ought to be using something better than momentjs these days. It was a great library but the spec has come a long way since. Just like jQuery used to be one of few good ways to query the DOM, the standard caught up and now it's nowhere near as useful, so I'm feeling the same things happening with momentjs. I will say to anyone looking to use your lib: think about internationalization sooner rather than later. It still takes a bit of shimming for those old Safari 8/9 devices, but if you're manually tossing a bunch of `MM/DD/YYYY` formatting strings in, peppered through your code, you're going to have a hell of a time making your dates readable in other regions. You definitely don't want a bunch of people showing up for an event on Nov. 9th because they didn't know you actually meant Oct 10th. With `import` and all our nice bundlers/module loaders these days, it's a lot simpler to setup your date-formatters as constants in one module to use elsewhere. const options = { hour: '2-digit', minute: '2-digit', timeZone: 'UTC' }; const brits = new Intl.DateTimeFormat('en-GB', options); brits.format(new Date()); &gt;&gt; "14:55" const yanks = new Intl.DateTimeFormat('en-US', options); yanks.format(new Date()) &gt;&gt; "2:55 PM" Yes, I know there are ways you _can_ do this in some libs, but when it's built in to the ECMA standard, it's better to choose that first.
"The ‘for’ loop will finish before the callback in the click event can register the appropriate i value." Maybe I'm reading too much into this, but I feel like this would lead a reader to believe that the for loop executes too fast and hence the reason you use the wrong value for "i" when it fact it has nothing to do with the speed of the for loop. What is actually happening is since var is function scoped, all the callbacks are bound to the same "i" value so when the click event is executed it will check it own scope (aka the callback's scope) and realize there's no "i" then check it's parent scope and find the "i" and so it will always display the wrong the value since the "i" was incremented to the locations length. 
Btw, this did the job, thx. one question though...matching_articles has same number of entries as the original, but only those which match would have content, the rest say undefined...so i still end up with an array.length of 20 (assuming the original array was 20) when the actual result was say 2. Is there a way to correct this as I would like to return something like 'Your query returned matching_articles.length results ' 
No support for time zones, which can be pretty important. 
React is going to stay strong.
I'm just commenting because [there's a screenshot of my reddit post](https://cdn-images-1.medium.com/max/666/1*B7LZhoWqkfy8QDNR9odMNw.png). &gt;The article and the threads it started were so disappointing to read. &gt;There wasn’t a single productive thing about it. No positive outcomes to be had. It was a group of people ganging up together so they can yell about how frustrated they are for a little while before moving onto the next thing. Welcome to reddit.
First off, that's XML, not JSON. Secondly, you'll have to write some code that goes through each article. It will check to see if the array (that you create) already has an article by that title. If it doesn't, it'll add it to the array. If it does, then it needs to count the words/characters/whatever in both to compare them, then replace the one in the array if necessary. If that doesn't help you write the function you need, I think you should take a basic (free) course on programming and learn how each of those steps are done.
Crossposting [my comment](https://medium.com/@jim.bolla/perhaps-we-need-communities-subreddits-etc-that-are-moderated-by-leaders-in-the-oss-community-2a28eabd5572#.l8w62wug1) for visibility: &gt; Perhaps we need communities (subreddits, etc) that are moderated by leaders in the OSS community who also have a sense for how damaging the negativity is for us. I personally would love to see some js/programming subreddits with less angry rants, “why’s my code broken”, and “here’s an intro to new ES2015 features when it’s almost 2017” posts; more focused on promoting &amp; discussing new ideas and advancing our craft. 
Really glad to see this! Moment's mutability bothers me and has actually caused me some headache debugging until I realized it
Vue, [Next.js](https://github.com/zeit/next.js) and React will dominate in 2017. edit: too many ands
Can we have `-&gt;` as its operator or is that too similar to arrow syntax? The idea is pretty sweet but dang those pipes are ugly. 
Where are you located (and are you willing to relocate)? What is your education background? My company requires a Bachelor's in a tech field but it doesn't have to be computer science. A lot of advertising/custom development companies group web development into web design so can you use photoshop? Otherwise, any personal project that shows you can build a dynamic front end is useful. Even moreso a project that you used to solve a problem and can show your resourcefulness and creativity.
So if I convert the function call into something that I can set the event bubbling easier like; typeFilterTable = function(){ var typeFilter, typeColumn, i; typeFilter = this.hash.substring(1).toUpperCase(); var savedTypeTableRows = []; for (var i = 0; i &lt; docTableRows.length; i++) { savedTypeTableRows.push(docTableRows [i]); } savedTypeTableRows.forEach(function(row){ var typeColumn = row.getElementsByTagName("td")[1]; if (typeColumn) { var contents = typeColumn.innerHTML.toUpperCase().replace(" ","%20"); if (contents.indexOf(typeFilter) &gt; -1) { /*do nothing*/ }else{ row.parentNode.removeChild(row); } } resetTypeButtons(); }); } var allTypeFilterButtons = typeContainer.getElementsByClassName("filterButton"); for (i = 0; i &lt; allTypeFilterButtons.length; i++) { typeFilterButtons = allTypeFilterButtons[i]; typeFilterButtons.addEventListener('click',typeFilterTable,false) /*OR*/ typeFilterButtons.addEventListener('click',typeFilterTable,true) } then I can set the listener further up easier?, I've tried setting the listener to trickle down from window, the container and straight to the element but I must be missing something because I get the same issue. 
Yea sorry I wrote that wrong. See lewisje's comment for the correct answer.
Would that explain how the event is triggered in the first instance, but not any subsequent triggered events? because would that not stop any event from triggering if the event wasn't bubbling up. Maybe this is my ignorance showing through.
Only go as high as you need to. There's no point adding a click handler to `body` if your `.target` is already contained in a static element, like `#content` or whatever.
Think you meant to reply to /u/stratodyne 's comment: https://www.reddit.com/r/javascript/comments/5gj9um/trying_to_get_my_foot_in_the_door_as_a_frontend/daswmv4/
/r/fossworldproblems/
Here is an example: https://jsfiddle.net/aju39902/
I agree and maybe to recap it, the problem isn't that people are assholes, we already knew that, the problem is one that we created which is that every asshole now has a voice in the community. It is only natural that leads to politics. Right now we are politics with zero governance, perhaps if we included some way to democratize the process of majorly impactful changes to large projects it would at least change the vent of hate to EVERYONE instead of a single person.
You can still use typescript with node.
I hope you try(tried?) snowboarding again. My first day sucked ass but now snowboarding is one of my favorite hobbies. I only started learning when I turned 20 btw.
... Our mods do a wonderful job in their volunteer capacity and don't deserve this implicit criticism. 
I'm still amazed at what happened with Babel. It swung from being the most amazing thing to come out of the JS community, to symbolizing what people hate about JS, practically overnight. Babel is a great example of why people need to think long and hard about the default settings they ship with. I understand why the change was made, but it still annoys me every single time I have to setup a new project.
This is not implicit criticism; there's nothing to read between the lines here. /u/jimbolla proposed an idea that can coexist with existing communities and their mods.
This won't work though. Too many CS 101 students with very vocal opinions regarding things they really don't know much about. There's only maybe five people that know enough about the babel codebase to actually make informed decisions regarding it, for example.
I added "in their volunteer capacity" for a very pointed reason. There's a lot that goes on here that people just don't notice. One of them is a system for quickly evaluating whether stuff is spam. You can help out by reporting stuff you don't think should be here!
This is a great question. I feel that there are two steps to adopting a new idea, let's call it "Foobars:" 1. This is a Foobar, and this is how it works. 2. This is a problem that Foobars solve in a unique and valuable way. I have found it difficult to write a single essay that does both jobs. If I want to explain foobars, I find that incredibly simplistic use cases are necessary so the essay can focus on the mechanism of foobars and not be distracted by the problem domain. Whereas, if I want to talk about foobars solving a real-world problem, I need to focus on what they uniquely bring to the table, and it is a distraction to try explain how they work from first principles. So... I try to separate these two essay subjects. For an example from real life, I have written essays about what decorators are, and I have also written different essays about use cases like how to apply decorators to classes. They essay you suggest is, I think, a good one, but I would write it completely separately and presume that the reader knows what an unfold is, and wishes to know about a useful application for unfolds in production code.
I've updated my post with a JSFiddle of the whole lot. https://jsfiddle.net/#&amp;togetherjs=Vb7nt3oRrR
Yeah they're doing a great job in fighting spam but it's more about the grey content. Maybe we should try to up the baseline a bit and not allow content that doesn't contribute to discussion? "Angular 2 is terrible" should've been removed purely based on its title imo, pure clickbait 
&gt; Maybe the author of this article can't divorce the people from the framework, People get attached to their code. It's human, but it's unprofessional. 
That is an editorial decision that I'm uncomfortable leaving in the hands of the mods. Bear in mind the title of this piece could easily be "Javascript communities are terrible." 
As someone relatively new to js and the community can you give me brief account of what babel was and what happened to it so that I can understand OPs article better? 
By writing an original application that solves a hard problem.
Everyone deserves *constructive* criticism. 
I'm not quite sure what you mean? Do you want to make anything more than an input which simply [evals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval) everything passed into it?
I've always had good luck with https://www.regex101.com for regex testing in general. Although Regexr.com, mentioned above, looks quite interesting. 
Agreed. There is however a feeling that for being a good developer these days, using non-bleeding edge tools is not an option. The implicit question is: is it true? Is the speed of the ecosystem effectively forcing the developers into an impossible need-to-stay-up-to-date situation? Mind that even if it is true, this is a different issue. Nobody should stop doing stuff in order to go slower. But sometimes I wonder if we should create tools to deal with the burnout of continuous updating.
...This is a completely unrelated point. I'm saying the criticism, whether constructive or not, is undeserved. 
Babel started as 6to5, which converted modern javascript to stuff that old browsers could understand. It changed to Babel when the maintainers realized they were providing a great piece of software that would be useful long after browsers support es6. Before version 6 Babel pretty much automatically just transpiled es6 to es5. After version 6, you have to specify what you want to transpiled. This often means just adding a reference to a preset in one of a number of ways: https://babeljs.io/docs/plugins/preset-latest/ It's still extremely useful, and the changes were necessary to keep the project ahead of the curve where it naturally lives due to its nature. For some reason, however, a large number of people got salty about having to add a line of configuration even though it is a useful and necessary feature. Edit: the name of 6to5
Argh, duh, of course, I've been flipping back and forth from XML to JSON the last few days, it didn't even occur to me that that was the wrong format.. Right, I just wanted to know if there were simple queries I could do link in Linq but it appears I have to loop through everything. Thx
Like the article says, they changed it from being a drop in, that worked for most people without having to configure anything, to an approach where it does nothing by default. Babel is still a foundational piece of modern WebDev, but the Babel 6 release changed its public image from being an amazing tool, to being just another thing in a stack of things you have to learn and configure before you can even start writing JS. Babel 5 was `npm install babel` Babel 6 needed a guide and documentation: https://babeljs.io/blog/2015/10/31/setting-up-babel-6 https://babeljs.io/blog/2015/10/29/6.0.0 
Adding triple quotes would make more sense than having an sql-specific tag.
What are you referring to? As in ```?
Yes.
its the same in every area, celebrities also reach tons of people and face a lot of criticism. You people just have to live with it or remove yourself if you cant handle it.
&gt; moderated by leaders in the OSS community I think the problem is that we, or at least me personally, would rather those really smart &amp; talented people be focused on writing great tools, rather than baby-sitting external communities. I'm a mediocre dev, so baby-sitting is in my wheelhouse. I would also like to state that moderating has been one of the single most-challenging things that I've ever done. I'm not a people-person, and have to constantly work at being diplomatic and fair. I don't always succeed. What I've learned though is this: some facets of moderating are more-or-less objective, i.e. "this poster is a spammer", or "this poster is a deliberate troll", or "this poster is verbally abusive". Those sorts of _'goes without saying'_ class of problems are easy to moderate. On the other hand, subjective matters are infinitely harder to effectively moderate; "Angular 2 is terrible", while a scathing take on the framework, isn't aimed at any named person(s). It's an impersonal criticism of works and ideas. While I can certainly understand how authors might take these things personally, is that fair? In other words, should we not be allowed to criticize things for fear of hurting someone's feelings? I agree that the Angular article is a little on the abrasive side, but would it have been any better if it was sugar-coated? Is it the tone or the content that's really upsetting? If it's the content, then how is one to offer honest criticisms if not by [directly addressing](http://paulgraham.com/disagree.html) the issue? To circle back to my point about moderating subjective content: I don't think anyone wants an environment where we have to walk on eggshells. We already prohibit _ad hominem_, and I don't think it's healthy to prohibit criticism of ideas (projects). So with that said, my stance thus far has been to let reddit's up/down votes be the moderator of subjective content. For objective content, at least most of us will come to an agreement on what is/isn't spam (or troll, etc.), but for subjective content, there's very likely to be wide disagreement, and I'm not too keen on being in the middle of such a shitshow.
It does. You won't have to escape single backticks. E.g. Dart supports triple quotes (and so does Python): var text = ''' omelette au 'fromage' ''';
The author is fine with constructive criticism of work, which this is.
I feel like anytime there are more than 2 people you are gonna have some amount of politics.
Bingo.
I think your viewpoint is certainly valid, and I also wouldn't want to make those hard subjective choices, but as a consumer of the content, I'd like more curation. Sometimes the upvotes/downvotes aren't enough to filter out all the 'junkfood' content.
That's not acceptable either. Why can't we try to work against both?
You need 2 players, share your url with someone! 
It works if you change it to `onclick="window.click()"`: https://jsfiddle.net/6qqp78bc/ The on*whatever* attributes are kinda weird in general. You won't have this kind of problem if you use addEventListener.
1. Do three projects with Jquery. Simple stuff like a wine recommender or tic tac toe. (Try to do two with some sort of api) 1. Don't get fancy here. Just hack them together quickly. 1. Pick one of these projects and rewrite it without any libraries. (Use only vanilla JS) 1. Pick a simple project idea and implement it with react 1. Take the egghead.io redux courses and try implementing another version with redux. 1. Make a small app with Vue.js (optional) 1. Make a small app with Aurelia. (optional) 1. Put all of this stuff on your github. And put notes in the readme like: "First react app, month 1 of learning js, etc" 1. Pick a framework and build a more complex web applications with multiple pages (routing) and login (fake the login for now) 1. Build yourself an interesting portfolio website where you can showcase these projects and talk a little about yourself, your interests, and your abilities. 1. Buy yourname.com or yourname.io and put your portfolio on it 1. ... 1. profit 
I appreciate OPs effort to open source but his message is a bit off. He should ask more constructive feedback instead of saying negative feedback is bad. Articles such as why angular 2 is terrible should exist. There is no such thing as perfect software. Everything has flaws and some of these flaws run deeper than others. If we were to never talk negatively about software we would never improve. People are shit at giving feedback. They often just state the problem they are having but don't explain why it is even a problem for them. People are also really bad at accepting change. Take Babel 6 for example. IMO it was a fine change. It was a major API change. Didn't like it because it broke everything? Well give some constructive feedback and ask for a better migration guide. Because of all that Open source maintainers need thicker skin. I'm sorry but it's true. You need to understand people are shit at giving feedback but appreciate anybody who is giving feedback at all! This means you are making a real impact to these people! Listen to their poor feedback and engage them for more constructive feedback. Show that there is a human behind this project and the reasonable people will treat you like a human next time. I know it's hard to be the adult in the room but the internet has taught people they can be shit to others. Above all else thank you for your contribution open source maintainers. We need more people like you. 
Play stupid games, win stupid prizes. Why are you stoking the fires continually by naming and shaming and insulting? Whoever gave you advice on this article was clearly wrong and you should stop taking advice from them because it seems to me that you're living in a bubble of supportive people and this is turning you blind to the criticisms and issues that other people face and their feelings too. You either learn to live with the criticisms and take the good with the bad or you wrap yourself into a cocoon of positivity leaving you blind to what reality is or you give up. I'd rather you contribute because you're amazing at it but please understand that we're all people like you and we too will have something to say, whether you like it or not. It's really as simple as growing a thicker skin.
Dart uses leading underscores for this, but leading underscores were already allowed. '#' is one of the few characters which is available. What's nice about this proposal is that "this." isn't needed (in Dart it isn't needed in either case). So, instead of `this._foo` (JS wannabe privacy), you'd just write `#foo`.
&gt; This behavior needs to stop. We need to stop rewarding anger. 2016 in a nutshell.
Oh another plugin to help with all the plugins. Yippee
This is the same James Kyle that goes on daily twitter rants, usually to the extent of being annoyingly toxic? The same James Kyle that hypocritically directs hate, anger and criticism at those with different political opinions, but calls for friendly unification when it deals with JS? Of course the sentiment of the blog post is positive and easy to agree with. Coming from James Kyle though is somewhat laughable. He's easily the most toxic person that I follow on Twitter.
This is where scope is causing collisions with your defined (global) functions. The scope of attribute handlers will be (for this case, though it can vary) your button element. So when you reference `click` directly in your attribute-defined onclick function, you're referencing the button element's `click` method. With the button object being the scope in which that function is called, its members will shadow anything you define in the global window. When you want to reference things in an attribute handler like that, you'll want to make sure they're uniquely named and won't clash with anything in the element's (or, to be safe, _any_ element's) api surface.
&gt; There is however a feeling that for being a good developer these days, using non-bleeding edge tools is not an option. The implicit question is: is it true? No, it's not. New &amp; shiny !== good.
&gt; Not only are promises just a poor man's observables, but they also don't translate well into other languages. I find that to be incorrect. Futures (promises) are found and easily used in many languages. https://en.wikipedia.org/wiki/Futures_and_promises#List_of_implementations
Why do you follow him?
I thought you have meant around each backtick. What you have shared is not a valid syntax, though. What you are referring to is here doc (https://en.wikipedia.org/wiki/Here_document). The reason I cannot do it is because (a) not supported natively and (b) not supported by Babylon (and therefore no Babel plugin can be written for it).
You are part of the problem.
&gt; &lt;p data-id="100"&gt;loading...&lt;/p&gt; Ok, so how did this problem come about? I mean, this is obv. not a "real-world" situation, and if learning is the goal, having us hand him the answer is only going to hinder his learning. 
Glad I could help. Also, it's worth mentioning that if you wanted to preserve the old `console.log` functionality you could do so with: var oldLog = console.log; console.log = function(message) { oldLog(message); ...
Because that's the only way to identify if you're running "npm install" vs "yarn install" that I know of.
I believe his comment isn't about whether, in reality, it is good or bad, but rather if the _social perception_ of a "good" developer in the web development community is how up-to-date and complex your technology stack is. I think there is some merit to this idea; social pressures are very real and influential.
And here in lies the crux of the matter for me. He wants us to try and appreciate the engineering and direction of open source projects taken by maintainers and acknowledge that as users we may not have the deep knowledge of how said framework / library works. I accept that. What I don't accept is not being able to take this view and apply it to the users of the software. You're telling users they don't understand your design decisions and users are telling you that all they have experienced is using the software / library and it's not working for them. I think communication is key. An example - the documentation for how to upgrade babel 5 to 6 is super light on it's feet and doesn't really explain anything. I had to cobble together what had changed from various online sources. So I can see why people would be annoyed at breaking changes. It hit me unawares and I try and stay up to date with major topics in the JS community, so God help those who don't and just use the software.
I was not saying that people should be mind-readers, or that they should not be frustrated, or that they should not criticize or voice their opinions. All of that is fine. I'm talking about directed completely transparent anger. I'm saying that we as a community should not reward people who act that way.
Just a warning to anyone who is about to watch this documentary. It is seriously depressing, so make sure that you can handle the dark place that it will take you to before watching. Oh nevermind, it says "JavaScript".
I don't think that's inherently a bad idea; however, you have to account for the fact that I would make the editorial decision in favor of readers seeing "Some bad things about Angular 2" and against readers seeing "Some bad things about online communities and Javascript communities in particular" on my personal Javascript forum. 
I had set this as solved but that was incorrect. The below code DOES find if ONE of the Categories matches but I need ALL the Categories to match.. var categories = ["10167", "10182", "10170"]; var matching_articles = myjson.map(function(article){ for(var i = 0; i &lt; article.categories.length; i++){ if(categories.indexOf(String(article.categories[i].id)) &gt; -1){ return article; } } }); so it would somehow have to be something like categories.indexOf(String(article.categories[i].id)) &gt; -1 &amp;&amp; categories.indexOf(String(article.categories[i].id)) &gt; -1 Ideas?
I don't disagree. :)
According to their docs, they do: &gt; Reliable &gt; It respects timezones &amp; DST.
An interesting thing about successful companies is their focus on company culture. Often times this means that the one thing that won't be tolerated, the one thing that will earn you a quick exit, is venting absent of constructive feedback. "If we focus on solutions, focus on helping others, focus on sharing ideas, we’ll be in a better place." Professional approach.
I don’t think pointing out factually incorrect information in your comment is “enforcing” my point of view but whatever. I’m glad that your comment gave me an opportunity to direct more funds to people creating great open source software, and help break out of the unsustainable cycle (that’s something we agree on!) Thanks for sharing your outlook. Perhaps when I’m older I’ll get more cynical, see open source as a zero-sum game, and see people as cogs in the machine too self-absorbed to consider moral implications of their work. Or maybe I’ll keep thinking open source software makes technology more accessible, like it did for me, and together we can overcome setbacks regardless of who funds that work. Chat again in 20 years?
Thing is, you cant rely on the browser to be correct here either so it makes DST virtually impossible to handle in the client.
&gt; What you have shared is not a valid syntax, though. That was Dart.
He asked.
Not a valid JavaScript syntax, sorry.
[removed]
I used Dart to illustrate the concept, because you didn't understand what I meant with triple quotes.
We fixed a lot of DST bugs in v0.17.0, back before v1.0.0 release and now pay attention to DST boundaries (and also run tests through [a number of timezones](https://travis-ci.org/date-fns/date-fns/builds/181343402#L2812-L3148)). Let me know if you had any issues with DST
I'm upvoting this because he sounds angry and it has a clickbaity title. Joking aside, I agree with what this author says. I'm a small open source contributor with a few of my own projects. Nothing huge, but I could imagine the frustration involved in pouring your life into a project just to get it shit on by armchair programmers. They often don't understand the complications involved in your decisions. While we should all be aware that these developers are making these comments because they've probably wasted their life trying to use a project which wasn't designed to solve their problem, like a square peg in a round hole. I myself have become frustrated by many things, particularly how coffeescript and ruby are so lackadaisical in their syntax compared to JavaScript even, but I don't go and write articles about it. That's my personal preference, not something I want to force upon the world. I've considered writing one but I can't hate it enough to divulge my frustration on others. It would be a waste of my time when it would just be easier to avoid it in my own projects. Regarding the way we have to compile JavaScript now, this is a natural evolution of professional development. First we start with simple kids websites, then we learn and want it to do more so we add things, like angular 2. Then we realize that angular and react are application frameworks, so we have to add things like Babel. This is how it works, the more complex you get, the more preparation you need in terms of utilities. These utilities are still new, so they don't always work well together, but that's just growing pains. Nobody complains about the c++ build process, or Java, or C#. These are application languages and they have compilation steps. JavaScript is nearly the same nowadays.
That was a really emotional post. A lot of frustration filled with sadness. I hope you get back on your coding horse as soon as possible. That being said, it was kind of biased. JavaScript community and environment is chaotic at its best. Maybe some self criticism is in order? Should the project maintainers stop for a moment and ask themselves why are they developing the next best project? Is it maybe the recognition they are after and not the altruistic feeling you keep referring to? Is there any chance a tool for the job is already available? Oh, it is but you don't like it? So the solution is to write a new one and hope it pleases everyone? Did JavaScript community forget about the time it takes for a platform to mature? Why not join and help guys that already made one tool like you want, just not exactly like it. Nobody wants to learn a new framework after they just spent half a year studying one, because the next one is really really the one... Take away here is that JS developers should stop saturating our tool-belt and pushing their next best project as in "How come you don't know the XYZ project, do you live on a moon?". Inventing problems that aren't there and finding a solutions for them will hardly get you praise from everyone. But it is true, the community can also be toxic as fuck.
I think that a code review should already spot this mistake. In our project, when adding a new dependency that is usually done in a single commit that should only contain 2 changes: package.json and yarn.lock. If the latter is missing then the ticket would be re-opened. If for some reason the code review misses this (which means already 2 developers have missed it), then an integration test should catch it afterwards.
I mean, that's true even on an OS -- I can fuck with my date/time, my region can be altered, I could live in an area that doesn't respect it at all. As long as the library supports it as an option I'm happy, but I see the pain.
[removed]
A lot of discussions + feedback already happens on Github. That's a good channel in my opinion.
Also, *asshole* has a wildly diverse definition. If I advocate no frameworks as a way of boosting performance and somebody else now feels threatened then I quickly become an asshole. When everybody is hyper sensitive any suggestion that is not immediately the most popular could very easily make you an asshole. Consider CrockfordGate as any example. To me, however, an asshole is a person whose intention is to incite a negative sensation above and beyond a technical subject... typically expressed as an ad hominem. Really, any ad hominem makes a person an asshole by default.
To this day I have zero idea how people stay motivated working for free. I can barely muster enough enthusiasm for the bullshit projects I work on at work, but at least I get a paycheck that makes those meetings, discussions, requirements change meetings, travel to India to meet with the back-end team, travel back to have management tell the dev team in India to change everything, power struggles that threaten my department's job, more meetings, 5AM conference calls to discuss yet another round of changes without talking to the devs, etc. There's an old saying about OSS: It's only free if you don't value your time. I find it.. absolutely amazing that people are willing to work, on their own dime, on things so that the rest of us can get shit done elsewhere. And for that, I always try to respect that: I ask with please, I say thank you, and I try to make the devs' jobs as easy as possible when it comes to bug fixing, reporting, feature requests, etc. I would imagine if I got a "FIX NOW" type of request, I'd tell someone to go fuck themselves. I just get irritated when people feel entitled to something that they're getting, for free, without realizing that there's a real human on the other end who, like me, doesn't like people telling them what to do. TL;DR: Treat people with respect, thank them for taking the time to build and maintain the projects you use, and be prepared to do it yourself if your needs aren't being met to your satisfaction.
He said this: &gt; I am trying to figure out how to call the information stored in the array, by the id so I can set my p data id to "100" and get the data in the array associated with Id 100. Im close but I keep over complicating it and wondered if there was a simple jquery function to call that array by the id.
&gt; Timezone support is [planned](https://github.com/date-fns/date-fns/issues/180) https://www.reddit.com/r/javascript/comments/5gl51e/a_modern_javascript_date_utility_library/dat7k1v/
I gave him advice on the article. He's not saying you can't criticize projects, he's just saying do it constructively. When you release open source there are just some folks who have this asshole spidey sense get activated that drives them to go talk extremely toxic shit. Constructive criticism? Sure, I love some of that. It's how things get better. But shit talking and insults? Nah bruh.
You can integrate your CI system with your Git server and configure it to test and build each pull request before allowing it to be merged. If the unit tests don't pass or the build fails, then the PR is automatically declined.
do you think Westworld would have all these problems if they just used VueJS instead?
Why is npm a joke? I see a lot of hate/derision about it.
I finally got it working with this if (Andthis != null) { Array.prototype.containsArray = function (array /*, index, last*/) { if (arguments[1]) { var index = arguments[1], last = arguments[2]; } else { var index = 0, last = 0; this.sort(); array.sort(); }; return index == array.length || (last = this.indexOf(array[index], last)) &gt; -1 &amp;&amp; this.containsArray(array, ++index, ++last); }; var matching_articles = myjson.map(function (article) { var indexes = new Array(); for (var i = 0; i &lt; article.categories.length; i++) { indexes.push(String(article.categories[i].id)); } if (indexes.containsArray(cleanedCategories)) { return article; } }); 
Hey, I have answered this question in a GitHub issue comment: https://github.com/date-fns/date-fns/issues/275#issuecomment-264934189 Sorry, we don't have it documented 😇 yet
I dunno man, the thread says, "or whatever"
That people take innocent criticism and sarcasm far too personally
the default colors on this site just punched me in the eyeballs - not a great start for a tool that's meant to work on UI/UX. good choice of name &amp; gTLD though.
Look I think the Microsoft ecosystem is terrible, and if the the devs there get butt hurt about it, I'll buy them a beer and tell them the Microsoft ecosystem is terrible. What privileges Angular 2 from not being called terrible if certain people think it is? And Babel 6 was a huge and shitty move, regardless of the good intentions of its developers. Want to install Babel 6? Take this six part minicourse on Udacity to figure out which components you need. Yeah, that was going to go over well. The javascript community is mean to developers comes from the same folks still insisting Clinton was right to focus on identity politics. JavaScript fatigue is not good, it's nothing to be proud of, it's not a mark of how powerful and innovative JavaScript is, it says nothing except JavaScript is built out of a rapidly pouring bucket of shit and if you want to have a chance of surviving you need to climb that enema waterfall as fast as you can. 
&gt; everyone especially in the Javascript community. But this isn't particular to js or /r/javascript - this is the Internet. You should see the anger and flames happening in Python after a prominent author trashed Python 3.
He wasn't saying that you are not allowed to criticize technologies, he asks you to do it in a constructive manner! Just saying "XY.js is terrible" does no good for anyone. If you can clearly state what you don't like or what you think is missing, and maybe even have spare line in your 5000 word article to thank the maintainer for contributing to the Frontend world, then you are contributing too. 
I just don't like people talking shit to me period. If somebody has something to say, they can come see me at a conf and we can take it down the street. Otherwise, put a fuckin cork in it.
While I appreciated the article, this is true, in that I thought it would be an open letter to the language itself...
&gt; My biggest contribution in over a year has been jokingly adding Guy Fieri ascii art to the project. He's not exactly Mr Constructive himself.
You make some great points about OSS. However, I oddly feel more motivated to work for free on stuff I like than on work projects, paycheck or no.
Thanks for the suggestions! I can already give you two good reasons as to why unit tests may not cover a new dependency: 1. The dependency is actually a package that has its own tests. You just need to import it and it binds some analytics trackers to DOM elements. So apart from including it, no more code is written (there are quite a few dependency that actually just need to be imported, leaving you with little to nothing to test). 2. For some reason, the dependency is mocked in the unit tests. So the question is not so much about whether our CI is great or not but how can one prevent such mistakes from happening because the truth is, one day it's going to happen.
Seconding this. I don't have to deal with any toxicity from OSS, but have still stepped away from most forms of social media after some tough life events and noticing how toxic/echo-chamber-y it can be. I'd consider at least starting an alt account.
That's a pretty elegant solution! Thank you so much :)
Well first an owner would need to opt into the system. I think then they could cede as much power as they want to one or more of the following: * Contributors * Public at large * Change Advisory Board * Prominent developers in the community In the case of public at large that could function almost as a proxy vote system like with stock ownership, your default position if you do not respond is that of the recommendation of the owner. I think no matter what the owner has the final say. 
That doesn't work on windows. But other than that, good point :)
Crossposting [my comment](https://news.ycombinator.com/item?id=13109404) for visibility: I have been on the receiving end of Kyle's outrage and I too feel the need to speak out that he has acted in direct opposition to what he is now promoting. I was a new contributor to lerna, no previous interactions with Kyle or babel, and have experienced some of the following: * My first PR was continuously rejected because he "did not understand my use case". I elaborated several times in great detail. Other project maintainers eventually chimed in that it was a good idea and should be accepted. Kyle continued to keep the issue closed and ignored all contact, including from other maintainers he works with, even to this day (the PR discussion mentioned something that set him off). * My second interaction with Kyle was one of the most highly requested features for lerna (nested directory support). I championed the issue and over the course of a year I attempted to get direction on which path would be accepted to submit a PR. It was ignored, so after a year, I mentioned I wrote some custom scripts and used another project to fill in the gaps. This seemed to immediately set off Kyle and he immediately locked the issue. * I opened a new issue since the original idea was accepted by Kyle and figured we could start fresh with a new discussion to avoid what led to him closing it in the first place. It was immediately Locked as well. * I reached out to Kyle on twitter to understand why everything I posted is immediately locked. No response. * I reached out on Discord to other staff members. Was also ignored. Eventually Kyle communicated with me on Discord with a very illuminating conversion. He didn't like the amount of github notifications he received so instead of unsubscribing he decided to lock all my threads. He provided several other personal reasons but essentially resorted to bullying tactics and said I should find another community. * I opened a Code of Conduct investigation because he was actively suppressing all my communication. He abused his power on more than one occasion and the public conversations we had were very aggressive on his part. He was found to be at fault during the investigation by Sebastian. Sebastian said his attempts to talk to Kyle were dismissed. No other maintainers responded to the incident that were listed on the code of conduct. They said nothing can be done about it, so essentially suck it up, even though they mentioned the steps that will be taken in the Code of Conduct. It was a complete joke and they should not have this document live. The only outcome from this was Kyle re-opened the original github issue he suppressed. * Other babel community members reached out and said they saw the chat and said sorry, it sucks, and they wish there was something they could do. It's nice to know there are people out there who recognize this toxic behavior from project maintainers. --- The whole experience was very upsetting. I will never contribute or participate with anything involving Kyle. No other maintainers and staff that work with Kyle, held Kyle accountable. At no point has Kyle held himself accountable. I was no one to Kyle, and a potentially new contributor. If I had this experience, I wonder how many others did as well. I am sure his message sounds good but if he doesn't practice what he preaches, then what is all of this for? I hope he has changed.
The author says that this is a community problem. But most loud complaining users don't see themself being part of the community. They just use every little straw they find to survive in the mess of web development. Babel is an excellent tool I believe, but most users just want it to work and not being another thing they have to work around. This is the cold hard world out there, where people are getting paid for doing boring CRUD applications with this. Others make money from teaching this stuff, if stuff breaks, they have to relearn and have to sell another new lecture. And why would a company buy another lecture for their devs for stuff they already have been taught? This is a huge market with big players like Facebook, Twitter and Google. Lots of money in it, which results in pressure to the devs to deliver something that works on IE10, Chrome, Firefox, Safari up to the newest Opera on some obscure mobile platform.
Pretty much you never need var, and if you think you do, something is wrong since it implies hoisting.
No, sorry, that's all I got.
I remember what happened here very well. I definitely overreacted a number of times, and I apologize for that. But you are severely exaggerating. You opened up a PR with something that hadn't been discussed and I asked what you were trying to do. I closed it after you hadn't responded for awhile because I was trying to clean issues up. You responded again and said "The use case for this all the reasons you would use file:// or private packages.". I again asked for more detail and you got really agro: "There are dozens of use cases for private packages which I won't get into here." I want justification for adding features because there are tons of cases when we can solve things in a better way that solves a more general use case. I wasn't treating you any differently than anyone who might ask for a feature. This went on for awhile before you left a response "Perhaps I should look into other projects or rolling my own?" at which point I wrote you off because once people go down that path they only get more and more agro at contributors. You say this feature was one of the most requested features in Lerna. It was not, you were the only one who had asked for it at that point. I don't remember my conversation with Sebastian, but the reason I locked that issue is because at that point Yarn was already underway and I was just going to wait for it to come out but people were just going on and on and getting more upset. I regretted locking it because that clearly only made people more angry. To this day I want there to be a politer way of doing locking, but alas there is not. I chose to ignore a couple things from you because I don't generally engage with people who are already pissed off. It makes me very sad that I upset someone so much that they are abandoning open source projects that they wanted to contribute to. I apologize for not being more forthcoming about my reasoning for things. But I assure you I was not trying to be hostile towards you at any point.
I use Frameworks to solve problems, if the framework itself is going to add so much more complexity to my problem solving process, I'm skipping it in a heartbeat. 
That's quite a comment coming from the React team! Can anyone get confirm this is actually true? I have a hard time believing it in a project readme!
Iterate over the array. :) 
hah...why are we supposed to empathize with your occasional bullshit because 'had a very rough time recently' but not the other way?
came here to share same tweet link (´･_･`)
Isn't that more or less how +1's and issue locking work in github? I'm saying that having a "democratic process" is kind of like doing lip service, because in the end you'll still have a large number of unhappy people when a decision doesn't go their way, and the vast majority of these people are probably not even aware of the decision in the first place, until it lands on a stable release (as was the case with the Babel vitriol situation). As a community leader, the best you can do is set some guidelines (and really, the rule of thumb of "be civil" is supposed to be a given), but when the discussion bleeds onto large public forums like Reddit and HN, you can't realistically expect people to always behave nicely. I'm not trying to blame the victim here, but at some point, you have no choice but to stop expecting things from others and you have to do what is within your own abilities in order to cope with the undesired situation. 
This is a great snippet. I'm gonna have to include this in my profile ASAP. *npm install* is so firmly entrenched in muscle memory that you sometimes forget about yarn. Thanks!
&gt; I definitely overreacted a number of times, and I apologize for that. Thanks for the apology. This is the first time in over a year I have been able to discuss this with you. &gt; But you are severely exaggerating. I don't know what I was exaggerating about. I listed all the events and experiences I had with you. Your next points are a discussion of the events but nothing has been exaggerated. &gt; I again asked for more detail and you got really agro. I wasn't treating you any differently than anyone who might ask for a feature. I don't believe I was aggressive at any stage during our conversation but I could understand why text can be interpreted that way. Your other colleagues have joined in the convo since then and immediately understood. I honestly had no idea how to convince you that private package support is needed because we both know their importance. You later accepted someone else PR for the same thing so you didn't treat me the same as you treated others. &gt; You say this feature was one of the most requested features in Lerna. It was not, you were the only one who had asked for it at that point. I disagree. Nested directory support discussion happened over more than a year with many contributions from the community. It resulted in one of the bigger PRs to the project and there were many people asking for it. &gt; This went on for awhile before you left a response "Perhaps I should look into other projects or rolling my own?" at which point I wrote you off because once people go down that path they only get more and more agro at contributors. I chose to ignore a couple things from you because I don't generally engage with people who are already pissed off. This was a valid question and I still stand by it. After many conversations you didn't show the slightest interest in private package support. Instead of hitting a dead end I asked if I should look elsewhere or rolling my own so I save both of our time. I realized you had a negative reaction to it which is why I **immediately apologized** for any confusion. In my experience when someone apologizes for any confusion they are not getting more and more aggressive. You ignored my attempts to talk to you on twitter, discord, and the github issues so I would say writing me off is an understatement. &gt; To this day I want there to be a politer way of doing locking, but alas there is not. There was never any justification for locking it in the first place. That is why Sebastian had talked with you and it resulted in it being unlocked for community discussion to continue. There was also never an explanation for locking the second issue either. &gt; I apologize for not being more forthcoming about my reasoning for things. But I assure you I was not trying to be hostile towards you at any point. I have yet to receive an explanation for any of it. I have the transcripts, the code of conduct investigation report, conversations with other colleagues of yours. I even have our conversation and at no point was any of the hostility justified or explained by any party. You keep saying its not personal but it most certainly was. When you single someone out, lock threads, write them off, ignore communication, disregard code of conducts, its entirely personal. &gt; It makes me very sad that I upset someone so much that they are abandoning open source projects that they wanted to contribute to. Ya it sucks. You had a Code of Conduct for a reason and you breached it. The code of conduct is supposed to represent and stand for something. I would have loved to have been part of the community. It is also frustrating that the only place you will talk about this is when there is public exposure. I only wish you didn't ignore my attempts to discuss in private as I get the feeling thats part of the reason it is being said now. However, I do really appreciate the apology nonetheless. 
Many of the complaints I've seen about npm are more about the community and package ecosystem around it than about the tooling. Especially the completely on verified nature of many packages on npm. The big criticisms of npm that I hear of stem from four facts: - It's trivial for someone to publish a package to npm - The JavaScript community likes publishing many tiny packages (many have an API that only wraps a single, short function) - Developers are quick to add these tiny packages as dependencies of their own projects - [A high-impact incident](https://medium.com/@azerbike/i-ve-just-liberated-my-modules-9045c06be67c#.19a5irwzr) revealed how deeply flawed npm's security model is. The big outcome of this is your dependency graph quickly balloons into 1,000+ packages. They're not all up-to-date, and it's not practical to vet the trustworthiness of your entire dependency tree. It's a huge surface area for bugs and security problems. Your app's security and stability depends on hypothetical package 4 dependency levels down. It's a 3-line function written by Joe HighSchooler in Iowa at 3am while he read his first JavaScript tutorial 4 years ago. Joe's package is permitted to run arbitrary code when it's installed on your machine, and it could change at any time to include new bugs or dependencies, which you'll probably download automatically because packages don't do a great job of version locking. Also you have no verification that the next version was actually published by Joe, and not Eve BlackHat, because npm doesn't use cryptographic signatures. If Joe reused his hotmail password for npm and it's lost in a data breach, Eve Blackhat can now inject code into your application. Many packages on npm are like this, and your very own dependency tree is sure to contain several. Solutions are harder to come by. Some require changing the JS community culture (some people really love their small modules), some sound like easy wins (cryptographic signing) but don't help as much as we'd like, and some are radical shifts in our tooling.
`item =&gt; item = 1` sets the parameter variable to 1, it doesn't modify anything outside of the function (the `item` parameter is unique to the function call). Using `item =&gt; item.foo = "bar"`, on the other hand, means you're modifying a property of the pre-existing value the `item` parameter references. You're not modifying `item` per se, rather what it points to. `item = 1` instead replaces `item`'s reference to that object to reference the value of 1.
RemindMe! 20 years "Chat with Dan about OSS superstars, evil companies exploiting their brain and the political/ethical meaning of our public actions."
But Angular 2 really is terrible... Sometimes you just have to call it like it is
So make a new anonymous account... Oh, I guess you like having followers... ;)
Are you kidding? **jQuery** is great and does all things, they should use that instead.
I guess the futures AI engineers will be `createClass` purists.
I feel like javascript is a relatively accessible foot-in to the programming world, which brings nice people to the field -- and then they get burned by deplorable people. Most programmers I've worked with are highly opinionated, credit-whoring, sociopathic emomaniacs who will berate others when there is little consequence -- as has been the case for a long time in the industry. Rudeness will rarely get you fired. I got out of the game because of how much time was wasted just being a dick to people. I, for one, actually enjoy solving problems, not bitching about them.
Well yeah, feedback is always gonna be biased towards the negative, because the people who have a positive or unnotable experience (things just work how you expect them to) tend to just get on with things. This kinda sums it up: &gt; "When you do things right, people won't be sure you've done anything at all." Note that this doesn't imply that negative feedback means you're doing things wrong - it's impossible to make software that perfectly caters to everyone, especially when the young people entering software these days are part of the most entitled generation (on the whole, I realize it's a generalization) to reach adulthood to date and often have unreasonable and vitriolic demands. What the internet serves to do is open communication channels that allow any negative feedback to condense into highly visible circlejerks of hate, which are the biggest problem.
Ohh, I understand now. Is there a rule of thumb that distinguishes when something operates on the argument and when it operates on what it points to?
I have a lot of personal issues with it (that I won't get too much into), mostly stemming from the fact that NPM reimplements much older package management systems that have served us all quite well. NPM has not respected the lessons learned from those systems, nor has it reimplemented those older ideas very well. It's largest appeal (originally, anyway) for JavaScript developers is that it's written in JavaScript; I did not pay attention early enough to know what other reasons NPM was created for. A huge security problem is that NPM has no method of signing or verifying packages [and it looks like it's dead in the water](https://github.com/node-forward/discussions/issues/29). Much of the discussion is concerning ... nothing substantial. There are few citations of existing technology, and I didn't see any references to prior works. NPM does not need to reinvent the wheel here. Another issue that has supposedly been solved in newer versions is the deep nesting of decencies, rather than a flat collection of them. This has created issues on Windows where path names are too long (NTFS [supports 32,000 characters](https://blogs.msdn.microsoft.com/bclteam/2007/02/13/long-paths-in-net-part-1-of-3-kim-hamilton/), but few softwares take advantage of this, including node.js). It has also caused problems with conflicting dependency trees, and has historically been slow to operate. Unfortunately I haven't been unable to get the later versions of NPM to operate because my node.js updates usually break (but that's a discussion for another time). NPM lets you host your own repositories and "mirror" others, but it lacks a mirrored network of repositories. See [here](https://www.debian.org/mirror/list) for an example from Debian of what I'm talking about. This means, if there is an outage of the official NPM repository, you're dead in the water until it comes back up. There is, however, a minuscule list of _official_ mirrors [here](http://blog.modulus.io/npm-mirrors). NPM's problems were apparently severe enough that Facebook created (and released) a new JavaScript [package management system](https://code.facebook.com/posts/1840075619545360), rather than contributing back to NPM. While this may come across as an appeal to authority, my intent is rather to point to the significance of this decision.
Intellectually, I agree with the author of that article, but realistically, I just don't care anymore. My ability to care has been stripped from me. You want to know why/how? Thanks for asking! Let me explain: I'm not a computer. I'm a human. My brain is made out of mushy stuff, not silicon and copper. I can only deal with so much change so quickly. Chances are, your Javascript project changes too much because EVERYONE'S Javascript project/framework/widget changes all the damn time. Sure, you just updated YOUR project, but I have to deal with break-neck changes in: * My personal code projects * My work code projects * The SCRUM process I use at work * My company coding standards * Switching to the new Javascript widget-glue-framework-thingy * Switching to the new CSS widget-glue-compiler-thingy * My personal life * The meta game in my favorite MOBA/MMO/Shooter changing * Anything to do with computer security * My favorite character in my favorite TV show being dead * YOUR software project * Evaluating all the new widget-compiler-framework-thingys that come out, literally every week, to try to stay somewhat up to date on current technology And I'm sure I've missed a few things. Point being: EVERYTHING in the world has started to update at "internet speed" and we haven't evolved yet either physiologically or socially to deal with it. I think the Javascript ecosystem suffers from this a little more than others because it's so popular/cool right now. I don't think most people want to be a-holes, they're just overwhelmed. I don't feel this is completely unique to Javascript.
I guess I should count myself as lucky that I've never really worked in a place like that. Have I met strong personalities? Sure, but not like you're describing.
Exactly the kind of constructive feedback that really encourages OSS development right here.
For me, it's about doing it the way I want. No clients, no managers, no one telling me how to make the product. Users can complain but the worst they can do is stop using the product and be assholes.
http://www.fapfapjs.io/ ofc
Most Microsoft devs are paid to contribute to the Microsoft ecosystem. OSS maintainers aren't paid at all. There's no need to be rude when criticizing something developed for free. 
Programmers are on average the whinyest group of entitled cunts on the internet, aside from gamers. Oh wait, many programmers are gamers. Hmm.
Yeah, I don't even have any idea about why such personal problems are being discussed here.
As one of the editors of ECMA402, I'd wish that people contributed more to our work. We're currently working on many future formatters (UnitFormat, ListFormat, RelativeTimeFormat etc.), and all of them could use some feedback from actual future users :) So, if anyone would be interested in future developments of the Intl API, look at https://github.com/tc39/ecma402/#current-proposals And wrt. DateTimeFormat, we're about to standardize `formatToParts` which gives a lot of power to style date/time strings for more sophisticated UI/UX.
But you realize usefulness is relative though, right? It may not be useful for your particular application or workflow, but that doesn't qualify it as outright "terrible", rather just "terrible for doing X". I'm not personally a fan of angular, but instead of giving it a blanket judgement I prefer to say it's not a good fit for what we do. I think that's an important distinction and also what the author of the article is getting at.
I just read this and I was not aware that the /r/javascript community was so toxic and hurtful. I'm really sorry to hear that you've had a bad experience. The part of your article that resonated with me was your call to reject the kind of negativity that has driven you to write this article. I'm on board with that. I believe that people need to be held accountable for the actions both good and bad in a public space so the community at large can learn from said actions. Keep doing what you're doing. Stay strong and thank you for your hard work on the kinds of open source projects that myself as a developer would be lost without.
&gt;junior web developers Yeah I completely agree, probably a better choice of words. Same meaning here tho
&gt;It's necessary to return to a state of balance. If anything there was rampant blind positivity for so long that you are now seeing the backlash from that. All the noobs that chased new and shiny are starting to reap what that sows and now they bitch about javascript fatigue. 
Should terrible frameworks not be called terrible?
Calling someone as asshole is also an ad hominem...
That's definitely part of it. I also like being able to have the freedom to design an app as opposed to implementing someone else's designs.
The curse of belonging to a highly social species, I suppose. 
I look at programming the same way a graphics designer (at least the ones I know) look at drawing. When I do it for money it's work, and obviously isn't that much fun. However, when I'm just sitting around the house, it's a creative outlet. Working on open source projects is kind of in the middle. It's not as much of a creative outlet as making an app that can make people's voices sound funny as a way to spend a rainy day, but doesn't feel like work. There is still a bit of the creative element of working on a project your truly believe in and get to show off to people, however with a bit of the work element thrown in. Since you do have to focus on being somewhat consistent, and "work" on creating a good project that people can rely on.
Fantastic piece! I think a huge thing with web-devs or really any industry that has a community sourced/designed/maintained resource is simply this: Community is key. We are both lucky and jaded in the fact that we rely so heavily on our community. Constructive, non-reactionary criticism is so important, yet instead we see a rise of toxic, click-bait articles going out more and more. If we're not able to have a level forum to exchange even conflicting ideas, how are we expected to continue to make progress? How are we expected to not turn every major contribution into acting like a tight lipped, no community interacting entity? We need to cultivate out the bullshit "I'm right you're wrong" mentality. I'm not saying we stop being critical, instead I am advocating we become more constructive, if calling someone's mistakes out does nothing but insight a flame war, we've gone no where but down. EDIT: This line is probably one of the best pieces of wisdom in the whole piece and lends itself to wisdom that can be applied much further than just frameworks in web-dev. &gt; I think there is value in learning about technical decisions that other have made and experiencing them first-hand.
I really take issue with your word choice as it comes across extremely negative- the kind of negativity that the OP is speaking out against. Be careful because when you come across as simply angry you lose your credibility. I don't really understand how blind positivity, as you put it, is responsible for javascript fatigue. I think the *pace of change* in the javascript community is blistering and I've become frustrated as I have to learn yet another concept / stack / framework. Don't tell people that being blindly positive is a bad thing- that can easily be interpreted as being positive *in general* is a bad thing. Dangerous. Do you want people to stop working on open source projects to allow us noobs to catch up? What is your solution? 
Maybe people without enough experience to follow basic best practices ( e.g. the release and its release candidates should be very similar to each other) should really get out of the business of writing frameworks.
My workplace also just picked Aurelia for all of it's web applications moving forward. I've built two applications with it, one pretty huge and one smaller, and I absolutely love it + TypeScript
Great work! The irony of an npm package made to alleviate the pain of installing npm packages is not lost on me. Bonus points if it can simulate droopy eyelids or yawning.
DAMMIT I JUST DECIDED TO LEARN REACT WHICH ONE SHOULD I USE AAAAAAAAUUUUUUUUGGGGGGGGGHHHHHHHHHHH
What triggered you? the word "noobs"? Get over it. There are people new to programming, what would *you* like me to call them? **Greenhorns**? Come on man! There is nothing "angry" about using "noob". Maybe it offends you, but that's really *your* problem. What else could have triggered you? "New and shiny"? If you're going to call me out on shit, do it directly - *tell me what you are calling out on so I can defend it properly.* You're the one attacking here, and suggesting anything I said is "Dangerous" is just adding a lot of *drama* needlessly to a conversation. &gt;Don't tell people that being blindly positive is a bad thing- that can easily be interpreted as being positive in general is a bad thing. Dangerous. No, I'm not going to stop telling people that being blindly positive is a bad thing, because it is bad - just as bad as being ignorant. In fact, blind positivity is the epitome of ignorance. If you think that's a good trait for a programmer, well... this conversation is going to only devolve from here. I can't defend or abide by ignorance in any way even if coming from blind positivity. &gt;Do you want people to stop working on open source projects to allow us noobs to catch up? What is your solution? Learn your craft. Gain wisdom. Pay your dues. Don't jump on bandwagons. And don't insert drama where there isn't any. 
Sadly it's becoming normal that you just need to stay out of this shit. And sadly that only leads to more bullshit as the only ones left are the more "extreme" on both "sides" which just makes everything more toxic. But I'm with you, for the most part I just ignore it now. I know that every time I bring up JS I'll get told I'm not a "real developer", every time someone finds out I use Atom I'll get ridiculed for not using vim. I know that no matter what choice I make half the community is going to vilify me for doing something so obviously dumb that they won't even write the reasons down since it's so beneath them. But at the end if the day, I'm making shit, it's working well, my dependencies aren't collapsing in on themselves, I'm not wasting weeks in configuration or in "keeping up". I'm productive and happy, and that's really all that matters. But I do wish there was a place I could go to talk about programming without all the "outrage" and anger.
your saying- applicants are becoming more commonly not college graduates?
What did you do, Reddit?! What did you do...
Dear javascript, go home you are drunk. /thread
Thanks for telling me what I should have said, *again*. Who made you the word police? Sorry, not going to play games with you. If you don't like it, take your comments elsewhere.
Not to mention "RIP beloved celebrities."
&gt; which you'll probably download automatically because packages don't do a great job of version locking This baffles me. I've only used NuGet as a package manager (mainly for C#) and I never have experienced any package updating automatically without my explicit approval. I don't understand why any other package manager would be different. If you're installing v1 of a library, then it's v1 and only v1 until you decide to even upgrade to v1.1.
You're assuming that we're using HTML as the view :) My comments weren't restricted to the view, as most of the complexity you'll find in badly designed applications is enormous amounts of convoluted and repeated code inside application controllers. That being said; I definitely would not disregard the importance for clean, well structured, and semantic templates and markup. This is the endpoint of your UI, and what your users see, and it's too often overlooked and underestimated. Building good templates also trains good habits, that will follow on into thinking about how you build web components and reusable pieces of UI. This is critical when working in teams, especially when multiple developers are touching the same markup. It removes any guess work as to how a template should look, what properties we're passing around the UI, and also helps when merging code with version control.
Not as clickbait, no.
My main arguments for Angular as a learning tool is it is (more or less) built around established MVC patterns - an easy step for a developer already familiar with Rails. It also does teach a lot of JS conventions, and provides modularity without requiring a task runner/compiler (e.g. `require` needs a bundler, `import` needs a bundler and an es6 transpiler). The Angular developer community is also a huge bonus. I'm in no way an advocate for Angular as an end all tool, and personally believe the use cases for Angular where another framework couldn't do a better job are quite limited, and it's very far down my list of framework choices - but it's use cases as a learning tool are still valid. Aurelia is fuckin sick btw - but again, same argument, it's not vanilla js.
I enjoy the process of building an app from scratch for the same reason. Very fulfilling. 
I saw this title thought "Oh, brother." but the dude's right.
I made [a list](https://medium.com/@IgnoreIntuition/the-fundamentals-of-javascript-aa3dc2be2723#.fftwg7buk) 
I never bought into it, so no, I don't recognize a reason for it. I wouldn't mind being enlightened.
React has a much larger cominity, more support, and a lot of jobs are requiring it. inferno-compat can even transform you React app into an Inferno app just by adding an alias to webpack, but it isn't stable enough yet... For now a better alternative would be [preact-compat](https://github.com/developit/preact-compat) (which does the same thing but uses Preact) and [React-Lite](https://github.com/Lucifier129/react-lite). You shouldn't worry about these right now, but they may be useful when you'll ship you app for production if you want to reductuce your app's bundle file size
I feel that rants have their place in the world. They are not meant to be constructive. They are used as an emotional outlet, and maybe provide entertainment for yourself and others. Much like satire about current events, they are still valuable, but not in the way that it provides solutions.
I am for a project with some minor popularity and I've been involved in conversations on JS tech for... five years? No, I haven't dealt with the overwhelming spew. I think there are improvements to the Github interface that would make dealing with the spew much easier. I don't question the existence of the spew or the fact that it's a drain on time and emotional wellbeing. I question the utility of engaging the spew outside of venting. This article engages the spew as a vent but pretends to somehow be productive. I am genuinely trying to say to /u/thejameskyle: make sure you get what you're trying to get out of this experience. 
&gt;Why do people who give their time for free need to be "professional"? This is a confusing point for you to make considering the point of this article could be stated as "the community should be more professional about criticism." Whatever, I'll answer your question anyway. * What we do is an art and a craft, but it's merely an art and a craft. To step away from it and view it with a critical eye is a basic component of improvement. * When open source maintainers are professional, they get more professionalism in return. If you read the complaints about thejameskyle here in this thread and elsewhere, you get the sense that there's a certain amount of hypocrisy in his writing this admonishment to behave better. That said, I certainly don't expect volunteers to be perfect, and it is not true that maintainers get what they deserve, but the moral superiority of this whole article is damaging and self-destructive of the point. &gt;I find these kind of statements the petty ones that would annoy me if I were a maintainer. Really? You shouldn't get attached to your code as a software developer, period; to do otherwise is unprofessional. Does that annoy you? Presenting an opinion on professionalism is that irksome to you? 
Honestly, I was just joking (re: javascript fatigue), but I *am* building an "app" that was going to use React, but I think I might use this instead since it's my own codebase and not an employer's. Thank you for the breakdown of the others, though, I shall also give those a look.
But a blog post is innately personal. If someone posts a blog saying angular is terrible, it's already assumed that they are scoping it within their frame of reference.
What specifically triggered you? &gt;Tolerance of haters gives them power by setting the tone of online discussion. Then report my comment if you think it's problematic. Let the mods decide, that's what they're for. &gt; People who don't tolerate assholes spend their time elsewhere, and what remains is a flamefest. You can't do that if you're maintaining a project like Babel. You do not get to choose who/what you are exposed to. If you want to code a private repo and invite only people who won't criticize you, you're free to do that - but that simply isn't where Babel is. Not sure if you read the article or are just reaching to create some drama here. &gt;More bluntly: you are contributing to the problem with your comments, and you should stop. Again, report me if you think I'm a problem. Is free speech a problem for you too? 
Considering that OSS maintainers are driven by passion/purpose and not money, I'd say it matters very very much whether or not they are paid. I'm talking purely selfishly. If you depend on code written by a volunteer, it is in your own self interest to keep that volunteer motivated. Also, don't be an asshole. Is that really so hard? It's literally *not* doing something. It is by definition less work. 
The source doesn't resemble javascript very much. Didn't help. 
Looks like javascript is only used as the scripting language to build **storylines**. The actual AI code would likely be written in something else. Makes sense, building a 'story' is essentially how we use javascript and React/Vue/Angular/whatever today. In many ways a web application has many similarities to a westworld 'story'. - Asynchronous workflow/structure - Getting user input and generating output. - Decision making based on user input. - Observables/Events If I were building an android that needed to be scriptable then this is probably the way I'd go too. Maybe not React but JS is a plausible choice. 
It didn't have duration support, which was a dealbreaker for me.
Yeah, one thing I learned since I started contributing to ECMA is that the process is much slower than coming up with APIs for libraries, but the end result much more satisfying. I'm currently about to land Intl.PluralRules in SpiderMonkey, and V8 will follow soon, and am now pushing Intl.ListFormat and started hacking on Intl.UnitFormat. All of that will hopefully make the Web a good multilingual dev platform!
[removed]
Oh sure, but you can trust to a higher degree that the OS will actually be correct and you won't have an hour just vanish: http://i.imgur.com/Fp0gx8y.png (FWIW, this bug is now fixed in Safari AFAIK).
I don't understand these libraries. Now instead of remembering that I can use a package like `strftime` to format dates, I need to remember that a grab-bag of utilities like this library called date-fns happens to have a method called format. I really don't like keeping two things in my head when I can keep a single thing in my head instead by depending on single-purpose packages. The other problem is that there is no natural boundary for these kinds of libraries. What belongs and what doesn't? There are exponentially more groupings of decoupled methods than the relatively smaller number of methods in the first place. These libs are constantly coming and going and changing but meanwhile the single-purpose libs could have been modified last 5 years ago and it doesn't matter because they're finished and don't need ongoing maintenance.
React. More mature, proven, libs, docs and community. Also, the team is working on a optimized core (react fiber). 
I feel sort of like a bottom feeder most of the time. I consume all this amazing free software people provide to me and others. I thank god everyday for the people smarter than me that make that possible. that being people like you and the angular team. I wish I could help on the projects but I wouldn't even know where to start. Thank you for what you do. edit: I do generally yell in frustration. mostly at my screen (not the developer) and receiving weird looks from my coworkers.
Well Typescript is just a superset of javascript. So assuming the ECMA standard eventually migrates in this direction its potentially a correct statement. Although we won't be calling it Typescript then. ES8?
TL;DR, don't be a dick. 
Yeah, pretty much a bad year from front to back. 
&gt; Downvote rants, upvote thoughtfulness That's the way Reddit is *supposed* to work, but unfortunately people tend to upvote what they like and downvote what disagrees with their opinion/worldview
jQuery.
I've been using DateFns as a Moment alternative for about 6 months now. Switched all my Moment usage over to this. It is far and away the superior alternative. Moment converts everything into its own custom Moment object format, which I always ran into issues with for various reasons. Add to that, many of the Moment methods mutate the internal state of the object, caused so many really really hard to track down bugs that languished for months (some I never even figured out why they were happening until long after it was too late and had hacked workarounds), and I looked high and low for a functional alternative, and just when I was about to give up, I found DateFns. The main things I needed to find in an alternative were: * Immutability (methods that changed something should produce a new object not change the existing one) * 80% or greater feature parity with Moment (or at least with ways to achieve the same results just as easily as a method call) * Good documentation * Reasonable library size and ability to import only the parts I needed (via es6 imports) DateFns was the only one I could find anywhere out there which had all of the above. I'm so glad I found it, I haven't looked back since. 
I'll respond in just a minute and try to clarify what we are doing further. Im gonna let one of my teammates try to clarify further on the subscriber question but in regards to : &gt; Second, we found that the ability to access these leaves of state resulted in my ability to lock state, or freeze partials of state. We implemented functionality to dispatch an action lets say "lock", when this action is dispatched you can now freeze your entire state object. similarly to what a library called redux-freeze does. However, we took it a step further and said what if we want to just "lock" or freeze a small part of state. for example, if we are writing a tic-tac-toe game and i select the middle square, we do not want that square to be picked again. We can simply dispatch an action "lock" this will tell our redux store that if another action is dispatched on this square, it cannot be changed. We can implement this functionality no matter how many layers nested our store gets, and we can unlock it by dispatching another action "unlock" to regain the ability to manipulate that piece of state. So by freezing or locking pieces of state we have taken out a bunch of unnecessary conditionals. Ill see if you need more clarification or if one of my teammates has a better response.
While we have plans to migrate our codebase to allow compatibility with the existing Redux library, our current one was designed with Angular 2 in mind so we don't have a mapState built in. What is meant by "specifically subscribed leaves of state" is that each key/property of state is mapped out and our subscribe function takes an extra argument that points at a specific key, rather than listening for changes to state as a whole. This cuts out unnecessary listener triggers and hopefully some overhead with larger applications.
I'm going to have to downvote you because I have taken offense at your harsh criticism of my comment. As a black aneurotypical lesbian trans little person, I take umbrage at your microaggression against me. -- does that help explain?
We mean a listener subscribed to a specific key in the state object. The key is a "leaf" of the state object and might be deeply nested. Locking state just means not allowing changes to state. We also have implementation to lock any key in the state object while allowing updates to other keys. Here is some sample code: this.store.subscribe(() =&gt; { /* do something */ }, 'key.nestedKey.furtherNestedKey.veryNestedKey') That would subscribe a listener specifically to "veryNestedKey," a key that is nested four levels deep in the state object. It only fires when that specific key changes. Conversely, if you wanted to prevent that key from being changed, you can call: this.store.dispatch({ lockKeys: [ 'key.nestedKey.furtherNestedKey.veryNestedKey' ] }) It takes an array of strings, which each string being a key path in the state object. That tells the store not to allow any changes to that specific key. Hope that helps. Cheers!
There is absolutely no reason to add another dependency to your project to check if something is an array, or if a number is less than zero, or to check if something is null. It adds unnecessary overhead and risk. 
The "real" programmers have plenty of drama in their communities, believe me
Imo these are musts to get started: * Understanding singletons well * Classes in es5 and es6 (Components are classes) * Revealing module pattern (Just a useful, basic pattern. I hold a lot of business logic inside these) * PubSub / Event Emitter (Think flux/redux) * Basic async patterns (promises etc) And for a little more: * Observer pattern (...mobx...) * Decorator pattern (Think mobx) * Factory patterns (I don't use them in react apps super often, but I feel like the decorator pattern and factory patterns teach you the basics of how react wants you to approach code reuse)
How are additional language features overkill? Why are you even in this subreddit?
In other words, even the TS doc is out of date? That's even worse.
Not out of date as far as APIs, more in terms of design patterns.
Saving to read later. God I hope this one is better than that callbacks minions post.
Well, isn't that the core problem? I guess everyone wants to stay hireable. Would you hire a dev today that writes "jQuery" as their main JavaScript skill?
Honestly, show your code to people, and you're lucky if people point out problems. There are plenty of people around who just want shit on everything without bringing up a single note of substance.
Conceptually components are really like functions in React and they can be written as ones. It's extremely useful to learn es6 classes when using React, but don't forget that they are just a mean to an end.
Hmm Redux folks would probably use a combination of this: https://github.com/reactjs/reselect and subscribe to the store with a function which only calls the locked logic if the partial state has changed since the last time it was called. 
That really depends on what I am hiring for. If it was a junior dev I get to mold and train, jQuery might be more than enough, given he or she can show me an aptitude for learning quickly. I barely even knew jQuery and had just started to learn Sass when I got my first job over 3 years ago. Now, I'm shipping a universally rendered React/Redux app this month, and it's all because a team took a chance on me being able to learn quickly. I know I would be apt to find the same qualities in another person if I were hiring.
Not money? A lot of the OSS guys I know are driven by a need to be recognized and a desire to be a maintainer of a popular OSS project because it can leverage them into good jobs, free passes to conferences, getting huge Twitter followings and so on. 
Re: missing documentation I think most of that was not deliberate. Angular 1 had a quite unique approach to Front-End Web Dev at the time it came out. It's clear from the code base and the history of the project that a lot of the decisions made at the time could have been better. Even so, they were in search of a better way to build apps and perhaps you can't really make the right decisions until you make the wrong ones. I'd say that it's rather easy to criticise with the benefit of hindsight. Personally, I know it took a while for the teams I've worked in to come to a really productive and maintainable approach to Angular - about a few years in fact. You mention this as well. I now look at the code I wrote 3 years ago and see so many ways it could have been simpler, so many ways it could have used Angular's strengths better. Angular, in general, has been very transformative in a good way for the JavaScript community. It's now a very strong framework for building large apps. I similarly expect it might take a few years for the concepts Angular 2 is introducing to mature and settle down into something great, assuming it does. The only real problem for the framework I see is that since there's so many great tools available now, it might not get the critical early adoption to push through the awkward years.
Nothing is more frustrating in OSS development than trying to submit a PR as a new developer on a project. Excuses, accusations of bloat or feature creep, or just plain ol' being ignored. The bottom line is that (some) people just can't stand to see their little code-babies change, or they just can't be bothered to return the favor and *read* the new code. At its worst, OSS development is a bureaucracy and an oligarchy. Once you've had a few experiences like yours, it really curbs your enthusiasm for contributing to OSS projects. Your perseverance is commendable! Sorry, Kyle's article left a sour taste in my mouth. Accept my damn PRs, people!
How do you get started with it ? The setup code says install some babel plugins... cool.. now what? The plugins are going to run themself? React has create-react-app, inferno had a fork but it doesn't work.
&gt; I'm not sure if this is even possible. It *will* be possible - all the code is present and running in a client application that you control and can customise. But it won't be *easy*, certainly not as easy as flipping a boolean value after page load. Some stuff is that easy to stop, but some advert networks are very tricksy about obfuscating their workings to try make it more hassle than it is worth to do so. Sometimes (though this is rare IME) the integration is even tighter and the app/game will expect a signal from the ad network that an advert has been shown before it will continue so not only will you need to block the advert form bothering you, you may also still need to make the relevant calls to the advertiser's servers to make it look like the advert was shown. If it was easy then your current blocking solutions would already have it sorted (unless it is brand new code that they've never seen before). Unfortunately I don't have time to help beyond saying "good luck on your quest!"...
ES6 isn't my javascript. Maybe it's yours. I don't use anything from ES6. Haven't needed it for 20 years, don't need it now.
This isn't r/typescript, and it's not r/ecmascript - it's r/javascript. Why are *you* even here? Do you even know where you are?
I installed all the plugins, so why isn't this app writing itself? 🤔
Regarding DST we're sticking to the ES standard, but we're working on timezones support that will allow precise calculations (see https://github.com/date-fns/date-fns/issues/180#issuecomment-264932949). It's safe to work within the system timezone in most of the use cases; that's why it wasn't a priority for us for a long time.
Guess /r/javascript is the /r/gaming of /r/games according to how you responded.
Why? It's better than a bloated framework where you're using 5% of it. Dojo is a good example in the early days
Also, if you need any help at all, please feel free to jump on to the Inferno Slack and ask :) https://inferno-slack.herokuapp.com/
This would be good advice if we were talking about any ecosystem other than JavaScript's. The fact is, once a new shiny API-breaking version of a project is published, development on prior versions stops almost immediately. If you don't upgrade as soon as possible not only are you opening yourself up to possible security risks but you can most likely forget about ever upgrading, as newer versions will stray farther and farther from yours with no simple upgrade path. 
I find it funny when employers want years of experience in some bleeding edge framework and then expect that theres some kind of standardized best practices around using it.
Most of the patterns you'll end up using with React won't be related to React. Data Stores, API calls, and even modular file architecture are things you may need eventually but React doesn't require. React gives you an API for serving components with predefined state and managing their life cycles. Determining and maintaining state will be up to the developer to implement.
It doesn't if you stick with semver. 
Saved. I jumped in to D3 a few weeks ago. I really have to say it helps to see things a few different ways. Thanks for making this!
Your carousel works for me. It has poor styling, yet is functional. If you want this zooming behavior look maybe on the MD carousel http://materializecss.com/carousel.html
My ideas are: A GUI tool for node projects that lists a) globally installed packages b) project dependencies Both can be updated with the click of a button. Of course new packages can be added too. It should be able to run tasks. (So you don't have to cd into the project folder and type the task name anymore) A markdown viewer. Like Adobe Reader for md-files. Double click a .md file and you see a nicely formatted HTML document. It could automatically open other linked documents. I'm not sure if it should include an editor too.
Very good point. It's about fulfilling an individualistic goal that sometimes happens to correlate with a few more people which makes it a collective goal. OSS projects that become too collectivist always crash and burn.
The purpose is dates are hard, have incredible "gotcha" edge cases, and if you're doing any kind of sensitive calculations around time (analyzing data, working with timeseries, statistics in general), you can get screwed if your implementation doesn't account for these instances. The humanizing and formatting is usually the most often used part of the library, providing the "X seconds ago" style output.
Why does it have to be extremes? Also, I would argue that constructive criticism IS the happy middle ground... let people know your concerns without being an ass about it. Win/win.
That doesn't change a thing I said. If you demotivate them and convince them that being a maintainer is actually harming their reputation, they will stop doing the work.
People usually don't make open-source projects to solve anyone's problems but themselves, then, at some point, the code may happen to be release as open and a community is born as a colateral effect of the effectiveness of the code in foreign projects. That's my impression of the situation about most open-source projects.
Could you please state clearly and concisely your overall goal? Like "I want a table such that when I click on a row, that row turns red. If I click it again, it turns green."
Literally *everyone* in this thread, from OP on down, has said that the point is: offer criticism constructively, don't be an asshole. Literally no one has said *don't criticize*. That is an obvious straw man, no doubt fueled by your apparent addiction to *being an asshole*. Look, it's very simple. If your goal is to have better OSS, it is in your interest to offer criticism in a way it can be heard and acted on. If your goal is to satisfy your own fetish for making people feel like shit, then by all means keep being an asshole. But let's not confuse one for the other.
My team are creating content tables. We have a requirement that we filter the table based on 4 key categorizations, Type / Sector / Service / Client. This information is part of the content table as column cell content. Select a filter, reduce the table rows to the selection and reduce the available filter options to reflect the current status of the table. EDIT: I should mention that JQuery is not an option, just vanilla JS.
And we'll get that. 
Your comment is basically "ok but &lt;insert reiterated point&gt;". I don't agree and I don't think you effectively rebutted anything I said. You think basketball players don't look at twitter? You're creating some paper thin point where you're going "oh well it's criticism but it's not visible". That's not only a bullshit refutation but it's not even true. Moreover, whether he gets paid A LOT... does that even make the analogy null and void? "Oh because he gets paid a lot, it doesn't matter". That doesn't refute any one of my points... you act as if it's EASY to play basketball (with the amount of money they make, if people could do it they PROBABLY would), or that basketball players don't get AS frustrated no matter the amount of money they're making when the fans lash out... how about you go ask Ron Artest whether the money was "sufficient enough" for him to not lash out at the fans... and I'm going to prerebut your upcoming "well that was different"... as I say often, apples and oranges but they're both fruit. Your job is to see what the analogy is based on, not the "differences" because if that were the case, using analogies would be pointless. There will always be "this sucks, that sucks". There will also be "this is awesome, I love you". You take the good with the bad. Stop FOCUSING solely on the negative criticism. You can sit there and complain but you don't get a safe space in life. This WILL continue to happen. You can either choose to be a victim, or go "hmmm MAYBE I should just view this as impassioned people... maybe they DON'T want to hurt me... maybe people are passionate about COLORS... do I really give fucks about this?". For 2 straight weeks, people bashed Apple when iPhone 7 dropped. I was one of the people that was like "this shit sucks, no headphone jack". Guess what? I own the iPhone 7 now. Love it. Maybe I was overreacting... that's what people DO. You can't police the world. It's much better to change your personal interpretation of reality rather than try to get everything to change. Like I said before, it's clear that a lot of you need some sort of meditation practice because you are WAY too affected by the outside world. You're essentially asking for a safe space. Get over it, it's really that simple. Edit: and no, OSS developer doesn't give you some special "get out of criticism free" card. So what... the corollary for being OSS is for people to treat you special? Again, you can keep dishing out that "well everyone deserves to be treated with respect" platitude but your definition of respect is a personal one. Respect is earned, and I'm totally fine with someone hating on something I did... that's true respect, not pulling punches and acting as you normally do when you don't like something. I can deal with the adulation so I should be able to handle negative comments. Good with the bad.
Are you aware how thoroughly you are talking past everyone who disagrees with you on this issue? Literally no one is saying you shouldn't criticize. What some people are saying, myself and OP included, is that *if you want your criticism to be effective*, you must offer it constructively and with respect.
It looks like your issue is that you're recreating the buttons with the resetXButton calls. You're removing the element from the DOM which will (generally) remove the event listeners as well ([stackoverflow](http://stackoverflow.com/questions/12528049/if-a-dom-element-is-removed-are-its-listeners-also-removed-from-memory)). You either need to re-add the event listeners to the new buttons that are created, or do as /u/orksnark or /u/inu-no-policemen suggested in the original thread.
Just es7 and webpack. If you can decrypt this: const x = ({ name, age }, ...stuff) =&gt; console.log(`${name}'s ${age} years old and he's got ${stuff.join(' ')}`); x({name: "ryan", age: 77}, "a", "nice", "car"); then React will be natural. const Button = ({ color, children }) =&gt; ( &lt;div style={{ color }}&gt; {children} &lt;/div&gt; ); &lt;Button color="red"&gt; &lt;span&gt;im a child&lt;/span&gt; &lt;/Button&gt; In essence it's the same. React components are just functions. So there's not much to learn if you know Javascript and HTML. React is simple, almost no API's, no template syntax, few gotchas, the things you study are mostly semantics, lifecycle methods and best practices - all can be understood under an hour. A very nice tutorial is the one from [egghead](https://egghead.io/courses/react-fundamentals). It concentrates on building and composing components. Redux, Routers and all this stuff can come later.
Thanks! I put it into my code and I am now up and running. Now I have to apply this to the rest of my code :/
I didn't say shit about criticism. I questioned the statement that people aren't doing OSS for other motives than personal curiosity and satisfaction. 
Honestly I would probably never learn React if I wasn't so frustrated with Angular 2, it was kind of a good thing after all. 
Nailed it!
Start from learning the tool that you intend to use. Research new constructs, syntaxes, patterns as you come across them. This way you will have more fun learning (a bit like solving a puzzle) and you are going learn those patterns by applying them in practise. It is a bit like the entire argument against the traditional academia. There is little value in learning all the theory if you are not going to apply it in practise. Learning theory becomes valuable when you design APIs (in a broad sense of the word) and you need to consider things such as concurrency, scalability, cache invalidation, etc. As a consumer, esp. a junior, focus on getting as much as possible practise. Leave learning implementation details to when feel comfortable as a consumer of the APIs. It is a bit like learning a natural language. You don't start to learn a new language by learning the dictionary (well, I am sure there are places where this approach is still part of the routine). Instead, you focus on making small conversations that produce the biggest possible utility (because most things can be said using simple constructs; same applies to programming). Then as you want to become more detail about your intentions, you learn more adverbs and adjectives to better express them.
&gt; Nevertheless, criticism won't damage their reputation. Being a whiny bitch will. context: a conversation about how we as a community should frame our criticism
Unless that toddler is yours, then it goes on the fridge! 
&gt; However, I do watch basketball and if someone misses all the shots they take in the game, I can say "that person sucks". If you meant that you are saying that person sucks on Twitter, that isn't what you said, and it is not how I read your comment. But either way, you continue to miss the key point: *OSS maintainers are volunteers*. That doesn't mean they get a pass, and that doesn't mean we treat them with deference out of some moral righteousness. It means they are motivated by passion/purpose/reputation not money. In other words, your interactions with maintainers *directly affects how they are "paid"*. It is in your interest, as a consumer of OSS, to keep its maintainers motivated. That's it. If the precept, "When critiquing a volunteer who served you, don't be an asshole", is too difficult for you. Maybe just don't say anything at all.
Wouldn't go that far, but I definitely expected more from people that work fot Google. 
Not yet. :) NY State area for now.
Agreed, I think it's totally reasonable to let off a rant over beers with some friends. Be as vicious and uncharitable as you like. Writing a ranty blog post is different because the authors of the subject under rant are pretty likely to read it, and open source runs on passion. Undermine that passion and we're all worse off.
Great form, mate. It's pretty clear where the failure was in your interaction with their project.
+1. domvm implements [1] the first part [2] of this and then falls back to a less complicated selection sort [3] that's sub-optimal in searching (usually cheap, pure js), but optimal in # needed (and expensive) dom move ops. This provides a good trade-off between code size, real-world apps and impl complexity. [1] https://github.com/ivijs/ivi/blob/master/src/vdom/implementation.ts#L1507-L1555 [2] https://github.com/leeoniya/domvm/blob/2.x-dev/src/view/syncChildren.js#L100 [3] https://en.wikipedia.org/wiki/Selection_sort
If you want to have a debate about why OSS maintainers are motivated, then please see my previous comment about how I am not a mindreader and don't care. All I have ever been discussing is how we can have the most successful OSS ecosystem, and how the way we criticize each other factors into that success. So if that's not what you wanted to discuss, then it was nice talking to you. Later.
https://github.com/ampproject/amphtml source code is also an amazing read :) I've learned alot from this sources.
don't put off learning React just because you feel like you need to prepare for it by learning complicated stuff. The amazing thing about React is basically how simple it is to learn. Just try [next.js](https://zeit.co/blog/next) or [create-react-app](https://github.com/facebookincubator/create-react-app) and you will be surprised by how quickly you can start writing React and creating your first React components – components are basically just functions. The first more sophisticated concept you'll meet in React is Higher Order Components (HOCs), which are basically wrappers or decorators for other components. Here's one [intro to HOCs](https://www.sitepoint.com/react-higher-order-components/). Another concept you might want to learn about is how to differentiate between [Presentational and Container Components](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0). Just jump in, the water is fine.
I take issue with the claim that you have laid out your points carefully. Your posts are like rhetorical shotgun blasts. Scattered and loud. Your intended target this time *seems* to be that assholes won't stop **all** OSS developers, so there is no point in encouraging people to be more constructive. This is analogous to saying that seatbelts don't prevent **all** traffic fatalities, so there is no point in encouraging people to wear them. If assholes cost us *some* OSS developers (they do), and we can encourage *some* of our community to be more constructive with their criticism (we can), then it is worth doing. 
A list of reserved words is what I think I was looking for. That is very useful and helps clear things up, thanks.
Do you have some example code? Want to look at this but have no idea what to actually put into my code.
I've not heard of one, but perhaps you will want to check out one of the Interactive Fiction projects and see how they handle data and choices. You'd probably want to do this as a backend project for easier database access, by the way.
I always recommend to read the references by MDN (Mozilla) about JS,HTML,CSS. it is presented very professionally edit: just google 'mdn addEventListener' or in general 'mdn &lt;FEATURE&gt;'
 var $submit = document.getElementById('submit'); $submit.addEventListener('click',startRoom); $submit.addEventListener('click',turnCounterUpdate); edits:on mobile,not that easy to look up your var names
Yeah.... I'm not doing that. Its a work around for other really bad decisions that incompetent people cannot live without.
Fascinating! 1895 - do you know whether the hypotheses have been researched and developed further?
I'm interested. Tell me more? Why is it what you said?
Send me a PM and I can answer you there. I made my comment intentionally vague to avoid trolling.
When it's 2012 and you have an absolutely garbage bundler with no tree shaking or dead code elimination, you really would take a 1 kb package over a 100 kb package if both do what you need.
I beg to differ. I'm certain i'm not an exception here, but I only have my anecdotes to offer. A non-exhaustive list of typical web technologies I use include C#6, VS2015, VS Code, Vim, TypeScript, plain-old JavaScript, Grunt, make, msbuild, AngularJS, ASP.NET, various Azure services, etc. These are all relevant and widely-used _modern_ technologies. None of them are particularly limiting or hinder me from being a hireable or relevant candidate. At the same time, I am aware of, and know a little bit about, newer, potentially less-stable or [currently] difficult to use technologies. Again, a non-exhaustive list includes WebPack, Babel, React, Flow, JavaScript FP, ES7, TypeScript 2, AngularJS 2, .NET Core, VS2017, etc. It takes some of my personal time to do this - time spent reading about and playing around with various technologies, but it's certainly viable. I believe it's viable, and I don't stagnate, because I (and others) have a solid foundation to build on top of. It doesn't matter whether I'm using AngularJS 1 or something that was just released today because I can figure it out as long as it works.
It doesn't matter in this case.
`link`s are not for `script`s (there was an old proposal to make it happen but browsers never implemented it). And `java.js` is a terrible name for a javascript file. We are also almost in 2017 and HTML 4.1 is superceded. After fixing the above things, your error is that the `id`s don't match. You have `wid1` and `wid2` in the `HTML` and `widget1` and `widget2` in the javascript.
So github was taking something that was basically an async operation, they made it synchronous.
TypeScript IS a superset of JavaScript. ECMAScript IS JavaScript. You're failure in understanding these basic concepts further emphasizes my previous comment. I'm also not alone in this matter, considering everyone is downvoting and arguing against you.
Sounds somewhat like what [svelte](http://svelte.technology/) is trying to accomplish. 
I would go so far as to say that Javascript itself is not needed for at least half of the things people are using it for. At least 80% of that being things that really do not need to move, be animated, be interactive, use AJAX,...
Learn. To. Edit.
Oh, thanks for bringing it back to my memory. I've read about it some days ago but really forgot about it again. I'll dig into it because the concept really sounds interesting.
Just open dev tools and throttle your network connection. It's easy to reproduce.
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in
Or through webpack-dev-server, yeah.
I love the npm gui idea
Alright thanks!
Thanks for the link, this is an interesting read.
 for (var i in testArray) { if (testArray.hasOwnProperty(i)) { &lt;some code here&gt; } } maybe? But manually doing for (var i = 0; i &lt; testArray.length; i++) { might be faster. Try both. 
That's nice to hear. Basically this is already built into JetBrains IDEs. But I'd like to have a IDE independent solution. On one hand I think it saves some time, even if you use the command line a lot. On the other hand I know some people who aren't so familiar with the command line (especially the HTML/CSS people in a company). It'd be a great help for them if they work on SASS, PostCSS projects or anything like that. The MD viewer has a similar inspiration btw.
If it's your first dive in SPAs I would rec looking into create-react-app. That'll get the quickstarting down a bit. Here's a good how-to when it comes to [routing](https://github.com/DavidWells/react-router-tutorial)
I'm afraid that's not the case, The document.getElementById works with the Id if I'm not mistaken, The pass and pass2 are jut variables made of the document.getelementbyID.value
I'm so sorry, thanks a lot! 
this is definitely a good way to iterate where performance isn't a steep concern, but you should still know how to write a for loop. 
Goodly.
You probably want uglifyJS https://github.com/mishoo/UglifyJS2
In your button example, what do the curly braces do? How's it different from const Button = (color, children) =&gt; (&lt;div.... 
not tested, but based off of the little information provided you'd do something along the lines of let keyboardEvent = document.createEvent("KeyboardEvent"); let initMethod = typeof keyboardEvent.initKeyboardEvent !== 'undefined' ? "initKeyboardEvent" : "initKeyEvent"; function left(){ keyboardEvent[initMethod]("keypress",true,true,window,false,false,false,false,37,0); document.dispatchEvent(keyboardEvent); } function right(){ keyboardEvent[initMethod]("keypress",true,true,window,false,false,false,false,39,0); document.dispatchEvent(keyboardEvent); } setInterval(function(){ left(); right(); }, 1) // probably shouldn't uncomment the below :) // while(true){ // left(); // right(); // } http://stackoverflow.com/questions/596481/simulate-javascript-key-events 
I think React, Angular 2, Aurelia and Vue.js will be the popular frameworks in 2017
a for/in loop should never be used to iterate over the indices of an array. this is because a for/in loop is used for enumeration not iteration. That is, a for/in loop will enumerate over the keys of a javascript object. let obj = { a : 1, b : 2, c : 3 }; for (let key in obj) { console.log(key); // =&gt; "a", "b", "c" } Note that this will also enumerate over key's on that object's prototype. let proto = { a : 1 }; let obj = Object.create(proto); obj.b = 2; obj.c = 2; for (let key in obj) { console.log(key); // =&gt; "a", "b", "c" } If you're going to use a for/in loop it's generally best practice to include an if statement before your code block to filter out unwanted properties which might by on the object's prototype. Note that the `in` operator will not enumerate properties which have been made explicitly non-enumerable via Object.create, or Object.defineProperty, or Object.defineProperties. Long story short, you should never use for/in on arrays, because that will enumerate the keys, not iterate over the indices. `Object.keys(Array(10))` returns an empty array. This might be what your professor means by "initializing". When you use `Array(10)`, the indices of the array aren't set, only the length property. If you DID want to you a for/in loop to enumerate the keys, it wouldn't work. You'd first have to use a normal for loop to set each value to undefined or something so that the keys would get created. Or you could use the es6 `Array.fill` So I guess my final answer for you (if you absolutely must use a for/in loop) is this let array = new Array(10).fill(0); for (let index in array) { console.log(index, array[index]); }
How do I make the lifecycle methods play nice with transition?
If it doesn't parse in a javascript interpreter, then it isn't javascript. Typescript does not parse in any javascript interpreter. Full stop. End of story. Don't use mental gymnastics to try to win arguments.
Thanks for the link! It seems like the process with reselect is a matter of getting the whole state object and then running it through the selectors to get data at a specific key. Pretty great for some situations. I was wondering, though, what if you only wanted to run some code when a specific key changes, instead of having to check the state object on every change to see if that one key changed?
&gt; the difference here would be well beneath trivial. Of course, this is just an example. But if you're actually writing code that executes 1-40khz it becomes decidedly non-trival.
Oh thank god, it's not just me? I got assigned to my first ASP.net project last week and had it mostly done using (mostly) native JS (And C#), but apparently I gotta redo it because the "corporate standard" is to use typescript and angular 2....I still can't even get it setup in visual studio right...
Really like how well-documented that is. Haven't studied every single option in-depth just yet, but it seems flexible enough for me to customize it so it does all the things I want it to and doesn't do any of the things I don't want it to. Great! Gonna study the options more closely before marking my post as solved, if someone has something even better do tell!
didn't read article, only a 10x developer would read it.
NDJSON ... I can't wait for the character-delimited vulnerabilities that arise from this.
I would start by commenting out the jquery definition in Project B, since Project A seems to be the parent project. Just to see what happens.
If you're reading this: You're less productive.
&gt; this is definitely a good way to iterate where performance isn't a steep concern I'm not even suggesting premature optimization. The above statement is perfectly accurate. Stop arguing just to argue. 
Not purposely. XHR requests, which are what power AJAX, don't support streaming, but full browser HTTP requests do. So when he loads Github up in a tab, the page renders as the content is streamed from the Github server. With an XHR request, since it can't do streaming, it instead waits for the entire page contents to load into memory and then says "Ok, XHR done here is the contents", which is when Github renders them to the page. This is a limitation of any frontend system that does navigation via AJAX.
Hi /u/Allthingsnavyblu, please use an online service to host your code. Here are a few, but not all, of the ways you can post your code: * [Codepen](http://codepen.io/pen/) * [JSFiddle](http://jsfiddle.net/) Please reply to this comment once you have done that and I will make the post public. Thanks!
I'm not arguing just to argue, I'm saying that "where performance isn't a steep concern" is such an absurd edge case it doesn't even deserve mentioning. IMO. And that teaching the proper approach is more important than worrying about unreasonable cases.
is this correct now?
Created a demo for my music analysis lib http://wizgrav.github.io/clubber/
So, a few things: * The JS is missing.. it has a `&lt;script&gt;` but nothing after it (be sure to click the "update" button at the top after you add the JS in). * Just paste the link from the address bar, like this: http://jsfiddle.net/x6pwkfyb/ 
It's impossible to answer. It depends on the details of your code, and it depends on the internal implementation details of the JavaScript engine that's executing it. It could even depend on other things like how many times the code is executed. The only way to know is by measuring. But writing a quality benchmark that isn't measuring noise is quite a difficult task. And you're almost certainly not going to find a huge difference, relative to all the other things that your script is doing. For example, even if one way was twice as fast as the other, that part of your script may only take, say, 500 ns to execute. The difference between 500 ns and 1000 ns is basically nothing, particularly if other parts of your page depend on things like network requests or image decoding, which typically take several orders of magnitude longer. So even if you come up with a benchmark, and even if it's a *valid* benchmark, and even if it says one way is twice as fast as the other way, that's still potentially utterly meaningless and a vast waste of your time. It's like saying that if you pull your car forward in your parking spot by an extra foot that you can get to work a little bit faster, since driving one foot takes less time than driving two feet. True, but utterly irrelevant. That is why you keep finding people saying that it's not worth worrying about. The only way to sensibly go about optimizing is by measuring the entire performance of your program, and then concentrating on the things that are taking the longest time. Doing micro-optimizations without knowing what their overall total contribution is completely pointless. 
ok think we got it lol
The link works but it doesn't have any JS still -- did you click update before copying the link?
[removed]
The [July 1983 issue of *COMPUTE!* magazine](https://archive.org/stream/1983-07-compute-magazine/Compute_Issue_038_1983_Jul#page/n99/mode/2up) featured a great lesson specifically about writing efficient text adventure games. Granted, due to the date the listing is in BASIC, but the principles are explained clearly enough that they're easily adaptable to JavaScript. Actually, if you don't mind transposing from BASIC, there's also [Creating Adventure Games on Your Computer](http://www.atariarchives.org/adventure/).
https://github.com/mishoo/UglifyJS2#mangling-property-names---mangle-props
ok lol for sure now
I'm so bad... I think I did it right
Nope, still no actual javascript, though you did manage to add a `&lt;/script&gt;` -- however it's in the wrong place, that tag can only go _after_ a `&lt;script&gt;`, not before. Your JS should have functions like `check_the_numbers()` and `Jones()`.
You nailed it. React teaches you JavaScript. Angular teaches you, well... Angular! All of its *ngIf and *ngFor made-up DSL has limited transferability once you move outside of the Angular world.
&gt; XHR requests, which are what power AJAX, don't support streaming They kinda do, via [xhr.readyState](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState) state 3, but you're right that it's not streaming in the true sense of the word (it's a memory hog) The problem with streaming is that your entire system needs to stream. If you've got a big JSON array, and you have to reverse it before rendering the data, you just blocked the stream. Needless to say, anything that isn't a flat list is harder to make streamable. For example, in the article, he uses ND-JSON so he can align stream chunks with a logical array item, but that strategy goes down the toilet if the array is short but each item is really large. Needless to say, it gets quite difficult to develop and refactor large applications while supporting full-on streaming. Also, he doesn't call iframes a hack for nothing. There's a whole slew of very annoying problems with them (some of which are touched upon in a comment in the article) and you'd have to be either insane or very very very brave to use them in production the way he's doing.
I think he's taking a dig at single page applications people.
While sweet, that's likely academically dishonest... anyways, good luck.
Mithril.js Not unknown enough? It has two sub-projects called ospec (a testing framework) and bundler (a bundling tool like webpack). In the same fashion as Mithril, they are tiny (~200LOC and ~150LOC respectively), high-density and have zero npm dependencies. I use them daily.
Yeah. That's exactly what I said. I said performance never matters. I also said I'm the son of Elmer Fudd, that I recorded an album with Miley Cyrus, and that ColdFusion is my favourite programming language. Since we're just making up dumb shit. What I said was that in practise, and especially for someone who is just learning, performance considerations like this are a **ridiculously** premature optimisation. And that **if** a person **ever** needs to do a loop over forty thousand records or some other absurdly invented usecase, and has to do it in JavaScript, then optimisations should be considered at that time. I'm simply trying to advocate teaching idiomatic javascript. But by all means, throw your little tantrum. 
I get how they work. Like assigning multiple variables into one for an indexing sort of thing. I'm just having trouble translating that into JavaScript code. Specifically I understand how to make an array size 50 but I don't get how to assign random numbers into said array and then a step farther and display the specific indexes in which a user inputted number is shown. I currently have a friend helping me now but if there is any input you have that you'd think would help me better understand that would be appreciated.
It's actually not a half bad article. Basically, it argues that an effective developer is a good communicator, proactive and creative, and that cranking out the most code per unit of time does not necessarily make a developer effective. If you've got a few years of experience under your belt, this should be nothing new to you, but I find that the `fast coding === good developer` mentality is actually a fairly common misconception among beginners.
Doesn't even talk about the psychology of a software engineer. You can learn all the code you want, if you don't learn how to interact with other human beings, you'll never get to this "super saiyan" level.
Are you saying the intent of your comment was to troll?
Maybe this will help: http://codepen.io/anon/pen/KNRvdx?editors=1112
Definitely go with the [CLI](https://github.com/angular/angular-cli). I think it's totally possible to set up your own webpack config etc, but it's best to start with the CLI. 
Um, ever used dev tools? I really doubt he did all this on his phone. Ctrl + Shift + I Get a job.
right. i wasnt suggesting someone would inject a legit build of this lib. if only there was some way to get the source code...oh wait it's javascript...and open source. don't mind me, just trollin.
TodoMVC implementation compiled by CC without any jsdoc annotations[1]. All other minifiers aren't even close to CC on complex projects. There are also two other great projects that I'd recommend to keep an eye on: splittable[2] and tsickle[3] [1] https://ivijs.github.io/examples/todomvc/bundle.js [2] https://github.com/cramforce/splittable [3] https://github.com/angular/tsickle
My presentation on picking JS framework in 2017 - what features to look for: https://slides.com/bahmutov/buzzjs Video is available at https://www.youtube.com/watch?v=ji8hqDi2BnA
&gt; It's actually not a half bad article. Is it 3/4 bad? Sorry, my "sensationalist headline" allergies are acting up again. Don't expect 100% thoughtful comments from me in /r/javascript, head over to HN for that. I save all my snark for here. https://en.wikipedia.org/wiki/Betteridge's_law_of_headlines
reversability is good. it's something that most routers lack and one of the main reasons i resorted to writing my own :( [1] https://github.com/leeoniya/domvm/blob/2.x-dev/src/router.js
tampermonkey is just an easy way to inject a script on any page and run it... loading at lightning speed is all based on the server, which you (or tampermonkey) have no control of. Think of it this way; a server sends you data, you have 100% control of the data, so of course you can take that and manipulate it how you want. But again, you have no control over how the server chooses to respond to your request for data.
Wait, did somebody just say iframes? I'm pretty sure someone just said iframes.
This sounds like a nightmare to debug or fiddle with, though...
Yes, TS/Flow are separate languages, but what's their base language? The language on which they are built onf? Oh, right, JavaScript. Like I've been saying since my first comment, TS/Flow are supersets. That's the entire point of a superset -- a set that includes another set. Both TS/Flow encompass the entire JS language, so yes, they are JS, but JS is not TS/Flow. That fact alone is enough for it to be considered JS. If it didn't do that, then it wouldn't be. I see where you're coming from, and I'll agree it's technically correct, but I'm technically not wrong either. That is all.
It's a manner of the function signature. * `(a, b) =&gt; { }` is a function with two parameters, `a` and `b`. It would be called like this `func(1, 2)` * `({a, b}) =&gt; { }` is a function with one unnammed parameter which is treated like a javascript object that has two properties: `a` and `b`. It would be called like this `func({a, b})` Again this probably looks like syntactic sugar, but I've inlined a lot to show it tersely above, here's an expanded example: const WithCurly({a, b}) =&gt; console.log(`A(${a}) B(${b})`); const WithoutCurly(a, b) =&gt; console.log(`A(${a}) B(${b})`); const example1 = { a: 10, b: 34 }; WithCurly(example1); // Output: A(10) B(34) WithCurly(10, 34); // Output: A(undefined) B(undefined) // This is because 10.a and 10.b are not properties, they're undefined WithoutCurly(example1); // Output: A([object Object]) B(undefined) // This is because example1 goes into the 'a' variable, and 'b' is never defined, thus undefined WithoutCurly(10, 34); // Output: A(10) B(34) You can see this behavior in action [at this jsbin](https://jsbin.com/jekeyadoce/edit?js,console). *(Note: Ignore the complaints on the left, the syntax parser is being strange, just hit run on the right and you'll see it in action).* This is because under the hood they're being converted to this: const WithCurly = function (this_name_is_irrellevant) { let a = this_name_is_irrellevant.a; let b = this_name_is_irrellevant.b; console.log(`A(${a}) B(${b})`); }; const WithoutCurly = function (a, b) { console.log(`A(${a}) B(${b})`); } It's just simplifying pulling all the sub-elements out of the object for you. Hopefully that makes the distinction on the raw feature of destructuring. Why this is relevant in the React example is that react passes all it's attributes for a component in a javascript object most commonly refered to as `props`. A simple "pure" component (a function) will often look like this: const Nameplate = (props) =&gt; { return (&lt;span&gt;{props.name}&lt;/span&gt;); }; When JSX parses your use of it: &lt;Nameplate name="Ted" /&gt; It turns it into this javascript: React.createElement(Nameplate, {name: "Ted"}); So when React goes to run your component to render the inner html it's basically doing this: let props = {name: "Ted"}; // actually passed in from the createElement call but im showing it here for clarity return Nameplate(props); So basically it's annoying to type `props.name` and `props.whatever_else` all the time so often the destructuring is used on the first parameter `props` to pull out the contents without all the ceremony of taking in the object and noisily refering to it everywhere. Thus this is born: const Nameplate = ({name}) =&gt; { return (&lt;span&gt;{name}&lt;/span&gt;); }; Is that more clear?
iframes were used as an XMLHttpRequest shim way back before all browsers supported it. There's a historical precedent here for abusing our awkward friend Mr. iframe.
Hmm, pretty sure Aphrodite already does this...
I do a database query which pulls in the creation time and stores it in an object "Files". I then display the creationTime on my site like this: &lt;td&gt;{{Files.creationTime | date : 'medium'}}&lt;/td&gt; So I have "Files in DBFILES" and display my object one at a time. Each object has a download button which should not be active until 5-10 minutes after the CreationTime Creation time in the database is stored as timestamp with time zone
They would probably implement that logic with the state's subscribe function (Having a variable outside of the callback function that is holding the last value) When the new value is different from the last, the subscribe callback could update last value and finally call the encapsulated function. Dont ask me if there is a premade solution or factory for that fictional callback function :)! I personally don't use Redux - in favor of another state management lib.
I hope to make a Chrome DevTools integration that will make style inspection easier. But the ideal use case is with a React application with live-reload setup, so tweaking can just be done in the actual source.
I'm more interested in the most *inefficient* version. Any ideas on that?
JSON.stringify won't return any newline, so it should be safe. Or as safe as it's supposed to produce well-formatted JSON (ie. as safe as right now).
Yea I'm already using that. The problem is it mangles properties of my exposed interface aswell, and I don't see an option to make it ignore those. (Besides doing it manually with a reserved file as I mentioned above.) EDIT: Also refuses to inline my constants :/ Only shortens their names. Am I missing an option?
There's a lot of background to explain here, but in general, you'll only be as fast as it takes for the server to first send you the page, and then to execute your code. But there can be numerous reasons to why your code executed slow that I would only be able to guess at without seeing your and the server's code.
Its amazing!! May I know I did you do that? 
What makes you think an iframe would solve this? I'd just recommend posting your code, explaining your problem and then seeing what our recommendations may be. More often than not I would imagine you're experiencing perceived-lag with some big loops you're doing in your JS as opposed to any graphic-related delay (4 to 5 seconds would be a pretty insane delay simply due to some re-painting).
why are you rendering 1,200 pages at once?
EDIT: Examples worked, pebkac at work. Sorry :) The API documentation on https://vuejs.org/v2/api/ is a bit hard to read. There is so much line height spacing between the list elements of a function/method, that most of them fit hardly on a visible page. But I like that there are examples in the documentation, even if there could be more. No idea about the code quality itself. But the developer seems to be supportet very well currently ($8000/month https://www.patreon.com/evanyou ). I am eager to try it out sometime. But at work I am stuck with AngularJS (1.x) anyways...
yes, thank you very much. if you're from google: TL;DR is that destructuring lets you refer to props by name instead of props.name by passing props enclosed in curly braces {}
There's two general things that will determine whether or not an if or a switch case is more appropriate for your code. 1), For the switch case scenario, it is best to use this if you are evaluating a single result and there are at least 3 or more cases, which also have multiple chained operations, that you would then expect to run concurrent actions. For example; const someValue = true switch (someValue) { case true; // some code case false; // some code default; // some code break; } With the above code, you can pool concurrent actions (I use this concept often in game-design), where I run some kind of loop, which based on the state either updates, draws, evaluates input or destroys, etc. Essentially, this type of design allows for you to inject yourself at various points of an expected process and likewise is regarded as typically faster than an if-statement in evaluating when it comes to JavaScript. However, there are considerable differences between browsers and thus running a test in general is the best approach to benchmark. 2) For the if-statement scenario, evaluating if-else is the best way to approach ranges and likewise generally performs better with fewer operations (it boots up faster than a switch statement). Additionally, just like switch statements, sorting them in the order of most frequent case or resultant values will also benefit performance. In general, no major differences, but semantic code and/or use-cases for the task at hand will generally make the decision for you of which type to use (as opposed to really anything with optimization).
I'm a complete novice in web dev, and so have not ever touched any kind of framework, but I got curious when I read your post and ended up on this page which seems to answer some of your questions : https://vuejs.org/v2/guide/comparison.html It is necessarily biased, but it does touch on a lot of key points on how Vue is different from other solutions.
Check https://github.com/vesparny/marky
What resources did you find helpful for a new comer who did not have any knowledge of using other frameworks other than documentation
Something is fundamentally wrong with your approach.
What's wrong with the documentation? Vue's documentation has been some of the best documentation I've worked with. The [guide](https://vuejs.org/guide) is actually really great. Prior to learning Vue (been using it in a largish scale app for ~7 months now) I had not touched a JS framework, and was a JS hater. I tolerate JS, and maybe even enjoy it a bit now, but the guide is really great for getting started with it.
We use it at work. Powerful, easy to get started with, not much to complain about, fast improvement. Highly recommend.
&gt; automatic updates without setState like Vue. MobX will give you this. As far as I can tell it does a similar thing to Vue, only updating exactly what is observed.
upvoted for replying to a modern javascript question with a 80s magazine article and still being relevant !
/r/brainfuck/
Maybe you can paginate a little, it seems that the bottleneck will occur whatever your approach is. In my experience iFrame are even worse. I've worked a lot with polygon rendering on maps inside of iframes and the iframe would just lock when there was too many polygons if I'd render it after DOM content had loaded. On window load it would perform better but I still had jank issues. So I ended up ditching iframes to implement shadow dom with a service worker to dispatch the load away from the main thread and render inside the DOM. I had to chunk elements to render them in packs and load them one after the other with window.requestanimationframe(). I still have some jank in the profiler but nothing tangible.
There are a few things that stand out to me, so since you are asking for suggestions: 1. Don't tightly couple the data fetching part of this function with the rendering of the output. Maybe, for instance, you or another developer would want to operate on the current value for some reason in the future. You would currently have to either get that value from the DOM (ugh) or duplicate all this code just to get at the raw data. The "library" part of this is really just a function that returns a future value of a number. With that number, the consumer should be able to do whatever they want. 2. Don't rely unnecessarily on side-effects. I get you want to cache the fetched value, but for such a short amount of code you have to jump all over the place to imagine running it in order. 3. This isn't really a library. You're just using an api, so they are doing all the work. It just seems a bit arbitrary to me to say that making a request and putting the result in an element is providing anything generally helpful. So maybe just publish it as a gist and call it a project that uses a bitcoin api. 4. It's not really a good practice generally to put stringified javascript inside of your html as you're doing with the `onchange` event listener in your example. Since you're already dealing with the dom in your js, you might as well set up your event handler there as well. 5. Don't use magic numbers. Seems like multiplying by 0.000000001 means something. Maybe just make a function called `satoshiToBtc` that multiplies by that constant (assuming that's what it's for), so other programmers can follow what it means. Either that, or make that constant a variable so that it at least has a name. Overall: I don't mean for this to come across as harsh, and I am glad to see excitement to share things, so I hope that this helps you make good changes to your code.
Can you provide specifics for why Aurelia weighed more in your decision making versus Vue 2?
So the validation libraries... Vue-validator is the major one, but isn't Vue 2.0 ready still... So I actually rolled back to Vue 1, only to find I didn't like vue-validator much, the docs suck, some things didn't work/weren't "natural" to understand... I found vee-validate much better, but it's still effectively beta, so I tried to contribute a few things and help it along... Hope it continues to improve as it's better than vue-validator. UI component plugins didn't seem to exist... I found one recently, turns out it had existed all along but only recently been ported from Chinese -&gt; English, so wasn't easy for me to find/use... Compared to Aurelia, where the very first release of aurelia-validation just worked, and had features I didn't even know I wanted until I used them, such as ValidateSimpleRules.then().ValidateAnExpensiveRuleLikeAServerCall() which only procs the 2nd validation if the 1st ones pass (e.g., don't do a "is email already in use in db?" call until they've typed a valid email)... Oh yeah... only 1 way binding property from Parent Component -&gt; Child component in Vue really did my head in for a few hours... Coming from e.g., Angular1/Aurelia background this didn't feel natural and felt overly restrictive, without Vuejs explaining why to me? (as opposed to React background where I think this is more common thought pattern?) Anyway, those are a few things I didn't love... But having said all that Vue is definitely my #2 favourite and it's really good. Think it has exposed my need to play with React/Redux/mobx one way data flow and learn a bit of that biz...
Could you explain more about the stateless functional component style in Aurelia?
I really hope Tim finds the piece of mind he's looking for. Moment is a phenomenal library.
I've been searching the front-end space for a bit. I've tried Angular, React, Ember, Polymer, Riot, &amp; Mithril to try and find something that works for me &amp; makes me happy/not frustrated. I'm not a fan of spending weeks learning a specific framework since I don't want to add extra overhead, I believe the framework should only be there to help (not become a whole story of its own!). I was able to learn Vue + Vuex properly in ~ 5 hours over 2 days; I then built a fairly complex app in 3 days and I have to say I think I've finally achieved the happiness I was looking for. I finally feel relaxed when previously the JS landscape really got on my nerves (to depressing levels, seriously) so I recommend you at least check it out and see if it makes you happy too :). Recently I've heard of Svelte &amp; Aurelia which seem to also follow my previously mentioned needs, so I might check them out too (would love it if someone would compare these with regards to what I've said!).
Do you mean the vue-newsletter? It can be found here: http://vue-newsletter.com/ There are 21 issues so far. Lots of tutorials and resources among other things :)
As for validators, you might be interested in trying out Vuelidate: https://monterail.github.io/vuelidate/ It works completely different from vue-validator or vee-validate in that it is completely decoupled from the template/jsx. The rules are simple functions you can pass to the validations property. With this in mind, it is quite easy to accomplish something similar to aurelia-validation. You can actually compose your validators like you would do inside computed values etc. Also, async validators support are almost done and should be available next week. :) You can read more about the idea behind Vuelidate here: http://monterail.com/blog/2016/rethinking-validations-for-vue-js/
It can: `JSON.stringify({ hello: "world" }, null, 2)`
What is problematic in my opinion: Having the overload, to support all those filetypes and codecs out of the box. Either it has to be native included in the browser, or the implementation should have a very small script, which identifies the file it shall play, and then load the correct codec and stuff. Else it just adds unnecassary traffic for shipping the whole VLC player over and over.
The problem is here: var var5 = 10,330; You can't use commas in numbers like you would in German. If you mean a fraction, you would write 10.330. Or if you meant a whole number, you just write 10330. You also have this issue in var4 and var7 - you're storing them as strings, not numbers. Just assign them as numbers - 6.67 and 5.1345 (no quotes). Then you can just write "var8 = var7 + var6", which will equal 11.8045.
You've misidentified the bottleneck. Streaming HTML and JSON make just about no difference on most networks today. The sizes are too small. The difference you're seeing in time to first render is because GitHub waits on assets to load, you don't. Waiting on assets adds one or more additional round trips, as well as the download time of the assets, to the wait time. Re-working GitHub's approach to load the HTML, show it, then load the assets will be almost as fast as your streaming approach, without the complexity or hacks. Also, streaming parsers for real JSON exist, though like I said they're not worth it for JSON sizes on 99.9% of websites.
React calls components with a single argument, an object, your code wouldn't work. You could also do: const Button = props =&gt; ( &lt;div style={{ color: props.color }}&gt; {props.children} &lt;/div&gt; ); Though, as you see, extraction goes a long way in making your code more readable and later on it gives you many other posibilities like extracting a couple of values you know you want, and the rest you dump into a contained object you need later on. Spread and extraction will become very important for Redux.
I haven't used Vue, but you should also check out [Aurelia](http://aurelia.io).
From Angular Vue felt like a *tremendous* upgrade and i would prefer it over Angular 2. Against React the benefits are smaller. It is a bit faster and smaller in size (inferno-compat, react-lite, preact-compat, etc. make it even again). The downsides. It is not as simple as React. APIs span 64 A4 pages. Templates are a regression. Composing isn't as free, templates get prepped to receive components. Components can be verbose, logic is sprinkled across trough computed props, because you are not given a class that is yours. It is still a long way from from ES6 and 7 with inconsistencies like not being able to use fat arrows in certain places because you would loose `this`. State is complex, it mutates it with getters and setters being liable to Javascript limitations, you end up using special $set and $get functions in your codebase. It has been indicated that React also has gotchas, i haven't seen them to such an extend.
In native CPU code, switch-case is faster than multiple `if` statements if there are 3 or more of the `if` statements. But in JavaScript, the threshold is likely be higher.
The lesser elements the browser need to process, the lesser time the browser need to complete it. So, using an IFRAME won't help at all.
Java !== JavaScript.
I'd still use FireBug as long as the built-in DevTools doesn't work and is not as capable as FireBug. I'd patch it to make it work if necessary.
So is this elf_crg/e1r0nd/rick_developer some bot?
It would be nice to have a wrapper that enables to control the optimized mapping behaviour, falling back to regular 1-to-1 mapping.
That is just tabs, actually.
Explanation and more info; https://www.reddit.com/r/firefox/comments/5gtedd/ublock_origin_developer_raymond_hill_on/dav4iiu/ I reimplemented based on the description. EDIT: wow, ok. Here's a version that doesn't spam the console; https://jsfiddle.net/ebhjxfwv/4/ Here's a version that **crashes devtools**; https://jsfiddle.net/ebhjxfwv/3/
I FUCKING LOVE VUE!!! I started with Polymer and really liked the web component approach, but it's just too big. A friend recommended Vue and I started the switch. Now everything I make used Vue (if there's a need for databinding). It's just so light and simple! Need a dialog with some js? Give it a vue object with all of its code contained in nice little braces. Even when having to work with other frameworks (Materializecss), there are fairly simple ways to create custom vue directives that trigger the creation and update functions when necessary.
forgive me for typing this in English and not javascript but I have to have it clear in my head also. Maybe it's something like "if (inputted word == array No1 id 02, AND chosen language == German, then getElementByID IN array No2 which corresponds to id 02++?)" 
I don't like it. Spamming the console at 60fps is not worth it. My proposal, considering 128px enough for all browsers: document.head.appendChild( document.createElement('style')).innerHTML = ` html.devtools { outline: 8px solid red; outline-offset: -8px; } ` window.addEventListener( 'opendevtools', () =&gt; { document.documentElement.classList.add( 'devtools' ) }) window.addEventListener( 'closedevtools', () =&gt; { document.documentElement.classList.remove( 'devtools' ) }) // DevTools' state detection void threshold =&gt; { const areDevToolsOpen = () =&gt; ( window.outerWidth - window.innerWidth ) &gt; threshold || ( window.outerHeight - window.innerHeight ) &gt; threshold window.addEventListener( 'resize', function test (){ const event = new Event(`${areDevToolsOpen()?'open':'close'}devtools`) window.dispatchEvent( event ) return test }(), true ) }( 128 )
Tcomb, especially with tcomb-forms, react and redux. Pattern matching and ADTs as types are delightful when working with complex APIs that have many different models/variations
I would recommand [freecodecamp](https://www.freecodecamp.com/). Here you can start from easy stuff until you make real projects where you can master your JS knowledge.
You are right. I didn't think about detached devtools. If we mix the two implementations, we have the perfect detection.
I will counter this other comment and say: Learn how authentication should work. Read articles written about it, implement oauth by yourself (without passport) so you can learn how it works. Once you understand the inner workings, you can make educated decisions about choosing libraries that will do it for you. 
&gt; not being able to use fat arrows in certain places because you would loose this Can you give an example? I am curious what places are you talking about
[The Majesty of Vue.js](https://leanpub.com/vuejs2) is a great book.
This solution hides the polling pretty well; https://jsfiddle.net/ebhjxfwv/4/
We transitioned from React for our SPA development buildchain to VueJS very recently. We're in the middle of our first major projects with Vue, having only a couple small projects with React before that. Vue is much easier for our less JavaScript friendly developers to cope with. Its very easy to explain and I can even have people that don't know JavaScript barely at all contribute to templating. vue-loader is fantastic for project organization as well. The codebase just makes sense. Vuex integrated much simpler compared to trying to plug redux into React. I feel like I was missing something in React there. Vue seems about equally performant in the limited use cases we've encountered compared to React. Supposedly it is faster, but I have yet to see evidence of this in practice yet. It is very easy to do things like globally register custom components. Just define the component as a Vue extension, and Vue.use(myCustomComponent); and you have access to &lt;my-custom-component&gt; in every Vue instance across the App. This cleans up our code base for very frequently reused custom components, like Sprites. The dev tools are much cleaner and easier to use IMO. I really haven't found much of a downside to Vue yet. Once in a while I run into a JavaScript error that is hard to trace back to where it came from, and I had a hard time finding a good library to help with my SEO management, but I was able to roll my own easily enough.
Yeah so at no part is this a big library, and it sounds a lot more like you just don't like to use other people's code. Single, purpose built packages are amazing -- they're only concerned with doing _exactly one job_ and doing it _extremely well_. Do you think for a second I'd trust one of my engineers to implement a SQL parser? Hell the fuck no. I'm going to use a library specifically engineered, with lots of eyes on it, and a strong testing suite to parse my strings to SQL queries. &gt; No natural boundary What are you talking about? Of course there is. This is a library concerned with common pure date manipulations, comparisons, and math. If you can't find the "natural boundary" in there, I've got a feeling you don't have a lot of skills in information architecture. But hey, this is all from a single reddit comment where your argument was for a unix command that maps a UTC int to the interpreted date parts. Have fun doing correct math with that that accounts for leap years.
Yeah no i dont think that's possible because scope to a degree is dependent on the manner in which things are being executed at runtime (prototype scope + block level scope [IIFE]). 
I agree about DI in Aurelia, it's very awesome and I would love to see something similar for Vue (a vanilla js lib would be ideal).
I keep hearing its API is better than that of mapbox, unfortunately it appears to lack webgl support. Thoughts?
&gt; var m looks like a huge jumble of stuff. Welcome to [regular expressions](https://en.wikipedia.org/wiki/Regular_expression)! It may look and sound daunting, but it's really just a way to either check whether a string matches a pattern, or to extract pieces of a string out using a pattern. The full pattern is: /([a-zA-Z]+)\ (([\d]+)(th|rd|st|nd))\ ([\d]{4}),\ (\d+):(\d+):(\d+)\ (AM|PM)/ I'll break it down piece-by-piece: ([a-zA-Z]+) Any letter, upper or lower-case, any number of times. (([\d]+)(th|rd|st|nd)) Any number of _digits_, followed by "th", "rd", "st", or "nd". In other words, probably looking for "1st", "2nd", "3rd", etc. ([\d]{4}) Precisely four digits. (\d+):(\d+):(\d+) Any number of digits, a ":", then any number of digits, a ":", then any number of digits. (AM|PM) "AM" or "PM". ---- So, all together, something like this should match: HelloWorldHaHaLoL 123456789th 9999, 123556:23112312:123312312312:0 AM Though it's probably looking for: December 7th 2016, 10:30:00 AM I'll let someone else cover the rest of the script!
Yes, I know. There are a many many Markdown editors out there. But it's not exactly what I'm looking for.
It's been *the* thing for years and the built-in tools couldn't match it. They gradually implemented more and more of firebug's abilities. You should treat it with respect
First thing I do on a site when an adblock warning appears is open chrome dev tools and remove the show_modal class from the body tag and delete any modal divs. It's going to suck if this is thwarted in the future.
What capabilities are still missing from the built-in devtools?
Custom styling without tiles, which is our default with mapbox. 
Oh, okay. We've always just used tile providers and layers of our own geoJSON
That's interesting, I've generally viewed setState as a positive asset because it makes components easier to reason about. You know specifically when and how the component is being mutated and outside of setState components are effectively pure. For me at least it's drastically reduced the number of bugs and I'm now somewhat averse to 2-way data binding.
i'm writing a chat app in vue 2 right now (scaffolded with vue-cli using the webpack template). coming from angular 1 it's definitely a much different experience - i'm very used to angular's "batteries-included" approach. with vue you definitely have to make more decisions for yourself, but you get a lot more flexibility out of it. you also get a way better story for things like css transitions (due to the included transition/transition-group components) and key events (due to the included keyEvent directives). i haven't used vuex yet; i'm still using a simple Vue instance as an event bus, but the codebase is still pretty small (&lt;1k loc) so i don't have any issues with it yet. all-in-all i'd say it's more than worth your time.
Inspect in Firefox?
So we're talking Firefox specifically? The Firefox tools have been quite good for at least 2 years now as well. I used to use Firefox pretty much exclusively back in the day. I had Firebug and like 15 other extensions. But that workflow became less and less attractive as built-in tools became better and better. So maybe we owe it to Firebug for getting the ball rolling... I can drink to that.
scroll! sorry
Async/await for crap browsers and object spread/rest properties where probably the most demanded features. Nice to see that this stuff was finally shipped. It was a deal breaker for some.
[`window.scrollTo(x, y)`](https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollTo)
Great talk, that solution seems like a pain to implement but very neat getting their perspective. User agents, ahg!!!!! lmao
This was helpful. Thank you! Seems like I will need to google the other code
is react-native actually stable for both Android and iOS?
Great, looks cool. Hope GUI fans use it! :)
The only person who could thwart such a thing would be another dev... and I hope we wouldn't do that to each other.
Use what you are comfortable with. If you are looking for something new try Vue or react. 
Well, that's the issue. Some are comfortable with react, others are with angular1. No one though is comfortable with angular 2 &lt; would this be a good decision, to start working with this and make an enterprise size app that is kind of customizable (layout for example).
Then I would really recommend Vue. I think both the angular and react devs will be comfortable with it. And yes angular 2 will be a great choice as well. Even though I am comfortable with angular 1 I would use 2 for a new project when it makes sense. 
Typescript is a superset of es2015/es6. All valid es6 code is valid typescript. I believe async/await + object spread are es8 features. The ES7/2016 spec is quite small in terms of new features. Typescript is basically a few versions ahead of the currently implemented ES spec. 
Basically the way you should think about TypeScript is that it's ES2015 and beyond, with optional static types. If you're familiar with JSX, it's conceptually similar to how JSX adds some syntax on top of JavaScript. The difference is that types in TypeScript don't have any emit - they're erased away. The benefits of the type system are not just catching errors and typos, but that we can build a lot of great tooling around it. You can try it out on https://www.typescriptlang.org/play 
Thx. This clears it for me. So if I use Typescript, I am covered and don't need to worry about ES2015 or beyond ? 
Thx. Your answer helps a lot. 
There is no types file.
Yeah, if you check out our source code you'll see that the only way we utilize inheritance is for abstract base classes where the abstract class is pretty much describing an interface. In a well-design Aurelia application there generally shouldn't be any inheritance. Something interesting though is to look at using decorators in lieu of inheritance to do mixin style programming with ESNext. 
Whatever the file is that requires to do manual work to map third party api types. Super dealbreaker
If you use vue-jsx I guess it is, honestly I haven't tried it yet. But Vue's default approach is pretty different from React's, I'd say it's more like an alternative to Angular.
To me Vue is a step backwards. While everything is moving into the ES6 space Vue has kept itself in ES5. One example of this is computed properties in a Vue component. These serve the same purpose as ES6 getters and setters in a class. If you want to see what I'm talking about here's a link to a quick egghead.io video in the new VueJS course they just released. https://egghead.io/lessons/javascript-use-vue-js-component-computed-properties
So in order to know when the new value is different from the last value in the first place, the listener would check the state object on every state change?
Anular2 is different beast as its a heavy framework. What made you choose between Vue/React? I like Vue's simplicity but I find that many of the things that the React ecosystem gets criticized for, e.g. setting up Babel, Webpack etc, is also needed for Vue. The startup curve is much smaller with Vue due to not having to learn a new way of programming (React's functional style) but functional programming and thinking of UI as stateless components is very powerful. Vue enables many abstractions and doesn't enforce this. e.g. I know you can use JSX but most people don't seem to and it isn't as clean, the most common style seems to be .vue components. I don't want to learn another DSL - this is the same problem with Angular, Ember, Aurelia etc. I wish the opinionated nature and built-in tools of Vue were in React, instead of having to choose routers, redux etc.
I tried that but the decorator wiring was pretty bothersome. Vue does it out of the box, without additional syntax.
Ah did not know that. Well we are currently stuck on Visual Studio 2013 which only supports TS 1.8.5. Surprised they went to NPM since Nuget is still a thing...
Yeah Async/Await for ES3/ES5 targets is very tasty and got me pretty interested now.
Member of TC39 and Flow here. It would be a mistake to standardize a type system for JavaScript right now. That would prevent necessary future changes. In a type system most changes are breaking: You're either removing an error or adding a new one. Even the syntax is still up for changing. Since tools like TypeScript and Flow are still evolving their type systems it would just halt all progress to standardize them now.
What I meant is that there is little downside to teams using TS tooling and tsc compiler even if the types are used sparingly. Standardization will happen if and when, AFAIK types are not a TC39 proposal yet. But libs from Facebook/MS etc already heavily use Flow/TS.
Babel's plugin architecture is amazing. Anyone can extend it for any reason. babel-preset-latest and babel-preset-env are very helpful. Congrats to the team for making such a great tool.
A Microsoft-centric thing, though. NPM is the definitive defacto package system for JavaScript. I'd no idea VS was stuck on pre-2.0. If you've the option, I'd strongly recommend you give VS Code a go instead.
Oh I've used it for personal stuff, this is for work though. VS2013 is stuck on 1.8.5 but 2015 is on the latest TS version. I don't have to rely on VS to handle the TS compiling, but NPM isn't something we use here (just me for some one off projects) so it wouldn't work for other developers.
I agree that the ecosystem should really start pushing hard to moving to typed JavaScript. Flow or TypeScript, they are both way better than what we have today. Flow is trying to do this by integrating with lots of the tooling already used in the ecosystem. i.e. If you already have Babel and ESLint setup you can add Flow to your build chain in like 1 minute.
I made a connect 4 game with react / node / socket.io https://murmuring-ridge-22925.herokuapp.com/ and this strange particle orbit simulation http://codepen.io/mackness/pen/jVKNrg 
I love remaking 4chan. Their JSON endpoints are great (Reddit's, too). Remaking the resume site is also another go-to of mine.
Core team member here. Could you elaborate a bit on the actual issues you are seeing with the things you see as "all ES5", and how using them is a bad idea? About Computed properties, since they are the only thing you explicitly mention: &gt; While everything is moving on to ES6 and TypeScript, Vue has kept itself in ES5. One example of this is computed properties in a Vue component. These serve the same purpose as ES6 getters and setters in a class. Well, since we don't use classes, we can't use class getters now, can we? And we don't use classes because we want to make user's lives easier by, for example, not having to `.bind(this)` every single one of their computed props - Vue does that for you, but that doesn't work with classes as well. See for example, this article about binding `this` when using React ES6 classes: http://egorsmirnov.me/2015/08/16/react-and-es6-part3.html. The same reasoning applies to functions in the `methods:` object. Apart from these points, you are pretty much free to use all of ES6 - but you don't have to. Our philosophy is that the library should be usable directly in the browser (though we offer [sophisticated build tooling support](http://vue-loader.vuejs.org/en/) as well as Typescript definitions right in our npm package etc.), which is another reason not to rely on ES6 classes - they are not natively supported in all relevant browsers. About TS: &gt; For using ES6 and TypeScript with Vue I've looked at vue-awesome but it seems that it implements its functionality at runtime. &gt; That means that **the TypeScript transpiler will have to be bundled with your app** so a user's browser can transpile your code at runtime. That defeats the purpose of Vue being a small and lightweight library. I have no idea how you came to the conclusion that I emphasized above. Anyway, the answer is: No, of course you don't have to. Please also see https://github.com/vuejs/vue-class-component If you have further questions regarding using vue with Typescript, feel free to ask on our forums. One of our core team members, @ktsn, is very proficient with typescript and can surely help out. Otherwise, I'm happy to try and answer further questions or concerns you might have.
Been there much longer than three years
You should "go back" if you want any of the following to apply to your JS project: - higher stability - higher productivity - less bugs - self-documenting code - easier developer ramp-up
Nice try bud
Nice. How does it compare w/ other tools?
Moving to TS was the best tech decision I've made in ages. The speed with which I build and refactor, the stability and overall quality of new code, the ease of diving back into old code... It just gives back over and over and over again. I've been using TS 2.1.1 for a few weeks now and it's been great. Unfortunately, TS 2.1.4 breaks `awesome-typescript-loader`, so I'll be holding off with the upgrade until this gets resolved. EDIT: I just read the whole release announcement and holy shit: ``` We decided that TypeScript needs to be more trusting, and in TypeScript 2.1, so long as you have a package installed, you can use it. ``` Thank you thank you thank you. I will say, though, that when all things are equal, I sometimes decide to use one library over another simply because of available types. Being able to use anything you have installed, making it easier to get around the type system, might not be lead to healthier code. I'm glad this is a configurable feature.
&gt; Core team member here. Appreciate all the work you, Evan, and the rest of the collaborators have done. Vue.js is really a refreshing alternative to React+Redux. 
Especially given that his proof wasn't even that Vue doesn't use ES6, it was that it doesn't use ES6 classes. That's literally one single feature. 
Any changes to how module loading work were probably made with the intention of making TypeScript easier for newcomers. Despite that, I'm sorry that it caused you issues. If you're willing to tell me about your experience, please DM me. We're always interested in getting feedback about any pain points you may've had. 
If you check the 2.1 blog post that this thread links to, you don't need to have declarations for your dependencies anymore.
[removed]
And it _will_ take 4x the time
Yeah, if you want to use ES6 or 7 without Typescript you can use Babel to transplile it to ES5 to support more browsers.
I know that, but OP was specifically referring to ES6 class getters.
This is the second worst part about Typescript for me. It's a deabreaker for me and others on my team. 
Yeah I don't think there's any reason you need to use ES classes, I'm not a fan of inheritance in components anyways. I do think it would be cool to use getters/setters in the existing Vue api though which is why I opened [this issue](https://github.com/vuejs/vue/issues/4409)
[].find and [].findIndex may be what you're looking for. 
That and you don't have to use something just because it's new. The Vue team no doubt did the research and came to the conclusion that ES6 classes were not in line with their vision. Perfectly acceptable. 
You need indexof
Thank you for all your hard work. You, Evan and the rest of the team have done a fantastic job. We're using both Laravel and Vue 1 for a large project at work (targeting over 200 stores nation wide), and Vue has made our lives a lot easier. Before I started the project. I built three proof of concept using React, Angular and Vue. Ran our team over each one of them. Right from the get go, people preferred Vue over everything else because it was easy to reason with. Both our tester and PM find it easy to make simple changes (copy/validation) because of HTML templates and our backend developer finds it easy to make changes to components because everything's nicely documented and broken up. Need to add a method or a computed value? There's a place for that. Anyways, keeps up the great work. We really appreciate it.
It's definitely getting better, and most of things I've spent time trying to work around have been fixed, but the constant change means there's always some new gotcha. The two biggest issues for me are: 1. Multi-module definition files e.g. importing one function from Lodash without polluting global namespace. Currently if you import lodash/filter, you declare _ as a global type available in all your modules. It's possible to write the definition file in a way that gets around this, but there are no examples on the TS website, and I've never seen anyone else do it. 2. Polyfills. The recommended approach is to use core-js, but the official typings get you all of it or nothing (due to point 1). I was excited about the introduction of the libs option until I found out that I still couldn't include the typings for object assign without also getting most of ES2015 along with it. I know it's considered to be out of scope, but it would great to have a compiler option to automatically polyfill based on your target and/or libs. I think this is what a lot of people expect the compiler to do by default.
This is a good move. When I first started using typescript (version 1.8), this took me by surprise because TS claims to be completely optional. I expected to be able to use types in my own code while still importing untyped libraries.
Yes, vue newsletter 
Equivalent to: function getElementsByAttribute(name, val) { return document.querySelectorAll(`[${name}="${val}"]`); }
k, I was actually just making the point that javascript development was real shitty in years past and it's kind of nuts to say it's somehow worse now but thanks for shitting up a week old javascript thread showing how smart you are with barely applicable logical fallacies. 
What IDE (and plugins) do you use if you don't mind me asking?
I can appreciate that not using class (and ES6) means you don't need any transpiler and Vue can be used in older browsers with a simple src include. That is a great feature. But class is really just syntax sugar, under the hood its still good old prototypal inheritance which no one understands and no one really uses. Using extends (and pure functions) vs createClass is definitely easier to write and comprehend. Perhaps you might consider this as an alternative to .component/.extends
I'm on VS Code now, having abandoned Jetbrains due to its performance. Code is incredibly fast, as you would expect from THE TypeScript IDE. The only plugins that matter to me: * Path Intellisense * TSLint * TypeScript Hero * Vim * vscode-icons Each of those provided something really crucial for me. I still use RubyMine or IntelliJ for other languages, though.
Did you read the rest of my post? I go on to say that their ideas are great for ES5. But hey, you're one of the people on this subreddit, so you must be overly negative too and assumed that everything I was saying was negative. Also, I have no concerns that need to be addressed, I'm not sure why you and the "core team member" think that. This post is an opinion post, it even says so in the title, and I support my opinion with links to what I'm talking about. Plus, there's a ton of positivity towards Vue on this subbreddit. Everybody loves it. You're just accusing me that I'm overly negative because I don't have the same opinion you do about Vue. &gt; I suspect a lot of people will read the title, up vote and move onto the next juicy headline. My post has a measly 10 upvotes while a post I read early today that says only positive things about Vue has over 100 upvotes. So this subreddit is not overly negative. It's only overly negative towards ideas that aren't popular at the time. As you can see with my post getting 10 upvotes and the pro Vue post getting over 100. This subbreddit should have its name changed from /r/javascript to /r/sheep.
I did know, but none of my libraries were written with TS.
Also worth noting that `class` isn't really what it purports to be. Like you said, it's syntactic sugar for an object constructor function. Classes in JS use object delegation instead of instantiation (differing from the common expectation of what a class is), OLOO - objects linking other objects. I enjoy using them and think that they are awesome, but I can definitely see why people would shy away from building a framework around the JS `class` as a design pattern.
class was added to make it easier but also because using prototypes is hard for lot of people. e.g. it was common to see - var car = new function() { function drive() {} } which is bad! vs the right way - var car = new function() { } car.prototype.drive = function {} with ES6 its just - class car { drive() {} } much simpler and less error prone. Using Vue's object syntax feels clunkier but its not a big deal since everything in Vue is based around that.
Cool bananas.
Haha, yep, I have migrated most of the app to 2.0 using both the migration helper and the docs, which was fairly painless (awesome work, again haha), and now I'm waiting on vue-validator to catch up. :) Been trying to figure out whether we can code split the app using Webpack and Laravel. Have you heard or seen anyone doing something similar? Would be really nice to be able to only load what's needed per route.
&gt; API span 64 A4 pages Ugh, seriously? When did we start evaluating frameworks based on how long the API page is? First, there is very little correlation between the number of API items vs. actual productivity. Simpler APIs often requires more userland concepts/constructs/composition to achieve the same end result - for example, Vue's class bindings supports Object/Arrays out of the box, so we need to document it, and React users most often will need something like https://github.com/JedWatson/classnames , which is not part of React but essentially a required addon with its own API. Vue also provides built-in support for transition effects, where as you yet again need an addon for that in React. If all you want is a simple API, feel free to build web apps with pure lambda calculus - it's all just functions and composes extremely well! Also, the API page is long because we go out of our way to provide as much information as we can for every single API in the framework, and that ends up being cited by some hater as a cons of the framework. Wow, just wow. &gt; Templates are a regression It depends on to whom - this is very subjective. In practice, there are two types of components: presentational ones and logical ones. When writing the former I often find JSX to be a regression. When writing the latter I do drop down to raw render functions (yes you can with Vue). Even if you prefer JSX all the time, you are not even forced to use templates anyway. I have replied to your past posts with counter arguments, can you stop repeating the same stuff over and over again without mentioning the fact that Vue can indeed use render functions and JSX? You are really being dishonest at this point. &gt; you are not given a class that is yours Again, I've explained before we don't expose a class-based API by default **because we don't force the users to use a transpiler**. If you do use one and want classes you sure can with https://github.com/vuejs/vue-class-component (another thing I've linked to before in reply to your comments, yet you failed to mention again). &gt; fat arrows Don't you lose `this` if you use them on React component classes as well? &gt; State is complex... you end up using special $set and $get You never need to use `$get`. $set is only needed if you are adding a property that wasn't declared in your component definition, which is a very rare scenario. Finally, how this equates to "State is complex" is completely beyond me - sounds like you've never even tried Vue with Vuex or React without Flux.
Woa. This is nice. 
Can you imagine how they would debug an issue on their own site at that point... It would be like shooting themselves sideways across both butt cheeks.
Technically needs to be escaped, but this is definitely a neater solution.
i'm working on something very similar to this as an internal analytics tool. also has player/recorder for ui events. heatmap generation. it doesnt have live streaming, but we don't need it. i plan to open source it at some point. recording every mouse move event is not necessary. using a simple 100ms setInterval poller that also diffs to previous mouse location and simply increases the prior frame's duration is very space-efficient. so much so that staying in JSON can get you quite far without having to reach for lower level typed buffers. packing the events using JSONH then optionally gzipping works very well also. 
Do people not know this?
And looping through every element of the DOM is faster?
Why not Jupyter?
Out of curiosity, how many engineers are working in it regularly? Would you describe it as a large project?
the data comes directly from your Datazar projects and you can use Modules made by other people. visualizations, math abstractions etc.... my favorite part is that it doesn't show the code in the document. makes it easy and professional to share with non-tech team members.
Excellent points! I wish more people would realize frameworks aren't a one-size fits all kind of thing.
I agree with that. Like I said, it's awesome and I love it. However, I'm confused by what this does: ``` var car = new function() { function drive() {} } ``` Oh, belay that. Closure scope is what I'm guessing your snippet implies. Just was confused because you weren't assigning or returning anything.
Thanks! Hoping to make [env](https://github.com/babel/babel-preset-env) much better coming soon!
av-ts' runtime part is the decorator code provided by av-ts (compiled into plain JavaScript like the rest of your TS code), it has nothing to do with "bundling the TypeScript runtime".
Where are these benchmarks?
Import * as _ from lodash 
Ember is very good at keeping you in check. I love the freedom and tend to see rigidity as stifling. Valiant point.
This is super helpful. Thanks so much! I am looping through an array containing objects each containing a few arrays. I am trying to create a function that gives accepts certain keywords as parameters and returns all of the objects that contain those keywords. 
It is/was an extension for Firefox. Long before Chrome even existed, if you wanted any developer tools at all, you installed Firebug, as the stock Firefox didn't come with any. Eventually the Firefox developers started writing their own (bundled) developer tools, which were substandard at first but rapidly become more and more refined, to the point where Firebug became extraneous for a lot of people. So you can credit Firebug for browsers having robust developer tools built-in, since it showed how useful and wonderful it was. (Firebug wasn't actually the first; I believe there was an add-on named Venkman for very early versions of Firefox, or possibly pre-dating Firefox, back to the original Mozilla.) Edit: and for context, it was recently announced that Firebug is no longer being maintained, so it will ride off into the sunset of obscurity, which is why everyone is probably talking about what it did for the JS world. 
Why do you want to keep every heartbeat in the store? Make your calls outside of redux. Maybe when a heartbeat fails dispatch an action that saves something in the store to know that the app is in offline mode or something
Is the result of the heartbeat considered application state? If not, I'd advise not putting it in Redux. If you're really concerned about the history being unusable because of all the heartbeat checks, why not just dispatch an Action if the heartbeat fails (I'm assuming that the heartbeat will return successfully &gt;99.999% of the time). Could you share an example to give some more context?
Haha
Fairly recently, Max released this Vue.js Udemy course https://www.udemy.com/vuejs-2-the-complete-guide/ and it's pretty solid. The course does a great job of covering nearly everything about Vue.
WAT?? What???
We have four people working on our project. A Laravel app that has close to 60 components, multiple payment methods, and uses Vue.js 1.x on the front end. Team consists of me (frontend), a PHP backender, tester and PM. So far, so good. We've found Vue.js easy to work with. The documentation's great. There's a few solid video courses. It's easy to understand. The supporting libraries are fairly solid. I know JSX is the flavour of the month but we find the HTML templating fairly useful as it allows our tester/PM to make simple changes.
I am going to assume that I will compare more than two objects at once, that's why I was avoiding the IF statement, I wanted it to dynamically grow as needed. I figured I could use this type of sorting in multiple places, it could be very useful. Thank you.
Had a similar experience with the HTML templating on our end. Our tester regularly jumps in and makes simple changes. He even spend a fair bit of time fine tuning the validation rules. I think I've turned our tester into a junior front ender. haha
Firebug didn't die, it just became normal. 
Ah cool, thanks. 
hmm i guess they could just turn that off in production though
I prefer not to use ES6 classes whenever possible. Related: https://www.quora.com/Why-are-classes-and-prototypes-bad-parts-of-JavaScript/answer/Sean-May-6 Also related: http://bdadam.com/blog/video-douglas-crockford-about-the-new-good-parts.html
Where did you see me re-rendering entire component every time I change a string? I re-render only those parts of elements, that actually were changed.
&gt; http://egorsmirnov.me/2015/08/16/react-and-es6-part3.html "Method 4. Using fat arrow function and ES2015+ class properties." precludes the needed for binding. 
It's easy to pick up but since you've already had experience with a lot of the frameworks that were inspired for Vue, you were even able to learn it faster. I'd say out of all the frameworks I've personally used it's very similar to React.
you'd obviously get more biased points of view there. ...we also can't be overly sensitive. I didn't find the guy's tone negative and non-productive.
You can also try a proper language instead 
I'm new to Babel, just wanted to compile ES6 to 5.. installed babel-cli and latest preset as per instructions... totalled nearly 80 thousand dependencies. That seems like a lot. I've been trying to avoid the whole npm package house-of-cards thing for as long as possible, is there any way to compile ES6 without pulling down so many additional files? Edit: for context, I'm not trying to convince people to not use Babel/npm; I'm a JS dev wanting to write ES6 in production and need to convince my team (and myself) that this approach is safe for both dev and production deploys of a non-trivial app (around 100K users, responsible for millions of dollars etc) Edit 2: Yarn sorted this out nicely.
In my opinion ES6 classes are a step backwards. Or at least in a wrong direction. Also I'm confused. Vue clearly encourages you to use ES6 features. Just read the documentation for Vue itself and, say, Vuex.
Why is dependency quantity an issue? 
Instead of wating for vue-validator to catch up, you may want to check out [vuelidate](https://monterail.github.io/vuelidate/) instead - it's compatible with Vue 2.0 and has some neat features like collection and nested model support.
What do red and green mean?
i think you're wrong in every single point. my team actually builds everything in typescript and uses es6 and es7 features heavily. then attached those models / controller to the views with vuejs. the disconnection of vue and the actual "brain" of our app makes this possible. you can bind the vue state to stuff that has nothing to so with vue and thus use es6 classes, setters and getters.
The downside is that including vast amounts of unknown dependencies in production code/build chain introduces an element of risk, especially when we're dealing with JavaScript. Are there any guarantees that those 80,000 JS files are well supported? Will the authors of all of them definitely make sure to keep pace with each other so no packages become incompatible or obsolete? I agree that I need to educate myself with the npm ecosystem more and give it a fair chance, and I intend to, but it's not crazy to be wary of this approach. Thanks for the tip about yarn, I'll look into it
It's already standard for angular 2
Hi, av-ts author here. &gt; TypeScript transpiler will have to be bundled with your app I don't know why you think that. Actually you must use either ts-loader or tsify to precompile your TypeScript files. It's not vue's problem. TypeScritp requires precompilation to be used in production. The same applies to Babel.
Wasn't it a helper extension from the times before the browser got dev tools built into the core?
&gt; It wasn't without its own problems And a lot of its problems were due to: * the slowness of the JS engine and DOM at the time, which a *lot* of work has been done on since obviously * the lack of explicit hooks in the browser so sometimes fairly hacky techniques had to be employed where today things can be a lot cleaner * the fact that it was one of the first (not *the* first, there were other similar projects at the time) major attempts to implement/improve those features (some brand new due to being browser specific and some imported from what we do/did in IDEs elsewhere) in the browser so there were some mis-steps that later work learned from and didn't need to repeat. It is one of those things that would have happened anyway eventually, necessity being the mother of invention, but Firebug and the people behind it deserve a lot of credit for both getting it as right as they did, continuing do it so well that the product stayed relevant (and competitive) as long as it did, and inspiring the options that came along side &amp; after.
... those 80k dependencies are devdependencies and are not used in production.
I understand why you feel like this, but I think you're being way too conservative. For a hugely popular tool like babel relied on by many, you really think it'll just be left to rot? **You** don't have to work about the dependencies of this project, because that is handled by the Babel project. If Babel's dependencies become obsolete, you won't even know about it, as the project will replace them itself.
Could they now spend a little time and add Service Worker support? https://jakearchibald.github.io/isserviceworkerready/
Yeah, but those tools sucked. Now that they have proper dev tools such extensions are obsolete.
But it basically sucks otherwise :(
Ohhhh holy cow!
There is also this project which attempted something similar ? https://github.com/bulkan/risposta
The actual code you are relying on in production is just what Babel compiles though. Babel itself you are probably just using in development.
Does it support modules?
I changed from Firebug to Chrome Dev Tools
That last feature is really excellent; I think that was by far the greatest hurdle to gradually introducing TypeScript to a project.
Safari doesn't suck at all. It is a great browser. If the definition of not sucking is doing whatever Chrome does, it is a wrong definition of quality in my opinion.
Proper IDEs with the right plugins work beautifully with typescript compared to JS as they can make proper inferences on the fly. Of course that is dependent on whether you decide to type everything (which you should).
As the article states, using fat arrow functions for class methods requires the use of class properties, which are not yet part of the standard, they are not even close. Right now, they are [stage-2](https://babeljs.io/docs/plugins/preset-stage-2/), so not arriving in the spec until 2018 (or 2019?). We choose not to rely on non-standard features for the core API.
Edge doesn't either.
Edge doesn't support it either.
Certainly need this.
Dunno about it. It's pretty inconvenient comparing to Chrome in my experience.
Thank you for your service of truly reminding people how terrible all of Microsofts browsers are. Your work does not go unnoticed!
Thank you for your service of truly reminding people how terrible all of Microsofts browsers are. Your work does not go unnoticed!
Thank you for your service of truly reminding people how terrible all of Microsofts browsers are. Your work does not go unnoticed!
You don't need to use sort or if statements (since you may need to compare more than two objects), you can use array [reduce](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce) to get the index of the highest energy value: const data = [{…}, {…}, …, {…}]; // get the index of the highest energy value const highestEnergyIndex = data.reduce((highestIndex, currentValue, index, arr) =&gt; { return currentValue.store.energy &gt; arr[highestIndex].store.energy ? index : highestIndex} , 0); //get the object with the highest energy value: data[highestEnergyIndex] EDIT: Another way is to use the first object as the accumulator in the reduce: // returns the object with the highest energy value data.reduce((prev, cur) =&gt; prev.store.energy &gt; cur.store.energy ? prev : cur, data[0]);
When did this happen? Just a few days ago I found a bug in safari in my SPA because I used `Object.values` without any babel settings for ES2017.
This is in nightlies, right? It's a great achievement but I won't be surprised if another browser is first to actually ship this to users. Apple insisting waiting for major iOS updates to update Safari is pretty outdated thinking these days.
So how about you also let people automatically test it on Windows as well? Too bad you need to either pay for some service to allow Safari-testing or do an investment to purchase hardware and get it setup on your environment to test Safari if you aren't using MacOS. Too bad they stopped their Windows release
This is actually only in the Safari Technology Preview, which most users will not have installed. So technically it hasn't happened yet. Safari 10 which is the latest release only has 44% support, and Safari 9 only has 6%. If your users don't keep their OSX install up to date they could even be on 8 (booted my laptop to OSX for the first time in months the other day to test out a bug and that was the version I was on before running updates). Hopefully everything in the TP will show up in the next update but that isn't really a guarantee.
Vim. Took a long time to learn/adapt. This (and apparently the codebase is very messy if you ever get the urge to contribute) is the only downside, though it's potentially a big one if you don't have the time to commit/aren't willing to adapt. Gvim/MacVim can make the transition easier, as they normally come with keyboard mappings closer to what you're used to. The upsides of vim are innumerable. A few follow. Hundreds (thousands?) of useful plugins (in vimscript) available, with some more performance-intensive plugins using C. Lots of built in language kits for syntax highlighting, code folding, window splitting/tabs/buffers, built in regex across files, awesome macro recording: record, playback, output to text, tweak and slurp back into runnable macro form. Overrideable key bindings for each mode. Normally vim runs great in terminals as well as having an OS-specific GUI version in gvim. Knowing vim means you inherently know vi, which is pretty much going to be available on *every single UNIX install* (unless it's an embedded distribution or the authors just want to be different) There are multiple package systems available (none of them official) and getting setup with Pathogen ~5 years ago my configuration follows me to whatever platform/machine I'm on. Just a git clone, submodule update --install and I'm good to go with all my plugins, key bindings, colors, fonts, overrides and other stuff exactly as it was on the last time. Modal editing, motions and text objects may seriously alter the way you think about/work with code. There are scads built in and you can define your own/many plugins define more. There is a reason "vim mode" plugins exist in VS, Eclipse, Emacs and many other apps. If you give it enough time to see how much it can boost your productivity (again that might take a year before you feel completely at home and comfortable picking up new plugins and knowledge of vim itself...) you'll see why yourself.
I don't understand why people still blindly hate on Apple, but my theory is that it's the Universe trying to balance out the people who blindly love everything Apple does. By the way, great job by the Safari devs.
You could also dual boot Windows and macOS, you know, without investing anything but a bit of effort and google research. Also it would be good for a developer to touch an UNIX environment from time to time, it's lots o' fun.
It Should be noted that this is only in the Technology Preview version of Safari. Safari version 10 (most up to date) only has 44% support for the features mentioned. Of actual released browsers chrome is still at the top with 78% support, followed by Edge with 52% and Firefox at 50%. 
Sometimes smart people and insecurity coincide and then you are really screwed (you being the person listening and trying to decipher wtf they are talking about). This is especially true of scientific/technical professions where you're basically competing with your peers at intelligence/knowledge i.e. smart people are more common and insecurity is promoted by a competitive "market". All my opinion of course. 
Your machine still needs to have certain hardware to do that, plus it will not be anything close to a realistic testing situation. Also it would require me to boot up a different machine or connect to that specifically which doesn't scream "automated testing" to me. Not to mention the limits on what networks and infrastructures at most businesses allow, i can't run anything other than a Microsoft OS here to work/test on
You get auto-complete etc for libraries which have a d.ts file (if you install those libs via npm, the @types stuff should be acquired automatically if you use the most recent version of VS Code) and you get some for your own code if static analysis can make some sense of it.
It's still possible to run macOS on a virtual machine, if all you want is to test Safari.
Is full ES2015, ES2016, and ES2017 support not important for developers?
Edge does not support macOS in the same way that Safari does not support Windows, the only way to get around that is also using a VM, it just happens that virtualization software available for Mac integrates better with the system, it's not Apple's responsibility to provide quality virtualization software for another OS.
Wtf why so many downvotes 
Good, now focus on all the existing rendering bugs and add missing APIs that aren't polyfillable.
You're right, but I also don't see why they like to make it harder for everyone else. You see this with Xcode when attempting to develop iOS apps; you need a Mac to develop an iOS app. It's nothing short of brand protection. 
Hello all, OP here. This post isn't JavaScript specific - but I felt this was a good community to share it with because of the direction a lot of JS frameworks are heading (or at least sharing some of the concepts). Functional Programming thrives on zero state changes in functions, no side effects, and more - all of which promotes concurrent behavior - and that type of behavior often makes for some well-written JavaScript too. I hope you find it beneficial!
This won't work on Node because it looks for `window.console.warn` rather than `self.console.warn`.
&gt; This post isn't JavaScript specific Removed.
And this is related to Safari how?
I like it, as a user. On a Mac it uses less power than any other browser out there, and it's fast. As a developer I agree it's not ideal.
Not legally it isn't.
Thanks! Special mention about VanillaJS - lol'ed at that ;-)
You understand what a dependency is, right? You're depending on 80,000 projects you don't control to be bug-free. There are 80,000 potential fault lines.
Of course it isn't. This thread is about Safari, and what it supports. Pointing out that Safari does not support WebRTC and service workers is relevant to a discussion about what Safari supports. Pointing out that Edge also doesn't support those things is not related.
But does it support actually telling the user of form validation errors yet? https://bugs.webkit.org/show_bug.cgi?id=28649
Jesus Christ. This is a thread about Safari. All you have contributed to this thread is moaning about Edge. As you ought to be able to tell by your downvotes, no-one wants to read it. It's not relevant. But this back and forth is a total waste of both our time. I have considerably more productive things to be doing with my time, so I'll leave you to it.
I wanted to voice my opinion because all I see on this subreddit are opinions I don't agree with. I'm playing devil's advocate. Not really playing because I legitimately don't agree with a lot of what's said on this sub... but you get the idea.
When I incorporated Babel into our build process, the time taken to do a fresh build increased by about 20 minutes due to the checkout and install time of all the dependencies. We also started to run into problems on our build server with disk io causing Jenkins processes to hang up and stuff like that and other teams were starting to complain. It took some work to resolve these issues.
ES7/8? Is it now? Care to share the spec?
&gt; When did this happen? It's in the latest Tech Preview, which prefigures an eventual Safari 11, which would most likely be released alongside 10.3. The current Safari is 10 and has significant holes in its ES support.
You should make a PR
Or service workers... Or WebP. Or intersection observers. Safari is far from the most modern browser to develop for. Es6 can mostly be polyfilled anyway. I'd rather have them focus on actual features. 
It's worth remembering that Babel (and all of its dependencies) are development-only dependencies: your transpiled code doesn't depend on any of them and they don't increase its size. Yes, it means that it takes a little bit to install Babel (though not *that* long, in my experience), but that's basically a one-time cost. If you're really concerned about the "second coming of `left-pad`" (though you shouldn't be), use `yarn`.
This kind of thing also happens with JS libraries/frameworks/APIs and the native language itself.
No, WebRTC is not part of the ES specification standard. ES, EcmaScript, the spec's official name for JavaScript, is standardized as ECMA-262, by the ECMA group. WebRTC is being developed and standardized by the IETF and W3C, unrelated to ES. The claim here is only that Safari is now feature complete on the latest JavaScript specification. That said, I don't doubt Apple has folks working on WebRTC. Apple tends to work on things and be very tight-lipped about it until late in the game when they are almost done. 
Windows and Linux version when? Until it's not locked to a single OS, I really don't give a shit about this.
Why not just make an alias so console.warn still works.
This explains a lot, thanks! I have been hearing a lot about firebug being discontinued, so I was wondering what it was. 
Right, he's supposed to say ES2016 (which has been released) and ES2017 (which is being finalised and of which it's pretty clear which features are going to be in) - my apologies. Other than that's it's pretty much accurate.
Heh, I am curious which browsers you're referring to with that last sentence :)
Why even delete the original? ಠ_ಠ=console.warn Done.
Or getUserMedia... yes it's almost 2017 and Safari cannot natively capture microphone input.
Konqueror of course.
Interesting. Looks decent, but a bit different. This looks like a async clone that uses promises. Relign is inspired by async, but there are major differences. For example, tasks can be any data type, not just promise returning functions. This library looks like it still expects the use of callbacks for tasks as it's wrapping them with promisify.
Microsoft shills I assume. 
You guys make so many assumptions in this thread... of course I was expecting to be answered. I was expecting a plethora of responses. Some insulting, some not. Even though my opinion has not been well received I'm still glad I voiced it. I also got to voice my opinion about how the people in this sub are. Which is a very insulting opinion but I'm glad I got to voice it even if I'm universally hated because of it. Maybe some people will wake up and actually take a hard look at the framework their using rather than using it just because reddit loves it. If they do this and their opinions don't change, then great. More power to them. My guess is that more than half the people who upvote the pro Vue posts have never used it though. They are promoting Vue because this sub has agreed that Vue is the new hotness.
I don't see the point of this lib. You can do all this with promise.all, promise.race, throat and standard ordering of promises. It's much better to learn how to organize promises than abstract it for very little syntax gains
That's the library's other function... 
Fuck man, I'ma wait till it's typescript so it can be exclusively badly programmed and tutorialized to the point that I can live in my gated community
Browser Compatibility ----------- Idk
&gt; While everything is moving on to ES6 and TypeScript Ummm, what are you talking about? You can mostly code in ES3 and be just fine. ES3 does not provide JSON support though and is a bit more verbose on accessing data in certain respects (no forEach and requiring use of charAt method to a character from a string at a designated index). That said you are just fine in coding to the ES5 spec well into the future. Furthermore, arrow functions are controversial. They are less code, which is good, but harder for many people to ready, which is worse. Classes in JavaScript are very controversial since many prefer to abandon the nonsense of inheritance when coding in this language. There are some useful utilities added to this language with ES6, but really most of ES6 is convenience and decoration that can easily be lived without.
That shouldn't be the deciding factor about whether "you give a shit" about it. The browser usage statistics of your users should be. They are the ones who ultimately decide what platforms you're building for. If you don't want users to use your site from an iPhone, then you're just fine. We wouldn't dream of dropping a platform in our product thats used by over 15% of customers.
I was talking about this: React.createClass({ render: () =&gt; { /* wrong this */ } })
`parseInt()` takes 2 parameters: what to parse, and the radix to parse from (base 10 is _usually_ the default). `Array.prototype.map` passes ~~two~~ three parameters: the value, the index, and the array. In other words, you're calling (ignoring the array since it's irrelevant here): parseInt('10', 0) // parseInt() probably does radix || 10, so '10' in base 10 is 10 parseInt('10', 1) // '10' in base 1 is not a number (there is no base 1) parseInt('10', 2) // '10' in base 2 is the number 2
function inside **map** receives more than 1 argument: *value*, *index* and *array* then this arguments are passed to **parseInt**, which has following arguments: *string value* and *base* so the output of this call will be like this: parseInt('10', 0); // 10 parseInt('10', 1); // NaN parseInt('10', 2); // 10 in binary =&gt; 2 
I did not know this until I did.
Because then console.warn would still work. Duh.
Other people have explained this. If you want the code to work you can use `Number` instead of `parseInt`
Whoops
Hello can you go and ask in this forum:http://www.html5gamedevs.com/forum/16-babylonjs/
Does that mean Opera and Vivaldi are also at the top with 78% support?
It won't live in the production code base, but it would be added as a build step on multiple production servers so it's a little different to the IDE analogy. Where it also differs is that the code for a given IDE is usually maintained under one roof.
Why would that be a blessing? It's actually a major pita in both macOS and iOS. If your device won't get a new major version you won't get security updates, fixes, etc. IMO it's a terrible idea to couple Safari and other apps with the OS.
So if I want to test mobile safari I need to buy an iPhone and Mac because apple can't be bothered with their massive profits to update their windows version of safari? This is why regardless of actual standards support, safari is the new internet explorer. Extremely expensive and difficult to work with.
As nice as this is, Safari is not developer friendly unless you buy into Apple hardware, which is not cheap. Until cross platform support comes back, Apple is bad in my book.
I'm hoping someone who's done a lot of testing gives you a data-driven answer, but for now I've got some anecdotal input. **Re: Would a bundler optimize our application better than we could?** How do you optimize your application currently? Webpack is powerful, only a badass team could recreate it. Maybe you are on a badass team. **Re: do we want to minimize the amount of require calls or does it not matter?** Do minimize the amount of dependencies you use in your project. Do **not** minimize the amount of require calls in your code. This is what bundlers are for: you write your code for humans and the bundler optimizes it for computers. Code written for humans should always explicitly require any files or libraries it needs. Consider switching from `require` to using `import` and `export`. Tree-shaking can help you optimize your app and that's only possible using Babel (or some other ES6 transpiler, if they're still around). **Test it** It only takes a few minutes to get a bundler set up. Add 30-60 minutes if this is your first time using a bundler. Acquire the tools to test your assumptions and you'll make informed decisions. [edited for formatting]
Note how it's *Safari Technology Preview* that achieves full support - not any official stable release. Then note Safari TP's [browser usage](http://caniuse.com/usage-table) (scroll down to the last item under Safari), and find a usage of 0%. All Safari versions summed together only reach ~2.4%. So tell me, do you actually have some source or basis from which you pulled that 15%, or did it come straight out of your ass just to downtalk someone else's opinion?
I doubt you'd get any long term performance, startup maybe. You could use https://www.npmjs.com/package/time-require to profile your requires. Requires won't be your bottle neck though. Node have a simple guide on profiling here: https://nodejs.org/en/docs/guides/simple-profiling/
Relign.series and having running promises in parallel for objects is a bit of a pain I agree. But those are the only two things that are medium level of difficulty. The rest is preventing people from learning standard ES6
It sounds like your arguing against abstractions. If I understand you correctly I think we're going to have to disagree. Abstractions like these aren't intended to obscure, but to untangle code that's hard to reason about.
... or you can use the `@autobind` decorator and avoid all that :-)
[Safari right now](https://s-media-cache-ak0.pinimg.com/736x/f9/2d/4b/f92d4b22e5cc707446004930603cdb4d.jpg)
In the grand scheme of things it wasn't actually that serious. Yes, it's embarrassing that it was caused by a single disgruntled user, and the fact that it's such a seemingly trivial dependency doesn't help, but ultimately, it was a single 2.5 hour partial-outage. That's certainly not a good thing, but it's hardly unprecedented for a web-service to have a few hours of downtime for one reason or another. (Deployment errors, DDoS attacks, unusual traffic, etc) --- And, yes, there's been work that should basically prevent it from happening again: namely npm made [changes to its unpublish policies](http://blog.npmjs.org/post/141905368000/changes-to-npms-unpublish-policy) to disallow users from breaking other packages by unpublishing their dependencies. And `yarn` in general makes the npm registry a bit safer to use, due to its caching. Since packages are cached, you only need to actually hit the npm registry the first time you install a given package version, so you aren't as dependent on the npm registry's availability in the first place. 
&gt; The browser usage statistics of your users should be. They are the ones who ultimately decide what platforms you're building for. Once saw a guy running a gay porn streaming server have to spend months customising his server to send bad non-standard connections full of bad hacks so that Safari would work.... At the time gay porn sites had 5% Mac users where the normal web was less than 1% (There is a joke in that somewhere). I don't envy that guy. I will never envy him.
Great answer, thanks for that link
It can be done entirely in JS, but the current implementation are too slow (MathJax), or incomplete (KaTeX). Wikipedia still uses images for equations because of that: https://en.wikipedia.org/wiki/System_of_linear_equations MathML would be a great improvement for education. I make mathematical animations https://animations.sowiso.nl/riemann.html like this. It is often hard to get the animations smooth with MathJax because it is so CPU intensive. And then I'm not even talking about other stuff. For example, if you use a library like React, or Angular, and want to add databinding event bindings to your MathML elements, that would be a dream. Now I have to do hacking with vanilla javascript/jquery, which often fails, because I can't reach the node I want.
Blocking mailinator signups indicates an intention to spam or sign users up for a newsletter. Bad form.
Good question for developers who already know and use React, Redux, immutable data structures etc, I see no benefit of switching to Vue. Vue doesn't introduce any new concepts or benefits of the rewriting your current/old application. For those who just started with this Javascript framework/library messy world chose Vue, as it is easier to start all components packed together.
They're very different teams. I don't think any current browser has people who work both on the JS VM *and* other parts of the browser.
This is why I am leaving reddit.
How is MathML an HTML5 spec? o_O
Evergreen updating (like Chrome, Edge and Firefox), Service Workers, microphone support, actual form validation, and bug fixing their viewport are all more pertinent and useful than the finer points of ES6/7. ES6 is already exhaustively polyfilled, but the rest are actively holding back the mobile web's potential.
Get ready to always be stuck with transpiling as there will always be new features waiting to be utilised. 
webpack supports bundling in a node env. You can use the `target` property and set it to 'node' or 'async-node'. Here's a link to our new docs page that covers all the target values. If you look in generated bundles you will find it leverages nodes require. https://webpack.js.org/concepts/targets/
I think the definition of not sucking is more about eliminating rendering errors (Safari has by far the most weird bugs with its viewport and rendering, a lot of them have been known and understood for years but not been fixed) and supporting basic browser features -- Safari has the worst support for the media streams API, the least ability to automate testing, etc. It's the biggest hassle out of all the major browsers.
A possible rule of thumb: Use arrow functions for ordinary functions, and use non-arrow functions (shorthand/declaration/expression) for methods. Just as in Python we wouldn't define a "self" parameter if we didn't need one, likewise in JavaScript we shouldn't define a "this" value if we don't need one.
Hi there, We have been developing a range of apps and got on the angular train when angular 1 was one of the big things. This was a huge step compared to the way things were done before. However, one had to read about two to five books to really understand how angular works. In addition, it was somewhat easy to get components tangled up with each other. Therefore we started to explore react when the likes of flux and redux became more widely spread. This was another great improvement of our code flow, but there was a lot of boilerplate code to write. A few months later I read a post about vue.js (even before 1.0) and started to play around with it. What struck me personally, was how well thought out the api is for daily usage. The direct data binding is very useful for small projects like dynamic forms, that just need to be enhanced to get a high degree of usability. On the other hand, one can simply include the vuex library and has the benefits of one way data flow as with redux, but with way less boilerplate to write. We have since written all our new projects in vue and are very happy with it. Almost every developer that started working with it, noted that they really like to work with vue on a daily basis, as it allows them to get things done very quickly. Vue 2.1.0 brought along scoped slots, which allows us to create awesome reusable components in a wicked easy way (a nice tutorial is here http://taha-sh.com/blog/building-an-awesome-reusable-autocomplete-input-component-in-vue-21-part-one). On a side note: we did also follow the development of angular 2.0 very closely and built a few small projects with it. Although the system is nicely designed, it does feel like it is built in a way java developers would think. Given that we are using golang as our main backend language, this was not such a great fit. In short, I would absolutely recommend vue.js to anyone, who is building web applications with a small to medium sized team. The api is amazing and one gets very productive after a short time of getting to know the framework. Single file components really help to get everyone to think in a component way and vue makes it very simple to create components with very little boilerplate. I would recommend to use vuex for everything that is more than a very small app, as it is otherwise easy to write a code flow that is hard to follow. For anyone interested: We did write a small docker container, that will allow you to use a webpack build system with live reload with very little setup (https://github.com/dkfbasel/hot-reload). 
That's true, but should we all be using assembler? :)
Arbitrary complexity is part of the utility of this project. 
Is this art ?
THIS, like saying my gmail address with a '+' in the name is invalid: ok welcome to my spam folder, idiots. 
There's quite a bit of literature out about this.. but being able to change css at runtime is a pretty major point, plus all of the stuff that a full programming language provides, loops, higher order functions, different kinds of scoping techniques, arbitrarily complex math, etc. YMMV
So I import a different module to the one I want to use? I don't think you understand the problem. Lodash allows you to import its functions individually so you don't bloat your bundle.js with several kbs of code you're not even using. For example I have a project where I'm using lodash/throttle, but nothing else from lodash. To do that I import it like this: import * as throttle from 'lodash/throttle'; The lodash definition file claims to support this usage, however it also pollutes the global namespace with types that have not been imported and are not really available. If you include the above import statement in a module, you'll notice that typescript thinks _.map is available even though this will throw an error at runtime.
Like most redditors, you don't look beyond the post above you and don't realize that the guy I first responded to brought up an unrelated point. Of course, I already said that but, like most redditors, you don't look beyond the post above you and never follow the thread so you don't know what's going on in the first place.
I take it you never worked with &lt;= IE8 then. There is no browser on the planet inferior to IE6.
That's definitely not the right way to do it, and I'm surprised it even works. You should switch to doing what volar92 recommends. It means you can use the standard native import syntax which TS can then transpile to commonjs imports if needed.
my favorite part though: **License** Idk, MIT, I guess
WebRTC is a web/browser protocol and API, whereas ECMAScript just specifies what's part of the JavaScript language itself. That means ES also doesn't include things like the DOM api - for example, there's nothing in it that says your JS implementation has to have a `querySelectorAll` method, which makes sense when you think about things like Node. Instead web standards like these are defined elsewhere (usually by the WHATWG/W3C/IETF). Anything in [this list](https://developer.mozilla.org/en-US/docs/Web/API) (notably `window`, `document`, `console`) is outside of the ES scope.
What does ES6 modules being available imply? Does this mean that we can write code which uses `imports` and `exports` without the transpiling step and / or the bundling step?
I once had a bug in which the text was written over top the scrollbar and off the screen in IE6 and IE7. Add in * the severe lack of support for CSS and JS * the number of rendering bugs * the slow development cycle and lack of automatic upgrades and IE still wins (loses) this fight hands down in my book.
You'll get minor patches up to a point, but in Mac software gets old pretty fast. You are forced to update your OS and hardware much faster than in Windows if you want to stay current. For example the latest Photoshop version only has support down to Yosemite, but in Windows it goes back to Windows 7 which was released around Snow Leopard. https://helpx.adobe.com/photoshop/system-requirements.html Same thing with Safari. If you want the latest version you'll need one of the latest OS versions. There's no Safari 10 for Mavericks or Mountain Lion.
&gt; Safari is backported to previous versions Only to the latest OS versions. Safari 10 for example is not available for Mavericks and below.
My corporate work must support both mobile and desktop browsers. And I mainly use Firefox (I've been using Firebug for so long that I've never gotten around to learning how Chrome's developer tools work) so I my workflow mainly consists of getting it working on Firefox and then having QA let me know if there are any issues in other browsers. For the last 10 years that has worked well for me.
I donno. It's just smth like `npm i babel-core babel-preset-es2015`. Pretty straight forward; core/cli + preset/plugin &amp; maybe a loader for your bundler of choice. Seems reasonable since Babel 6 is more than just ES2015 after all.
Ahh ok. Thanks for explaining some of it :)
How did you manage to use left/right quote character instead of just quote? Did you use a word processor to make your code, or did you use non English keyboard?
&gt; I donno. It's just smth like npm i babel-core babel-preset-es2015. &gt; Pretty straight forward; core/cli + preset/plugin &amp; maybe a loader for your bundler of choice. &gt; Seems reasonable since Babel 6 is more than just ES2015 after all. Yes, that's clearly the argument from it's just not that complex for those of us who know what we are doing crowd. And it gives zero fucks about n00bs suffering from javascript fatigue. That's what the whole thing is about. I'll go one step further. I want to write in ES6 and never fucking install either that piece of shit npm or that piece of shit node on my computer. I realize I need to. But the simple desire of wanting to write in ES6 shouldn't require that. Ever. But given that I do, how about a *most people use this* setting and a *full install* setting? Instead even now, it's for each piece of shit you are forced to use, come back here to this website to learn of the new and proper way to install the additional crapola you need to get babel to work with your favorite piece of shit inflicted on you by the other asswipes in the javascript fatigue is a good thing camp.
&gt; But the simple desire of wanting to write in ES6 shouldn't require that. Ever. Over time ES2015 support will increase and things will get easier. Bleeding edge language features + wide support means smth like transpiling. For now, if you want, stick to ES3 or ES5 then that's doable without it.
Nevertheless, this isn't year zero of programming or year zero of personal computing or year zero of plugins. Installation of the Babel Transpiler still should not require: + npm + node or have a zillion other additional little plugins to install every other little thing needed. Babel 6 probably had the best of intentions when they broke things apart, but concern for noobs, beginners, and intermediate developers was not any of their evident priorities.
Why is let bad?
Readability, smaller size. But yea, I'm agree that it can goes complex and complicated easily. And actually I'm trying to not use it as much as possible, but I feel I falling in love to it last weeks. It's not a problem that browsers can't understand it, that is The Spec., so they WILL in near future.
bad performance wise refer to this tweet chain https://twitter.com/getify/status/806585326177320960
Pretty much no developer wants to support safari due to lack of crucial Web APIs and DOM APIs.
We can get around it using transpilers, but we can't get around lack of support of SW and other crucial APIs that are a must for Progressive Web Apps. Clearly apple is fearing PWA eating away App Store installs.
Maybe it's worth conceding that bleeding edge language features and transpiling aren't "noob" appropriate waters to be wading into.
Just read that article from Facebook about Yarn (the issues they ran into are also what I was wary of) and got it up and running. It's perfect. Exactly what I was after, thanks for that.
Yep, Yarn is exactly what I was after, thanks
Does installation of Microsoft Office require me to install Microsoft Visual Studio? Why shouldn't office require I have a compiler? Does installation of Microsoft Office require me to determine which of a zillion C or dotnet runtime libraries I need on my machine? Why shouldn't office require me to figure out which of a zillion c or dot net runtime libraries I need? If I install some sort of cross compiler from say tcl to java what I would expect is a single download and then an installer that attempts to sniff out where my jre or even jdk is, and if it can't it then asks me. And I would expect it to install a configuration panel or even a setup tool so that if options change in the future, it's easy to reconfigure it from there. Same thing with when I install IDEs. What I do not expect is a literal spanish inquisition on the download page, interrogating me and offering 30 different install options. I actually don't give one single fuck about Babel, npm, node or anything like that. And most users don't. I want to use the fucking thing for one fucking job. Just transpile my shitty ass program and yeah, give me three dozen error messages about a wrong place squirrely bracket but otherwise shut the fuck up. I don't want to babysit it, change its nappy, breastfeed it, spoonfeed it, or anything. I want a simple install so I can get on with life. And that's what 99.9999% of successful programs, apps, tools and dev teams have figured out over the past 60 years of computer development. But with JavaScript, each mine you step on, each pile of shit we throw at you is considered to make you stronger. One more of the boys. Ain't we great.
Took them long enough
I don't transpile anything.
The Edge app is out of the OS, but the web platform code is still in System32, e.g. Chakra and EdgeHTML. So no new JS languages features in Edge until a new OS rolls out.
Weird, I could have sworn it was necessary, but apparently it works just fine without it in Chrome and Node. Edit: but Firefox requires it. Edit 2: updated Firefox from 41 -&gt; 50, no longer requires the `.bind` either Edit 3: not needed for IE11 and Edge either. I must have missed the memo.
So with this, now I'm most interested in seeing what example best practices for a dev environment look like. I'd love to see Webpack and Babel config go away for some of my simpler projects.
I thought the WHATWG loader spec hasn't been finished yet so although the syntax is finalized, there still may be some slight changes to how things will ultimately work? https://whatwg.github.io/loader/
ES6 arrows don't transpile.
&gt; javascript toxic waste dump &gt; FWIW - you're going to have a hard time being taken seriously when you use language like that. I have a hard time taking you seriously (and any claim you aren't either a dipshit, an elitist jerk, or part of the problem) that you deny the seriously shit that much of hte community recognizes as the javascript environment. http://i.imgur.com/3NrrI4e.png http://i.imgur.com/VvhIwFn.png http://i.imgur.com/n7JZ8os.png http://i.imgur.com/G8fXLtR.png Frankly, I don't a rats ass if you take me seriously or not. You remind me of the shitheads still insisting that identity politics is the way to win the Presidency and that the Russkies hacked the ballots.
&gt; Arrow functions, why we do have to move away from normal standards from other programming languages? JavaScript arrow functions are syntactically nearly identical to lambdas in C#. &gt; We are even writing code that our browsers can't even read we have to use another complicated tool This is one of the best things about JavaScript. The platform is ridiculously fragmented in what's supported because there are a large number of browsers and browser versions and not everyone can upgrade. Despite that we can still write using modern language features and don't need to pander as much to the lowest common denominator. You might not have written JavaScript before polyfills or before parity was even important across vendors but I'll be the first to say that those days were very, very bad days.
This is due to your server (nginx, apache, caddy... etc) is not properly set up to handle a single page application. When you request /somebadurl or even /somegoodurl on your application directly, the server is going to look for that file and then an index.html inside of that file. For example when requesting /somegoodurl your server is going to look for (serverRoot)/somegoodurl/index.html You need to rewrite your configuration file to redirect all requests to the index.html file at the base of your application. There are examples of this if you good. I use caddy, so here is an example of my caddyfile: https://github.com/Skilgarriff/Personal-Proxy/blob/master/Caddyfile.Reactjs
nah, I would disagree because I deal with these people often. To the layman they my seem smart but it's a facade, I have never met a truly intelligent person that exclusively mumbles jargon. A smart person would identify another persons domain and speak of their problem set in the listeners terms. In programming often times pretty much the exact same concepts are described in radically different ways, programming is not quantum mechanics, we deal with discrete mathematics, binary switches, anyone who can't speak plainly on logical terms any programmer can understand is not smart. IMO if you ramble buzzwords and think that counts as a valid argument then it screams "I don't know shit I hope my buzzwords make you too intimidated to prod further". When I talk to C programmers I talk about JS in terms of [single assignment form](https://en.wikipedia.org/wiki/Static_single_assignment_form), if I am talking to aging ruby hipsters I talk about JS in terms of Ruby Object Model and compare and contrast. Every single intelligent person I have met can translate their domain in terms another person can understand(outside of theoretical physics) which is obviously a little counter intuitive. But we deal with a series of switches, it is or isn't, there should be no way any good programmer can't explain the underlying logic in layman's terms. If someone tries to argue using a **slow** and **massively bloated** framework is "good", then they're an idiot. I know because I work in enterprise, everything is so filled with buzzwords I want to puke, we develop SLOW and SHITTY software and I am forced to comply due to seniority and red tape. When someone says **enterprise** it mean someone who has buzzworded their way to the top by using buzzwords to convince non technical people theyre smart. It destroys my soul and I wish Richard Feynman's Ghost would appear and say "hey hey, what the fuck are you saying. Explain it, if it makes logical sense then i'd agree". 
You can develop mobile apps with .net standard now which is cross platform. also I believe Xamarin works on Windows phone but I am not 100% sure on that.
Probably because, unlike Safari, Edge supports ORTC, which is the successor to WebRTC. https://www.sinch.com/learn/ortc-vs-webrtc/
Oh. That memo? I ate it, yes, sorry. Did I read it? No, obviously not. (TIL!)
There are libraries for server-side programming languages, to download content from the Web and extract information from it; although "curl" is a binary, and "Beautiful Soup" is a Python module, those are exemplars of the two things you're probably looking for. The idea is that you take that product URL that the user input, whether as part of a GET request or part of a POST request, and then use the server-side code to get that info. from elsewhere on the Web, and put the info. into a page to display to the user. (You could also go in the Ajax/SPA direction, by having the page send an Ajax or Fetch request to a server-side script, and then display the response.)
Meh only problem with Chrome is it feels like an OS more than a web browser, sort of a privacy nightmare. 
Shots fired
This is why I feel this is such a complex language that only people who got into it years ago can properly keep up in the industry anymore, they went through so many more pitfalls and are basically almost qualified to create new iterations or features of the language, while clowns like me are still tripping over the object oriented nature of the syntax itself. And I thought CSS was bad, feels like my brain is frying everyday. 
Nahh, IE6 wasn't quite so *insane*. Outdated perhaps, and held back the web for years, but it was rather logical in its insanity. Safari is just broken and random things that every other browser have been able to do for years, Safari can't. I'd honestly rather have to develop for IE6 in 2005 than Safari today.
I think Wes is pretty good about this sort of thing. He sends emails now and then, but they don't feel spammy. 
&gt; .net standard Yes, the standard library is cross platform now, but iOS, Android and UWP still need platform-specific code to make complete apps. &gt; also I believe Xamarin works on Windows phone but I am not 100% sure on that. Last time I ran Xamarin Studio on a Mac, it didn't let me deploy the UWP version. I didn't dig too deep into that, though.
FWIW, our site has Safari on #3. Chrome and FF are on #1 at ~27% closely followed by Safari with ~24%, IE only being at ~13% and Edge on ~4% to complete the top 5. We are a German site, one of the few countries with higher FF usage than Chrome, and the topic is digital photography which could explain the high amount of Safari users. edit: spelling
not to mention some of those lets should probably have been const. Plus how likely is it that he ran it on native es6 and not transpiled?
Signing users up for a newsletter is a typical intention that I think most potential users are okay with. Difference of opinion I guess.
Post the code
I've worked on a system much like this and we did a transition, but in the other direction (from multiple components to a single one). Here's some stuff that I learned, and hopefully that you can learn from. * Automated validation is incredibly helpful. Some form of code checking ([Closure Compiler](https://github.com/google/closure-compiler) or [TypeScript](https://www.typescriptlang.org/), etc), unit tests (I like [Karma](https://karma-runner.github.io/1.0/index.html)), and maybe even linting ([ESLint](http://eslint.org/)), really helps make sure that some teams don't break others' code. It also provides wonderful peace of mind when doing whole-codebase refactors like this one. I'd say implement this ASAP. * Make sure somebody is keeping track of common good practices and patterns. It's very easy for teams with separate codebases to stop communicating, and that removes your ability to share code very quickly. This person should at least be aware of most commits made in the company. * Make a set of rules about what kinds of code should _always_ be shared, and have this enforced in code review. Overall I think the most important thing is keeping the benefits of a single repo (lots of shared code, ease of access, consistency) while gaining those of split repos (separate deploy &amp; dev cycles, more flexibility, better monitoring). Finally, in your situation I personally wouldn't split the repo -- instead, I'd create near-top-level folders for the environment-specific code, and create multiple build pipelines that each have a different set of source folders and produce separate artifacts. This would allow you to keep your easy, one-repo development while still being able to do separate deploys. Good luck!
Sorry. Here's the code in the plug-in, that's used for the favorites page. &lt;div class="add-item"&gt; &lt;div class="wishl-item-price {{priceClass}}"&gt; {{{variantPrice}}} &lt;del&gt;{{{comparePrice}}}&lt;/del&gt;&lt;/div&gt; &lt;form class="cart-form custom" action="/cart/add" method="post" enctype="multipart/form-data"&gt; {{#if showAddToCart}} &lt;input type="submit" class="purchase button" name="add" value="{{showAddToCart}}" /&gt; &lt;input type="hidden" name="id" value="{{variant.id}}" /&gt; {{#each item.properties}} &lt;input type="hidden" name="properties[{{@key}}]" value="{{this}}" /&gt; {{/each}} {{else if showSoldOut}} &lt;input type="submit" class="btn wishl-btn add-to-cart disabled" name="add" value="{{showSoldOut}}" disabled="disabled" /&gt; {{/if}} &lt;/form&gt; &lt;div&gt; {{#if deleteLabel}} &lt;a href="#" class="wishl-del" data-item="{{itemId}}" data-item-title="{{product.title}}"&gt;{{deleteLabel}}&lt;/a&gt; {{/if}} &lt;/div&gt; &lt;/div&gt; And here is the code that is on the collections/product pages (that works without sending me to a new page) : &lt;form class="cart-form custom" action="/cart/add" method="post" enctype="multipart/form-data"&gt; &lt;div class="variants hidden"&gt; &lt;select id="variant-listbox" name="id" class="medium"&gt; {% for variant in product.variants %} &lt;option data-sku="{{ variant.sku }}" {% if variant.inventory_quantity &lt;= 0 and variant.available == false %}DISABLED {% endif %}{% if variant == product.selected_or_first_available_variant %}selected="selected" {% endif %} value="{{ variant.id }}"&gt;{{ variant.title }} - {{ variant.price | money }}&lt;/option&gt; {% endfor %} &lt;/select&gt; &lt;/div&gt; &lt;input id="quantity" type="hidden" name="quantity" value="1" /&gt; &lt;div class="add-to-cart"&gt; &lt;button type="submit" class="purchase add-to-cart-button" name="add" id="add"&gt; &lt;div class="add-plus"&gt;+&lt;/div&gt;&lt;div class="add-to-cart-label"&gt;{{ 'products.add_to_cart' | t }}&lt;/div&gt; &lt;/button&gt; &lt;/div&gt; &lt;/form&gt;
&gt; For the same reason, you have to use a decorator (also stage 2) in Angular 2 to pass additional metadata about your component that simply cannot be expressed through the plain class syntax This bit isn't strictly correct. All Angular's decorators do is exactly what you're describing, eg `MyClass.annotations = [new Component(config) ]` - in fact, we downlevel to exactly that syntax.
Es5 modules don't exist, unless you're referring to common js modules? Those can be imported using ES6 syntax like the following import * as angular from 'angular'
Can You show us .js You use to handle it, please?
Fetch the page from server-side using [`request`][1] module (this is the nodejs equivalent of "curl") and then send it back to the client. [1]: https://www.npmjs.com/package/request
I say make a demo of your project in angular 1 and react. And then on the basis of your expeirence with demo, choose the better option. If you want more options, add Vue and aurelia to your lsit. but no more than that. 
Babel transpiles ES modules (import/export syntax) to CommonJS (require/module.exports): https://babeljs.io/docs/plugins/transform-es2015-modules-commonjs/ Edit: [this article](http://www.2ality.com/2015/12/babel-commonjs.html) explains in detail how exactly ESM =&gt; CommonJS transpiling works.
Since all such frameworks are compiled into vanilla js, you can do literally all the same things. But how much time it will take to develop and debug it? Actually, the main thing which is required for reach JS apps is not a framework itself, rather it's any modular/build system. And frameworks could (or could not) make development easier/faster, depending on tasks, skill level and so on.
It's not the standardized behavior. TC39 is working on standardizing the CJS module integration with ES6 modules *now*.
addendum: almost by definition there is nothing you can do in a framework that isn't possible in vanilla JS. BUT something that is possible in 1000 lines of JS code can often be done in way fewer lines using a framework (and possibly faster). for instance take a look at something like socket.io, all of it is possible to implement in the default vanilla JS but in the framework I just define my events and how I react to them (I don't care about the technicalities of the net code and let the framework do that for me)
Well considering it sort of runs chromebooks (that's the OS part) and a privacy nightmare (because it's google). 
Answered to other guy asking the same. 
Sublime Text 3. 
Where?
Here: https://www.reddit.com/r/javascript/comments/5h6fjn/safari_supports_100_of_the_es2015_es2016_and/daz95hs/
The kernel is Linux, that's about it though. And as you said uses chrome as the DE. Most of the sand boxing that Chrome exhibits is not open source material, who knows what is actually gathered and what not, and it's integration with other Google services are baked in capabilities. Safe to derive that a company that bases its existence on the advertising industry, or as the intermediary between industry/consumer in the form of information exchange of people's data in many forms, my feelings hold valid. 
Right above?
Okay, And now? http://codepen.io/Linuxdirk/pen/ObwJEV
You are absolutely mistaken: https://www.chromium.org/developers/design-documents/sandbox You're talking out of your ass.
Aight I concede. 
and I think you not provided enterViewport and exitViewport callback. I think this is the base APIs.
Haha, did I win an argument with a stranger on the internet? :-) 
You went too low in your analogy. Your example is equivalent to saying you need to mine silicon and make chips before you can write javascript. The issue with frameworks is you must mold your workflow to the framework and work within the frameworks limitations. With many frameworks, it's almost like building tract housing that all look the same and work the same. The "reinvent everything" is a reddit fallacy that needs to stop. Most web developers and the companies they work for, like mine, put together their own workflow years ago, a "framework" if you wish, that need not be re-learned or reinvented, does everything they need and customized to how they do things and *more* likely to be faster and easier to use because of that.
You can get import/export client side with webpack "vanilla" config, new browser versions allow asyc/await, and node 7 should support async/await behind a flag. The real question is if you have to support non-recent browser versions and thus need transpilation.
this has to become the next leftpad.
simple build-systems, plugins, everything you need w/out the overload of some IDEs. sublime rocks.
I don't have 100% solution, but I have few hints from my experience: 1. Visual styleguide, absolute must have. Every developer should have possibility to browse all the components in projects, and see how they render, what data they receive, what are their dependencies, what CSS classes they use etc. It should be generated automatic, or at least demi-automatic, for example: https://github.com/pocotan001/react-styleguide-generator Shared knowledge can be huge gain (and from what you wrote I think you have some problems with communication and knowledge exchange). 2. every programmer should create components in similar way. Folder structure, filenames, organization of CSS styles, properties/events of components should be standardized. 3. Decoupled components (decoupled CSS, components independent of external HTML structure, components independent of global variables, components without many JS dependencies etc.). Imagine that every component is Lego brick. Fitted everywhere. Separate application specific code from general reusable code. Theming can be injected to components somehow (for example by using CSS classes - look at the Bootstrap - the same classes but they can have various colors. People also inject theme styles via React context etc.) 4. `situation where developers from one team A are breaking apps in team B, by doing some trivial fix/improvement on UI component` Tests should help. Even retroactive ones (after finding bug). 5. Graphic/UX designers should cooperate with programmers. They should help build reusable components and understand reusability and maintainability needs (sometimes they don't!) 
Where is this video?
Gotcha.
&gt; What can you do with these that you can't do writing vanilla javascript? Nothing. That's not the point. The point is that they're able to do those things much faster and much more consistently than doing it by hand. I saw a talk by the developer of Vue recently, and he talked of Inherent Complexity, and Instrument Complexity. I liked these concepts. Inherent Complexity is the problem itself. Trying to do some things is hard. Some is easy. Making a box turn blue is easy. Searching an airline flight API to map connecting flights and generate an itinerary, then book the flight and confirm the reservation... is like... hard as fuck. Instrument Complexity is the complexity of the solution. If you have to set up elaborate and all-consuming technology stacks, set up a windows server, build processes, etc... that's a high Instrument Complexity. Throwing a PHP (or node) page on a server that pulls shit from a database and displays it... very low Instrument Complexity. Where this gets interesting is the relationship between the two. If you have a low inherent complexity problem, and you use a low instrument complexity solution... all is well. If you have a high instrument complexity solution with a low inherent complexity problem... the wheels have fallen off. The thing about the inherent complexity of a project is it tends to change. And it goes up. And quickly. A project that does one thing is easy. As it does two, or three, or four, the number of interactions and potential issues increases exponentially. Your inherent complexity goes through the roof. And your low Instrument Complexity solution simply cannot contain it. The **point** of frameworks - imo - is that their instrument complexity is known and a given. Taking a scale of 1 - 10, let's say the inherent complexity of jQuery (for example) for a simple project is a 1. But you start adding a million plugins, a bunch of dependencies, build processes, handling events on different pages, etc... it all spirals out of control. Your instrument complexity gets up around 7 for a 5 problem. Something like Ember might be a 4. And given an Inherent Complexity of 8 the Instrument Complexity is still going to be a 4. Maybe a 5. Maybe. Managing complex apps, while keeping them comprehensible and maintainable, is the point of frameworks.
Sites that use WebRTC or Service Workers don't. Popular sites are lyft's web app, appear.in, flipkart web app etc.
We use similar project for React (https://bvaughn.github.io/react-virtualized/#/components/Collection). Maybe you find some inspirations there :)
**VIM** or bust. Been using it for eight years for primarily web development. I've customized my vimrc over the years to my liking and even written a plugin or two. I use it mostly on the command line and prefer linux (ubuntu) as my dev environment.
IntelliJ over WebStorm? How good is IntelliJ for non-java languages? I use pycharm and WebStorm but it's really irritating to switch between them while working on a django app. 
I'm not blaming you. I'm just trying to understand what caused it, so that I can use it for solving other users' problem.
Intellij is basically Java + WebStorm + PHPStorm + PyCharm + RubyMine + any language specific editor from idea
Not an IDE, but Visual Studio Code. I love the intellisense support, git integration, and built-in Node debugger.
Just because there's a new one, it doesn't mean that the old one is no longer working.
Any IntelliJ IDE (Webstorm/phpstorm/etc) are the best for javascript atm.it's a worth investiment. Sublime and atom are for small projects, in a real big javascript application (with many people working on it) I think it would be unwise to use either, I'm not sure about their plugins but last time I've checked there wasn't much to help with reference tracking/code navigation/smart autocomplete/etc. While Intellisense for javascript is still lacking, it helps a ton. I know you are going to see lots of devs on youtube coding on their sublime, but they are mostly home developers....at enteprise level I think an IDE makes you way more efficient. VSCode is the only one that is coming close to Intellij. Actually I could see VScode surpqssing Webstorm in the future.
Whatever. Anything is better than JSON for configuration. Comma issues make me throw a tantrum each time I want to edit a file.
Tried MeetUp?
Visual Studio Code. Pros: All the power of Sublime Text, but with a built-in package manager, git support (you can diff, commit, push and pull within the editor) and a node debugger. Also supports Markdown previewing out of the box, and shows CSS colors in the editor (like Brackets). Like Sublime, it's multi-platform (Windows, Mac, Linux), but unlike Sublime it's also free and open-source. Cons: It's made by Microsoft.
VIM all the way, been using it for the past 4 years and modal editing has allowed me to focus more on work and not in editing or doing repetitive tasks.
Anything that accepts comments in it is better than plain old JSON. Even a .js file with `module.exports = {}` would be a life saver.
/u/BTPL Babel is using JSON5 format. You can use comments in `.babelrc` file.
It is my first angular 2 app and i would appreciate your feedback! I'm open to any questions :)
Because we don't want config to be Turing-complete?
Hi /u/unnivm, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `youtube.com/user/videovideoguy`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [Unni Mana - YouTube](/search?q=%28and+site%3A%27youtube.com%27+author%3A%27unnivm%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;syntax=cloudsearch&amp;feature=legacy_search)|12|100%
But even then, do you check per version as well? And how incredibly small is the usage for the latest Technology Preview? Exactly.
But it's amazing in webpack config to be able to use require statements and stuff. 
Oh? Never tried it, thanks for letting me know!
I block these because they bounce when I announce a new course, and it hurts my deliverability. gmail +modifiers are totally fine 
Very welcome! Enjoy them
I'm just gonna leave this here: http://codereview.stackexchange.com/questions/135382/request-queue-for-league-of-legends-api
I think IntelliJ based products are somewhat like Sims. Efficient way for sell one product many times (Sims + Addons, various flavors of IntelliJ).
You can do `.babelrc.js` without making it hard to read. You don't *have* to do anything dynamic, currently my `.bablerc.js` file looks like this: module.exports = { //static JS Object }; Mostly, I do it this way because like being able to omit quotes and use familiar comment syntax, without having to learn yet another markup language, and while leaving the door open for future dynamic stuff, if I find an appropriate reason for it.
Only stoopid people would criticize this, the latest and greatest JS innovation. Am refactoring now. 
&gt; I tried a workaround transforming 'for each' into something before linting Try putting `// eslint-disable-next-line` before every 'for each' line. http://eslint.org/docs/user-guide/configuring#disabling-rules-with-inline-comments
Correct, and this is not expected to land in browser specifications.
Woooooow! You are the one and only! Very very very thanks bro! You realy helped me a lot! Sure, I'm beginner in JS code, but Reddid users help me a lot!
I usually switch between visual studio code and atom for personal use. Most places I work at use sublime. They're excellent editors with a decent community support and plugins to add features.
[**Blink**](https://en.wikipedia.org/wiki/Blink_\(web_engine\)) is [**Web browser engine**](https://en.wikipedia.org/wiki/Web_browser_engine) that use to render marked up content. It is **not** JavaScript engine. [**V8**](https://en.wikipedia.org/wiki/V8_\(JavaScript_engine\)) is [**JavaScript engine**](https://en.wikipedia.org/wiki/JavaScript_engine) that use to execute JavaScript. Chrome, Opera and Vivaldi use V8. That's why they have similar percentage of ES6, ES7, ES... support.
Both browsers and node implement their own loaders, the JS spec does make some invariant constraints upon Modules, but it does not specify loading mechanisms. V8 will not implement type="module" no the Node loader. For the v8/chrome/node ecosystem: Blink will implement type="module", Node will implement its own loader that is still in flux for specification due to incompatibilities with CJS, BabelJS ESM (they are not to spec), and real ESM.
Huh. TIL. ... is there a way to tell my text editor that it's a JSON5 object? Because otherwise it complains if I don't use proper JSON syntax.
Hi, Thanks for the answer, but this can't make it. ESLint works in phases, code is parsed first, and rules are applied after that. The 'for each' messes up the parse phase, and ESLint doesn't even have the chance to kick in. That's why I'm trying to upgrade syntax support at parser level. Unfortunately, while I've found a complete guide on implementing transform plug-ins applied after parse, I can't figure out (yet) how to modify the parser grammar.
Thanks for the answer! We wont decide anything at this point, and i do see benefits of a single repo. We are more interested in how to logically do this so it enables us growth &amp; async dev but also brings us stability and consistency we had with shared components monolithic codebase. We are aware that those two are nearly impossible to have at the same time, but we do want to invest in **tooling** and practices. 
hum, latest researches I made tweaking my keywords a bit made posts come up saying that babel doesn't support custom plugins at syntax-level T_T
By the time Safari TP gets released as Safari 11, the other browsers will be ahead again...(Kappa)
Tell that to Alon Zakai.
Yes you are totally right, but I would divide my (personal) definition of "smart" into levels in order to clarify my position. Level 1 smart is "I can understand complex/abstract concepts and re-apply them to solve problems. Level 2 smart: "I can understand complex/abstract concepts and recognize **when** to apply them to solve problems. Level 1 smart would not be able to do what you describe - they just think it's awesome and throw it around because they are really proud of themselves for understanding it. I agree this is not **true** intelligence, but in every day life these people would be regarded as smart people and will certainly be above the average in that department though maybe only by a little bit. Hope that makes sense, basiucally I'm saying we agree!
The dequeue operation of a (properly implemented) queue is O(1). Array's shift is O(n).
I use Atom and it highlights invalid JSON for me, at least the text gets highlighted in red if I don't use quotes. I'm pretty sure `language-json5` only works on files that end in `.json5`, and I can't do that for `.babelrc`, I don't think. Or if not, I don't want it to assume that *all* my JSON files are JSON5.
What tweet? JK. It's a cool announcement. Looking forward to testing it :)
your yaml config can be translated into js as { env: { development: { plugins: [ 'istanbul', 'transform-es2015-modules-commonjs', 'transform-export-default-name', ] }, production:{ plugins:[ 'transform-export-default-name', ] }, } so, in the guise of static config, you actually want to alter the structure of config object? Not bad idea! but this matter is unrelated to yaml/js. &gt;There simply isn't much that you can do with it beyond anchoring, merging and sets. maybe you are right. maybe yaml is the silver bullet we are all searching for! But I don't believe so. Frankly I don't know even know what *anchoring, merging and sets* are, so arguing any further is useless. My original point was that yaml config will increase one more thing to learn. While js is something we already know. Is yaml a good format for config? I am sure it is. But should we use it for a js project when .js option is available? No. 
Not sure if sarcasm, because the linked issues uses webpack as "when things go too far" (Note: I have nothing against webpack. I am an active contributor to the webpack ecosystem. I am simply referring to the example used in the issue being discussed.)
Open `.babelrc`. Open console. Type "Grammar", select "JSON5".
It's all preference, but I don't really like a top level "web" directory. It doesn't seem to be a functional description like the others (e.g., models, config, worker). What is "web"? World Wide Web? Furthermore, do you use web/middleware without a route? I'm guessing the only function of web/index.js is to get to web/router/index.js. Actually, I'm a little confused as to what index.js does at the root vs web/server.js. I tend to put server.js at the root and then call into /routes from there. Save a level of hierarchy.
Huh?
A lot of Sublime Text's features can be found in Atom or VS Code but Sublime Text's performance is far better.
Nah. I genuinely enjoy using that. 
You can turn off most the Java stuff and just enable the feature you want. It supports many more languages (all customizable). The UI is a little different and sort of assumes a Java workflow, but that's not really an issue, just a minor difference.
js users know js, if they know yaml too and want to use it, then add a conversion step to your startup/build.
Yeah, I've tried Atom but it didn't impressed me in comparison with Sublime. And about VS Code – maybe, will check it next time, thanks.
Thats what I have suggested. :-) https://github.com/babel/babel/issues/4980#issuecomment-266055221
maybe that's why the author had it in the comparison graphs
Not all value is monetary. I have education from open-source projects that I wouldn't be able to get at a University. I find myself motivated to code for fun, I find it enjoyable, some people don't. I decide to open-source most of my work because I was able to learn beyond what I learned in school through other open-source projects and I'd like to give back.
Unless developers work in Vim with some half-arsed config I don't even see it as a problem. How would anyone mess up indentation in this day and age?
The reason for that is simply because Babel (and rollup) provide an Interop helper. I doubt this will become spec 
We have one client with multiple different projects with one backend. We keep the fronted currently in one large repo with different folders for each app and one for common. On top of that we are using webpacks resolve config, to enable us to directly import stuff from the common module. Edit: we plan on changing this structure to private npm modules. We also start developing a component in the app where we need it and pull it out when we need it somewhere else. 
I may do this for code organization reasons, but since each function would exclusively call the other, and there didn't look to be any large state which could be picked up early by the garbage collector, I decided against it when writing. That is, I'm not sure there would be a performance benefit (in either memory or execution time) to separating the MST generation from the Graph generation. Also, do note that the MST is not *found*. The algorithm works by generating the MST first and then filling in the rest of the graph in such a way that avoids changing the MST. I'm not sure if that way of implementing this was actually better in the long-run, since it ends up being *O(n^2 log n)* anyways -- equivalent to building the graph randomly then finding the MST. But it does have the benefit of ensuring there's exactly 1 MST for the graph in-place. But that could be done with max *O(n^2 )* overhead during randomization anyways... So I would say testing other algorithms (and probably other languages)would probably be worth it if the ultimate goal is performance. In any case, thank you!
"prototypal inheritance which no one understands and no one really uses." Hyperbole much? Prototypal inheritance is quite simple if you just spend a little time educating yourself on it. 
I know. With that one line I realized that we are dealing with either an inexperienced or a clueless developer here. 
Curious if you've found an acceptable plugin for handling merge conflict resolutions? That's the only thing holding me back from switching from Atom. Webstorm has my favorite merge tool. Atom's git-merge package is a decent enough alternative. I don't know of anything for VS Code though.
&gt; In some languages it might not matter, but with JS design-patterns that use closures (e.g. memoization) it is necessary to think about multiple scopes at a time. Interesting, can you exemplify? I've used closures in languages that don't require an extra keyword for variable declaration (e.g Python). const behaviour as the implicit default, plus let in case you want to redeclare the variable work in all cases that come to mind. &gt; As much as I would like for it to be the default, we can't break backwards compatibility because the end user (the person who matters most) wouldn't be able to visit old sites I actually meant I don't mind having to stick a flag like 'use strict' if that helps enforcing a subset of the language. I only feel that 'use strict' falls short in what it forbids. To use the same example, if let/const are preferred to var, then such a flag shouldn't allow using var. Old code wouldn't have the flag, so it would still work.
Importing it that way imports all of lodash even if you only use throttle. To just get throttle, you need to import from lodash/throttle. &gt; The reason typescript thinks lodash is there is because of the type definitions I believe. I know. That's the problem. Typescript it supposed to provide type safety. It shouldn't provide intellisense for functions I've never imported.
You have to create jsconfig.json in the root directory of your project. Have a read though https://code.visualstudio.com/Docs/languages/javascript
Thanks, I'll have a look. 
Rather have `function getElementsByAttribute(value) { return document.querySelectorAll('[' + value + ']')` because otherwise you are forced to enter both arguments, and are not able to do getElementsByAttribute('name') or getElementsByAttribute('name^=something'). 
I've been developing on Ubuntu for several years and everything works fine, similar to OSX.
&gt; What happens when you go to a company that uses a popular framework that you don't know? I can learn it from the plethora of resources available all over the internet &gt; What's the difference between internal and external documentation? It's not documentation, it's other resources like StackOverflow, Github, etc. &gt; You mean you don't want to learn how to program? It's all code to us so you got a problem with that? I already know how to program, but if I'm switching jobs, I can't add any new skills to my resumé. No one outside your company gives a shit if I learned some obscure home-baked framework. &gt; So how did people do any of this before there were such frameworks? Sure, that was a more appropriate time to create your own framework of sorts, because nothing better existed. Now, I _guarantee_ what's out there it better, more performant, and more battle tested than anything you built in-house.
yes it works just like your posix OS ... 
I don't get why this was downvoted. It was a really good and informative talk, and an important one too (imho).
Fuck off.
The Node CommonJS interop is under flux and unfinished while the TC39 and VM implementors look at changing spec. True interop is closer to https://github.com/babel/babel/pull/4964 , which is the lowest common denominator of all the possible paths. Even then, your loader/bundler will determine the behavior of imports for the foreseeable future. There are various minor path incompatibilities / differences in path resolution between browsers and node as well. ESM does not aim for exact same behavior across all solutions.
That entirely depends upon how many such operations there are. Performance is usually pretty hard to measure (in total). Guessing that something might or might not be noticed and then deliberately choosing a substantially slower option seems unnecessarily risky to me. I prefer to take the more scientific route and trust the evidence rather than ignore evidence for convenience.
Sourcemaps! 
I see. It may work in JSHint. http://stackoverflow.com/questions/34888523/eslint-ignore-line-from-js-parsing/34965630#34965630 &gt;The difference between JSHint and ESLint is that JSHint was linting files as it parsed them. So a comment would disable parser until it sees corresponding closing comment. TIL! Although I'm not sure if JSHint has as rich a library of rules as ESLint does. But there seems to exist a tool that could be used to convert between them: [polyjuice](https://www.npmjs.com/package/polyjuice). Hope any of it helps. Good luck
probably just manbabies that are mad about the nodevember controversy
This has some good ideas. for large-scale NodeJS apps I've built, with several microservices, I found a good pattern was to further decompose the building blocks of the apps into "components" and "services" that are required / init-ed in turn based on environment variables (basically an extension of the ideas in this repo / article). For example, the REST API might have SERVICES=db,pubsub,s3,sqs COMPONENTS=rest-server,auth-api,users-api Allowing you to easily configure any combination of functionality you need on a per-process basis. Works extremely well when paired with containers, as you have a single application image, that can be run with different environment variables to determine what services and processes are spun up. 
I'm curious why you would consider React Context a dirty corner? First of all, most people never use it, so it becomes a non-issue. But I'd argue it provides a very useful capability for cutting boilerplate, which I operationalized in https://github.com/artsy/react-redux-controller.
The pattern I'm describing is not an alternative to the ducks approach, it builds on top of it.
The other way around it means 3.000 operations per ms, that is an insane amount that is never even remotely justified. 
lol?
&gt; Why run all over the internet when everything is right in front of you, along with the people who wrote it? Because I don't want to shoulder tap my co-workers with constant questions about why this framework sucks so bad? &gt; No one cares if you know React if they don't use React either. So what difference does it make? Smart companies hire programmers, not framework monkeys. I can learn any framework I want before I even land a job because it's out there in the wild, with communities and resources rallying behind them. I cannot say the same for your obscure "framework". &gt; Our "framework" is doing some things you haven't even thought of and you won't see in a framework for some time into the future. Haha, sure bud, care to elaborate on your genius? &gt; While you were wow'ed by some framework somewhere still in beta testing, we already been there, done that, and moved on into newer things. You are way behind our curve. Yes, I'm sure I'm so behind the curve with the rest of the community using open source work created by companies that could buy yours out and turn it into their personal nap rooms. &gt; If you can't do your job without a popular framework, then you aren't good enough to work for us. Sure I can do it without frameworks. Do I want to? No, because that's not productive. I wouldn't go near your obviously big-headed company with a 10-foot pole. There's toxic developer culture written all over it. Gross.
I don't understand what that means? Are you saying some code isn't justified because it executes too efficiently?
Oh wow you actually love safari so much that you're personally offended by this.... That's batshit crazy mate.
I'm out of the loop, what happened?