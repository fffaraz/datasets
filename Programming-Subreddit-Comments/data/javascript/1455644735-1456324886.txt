The original discussion I was referring to started when someone asked why the `async` and `await` keywords were necessary/desirable, and what this article describes is essentially async/await behavior without the keywords. &gt; note there is no way to represent the ambiguity you pointed out This is exactly why the keywords are necessary. They eliminate â€“ or at least reduce â€“ the ambiguity that would otherwise confuse things. In reference to this article, `async` and `await` can be thought of as "sugar" for Promise boilerplate, and my argument is that this "boilerplate" is necessary to avoid the confusion that would otherwise arise in non-pure functions.
Check out web workers. May be a solution you can use depending on browsers
Ask them to enable CORS
Gah. that's just weird. no idea why that's happening. sorry.
The things that some people see as reasonable...
You can access style properties of html elements like this `element.style.border = "1px solid black"`. Margin is `element.style.margin`. People are probably going to tell you though, that you shouldn't be using js for styling.
how would i implement that within the &lt;table&gt; ?
[Perhaps a simple tutorial to get into the world of full stack.](http://cwbuecheler.com/web/tutorials/2013/node-express-mongo/) 
I'd probably designate a particular classname to signify all divs that shouldn't redirect, then bind a click event that stops propagation from all divs with that classname. Here's a [fiddle](https://jsfiddle.net/5upckbe1/) demo var noredirect = document.querySelectorAll('.no-redirect'), len = noredirect.length; while(--len &gt; -1){ noredirect[len].addEventListener('click', function(e){ e.stopPropagation() }); } With jQuery: $('.no-redirect').click(function(e){ e.stopPropagation() });
that worked. I'm confused as to why it would go AFTER the table loop? wouldn't it go within or prior?
Needs more memes.
The issue is that you're creating a new blank array called filters inside of your click event every time. You're only getting the last result because it's the only thing in that brand new array you've just created. Here's a [fiddle](https://jsfiddle.net/uk9hqkxj/1/) that demos the functionality. I've also added in a section to remove a filter on second click inside your else statement. `var filtername = $(this).data('filter'); var i = filters.indexOf(filtername); filters.splice(i, 1);`
Isn't this solved in custom modules, such as here: https://github.com/danialfarid/ng-file-upload
May I ask what you are calculating that is blocking the thread for a whole 15 seconds?
users are uploading large pipe delimitated files. Javascript is used to parse and create graphs from the data. Pretty intensive stuff. I'd like to have a progress bar as it goes through the parsing.
You can definitely chunk that out. If the main thread still hangs, look into web workers. Sorry, I'd give you an example but I'm on mobile right now :(
I definitely can chunk that out. what would the syntax be like though? onclick { showProgressBar() parseChunck1() updateProgressBar() parseChunck2() updateProgressBar() parseChunck3() updateProgressBar() parseChunck4() updateProgressBar() parseChunck5() } 
Looks like he cleans that up with a `Symbol.iterator` member defined on the `BinaryTree` class so you could just `for (const node of tree)` over all nodes.
What is the "utility" of a protocol-relative URL? If you know if the resource is available on HTTPS, you should *always* use SSL. And in this case, this is a call to an API. You always want to use SSL when talking over HTTP to an API. It's just a good habit to form. Weather data isn't super-important, but a bad pattern of using a protocol-relative URL could easily leak over to something more critical, such as login or payment information. You end up leaking information like that and you have a big problem on your hands.
Moreover, you can always include HTTPS content on a HTTP page. You can't do the reverse. If you have an SSL resource available, there's no need to drop down to HTTP. There is no benefit (performance or otherwise) to doing so.
Fair point re: mapping over a tree. You'll produce different sequences based on whether your traversal is depth or breadth first too. I guess I was thinking of something along the lines of clojure's `tree-seq` https://clojuredocs.org/clojure.core/tree-seq
If you are using LoDash like library to perform "long calculations" it might be woth to look at http://danieltao.com/lazy.js/ 
Why another Html file? In your first Html file, there could be script, which opens a connection to a websocket server (this one can be the same or another node app) 
Disclosure: the link takes you to a frontend framework; written by me. This is just my way of introducing it on a lighter (click bait?) note and also give thanks to the many other open source developers from whose work I have learned.
Would suggest only using the socket to pass signals and the message itself. no need for html to be passed through the socket. That html (template / prototype) should already be in the original html page. Use javascript / jquery to update the presentation accordingly based on events triggered. 
Seems to be a fundamental misunderstanding of the js threading model (there's only a single thread, so everything runs on the "main" thread.) The author gets the impression that `setTimeout` executes a function on a different thread.
FWIW I saw the title and thought "no" and moved on, but then noticed there was a comment and wanted to see if they agreed. They did not.
Damn dude, do you have a bone to pick or what? Chin-stroke hipster types? There's a lot of movement in javascript lately towards more functional style. The react community has things like immutable js and redux. There's also a lot of the changes lodash has made, and other libraries like ramda, RxJs, etc. You don't have to go full monads and typeclasses to enjoy benefits from functional programming, just like you don't need things like interfaces to enjoy benefits from OOP. If you've ever used something like map, a promise, or a closure, congratulations, you've benefited from FP. As an aside note, angular 2 works just fine with [immutable JS](http://www.jvandemo.com/how-to-build-minesweeper-using-angular-2-and-immutable-js/) (or [RxJs](http://blog.jhades.org/angular-2-application-architecture-building-applications-using-rxjs-and-functional-reactive-programming-vs-redux/)), and typescript does nothing to dissuade you from writing more functional code. Indeed, it even has first class support for react and its purely functional components. Moreover, the answer will always be somewhere in the middle for javascript; it's not a language particularly suited to java-style OOP or haskell-style FP. You have to be pragmatic. 
That is how I think I'll explain immutability to everyone. Do you think there are a better explanations of the concept?
Hmm.. my plan is either back-firing or going exactly as planned. Actually, just having fun with it. If folks are happy with their current setup then I am happy if they conclude no to the question.
Wouldn't we all rather just throw it away?
I wrote up a big post on dependency injection that got lost. Very irritating. The gist of it was: Without using dependency injection: var myModule = require('myModule'); function doSomethingAwesome() { var instance = new myModule(); instance.doSomething(); } doSomething(); Using dependency injection: var myModule = require('myModule'); function doSomethingAwesome(instance) { instance.doSomething(); } doSomething(new myModule()); The example you posted is using "constructor-based" dependency injection when it calls `session` with the `connect-session-knex` dependency: session({ store: require('connect-session-knex')() }) And then uses "setter-based" dependency injection to pass this to express: app.use(session({...})); There's nothing inherent about node.js modules that forces us to use dependency injection, however. This is completely up to the library/framework author and how they decide to interface with dependencies. Source: [Wikipedia](https://en.wikipedia.org/wiki/Dependency_injection)
Why not just give doLongCalculation() a callback to call that updates the bar? Call the callback at key points in your calculations. Use css transitions to animate the progress bar.
YES! Awesome.
Don't use MS Office VBA for this is the simple answer. You're setting yourself up for pain. Do it properly using a better tool for the job. For a higher-level way to get the browser to do stuff, check out webdriver: http://seleniumhq.github.io/selenium/docs/api/javascript/ If you want something that behaves like a browser, but can run on the command line, check out phantomjs, which can be driven by webdriver. 
Some are, sure. But... those are for angular 1, not angular 2. There's going to be maintenance jobs to keep angular 1 shops running for a looooong time. Angular 2 has only been out for a few months, and has fierce competition from the likes of react, vue, and aurelia. I would be greatly surprised if ng2 is anywhere near as popular as ng1 was, especially with the 1.5 update to ng1 that gave us easy multiple transclusion and lighter syntax for the directive API, and especially especially with the popularity react has been enjoying.
http://raganwald.com/2015/02/17/lazy-iteratables-in-javascript.html The language definitely needs to move in the direction of having versions of `map`, `reduce`, and so on over iterables.
To chime in with what others have said, when you do a calculation in your 'JavaScript Runtime Environment' (in your case within your browser) it blocks the 'event loop'. The calculation is occupying your browser and preventing it from repainting and probably also reacting to user interactions. When you use setTimeout() even if it's with 0 delay, it will add that to the end of the queue waiting to be handled in the event loop, giving time for repaints etc. The solution is to break up this computation (is it a big loop? Use recursion with a timeout) to allow for repaint slots in between. Why does the calculation take that long? Edit: You also can't just wrap all the parts in setTimeout, because if you do that it'll wait the delay and then add them all to the end of the event loop (and still do the computations in a row). 
CSS transitions are a good idea, but if your browser is blocked by large calculations there is no time to repaint and CSS animations still wouldn't help.
Yes. In the React/Redux world functional programming styles are not uncommon, and once you start to go down that road you'll quickly find composition and currying are very useful. Keep in mind, they're not super exotic concepts. It's stuff like wanting to filter an array of objects to only show objects with a negative value in their `total` property. How would you do this? Well, there's a lot of ways of doing it. But one way might be to write something like this: const newData = data.filter(x =&gt; { return x.total &lt; 0; }) Boom, done. And for simple problems, that's more than enough. But you could also try and break this down into re-usable steps. For example: const prop = key =&gt; obj =&gt; obj[key]; const lt = right =&gt; left =&gt; left &lt; right; const getTotal = prop('total'); const isNegative = lt(0); const totalIsNegative = x =&gt; isNegative(getTotal(x)); const newData = data.filter(totalIsNegative); Is that better? I dunno, maybe? Depends what you're doing, but for something big and complex the explicit breakdown might be clearer and more expressive. Plus, you could potentially build up different building blocks and snap them together in different ways. True, it's more verboseâ€”but if you do this stuff a lot, you can stop defining all those simple helpers, and shove them in a library, or use something like the excellent Ramda library (which already has `R.prop`, `R.lt`, etc.), so you might just write: const negativeTotal = R.compose(R.gt(0), R.prop('total')); const newData = R.filter(negativeTotal, data); For me at least, that's a lot clearer that creating anonymous functions on the fly, and just as terse. And as your problem becomes more complicated, the advantages just increase.
why bother. they'll just change it again. learn react.
The &lt;script&gt; tag will execute the code that's inside of it (even without a type attribute), that's correct. But if your code just calls the String.fromCharCode function, then it will create a string. You'll have a string containing your encoded code. But your string won't execute, because it's just a string. If your goal is to execute an XSS attack then [eval()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval) may be what you're looking for. Calling `eval(yourString)` will execute the code in `yourString`, assuming the string contains some valid JavaScript.
Serious question because I don't know the entire history - is using Aurelia a legit choice for long term support? My understanding is that Durandal just fell off a cliff and Rob decided to just create something brand new (Aurelia) after leaving NG2 rather than return to Durandal and evolve it in that direction. Ironically this is the same thing many people criticize the Angular team for. The best I've seen offered by Aurelia is that it "will feel familiar to Durandal users".
Author and contribute to open source. It's the best proof you can ever offer that you 1) know what you're doing and 2) know how to work with others.
Yes but I read somewhere that OSS as a whole is not a best example of good code, also these are mostly libraries or frameworks and not production ready web apps. Can you recommend some specific projects that anyone can join and be an important member?
Predicting the future of web development is honestly a loser's game. For a sizable chunk of the time angular 2 was in development, there was [no real upgrade path](http://www.effectiveui.com/blog/2015/04/20/learned-ng-conf-write-angularjs-migration-mind/). Only recently before it was released did I hear *anything* about a serious upgrade path, and that still mostly amount to "run angular 2 and 1 at once" or "write angular 1 that looks like angular 2". This is where a lot of criticism came from. An upgrade path was *not* a priority for the ng2 team, and if it was, it was very consistently poorly communicated. As for Aurelia, I honestly just can't tell you much about it. The lack of IE8 support and huge framework with DI and everything was a non-starter for me, and I never felt the whole framework of Durandal was necessary when I still used knockout. I do know that Aurelia can consume AMD modules (like Durandal code) and that they have the same life cycle events (or at least, Aurelia has all of the ones that Durandal did). I know when Aurelia was announced there was supposed to be a "straight upgrade path", but that's honestly the last I heard of it. Also, keep in mind that the fact we even have to talk about migration paths is a reason I don't like larger frameworks. If you use the entire angular stack, you're basically committed to angular. The react ecosystem is different in that each of the pieces (immutable js, redux, react) can be iterated on and replaced separately, at much smaller costs. If I use redux, for example, I can bind it to mithril, react, riot, knockout, whatever, and keep my same business logic. 
 &gt; [..."alert('ohai')"].map(x =&gt; x.charCodeAt()) [97, 108, 101, 114, 116, 40, 39, 111, 104, 97, 105, 39, 41] &gt; String.fromCharCode(97, 108, 101, 114, 116, 40, 39, 111, 104, 97, 105, 39, 41) "alert('ohai')" Try: &lt;script&gt;new Function(String.fromCharCode(97, 108, 101, 114, 116, 40, 39, 111, 104, 97, 105, 39, 41))()&lt;/script&gt;
Interesting dilemma. I recently did something similar with my career. Went from mostly LAMP-oriented full stack development as the senior dev at a small company, to a junior dev focused on JavaScript/Angular at a larger company that has an actual software development process in place. Part of that process is doing code reviews on pull requests, where you invite members from several different sub-teams to give you feedback on your code in the form of actionable suggestions (not shit comments like "why did you do this?" or "this could be better"). I've found that this has been totally instrumental in helping me learn new patterns or the reasons for using patterns I was only mindlessly parroting because I heard somewhere it was considered good practice. That said, it's a double-edged sword. A company inherently has a team culture that tends to have a convergence of style and thinking. If that group collectively agrees on a change that you personally disagree with, it can feel bit off-putting. Of course, it should then be up to you to put together a serious set reasons behind your disagreement and bring it up at the next meeting. Maybe there's some reasoning *you* haven't considered, and maybe there's some reasoning *they* haven't considered. Either way though, just be mentally prepared to be shot down. You function as a part of a larger team, and you must write software for the benefit of the team, not just yourself. That can be a bit of a shock if you come from an environment where you call the shots.
Great to know. I guess it really depends as you say, as to where I refactor the code to follow FP conventions.I've used maps and filters in many cases before. But for this very particular case it's not a CRUD app obviously. In general terms applying computations to large sets of numeric data. I am processing a lot of floating point values. My biggest optimization in performance was actually pretty straightforward. Changing some literal array contructors to float64array objects saw my performance improve almost by 100%! Not surprising since typed arrays can be a lot more efficient in passing uniform sets data in large amounts. Although the goals with my application are two-fold- being as real-time performant as possible but also having a small code footprint, so I hope it doesn't become a huge compromise between both :p That's why I got curious about using FP to enforce DRY in places where data is not going to be changed a lot yet. Like during initialization, for example.
Why create a `Request` object, which just uses the `url` why not just pass the `url` to `fetch(url, options)`?
I worked on something similar last year and used [graphlib](https://github.com/cpettitt/graphlib/wiki) with great success. The JS object format it uses is a little wonky, but it's not hard to transform your data to match. It includes several graph search &amp; traversal algorithms. Highly recommended. edit: [Here are some utility functions I wrote for working with graphlib &amp; d3](https://gist.github.com/dandelany/b6f91699f6d1135f1070). Some of them are pretty specific to the data format we used, but hopefully they're helpful anyway - should be easily adaptable to your data format. p.s. happy cake day!
Your manifest may not contain JavaScript. It's the meta information in JSON only.
Creating Chrome extensions is very well documented. You just need to read the documentation ðŸ™‚
Honestly, the 1.5 update was good enough to me that I don't feel the need to upgrade any of my angular 1 apps. The new component syntax is actually *less* noisy than I find angular 2, and holy crap multi slot tranclusion without custom transclusion functions. And [stateless components](https://toddmotto.com/stateless-angular-components/)!
I've been in a similar position than you. And my skills sky-rocketed when I was mentored by an old boss with 30+ years of experience but outside that I've been by my own my whole life. I think it's better this way because being on your own and being responsible for a project, impulses you to find new skills and to learn the ins and outs of the tools you use. Also it gives you the opportunity to work with a wide range of problems that otherwise you wouldn't. That gives you a lot experience. So don't feel being left behind. The fact that you feel that way probably is a testimony that you are doing pretty darn good. I want to vote for author or contribute to open source. That's a good measure of you skills. - Can you dive into large code bases and add features? - Can you identify a library pain points? - Can contribute with bug fixes? - Can you adapt a library to your needs? 
We use async/await in production with Babel, and love it. Thanks to Babel, the transpilation is pretty straightforward and low risk. And it's a *better* design pattern than promises for most of what we do, which reduces risk of bugs on our end (far more common than bugs in established libraries like Babel.) We did moan a bit when we lost async*, but the ease of swapping it out for the clumsier Promise.all([]) model only made us more comfortable taking risks on stage-0 features in the future. Looking forward to ::, coming soon to a production environment near us. :)
I am in an almost mirrored situation. Not currently entertaining offers from other places, but I often wonder how I'm comparing to peers that are working in better software environments. I work for a lean &amp; mean software shop. I'd say the stresses / challenges / expectations are higher than normal shops of our size as we augment the software efforts of some very large companies. I've quickly learned that proficiency in this field isn't about being an ace with framework XYZ, or mavericking Log(N) solutions M-F. Assuming you're good with the tools being used (or sought after), and can solve problems is creative ways, then you're probably as close to mastery as you could *want* to be. The real show of mastery (IMO) is the ability to take the proficiency in your craft, and relate it your team, boss, PM, BA's, clients, and ultimately meet functional requirements at a crossroads with technical optimums (oh and it's gotta' scale too). If you can transcend the roles of others in your team and help augment their efforts while still keeping pace with your technical expectations, you're proving your mastery.
I'm not sure what you mean by prove the "legitimacy" of your knowledge. If you can code, then you can code. The rest is just a factor of your intelligence. No one else can teach you to be smart. That's one of the things I love about coding. You can copy someone else's code and use frameworks, but, eventually, you're going to run into a unique problem that you have to really think about to solve, and that's what separates the good coders from the hacks. Also, I've worked at big corporate companies, and they don't know anymore than you do. In fact, it taught me how much further I am than they are, and I'm completely self-taught. If you really want to prove to yourself your worth, find an impossible task and do it. Don't give up, but just chip away at it until you've accomplished it. Think of something that only an "master" of javascript could do and do it. Design patterns, fancy algorithms, those are all well and good, but at the end of the day, what really matters is what can your code do. And the best way to learn what you can really do with your code is just to try it, and you'll learn those fancy algorithms and design patterns along the way, when you need them. You need to make it faster, you start refactoring your code, oh, I read on stack overflow, I can make this faster with object pooling. I can use a service here, etc.. But it sounds like you're doing good at your job, so I would assume you're a pretty good coder. If I were in your situation, I would go to a big name open source project, something that people have heard of, like react or angular or if you're really ambitious, the Chromium project and start trying to figure out bugs. Once you start doing that, you have a great resume line and see how little that separates you from the so-called masters.
I do love the feature, and if you're compiling anyways, I guess there's not that much of a downside. It just strikes me as foolish, for some reason.
Well it's not just the compiler that breaks, it's your codebase, and that's part of my worry.
[Tree traversal with ES6](https://h3manth.com/new/blog/2014/tree-traversal-with-es6-generator/)
Not a full answer but why not have the base styles first and then the generated custom ones after? As long as the generated ones are not less specific an than the base ones they should overwrite without important! That second approach feels very wrong to me. If definitely generate a style sheet somehow. 
I'm not sure why this needed an explanation. What was wrong with the one-liner everyone else uses of "in an immutable data structure, you can never change the data, instead you create a copy with your changes applied to it". That's it. Make a copy. There's really no need for analogies.
I would say generating the style sheet is the more advanced and more correct approach. It will definitely render the styles much faster than adding properties to the elements like that. You will probably be better off refactoring your generic style sheets in such a way that applying the branding doesn't require so many !importants.
What're the most important things people gain from working at big companies? 
I think this is indeed what I'm looking for! I misunderstood; what you said sounds right, that the content as of now is just a string and I would have to execute it. Let me try it out. But THANKS!
It does indeed stand for binary to ascii. To avoid using the btoa trick, the image can be loaded as a blob and fed into window.URL.createObjectURL() MDN has example code on how to load an external image with this. 
The regular expression above filters semicolons, single quotes, and double quotes. So, the simplest example which would work is this: &lt;script&gt;alert`xss`&lt;/script&gt; The example above could be also written like this: &lt;script&gt;new Function(`alert(\x22ohai\x22)`)()&lt;/script&gt; Much simpler, right?
Speed is something I didn't consider. The problem is I don't like tying the branding styles directly to class names. It makes it very hard for other developers to know what might break when changing some HTML. I'm currently using attribute selectors for the custom branding, that way it's easy to tell what element has branding. Which also means I lose on specificity because most of the selectors in our app have crazy nesting (refactoring sadly is not an option right now). I'm now wondering if this can be done sever side. 
\*sigh\* ... Yet another front-end framework. It's like the "I wrote a calculator in LANGUAGE_XYZ" for JavaScript: The one who made it is proud of it but no-one else would ever use or need it.
Separate code blocks from text with a blank line, and indent four spaces more than usual; here is your code reformatted (including proper spacing, etc.): var Color; function colortest() { Color = prompt("red or black", "color"); switch (Color) { case "red": console.log("You are betting on " + Color + "."); break; case "black": console.log("You are betting on " + Color + "."); break; default: alert("Invalid Color"); Color = prompt("Red Or Black"); break; } } do { colortest(); } while (Color.len != 3 || Color.len != 5); With this said, I believe your problem is that the number of characters in a string `str` is `str.length` and not `str.len`: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length
Have you considered reading more programming related books? Just pick whatever seems even remotely interesting and read it - can often find all kinds of insights or different ways to look at things.
Thanks :D
&gt; Also, do not discount the quality of open source projects. No, one should not! But to be fair (or picky), OP said "production ready web apps", which may need some digging to find. If anyone knows about such, it would be really nice to be able to give them a look.
It's a more efficient way than running several `try..catch` blocks on your code, since they prevent optimization ([at least on V8](https://wincent.com/wiki/V8_optimization_killers)). The issue is when you bundle your JavaScript sources and they just run inline, and if anyone just adds a line that breaks, say referring to `$.fn.offset().top` on an empty jQuery result, every code after that line fails to execute. With `setTimeout` you still have an error, but because it runs on a different "tick" anything added below it has the chance of still working. Many module solutions (such as Almond) already provide this behavior internally.
People from object oriented backgrounds (along with languages that embrace mutation) typically don't understand the *value* of immutable data structures, they don't necessarily struggle with what it means. 
Some clarification would be welcome then
In ES6 there is less need for a IIFE. You can wrap code in curly brackets to get a new scope... like so: { let secretVariable = "helloes"; console.log(secretVariable); // returning "helloes" } console.log(secretVariable); // throwing null 
Sorry, I think I meant to say not "what" but "why". Sometimes it's hard to understand why data should be immutable. This is what I've tried to explain.
There is a tool that already does this really well, [Webpack](http://webpack.github.io).
To avoid other developers accidentally getting too specific forcing you to litter the client CSS with !important, or clobbering classes that are needed for the client's white label I suggest using a class name pattern to help distinguish between them. .base-header, .base-button, etc // basic styles here, lets devs style at will .whitelabel-header .whitelabel-button, etc // generated client styles that extend/override base styles These classes would both be included on the elements you want clients to affect and I cannot stress enough the importance of proper documentation about what class names are used where and for what
Using while instead of do-while just means that you're doing one pointless check before you've even asked the user for a color. function getColor() { var color; do { color = prompt("Color?"); } while (color !== 'black' &amp;&amp; color !== 'red'); return color; } alert('You chose ' + getColor()); Pretty simple, right?
Yeah I knew about that, I was just a bit curious about the error I was getting.
&gt; Anyhow, the wrapping parenthesis are always added to tell the reader that this is an IIFE and not a plain function expression. Right, but the last example seems to work fine even without the parentheses. It's just ESLint that's saying that there's an error, which is why I wanted to ask
i have tried so many options i have searched the web for about to days now and nothing have worked so i have tried so many things. but here is one of them, the text is in danish but i shouldn't be the problem https://jsfiddle.net/tjaajd26/#&amp;togetherjs=lN4VzfviPR
I wouldn't join a backbone.js project. I would if it was 2010 or maybe 2011 but it is 2016 and that framework is seriously obsolete. I will get downvoted to oblivion, but it really is the same as if you were a PHP backend programmer and they wanted you to work on PHP 2.0 project. Ideally find a company which does React. If you can't at least find some that does Angular/Ember.
In addition to this, be aware that localStorage may not behave correctly in some scenarios. It's not available in private browsing in Safari and may not be available in some situations where a host isn't defined. e.g. Loading JS from a file or blob. If in doubt, use something like Modernzr to detect the feature.
I am doing this using webpack+babel for backend and I am quite happy with this. I believe that async/await will make it into final, it is just too useful for not to. It is a thing that makes JavaScript fully viable in backend programming. And EVEN when it will not go in OR it will go in some another form, I think that Babel will provide a compatability layer anyway, so we will just stick with babel+regenerator as we do now. Async/await is my least problem in production for now. We have that scenarios: a) Async/Await will be dropped from ES completely: first of all I dont believe it. It is just way too useful and too ideal for JS world to have it dropped. In terms of JS engines it is not a really implementation problem at all, I've read some Mozilla or Chakra dev blog (dont recall now) where they told that async/await essentially uses same code as already implemented generators, only with some tiny tuning. Anyway if this happens, then we will just continue to use Babel and Regenerator, because I think that Babel wont drop support anyway. They might move async/await feature into some 3rd npm module if they drop it off from mainstream package, do you really think they would just rm -rf that amount of code which is THAT useful to community? b) Async/Await will get its specifications changed: Also I dont believe it, because async/await is actually simple and ideal in current state. It bases on promises, async function will return a promise that will resolve with returned value or reject with error if expcetion is thrown. Await accepts raw values or promises and can handle both, so it is compatabile with all of them: your async code, 3rd party code that bases on promises and some code that was a promise in the past but was changed into synchronous function. Even if specification will change, how it can change? It wont change completely, there will be at most some tiny changes, so MAYBE you will have to adopt a tiny bit of your code. If you have unit/integration tests in your project, this will not be a serious problem even if there will be slight compatiblity break. c) Async/Await will get into spec in future - most probable one for me. I'll just keep using babel until it will be accepted and implemented in engines, thats all.
I'm not sure what environment it's running okay in, but in the Chrome console, `()=&gt;{console.log('hi');}();` yields `Unexpected SyntaxError: Unexpected token (` while `(()=&gt;{console.log('hi');})();` logs `'hi'` to the console and returns `undefined` as expected. Also, clearly if you have the simplified return expression, you do need to wrap the arrow function in parens, or else the invocation parentheses would be interpreted as part of the function's return expression: ()=&gt;console.log('hi')(); // an arrow function that, if invoked, logs 'hi' to the console and then // tries to invoke undefined as a function, yielding a TypeError (()=&gt;console.log('hi'))(); // logs 'hi' to the console and returns undefined
its transpiled down to es5 most likely.
In particular, you can't have functions in JSON, and you can't have function invocations in JSON: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON You should move all the application logic into separate JS files, which can then be referred to in the JSON file.
Wow. Didn't know about this feature. Seems nice. :)
It might not be sexy but i guess lots of companies still use it.
Yes thats great idea. I have already learned a lot from books, about Javascript prototypes, Angular internals and what not. Probably only skipped books about HTML/CSS and UX/UI. To be honest I find it hard to motivate myself to read more books now since I have came to the point at my current job that I dont need any more knowledge to do my stuff.
Ah, sorry just reread that. Got it, thanks!
Yes, the $$$ is big
Thanks for the examples! Also, that's really weird. It seems to run fine with Node but, like you said, it doesn't run in Chrome's console.
The only problem is the compiled code is pretty ugly and hard to debug.
Yes, this is the way I've tried it (see the pastebin)
No, no I don't. I use the features that ship with the version of node I'm using and the browsers I target. The benefits of extra syntax sugar are quickly dwarfed by the extra tooling complexity and interoperability problems, especially when publishing reusable packages to npm. These features will land eventually (in much more performant, compliant forms). There's no rush.
This is similar to what I'm doing, but I'm using an attribute selector instead of another class. The main problem is we have a lot of heavily nested less eg: .header .inner &gt; .profile .links &gt; li a (Imagine that indentation pyramid :( ) I can't just add a 'white-label' attribute or class to the anchor without important or copying the entire selector again in my JS. I've been preferring important over maintaining these ugly guys in two places. Looks like the best solution really is to refactor the base CSS *shiver*. I'm also thinking it should be possible to write some automation tests to cover the banding. 
True enough. I came from the Smalltalk world so I may have a bias for mutable state, but I think that mutable state most accurately describes the world around us. Immutable data is an abstraction 98% of the time. If you need a log record, immutable data is your friend, but in your typical application once an action has been processed the entire system is in a new state and there's no going back. I don't believe the mapping from state A to state B becomes any easier just because A/B do not live in the same memory location. React, one of the latest technologies in the Javascript market, is often characterized as one of 'pure' state transitions---however it is not. The virtual dom is an engine to deal with mutable state, and abstract most of the bookkeeping of updating the DOM for you... it is not actually based on any immutable data principles. With React doing most of the work behind the scenes, you can begin to pretend that immutable data exists, but that too is a mere abstraction that will become increasingly problematic once the scale of state transitions increases.
Ha baggage is a nice way to put it. Yes, the app has its fair share. Anything new we follow BEM naming convention, but most of the core is legacy which is unfortunately where we need custom branding the most. 
Nah, not those kinda 'startups'. You are looking for a top 3 company in the world in something innovative and productized, albeit niche. Think something like Uber. I emphasize the product part a lot because it makes all the difference in the world. A service company wants to get shit done in X hours because thats what client paid for. So does a shitty 'ecommerce solution' company. This means a lot of stress and tons of hastily written code and ux designed without iterations. A proper product company will want to have great product and happy developers and let sales people take care of the rest.
The things you're mentioning are going to be in ES&gt;2016 - the release they're going to be in depends on when they're ready.
Yup, it is exactly that. More specifically, it is a wrapper around react pure components, so you don't use this.setState, etc. to manage state, everything comes in props. I will try to summarize a bit better. 
Thanks for the help, although I mentioned in my OP, that using "this.position" as a variable didn't work for me and simply gave me the issue of "Uncaught ReferenceError: position is not defined" I'll do some reading this afternoon on some of the new class structures I have seen on Mozilla's site. Although, I wish to stay with functions or prototypes for use as "classes" for now since some of the computers the application will be used on aren't as up-to date as I'd like.
It does.
Holy fuck I'm an idiot, I'm sorry for you having to spoon-feed me. For some reason I thought the problem was with the deceleration of the variable but it was the usage I had inside of the update method. Thank you very much!
Yes. It looks like it's going to be a while before we can confidently use plain es6 features :(
I've programmed for years, but only took up JavaScript in the last year or so. I found a local meetup group centered around js that has given me a lot of knowledge and exposed me to a variety of topics and methodologies. I highly recommend it if you have one near you. As someone else mentioned, each company has a culture and style of coding. Reaching out and talking to other "tribes" and learning how other teams do things (and more importantly WHY) is hugely beneficial IMO.
I need help with simplifying this shit of a redundant code.
https://www.reddit.com/r/javascript/comments/45wl7z/thoughts_on_scaling_frontend_development_from/d02zhqx
Generic in this case refers to the `BinaryTree` class, not the `BST`.
You could add specific classes to the customisable elements, remove all customisable CSS the nested hell, and apply the custom styling separately using the specific tags. If that made sense. It's a big rewrite, but it could pay off in the long run
I use async/await, the `::` function bind proposal, `[].includes`, object rest/spread. Out of these, function bind would be the only one I'd recommend not using (due to still being strawman). The other are pretty solid by now.
His question is actually legit. Please read http://www.schibsted.pl/2015/12/how-to-do-dependency-injection-in-node-js/
Is there not a polyfill for these where, should they not make the implementation, they could just be implemented by the coder?
I found local "MeetJs" meetup but It was hard for me to socialize there. Im just too shy to talk randomly to complete strangers. I feel like outsider there.
Not to pry too heavily but what do you make? I've interviewed at a startups up to large companies and whole the start ups generally have small salaries/benefits they make up for it in other ways.. And the small companies generally did well to match and often exceed the salary/benefits of larger companies. 
I do not think we will ever stop transpiling our JavaScript code unless you only write in ES5. If you look at the mission of transpilers/preprocessors like Babel, their mission is to always all the developer to use features that are not currently available in browsers. It was ES6, now it is ES6 &amp; ES7, and then it will be ES7 &amp; ES8 and so on. We will be using these transpilers forever, unless we only write code that is currently supported cross browser. I recently stopped using all of these tools because even though they aid in development speed, they are too much of a pain in debugging applications. I would rather my code be wrong so I can fix it directly as opposed to the problem being in the tool.
I understand but lets be real, its not easy to join that kind of startups, also im not located in US.
There is a reason that I put the words "production ready" in quotes. It's such a subjective concept. It only matters when compared to the standards of an organization. People put code into production that would astound you. Working with open source means working with real code. It's far more important to learn from the mistakes of a less than perfect codebase and fix them than to stare in awe at an architectural unicorn. Unless you're the only programmer on the project, you're far more likely to run into the former 'in production' than the latter.
manifest.json sets up your extension and is like a README or .info file for Chrome. Your javascript goes into a file, which you specify in the manifest.json. Here's a sample from my last extension. Your code would start in *main.js* { "manifest_version": 2, "name": "SuperDuperWordReplacer", "version": "0.1", "description": "My Extension", "icons": { "128": "icon-19x19.png" }, "content_scripts": [{ "matches": ["*://*"], "js": ["main.js"], "run_at": "document_start", "all_frames": true }], "permissions": [ "tabs", "webRequest", "webRequestBlocking", "webNavigation", "management", "nativeMessaging", "*://*/" ], "web_accessible_resources": [ "images/*.png", "blocked.html", "inject.js" ] } 
I'm not saying it can't be done, but your dependencies list seems ... big and somewhat redundant. Is your code on github? Also, +1 for [Webpack](http://webpack.github.io/)
Yeah, it really depends on your location. I am not from US either.
It needs to be a custom solution. Hard to explain why... but take my word for it, it must be written inhouse. Also it's not to follow one particular person. It's too track what all visitors do on the site! So if User1 comes to the site and clicks around, we need to know what pages he visited. He may have the site open in two browser tabs, so we need to somehow track those two sessions separately.
Actually, my preferred library is Vue.js. It has data-binding with directives like Angular. However, it does not do dirty-checking, digest cycles, etc. It provides components that are very close to the current spec. You could use Backbone with it for the models. It's very unopinionated, unlike Angular. It is easy to use development patterns like Reach Redux, etc. with it. It's got some really great development tools, such as full support for coding in ECMAScript 2015/ES6 with Webpack/LiveReload, etc. They have command line tools to help you get a project up and running quick with a lot of options. It has a large, active community and a great Gitter presence where you can post questions. And there are some pretty good video tutorials online to get you going quick. Vue.js solves the complexities of Angular and React in elegant ways that makes you wonder about the priorities of the teams behind those frameworks. 
Well, if you're writing in a compiled language, you don't 'ship' your source necessarily, but that doesn't mean you should do whatever you want in the codebase. That's like saying "Oh, we compile from c to asm so we can do whatever we want in source". It's technically true, but the entire reason we have coding conventions is that that sort of thinking isn't scalable. As for going back and fixing, that's a nasty manifestation of technical debt. Unless there's business reasons to do so, I can imagine real scenarios where it piles up "Oh we can't switch away from babel 6.whatever because we have too much riding on it." 
I'm very much a fan of vanilla code and custom solutions, but this is very much reinventing the wheel. The are a lot of mundane tasks that you'll need to do.. probably a solid week of work for an experienced coder, likely more. Cookies may be disabled, and naturally the solution will require JS, but I suppose if it were me... I'd build a script that starts when the user connects, logs the IP and browser, and records mouse and keyboard events every 400ms or so, then ships that off in chunks every 10 seconds or so. The downsides are enormous.. you'll also need to ship back the users client window size and reconstruct what the user saw later. I guess the big upside is you'll basically be able to spy on exactly how users are interacting with your site, but IMO you'd need a really good reason to justify the cost of such a complex project. There are other pre-made solutions that may fit your needs exactly (and then some). I'd do a little more research on existing solutions before proceeding. 
3) are motivated 4) genuinely enjoy programming
That's too bad. But if you have to do all frontend then your large style sheet will be your best bet. We are actually a paid service so the clients that pay for the service give us their brand colors and we set those in the database. But the easiest approach would be a color palette, but that may not work for most clients if they have specific brand colors. If you want to have them specify the colors, you'll basically have to do inline if you can't do the generated sheet. As for the branded elements. We keep the amount very minimal. For the most part, we don't have a way of knowing though. When I first started, all of our modal were branded and I had no idea and made a few without it. Really, the only way to make sure is to have comments or clear documentation.
Is it that complex even if I just need to track which URIs he visited?
By that time you're transpiling ES16, which is not supported by IE11.
:: &lt;3
Where did you see the cutoff date?
http://www.2ality.com/2016/01/ecmascript-2016.html &gt; Any proposals that were at stage 4 on Thursday, 28 January 2016, will be in ES2016 
Ehm... You are really making problems that don't exists. For 99% of the cases, things worked exactly the same after transpiling to ES5 as they work when directly running ES6 in Chrome Canary. Of course, you need to always make sure the end product work in all major browsers, but we were talking about debugging, and it is perfectly fine to debug in Chrome Canary (except if it is some browser specific bug of course).
Could you share your current workflow at your job from developing in ES6 to transpiling and testing in ES5 to production?
Rather than pitching this as a framework for CMS / Admin you might consider it a more general CRUD framework for React. The form stuff and resource actions sound great but not a big fan of having to use the provided components
All of the resource actions and form store benefits can be used without the components. They just make it easier to do so. All one would need to do is hook into the Form Actions (Calling `FormActions.editField` on change for [example](https://github.com/fuzz-productions/Mortar-JS/blob/dev/lib/actions/FormActionCreators.js#L30-L38)) to hook into that workflow. 
If you do any kind of threading work in OOP, you'd know the value of immutable data. Either that, or you learn to deal with absurd things like double object locking. I imagine the bigger hold up for people is just the feeling of it. Immutable data doesn't *feel* like it can be anywhere near as efficient. Additionally, if you ask e.g a haskeller how they deal with state, they'll respond "With the sate monad!" which is eye-rolling (or confusing) to a lot of devs. 
I find taking a coworker with me helps, especially if they're more social. Asking questions of the presenter after is also easier than during the presentation.
Thanks! The newer frameworks are actually part of the reason why I'm conducting this research. Most of the literature I found contained the same mature (and sometimes outdated/unmaintained) frameworks (PhoneGap, MoSync, Xamarin, RhoMobile, and so on...), while others tried to propose their own hybrid frameworks. Very sparse research on newer techs, so I found a gap that personally and academically interest me :)
Awesome! I'll take a look, sounds like that's where the real benefit is
That was pretty easy to do, and looking forward to seeing your results.
React is not the pure state transitions. React is a comparatively simple view library that emphasizes *functional components*, e.g same data in, same component out. It has no opinion on how your data is stored or updated, and even has support for stateful components. The actual pure state transitions live in redux (and probably some other flux libraries). In redux, your entire application's state, no matter how big or small, lives in one tree. You use *reducers* to apply *messages* to get new state. Redux very strongly emphasizes immutable state. This is almost certainly what people are talking about if they say "react state transitions". Additionally, the virtual dom is not an engine so much as a huge javascript object which represents each element with more javascript objects. The tree is diffed against the DOM, and only the absolute minimal amount of changes are made to the DOM to synchronize it with this representation. In this sense, one could easily recognize it as a pure concept - namely, `VirtualDOM -&gt; RealDOM -&gt; DomUpdates[]`. In fact, if you look at [virtual dom implementations](https://github.com/Matt-Esch/virtual-dom), you'll see this concept reflected in the API. 
I'll definitely try my best to do that!
Give up javascript and learn proper backend and database management. 
Since it is a part of swagger.io I really doubt it.
Don't know what the util part is or how you're managing the PDF side, but adding dates to a date is pretty much just: var d = new Date(); d.setDate ( d.getDate() + 30); //d = Fri Mar 18 2016 
Much of the time that people are using JSON they care about speed, and schema validation tends to slow things down. There are use cases (I use it myself for some projects) but they tend to be ones where the cost of recovering from an occasional error far outweighs the penalty incurred by doing the validation, or ones where it's more about post-processing a document than it is about processing streamed input.
XML DTDs are quite useful. For example, a while back I implemented a parser for a large and complex XML file and it was really easy because all I had to do was read the DTD and go item by item. Aside from making it easy to work with the data files, it also means you can be (reasonably) certain that a file which conforms to a schema, fed to a parser that knows how to validate files according to a schema, will never error out in unpredictable ways. If the file doesn't conform, you reject it right away, rather than partially utilizing the file's contents and then erring out halfway through, which can be much more dangerous. One could argue this is overkill for JSON since it was really just made as a simple data interchange format, but in practice these files do get used for reasonably complex and important data, so it doesn't seem so far-fetched to me that it should support a schema-based validation. edit: personally I've never used any kind of JSON validation though so I can't actually answer the question.
Schema validation is great for API testing purposes. It is also great to generate code automatically, e.g, make me a form from this schema. 
If you can add important to these rules you can also make them more specific. What I am saying is make these custom rules just as specific (or more specific) than the ones they need to overwrite.
Holy cow! That actually worked! I have no clue how I made it this far with out learning that. Thanks!
To be honest i tried, but my current coworks just completely lack of interest in such things, they dont do any kind of programming related stuff outside work, actually programming is just work for them and they do minimum.
&gt; WHY cool kids doesn't validate with JSON Schema? Data integrity is not WEB SCALE :P
It's an interesting idea, but without syntax support it's quite ugly. I prefer lodash's [get](https://lodash.com/docs#get) when not working in a compile-to with safe navigation operators. You could also just write a function to do safe navigation, since you have to call one anyway to set up the proxy: const safe = action =&gt; { try { return action(); } catch (e) { if (e.name === 'TypeError' || e.name === 'ReferenceError') return undefined; throw e; } } Use like: safe(() =&gt; o.getAddress().street) === '513'; safe(() =&gt; o.name.noName.noName2) || 'name' === 'name'; cf., from link: safe(o).getAddress().street.$ === '513' safe(o,'name').name.noName.noName2.$ === 'name'; Less magic with the function or lodash approach, imo. With the function, you're also half way to a [result type](https://www.reddit.com/r/javascript/comments/458c3l/has_anyone_found_a_good_use_for_es6_generators/czw0bv0?context=3).
I've used it on a project where we had frontend, backend and mobile clients all replicating the same data model, it was cool for that
Two quick things I noticed: First is that when the error blocks show, they push the content around. I like to create a space for them ahead of time (or use z-index, etc.) so that they don't move the form fields on the page. Kind of jarring for a user. Second, rather than evaluate each field individually, I like to build functions to check for specific things, like is the field empty. Then, add a class to each input you want to check for being empty. Much more modular and easier to add validations to new fields/forms as they are added.
You should not be doing complicated business-logic validation on the FE. However, you should be doing simple validation, like required fields, to improve the user experience. Having to submit a form just to get "this field is required"-style errors is hugely frustrating.
That is not a good comparison. Object.observe can be implemented in javascript via proxies. The original author of the spec withdrew his strawman proposal because of that. It is not the same with async/await. People who submitted it are standing firmly behind it and there is no one on the ecmascript commitee who would be against async/await.
I greatly disagree. I think adding array.flatten is good addition, but additions which are not polyfillable boost my productivity much more.
That is a good point re: parser, but forks are a thing. I never said you're trying to be coffeescript haha. I merely was pointing out that the people will go where the ability to best get shit done is. If Babel drops support for async/await, that will open up an awesome opportunity for others. What's out of scope for one team is the opportunity for another!
I suppose it would largely depend on the service your using. If your backend service has good error handling, and can tell you what is specifically wrong instead of just responding with a 500 or a 400, then I would not bother duplicating logic solely for the marginally faster response time. There are other tricks for required fields that you could do that I would not consider to be "validation", such as disabling the submit button until certain fields are filled in. 
I think we are all finally working on it (at least Chakra, SM, and V8). Much progress has been made in the last few months on the necessary specs. It's great to see. Edit: here are the relevant Chakra PRs: https://github.com/Microsoft/ChakraCore/pull/297, https://github.com/Microsoft/ChakraCore/pull/293.
I never really got into the idea of JSON schema. To me a schema is a data structure definition format that is itself extensible. In a well designed system that data structure definition also serves as the definition of instances that themselves could be schemas for yet other instances. You don't get this capability with JSON, because the format is too primitive. In XML schema, for instance, you are write a Schema to define a new markup language that can also be a schema for instances of its own definition. You cannot create new languages with JSON. It seems JSON schema only exists to validate if a data structure conforms to certain structured constraints. If you are doing this you are making presumptions upon the data, which aren't primitive. Primitive is the primary advantage of JSON over XML. If you are going to take that away then you are probably violating separation of concerns between the data and the consuming application. If you really want to do this you might as well just be using XML, which allows all manners of complex capabilities without violating separations of concerns.
I get [this](http://prntscr.com/a4jliy) error when i put in into my code
Would your app break when fields in the JSON are missing or contain unexpected data types/formats? Then you should verify it somehow, and a schema is one of the ways to do this. It is a bit heavy maybe, but the alternative of checking per field and recurse manually doesn't work well at large scale (like when verifying your whole API). It would even more verbose and once you're done writing utilities to manage the amount of tests and give useful error reporting you'll have recreated Joi or something like it.
First off, I meant Web Worker in title :( In response to my post from yesterday [Help updating progress bar],(https://www.reddit.com/r/javascript/comments/463ale/help_with_updating_progress_bar_during_long/) I took the plunge into Web Workers. There didnt seem to be many good simple examples out there so I decided to make one. Clicking the "Web Worker" button, the large loop will be calculated in the Web Worker. Clicking "Local" the same large loop is executed locally. You can see when executing with the Web Worker will get little to no blocking of the UI, however the local execution completely blocks the UI. Hope you all enjoy. These Web Workers seem really really useful in the future of JS. 
If you use a JSON-like schemaless storage (Mongo, Couch, or ye olde JSON-in-a-text-column hack) you should definitely check your data or explicitly extract what you need or someone could nest a 50MB object tree and you'd never know until it gets read back.
Joi is very solid, I'm torn between it and JSONSchema. I like the idea of using the JSON based schemas in other languages but so far we don't actually use that and in practice we use so many utilities to manage the schemas in Javascript we might as well use Joi.
and in javascript only... validates = document.getElementByClass("validate-required); for ( var i = 0; i &lt; validates.length; i++) { //calls each one validates[i] }
I am trying to setup the architecture of developing apps and the app dependencies locally. So both of the scenarios would be common in this environment. My understanding of npm link is that it symlinks them globally. So app1/node_modules/dep1 would conflict with app2/node_modules/dep1 if app1 and app2 used different versions? What about dep1/node_modules/dep2 and dep2/node_modules/dep1? I am mainly struggling with the fact that I want isolated, decoupled components in 90% in my framework and 10% glue code to tie it all together. I then have multiple apps built upon that framework which uses more decoupled components with some glue code. I fear that a npm install process with duplicated tooling for each component is not scalable. However the alternative of not making everything so decoupled seems worse. I could technically create a mono repo that all shared the same deps with packages still separated out, but makes it harder for devs to use / fork specific pieces of it, crazy require paths require(system/package/router/lib/someNestedPath), and versioning would have to happen for the entire repo. Seems to explain why ember, babel, etc choose this. So what would be worse, hundreds of npm installs, duplicated deps, and crazy symlinks to wire things together. Or a big mono repo. Not sure what direction to look.
Interesting, I haven't seen that one. I'm definitely a fan of co when promise code starts requiring control flow.
http://prntscr.com/a4k8yg
"hip" https://www.youtube.com/watch?v=oAatPPEaZDA
There is one use case where you still need an immediately-invoked function in ES6: Sometimes you only can produce a result via a sequence of statements, not via a single expression. If you want to inline those statements, you have to immediately invoke a function. In ES6, you can use immediately-invoked arrow functions if you want to: const SENTENCE = 'How are you?'; const REVERSED_SENTENCE = (() =&gt; { // Iteration over the string gives us code points // (better for reversal than characters) const arr = [...SENTENCE]; arr.reverse(); return arr.join(''); })(); Note that you must parenthesize as shown (the parens are around the arrow function, not around the complete function call).
Nope. ES2016 is very small, just Array includes and exponentiation operator: http://www.2ality.com/2016/01/ecmascript-2016.html Decorators are right now only stage 1 I think... yeah: https://github.com/tc39/ecma262
`this.value` is what's undefined. The `this` refers to an undefined (presumably in your code) input variable. Change all the instances of `this.value` to whatever points to the string in which you are looking for "Hi".
Ugh. I don't know. I want to learn Angular 2 with ES2015, but I am somewhat grossed out that I have rely on decorators when they're not even in the language spec. Typescript is so meh to me. It provides so little over ES2015 (except types, obviously... but some of the superfluous syntax sugaring is a turn off).
You can always check by looking at this list of proposals: https://github.com/tc39/ecma262 Only proposals at stage 4 are ready to be included in the next ECMAScript version (or the one after that if time has run out). According to spec editor Brian Terlson, ES2016 will only add `Array.prototype.includes` and the exponentiation operator (`**`).
You are rebutting me by saying: &gt; React **is not** the pure state transitions. When I said: &gt; React ... is often characterized as one of 'pure' state transitions---**however it is not** I'm not sure your correction is really required here. 
Negative, nor were they ever really in the running. ES2017 is possible (especially for some subset like class member decoration), but ES2018 seems more likely to me.
Try it!
I was torn as well. But being fullstack JS developer, I can use joi schemas anywhere. All I have to do is to share the JS file. There is no real advantage of using JSON schema for me. 
http://prntscr.com/a4kyd6
Can you post all of your relevant code in to a [CodePen](http://codepen.io/pen)? Save it and then copy and paste the link back here.
I agree with everything you say, but I don't think it has much relevance to using a stage 3 feature. Especially in the case of async/await, it's very unlikely to be dropped, and quite unlikely it will see any further major changes. Plus, I mean...if you write your code without async/await, you may find yourself wanting to go back and rewrite it once the proposal does hit stage 4. That's also technical debt. :)
The other voices are unique to OS X, I believe. They can be passed as options to OS X's `say` command. This is what I get: ["Alex", "Agnes", "Albert", "Alice", "Alva", "Amelie", "Anna", "Bad News", "Bahh", "Bells", "Boing", "Bruce", "Bubbles", "Carmit", "Cellos", "Damayanti", "Daniel", "Deranged", "Diego", "Ellen", "Fiona", "Fred", "Good News", "Hysterical", "Ioana", "Joana", "Junior", "Kanya", "Karen", "Kathy", "Kyoko", "Laura", "Lekha", "Luciana", "Maged", "Mariska", "Mei-Jia", "Melina", "Milena", "Moira", "Monica", "Nora", "Paulina", "Pipe Organ", "Princess", "Ralph", "Samantha", "Sara", "Satu", "Sin-ji", "Tessa", "Thomas", "Ting-Ting", "Trinoids", "Veena", "Vicki", "Victoria", "Whisper", "Xander", "Yelda", "Yuna", "Zarvox", "Zosia", "Zuzana", "Google Deutsch", "Google US English", "Google UK English Female", "Google UK English Male", "Google espaÃ±ol", "Google espaÃ±ol de Estados Unidos", "Google franÃ§ais", "Google à¤¹à¤¿à¤¨à¥à¤¦à¥€", "Google Bahasa Indonesia", "Google italiano", "Google æ—¥æœ¬èªž", "Google í•œêµ­ì˜", "Google Nederlands", "Google polski", "Google portuguÃªs do Brasil", "Google Ñ€ÑƒÑÑÐºÐ¸Ð¹", "Google æ™®é€šè¯ï¼ˆä¸­å›½å¤§é™†ï¼‰", "Google ç²¤èªžï¼ˆé¦™æ¸¯ï¼‰", "Google åœ‹èªžï¼ˆè‡ºç£ï¼‰"] 
The Internet has ruined me. I saw JSON Schema and my mind went straight to John Cena.
If the keyword `function` appears on the right side of an assignment expression, as in /u/x-skeww's example, the JS engine will know that it starts a function expression, which means that you don't need to wrap it in parentheses to immediately execute it.
This last bit is why I've moved from Crockford's old recommendation for ordinary IIFEs, for consistency with how arrow IIFEs must be typed; that is, even for ordinary functions, I now wrap the function expression itself and not the whole invocation.
Here's this: http://codepen.io/anon/pen/BjEVmd It will also trigger on anything that starts with "Hi". So like "His" or "History". I can show you how to combat that, if you want.
Great point. On the occasions I've had JS projects that relied heavily on JSON I would do at least some level of validation. Lately I've been working a lot with MeteorJS; I have come to love the *collection2* package which pairs nicely with the *autoform* package. Coming from working with the LAMP stack, having JS front to back has improved my workflow tremendously.
Considering how tiny and trivial ES7 is, and how easy .includes is to polyfill (or not even use at all, it's pure syntax sugar for something already easy to do with indexOf), we can probably write ES6 code and have decent browser support as long as the project is okay with just Edge support. 
You can write ng 2 without all of that, though most of the documentation and examples will likely be in the class-and-decorator syntax. At least there's the 1.5 release for angular. 
Yes, `() =&gt; {}()` will not and should not work. Arrow functions are really just the same as function expressions. Not sure why I was downvoted above, would you be able to explain?
This has to do with javascript's automatic semi colon insertion. return { unrelated: 'stuff' } Actually is parsed as: return; // same as 'return undefined' { unrelated: 'stuff' }; This is one of the reasons why One True Brace Style (braces on the same line as code) is so overwhelmingly popular in javascript.
Nope. Hated perl when I started this job, but I've come to like it quite a lot. I guess part of that is that it actually reminds me a lot of JavaScript, in that they're both scripting languages that excel at what they do and got a lot of undeserved hatred. Don't get me wrong, I would never use perl on my own for anything beyond a quick utility script, but it's fantastic for parsing and manipulating text which is a huge chunk of what we do.
But the browser support is still at 0%.
The brackets are needed, since function () { is a function declaration. You can't declare an anonymous function nor immediately invoke it. (function(){}) is a function expression, which is evaluated, and can be invoked with a () at the end (or inside) 
I'm pretty sure that the reason is that this has been overtaken by Avro, Protobuf, and Thrift. They have a lot of momentum, a lot of experience around usage patterns, and at least the first two can be serialised to JSON. 
My real problem is that I will have about 100 local modules. I don't want to for(package in local_modules/*) npm install. All the other use cases just stem from the fact that it isn't a great developer experience to wait a day to install all those dependencies, of which 90% is shared between the local modules, then deal with updates, npm link, etc. It appears two bad choices in architecture of decoupled components and maintenance nightmares or monorepo with its drawbacks. I was hoping there was some popular open source projects, tooling, etc build around maintaining apps and dependencies that are all decoupled. From your response, it sounds like there isn't a good solution due to how node was designed and that npm link is the only tool to try and make it less painful.
JSON object validation is fantastic for test driven development. Agree what the API schema will look like up-front. Write your tests such that they conform to the JSON schema. Then get your code to pass. In the past, I've taken it a step further to have my test suite generate my documentation. That way you know that your docs are always up-to-date with with your API. The devs consuming your API will love it. I have done most of my API development using Rails so I don't know a good suggestion for node.
Thanks for the info. I think you've got me, by polyfill I meant updating prototypes but I had not looked at the await/async specs at all. Funny enough, not more than an hour ago I was sitting with someone looking at using a generator function and arrays of async functions as a kind of async series. I tossed the code but basically taking an array of async functions, passing them to a generator, having the generator run a for loop to yield over the length of the array (I have absolutely no indication if that would work), calling asyncGen.next() in each of the functions, and finally calling the "resolve" function after the loop in the generator. \o/ We were talking hypotheticals and I really don't know how that for func in funcs loop yield would work out.
Panda Strike has blogged about their fast JSON Schema implementation a bit â€“ [here's a post about an even faster implementation](https://www.pandastrike.com/posts/20150123-congrats-imjv).
[removed]
185k base plus a bonus which put me at 225 all in last year. Id love to discover I'm wrong as I work as a developer lead in a soul sucking industry with a hugely restricted/controlled development (things like react/ aurelia are outright banned, for example) I'd be more than happy to join a company with a more open culture.
&gt;programming is just work for them and they do minimum. My condolences sir.
Where are you located? I'd say you're doing quite well and are likely on the upper end of the spectrum and that is the issue you're seeing when applying to other places. People I know in San Francisco and LA working for big names and startups alike aren't pulling in quite that amount.
Maybe I'm misinterpreting what you said, but if you're proposing not checking your inputs, this sounds like a horrible idea. You have to validate the input you're provided at some point prior to using it, or you're just asking for trouble, not to mention that you can't provide any useful error messages in the event of inappropriate input. What about injection attacks (even accidental ones)? Enforcing against a schema on the input is not the only way to protect yourself though. I essentially just attempt to convert the input into a model I use internally (tightly validating the fields as I construct it) and if it fails, I can give a useful response. And if it succeeds, I can safely assume that object doesn't require further checking as I use it. 
TDD basically. Write your schema, then write your API. Or give it to your consumers.
Yeah, and there's also the situation of new hires that are offered higher salaries than what are usually given in the form of a raise. It's a sad state of affairs when in most companies, the price for new hires appreciates faster than the internal system for raises and bonuses for their existing employees. It's like you're being penalized for staying with the company for longer periods of time.
That's weird. Is it a quirk of Node or intended in v8? 
You are. Key to your third paragraph.
This is fine for toy or small applications, but if you intentionally abstain from a framework you'll end up creating another one just in the natural process of DRYing up your code. Most modern frameworks are on the small side and can be learned in a weekend. Also, don't forget why people made these frameworks to begin with. The DOM API is not particularly pleasant to work with, nor is it especially fast.
I have played around it a bit. Besides speed, it also has great documentation, rich api, and easier to read codebase. I am trying to convince my team to move from is-my-json-valid to ajv, but I think there might be some tradeoff I am not aware of...
Do you know if transpilers use IEFEs to accomplish this or do browers do this natively now?
This won't really get you an answer. If you want help, tell us what you tried and what about it isn't working. Code samples will get you the best help.
I use https://github.com/dcousens/typeforce for my type validation. It's more flexible than JSON schema and allows me to easily analogue to other type systems.
Was it ever alive?
That's not a lol, this is a lol: speechSynthesis.onvoiceschanged = function() { var msg = new SpeechSynthesisUtterance(); msg.voice = this.getVoices().filter(v =&gt; v.name == 'Cellos')[0]; var str = 'CkEgY291cGxlLCBib3RoIGFnZSA3OCwgd2VudCB0byBhIHNleCB0aGVyYXBpc3QncyBvZmZpY2UuCgpUaGUgZG9jdG9yIGFza2VkLCAiV2hhdCBjYW4gSSBkbyBmb3IgeW91PyIKClRoZSBtYW4gc2FpZCwgIldpbGwgeW91IHdhdGNoIHVzIGhhdmUgc2V4PyIKClRoZSBkb2N0b3IgbG9va2VkIHB1enpsZWQsIGJ1dCBhZ3JlZWQuCgpXaGVuIHRoZSBjb3VwbGUgZmluaXNoZWQsIHRoZSBkb2N0b3Igc2FpZCwgIlRoZXJlJ3Mgbm90aGluZyB3cm9uZyB3aXRoIHRoZSB3YXkgeW91IGhhdmUgc2V4LCIgYW5kIGNoYXJnZWQgdGhlbSAkNTAuCgpUaGlzIGhhcHBlbmVkIHNldmVyYWwgd2Vla3MgaW4gYSByb3cuIFRoZSBjb3VwbGUgd291bGQgbWFrZSBhbiBhcHBvaW50bWVudCwgaGF2ZSBzZXggd2l0aCBubyBwcm9ibGVtcywgcGF5IHRoZSBkb2N0b3IsIHRoZW4gbGVhdmUuCgpGaW5hbGx5LCB0aGUgZG9jdG9yIGFza2VkLCAiSnVzdCBleGFjdGx5IHdoYXQgYXJlIHlvdSB0cnlpbmcgdG8gZmluZCBvdXQ/IgoKIldlJ3JlIG5vdCB0cnlpbmcgdG8gZmluZCBvdXQgYW55dGhpbmcsIiB0aGUgaHVzYmFuZCByZXBsaWVkLiAiU2hlJ3MgbWFycmllZCBhbmQgd2UgY2FuJ3QgZ28gdG8gaGVyIGhvdXNlLiBJJ20gbWFycmllZCBhbmQgd2UgY2FuJ3QgZ28gdG8gbXkgaG91c2UuIFRoZSBIb2xpZGF5IElubiBjaGFyZ2VzICQ5MC4gVGhlIEhpbHRvbiBjaGFyZ2VzICQxMDguIFdlIGRvIGl0IGhlcmUgZm9yICQ1MC4uLmFuZCBJIGdldCA0MyBkb2xsYXJzIGJhY2sgZnJvbSBNZWRpY2FyZS4K'; msg.text = atob(str); this.speak(msg); }; 
Thanks :D! Unrelated, How do I upvote?
nvm figured it out
You should make variables as local as possible; within a function, you should declare variables at the top of that function (with `var`, ES5 and earlier) or as close to the point of first use as possible (with `let` or `const`, ES6 and later). To minimize the use of global variables, wrap all of your code in an immediately-invoked function expression (IIFE, ES5 and earlier) or put it all in a module (ES6 and later).
* [Relevant SO about the benefits of a virtual DOM](http://stackoverflow.com/questions/21109361/why-is-reacts-concept-of-virtual-dom-said-to-be-more-performant-than-dirty-mode) * [SP question about React's v-dom vs Polymer] (http://programmers.stackexchange.com/questions/225400/pros-and-cons-of-facebooks-react-vs-web-components-polymer)
For some people this is true as they absolutely cannot work without some level of abstraction so they create their own. That still isn't vanilla JS. There are people who are capable writing large powerful applications in vanilla JS, so it isn't beyond imagination. The DOM isn't slow. It's your abstractions that are slow. The DOM is perhaps the most heavily optimized API ever implemented. Do you have benchmarks showing where the vanilla DOM methods are slow?
&gt; (isNan(initialBetAmount) what does that mean please
I didn't know about that subreddit, thanks, I'll do that from now on.
I think the one he made up was Pantone: Most colors don't correspond to swatches in the PMS, and IIRC the set itself is proprietary; I remember an old color-info. site that even said it had to stop offering matching Pantone colors because the info. wasn't available for free dissemination.
It's to get around Same Origin Policy restrictions... See http://easyxdm.net/
&gt; Don't you just need to grab the window location on page visit and then post that off to your api? Seems fairly simple to me... I think you're right. I'm overthinking the problem...
You're making this more complicated than it needs to be. `&lt;input type="number"&gt;`
Tough crowd around here. Thought for sure there'd be more discussion around this. 
The reason is that your return statement is inside your loop, not outside of it.
So I should put it one "level" down? I've tried that, and I get this error: TypeError: Cannot read property 'split' of undefined Any ideas?
here's my two cents: http://freezer.js.org/minimum-viable-view-library
^ this should really be in the sidebar.
Heh, nice. How did you encode the text?..... ah.... using btoa? 
Interesting point there.
I work on a project where our frontend generates forms based off of JSON Schema... it works very well especially considering we only have Mongo docs for data. It's also nice since we can use the schema for validation on both the client and server. yay for data integrity!
I didn't see any syntax errors either, so I copy pasted your code into codepen. No syntax problems, but I was also getting a different error than "Unexpected token ILLEGAL"--I was getting "cannot read property 'split' on undefined." That pointed me to a problem with your for loop: for(var i = 0; i &lt;= words.length; i++) { // Wrong exit condition! Your exit condition is `i &lt;= words.length`. This means that, since the `words` array has length 4, the loop will attempt to run the final time with `i = 4` (because 4&lt;=4 is true). However, `words[4]` is undefined; the last item is `words[3]`. So you actually want: for(var i = 0; i &lt; words.length; i++) { // &lt;, not &lt;= With that, [your code worked for me in codepen](http://codepen.io/anon/pen/MKRxwM). Subtle trickery like this is one reason people often prefer not to use "imperative-style" for-loops and instead try to use "declarative-style" data manipulation. For example, if you explain what your for loop does in English, you'll probably get something like "take each item in the words list, check to see if it is an anagram of the target, and if it is, add it to the results." Or, in other words, "Filter the words list down to only the items that are anagrams of the target." You can achieve the same thing in a declarative style using the native `.filter` method: function anagrams(target, words) { return words.filter(function(word) { return alphabetize(target) === alphabetize(word); }); } This code is easier to reason about, and there's less chance of a sneaky for loop error.
I suppose that's one way to look at it. I did have to learn an entirely new technology and figure out a way to jury rig tests for my output since the language I was using (perl) has shit support for JSON schema. I think I ended up dumping stuff out to a text file and using node to check stuff on my local machine. It was manually intensive and I would have vastly preferred having been able to automate the tests, but that sadly isn't an option in the environment I'm stuck working with.
&gt; some great cutting edge web frameworks Could you give me some names to look into? I don't follow perl very much so I don't really have a sense of what's out there. All I really know of is Dancer.
Holy crap, thank you so much. I'm simultaneously relieved that it's working, and mad at myself for something so small. I've actually spent a lot more time in Clojure than JavaScript, and was able to solve this exact problem in like 3 lines of code in Clojure. It was definitely easier with a functional approach. I didn't think to use filter here, however. Thanks a ton for the help! Now I just need to figure out how to turn this 250k line .txt file into an array and try to use this code on it!
With Promise it would look something like this (inside the app.get(..) route): SC.get('/resolve?url=http://soundcloud.com/' + req.params.username).then(function (data) { res.json({ username: data.username }); }).catch(function (err) { res.json({ error: err }); });
If you care about performance chose another language entirely
Only works in Chrome/Mac.
You could check to see if the page already has jQuery and then decide if you should load it (append another script tag linking to jQuery). EDIT: Just remember, more dependencies means more HTTP requests. Try to keep it as minimal as possible for the sake of the users!
Add an event listener on key up and validate the input value there 
I might've gone with `atob("ZWF0IGEgZGljaw==")`. Or, if you really want to obscure it, maybe `window['\141\164\157\142']("ZWF0IGEgZGljaw==")`. :P
Advanced options: "whole word" :)
Type "log"? 
.log ? e.lo ? nso ? &lt;- this one works pretty well.
Hey, I'm on /r/javascript, I should post a totally irrelevant answer, everyone will give tons of upboats
Ah you must be suffering from true javascript fatigue, write a medium post and complain about it !
I can't imagine import being used much in production code. Minifying and conglomerating code should be the norm, there's no real reason other than in dev environments to use the import statement in a browser.
TLDW version?
Why not link to [the actual search result](https://duckduckgo.com/?q=es6+cheatsheet&amp;t=ffab&amp;ia=answer&amp;iax=1)?
I'm wondering a bit about the description for a promise. It seems the description is taken almost verbatim from the MDN site: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise But that site has two different descriptions: - "A Promise represents an operation ...." And a bit lower down - "A Promise represents a proxy for a value ..." There seems to be a lot of different opinions and usages for this. The makers of the original promise spec say it was intended to be a proxy for values. And most notably jQuery breaks this in their $.ajax promise implementation (which resolves to a method with more than one parameter). Anyone know what's the correct way according to the ES6 spec?
Look at the context. He's coming from Angular 1 and is looking for a the fastest "framework". Angular 1 is built on top of "Vanilla JS", you think he doesn't understand this? Religion is not built upon Atheism, that's not a great analogy. It's like asking "I have a dell laptop, what's the cheapest laptop alternative?" with a response of "Build it yourself, building is cheaper". Well gee, thanks... yes, it's cheaper but I asked for "cheapest laptop", if you give me a cheapest non-laptop, it doesn't satisfy the question. This response is similar to the one below that says "Don't use Javscript"... It doesn't answer the question or bring anything to the table.
 ReferenceError: speechSynthesis is not defined 
But then are we going to transpile ES7 into ES6 or down to ES5 again? And with the Ecmascript committee's plan to release a new ES every year, how low do we go? Is ES5 going to be the semi-permanent baseline that IE6 used to be for the web industry?
Sounds like a very fulfilling life you've got going on, there ...
Hope you carry on believing downvoting makes a difference :^)
thanks
Just to add an alternative way: Events always make a round trip through the Dom tree, first they trickle downwards in the capture phase, then once they hit the deepest nodes, they bubble upwards in the bubbling phase. Basically you make the body eventlistener trigger during the **bubbling phase**, that way when you have child elements that you want to exclude, you can register their listeners in the **capture phase** and stop it from propagating, as in stopping the click event dead in its tracks before it ever reaches the bubbling phase (in which the primary eventlistener is triggered). capture phase, trickle downwards through dom tree -&gt; if excluded element is found, stop propagating, else continue -&gt; bubble phase, bubble back up -&gt; trigger primary event listener example: document.body.addEventListener( "click", function(e){ //do something here }, false // false is bubbling phase ); document.querySelector('.myExcludedDiv').addEventListener( "click", function(e){ // stop propagation of this event, it will never reach body in bubbling phase. e.stopPropagation(); }, true // true is capture phase ) made an example too: http://codepen.io/arianr/pen/yeWLXm
OK, So, for the most part, a benchmark against native DOM won't make any sense. When you are worried about performance, there's two huge areas you have to worry about: * Initial render time * Data update render time In the first scenario, it would be obvious that the fastest way to add something to the DOM would be to use the DOM directly. The second scenario, though, reveals a complicated problem: How are we going to associate some data that we mutate with the DOM? * If you say, the DOM itself will hold the data, you're going to re-invent something like jQuery or prototype * If you say, we should check if our models change, you're going to reinvent something like backbone or angular * If you say, we should trigger updates based on mutating observables, you're going to reinvent knockout * If you say, we should have components that can render themselves and compare that against what's in the DOM currently, you're going to reinvent react (or other virtual DOMs) This is basically the oldest problem in dynamic website development. How to maintain changes to our application state in a way that is easy to develop, not error-prone or tedious, and generally easy to maintain? The DOM doesn't give us a way to synchronize a model with the DOM. Of course, you might be saying "just do mutations through the DOM manually" but this solution simply doesn't work or scale if you have multiple identical DOM elements associated with different data. You might say "just use the DOM to store your state" to get around this problem, but now you need to read the DOM every single time you need to access any part of your state. This is why it's inevitable that people either make a framework or adopt one. This is why it's fine to use "VanillaJS + DOM" for small or toy applications, but it is untenable for a larger one. Most people recognize the proposition of maintaining dozens and dozens of DOM mutation functions as a *nightmare*. As for not recognizing the DOM or javascript as abstract and simply flat-out ignoring what people have been saying for years now: That's just like, your opinion, man. I have no interest in responding to that when you clearly have no interest in having an open mind on those topics. 
And if you're looking for a language that can run everywhere, pick JS.
That's kind of where I was going with it. WebPack and friends are cool for optimizing and whatnot, but when building small-medium examples or experimenting with new libraries, it's nice to not need a full blown build environment. My hope is that a native `import` will make this possible again.
Your perspective sounds very confined to HTML and MVC. The DOM applies to more than just HTML. &gt; How are we going to associate some data that we mutate with the DOM? Assuming we are only talking about HTML the data should never reside in the DOM. The data should reside in your application. The DOM should contain human consumable content, a descriptive and navigable structure, and attached events. This is basic separation of concerns. You should never update the DOM merely because the data changed. Again, this is basic separation of concerns. This is a common misconception of things like two-way data binding which is often unnecessary and rarely efficient. You should deliberately update specific content because: * You want to inform the user of a single specific content update, like if they have a comment awaiting their attention or if a stock ticker value changed dramatically. * A user fired an event that causes an intentional content change * Content related data is updated from an asynchronous response, like a news update, and should result in updating content to the user. Most people don't think about this stuff because they are utterly reliant on their framework to figure out for them. They know there is data in some model and a view that renders into something and some magic that happens in a controller in between. That is nice and dandy but makes things like accessibility harder to understand. If you had to try producing a WCAG 2 AA site with Angular you will quickly wish you were using vanilla JS. &gt; Since the DOM has no way to associate a javascript model with a DOM element It shouldn't. That is a violation of separation of concerns and bad application architecture. Your application logic does one thing and the DOM/HTML does something completely unrelated. You should be separating your JavaScript application logic from your JavaScript DOM interface code as in separate files that only talk to each other through a documented API in your app. &gt; This is why it's inevitable that people either make a framework or adopt one. The most common reason is because they find the web (with its various different technologies working together in various different ways) completely intimidating, particularly if they are new to the web or new to planning architectures. For these people it is absolutely inevitable, but only because they don't have the imagination and experience to operate otherwise. I say this because I have seen both perspectives numerous times at various jobs and because I have written large vanilla applications that were easily extensible. &gt; As for not recognizing the DOM or javascript as abstract and simply flat-out ignoring what people have been saying for years now: I have been working in this field for almost 20 years. I don't give a shit what ignorant garbage is currently popular among ignorant fearful people. If you want to examine this line of thinking I recommend reading http://www.amazon.com/Lord-Flies-William-Golding/dp/B001K2DIME/ref=sr_1_4?s=books&amp;ie=UTF8&amp;qid=1455808757&amp;sr=1-4&amp;keywords=lord+of+the+flies
&gt; Look at the context. He's coming from Angular 1 and is looking for a the fastest "framework". Angular 1 is built on top of "Vanilla JS", you think he doesn't understand this? I have encountered developers who don't. &gt; Religion is not built upon Atheism, that's not a great analogy. Actually it is, but I am not going any further with that.
By the way, what's so better than js? C#? Yeah it's not like all the GAFA are pushing for javascript.. Or are they? No sound-minded company created these days will push for something like C#.
Rofl 
I mentioned this on Hacker News a couple of days ago, but it's worth repeating: nowadays you really have to question the idea that vanilla js is always faster. Most people are not templating library writers and are not aware of the tricks that these libraries employ, the algorithms to handle hairy cases or even what can cause js engine deoptimizations, whereas library authors are acutely aware of them and working restlessly on the performance angle (thanks to the healthy competition provided by there being so many virtual dom libraries). Just to give you one example: the most likely thing an average dev would do to clear a node's children is probably `foo.innerHTML =""` (or worse, `$(foo).html("")`). This can be accomplished a lot faster (and I'm not saying how in order to make the point that your average team member likely doesn't know how). And this is only *one* case. 
Wait, do you mean that I don't get paid my employer to waste 2 years on a weather app using only Vanilla JS (and maybe roll out my own framework because I'm so much better than everybody else?) 
But i get a undefined method .then for data because data comes back undefined?
Is JQuery ok? $("document").ready(function () { $("#buttton").click(function () { $('#myform').submit(function (e) { e.preventDefault(); $.ajax({ url: "listrecord.php", type: "GET", data: "data", success: function (data) { $("#form_output").html(data); }, error: function (jXHR, textStatus, errorThrown) { alert(errorThrown); } }); // AJAX Get Jquery statment }); }); // Click effect }); //Begin of Jquery Statement 
Nope, I'm using React on the front-end. So no JQuery.
function submitForm() { var http = new XMLHttpRequest(); http.open("POST", "&lt;&lt;whereverTheFormIsGoing&gt;&gt;", true); http.setRequestHeader("Content-type","application/x-www-form-urlencoded"); var params = "search=" + &lt;&lt;get search value&gt;&gt;; // probably use document.getElementById(...).value http.send(params); http.onload = function() { alert(http.responseText); } }
It depends on what the form is doing. If you just need to POST some data and it will respond with a payload, then you can use AJAX to simulate a form a post, e.g.: function submitForm(e) { e.preventDefault(); // don't navigate away from the page var formData = this.state.formInputs; // assuming you're keeping track of your form's inputs inside of your component's state $.post('http://urlToPostTo.com/endpoint', formInputs) .then(function (response) { console.log(response); // log the data that came back }); } // ... &lt;button type="submit" onClick={submitForm} /&gt; Now, the problem that you're going to run into is the file upload. Uploading files through AJAX is not supported by all browsers and is a bit tricky. We can use the [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) API to do this; [here is a stackoverflow](http://stackoverflow.com/questions/2320069/jquery-ajax-file-upload) post on doing that using jQuery, though swapping it out for using plain JavaScript/React shouldn't be hard.
You can create your own 'virtual dom'. It's another name for 'manipulate javascript objects' -- it's confusing people and it's a marketing ploy which happens to be a lie about how it's working under the hood. You want to sort a table? Create a JavaScript object, sort that thing, then render it to the DOM.
Since I can't seem to manage the formatting here: http://www.javasqript.com/2016/02/post-form-without-refreshing-page.html
It's slightly misleading to me to say mithril doesn't have templates. It does have templates, it's just that the templates are inside the javascript, instead of being in the HTML. 
I was just on CNN and had this download automatically. 
Not only: http://caniuse.com/#search=SpeechSynthesisUtterance
&gt;Just when you managed to codify all your projects' tasks into Grunt, you were tempted by Gulp. Then Broccoli.js came along to seduce you and now you are also considering Mimosa. To be honest, I thought broccoli js was a joke the first time I heard it. But anyway, I always think of [this](https://xkcd.com/927/) when someone laments about all of the options in javascript while simultaneously introducing another solution. 
Function composition: "advanced usage" of `reduce`.
That's very cool. I'm new at web development, and animating stuff in the DOM is still mysterious to me... would you know of a good resource to learn how it's done?
Faster still is to not clear its members, but instead remove it from the document without destroying it and put another node with the desired children in its place. You don't need a virtual DOM to optimize around this.
Nice library. I am absolutely loving all the micro service love here. We already have a large app in prod using RabbitMQ with ECS, but have been investigating the AWS Lambda approach. 
Rofl
Always bet on javascript
&gt; In the first link the infernojs tab is broken That's just because FF doesn't support `class`. Use chrome. &gt; It would be close to 0, because you only have to write the array FPS is not the proper unit to measure that, and besides, it would take far longer to traverse the DOM than doing the same on a virtual dom tree. DOM API function calls are very expensive - and attribute lookups are also expensive because they are function calls under the hood - compared to js data structure lookups. JS data structure lookups can get near-native speed from function inlining, hidden classes, etc, whereas DOM API calls don't get any JIT optimizations and have a ton of spec-compliance overhead. Not to mention some browsers do sometimes trigger repaints on DOM traversal (Android). I'm really not sure what you're trying to prove here. I've shown you apples-to-apples comparison where vanilla js is clearly losing, and in your oranges-to-apples attribute gathering exercise, vanilla loses too. Do you really think that just because you have 20+ years experience, you know better than the dozens of developers who are actually doing optimization work with modern javascript engines today? It used to be that using the `.` operator or doing loops in certain ways was significantly more expensive a few years ago, but that class of micro-optimizations is largely obsolete nowadays. The field of js optimization has changed drastically over the past few years, and to suggest that DOM is not the bottleneck in rendering today is somewhat out of touch with reality.
&gt; HTML Canvas interaction is fast precisely because it doesn't interact with the DOM. It's a special case where you're directly manipulating the data. That isn't entirely true either. It is true that DOM access is an unrelated and competing concern to GPU rendering optimization one must still wait on the other, so in this case DOM will reduce the rendering potential (in most cases). For a counter example look at Flash. Flash from 5-6 years ago is still renders with greater FPS than canvas render in the browser even with DOM access. This indicates that there remains room to optimize the relationship between DOM access and GPU render. &gt; DOM reads and writes need to cross the native barrier, and are batched in modern JS Engines. You're paying a serious penalty to read/write to the DOM that doesn't exist when you stay in JS Land. That is entire true, but in modern browsers it isn't as significant as many people would suggest. Prior to 2010 this used to be very slow, but that isn't so much the case now. The DOM is so well optimized now that is easily possible for well written DOM reads and interactions to be faster than poorly written JavaScript logic written around it. &gt; You even mentioned yourself that you want to separate your data from your DOM -- that's all that modern frameworks really do these days That could be their intention, but I rarely see frameworks used in that manner.
Could this be language envy? It is Java Magazine after all.
And the sky is blue :)
That is heavy speculation. I don't need to speculate when I write vanilla code. There is all manners of research and experiments out there about performance with vanilla JS. When something is in question you can write your own perf at jsperf. If you have to speculate in order to justify the possible (unknown) execution potential of a given framework then we are no longer talking about a fast framework as fast implies something tested and having benchmarks.
Yes.
Probably peaked around 100% browser support.
I noticed the same. :/ Sneak~~er~~y (lol!) fuckers... I haven't used facebook in years. I opened up Chrome the other day and got a facebook notification. I didn't know what to make of it. I Googled around and you have to go in to advanced settings to shut it off. I suppose it started happening with a recent update to Chrome..? I haven't a clue what script or whatever started running in order to display the notifications. Hopefully someone can give some answers...
Would "main.js" be where I put the literal code, or would it be where I put the name of the file with the code in it?
Create your own fictional stock api, (stocks for umbrella Corp, abstergo, Evil Corp, stark industries etc. ) The most basic one: Todo backend. This example scales really good: start with in memory storage and only support one set of Todos (all users access same todos) add user accounts, add persistence, add notifications for todos, add connections between todos. 
because there are people that don't want to open up a browser each time the cheat sheet needs viewed. the image works better for me, thanks OP!
Ok, so, you can only obtain files in the browser using the built-in Choose File dialog. You have access to localStorage in modern browsers but you are limited to 5MBs of data. If your data is less than 5 MBs accumulated, you can try that. Otherwise, some sort of server must be used to store the data. Google Drive comes to mind. It is easily accessible from Javascript, and you get 15GB of free storage. 
That looks awesome and it's probably what I'm looking for. I was hoping that there would be something like this, that can just let you statically type variables more intuitively. LLJS still looks a lot like "normal" JavaScript, but even more interesting that it lets you do C++ like memory management with an emulated stack.
Always bet on javascript
I've worked with both CoffeeScript and TypeScript and I have to admit that I was initially skeptical with TypeScript. However, having used both in medium / large web applications at my current company, I'm a proponent to TypeScript. Having typings is such a time saver and debugging help with integrated IDE's. On top of that, since its a superset of JavaScript, you're essentially writing JavaScript with extra typings. That being said, CoffeeScript is awesome in its own right, but with the advent of ES2015, a lot of its features are now baked into JavaScript.
TypeScript is easily the best choice we've made in our recent projects. I would never start a new project and NOT use TypeScript. And don't bother comparing it to something like CoffeScript. They're not on the same level
&gt; I do not see any code, just computer science buzzwords so I can't comment on it. Yet, you are commenting on it. And there are links to the source projects. It's widely known that DOM updates are traditionally the most expensive part of the JavaScript that runs in a JavaScript application. Also, infinite scrolling would not solve this problem. It's about being able to perform filters and transforms that result in DOM updates faster. An infinite scroll shows less data, but you still need to perform a transform on your source data to then slice off what is displayed to the user. Finally, the author acknowledged that those large data sets in the examples were contrived. But being that maps and filters are some of the most common transforms done in JavaScript applications, it's not unreasonable that a large app with many transforms and filters would benefit with even smaller data sets. 
Can I ask what specifically changed in your workflow? I know very minor basics of TypeScript but I haven't bothered to integrate fully into my dev projects.. but sounds like to you TS has become indispensable
You make it sound like typescript and javascript are two separate things when in reality one is just a superset of the other including types.
Exactly. An image can be saved and quickly referenced without opening up the browser. Not that I think that's necessarily any easier.
You're accessing your array just fine. Your problem is with timing. It sounds like you're expecting to see data in your array before you have data. Its like expecting the first log here to have data: var test = []; console.log("test outside: " + test); // Where's my 1, 2, 3? test.push(1, 2, 3); console.log("test inside: " + test); // Has's the 1, 2, 3 The same applies to your code. You're checking the outside before the code has run to set the data on the inside. If you have things in that "outside" area that is depending on that data existing, then you need to move it to the "inside"
Only takes a few hours anyways. It only adds a handful of features to the massive language that is ES6. It really isn't a noteworthy investment.
&gt; in conversations w/ some vdom library authors, How and why would vdom library authors use proxies? Proxies improve observable performance. I can't see how they would benefit the vdom approach. &gt; a `reverse` operation would not benefit much Actually, reverse would benefit in the same way as map and filter, but I think you're missing how `reverse` would be used with change propagation. You're likely thinking of how long it would take for someone to call `.reverse`. For example, I have an array of todos and I want to reverse it. For that single reverse call, change propagation wouldn't help. However, if that reverse was something you had to do every time a todo was added to your source list, change propagation could maintain a reversed list in `O(1)` time. This is how, in general "functional reactive apps" should be built. This is why change propagation could be so useful in those situations. Once you've setup your transforms, the app can update much faster. &gt; In addition, the field of vdom performance has very strong traction currently. Yes, VDOM is a great technique. But none of those techniques can change the fundamental performance from linear to logarithmic. 
There's no one left to teach JS to!
You could then use a `$watch` to [access it from outside](http://jsfiddle.net/HB7LU/24080/).
You can use the closure compiler * write ecma 6, * Get type checking - switch on type inference and write normal javascript and occasionally add type annotations as a text comment to help the compiler. * Get tree shaking * Ability to split out modules 
Does TypeScript and JSX mix?
yes https://github.com/Microsoft/TypeScript/wiki/JSX
Nope. The definition of the `test` variable and your "outside" log are synchronous. The only way to have that log get the values you want is if you `push` those values synchronously before your log (no $timeout) OR by moving the outside log to also be asynchronous like the $timeout. This means either putting it with the `push` code or setting it up in some other delayed code block (like EnchantedSalvia's example) that gets run after.
&gt; I can't see how they would benefit the vdom approach. The original idea was to create action flags for cheap actions (e.g. push and pop), so that the diff engine could shortcut and do a insertNode/removeNode without diffing the entire array. It turned out that this idea didn't perform so well in practice, so it was dropped. &gt; if that reverse was something you had to do every time a todo was added to your source list, change propagation could maintain a reversed list in O(1) time. Reversing the javascript array is never ever ever going to be your bottleneck. The problem is that you can't reverse an attached DOMNodeList in less than O(n). This is a fundamental problem w/ dealing w/ the DOM API: some DOM operations *cannot* be done in log time. We can only improve algorithmically on other cases, and try our best to reduce overall overhead for the generic case.
Make a simple blogging platform, save users and posts, make them editable, get all posts, get by user id. You could also add tags. 
I think this is a good solution! Thank you very much! 
Writing wasm modules in Rust (or C++ etc) will be probably the way to do that kind of thing in a year or two. So, learn Rust or C++ if you're interested in writing high-performance code. Writing Asm.js code by hand isn't feasible. It's like a seriously shitty bastard C. It's actually so bad that it qualifies as an esoteric joke language like Brainfuck or Befunge.
Thanks for this suggestion. Webpack has solved all of my problems.
Right you were!
Are you planning on using the [JerryScript runtime](/r/programming/comments/3eq05z/jerryscript_a_javascript_engine_for_internet_of/)? or another [embedded JS engine](https://news.ycombinator.com/item?id=9951458)? (had to xpost the [relevant XKCD](https://xkcd.com/801/) "[Golden Hammer](https://imgs.xkcd.com/comics/golden_hammer.png)") :-)
There's no way JavaScript is ever going away unless the w3 consortium can decide on a new language. Even if people use typescript or something, that still compiles to JavaScript. Maybe it won't be as popular on the back end, but it's for sure going to outlive Java.
You missed elaborating on the key reason for TypeScript's existence, which is type safety.
Node.js, or Rails.
TypeScript because it's becoming esnext+types+annotations, Especially since version 1.8; it's far easier to mix plain js with typescript.
You could save a reference to the original functions and then provide a method to allow toggling the state of logging. Pulling from his code, it could be something like: (function() { var noop = function() {}; var methods = [ /* array of method names as strings */]; var backup = {}; var enable = function(method) { console[method] = backup[method]; }; var disable = function(method) { console[method] = noop; }; methods.forEach(function(method) { backup[method] = console[method]; disable(method); }); console.enableLogging = function(shouldEnable) { if (shouldEnable) { methods.forEach(enable); } else { methods.forEach(disable); } }; })(); Or is there something I'm missing?
Misunderstood the comment 
&gt; mentally apply Wasn't aware there was another way to apply knowledge of a programming language
He's still waiting for Java Applets to take off.
React isn't going away anytime soon. Angular 2 came out recently and is huge. Try using google trends for frame works and you will see. Also look at the job market, check what skills you need for certain career paths. 
https://en.wikipedia.org/wiki/WebAssembly?wprov=sfla1
It's already here, even on IE9; See: https://github.com/kripken/emscripten
Ha! You're funny.
2016 will be the year when embedded Java apps come back
Learning to use a framework is not committing to anything. It's learning. Maybe try to make a game?
I switched over to TypeScript about 4 months ago. It is one of the best decisions I ever made. For the project I am working on it has made cross-team collaboration so much better and reduced the number of syntax related issues making their way into deployed Javascript. Such a lifesaver. Some aspects might be foreign to you, strict typing is awesome.
Work application is a .NET API and Aurelia for the front-end. In a personal project I am using Aurelia with Node.js for the RESTful API backend and most of my contracting work is as well.
any good tutorials/videos to grasp the gist of TypeScript you guys would recommend?
/r/atwoodslaw 
Golang! All our APIs are Go.
[another module bundler?](http://www.thecoli.com/media/dj-khaled-another-one.6093/full)
Genuinely curious, not trying to be argumentative: what's your rationale for suggesting Aurelia over a framework like Angular or React with widespread commercial adoption for a newbie? I'm asking as a newbie myself, who's looking for his first programming job and seeing a lot more openings for established frameworks.
Aaaany time now
On phone so.... Rob Eisenburg is a big name in the field. But if you are looking for a job, maybe common is better. 
Well, if you write code in some other language and then compile it *into* Javascript, does that still count as Javascript?
Changes to your workflow can include: * a build step * not having to constantly reload your app, find a typo, reload, find a typo etc etc. You can fix this directly in your editor (often without having to run anything explicitly). * being able to jump directly to where things are defined * being able to find which code calls the function you are looking at * being able to refactor and rename thing easily and safely * having clear machine readable docs which are also checked against the code etc etc
Go Angular 2/ typescript
typescript and coffeescript aren't really too related. Typescript: \+ type safety (interfaces, return values on class members etc) \+ some null protection \- a lot of extra characters to get type safety to work \- longer build times \- only works with stable dependencies (due to definitely typed-reliance) CoffeeScript: \+ dense, clear syntax \+ good jsx (csx) support Depends on what you want really. You have to ask yourself how important type safety is for you.
I am suprised no one has mentioned Dart yet, Googles "JavaScript" killer. It's like TypeScript, but its not a superset of JavaScript (meaning Google created a language from scratch and could ignore any bad decisions done in the early time of JavaScript, etc), its actually its own language that gets transpiled to JavaScript. I think you should see some example code of that as well. https://www.dartlang.org/#code
At some point, I had a talk with an engineer that was trying to tell me that GWT was the future of web development. Mind you, he wasn't exactly sure about the difference between Java and Javascript, but that apparently wasn't a problem. Worst part is that it wasn't so long ago, maybe three or four years.
It did for me, osx 10.10
I second react. Angular 2 meh not so much. I think these big frameworks are a thing of the past.
Is it easy to port to Angular?
Can you explain the exact steps? Maybe I'm using 'your console' wrong. Which should be the javascript console under Opt+Cmd+C isn't it? I'm getting ```SyntaxError: Unexpected token '&gt;'```. Which seems odd since arrow function expressions are part of Javascript. Safari 9.0.3 on El Capitan.
How much is reinvented by a framework should be considered when choosing a frameworks For example Angular reinvents many things and Aurelia uses more plain JS and web standards.
Why and where is type safety important? Haven't needed it in JS, ever. I can imagine it leads to developers understanding their code better and enforcing types of data, but is that it? Developer-experience improvements?
Essentially, yes. Errors in code are spotted on compile time so you catch most problems before they're shipped off. Also works great in team environments.
Does anybody remember VBScript?
I think that might be the route I go.
I know what it is. What is your problem? It is manipulating objects, creating methods to approximate the same behaviours that manipulating actual DOM objects gives you with less overhead of manipulating a DOM Node. I get its value.
Would you go back to previous job if you could?
Yes but i still feel like a change would be good, even the change for something potencially worse but different. Different project, diffetent people, probably strong learning experience. Thats what my gut tells me. I have not been on IRC since ages, will try it.
Wrote this: /* reusable code to get the property value of any element with an id call the function, passing in element id and the style property that you want to know */ function getStylePropertyValue(elemId, prop) { var elem = document.getElementById(elemId); return window.getComputedStyle(elem).getPropertyValue(prop); } console.log(getStylePropertyValue("myDiv", "font-family")); //'Times New Roman'
This might be useful. I'll check back in with you after digging into it a bit. Thanks! 
90+% is slow. /s
There's compile-tos like [livescript](http://livescript.net/) to take up the slack coffeescript has in the times that ES6 is popular. Particularly now that some functional programming is starting to pick up, things like function piping and currying as language features is really nice.
ES6 (ECMAScript2015) became a standard in June 2015, 9 months ago and many parts of the specification were finalized before that http://www.ecma-international.org/ecma-262/6.0/ The actual browser support at the moment http://kangax.github.io/compat-table/es6/ Latest desktop Chrome and Firefox implement many features, although native modules still do not work consistently. At the same time, unfortunately, desktop IE11 and Safari as well as mobile browsers lag far behind in their support of ES6.
We are using redux to store any locale related data (selected locale, messages for locale, etc). We have a mock in one place that configures the Intl polyfill and returns en locale for tests. We don't have to add anything extra to individual tests that render react-intl components. The mock point/seam in our code is the redux connected component that provides locale data from the state to the context for react-intl components to consume.
It got me a lot of interviews!
"I want to improve my resume by copying someone else's project" Don't get me wrong, checking out open source code you're interested in is a great way to learn by example, but if you're at the stage where you'd have to do so to have an idea of how to go about the project in the first place then I don't know if you can really call it a 'resume project'. I would start by laying down a list of things you want your platform to do, then sit down and try and implement them one by one. Then, if you get stuck, you can go research how other people did that specific thing. But that's just my dumb $0.02
I interpreted his "conventional" to apply to the templating engine, which in the case of Ghost is Handlebars, which is pretty conventional as far as JavaScript templating goes.
React.js/Node.js for frontend code/api proxying/simple data storage like user info C#/.NET for platform API, Data processing, I/O to stores/data warehouse, backend workers, and scheduling - pubsub architecture
This is exactly where our seem is as well. Components are Unit Tested, Containers are not. The issue is react-intl requires that top level IntlProvider to function to my knowledge, and I don't want to have to wrap every single component test in that because that's a bit ridiculous.
How is this done using ES6 syntax?
That first point is just it: I haven't missed it so far ;) 
Awesome link! Thanks for sharing buddy.
That's not my point
Reminds me of https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript, Gary Bernhardt's retrospective on JavaScript from the year 2035 (well worth a watch). Choice quote: "Although JavaScript has effectively taken over the world, [...] the language is dead". Seems surprisingly plausible eventually: the JavaScript world right now is great, but the really uniquely powerful magic isn't in the language, it's the ubiquitous platform, and the technologies around it. If we can progressively improve the tools and mechanisms for building things on top of it so you can develop using a fantastic language with a top-notch development experience and still get all the benefits of the JS platform, then I could really see this happening. 
&gt; learn react. What?
You don't need to specify the type of `person` here; TypeScript will infer it. `greeter(person = 'noname')` is sufficient.
I'm friend of u/eric-douglas, but have no responses in my last messages. 
I think he went off to find Mark Pilgrim.
I think you'll need to check such a thing yourself, ideally using a perceptual scale like the Y of YIQ, or if you're already using the D3 library, the L of the LAB scale.
Node, js front and back.
What's the advantage of doing a game in React vs. using a library like Pixi.js that's made specifically for animation and games?
 let emptyNode = require('./path/to.emptyNode'); let RootComponent = React.createClass({ childContextTypes: { // might be something else here, but i believe object is correct. // doing this in my head without any documentation right now i18n: React.PropTypes.object }, getChildContext: function() { return {i18n: this.props.i18n || emptyNode}; }, render: function() { return ( &lt;div&gt;{this.props.children}&lt;/div&gt; ); } }); then in your child components you can just reference this.context.i18n 
In case this interests you, I've written comments about [how to use generators other interesting ways](https://www.reddit.com/r/javascript/comments/458c3l/has_anyone_found_a_good_use_for_es6_generators/czw0bv0). They're pretty useful for DRYing up code in ways that may be slightly hard to grasp at first. You can even DRY up things you might have considered not-DRY-able, like try/catch blocks.
We recently decided to go with TypeScript for a large e-commerce site that we're building with React. The reason we decided to go with TS instead of ES6 with Babel was because we generate type definitions for how the JSON looks. So backend devs can safely refactor and see where in the frontend code they also need to change. It's been great so far. There are some things missing in TS and sometimes you need to work around the type system. But I think it's worth it. 
They are indeed pretty cool, e.g. I just implemented a web crawling function in [domp](https://github.com/mateogianolio/domp) that follows all valid links and returns "promise generators" for every level of recursion: https://github.com/mateogianolio/domp/blob/master/test.js
Interesting... How large of an app have you built with this? I think this would work well for basic cases but would fall apart in scenarios where you have complex containers. For example, most of my containers aren't passing root level store keys to my components. Instead I'm using a variety of selectors to derive data from the store and pass the results to my component. In addition I'm not often passing a root level action creator to my components. Instead I compose vanilla actions creators in mapDispatchToProps and pass the resulting "chains" as props to my component
done and done: http://doppiojvm.org/
I should've known... :)
The way modules work wasn't finalized until very recently (this month?)
This battle was fought and lost by Dart (sadly, I might add ). So be it. The future is JS or a faster subset thereof. Thankfully you can compile just about everything to JS and that is the future. JS is the new machine language. 
Couple clarifications, if I may? 1. Non-TC39 members cannot get a stage 0 proposal into the process. They need to find a TC39 champion first. Es-discuss is the right place for that. 2. A Feature may not be implemented in two browsers before stage 4. It's unclear (ie. not normatively documented) at this point what exactly the implementations requirement is, but it's conceivable that for some features, non-browser implementations (such as those in polyfills or non-browser engines) could be sufficient.
Yep, and it can lead building a fun recusive beastie where doppio runs nashorn runs doppio runs nashorn and then, of course, you run windows 95 inside all that! the future is bright I tell ya! :-)
- Lumen (PHP) - node - Java (Spring/JAX-RS) Also planning to use Clojure in the future.
I don't get the advantage of generators in this specific example. Instead of for (var page of requests) { page.then(function (body) { couldn't you just do for (var page of requests) { get(page).then(function (body) { (while `requests` is an array). If I want to loop something, I'd rather have an extra expression to retrieve an element from a collection rather than having an extra code block for it. One situation where I imagine generators to be a good thing would be in lazy load situations. For example if there's heavy processing involved or if the next few elements (eg. search results...) need to be fetched via HTTP.
aren't `@decorators` included in ES2016?
Vue is fantastic. So easy to get into, especially if you have some experience with angular but don't need all the abstraction.
HA HA HA HA HA! Slowly!? Maybe you're forgetting that many browsers still don't fully support standards that came out 10 years ago. There are a variety of reasons why vendors may take some time to adopt a new standard 1) wait and see if there's demand 2) see what a competitor does 3) waiting for amendments and changes to controversial or half-baked elements 4) waiting on validation of their own amendments 5) maintaining backwards compatibility 6) purposefully trying to sabotage the adoption of their competitors standard 7) confusion around how specifically to implement (i.e. look to arguments over the years between browser vendors on the box model implementation) 
That is true any time the values of the money "matter". In this case the conversion cannot be so exact that it does. 
VueJS is love.
No, still stage 1.
It's all a matter of communication. React is young enough to be able to do this kind of move, and people will have to search how it came from 0.14 to 15.0, and will find an answer easily.
 Edit: Like I said I'm still getting on board. I got a little confused because OP used "const foo = {}", then the next example is "const foo = 42". I reread it and now it's quite clear. 
It matters when you're dealing with libraries like redux where immutability is important.
you can get the client ip in browser js using the webrtc api, checkout https://diafygi.github.io/webrtc-ips/ for instance
You've never used const to declare an object or array that you're planning on changing?
How have others' experiences been? I might try it for my next project!
FYI, if you indent all of your code (including the HTML) with 4 spaces, reddit will format it correctly.
I'm finally using [joi](https://github.com/hapijs/joi) with it's compact and expressive schema definition (and FAST!). JSON Schema interoperability and genericity will miss me but heh.. JSON Schema is too verbose and complicated.. 
Call the Object.freeze() police.
Why not just call it 1.0.0?
&gt;It's all a matter of communication. Jumping from 0.14 to 15 makes React seem *less* stable to me, it *communicates* to me that the decision making around these things isn't very good. If they went from 0.14 to a v1.0, that would make so much more sense. It seems like they are trying to trick people now - React is at v15 and Angular is only V2.0... maybe the Angular team should go out of beta with Angular v20 instead of v2 then? Can you see how stupid this makes their decision seem?
True, but why focus on one specific JavaScript library? What about the rest of Google and what they use internally? That doesn't matter? Just curious.
It makes a constant reference, not an immutable one. Similar to `readonly` or `final` in java/C#, or a `const` pointer in C/C++.
Hey all! I'm late to this thread but wanted to mention that these are open source, "Instant Answers" created by the [DuckDuckHack](http://duckduckhack.com/) community. We're aiming to have an answer for every possible language/framework and there are several more in development/in need of adoption: https://github.com/duckduckgo/duckduckgo/wiki/Programming-IA-Coverage Full Disclosure: I work at DuckDuckGo
Haha I literally just told one of my co-workers not to use it for future projects yet since it hasn't even hit 1.0. So obviously version number is important when deciding how to make a project for clients. Edit: I am rightfully so receiving a lot of downs and backlash for my comment. My main point was that version number is definitely something people look at when planning a projects. I work for the government so that is why I made the decision. My higher ups could care less who does what, they just want a working application and it's not worth fighting over, wasting time. Sorry for the wording, not sorry for the statement. 
&gt; A version number 0.14 does not accurately reflect what React.js is today. Neither does 15.0, but whatever floats their boat React follows semantic versioning, thus the difference between 0.14 and 15.0 is actually a significant one. By saying "we practice semantic versioning" the React team has actually told you this themselves, I'm not putting words in their mouths! In semver a pre-1.0 project may break any APIs in any version, however a post-1.0 app must not break public APIs in minor or patch releases. You might argue "they already did that!!" and I would debate it, but that doesn't matter. The point is that version numbers in semantic versioning actually do mean something. They've taken on a new commitment for stability. And this is a great step forward for the React team to take! Excited to see how they handle the new challenge.
poll for mouse position, move iris in direction of mouse position.
Jesus Christ. I hate to be *that guy*, but is this blog post really necessary? Constants are not a new concept and have been well understood for *decades* in other languages. The only new information here is the existence of `Object.freeze` which I've never had to use. 
You do know Facebook uses React right?
This blog post - or some variant of it - appears more or less every week. I have no idea why it keeps being upvoted. Object variables are pointers to structs; if the var is a const the pointers cannot change but the structs can. Isn't this obvious? Do people still not 'get' pointers?
You forgot some cons of cs: - not a superset - no real big support from companies like Google, Facebook, Microsoft - compiler has vague errors - debugging can be painful - less documentation support
They could just call it React Core 1.0 Edit* This was sarcasm. .NET just changed their new version from vNext to .NET 5 to (now) .NET Core 1.0, which is confusing.
As far as I know, not much Dart is used internally since Go supersedes it on the server and Angular is used on the client. Looking through the "Who uses Dart" page and comparing, it appears that Angular is used more often than Dart in both internal and 3rd party applications. Google is in a tough spot. On one hand, they don't want to abandon Dart, but on the other, they realize that other languages are better at doing what Dart does, like TS and Go. 
Yayy, I wish more open source projects would increment the major version once the API is stable. I'll see projects with versions like '0.26.0' with multiple releases including breaking changes. Much easier to track a project and avoid dependency issues when versioning is done properly
Doing something like this for the only reason of giving your users the illusion of more security is questionable
&gt; it doesn't work on canvas and I hope it will perform well It probably won't. You need canvas for that. You need hardware acceleration and as little overhead as possible. You can draw like 30k sprites @ 60 FPS if you use WebGL and you can still draw a few thousand with a regular 2D canvas. You won't get anywhere near that with SVG/DOM.
they also use PHP
confusing. Just call it 1.0. And then again its Facebook no wonder.
Which [also skipped versions](http://php.net/manual/en/migration70.php)! It's clearly a conspiracy of some kind.
semver totally working
I meant more class syntax. Sorry
Good guess.
&gt; Because people frequently refer to React versions without the "0." prefix. So you might avoid future developers searching for "react 14 (some issue)" and finding StackOverflow answers that are actually discussing React 0.14 Just a guess though.
It actually is if they change the major version, regardless of the API being the same or not.
Well, it's just syntatic sugar for a function call. Same thing as `const localizedClass = wireUpLocaleData(OurFormattedDate)` Call your mock before importing `OurFormattedDate`: import { * as foo } from 'bar'; foo.wireUpLocaleData = mockFunction; 
Reminds me of how IE changed to 'Edge'. Just because they move the 15 over to the left a little isn't going to change anything.
holy shit, a learning curve
their semver isn't stable
rip raf
Yep, a weird change. It seems no one else picked up on the joke
Javascript has a lot of users with no formal computer science degree or computing background, probably more so than any other programming language. I think the issue is literally that having different types of variable is a foreign concept to a lot of JS developers. Point being that it's not that they're being slow to catch on, it's just that they've never encountered this before.
Get rid of MongoDB tho...
Some of the tips here are Chrome-specific but most won't hurt in other browsers: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers Also, if you really want to squeeze performance out of the framework, consider avoiding function expressions (i.e. the *creation of wholly new function objects*) inside loops, unless those functions are actually distinct per iteration. Also, if you rely on functions that use an options object pattern, consider setting up one object and reassigning its properties, rather than making a whole new options object for each function call. Finally, something-something "bit-hacks and small inlinable pure functions." P.S.: If you do use the DOM, cache all your DOM accesses and batch DOM mutations; also it's much less expensive to animate `transform` or `opacity` than any property that requires a reflow (like, say, `left` or `display`), and anything akin to `getComputedStyle` is very expensive, even though it doesn't *look* like a mutation.
It's more about communicating their intent to keep the API stable. 
Hmm, not really like a const pointer in C++. They didn't bother implementing it in C# because of it's inconstistencies. (i.e., const in some parts of the program but maybe not in others.) EDIT: I mean in the case of: void foo(const char *s) { ... foo has no guarantee that s is const, only that foo can't change s.
It's semvar. They can go to version 10000. It's meaningless as semvar versioning simply requires you to increment the major version when you have a breaking API change. The problem is your complete lack of understanding of versioning. The fact that you think the marketing team chooses version numbers is telling.
`const` is in C#, it's just only for compile-time constants. It's pretty consistent about that. `readonly` works for all data types and can only be set in the constructor. I forget what the rules for java's `final` are, but I know they can be set, once. And a `const` pointer *doesn't* guarantee that what you're pointing to is constant, only that you can't change what it's pointing to.
LMAO, dude stalks my post history and calls me a loser. I'll let you continue your important work of arguing that all major version releases must be incremented by one. I'm being your in high school.
I have no idea what you are talking about. Why are you so angry about a libraries versioning? It's weird.
The should have gone to 11 https://m.youtube.com/watch?v=KOO5S4vxi0o
Vue is honestly one of the best libraries I've had the pleasure of working with. Temptations is intuitive and Vue really gets out of your way and let's you do things how you want!
In what two languages does const mean the same thing? In C++ const means all kinds of different things in different contexts. In JS, const is very simple. A const variable cannot be reassigned. That's all, nothing more, nothing less. const does not mean immutable. It only happens to be immutable in C# because it's constrained to primitive types.
Yes, I mean didn't bother implementing it for non-primitive types.
I agree. There are developers out there who have spent 3-5 years working within Javascript without ever touching or thinking about another programming language. The idea of multiple variable types is new. The idea of pointers is utterly unknown.
I know there are several Pinterest like repositories: angular-deckgrid, ngFlowGrid and angulargrid. 
Three threads down and still misspelling semver. Not nitpicking but at least get the name right before arguing what it's supposed to do. I honestly thought it was some different versioning system. 
I don't think that's the same audience as who visits this subreddit, though. I'm sure there's some overlap, but enough to warrant this discussion coming up so often?
No worries. I was just slightly confused and corrected for future readers. 
There's a saying that goes something like "repeating it louder and more often doesn't make it right." I don't know why you insist on digging yourself into a hole on this. You've made your point. People have disagreed with you. It behooves no one to argue with internet strangers about it.
*semver
I get it, but it's still stupid. There must be better measures of stability: age, bugfixes, code coverage, estimated hours in use, etc.
Right now you are saying that a triangle has the the sides, represented as strings, `side1`, `side2`, and `side3`. Can you think of a more mathematical way to represent a side of a triangle? *hint: points*
Are they teaching javascript in high school now? Do your own homework 
Something like this would do the trick. "234".split('').map(num =&gt; parseInt(num)).reduce((prev, curr) =&gt; prev + curr)
I'm on my phone so hard to type but do a toString on the number and then split on empty string
Can I ask what library you are using for the API?
 &gt; 123..toString().split('').map(Number) [1, 2, 3] The lazy approach is probably good enough.
I recommend getting into node at least a little bit before jumping into a front end framework. You'll become a better JS programmer by playing with things like fs and express, writing a few simple modules and wrapping your head around async control flow.
Sites using React right now: - Facebook - Reddit - Netflix - Instagram - IMDb - Imgur - AirBnB - New York Times - Wired - WordPress - DailyMotion - Yahoo - The BBC - Dropbox 
Actually, I guess you could just use: tally += &lt;something&gt; But, basically, what you had before was saying: tally = tally + tally + &lt;something&gt;
 My bad, I mean it should return 4. edit: still returns 42 Ima restart the program and try again. Yea I still get 42?
Big fan of the `rnh` function.
Here: http://jsbin.com/topemixabo/edit?js,console
My situation wasn't to far from yours) I ended up finding something to make - something i need, so i didn't have any other choice than learning)
unminified for you) var myFunction = function(document, 'script', 'facebook-jssdk') { //define variables var js; var fjs = document.getElemntsByTagName('script')[0]; // if there is an &lt;script&gt; with id 'facebook-jssdk', return if (document.getElementById('facebook-jssdk')) { return; } // this is pretty much as else statement // if there is no 'facebook-jssdk' &lt;script&gt;, create one js = document.createElement('script'); js.id = 'facebook-jssdk'; js.src = "//connect.facebook.net/en_US/sdk.js"; // insert this &lt;script&gt; js before fjs, where fjs is first (?) &lt;script&gt; tag? fjs.parentNode.insertBefore(js, fjs); } myFunction(document, 'script', 'facebook-jssdk'); 
wow thanks for the help man. I had forgotten to do the same in the second "for" loop. Hate random bugs like that.
asm.js is supported by firefox, and plenty fast on chrome. Hell you can embed a browser in a browser (http://trevorlinton.github.io/)
1. I do not know why they fetch the variable `fjs` before it is needed 2. Putting braces around statements in a if/then/else construct is good practice 3. Here it seems that quotes are used to denote resources/URLs, while apostrophes are used to denote identifiers used in the DOM 4. The minifier probably chose the variable names automatically, and using arguments is probably for reusability of the code
node-soundcloud but I fixed it, my key was off by one character..../facepalm
Oh ha, glad you fixed it!
Haha you're retarded.
Heh, does [this](https://github.com/mbebenita/Broadway) count? Broadway: a realtime H.264 decoder ported from C++ to JS using [Emscripten](https://github.com/kripken/emscripten) then optimized to use the Google Closure compiler and WebGL? And yes, this abomination actually works. Some ads are even using it to get around current mobile browser restrictions on autoplaying video. But more seriously, the GitHub should probably link to JS transpilers like Emscripten, [pyjs](http://pyjs.org/), etc...
fixed now, thanks!
ok thanks
Not yet it isn't. What I am saying is... &gt; Read as: If this is production, set _i18n to props.i18n. Otherwise, check if props.i18n exists. If it does, set _i18n to props.i18n, otherwise set _i18n to emptyNode. ...you think your code does one thing, while it actually does something else, and it just so happens that you get the results you are expecting because you happen to be on the "happy path" all along ... that is a bug in disguise waiting to bite you in the ass.
&gt; Mobile users The search page works better.. no zooming in and out.. &gt; The result could change The cheatsheet may change, but I'm pretty sure it will always show up..
- generate color scheme from image url: http://codepen.io/chovy/full/WrPNbN/ - svg+css spinner http://codepen.io/chovy/pen/rxgEoO
&gt; I want to see some prototype-based OOP in work using JS (not Self). Do you know any open-source project of moderate size that uses prototype- rather than class-based OOP exclusively or extensively? I do! ...all of them. Because all JS has is prototype-based OOP. The new `class` keyword is simple sugar for the prototype-based OO we already had, and it's not widely used yet. See, eg, [here](https://ponyfoo.com/articles/es6-classes-in-depth): &gt; JavaScript is a prototype-based language, so what are ES6 classes really? Theyâ€™re syntactic sugar on top of prototypical inheritance What exactly do you want to see?
I don't think you understand semver.
Are the people upset about Facebook skipping 1.0 also upset about MS for not releasing a Windows 9?
You could always confuse them more with `123 .toString()`
Why would that be surprising?
And your credentials know anything about Google is.. what?
My point is that Google is a pretty big company. Just because the Angular team is using TypeScript, means actually.. nothing. Steve, who works for Mozilla, uses Chrome as his default browser. So I guess Mozilla doesn't believe in Firefox, right? Same logic.
&gt; Almost everyone starts out with jQuery While this may have been true 2 years ago; it definitely no longer is. People start out with the framework du jour, which probably means that newcomers now will start out using React.
You can ready more about the issue in this post: https://medium.com/@lavrton/frontend-development-tools-are-damn-complex-let-us-fix-it-56b3ff46ca8d
Boilerplates projects are fine, but they're not going to "fix" tooling complexity. They'll fix it for an individual developer, but it just adds another layer of abstraction without making anything less complex. In a year I wouldn't be surprised to see "there are too many boilerplates" with a meta-boilerplate project hailed as the solution. Just figure out what tools are used for and don't use them until you need them.
const in es6 works almost exactly like const in C. What you're talking about is more like a #define precompiler directive.
I can somewhat relate to you. I had been doing course after book after tutorial after practice project for a long time but rarely felt like I was actually gaining skills that would make me employable. But it changed when I went on github and started building things and working on projects (documentation, helping to close issues, fixing bugs, writing features, probably in that order). Far be it from me to disparage the great free and paid learning resources because they do help a lot. But nothing is better to become a coder than writing or writing about) actually useful code. So either come up with a project you really want to build and build it, or find an existing project, dive into the code and start helping out! As I said I do relate to your situation (though I tend to be more of an obsessive tinkerer) and I share your goals and interests (node) so feel free to pm me if you want my mail for a kind of coding buddy thing or whatever. Depending on how far you are with node at this point, I might have an easy-ish node project we could work on together if you'd like
If the input is points then isTriangle could just be: function () { return true; }
Self is a very different language than JS, and idiomatic JS code wouldn't look much like Self, even if written in a prototypal style. I don't think you're going to find what you're looking for. &gt; I want to see non-trivial JS code written by programmers in a prototype mind-set, not one of class I'm still not entirely sure what you mean. Could you give an example of JS code you believe represents a "prototype mind-set" and another example representing a "class mind-set"? I'm not sure how you'd go about recognizing JS code that uses prototypes with a "class mind-set".
Isn't it a React / ES6 with Babel / Webpack boilerplate? What about Angular2 / TypeScript / Gulp?
It's semver. Short for Semantic *Ver*sioning.
It pretty much entirely ends the conversation if you honestly believe the "chin stroke hipster type" stuff. That means your mind is already made up on it, and even worse, you've associated a very negative stereotype with anyone who feels differently. If you are actually interested in learning more about it, hopefully you approach future conversations with a more open mind and less negativity. As for the rest of what you said, you don't need 800 classes for a line-of-business application. Angular 1.x didn't have classes or annotations for *anything* and it got away it, as does pretty much every other frameworks for building SPAs. This is where the criticism of angular 2 comes in - it's needlessly abstract and java-ish. And even if all of that was worth while and was necessary, there's still the horrifying HTML syntax *that they had to write their own non-complaint HTML parser for*, and how much extra code you have to write with it just to achieve the same things. These criticisms have nothing at all to do with FP/OOP, and honestly, they're the more important ones. I don't care if angular is going against a trend, but I do care if I have to write twice as much code to do the same damn thing. 
Not to discredit your experience, but in my experience, I used the OS X reasoning because the only time I've ever seen anyone refer to El Capitan as 10.11 was because they had a specific issue and wanted to drill down. ya know "Oh my spotlight don't work, my version is 10.11.3" I see where you're coming from with technical people being on the number side too, but that's why semver is so important, so we all know what's going on when we read the version number. If you follow semver, seeing 1.5.3 go to 2.0.0 means there was a breaking change to the API. But if you don't follow semver, 1.5.3 going to 1.6.0 could mean breaking change, but you really don't know without reading changelogs, if the library has any.
Seems like a huge oversight on their part if that's really the case.
You can't really help what your users do. 
here's even more advanced demo with also animating inserts/removes: http://codepen.io/pakastin/pen/jWoXBP
Considering I have examined the output of this code in unit tests, dev builds, and production builds and it works perfectly fine and as intended (down to removing the or) I'm still not sure I understand what you are getting at. Don't get me wrong, I'm not defending this line of code because I also hate it and I am spending a good part of today going through the solutions offered here in detail to try to remove it. I'm just not understanding what you are getting at. 
I made a little library for using lenses in JS a while back and finally released it, [bifocal](https://github.com/justinj/bifocal). I think if nothing else it's sort of fun to consider.
http://i.imgur.com/hsvtxve.png A Google Maps-like RuneScape API. At its highest level, it will be 50,000 pixels long. I like the way it is progressing.
Try doing some particle effects like sparks, flames, and smoke with canvas and then try the same via DOM.
I recently discovered dojo for myself. Coming from an Ext.js/Ext.net background and needed 'something like it' i truly enjoy dojo. It has clear concepts, is robust, mature and well designed. It involves 'some' characters more to type than other frameworks, but it really pays off once your project grows to a certain complexity. The only thing im wondering is it being mentioned really rare. Can someone explain to me why this is? I see no obvious reason
Good idea. But my use case requires some server services.
Check out Adobe Flash and ActionScript
I've used Dojo on a rather large project. I personally think it grew in popularity because it did everything that Javascript made difficult. "Classes" were now available. Needed an AJAX request? Dojo supplied the mechanism to do that. Deferreds (Promises)? Yep. Got those too. Module loading? You get the picture. But then there was this shift from using these large frameworks to using focused libraries. I wanted to use real Promises. Bluebird. I wanted a much cleaner module loader. CommonJS (w/ Browserify). Dojo has all these great ideas but it's difficult to use the pieces you really wanted. Newer, more interesting, clearer methods came about since Dojo was a popular framework. And don't get me wrong it's still a wonderful project. Just behind the times, in my opinion. They've also been promising Dojo2 for about 2.5 years now as well. That always irritated me - knowing the framework I'm using now will be "outdated soon". 
Have you tried http://www.freecodecamp.com/ ? Give it a try, Its not an online course, here you have to do some work for nonprofits.
Thanks for the recommendations, I'll definitely check those out.
Ah yes, thanks! 
So what you need to to is use the jsonp format from their api. How jsonp is by making the ajax request in a script tag. (You insert a script tag with the src being the name of the api url). Then the script tag is populated with the result of the ajax. BUT in the url (if your api supports it) you have to supply a callback that is called when the script tag loads, the first argument is the response. If thats confusing read this:https://en.wikipedia.org/wiki/JSONP The reason this works is because browsers don't enforce the cross origin policy on script tags. Scroll down to the JSON section on this https://www.mediawiki.org/wiki/API:Data_formats. You will see that you can supply a callback that will be called with the parameter at your xhr response. I know that was confusing so ask me a question. If you don't want to deal with this stuff manually you can use jquery and it supports jsonp and does all the script insertion/callback for you. 
Logically they should have gone to 1.0 but few people who pay attention will be confused so it really doesn't matter. 
It's probably more the people that were upset that Windows 7 was nt 6.1 and windows 8.1 was nt 6.3. But windows 10 is nt 10.0
&gt; knowing the framework I'm using now will be "outdated soon". All JS frameworks have this problem ;)
Not really, pretty common in development. Java went through the same thing.
http://www.foreverscape.com/art/2016/byte-me-javascript-fatigue/
Thanks for the response! Tried this &lt;script&gt; function processJSON (json) { console.log(json); }; &lt;/script&gt; &lt;script src='https://en.wikipedia.org/w/api.php?jsoncallback=processJSON&amp;action=query&amp;titles=Main%20Page&amp;prop=revisions&amp;rvprop=content&amp;format=json'&gt;&lt;/script&gt; Didn't work...
Angular 1 was all about OO patterns and dependency injection which was both very Javaish. I find it weird that you object the use of class keyword and annotations/decorators which make those OO concepts and DI more manageable and readable, but you were ok with them in the convoluted way they were implemented in Ng1. In full agreement on the horrible HTML-mutilating syntax but I also understand them because with a proper editor/IDE it will allow for easier code scanning by new/other devs. Still, the way UI syntax is done in the React camp with the whole "lets make everything JavaScript" deal and the whole WindProc for 2010s mentality of it all, I'd still take Angular route any day. Hopefully stuff like UI data binding and virtual DOM will become the part of the Web Components implementation in browsers, and JS frameworks will start dealing more with app structure and data management. So far Angular and Ember remain the least horrible frameworks.
Yes. I just quick-edited my existing code (which uses a specific url). 
In short, Typescript offers the benefits of static type checking in javascript. These can include more robust code that can be reasoned about formally, easier refactoring, better tooling and generally higher productivity with fewer bugs. For small (say, less than 1000 LOC) projects the benefits TS gives may not be worth the overhead. For medium and large sized projects, however, static type checking can have a huge positive impact.
I'm a huge fan of GSAP. It's worth the license fee. Have not worked with Velocity yet, but if it does not ship with something like GSAP's Timeline, then there is still nothing that competes with GSAP.
FRZR view library also has a really minimal animation helper: https://github.com/pakastin/frzr/blob/master/src/animation.js There's also easings included: https://github.com/pakastin/frzr/blob/master/src/easing.js And automatic vendor prefixes: https://github.com/pakastin/frzr/blob/master/src/prefix.js Here's an example how to use it: http://codepen.io/pakastin/pen/jWoXBP
The basic idea is to use d3 for the scaling, data formats, and math, and react to render (manage the dom mutation). See for instance https://github.com/freddyrangel/playing-with-react-and-d3/blob/master/README.md Recently, d3 has modularized so that you can more easily use its libs without pulling in all of d3. See repos under https://github.com/d3 .
Yup, that's a 1:1 reimplementation of the Portal (game) ending sequence. For reference: https://www.youtube.com/watch?v=Y6ljFaKRTrI
FYI this is what I see, and tapping the menu does nothing. http://imgur.com/a/y5fTN
sorry about that, hopefully this makes more sense.What my code is currently doing i allowing a user to input two separate postcodes and submit them to place the two marks at the same time. Then when you mouse over the markers it show an info box with the postcode in it. What I now want to do is allow the user to insert their own info that then can be submitted to display on the marker when they mouse over it.
OMG, is this iPhone 6? I don't have any i-device near me to test. Anyway, thank you for letting me know.
fwiw, i tried it on chrome android and found dismay when the ogg file didn't start: https://mauricebutler.wordpress.com/2014/02/22/android-chrome-does-not-allow-applications-to-play-html5-audio-without-an-explicit-action-by-the-user/
There is a lot of talk about using Postgres since it can have json stores. Also GraphQL is gaining some attention.
Is the error because you opened the page locally without a web page involved. I seem to remember that caused this error. 
JavaScript is single-threaded, so running more than one instance of this function at a time is not possible. Very important to understand how the event loop works: http://ejohn.org/blog/how-javascript-timers-work/ It's likely you mean you want to prevent more than one instance of this function to be scheduled to run at any particular time. Three approaches depending on exactly the behavior you want: 1. Throttle (prevent a function from being called more than n times in a given timespan) 2. Debounce (delay execution of function until a certain amount of time has passed since the last invocation attempt) 3. Set a variable true when you create the promise, have completion of the promise set the variable false, don't create another instance of the promise if the variable is true. if (!window.running) { window.running = true; http.get('my/thing').finally(() =&gt; { window.running = false; }); } (or similar) http://drupalmotion.com/article/debounce-and-throttle-visual-explanation 
Thanks!
Precisely what I'm doing... Thanks!! *Brilliant! This works: $.getJSON('https://en.wikipedia.org/w/api.php?action=opensearch&amp;datatype=json&amp;limit=5&amp;search=cat&amp;callback=?', function(data) { console.log(data) });
Dojo 2 will never happen.
The behaviour I want is to make the function stack and queue then I think.
GraphQL is not a database, it's just an alternative to HTTP/REST APIs. Not sure if you knew that but you made it sound like an alternative to SQL.
Absolutely not dying. It's the proper modular depedency injected way to do things.
&gt;Mongo is no longer cool (thank god) I'm still amazed people were using Mongo as their main database. The minor convenience of a database that speaks JSON gets lost as soon as you need relations or even mildly complicated aggregation. &gt;React is cool, but only in combination with its companion library of the week It seems like the React community has settled on Redux.
Exchange your soul (or credit card) for unlimited knowledge and worldly pleasures... Google is now a Faustian devil like Paypal.
It can all be summed up by http://lebron.technology/
That is what will happen with your existing code... JavaScript does not thread (unless you are doing it rather deliberately with workers). Async (like HTTP) is single-threaded. Every function is scheduled to be run in the order it was invoked, in a queue. Their executions are not parallel -- they cannot be executed concurrently.
Those dependencies may add themselves to some global backbone collection. So you're starting them up but not directly requiring them.
Most of this stuff was happening a year ago too but I think is a good recent summary anyway: 1. learn [ECMA6](https://github.com/ericdouglas/ES6-Learning). Arrow functions, modules, let vs var, etc 2. we all use [Promises](https://github.com/kriskowal/q) now because they're awesome 3. [React](https://facebook.github.io/react/) and [Angular](https://angularjs.org/) are really popular now, and I guess EmberJS is still pretty popular. I still like Backbone but don't see it around as much as I used to 4. [youmightnotneedjquery.com](http://youmightnotneedjquery.com/) don't use jquery anymore you probably don't need it And also LESS, browserify, bower are all great.
Died when npm became popular. We have plenty of build systems now that take care of the dependency loading problem much more simply, with less ceremony, and fewer differences between development and production builds. Check out [webpack](http://webpack.github.io/). It's backwards compatible with AMD, works with NPM modules, will support ES6 modules natively in version 2 (currently in beta), automatically handles code splitting with no configuration, and is capable of handling all of the resources for your application (css, images, html, templates, etc). **EDIT:** Check out the [webpack comparison page](https://webpack.github.io/docs/comparison.html) for information comparing it to other build systems, including require.js. Compared to require.js it has significantly less client-side overhead.
&gt; Died when npm became popular. that is not really relevant. When NPM became popular, it was used for backend code only. AMD modules started losing the war when browserify came along I think.
To avoid problems like this one, practice thinking "properties" instead of "values". In your case, you're iterating through an array. The for loop should keep going while i is less than the length of the array. Instead of hard-coding the array length as a value, like you did and like it was suggested to you, the fail-safe way to do it should be: for (var i = 0; i &lt; family.length; i++) {...} That's the "old school" way to do it. Now there's an even better way: family.forEach(function(){...})
&gt; http://codepen.io/pakastin/pen/jWoXBP This seems very promising, I'll check it out. :) But being so small, I'm scared about the performance and ease of use; since the app will be quite complex. (I'm not sure how true this is however, maybe the optimization browsers do to RequestAnimationFrame() and similar is all that's required).
Probably not. We've been trying to kill Internet Explorer for years.
350
https://xbytez.io fixs that :) I never updated .eu
New 'import' statements from es6 will kill it.
Hi /u/spfccmt42, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index) (specifically, _Posting: Showing off a Project_). Please use the [Showoff Saturday](https://www.reddit.com/r/javascript/search?sort=new&amp;restrict_sr=on&amp;q=flair%3AShowoff%2BSaturday) posts for these types of submissions.
I've spent a lot of time experimenting with velocity and GSAP over the last year - velocity is great, for simple animations, but it just doesn't have the power of GSAP for anything complicated. 
But browserify uses npm modules doesn't it?
Yup was just mentioning that it was starting to get some attention.
Protip: use four spaces at the beginning of a line to write codeblocks
True.
&gt; switching to import / export modules once a spec is finalized Don't you mean implemented? I thought the spec was finalized last year, just nothing besides transpilers had implemented it yet. [edit] Did a little more digging. Apparently, the declarative syntax was finalized, but [not the loader API](https://github.com/lukehoban/es6features/issues/75), i.e. there's no agreement on how engines are supposed to interpret it. Transpilers just map it onto CJS as best they can, but they're operating in a spec-vacuum at the moment.
koa and rethinkdb
Uhhhh... No... The only way this site can inject CORS headers is by becoming a proxy/man in the middle. This is especially a problem if you are dealing with site sitting behind TLS. If you are in a situation where your browser client needs to interact with a 3rd party service that doesn't support CORS or jsonp, you need to run a proxy service of your own, that you control. I'm sure this fellow is well intentioned but this is a security nightmare waiting to happen. 
AMD is still the fastest "standardized" way to load individual modules in the browser. Many third-party modules still support AMD via UMD builds made trivially via other systems. However, lately I've seen projects degraded to using build steps and rebuilding the AMD files on every change. This really sucks, because it's not optimized for that use case. I think this is due to the inexperience with the design goal of AMD versus other module formats like CJS and ES6 which both (at the moment) require a build step. In the future though, browsers will make importing ES6 code trivial even in workers. So unless you're going to work on legacy projects (internal or open source), it's probably not worth learning AMD. If you're going in for a senior job interview, it'd be useful to know that you can speak on the subject, and identify its stagnation and age. For instance, hot module replacement isn't available for AMD, at least to my knowledge. Processing ES6 files in the browser is going to be slower than partial rebuilds, so if you want to use cross browser ES6, AMD will make that more of a challenge. Overall, I'm still a huge fan of AMD, but I'm even more of a fan of ES6 modules, so I'll choose that 100% of the time going forward. My thinking is that I can import any CJS module from NPM with babel's ES6 module transpiling, and the browsers will most likely make it possible to register a hook (maybe babel?) to support global requires (otherwise most babel import code will need to change).
There was so much hype early on, while many of us were asking *how* the modules will load. Especially for an engine like v8 which is used in multi-environments, what is the proper way for it to interpret loading from the file system versus the network. More likely there will need to be a hooks API in the loader specification, that babel and Node can hook into and provide the necessary implementation (Babel would only be used for legacy most likely).
Thanks for letting me know, I wasn't aware of that. 
Quite common to see this. Presumably the `firebase` module plants a global variable, e.g. window.Firebase so you won't necessary need a return value. Else it could be something like a jQuery plugin that hooks itself up to the $ variable without needing an explicit return value to be used.
It's not getting talked about much, but does that mean it's dying? It's done and complete. No news is good news. There's not much to add or change. I still use it and would always recommend it. It's a solid, well thought out, piece of technology.
Yes, you should change, but don't change your work :) Use your work to get very efficient - make it a game to see how efficient you can get, and then make time for side projects... if you can generate money from these side projects, it'll free up your time because you'll have enough money to stop working altogether if you want. At this point, you can change jobs freely without it impacting anything. 
There's not really enough info here to provide an answer. How does this code 'not work'? Did it throw an error or simply not provide the desired results? The code you provided is valid, but without context it's meaningless. If the code errors, make sure html elements with those ids actually exist. Also, look at when this code is executed. If it executes before the DOM is finished loading, the select element probably doesn't exist in the document yet because the browser hasn't finished rendering it. If the code doesn't error, inspect the select element and make sure it contains an option with the value 'abcd'. If the value attribute of the option element is set, that's is what's returned by the value property in js. If not, then the js value property returns what's inside the option tag. Are the options in the select loaded dynamically? If so, make sure it is loaded before this code runs. Like I said, the code you provided is valid. It's the context in which it's executed that's likely the issue.
https://github.com/sindresorhus/awesome#front-end-development
https://jsfiddle.net/zopar9n7/ Note: [The "hidden" attribute isn't supported by IE10 and below](http://caniuse.com/hidden).
What do you need in a js library that you can't get with CSS animations and transitions?
.. am I really the only person here who thinks that a label stating you've had 15 major changes in two years indicates the opposite of stability? The very definition of stable is, and I quote, "not likely to change".
Agree across the board, except SASS has become the preferred preprocessor.
&gt; how do you get javascript to display an error? It depends on the browser, but there will be an option for "Developer Tools" or "Console" in one of your menus. (For example, in Firefox it's under Tools &gt; Web Developer &gt; Web Console.) If there are any script errors, they will appear in that window, but you may need to reload the page after opening the console.
This is a *old* (Nov 2015) and poor article on picking JS. * Mentions Netscape * Uses V8 as a benchmark for performance, when Safari's JSCore and even Firefox have been performing better for a while. https://arewefastyet.com/ even shows this when you disable the scale-busting "full turbofan, no crankshaft" option. * Claims Node is a great platform b/c npm is growing fast, despite significant flaws in npm's reporting (the package manager makes more server requests than most others) * Touts new features, but acknowledges you need to use transpilers like Babel to get them. Despite Babel being great, it is definitely a crutch compared to simply upping the language version as happens elsewhere. There are definitely reasons to embrace JavaScript, but this old article with weak arguments is probably not the best to represent them.
&gt;Death to "fatigue" posts. Don't upvote. &gt;downvoting any post with "fatigue" in the title I have dutifully downvoted your post.
You're correct that it will make it less performant in HTTP1.1 but HTTP2 will not only make it more performant overall but more performant than bundling and minifying due to the nature of HTTP2's multiplexing and inherent compression. Furthermore, it allows for neat tricks like lazy module loading, partial code downloading, and other things I'm sure we haven't anticipated. ES6 modules according to [Allen Wirfs-Brock](https://twitter.com/awbjs) (editor of the ES specs since forever until recently) has said on a few occasions that the biggest deal in ES6 are the modules.
Angular ui-router does the same, so I can't think of any significant drawbacks... Keep in mind that it prevents you from using other fragment URLs 
I would recommend the simple "/' HTML5 push state approach. The drawback of the hash approach is that they aren't indexable by crawlers. 
It was useful before we had build systems like browserify and webpack with source maps. You could have the source directly in the browser so debugging was easier than working with the compiled version. Now there is no reason to deal with the cumbersome syntax necessary to make them asynchronous.
Depends on what you consider "at the same time". Technically, no, they can't ever run at exactly the same time. However, if you call your code 3 times, it will execute `$('.alert:first').remove();` 3 times, and the timeout periods can all run at the same time. 
Wouldn't compression be more effective working on a huge bundle?
It would, but the advantages of loading modules only if you need them makes up for that IMHO, by far. And if you want both, in the meantime, give my loader (mentioned above) a shot.
3 months is old now? And not just regular old, *italicized* old?
a few things I see: - there are only christening cakes on the page, so all the other buttons will hide everything. - on initial page load, all the elements have a style attribute including a display of inline-block - isotope removes this and the 'mix' class with display:none takes over. Remove that rule and it seems to work. - another bug -- on initial page load it isn't able to pick up the height of the container element and so something is setting it to 0 so the cake images appear behind the rest of the page. Clicking one of the buttons fixes this though That's about all I can help with... not to keen on decrypting all your minified code.
Well, it's popularity is declining which is bad news (for AMD, not for the rest of the world as other solutions are vastly superior). If you're still recommending AMD to others I believe you're doing them a disservice. I switched away about a year ago, and really wouldn't want to go back to a situation where: * Production builds might fail in ways development builds don't, because the optimizer causes the order in which dependencies are loaded to change. * My browser needs up to ten seconds to load all dependencies in development. Loading every file separately seems nice at first, but for large projects it's a pain in the butt. Not to mention when you want to test on mobile devices. * The awkward require syntax where you need to manually match the position of module names with the position of the module parameter. Causing the oddest bugs when you change dependencies, make a mistake and suddenly parameter A refers to module B.
I agree. So confused as to what to do right now.
Angular has massive amounts of community custom modules. Are they easy to port to vue?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/vim] [\[Question\] What do you use for syntax checking in vim ? : javascript](https://np.reddit.com/r/vim/comments/46uw4i/question_what_do_you_use_for_syntax_checking_in/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Syntastic + eslint with babel-eslint parser
How does code splitting work? I assume the bundles export something into the global scope, right? One of the most important features of webpack for me is scoping everything in one local function scope without polluting the global scope. 
- pangloss/vim-javascript - scrooloose/syntastic with jshint (npm package)
So the main rule of the thumb is do what makes sense to you. Does it makes sense to have it all in a big block? Sometimes it does -- there is just a lot of things that needs to be done. Or can you split it up into several functions? i.e. you could split it up into: function loadMap () { ... } function ajaxRequest () { ... } function appendToDropdown () { ... } and then, when relevant you can call them: loadMap(); ajaxRequest(); appendToDropdown(); So, in conclusion, use different files to separate big sections of code, and within those sections, you *can* use functions to separate if it makes sense.
I just switched from Syntastic + eslint to neomake + eslint, because eslint is quite slow, I feels much better after using neomake and neovim with the async job-control feature.
On Chrome when you type in clear into the console you get function clear() { [Command Line API] } Which means the clear function only exists through the console command line.
If you set the debugger to pause on caught exceptions then execute `throw "something"` in the console then the script debugger will show a script resembling: with (typeof __commandLineAPI !== 'undefined' ? __commandLineAPI : { __proto__: null }) { throw "Something" } 
Statements in the Chrome console are interpreted inside a `with` block, where the context is the console API. See the [MDN page for the `with` statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with) for more details on the construct. You can verify this by running the following statement in your console: `throw new Error()`. When the error is logged, click on the stack trace locator on the right. You'll see how the internal wrapping looks like.
Your years left to retire function is not part of the `person` class, so `this.age` in that function would be `underfined`
this.age within yearsLeft is probably undefined as this would be tied to that functions scope. You could call years left and specify the this scope using bind which should work. Try this.yearsUntilRetire = yearsLeft().bind(this). Might be worth reading up on bind, apply and call to understand how you can use that a bit more and what they do. Edit: Alternatively you could pass the age in as an argument without the need to use this at all if you were looking to keep this function separate from the person object.
I still use require.js for websites, using Babel to transpile es6 to umd. I then use r.js to build up a common module pack that is loaded on every page and I use page scraping to dynamically load non bundled modules via dom data attributes. This is something that is very difficult to do with webpack. I also think people who complain about how require loads tons of modules slowly has never optimized properly using r.js. For SPA's, I use webpack with module hotloading to ease dev. Hotloading is something require can't do but there is talk of adding it. I don't think require is dying just yet, it's an architecture decision that you need to ask yourself. Do you want your module loading code downloaded to the client or do you want your build tool to add it? When the es6 module loader is ratified and http2 is commonplace then both webpack and requirejs MIGHT be deprecated, but the benefits of transpiling other module types (css/json, etc) and having them part of your app would still warrant a need for both of these tools. BTW, if you bundle commonjs modules correctly using r.js (transpiled to AMD) and include almond in your bundle the output is usually a little smaller than a webpack build.
It looks like a two step process. Step 1 is to parse that data and return an object in the proper shape for Google Charts. Step 2 is create the chart. You could use a library like underscore.js to make step 1 easier.
If you're using Windows, F12 will bring up the developer tools. If your using a Mac I think it's Cmd-i. These shortcuts are for Google Chrome. You'll also want to read up on the change event [here](https://developer.mozilla.org/en-US/docs/Web/Events/change).
Learn
It will feel less messy if you break out as much as possible into smaller reusable functions and then have one main file that is mostly just calling functions. Also check out this free book "Essential JS Design Patterns" by Addy Osmani from Google: https://addyosmani.com/resources/essentialjsdesignpatterns/book/
Btut when you just type `log('hello')`, you get a reference error
I was wrong, it was a talk not a blog post. [Here's the link](https://www.youtube.com/watch?v=g01dGsKbXOk).
Yeah I've read that. I asked "what do **you** need that you cant get with CSS".
Eslint would cost nearly 1s to run even for small javascript files and Syntastic would block the UI while perform the syntax check, they both make the edit experience terrible. I hope Syntastic would make use of job-control feature newly added to vim.
Thanks for the feedback, I am interested in knowing different thoughts about it.
Yeah, sometimes perceived performance is what matters!
Sure, and thanks for your concern, however what is your perspective in this article?
Do you have any other ideas for the controls? Also we're trying to make up arrow more effective, but it often leads to tunneling
That statement doesn't make any sense. Anyhow, that script uses ids and classes. It can show/hide any kind and any number of elements.
uh...learn the tool before you rant about it? You use r.js to optimize into one file. The benefit of requirejs is that you can optimize what you want (using r.js optimizer), and then use the same require() calls to pull in whatever you don't (if you have any lazy-load dependencies/stuff). What is even more awesome is if you want to run it in the browser in separate files (makes debugging easier, no need to recompile each time, etc) then you can run the SAME code simply pre-r.js...
I didn't realise this was the case but suspected based on the question that REPL commands were being bound to a context. For anyone interested, this is what code looks like once it's been wrapped: with (typeof __commandLineAPI !== 'undefined' ? __commandLineAPI : { __proto__: null }) { // your code here }
Looking forward to "Best 100 Frameworks".
True for the time being but HTTP2 will change this
I feel stupid now :P Thanks a bunch! ^^ -Olav_
Your question has nothing to do with rolling dice. Your description is unclear. You didn't provide a minimal test case. Use JSFiddle, JSBin, or CodePen. Using document.write is generally a bad idea.
Well, at least it works like that in Chrome/Win10. Maybe different ECMAScript levels are enabled on different doctypes in Safari? This site agrees on the syntax error though: http://www.javascriptlint.com/online_lint.php
You're welcome!
I rewrote some of your code, and tried to use more "best practices" for programming in JavaScript with the DOM (included some comments). Just to give you some hints for later code you'll write :) http://pastebin.com/EqhyTBw9
https://en.m.wikipedia.org/wiki/Man-in-the-middle_attack Simple example. Suppose you built a website that interacts with your bank website. Your bank offers an api, but they don't support CORS or jsonp. The javascript in your website can't access the bank api because of the browser security model, i.e. no cross domain XHR. So you use a service like this to relay your api requests to the bank api. That requires you to authenticate to the bank. This could be via oauth or a session cookie after you've authenticated. Either way, the credentials have to be passed in every request through the proxy. Now whoever runs the proxy has access to your bank account. They can simply use your credentials to do whatever they want. 
Oh strange, their app doesn't work without www. I added it in the link submission thinking it'd just work.Thanks . Deleting. https://npmcdn.com/
Try [eslint_d](https://github.com/mantoni/eslint_d.js), does caching with a server in the background and works much faster. It's supported by both syntastic and neomake if I remember right. Edit: sry, saw after posting that someone suggested it already.
This is beautiful! Thanks for the contribution. 
try this: book = new Book (a[0], a[1], a[2], a[3]) Assuming `a` is your array. You are using four assignment operators separated by commas, taking one of them: name = Array[0] This has the effect of setting the variable `name` to `Array[0]` -- the result of this is used as the first parameter of the function. Same goes for the other 3. `Array[0]` is the same as saying `Array.0` which is undefined - the array constructor doesn't have a 0 property. Same goes for the other properties -- in the end, all your book instance properties wind up as `undefined` *edit* Also, here's a more complete example: var a = [] a.push(prompt('enter the name')) a.push(prompt('enter author name')) a.push(prompt('enter the year')) a.push(prompt('enter the price')) var book = new Book (a[0], a[1], a[2], a[3]) You could very well put this in a loop or some such.
From my experience the combination of yajs and vim-jsx messes with indentation, if I remeber right, by deleting the indent file from vim-jsx you'll make it work, but you still need panglos js plugin for correct indentation. Panglos+vim-jsx works fine for me tho with all es201[5,6] constructs, without yajs, and I find yajs syntax highlighting too colorfull, slow and inconsistent anyway. 
I'm sure its also the No. 1 most hated too ;_;
You can just enter `debugger` too
I was using Brackets, but I guess I might switch now ^^ 
Thanks so much, your advice really helped me out.
Nice! I'll be using this. This is what Readme.io could have been if they embraced native docstrings.
Thank you! That's very nice to hear... that's just the start...
Nice, didn't even read them... just searched for the most popular books on Amazon and used his referral link. We know how to search Amazon.
Is the image a raster image or vector image? Depending on which you could use a different approach that is best for each case.
I've done very similar animations with CSS many times and never had a problem with framerate, as long as the images are preloaded. It's good to use nth-child with animation-delays. But yeah if you are using pixi then CSS won't help.
Has to be https://babeljs.io and http://eslint.org for me.
I appreciate the idea to keep components reusable, but this negates a lot of the benefits of Redux. All your actions no longer go through the same reducer, which makes debugging more difficult. Is the action in the local reducers or the global reducers? Which local reducers? The parent's or some higher up the tree parent? A component that uses `setState` already is reusable. Unless you later want to change that state to global state somewhere else. I have never had that happen.
If you are working with dates, momentjs is quite handy
This is misleading. The browser is the most common runtime environment. Javascript is the only option that's not merely transpiled to something else. Almost like saying "Java is the No 1 most used programming language in environments that favour the JVM"....
It's likely to do with the '/' for scoped packages, will fix it soon, thanks!
Slow compiler? With watch functionality enabled, it's nearly instant. Sub second is not slow. I haven't needed to create or use type definitions either. IntelliJ seems to pick up on things just fine. I don't feel this article is as informed as it should be.
Going to be honest, my recent discovery of lodash is the exact reason I made this thread. I tend to consider myself pretty knowledgeable when it comes to JavaScript, yet to have something that good slip under my radar had me feeling that: 1. Maybe there's other great libraries I was missing out on, and 2. Maybe there were other devs like me that could benefit from an up to date thread of "how do you still program without this" tools.
This is important, back in the day I had to use a piece of shit library called DateJS that Google suspected of having malware on their website at one point. I'm so glad moment came along and made working with the crappy JS Date system easy.
I guess the author meant slow as in slow compared to other transpilers. There was an article the other day that compared compile times and TypeScript was among the slowest. Personally I don't care as it is not getting in my way and I would never give up type annotations once you are used to it only so that it compiles a little faster.
Babel--or I suppose more accurately ES6--is awesome. I've been using it so much that when I recently found myself on a project without it, I found myself time and time again thinking "if only I had &lt;insert ES6 feature here&gt; this code could be way cleaner." *(For the curious, the reason I couldn't use Babel on that project was because of office politics, not because of a limitation of Babel itself.)*
I'm actually wondering whether this would work since OP remarked that using a GIF didn't work
What part of this is "misinformation"?
Try `tsc -w`. You don't need to learn any extra tools to get watch functionality. The built in one isn't the best watcher, but it beats compiling the whole app every time.
Why the help tag?
Why the help tag?
Put the canvas draw function in a setTimeout. Set a variable ("processing") to true before calling setTimeout, then within the setTimeout set the variable back to false. At some interval you'll have to check the processing variable, typically Angular and other MVC frameworks have an event loop, but if you don't use a framework then you'll have to manually perform some action. var processing = false; function toggleProcessingLayer(){ //let's assume JQuery's in use for brevity if(processing){ $(otherCanvas).show(); }else{ $(otherCanvas).hide(); } } function upload(){ //do other stuff //get JSON processing = true; toggleProcessingLayer(); setTimeout(function(){ canvas.drawSomething(); // or whatever the function's called processing = false; toggleProcessingLayer(); }, 0); This is a simplistic and inelegant example that I hope you could forgive. They main key is to use the setTimeout to offload the blocking function and give the browser control until it's ready. http://stackoverflow.com/questions/5113840/using-settimeout-to-improve-responsiveness
&gt; The awkward require syntax I don't know if you are aware but you can just place a `require("module")` anywhere and the loader will automatically figure out that it's a dependency and pre-load it.
Draw as much as you can in 50 or 100 ms. If you aren't done yet, schedule a task via setTimeout which continues where you left off, and so on. In order for something visible to happen, you have to periodically return the control to the UI thread. Nothing will change on screen for as long as you're blocking. **Edit:** Here is a simple demo I wrote a few days ago, which does one long-ish calculation per step: https://jsfiddle.net/e0x7wu4a/
It's a canvas image. Technically, it gets displayed as a raster image in the browser, but it's generated dynamically in javascript using canvas methods. That's really the only way to generate it.
https://gist.github.com/SeanJM/03fe217e0c4d08ef9e17 This is a function which takes 3 arguments, the first is a destination object, the second is an object which is a named list of functions, the third is a series of arguments which is a partial application to the destined function. I use this a lot to create modular components for web applications. The JSFiddle does a better job showing what it does.
That is exactly what I'm doing. I have tried is using both a canvas animation as the loader and using a div with a GIF in it as the loader. In both cases, the results are as I mentioned above. I have not tried cssload, so I'll give that a shot and report back.
I just took a look at cssload.net, and while I won't use anything there directly, my loading animation is simple enough that I should be able to implement it using CSS3 animation. Seeing as how cssload.net has a bunch of these animations all running at the same time, I'd guess they are probably non-blocking. I'll let you know how it turns out.
I have tried using setTimeout and flag vars, and the net result is the same as above, but with an additional delay at the start. It's funny though, my vars and function names are remarkably similar to yours.
Get your own at [trumphat.github.io/](http://trumphat.github.io/) This was a fun project that I was able to put together pretty quickly thanks to the open source project [Meme.js](https://github.com/BuddyMeme/Meme.js). I worked on the idea with some friends of mine. They setup the twitter account [@TrumpThisHat](https://twitter.com/TrumpThisHat) to post the best they find. Sorry its not perfect, only so much time for these projects. [X-POST] /r/javascript/ /r/memes
Absolutely this.
The main thing I'd do is factor out that function expression to something outside the loop, then just call that function in the loop; as it stands, you're making a new function object on each iteration. Also, I'd filter out inherited methods on `source`. In this fork, I even used somewhat cumbersome boilerplate to ensure the `arguments` object isn't passed into a function, because that can deoptimize engines: https://gist.github.com/lewisje/041f4d25d12c8a135a8b
I wrote a chrome extension that turns all mentions of Donald Trump into Donald Trumpet-arse... make headlines hilarious https://chrome.google.com/webstore/detail/donald-trumpet-arse/emcfepikondfnlfidohlgcpigdiefino 
Try what the kewl kidz use: `requestAnimationFrame` or `setImmediate`.
Hey, you get me wrong. I want to learn, but i lose my focus and interest very quick, don't know why &gt;_&lt;. And well i can change, everyone can change, but i need some help and that's what i'm asking for.
Thanks bro! sending you a PM right now!
"classaY", "enLe", "mE"... yea, naming things is hard. I have no idea what you're trying to do. Anyhow, as /u/Rhomboid said, the classes aren't in any particular order. Use a data attribute if you want to attach some data to some element.
Sit. Take notes. Chat with people if you're so inclined. Ask questions. 
The innermost function expression does indeed need to be created on the fly, but the function that *makes* this expression does not; the way your code currently works, it makes several copies of the same function that are each called once to return another function, but instead you can define this function-builder just once and then call it inside the loop. I mean the garbage collector will deal with it in the end, but it helps performance to give it less garbage to deal with it. **EDIT:** On re-reading, I think you came to the same conclusion I did, but I still like how I explained it.
you have to parse the json first: `var mydata = JSON.parse(JsonFromServer)` we need all Float values for the chart... a helper fn to convert time to unix timestamps via `getTime`, and well use it to sort too function parse(dateAsString) { return (new Date(dateAsString.replace(/-/g, '/'))).getTime() } the datas not sorted so well sort it var sortfn = function(a,b){ return parse(a.time) - parse(b.time) } mydata = mydata.sort(sortfn) assuming thats done using `mydata`: var output = []; for (var i = 0; i&lt;mydata.length;i++){ var item = mydata[i]; output.push([ parseFloat(parse(item.time)), parseFloat(item.temperature), parseFloat(item.humidity), parseFloat(item.battery) ]); } data.addRows(output); https://jsfiddle.net/q954yyy3/
Don't forget [PopMotion](https://popmotion.io/)!
&gt; If the order of dependencies in a require or define call is significant, something is wrong. That's not to say it doesn't happen in the real world (generally when mixing AMD and non-AMD modules), but it's not technically an issue with AMD. I can agree to a point it's a developer's fault, but then again it's a fault developers won't make with CommonJS, so yeah, it is really only an issue with AMD. And it's indeed very common in the real world, as any module that attaches itself to another rather than exposing their own exports (jQuery plugins anyone?) can fall victim to this. Take this example in CommonJS: require('jquery.plugin'); require('module-a'); In this case it is guaranteed `jquery.plugin` is loaded when `module-a` is evaluated, which is actually a very desirable property because it allows you to guarantee all jQuery plugins (and other modules that attach themselves in a similar fashion) are loaded before anything else. The equivalent AMD syntax (`define(['jquery.plugin', 'module-a'], function(jqPlugin, moduleA) { ... })`) doesn't have this advantage. Now you can argue this shouldn't be a problem because `module-a` *should* require `jquery.plugin` itself, but this is easy to forget, won't be enforced by your linter and it will probably still work in development even if you do forget it. CommonJS allows you to easily sidestep the problem in its entirety, AMD doesn't.
Basically you would split the string and move the single items into a data structure called an [AST (abstract syntax tree)](https://en.wikipedia.org/wiki/Abstract_syntax_tree). I think you can find a lot of examples for the details of this process on the web.
I plan on fixing scoped package search today and hopefully add the history push state this evening, I'll update the thread and let you guys know when I do, thanks :)
Use a regular expression to chop it into pieces: &gt; "-1+2*3+(5/2.5)+69".match(/[0-9\.]+|[+\-*\/\(\)]/g) ["-", "1", "+", "2", "*", "3", "+", "(", "5", "/", "2.5", ")", "+", "69"] Then build a tree from these tokens. Check this talk. It should give you an idea how to model this tree: "The Clean Code Talks -- Inheritance, Polymorphism, &amp; Testing" (Misko Hevery) https://youtu.be/4F72VULWFvc?t=7m38s
Or you can cheat and use Function :) new Function('return -1+2*3+(5/2,5)+6')() I'm kidding of course. I'm no help.
&gt; Can software die? That is rather filosofical debate and I think you just want some advice. If everybody stops using it then yes, obviously tons of code outthere deployed with requirejs , but I always hated it. It's just stupid. IMHO all the code should be loaded upfront and synchronously (at worse using defer). There was never a good reason to use requirejs, it was a solution looking for a problem. HTML has script tags, the JS world tends to find complicated solutions that would terrify even the most hardcore C++ developer. Instead of taking advantage of JS simplicity we are now ending up with an ecosystem of monstruous tools, build tools, packaging tools, insane pipelines that accomplish very little since we are now spending most of our time managing these pipelines and swapping one pipeline for another instead of writing code. INSANE. In my whole developer career I have never seen that. And yes, I work with autotools, make,Cmake and co 10 hours a day.
Do you think it looks legit, or there are some issues with it?
Like rodneon said, take the habit to use .length instead of using values, so that if you need to test your code or even deploy it to production it is prepared to any case and you don't have to change it each time
I write [Popmotion](https://popmotion.io/), its an animation/physics/input library for 12kb which I recommend *not* to use just yet. Currently it's a pay-for and I'll be releasing a complete API overhaul under MIT some time in March but it'd be cool if you checked it out then (I'll post here about it). It also has discrete rendering steps, so you could write a process for PIXI that fire at the `postRender` step (for instance), to add post-processing effects after everything has finished rendering. I just wanted to comment on the benchmarks - Greensock is undoubtedly the best-performing framework out there. I'd actually be surprised if it was ever bested as it's always been written performance-first all the way back to the Flash days. You do pay for it with the upfront file size, though, and the other thing is these benchmarks are animating hundreds or thousands of objects. I've personally never encountered that situation in day-to-day life. You'll probably be good with any of the compared frameworks. 
 var elements = document.querySelectorAll("h1, h2, span, etc"); function onMouseOver(event) { ... } for( var i = 0 ; i &lt; elements.length ; i++ ) { elements[i].addEventListener("mouseover", onMouseOver); }
Not saying I don't appreciate these kind of resources but most developers shy away from this if they don't include unit tests. 
&gt; var elements = document.selectQueryAll("h1, h2, span, etc"); querySelectorAll(...) ?
https://en.wikipedia.org/wiki/Shunting-yard_algorithm
Many movies fall into more than one genre though. For example, there are a bunch of sci-fi horror films like Event Horizon or Alien. Genres are like tags. Each entry can have several of those.
&gt; can it create a single namespace in which all the functionality is exposed https://webpack.github.io/docs/configuration.html#output-library &gt; when i use the babel loader, will all the polyfills be part of the lib - and what happens if the customer is also using Babel, will they double? Polyfills are not bundled by default, you have to add 'babel-polyfill' to your 'entry'. And if you are they will be doubled. You can also not bundle polyfills and rely on external package with polyfills. &gt; is webpack even the right tool for this or should i rely on Babel/Gulp for Es6-importing alone, while on the outside the lib is used as always It seems so. You can even just require external lib (you have to manually add it to page) - https://webpack.github.io/docs/library-and-externals.html
- Yes, Webpack (or browserify) are nice tools for this. They can both produce "standalone" (UMD) bundles that should work in the browser with a single `&lt;script&gt;` tag, and also support Node's CommonJS require syntax. - Babel loader doesn't include any polyfills by default, you need to import the `babel-polyfill` module. Generally you should not do this in a library, to avoid duplication, but instead tell your customers *they* need to import the babel polyfill. This is annoying, and one reason some people choose not to rely on ES2015 polyfills for building libraries. - Sure, webpack or browserify could be used for this. Another approach is just to distribute CommonJS and force the build step on the end user. Tools like Browserify-CDN make this pretty easy. See [here](https://github.com/Jam3/audiobuffer-to-wav/pull/1#issuecomment-166328164). e.g. With browserify, your whole gulp/build step could be replaced by something like this in a `package.json` file. I'm sure webpack is similar, but I'm not as familiar with it. "scripts": { "start": "budo test/index.js:bundle.js --live -- -t [ babelify --presets es2015 ]", "build": "browserify index.js -t [ babelify --presets es2015 ] -s NAMESPACE | uglifyjs -cm &gt; bundle.js" } Then: # make sure you've installed the dependencies npm install budo browserify uglify-js babelify babel-preset-es2015 --save-dev # to test / develop your library npm run start # to build the standalone UMD bundle npm run build Some more reading: [npm / module basics](https://github.com/Jam3/jam3-lesson-module-basics)
Works for me, only Safari is supported atm, though.
Personally, I find webpack a bit complicated for this use case. Using babel and browserify would be simpler to configure, but if you're already using webpack and/or will be using webpack in other projects, it's not that big of a deal. At work we went from concat-ing files in order (blearaghd!) to using grunt/browserify/babel and it works quite well for us. I use webpack at home.
What are your end goals for this? Are you planning on adding filters or sequencer or anything? Do you have experience with web design along with programming or is that what you need help with? I'd like to help with this if I can but would like to know what specifically you're looking for. Of the online synthesizers I've seen/used this seems to run really well (in my Chrome) so I'm excited about it.
&gt; querySelectorAll Yadada - You say Tomato, I say Potato, same same, we're all friends here!
Well, it's young, so lib is very junky right now. Plus Safari is what, 3 to 10% on mobiles+desktop? So yeah, no point except playing around with.
Logical operators like AND and OR are simple 
Thanks dude, feedback is welcome :D
Much appreciated. :) Also, feel free to steal code and ideas from what I have done for your project if you get back to it, of course.
I've found the issue and already working on it. If not for you, I wouldn't even notice it. Thank you!
Is thay code somewhere online? I would love to see how other people work with elasticsearch 
&gt; document.querySelectorAll('body *:not(:empty)'); Does that really work? I tried it out and it seemed to return some nodes that didn't contain any text at all.
I didn't really test to be honest, looks like it's matching nodes that have a child node or text content
Yea I realize that, but this is only for learning RxJs and building somethings simple and quick I have no intention of using it. But just my learning style usually involves making something to learn the syntax and see what breaks , and what works. But you're right Aliens is Scifi, horror, action, and thriller movie, so one class wouldn't work, I would probably have a data attribute with all of the genres and then keep a mapping in memory of ge current set and which elements fall under what 
Any good example of another site doing it right?
If you want a global namespace, you can use a file with this as your entry point in webpack: import mod from './your-module'; window.NAMESPACE = mod;
Thanks. I'll definitely look at what you've done. Regarding ES2015, I was thinking about trying to make that conversion, and I imagine it shouldn't be hard to add that to my tool chain â€” so switching to that might happen sooner than later. Regarding "there's not a lot there yet", I wanted to get the quality of the initial implementation up to a decent level before adding too many features so there is a solid base to build on. Also, it seems generally advised to ask for collaborators early in the development of an OSS project.
I like Reason. I'd just like to know, why are you doing this? Will there be a day when people are producing music professionally in a web browser?
Dude. This is like front-end 101. Make your site readable. That red and that #3d1e37 on top as the main text color is atrocious and hardly readable.
&gt; Disclaimer: I have never read any of these books In other words, I'm writing about stuff I don't know about.
No, but many of these: https://en.wikipedia.org/wiki/Whitespace_character
That makes sense -- I just think that you may find yourself wanting to make changes to the way you're setting up and managing your synth voices as you add more modules. Of course "plan ahead" is easier said than done, but if you know you're going to be adding envelope(s), filter(s), LFO(s), PWM, and whatever else -- because the requirements of an analog synthesizer are well-defined, after all -- it'll save time to think about how that architecture will work from the start, and maybe stub some things out.
[EDIT] Oops. That question wasn't for me. Leaving my "answer" here anyway. I don't have one major reason. Some reasons areâ€¦ * I wanted a project on which to learn how to use the WebAudio API that I could see results on fairly quickly. * I wanted to try building a single-page application using a somewhat conventional tool chain. I've been mainly a Ruby developer and have not used any toolchain for my previous browser-based coding projects. * Whether it's ever very useful or not for serious work, it's a fun toy. * If nothing else, it's a great way to just play a note for tuning when all you have at hand is a computer with Internet access.
I've been meaning to learn the WebAudio API for a while. I will have a read through your code. I think it would be great to be able to use web-based audio software for serious work. From the user's perspective, cross-platform, and no need to worry about upgrades. From the developer's perspective, no need to worry about piracy. An online authentication mechanism could be implemented.
A better way of doing it might be to change the placeholder text from "express" to "e.g. express", making it clear that you need to enter your own value.
technically correct. The best kind of correct
Advice acknowledged. Digesting. :)
Respect the work of designers who build unpleasant designs?
I looked into these and setImmediate seems to only be implemented in Internet Explorer and Node.js, neither of which is relevant in this case. I tried using requestAnimationFrame, once per loop iteration in my main drawing function. All it did was extend the length of time it took to run from 3 or 4 seconds to well over 2 mins. Didn't update the animation at all.
Any luck with this approach? I [created a little module](https://github.com/Wildhoney/DetectFont) based on the concept, and it seems to work well.
Yup. A lot of the things that WebAudio ostensibly does are not usable today in any practical way because they need to happen in real time, but they can only happen on the main thread and must wait arbitrary amounts of time for other events to run. Once AudioWorkers are ready for prime time, things should be much nicer.
I hadn't heard of this occurring outside of migration scenarios, but some looking around shows that even [the meteor site has some documentation on this](https://www.meteor.com/tutorials/react/collections). Looks like the benefit is you get to use react for all of the benefits that entails, and meteor for the data store. 
 body { background-color: #449A72; } Ahhhh..
So I guess the question is, what makes React better than Blaze? I also heard Meteor is bad for SEO. Does React fix that issue?
Chrome on win10.
agreed w/ u/dmitri14_gmail_com - that red is harsh and makes the site very hard to deal with. 
React is really powerful when it comes into front-end developing. For or against Meteor it really depends on what you want to do. You can use Meteor's Blaze template engine or you can also use Angular instead of Blaze which is also officially supported. There has been many discussions on React vs. Angular, but this is really personal taste. Like React states itself, it's the View in MVC and it's more a library than a framework like Angular. At first I'd really suggest you to have a look at React itself, since you aren't that familiar with JavaScript yet and Meteor itself has a huge API. I can provide you some links for React beginner posts and tutorials. After you've played around with React, you can dive into Meteor, but there are also many other ways to build your application and assemble your own stack with React. There are already many resources about that topic (i.e. Flux, Express/Koa, etc.).
Interesting. I didn't notice that happening in Chrome on OS X. The cause of the problem might actually be something that might happen in any browser though, and I've just only noticed it in FF on OS X. I take it I can add Chrome on Windows 10 as a known working browser though, eh?
Another thing that I could use some help on with thisâ€¦ Automated testing. I've used Jasmine to test js code in the past, and there are pure-code parts of this that I should be able to bring under unit testing in a reasonable way. There is a lot about it that seems really hard to test in an automated manner though.
**another** js framework??? /s
Are you using Firefox? Last I checked there was an FF bug that broke the envelopes, and one of the devs told me they were working on it. That was a long time ago though. Looks like the UI doesn't quite render correctly in FF either. It works properly in Chrome. (Note that the switch has to be set to `ENV` rather than `GATE` in the `VCA` section to enable the envelope, as on the real 106).
Actually, I was just able to reproduce the problem in Chrome. It's not consistent though. It also seems to happen sometimes in the middle of playing a single note, so that seems to rule out the envelope thing. Maybe it's a WebAudio implementation bug? I'll definitely try to figure out what's going on with this.
Yeah. But it's the only serious language on that platform. So saying it's No 1 is disingenuous, given the lack of choice on that platform. (Not to be disparaging of TypeScript, which I think is excellent.)
Ah cheers, looking good!
Yeah, good call. I tried addressing that at some point by killing all notes when the window lost focus, but I didn't get that approach working correctly so I abandoned it. I like your method.
don't know what you mean by good, but there seems to be a few: http://jedwatson.github.io/react-md-editor/
This is exactly what I need, but I don't use React :/ Can anyone recommend something similar but without such dependency (jQuery is ok since I use it anyway). Basically, I don't need the full editor like TinyMCE but only a few controls in form of an API so that I can build custom controls for it. Thanks
Is there a reason you don't want to introduce React into your ecosystem? Even if you use jQuery for everything else, for a fully-featured rich text editor I'm not sure you'll be be gaining much by using jQuery instead of React.
Well I'm not using React anywhere else so if I can avoid additional dependency in my codebase, I would prefer that. I am using Backbone on the frontend and I am satisfied with how my views are handled. I will need to provide exactly 4 controls in my text editor: heading, bold, italic and hyperlink. Due to the simplicity, it would be amazing if I could find some API that lets me build controls but handles the text modifying.
So much wrong with this comment. Thinking visitors come to admire the work of designers is completely backwards. Designers work to solicit visitors. If the website's designer is pissing people off, then he's doing his job poorly. And how are you even suggesting we "just change it in the browser"? Every method of doing so is far too much work for a page only visited once or a handful of times. Saying nothing, as you suggest, would be more cruel than writing these comments. He can't improve without feedback.
Maybe check out [Quill.js](http://quilljs.com/)? I have not used it, but seems to be similar to what you're looking for.
I'm sorry if my sarcasm didn't make it through the OP.
I like it
Draft.js is going to work outside of the React ecosystem soon enough, as the library's core is not coupled to React. &gt; The entire Draft model is also separate code decoupled from the UI and you're free to use the model and implement the views yourself if you're allergic to React or aren't targeting the DOM. The Facebook Groups app uses Draft's model but implements custom views for it in React Native. Source: https://news.ycombinator.com/item?id=11153935 
Great recommendation, thanks, will definitely take a look.
Awesome, thanks, will check it out!
Thanks, very useful to know!
My friend wrote this library. I don't use React a lot, so I'd be curious about what you guys (and girls) think.
Ooh, this'll be great for me as I'm building something that'll have a lot of descriptions and stuff. I'd need a good editor.
I know that Windows Phone 8's browser isn't great, but the text editor didn't render at all.
Yep. That's the whole point: if you're early on, you have to just pick a tool and avoid the decision paralysis. Decision fear exists for every ecosystem, no, every aspect of life. It's about learning patterns and discipline anyway, not particular tools. If you're seasoned (if I count my middle school javascript and AOL job, I've been doing this for 20 years) you've seen many tools and technologies come and go. What really stays is the ability to read other people's code, separate your concerns (patterns) and traverse documentation and research articles quickly and turning that into usable and actionable information. 
Medium-Editor is my go to.https://github.com/yabwe/medium-editor
I really need to update that section of the site. :P The real reasons I only support the GET verb in the proxy are 1) I like keeping the codebase simple and I'm lazy, and 2) if somehow someone *does* do something super sketchy with the proxy, I don't want to be held responsible for it.
Follow a style guide. [Google's](https://google.github.io/styleguide/javascriptguide.xml) and [AirBnB's](https://github.com/airbnb/javascript) are popular. Use a tool like [eslint](http://eslint.org/). 
With [parse-messy-time](https://www.npmjs.com/package/parse-messy-time): var parse = require('parse-messy-time') console.log(Date.now() - parse('last sunday').getTime()) 
Something like this: https://jsbin.com/zutuvajusu/1/edit?js,console Previous Sunday would be day(-7) instead.
Personally I love Jade because it's so clean, you just pass an object of variables and do what you want with it. Plus the separation of concerns etc. My big issue with React is you're throwing a lot of html into the javascript code where in my opinion it shouldn't be. Things can get messy very quickly. But I'm saying that as someone who has just cursively looked at the React API. I'm just intrigued as to the huge support from the community for React and why so many people are really pushing it as the next big thing.
I used Jade for a couple of years and I loved it. In fact it was the way I wrote my Meteor Blaze / Angular templates. I'm pretty minimalist in my writing style so it was a perfect fit. &gt; throwing a lot of html into the javascript code where in my opinion it shouldn't be This is the old idea that React's popularity has proven to defeat for a variety of reasons. As Facebook says, splitting markup into html and behaviour into JS is a separation of technologies, not concerns. We gain nothing by extracting html represented in our component code and chucking it into a separate file, changing the extension to html or jade. On the other hand we gain a great deal of power and organization by describing component markup along with the behaviour it relies on together in one JavaScript file. I was never sceptical about this idea so I can't relate to your feelings, but I definitely have met enough people to sympathize. I think people that don't use React think your program becomes one crazy JavaScript file that messes everything up, when in reality everything is neatly organized in many modules. It's super normal to have modules that only contain markup, so it borders the line of a jade template but with the full power of JavaScript. That being said, I've grown to like hyperscript more than jsx--it's more "jadey"; no closing tags and it can be used in React instead of jsx if preferred. 
Use http://jscs.info/
But just how fast is *blazing* fast? Slower than *LIGHTNING FAST*? 
I'm not familiar with the type of architecture you're trying to build... I think it may be worthwhile to go into more detail--maybe some pseudocode of what you're imagining. You could use the RxJS library to wrap whatever is providing values in your runner with an Observable and return that to the caller, who can then subscribe to it. https://github.com/Reactive-Extensions/RxJS
Yep: this isn't even just for the good of other people. If you stick to a style (ANY style, though hopefully also a good, sensible one), it's even helpful for YOU when you come back to read your own code later. Instead of things being styled in whichever way you felt like writing things that day, it'll be consistent. Consistency = easier and faster to read and relearn what you were trying to do when you come back to it.
Style guides are good of course, but readable code often comes down to proper variable / function naming, keeping things DRY (don't repeat yourself) and writing concise, focused modules. The best way is to practice and read others' code!
Really cool! Been loving learning about and playing with Lenses lately. Why does your compose function reference the lenses? Won't a regular variadic compose compose Lenses without any extra code specific to lenses?
RetroBASIC emulates a running basic PROGRAM, not a BASIC interpreter.
thanks
Thanks! That sounds interesting! Could you give me an example of what you mean? I don't see an obvious way to generalize it (or composition in general) to all functions, instead of just lenses, especially since the range of these lenses is completely different when given two arguments vs one.
Why use a mixin? Just import the styles and use them directly: import styles from './wherever'; // wrapper styles accessible via: styles.wrapper If you're serious about using inline styles you're going to need a library like [Radium](https://github.com/FormidableLabs/radium), which adds media queries and pseudo-class support, as well as some other niceties. It is currently the most popular library for inline styles, and the closest to achieving feature parity with CSS. FYI the README has a typo. This: let wrapper: { backgroundColor: '#666', padding: 30 } isn't syntactically valid JavaScript.
momentjs: moment().day(-7); // last Sunday (0 - 7) You may need to set the time to 12:00 am. 
It's definitely an operation generalizable to all functions: one of the coolest thing about Lenses *is* precisely that they compose in the very strict sense (like any pure, unary functions) ... and in the same way that everything from isos to Prisms to Profunctors in general compose (in fact, they're all fundamentally related, though I've not dug too deep in figuring out exactly how). A standard workhorse compose should suffice for any of these: const compose = (fn, ...rest) =&gt; rest.length === 0 ? fn : (...args) =&gt; fn(compose(...rest)(...args)); I wrote an article working through my understanding of lenses for more discussion on how (I think) they work: https://medium.com/@dtipson/functional-lenses-d1aba9e52254 But then check out these implementations for more (and some great discussion in the open/closed issues for the latter): https://github.com/DrBoolean/lenses https://github.com/ramda/ramda-lens
Ah, I see, I think my lenses, as I've implemented them, are a bit less pure-of-abstraction than those examples, that they're implemented as functions in bifocal is mostly a convenience to access the getting and setting operations. In particular, that `compose` doesn't work on them because each lens being composed needs to have the possibility of being applied with either one or two arguments, where that implementation only ever applies with one, except for the last function in the chain.
Just used the w2ui grid on a recent project and was very pleased with the large set of features available and solid documentation. The only thing that I wished it had was a way to do traditional pagination instead of the infinite scrolling, but small issue overall form us.
FWIW this is idiomatic WebAudio -- the API is optimized to be used this way.
&gt; se some I'm using the string to display the information, and i thought it could be easier to make calculations with it. Guess I'll have to rethink my approach :) I added links to my current code, maybe it will clear things up.
Why not use nvm?
If you're creating something that runs in the command line, you can pipe your output to ```process.stdout```. If your writing a package the ID to be ```require```d into another script, export a function that takes a writable stream as an argument and pipe to that. I did some quick Google-fu on learning node streams. You can read about them [here] (https://github.com/substack/stream-handbook/blob/master/readme.markdown#basics).
I really like this repo but I am not sure how to use it on my site. My most basic guess is that I download the whole repository and then re-upload it to my site. Is there a way to do it that would keep everything more up-to-date without someone like me having to update it and go through the coding work? I want to make this simpler to use in case I am not available to help in the future.
Not to take away from this project, but I investigated this about a month ago so I'd like to give some React-specific alternatives: 1. http://zenoamaro.github.io/react-quill/ 2. http://alloyeditor.com/demo/ For what it's worth, I think the Facebook team has probably done a pretty good job here but their documentation is fairly confusing due in part to the fact that every example is of some tool internal to Facebook. It's almost as if this was released on the fly, and we're seeing internal documentation. 
Hello, thanks for your interest in factbook.json. Please post ongoing questions and comments to the [project forum / mailing list](https://groups.google.com/group/openmundi). Cheers.
Wow, that actually looks really cool and powerful, will definitely check it out. Thanks!
https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest Use XMLHttpRequest to get the file, also set oReq.responseType to 'json'. The latter will automatically parse the json data as a native JS object. so the code would then look something like: function reqListener () { var list = this.response; //do something with artist and date console.log(list.artist, list.date) } var oReq = new XMLHttpRequest(); oReq.addEventListener("load", reqListener); oReq.responseType = 'json'; oReq.open("GET", "http://www.example.org/example.txt"); oReq.send();
Write modules and utilities, use a style guide (and jslint), functions should do one thing at a time, hoist your variables. Write code and learn best practices for different things to help write concise code.
if you're using Node.js you don't even need to use a library, you can simply require it. var data = require('list.json');
Check out [ProseMirror](https://prosemirror.net/)
indeed npm install socket.io --save
Read "Code complete" book and some guidelines for your frameworks/technologies.
Based on how Facebook did it for the last events, my best guess is: Yes.
* Don't write "clever" code * avoid having multiple method calls within one statement * If it's language optional, but the majority of the time you need it or not using it can cause side effects, make it mandatory. * choose a style and be consistent, use a linter/static code analysis tool to keep yourself true. * Write meaningful comments, say *why* this next block of code is doing something, the code itself should say *how*. If you refer to the first and second point you shouldn't need to say *what* it is doing.
Android or iOs??
A word of caution to anybody who wants to play this - the game's business model is basically renting out CPU hours to players, and there is no free tier. You get some free CPU time by sharing the game on Twitter, but once you run out that's it. They don't publish this fact prominently, so don't waste your time poking around the tutorial unless you can fork out $7-$9 every month for this. 
Expertise, insight, and a call to action. The type of post that is a cut above the rest.
In fact, this crowdfunding campaign is aimed to change that. You'll be able to run your own world for free.
Ya, i developed this app using Ionic framework. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/webdev] [Screeps, an MMORTS game for JavaScript programmers, is open-sourcing its game engine](https://np.reddit.com/r/webdev/comments/476wgn/screeps_an_mmorts_game_for_javascript_programmers/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Has this improved over the years? Because I remember using this a few years ago and it was very unreliable. Ended up not using it in the end.
Website URL?
Thanks. I understand that it is related to the font used. But isn't there any way to detect if it's supported by the font or not?
Yeah I think I'm going to go with moment, because we use it elsewhere in our code.
I'm fairly certain that the answer to that is no.
I'm OK with wrong lint results sometimes(rarely happens), but I'm not OK with the UI stuck for 1 second every time I save a file.
&gt; document.querySelector("#play").click() &gt; document.querySelector("#stop").click() work like a charm! Thanks so much! Javascript is so awesome! And thanks so much for your fast response, it was very helpful! 
Awesome! Glad you got it going! No problem! Yes, javascript is wonderful! :)
ML Language? No thanks.
I'm working in a CLI context.
Not using [window.prompt](https://developer.mozilla.org/en-US/docs/Web/API/Window/prompt), which is very simple and not often used on the modern web, but you can make your own modal window (or find a library) with whatever buttons you want.
Elm is basically Haskell without some features (like typeclasses).
ML? 
I don't know, but it's not ludicrous.
You can also get something resembling syntax support by [utilizing generators in a monadic way](https://www.reddit.com/r/javascript/comments/458c3l/has_anyone_found_a_good_use_for_es6_generators/czw0bv0?context=3).
ML is a hugely influential functional programming language. It inspired parts of haskell, and has evolved into other languages, like OCaml and F#. You also see bits and pieces of it in languages like Scala and Rust. You can even see how it does type annotations in things like typescript.
First, you're doing a lot of unnecessary work generating your response. You can simply do the following: app.post("/upvote", function(req, res) { inc += parseFloat(req.body.changeBy); res.send(inc); }); You can change res.send(inc) to res.json(inc) if you prefer, but they are essentially the same thing for this example. As for your actual question, have you looked in your browser's developer tools to see what you are getting back from the .post()? If so, what is it? Also, you may want to add a console.log(inc); before your res.send(inc); to see what is logged on the server side. 
http://greensock.com/gsap
It's just an internal tool they shined up for the conf...
What port should it be set to?
http://www.cd4.hctx.net/2014/images/photos/constable/constable_resized.png
You can elect the way of pain it seems. Use https://github.com/node-ffi/node-ffi to call [SetConsoleOutputCP](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686036.aspx) if you really really want that spinner. 
That is up to you, but the numbers after the `:` in your URL should reflect that.
It's not so much that it "leaks" *per se* as that V8 has a hard time optimizing functions that return the `arguments` object or that pass it as an argument into a function call; this kind of micro-optimization definitely harms readability and maintainability, however, so it's less important than the bit about not making identical copies of functions inside loops.
Maybe this is why `requestAnimationFrame` isn't used in [the polyfill for `setImmediate`](https://github.com/lewisje/setImmediate/blob/master/setImmediate.js).
Nice job Way! So I should cross post everything from HN there? jkjk
Maybe not *everything*... a lot of stuff on HN totally fits, though! :)
Is that a some fork of Knockout.JS or what?
How about if you just use a [font icon](http://fontello.com)? 
Why not use [PDFjs](https://mozilla.github.io/pdf.js/)
I'd say nootropics and other cognitive enhancement topics would fit into tech culture, what do you think?
Why would anyone use this? Won't the PDFs be inconsistent because of how browsers render web pages their own way? This seems like a job for the backend. 
Why does this have 22 upvotes?
If I use that will I be able to restrict the input to only the icons?
I think it is an oxymoron, a software Engineer isn't limited to any particular language and chooses the right tools for the particular job/situation, so probably polyglot is implied there. Javascript Engineer sounds buzzwordmashupy, as you probably won't have the engineering perspective without the experience of multiple languages/platforms, just my $0.02.
There is really no true way to restrict input, short of creating an entirely custom input field and translating keypresses to images, mapping those images/keypresses to some other data type, and then storing and transmitting that data type through some other cumbersome state management method. Or, you could just allow the input to be whatever, but force the font to show only icons. Why not describe what you're _actually_ trying to create? You'll tend to get more useful answers when you give more details in the question.
Yeah, that much was fairly clear. What's it for? And why is it so important to you that no other kind of input is captured?
You could use a registry pattern, so you would only have a single global and then fetch the components from the registry as you need them. For example I migrated my web app in progress from using globals to browserify and I already feel much better about my code :)
Here's the basic html/css modal I use in my projects: http://codepen.io/FullR/pen/NxQXyV?editors=1100 
Because I am linking it to an api that designing. It shows video game inputs (like arrow and such) and i don't want random text to be sent. I could do a check for text before I send it to the api, but I wanted to see if there was a better way. I thought of using regex and pngs to build the icons for keyboard. That's why i asked if there was some sort of library I could use.
Aside from potential conflicts, passing values via the global scope can confuse others in how they are initialized or relied upon. There are many common exceptions that people make (e.g. jQuery). This might make sense if you are getting jQuery from a 3rd party CDN and not including it in your build. Relying on global a like this may make writing or setting up automated tests a little bit more work too. 
Perhaps Barney is Java developer and this JavaScript filth is beneath him. It doesn't even really matter if the code even works.... because as we all know the only real work occurs in Java.
Myself as well. Cool concept, if they could get it consistent
Did you read the article? It's basically "how to install node on windows". 0 value whatsoever. 
Read it on Twitter :)
Heavily inspired? Definitely! Fork? Not at all.
Because it's a shitty article with recycled content??
It looks like it's generating a different color based on the kind of token is in the stream, and it cleverly packed the color-codes together so they overlap.
I really liked the push prompt method here in your example. It would also help make validation much easier. Thanks a lot.
I developed all of my node apps on windows and I never had any problems deploying them on Ubuntu... They were all pretty small projects so I am interested in what could be going wrong? 
oh gotcha
Typescript is effectively just a linter. But to be a better linter than whats possible with vanilla JS, those extra extensions to the language are needed. Edit: okokok, hate for calling Typescript a linter I guess. I know its not; they are completely different. But as far as the purpose of writing error-free code goes, the intentions are the same. Failure in attempting to simplify/dumb it down. &gt; What they flying fuck, this isn't user friendly readable in any way If you have an alternate syntax that is able to represent the same thing in a friendlier way (without being excessively verbose), I'd be interested in seeing it. You get used to the syntax the more you see/use it. It becomes easier to mentally parse it then.
Maybe because some of us fellow Europeans work with macs and know that pretty much all the other agencies in our cities do as well.
Yes but if you are already transpiling the code, why not make it better readable (and autocomplete it anyway). Lots of things need to be done manually, which i don't understand if you are going to convert it anyways. Plus like i said, integrating properly in any big IDE seems better than going for a new language
 &gt; We at Microsoft are so excited to announce and bring to your our new open-source editor, Visual Studio *CodeFart*! Beautiful
&gt; A proper IDE can be extended to do just that. Can it? If types can be 100% inferred statically with no annotation this is the first I've heard of it. Do you have any examples of this working in any language? &gt; Seems to me this is more about making another standard and not really about improving the way we already work. You know what, you're right, there is no benefit. Google, Microsoft and thousands of other software shops are just using Typescript for the hell of it.
No, an IDE can't do that. Flow and TypeScript add static type checking. Do you know it's different than linting right?
I use [SweetAlert](http://t4t5.github.io/sweetalert/) and for more options I just build out a logic tree of yes/no or whatever the options are.
One reason is because singletons and global variables make your code less testable. I recommend you to watch this talk https://www.youtube.com/watch?v=XcT4yYu_TTs It touches interesting topics like dependency injection and other goodies.
https://news.ycombinator.com/item?id=11161119
Yay for string literals, you are most welcome.
wut you say?
I was thinking that because a lot of people in the tech field browse forums / use irc it would be cool to have a subreddit for the culture 
I personally thought the points about who backs a framework were well worded and well received. I'm biased of course but felt like sharing anyway.
dig into it, it's awesome
I think any IDE would be capable of finding out what variables, functions and classes are connected to see what types are being used. And sure, i might currently only be thinking a bit basic about it, but that doesn't change the fact that IDEs can do so much more. You don't need to invent a whole new language for it. Also, like i said, i still feel that Typescript isn't really solving anything for me (that i can't already) and that it really requires too much manual work/input. 
put the quotes in an array and grab a random number from 0 to array length.
Just the challenge, I guess. Also there might be a time when you want to put down your thoughts and don't have your DAW in front of you. I would like to have it export midi files and then you could import them into a DAW at a later time.
Interesting take. I can't find much fault with it. One other thing I'd add though is that a *professional* developer stays on the Ron and Roger side of the spectrum almost always and they take it *very* personally when they realize they've slipped even just temporarily to the other side. 
Whatever it is, it doesn't work in Safari. Looks good in Chrome, though.
my grain of salt: Ron has an excellent attitude, it's not possible to discern whether or not Ron is an excellent programmer. This attitude is common throughout almost any discipline you can think of. But that attitude does not guarantee greatness. Not everyone is cut out to be a programmer, musician, painter, sculptor, mechanic, doctor, lawyer, whatever, but they will still have the drive to be better, even if excellence is out of their reach. 
Safari, the new Old IE.
I had that syndrome for so long. Mainly because there was so much to back it up. I got a job as a software engineer by accident. Surrounded by Master's degree holding actual engineers. I Hello World'd in my 20s. What made me realise that I'm actually worth what I'm paid and belong here is that while I might not be as good a programmer as Roger, I work hard to act like him. The programming kind of caught up with the problem solving over the years after that. 
And that's when my brain broke.
Store the quotes in an array. Generate a random number, then round it down to an integer that represents an index of the array you just created. Combine the random index with the array and you get a random quote. var quotes = ['quote1', 'quote2', 'quote3']; var randomIndex = Math.floor(Math.random() * quotes.length); var randomQuote = quotes[randomIndex];
Code exists in github for a year whether it's bad or good. 
Is taking a week off to do the online course full-time instead of the evening not an option? What are you using to learn right now? This would probably the cheapest option. If you would prefer an arrangement where it's a mentored learning process where the mentor is available throughout the week, then you might have luck trying to find a paid mentor that will tailor the week for your learning needs and your skill level. That could get expensive. The challenge with a one-week bootcamp is that it would need to be tailored to your needs for it not to be a waste of your money. I cannot think of a single place that would do that. 
It really depends what industry you are in; I am in "software product development" ( we basically sell a service ), and in that industry, you have frequent chances to revisit code. It is not super often, but depending on how "hot" the code is, this can be every 3 months, to 6, to every year. I refactor a little bit with every new feature I put out, because we always have to re-invest on what we have already promised from a business perspective ( as well as update it and make it fresh ).
It definitely does, it abstracts it away from the XMLHTTP a fair amount, you just still need to be wary of async issues and in this case setting the file content type. JQuery is pretty good at autodetecting as well, but there are always some edge cases where it doesn't.
Yeah I get the grouped hex codes, and regexes, but I'm not understanding the randomly placed array, or how mod 9 matches the matched token.
My mind doesn't work this way at all. Get from A to B, do it cheaply and cleanly. This is a different game.
If you use any substring of `functionifvar}return(-.[&amp;&gt;&lt;;/)+{]',$=_"forinelse%!whileletconst` as a whole word in a named function or variable you'll get broken highlighting. function con() {} - con will be considered highlight worthy var able = False - able will be considered highlight worthy Because of this behavior, 250 characters it's not very impressive. I can write a broken js syntax highlighter in 0 characters. 
I also do this. Plenty of people develop node on windows. It was designed to run in a windows environment. It's silly to assume that you would be shooting yourself in the foot because you develop on windows, and I wouldn't worry about it at all. I've been developing node applications on windows for years now, deploying multiple successful projects to *nix servers along the way. The only real issue is needing to have some version of visual studio installed on my development machines to compile native modules via node_gyp, and even that issue is fairly minor. 
Rendering differences shouldn't impact the PDFs that come out of this library.
Another alternative is to use a print stylesheet (CSS), which some web sites do very well for print versions. Browser vendors aren't great about supporting them consistently, though.
&gt; We talked about how JavaScript can support some of the OOP things (not all) that they love so I expected them to utilize it I wouldn't. JS OOP is kind of shit. The fact that `this` is not fixed/stable and varies depending on calling context makes it FAR too error prone to be worthwhile IMO. Forget a `.bind()` or `.call()` and now you've got weird bugs. What's more is even ES6 syntactic sugar is kind of shitty, and still doesn't support private scoping. Given inheritance is not needed *most* of the time, the most elegant way to use JS is functional composition. Factory functions are brilliant substitutes for classic objects. Built in private scoping, super slim, elegant syntax, no accidental misuse of `this`... So while you're correct that their procedural slop was silly, I can't exactly say I blame them for avoiding the OOP side of JS. OOP is an absolutely fantastic paradigm - don't misunderstand me, but OOP *in JS* is not great.
How is that a determining factor when assessing the design quality of a language? A lot of great languages use standard math notations for non-math related tasks. And I'm not saying that Javascript is a well designed language, because we all know it isn't.
&gt;And I'm not saying that Javascript is a well designed language, because we all know it isn't. I've been coding around 35 years, and have used dozens of languages, and I can say you are entitled to your opinion, but I think you are wrong.
Putting the quotes in an array and then accessing them via their index in the array is probably the best way to do it. And it looks like people here have explained how to do that. I'll offer a less than ideal way to go about it, but one that uses an object directly: //object using numbers as keys var quotes = { 0:"Alright, alright, alright.", 1:"Surprise, muthatrucka!", 2:"Don't feed them after midnight.", }; //defines the "length"/how many quotes are in the object quotesLength = 0; for (var x in quotes) { quotesLength++; } //use Math.floor() to do rounding and Math.random() for randomness var randQuote = quotes[Math.floor(Math.random() * quotesLength)]; console.log(randQuote); //quote is logged to console
Neat. But, seriously, no screen-shots of it's results or something?
Writing javascript on bath salts. - Seemed like a good idea at the time.
&gt; I still feel that Typescript isn't really solving anything for me (that I can't already) That's the WHOLE FRIGGEN point it frees you up to focus on more important things than juggling types in your head. There's no way I could go back to writing js without interfaces and CORRECT code completion. I get the feeling you've never had to refactor a large chunk of business logic in a 50,000 SLOC JavaScript app. 
Nice!
Thanks! Lots of great things to read up on. I haven't yet delved into ES2015, as 90% of my JS is just toggling classes and creating elements. Looks like it's time to get up to speed.
After quite a few years in the JS world (and programming world in general) i've moved to the position that: &gt;imperative and code with rampant mutable state === bad code While: &gt;functional, stateless, side effect free code === good code 
The ability of your code to be understood by fresh eyes is invaluable. That makes you a Great Developer in my book.
I can really recommend a gulp/browserify/watchify toolchain for modules. You can use Babel to transpile es6 (including es6 module syntax) One thing that does not look quite right to me is the 7-1 pattern. This is partition of your projects on a technical view. I find it more pleasing to split my code in domain components. An example: I build an application with a huge spreadsheet. I have the folder datagrid. In there I have header body and footer folders. In he header I have the folder column header for example. In this component folder, I have the Html template, the js logic of this component and the styles 
Have you ever used a static typed language? I am not sure you are understanding what type safety looks like in practice. I'm just pointing out that there is a disconnect in this conversation.
For larger applications, I can see that approach making a lot of sense. I tend to work on a lot of smaller sites with blogs (typically, using a static site generator), so this approach works better **for me**. My folder tree is something like: |- source |- stylesheets |- scripts |- blog |- templates |- partials |- package.json |- build.js where all the files in 'blog' are Markdown w/ YAML.
&gt; Well VS Code is getting surprisingly good at it. The situation is exactly the same though. Type inference requires types. These types are introduced by constants, d.ts files, type annotations &amp; type casts, or doc comments. When you query the DOM for some element with some ID, the analyzer won't know what kind of element it is. You have to be explicit about it. &gt; Typescript (or other typed languages) can seem a bit redundant with both the type annotation and the comments to document it in 2 places. Actually, the type isn't repeated in other languages like Java, AS3, or C#. Java: /** * ... * @param foo description for foo */ AS3: /** * ... * @param foo Description for foo. */ C#: /// &lt;param name="Foo"&gt;Description for Foo.&lt;/param&gt; It's only like that with TypeScript because they didn't come up with a new doc comment syntax. You've to use JSDoc which happens to put the type there since it's supposed to be used with JavaScript. Dart, on the other hand, has its own standardized doc comment syntax and its also shipped with a doc generator. https://www.dartlang.org/effective-dart/documentation/ It's based on Markdown and it doesn't force you to write something about each and every parameter. If the type and the name is enough, you can leave it at that. If you want to refer to a parameter or anything in-scope, you just put it in square brackets. Feels about right for a scripting language. The types, descriptive names, and a one-line description are usually all you need. I wish TS had done something like that, too. Most people probably wouldn't have liked that though. It would be slightly overstepping its bounds, I guess.
What's your stance (and/or the subreddit's stance) on tech culture criticism, like questioning the lack of diversity or the effects of the switch to internet-based public services on the less technology-savvy? 
&gt; It was so functional, it hurt. Are you guys talking about [this kind of functional](https://en.wikipedia.org/wiki/Functional_programming)? Because if my colleague primarily-Java developers would be doing that in Javascript, that'd be great.
Still it does not classify for me as my "wet dream" :S I wish there would be something like Vue.js but developed as both client/server side rendering :)
Absolutely. "Hey boss. I fixed that problem you wanted me to fix today, but I also noticed our codebase could be written more elegantly. Would you like me to spend 2 days on that, or go on to fixing the next thing quickly?"
Unmotivated developer != terrible developer.
/u/dt3ree , is this meant to be just a collection of tools, or is there also a script interpreter and maybe an interactive shell? Are you sure that cash doesn't 'conflict' or compete with shelljs? Shelljs is more active at the moment and they appear to be happy to take on features which mirror the standard unix-style tools. Keep up the good work though. It looks good. 
that was genuinely interesting. Thank you
A one liner in your code that you can comment/uncomment: `for(var key in console) console[key] = function(){};` **Not suitable for multiple files however**
salaried developer in enterprise software, it's nice in terms of security but also i want to shoot JIRA in the fucking head.
I thumbed you dumbed for using 'let' and also for using those obnoxious shorthands which OP will certainly not understand since he's clearly a novice.
I'm not one to bash people trying to teach things to other people but hte [NodeJS "about" example code](https://nodejs.org/en/about/) is more complete than yours, it's actually a very very gentle introduction
nice one!
Microsoft Typescript is for people who need to write a bit of javascript for some reason but who are too full of themselves to actually learn how to do it properly. Microsoft sees those people as an opportunity to continue their embrace extend extinguish strategy and sabotage javascript. You want a language that works with your obsolete thinking? Do you have to use all your VB and C# anti-patterns because you don't know any better? Microsoft has got you covered. Don't worry about the downvotes, it is the Microsoft PR department.
An excellent JS developer has both attitude AND aptitude (and ideally some non-trivial mathematics, particularly in geo|trig &amp; stats) a good js dev has some of both a mediocre js dev has either a terrible js dev has neither
It will return nodes if they contain whitespaces - even if they *only* contain whitespaces.
your autistic
No, using this page as a test platform I looked at the method above to a given `ul` element from the resulting node list and then looked it up in the inspector. I then looked that element up in the raw source. No text child nodes... even those that contain only white space in either the static or dynamic code.
OP doesn't even know what arrays are or doesn't know how to use one, do you seriously think he'll understand what truncation is? Also 'let' is not completely supported in all browsers and shouldn't be used in production. Let's be honest, your original comment was to show off your mad JS skillz and not to actually help OP.
That's awesome! Thanks once more. But I discovered, that if I stop and start it too often, it does not show every title in the title bar. I found the js file behind the player, and I want - jus to play around - refresh the div. I found the line refreshConnection: function() { this.api.DEBUG &amp;&amp; radioplayer.utils.output("html: refreshConnection()"), clearTimeout(this.stallTimeoutId), clearTimeout(this.errorTimeoutId), this.supported &amp;&amp; !this.disconnected &amp;&amp; (this.disconnectStream(), this.connectStream(), this.resume()) , So I defined it as a function, but got an error. How could I execute the function that refreshed the player? Thank you!
There is also https://github.com/webr3/rdf.js
&gt; OP doesn't even know what arrays are They do know what arrays are. https://www.reddit.com/r/javascript/comments/44lntf/filter_on_false_values/ &gt; Also 'let' is not completely supported in all browsers and shouldn't be used in production. I said it's supported by all current browsers. http://kangax.github.io/compat-table/es6/
http://motherfuckingwebsite.com/ (no offense)
lol, comments from webpack's introduction page: &gt; The document is so obscure, I read so many times,but still can not figure out how to use it comprehensively and cleanly. &gt;Thought I was the only one...! I came here from angular 2.It's just a module bundler,it's just a tool,yet it feels like rocket science with this bloated and all-over-the-place documentation &gt; This document needs to be rewritten, it's beyond marketing bullshit it has zero value :) &gt; Its actually a big turnoff - I will stick to grunt/gulp until I need something that gulp cannot do. &gt; Strong contestant for worst introduction ever in the history of library documentation. &gt; I dont understand what it does, how can I quickly use it for most common cases. Simple example or use case would be nice &gt; Now I'm using Grunt for this kind of task.
I agree except for the part about private scoping. Things can be made more private when moved into a child scope.
You can usually get very far with the CLI, npm scripts and/or helper modules like budo. Personally I would hold off on grunt/gulp for as long as possible â€“ but that's just my experience. :)
That indeed. Otherwise it breaks the solid feel I suppose. And maybe make a version that only zooms, and pans with one finger (just like on mobile) because I think that has the most use case scenarios.
I bet bosses trust Barney more than Ron. He gets the job done.
Command prompt in Windows 7 is breaking for me with this approach. Also it's better just to let npm resolve the dependency since it might not always be the path you think it is. 
Thank you.. Trivia: not a single function like sqrt, sin, cos is used, which may be enabling performance and accuracy.
I'll be interested to see if any more proposals eventually make their way into [the process](https://github.com/tc39/ecma262) to help with some functional programming. compare: // es3/5 function literal obj.on('anEvent', function(x) { console.log(x); }); // es3/5 function.bind obj.on('anEvent', console.log.bind(console)); // es6 fat arrow obj.on('anEvent', x =&gt; console.log(x)); // livescript, skinny arrow with implicit argument obj.on('anEvent', -&gt; console.log it) // livescript, partial application obj.on('anEvent', console.log _) // proposed function bind operator strawman obj.on('anEvent', ::console.log); // livescript bind operator obj.on('anEvent', console~log) // dart? obj.on('anEvent', console#log)
There is a few things wrong here. - Single equal symbol is for assignment, not comparison. You probably want == or even === for those if statements. - Prompt inputs always come back as a string, so you probably don't want to compare it to a number before running a parseInt() on it or something. - Why not just use the Date object to do the maths? It'll just allow you to just go all (enteredDate - startOfYear) / lengthOfDay. See [this example](https://jsfiddle.net/jr340L4p/3/). [edit] Changed Math.floor to Math.round to avoid daylight savings issues, see [here](https://jsfiddle.net/jr340L4p/6/).
Agreed. It also does not account for keywords located in strings. `var l = "let for function in var const while if return ...";` Outside of the purposes of pure code golf, I'd consider this code virtually useless. You won't learn anything from it and it's virtually unusable.
jspdf requires a webserver to run https://github.com/MrRio/jsPDF
Amazing OP, I didn't expect it to work so well, plus it's only 610 bytes, that's an awesome work you did there :D