Good to know, sorry for the misinformation I was basing my comment on other comments I read a while ago about the ember benchmark (comments which might not have been accurate at the time anyway). About the desktop performance: http://discuss.emberjs.com/t/why-is-ember-3x-5x-slower-on-android/6577 Isn't it weird that the iPhone 5S (and even the 5) get results close to a i7-4470k? It looks like something unusual is happening to me but I may be completely wrong.
Strange, I usually get better performance on real life projects on Chrome and Firefox than Safari on my macbook pro.
Talk about the event loop and event driven programming, [here is a nice visualization](http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D)
&gt;Dr NoClass *or* How I stopped worrying and learned to love this Select based on audience present.
Hey man I'd be grateful if you did, I haven't had many eyes on this so any feedback is gold. As for callbacks, you can either give an `Actor` an `onComplete` callback (there's an `onStart` callback available too) or personally I chain `then`s: myActor.start(animation) .then(otherAnimation) .then(somePhysics) .then(function () { console.log('myCallback') }) http://popmotion.io/api/actor/then The next release (hopefully in the next couple of days) will allow `onStart` and `onComplete` callbacks on `Tween` `Simulate` and `Tracks` too, but currently they'll overwrite whatever's set on an `Actor`. --- Override animation controls: see http://popmotion.io/api/actor for `stop`, `pause` and `resume`. If you're running multiple actions on the same Actor you can control these individually: var spinControls = myActor.start(spin); var moveControls = myActor.start(move); setInterval(() =&gt; { spinControls.toggle() }, 500); Example: http://codepen.io/popmotion/pen/EVZYwe?editors=001
I'm trying to improve the load time of my website so that's why I'm asking. Is the async property also supported in IE8? 
You're welcome :)
There's a bigger consideration. A57 is slower per clock than the Apple A7. The A7 launched in 2013 while the A57 didn't see products until the middle of this year. ARM announced the ARMv8 instruction set in October 2011. **ALL** good ISAs take 4-5 years to make. The A57 shipped almost 4 years later and the fixed version (A72) still hasn't shipped. Qualcomm is shipping it's custom Kryo core finally, but it's also 4 years after the architecture was available. Even the biggest companies like Intel need 4-5 years to plan, test, and ship a new architecture (tick-tock works because the design periods overlap). How did Apple make a chip in 2 years? The answer is either Apple really is a miracle company or they actually started earlier. Apple purchased PA-Semi in mid-2008 which is a great 5-year mark for a new chip (with a couple spare months to restructure in the new company). How did Apple manage to get their hands on ARMv8 before ARM even had a chance to start on their own designs? My suspicion for the past couple years is that Apple strong-armed ARM (no pun intended) into using the ISA. Apple has dealt with complete ISA shifts in the past and even though their move from POWERpc to x86 was smooth as could be expected, it was still difficult. Rumors pegged MIPS as looking for a buyer starting a few years ago. Apple probably considered the purchase, but didn't want to deal with a complete shift. They design a new, somewhat backward compatible ARM ISA that meets their needs. In the meantime, all the lower-level parts of the chip design can be started. A 18 months or so into the process, they tell ARM to either use the "suggested" ISA or they buy MIPS and move on (note that Apple no longer owns any ARM shares, but they helped found the company in the 90s). ARM isn't about to lose the biggest player in the game, so they accept the ISA and start work (not a bad trade for them anyway as it is a good ISA). Apple bypasses MIPS which then sells to Imagination Technologies, but ARM and a few other companies go in on Bridge Crossing LLC to get patent grants to most of the MIPS portfolio (I don't know if Apple was one of these companies or not). Bridge Crossing LLC later sold the patents to the highest bidders (I don't know who the buyers were or if ARM retained patent licenses after the sale, but I suspect they retained some licenses and bought some patents as well). All of Apple's competitors are now a couple years behind in the processor race and the result is what you mention today.
Thanks for the feedback! I'll look into those and make adjustments. 
That is what it does for old versions of certain browsers, and safari. Scroll down to the bottom to read more about the ctrl+c fallback.
&gt; why frameworks like jQuery are major overkill Are they? I'm not sure I'd even call jQuery a "framework," exactly.
or here https://www.destroyallsoftware.com/talks/wat
This looks like a great tool, and I fully plan to use it in the future, just keep in mind that it's only just been released. It may be worth waiting a little bit before using it in production. Will be very glad to get rid of the Flash dependency though.
https://www.destroyallsoftware.com/talks/wat The Javascript section of Gary Bernhardt's lightning talk.
4,300 stars in 13 days. Dang. I guess we've been wanting this. :)
Explain JavaScript's real inheritance model and utilities (`__proto__`, `Object.create`, `Object.defineProperty`) and then get into the weird Java-friendly hacks like `Function.prototype` and what `new` actually does. In a perfect world you'd only need the former, but you need to know the awful syntax version too to work with other people's code. Spend some time on the modern JS dev environment and the broad categories of tooling (linters, task runners, testing frameworks and runners, package managers, module systems, transpires, etc.)
Remember these rules don't apply to fat arrow functions in ES6, though, which is both great for callbacks requiring no separate context, and ugly for people just picking up the language.
Firefox
*grabs pitchfork* We don't take kindly to your kind around here!
This kind of shit is really annoying on touch.
We needed flash because flash has been able to copy text, in every browser, for ages. Browsers, meanwhile, refused to implement a JavaScript API for it despite constant requests, citing security concerns. Which, if you think about it, is actually insane, because giving people a second way to do the same thing cannot possibly impact security. Or, in IE's case, a third way: IE has had its own beautiful JavaScript API for copying text for ages. Insane, and inconsistent too, as they simultaneously worked on implementing it in the command this library uses, `document.execCommand`. But of course nobody but me will call them out on that, because if anybody says the word "security", well golly gee I'd better stop thinking and leave this to the "experts"! Which experts? Whoever says they're an expert! All I know is it isn't me! ...moving on... Anyway, the default solution for this has been ZeroClipboard, a wrapper around a small flash file with a rather unfortunate API but a big check for the most important feature: it works, and in every browser to boot. It continues to be the only solution that works in every browser.
Well he's technically not wrong. It does do as he described, sometimes...
Thanks!
Thanks for the ELI5 :)
blah, no Talk about why composition is better for some things, and why inheritance is better for other things. then remind everyone that there is rarely ever a single solution. If they are going to a conference, they are good enough to be taught nuance.
Yeah, API reworking and masking over common and completely unrelated things like delegated event listeners. In the end it literally comes down to this: copyText() { let succeeded; try { succeeded = document.execCommand(this.action); } catch (err) { succeeded = false; } this.handleResult(succeeded); } Prior to that all it does is set up a textarea element to make the `execCommand` call work.
I would recommend the second way. Here are some of my thoughts: * Extending the prototype is changing a global, [which is bad](https://www.nczonline.net/blog/2010/03/02/maintainable-javascript-dont-modify-objects-you-down-own/) * It becomes hard to see what code prototype properties are yours and whats not, as opposed to functions like the second way you know exactly what's in your scope * It's easier to test that the function is doing everything correctly the second way: Example: var testDoThing = function() { var fakeImg = {}; doAThing('google.com', fakeImg); if (fakeImg.src !== 'google.com' || fakeImage.width !== 32) { throw new Error('Heads Up!'); } }; 
Looks like copy selection support is new in FF 41 which just was released last week (and I was on a work copy which is updated externally in batch or something)
Nice! Well done, and informative
No, only the good parts.
They can be overkill depending on what you're doing. For SPAs or complex web apps, having a framework (a real one, not jQuery) makes life a lot nicer. But a lot of times you have a regular web app that just needs to make a few AJAX calls and toggle visibility here and there. Vanilla JS works just fine for that use case.
Sure, but the cost of adding jQuery is close to zero and you get more concise code that you can be much more confident works cross-browser than if you tried to do pure vanilla JS. 
Is a bit inaccurate and also doesn't teach anything about JavaScript.
edit: Wow, crazyShit mode (mode 10) ... I can't ... even .... outside of the obvious 'features' of it it combines the effects in random over and over. CrRaAaZzzyYYy!!! I made this a year or so ago and finally created a jsfiddle account recently and just found this around the same time so I just put it up. The code is NOT good at all. I'm sure you all have done things like this where you just keep messing with it and tweaking stuff. Either way, I thought it was interesting how many variations there are for essentially only two or three main effects. Oh yeah, I put in a guide for how wide I had the display window (maybe in case fps drops). There is a little ASCII juggler guy and if you make the window wide enough to see him then that should be good enough. Not sure it matters but it seemed to be a concern of mine at the time. =)
Too bad you can't use it as-is. [Import](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Browser_compatibility), for one, isn't supported.
Similar feature set to promises. Although I very much prefer that promises are stateful, it means I can re-use (memoized) async calls easily and its supported in most major browsers and node js. Also like I said `async/await` is the future and sadly for your library promises took the lead here. Personally I think the ecma spec should have used thunks for performance reasons but promises have the benifit of working cleanly even without generators / async functions and ultimately they aren't terrible in terms of perf.
I've always been told (in my extremely long 4 month career) that people almost always have trouble with objects (what they are, how to use effectively) and the concept of scope.
Didn't expect to read so many haters on this post. A great project. It is significant and deserving of stars and upvotes and likes galore.
the lazy function evaluation pattern for cross-browser code, like figuring out how to write a wrapper over `addEventListener` and `attachEvent` (in case you want to support *old* browsers) without checking which event model is supported *every single time* the wrapper is called
Thanks, TIL. Perhaps the part worth teaching then is how/why Javascript does this silent type conversion?
The only time when it might be okay [to extend a native prototype](http://perfectionkills.com/extending-native-builtins/) is when writing a polyfill, but then you should be careful to ensure the polyfilled method doesn't already exist, and that you use `Object.defineProperty`instead of direct property assignment so you can make the property non-enumerable; even then it can be problematic [to rely on potentially polyfilled native APIs](http://chimera.labs.oreilly.com/books/1234000001655/ch01.html). It's especially bad, however, [to extend DOM prototypes](http://perfectionkills.com/whats-wrong-with-extending-the-dom/) or even DOM instances. It is definitely more professional to use standalone functions, even moreso to bundle up functions like that as methods of a larger module you create; the modern way to do this would be to create an ES6 module and use Browserify or Webpack to turn it into something a browser can run, and a more traditional way would be to create a single global variable with an all-caps underscore-separated name (like `var DOOM_TAY = {};`) and then assign those functions as methods (like `DOOM_TAY.doAThing = function (newURL) {/* ... */};`). A variant of the traditional method for making modules is to create the methods in a closure, which allows your module to have private variables: var DOOM_TAY = (function (window, undefined) { // cache a reference to the window object, and keep // others from messing with the value of undefined var privateVar; function doAThing(newURL) { /* ... */ } // more functions return { doAThing: doAThing, // more public methods }; })(window);
heh
It's almost as if commenters on reddit have no concept of subjective opinions. We don't all find it more readable.
An hour 
http://youmightnotneedjquery.com/ This is what opened my eyes, never used jQuery since
huh?
&gt; Also, I'd bring up and show examples of Node and how you can use JS for more than just web/DOM stuff, including standalone applications and server-side programming. Mention that Javascript is the most popular and one of the most in-demand languages right now. I'll definitely do that! 
It would be nice if the form had an `id` attribute, but if you're sure this is the first form on the page, you can get a reference to that form with `document.forms[0]` (part of the special [forms collection](https://developer.mozilla.org/en-US/docs/Web/API/Document/forms)). Then you can use the [elements collection](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/elements) of the form to get a reference to the input element with name answer, like `document.forms[0].elements['answer'];` Finally, to get the value in that input element, use the `value` property (this value will always be a string, use the unary `+` operator, the `Number()` conversion function, `parseInt()`, or `parseFloat()` to get a numeric value): `document.forms[0].elements['answer'].value;` --- Technically, the user's input is saved as a property of a DOM element, not as a variable by itself, but if you wanted to turn it into a variable, you could try something like this: var answer = parseFloat(document.forms[0].elements['answer'].value); Of course, if you'll be referring to multiple elements in a form, it's a good idea to store a reference to the form and to its elements into variables, because repeated DOM accesses are slow. var answerForm = document.forms[0], answerElements = answerForm.elements; answer = parseFloat(answerElements['answer'].value); The key thing to remember is that *all* input fields will have values that are strings, even if the type attribute says something that sounds more numeric, like a date, a time, or a numeric range.
This free online book by Kyle Simpson really helped me to understand prototypes: https://github.com/getify/You-Dont-Know-JS/tree/master/async%20%26%20performance
The birth and death of JS was such an awesome talk :D
Oh well, I'd just like to know others opinions, why is it a bad thing to learn from others? Can't know everything you know..
For now, yes. ES6 modules are among the most debated and seemingly hardest parts of the standard to get browsers to agree on, not sure why.
Also: if the copied text has a newline, then when you paste it will execute immediately, without giving the user chance to review it (well I haven't found a terminal where this isn't true). So don't copy stuff from a web site and copy to a terminal, copy to a text editor first (but I know many people wouldn't do this because it's not convenient..)
 &lt;script&gt; function myFunction() { window.open("https://www.etsy.com"); } &lt;/script&gt;
"#perfmatters" here meaning "you want good performance but you're probably too stupid to achieve it so we're going to cram a mediocre solution down your throat just so you don't have a chance to write something worse".
Github has been doing it with Flash in browsers which don't support it via JS. Which was a lot of browsers until HTML5. For a long while Firefox only supported it via JS if you did an about:config change. And Chrome didn't offer a method at all for a while, except Flash. Internet Explorer is the only one that has offered their own unique API for this since before Github existed.
thanks for the zippy response! ive never coded... assuming i need to insert my existing code into your string?
Even TypeScript's (and Java's, etc...) declaration is too verbose in the majority of cases: function doSomething(person: Person, account: Account) { 
How so? What would you suggest?
Looks good :) I did something similar but for baccarat some time ago. I don't think I used objects for each card( was learning and was like optimize all the things! ), I had learnt a clever way to tell the card/suit by just a number haha. _rank = _n%13 //0=Ace..12=King, value 0-51 should be given _suit = Math.floor(_n / 13) //0=Spades, 1=Diamonds, 2=Clubs, 3=Hearts _name = rankArray[_rank] + " of " + suitArray[_suit] + "s" I guess looking at that now, it'd be good for saving on memory, and was fine with Baccarat since you only have 6 cards a game, but with blackjack depending on players you can easily go over a deck per round, so probably not so good recalculating those values every time :p Not code related but possible bugs in your rules(though it varies from casino to casino), these are the ones I remember when I was a blackjack croupier. * Double down on ace is not permitted * Insurance up to half wager(minimum chip as smallest unit), same with doubling, except you could match up to your original wager. * Can't recall, but for casino's that deal first 2 cards to dealer instead of 1 at the start, after insurance you end game if dealer has blackjack? Yours doesn't do that, but it does end the game on a ten if the facedown is an ace. * If the player hits and the hand value is less than 11, you keep drawing for them until they're over the minimum they can stay on(That said you also can't stay on &lt;11 hand values unless due to doubling) I didn't check if you only take half the wager on a double when the dealer gets blackjack, but with your current system maybe that wasn't even possible to do. None of these matter too much as american casino's seem to have different rules which I assume you referenced :)
&gt; Its the implementation of it on android along with the performance of a single processor on android devices. A different webview implementation does change the processor of your phone 
thanks for the reply... part of the issue is i cant modify the site per se the host is weebly and the account i have only lets you insert a script on the page... the script im inserting is the: &lt;script type='text/javascript' src='https://www.etsy.com/assets/js/etsy_mini_shop.js'&gt;&lt;/script&gt;&lt;script type='text/javascript'&gt;new Etsy.Mini(6522454,'gallery',3,5,0,'https://www.etsy.com');&lt;/script&gt; of which im just pasting into a frame they provide, its lame i know, but its all ive got...any ideas to work around it? 
Hmmm... Brand new account. First line sounds like a question from a GCSE paper or some shit. Nope. Homework is your own.
Not keen on the click event binding to an anonymous function as removing it will remove *all* click handlers because there is no reference available. It's a simple rule: don't touch stuff you didn't create.
you could use script that modifies the &lt;a ..&gt; tag for the store link on the main page to not have an href, or have an href="#" and then add the onclick="loadMyStore()" , not difficult with jquery, a little less easy with vanilla js, but there should be plenty of links online to info on how to do it... I might take a crack at it for you later, no garauntees, im hoping someone else will come save the day for you, as ive only been learning javascript for a few months or so... 
Right. Hence the 'along with' in that sentence. The different webview does affect performance. Thats actually the point of the crosswalk webview. In addition, just wrapping the existing app in a downloadable app can increase performance by having at least some parts of the app and the necessary resources locally available. Both aspects back my assertion that just compiling the existing app in such a way could improve performance. Don't get me wrong.. Im certainly not claiming a cure all by just doing that minimum; but that minimum requires almost zero extra effort and does improve performance.
I think your audience should like to know why they should learn JS against any other language. Because they have to? Or because JS is awesome? Either way you should be able to show them what they can do with it. Remember, there is a reason JS dominates the web scenery today.
Which version of vanilla JS? ES6/7 can look very different from ES5. You will have to pick and choose but here are my ideas. I like the 'controversial' features like class and async/await. Actually I think you should show them ES7 with babel and browserify, ES6 modules and npm's massive ecosystem. Modules and semver. Maybe show some HTML 5 stuff like Camera and WebGL and WebRTC. An example of running Node on a Raspberry Pi. Also, in the future JavaScript may fall out of favor as web assembly is implemented and becomes trendy. 
The security concern is that by opening up the clipboard completely, a web page would be able to spy on the contents of the clipboard even when the user is doing something else completely unrelated on their computer. This problem has been mitigated in the browser by only allowing access to the clipboard when a user generated event is being handled (i.e. in response to a button click or keyboard event). So yes. There is really are valid security concerns. 
I think a good point that doesnt seem to have been brought up is simply general use cases for javascript, why use it at all? many people with a little bit of server side language experience might not realize why they would want client side scripting at all. Though js as a client side scripting language is a pretty limiting point of view of js, though it is probably the most unique aspect of js when you think about it, it is what separates js from every other language (not the only thing, but definitely one of the main things)
I do have a single app.js file (which is quite big, by they way). It's then loaded by require.js by putting it inside of &lt;head&gt;. Require.js does add a 'async' flag but I'm concerned whether it's actually loading asynchronously on IE (I'm supporting IE8 and IE11). That's why I wanted to make sure by putting this file at the end of &lt;body&gt;. 
I didn't know what those students have learnt or heard about the web platform in general but if it is anything like the misconceptions which I see on /r/programming (i.e. it's a glorified document viewer with some scripting capabilities) then it is likely to be hopelessly out of date. I propose to you that you give a talk called something like: "The Modern Web Platform: Where it is and where it is going". Your points are something like: * Advantages: network native, browsers are everywhere, 3 major implementaions, open standards, no single corporate owner or gatekeeper (contrast with mobile) * Short history: started as a network document viewer, gained scripting, turned into an application platform. * Current evolution: Standards bodies and browser makers are quickly filling in the missing APIs to make it a full application platform; competes with mobile/native. * Overview of new APIs, HTML5 * JS is growing up quickly: ES2015 and beyond. * Tooling is growing up quickly: TypeScript, Flow, build tools, preprocessors etc; quickly resembling traditional native development and tool chains. * Web assembly, SIMD and the drive for JS performance * JS outside the browser: nodejs, NW.js, Electron You won't have time to get into JS code though. (sorry, I got carried away. I did a talk like this at work early this year.) 
For the simple example `add` you probably don't wanna write a four-line long jsdoc comment, but TBH, you don't even want to write type signatures. Let the compiler infer it to you. Although I prefer type safety, and Haskell can do this for you, in JS most probably you won't need it. add a b = a + b And that's it! Look at a JS implementation: let add = (a,b) =&gt; a+b And it's perfectly fine, don't put any comments here, it's obvious. Now look at `doSomething` (let's rename it to `getTaxPercent`). It will give you tax information based on a Person's age and selected account[1]. You can be really enterprisey and write that four-line long comment, but isn't that more concise, while conveying the same imformation? // getTaxPercent :: Person -&gt; Account -&gt; Number let getTaxPercent = (person, account) =&gt; { ... } Typescript helps you in a lot of different ways, but not with type signatures. It's just funny to read that: let getTaxPercent = (person: Person, account: Account) { ... } I just prefer Haskell's separation of type declaration, while still keeping it short. Another solution would be this: let getTaxPercent = (p: Person, a: Account) { ... } But here function body readibility suffers. Anyways, compare the previous examples to this scary thing: /** * Calculates taxable percentage of salary * * @param {Person} person A person whoose of.. err.. So a person. * @param {Account} account The selected account * @returns The taxable percentage of the salary */ let getTaxPercent = (person, account) = &gt; { ... } Whatever you do (use TypeScript, or Haskell style comments), msot of the times it's probably better than using stupid JSDoc comments. If you want to have auto-generated code documentation, it's okay, or in case your variable and function names don't tell what exactly a function does. Also using non-pure languages, like JavaScript, urges you to declare how a method would mutate state of variables other than it's parameters. After all, it's just easier to organize your code in a pure functional way I must say :| "It even helps you with commenting styleâ„¢!" [1]: This is a terrible example. As terrible as what you'd see in enterprise code 
&gt; And it's perfectly fine, don't put any comments here, it's obvious. No, it's not. &gt; add({valueOf(){return 7}}, 'foobar') "7foobar" &gt; add([],[]) "" Totally legit, right? double getTaxPercent(Person person, Account account) { ... } How is this too verbose and how could you make that any less verbose? There isn't anything you could omit. Sure, you could omit the types: getTaxPercent(person, account) { ... } But we do want those for documenting our intent and for improving the tooling. Well, "Person person" and "Account account" reads a bit silly, but usually those type + name combinations paint a very accurate picture. E.g. an "Entity" class might have a method like this one: bool intersects(Entity other) It's not "Entity entity", it's the *other* Entity which might intersect `this` one. Or this one: Vector aim(Vector cannonPosition, double bulletVelocity, Vector targetPosition, double targetVelocity) { ... } Makes a lot more sense with the types attached, doesn't it? Otherwise, you might guess that the positions are Points or that the velocities are ints or also Vectors.
Dont you think, there should be a class that allow you to just throw in an object and a key and it will automatically add a unique index to the object and save it to localstorage . it should also have sorting , searching, updating , remove and insert methods . All these are very common tasks it should be included in javascript or jquery dont you think ? 
If you don't want/can use a module system like CommonJS/AMD/SystemJS/ES6, I would at least suggest you namespace your stuff into one global object instead of pulluting the window. `var LIB = { /* your stuff */ }; /* ... */ LIB.router = ...`
Point taken. Being modular means things shouldn't reference outside its boundaries to avoid being environment dependent.
What he's saying is that 500+ lines of code for a simple try catch statement around a native browser function is a poor value add to your application. If your app is built around copy paste and you need to use all the different API options of this library, then maybe it's valuable... Otherwise, most people will likely use only one API method and could just write their own call to the browser functionality in about 10 lines of code with just their own event handler. 
Truthy and Falsy values and how to use it to your advantage. 
Don't get off on a tangent based on that. That would be the reddit way but not the smart way.
I guess I'll stick with the second approach then
FYI, '+' is defined for those, so it still did 'add'. Note, that addition can mean the number addition (as in mathematics), but as for strings, it's just a monoidal append[1]. These new examples are not additions in any ways (*, -). Not to mention, your second example tries to subtract 3 from undefined. That's indeed, NaN. Anyways, I am really not into this passive-agressive 'Legit' style shit, sorry. The thing is, the comment itself won't save you. And If I were to use the closure compiler (or coffescript, or whatever else) I just won't[2]. I'd go for TypeScript then. BTW. typically the one-liner ` multiply :: Number -&gt; Number -&gt; Number ` would give a kind of nice hint for the caller site not to invoke it with 'foo', and undefined. [1]: Too bad that it's also defined for functions, etc. [2]: Maybe for minifying my code. But not for "type checking".
As mentioned, the second way is prefered. However, in the near future it will be possible to use [subclassing](https://hacks.mozilla.org/2015/08/es6-in-depth-subclassing/) to achieve the first way in a cleaner safer manner.
&gt; FYI, '+' is defined for those, so it still did 'add'. It's not about what kind of parameters won't generate a runtime error. &gt; Note, that addition can mean the number addition (as in mathematics), but as for strings Which operators are used inside some function isn't something you should be aware of. It's an implementation detail. It can change. E.g. you might add a check for arithmetic overflows. Call-sites which used it with strings, Vectors, or whatever will break. The intent was that this function should do something with 2 numbers. &gt; Anyways, I am really not into this passive-agressive 'Legit' style shit, sorry. There was nothing passive-aggressive about it. It was an example for pure nonsense which too doesn't produce an error at runtime. As I said, going by that isn't useful. It doesn't convey the intent. It just sweeps potential errors under the rug. &gt; The thing is, the comment itself won't save you. The comment itself documents the intent. The Closure Compiler is a tool which enforces it. &gt; or coffescript CoffeeScript doesn't improve the tooling. CS' tooling is actually significantly worse than ES6's. &gt; multiply :: Number -&gt; Number -&gt; Number Not any shorter than type annotations. Plus, matching those types with the parameters is kinda annoying. It really doesn't improve anything. &gt; would give a kind of nice hint Since there is no analyzer for that, no, it wouldn't. You do get actual real-time checking if you use a d.ts file, for example. You also get a useful tool-tip if you use JSDoc comments. And if you use CC, those types from the JSDoc comments are checked.
I was on mobile, should have been more specific. Giving a talk about vanilla javascript is great, "Vanilla JS" not so much (http://vanilla-js.com/). Vanilla JS is a smug, "look at me" website to brag about your superiority in writing plain Javascript. If I asked someone what framework(s) or libraries they were using and they pointed me to this site I'd probably smack them (just kidding, I'd want to though). 
Netflix web player has the feature you implemented in your extension built in. The left arrow is rewind 10 seconds and right arrow is skip forward 10 seconds. Still a decent article. You really didn't know these keys did that or are you on some platform that really does not have this feature? It works on OS X and Windows in Chrome.
Hi /u/dmentes34, this post was removed. Please see our [posting guidelines](http://www.reddit.com/r/javascript/wiki/index).
What would you suggest? And how does the React/vDOM bit affect the choice of using phantomjs compared to regular DOM and ember/angular/no-framework? I'm assuming WebDriverIO with real browsers, but perhaps you had something else in mind like Slimer.
I'm positing that you don't need to render it at all. If the vdom has the proper constructs, then you can validate that the proper classes will be applied at render in the browser. By running it through phantom or something like that, all your tests are doing is testing React's tests because they already have testing to ensure the vDOM renders properly, so this is not something you should be testing. Edit: http://simonsmith.io/unit-testing-react-components-without-a-dom/ https://facebook.github.io/react/docs/test-utils.html
The less you bind to window (ie. globals), the better. I was doing something like this: window.myApp = { router: require('./router.js'), config: require('./config.js'), data: require('./data.js') };
Ah alright, I'm not too familiar with React, still on the fence about picking that up atm. What about testing that the CSS is correct with WebdriverCSS? That might be a valid usecase, PhantomJS might be lacking support for some of the more recent CSS features though.
Frankly, no, I don't think so, localStorage is not a full-blown database to have all that methods available, nor I think that it should ever be used like one But if you want to, you have a lot of options, here are some examples: http://www.sitepoint.com/9-javascript-libraries-working-with-local-storage/ 
Fuck you buddy.
For whoever reported this, thank you. However, /u/RevillWeb is currently undergoing spam rehabilitation, and has been doing a fairly good job of posting from varied sources. It's a little extreme to expect them to only post from other sources for an extended period, so as long as they're making an honest effort to bring their numbers into a reasonable state, I'll be willing to work with them. 
Hey man just a heads up - you can now add action-specific callbacks with 3.1.0. Example: var actor = new ui.Actor({ onUpdate: function () { console.log('my actor is doing things') } }); var tween = new ui.Tween({ values: { x: 200 }, onUpdate: function () { console.log('oh dawg my tween is doing things too') } }); actor.start(tween); // will console.log lots
This is a localization/data problem. By the way, in the US sales tax is typically defined per county and there are more than 3000 counties.
I kind of agree, but I think you're over-stating the case. Generators for async flow will be superseded by async/await once they're ratified in the spec, but there's nothing harmful about using them that way in the meantime.
Having a script tag in the DOM doesn't matter, though. You don't get any benefit from that. Do you?
&gt; This is a localization/data problem. There are more than 3000 counties Isn't JavaScript an excellent tool to handle large data problems? It seems like your comment is saying I'm asking in the wrong place when I can't think of a better place to ask. JS is used to build sites, many sites deal with e-commerce, and e-commerce usually involves handling Tax and VAT. If you're saying I'm in the wrong place, then I disagree.
Hi Kenman. Thank you, if i need to post even less from RevillWeb I will. I genuinely just want to share useful links I think people will like to read. Obviously I want to share and promote my own stuff too - but thats no good if people think i'm spamming!
In case you've never seen it before: Atom + JSDoc: http://i.imgur.com/chzIrSg.png VSCode + jquery.d.ts: http://i.imgur.com/Aa0TjzB.gif
The name property defaults with the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }, which is why you can't set it. Since it's configurable you can use Object.defineProperty to change the value: Object.defineProperty(foo, 'name', {value: 'bar'}); 
Thanks for the link. I'll take a look.
How you respond to, or what you do with, the correctly queried data is a programming concern. Gathering/storing/organizing that data in the first place is a data concern.
Hey, I'm asking what's the best way to get and handling multiple tax rates For example, if I'm on Amazon and want to buy something, they charge me tax, which is based on my location or billing address. I assume the same applies to the US. So I'm wonder, are they: 1. Using a tax table with `Country | City | Rate` and just doing a lookup based on the billing address. 2. Using some sort of API that returns the rate based on the billing address, or properties 3. Something else Right now, I'm dealing primarily with Canada which only has 13 provinces/states so I could create a table called 'Tax' rates then use lookups to return the correct rate for each item based on their `Province/State`. But then if those rates ever change I have to remember to update them, if we expand to US, that problem becomes significantly worst. 
Knowing Debian, they probably provide something from the early 00's.
For anyone not bothering to click on the 2ality link, arrow functions are included in this behavior &gt; With regard to names, arrow functions are like anonymous function expressions: const func = () =&gt; {}; console.log(func.name); // func
Honestly I didn't know about that before I started development, but I did find out before I was done. Even so, I find it to be a different UX case. There's keyboard shortcuts for pause/play and volume control, but I think you'd agree that Netflix isn't going to remove those buttons anytime soon. Ultimately I'm planning on adding a complete player overhaul to the extension. I'm planning something like this: http://i.imgur.com/8rBXtiw.jpg
That's cool, keep on hacking and writing about it! ;)
Problem isn't the language, it's gathering and maintaining the dataset. Taxes aren't just a simple % in the US anymore. There are thousands of locations that have what's called a "Tax on Tax" system. Sample: 7% sales tax: $100 purchase +$7 sales tax +$0.49 tax on sales tax +$0.03 tax on tax on sales tax grand total: $107.52 Some counties have seperate rates for the tax on tax, some don't have tax on tax. The state of sales taxes in the US is a nightmare.
Ah, my bad. I forgot to use arrow functions instead of function expressions. Fixed now, thanks!
technically, hes not right.
You'll probably need an api for each territory. SureTax is the leader in the US, as they're used by the IRS.
I want to embrace JSPM but it is lacking in comparison to webpack. There are not nearly as many loaders written for it, I don't want to have to write my own sass wrapper or jsx wrapper (I just checked and they have those now, but not many more. A few months ago those didnt even exist, when I tried to use it). Also it lacks the nice webserver that webpack has with hot reloading.
www.freecodecamp.com
the code you posted in the gist is not a service worker. The server worker is LOADED within this code: if ('serviceWorker' in navigator) { navigator.serviceWorker.register('/_/chrome/newtab-serviceworker.js', { scope: '.' }) .then(function(sw) { console.log("SW registered"); } , function(x) { console.log("SW failed to register: " + x.message); } ); If you want to actual service worker code you need to look in the file referenced above.
Looks like you might be right however the concerns remain as this is something loaded on every new tab opened in the browser. This is the service worker logic i guess var EXTRA_FILES = [ "/xjs/_/js/k=xjs.ntp.en_US.xiRK793ItKc.O/m=jsa,ntp,d,csi/rt=j/d=1/t=zcms/rs=ACT90oHG8l8Ul7ikVRH2P_1Gb- HDipPG0w", ]; var CHECKSUM = "x222dd"; var BLACKLIST = [ '/gen_204\?', '/async/', ]; var FILES = [ '/images/srpr/logo11w.png', '/images/srpr/chrome_ntp_white_logo2.png', '/' + '/ssl.gstatic.com/chrome/components/doodle-notifier-01.html' ].concat(EXTRA_FILES || []); var CACHENAME = 'newtab-static-' + CHECKSUM; self.addEventListener('install', function(event) { event.waitUntil(caches.open(CACHENAME).then(function(cache) { return cache.addAll(FILES); })); }); self.addEventListener('activate', function(event) { return event.waitUntil(caches.keys().then(function(keys) { return Promise.all(keys.map(function(k) { if (k != CACHENAME &amp;&amp; k.indexOf('newtab-static-') == 0) { return caches.delete(k); } else { return Promise.resolve(); } })); })); }); self.addEventListener('fetch', function(event) { event.respondWith( caches.match(event.request).then(function(response) { if (response) { return response; } return fetch(event.request).then(function(response) { var shouldCache = true; for (var i = 0; i &lt; BLACKLIST.length; ++i) { var b = new RegExp(BLACKLIST[i]); if (b.test(event.request.url)) { shouldCache = false; break; } } if (event.request.method == 'POST') { shouldCache = false; } if (shouldCache) { return caches.open(CACHENAME).then(function(cache) { cache.put(event.request, response.clone()); return response; }); } else { return response; } }); }) ); }); if (!Cache.prototype.add) { Cache.prototype.add = function add(request) { return this.addAll([request]); }; } if (!Cache.prototype.addAll) { Cache.prototype.addAll = function addAll(requests) { var cache = this; function NetworkError(message) { this.name = 'NetworkError'; this.code = 19; this.message = message; } NetworkError.prototype = Object.create(Error.prototype); return Promise.resolve().then(function() { if (arguments.length &lt; 1) throw new TypeError(); var sequence = []; requests = requests.map(function(request) { if (request instanceof Request) { return request; } else { return String(request); } }); return Promise.all( requests.map(function(request) { if (typeof request === 'string') { request = new Request(request); } return fetch(request.clone()); }) ); }).then(function(responses) { return Promise.all( responses.map(function(response, i) { return cache.put(requests[i], response); }) ); }).then(function() { return undefined; }); }; } if (!CacheStorage.prototype.match) { CacheStorage.prototype.match = function match(request, opts) { var caches = this; return caches.keys().then(function(cacheNames) { var match; return cacheNames.reduce(function(chain, cacheName) { return chain.then(function() { return match || caches.open(cacheName).then(function(cache) { return cache.match(request, opts); }).then(function(response) { match = response; return match; }); }); }, Promise.resolve()); }); }; } 
gonna test it too, thank you
Wait wait, everyone doesn't use NCSA GNU/Mosaic 3.0 (IceGoose)? What am I missing?
Great! But in your CODE you need the same cleanliness. Unless you are doing the multiplication within postgres.
no, but often they help us build something faster and easier. 
I would not consider myself a veteran by any stretch, so maybe I'm missing the point. But this is another example of what makes the whole JavaScript world so undesirable to me. There's just forks and flavours of so much stuff. Is the efficiency gained by this new implementation worth having yet one more thing in the ecosystem? As /u/WalkerCodeRanger asked, why does this have to be JavaScript or NginScript? Why can't it be something that exists?
What about cloudfront's geo header?
This is useful, thanks!
 (^|\W)word(\W|$) that seems to work for your examples. That will find it, but to return "word" you just need to put some captures around word for whatever language you're using
 \bword\b Should do the trick.
Don't assume your framework/language is doing the correct thing, verify! You want to test some math that involves fractions of the whole unit. This stack overflow shows you some of the error conditions: http://stackoverflow.com/questions/3730019/why-not-use-double-or-float-to-represent-currency 
Wouldn't a better option in that case be a compiled subset of JavaScript instead of an interpreted subset?
Not acceptable. Forked. underda.sh
https://github.com/twitter-fabric/velocity-react
if we just install the commands line utils and call them from npm scripts we have all we need. The config of grunt is often very verbose, and gulp maximum parallelism by default sometimes causes races conditions. It will be fixed in version 4 but still. The plugins of both provide a level of indirection towards the tool they are wrapping, and don't always use the latest version. You have to wait until the plugin updates itself to get access to a new property, also the documentation of the plugin needs to be updated each time. Just using the command line tools directly seems a lot simpler to do. I wonder if we really need a task runner most of the times? 
To use JavaScript as glue between console commands, you'll want to look at Node.js. It provides a `child_process` module that lets you launch processes and manipulate their input/output streams. In the case of this stockfish thing, I believe you would want to write your commands to the process' stdin stream and scrape output from its stdout stream. I would imagine it going like this: * Run `child_process.spawn("stockfish-exec", /*some additional parameters here*/)`. The return value is a `ChildProcess` object (call it 'fish') * Write your commands to fish.stdin * Attach a listener to fish.stdout to read output from it Read the docs and you should be able to piece this together. Unfortunately the asynchronous callback-passing style of the Node.js APIs makes sequential tasks like this one kind of tedious. If you find it unbearable, there are many libraries available that will wrap native Node APIs to return "promises" (futures) instead, which are easier to deal with. 
That is still quite a lot more effort though. 
The operators affect the return value of the function. The function doesn't return anything so what you end up with is: !undefined +undefined ~undefined
I have to admit I just kind of arbitrarily picked one where the suggested alternative was long to make my point.
As long as people are just posting links on reddit it's fine, but if they produce their own content then that's a problem? This is the first I've heard of it. But if that's what the problem is, sheesh. His username is literally the domain, guy isn't hiding it.
Clicked thinking I'd have the same conclusion. Left having learned debug(), undebug(), monitor(), and unmonitor() which would have been SUPER useful last week.
Ok. Sort of reads like 'repost, upvote, oc, banned.' Fairly well deserved stereotype of reddit, among them.
You posted the wrong link, i think?
&gt; "...since Javascript is not a very structured language it can sometimes be hard to get an overview of what happened and when..." No, since most people writing JavaScript don't do it in a structured way it can very often be hard to get an overview of what happened and when.
Couldn't this example be done like this? "build:dev": "NODE_ENV=developer npm run build", "build:production": "NODE_ENV=production npm run build"
Another interesting approach is to use webpack and have npm scripts kick off which webpack config you want to run (dev, prod, etc) with something like `npm dev`.
npm scripts work the same in a windows box (at least from git bash) or a unix build server. I usually build the source maps in a separate file and send them to production as well, as they are only loaded if the dev tools are opened. But I understand its only an example, its just that recently I've started to question if we really need task runners at all. most of the times with browserify and gulp for example, you had the gulp-browserify plugin that was blacklisted. The official recipe (https://github.com/gulpjs/gulp/blob/master/docs/recipes/browserify-uglify-sourcemap.md) is to pipe the bundle through vinyl which is really something I would never come up with without the recipe, and im not sure if i fully understand. Its all pretty complex and in the end I really think its less readable in the concrete example of browserify and gulp, when a simple command line call to browserify like the author is doing is all its needed. Also with gulp, the fact that it launches everything in parallel and then you have to carefully un-pararelize it with runSequence etc. its all pretty complex as well and can really bite us. How many times I forget that clean is being launched in parallel with all the rest and deleting what other tasks are generating. Im starting to really question if the complexity of adding a task runner is really compensated by its benefits, specially now with things like webpack or jspm. jspm can build a self-executing minified bundle with a module loader packed inside in one command.
sounds simple, jspm is another power command line tool that might be interesting to use like that. It can create a self-executing minified bundle with a module loader inside it with only one command.
ugh no, another one of these. If you are doing anything of significant complexity it does not scale. Sorry - but ""build": "npm run html &amp; npm run css &amp; npm run js &amp; npm run fonts" does not scale and is dumb. Have fun edit-ing your 20-something long line string of things you're trying to get to work together. Even more fun when you start trying to pipe all the output around you have a magical like of &amp; and | and complex sh to manage. 
Pretty good, but there are some serious problems with the bundle step. - since you aren't using `watchify`, you will end up with long bundle times as your app scales in complexity - if LiveReload or a manual page refresh is triggered before browserify is complete, you will get a stale bundle - build errors (i.e. syntax, transform errors) can mess up the development cycle - dependencies in transforms (i.e. a file in brfs) will not trigger a bundle re-load Some approaches to solving these problems while keeping things in the "npm script" realm: - [watchify-server](https://www.npmjs.com/package/watchify-server) - [budo](https://www.npmjs.com/package/budo)
I wrote an article like this a few weeks ago over a weekend project and was like, "why do I use Gulp?" Got back to real work and was like, "oh, yeah. That's why." NPM scripts can make a good install set up routine though. That being said, my code has been getting more modular and I don't need such a busy build sequence a lot of the time for solo dev. Working with others, it's much easier for me to set up a grunt or gulp file than trying to explain my work flow. 
What forks and flavours and ecosystem? This is not even JavaScript. It is an implementation of a subset of ES5, using already established syntax and api instead of inventing their own. Makes sense to me. 
Please clarify your request then. Neaoxas' and 3ggsnbakey's regex does exactly what you ask for: http://regexr.com/3btd4
Actually reading the article reveals that it does in fact compile to byte code for their own and very specialised vm. 
Every function that lacks a return statement implicitly returns `undefined`. Then you're just evaluating undefined with the `!`, `+` and `~` operators to get different results. undefined is falsey, so `!undefined`converts undefined to a boolean value (`false`), then logically negates it, giving `true`. `+undefined` is basically shorthand for `0+undefined`. undefined is not a number, so in numerical terms it's an undefined or unrepresentable number... which is represented in Javascript by NaN. Hence when you try to coerce it into a number by adding it to another number it's first converted into a `NaN` value... and any number plus `NaN` is... `NaN`. Finally the tilde operator performs a bitwise operation that's basically `-(N+1)`. So because undefined is falsey and you're using it in a ~~numerical~~ (edit: [**bitwise**](https://www.reddit.com/r/javascript/comments/3n5a8r/why_do_these_three_selfinvoking_functions/cvlablm?context=1)) context it's first coerced into a `0`, and `-(0+1)` is `-1`. In the fourth case you're just returning the (implicit) return value of the function, without molesting it or coercing it into any other type first. [Javascript's implicit type coercion is a bit wild and wooly](http://patriciopalladino.com/blog/2012/08/09/non-alphanumeric-javascript.html), which is why you'll see a lot of people advocate the use of the (type-strict) `===` operator instead of the (type-coercion-allowing) `==` operator. That said, if you understand it properly and use it where appropriate it can allow you to write more succinct (if sometimes harder to read) code.
Oh wow, that's an interesting approach! I didn't even think about the path-length thing, Windows is so lame about that.
You're both correct. The reason people don't write JavaScript in a structured way is *because* Javascript is not a very structured language.
I believe it might have to do with the fact they use QT's webkit? Prior to 2.0 windows version had a problem with rendering to PDF, and now that problem has been fixed in 2.0 but a very similar bug is now in the Linux/OSX versions ha.
I keep seeing everyone arguing for/against classes in ES6 and I'm just sitting here having fun with TypeScript :|
Yeah doggie. async/await is the best slated feature in JS by far.
I think SIMD is pretty bad ass too but it has more of a niche appeal...
Well that's one for me to read about, then. 
Thanks for the tip. Although I didn't end up using javascript (I wrote the solution in Python), the syntax and method is extremely similar. My main problem was that although I would write stdin commands, they never worked. I solved it by taking note of an extremely obscure comment on stackoverflow here http://stackoverflow.com/questions/10377221/communicate-with-python-subprocess-while-it-is-running at the last comment. Turns out I needed to put \n at the end of my comments to make them execute.... I thought it did that automatically. Anyway thanks. 
Don't forget to post SIMD ;)
Slick! Was the push for this largely because C# devs already are very comfortable with async/await?
So do you just use plain Javascript where you would have used Jquery now? That is in order to avoid the possible hit to performance of loading Jquery. 
I love async/await, but now everything will be wrapped in try/catch. Then I'll have to check if an exception came from await or later inside the try block... :( Is there a better way to just catch the exception from the await call?
C# showed how useful the feature can be but it's being pushed largely because it's really great for JS.
Have they added context right clicking in yet? One of my coworkers loaded up edge, tried to right click and nothing came up.
Yeah, that wasn't coming up when Windows 10 was first being distributed officially for some reason. I'm sure he didn't give it anymore thought because Chrome quickly got installed when the right click menu didn't show.
You're arguing against react-router, not pushState routing. react-router rc1 uses [history](https://github.com/rackt/history), which has a very simple API that would work just the same as your hash based routing.
Also, good luck running those on your Windows dev boxes.
The logging was taking place when I typed in a url in the address bar, perhaps you are right but it doesn't sit well with me logging every url I visit that way without giving me the option to opt out. 
When I referenced build environment, I wasn't talking about your local OS, I was referring to deployment target. My development build is not the same thing as my QA build is not the same thing as my production build.
&gt;Established JavaScript developers will note how familiar this looks since XHR callbacks are used all the time! wait, you mean there are people who DONT use jQuery? edit: half of all the websites on the internet use jQuery. I dont start a project without it. The only two features I use is $.Ajax and query selector. There are relatively few people that I know that know how to properly set up an XHR request from scratch because it's such a pain compared with our jQuery overlords. 
Hi, not related, but by when do you think Edge will have all ES 6 features implemented? There will be bugs of course, but I guess they will be ironed out later.
The regexr link (http://regexr.com/3btd4) demonstrates that regular expression tested against your example :) the text in the lower section of the screen highlighted in blue is what matches the regex in the upper section of the screen.
Generators and a utility like task.js spawn or Bluebird.coroutine are very similar semantically - yield behaves like await and the utility function handles yielded promises in a similar fashion to async function awaits. They are so similar that Chakra's implementation of async functions starts with effectively a source transform to a utility function + generator - more details on [our blog](http://blogs.windows.com/msedgedev/2015/09/30/asynchronous-code-gets-easier-with-es2016-async-function-support-in-chakra-and-microsoft-edge/).
Grunt? Bower? Coffeescript? What is this, 2014?
How is the Edge async/await debugging experience compared to simple callbacks? Same problems as promises? (i.e. no break on error, issues with source maps, brutal stack traces, unhandled rejections, etc)
It's the same as Promises, so you get async callstacks and I believe break on error should work fine in all the latest browsers. Unhandled rejection tracking is something we're looking into!
Okay, so you eliminate the need for a task runner at the cost of requiring windows users to know to use git bash to run? If the goal with this is simplicity you have done yourself a disservice. 
I agree with you and we actively discuss this on the team... but I don't have more to share at this point.
Hi there, I'm the author of Mag.js. For the record, I did not create any of these original tests but I did add the MagJS code to them. That being said, the reason it is so fast is quite simple. Using rAF and cloneNode with the lightest touch it can loop though thousands of rows very quickly. The libraries total gzipped size is only 5kb. But the question remains is it just that particular test? Here is another, different jsperf test: http://jsperf.com/react-vs-raw-dom-manipulation/20 And here's another completely different test where Mithril is ahead of MagJS: https://jsperf.com/testvdom/23 What's MagJS for? It's mostly used for rapid prototyping. The library is fully independent so it can be easily used anywhere with other programs as well. The main point though is it works with the Dom, plain html and pure JavaScript. There's no html in the JavaScript and no JavaScript in the html, no special syntax or new template language. MagJS is simply Dom binding glue :) To learn more and see many other examples .. https://github.com/magnumjs/mag.js
You've heard that from whom? How much slowdown are we talking about? I don't think it's correct, because jQuery is pretty optimized, not that big, and, if you use the CDN, almost certainly cached already. 
This is your chance to get node devs using chakra. 
I tried to look at your post about how it is easier but I scrolled for about 15 seconds before realizing that it must not be too much easier...
Wow. Just... Wow dude... Perhaps try stackoverflow then. Reported for (and I quote) "Being a cunt".
This happens because of type coercion, for the operators you mentioned,following behaviour is defined in the [specification](http://es5.github.io/) * [11.4.6 Unary + Operator](http://es5.github.io/#x11.4.6) 1. Let `expr` be the result of evaluating UnaryExpression. 2. Return [ToNumber](http://es5.github.io/#x9.3)(GetValue(expr)). * [11.4.8 Bitwise NOT Operator ( ~ ) ](http://es5.github.io/#x11.4.8) 1. Let `expr` be the result of evaluating *UnaryExpression*. 2. Let `oldValue` be [ToInt32](http://es5.github.io/#x9.5)(GetValue(expr)) 3. Return the *result* of applying bitwise complement to `oldValue`. The result is a signed 32-bit integer. * [11.4.9 Logical NOT Operator ( ! )](http://es5.github.io/#x11.4.9) 1. Let `expr` be the result of evaluating *UnaryExpression*. 2. Let `oldValue` be [ToBoolean](http://es5.github.io/#x9.2)(GetValue(expr)). 3. If `oldValue` is **true**, return **false**. 4. Return **true**. * [13.2.1 [[Call]]](http://es5.github.io/#x13.2.1) 1. Let `funcCtx` be the *result* of establishing a new execution context [...] as described in 10.4.3. 2. Let `result` be the *result* of evaluating the *FunctionBody* that is the value of F's [[Code]] internal property. If F does not have a *[[Code]]* internal property **or if its value is an empty FunctionBody**, then result is *(normal, undefined, empty)* 3. Exit the execution context `funcCtx`, restoring the previous execution context. 4. If *result*.type is throw then throw *result*.value. 5. If *result*.type is return then return *result*.value. 6. Otherwise *result*.type must be normal. Return **undefined**. It should be clear that the *result* of your last example - evaluating `(function(){})()` - yields `undefined`. Hence the other 3 examples convert the value `undefined` as specified above, So let's look at the steps for your thrid example, the *Logical NOT Operator* 1. Let `expr` be the result of evaluating *UnaryExpression*. **-&gt; `undefined`** 2. Let `oldValue` be [ToInt32](http://es5.github.io/#x9.5)(GetValue(expr)). **-&gt; `0`** 3. Return the *result* of applying bitwise complement to `oldValue`. The result is a signed 32-bit integer. **-&gt; `-1`** 
I think he wants to handle other errors differently from the errors relating to the async op. I guess you could either test what error it was in the catch block or nest `tryâ€¦catch`. 
Because with you being edgy about Microsoft Edge, this essentially constitutes a knife fight.
Async/await is an ES7 feature, it's not implemented in any browser yet and you have to use a transpiler to use the syntax. Well, besides IE Edge now.
I'm getting the impression you've not used it? 
I guess this is the right link http://stackoverflow.com/q/32895832/1487756
~~https://github.com/yortus/asyncawait~~ &lt;-- not for native async/await. http://www.sitepoint.com/simplifying-asynchronous-coding-es7-async-functions/ http://pouchdb.com/2015/03/05/taming-the-async-beast-with-es7.html https://jakearchibald.com/2014/es7-async-functions/
That's sorta like the situation C has been in for 30 years. It only seems to have improved the life time of the language and the tools, and seems like only upsides to me.
but it is! declaration of `async function` means that body of function is wrapped in Promise. `await` call means, that result of call will be treated as a Promise and it's `then()` result is returned to caller, while it's `catch()` result is converted into native exception. see https://tc39.github.io/ecmascript-asyncawait/ yield is part of that sugar, but core is still about Promises
no not really... you can say async / await is wrapper around promises which is implemented using generators where you wait for (yeald) resolved promises value while providing next promise to wait for
Obligatory "just use make" comment. No seriously, just use make.
Yep, you're all right, I was wrong. I wasn't properly escaping the \b.
"You wouldn't believe #3."
I very rarely use jQuery anymore - only time I bring it into a project is if another library requires it. 
I realize he was a little abrasive, but please refrain from personal attacks.
What I said wasn't a personal attack, it was an accurate depiction of what was happening. It was factual. He (for no reason), got mad. Making him an argumentative cunt. Sorry, however that is the truth. It would of been a personal attack if I said, "well your life isn't worth living - go fucking kill yourself" - but I didn't. I just called him a name. As I said, *factual* not *personal*.
Ah, thanks for the info!
Wait, you're letting this comment slide? Let me just re-iterate what /u/SkilFluckYJ said: &gt; You can go fuck yourself in the ass because I am genuinely trying to learn for something that matters more than your life. And that is fine is it? For a Javascript discussion...?!
What the...
Yep, you're right. Apparently my glitch is elsewhere. Thanks! I was barking up the wrong tree.
Better support for modern css and Javascript is all I ask for and it seems it has delivered on that. The days of separate IE style sheets are over. 
I nuked the whole post.
The easiest way to use 03 with a leading zero would be to use strings rather than integers. So your keys would be: myData['03'] = '2015-09-22'; And so on. Typing 03 into the first box will result in undefined because there is no entry for 3 in the array. Adding keys like I showed above make it work for me. My code looked like this btw: &lt;script type="text/javascript"&gt; var myData = new Array(); myData['01'] = '2015-09-08'; myData['02'] = '2015-09-15'; myData['03'] = '2015-09-22'; myData['04'] = '2015-09-29'; myData['50'] = '2015-10-06'; &lt;/script&gt; Last Week Number: &lt;input type="text" name="week_number_two" id="week_number_two" placeholder="Week Number Two"&gt; Last Week Enter Date: &lt;input type="text" value="Date" id="date_two" name="date_two" /&gt; &lt;script type="text/javascript"&gt; document.getElementById('week_number_two').onchange = updateText; function updateText() { var obj_sel = document.getElementById('week_number_two'); document.getElementById('date_two').value = myData[obj_sel.value]; } &lt;/script&gt; Edit: Updated my array keys after I noticed you wanted to type 01.
Go in to chrome and type chrome://predictors now go open up fiddler or Wireshark and type the first letter of the most common prediction and watch your traffic o_O none of this is remotely new by the way
Async/await is built on top of Promises. If a function returns a Promise, you can await the actual result. And an async function always returns a Promise. Just do everything with Promises. Once you can use async/await, using those promise-returning functions will become much simpler, but you will still need to understand how Promises work. So, it's not an either-or thing. Promises are the foundation and async/await is sitting on top.
Wait - JS is getting SIMD instructions??
Just because async uses promises under the hood doesn't mean that it's sugar over promises. That's like saying your car is interface sugar over gasoline because your car uses it under the hood (literally) to power itself. They serve two different functions. Promises give you a way to ensure that inversion of control is done in a safe way; that when you hand over execution of your code to some other framework/library/block of code, it will return execution to your code in a predictable, consistent manner that you can code against. Async/await allows you to run code in a non-blocking manner and control its flow.
I knew it would be something very simple, thank you SO much.
1 - It's way more readable, and debuggable, I can ask webstorm to run my gulp file drop a break at any point or in any of my previous declared plugins. Do you have a great shell debugger? I feel free to try and attach to exorcists's process and break in it when something goes wrong. 2 - Again you still have 2 things going on here. What if you have 40? At some point you still have a giant pyramid of npm run statements that can't be nested, can't be put in other files (there is no other package.jsons). I can go as far as take my gulp tasks and expose the function entry via require if I want things to be more readable. 3 - All of that is well and good when someone else has written the installable global packages for you and you can just hook "exorcist". But if you have a significantly custom task (and you will when you're doing more then something incredibly basic like what is in this example) then it's on you to do all that work for the pleasure of your npm's simplicity. Or you'll end up just writing .js file and executing those like shell scripts. **edit to add: If I want to add something signficiantly custom to gulp, I just need to have a basic understanding of how to use through2, write a func and I'm done. No global plugin, no new commands. All in, npm is a great package manager. It is excellent for storing configuration in json. But it is not a good task running framework. Use gulp, you'll thank me later.
[removed]
There's plenty of good answers here, I just thought I'd add a bit of code as an example (my mind works by having to see code). The difference is demonstrated in the "main" function below: // // define a function that returns a promise that can be "await-ed" on // function sayHello(nm) { return new Promise(function(resolve, reject) { setTimeout(function() { resolve('Hello ' + nm + '!') }, 2000) } } // // we can only "await" on async functions inside another async function // async function main() { let msg = await sayHello('World!') // this also works, because sayHello just returns a promise!: sayHello('World!').then(function(msg) { // do something with 'msg' }) } main() 
don't do this. javascript does not have "associative arrays". array "keys" in javascript are not keys, they're indices, and thus integers. when you attempt to use a string, you're actually setting properties on the array object, not elements of the array. thus myData.length will be 0 and you can't use functions of the array prototype to iterate or manipulate that data because it's not contained in the array data, which is almost guaranteed to cause problems and confusion. you're treating it as an object, use an object as the current top comment from /u/x-skeww says.
Despite what the Settings pane shows, the end of your [userAgent string](http://whatsmyuseragent.com/) is Edge/12.10240. It looks like this support for this is coming in the next major version of Edge. Edited to add: [Windows Insider Program](https://insider.windows.com/) info / signup.
There's no reason for sayHello to be an async function. You can await on anything that returns a promise.
I'm not sure where to start so I'll just do these in random order: 1. `new Array()` JavaScript has array and object literals. Instead of `new Array()` use `[]`, instead of `new Object()` use `{}`. You should stop thinking about Array and Object as classes, they are nothing of the sort. JS does not have classes (in the Java/PHP/C# sense), only objects. 2. `01` Array slots in JavaScripts are just regular properties (mostly). So assigning to them is a regular property assignment. In property assignments the property names (in this case `01`) are converted to strings -- property names are always (with some exceptions) strings. In order to conver the numeric literal `01` to a string, it is first interpreted as a number: the leading zero indicates an octal number (i.e. base 8) rather than a decimal (i.e. base 10), but as it's smaller than 8, it just works. The number (1 in the case of `01`) is then converted to a string `"1"` and that is then used as the property name. 3. `01`, `02`, `03`, `04`, `50` Your "array" has gaps. Arrays start counting at zero and shouldn't generally have gaps. You don't seem to use any logic that acts on the slots as numbers, so the proper thing to use would probably be a plain old object. Arrays are just a special type of objects anyway. 4. `onchange` You shouldn't use the `on*` attributes to assign event handlers. Use [addEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener) instead. The main difference is that it allows you to have more than one event listener on the same element. 5. Your actual question Use an object, use actual strings as property names. With object literals this becomes even easier to write: var myData = { '01': '2015-09-08', '02': '2015-09-15', '03': '2015-09-22', '04': '2015-09-29', '50': '2015-10-06' }; 
Can you access your IIFE properties? I think not, then it isn't a declaration, I guess that even if you do something like this. (function IIFE() {})(); You still couldn't access them - i.e `IIFE.toString();`, I may be wrong saying this but they just work like the anonymous functions.
I agree that the Immutable.js can be very cryptic sometimes. *Predicate* in this case means a function that "find" will use. The function has the following signature: function (currentValue, currentKey, iterable) Iterable is the immutable object you are calling find on. *context* is the value that *predicate* will use for it's "this" (if that doesn't make sense, it's not super important and not used very often). *notSetValue* is what value to use when an element in the List is empty (as in a sparse List)
This is the blog post that brought about the name: http://benalman.com/news/2010/11/immediately-invoked-function-expression/ It is an expression and not a declaration. Anything inside the () becomes an expression because JS doesn't expect statements inside parentheses.
http://codepen.io/anon/pen/epvgKX Please feel free to ask all the questions you would like!
No, it's literally sugar over promises. If you call an async function without awaiting it'll return a Promise. You can also await any Promise.
Your first link relates to something which is similar but has a totally different and incompatible implementation, it's based on fibers not promises and fibers are dead now. If you're new to async/await, I suggest that you skip it.
Why, yes you are right, thanks for the correction...updated the code.
Thanks i'll strike it. Shouldn't comment at 3am.
TIL thanks
You're saying he's wrong because he's not mentioning generators. But the statement "it's a wrapper around a promise" is correct whether or not he mentions what else is involved.
Your car is a higher level convenience wrapper around an engine, not gasoline. And that's true whether or not you mention all the other things involved with building a car, like transmissions.
Yes it is. Async/await is syntactic sugar to make a method that produces a series of promises through a generator, and then wraps that method in a spawn call that wraps and chains those promises.
Async/await is syntactic sugar over one specific use for generators. In general, generator functions have yield points where they return values to the caller and can be resumed at that point by the caller (with or without the caller providing an argument to use when resuming.) Async/await is the idea that we can: 1. Write a generator function that returns a series promises 2. Wrap that generator function in a function that will return a promise that iterates over promises from the generator, giving the result of the previous promise and asking for a new promise each time a promise is resolved. 3. Provide simple syntactic sugar that indicates that we want to write this kind of function. 
&gt; If File_Name = New_File_Name and they aren;t the same file then: Isn't this logic backwards? 
I don't know how many platforms we're talking about, but they definitely work on Linux, OSX and Windows 7, 8 and 10 as far as we've tested. These are the platforms we use at my current place of employment to build. Windows does need a little more attention - you have to specifically create a "junction". This is possible with fs.symlink.
This is like worse than global variables X10. Messing with the very constructs of the standard library. Might as well redefine the new operator in C++. yuck. The problem is that things like Object are a contract between the programmer and the system. And your changes are not limited to your own code, they apply to anything running in that browser window. just yuck.
Perhaps you should first focus on learning HTML and CSS, since that's like 95% of the work. I just started using [Hugo](http://gohugo.io/) to create a simple portfolio / blog. It's pretty neat. I host it on github pages for free, and use [Wercker](http://wercker.com/) to automatically build and deploy the site when I push a new piece of content to the repository. 
Is there a chance in hell? Sure, nothing is off the table! Especially if we keep hearing feedback like yours...
source?
Damn that's badass. I can't wait for that
There's a dist folder with transpiled files.
No.. none of those are function declarations, they are all function expressions. I agree that the parens are good practice, but from a language syntax point of view, they are not needed *in those cases* Too much detail here between the two to duplicate here: http://stackoverflow.com/questions/1013385/what-is-the-difference-between-a-function-expression-vs-declaration-in-javascrip
What if RemindMe isn't maintained 6 months from now? 
Indeed, but I said "as-is", which means I think it's too bad the source needs to be transformed before it's natively usable.
Oh, no worries! :) Did you see my example? Yep, you're right, `if (x = 0;)` isn't proper syntax. One = assigns a value, == does a not as strict comparison, and === does a stricter comparison. You also don't want the ; in the parentheses... you can just delete it out of there. I'd also do your x-- operation before assigning the value to the input. And then your if statement needs to be moved inside of the function so the comparison can be done each time the function is called. Like this: http://codepen.io/anon/pen/WQpOej Make sense?
Anytime!
I recommend creating a static website first with raw HTML, CSS, and minimal JavaScript if you know nothing about web development. That would be a good way to get your feet wet. Creating a blog (essentially a content-management-system) is diving in the deep-end for someone with little-to-no experience. You'll have to choose which stack you want to work with. You'll be using HTML/CSS and possibly some JavaScript anyhow, so it's a matter of picking which language you want to use for your back-end: **Python**, **PHP**, **Node.js** (JavaScript) for communicating with your server and database. Which brings me to the next aspect, the database. **MySQL** is the most common. You also would have to choose if you want the web-server running on **Apache** or something like **Django** (Python library). Commonly used stacks are: **WAMP/LAMP**, **MEAN**, and stacks including Python.
&gt; Windows does need a little more attention - you have to specifically create a "junction" That's the problem, a junction is not a symlink which means symlinks are not very platform portable. They end up unintentionally breaking a lot of tooling built around development such as IDEs, version control, and there's always caveats around using them. I think it's best practice to avoid using them entirely in development, especially since a lot of their use cases can usually be solved in some other cross-platform friendly way. Use symlinks in production or known friendly environments, sure. Avoid using them in development if at all possible. 
What if I die within the next 6 months? Sometimes you just gotta stop worrying.
No, I corrected your analogy and highlighted why asyc/await does indeed wrap a promise, and that's true whether or not you mention all the other things involved in providing us delicious asyc/await sugar, like generators. Engine = promise, transmission = generators, car = async/await. Apologies for assuming you would be able to make the connection between the analogy and my point without me spelling it out.
It's not a buzzword. "Sugar" is a term used by PL researchers all the time.
The Dart VM had SIMD support for a while. It did demonstrate that SIMD does make sense with fast scripting languages and that you can indeed make some things 4 times faster if SIMD is a good fit. There is one key difference, however. Dart also supports operator overloading, which makes SIMD and vector code look a lot nicer. Operator overloading is also on the roadmap for ECMAScript, but it probably won't be in ES7 yet. Bringing SIMD to the Web via Dart (by John McCutchan) https://www.youtube.com/watch?v=CKh7UOELpPo (John McCutchan also wrote the SIMD.js polyfill and he's also working on the SIMD.js proposal.)
I just heard it from talking to a programmer, so it's anecdotal evidence. There's this [site](http://youmightnotneedjquery.com/) also. So I dunno. Do you know if Cloudflare or MaxCDN automatically cache and/or optimize Jquery if you use them as your CDN?
So because some people "use it all the time" it's not a buzzword? I think you misunderstand the "buzz" part of "buzzword".
Why would you block the screen with a request to subscribe? Why would I choose to subscribe before reading anything at all from your site?
I used Lucene on a project that required spatial searching and would definitely recommend checking that out. It's a great learning experience and a very powerful tool.
[SUBSCRIBE TO READ THIS COMMENT]
I don't think learning proto inheritance is necessary anymore. Just learn the new syntax and generators, promises etc.
And so begins the slew of "10 node/npm packages you should be using" blog spam.
Every time this question is asked, the answer is the same: because it works.
No it does not.
Okay.
This is a great comment. I thought I could maybe add a bit by linking to the [testing pyamid](http://martinfowler.com/bliki/TestPyramid.html) which states that the majority of the tests should be unit tests, exercising individual units of work. Above that (and consequently fewer) should be the integration tests, which integrate multiple units of work together to solve a business function. Above that (and fewest, using my three layers) should be the UI level tests. These are finicky, slow, and frequently very brittle. There should be few of them and they should exercise the highest value code paths. All three of these layers are important, and they work in concert.
The most important thing is that you understand the language JavaScript and how the DOM works. Can you add an element to the DOM without using $ ? If I asked you to make an object which inherits from another could you do it? Do you know a little about how the JavaScript runtime works? i.e. blocking code, event loop, et cetera. Finally, do you understand the meaning of 'this', scope, and closure? If you can answer those questions and write a bit of HTML, CSS, and some specific javascript framework, then you can get an entry level web dev job no problem.
I'm not sure that's quite accurate. `await* promises` was designed to desugar to `await Promise.all(promises)` -- there is no difference between those expressions. You don't need a separate catch.
Thanks for this. Good info to know going into the job market. 
I think you took my comment to mean the inverse of what I intended. I'm not saying you need it (`catch()`), or that you should use it, but that developers may end up doing that, which will lead to difficult to read, maintain, and debug code.
thanks for the advice. I'll definitely revisit vanilla js. It looks like most people here are leaning more towards react than angular. I might go with that after.
This was intended to really be black box testing. At the end of the day, whoever is making calls to the API (whether it is some frontend dev or it is intended to be a public API) they shouldn't have to care about implementation. 
It just got implemented into microsofts new browser natively..it's more than a hot topic 
I think it's important to draw a distinction between "front end testing" and javascript testing when determining what's cost prohibitive or "nigh impossible". While I think it's true that a lot of front end code is not tested, I think that it's mostly due to laziness, speed of development ("I have to make this site for a client in 2 weeks fuck tests"), or thinking that testing front end code is impossible. ~~First, testing the way something *looks* should probably never be done. At least at a "pixel perfect" level. You could write tests to make sure DOM nodes are properly nested or something but that's about it. The looks of applications often change and having to change tests for these sorts of things would be ridiculous. Here I totally agree that this sort of testing it cost prohibitive or at the very least really quite obnoxious.~~ EDIT: Turns out this point probably isn't entirely accurate as I've been informed by some other commenters. My experience here was only second-hand headaches from our QA using these sorts of tests and apparently there are ways to do it that are both not super difficult and really useful. &gt; building a test that incorporates every possible place the mouse might click, and knowing that those clicks produce the correct business process result This actually isn't that hard at all. Lots of front end frameworks make it very easy to tie a single function or handler to a button in an expressive manner (I mean `addEventListener` is great on its own too). And it's very easy to write a test that tests a number of things that a function does: fires an event, calls another method, changes a value, makes a request, etc. Tying those two things together, it's pretty easy to test what happens when a button is presssed: e.g. "Since we know button A fires function Foo and we have tests stating that Foo does the right things then it follows that clicking button A does the right thing." From my experience this covers 99% of the use cases you need for UI interaction. The specific testing that *can* get out of hand, is end-to-end testing. I believe another commenter also mentioned this. I.e. testing to check that a button being pressed causes a request to go off, which when resolved updates a piece of the UI, and then changes the page or something. Testing that series of events in a single test can be a headache for a whole variety of reasons. But the way I see it is that most of the time this can be sidestepped by just writing unit tests for all the individual pieces. Then once you have tests for each piece you just write simple tests to make sure the individual pieces interface/interact correctly and then you're done. This all being said, writing tests is a cost no matter what type of code you're writing them for, back end or front end. And understandably some people don't want to invest in that cost. Some startups I've worked at work incredibly fast and work on experimental features often and skip tests entirely for front end code while other companies I've work at are more invested in their product and want solid, tested code. It's just a matter of where you place your value. tl;dr a lot of front end code isn't tested but it probably should be because it's really not that difficult to write testable front end code.
I have created a static websites ekalipi.com and ekalipi.org using bootstrap. How should I give it a start ? I want to first start with Node.js and Mysql in the back end and JavaScript or a JavaScript framework in the front end. Like I said being a computer science major I know some things so creating a blog wouldn't be that difficult right ? Plus I also need to know how do I give it a headstart ? Like do I create the login page first ? Or the post page ? Or the home page ?
Line chart?
You need fewer tests with optional types Ã  la Dart or TypeScript to reach the same level of confidence. Without types, you need a lot of tests just for the sake of increasing the coverage in order to ensure that you exercise every line which in turn helps with detecting breakages caused by refactorings or library updates. With types, you already know that the puzzle pieces fit together. The analyzer continuously checks everything. So, if you cover your own packages and your business logic, you should be fine.
meh you see this exact sentiment come and go. People went from assembly to compiled languages and were saying the same thing. The went from lower-level languages to higher languages and said the same thing. This tbh is exactly the same. For all intents and purposes you can write good js apps never knowing about proto inheritance. 
Haxe would be good for this :P
Shut up.
"You will be working closely with the owners and we have been in this business for almost 10 years. Your punctuality, communication and work ethic must be excellent or the position will not work out for you. The hours of operation are 9 am - 6 pm PST and it is a full-time, salaried position Monday thru Friday in the heart of downtown San Diego." Sounds like a great work environment, however I'm concerned they won't ask for estimates or change their vague requirements frequently enough. As a gluten for punishment: I have pretty discerning standards when job shopping. Just to be safe, I'll probably ask them to list the "5 most effective ways to motivate employees" just to be sure I'm not wasting my time with an interview.
There is also React Native... allowing full native mobile app development for iOS and Android. Learn React... have most of the skills for mobile dev!
You're not. The problem with /u/gdmno's statement (and, presumably, assumption) is that his perspective is biased by the community he's surrounded by. These modals *are* annoying, and a good number of the readers here leave sites immediately when they see them. However, *in the real world*, these modals drive conversions. Granted, when they pop up immediately, they are less effective, but "it works."
Yes.
Ah in that regard I totally agree with you. Though modern browsers do now support checking whether something is occluded via `document.elementFromPoint`. That being said, as I said in my post, I think these sorts of visual things should not be tested because 1) they change far too often, as you said, and 2) the current methods for testing these sorts of things are entirely too clunky and way too much of an investment.
Yep, but I'm not sure how to segment the lines. Wasn't sure if that had a specific term.
Given your post history and submissions, you might as well be. Thanks for confirming.
Oh awesome, thanks, I didn't know about that method! (I've been switching to web dev the past 18 months, DOM API knowledge is something I could use more of!)
I'm not a marketer, nor do I recommend this feature for site as I personally dislike it. My statement is based on the more official statements given by other redditors who are marketers, and who do have the data to back it up. Stick around; someone may respond with the sources you're looking for.
what are you using to block the requests?
Awesome! Looking forward to have it all by Jan 1 2016... :P --- ## EDIT: HOLY BANANAS! With the exception of these [4 features](https://dev.modern.ie/platform/status/classeses6/?filter=f0e0000bf&amp;search=ES6), everything else is implemented: * Classes (ES6) * Modules (ES6) * Subclassing (ES6) * Tail Calls (ES6)
I only disagree on one point, which is that the optional part negates your statement. You can't assume that you know how the pieces fit together if defining the piece is optional. Worse, mixing typing and not typing makes a huge mess. It makes me cry.
I guess employers looking for [rockstars](https://www.reddit.com/r/KitchenConfidential/comments/3furbz/when_i_see_a_craigslist_ad_for_rockstar_line/) are universally assholes, huh?
 Not sure I like that sugar when generators use the asterisk as well.
[RequestPolicy](https://requestpolicycontinued.github.io/).
If you were making half as much in South Dakota you are well paid. San Diego must be crazy expensive.
1. Don't let us fuck up the culture. Hold us to our values. 2. Be in 10-3 so we can get access to you in person, and be in for meetings. Otherwise do work when and where you want. Nobody is monitoring your hours. 3. Speak up if you see something wrong. Actually, speak up if you even sense something might be wrong, especially if it's in some part of the company you have nothing to do with. 4. We don't have arcade cabinets, a loaded kitchen, constant paid lunches and dinners, etc. We have one foozball table to share and enjoy. We don't want you here late so we don't want to make it too cozy. We want you to go home and have a life. 5. If we're asking you to do work that makes you work over 40 hours, it is your duty to bring it up with your supervisor so we can figure out how to ensure you have a life. So, these aren't "ways to motivate you", but would you feel motivated at a company like that? 
Thanks a lot. Okay that was something I was looking for. Oh and what about the framework ? Angular, backbone ? Would it be okay if Pm'd you if I needed help in doing any of this ?
*asynched
I am currently trying out nativescript. While it is open source Telerik has an online IDE and cloud build for ios and android. It also has a live sync app that can auto update code OTA to your test device. React was a a non stater due to only working on osx(for now at least) 
So basically (at least according to the article) very inflexible coroutines that are no more readable than current JavaScript? Brilliant! :-/
You sound a lot like me; I've only just got my first job out of school as a jr. dev, and apart from some fun and totally incomplete side projects using Angular and more recently React, I didn't know a full fledged library aside from jQuery. That being said I'd echo that React is definitely worth looking into; I sing its praises a little too often on IRC, but it really is a great View library. Haven't used it with Flux or Relay yet, so can't talk about its stronger capabilities. Reacts strengths are that it's [decently sized](http://prntscr.com/8n5jgf) (via [weightof.it](http://weightof.it/category/application-frameworks)) for its abilities, it uses plain JS for much of its logic, and if you know your way around HTML and vanilla JS, it's fairly simple to get started. Angular is in a weird place as Google announced the v2.0 will be drastically different than v1.x, so many folks who haven't learned it yet aren't looking to start until after 2.0 is released, if at all.
This confused me greatly as SD can mean South Dakota or San Diego...
It feels like javascript developers create a lot of their own problems. I can't say I've experienced these problems they keep trying to solve.
Took a look at your library and I got the feeling that it was cool, but I don't quite have the mental capacity atm to figure out exactly what its use case would be (currently rather exhausted, about to call it a night). I think it was a mix of the variable names/values being slightly un-intuitive to what the library's function is. Which is cool, its your library, do what you do. But as a curious george would you ELI5 a real-world-usecase for it so I might get a better understanding? Thanks :) .
You do of course put types at the boundaries, because this documents your intent and because it instantaneously improves the tooling. Adding them is the lazy thing to do. It means you can auto-complete more. All 3rd party code I've used was properly typed. All of my packages are properly typed. And all of my app code is properly typed as well. You see, I'm seriously lazy. Having the types there pays off within the next few minutes. This isn't anything like writing JSDoc comments. It's not a chore, it's a convenient shortcut. &gt; Worse, mixing typing and not typing makes a huge mess. It actually doesn't. You just annotate functions and fields, literals always have a type, and type inference covers pretty much everything else. So, you write very few type annotations, but you end up with code which is almost fully or even entirely typed. You also aren't really mixing anything. You application is always dynamically typed. The types are more like documentation which is also available to your tools. If you're passing the wrong type to a function, you aren't using it as documented. Well, I was also skeptical at first, but it does work amazingly well in practice. You really should give it a try.
I'm fascinated by the advancement (err progress?) of non-relational database usage in recent years. There's an interesting subtlety when it comes to architecting database schemas that is lost on most of the people who use them (web developers, mobile developers, generally any developer who uses it as a necessity/means-to-an-end rather then a full-time-gig). I imagine many, many, developers would have chosen a relational database thinking it was a trivial decision and thus been unable to build the same solution as OP. Such an obstruction could have cost them days of development time, and quite likely left them with an inferior project/product. Hat off to this team, I'm sure they have a bright future ahead of them.
remember thats **starting** salary. In NYC its 100k. 
If you look inside the /twitter/typeahead.js issues you should see some people talking about it. edit: Haha I just tired to find it again, it took about 2 minutes... https://github.com/twitter/typeahead.js/issues/1320
I should really move back to the USA. Tokyo and less than $30k.
don't pollute the planet, buy an electric car
https://github.com/Javin007/JavMin/blob/7f3a36a90b7b83aa9c8e257eada242035666392e/JavMin_1.0.0.js There is a block comment from line 1 to line 277. This is obviously broken. You also shouldn't put the version number in the file name. You could have provided a demo page with two textareas and a button. You don't have any unit tests.
As someone who is hiring soon for multiple roles that include angularJS and related knowledge, I would like to point out a few of my personal opinions on this question, as it is asked quite a lot. Again these are my own opinions and should be judged as thus. * I don't really care which you learn as long as you can learn them. It varies by company but I don't expect you to know our entire stack like the back of your hand. This is one of many reasons hiring developers is hard, it is difficult to judge ones ability to learn beyond basic indicators (college degree, portfolio, work experience, etc.). * Why is always more important then what. Why would you choose react for a project? Why would you use angular? Why is angular popular in the first place? Almost anyone can learn syntax and api calls. Not so many understand why. Interestingly enough there are many large companies with senior engineers who make decisions without fully understanding why, and it is my personal belief that they pay for this mistake (if not in this world then the next..) * You'll get further in the job market with breadth rather then depth. You're an expert in javascript? Shut up the other resume on my desk has eight years experience and has written production code in javascript, coffeescript, and typescript. Oh and he also has made major contributions to a dozen libraries, two of which we use on our stack. You will rarely be able to compete in depth, as by definition, it takes time, of which as a junior dev you've spent very little. So again circling back on the ability to learn, it's important. * Fake it 'till you make it. Again the job market is quite unfair, you are very much outgunned. Don't lie on your resume because any competent hiring manager will call you out on it, if he/she doesn't then you probably shouldn't apply to that company (but apply anyways because you're a junior developer). Use tools like nmap and builtwith to find out as much about their stack as possible before applying, then study up and tailor you're resume to fit the role they need, even if they don't know it yet. * I used to, and still do, ask myself constantly "Would I hire myself?". If the answer is no, think about why and aim to correct it. If the answer is yes, you've saturated your current potential and should aim for a better title and a new job. Apologies that got long winded, hope it helped! TLDR; framework doesn't matter. You're not aiming to be an expert, you're aiming to get hired. It's not as simple as pick and learn X, otherwise everyone would do it.
OP has celiac, so either works
Async is built on a much more flexible and general feature (generators.) These are python style generators (bidirectional) and are effectively coroutines.
I have trouble remembering whether `await*` is for Promise.all or Promise.race, and I'm probably not the only one. Better to make the use of Promises a little more transparent. The syntax was also a bit confusing because it wasn't quite analogous to `yield*` or python's splat operator.
"Sugar" is meaningless. In a high-level language, everything is sugar. Saying that some new feature is "just syntactic sugar" conveys zero information. It's empty filler. "a += b" is sugar for "a = a + b". A feature which helps you to structure your code in a more straightforward manner is a bit more than that, don't you think?
Full stack dev that has used js only where it makes sense. Ui on the client and "realtime" data reporting with node.js. Some of these things I read about these days seem like solutions in search of problems. 
&gt; It actually doesn't. We're going to have to agree to disagree here. There is one developer on my team who is terrible about applying types. It hovers around, perhaps, 60% of his code having types (he applies `any`). The remaining untyped (mind you, I'm not referring to literals or inferred types) code contains spurious usages of his and other's code, and debugging it is a nightmare. So, perhaps if every developer on your team is a magical unicorn, it works fine to sprinkle in types. I prefer, and experience has taught me, that mixing the two is crap. And, like you said, types let us be lazy. There really isn't a reason not to use them (again not referring to literals and inferred types).
Same here, I pushed for $40k expecting my company to haggle it down. To my mild amusement they agreed, but even then after taxes I ended up with about $29k in actual salary per year.
While I agree with you, I wouldn't be very happy if they only allowed one programming style, mostly because that would be OOP.
Uh, try 130 in the bay area.
Oh, sorry - I was agreeing with you too. Must be late over here. Either way, I'll gladly write `Promise.all` all day long, as long as I can use that sweet async flow.
How do you survive?
Those requests may work in an idiot marketer sense but definitely not in a happy customer sense.
Living expenses are pretty cheap. Company puts up half of rent, $800/month, so I only need to pay $400. I live close to work, so i don't need train fare or a car, and I eat lunch at work. Cellphone bill is $20 a month, things like that. So I don't make a lot of money, but at the same time I don't really use it either.
Metric dollars!
Sticking to some simple conventions doesn't require any special skills. https://www.dartlang.org/articles/style-guide/ Simple enough, right? If you want that every team member annotates all fields and functions, you have to write it down. Have some conventions which specify this. "Everything that's visible from the outside must have types attached." Just like that, for example. Adding those types is the bare minimum of documentation. Anyhow, I don't see how things could be any better if there weren't any types.
Holy crap. I used to live in Paris and get â‚¬40k, as a native mobile + web developer...
&gt; Please send your application to: admin @ country rebel .com (remove ALL the extra spaces) Yeah, remove all the extra spaces. That's the kind of information a ROCKSTAR dev needs to put this email together.
A super-hot topic?
As a non-american, what do the numbers actually mean? Here in Sweden, in my city of 80k residents, I earn around $ 32k *after tax*. But our taxes are very high compared to the US, and most of the US "benefits" are guaranteed by our state (sick/parental leave) or culture (min 5 weeks paid vacation). My tax is around 30 %, so the salary before tax is ~ $ 45k. On top of that, an employer has to pay a separate tax, so as a rule of thumb, my employer would have to pay 2x of the amount I receive after taxes. How does this work in the US?
Keep in mind where you're going to ve working, too. React is great but unless you're working in a major tech hub you're unlikely to find many jobs using it. Even in the Bay you have to hunt for React jobs. Angular is viewed in the same light as Java/C#/PHP, people rag them constantly for being "enterprise" but if you want a job in most of the country it's going to be your go-to. Look for job postings wherr you want to start working and let that be your guide. 
As an American working overseas due to family situations, I see several factors at play here. First off the culture in the Nordic Countries is very egalitarian and socialistic and doesn't look favorably on large differences in take home pay regardless of the supply / demand / skill curve for that occupation. Second, from what I've seen the unions have sold their members out and are colluding in keeping developer salaries low due to fear of outsourcing and the idea that Europe can be the future upcoming export economy of developer talent to the US. Third, the developer industry I've been mostly exposed to has very little to do with consumer services with the population at large consuming American conceived and built applications and services. Where's the French Facebook, the Finnish Twitter, the German Amazon? They don't exist. Without those giants pulling the top talent and dragging other developer salaries up behind it the market forces driving salaries higher don't exist in Europe. So with a lack of market forces driving salaries higher, and active efforts in place to keep them low, this is the reality. 
In Belgium they say your employer pays 2,5x what you receive in net income. I don't think a lot Americans have a clue how much tax they actually pay, I've asked it multiple times with no real answer. 
This news made me update to Win10.
No, these are actually pretty good wages, to be as well of in the states you'd have to be paid 70 or 80k
You are way to emotional about a web browser.
Wait, await and promise are not part of vanilla js ? Edit: Nah, not supported by any browser so far
My main problem with callbacks is the scope issue in loops.
&gt;As long as you are hard working and a pro-active problem solver giving 110% each day with a positive attitude, it is a very laid back and fun work environment! One of these things is not like the other... And the prescribed way of writing an email to them? Yeah, jobseekers have time for that bullshit.
Rent's not $3k/mo in San Diego. When I was there 5 years ago I was paying just under $1k for a a studio (with a divider to make it a 'one bedroom').
To be "better off" is a fairly far-reaching statement considering only personal income and healthcare are considered. There are strata of societal implications of these differences in taxation, and other things, to consider. Please note I am not saying Sweden &gt; US, I'm just saying it's complicated.
That sounds really good tbh. I pay 600 euros for 20m/sq and I'd say it's a good price here in Helsinki.
I had just bought a 3 bedroom house when a friend took a job in the bay area. I happened to be there for work and went condo hunting with him for a day. One of the condos he was thinking of getting looked exactly like my one bedroom apartment, when I was single, but it cost 3x the price of my smallish, 3 bedroom house.
That wall of text under `TypeError: cannot read property '0' of undefined` is called a [stack trace,](https://en.wikipedia.org/wiki/Stack_trace) and it tells you how the program got to the point where it failed, and where to check for the failure. In this case, it's at line 337 of `tradebot.js`. If I had to guess with no context, I'd say you're expecting a function to return data for `row` somewhere and it's not, then you're using `row`, expecting it to have data.
I meant with isomorphic js, you seem keen on using it in your solution but you should never think how tech x can solve problem y, but what tech should I use to solve problem y
recently i wrote review comparing 8 JavaScript books http://xahlee.info/js/JavaScript_books_review.html in summary, today, i still think the best, most comprehensive, is the Rhino book, even though it's aged. to pick a second, i'd go for Professional JavaScript for Web Developers By Nicholas C Zakas. Or, perhaps one of his other JavaScript books. (he's got 4.) Zakas's books is aimed at experienced industrial programers only. hard to pick the 3rd one, without specifying if it's for beginner or experienced. Hard to be best at both. 
Huh? I haven't met a single American who isn't aware of what they pay in income taxes. Even as a 15 year old, I was busting out a calculator and realizing I was losing like 15% to taxes at the time. It's on all of our pay stubs and year end W2s. Now, people might not understand tax brackets as easily so they can understand how their taxes compare to someone else's who makes more or less... But they are very aware of their own taxes. Maybe you aren't getting an answer because as Americans there isn't a single rate and it sounds like you're looking for a single number. We pay income taxes on a federal and state level. Both are through brackets which are based on your gross income. Also extra incomes like bonuses are taxed at a different rate. Based on where you live and how much you make, the tax rate varies greatly. Also, individuals often base how much taxes they pay on what's taken out of their checks which isn't always right. We fill out our own tax forms (i9) when starting a job and if you fill it out wrong you could pay over or under what you should. This is why at the end of the year when doing taxes a lot of people get tax returns from the government. Well, that and all the tax breaks based on their last year (eco friendly purchases, low income breaks, educational breaks, etc) are tallied and also applied against their taxes, resulting in a return. Anyway, what I'm saying is that if you're asking a simple, "What's the American tax rate?" question, then yes no one will have an answer for you because the answer is far more complex than the question warrants. 
dont forget the penis tax in sweden
Now if they've seen this thread, they'll know its you in the interview. You fucked up, son!
Craigslist actually seems pretty good for tech here in Denver metro area, in fact I'd rate it as the best place to look for jobs, just filter by "engineer" instead of "developer" and you'll be golden.
IMO, this seems like a bunch of vernacular "gotchas". The article even explicitly points this out with Question 5 about "classical" inheritance. I ultimately feel they're okay interview questions because having your developers use the same words to describe their concepts makes things go faster. Having said that, if I was being interviewed and someone said "programming paradigm" in a question when they could have just as easily said "programming patterns", I would just assume they're pompous twit and would eventually start asking me questions about "web 3.0" and "socially scalable apps".
I know -- it's missing an intro explanation and a bunch of simplified examples :( But thanks for the kind words despite! It's a data flow library for apps (mostly concerned with in-memory moving data). It's part of a framework being used by my company for single page intranet apps (we're open sourcing it at the Nodevember conference). I'm planning to produce a bunch more examples soon with the 2.0 release that will make things more clear hopefully. But basically, it's similar to redux.js, bacon.js and postal.js mixed together. it's all about subscribing to data as streams, transforming it, and moving it around. You can listen to say 5 different pieces of data, note that you require 2 of them to be present, batch them up so if 3 change it only produces one callback type event, group or transform them as they come in, pipe the data to a different data point or run some callback function. In the full framework, everything is declared as relationships, then it auto-wires itself up, and you don't really have to worry much about logic related to timing/order etc. It is based on creating apps that download a bit at a time, so all logic is added asynchronously, but you don't have to use dependency injection (since it requires a kind of apriori knowledge of what's coming in-- more like a web browser, it tries to handle whatever)... Check out: http://darkmarmot.github.io/kodama/ That one at least is a little more fleshed out. I still need like half a dozen nice examples though.... 
And had had 5 weeks of vacation like never....
What? Americans receive W-2 forms every year which explicitly state what they made and what they were taxed. Everybody knows how much tax they paid. What they don't show is the majority of tax paid is to make up for taxes that corporations avoid. A person making $50K/year pays about $50 for welfare/food stamps, $250 for military, and about __$4000__ for corporate subsidies. 
https://en.wikipedia.org/wiki/Class_%28computer_programming%29 &gt; In object-oriented programming, a class is an extensible program-code-template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or methods). &gt; When an object is created by a constructor of the class, the resulting object is called an instance of the class, and the member variables specific to the object are called instance variables, to contrast with the class variables shared across the class. Classes in JS do all of that. You can picture it like that and use it like that. You don't think classes in JS aren't anything like that because a prototype property exists if you look at it, do you? Classes in Java have a "class" field. This kind of stuff is just a footnote. You do of course also have to learn how prototypes work. You need that for old code. Just like you have to learn how var works and that you won't get that for-loop iteration scope stuff if you use var. You also have to learn the old octal literal syntax and the new one. You have to learn what strict mode is. You have to learn how the two flavors of `this` work. JS comes with a lot of baggage. It's a complicated language.
The thing is in Norway you already have full health and dental, plus higher education is super cheap, unemployment insurance is for everyone, etc... If you take home 2k per month in the US, it is my impression that you'd have a hard time making ends meet. Now I don't know specifically about Norway, but here in France most of the people i know make between 1300â‚¬ and 2000â‚¬. And most have kids and live in houses they've bought. To give you an example, i studied litterature for 3 years at the university, and it cost me maybe 1000â‚¬ total in tuition. I then switched to computer science on a 2 year course (is that what you call a bachelor's degree in the US?), in a private "expensive" school, so i borrowed 15k and paid that back during my first 2 years of working. All i'm saying is you can't really compare. Living in a European country means pooling lots of expenses with everybody, so much more of the money you make is "spending money". In the States you'll make 2 or 3 times the same amount, but then you have much more to pay for yourself. It's really just a matter of putting everyone's money in a big jar or distributing it so everyone spends it how they like. We can argue about personal preference but i think functionally it's not very different.
You don't like compile-time checks and static typing?
I should have used jQuery 
I don't think I'd want to work for a guy that just drills me on his ideas of what inheritance should/shouldn't be. Half these questions are about prototypical or classical inheritance or directly mention them when one or two would've been plenty. Especially if in his opening he says he would never hire someone who uses classical anyway. Interviewer: Do you use classical inheritance? Interviewee: Yes. Interviewer: Thanks for your time. Why bother asking the other questions if that is you biggest hurdle and you aren't willing to budge? I think this article started as a bash against classical inheritance but had a few things tacked on the make it feel less ranty.
 String.prototype.likeABoss = function() { return this.replace(/ /g, ""); } "admin @ country rebel .com".likeABoss();
But you get paid in yen? If you ever want to convert back to USD it's gonna hurt.
Not if you have fewer than 15 employees or so?
really good video!
Denied! A true "rockstar" developer doesn't even KNOW native JavaScript. You should have at LEAST 15 years of jQuery 2.0 and BackAngularNodeJs.
&gt;as a gluten for punishment Hey. I have celiac as well. You should come check our /r/celiac
But the thing im really having problems with, is how do I get it too have data? I have already checked the db and I dont think its a problem there. Here is the code: http://pastebin.com/sdr0Z2Ss
Here you go: http://pastebin.com/sdr0Z2Ss 
Huh? San Diego is a good 8 hours from the Bay Area, and things have changed a lot in the last 5 years.
Refactoring for the interview? Hired!
Fifty, actually.
&gt; Interviewer: Do you use classical inheritance? Interviewee: Yes. Interviewer: Thanks for your time. The author's stance is more nuanced than what you give them credit for; it comes down to avoiding hires that are fixated on class inheritance and have a "don't tell *me* what to do" attitude, which I think is at the core of the poor reception of his articles in places like reddit as well.
my bad!
&gt;I think this article started as a bash against classical inheritance but had a few things tacked on the make it feel less ranty. It is kind of a ranty article with a clickbait headline. But as someone who is trying to learn about best practices, I have heard bad things about classes, and they don't seem to accomplish anything that can't be done better with composition. Can you explain some benefits about classical inheritance or why it should be used over other patterns?
"admin @ country rebel. com".split(' ').join('')
Its gone up quite a bit. A 2br $2,500 apt or house is pretty common. 
8? You mean 12.
Downtown DC: studio 500 sq ft w/ utilities: probably $2000/mo. Fucking kill me..
&gt; Since async/await are meant to abstract away promises Anyone that uses async/await needs to understand they are dealing with promises, it's very easy to miss a try catch on a promise and lose any hope of debugging the application on error. I don't see this as that big of an eyesore.
I'm on OSX so Kinect 1 (2 is not supported AFAIK), I made this to work with it: https://github.com/szymonkaliski/Kinect2OSC
If you are interested in Windows development, the universal app can be written entirely in JavaScript with native O/S functionality. It's pretty sweet.
Ok, you are right, it doen't matter the name. Thank you for clarification.
I'm using it for running kiosk software (both server and client, which are running on the same machine). Also, there are some libraries available like [CoherentUI](http://coherent-labs.com/) that allow you to use it for the UI in 3D games.
Because they were bought by Microsoft, but they were originally created in Sweden. 
In some strongly typed languages, classical inheritance is used to implement polymorphism. For example, in Java, the only way to get dynamic method dispatch is through inheritance and classes. This is not necessary in JavaScript, where *every* method call is dynamic.
http://electron.atom.io/
As someone who doesn't know any better, why does mentioning lisp lead to a no hire? I'm genuinely curious.
Perhaps you read into it further than I do.. But I thought this was pretty clear.. &gt; I advise people to hire based on whether or not a developer believes in class inheritance. It would appear to me that the author himself has a very 'don't tell me what to do' attitude in that he *completely discounts a whole, widely used inheritance model*. It has its place and recognizing that it can be useful is important. 
This seems ... completely insane. Sorry to say, but JavaScript is no longer a `disable and we get a slightly less cool experience` -- it is required to make many web sites function at all. I just updated back-end api with new signatures for some end points -- and users are complaining it doesn't work. Did they not accept the prompt to update the front-end code? Yea you're going to need to do that. It's bad enough that cached javascript can cause problems when an API is updated with a new signature, needing something like a cache buster scheme to fix -- but users should be able to opt out of updates? Someone is using the site and then it stops working. Oh, the user modified the script and now it does unexpected things and doesn't integrate with the API as it did before? C'mon. It's hard enough to make a seamless user experience but now the user can throw a wrench into the works and fuck with the javascript, block arbitrary libraries and the like?
This approach is not scalable. You should use a node.js backend that does processing with mongodb.
&gt; If there was zero strengths on a classical model, why did they see fit to add it to the spec? ES6 just adds a class definition syntax, it doesn't add a new inheritance model. The rationale for adding the class syntax was to ease developers used to the classical model into a prototype-based language, and your argument actually illustrates a common objection to that, namely that it would lead to misunderstandings about what model JS uses. 
Currently using javascript to drive the logic behind embedded Qt/QML interfaces.
Yeah man, we've done a ton of work :) Classes and subclassing are out from behind a flag in the latest flight as well, so really the only big missing pieces are modules and tail calls.
Because obfuscation == rockstar. What you propose makes too much sense. That flies in the face of this exercise.
I had my DNA looked at recently. Turns out I have a touch of Asian back in the woodshed somewhere. I think we may hove found its effects.
&gt;Ill do it in 100 lines 90 lines of it for tests
Oh dear god, easily.
This is what the description should say: * Looking for recent graduate, talented, but without a lot of experience, who is looking to build up his resume * Should be under 25, so your parents still pay for your benefits. * Experience should include writing a lot of wicked webapps in college, and ability to pick up PHP quickly (because no one under 35 uses PHP) * We will call you a Rockstar developer, the same way your mom calls you the most handsome boy in the world * Our offices are in downtown, so you can visit all your friends working at the fair trade coffee places during lunch time and go out with them after work * No flexible hours, just so that you know who the boss is $70k sound reasonable 
Sort of, but not what he was referring to.
In this case, is he not calling stdin of the ffmpeg process, and not stdin of the running node process?
Go on ... 
[javascript for automation](https://github.com/dtinth/JXA-Cookbook/wiki) allows os x apps to be controlled with javascript. sadly, the documentation is poor and few make use of it. one non web related thing i made is a utility that [gets genres for your itunes songs and retags them](https://github.com/northamerican/get-genres-from-discogs). 100% js. 
tbh if I would get asked examples of FP languages I would have said haskell and lisp. Neither I have used...
How about popularity over time? If you agree with the author, functional programming's been around since LISP way back when. Yet OO has thrived in both academia and practice for decades now. When presented with JavaScript which supports both functional and OO styles and inherently favors functional slightly, developers find ways to implement OO closer to classical inheritance. 
Nice! This code is absolutely horrible, should have caught that.
from the article: &gt; I advise people to hire based on whether or not a developer believes in class inheritance. I think it's illegal to discriminate based on religious beliefs.
Yup. Never underestimate just how awful California traffic is, and how much time you would lose to it.
Apparently founded in Sweden, before they moved to Germany. Didn't know that!
I completely agree. The way JS plays so loosely and unpredictability is one of the reasons I generally don't like web development. Besides the tediousness of HTML and CSS and having to fight against bloated established systems like WordPress. Anyway... The way Unity implementation of JavaScript helped me to inspire me to learn more about C# (the other scripting language used by Unity) and general concepts like object oriented programming and working with classes. In the past few months I have started doing a lot of Java programming and I like it a lot.
Wow, electron looks really cool, thanks for sharing
Tons of stuff outside web! - [node OpenCV](https://github.com/peterbraden/node-opencv) - [Johnny Five](https://github.com/rwaldron/johnny-five) (great for arduino) - [Cylon robotics library](https://github.com/hybridgroup/cylon/) Just to name a few. Lots of stuff :)
At my job, we have several command-line tools that we use which are written in JS.
What is the range of force on iOS?
JS robotics library... thank you very much.
I've used JS to create cross platform desktop apps. I used [Electron](http://electron.atom.io). Having a single codebase for all desktop operating systems is so much better.
Let me be the first to say no. No, no, no, no, no. Use the right tool for the job. JavaScript is far from the right tool for EVERYTHING. It is meant for web, it works well for web and that's it. It might work for other things but not nearly as well as it could. Seems like a vaporware kind of idea to me but for a lot of people's sake, I hope not.
You could just use this: import {exec} from 'mz/child_process'; async function run(cmd) { let [stdout, stderr] = await exec(cmd); return stderr; } 
So what you're saying is a good JavaScript developer reads Eric Elliott? :) No disagreement there.
You can do so much even without frameworks: https://deck-of-cards.js.org ;) ..of course depends on the project what's the best solution
Well, are you speaking from experience? What sort of non-web scenarios can you speak of?
Interesting! Where did these numbers come from? I'd like to read more.
Lots. and?
I feel like someone with experience wouldn't say that. JavaScript for desktop and client/server development is far from optimal or likely even realistic. I haven't seen any large applications using any of this in a production environment.
You pay income tax, which is based on brackets. Your employer pays social taxes (in Belgium RSZ 13,06%) and others (patronal 35%) but that differs per country.
What a nice system. I meant that over in North America we pay our own taxes, not our employers.
It depends what you mean I think. I love writing WebGL games, I've made a lot of use of Babylon and it's a great engine, I see big advances with perhaps a move to Web Vulkan if that happens. Of course Unity already supports Javascript as well. However for creating an engine for 3D or higher end games that need performance, C++ will dominate for a while, Unity is written in C++, Unreal is, cryengine is etc. That's why I stated it depends on what you mean, if using a 3rd party engine, Javascript is very capable but if designing an engine that you want running as fast as possible, I don't see Javascript being dominate there to be honest. 
 function deSpacifyEmailString(string, spaceValue) { if (string.length == 0) { return ""; } var char; if (string.charCodeAt(0) == spaceValue) { char = ""; } else { char = String.fromCharCode(string.charCodeAt(0)); } return char.concat(deSpacifyEmailString(string.substr(1, string.length), spaceValue)); } deSpacifyEmailString("my dick @ soo huge . xxx", 32); Can I has job now? Make good codings!
I would agree that it's probably pretty ideal for one off solutions and prototyping. I just thinks its silly to invest into it as if it can do everything. A JS based microcontroller sounds like an absurd waste of energy. I will take some time to look into but I feel like the performance would be horrible for any "real" application.
looks like an array to me
Youre testing if the references are equal, not if the content is equal.
What this guy said. `==` is a reference test for objects, not a content test.
An array is an object in JavaScript
One could argue that a Swiss army knife has everything you need in life. But try to actually live off of one and tell me how you make out. I'm not saying its useless, I do love JavaScript for web development and I could imagine a handful of other scenarios where it would be very nice. I'm just saying its not feasible for production desktop and client/server development or microcontrollers as the post suggested.
For a class project (brainfuck compiler) I tried using javascript. Turns out, a browser based, interpreted language is not a good language to write an interpreter in.
Well, I will leave you with this thought. You are wrong. Empirically. But I hope when you are presented with the evidence in a way better than I am currently able to do, you will recognize it for what it is. All I know is, everytime someone says something can't be done in Javascript, it starts to do it. But we have indeed reached the point of impasse in our current debate. Unfortunately all I can do is point you at things like reactnative and nodejs and see how the language is at the beginnings of doing the very things you say it is inappropriate for. I'm definitely not saying it's perfect for those things. Yet. What I am saying is that to say it CAN'T or SHOULDN'T do those things is just straight up incorrect. It just needs more bodies thrown at it to reach up over the next wall.
is it different from just doing ["last].toString() == ["last].toString() ?
Not a fan.
Can't go into specifics. There is a lot of embedded display work going on with Qt/Qml in automotive and aerospace, and that uses vanilla Javascript without all that DOM stuff getting in the way.
I find discussion of MVC always end up being overly pedantic. MVC isn't some specific architecture that you must abide by exactly. MVC is just a general term that means your code properly separates its concerns: user actions are handled in one place, data model and storage is handled in another place, and UI behavior is handled elsewhere. Flux fully separates each layer. You don't execute data mutation logic within your views or trigger AJAX from within your data model code. Like any other MVC architecture this makes it easier to test and reuse code through composition.
I wrote some games in JS. It's a lot easier with Dart or TypeScript. WebGL is also a lot easier to use with types and better tooling. I also really like operator overloading in Dart. It makes vector and SIMD code look a lot better. SIMD will be in ES7. SIMD support in browsers should show up in a few months. I used some operator overloading in this demo: https://dartpad.dartlang.org/e91384a4e1eee6749287 For small games, JS is certainly more fun than Java, but I think the sweet spot are the optionally typed scripting languages. You get so much more assistance from your machine and more information is right at your fingertips.
`==` &amp; `===` do not coerce to a primitive via `Object.prototype.valueOf`. So some weird rules apply: **`==` is somewhat coercive** 0 == '0' // true ['last'] == ['last'] // false **`===` is not coercive at all** 2 == '2' // false ['last'] == ['last'] // false **Best Part! Value comparison, `&lt;`, `&lt;=`, `&gt;=` and `&gt;` coerce to a primitive via `Object.prototype.valueOf`** var x = ['last'], y = ['last']; x &lt;= y &amp;&amp; x &gt;= y // true So you can get away with *greater than or equal to* &amp;&amp; *less than or equal to*, if you want it to act like Ruby. It essentially converts the arrays to strings joined by a comma. Probably no different than: x.toString() === y.toString()
Perhaps you should look into Haxe. Fairly flexible language that compiles to C/C++/C#/Obj-c/JS/Ruby/PHP/Python/etc, can interface with the native language targets libs, frameworks which optimize or use different tech stacks depending on target languages while maintaining consistency. It's pretty awesome.
&gt;How about popularity over time? How about people in the middle ages thought that not washing was a good way to ward away disease. "People do it" is not a strength. Please objectively explain why its good. Like actually tell me a reason why I should use the classical inheritance pattern over any other pattern. I am not trying to bash any particular way of doing things here. But I've asked this question and all I get is "well that's just the way we've always done it", that's not good enough.
Soon, as soon as jibo comes.
Yeah I agree with you on that - flexibility and options are good. What bugs me is how a lot of the features feel almost isolated from each other and designed fundamentally differently to a point where they don't mix too well. For example, the new `class` keyword bugs me a lot - the syntax for defining `class` methods vs `function constructor` methods is different which makes no sense to me. Class methods get defined more like you'd see in C# instead of what you've been seeing in JavaScript. And hoisting doesn't work either so the scope behaves completely differently than function constructors (as well as some other weird quicks i've read but can't recall right now). JavaScript is a steep enough learning curve to write it properly coming from a C# background and it feels like overall the language changes will lead to some very strange, confusing code out there.
I wrote a nodejs webcrawler / ETL data loader. It was a batch process to extract project data from github and feed it into a graphical database.
 constructor(_) { this.image = _.image; } ... const edge = new Edge({ image: document.getElementById('img') }); You could just skip that object. 'c' is a somewhat bad name for `CanvasElement`. '$' is a bad name for `CanvasRenderingContext2D`. '_' is a bad name for `ImageData`. There are some `var`s. Get rid of those. I'd scale the image proportionally instead of stretching it.
 &gt; ["a","b"].toString() == ["a,b"].toString() true If you want to check if the items are identical, you have to compare them one by one.
 console.log(shallowEqualArray([...'abc'], [...'abc'])); // true console.log(shallowEqualArray([...'abcd'], [...'abc']));// false console.log(shallowEqualArray([...'abc'], [...'abcd']));// true! oh noes! You also have to check if they have the same length. Conveniently, this will also make the function much faster in cases where they don't have the same length.
It sounds like a fantastic excuse to use `Array.prototype.map` on a String since every Brainfuck command is a single character long. You could probably do something like: Array.prototype.map.call(brainfuck, function(char){ return commands[char]; }); ...to convert the string into an array of functions, with each element being the implementation for that particular character. (Or, simply using `forEach()` and running the command in the callback.) Another option would be to replace it with the strings of [the equivalent C code on Wikipedia](https://en.wikipedia.org/wiki/Brainfuck#Commands), doing an `array.join(" ")`, and finally `eval()`ing the result...
Node.js developers would disagree. I make Node scripts all day and write them in Atom (a desktop app written in Javascript).
I do not know of a framework that is implemented without using at least some some classical inheritance. However, I have been pretty happy with react+lodash for a functionally focused structure. You can use both without any local state, your views and functions being purely functional and only operating on an external, mutable state object (which itself could be implemented in the immutable or pure functional style). Internally, React does use inheritance (prototypal) to describe its objects for efficiency reasons apparently. Other than referencing member functions in your views using 'this', you can pretty much ignore inheritance as a lanuage feature. I only have experience with Angular and React, in addition to Vanilla JS.
I've personally been playing with using Javascript on embedded systems, and I know there is a growing community of people using Node.js on embedded as well.
Is it really necessary to mock a `document` for the tests?
&gt; In JavaScript, prototypal inheritance is simpler &amp; more flexible than class inheritance. ES6's classes are the simplest option. Messing with prototypes gives you more flexibility, but this flexibility comes at a price. It also negatively affects tooling. Anything you do imperatively is pretty much inaccessible to static analysis.
In the US, Federal Unemployment Tax is a tax based on employee wages by employers; it is explicitly not paid by employees or withheld from their payments. There's a variety of other taxes (depending on which state you live in) levied on both employers and employees (in the form of automatic withholding from paychecks). Then at the end of the year, employees get to pay even more, if an insufficient amount had been withheld. There are some numbers [here](http://smallbusiness.chron.com/calculate-much-employer-pays-payroll-taxes-10081.html) as an example.
NetIQ Identity Manager (formerly Novell) uses the Rhino JS engine to allow ECMAScript execution for data manipulation and custom code, and the cool thing about the Rhino JS engine is that you can call Java code pretty much willy-nilly from JS. https://www.netiq.com/documentation/idm402/policy_designer/data/ecmaexamples.html https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino 
Javascript is used heavily by BIRT tools. [BIRT](http://www.eclipse.org/birt/)
You keep using the word "installed". I do not think it means what you think it means. Furthermore, your proposal would break the web completely. There are so many SPAs that require frequent updates to their Javascript, without which updates major functionality could be lost. Having to manually update all of my websites every time I visit them sounds like a pain in the ass. Right now, the browser manages website "versioning" through caching. You basically want to get rid of the package manager that we have and turn the web into Windows, where you have to manually update every program on your computer one at a time. Furthermore, which sounds like more of a security hole? Having Javascript permanently installed on your computer, or having it run in a sandbox inside your browser where it can't access anything other than the website you're currently visiting, and it goes away after you leave the page? I'm pretty sure any sane person would say it's the first one.
We use it for cordova based ipad apps used as a sales tool. Javascript falls down with calculations. Even math.js had bugs we had to write workarounds for. We should have probably written the large calculation engines in c. I use it for everything else though ;)
Hey there! Galvanize I'm guessing? How did your exam go? I have mine Monday! :) 
It does, THANK YOU. I'll go see how far I get with this new, shiny info today. 
 execCommand () { return new Promise((resolve, reject) =&gt; { var errdata = ''; var app = fs.child_process.spawn('cmd_not_real',[]) app.on('error', (data) =&gt; { errdata += data }) app.on('close', () =&gt; resolve(errdata)); app.on('exit' , () =&gt; resolve(errdata)); }); } You can now call this with await. let errorData = await execCmd();
You forgot Ikea. Soon. Very soon.
I wrote a Chrome App that connects to a Bluetooth fingerprint scanner to verify the user. This was for a micro-finance module. JS rocks. :)
Weak ones. It's still just generator yield points which are continuations, but not nearly as powerful as full blown continuations. You can't pass around generator yield points and jump between them at will. They must be consumed in order and can not be rewound or reset. In fact, async await is less general than raw generators because the entire machinery for how they are consumed, resolved and chained is not in your control. Async/await always uses spawn and you can not change or customize this. Async await is handy, but it is really just a particular hardcoded use of generators. 
Does it only work with the common module loader?
It's great for Java developers who don't want to learn JavaScript, I guess. Believe me when I tell you that Java is not the language you want to emulate and Java-inspired patterns are not the ones you want to adopt. If your code is disposable and has no chance of surviving past a few years, then it may be an acceptable trade-off to widen the pool of hires and offer lower wages (especially outsourcing) in exchange for harder-to-maintain code. The problems with classical inheritance are well-known and well-documented by experienced programmers, but languages like PHP and JS that adopt native class syntax late in their lifetimes make the community go through a phase where classes are the best thing ever invented and should be used for everything. (Oh, how I love PHP.) The Gang of Four book was almost entirely written as a way to get around the problems caused by inheritance. If you ever learn FP and re-read that book (or half of Uncle Bob's books), then you will realize how almost every design pattern, principle, and recommendation becomes useless or a natural consequence of using simple pure functions and composition. Anyway, it's important to distinguish between classes and classical inheritance. You don't have to use inheritance if you use classes. In that case the class becomes kind of like a glorified factory function. If you do that then you might as well use functions/closures in most cases, but classes do have some benefits in static analysis, developer familiarity, and performance. Trade-offs: less maintainable, less flexible, difficult behavior sharing outside of inheritance, no/difficult encapsulation, all of the problems caused by `this`, harder to test, less reasonable, interface coupling (`new` keyword), leaky abstraction, tempting inheritance, etc. But in general, classes are fine if you avoid inheritance. Just don't go down the Java/Angular2 road of making literally everything a class. By the way, inheritance for behavior sharing should be avoided whenever possible, be it classical, prototypal, or multiple. Prototypal inheritance is usually even worse than classical inheritance in a mutable language like JavaScript. Basically, more flexibility at the cost of nearly impossible-to-trace bugs (even with unit tests). It has its place, but rarely. Prototypal inheritance is cool in theory, but rarely truly useful in practice. And as /u/MoTTs_ said, be careful not to confuse multiple inheritance/mixins and composition. There's a lot of FUD there, both in and outside the JS community.
They are nondescriptive. I'd call my `CanvasElement` "canvas", `CanvasRenderingContext2D` "ctx" (a common abbreviation), and `ImageData` "imageData". For example, I had to read quite a bit of code to figure out that "_" is supposed to be an `ImageData` instance. I actually had to look at a call-site and not the function itself. I had to see how it's used to figure out how it's supposed to be used. If I hadn't known that getImageData returns an ImageData instance (it isn't always this obvious), I still wouldn't have known the answer. There aren't any downsides to using longer more descriptive names. Auto-complete takes care of the typing work and minifiers take care of the file size (local identifiers can be renamed). Naming things is hard, but it's also very important. It's one of the few clues you can leave behind to make your code less cryptic. "There are two hard things in computer science: cache invalidation, naming things, and off-by-one errors." Seriously, naming things is hard.
Testing by reference instead of value is actually pretty useful. Those two arrays aren't the same, because if you add an item to one, it won't be added to the other. They are two different arrays. 
Node is using Chrome's JS engine: V8. You don't need a browser to run your javascript scripts, they're interpreted by V8. Have you ever looked at the Node API docs or source? It provides access to filesystem, cryptography, net and http operations for example just like you would have in Go, Java, C++, PHP and etcetera. The killer thing for web developers that are proficient in Javascript is that you can don't need to learn another language and it's set of tools to manage your backend and/or frontend. Imagine you have a web app which list the directories and files from a location in your computer and retrieves this data from an HTTP API, you can do it with Node. * Setup an easy Express HTTP server, listen on a specific port. * We will handle the directories and files request on i.e (localhost:3000/ls/Desktop) where `Desktop` is the `ls` command 1st argument. * Import the `child_process` module and spawn the `ls` command, wait for it's stdout and send it as a JSON response with directories and files on Desktop. * Run your script i.e `node ls_server.js`. Finally - on your web app you do an AJAX request to (localhost:3000/ls/Desktop) and get the JSON response.
You're right, there is definitely a clear intention to separate the M from the V in Flux. The thing that makes me feel a bit uncomfortable with Flux is that some degree of "business" logic finds its way into the stores (to "switch" between logics, and to implement actions). The same thing goes to the View - If Actions are initiated there, it means that we have "crossed the line" into the business logic land. Things could have been that much better (more maintainable and reusable) if the view wasn't so closely coupled to the dispatcher, and stores contained less foreign logic.
In most languages the equality operator on two separate arrays or objects will return false, not just JavaScript.
Does anyone know if ES2015 will have module loader? I feel that if we have that then JavaScript will no longer need frameworks apart for the view/DOM. 
From a quick glance, it looks clear and maintainable to me, following good practices and not that many de facto shortcuts as otherwise common in JavaScript code, including my own. The only thing I'd change right away is moving the throwing of custom error into the catch enclosure, because why test for the same thing twice. If this is what your code looks like, I'd hire you. Edit: I may have done details differently, but hey if it works, who cares. 
JavaScript isn't Java. You are probably trying to do things the Java way which is why you are having difficulty. What are you trying to do?
My question is do any of these options have a better option than JS? It is definitely of interest that JS *can* be used, but is there a better option? That is a legitimate design consideration when architecting a project, and choosing something that is less suitable for a project is more of an 'ooo interesting' than 'this is the best solution'. This is fine for a hobbyist, but when talking about enterprise opportunities, the answer changes.
Not tech. 
Write tests against your code. Look up guides to Mocha or Jasmine. Making your code testable may require to write your code in a different way and break it into smaller parts. If your code has decent tests against it you can have a lot more confidence that it has been written in a 'right way'.
Writing a desktop app like Atom automatically adds 40MB to your install size due to having to bundle Electron. It's fine for some stuff, but that's an awful lot of bloat. 
66 / (1.65 * 1.65) = 24.2424... 1.65 / (66 * 66) = 0.00037878... You mixed up the numbers in your example. They're correct in your code. (Also, here's [a working fiddle](http://fiddle.jshell.net/hek0mLgh/2/).)
&gt; critique my code Okay. Your code sucks. There you go. Happy? 
&gt; Since my objects are huge 1. Read about composition 2. Thank me later
Because it is written in the manual. &gt; The comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows: &gt; 1- If Type(x) is the same as Type(y), then &gt; f- Return true if x and y refer to the same object. Otherwise, return false. cf. http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3
on the `iterateCharacters`: instead of using 4 level nested ifs you could use something like if (!serviceData.hasOwnProperty("Service")) return if (!serviceData.Service.length || !(serviceData.Service instanceof Array)) return for (...){ ... } or just `throw 'servicedata is not array type!'` instead of `return`.
Thanks a lot. Misc.fileAction isn't one of mine, but still good advice.
But since functional preceded OO, wouldn't functional be the 'middle ages' in your metaphor? I know on this corner of Internet-land we *know* that convention and best practice must be entirely and fundamentally wrong. The argument from the original article is that it should justify barring candidates outright. So toxic an idea, a developer who worked on any large scale Java, C#, Python, or PHP is probably poisoned and is incapable of writing good JavaScript. That's the assertion that needs to be proved, not whether the industry practice widely adopted by most of the industry is fundamentally flawed. 
I can't express how grateful I am that you took the time to write this up for me. As someone that has no links to any programmers a response like that from somebody that obviously knows what they are talking about is like gold. I was unsure how to explain the unsatisfactory feeling I had when reading my code. Repetition and almost repetition is the perfect way to explain it. That is what was bugging me but I was unsure how I could go about doing it differently. Those print() lines were just there for debugging purposes. I actually continued a bit more on that function since I posted that. I'm going to completely scrap it later and restart trying to use what you posted. Here's how it progressed: http://pastebin.com/h6FnngiW As you can see, it is extremely repetitive. I'm going to try and work on it with the advice you have posted.
&gt; The author's stance is more nuanced than what you give them credit for; it comes down to avoiding hires that are fixated on class inheritance and have a "don't tell me what to do" attitude, which I think is at the core of the poor reception of his articles in places like reddit as well. To be honest, it sounds more like a rant he wrote one day after somebody challenged him on his anti-inheritance views. The fact that he justifies his opinion by raving on about how much experience he has instead of providing us with any actual reasons is just pathetic. He can't actually justify his viewpoint, so he throws out an appeal for authority and then goes on to basically say "If you disagree with me you shouldn't be hired". Sounds like he wrote some shitty code once apon a time and has decided to blame the tools for his mistakes. He criticises developers that are dogmatically set on one way of thinking, and then goes on to do exactly the same thing with his own viewpoint. I shudder to imagine what kind of monstrosities he's created in an attempt to avoid inheritance in places where it's a more elegant solution. There is nothing wrong with inheritance. It's a tool that is useful in some scenarios, and misused in others. The important thing is to know when to use it, and when not to. 
The behaviors should live in your actions, they are just triggered from your within your view. Your stores should contain whatever logic is required to maintain state and nothing more, the stores should have no data fetching logic or ui logic or behavior logic.
I'm not sure I understand the point. Js and css modules will be cached by the regular browser cache with the appropriate headers, and local storage is space limited and too valuable to use for caching code that the browser will cache for you automatically anyway. What am I missing?
I just glanced over the code in your first link. (like only the first 10 lines). Still I saw one thing i want you to know. if (typeof obj !== "object" || obj === undefined) { If *obj* **is** undefined it will also **not** be of type *object*. So the second part of that if condition is not needed.
Exactly this, I couldn't have said it better myself. Everyone jumps on and then the people who don't are idiots, non-believers or "are stuck in the old ways" because "it can be done because I've done it". Its an ecosystem that likely has a lot more traction than just the web but 90% of it is very short lived outside of a developers free time. Its "cool" and "neat" but thats as far as it goes.
@frambot, I don't mock the document. I just create a function to make trigger on keyup event (https://github.com/EvandroLG/slugify.js/blob/master/test/spec.js#L37) Did you get it? Thanks
I guess Heroku is not the best option if you want privacy of what I've understood from: https://www.reddit.com/r/webdev/comments/3lzouy/why_were_leaving_heroku/.
Hi /u/revilon_, this post was removed because /r/javascript is not a job board.
I've never heard of Eric Elliot. What's his deal?
Composition is as simple as this: function SomeType(greeter) { this.greeter = greeter; } SomeType.prototype.doSomething = function (name) { this.greeter.greet(name); } The crucial difference is SomeType does *not* automatically get the same interface as greeter. So, for example, you can't call someType.greet(). EDIT: Or if you want to see the same thing in Johansson's factory function style: function makeSomeType(greeter) { var state = { 'greeter': greeter } return { doSomething: function (name) { state.greeter.greet(name); } } } Notice we are *not* mixing greeter's methods into our own object. Instead, we *use* (call) an existing greeter object.
It is definitely not difficult for rudimentary stuff but is extremely sub optimal.
daedalus said "consumer services". Ikea provides us with pencils. You need developers to keep the worldwide pencil supply chain running.
FWIW he uses inheritance all the time, just not `extends`.
Thanks for your feedback. I've implemented it: https://github.com/CentaurWarchief/babel-plugin-global-require/pull/4. Just waiting to improve few things and I'll merge it. I'll give a shot for **systemjs** later.
You can try out react 0.14 Release Candidate 1. Create your ui state managing components with React.createClass. Then create your ui with stateless component functions. You could use redux for store for more functional goodness.
Ima let you finnish
&gt;"The best way to evaluate a candidate is a pair programming exercise." &gt;"Pair program with the candidate. Let the candidate drive. Watch and listen more than you talk. A good project might be to pull tweets from the Twitter API and display them on a timeline." I'm not a fan of this type of interview. Most programmers spend countless hours 'in the zone' without someone watching over their shoulder. It might work for a sub-set of programmers who actually don't have a problem having every step scrutinized, but most aren't going to perform well in this arrangement. To evaluate a programmer based on putting them under a spotlight is not usually a fair way to test a programmer's ability. 
Please give this man a cookie.
Clever visual effects using markup is so over as something to get hyped about.
Agreed 
Interesting, but I wish he'd talked about my favourite immutable data structure library, [Freezer.js](https://github.com/arqex/freezer). It: 1. Has Immutable.js style structural sharing but 2. Also has seamless-immutable style vanilla JS interop. Seems like it gives you the best of both worlds, but it'd be nice to see some other viewpoints on it.
I'm all about open-source and free software, so if you're looking for just charts, I'd have to say, [Chart.js](http://www.chartjs.org/). Canvas is more performant than SVG. If you're looking for interaction between charts, I'd say, [dc.js](https://dc-js.github.io/dc.js/). I chose not to use Highcharts because you have to license it, for a pretty [hefty price tag](http://shop.highsoft.com/highcharts.html) in some commercial software. I also chose not to use [Google Charts](https://developers.google.com/chart/?hl=en), because they require a internet connection and would not be suitable for offline use or electronic conventions (that day sucked)...
When I run the query I do get a return value of 10. I tried to replace the current code with yours but now I get another error at line 407 with the same thing. Screenshot: http://imgur.com/yN2vKv5
Plain javascript should do this just fine. Hook the even handler on the input up to a function that changes the font-size css property of the p tag targeted with an ID. Using some jquery here, but you don't have to. Didn't test this, but something like the following: $(".slider").on("change", function(){document.getElementByID('ptag').style.fontsize = this.value});
oh okay, sorry then, i thought the cost of life was comparable
Good call. Would you consider length differences to be a frequent case?
Canvas is more performant but what about styling? You'd miss out on the benefits of CSS wouldn't you? How easy is it to make some interesting visuals rather than just changing some colours? Just looked at dc.js and it's pretty awesome, any idea how that compares to HighCharts? I liked how Highcharts could do ajax requests on large datasets for just the slice you were interested in, normalize it and also stream realtime.
filePath: "data/Service.json". Avoid hard dependencies in your class, this prevent it from being reused and can make it harder to test with dev/stating services or mock data. setFilePath: function(_) { this.filePath = _; }.
Care to post your code?
That's really neat :) Will add it to my list, bit sad that it's only Linux supported though.
https://github.com/JeffreyCheng92/BenchB-B/blob/master/app/assets/javascripts/bench_bnb.js.jsx Sorry for the link, not sure how long it would take me to indent 4 spaces for every line. Unless theres a &lt;code&gt; tag &lt;/code&gt;..
Shitty 10 square meter room where you share kitchen/bathroom with 3+ people will run you 500+ usd a month (usually + internet and electricity) and thats usually not very nice standards. A cheap haircut is 50 bucks. 15 usd a day for food will not have you eat well or varied or much meat. It will have you eating noodles, bread etc and not nice dark bread cause thats 4+ dollars just for one loaf of dark bread. If you live in any of the bigger cities and want to live alone and central look at 1000 usd a month as a MINIMUM just for a place to stay, 1400 usd will get you a pretty nice place &lt;40square meters, might have bedroom, might be bedroom in livingroom and prob include internet or heating. Want a pair of shoes that dont suck? 100 usd. A cheap dress shirt? 35 usd. A very cheap blazer ? 60 usd. And this is with current exchange rates with a very weak krone compared to usd.
If you use reddit enhancement suite, it has a button that will auto indent. There's also things like jsfiddle and codepen.
Break your objects down into chunks that make sense. var Engine = require('Engine'); //CommonJS module, require is like an import var Wheel = require('Wheel'); var Window = require('Window'); var brokenWindow = new Window(); brokenWindow.isBroken = true; Car = {} Car.engine = new Engine(); Car.wheels = [new Wheel(), new Wheel(), new Wheel(), new Wheel()]; Car.windows = { front: new Window(), back: new Window(), left: brokenWindow, right: new Window() } Car.colour = #F00; Something like that should provide some good ideas for how you can approach it :)
Funny, but the author's opinion on this is actively harmful, and based on a sweeping generalization. Incidentally, he spends 1,023 words getting his opinion out before cutting to the chase.
What is the case usage of immutable data structures? Why would I need/use them?
It's explained in the article. Fast diffing w/ libraries like React that have virtual DOM with a method like shouldComponentUpdate: function (newProps) { return this.props.something !== newProps.something; }
Why do they have to be immutable to be able to do all that cool stuff?
Because mutable data returns true for ===. To check for equality on mutable data structures you have to use a .equals() type of function that would check equality of the objects contents - this can be expensive. With immutable data, any updates to the data will always return a new object, so you can safely use === to check if any part of the object has changed.
I'm not entirely sure what this does.
One other thing that is problematic is the lack of optional static typing. Add that and you have a pretty good thing.
When I use the console.log(row) it also returns undefined. 
Looks like a cool library! I think the key difference is that libraries like Immutablejs and Mori implement some optimizations like using hash map tries under the hood for efficiently modifying deeply nested structures. It's able to perform update operations in O(log32N) complexity whereas Freezer appears to perform a shallow clone on the mutated object each time 'set' is called (O(n) complexity) -this greatly simplifies things, but could potentially be computationally expensive if there are many nodes (like in a very large list for example). Update operations in Immutablejs are also memoized so you'll always get the same reference returned to you if you try to update a value with the same value. Freezer will trigger an update event each time (potentially causing a rerender) as well as shallow cloning the node. Also Immutablejs is more of a "dumb" datatype implementation, whereas Freezer's scope seems to encompass some state management also (with event listeners, etc). It seems to be more in league with libraries like [Baobab](https://github.com/Yomguithereal/baobab) or [Redux](https://github.com/rackt/redux). All in all a very cool library!
Anything SVG + JS is all good in my books, but this is one: damn nice.
There really isn't a proper way to parse them; you can use only a rule of thumb such as it needs to have an @-symbol (technically not needed, but more or less enforced by every server) and that to the right of it there needs to be a dot (usually top level domains don't accept email) There's apache common-lang, but it does not support the new top-level domains... The only true way to verify that an email address is valid is to send an email to it and expect a reply or click - through. 
Take advantage of the event delegation, and add the click listener to the parent element. In that case, get your elements by the .answers class name
Was interested, but the audio quality... 
Incredible, great work as always. Thanks for annotating your code!
Javascript has no block scope (Fixed in ES2015), only function scope: this inside the definition for themeObject does not refer to themeObject. There's a few solutions for this, easiest is to move the `getUniqueId` function to the global scope. http://jsfiddle.net/tqczdt8o/2/ This also might help http://blog.pivotal.io/labs/labs/javascript-constructors-prototypes-and-the-new-keyword
We have great articles on JavaScript and ClojureScript today, as well as tools and talks. Enjoy your Monday folks! Also, at Redradix School we are starting a training course on advanced React development. Check the course here http://school.redradix.com/courses/React and join us if you are in Spain, Madrid.
getUniqueId: function() { return **this**.id +'-' + Math.random().toString(36).substr(2, 16); } Of course you'll need to populate the id first, as it doesn't appear in your object as it stands...
Hint: you probably want to use document.createElement() in a loop over your text, and create different DOM based on whether the word matches or not. Then use appendChild to add them to the page.
Because `this` in the object literal is the same as `this` outside it. It only becomes a different `this` binding when inside a function definition. var a = this; var b = {c: {d: this}}; a === b.c.d; // true 
You could try edge tracing
Just remember that Linux/OSX is bugged(scales the render wrong) and has been for some time, not sure when it'll be officially fixed.
So if you're using lodash, you'd more than likely drop it due to overlap/incompatibility if using something like immutability.js or mori? And these immutable data structures are mostly useful for things like speed gains when comparing deep equality, saving on memory when dealing with many similar instances(struct sharing) and reducing some side effects? But if using quite a bit of third party libs to interact with your data you may not benefit so well? I suppose you'd run into problems if someone made a postprocessor or a variant for say Haxe's JS target that would convert bits like `array[0]` to `array.get(0)` effectively switching the code to immutable.js? Specifically the problems that might occur could happen with third party libs written with mutable data structures in mind?( I have no idea if this conversion would cause problems or not, just assuming :) ). Am I best to just keep immutable.js/mori and similar libs on the side until a performance need for extra speed or less memory occurs then refactor for it?
Everyone here loves doing your job / school assignment for you. /s
How does this scale? I can't imagine users being thrilled about storing a few gigs of data locally for high traffic sites. Maybe I am not seeing the usecase?
I didn't say it was a block. I said block scope http://stackoverflow.com/questions/17311693/why-was-block-scope-not-originally-implemented-in-javascript
FFS, do you really have to be that guy? I'm simply looking for guidance not someone to write the fucking thing for me. If I wanted it written for me I'd have posted to stackoverflow!
thanks for the hint....
this sounds simpler!
Where is Flow?
This one: http://flowtype.org? I'm not sure if that would qualify as a separate language?
This is awesome, great work!
I think you're taking this way overboard than it needs to be. You're treating JS like a traditional oop language when it's not. But since this is new to me what you're saying: Sprite has this in it's "constructor", calling the "super": Container.call(this); and Container's "constructor" again calls: DisplayObject.call(this); and again with DisplayObject: EventEmitter.call(this); Finally we get to the end of the chain: function EventEmitter() { /* Nothing to set */ } So where would OP start here?
So what would the right way to do this in JS be? In classical languages you'd typically use traits or interfaces. 
The shadow puppets are fucking awesome.
Just because you are using an entity component system doesn't mean you can't ever use inheritance/OOP at all. The purpose of an ECS is to not use inheritance when crafting your actors/entities and instead combine components to create your entities instead. If anyone ever tells you that you can't use OOP in an ECS, they are pretty stupid.
this is a clear promise example thanks a lot. now im getting `unexpected token '='` from `let errormessage = await trybuild();`, even on the babel website repl. but its probably my fault, im running old node and old babel probably. i upvoted you anyway! thanks.
&gt; JavaScript is a class-free, object-oriented, &amp; functional programming language. It eschews classical inheritance in favor of prototypal inheritance. Just because we use the word "class" doesn't mean it isn't still prototypal inheritance. In fact, let me see if I can appease the ES6 class critics with nothing but a jargon switch: prototype Point { initialize(x, y) { this.x = x; this.y = y; } toString() { return '(' + this.x + ', ' + this.y + ')'; } } prototype ColorPoint delegatesto Point { initialize(x, y, color) { super(x, y); this.color = color; } toString() { return super.toString() + ' in ' + this.color; } } let cp = create ColorPoint(25, 8, 'green'); cp.toString(); // '(25, 8) in green' This perfectly describes the prototypal nature of the objects and their relationships, yet all I did was change the words class/prototype, extends/delegatesto, new/create, and so forth. There's no classical inheritance happening here. ES6 classes *are* still prototypal. &gt; Many believe prototypal inheritance to be more flexible and freeing than classical inheritance due to its less rigid nature. The people who say that (a la Elliot, Johansson) don't understand the difference between composition and multiple inheritance. The thing they find rigid is single inheritance. The thing they find freeing is multiple inheritance. Neither of which has anything to do with classical v prototypal.
Commented in a tweet to @rauschma, but figured this is a better place for discussion. I was hoping for more objective technical reasons why they aren't awesome. What I'm seeing in this repository is a lot of curated resources philosophically against OOP, not the actual implementation. While the philosophical debate can be interesting, I think in this context it's less useful. Defining constructors in a class-like fashion has been proven popular in JS; evidenced through the mass adoption of libraries like React, Ember, Backbone, Angular, etc. These all implement their own declarative inheritance interface, it only makes sense to provide such a feature intrinsic to the language. Objective problems with the implementation: - Classes are currently missing a way to define properties, which I find is a huge barrier to using with existing libraries. - Inconsistencies between Firefox and Chrome implementations. While Chrome doesn't mind if you omit `constructor() { super(); }`, I found Firefox complains and requires it to be called (at least true for Custom Elements). Consider the following examples: ES6: class MyElement extends HTMLElement { createdCallback() { console.log('The element instance', this); } attachedCallback() { console.log('The element is now in the DOM'); } detachedCallback() { console.log('The element has left the DOM'); } } ES5: var MyElement = Object.create(HTMLElement.prototype, { createdCallback: { value: function() { console.log('The element instance', this); } }, attachedCallback: { value: function() { console.log('The element is now in the DOM'); } }, detachedCallback: { value: function() { console.log('The element has left the DOM'); } } }); Yes please ES6!
No one wants this because it would drastically increase your page load times. Each import would need a request, and then those requests might have new imports that need more requests, etc until all your js finally loads, and then your app can finally run.
Ah, Backbone does some magic! Thanks! edit: I say this without sarcasm, btw.
&gt; Each import would need a request If it isn't included in the larger package. That is also not as huge a concern as it sounds when you account for dependency flattening.
Super useful as an NPM author, but also ignorance is bliss when you realize what a mess you've published.
I didn't say that ES6 class syntax WAS classical inheritance, just that it unnecessarily complicates an already misunderstood feature of the language... but, again, many people have a problem with the style of OOP JS which uses constructors and "new", which is partially why I went into that. I admit, it could be much more clear. I want people to add to it and contribute. The only reason I made it was because I couldn't find anything like it already on GitHub. I think the main problem the linked authors have with classical inheritance is actually deep, rigid hierarchies, not necessarily single inheritance.
&gt; I think the main problem the linked authors have with classical inheritance is actually deep, rigid hierarchies, not necessarily single inheritance. Unfortunately some of them (Eric Elliott) [solve this by using multiple inheritance](https://github.com/stampit-org/stampit), and others (Kyle Simpson) solve this by creating deep stateful object (rather than class) hierarchies.
Yeah, it's kind of an infectious virus. (There's really few things worse than seeing people inherit from React components.) Stateless function components in 0.14 are great so far, and only increase my thirst for [stateful module components](https://github.com/reactjs/react-future/blob/master/07%20-%20Returning%20State/02%20-%20Module%20Pattern.js). So much easier to work with.
I don't know, we could sit here and say that everyone trying to do OOP in javascript are doing it wrong, but I'm not sure that's particularly useful. The sugar-less OOP paradigm in javascript is ugly and verbose, which is precisely what the new class syntax tries to alleviate. In ES5, there's at least 4 different ways to create a "class"-like object, and it's very easy to not understand the subtle differences between them, at least unifying the different methods with some sugar seems like a win to me. 
getBoundingClientRect didn't work, but getting the parent node width is good enough for me: stageSize = { x: s.node.clientWidth || s.node.parentNode.clientWidth, y: s.node.clientHeight || s.node.parentNode.clientHeight } It did require wrapping the SVG but what is life without a little extra HTML?
heh. semantics.
NPM flattens much of the dependency chain directly without an intermediate step.
I was basing this opinion upon this data, which may not be accurate as far as projecting future efforts: https://github.com/Fyrd/caniuse/issues/1869
It can be funcitonal in the way that the argument passed to the function is not altered. Instead, a new object would be returned which does not include the property you want to delete.
Ahh yes, but then technically you haven't deleted anything. ;)
The argument here is logically broken. JavaScript doesn't "eschew" classical inheritance, we've known from the start that prototypal inheritance can be used to implement classical inheritance. Prototypes gives you more flexibility, and that isn't being taken away. However, it has long been best practice to use prototypal inheritance like classical inheritance - ie not modify protoypes after you have instances - **because JavaScript does use classes behind the scenes as a performance optimization**. You don't get the fast engines you have today without classes, and you don't get to use prototypes to their full flexibility if you want to use those fast engines. &gt; Many believe prototypal inheritance to be more flexible and freeing than classical inheritance due to its less rigid nature. Ah, "many", the word people use when they want to avoid making any refutable claim. Here's my claim: I've never seen a single piece of code or library use prototypes to their full flexibility, and I've never seen a single style guide recommend doing so. I have, however, seen dozens of guides specifically tell you to *never* use prototypes to their full flexibility. &gt; The ES6 class syntax, constructors, the new keyword, etc. are ideas taken from the classical inheritance model to make programmers coming from languages like C++, Java, C#, etc. more comfortable... So? If you can make programmers more comfortable without downsides then that sounds like a great idea. &gt; ... and do not really belong in JavaScript. What's "belong"? It sounds like you just don't want the language to change. &gt; there is a growing movement among developers, both within and outside of the JS community (Ex: Composition in Golang), to shift away from inheritance in favor of object composition. Native classes don't stop you from exploring object composition in JavaScript. Are you saying you want them to add composition sugar too? &gt; ES6 class syntax is essentially syntactic sugar that will end up obfuscating the true nature of JavaScript and confusing the next generation of programmers learning it. Again, prototypes can (and now do) implement classes. It isn't obfuscating it, it's subsetting it. If a new programmer learns classes without learning prototypes, then their knowledge won't be flawed, they just won't know how to use prototypes as well - which nobody does anyway. &gt; â€œIf a feature is sometimes dangerous, and there is a better option, then always use the better option.â€ --Douglas Crockford "If there is a better option then use the better option". No shit, the problem is figuring out which is the better option. This is why people have selective hearing when it comes to Crockford.
Right, this is the approach I was taking. I can't see another way with vanilla JS besides using a library like ImmutableJS that implements tries etc.
The most important thing about hiring any javascript developer is the ability to self teach and learn new things quickly - period. Javascript libraries are born and die on an almost weekly basis the ability to keep up and assimilate new frameworks and techniques is more important then `do you use classical inheritance?`. I'd much rather throw something at a potential hire that they don't know anything about. If they dive in and are enthusiastic about figuring out the problem without knowing anything about it (I don't even care if they get very far right away), those are the devs I want. If they freeze up and get frustrated without doing anything then that's a red flag. 
So in other words, op could use a function as a constructor to solve the problem.
I'm a bit late, but the real winner is `["last"] == "last"`. Wait, let's make that `[[[[[["last"]]]]]] == "last"`. I was utterly pwned a while back by this. Cue lint and no == ever again.
I should have been more nuanced. Inheritance is *usually* bad, particularly compared to the alternatives. There are cases where it really is the best tool for the job, but those instances are rare, especially in a flexible language like JavaScript. &gt; But you can easily write brittle code using any other technique. True, and this was one of the arguments in favor of `goto` and against structured programming. If we have a better way to do something, then we should take it.
https://github.com/okbel/basicAPI :D have fun! 
I'm not sure exactly what the end goal is but you can do this easily using jQuery .attr method. var myThing = $('a').attr('href'); console.log(myThing);
If you are using NPM, I don't see why you are trying so hard to avoid using grunt/bower/gulp.
If you want to really learn about pacman, the person who has done a lot of excellent work in HTML 5 is Shaun Williams. http://pacman.shaunew.com/ He's done research on a decompiled version, showing the ghosts patterns of movement and how the speeds were managed in the original game using integer arithmetic where the ghost speed was 11 vs pacman speed of 10 (IIRC). All in javascript. (Grammar edit)
hey @thebigkick thanks for the help. to be honest , i dont really know much about JS, i just know some basic java. Ill be honest with you and please dont judge me. Our professor always post exam links on this website, i have to login first, click the link , enter the password then continue the exam. but the problem is the exam has a timer of 55 mins, it is not quiet enough for me. and after 55mins, it automatically sends the attempts .. So i was thinking if it is possible to bypass that , maybe anonymously get the exam first , then do the test again.. i know this is wrong, but the professor is lazy enough to post the test on homework website, thats why im having this evil thoughts.. ill post the whole code: &lt;td class="cell-assignment-name"&gt;&lt;a href="javascript: void 0;" class="pwd-req assignment-title" data-timelimit="55" data-timeleft="3300" data-late="true"&gt;Exam II&lt;/a&gt;&lt;a href="javascript: void 0;" class="timed-assignment old-icon-time" title="Time Limit: 55 minutes"&gt;&lt;/a&gt;&lt;/td&gt;
The articles also tend to dismiss the whole idea of having classes in JS based on their current state, ignoring the fact the specification can live and the VMs aren't set in stone. Google's Andreas Rossberg's [Strong Mode proposal](https://docs.google.com/document/d/1Qk0qC4s_XNCLemj42FqfsRLp49nDQMZ1y7fwf5YjaI4/view) contains ideas like immutable classes with proper sealing, instancing and frozen properties. While class might be used for cleaner syntax right now, there's potential for optimization and they can serve as a good base for many convenient features in the future.
Not sure if this is helpful, but you could implement a omit function like in lodash/underscore, that omit own properties, and returns a new object? 
&gt; Having Factory functions is the worst boilerplate of the century Can you elaborate? Factory functions are usually much simpler than classes. Unless you're referring to some other type of factory function (like the ones used in Java). &gt; Modifying the prototype chain "because it's flexible" will lead to maintenance nightmare and spaghetti logic in a code that might look nicely organized. Mutation is the root of most Evil. Agreed. I've had the pleasure of working on codebases making heavy use of `Object.create` and other nonsense, and it's pretty awful because of mutation, shared state, and the inability to statically analyze the code, resulting in nearly impossible-to-trace bugs. It's made worse by the way people do it in JS, where an object can be easily put into an uninitialized, semi-initialized, or fully-initialized state, and you have no easy way to know which one, and no way to know which one you even want. Rabble rabble rabble.
I don't get it. ES6 classes are just sugar for prototypes, not a new thing. And having sugar is good as it formalizes common patterns. I actually like that it was done this way instead of bolting on another high concept onto a language like it would have been had they gone with C# style OOP. We dodged a bullet here.
**Distribution.** I want my application to run on my local exactly as it runs on the server. I want the freedom to send a couple of files to anybody and simply open a single file in either the browser or node for things to execute immediately. For my personal project this is little more than a convenience since all of my users are developers (probably better developers than I am). On the job though this is absolutely necessary (although in most jobs I am forced to use a build process anyways). Most of the people you need viewing your work from the job are product owners, management, and other decision makers that are not going to dick around with a build process. Everything is dandy if they can just stare over your shoulder while you drive a demo, but the moment these people go remote or need to drive their own demo you have a problem. Now you have to have some internal server to push to and perform a separate build on and then monitor the status and version of the remote build versus the latest and greatest that you are actually working on. In organizations where everything is tightly coupled I feel like I am spending more time building than actually writing code.
I think you're thinking about this the wrong way. The `href` attribute of `&lt;a href="javascript: void 0;"&gt; &lt;/a&gt;` is `javascript: void 0`. You can grab that and store it in a variable but it's not going to be particularly useful.
Can I DOS this by requesting sindresorhus's and substack's lists over and over? :P
Having everything in separate files is nicer for development. The per-file overhead is a lot smaller with HTTP/2 and it also supports Server Push. If you request the document and there isn't a cookie, you get the whole package without even asking. If you do have a cookie, you get the files which have changed since your last visit (again, without even asking). If only one small file has changed, you'll only get this one small file instead of a completely new bundle. So, it would actually improve the loading time.
Well, first of all, the opt-in to strict mode is unnecessary if you're using ES6 modules, which you should be. ES6 modules are always in strict mode. You're correct that autocomplete is more likely to work with classes, but that has little to do with conceptual simplicity, which is what I'm referring to. Anyway, if you measure simplicity by lines of code, then: const Foo = () =&gt; ({ bar() { console.log('bar'); } }); Personally I might prefer using the `function` syntax since it's more straightforward, but I guess if your definition of simplicity is "fewer LOC", then sure. Anyway, just a few reasons why factory functions are simpler: * No need for `this`, one of the most confusing parts of the language. And even if you do use `this` then you have automatic binding of `this` with ES6 method shorthand syntax. * No need for prototypes, the other most confusing part of the language. * No temptation to use ES6 class inheritance. Hopefully I don't have to explain why inheritance is bad, but whatever: brittleness, accidentally overriding base methods and breaking dependent methods, no encapsulation, high coupling, implicit shared state, `super` complexities and browser inconsistencies, etc. * Ease of true encapsulation with closures. Possible with ES6 classes, but not fun. In practice you will either use naming conventions or have convoluted code. * Composition, behavior-sharing, and state-sharing are all simple to do and typically safe. Keep in mind that I'm referring to conceptual simplicity. With factory functions, all you really need to know is how to define a function that returns an object literal. They do have their downsides compared to classes, which are mainly caused by the fact that they aren't personally blessed by the language creators: performance and static analysis. The story would be different if the pattern had its own syntax.
Ew. I am using pixiJS, and I would not do stuff like that. What is simpler is: Have an object that has a sprite. Bam. and that is sprite is a new PIXI.Sprite, with all the data needed. No need to completely muddle the waters between objects and pixi entities. 
What's going on?
yeah . . . I get you. But modern programs don't generally care. And these tools aren't generally going to be used for high demand programs that need to do their own file or memeory system maintenance. I mean I think back to about 09 with people I knew bitching about how bloaty firefox was getting because it was taking 150mb of ram on their 4gb. Drive space and ram, not to mention maintenance, are no longer at a premium. Programs are built on high-level langs like js and python with their automated garbage collection and all. And end-users of the internet consumer generation are not even remotely concerned about system or application stability... such is the benefit of modern OS's paired with just about any high-level lang. So considering that the target demo is a person with 8g ram and prob 4t of free drive space, 120mb is pretty chump.
&gt; the opt-in to strict mode is unnecessary if you're using ES6 modules Big enough for classes or factory functions doesn't mean it's also big enough for modules. A good example are all those demos on CodePen. &gt; No need for `this` Well, you still need `this`, if you want to refer to one of this object's properties. &gt; No need for prototypes Not sure why you mention this. &gt; No temptation to use ES6 class inheritance. Inheritance is a decent fit for many scenarios. It's also extensively used in large software projects like web browsers or 3d game engines. Evidentially, it works fine. Just because there is some sort of inheritance does not mean that you have to put everything in some gigantic hierarchy. &gt; [Privacy] Yes, but I'm sure future revisions of the spec will address this. I'm also not sure if I'd call closures "conceptionally simple". Compared to some privacy modifier, it's really hard to explain. For example, in Dart, you only have to add a leading underscore to make an identifier only visible inside its library. That's it. Now you know how privacy works in Dart.
`&lt;script type="text/javascript" src="js/SmoothScroll.js"&gt;&lt;/script&gt;` Having IE flashbacks
It's funny that no one has a problem with how the new syntax will affect *them* directly. It's all a bunch of arrogant handwringing about how everyone who isn't as smart as the authors are going to get confused. 
I am running from localhost. When I access the php file, it works fine. It doesn't work when I use load().
I like the library a lot, but won't be able to use it because of all the dependencies. Do you really need all of underscore? Could you at least include only specific functions? I know lodash has that option. I don't have underscore in my codebase currently and I don't think this library is worth the bloat for me. Your generic `convenance` library is another few hundred lines. A simpler check could be done in a few lines.
I found the error, had nothing to do with the configuration of the server.
Awesome, thanks! Ended up doing something pretty similar, works alright and like you say is still functional, at least from a reasoning perspective which is what matters to me :p.
&gt; [120 megs] feels like a lot. That's because it is. The Java 5.0 runtime environment only added about 10 MB to your installer, for example. With 7.0, it was about 25 MB or so. This included Java's enormous standard library in its entirety. Having said that, I do think it's worth it. You probably won't have that many of these apps installed. So, it won't actually hurt that much. This is also the perfect answer for doing business-critical internal "internet" applications. Instead of repeating the mistake of doing a company-wide IE version lock-down, you can update each app and its "browser" at its own pace.
You should look at tint2: https://github.com/trueinteractions/tint2/
Why not just a zip file that has an index.html at the root. That would be great. You should be able to send that and run it anywhere.
I'm curious, I take it nesting elements within another element containing a string is usually something you'd want to avoid?(besides perhaps &lt;em&gt;/&lt;strong&gt;/etc). Are there any situations where `&lt;p&gt;string_original&lt;/p&gt;&lt;span&gt;string_inserted&lt;/span&gt;&lt;p&gt;string_original&lt;/p&gt;` is better than `&lt;p&gt;string_original&lt;span&gt;string_inserted&lt;/span&gt;string_original&lt;/p&gt;`? I guess specificity happens with the latter nesting the span, but beyond that?
You should read this to get a better understanding of the differences between classical and prototypal inheritance, because based on your post I really don't think you get it. https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a
Use your own words. "In class inheritance, instances inherit from a blueprint (the class), and create sub-class relationships. In other words, you canâ€™t use the class like you would use an instance. You canâ€™t invoke instance methods on a class definition itself. You must first create an instance and then invoke methods on that instance." How does this contradict anything I said? How does JavaScript shy away from this? It doesn't.
You _can't_ do this as is. Promises are designed to only ever resolve once. Introducing anything that utilizes `.then` and resolves multiple times is an anti-pattern. You'll eventually be left looking at some code and have no idea if it's a promise or "provent", which is just a nightmare. I'd suggest replacing `then` in your API with instances of Array methods, which effectively turns this into a light version of something like rxjs. These methods would then return promises that you could chain: click .map((p) =&gt; p.nodeName) .then(...) click .filter((p) =&gt; p.matches('.foo.bar.baz')) .then(...) And likewise, don't overload the usage of `reject` __tl;dr__ -- Overloading APIs is bad. Treat this like what it is -- An event library that returns Promises.
* Replace the words with underscores in an element with a class for targeting via event delegation on the parent node that they're all nested in. * Have each of these elements have a `data-ref="some_unique_id_value_inserted_via_JS"` attribute, or perhaps could use ID attribute here, it's purpose is to know what group of possible answers belong to it. * Your event listener can then filter the click event to the underscore classed elements and check the attribute to display the dom overlay element with possible answers(either dynamically created when triggered or toggled visbility). Likewise any other event listeners will be able to handle the removal/hiding of the question popup. * All your answer lists can be predefined in json/object literals, use what ever structure works best for you like `{answer: "answer_value", fakes: ["val1", "val2", "val3"]}` or `{one: { val:"answer_value", answer: true }, two: {val: "val1", answer:false } }` each of those assigned to whatever identifier you use(go with the word/string if you like, makes cheating even easier though :p). * for the popup just use event delegation again with a listener on that element or if you're not creating/replacing dynamically and toggling, on the parent element with all the answer groups nested. Do a compare with your data and user input and handle accordingly.
&gt;How does this contradict anything I said? You think that classical inheritance in ES5 involves messing around with prototypes. Which is itself a contradiction in terms, because classical and prototypal inheritance are different. Hence why I linked you to the article.
RequireJS?
this is important
I'd read through their docs to find out more about it. jQuery is a JavaScript toolkit. It gives you a lot of pre-baked functions that make life easier (to a point). Instead of using $.getJSON, you could use the native [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) -- getJSON is basically a wrapper that makes the api easier to work with. 
Many decent frameworks do almost all of it for you. For example, check out Django Rest Framework and its ViewSets. All you have to do is write the models, which is a good exercise of understanding the database schema, discovering issues, and authoring the definitive authority on the schema. However the one-size-fits-all API made available is generally just a tool and/or starting point. Most meaningful projects will require customization beyond that to be done properly. But having a full generic API into the database after very little effort is quite useful.
Why Redux vs. Vanilla Flux? The examples don't show anything Redux specific. Also, I thought everyone has moved past document stores in favor of more reliable solutions like Postgres. Are we back to trusting document storage?
Honestly I would do this in R using the JSONLite package and dplyr. https://www.opencpu.org/posts/jsonlite-a-smarter-json-encoder/ I'm not saying you *should* do it this way though. Just giving another option. I'm not sure what your co-op position is for (if it's webdev, maybe R isn't appropriate).
you cannot load resources on a page from another origin (website). so if you open a webpage, that webpage can't open some rando link - only links from the same domain. 
There is a python project Eve, that is doing exactly that.
I would love to have exactly this for Node.js. I think it's a great starting point to get an app up and running, especially if you need to rewrite the front-end for an older site. I'm not making any promises about time, but if you do share a project on github I might be able to contribute. 
There is a playable version at the link above and I was able to do a view source just now. It's not minified and nicely commented. I know he got a C &amp; D somewhere along on his journey. Also looks like he's got his own repository here: http://pacman.shaunew.com/redmine/projects/pacman/repository
&gt; I understand there are ES6 modules, but nobody is supporting this. If you're willing to engage in a build system, which makes your life startlingly easier, then you can just run your stuff through `babel` and receive es5 for your es6 modules.
Could you elaborate more on the document stores(NoSQL, storing JSON schema's like Mongo right?) vs Postgres(Relational like SQL if I remember but also supported storing JSON)? If you have any good articles and such to link to that's also helpful :) I'm mostly focused on the frontend and bit of backend+devops but haven't really had time to explore the database side of things much. I was at an interview recently and I talked about Mongo, Neo4j and I brought up what little I knew about Postgres but the interviewers laughed in a mocking sort of response when I mentioned that. They were very much into their Microsoft stack with SQL, not sure if they actually were trustworthy experienced seniors or just their culture/roots(they also shut down node.js on being JS and single threaded, lack of typing etc.. and AS3 due to it's bad reputation, despite it's popular use/value in game dev on mobile). I've also been interested in looking into databases like OrientDB but Neo4j has a really nice query language(Cypher) for graph based data, OrientDB had some sweet features though and might be a good fit for most projects. Haven't looked into others like RethinkDB, I'm just so caught up on other parts and trying to land a job before I get time to understand these all better :)
There's really nothing unreliable about RethinkDB. The problem isn't with document stores; the problem is with Mongo and its decision to be a cache rather than a database. Rethink actually persists your data to disk. Mongo uses Big Data Web Scale Technology (something called `/dev/null`) to persist your data.
I think Breach/Thrust achieves that? But you can't really avoid the huge filesize for offline apps that use Node + a stripped down browser. You got runtimes, rendering engines such as Blink etc, I'm not entirely sure what the bulky parts are but I'm assuming they're not easily avoided if you want this type of solution to create desktop apps. You're choosing Electron or NW.js on the basis that your product is of value to the customer that they have no problem with the download size of around 100mb(Check out Steam with gamers, they have no problem here downloading gigs, this is nothing). In exchange your developers/team don't have to maintain ports in other languages and complicate things. You can minimize the platform specific code(OS integration) while the majority of the frontend/backend will work much the same as your browser version(although you're free to provide/maintian a different experience). Your testing/tooling all remains the same for a productive pipeline pretty much, rendering is more consistent. This is great for enterprise solutions where IT locks down browsers/tech that can harm your ability to deliver value(some clients like hospitals still use IE8). The consistency and shared code base will help you deliver quality code faster, provide fixes sooner, onboarding/documentation better, hiring or losing talent also has less cost/impact, etc. So long as you're still catering to your demographics needs and providing the value they need, this is a huge win for your business side of things. If you want to achieve similar benefits for your team/business while delivering smaller file sizes and better native performance, you can find more appropriate solutions such as Haxe language, only drawback being finding talent will be difficult and you'll more than likely hire devs skilled in similar languages that are willing to learn Haxe and get familiar with it's ecosystem.
if you just want to run your code locally you can get a chrome extension, search for CORS or "cross access resource sharing" if it's your webserver, then you can lookup how to allow CORS on your backend, i did this with express and it was like one line of code.
Take a look at Sequelize http://docs.sequelizejs.com/en/latest/ 
Server-Push/Server-Hint support would be neat. As in if I have NGINX with this feature on, if there were a way for Webpack to integrate so that requesting module/chunk dependencies from the browser I can avoid roundtrips and send all the ones needed with that request. Example, You go to mysite.com, NGINX fetches the html to send but also knows to send relevant assets to the client as well. This might only be above the fold/critical assets, or all image/js/css depending on site in question. Once the client parses the html, the files they'd request are already being pulled in or cached(server-hint), thus they don't have to request the server for them and get the assets sooner. If the user navigates to another page in a SPA, webpack can async request the needed dependencies, and those dependencies can fire additional async requests right? With server-push or server-hints, that one initial request can be looked up by NGINX as having all other related dependencies that'd be requested once loaded and send those all over in parallel. JSPM has done something like this with depCache, rather than using server-push/server-hint it requests all related assets(via dependency graph) at once to take advantage of HTTP/2 multi-plexing. This is not as great but still useful, can manually push/hint the linked js script in the html response. If I'm mistaken and Webpack caters to this than awesome :)
[**@fisherwebdev**](https://twitter.com/fisherwebdev/) &gt; [2015-07-01 16:47 UTC](https://twitter.com/fisherwebdev/status/616286955693682688) &gt; @dan\_abramov BTW, I asked for comments on Redux in FB's internal JS discussion group, and it was universally praised. Really awesome work. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
That time should be spent learning a proper ORM for the language of your choice.
This may be a bit advanced for you, but look at [Lodash](https://lodash.com/) for common array and object iteration functions once you receive the xhr data.
for php there's [arrestdb](https://github.com/alixaxel/ArrestDB) - super simple plug-n-play rest api. in my opinion, if you ever get that nagging feeling that you've reinventing the wheel... I don't regret the times that I've flown headfirst into making my own frameworks because I learned so much. however, solving problems that have been solved before (and probably solved more efficiently and comprehensively) isn't exactly practical. on the other hand, progress requires us to start fresh sometimes, and you may have hit on a new approach. so, my vote is: do it if you think it'll be a fun pet project. if your main motivation is becoming more efficient, find a tool that's already been developed and maybe you'll feel like contributing that project. 
Pretty much how I'd do it. Probably without the `data-target` as you can just use `.closest` and/or `.find` depending on the code to expand
What corporations use Meteor? Why would any large-scale application choose to lock themselves into a stack like Meteor when they could use any other hosting option and have full control?
No, it isn't. Because when you use classes you are creating new objects from a blueprint (the class). If you build a house and then change the blueprint, the house won't be altered as a result because it is already built. Prototypal inheritance creates active links to other objects, if you change one then you change any copies of that object. If you create a "class" that has a prototype, then its not behaving like a class. It passes its methods to other instances of itself through the shared prototype that is automatically added by Javascript. That means that you can alter the methods in the original "class" and those changes will propagate to the other objects after they have been created. i.e. if you draw some lines on your blueprint you would give your already built house a garage. Classical and prototypal inheritance is not the same thing.
Meteor may know best what would be the ideal hosting for it's users. It may not be full featured yet, but it's just starting. At the end of the day, it's just a good way for them to make money, like Taylor Otwell and laravel forge. Meteor is never going to sell it's framework, so it has to sell a good product, which would be hosting and support. Why hate them for it? I personally want them to succeed, so they need to make money. This is a great way to make money and not be shady, it's not like they can survive on VC forever.
In general, relational databases like PostgreSQL or MSSQL (anything that uses sql) are for relational data and NoSQL bases for non-relational data. For instance, if you have a website where you have users and posts and comments, you would use a relational database, because the data is naturally relational (Users create posts and comments etc). You would use a relational database here because SQL would make your job super easy (using joins and such you can efficiently and elegantly query all necessary data), while NoSQL bases are not well-suited for this. NoSQL databases are usually meant as document stores, for instance, if you write a webcrawler to just gather a bunch of websites and save them in a database, NoSQL would be a good fit, because you're literally just storing documents. Both have their place, but usually you'd want SQL.
Any idea why Postgres seemed a joke to these senior devs? Tweets would be relational wouldn't they? I found it easier to store all the data of a tweet(most of what JSON was returned by Twitters API) in a collection of tweets. The only issue I remember was some duplication of values when they should probably be sharing a reference to this value(normalizing in SQL I think?), I think it would have been better suited for SQL or a Graph database with this need but the rest seemed really well suited for NoSQL(Mongo was used). I'd imagine setting up the schema for an SQL database along with the queries would have been more work/complicated than performing the queries with Mongo(I had a schema in place still). I later came across OrientDB which seemed to offer best of both worlds, though I didn't get around to trying it.
the ORM situation in javascript land is not stellar. Almost all ORMs are single-purpose things with very little flexibility, the models are super-tied to one db on the configuration level and very hard to reuse. I needed what OP needed as well, the ability to connect to one or more databases, one was easy, more than one was HELL. Even cross-db ORMs for some reason didn't think it would be a good idea to use the same model across databases. Like I wanted one model in relational and mongo AND file and all the others just in mongo.
`'package-json-validator'` basically.
Focus on the errors first.
heh heh :)
ðŸ‘
Cheat sheet : http://jsfeatures.in
Cheat sheet : http://jsfeatures.in
&gt; you're nitpicking over the definition of the word "classical" "You should read this to get a better understanding of the differences between classical and prototypal inheritance, because based on your post I really don't think you get it." That's what you said. You see, the problem was that your definition of "classical inheritance" was kinda off. I'm still not sure how you thought it was supposed to work. &gt; You should read the first two articles that you posted to understand why the addition of the class keyword isn't actually going to change how Javascript does anything That wasn't the topic. But yes, it won't change anything, because modern engines already use classes. &gt; as I originally said, its just syntactical sugar. As [I already mentioned](https://www.reddit.com/r/javascript/comments/3nkycz/not_awesome_es6_classes_a_curated_list_of/cvpstii), it's not *just* syntactic sugar.
Kwhali, Thank you very much for your guidance. It is much appreciated and very helpful.
Thanks
Of course i did, but cant really master js before friday :D 
Nice podcast! Any chance I could subscribe with an RSS feed in my podcasting app?
Those are just implementation details, not part of the definition of "class" except as applied specifically to some (non-JavaScript) languages. And if you're that worried about being able to affect an existing instance by changing the prototype, it's easy to prevent that in a dozen different ways.
You're welcome :)
The problem with trying to define both database model and js object model using the same structure, is that you must limit yourself to the common denominator of all the supported DB - it's fine for simple uses, and it becomes HELL as soon as you need custom types or indexes. Recently i came across this solution: https://github.com/Vincit/objection.js the great idea here is to simply split db model from object model. Define your db on one side, using whatever is specific to your db (knex is not bad at this), and on the other side, define a json schema the data must be validated against. It seems to be more work but in the long run it's major improvement over any other ORM - that's also why it cannot really be called an ORM. Once you get that, you can use objection-find, objection-rest which are alpha modules but already great.
Cool! I actually just saw a self post the other day regarding this topic. 
Most times you want to trust the data you have. Immutable data is related to functional programming, in the sense that it allows you to focus on logic flow over programming nooks. It's not so much that data shouldn't change but rather, data shouldn't have any unnecessary side effects. Immutable data is just a guarantee that your data will be what it says on the tin. Using something like `array.splice` has a lot of negative side effects, which means that you have to add some extra code to manage those side effects. Something like `array.slice` is much cleaner because you don't have to worry about `array` next time you refer to it down the line.
Spring Data REST FTW
I'm guessing it will only run on Macs?
&gt; Using something like array.splice has a lot of negative side effects, which means that you have to add some extra code to manage those side effects. Something like array.slice is much cleaner because you don't have to worry about array next time you refer to it down the line. As a relative newcomer, can you explain this a little further? What are these "side effects"?
If passing an object to a function is guaranteed not to mutate it then that's one less thing you have to think about when reasoning about code.
Ok thanks! Will try to fix again tonight
https://github.com/getify/You-Dont-Know-JS/tree/master/es6%20%26%20beyond
Yes, of course, my project could really be called "ArrestDB didn't exist on Node so i made it" :) Of course, the learning alone is worth the time i'm spending on it, and i know it won't be "wasted time" down the road. Thanks for your input anyway!
I may be wrong, but with blueprints (and other ORM / frameworks) you still have to define controllers don't you? The point of my project is to auto-discover tables and keys to have litterally 0 backend code, only config.
I was looking for a tool where i don't have to write any controller code, the tables and keys being auto-discovered, that is why i didn't go with one of the well-known ORMs and backend frameworks.
Interactive learning: http://tagtree.tv/courses/expert-es6
Yeah, i stumbled upon this project two days ago, and it looks really interesting, but there is always the problem of having to define models and all. Also i'm not sure Sequelize's multi-db capabilities really answer my use case.
The syntax seems very clean! Do you know if others videos with others frameworks are coming ?
Splice modifies the original array which can have unforseen consequences of it is accessed from other pieces of code. Slice, in contrast, does not modify the original but creates a copy so that any changes you make are isolated. 
Nobody hates classes by themselves; they hate classical inheritance, which is the inheritance model ES6 supports. Prototypal inheritance is a superset of classical inheritance, is more versatile, and is more transparent. We're not enemies of having a standard way of doing things, we're enemies of the chosen standard. Instead of dealing with inheritance via duck-typing and depency injection via prototypes, we now have a default system that goes against the standard features that make javascript unique and powerful. Implementing classical inheritance as syntactic sugar breaks with the fundamental design philosophy of javascript and for no practical reason (that I'm aware of). It wasn't implemented this way because it was the best way to do business. It was done this way because that's what less-informed programmers coming from c++ and java are used to. The writer of this article could benefit from some humility.
You only have to name them, they're automatically created by the CLI. The thing with blueprints is that you define your schema in models and Waterline creates table schema.. so yea, it's kinda the other way around from what you want. However since your idea is very interesting (and I use Sails for backend stuff I make out of the box) I'd be interested in a tool that scans existng tables and keys and generates mapped Sails blueprints (I'm not aware of one, perhaps it does exist). Such a tool would then effectively generate a full REST API backend (which is what blueprints do) so taking this route would mean that you effectively eliminate the job of creating an API -- i.e. all you'd have to do is generate controllers/models and map DB schemas to blupeprint model schemas which is very little (output) code to be written.
Actually, I'd say it's the other way around: most devs do not like prototypal inheretence, it's error prone if you do not really understand it. And classical inheretence is NOT what ES2015 supports. It makes things even more confusing, because the syntax is more similar to other languages now, that do use classical inheretence. 
I'm investigating a similar stack for a current project that I'm starting. I've been dying to give RethinkDB a shot, but looking at its requirements, they want two gigs of RAM. Postgres is running just fine on my 1gig Digital Ocean instance, so the features would really have to justify doubling the RAM. Anyone know the killer feature that'll make me a believer? (Yes I'm very familiar with document stores vs sql - I'm more looking at how it makes dev process nicer. )
The "Class" haters tend to be proponents of structuring code using plain objects or using factory functions. I personally don't mind that, but also I like just using simple constructors and prototypes, works for me and I've never had issues because of it. The new "Class" syntax of javascript is mostly a more straightforward way of implementing this, and it also proposes a standard way of modularizing your code. Right now javascript is a gong show when it comes to "best practices" of code modularization, and this can be super painful for devs wanting to share code but adhering to different paradigms. I think in the end, if people stop being stubborn, having this normalized syntax will HUGELY help the collaborative effort happening in the JS world. 
So, why would you use splice anyway, rather than just `all_primes_under_ten[0]`?
Anywhere that supports node and the packages being used.
&gt; inheriting from a React component Not something you want to do. By the way, if you're going to invoke React, then the reason they were excited about ES6 classes is not because they love classes. It's because it provides a more standard, clean syntax than their own `createClass`. The engineers at Facebook in the React team are broadly against classes, and support a more functional style. In fact, they just hired Dan Abramov, who has been very prominent in bringing functional programming paradigms to the JavaScript community. [They just added stateless component functions](https://github.com/reactjs/react-future/blob/master/01%20-%20Core/03%20-%20Stateless%20Functions.js) and plan to add more things like that, which will quickly become the standard way to write components. Much simpler than class-based components and much easier to test. Also prevents people from inheriting from React components, which is a horrible idea. Edit: By the way, just because some popular framework uses some technique doesn't make that technique a good idea. For example, pointing out two instances of monkey-patching in popular frameworks doesn't mean we should all use monkey-patching and that it's obviously a good idea because [appeal to authority]. As it is, generic functions/objects are used much more often in Node and React than classes.
Here is a simple way of looking at it: Say I have two functions: useRandom(random, num) and makeRandom(num) Say they both just add the random number to the num argument. The only difference is in useRandom, you pass the a random number to it and in makeRandom it generates the random number internally. useRandom with immutable data can be a pure function with a predictable outcome. We can predict how it will behave and thereby trust it. makeRandom can never be trusted in the same way because we don't know what the random number it generates will be. We can easily test useRandom but we can't really test makeRandom at all.
Totally. I ran into unfluffjs in a closed source project I'm working on. It's really great.
Very good question! posting consumes coins. So there'll be no spamming. Normally a JS app is just below 1M. User interactions can go through offchain channel which is not introduced in the article to avoid making the intro too complicated.
Wow, this is very new and this type of library was a missing feature in the JS community...
I can remove all of underscore and covenance, but didn't think it'd be a blocking concern for most developers. If enough people voice it as a concern, I'd change it. 
Since you are running into this, I'm assuming you are running 1.0.0-rc1. If you are not, things will be different :) To use the browser history, which would probably require changing your routes config in your Rails project (I think, I'm not a Rails wizard): var History = ReactRouter.History &lt;Router history={History.createBrowserHistory()}&gt;&lt;/Router&gt; [They don't recommend it](https://github.com/rackt/history/blob/master/docs/HashHistoryCaveats.md), but to keep using the hash history without that query string: var History = ReactRouter.History; &lt;Router history={History.createHashHistory({ queryKey: false })}&gt;&lt;/Router&gt; You could also do something like: &lt;Router history={History.createHashHistory({ queryKey: '_stateKey' })}&gt;&lt;/Router&gt; to get `_stateKey=123abc` instead of `_k=123abc` which is a bit less ugly imo With all that how to out of the way, I'd probably leave it as is until you have a reason to change it or before you go to production with your app. Yes, it's ugly, but it does provide some functionality and it "feels" like one of those things you tweak at the end of development instead of the beginning.
That's a good one. The simplest explanation is more often the best one.
Jesus christ this argument with classes is as dumb as the US's war on drugs. By this I mean the ones who are fighting for classes and those who are not.
What are the pros and cons of using this library over others like handlebars?
That's certainly the consensus. Looking into improvements. Got any code to share. Thanks for the feedback.
Yeah, I was just thinking about â€œGetting the first because it's cool,â€ overlooking the maintained array structure. But then you can still easily wrap the data into an array without using splice. But in any case, I'd say your problem is simply using the wrong function. That the array mutates is only a â€œside effectâ€ in the functional programming definition of the term. Whereas the mutation is pretty much the whole point of the method outside of that. That is, itâ€™s the primary effect, not a side effect (in a more vernacular use of the term). Thatâ€™s the reason slice exists alongside splice. Thatâ€™s the function defined for accessing/copying array fragments. Splice is explicitly for mutating. I donâ€™t see why one can complain about unexpected behavior when one is using the wrong function to begin with. Youâ€™d have similar problems when using the wrong function even if it didnâ€™t mutate the data. (Though I will concede that it can be easier to find the root of the problem with non-mutated data.)
I'm checking on them and thinking maybe the piece i'm developping should sit on an existing ORM instead of sitting directly on the databases. That would save a lot of trouble indeed.
There are a few things that stand out to me: - embedded query language -&gt; whichever programming language you use RethinkDB's query language is effectively an DSL - so no more writing SQL queries or worrying about sanitisation because you're effectively talking to your database via a composed string. - changefeeds -&gt; you can get realtime change information about a table, or a specific query. Want to display a leaderboard on your site of the top 5 people in a specific category, this is trivial with RethinkDB. If you are building something with real-time requirements, it is a serious contender for this point and greatly simplifies solutions just involving a DB. - distributed joins -&gt; it is a document store, but it can handle joins, so retrieval of related information is easy with RethinkDB. Check out the [API docs](http://rethinkdb.com/api/javascript/#inner_join) - [horizontal scaling](http://rethinkdb.com/docs/start-a-server/) -&gt; it takes 2 minutes to add another node: set up new server, install rethinkdb, then run command to connect to server As for the Dev process. We at Workshape.io initially chose RethinkDB purely for the fact that it allowed us to concentrate on the product for the end-user and iterate on our schema quickly. As we grew and scaled the database scaled with us, so once we had solidified on a model, it was still useful to us, especially with the real-time features and ease of horizontally scaling. For more info check out our [blog](http://blog.workshape.io/we-use-rethinkdb-at-workshapeio/) about it.
I love what RethinkDB is doing, but there are still many public performance tests out there showing that Mongo is faster. I think this is something they're going to have to improve on to really knock Mongo out of the picture.
This is the real answer
https://yourlogicalfallacyis.com/no-true-scotsman
Splice is like taking a piece of cake out and you have the altered original cake. A cake with 4 pieces will now have 3 remaining, with 1 piece in your hand. Slice is like taking a piece of cake but it makes a clone while leaving the original cake in tact. You get the 1 piece of cake but the original cake it still 4 pieces. Not altering originating data can be useful for measuring the state of an object by comparing it to the piece you're transforming, it's also useful because you can have an "undo" state which you can refer to, and you can have highly decoupled pieces working with their own snippets of the original object. Yes I think of cakes when I slice an array.
If you read my post, you'll know that I'm talking about all these people who use that fallacy.
I like the syntax a lot more. Granted, I'm not sure what my JavaScript will look like in 6 years, but that's part of the fun. 
I find the arguments against the class syntax really unconvincing. It seems that a declarative, unifying syntax is monumentally better than the various hand-rolled solutions that may or may not be compatible with one another. And fundamentally, it's still prototypes under the hood. The foundation didn't change, it's just sugar. Can you find me a definition agreed upon by all languages that use the concept of a "class?" "But beginners will get confused and not understand the language!" So are you saying that beginners who come to JavaScript aren't immediately confused by many aspects of the language, including prototypes? At least they have a chance of doing things somewhat correctly right off the bat with some familiarity. edit: clarity
Thanks for the info. I would also like to see more benchmarks. Like I said, I love RethinkDB. The focus on developer experience, the ReQL query language, the changefeeds feature... all of it is awesome. It's just hard to make a case for it among performance-minded people when it loses in benchmark tests, because it doesn't have the huge momentum of something like Mongo. I had a brief discussion with someone after a Node meetup a few weeks ago about it, and they started telling me about the improvements made with WiredTiger and the various storage engines available... It seems Mongo is getting better over time (in some ways), and they already have the market share.
XPost Subreddit Link: /r/node Original post: https://www.reddit.com/r/node/comments/3nq7f4/nodejs_and_es6_instead_of_java_a_war_story_how_we/
I'm not saying i won't learn to use ORMs (i've gotten handsy with Doctrine before), just that it will pain me if the 5th project of the year has 40 tables on three databases to write kilometers of boilerplate controllers when i know i'll be doing SELECT * FROM ? WHERE ? = ? 99% of the time. Maybe i'm just lazy, man...
&gt; I would have preferred them being constructor objects (because thatâ€™s what they look like) and not constructor functions. That would have been awesome and probably paved the way for metaclasses as known in Python. 
â€œJavaScript inheritance patternsâ€ @P1taJ https://medium.com/@PitaJ/javascript-inheritance-patterns-179d8f6c143c Check methods 3 and 4. They show inheritance without the use of class.
Ha, suckers! I've already moved onto Typescript! :-P
for(**let** i=0;i&lt;5;++i) setTimeout(function() { console.log(i); }, 500); 
I feel like this is a reaction to this article? https://medium.com/javascript-scene/10-interview-questions-every-javascript-developer-should-know-6fa6bdf5ad95
&gt; surely an enterprise customer knows how to fire up their own server and deploy a Meteor app. Some probably can't. But even the ones that *can* may not want to. For probably less money overall, you can just pay and get minimal downtime and auto-scaling. The money is going out one way or another. Either you are paying someone more (and probably overtime when the server goes down) or you are paying for a PaaS to do it for you. For large companies, this doesn't seem like a particularly bad idea. Looking forward to hearing about the other plans
&gt; "But beginners will get confused and not understand the language!" As an argument against ES6 classes, this is laughable. Anyone who makes this argument is displaying gross ignorance. That said, there are far better arguments against ES6 classes, most of which I'm not eloquent enough to present. I'm against ES6, but this isn't why. I *dislike* ES6 classes, because I think this kind of a class system (which even modern C++ is somewhat turning away from) is a kind of brain damage best avoided.
React maybe not, but you can't deny its influence. Node should be uncontested...
They both exit early on their respective false and true
&gt; It seems that a declarative, unifying syntax is monumentally better than the various hand-rolled solutions that may or may not be compatible with one another. I think this is the common opinion in support of ES6 classes and **it completely misses the point**. While a common unifying convention is certainly better than various hand baked insanity, **this is an unrelated strawman**. The problem is that the convention of classes, whether a single uniform approach or hand baked insanity, does not fit well in this language. The primary advantage is to provide a convention familiar to developers who are primarily educated in some other unrelated language *(cough cough.... Java)*. edited, formatting
No, ES6 has classes because Java programmers wanted classes. They wanted classes because they had a hard time implementing their ProblemFactories in JS syntax. Post a strawman, I raise you a strawman of my own.
&gt; But it's what most people want. I would like to see data on that before I believe it. &gt; That's why you have so many hand rolled implementations. I disagree. I rather suspect its because JavaScript looks amazingly similar to Java and C# but misses public/private pragmas and of course classes. You cannot arbitrary add new keywords to the syntax, but you absolutely can add a bunch of stupid unnecessary conventions. &gt; What people are doing is more important.... *"I cannot be bothered to learn this stupid little language. Most of my app is written in language (put some random letters here) and I have a deadline."* I encounter this pretty frequently and the only valid answer is: **ignorance**. The result is (pick one or more of from this buffet): * tightly coupled services (no separation of concerns) * spaghetti code * architectural confusion (probably ad hoc stupidity) * missing documentation * deeply embedded APIs that cannot be tested externally * collisions * build systems that build systems * embedded services using custom protocols (really!?!) * logic reflecting no clear product direction
&gt; Flex based intranet application I'm not sure what that is. What does it do? Explain to me what you want to happen and I'll see I can code you something...
Its not an ill-defined notion. Any object that you create in Javascript is automatically assigned a prototype. A Javascript "class" inherits its methods through a shared prototype like all other Javascript objects, so the `class` keyword isn't actually changing anything about the language. In a traditional class-based language you define a class and its like drawing a blueprint. You create an object using a class, and its like building a house from the blueprint. In javascript if you build a bunch of houses from a blueprint, then go back to the blueprint and draw some extra lines on it, you look up and all of the houses you built suddenly all have garages. That's not how class-based inheritance is supposed to work, that's prototypal inheritance works, because prototypal inheritance enables active links to other objects. So all these arguments are pointless. The `class` keyword is just syntactical sugar that doesn't change anything, and seems designed to make transitioning developers more comfortable. The worst thing about it is that its so confusing and now everyone thinks its some kind of paradigm-shifting change when ES6 isn't actually giving anyone a new object model with classes
If you are trying to do this in an automated way.. Then I really dont see - if there is any such solution in existence.. ( I might be wrong! ).. But if you do hire a few js devs to do it - I would think its quite straight forward - especially if you use something like Angular or React .. FWIW - angular was inspired by flex.. so there are lots of similarities there. 
&gt; The problem is that the convention of classes, whether a single uniform approach or hand baked insanity, does not fit well in this language This is just nonsense. Virtually every major JS project out there uses classes. They fit perfectly well in this language. I see a lot of these circular arguments attempting to justify why classes are somehow harmful, when the reality is that the arguer simply doesn't like them. It's fine, you don't have to like them or use them, but saying that they're useless or somehow bad is plain ridiculous.
I think the real distinction is between people actually programming in javascript and people copying together stackoverflow answers and jquery plugins.
They should know better than to step on your lawn ;)
Thanks! I'll check out Angular, hopefully it won't be too bad rebuilding it if they're similar.
If it is not ill-defined could you provide a definition? What makes a language feature a good fit? What makes something a good fit for JS?
Your last point about rooting out the problem is one of the main benefits of programming functionally and indeed why, if you were programming functionally, you'd avoid using directly mutating functions like splice. Slice in this context would be a pure function and splice impure. The benefits of programming in a pure, functional, immutable way is that your code is far easier to "reason about" and also more easily testable.
&gt; Does it really matter if it's "real" classes, or a syntax over the prototype? If so, why exactly? **Scale** You are assuming you need some kind of inheritance model. This assumption is absolutely a false premise. TLDR; wrong. The benefit of inheritance in a C++ like language is that an object with stored properties is assigned to a known point in memory. The point is cached and known so that it does not have to be rewritten into another area of memory. Things *inherit* from the cached object by referring to it, cloning it, and modifying as necessary. You loose some (insignificant) processing power in this process but conserve memory and gain memory performance. Of course for the benefit to occur you need to use this convention in a language where you actually control access and consumption of memory. You have this in C++. So, now lets talk about garbage collected classical languages like Java and C#. These languages use GC, so in these languages have no control of memory assignment. This therefore destroys the original benefits of classes immediately. All is not lost though. Classes are convenient. A developer can write a class, inherit from it later and extend the inherited instance in a way that can be further inherited. These are like blueprints (but are more regularly called factories). While this simplifies approaches to logic in the code it requires substantial overhead, in the case of Java the overhead can quickly become the majority of the code expressed. To be fair classes directly serve the needs of *declarative* code styles. In many cases the increased code overhead directly reinforces are keyword and reference based description model. In a services oriented application you tend to really need an inheritance model because you tend to sometimes get requests faster than garbage collection can free memory from the prior requests. In such scenarios it is necessary to be as thrifty as possible even if you are not directly controlling and freeing memory. Now let's look at lexically based languages, which includes things like JavaScript and XML (so ultimately all native web technologies that allows expression of logic and decisions). First, I want to be clear that I did not say functional languages, which implies something different. In a lexical language a scope model is achieved by where things are declared relative to the existing (containing) structure of the code instance, which is wildly different from an inheritance model. To make things more confusing JavaScript is object oriented exactly to the same definition as Java, but JavaScript uses a different inheritance model (prototypes instead of classes) and the inheritance model is separated from its scope model (which is not the case in most class-based languages). This is the most important part of the whole story, so let's be very clear: **In JavaScript the scope model is separate and unrelated to the inheritance model.** That said, you don't need inheritance in JavaScript. In nearly any language you absolutely cannot escape the scope model. So, the scope model is mandatory and inheritance is optional. Important stuff. But but but..... memory..... JavaScript is a very high level language. Inheritance does offer some memory performance but at a cost. The benefits to memory offered by inheritance in JavaScript does not make applications work faster or even conserve memory. What it does do is extend the life of objects bound to references through garbage collection cycles so that an application runs more consistently. This is only noticeable if the given application is consistently running specific tasks over and over in a loop where this execution is delegated to some other process in a manner that is not locking the execution thread. This need rare, and I mean exceedingly rare. But it does occur with games, animations, and canvas operations. So there is an absolute benefit to inheritance in this language, but its a purple unicorn. But but but... JavaScript benefits from declarative coding style just like Java. You don't need inheritance for this. In fact, using inheritance models to achieve this is counter-productive because the excess overhead is distracting. The lexical model (nested structures) provide sufficient opportunity for naming things appropriately to achieve a declarative style. Furthermore, in nested lexical code you also get *context*. You have some idea of what a nested function is doing by looking at its descriptive name and well named references and by looking at the descriptive name of the containing function and its containing function. Context is what makes spoken language understandable, and it can make code understand exactly the same for exactly the same reasons. Inheritance generates a bunch of noise that screws this up.
Flash
&gt; Virtually every major JS project out there uses classes. Then I am absolutely wrong. I refuse to argue with bandwagon popularism that isn't based on anything.
&gt; What makes something a good fit for JS? Whether or not you can use it to make yet another JS framework. Evidently, the ease of framework creation is JS's niche.
(A Smarter way to learn JavaScript by Mark Myers). Has a ton of practice tests to go with each lesson. Reviews are off the charts on Amazon. http://www.amazon.com/Smarter-Way-Learn-JavaScript-technology-ebook/dp/B00H1W9I6C
&gt; I refuse to argue with bandwagon popularism that isn't based on anything. Likewise. 
&gt; React React is moving away from classes. For whatever short time React has used classes, it's already caused a lot of problems and confusion (side note: `createClass` doesn't make classes, just a stupid function name).
Real programmers don't use poorly designed scripting languages tossed together in a matter of days that only became popular because it was running in a one man race, then sat stagnant for over a decade while the standards body responsible for it sat on their ass. Downvote if you know this is true.
No it's a response to [this](https://www.reddit.com/r/node/comments/3nl09z/not_awesome_es6_classes_a_curated_list_of/) post, which was also cross posted to several other related subs.
I tried fixing some things and now instead of the row error I get this: http://imgur.com/58wx2ZX 
Wouldn't know.
Well it will probably be a lot easier to support gazillion databases with an ORM that has large community writting DB adapters for it than it would be to support it yourself.
&gt; Those are just implementation details Implementation details are the things that matter the most! Just because we slap on a sticker that says "classical" doesn't actually make it so. The underlying behavior (the implementation details) is what makes something *actually* classical or *actually* prototypal.
Not using inheritance is clearer still.
I'm not assuming I need inheritance; I like inheritance very much and choose to use it because my team and I unanimously agree that switching to the ES6 class syntax saved us time, made scaling easier, memory management easier, testing easier, re-usability easier, training easier, and more. In fact, the only thing we complain about is the lack of *more* sugar to help with things like private properties without the need for weakmaps. We look forward to ES7 additions. I am not trying to be dismissive of your arguments.. but none of them were compelling enough to me, because they're subjective in nature. There are no technical limitations to using ES6 classes instead of rolling your own. It's just another way of writing the same code, so it's a subjective decision to use them or not. Until there's a serious technical limitation with them, ES6 classes are here to stay for us and we're really happy with the decision.
Both use inheritance... don't care. When you stop using inheritance you are left with functions and assignments, which is more clear and still saves you characters compared to your first code example.
Oh... Thanks!
&gt; It seems that a [PUT ANYTHING HERE] is monumentally better than the various hand-rolled solutions that may or may not be compatible with one another. FTFY. But that serves to underline the point that what you're saying has nothing really to do with an advantage of class. You then prove this by saying this: &gt; fundamentally, it's still prototypes under the hood. The foundation didn't change, it's just sugar. What you probably think is the coolest thing ever... is typescript. And when you finally figure out why bashing javascript into type-safety and classical inheritance is neutering an incredibly flexible and powerful language, come back and re-read the things you currently disagree with. 
&gt; OOP isn't about saving memory at all It was originally. &gt; Objects do not inherit from other objects. They do in JavaScript where everything is either a primitive or an object. Functions, arrays, classes are all objects. Your example is flawed in that there is an object `Foo` which is defined as a class and an instance named `Bar`. Two separate things: the original and a new instance based upon the original. &gt; The performance benefits of classes are all about having object properties with predictable data types at predictable memory offsets. In the JIT all references are nearly equally predictable provided there is no type recasting. To optimize scope chain resolution the location of references is cached against the container in which they are declared. This just means that classes are less crappy than they could be since the prototype chain is a secondary scope model after the primary reference scope model, but it certainly doesn't mean classes are expected to perform better. Let's just assume I am wrong though. I will await a jsperf.
&gt; The benefits to memory offered by inheritance in JavaScript does not make applications work faster or even conserve memory. Inheritance does NOT conserve memory? Are sure? Compared to what approach?
I actually don't think it's the coolest thing ever. I almost never use inheritance, and prefer a more FP approach to JS rather than OO. But this new syntax is a clear win for the language and community.
That's an impressive work, I wish the project source of [this other mosaic tool](http://www.phpsecure.info/mosaic-face/) was as friendly as yours. 
JS is weird. `Foo` and `bar` are both function (with a constructor being capitalized by convention and an instance being lower-case by convention). Unlike C++, JS does not have classes. It just has functions that we use like classes (i.e. constructors). 
I completely agree with you, it's rare to find a place where inheritance isn't a very brittle solution. But they're being built anyway, so lets use a single syntax.
&gt; JS does not have classes. It just has functions that we use like classes JS absolutely does have classes, otherwise what are the `new`, `class`, `extends` and `instanceof` keywords for? The fact that they're based on constructor functions is an irrelevant implementation detail. The classes in C++ have a different implementation to the classes in Java, both have classes, so does JS.
&gt; In this case a class system allows developers to write code at a superficial layer that completely masks the language's intended way of structuring and declaring things. I think that superficial layer is a good thing. So does the rest of my highly-skilled team. You disagree. I guess that makes it.. subjective, doesn't it? &gt; but you have absolutely no idea what you have missed and the alternate potentials. We each wrote vanilla Javascript for over a decade prior to switching, but really.. I'm not sure why I even have to reduce myself to an argument to authority. It's kind of offensive that you assume everybody in this thread has less experience than you, and even make rude comments about it like: &gt; you are not able to compare them against the major alternate approach. I mean.. really? Surely you want to be a more effective communicator than this. I'm totally turned off to having a conversation with you now.
Good catch. But the main point is that classes aren't really anything special and they work the same way as (most) other objects in Javascript. http://codepen.io/anon/pen/MamGpR?editors=001
&gt; this new syntax is a clear win for the language and community. I don't think you've established it's a "clear win". It clutters the language with things we neither need nor should use. It dilutes the intent of the prototypical inheritance system on which the language is based. Sure, it makes -your- life easier. But you're arguably doing things that was never intended to be how the language should be used. Facilitating that does not sound like "a clear win", it sounds like a degradation. 
&gt; Not one is more clear than the other for everyone. You know, because it's subjective. It isn't that subjective. This is more clear: var Thing = { bark: function () { console.log('woof'); } }; Than: class Dog extends Thing { bark() { console.log('woof') } } If a person cannot extend code without inheritance then it isn't a matter of subjectivity at all. Its a basic misunderstanding of how this language operates.
Are you INSANE or ILLITERATE?!?! As they've been trying to tell you, JS, somewhat in the spirit on things like LPC, simply designates an instance of an object to be its ancestor as a prototype. The prototype chain that acts to form an inheritance tree does not uses classes, but actual object instances that can be modified after creation.
When developing JS that runs on a mobile device as many of us are, memory is of great importance -- and yes, you can save memory allocations in JS just as you can with almost any GC'd language.
I think you presumed a tone authority or expertise I had no intention of conveying. Let me explain it this way. In the past, before using classes, did you ever structure an application by nesting functions? This is an alternate and unrelated approach to inheritance. It allows opportunities in the code that inheritance does not. If you did not write in this approach then you, merely by absence of approach, did not learn these sorts of benefits. That means that you cannot compare those benefits to those learned and experienced from using classes. I am only speaking from logic in that something must be tried (whether or not successful) before it can serve as a basis for comparison. Know that one approach is beneficial is helpful, but not complete unless knowing its benefits versus some alternate and unrelated approach.
Free online books on ECMAScript 6: * â€œ[Understanding ECMAScript 6](https://leanpub.com/understandinges6/read/)â€ by Nicholas C. Zakas * â€œ[Exploring ES6](http://exploringjs.com/es6/)â€ by Axel Rauschmayer * â€œ[JavaScript AllongÃ©, the "Six" Edition](https://leanpub.com/javascriptallongesix/read)â€ by Reg â€œraganwaldâ€ Braithwaite * â€œ[You Don't Know JS: ES6 &amp; Beyond](https://github.com/getify/You-Dont-Know-JS/blob/master/es6%20&amp;%20beyond/README.md#you-dont-know-js-es6--beyond)â€ by Kyle â€œgetifyâ€ Simpson 
I think the "why" is easier to explain, and without entering sterile debate. Javascript earned a lot of popularity and is growing steadily on every platform. There are more and more developers using it. Javascript is designed by committee. Classes represent a highly demanded feature. Introduction of classes doesn't remove existing abilities and supported paradigms, pleases a lot of people (and can even drive in the field some reluctants), and the most important point: they offer a standard. Because hey, class-oriented inheritance-loving developers have been hacking their own implementations of extend and super, more or less efficient, for ages. And this would never go away without a standard. It was more likely to increase. So committee decided to please a big user base, and, while at it, come up with a consistent implementation. ES2015 classes have a nice terse syntax, remain usable as expressions, remain hackable at runtime, will be used as support for ES7 decorators. Whatever my position on classes usage, I think those are as nicely implemented to fit the language as it was possible. So IMHO, there are only advantages. Sure, some people won't understand how it works under the hood, won't dive into FP and prototypes, and will come up with big inheritance monsters. But would those people have dived in anyway, even without classes? I don't think so. They would have thrown some class framework in their code and call it a day. They're already doing it. At least they won't have this excuse anymore to introduce another third-party library or give birth to their own hack. The fact that you can chose your own paradigm is something that I find really fundamental in javascript as it is now. And I appreciate that, as a general-purpose language, js tries to offer tools for each supported paradigm. (I would appreciate having a bit more functional tools though, come on, enough has been done on the OOP side for now! ;) ) 
They use classes, but rarely do they do really complex inheritance models like you see in Java. Without strong typing, abstract classes, interfaces, etc, a class is pretty much just a convenient place to group a bunch of functions, maybe with one or two base classes for shared code. Not that it's a bad way to do things, just a different style. 
The only way to verify that is to run a memory profiler and compare the results against a different memory profile. Considering that memory profiling is still pretty new in JavaScript when people make claims such as this I am thinking they don't have memory profiles saved from testing, particularly against mobile. Even on mobile devices you typically have far more memory than you would ever need. I have an ancient IPhone 4 and even still it has 8gb of memory. Any JS application that is going to fill that memory before GC can reclaim it is going to noticeable reduce the CPU to a crawl to the point where the device is challenging to use anyways. The IPhone 6 comes in memory sizes of 32-128gb. Is your application really consuming that much memory that you can tell from running a memory profiler? Seriously, when people talk about writing to memory efficiency I just presume they are completely new to JS.
Are you now suggesting that storage space is the same as memory?
You might as well be asking why JS has bitwise operators when it doesn't have integers. It's a frankenmonster of a language with a lot of syntax that doesn't make sense but has to be maintained so we don't break the web. If you insist on pointing to the `class` keyword as evidence that JS behaves exactly like Java then you really don't understand the language.
Brave post
ok, I just want to be sure there isn't a better alternative or the "right way"
&gt; If you insist on pointing to the class keyword as evidence that JS behaves exactly like Java then you really don't understand the language. Literally never said nor implied anything like that.
Do you have any idea what practical purpose that serves?
No, I wanted to ensure you were aware of an alternate approach. It sounds like classes are working well for you and your team.
You're right the spec has the word "class." But semantics aside, javascript has prototypes as the mechanism. You could argue it's just an implementation detail, sure. But to be a competent js dev you must understand how they work. I personally would not hire someone who claimed to use the syntax and did not know how prototypes work on a basic level.
&gt; if you're writing a node app and each request consumes hundreds of Mb of RAM If I encountered that I would definitely think you were new to JS. Bottom line, you have no control over how frequently GC operates or what it collects, particularly cross application/platform. &gt; I feel like you're making a lot of assumptions about the other people's competence when compared to your own. This attitude does you no favours. I am only speaking from logic and past experiences. If you are reading anything emotional into my opinions then you must be a far more emotional person than I. If that upsets you then I really don't care. Go read this: http://www.16personalities.com/intp-personality If you really want to be sad and offended I honestly believe that if you value the emotional qualities leading to a decision as more important than the outcome of competing opinions that comprise a decision that you shouldn't be programming in the first place.
Performance isn't everything. If it were, angular would have never become popular. 
Wow I'm stupid. You're right!
You think frameworks like Backbone were written by Java programmers? Everyone who used CoffeeScript is a Java programmer? Java isn't the only language with classes. Also don't forget that JavaScript is supposed to look like Java. That's how it was made.
No, it is not supposed to look like java. It only has the name for marketing reasons, and thats it.
Are you sure? I'm using a new moto G and it has 1 gig of ram ( although 8 gigs of storage). Maybe iPhones have the huge amounts you suggest but most mobile devices certainly don't.
Java was a direct influence. Constructor functions were added to make it look more like Java. And yes, it was even renamed to JavaScript for marketing reasons. It was made to look similar to Java and it was marketed at Java developers.
I agree with you. 
Imaginary JavaScript Programmers check for `NaN`.
Can confirm. Am beginner and confused by prototypes. 
It all depends on the database. If it's sql, write a view or stored procedure once. I can't speak for JS dbs, realized that was the context too late after commenting. My only ORM experience to speak of is .NET Entity framework 
Remove this: var forward = setTimeout(forwardElsewhere, 5000); Add: $(document).click(forwardElsewhere); That's it. (I don't need gold.)
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script src="https://code.jquery.com/jquery-1.10.2.js"&gt;&lt;/script&gt; &lt;style&gt; body { overflow: hidden; background-color: #000; } h1 { color: #fff; z-index: 10; position: relative; top: 50%; transform: translateY(-50%); text-align: center; font-family: Helvetica, Arial, sans-serif; font-weight: 500; font-size: 50px; text-shadow: 0px 0px 13px #000; max-width: 300px; max-width: 600px; margin: auto; padding: 20px; display: none; } #center-container { position: fixed; width: 100%; height: 100%; } img { position: absolute; left: 0; top: 0px; right: auto; bottom: auto; height: auto; width: 100%; vertical-align: middle; display: none; } @media all and (max-width: 975px) { img { height: 100%; width: auto; } } @media screen and (max-width: 375px) { img { left: -50%; } } &lt;/style&gt; &lt;script&gt; $( document ).ready(function() { $('img').fadeIn(600); var delay = setTimeout(showText, 1000); document.Body.addEventListener('click', forwardElsewhere); }); function showText() { $('img').fadeTo(1000, 0.3, function() {$('h1').fadeIn(1300);}); } function forwardElsewhere() { window.location.href = "http://google.com"; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img src="museum.jpg"&gt; &lt;div id="center-container"&gt; &lt;h1&gt;Mr Palmer is concerned with the 1000 dollars&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;
If you start your comment off with "You think...", you're probably wrong or at least out of proportion. I'm well aware of Javascript's history. I am well aware of many languages that use classes, including Java, having programmed in them for years. My point is not so much that it is Java programmers who want this change, as it is that the writer of this article assigned a strawman as the reasons I (and others) disapprove of the slow 'classification' of JS. So, rather than give the actual, legitimate arguments (which this author has ignored completely), I simply responded in kind. If you want to know the actual reasons I oppose it, read through some of my past comments on reddit. I've enumerated them many times.
Hey, thanks a ton for the thoughtful reply. I'm struggling to get a good grip on this topic, and your comment helped, although I still have a couple questions if you don't mind going another round: &gt; It's able to perform update operations in O(log32N) complexity whereas Freezer appears to perform a shallow clone on the mutated object each time 'set' is called (O(n) complexity) -this greatly simplifies things, but could potentially be computationally expensive if there are many nodes (like in a very large list for example). Makes tons of sense. I threw together a quick benchmark that tries to repeatedly increment the value of an object in a list of 1000 objects. Vanilla mutation is about 1300 ops/sec, Immutable JS is about 35 ops/sec, and Freezer is 0.1 ops/sec. Obviously a pointless microbenchmark, but it really helped me see the penalty of doing shallow clones on large data structures. ([Link](http://jsperf.com/immutable-js-map-speed/13) for the curious.) &gt; Update operations in Immutablejs are also memoized so you'll always get the same reference returned to you if you try to update a value with the same value. That sounds pretty cool, but doesn't that mean that if I do: var state = Immutable.fromJS({root: {a: {b: {d: 'test'},c: {e: 'also a test'}}}}); var b = state.getIn(['root', 'a', 'b']); state = state.setIn(['root', 'a', 'b', 'd'], 'test'); console.log(b === state.getIn(['root', 'a', 'b'])); state = state.setIn(['root', 'a', 'b', 'd'], 'test2'); console.log(b === state.getIn(['root', 'a', 'b'])); state = state.setIn(['root', 'a', 'b', 'd'], 'test'); console.log(b === state.getIn(['root', 'a', 'b'])); I should get "true false true"? But I actually don't; it prints "true false false". Which is still fine, but if I do: var freezer = new Freezer({root: {a: {b: {d: 'test'},c: {e: 'also a test'}}}}); var b = freezer.get().root.a.b; freezer.get().root.a.b.set('d', 'test'); console.log(b === freezer.get().root.a.b); freezer.get().root.a.b.set('d', 'test2'); console.log(b === freezer.get().root.a.b); freezer.get().root.a.b.set('d', 'test'); console.log(b === freezer.get().root.a.b); I'll *also* get "true false false". So I'm not sure I understand the distinction you're making here. Any chance you could show some example code that shows off what Immutable.js is doing differently than libraries like Freezer? Similarly, you say: &gt; Freezer will trigger an update event each time (potentially causing a rerender) as well as shallow cloning the node. But that also doesn't seem to be the case: var freezer = new Freezer({root: {a: {b: {d: 'test'},c: {e: 'also a test'}}}}); freezer.on('update', function(newValue) {console.log('Updated');}); freezer.get().root.a.b.set('d', 'test').now(); freezer.get().root.a.b.set('d', 'test2').now(); freezer.get().root.a.b.set('d', 'test3').now(); That will print "Updated" twice, not three times; the first set() call doesn't trigger any events (and as above, preserves referential integrity). Am I missing the point you were making? Again, thanks for your comment; definitely helped.
I'm specifically pointing out some important differences between using prototypes (in a basic way) and using classes. As you can see in my examples above, static methods and instance methods of classes are not enumerable in ES6. Whereas methods simply set on the prototype or on the constructor itself are. Object.keys is just a simple way of demonstrating what is enumerable and what isn't.
Not sure, but you can still get all the methods by using Object.getOwnPropertyNames
ES6 has classes because everyone and their dog was using some kind of classes and inheritance. It's the JavaScript programmers who apparently wanted this. If your point isn't that Java programmers wanted this change, you should perhaps say something else. Kinda straightforward, really.
Actually it was a response to the post where the guy was talking about how cool classes were, and then got called out by someone else how he made a issue on node.js' repo saying all instances of "class" in docs need to be removed. And the fact that everyone is spewing their personal opinions about classes in ES2015 as "How real JavaScript programmers do it"
Everything Eric Elliott writes is like that, he's always going on about how much classes suck.
I think this is awesome
&gt; It was originally. You write a lot of big words, but, I'm sorry, you're factually wrong. Simula was designed to make it easier to implement discrete event simulations. Nygaard found existing languages too low-level and made it hard to express the kinds of programs he was trying to write. Smalltalk was, of course, absolutely never designed to be parsimonious with memory. As a dynamically typed, garbaged-collected language in 70s, it started out pretty far in the hole as far as efficiency is concerned. OOP was always about expressiveness and maintainability, not memory and performance. vtables are a neat implementation trick, but OOP was around long before they were created.
Ignoring the effects of the actual syntax, yes, the way ES classes work behind the scenes is prototypal inheritance... but it's only one of the ways to do prototypal inheritance: prototype chain constructor patching + the "new" keyword, a method which a lot of people believe has issues. https://tsherif.wordpress.com/2013/08/04/constructors-are-bad-for-javascript/
I like the `class` syntax I just prefer a different keyword like `contruct`: construct Person { constructor() { } } Something else that won't confuse with other languages classes (Not sure if `construct` is a good keyword, but point is just something other than `class`)
Object diffing is expensive. But diffing the hashed key of an immutable structure is very cheap &amp; more reliable. 
 var fs = require('fs'), request = require('request'), cheerio = require('cheerio'); url = 'http://www.ozbargain.com.au'; request(url, function(error, response, html) { if (!error &amp;&amp; response.statusCode == 200) { var $ = cheerio.load(html); var $el = $("a:contains('Xbox')"); if ($el.length) { console.log($el.text()); } else { console.log('hey'); } } }); 
As far as I know, React is simply embracing ES6 classes over its own custom implementation - not getting rid of classes altogether.
/r/slavelabour
/u/achen2345 is confusing Flash Memory(Storage) with RAM. Based on that alone, I would disregard pretty much anything he has to say.
I just reversed 100 000 items (reorder on) with my iPhone in a reasonable time (under 2 seconds). That's something not every framework will do at all. Try yourself: hit "shift 1000 items (with reorder)" hundred times, then "sort (with reorder)" and finally "reverse (with reorder)".
Oh god. I remember the hell of trying to get this stuff to work consistently back when I did Java. I hope it's improved a lot since then, otherwise I don't think it's that comparable. Also, JRebel was expensive as hell iirc. Hundreds of dollars just for live reloads. 
This page talks about the object vs class thing in Javascript. [You Don't Know JS: this &amp; Object Prototypes Chapter 4: Mixing (Up) "Class" Objects](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&amp;%20object%20prototypes/ch4.md)
Looking through the comments I think some people don't have a great understanding of how objects/prototypes/"classes" work in Javascript. I recommend everyone check out the series You Don't Know JS on Github. Especially check out the book on `this` and prototypes. Chapter 4 is all about the class stuff: [Chapter 4: Mixing (Up) "Class" Objects](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&amp;%20object%20prototypes/ch4.md)
I'll just keep posting this around: This page talks about the object vs class thing in Javascript. [You Don't Know JS: this &amp; Object Prototypes Chapter 4: Mixing (Up) "Class" Objects](https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&amp;%20object%20prototypes/ch4.md)
Whhhhaaaaatttt. Dude, you really need to reevaluate your understanding of programming languages. Inheritance has absolutely nothing to do with memory. The rest of what you've written is just as inaccurate.
It's not really about the syntax- the problem is the contract between the caller and the module. Classes require the caller to use `new` which forces the thing before `new` to be a constructor and to run in the context of a newly-created object. It ruins composability and things like that because there is no way around the fact that there is a `new` at the call site.
I've been using React for so long I forgot what inheritance is used for
This. It's all trigonometry. You figure out the rise and run and then remember why you shouldn't have slept through 10th grade maths.
Has anyone used this ? Any screenshots? I'm on mobile. Edit: there is a demo link on the page. Nevermind.
Gotcha, thanks! I guess I should go learn some more trigonometry
https://en.wikipedia.org/wiki/Poe's_law Sarcasm doesn't really work on the internet. There is no intonation, no gestures, no facial expressions, no anything. There is no way to distinguish a sarcastic remark from the real thing, if it lacks an excessive amount of hyperbole. So, yes, I generally try to be very clear and specific, because getting the point across is already hard enough as it is.
So I guess you missed the part where I clearly labeled my statement a strawman, then?
Sweet! It works. Thanks!
What school did you go to that didn't teach basic trigonometry?
I agree with this comment. The problem is, if you ask this very question in 6 months, when angular 2.0 is out, the answer will be different. Then again, ask the same question in 1 year, and you might get a completely different answer. This is not good.
Why not take bits of pieces of impact and write your own?
I suspect that you will not receive an answer.
Does it limit the use of mismatching types?
No there's no way to use crossdomain.xml in plain JavaScript to tell the browser that it's ok. You'd have to use Flash to access that domain (E.g. [CrossXHR](https://code.google.com/p/crossxhr/wiki/CrossXhr)), or have a server proxy on the video streaming site that accessed the subtitles site. With plain JavaScript you are out of luck unless the site supports CORS, or unless you disable cross domain security in your browser (e.g. start it with `chrome --disable-web-security` every time). Probably a silly idea but can you run the bookmarklet on the subtitles domain and access the videos as the cross domain? E.g. &lt;video&gt; and Flash video don't typically have cross domain restrictions.
Can you add an rss feed?
As it looks like your original debating partenr has gone away for a while, I'll jump in! The problem as I read it, is that you're arguing two seperate things; *you're* arguing that classes make inheritance cleaner and clearer, because they do. But he was arguing that classes make inheritance, which previously was a pain in JS, too damn easy. If you want easily testable code, it's usually better to use some form of composition or depenency injection over inheritance, as inheritance makes it very hard to isolate your system under test when it drags all its parents along with it. With composition, you can test functionality in isolation a lot more simply, and a functional language like Javascript lends itself really nicely to that pattern. Now, before I get to the code theres a great big disclaimer: In this trivial example, your code looks simpler and more easily understood, and saves 3 lines. I certainly will not win that fight. BUT should bark or growl become modules that rely on the audio API, or should walk become an animation on a canvas, or a 3d render in WebGL; the composition method allows you to test all of that really easily in isolation, or straight up import it from another library altogether, without it ever needing to know what the hell a Dog or even Animal *is*. Without further ado; may I present, your example: var walk = function(name) { console.log(`${name} walked.`) } var bark = function(name) { console.log(`${name} barked.`) } var growl = function(name) { console.log(`${name} growled.`) } function Animal (name, abilities) { this.name = name; this.vocaliser = abilities.vocalise; this.walker = abilities.walk; } Animal.prototype.vocalise = function () { this.vocaliser(this.name); } Animal.prototype.walk = function () { this.walker(this.name); } var cujo = new Animal('Cujo', {vocalise: bark, walk: walk}); cujo.vocalise() // Cujo barked. cujo.walk() // Cujo walked. var fluffy = new Animal('Fluffy', {vocalise: growl, walk: walk}); fluffy.vocalise() // Fluffy growled. fluffy.walk() // Fluffy walked. With regards to code clarity, I may actually be more inclined to write the above more like this, which looks a little less scary to people coming in from a language without prototypes, and only assumes knowledge of closure, rather than prototype inheritance, similar benefits, slightly less idiomatic of the language: var walk = function(name) { console.log(`${name} walked.`) } var bark = function(name) { console.log(`${name} barked.`) } var growl = function(name) { console.log(`${name} growled.`) } function Animal(name, abilities) { // common functionality here return { walk: function() { abilities.walk(name); }, vocalise: function() { abilities.vocalise(name); } } } var cujo = new Animal('Cujo', {vocalise: bark, walk: walk}); cujo.vocalise() // Cujo barked. cujo.walk() // Cujo walked. var fluffy = new Animal('Fluffy', {vocalise: growl, walk: walk}); fluffy.vocalise() // Fluffy growled. fluffy.walk() // Fluffy walked. Ninja edit: now animals also have a common interface / API. Handy.
Yep, I do have a JRebel license. My experience with it was that it tends to not work properly a lot of times, and I had to spend more time than I ever wanted to keep it working.
Here is a much better one! https://medium.com/javascript-scene/10-interview-questions-every-javascript-developer-should-know-6fa6bdf5ad95
Why are Tor users banned from that website?
&gt; I used homing missiles as an example. I am trying to make two objects move closer to each other. That's not like homing missiles at all. A homing missile flies at a constant speed and turns towards the target. In video games, you continuously increase the turn-rate in order to avoid orbiting. So, they will do some homing stuff but ultimately they will hit. You only need a simple easing function. start + (end - start) * easingFunction(normalizedTime) You do that for X and Y. The normalized time argument goes from 0 to 1. Start &amp; end are the positions. Some easing functions you could use: inQuint(t) =&gt; t * t * t * t * t inQuart(t) =&gt; t * t * t * t inCubic(t) =&gt; t * t * t inQuad(t) =&gt; t * t inSine(t) =&gt; -1 * Math.cos(t / 1 * (Math.PI * 0.5)) + 1 inExpo(t) =&gt; (t == 0) ? 0.0 : Math.pow(2, 10 * (t - 1)) inCirc(t) =&gt; -1 * (Math.sqrt(1 - t * t) - 1) What /u/katnapper323 mentioned also works, but it would have been a lot simpler with vector math. position += (target - position).normalized() \* speed \* t That's it. Pretty much. (Not quite as sexy without operator overloading though.)
I agree, but we already have that problem without the class syntax. I always have `static create()` factory function to wrap `new`. I dislike using `new` mainly because it does not support function composition.
The code and tests are executed on node.js so you can write ES2015 code and it just works (without transpilation) using node 4+
&gt; TC39 resisted giving into demand for awhile Bollocks. Classes have been around since the [ES4 proposal](http://webcache.googleusercontent.com/search?q=cache:mpxSJP3f4hsJ:www.ecmascript.org/es4/spec/overview.pdf+&amp;cd=4&amp;hl=en&amp;ct=clnk&amp;gl=uk), the reason they didn't ship already is because ES4 itself died, not because TC39 was "resisting". &gt; **Classes**: A class describes an object by presenting those properties (fields) of the object that are always present (thefixed properties or fixtures), including variables, constants, and methods: class C { var val // a variable property var large = Infinity // a variable property const x = 3.14 // a constant property function f(n) { return n+val*2 } // a method property } If you have an argument, you don't need to resort to: 1. Making shit up 2. Using the term "java developer" as an insult, it isn't. If you find yourself doing those things, perhaps you should reconsider your position.
Do you have to do so with JavaScript, as this can be done with just CSS: http://codepen.io/anon/pen/wKdQVr
If you want to expose a part of your state to a child component, i think you need to pass it to the child as a property. 
Or you can install Babel and use the require hook of you're not on node 4.x yet.
Codeacademy is a good place to get your feet wet in JavaScript and jQuery. Imo knowing how JavaScript works makes understanding the other languages you mentioned easier. https://www.codecademy.com/en/tracks/javascript https://www.codecademy.com/en/tracks/jquery For angular.js in particular, code school had a free course on it powered or backed by Google I believe. https://www.codeschool.com/courses/shaping-up-with-angular-js I haven't found a good node.js tutorial yet but I also haven't looked very hard. 
How are the animations being performed? 
It might be helpful to setup a small subset of this code in something like JS bin. People willing to help could then explore it a bit. 
Show us what you have so far. Have you been able to get any JavaScript code running in the browser at all? Something that alerts a message to the user, perhaps? Can you get a prompt box to display, even if it doesn't do anything when you click OK? Use https://jsfiddle.net/ or http://codepen.io/pen if you need to demonstrate what your existing code is. If you need help figuring out what certain functions do, search the [Mozilla Developer Network](https://developer.mozilla.org/en-US/) or go to mdn.io/&lt;thing you want to find out about&gt;, e.g. http://mdn.io/prompt
&gt; Use the way you're comfortable with I'm comfortable with having as much as possible on the global scope, and using eval whenever possible.
It's makes your code a lot simpler, because when you use pure functions (all arguments are immutable, no global var mutation) you don't have to worry about mutations breaking some other peice of the code. It's also much easier to do equality comparisons. Say you have a request object with many fields (URL, query, body, headers, method). It's just a simple === for a reference comparison, or you can use .equals to easily compare values.
Hey if that's what you want to do, do it up buttercup. But don't expect others to maintain it.
Maybe it's because most times when someone mentions a fallacy without actually giving context, they assume the fallacy is regarding them and not something else. So I read this as him saying I was using a fallacy, which I assume everyone else who downvoted him thought also.
Start looking at ES6 and Babel.js
no! Just because you're comfortable with something, does not mean at all that it is the best choice. This attitude is wrong. Yes, there are different ways to get the same result, but only a few of them (at most) will actually be worth it. We shouldn't encourage engineers to do what they are most comfortable with, we should be encouraging (and if you're in a team, enforcing) that the best approach be taken. 
I was being sarcastic because your response was sarcastic.
Based on the fact that "medium" is higher priority than "low" which is a higher priority than "extremely low."
You have to post all of your code :). I'll help you.
You have to post all of your code :). I'll help you.
Depending on what your flex app did, you may find a minefield of compatibility between what js and what flash were capable of. If the app's capabilities are possible in JS, you are probably better off with a rewrite. Flex's "DOM" for lack of a better term, worked differently than html. Outside of recreating flex in js, I don't see an easy transition of visual structures. The code, on the other hand, should translate nicely.
Is it only js or front-end stuff(node?) in general?
Using Chrome... http://codepen.io/anon/pen/zvwXEY
OP here, maybe interesting background on this: The game this tutorial is based on was done in late 1996 for Netscape Navigator 3.0 (introduced, I believe, in September 1996 and the first browser to let you manipulate images by changing the source-attribute). The whole point of the code laid out in the tutorial was about being fast enough to do it in realtime (especially string operations were very slow and even crashed Netscape 3.0 on a PowerMac, bringing down the whole machine, when there were too many of them). Game animations were, since based on static images, severely limited by bandwidth and dial-ups then commonly in use. (There's a demo [1] for smooth animations for NS 3, achieving sub-animations by the image equivalent of 8-bit programmable character-set animations. But this would have been too heavy in load/bandwidth to be used for a full featured game.) Another limiting factor was the amount of available screen estate, then commonly 640 x 480 less the space occupied by the task bar, menu bar, the quite heavy chrome of the browser and so on. (No way to squeeze a full featured Pac-Man layout into the remaining area.) DHTML came in August 1997 (NS 4.0 and layers) and would finally let you do you whatever you wanted (or rather, some of it). Also, both JavaScript and average machines had become a little faster by then (but there were a few surprise in JS 1.2, like minus zero). Moreover, at this time the average screen size was already 800 x 600 pixels, allowing more complex layouts and game scenarios. Before Netscape 3, there had been browser games, too, either using a textarea as the display element or using plug-ins, like Director Shockwave (but this posed quite an entry barrier onto users). [1] http://www.masswerk.at/JavaPac/legacy/JS-SmoothMaze.htm [2] The 1996 implementation of the Pac-Man game: http://www.masswerk.at/JavaPac/legacy/JS-PacManSR.htm (Click cancel in the popup-prompt. Mind the small maze for 640 x 480 screens and the unusual connection of the "teleports" to add a bit of complexity to the maze layouts. There was another, even earlier implementation to this one, but I don't have the sources anymore.) [3] A more recent iteration of the same code: http://www.masswerk.at/JavaPac/JS-MsPacMan3D.html or http://www.masswerk.at/JavaPac/LostInMaze.html â€“ see also http://www.masswerk.at/JavaPac/LostInMazeCE.html (all 2008/2009) Usage history: The games (JS-PacMan and an Invaders game) were done explicitly as demos for brand-able browser games, but â€“ while listed in all those "What's cool" directories of the day â€“ marketing people didn't catch the idea of games in the browser then. I ended up providing the Invaders game for free to USA Today Marketplace (they opted for the Pac-Man game first, but settled on the Invaders game for legal concerns), since there wasn't a commercial market for this. (Some years later, all those mails like, "I need this for my homework, can I have it?", started to drop into my mailbox, this is, why there is the tutorial. That's also why there are some gaps left in the tutorial, meant to force people to do their own, rather than just copying the code.) Ironically, when the originally iPhone came out, the game was just up to date again, in terms of screen size, performance requirements, and touch-friendly input. There were means to transfer it onto the iPhone and someone sold a pirated version on CD as a dedicated iPhone game. Edit: Mind the 3D-accentuated graphics of the original game. Flat design was experienced as crude and old then â€“ these were the days of graphically rendered headlines and drop-shadow typography! :-)
Would be quicker to rewrite it. It's minified which means all of the useful information is removed for the sake of reducing size. You would have to decipher the whole thing first.
There are currently 3 places in the script where there is a +1 , I would suggest replacing that with a -1 and see how well it works.
I tried your suggestion. Whenever I activate the bookmarklet, it still goes to the next page. **EDIT**: Ooh I also tried changing the 'next' in: if(r.length&gt;1){re=/(next|older)/i; which now yields the following code: javascript:(function(){var e,i,l,re,r;e=document.getElementsByTagName('body')[0].getElementsByTagName('a');r=[];re=/^\W*(next|previous|older)(\s+(post|posts|page|article|articles|entries|entry))?\W*$/i;for(i=0,l=e.length;i&lt;l;i++){if(re.test(e[i].text)){r.push(e[i]);}}if(r.length&gt;1){re=/(previous|older)/i;for(i=0,l=r.length;i&lt;l;i++){if(re.test(r[i].text)){r=[r[i]];break;}}}if(r.length){window.location.href=r[0].href;}else if (/^\?p=[0-9]+$/.test(window.location.search)){window.location.href='?p='+(parseInt(window.location.search.replace(/[^0-9]/g,''),10)-1);}else if(/^\/p\/[0-9]+\/$/.test(window.location.pathname)){window.location.href='/p/'+(parseInt(window.location.pathname.replace(/[^0-9]/g,''),10)-1)+'/';}else if(/^\/page\/[0-9]+\/$/.test(window.location.pathname)){window.location.href='/page/'+(parseInt(window.location.pathname.replace(/[^0-9]/g,''),10)-1)+'/';}})(); And I think it's working? At the very least, it's decrementing. If any of you are interested with this bookmarklet, you could post your feedback if the edits work. :) **EDIT 2**: I just found out that when you're at ?page=1, and you activate the bookmarklet, it goes back to ?page=2, at which point it goes back to ?page=1.
&gt; so only the last .innerHTML value is viewed. Yes, each use of the `innerHTML` property overwrites the previous use when used on the same node. When you assign to that property you are defining 100% of the interior of that DOM element.
I like the looks of it. Don't quite understand it (partially due to the lack of complete examples and real docs). The only other thing I will say is this: &gt; microcomponentization Sounds like a parody word.
I believe the answer is NPM and its various options to run scripts, automate scripts, run other tools, and chain results together. So nodeJS and the built-in package manager for it. https://blog.cesarandreu.com/posts/give_npm_scripts_a_chance
I've written up this example: http://jsfiddle.net/668v5dLe/ What I want to be able to do is access both the data on the main ractive instance, but still have each component (the Outer) have access to the "Form" var all the way down to the inner component. Any ideas on how to make this happen?
I've written up this example: http://jsfiddle.net/668v5dLe/ What I want to be able to do is access both the data on the main ractive instance, but still have each component (the Outer) have access to the "Form" var all the way down to the inner component. Any ideas on how to make this happen?
You're redefining the variable rather than adding to it. Try this: var a = "5"; a += "7"; a += "3"; a += "8"; alert(a); Storing the variable as a string stops the compiler from just summing the integers. The above block will give you your expected output of "5738". Also of note: += is equivalent to a = a + "x";
It's html. I checked.
Chrome won't refresh or repaint the window with the new text until your function has returned back to the event loop. 
Don't forgot to parseInt(x, 10) to avoid insanity.
Thanks! You mean use a while loop to check the status of the reading and appending?
CrossXHR seems like it will work for my purposes. I also discovered YQL, and that will work for downloading the subtitles as a backup for those who do not have Flash installed.
Thanks. That does sound very interesting, but do you know of a book I could recommend? 
Good work! I submitted a PR that increases the performance 50-100x, context.getImageData is extremely costly and was choking your script.
Pretty much, yeah. Something like this... var buffering = true; while (buffering) { document.getElementById("someID").innerHTML = "Buffering...Buffering..."; if (loaded) { buffering = false; } } Of course, this would be run inside of another loop that controls the loading...loops are hard, man. But cool as hell, too! EDIT: Now that I see the source, I would have put this loop inside the saveTextAsFile() function. 
I have a redraw() function that can be called from anywhere, and it calls requestAnimationFrame (that in turn calls the other functions to redraw the canvas) Redraw events mostly come from canvas mouse interactions, but they can also come from input property changes.
We were looking at this last week at work for just a general challenge, but it might be good paradigm for testing potential hires. http://www.codewars.com/ - Another good place. I pick a few of these a week to keep up on and keep the tools sharp.
Maybe they want to determine the variable as they go about other calculations? Either way, this is a good time to learn about the += method. 
Sounds interesting, although I don't know anything about Vue.js. I see this removes Bootstrap's jQuery dependency (for advanced features, I assume) with Vue.js. Is this beneficial in other ways? 
Ah.. okay! I getcha.
A lot of great ideas in this release and it makes me excited for the future of React. I've been on 0.14-rc1 and my favorite feature so far is stateless function components. So much cleaner than class-based components. One downside is that hot reloading doesn't work with it yet (AFAIK). Hopefully that will come soon now that 0.14 is officially released. (And I believe Dan is/was on vacation.) Andrew Clark (core contributor to Redux and creator of Flummox) just released Recompose which provides powerful capabilities for stateless components: https://github.com/acdlite/recompose. Some of the benefits of stateless function components as outlined in Recompose's readme: * They prevent abuse of the setState() API, favoring props instead. * They're simpler, and therefore less error-prone. * They encourage the smart vs. dumb component pattern. * They encourage code that is more reusable and modular. * They discourage giant, complicated components that do too many things. * In the future, they will allow React to make performance optimizations by avoiding unnecessary checks and memory allocations. Edit: People really love their classes! If you have any reasons to prefer them in this case, please give reasons rather than downvote, so that we can all learn from your wisdom. Edit 2: By the way, stateless functions are a stepping stone towards [stateful functions](https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State).
"ES6 component classes must now extend React.Component in order to enable stateless function components. The ES3 module pattern will continue to work." Hmmmm.....
Hi. I'm planning on adding that.
http://www.rexegg.com/regex-best-trick.html var ok = str.match(/\.theWord|(theWord)/); if(!ok || !ok[1]) return false; side note, fancy regex is cool, but for performance many times it is better to use 2-3 dumb regex matches vs a single complicated-as-hell one.
Why would you get excited about not having to use jQuery?
Here's another repo thats sorta similar that I suggest to people when preparing for an interview. It gives you a bunch of tests and asks you to write the code that makes them pass. https://github.com/rmurphey/js-assessment
I've been playing with this lately https://leetcode.com/
Thanks for the concise summary!
I agree, SFCs look great. Thanks for the summary.
If you are rendering 10k of anything, you might need to use WebGL instead of Canvas/DOM. You could use Pixi which wraps both Canvas2D and WebGL together. A timeline is just some stuff along a single axis. You don't really need a library for it. eg: var t = unlerp(startYear, endYear, event.year); event.x = timelineWidth * t; Don't render elements when they are off-screen, and add some triggers when the playhead reaches a certain range. `unlerp` looks like this: https://github.com/mattdesl/unlerp/blob/master/index.js
I wonder if they will memoize functional react components by default
If I am understanding your description correctly, then I'm not sure there is an idiomatic way to achieve this. Happy to be proven wrong though. I would recommend restructuring things slightly, to make the form control components children of the `form-group` component, rather than yielded in, so they can be passed `Form` directly. Alternatively, you could store `Form` in the root component then pass it to both the `form-group` and the yielded form controls.
&gt; This release has a few major changes, ... Still no 1.0? Is it not cool anymore if it hits 1.0? Edit: I love react btw. I just don't get why they don't use semver.
Well, you can also use string concatenation without understanding how stuff like ropes work or allocate some objects without understanding how garbage collection (in detail) works. Exercises which assume that Promises and async/await exist would be perhaps more relevant, because that's the kind of stuff everyone will be doing going forward. It's not like these exercises are useless, but many people who are interested in improving their skills by doing some exercises are probably looking for exercises which use a level of abstraction which roughly matches real-world code. They want to be prepared for the future and this future does of course include things like Promises and async/await.
This is a work of genius. Best laugh I've had all week.
Hilarious. Great work!
In theory, but the reality of it is that users want a lot of code pushed into production and they want it with low time consumption. To best serve user interests, a certain amount of strategy must be employed when dealing with CI servers.
Wouldn't memoizing a functional component just mean caching the virtual dom produced for each set of props, which should be immutable, rather than the actual browser dom which is eventually rendered.
For every idea that pops into your head that you don't act on, someone else surely will. Sadly, some shit programmer will one day be caught using a variation of this. Let's just hope it's not something that our security or privacy depend on.
Haha it does. I believe Sebastian Markbage was the first one to use it, though I can't seem to find the source. But I didn't make it up, promise!
A special type of stawman because ES6 class 'syntax' only difference is in syntactic sugar.
I've seen this in live sites back when we had those "Valid CSS2/XHTML1.0" badges: if($_SERVER['REMOTE_ADDR'] == "[html.css.validator.ip]") die("&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;");
[**@andrestaltz**](https://twitter.com/andrestaltz/) &gt; [2015-10-06 17:39 UTC](https://twitter.com/andrestaltz/status/651451839431462912) &gt; Flux Challenge launched! &gt; https://github.com/staltz/flux-challenge &gt; HackerNews: https://news.ycombinator.com/newest &gt; cc @dan\_abramov &gt;[[Attached pic]](http://pbs.twimg.com/tweet_video_thumb/CQpr9zzW8AANNdD.png) [[Imgur rehost]](http://i.imgur.com/DrNqt6U.png) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Can you post the code somewhere?
That did not seem to work. Still reaching CPU loads of 30%+.
I too subscribe to /r/php. Nice to see you gave credit.
The person who calls the callback is the one who decides how it's supposed to look like, because they call it with a specific set of arguments. The problem with callbacks is that you can't see which parameters are passed to it when you look at the callee's signature. You either have to look at the code or check the docs. TypeScript and Dart address this. Their type annotations are flexible enough for also annotating the signature of a callback function.
Thank You
I can't really explain how you're thinking about callbacks. They aren't too strange once they click. Are you familiar with function pointers in languages like C? Because that's all a cb is. Think about it as an address of a function. When the process sees the callback, it jumps to that location and starts processing with whatever params you give it. Also: a callback need not be defined separately from its calling function. You can write anonymous functions exactly where you put your callback function name. 
I don't know, React 0.12 has been out for a year now, so its not THAT fast. I think it could only help to establish that 1.0.. yet I do think not committing to 1.0 does kind of foster that cool start-up culture/vibe. Idk.. just babbling. 
"it's unlikely to matter in the wild." =&gt; I'm not so sure. I did the test with a simple restify server that returns current timestamp with server.get('/time', function (req, res, next) { res.send((new Date()).getTime()); return next(); }); Here is the KPIs on ab w/500 concurrency : Concurrency Level: 500 Complete requests: 10000 Time taken for tests: 6.222 seconds Requests per second: 1607.17 [#/sec] (mean) Here are the results when I pad the function with comments over 600 bytes : Concurrency Level: 500 Complete requests: 10000 Time taken for tests: 11.905 seconds Requests per second: 839.97 [#/sec] (mean) 
I just wish they would support running React stuff under a shadow DOM. :-( 
Slim arrow functions were in the original proposal but they don't add anything new. Removing them got fat arrow functions in the spec
&gt; Also, why are the functions declared with the new class syntax not automatically bound to the object? Not complaining, just need to know the motivation. Because arrow functions are lexically bound, which is a fancy way of saying that the context is based on where it's written in your code. As an example, an arrow function `x` written in the `window` context would retain `this === window` despite being explicit about its context with `x.apply('y')`.
&gt; **Between JavaScript and an ASP script, which is faster?** &gt; &gt; JavaScript is faster. JavaScript is a client-side language and thus it does not need the assistance of the web server to execute. On the other hand, ASP is a server-side language and hence is always slower than JavaScript. Wat?
Can't agree more, I have been stuck for a long time thinking that JS was just about DOM manipulation through jQuery :p 
This is the best.
Ah, sorry, missed that - I stopped reading since I knew the gist of it anyway since I'd also seen the PHP version :P
Best ways to work with (.d.ts) definition files. How to distribute &amp; generate them, especially for the browser. Also, handling DefinitelyTyped `tsd` dependencies with multi-module projects, do you redistribute definitions for sub-projects or let the sub-project install them...
https://en.wikipedia.org/wiki/Waterfall_model#History &gt;The first formal description of the waterfall model is often cited as a 1970 article by Winston W. Royce,[3][4] although Royce did not use the term waterfall in that article. **Royce presented this model as an example of a flawed, non-working model;** which is how the term is generally used in writing about software developmentâ€”to describe a critical view of a commonly used software development practice.[5] Close enough.
Read some news dude
Hrm. So explain to me what you're doing here. It looks like you're actually trying to find .theWord where I'm specifically trying NOT to find it?
Yep, I'm using class all over the show. The original argument is that it will encourage an over-dependance on inheritance, and that inheritance itself is bad. &gt; nobody extends a class without mixing or relying on parts of the parent in it's self, so testing just Dog without Animal will break. Ouch. That is the exact, golden core of the argument. If you *can't* test the dog walk method without Animal you're very tightly coupled; exactly the problem we're trying to avoid with composition. It should be eminently possible to write a walk method without relying on an animal. The end goal isn't avoiding inheritance, the end goal is modular, de-coupled code with a strict single-responsibility per module. Composition encourages thinking about how your code interacts, how data is passed, how methods are called and generates much more reusable, clearer code. In almost every case I've seen, extending an object is a sign of an improperly thought out interface. Extending A-&gt;B will often quickly solve a problem, but sooner or later it'll be A-&gt;B-&gt;C-&gt;D and to test or use D you need to know everything about A,B and C. If these are separate concerns, you should be able to encapsulate each responsibility cleanly. If you can't why the extension? They should be one object. As a codebase ages, classical inheritance just gets worse over time, composition keeps quality high.
&gt; In intelliJ jQuery is enabeld. That doesn't mean jQuery will be included by the page, does it? Check the console in your browser's dev tools (F12 -&gt; console). It will probably say something like "$" is not a function (because jQuery wasn't loaded). Secondly, if you want to hide something initially, do this via CSS. If you don't support IE10 and below, you can just use the "hidden" attribute. Well, even if you support older IE versions you can still use it if you add a CSS fallback. A recent version of Normalize.css will do this for you. https://html.spec.whatwg.org/multipage/interaction.html#the-hidden-attribute https://necolas.github.io/normalize.css/
After losing all hope for humanity in that dreadful [class](https://www.reddit.com/r/javascript/comments/3npvo1/real_javascript_programmers_es6_classes_and_all/) thread I can't but wonder when somebody is going to create a r/java2javascript subreddit. 
Thank you very very much! This works like charm! :)
Ya know, I see people always talking about decoupling and that's why repositories and all this other stuff exist... I've built many apps and not once has having a class extend another class been an issue. When extending `Animal` with `Bear` or `Dog` it's given you should know what `Animal` is doing. Take ORM's for example, you have a `Model` you extend for `User` do you expect to be able to test `User` without `Model`? Then what's the point of `Model` if you could? If you tested `User` without `Model` then many-to-many relationships and that break, because they depend on `Model` being extended. I personally don't understand this mindset and see spending countless ours making your code harder to work with by adding bunch of extra logic, just to test a class without relying on the class you extend.
Hi /u/jucrouzet, it looks like you're new to reddit, welcome! Thanks for the submissions, but please make sure you read http://www.reddit.com/rules and our [guidelines](http://www.reddit.com/r/javascript/wiki/index). In short, you should post from a variety of sources, and not just `medium.com/@c2c`. Thanks for your consideration! domain submitted from|count|% :-|-:|-: [medium.com/@c2c](/search?q=%28and+site%3A%27medium.com%27+author%3A%27jucrouzet%27+is_self%3A0+%29&amp;restrict_sr=off&amp;sort=new&amp;feature=legacy_search)|8|80%
&gt; Matches a word boundary. A word boundary matches the position where a word character is not followed or preceeded by another word-character. Note that a matched word boundary is not included in the match. In other words, the length of a matched word boundary is zero. (Not to be confused with [\b].) &gt;Examples: &gt;/\bm/ matches the 'm' in "moon" ; &gt;/oo\b/ does not match the 'oo' in "moon", because 'oo' is followed by 'n' which is a word character; &gt;/oon\b/ matches the 'oon' in "moon", because 'oon' is the end of the string, thus not followed by a word character; &gt;/\w\b\w/ will never match anything, because a word character can never be followed by both a non-word and a word character. I don't follow. I would assume a "word character" would be alphabetic or numeric?
Skyweb? Not Skynet? :(
If you're a software developer, and you don't know what a CI server is, then you probably don't need to worry about this project.
Also, as far as pseudo-scientific bullshit go read this: http://sealedabstract.com/rants/why-mobile-web-apps-are-slow/ TLDR; * To be efficient GC demands about 6x available memory of what it actually uses * There is no evidence that inheritance conserves memory * Sloppy convenience conventions are largely to blame for slowness under the hood Instead of trolling perhaps you think a bit harder on that pseudo-scientific bullshit.
`\w` matches a word character. `\W` matches a non-word character. A word boundary is the gap between a word character and a non-word character, i.e. the gap between `\w\W` or `\W\w`, or the gap prior to the word character at the beginning of a string, or the gap after a word character that's the last character of the string. Both `+` and `=` are non-word characters, so the gap between `+=` is not a word boundary. 
&gt; So, yes, I generally try to be very clear and specific, because getting the point across is already hard enough as it is. &gt; I love the Power Glove. It's so bad. No, seriously, it fucking sucks. Seems inconsistent to me. ;)
That was referential humor. Not everyone will get it and that's totally okay. It's the cheapest form of humor. Not only is it lazy, it also excludes part of the demographic. Anyhow, my point still stands. Your "straw man argument" does match your actual opinion. You fluffed it up with a dismissive line, but it is indeed pretty much what you actually think. No idea why you pretended that this wasn't the case. There was no point in doing that.
This is a really good one, IMO.
I wish the build was failing...
&gt; It is... in C++ It absolutely isn't. You do not have any idea what you're talking about. Other people called you out on this utter nonsense and, obviously, you ignored them because you are painfully out of your depth but too small to admit it. Either you're wrong because you think that OOP originated in C++, or you're wrong because you said ["OOP was originally about conserving memory"](https://www.reddit.com/r/javascript/comments/3npvo1/real_javascript_programmers_es6_classes_and_all/cvqhwbs). Either way, you're wrong. &gt; Reading is hard. Apparently *thinking* is hard for you. The *logical* thing to do here would be to admit your mistake, but your *emotions* are getting the better of you, so you're doomed to make further mistakes.
Not my point. My point is, he's not explaining himself. He's not defining the purpose of his software. Does CI stand for CodeIgniter? If not, what is it? There are so many github accounts just like this. It's been a problem with software on the internet for decades and I've seen other talks about it, too. A page showing some new software and no one knows what it's for.
What a reddit comment. Obviously you're as undefined as that github. I wouldn't consider CodeIgniter an update of my skillset.
Whoa man, stop the fat shaming
Here is your code with my opinionated style fixes. (I would have refactored a bit more but you'll have to settle for some style and best practice fixes from me.) (function () { //function to move circles function moveCircleRandomly(circle) { var x = Math.floor(Math.random() * 100) + '%', y = Math.floor(Math.random() * 100) + '%'; circle.style.left = x; circle.style.top = y; } //initialize time var time = (Math.random() * 1000000) % 2000; var score = 0; //function to check when to move function myLoop(circleId, lastTime, switchTime) { setTimeout(function () { var circle = document.getElementById(circleId); if (score === 0) { if (lastTime &gt;= switchTime) { moveCircleRandomly(circle); lastTime = 0 switchTime = Math.floor((Math.random() * 1000000) % 1000); } else{ lastTime = lastTime + 10; } console.log([switchTime, circleId].join(' ')); //for debugging console.log([lastTime, circleId].join(' ')); //for debugging myLoop(circleId, lastTime, switchTime); //loop } }, 10); } myLoop("circle", 0, time); myLoop("circle1", 0, time); })();
&gt; I ~~probably~~ am wrong Thanks, that's all you needed to say.
? Browsers put lots of things behind prefixes Also how much easier could a polyfill possibly be
Thank you. I thought about the variable names after I posted. What is the advantage to putting everything in a unnamed function and running it with ()?
If you ask someone what's wrong with Javascript, and they can't immediately think of about 20 things, they're probably not an expert.
That is called an Immediately-Invoked Function Expression (IIFE). It is a good practice for encapsulating scope, i.e. preventing pollution of the global scope. It's always a good idea to name your functions though, even if the name is something like `__iife`.
Thanks Everyone for the responses, very useful for our discussion.
Notice that the names of variables are in camel case which is the standard for JS. I've known very smart people to also use snake case in JavaScript due to it's increased readability. In either case just try to be completely consistent about which one you choose. What /u/maurice_jello says is true. You should name all functions as it makes debugging significantly more complex programs easier. In the debugging console you'd see the name of the function rather than the generic "anonymous function" tag. Luckily, chrome's debugger also points you to the line number of the function that's causing the problem, but if your code is minified already then this is of little help unless you've named the function. myLoop is a terrible name for a function. I'm not sure what exactly a good name for that specific function would be, but that's pretty much the hardest part of programming anyway. /u/bdflynn makes the point that you could avoid declaring variables for the various things, but those variable names provide meaning to your code. The more meaning there is the less you need to think while reading the code. That means you'll be able to debug faster after coming back to the code in 6months (or 4 years like the code I just debugged today.)
&gt; If you start your comment off with "You think...", you're probably wrong or at least **out of proportion**. To be as literal and as to-the-point as humanly possible, as you seem to require... The historic desires of Java programmers and those wishing to coddle them has had an inappropriate influence on Javascript throughout its history. I believe this to be the SOURCE of the issue, the originating factors that caused the formation of my opinion. However, it is not the REASON I oppose classes in Javascript. I oppose classes PRIMARILY because they encourage classical inheritance, the frequently cited feature for which classes in Javascript are 'needed.' I do not, in fact, care whether a particular idea is from or not from Java. I only care about the merits of the idea, and what the consequences (both intended and unintended) will be of such an idea being implemented or widely used. (And by Java programmers, I don't literally mean Java exclusively, but the large list of languages who either require or heavily push classes and classical inheritance.) The definition of a Strawman Argument does not necessitate that I advance a false premise, though it often does, it only necessitates that I advance a MISREPRESENTATIVE argument. It can be rooted in fact, but blown out of proportion, which is exactly what I have done here. Do you understand?
Yeah I found core estimator to be something I didn't want to bother with as it isn't 100% reliable and I think it's best to put the problem onto the browser manufacturer to improve the situation instead of us having to hack around their shortcomings. 
They also have IE. Maybe average the two together?